ssions )
    {
        SendMessage( hWndListBox, LB_ADDSTRING, 0,
                     (LPARAM) TEXT("Looking for games...") );
    }
    else
    {
        SendMessage( hWndListBox, LB_ADDSTRING, 0,
                     (LPARAM) TEXT("Click Start Search to see a list of games.  ")
                              TEXT("Click Create to start a new game.") );
    }

    SendMessage( hWndListBox, LB_SETITEMDATA,  0, NULL );
    SendMessage( hWndListBox, LB_SETCURSEL,    0, 0 );

    // Disable the join button until sessions are found
    EnableWindow( GetDlgItem( hDlg, IDC_JOIN ), FALSE );
}




//-----------------------------------------------------------------------------
// Name: SessionsDlgEnumHosts()
// Desc: Enumerates the DirectPlay sessions, and displays them in the listbox
//-----------------------------------------------------------------------------
HRESULT CNetConnectWizard::SessionsDlgEnumHosts( HWND hDlg )
{
    HRESULT hr;

    m_bEnumListChanged = TRUE;

    // Enumerate hosts
    DPN_APPLICATION_DESC    dnAppDesc;
    ZeroMemory( &dnAppDesc, sizeof(DPN_APPLICATION_DESC) );
    dnAppDesc.dwSize          = sizeof(DPN_APPLICATION_DESC);
    dnAppDesc.guidApplication = m_guidApp;

    // Enumerate all the active DirectPlay games on the selected connection
    hr = m_pDP->EnumHosts( &dnAppDesc,                            // application description
                           m_pHostAddress,                        // host address
                           m_pDeviceAddress,                      // device address
                           NULL,                                  // pointer to user data
                           0,                                     // user data size
                           INFINITE,                              // retry count (forever)
                           0,                                     // retry interval (0=default)
                           INFINITE,                              // time out (forever)
                           NULL,                                  // user context
                           &m_hEnumAsyncOp,                       // async handle
                           0    // flags
                           );
    if( FAILED(hr) )
        return hr;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: SessionsDlgNoteEnumResponse()
// Desc: Stores them in the linked list, m_DPHostEnumHead.  This is
//       called from the DirectPlay message handler so it could be
//       called simultaneously from multiple threads.
//-----------------------------------------------------------------------------
HRESULT CNetConnectWizard::SessionsDlgNoteEnumResponse( PDPNMSG_ENUM_HOSTS_RESPONSE pEnumHostsResponseMsg )
{
    HRESULT hr = S_OK;
    BOOL    bFound;

    // This function is called from the DirectPlay message handler so it could be
    // called simultaneously from multiple threads, so enter a critical section
    // to assure that it we don't get race conditions.  Locking the entire
    // function is crude, and could be more optimal but is effective for this
    // simple sample
    EnterCriticalSection( &m_csHostEnum );

    DPHostEnumInfo* pDPHostEnum          = m_DPHostEnumHead.pNext;
    DPHostEnumInfo* pDPHostEnumNext      = NULL;
    const DPN_APPLICATION_DESC* pResponseMsgAppDesc =
                            pEnumHostsResponseMsg->pApplicationDescription;

    // Look for a matching session instance GUID.
    bFound = FALSE;
    while ( pDPHostEnum != &m_DPHostEnumHead )
    {
        if( pResponseMsgAppDesc->guidInstance == pDPHostEnum->pAppDesc->guidInstance )
        {
            bFound = TRUE;
            break;
        }

        pDPHostEnumNext = pDPHostEnum;
        pDPHostEnum = pDPHostEnum->pNext;
    }

    if( !bFound )
    {
        m_bEnumListChanged = TRUE;

        // If there's no match, then look for invalid session and use it
        pDPHostEnum = m_DPHostEnumHead.pNext;
        while ( pDPHostEnum != &m_DPHostEnumHead )
        {
            if( !pDPHostEnum->bValid )
                break;

            pDPHostEnum = pDPHostEnum->pNext;
        }

        // If no invalid sessions are found then make a new one
        if( pDPHostEnum == &m_DPHostEnumHead )
        {
            // Found a new session, so create a new node
            pDPHostEnum = new DPHostEnumInfo;
            if( NULL == pDPHostEnum )
            {
                hr = E_OUTOFMEMORY;
                goto LCleanup;
            }

            ZeroMemory( pDPHostEnum, sizeof(DPHostEnumInfo) );

            // Add pDPHostEnum to the circular linked list, m_DPHostEnumHead
            pDPHostEnum->pNext = m_DPHostEnumHead.pNext;
            m_DPHostEnumHead.pNext = pDPHostEnum;
        }
    }

    // Update the pDPHostEnum with new information
    TCHAR strName[MAX_PATH];
    if( pResponseMsgAppDesc->pwszSessionName )
    {
        DXUtil_ConvertWideStringToGeneric( strName, pResponseMsgAppDesc->pwszSessionName );
    }

    // Cleanup any old enum
    if( pDPHostEnum->pAppDesc )
    {
        SAFE_DELETE_ARRAY( pDPHostEnum->pAppDesc->pwszSessionName );
        SAFE_DELETE_ARRAY( pDPHostEnum->pAppDesc );
    }
    SAFE_RELEASE( pDPHostEnum->pHostAddr );
    SAFE_RELEASE( pDPHostEnum->pDeviceAddr );

    //
    // Duplicate pEnumHostsResponseMsg->pAddressSender in pDPHostEnum->pHostAddr.
    // Duplicate pEnumHostsResponseMsg->pAddressDevice in pDPHostEnum->pDeviceAddr.
    //
    if( FAILED( hr = pEnumHostsResponseMsg->pAddressSender->Duplicate( &pDPHostEnum->pHostAddr ) ) )
    {
        goto LCleanup;
    }

    if( FAILED( hr = pEnumHostsResponseMsg->pAddressDevice->Duplicate( &pDPHostEnum->pDeviceAddr ) ) )
    {
        goto LCleanup;
    }

    // Deep copy the DPN_APPLICATION_DESC from
    pDPHostEnum->pAppDesc = new DPN_APPLICATION_DESC;
    ZeroMemory( pDPHostEnum->pAppDesc, sizeof(DPN_APPLICATION_DESC) );
    memcpy( pDPHostEnum->pAppDesc, pResponseMsgAppDesc, sizeof(DPN_APPLICATION_DESC) );
    if( pResponseMsgAppDesc->pwszSessionName )
    {
        pDPHostEnum->pAppDesc->pwszSessionName = new WCHAR[ wcslen(pResponseMsgAppDesc->pwszSessionName)+1 ];
        wcscpy( pDPHostEnum->pAppDesc->pwszSessionName,
                pResponseMsgAppDesc->pwszSessionName );
    }

    // Update the time this was done, so that we can expire this host
    // if it doesn't refresh w/in a certain amount of time
    pDPHostEnum->dwLastPollTime = timeGetTime();

    // Check to see if the current number of players changed
    TCHAR szSessionTemp[MAX_PATH];
    if( pResponseMsgAppDesc->dwMaxPlayers > 0 )
    {
        wsprintf( szSessionTemp, TEXT("%s (%d/%d) (%dms)"), strName,
                  pResponseMsgAppDesc->dwCurrentPlayers,
                  pResponseMsgAppDesc->dwMaxPlayers,
                  pEnumHostsResponseMsg->dwRoundTripLatencyMS );
    }
    else
    {
        wsprintf( szSessionTemp, TEXT("%s (%d) (%dms)"), strName,
                  pResponseMsgAppDesc->dwCurrentPlayers,
                  pEnumHostsResponseMsg->dwRoundTripLatencyMS );
    }

    // if this node was previously invalidated, or the session name is now
    // different the session list in the dialog needs to be updated
    if( ( pDPHostEnum->bValid == FALSE ) ||
        ( _tcscmp( pDPHostEnum->szSession, szSessionTemp ) != 0 ) )
    {
        m_bEnumListChanged = TRUE;
    }
    _tcscpy( pDPHostEnum->szSession, szSessionTemp );

    // This host is now valid
    pDPHostEnum->bValid = TRUE;

LCleanup:
    LeaveCriticalSection( &m_csHostEnum );

    return hr;
}




//-----------------------------------------------------------------------------
// Name: SessionsDlgExpireOldHostEnums
// Desc: Check all nodes to see if any have expired yet.
//-----------------------------------------------------------------------------
VOID CNetConnectWizard::SessionsDlgExpireOldHostEnums()
{
    DWORD dwCurrentTime = timeGetTime();

    // This is called from the dialog UI thread, SessionsDlgNoteEnumResponse
    // is called from the DirectPlay message handler threads so
    // they may also be inside it at this time, so we need to go into the
    // critical section first
    EnterCriticalSection( &m_csHostEnum );

    DPHostEnumInfo* pDPHostEnum = m_DPHostEnumHead.pNext;
    while ( pDPHostEnum != &m_DPHostEnumHead )
    {
        // Check the poll time to expire stale entries.  Also check to see if
        // the entry is already invalid.  If so, don't note that the enum list
        // changed because that causes the list in the dialog to constantly redraw.
        if( ( pDPHostEnum->bValid != FALSE ) &&
            ( pDPHostEnum->dwLastPollTime < dwCurrentTime - m_dwEnumHostExpireInterval ) )
        {
            // This node has expired, so invalidate it.
            pDPHostEnum->bValid = FALSE;
            m_bEnumListChanged  = TRUE;
        }

        pDPHostEnum = pDPHostEnum->pNext;
    }

    LeaveCriticalSection( &m_csHostEnum );
}




//-----------------------------------------------------------------------------
// Name: SessionsDlgDisplayEnumList
// Desc: Display the list of hosts in the dialog box
//-----------------------------------------------------------------------------
HRESULT CNetConnectWizard::SessionsDlgDisplayEnumList( HWND hDlg )
{
    HWND           hWndListBox   = GetDlgItem( hDlg, IDC_GAMES_LIST );
    DPHostEnumInfo* pDPHostEnumSelected = NULL;
    GUID           guidSelectedInstance;
    BOOL           bFindSelectedGUID;
    BOOL           bFoundSelectedGUID;
    int            nItemSelected;

    // This is called from the dialog UI thread, SessionsDlgNoteEnumResponse
    // is called from the DirectPlay message handler threads so
    // they may also be inside it at this time, so we need to go into the
    // critical section first
    EnterCriticalSection( &m_csHostEnum );

    // Only update the display list if it has changed since last time
    if( !m_bEnumListChanged )
    {
        LeaveCriticalSection( &m_csHostEnum );
        return S_OK;
    }

    m_bEnumListChanged = FALSE;

    bFindSelectedGUID  = FALSE;
    bFoundSelectedGUID = FALSE;

    // Try to keep the same session selected unless it goes away or
    // there is no real session currently selected
    nItemSelected = (int)SendMessage( hWndListBox, LB_GETCURSEL, 0, 0 );
    if( nItemSelected != LB_ERR )
    {
        pDPHostEnumSelected = (DPHostEnumInfo*) SendMessage( hWndListBox, LB_GETITEMDATA,
                                                             nItemSelected, 0 );
        if( pDPHostEnumSelected != NULL && pDPHostEnumSelected->bValid )
        {
            guidSelectedInstance = pDPHostEnumSelected->pAppDesc->guidInstance;
            bFindSelectedGUID = TRUE;
        }
    }

    // Tell listbox not to redraw itself since the contents are going to change
    SendMessage( hWndListBox, WM_SETREDRAW, FALSE, 0 );

    // Test to see if any sessions exist in the linked list
    DPHostEnumInfo* pDPHostEnum = m_DPHostEnumHead.pNext;
    while ( pDPHostEnum != &m_DPHostEnumHead )
    {
        if( pDPHostEnum->bValid )
            break;
        pDPHostEnum = pDPHostEnum->pNext;
    }

    // If there are any sessions in list,
    // then add them to the listbox
    if( pDPHostEnum != &m_DPHostEnumHead )
    {
        // Clear the contents from the list box and enable the join button
        SendMessage( hWndListBox, LB_RESETCONTENT, 0, 0 );
        EnableWindow( GetDlgItem( hDlg, IDC_JOIN ), TRUE );

        pDPHostEnum = m_DPHostEnumHead.pNext;
        while ( pDPHostEnum != &m_DPHostEnumHead )
        {
            // Add host to list box if it is valid
            if( pDPHostEnum->bValid )
            {
                int nIndex = (int)SendMessage( hWndListBox, LB_ADDSTRING, 0,
                                               (LPARAM)pDPHostEnum->szSession );
                SendMessage( hWndListBox, LB_SETITEMDATA, nIndex, (LPARAM)pDPHostEnum );

                if( bFindSelectedGUID )
                {
                    // Look for the session the was selected before
                    if( pDPHostEnum->pAppDesc->guidInstance == guidSelectedInstance )
                    {
                        SendMessage( hWndListBox, LB_SETCURSEL, nIndex, 0 );
                        bFoundSelectedGUID = TRUE;
                    }
                }
            }

            pDPHostEnum = pDPHostEnum->pNext;
        }

        if( !bFindSelectedGUID || !bFoundSelectedGUID )
            SendMessage( hWndListBox, LB_SETCURSEL, 0, 0 );
    }
    else
    {
        // There are no active session, so just reset the listbox
        SessionsDlgInitListbox( hDlg );
    }

    // Tell listbox to redraw itself now since the contents have changed
    SendMessage( hWndListBox, WM_SETREDRAW, TRUE, 0 );
    InvalidateRect( hWndListBox, NULL, FALSE );

    LeaveCriticalSection( &m_csHostEnum );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: SessionsDlgJoinGame()
// Desc: Joins the selected DirectPlay session
//-----------------------------------------------------------------------------
HRESULT CNetConnectWizard::SessionsDlgJoinGame( HWND hDlg )
{
    HRESULT         hr;
    HWND            hWndListBox = GetDlgItem( hDlg, IDC_GAMES_LIST );
    DPHostEnumInfo* pDPHostEnumSelected = NULL;
    int             nItemSelected;
    DWORD           dwPort = 0;

    if( m_bConnecting )
    {
        m_bConnecting = FALSE;
        KillTimer( hDlg, TIMERID_CONNECT_COMPLETE );
        if( m_hConnectAsyncOp )
            m_pDP->CancelAsyncOperation( m_hConnectAsyncOp, 0 );
    }

    m_bHostPlayer = FALSE;

    // Add status text in list box
    nItemSelected = (int)SendMessage( hWndListBox, LB_GETCURSEL, 0, 0 );

    EnterCriticalSection( &m_csHostEnum );

    pDPHostEnumSelected = (DPHostEnumInfo*) SendMessage( hWndListBox, LB_GETITEMDATA,
                                                         nItemSelected, 0 );

    if( NULL == pDPHostEnumSelected )
    {
        LeaveCriticalSection( &m_csHostEnum );
        MessageBox( hDlg, TEXT("There are no games to join."),
                    TEXT("DirectPlay Sample"), MB_OK );
        return S_OK;
    }

    m_bConnecting = TRUE;

    // Set the peer info
    WCHAR wszPeerName[MAX_PATH];
    DXUtil_ConvertGenericStringToWide( wszPeerName, m_strLocalPlayerName );

    DPN_PLAYER_INFO dpPlayerInfo;
    ZeroMemory( &dpPlayerInfo, sizeof(DPN_PLAYER_INFO) );
    dpPlayerInfo.dwSize = sizeof(DPN_PLAYER_INFO);
    dpPlayerInfo.dwInfoFlags = DPNINFO_NAME;
    dpPlayerInfo.pwszName = wszPeerName;

    // Set the peer info, and use the DPNOP_SYNC since by default this
    // is an async call.  If it is not DPNOP_SYNC, then the peer info may not
    // be set by the time we call Connect() below.
    if( FAILED( hr = m_pDP->SetPeerInfo( &dpPlayerInfo, NULL, NULL, DPNOP_SYNC ) ) )
        return hr;

    ResetEvent( m_hConnectCompleteEvent );

    // Connect to an existing session. DPNCONNECT_OKTOQUERYFORADDRESSING allows
    // DirectPlay to prompt the user using a dialog box for any device address
    // or host address information that is missing
    // We also pass in copies of the app desc and host addr, since pDPHostEnumSelected
    // might be deleted from another thread that calls SessionsDlgExpireOldHostEnums().
    // This process could also be done using reference counting instead.
    hr = m_pDP->Connect( pDPHostEnumSelected->pAppDesc,       // the application desc
                         pDPHostEnumSelected->pHostAddr,      // address of the host of the session
                         pDPHostEnumSelected->pDeviceAddr,    // address of the local device the enum responses were received on
                         NULL, NULL,                          // DPN_SECURITY_DESC, DPN_SECURITY_CREDENTIALS
                         NULL, 0,                             // user data, user data size
                         NULL,                                // player context,
                         NULL, &m_hConnectAsyncOp,            // async context, async handle,
                         0 ); // flags
    if( hr != E_PENDING && FAILED(hr) )
        return hr;

    LeaveCriticalSection( &m_csHostEnum );

    // Set a timer to wait for m_hConnectCompleteEvent to be signaled.
    // This will tell us when DPN_MSGID_CONNECT_COMPLETE has been processed
    // which lets us know if the connect was successful or not.
    SetTimer( hDlg, TIMERID_CONNECT_COMPLETE, 100, NULL );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: SessionsDlgCreateGame()
// Desc: Asks the user the session name, and creates a new DirectPlay session
//-----------------------------------------------------------------------------
HRESULT CNetConnectWizard::SessionsDlgCreateGame( HWND hDlg )
{
    HRESULT hr;
    int     nResult;

    if( m_bConnecting )
    {
        m_bConnecting = FALSE;
        KillTimer( hDlg, TIMERID_CONNECT_COMPLETE );
        if( m_hConnectAsyncOp )
            m_pDP->CancelAsyncOperation( m_hConnectAsyncOp, 0 );
    }

    // Display a modal multiplayer connect dialog box.
    EnableWindow( hDlg, FALSE );
    nResult = (int)DialogBox( m_hInst, MAKEINTRESOURCE(IDD_MULTIPLAYER_CREATE),
                              hDlg, (DLGPROC) StaticCreateSessionDlgProc );
    EnableWindow( hDlg, TRUE );

    if( nResult == IDCANCEL )
        return S_OK;

    // Stop the search if we are about to connect
    if( m_bSearchingForSessions )
    {
        CheckDlgButton( m_hDlg, IDC_SEARCH_CHECK, BST_UNCHECKED );
        SendMessage( m_hDlg, WM_COMMAND, IDC_SEARCH_CHECK, 0 );
    }

    m_bHostPlayer = TRUE;

    // Set peer info name
    WCHAR wszPeerName[MAX_PATH];
    DXUtil_ConvertGenericStringToWide( wszPeerName, m_strLocalPlayerName );

    DPN_PLAYER_INFO dpPlayerInfo;
    ZeroMemory( &dpPlayerInfo, sizeof(DPN_PLAYER_INFO) );
    dpPlayerInfo.dwSize = sizeof(DPN_PLAYER_INFO);
    dpPlayerInfo.dwInfoFlags = DPNINFO_NAME;
    dpPlayerInfo.pwszName = wszPeerName;

    // Set the peer info, and use the DPNOP_SYNC since by default this
    // is an async call.  If it is not DPNOP_SYNC, then the peer info may not
    // be set by the time we call Host() below.
    if( FAILED( hr = m_pDP->SetPeerInfo( &dpPlayerInfo, NULL, NULL, DPNOP_SYNC ) ) )
        return hr;

    WCHAR wszSessionName[MAX_PATH];
    DXUtil_ConvertGenericStringToWide( wszSessionName, m_strSessionName );

    // Setup the application desc
    DPN_APPLICATION_DESC dnAppDesc;
    ZeroMemory( &dnAppDesc, sizeof(DPN_APPLICATION_DESC) );
    dnAppDesc.dwSize          = sizeof(DPN_APPLICATION_DESC);
    dnAppDesc.guidApplication = m_guidApp;
    dnAppDesc.pwszSessionName = wszSessionName;
    dnAppDesc.dwMaxPlayers    = m_dwMaxPlayers;
    dnAppDesc.dwFlags         = 0;
    if( m_bMigrateHost )
        dnAppDesc.dwFlags |= DPNSESSION_MIGRATE_HOST;

    // Host a game on m_pDeviceAddress as described by dnAppDesc
    // DPNHOST_OKTOQUERYFORADDRESSING allows DirectPlay to prompt the user
    // using a dialog box for any device address information that is missing
    if( FAILED( hr = m_pDP->Host( &dnAppDesc,               // the application desc
                                  &m_pDeviceAddress,        // array of addresses of the local devices used to connect to the host
                                  1,                        // number in array
                                  NULL, NULL,               // DPN_SECURITY_DESC, DPN_SECURITY_CREDENTIALS
                                  NULL,                     // player context
                                  0 ) ) ) // flags
        return hr;

    // DirectPlay connect successful, so end dialog
    m_hrDialog = NCW_S_FORWARD;
    EndDialog( hDlg, 0 );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: StaticConnectionsDlgProc()
// Desc: Static msg handler which passes messages
//-----------------------------------------------------------------------------
INT_PTR CALLBACK CNetConnectWizard::StaticCreateSessionDlgProc( HWND hDlg, UINT uMsg,
                                                                WPARAM wParam, LPARAM lParam )
{
    if( g_pNCW )
        return g_pNCW->CreateSessionDlgProc( hDlg, uMsg, wParam, lParam );

    return FALSE; // Message not handled
}




//-----------------------------------------------------------------------------
// Name: CreateSessionDlgProc()
// Desc: Handles messages fro the multiplayer create game dialog
//-----------------------------------------------------------------------------
INT_PTR CALLBACK CNetConnectWizard::CreateSessionDlgProc( HWND hDlg, UINT msg,
                                                          WPARAM wParam, LPARAM lParam )
{
    DWORD dwNameLength;

    switch( msg )
    {
        case WM_INITDIALOG:
            SetDlgItemText( hDlg, IDC_EDIT_SESSION_NAME, m_strSessionName );
            CheckDlgButton( hDlg, IDC_MIGRATE_HOST, BST_CHECKED );
            return TRUE;

        case WM_COMMAND:
            switch( LOWORD(wParam) )
            {
                case IDOK:
                    dwNameLength = GetDlgItemText( hDlg, IDC_EDIT_SESSION_NAME,
                                                   m_strSessionName,
                                                   MAX_PATH );
                    if( dwNameLength == 0 )
                        return TRUE; // Don't accept blank session names

                    m_bMigrateHost = ( IsDlgButtonChecked( hDlg,
                                       IDC_MIGRATE_HOST ) == BST_CHECKED );

                    EndDialog( hDlg, IDOK );
                    return TRUE;

                case IDCANCEL:
                    EndDialog( hDlg, IDCANCEL );
                    return TRUE;
            }
            break;
    }

    return FALSE; // Didn't handle message
}




//-----------------------------------------------------------------------------
// Name: SessionsDlgEnumListCleanup()
// Desc: Deletes the linked list, g_DPHostEnumInfoHead
//-----------------------------------------------------------------------------
VOID CNetConnectWizard::SessionsDlgEnumListCleanup()
{
    DPHostEnumInfo* pDPHostEnum = m_DPHostEnumHead.pNext;
    DPHostEnumInfo* pDPHostEnumDelete;

    while ( pDPHostEnum != &m_DPHostEnumHead )
    {
        pDPHostEnumDelete = pDPHostEnum;
        pDPHostEnum = pDPHostEnum->pNext;

        if( pDPHostEnumDelete->pAppDesc )
        {
            SAFE_DELETE_ARRAY( pDPHostEnumDelete->pAppDesc->pwszSessionName );
            SAFE_DELETE_ARRAY( pDPHostEnumDelete->pAppDesc );
        }

        // Changed from array delete to Release
        SAFE_RELEASE( pDPHostEnumDelete->pHostAddr );
        SAFE_RELEASE( pDPHostEnumDelete->pDeviceAddr );
        SAFE_DELETE( pDPHostEnumDelete );
    }

    // Re-link the g_DPHostEnumInfoHead circular linked list
    m_DPHostEnumHead.pNext = &m_DPHostEnumHead;
}




//-----------------------------------------------------------------------------
// Name: MessageHandler
// Desc: Handler for DirectPlay messages.  This function is called by
//       the DirectPlay message handler pool of threads, so be careful of thread
//       synchronization problems with shared memory
//-----------------------------------------------------------------------------
HRESULT WINAPI CNetConnectWizard::MessageHandler( PVOID pvUserContext,
                                                  DWORD dwMessageId,
                                                  PVOID pMsgBuffer )
{
    // Try not to stay in this message handler for too long, otherwise
    // there will be a backlog of data.  The best solution is to
    // queue data as it comes in, and then handle it on other threads.

    // This function is called by the DirectPlay message handler pool of
    // threads, so be careful of thread synchronization problems with shared memory

    switch(dwMessageId)
    {
        case DPN_MSGID_ENUM_HOSTS_RESPONSE:
        {
            PDPNMSG_ENUM_HOSTS_RESPONSE pEnumHostsResponseMsg;
            pEnumHostsResponseMsg = (PDPNMSG_ENUM_HOSTS_RESPONSE)pMsgBuffer;

            // Take note of the host response
            SessionsDlgNoteEnumResponse( pEnumHostsResponseMsg );
            break;
        }

        case DPN_MSGID_ASYNC_OP_COMPLETE:
        {
            PDPNMSG_ASYNC_OP_COMPLETE pAsyncOpCompleteMsg;
            pAsyncOpCompleteMsg = (PDPNMSG_ASYNC_OP_COMPLETE)pMsgBuffer;

            if( pAsyncOpCompleteMsg->hAsyncOp == m_hEnumAsyncOp )
            {
                SessionsDlgEnumListCleanup();

                // The user canceled the DirectPlay connection dialog,
                // so stop the search
                if( m_bSearchingForSessions )
                {
                    CheckDlgButton( m_hDlg, IDC_SEARCH_CHECK, BST_UNCHECKED );
                    SendMessage( m_hDlg, WM_COMMAND, IDC_SEARCH_CHECK, 0 );
                }

                m_hEnumAsyncOp = NULL;
                m_bSearchingForSessions = FALSE;
            }
            break;
        }

        case DPN_MSGID_CONNECT_COMPLETE:
        {
            PDPNMSG_CONNECT_COMPLETE pConnectCompleteMsg;
            pConnectCompleteMsg = (PDPNMSG_CONNECT_COMPLETE)pMsgBuffer;

            // Set m_hrConnectComplete, then set an event letting
            // everyone know that the DPN_MSGID_CONNECT_COMPLETE msg
            // has been handled
            m_hrConnectComplete = pConnectCompleteMsg->hResultCode;
            SetEvent( m_hConnectCompleteEvent );
            break;
        }
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\test\simplepeer\netconnect.h ===
//-----------------------------------------------------------------------------
// File: NetConnect.h
//
// Desc:
//
//@@BEGIN_MSINTERNAL
//
// Hist: See source file for detailed history
//
//@@END_MSINTERNAL
// Copyright (C) 2000 Microsoft Corporation. All Rights Reserved.
//-----------------------------------------------------------------------------
#ifndef NETCONNECT_H
#define NETCONNECT_H


#include <windows.h>
#include <dplay8.h>
#include <dpaddr.h>
#include <tchar.h>


//-----------------------------------------------------------------------------
// Defines, structures, and error codes
//-----------------------------------------------------------------------------
#define DISPLAY_REFRESH_RATE        250
#define TIMERID_DISPLAY_HOSTS       1
#define TIMERID_CONNECT_COMPLETE    2

#define NCW_S_FORWARD      0x01000001  // Dialog success, so go forward
#define NCW_S_BACKUP       0x01000002  // Dialog canceled, show previous dialog
#define NCW_S_QUIT         0x01000003  // Dialog quit, close app


class CNetConnectWizard
{
public:
	CNetConnectWizard( HINSTANCE hInst, TCHAR* strAppName, GUID* pGuidApp );
	virtual ~CNetConnectWizard();

    HRESULT WINAPI MessageHandler( PVOID pvUserContext, DWORD dwMessageId, PVOID pMsgBuffer );

    VOID    Init( IDirectPlay8Peer* pDP );
    HRESULT DoConnectWizard( BOOL bBackTrack );

    void   SetMaxPlayers( DWORD dwMaxPlayers )                 { m_dwMaxPlayers = dwMaxPlayers; }
    void   SetPlayerName( TCHAR* strPlayerName )               { _tcscpy( m_strLocalPlayerName, strPlayerName ); }
    void   SetSessionName( TCHAR* strSessionName )             { _tcscpy( m_strSessionName, strSessionName ); }
    void   SetPreferredProvider( TCHAR* strPreferredProvider ) { _tcscpy( m_strPreferredProvider, strPreferredProvider ); }

    TCHAR* GetPlayerName()                                     { return m_strLocalPlayerName; }
    TCHAR* GetSessionName()                                    { return m_strSessionName; }
    TCHAR* GetPreferredProvider()                              { return m_strPreferredProvider; }
    BOOL   IsHostPlayer()                                      { return m_bHostPlayer; }
    BOOL   IsMigrateHost()                                     { return m_bMigrateHost; }

protected:
    struct DPHostEnumInfo
    {
        DWORD                 dwRef;
        DPN_APPLICATION_DESC* pAppDesc;
        IDirectPlay8Address* pHostAddr;
        IDirectPlay8Address* pDeviceAddr;
		TCHAR                szSession[MAX_PATH];
        DWORD                dwLastPollTime;
        BOOL                 bValid;
        DPHostEnumInfo*      pNext;
    };

    static INT_PTR CALLBACK StaticConnectionsDlgProc( HWND, UINT, WPARAM, LPARAM );
    static INT_PTR CALLBACK StaticSessionsDlgProc( HWND, UINT, WPARAM, LPARAM );
    static INT_PTR CALLBACK StaticCreateSessionDlgProc( HWND, UINT, WPARAM, LPARAM );
    INT_PTR CALLBACK ConnectionsDlgProc( HWND, UINT, WPARAM, LPARAM );
    INT_PTR CALLBACK SessionsDlgProc( HWND, UINT, WPARAM, LPARAM );
    INT_PTR CALLBACK CreateSessionDlgProc( HWND, UINT, WPARAM, LPARAM );

    HRESULT ConnectionsDlgFillListBox( HWND hDlg );
    HRESULT ConnectionsDlgOnOK( HWND hDlg );
    VOID    ConnectionsDlgCleanup( HWND hDlg );

    VOID    SessionsDlgInitListbox( HWND hDlg );
    HRESULT SessionsDlgEnumHosts( HWND hDlg );
    HRESULT SessionsDlgNoteEnumResponse( PDPNMSG_ENUM_HOSTS_RESPONSE pEnumHostsResponse );
    VOID    SessionsDlgExpireOldHostEnums();
    HRESULT SessionsDlgDisplayEnumList( HWND hDlg );
    HRESULT SessionsDlgJoinGame( HWND hDlg );
    HRESULT SessionsDlgCreateGame( HWND hDlg );
    VOID    SessionsDlgEnumListCleanup();

    IDirectPlay8Peer*       m_pDP;
    CRITICAL_SECTION        m_csHostEnum;
    GUID                    m_guidApp;
    HRESULT                 m_hrDialog;
    HWND                    m_hDlg;
    HINSTANCE               m_hInst;
    DWORD                   m_dwMaxPlayers;
    TCHAR                   m_strAppName[MAX_PATH];
    TCHAR                   m_strPreferredProvider[MAX_PATH];
    TCHAR                   m_strSessionName[MAX_PATH];
    TCHAR                   m_strLocalPlayerName[MAX_PATH];
    BOOL                    m_bSearchingForSessions;
    BOOL                    m_bMigrateHost;
    IDirectPlay8Address*    m_pDeviceAddress;
    IDirectPlay8Address*    m_pHostAddress;
    DPHostEnumInfo          m_DPHostEnumHead;
    BOOL                    m_bEnumListChanged;
    DPNHANDLE               m_hEnumAsyncOp;
    BOOL                    m_bHostPlayer;
    DWORD                   m_dwEnumHostExpireInterval;
    BOOL                    m_bConnecting;
    DPNHANDLE               m_hConnectAsyncOp;
    HANDLE                  m_hConnectCompleteEvent;
    HANDLE                  m_hLobbyConnectionEvent;
    HRESULT                 m_hrConnectComplete;
};


#endif // NETCONNECT_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\test\hostjoin\test.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 ****************************************************************************/

#include <xtl.h>
#include <dplay8.h>
#include <dpaddr.h>

HANDLE				g_hSyncEvent = NULL;
HANDLE				g_hConnectEvent = NULL;
LPDIRECTPLAY8PEER		g_pDPHost;
LPDIRECTPLAY8PEER		g_pDPJoin;
GUID				g_guidApp = { 0x2ae835d, 0x9179, 0x485f, { 0x83, 0x43, 0x90, 0x1d, 0x32, 0x7c, 0xe7, 0x94 } };

DPNID				g_dpnidLocalPlayer            = 0;
LONG				g_lNumberOfActivePlayers      = 0;
TCHAR				g_strLocalPlayerName[MAX_PATH];

BOOL				g_fThreadRun = FALSE;

#define LOCALADDRESS L"157.56.10.87"
#define HOSTPORT 2350


#define MAX_PLAYER_NAME         14

struct APP_PLAYER_INFO
{
    LONG  lRefCount;                        // Ref count so we can cleanup when all threads 
                                            // are done w/ this object
    DPNID dpnidPlayer;                      // DPNID of player
    TCHAR strPlayerName[MAX_PLAYER_NAME];   // Player name
};

#define GAME_MSGID_WAVE        1

struct GAMEMSG_GENERIC
{
    DWORD dwType;
    CHAR blah[2048];
};

typedef HRESULT (WINAPI *LPFNDIRECTPLAYMESSAGEHANDLER)(PVOID, DWORD, PVOID);

BOOL GlobalInit(void);
BOOL InitDPlayPeer(LPDIRECTPLAY8PEER *pDirectPlay8Peer, LPFNDIRECTPLAYMESSAGEHANDLER pMessageHandler);
BOOL HostGame(LPDIRECTPLAY8PEER pDirectPlay8Peer);
BOOL JoinGame(LPDIRECTPLAY8PEER pDirectPlay8Peer);
BOOL SendMessage(LPDIRECTPLAY8PEER pDirectPlay8Peer);
BOOL CloseDPlayPeer(LPDIRECTPLAY8PEER *ppDirectPlay8Peer);
DWORD WINAPI WorkerThread( void *pParam );

HRESULT WINAPI DirectPlayHostMessageHandler( PVOID pvUserContext, DWORD dwMessageId, PVOID pMsgBuffer );
HRESULT WINAPI DirectPlayJoinMessageHandler( PVOID pvUserContext, DWORD dwMessageId, PVOID pMsgBuffer );

void __cdecl main()
{
    __asm int 3;

    if (GlobalInit() == FALSE)
    {
        __asm int 3;
        goto exit;
    }

    if (InitDPlayPeer(&g_pDPHost, DirectPlayHostMessageHandler) == FALSE)
    {
        __asm int 3;
        goto exit;
    }

    if (InitDPlayPeer(&g_pDPJoin, DirectPlayJoinMessageHandler) == FALSE)
    {
        __asm int 3;
        goto exit;
    }

    g_fThreadRun = TRUE;

    if (HostGame(g_pDPHost) == FALSE)
    {
        __asm int 3;
        goto exit;
    }

    if (JoinGame(g_pDPJoin) == FALSE)
    {
        __asm int 3;
        goto exit;
    }

    ResetEvent(g_hConnectEvent);

    if (SendMessage(g_pDPJoin) == FALSE)
    {
        __asm int 3;
        goto exit;
    }

    WaitForSingleObject(g_hConnectEvent, INFINITE);

    CloseDPlayPeer(&g_pDPHost);
    CloseDPlayPeer(&g_pDPJoin);

    g_fThreadRun = FALSE;

  exit:

    HRESULT hr = DPlayCleanup();

    if (FAILED(hr))
    {
        __asm int 3;
    }

    __asm int 3;
}

BOOL GlobalInit(void)
{
    INT err = 0;
    HRESULT hr = S_OK;
    DWORD dwThreadID = 0;
    HANDLE hThread = NULL;

    g_hSyncEvent = CreateEvent(NULL, TRUE, FALSE,NULL);
    g_hConnectEvent = CreateEvent(NULL, TRUE, FALSE,NULL);

    ResetEvent(g_hSyncEvent);    
    ResetEvent(g_hConnectEvent);    

    err = XnetInitialize(NULL, TRUE);
    if (err != NO_ERROR)
    {
        __asm int 3;
        return FALSE;
    }

    hr = DPlayInitialize();

    if (FAILED(hr))
    {
        __asm int 3;
    }

    hThread = CreateThread( NULL, 0, WorkerThread, 0, 0, &dwThreadID );

    return TRUE;
}

BOOL InitDPlayPeer(LPDIRECTPLAY8PEER *ppDirectPlay8Peer, LPFNDIRECTPLAYMESSAGEHANDLER pMessageHandler)
{
    HRESULT hr;

    hr = DirectPlay8Create(IID_IDirectPlay8Peer, (void **) ppDirectPlay8Peer, NULL);
    if( FAILED(hr) )
    {
        __asm int 3;
        return FALSE;
    }

    hr = (*ppDirectPlay8Peer)->Initialize( NULL, pMessageHandler, 0 );
    if( FAILED(hr) )
    {
        __asm int 3;
        return FALSE;
    }

    return TRUE;
}

BOOL HostGame(LPDIRECTPLAY8PEER pDirectPlay8Peer)
{
    HRESULT hr;
    DPN_APPLICATION_DESC dnAppDesc;
    LPDIRECTPLAY8ADDRESS pDeviceAddress;

    // Create a device address
    hr = DirectPlay8AddressCreate(IID_IDirectPlay8Address, (void **) &pDeviceAddress, NULL);
    if( FAILED(hr) )
    {
        __asm int 3;
        return FALSE;
    }

    pDeviceAddress->BuildAddress(LOCALADDRESS, HOSTPORT);

    ZeroMemory( &dnAppDesc, sizeof(DPN_APPLICATION_DESC) );
    dnAppDesc.dwSize          = sizeof(DPN_APPLICATION_DESC);
    dnAppDesc.guidApplication = g_guidApp;
    dnAppDesc.pwszSessionName = L"MyGamexbox";
    dnAppDesc.dwMaxPlayers    = 5;
    dnAppDesc.dwFlags         = 0;

    hr = pDirectPlay8Peer->Host( &dnAppDesc, &pDeviceAddress, 1, NULL, NULL, NULL, 0 );
    if( FAILED( hr ) )
    {
        __asm int 3;
        return FALSE;
    }

    pDeviceAddress->Release();

    return TRUE;
}

BOOL JoinGame(LPDIRECTPLAY8PEER pDirectPlay8Peer)
{
    HRESULT hr;
    DPN_APPLICATION_DESC dnAppDesc;
    DPN_PLAYER_INFO dpPlayerInfo;
    DPNHANDLE hConnectAsyncOp;
    LPDIRECTPLAY8ADDRESS pDeviceAddress;
    LPDIRECTPLAY8ADDRESS pHostAddress;

    // Create a device address
    hr = DirectPlay8AddressCreate(IID_IDirectPlay8Address, (void **) &pDeviceAddress, NULL);
    if( FAILED(hr) )
    {
        __asm int 3;
        return FALSE;
    }

    // Create a host address
    hr = DirectPlay8AddressCreate(IID_IDirectPlay8Address, (void **) &pHostAddress, NULL);
    if( FAILED(hr) )
    {
        __asm int 3;
        return FALSE;
    }

    pHostAddress->BuildAddress(LOCALADDRESS, HOSTPORT);

    ZeroMemory( &dnAppDesc, sizeof(DPN_APPLICATION_DESC) );
    dnAppDesc.dwSize          = sizeof(DPN_APPLICATION_DESC);
    dnAppDesc.guidApplication = g_guidApp;

    ZeroMemory( &dpPlayerInfo, sizeof(DPN_PLAYER_INFO) );
    dpPlayerInfo.dwSize = sizeof(DPN_PLAYER_INFO);
    dpPlayerInfo.dwInfoFlags = DPNINFO_NAME;
    dpPlayerInfo.pwszName = L"MarkXbox";

    hr = pDirectPlay8Peer->SetPeerInfo( &dpPlayerInfo, NULL, NULL, 0 );
    if( FAILED( hr ) )
    {
        __asm int 3;
        return FALSE;
    }

    hr = pDirectPlay8Peer->Connect( &dnAppDesc, pHostAddress, pDeviceAddress, NULL, NULL, NULL, 0, NULL, NULL, &hConnectAsyncOp, 0 );
    if( hr != E_PENDING && FAILED(hr) )
    {
        __asm int 3;
        return FALSE;
    }

    WaitForSingleObject(g_hConnectEvent, INFINITE);

    pHostAddress->Release();
    pDeviceAddress->Release();

    return TRUE;
}

BOOL SendMessage(LPDIRECTPLAY8PEER pDirectPlay8Peer)
{
    HRESULT hr;
    GAMEMSG_GENERIC msgWave;
    DPN_BUFFER_DESC bufferDesc;
    DPNHANDLE hAsync;

    msgWave.dwType = GAME_MSGID_WAVE;
    bufferDesc.dwBufferSize = sizeof(GAMEMSG_GENERIC);
    bufferDesc.pBufferData  = (BYTE*) &msgWave;

    while (1)
        pDirectPlay8Peer->SendTo( DPNID_ALL_PLAYERS_GROUP, &bufferDesc, 1, 0, NULL, &hAsync, DPNSEND_NOLOOPBACK );

    return TRUE;
}

BOOL CloseDPlayPeer(LPDIRECTPLAY8PEER *ppDirectPlay8Peer)
{
    HRESULT hr;
    LPDIRECTPLAY8PEER pTempPeer = NULL;

    hr = (*ppDirectPlay8Peer)->Close(0);
    if( FAILED(hr) )
    {
        __asm int 3;
        return FALSE;
    }

    pTempPeer = *ppDirectPlay8Peer;
    *ppDirectPlay8Peer = NULL;

    SleepEx(10, FALSE);

    hr = (pTempPeer)->Release();
    if( FAILED(hr) )
    {
        __asm int 3;
        return FALSE;
    }

    return TRUE;
}


DWORD WINAPI WorkerThread( void *pParam )
{
    while (1)
    {
        if (g_fThreadRun && g_pDPHost->DoWork(0) == S_FALSE && g_pDPJoin->DoWork(0) == S_FALSE)
        {
            SleepEx(10, FALSE);
        }
    }

    return 0;
}


HRESULT WINAPI DirectPlayHostMessageHandler( PVOID pvUserContext, DWORD dwMessageId, PVOID pMsgBuffer )
{
    switch( dwMessageId )
    {
        case DPN_MSGID_CREATE_PLAYER:
        {
            HRESULT hr;
            PDPNMSG_CREATE_PLAYER pCreatePlayerMsg;
            pCreatePlayerMsg = (PDPNMSG_CREATE_PLAYER)pMsgBuffer;

            // Get the peer info and extract its name
            DWORD dwSize = 0;
            DPN_PLAYER_INFO* pdpPlayerInfo = NULL;
            hr = g_pDPHost->GetPeerInfo( pCreatePlayerMsg->dpnidPlayer, pdpPlayerInfo, &dwSize, 0 );
            if( FAILED(hr) && hr != DPNERR_BUFFERTOOSMALL )
                return hr;

            pdpPlayerInfo = (DPN_PLAYER_INFO*) new BYTE[ dwSize ];
            ZeroMemory( pdpPlayerInfo, dwSize );
            pdpPlayerInfo->dwSize = sizeof(DPN_PLAYER_INFO);
            hr = g_pDPHost->GetPeerInfo( pCreatePlayerMsg->dpnidPlayer, pdpPlayerInfo, &dwSize, 0 );
            if( FAILED(hr) )
                return hr;

            // Create a new and fill in a APP_PLAYER_INFO
            APP_PLAYER_INFO* pPlayerInfo = new APP_PLAYER_INFO;
            ZeroMemory( pPlayerInfo, sizeof(APP_PLAYER_INFO) );
            pPlayerInfo->lRefCount   = 1;
            pPlayerInfo->dpnidPlayer = pCreatePlayerMsg->dpnidPlayer;

            if( pdpPlayerInfo->dwPlayerFlags & DPNPLAYER_LOCAL )
                g_dpnidLocalPlayer = pCreatePlayerMsg->dpnidPlayer;

            delete pdpPlayerInfo;

            // Tell DirectPlay to store this pPlayerInfo 
            // pointer in the pvPlayerContext.
            pCreatePlayerMsg->pvPlayerContext = pPlayerInfo;

            // Update the number of active players, and 
            // post a message to the dialog thread to update the 
            // UI.  This keeps the DirectPlay message handler 
            // from blocking
            InterlockedIncrement( &g_lNumberOfActivePlayers );

            break;
        }

        case DPN_MSGID_DESTROY_PLAYER:
        {
            PDPNMSG_DESTROY_PLAYER pDestroyPlayerMsg;
            pDestroyPlayerMsg = (PDPNMSG_DESTROY_PLAYER)pMsgBuffer;
            APP_PLAYER_INFO* pPlayerInfo = (APP_PLAYER_INFO*) pDestroyPlayerMsg->pvPlayerContext;

            if( pPlayerInfo )
            {
                pPlayerInfo->lRefCount--;
                if( pPlayerInfo->lRefCount <= 0 )
                    delete pPlayerInfo;
            }
            pPlayerInfo = NULL;

            // Update the number of active players, and 
            // post a message to the dialog thread to update the 
            // UI.  This keeps the DirectPlay message handler 
            // from blocking
            InterlockedDecrement( &g_lNumberOfActivePlayers );

            break;
        }

        case DPN_MSGID_HOST_MIGRATE:
        {
            PDPNMSG_HOST_MIGRATE pHostMigrateMsg;
            pHostMigrateMsg = (PDPNMSG_HOST_MIGRATE)pMsgBuffer;

            break;
        }

        case DPN_MSGID_TERMINATE_SESSION:
        {
            PDPNMSG_TERMINATE_SESSION pTerminateSessionMsg;
            pTerminateSessionMsg = (PDPNMSG_TERMINATE_SESSION)pMsgBuffer;

            break;
        }

        case DPN_MSGID_RECEIVE:
        {
            HRESULT hr;
            PDPNMSG_RECEIVE pReceiveMsg;
            pReceiveMsg = (PDPNMSG_RECEIVE)pMsgBuffer;
            APP_PLAYER_INFO* pPlayerInfo = (APP_PLAYER_INFO*) pReceiveMsg->pvPlayerContext;
            APP_PLAYER_INFO* pPlayerInfo2 = NULL;

            GAMEMSG_GENERIC* pMsg = (GAMEMSG_GENERIC*) pReceiveMsg->pReceiveData;
            if( pMsg->dwType == GAME_MSGID_WAVE )
            {
                // This message is sent when a player has waved to us, so 
                // post a message to the dialog thread to update the UI.  
                // This keeps the DirectPlay threads from blocking, and also
                // serializes the recieves since DirectPlayMessageHandler can
                // be called simultaneously from a pool of DirectPlay threads.
                hr = g_pDPHost->GetPlayerContext( pPlayerInfo->dpnidPlayer, (LPVOID* const) &pPlayerInfo2, 0);

                if( pPlayerInfo2 )
                    pPlayerInfo2->lRefCount++;

                if( FAILED(hr) || pPlayerInfo2 == NULL )
                {
                    // The player who sent this may have gone away before this 
                    // message was handled, so just ignore it
                    break;
                }
            
                // Make wave message and display it.
                TCHAR szWaveMessage[MAX_PATH];
                wsprintf( szWaveMessage, TEXT("%s just waved at you, %s!\r\n"), 
                          pPlayerInfo2->strPlayerName, g_strLocalPlayerName );

                if( pPlayerInfo2 )
                {
                    pPlayerInfo2->lRefCount--;
                    if( pPlayerInfo2->lRefCount <= 0 )
                         delete pPlayerInfo2;
                }
                pPlayerInfo2 = NULL;
            }

            SetEvent(g_hConnectEvent);
            break;
        }

        case DPN_MSGID_ASYNC_OP_COMPLETE:
        {
            PDPNMSG_ASYNC_OP_COMPLETE pAsyncOpCompleteMsg;
            pAsyncOpCompleteMsg = (PDPNMSG_ASYNC_OP_COMPLETE)pMsgBuffer;

//            if( pAsyncOpCompleteMsg->hAsyncOp == hEnumAsyncOp )
//            {
//            }
            break;
        }

    }

    return S_OK;
}

HRESULT WINAPI DirectPlayJoinMessageHandler( PVOID pvUserContext, DWORD dwMessageId, PVOID pMsgBuffer )
{
    switch( dwMessageId )
    {
        case DPN_MSGID_CREATE_PLAYER:
        {
            HRESULT hr;
            PDPNMSG_CREATE_PLAYER pCreatePlayerMsg;
            pCreatePlayerMsg = (PDPNMSG_CREATE_PLAYER)pMsgBuffer;

            // Get the peer info and extract its name
            DWORD dwSize = 0;
            DPN_PLAYER_INFO* pdpPlayerInfo = NULL;
            hr = g_pDPJoin->GetPeerInfo( pCreatePlayerMsg->dpnidPlayer, pdpPlayerInfo, &dwSize, 0 );
            if( FAILED(hr) && hr != DPNERR_BUFFERTOOSMALL )
                return hr;

            pdpPlayerInfo = (DPN_PLAYER_INFO*) new BYTE[ dwSize ];
            ZeroMemory( pdpPlayerInfo, dwSize );
            pdpPlayerInfo->dwSize = sizeof(DPN_PLAYER_INFO);
            hr = g_pDPJoin->GetPeerInfo( pCreatePlayerMsg->dpnidPlayer, pdpPlayerInfo, &dwSize, 0 );
            if( FAILED(hr) )
                return hr;

            // Create a new and fill in a APP_PLAYER_INFO
            APP_PLAYER_INFO* pPlayerInfo = new APP_PLAYER_INFO;
            ZeroMemory( pPlayerInfo, sizeof(APP_PLAYER_INFO) );
            pPlayerInfo->lRefCount   = 1;
            pPlayerInfo->dpnidPlayer = pCreatePlayerMsg->dpnidPlayer;

            if( pdpPlayerInfo->dwPlayerFlags & DPNPLAYER_LOCAL )
                g_dpnidLocalPlayer = pCreatePlayerMsg->dpnidPlayer;

            delete pdpPlayerInfo;

            // Tell DirectPlay to store this pPlayerInfo 
            // pointer in the pvPlayerContext.
            pCreatePlayerMsg->pvPlayerContext = pPlayerInfo;

            // Update the number of active players, and 
            // post a message to the dialog thread to update the 
            // UI.  This keeps the DirectPlay message handler 
            // from blocking
            InterlockedIncrement( &g_lNumberOfActivePlayers );

            break;
        }

        case DPN_MSGID_DESTROY_PLAYER:
        {
            PDPNMSG_DESTROY_PLAYER pDestroyPlayerMsg;
            pDestroyPlayerMsg = (PDPNMSG_DESTROY_PLAYER)pMsgBuffer;
            APP_PLAYER_INFO* pPlayerInfo = (APP_PLAYER_INFO*) pDestroyPlayerMsg->pvPlayerContext;

            if( pPlayerInfo )
            {
                pPlayerInfo->lRefCount--;
                if( pPlayerInfo->lRefCount <= 0 )
                    delete pPlayerInfo;
            }
            pPlayerInfo = NULL;

            // Update the number of active players, and 
            // post a message to the dialog thread to update the 
            // UI.  This keeps the DirectPlay message handler 
            // from blocking
            InterlockedDecrement( &g_lNumberOfActivePlayers );

            break;
        }

        case DPN_MSGID_HOST_MIGRATE:
        {
            PDPNMSG_HOST_MIGRATE pHostMigrateMsg;
            pHostMigrateMsg = (PDPNMSG_HOST_MIGRATE)pMsgBuffer;

            break;
        }

        case DPN_MSGID_TERMINATE_SESSION:
        {
            PDPNMSG_TERMINATE_SESSION pTerminateSessionMsg;
            pTerminateSessionMsg = (PDPNMSG_TERMINATE_SESSION)pMsgBuffer;

            break;
        }

        case DPN_MSGID_RECEIVE:
        {
            HRESULT hr;
            PDPNMSG_RECEIVE pReceiveMsg;
            pReceiveMsg = (PDPNMSG_RECEIVE)pMsgBuffer;
            APP_PLAYER_INFO* pPlayerInfo = (APP_PLAYER_INFO*) pReceiveMsg->pvPlayerContext;
            APP_PLAYER_INFO* pPlayerInfo2 = NULL;

            GAMEMSG_GENERIC* pMsg = (GAMEMSG_GENERIC*) pReceiveMsg->pReceiveData;
            if( pMsg->dwType == GAME_MSGID_WAVE )
            {
                // This message is sent when a player has waved to us, so 
                // post a message to the dialog thread to update the UI.  
                // This keeps the DirectPlay threads from blocking, and also
                // serializes the recieves since DirectPlayMessageHandler can
                // be called simultaneously from a pool of DirectPlay threads.
                hr = g_pDPJoin->GetPlayerContext( pPlayerInfo->dpnidPlayer, (LPVOID* const) &pPlayerInfo2, 0);

                if( pPlayerInfo2 )
                    pPlayerInfo2->lRefCount++;

                if( FAILED(hr) || pPlayerInfo2 == NULL )
                {
                    // The player who sent this may have gone away before this 
                    // message was handled, so just ignore it
                    break;
                }
            
                // Make wave message and display it.
                TCHAR szWaveMessage[MAX_PATH];
                wsprintf( szWaveMessage, TEXT("%s just waved at you, %s!\r\n"), 
                          pPlayerInfo2->strPlayerName, g_strLocalPlayerName );

                if( pPlayerInfo2 )
                {
                    pPlayerInfo2->lRefCount--;
                    if( pPlayerInfo2->lRefCount <= 0 )
                         delete pPlayerInfo2;
                }
                pPlayerInfo2 = NULL;
            }
            break;
        }

        case DPN_MSGID_CONNECT_COMPLETE:
        {
            HRESULT hrConnectComplete;
            PDPNMSG_CONNECT_COMPLETE pConnectCompleteMsg;
            pConnectCompleteMsg = (PDPNMSG_CONNECT_COMPLETE)pMsgBuffer;

            hrConnectComplete = pConnectCompleteMsg->hResultCode;

            SetEvent(g_hConnectEvent);

            break;
        }

        case DPN_MSGID_ASYNC_OP_COMPLETE:
        {
            PDPNMSG_ASYNC_OP_COMPLETE pAsyncOpCompleteMsg;
            pAsyncOpCompleteMsg = (PDPNMSG_ASYNC_OP_COMPLETE)pMsgBuffer;

//            if( pAsyncOpCompleteMsg->hAsyncOp == hEnumAsyncOp )
//            {
//            }

            break;
        }

    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\test\simplepeer\dxutil.h ===
//-----------------------------------------------------------------------------
// File: DXUtil.h
//
// Desc: Helper functions and typing shortcuts for DirectX programming.
//
//@@BEGIN_MSINTERNAL
//
// Hist: See the source files for detailed histories
//       03.21.00 - mwetzel - Last Modified
//
//@@END_MSINTERNAL
// Copyright (c) 1997-2000 Microsoft Corporation. All rights reserved
//-----------------------------------------------------------------------------
#ifndef DXUTIL_H
#define DXUTIL_H


//-----------------------------------------------------------------------------
// Miscellaneous helper functions
//-----------------------------------------------------------------------------
#define SAFE_DELETE(p)       { if(p) { delete (p);     (p)=NULL; } }
#define SAFE_DELETE_ARRAY(p) { if(p) { delete[] (p);   (p)=NULL; } }
#define SAFE_RELEASE(p)      { if(p) { (p)->Release(); (p)=NULL; } }




//-----------------------------------------------------------------------------
// Name: DXUtil_GetDXSDKMediaPath() and DXUtil_FindMediaFile() 
// Desc: Returns the DirectX SDK path, as stored in the system registry
//       during the SDK install.
//-----------------------------------------------------------------------------
const TCHAR* DXUtil_GetDXSDKMediaPath();
HRESULT      DXUtil_FindMediaFile( TCHAR* strPath, TCHAR* strFilename );




//-----------------------------------------------------------------------------
// Name: DXUtil_Read*RegKey() and DXUtil_Write*RegKey()
// Desc: Helper functions to read/write a string registry key 
//-----------------------------------------------------------------------------
HRESULT DXUtil_WriteStringRegKey( HKEY hKey, TCHAR* strRegName, TCHAR* strValue );
HRESULT DXUtil_WriteIntRegKey( HKEY hKey, TCHAR* strRegName, DWORD dwValue );
HRESULT DXUtil_WriteGuidRegKey( HKEY hKey, TCHAR* strRegName, GUID guidValue );
HRESULT DXUtil_WriteBoolRegKey( HKEY hKey, TCHAR* strRegName, BOOL bValue );

HRESULT DXUtil_ReadStringRegKey( HKEY hKey, TCHAR* strRegName, TCHAR* strValue, DWORD dwLength, TCHAR* strDefault );
HRESULT DXUtil_ReadIntRegKey( HKEY hKey, TCHAR* strRegName, DWORD* pdwValue, DWORD dwDefault );
HRESULT DXUtil_ReadGuidRegKey( HKEY hKey, TCHAR* strRegName, GUID* pGuidValue, GUID& guidDefault );
HRESULT DXUtil_ReadBoolRegKey( HKEY hKey, TCHAR* strRegName, BOOL* pbValue, BOOL bDefault );




//-----------------------------------------------------------------------------
// Name: DXUtil_Timer()
// Desc: Performs timer opertations. Use the following commands:
//          TIMER_RESET           - to reset the timer
//          TIMER_START           - to start the timer
//          TIMER_STOP            - to stop (or pause) the timer
//          TIMER_ADVANCE         - to advance the timer by 0.1 seconds
//          TIMER_GETABSOLUTETIME - to get the absolute system time
//          TIMER_GETAPPTIME      - to get the current time
//          TIMER_GETELAPSEDTIME  - to get the time that elapsed between 
//                                  TIMER_GETELAPSEDTIME calls
//-----------------------------------------------------------------------------
enum TIMER_COMMAND { TIMER_RESET, TIMER_START, TIMER_STOP, TIMER_ADVANCE,
                     TIMER_GETABSOLUTETIME, TIMER_GETAPPTIME, TIMER_GETELAPSEDTIME };
FLOAT __stdcall DXUtil_Timer( TIMER_COMMAND command );




//-----------------------------------------------------------------------------
// UNICODE support for converting between CHAR, TCHAR, and WCHAR strings
//-----------------------------------------------------------------------------
VOID DXUtil_ConvertAnsiStringToWide( WCHAR* wstrDestination, const CHAR* strSource, int cchDestChar = -1 );
VOID DXUtil_ConvertWideStringToAnsi( CHAR* strDestination, const WCHAR* wstrSource, int cchDestChar = -1 );
VOID DXUtil_ConvertGenericStringToAnsi( CHAR* strDestination, const TCHAR* tstrSource, int cchDestChar = -1 );
VOID DXUtil_ConvertGenericStringToWide( WCHAR* wstrDestination, const TCHAR* tstrSource, int cchDestChar = -1 );
VOID DXUtil_ConvertAnsiStringToGeneric( TCHAR* tstrDestination, const CHAR* strSource, int cchDestChar = -1 );
VOID DXUtil_ConvertWideStringToGeneric( TCHAR* tstrDestination, const WCHAR* wstrSource, int cchDestChar = -1 );




//-----------------------------------------------------------------------------
// Debug printing support
//-----------------------------------------------------------------------------
VOID    DXUtil_Trace( TCHAR* strMsg, ... );
HRESULT _DbgOut( TCHAR*, DWORD, HRESULT, TCHAR* );

#if defined(DEBUG) | defined(_DEBUG)
    #define DXTRACE           DXUtil_Trace
#else
    #define DXTRACE           sizeof
#endif

#if defined(DEBUG) | defined(_DEBUG)
    #define DEBUG_MSG(str)    _DbgOut( __FILE__, (DWORD)__LINE__, 0, str )
#else
    #define DEBUG_MSG(str)    (0L)
#endif




#endif // DXUTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\sources.inc ===
#
# Do not include this file directly.  Instead, use win32.inc, console.inc, 
# xbox.inc or dsound.inc
#

TARGETTYPE=LIBRARY

DXBASEDIR=$(BASEDIR)\private\windows\directx
DSBASEDIR=$(DXBASEDIR)\dsound

!ifdef DPFLVL_DEFAULT
C_DEFINES=$(C_DEFINES) -DDPFLVL_DEFAULT="$(DPFLVL_DEFAULT)"
!endif

!ifdef DPFLVL_DEFAULT_BREAK
C_DEFINES=$(C_DEFINES) -DDPFLVL_DEFAULT_BREAK="$(DPFLVL_DEFAULT_BREAK)"
!endif

NTDBGFILES=1
USE_MAPSYM=1

USER_C_FLAGS=$(USER_C_FLAGS) /FAcs

!if !$(FREEBUILD)
MSC_OPTIMIZATION=$(MSC_OPTIMIZATION) /Od
!endif

INCLUDES=\
    $(DSBASEDIR)\common
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\win32.inc ===
#
# Include this from your sources file when building a Win32 app
#

!include sources.inc

UMTYPE = windows

TARGETPATH=$(BASEDIR)\public\wsdk\lib

INCLUDES = \
    $(BASEDIR)\public\wsdk\inc;\
    $(BASEDIR)\public\wsdk\inc\mfc42;\
    $(BASEDIR)\public\sdk\inc;\
    $(INCLUDES)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\dsound.inc ===
#
# Include this from your sources file when building a lib that is linked into
# dsound.lib
#

!include xbox.inc

C_DEFINES=$(C_DEFINES) -DDSNDVER -DBUILDING_DSOUND
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\console.inc ===
#
# Include this from your sources file when building a console app
#

!include win32.inc

C_DEFINES = $(C_DEFINES) -D_CONSOLE
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\test\simplepeer\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by SimplePeer.rc
//
#define IDD_MAIN_GAME                   101
#define IDC_WAVE                        1001
#define IDC_NUM_PLAYERS                 1002
#define IDC_PLAYER_NAME                 1003
#define IDC_LOG_EDIT                    1016
#define IDD_MUTLIPLAYER_CONNECT         10001
#define IDD_MUTLIPLAYER_GAMES           10002
#define IDD_MULTIPLAYER_CREATE          10003
#define IDC_RETURN                      11001
#define IDC_PLAYER_NAME_EDIT            11002
#define IDC_GAMES_LIST                  11003
#define IDC_JOIN                        11004
#define IDC_CREATE                      11005
#define IDC_CONNECTION_LIST             11006
#define IDC_BACK                        11007
#define IDC_CHECK_DPLAY_PROTOCOL        11008
#define IDC_EDIT_SESSION_NAME           11009
#define IDC_SEARCH_CHECK                11010
#define IDC_WAIT_TEXT                   11012
#define IDC_MIGRATE_HOST                11013
#define IDI_MAIN                        11014
#define IDC_STATIC                      1050

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        105
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1004
#define _APS_NEXT_SYMED_VALUE           103
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\test\simplepeer\simplepeer.cpp ===
#include <windows.h>
#include <dplay8.h>
#include "NetConnect.h"
#include "resource.h"
#include "DXUtil.h"

//-----------------------------------------------------------------------------
// Player context locking defines
//-----------------------------------------------------------------------------
CRITICAL_SECTION g_csPlayerContext;
#define PLAYER_LOCK()                   EnterCriticalSection( &g_csPlayerContext ); 
#define PLAYER_ADDREF( pPlayerInfo )    if( pPlayerInfo ) pPlayerInfo->lRefCount++;
#define PLAYER_RELEASE( pPlayerInfo )   if( pPlayerInfo ) { pPlayerInfo->lRefCount--; if( pPlayerInfo->lRefCount <= 0 ) SAFE_DELETE( pPlayerInfo ); } pPlayerInfo = NULL;
#define PLAYER_UNLOCK()                 LeaveCriticalSection( &g_csPlayerContext );


//-----------------------------------------------------------------------------
// Defines, and constants
//-----------------------------------------------------------------------------
#define MAX_PLAYER_NAME         14
#define WM_APP_UPDATE_STATS    (WM_APP + 0)
#define WM_APP_DISPLAY_WAVE    (WM_APP + 1)

// This GUID allows DirectPlay to find other instances of the same game on
// the network.  So it must be unique for every game, and the same for 
// every instance of that game.  // {02AE835D-9179-485f-8343-901D327CE794}
GUID g_guidApp = { 0x2ae835d, 0x9179, 0x485f, { 0x83, 0x43, 0x90, 0x1d, 0x32, 0x7c, 0xe7, 0x94 } };

struct APP_PLAYER_INFO
{
    LONG  lRefCount;                        // Ref count so we can cleanup when all threads 
                                            // are done w/ this object
    DPNID dpnidPlayer;                      // DPNID of player
    TCHAR strPlayerName[MAX_PLAYER_NAME];   // Player name
};




//-----------------------------------------------------------------------------
// Global variables
//-----------------------------------------------------------------------------
IDirectPlay8Peer*  g_pDP                         = NULL;    // DirectPlay peer object
CNetConnectWizard* g_pNetConnectWizard           = NULL;    // Connection wizard
HINSTANCE          g_hInst                       = NULL;    // HINST of app
HWND               g_hDlg                        = NULL;    // HWND of main dialog
DPNID              g_dpnidLocalPlayer            = 0;       // DPNID of local player
LONG               g_lNumberOfActivePlayers      = 0;       // Number of players currently in game
TCHAR              g_strAppName[256]             = TEXT("SimplePeer");
HRESULT            g_hrDialog;                              // Exit code for app 
TCHAR              g_strLocalPlayerName[MAX_PATH];          // Local player name
TCHAR              g_strSessionName[MAX_PATH];              // Session name
TCHAR              g_strPreferredProvider[MAX_PATH];        // Provider string




//-----------------------------------------------------------------------------
// App specific DirectPlay messages and structures 
//-----------------------------------------------------------------------------
#define GAME_MSGID_WAVE        1

// Change compiler pack alignment to be BYTE aligned, and pop the current value
#pragma pack( push, 1 )

struct GAMEMSG_GENERIC
{
    DWORD dwType;
};

// Pop the old pack alignment
#pragma pack( pop )



//-----------------------------------------------------------------------------
// Function-prototypes
//-----------------------------------------------------------------------------
HRESULT WINAPI   DirectPlayMessageHandler( PVOID pvUserContext, DWORD dwMessageId, PVOID pMsgBuffer );
INT_PTR CALLBACK GreetingDlgProc( HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam );
HRESULT  InitDirectPlay();
HRESULT  WaveToAllPlayers();
VOID     AppendTextToEditControl( HWND hDlg, TCHAR* strNewLogLine );





//-----------------------------------------------------------------------------
// Name: WinMain()
// Desc: Entry point for the application.  Since we use a simple dialog for 
//       user interaction we don't need to pump messages.
//-----------------------------------------------------------------------------
INT APIENTRY WinMain( HINSTANCE hInst, HINSTANCE hPrevInst, 
                      LPSTR pCmdLine, INT nCmdShow )
{
    HRESULT hr;
    BOOL    bConnectSuccess = FALSE;

    g_hInst = hInst; 
    InitializeCriticalSection( &g_csPlayerContext );

    // Init COM so we can use CoCreateInstance
    CoInitialize( NULL );

    // Create helper class
    g_pNetConnectWizard = new CNetConnectWizard( hInst, g_strAppName, &g_guidApp );

    if( FAILED( hr = InitDirectPlay() ) )
    {
        MessageBox( NULL, TEXT("Failed initializing IDirectPlay8Peer. ")
                    TEXT("The sample will now quit."),
                    TEXT("DirectPlay Sample"), MB_OK | MB_ICONERROR );
        return FALSE;
    }

        // If not lobby launched, prompt the user about the network 
        // connection and which session they would like to join or 
        // if they want to create a new one.

        // Setup connection wizard
        g_pNetConnectWizard->SetPlayerName( g_strLocalPlayerName );
        g_pNetConnectWizard->SetSessionName( g_strSessionName );
        g_pNetConnectWizard->SetPreferredProvider( g_strPreferredProvider );

        // Start a connection wizard.  The wizard uses GDI dialog boxes.
        // More complex games can use this as a starting point and add a 
        // fancier graphics layer such as Direct3D.
        hr = g_pNetConnectWizard->DoConnectWizard( FALSE );        
        if( FAILED( hr ) ) 
        {
            MessageBox( NULL, TEXT("Mutliplayer connect failed. ")
                        TEXT("The sample will now quit."),
                        TEXT("DirectPlay Sample"), MB_OK | MB_ICONERROR );
            bConnectSuccess = FALSE;
        } 
        else if( hr == NCW_S_QUIT ) 
        {
            // The user canceled the mutliplayer connect, so quit 
            bConnectSuccess = FALSE;
        }
        else
        {
            bConnectSuccess = TRUE; 

            // Read information from g_pNetConnectWizard
            _tcscpy( g_strLocalPlayerName, g_pNetConnectWizard->GetPlayerName() );
            _tcscpy( g_strSessionName, g_pNetConnectWizard->GetSessionName() );
            _tcscpy( g_strPreferredProvider, g_pNetConnectWizard->GetPreferredProvider() );
        }

    if( bConnectSuccess )
    {
        // App is now connected via DirectPlay, so start the game.  

        // For this sample, we just start a simple dialog box game.
        g_hrDialog = S_OK;
        DialogBox( hInst, MAKEINTRESOURCE(IDD_MAIN_GAME), NULL, 
                   (DLGPROC) GreetingDlgProc );

        if( FAILED( g_hrDialog ) )
        {
            if( g_hrDialog == DPNERR_CONNECTIONLOST )
            {
                MessageBox( NULL, TEXT("The DirectPlay session was lost. ")
                            TEXT("The sample will now quit."),
                            TEXT("DirectPlay Sample"), MB_OK | MB_ICONERROR );
            }
            else
            {
                MessageBox( NULL, TEXT("An error occured during the game. ")
                            TEXT("The sample will now quit."),
                            TEXT("DirectPlay Sample"), MB_OK | MB_ICONERROR );
            }
        }
    }

    // Cleanup DirectPlay and helper classes
    SAFE_DELETE( g_pNetConnectWizard );

    if( g_pDP )
    {
        g_pDP->Close(0);
        SAFE_RELEASE( g_pDP );
    }

    DeleteCriticalSection( &g_csPlayerContext );
    CoUninitialize();

    return TRUE;
}




//-----------------------------------------------------------------------------
// Name: InitDirectPlay()
// Desc: 
//-----------------------------------------------------------------------------
HRESULT InitDirectPlay()
{
    HRESULT hr;

    // Create IDirectPlay8Peer
    if( FAILED( hr = CoCreateInstance( CLSID_DirectPlay8Peer, NULL, 
                                       CLSCTX_INPROC_SERVER,
                                       IID_IDirectPlay8Peer, 
                                       (LPVOID*) &g_pDP ) ) )
        return hr;

    // Init the helper class, now that g_pDP and g_pLobbiedApp are valid
    g_pNetConnectWizard->Init( g_pDP );

    // Init IDirectPlay8Peer
    if( FAILED( hr = g_pDP->Initialize( NULL, DirectPlayMessageHandler, 0 ) ) )
        return hr;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: GreetingDlgProc()
// Desc: Handles dialog messages
//-----------------------------------------------------------------------------
INT_PTR CALLBACK GreetingDlgProc( HWND hDlg, UINT msg, 
                                  WPARAM wParam, LPARAM lParam )
{
    switch( msg ) 
    {
        case WM_INITDIALOG:
        {
            g_hDlg = hDlg;

            // Load and set the icon
            HICON hIcon = LoadIcon( g_hInst, MAKEINTRESOURCE( IDI_MAIN ) );
            SendMessage( hDlg, WM_SETICON, ICON_BIG,   (LPARAM) hIcon );  // Set big icon
            SendMessage( hDlg, WM_SETICON, ICON_SMALL, (LPARAM) hIcon );  // Set small icon

            if( g_pNetConnectWizard->IsHostPlayer() )
                SetWindowText( hDlg, TEXT("SimplePeer (Host)") );
            else
                SetWindowText( hDlg, TEXT("SimplePeer") );

            // Display local player's name
            SetDlgItemText( hDlg, IDC_PLAYER_NAME, g_strLocalPlayerName );

            PostMessage( hDlg, WM_APP_UPDATE_STATS, 0, 0 );
            break;
        }

        case WM_APP_UPDATE_STATS:
        {
            // Update the number of players in the game
            TCHAR strNumberPlayers[32];

            wsprintf( strNumberPlayers, TEXT("%d"), g_lNumberOfActivePlayers );
            SetDlgItemText( hDlg, IDC_NUM_PLAYERS, strNumberPlayers );
            break;
        }

        case WM_APP_DISPLAY_WAVE:
        {
            HRESULT          hr;
            DPNID            dpnidPlayer = (DWORD)wParam;
            APP_PLAYER_INFO* pPlayerInfo = NULL;
            
            PLAYER_LOCK(); // enter player context CS

            // Get the player context accosicated with this DPNID
            hr = g_pDP->GetPlayerContext( dpnidPlayer, 
                                          (LPVOID* const) &pPlayerInfo,
										  0);

            PLAYER_ADDREF( pPlayerInfo ); // addref player, since we are using it now
            PLAYER_UNLOCK(); // leave player context CS

            if( FAILED(hr) || pPlayerInfo == NULL )
            {
                // The player who sent this may have gone away before this 
                // message was handled, so just ignore it
                break;
            }
            
            // Make wave message and display it.
            TCHAR szWaveMessage[MAX_PATH];
            wsprintf( szWaveMessage, TEXT("%s just waved at you, %s!\r\n"), 
                      pPlayerInfo->strPlayerName, g_strLocalPlayerName );

            PLAYER_LOCK();
            PLAYER_RELEASE( pPlayerInfo );  // Release player and cleanup if needed
            PLAYER_UNLOCK();

            AppendTextToEditControl( hDlg, szWaveMessage );
            break;
        }

        case WM_COMMAND:
        {
            switch( LOWORD(wParam) )
            {
                case IDC_WAVE:
                    if( FAILED( g_hrDialog = WaveToAllPlayers() ) )
                    {
                        EndDialog( hDlg, 0 );
                    }

                    return TRUE;

                case IDCANCEL:
                    g_hrDialog = S_OK;
                    EndDialog( hDlg, 0 );
                    return TRUE;
            }
            break;
        }
    }

    return FALSE; // Didn't handle message
}




//-----------------------------------------------------------------------------
// Name: DirectPlayMessageHandler
// Desc: Handler for DirectPlay messages.  This function is called by
//       the DirectPlay message handler pool of threads, so be careful of thread
//       synchronization problems with shared memory
//-----------------------------------------------------------------------------
HRESULT WINAPI DirectPlayMessageHandler( PVOID pvUserContext, 
                                         DWORD dwMessageId, 
                                         PVOID pMsgBuffer )
{
    // Try not to stay in this message handler for too long, otherwise
    // there will be a backlog of data.  The best solution is to 
    // queue data as it comes in, and then handle it on other threads.
    
    // This function is called by the DirectPlay message handler pool of 
    // threads, so be careful of thread synchronization problems with shared memory

    switch( dwMessageId )
    {
        case DPN_MSGID_CREATE_PLAYER:
        {
            HRESULT hr;
            PDPNMSG_CREATE_PLAYER pCreatePlayerMsg;
            pCreatePlayerMsg = (PDPNMSG_CREATE_PLAYER)pMsgBuffer;

            // Get the peer info and extract its name
            DWORD dwSize = 0;
            DPN_PLAYER_INFO* pdpPlayerInfo = NULL;
            hr = g_pDP->GetPeerInfo( pCreatePlayerMsg->dpnidPlayer, 
                                     pdpPlayerInfo, &dwSize, 0 );
            if( FAILED(hr) && hr != DPNERR_BUFFERTOOSMALL )
                return hr;
            pdpPlayerInfo = (DPN_PLAYER_INFO*) new BYTE[ dwSize ];
            ZeroMemory( pdpPlayerInfo, dwSize );
            pdpPlayerInfo->dwSize = sizeof(DPN_PLAYER_INFO);
            hr = g_pDP->GetPeerInfo( pCreatePlayerMsg->dpnidPlayer, 
                                     pdpPlayerInfo, &dwSize, 0 );
            if( FAILED(hr) )
                return hr;

            // Create a new and fill in a APP_PLAYER_INFO
            APP_PLAYER_INFO* pPlayerInfo = new APP_PLAYER_INFO;
            ZeroMemory( pPlayerInfo, sizeof(APP_PLAYER_INFO) );
            pPlayerInfo->lRefCount   = 1;
            pPlayerInfo->dpnidPlayer = pCreatePlayerMsg->dpnidPlayer;

            // This stores a extra TCHAR copy of the player name for 
            // easier access.  This will be redundent copy since DPlay 
            // also keeps a copy of the player name in GetPeerInfo()
            DXUtil_ConvertWideStringToGeneric( pPlayerInfo->strPlayerName, 
                                               pdpPlayerInfo->pwszName, MAX_PLAYER_NAME );

            if( pdpPlayerInfo->dwPlayerFlags & DPNPLAYER_LOCAL )
                g_dpnidLocalPlayer = pCreatePlayerMsg->dpnidPlayer;

            SAFE_DELETE_ARRAY( pdpPlayerInfo );

            // Tell DirectPlay to store this pPlayerInfo 
            // pointer in the pvPlayerContext.
            pCreatePlayerMsg->pvPlayerContext = pPlayerInfo;

            // Update the number of active players, and 
            // post a message to the dialog thread to update the 
            // UI.  This keeps the DirectPlay message handler 
            // from blocking
            InterlockedIncrement( &g_lNumberOfActivePlayers );
            if( g_hDlg != NULL )
                PostMessage( g_hDlg, WM_APP_UPDATE_STATS, 0, 0 );

            break;
        }

        case DPN_MSGID_DESTROY_PLAYER:
        {
            PDPNMSG_DESTROY_PLAYER pDestroyPlayerMsg;
            pDestroyPlayerMsg = (PDPNMSG_DESTROY_PLAYER)pMsgBuffer;
            APP_PLAYER_INFO* pPlayerInfo = (APP_PLAYER_INFO*) pDestroyPlayerMsg->pvPlayerContext;

            PLAYER_LOCK();                  // enter player context CS
            PLAYER_RELEASE( pPlayerInfo );  // Release player and cleanup if needed
            PLAYER_UNLOCK();                // leave player context CS

            // Update the number of active players, and 
            // post a message to the dialog thread to update the 
            // UI.  This keeps the DirectPlay message handler 
            // from blocking
            InterlockedDecrement( &g_lNumberOfActivePlayers );
            if( g_hDlg != NULL )
                PostMessage( g_hDlg, WM_APP_UPDATE_STATS, 0, 0 );

            break;
        }

        case DPN_MSGID_HOST_MIGRATE:
        {
            PDPNMSG_HOST_MIGRATE pHostMigrateMsg;
            pHostMigrateMsg = (PDPNMSG_HOST_MIGRATE)pMsgBuffer;

            // Check to see if we are the new host
            if( pHostMigrateMsg->dpnidNewHost == g_dpnidLocalPlayer )
                SetWindowText( g_hDlg, TEXT("SimplePeer (Host)") );
            break;
        }

        case DPN_MSGID_TERMINATE_SESSION:
        {
            PDPNMSG_TERMINATE_SESSION pTerminateSessionMsg;
            pTerminateSessionMsg = (PDPNMSG_TERMINATE_SESSION)pMsgBuffer;

            g_hrDialog = DPNERR_CONNECTIONLOST;
            EndDialog( g_hDlg, 0 );
            break;
        }

        case DPN_MSGID_RECEIVE:
        {
            PDPNMSG_RECEIVE pReceiveMsg;
            pReceiveMsg = (PDPNMSG_RECEIVE)pMsgBuffer;
            APP_PLAYER_INFO* pPlayerInfo = (APP_PLAYER_INFO*) pReceiveMsg->pvPlayerContext;

            GAMEMSG_GENERIC* pMsg = (GAMEMSG_GENERIC*) pReceiveMsg->pReceiveData;
            if( pMsg->dwType == GAME_MSGID_WAVE )
            {
                // This message is sent when a player has waved to us, so 
                // post a message to the dialog thread to update the UI.  
                // This keeps the DirectPlay threads from blocking, and also
                // serializes the recieves since DirectPlayMessageHandler can
                // be called simultaneously from a pool of DirectPlay threads.
                PostMessage( g_hDlg, WM_APP_DISPLAY_WAVE, pPlayerInfo->dpnidPlayer, 0 );
            }
            break;
        }
    }

    // Make sure the DirectPlay MessageHandler calls the CNetConnectWizard handler, 
    // so it can be informed of messages such as DPN_MSGID_ENUM_HOSTS_RESPONSE.
    if( g_pNetConnectWizard )
        return g_pNetConnectWizard->MessageHandler( pvUserContext, dwMessageId, 
                                                    pMsgBuffer );
    
    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: WaveToAllPlayers()
// Desc: Send a app-defined "wave" DirectPlay message to all connected players
//-----------------------------------------------------------------------------
HRESULT WaveToAllPlayers()
{
    // This is called by the dialog UI thread.  This will send a message to all
    // the players or inform the player that there is no one to wave at.
    if( g_lNumberOfActivePlayers == 1 )
    {
        MessageBox( NULL, TEXT("No one is around to wave at! :("), 
                    TEXT("SimplePeer"), MB_OK );
    }
    else
    {
        // Send a message to all of the players
        GAMEMSG_GENERIC msgWave;
        msgWave.dwType = GAME_MSGID_WAVE;

        DPN_BUFFER_DESC bufferDesc;
        bufferDesc.dwBufferSize = sizeof(GAMEMSG_GENERIC);
        bufferDesc.pBufferData  = (BYTE*) &msgWave;

        DPNHANDLE hAsync;
        g_pDP->SendTo( DPNID_ALL_PLAYERS_GROUP, &bufferDesc, 1,
                       0, NULL, &hAsync, DPNSEND_NOLOOPBACK );
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: AppendTextToEditControl()
// Desc: Appends a string of text to the edit control
//-----------------------------------------------------------------------------
VOID AppendTextToEditControl( HWND hDlg, TCHAR* strNewLogLine )
{
    static TCHAR strText[1024*10];

    HWND hEdit = GetDlgItem( hDlg, IDC_LOG_EDIT );
    SendMessage( hEdit, WM_SETREDRAW, FALSE, 0 );
    GetWindowText( hEdit, strText, 1024*9 );

    _tcscat( strText, strNewLogLine );

    int nSecondLine = 0;
    if( SendMessage( hEdit, EM_GETLINECOUNT, 0, 0 ) > 9 )
        nSecondLine = (int)SendMessage( hEdit, EM_LINEINDEX, 1, 0 );

    SetWindowText( hEdit, &strText[nSecondLine] );

    SendMessage( hEdit, WM_SETREDRAW, TRUE, 0 );
    InvalidateRect( hEdit, NULL, TRUE );
    UpdateWindow( hEdit );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\xbox.inc ===
#
# Include this from your sources file when building an Xbox app or library 
# that does not get linked into dsound.lib.
#

!include sources.inc

TARGETPATH=$(BASEDIR)\public\sdk\lib

INCLUDES=\
    $(SDK_INC_PATH);\
    $(DDK_INC_PATH);\
    $(PRIVATE_INC_PATH);\
    $(BASEDIR)\private\ntos\inc;\
    $(DSBASEDIR)\dsound;\
    $(DSBASEDIR)\ac97;\
    $(DSBASEDIR)\codecs\inc;\
    $(DSBASEDIR)\tools\inc;\
    $(INCLUDES)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\boot\bootsnd.h ===
/***************************************************************************
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       bootsnd.h
 *  Content:    DirectSound bootsound source.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  06/19/01    dereks  Created.
 *
 ****************************************************************************/

#ifndef __BOOTSND_H__
#define __BOOTSND_H__

#define MCPX_BOOT_LIB

#undef DBG
#undef DEBUG

#ifndef BOOTSND_STANDALONE
#define _NTSYSTEM_
#endif

#include "dsoundi.h"

#endif // __BOOTSND_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\boot\sources.inc ===
!include ..\..\xbox.inc

C_DEFINES = $(C_DEFINES) -DDPF_LIBRARY=\"BOOTSND\"

SOURCES =\
    bootsnd.cpp
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\boot\bootsnd.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       bootsnd.cpp
 *  Content:    DirectSound bootsound source.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  06/19/01    dereks  Created.
 *
 ****************************************************************************/

#include "bootsnd.h"

#pragma comment(linker, "/merge:DSOUND_RW=DSOUND")
#pragma comment(linker, "/merge:DSOUND_RD=DSOUND")
#pragma comment(linker, "/section:INIT,ERW")

#include "..\dsound\dscommon.cpp"
#include "..\dsound\dsapi.cpp"
#include "..\dsound\mcpbuf.cpp"
#include "..\dsound\mcpapu.cpp"
#include "..\dsound\mcpvoice.cpp"
#include "..\dsound\mcpxcore.cpp"
#include "..\dsound\dspdma.cpp"
#include "..\dsound\gpdsp.cpp"
#include "..\dsound\heap.cpp"
#include "..\dsound\globals.c"
#include "..\ac97\ac97.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\ac97\ac97reg.h ===
//****************************************************************************
//****************************************************************************
//
// ac97reg.h
//
//
//
// Description:
// This file contains the codec register descriptions.
//
//
// Copyright (c) 2000 nVidia Corporation.
//
//****************************************************************************
//****************************************************************************




#ifndef _AC97REG_H_
#define _AC97REG_H_


//****************************************************************************
//****************************************************************************
//
// Defines
//
//****************************************************************************
//****************************************************************************

//
// These are the AC'97 registers found in the 2.1 specification.
//
typedef enum
{
    AC97REG_RESET = 0,
    AC97REG_FRONT_VOLUME,               // 0x02
    AC97REG_HEADPHONE_VOLUME,           // 0x04
    AC97REG_MONOOUT_VOLUME,             // 0x06
    AC97REG_MASTER_TONE,                // 0x08
    AC97REG_PCBEEP_VOLUME,              // 0x0a
    AC97REG_PHONE_VOLUME,               // 0x0c
    AC97REG_MIC_VOLUME,                 // 0x0e
    AC97REG_LINE_IN_VOLUME,             // 0x10
    AC97REG_CD_VOLUME,                  // 0x12
    AC97REG_VIDEO_VOLUME,               // 0x14
    AC97REG_AUX_VOLUME,                 // 0x16
    AC97REG_PCM_OUT_VOLUME,             // 0x18
    AC97REG_RECORD_SELECT,              // 0x1a
    AC97REG_RECORD_GAIN,                // 0x1c
    AC97REG_RECORD_GAIN_MIC,            // 0x1e
    AC97REG_GENERAL = 0x10,             // 0x20
    AC97REG_3D_CTRL,                    // 0x22
    AC97REG_RESERVED0,                  // 0x24
    AC97REG_POWERDOWN,                  // 0x26

    //
    // AC97 2.0 registers (0x28 - 0x3a)
    //
    AC97REG_EXT_AUDIO_ID,               // 0x28
    AC97REG_EXT_AUDIO_CTRL,             // 0x2a
    AC97REG_FRONT_RATE,                 // 0x2c
    AC97REG_SURR_RATE,                  // 0x2e
    AC97REG_LFE_RATE,                   // 0x30
    AC97REG_LR_RATE,                    // 0x32
    AC97REG_MIC_RATE,                   // 0x34
    AC97REG_6CH_VOL_CLFE,               // 0x36
    AC97REG_6CH_VOL_SURR,               // 0x38
    AC97REG_RESERVED1,                  // 0x3a

    //
    // Modem registers (0x3c - 0x58)
    //
    AC97REG_EXT_MODEM_ID,               // 0x3c
    AC97REG_EXT_MODEM_CTRL,             // 0x3e
    AC97REG_LINE1_RATE = 0x20,          // 0x40
    AC97REG_LINE2_RATE,                 // 0x42
    AC97REG_HANDSET_RATE,               // 0x44
    AC97REG_LINE1_LEVEL,                // 0x46
    AC97REG_LINE2_LEVEL,                // 0x48
    AC97REG_HANDSET_LEVEL,              // 0x4a
    AC97REG_GPIO_CONFIG,                // 0x4c
    AC97REG_GPIO_POLARITY,              // 0x4e
    AC97REG_GPIO_STICKY,                // 0x50
    AC97REG_GPIO_WAKEUP,                // 0x52
    AC97REG_GPIO_STATUS,                // 0x54
    AC97REG_MISC_MODEM_CTRL,            // 0x56
    AC97REG_RESERVED2,                  // 0x58

    //
    // Vendor reserved registers (0x5a - 0x7a)
    //
    AC97REG_VENDOR_RESERVED0,           // 0x5a
    AC97REG_VENDOR_RESERVED1,           // 0x5c
    AC97REG_VENDOR_RESERVED2,           // 0x5e
    AC97REG_VENDOR_RESERVED3 = 0x30,    // 0x60
    AC97REG_VENDOR_RESERVED4,           // 0x62
    AC97REG_VENDOR_RESERVED5,           // 0x64
    AC97REG_VENDOR_RESERVED6,           // 0x66
    AC97REG_VENDOR_RESERVED7,           // 0x68
    AC97REG_VENDOR_RESERVED8,           // 0x6a
    AC97REG_VENDOR_RESERVED9,           // 0x6c
    AC97REG_VENDOR_RESERVED10,          // 0x6e
    AC97REG_VENDOR_RESERVED11,          // 0x70
    AC97REG_VENDOR_RESERVED12,          // 0x72
    AC97REG_VENDOR_RESERVED13,          // 0x74
    AC97REG_VENDOR_RESERVED14,          // 0x76
    AC97REG_VENDOR_RESERVED15,          // 0x78
    AC97REG_VENDOR_RESERVED16,          // 0x7a

    //
    // Vendor IDs (0x7c - 0x7e)
    //
    AC97REG_VENDOR_ID1 = 0x3e,          // 0x7c
    AC97REG_VENDOR_ID2,                 // 0x7e


    AC97REG_INVALID
} AC97REGISTER;
#define FIRST_AC97REG       AC97REG_RESET
#define LAST_AC97REG        AC97REG_VENDOR_ID2
#define NUM_AC97REGS        AC97REG_INVALID


//
// Reset Register Bit Defines
//
#define AC97REG_RESET_VALUE                         0x0000

#define AC97REG_RESET_ID0                           0x0001  // Dedicated Mic In Channel
#define AC97REG_RESET_ID1                           0x0002  // Reserved
#define AC97REG_RESET_ID2                           0x0004  // Bass & Treble Control
#define AC97REG_RESET_ID3                           0x0008  // Simulated Stereo
#define AC97REG_RESET_ID4                           0x0010  // Headphone Out Support
#define AC97REG_RESET_ID5                           0x0020  // Loudness Support
#define AC97REG_RESET_ID6                           0x0040  // 18-bit DAC Resolution
#define AC97REG_RESET_ID7                           0x0080  // 20-bit DAC Resolution
#define AC97REG_RESET_ID8                           0x0100  // 18-bit ADC Resolution
#define AC97REG_RESET_ID9                           0x0200  // 20-bit ADC Resolution


//
// 3D Bits Defines
//
#define AC97REG_RESET_3D_MASK                       0x7c00
#define AC97REG_RESET_3D_SHIFT                      10

#define AC97REG_RESET_3D_NONE                       0x0000
#define AC97REG_RESET_3D_ANALOG_DEVICES             0x0400
#define AC97REG_RESET_3D_CREATIVE                   0x0800
#define AC97REG_RESET_3D_NATIONAL                   0x0c00
#define AC97REG_RESET_3D_YAMAHA                     0x1000
#define AC97REG_RESET_3D_BBE                        0x1400
#define AC97REG_RESET_3D_CRYSTAL                    0x1800
#define AC97REG_RESET_3D_QSOUND                     0x1c00
#define AC97REG_RESET_3D_SPATIALIZER                0x2000
#define AC97REG_RESET_3D_SRS                        0x2400
#define AC97REG_RESET_3D_PLATFORM_TECH              0x2800
#define AC97REG_RESET_3D_AKM                        0x2c00
#define AC97REG_RESET_3D_AUREAL                     0x3000
#define AC97REG_RESET_3D_AZTECH                     0x3400
#define AC97REG_RESET_3D_BINAURA                    0x3800
#define AC97REG_RESET_3D_ESS                        0x3c00
#define AC97REG_RESET_3D_HARMAN_INT                 0x4000
#define AC97REG_RESET_3D_NVIDIA                     0x4400
#define AC97REG_RESET_3D_PHILIPS                    0x4800
#define AC97REG_RESET_3D_TI                         0x4c00
#define AC97REG_RESET_3D_VLSI                       0x5000
#define AC97REG_RESET_3D_TRITECH                    0x5400
#define AC97REG_RESET_3D_REALTEK                    0x5800
#define AC97REG_RESET_3D_SAMSUNG                    0x5c00
#define AC97REG_RESET_3D_WOLFSON                    0x6000
#define AC97REG_RESET_3D_DELTA_INTEGRATION          0x6400
#define AC97REG_RESET_3D_SIGMATEL                   0x6800
#define AC97REG_RESET_3D_UNDEFINED0                 0x6c00
#define AC97REG_RESET_3D_ROCKWELL                   0x7000


//
// Volume most significant bit masks
//
#define AC97REG_VOLUME_LEFT_MSB_MASK                0x2000  // Determine bit resolution
#define AC97REG_VOLUME_RIGHT_MSB_MASK               0x0020  // Determine bit resolution
#define AC97REG_VOLUME_LEFT_MSB_UNSUPPORTED_MASK    0x1f00  // Mask off unsupported bits
#define AC97REG_VOLUME_RIGHT_MSB_UNSUPPORTED_MASK   0x001f  // Mask off unsupported bits


//
// Front Volume Register bit defines
//
#define AC97REG_FRONT_DEFAULT                       0x8000  // The default register value
#define AC97REG_FRONT_VOLUME_UNMUTED                0x0000  // The unmuted value
#define AC97REG_FRONT_MSB_MASK                      (AC97REG_VOLUME_LEFT_MSB_MASK | AC97REG_VOLUME_RIGHT_MSB_MASK)


//
// Headphone Volume Register bit defines
//
#define AC97REG_HEADPHONE_DEFAULT                   0x8000  // The default register value
#define AC97REG_HPHONE_MSB_MASK                     (AC97REG_VOLUME_LEFT_MSB_MASK | AC97REG_VOLUME_RIGHT_MSB_MASK)


//
// Master Mono Volume Register bit defines
//
#define AC97REG_MONOOUT_DEFAULT                     0x8000  // The default register value
#define AC97REG_MONOOUT_MSB_MASK                    AC97REG_VOLUME_RIGHT_MSB_MASK


//
// Tone Register bit defines
//
#define AC97REG_TONE_BYPASS_VALUE                   0x0f0f  // Tone bypass value
#define AC97REG_BASS_LSB_MASK                       0x0100  // Determine bit resolution
#define AC97REG_TREBLE_LSB_MASK                     0x0001  // Determine bit resolution


//
// PC BEEP Register bit defines
//
#define AC97REG_PCBEEP_DEFAULT                      0x8000  // The default register value


//
// Phone Register bit defines
//
#define AC97REG_PHONE_DEFAULT                       0x8008  // The default register value


//
// Video Register bit defines
//
#define AC97REG_VIDEO_DEFAULT                       0x8808  // The default register value


//
// Aux Register bit defines
//
#define AC97REG_AUX_DEFAULT                         0x8808  // The default register value


//
// Record Select Control Register bit defines
//
#define AC97REG_RSC_MIC                             0x0000  // Microphone
#define AC97REG_RSC_CD                              0x0001  // CD
#define AC97REG_RSC_VIDEO                           0x0002  // Video
#define AC97REG_RSC_AUX                             0x0003  // AUX
#define AC97REG_RSC_LINEIN                          0x0004  // Line In
#define AC97REG_RSC_STEREO_MIX                      0x0005  // Stereo Mix
#define AC97REG_RSC_MONO_MIX                        0x0006  // Mono Mix
#define AC97REG_RSC_PHONE                           0x0007  // Phone


//
// Record Gain Mic Register bit defines
//
#define AC97REG_RGM_DEFAULT                         0x8000  // The default register value


//
// General Purpose Register bit defines
//
#define AC97REG_GENERAL_DEFAULT                     0x0000  // The default register value
#define AC97REG_GENERAL_POP                         0x8000  // 3D Bypass bit
#define AC97REG_GENERAL_ST                          0x4000  // Simulated stereo bit
#define AC97REG_GENERAL_3D                          0x2000  // 3D stereo enable bit
#define AC97REG_GENERAL_LD                          0x1000  // Loudness bit
#define AC97REG_GENERAL_MIX                         0x0200  // Mix select bit
#define AC97REG_GENERAL_MS                          0x0100  // Mic Select bit


//
// 3D Stereo Enhancement Register bit defines
//
#define AC97REG_3DCTRL_DEPTH_MASK                   0x00ff  // Masks off center bits
#define AC97REG_3DCTRL_DEPTH_MASK1                  0x0000  // Determine if control is fixed
#define AC97REG_3DCTRL_DEPTH_MASK2                  0x000f  // Determine if control is fixed
#define AC97REG_3DCTRL_CENTER_MASK                  0xff00  // Masks off depth bits
#define AC97REG_3DCTRL_CENTER_MASK1                 0x0000  // Determine if control is fixed
#define AC97REG_3DCTRL_CENTER_MASK2                 0x0f00  // Determine if control is fixed


//
// Powerdown Control/Status Register bit defines
//
#define AC97REG_PCS_EAPD                            0x8000  // External Amp Powerdown
#define AC97REG_PCS_PR6                             0x4000  // Alt Line Output Buffer Powerdown
#define AC97REG_PCS_PR5                             0x2000  // Internal Clock Disable
#define AC97REG_PCS_PR4                             0x1000  // AC-Link Power Down (BIT_CLK off)
#define AC97REG_PCS_PR3                             0x0800  // Analog Mixer Off (Vref off)
#define AC97REG_PCS_PR2                             0x0400  // Analog Mixer Off (Vref still on)
#define AC97REG_PCS_PR1                             0x0200  // DACs Powerdown
#define AC97REG_PCS_PR0                             0x0100  // ADCs and Input Mux Powerdown

#define AC97REG_PCS_POWER_OFF                       0xff00
#define AC97REG_PCS_FULL_POWER                      0x0000

#define AC97REG_PCS_REF                             0x0008  // Vreg at nominal levels
#define AC97REG_PCS_ANL                             0x0004  // Mixer, Mux, and Volume ctrls ready
#define AC97REG_PCS_DAC                             0x0002  // DAC ready to accept data
#define AC97REG_PCS_ADC                             0x0001  // ADC ready to transmit data

#define AC97REG_PCS_STATUS_READY                    (AC97REG_PCS_REF | AC97REG_PCS_ANL | AC97REG_PCS_DAC | AC97REG_PCS_ADC)


//
// Extended Audio ID Register bit defines
//

//
// Codec Config Bits (Primary = 0x00, Secondary = 0x01, 0x10, 0x11)
//
#define AC97REG_EAID_ID1                            0x8000  // Codec config ID1 bit
#define AC97REG_EAID_ID0                            0x4000  // Codec config ID0 bit
#define AC97REG_EAID_CONFIG_MASK                    (AC97REG_EAID_ID1 | AC97REG_EAID_ID0)

#define AC97REG_EAID_AMAP                           0x0200  // Optional slot/DAC mappings bit

#define AC97REG_EAID_LDAC                           0x0100  // LFE DAC bit
#define AC97REG_EAID_SDAC                           0x0080  // Surround DAC bit
#define AC97REG_EAID_CDAC                           0x0040  // Center DAC bit
#define AC97REG_EAID_CHANNEL_MASK                   (AC97REG_EAID_LDAC | AC97REG_EAID_SDAC | AC97REG_EAID_CDAC)

#define AC97REG_EAID_VRM                            0x0008  // Variable Rate Mic input bit
#define AC97REG_EAID_DRA                            0x0002  // Double Rate bit
#define AC97REG_EAID_VRA                            0x0001  // Variable sample Rate bit
#define AC97REG_EAID_VARIABLE_RATE_MASK             (AC97REG_EAID_VRM | AC97REG_EAID_DRA | AC97REG_EAID_VRA)


//
// Extended Audio Status and Control Register bit defines
//
#define AC97REG_EASCR_PRL                           0x4000  // MIC ADC off
#define AC97REG_EASCR_PRK                           0x2000  // PCM LFE DAC off
#define AC97REG_EASCR_PRJ                           0x1000  // PCM Surround DAC off
#define AC97REG_EASCR_PRI                           0x0800  // PCM Center DAC off
#define AC97REG_EASCR_POWER_MASK                    (AC97REG_EASCR_PRI | AC97REG_EASCR_PRJ | AC97REG_EASCR_PRK | AC97REG_EASCR_PRL)

#define AC97REG_EASCR_MADC                          0x0200  // Mic ADC bit
#define AC97REG_EASCR_LDAC                          0x0100  // LFE DAC bit
#define AC97REG_EASCR_SDAC                          0x0080  // Surround DAC bit
#define AC97REG_EASCR_CDAC                          0x0040  // Center DAC bit

#define AC97REG_EASCR_VRM                           0x0008  // Variable Rate Mic input bit
#define AC97REG_EASCR_DRA                           0x0002  // Double Rate bit
#define AC97REG_EASCR_VRA                           0x0001  // Variable sample Rate bit

//
// Double Rate Bit Mask
//
#define AC97REG_DR_MASK                             0xffff0000

//
// Default Audio Sample Rate
//
#define AC97REG_ASRC_DEFAULT                        0xbb80

//
// Default Six Channel Volume Control Value
//
#define AC97REG_6CVC_DEFAULT                        0x8080
#define AC97REG_CENTER_MUTE_MASK                    0x0080
#define AC97REG_LFE_MUTE_MASK                       0x8000


//
// Extended Modem ID Register Bits
//
#define AC97REG_EMID_INVALID                        0xffff  // Register is not supported


//
// Codec ID Register Bits
//
#define AC97REG_VID_MASK                            0xffff  // Allow all ID bits
#define AC97REG_VID1_F_MASK                         0xff00  // First character of ID
#define AC97REG_VID1_S_MASK                         0x00ff  // Second character of ID
#define AC97REG_VID2_T_MASK                         0xff00  // Third character of ID
#define AC97REG_VID2_REV_MASK                       0x00ff  // Revision ID mask

//
// Codec IDs
//
#define AC97REG_VID1_ADI                            0x4144  // "AD"I ID1
#define AC97REG_VID2_ADI                            0x5300  // AD"I" ID2
#define AC97REG_VID2_ADI_REVISION_MASK              0x00ff  // Rev ID Mask
#define AC97REG_VID2_ADI_REV_1881                   0x0040  // ADI1881
#define AC97REG_VID2_ADI_REV_1885                   0x0060  // ADI1885

#define AC97REG_VID1_CRYSTAL                        0x4352  // "CR"ystal ID1
#define AC97REG_VID2_CRYSTAL                        0x5900  // Cr"Y"stal ID2
#define AC97REG_VID2_CRYSTAL_PID_MASK               0x0070  // Part ID Mask
#define AC97REG_VID2_CRYSTAL_RID_MASK               0x0070  // Rev ID Mask
#define AC97REG_VID2_CRYSTAL_PID_4297               0x0000  // CS4297
#define AC97REG_VID2_CRYSTAL_PID_4297A              0x0010  // CS4297A
#define AC97REG_VID2_CRYSTAL_PID_4294C              0x0020  // CS4294 Rev C
#define AC97REG_VID2_CRYSTAL_PID_4298               0x0020  // CS4298
#define AC97REG_VID2_CRYSTAL_PID_4299               0x0030  // CS4299
#define AC97REG_VID2_CRYSTAL_PID_4201               0x0040  // CS4201



#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\ac97\acireg.h ===
/***************************************************************************
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       acireg.h
 *  Content:    ACI registers.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  09/27/00    dereks  Created based on NVidia code.
 *
 ****************************************************************************/

#ifndef __ACIREG_H__
#define __ACIREG_H__

//
// Memory-mapped IO offsets
//

#define AC97_MIO_BASE       0x0000      // AC'97 base offset
#define ACI_MIO_BASE        0x0100      // ACI base offset

//
// DMA channel relative offsets.
//

#define AO_BL_BASE          0x0010      // audio out buffer list offset
#define SO_BL_BASE          0x0070      // SP/DIF out buffer list offset

//
// Defines for base-relative bus master register access
//

#define X_BL_BASE           0x0000      // Buffer List Base Address
#define X_CUR_IDX           0x0004      // Current Index
#define X_LST_IDX           0x0005      // Last Valid Index
#define X_STATUS            0x0006      // Status Register
#define X_CUR_POS           0x0008      // Current Position
#define X_NXT_IDX           0x000a      // Next Index
#define X_CTRL              0x000b      // Control
#define X_STWD              0x000c      // Channel status word (SPDIF only)

//
// DMA Status Register bit defines
//

#define X_STATUS_FIFOE      0x0010      // FIFO Error
#define X_STATUS_BCI        0x0008      // Buffer Completion Interrupt
#define X_STATUS_LVBCI      0x0004      // Last Valid Buffer Completion Interrupt
#define X_STATUS_CIELV      0x0002      // Current Index Equals Last Valid
#define X_STATUS_DCH        0x0001      // DMA Controller Halted

//
// DMA Control Register bit defines
//

#define X_CTRL_IOCE         0x10        // Interrupt On Completion Enable
#define X_CTRL_FEIE         0x08        // FIFO Error Interrupt Enable
#define X_CTRL_LVBIE        0x04        // Last Valid Buffer Interrupt Enable
#define X_CTRL_RBMR         0x02        // Reset Bus Master Registers
#define X_CTRL_RPBM         0x01        // Run/Pause Bus Master

//
// Global Control Register
//

#define GLB_CTRL            0x002c

//
// Global Control bit defines
//

#define GLB_CTRL_SRIE       0x00000020  // Secondary Resume Interrupt Enable
#define GLB_CTRL_PRIE       0x00000010  // Primary Resume Interrupt Enable
#define GLB_CTRL_ACSD       0x00000008  // AC-link Shut Down
#define GLB_CTRL_WARM       0x00000004  // AC97 Warm Reset
#define GLB_CTRL_COLD       0x00000002  // AC97 Cold Reset
#define GLB_CTRL_GIE        0x00000001  // GPIO Interrupt Enable

//
// Global Status Register
//

#define GLB_STATUS          0x0030

//
// Global Status bit defines
//

#define GLB_STATUS_MD3      0x00020000  // Power Down Semaphore for Modem
#define GLB_STATUS_AD3      0x00010000  // Power Down Semaphore for Audio
#define GLB_STATUS_RCS      0x00008000  // Read Completion Status
#define GLB_STATUS_B3S12    0x00004000  // Bit 3 Slot 12
#define GLB_STATUS_B2S12    0x00002000  // Bit 2 Slot 12
#define GLB_STATUS_B1S12    0x00001000  // Bit 1 Slot 12
#define GLB_STATUS_SRI      0x00000800  // Secondary Resume Interrupt
#define GLB_STATUS_PRI      0x00000400  // Primary Resume Interrupt
#define GLB_STATUS_SCR      0x00000200  // Secondary Codec Ready
#define GLB_STATUS_PCR      0x00000100  // Primary Codec Ready
#define GLB_STATUS_AOINT    0x00000040  // Audio Out Interrupt
#define GLB_STATUS_SOINT    0x00000010  // SP/DIF Out Interrupt
#define GLB_STATUS_GPINT    0x00000001  // GPIO Interrupt

//
// AC97 Register Semaphore
//

#define AC97_SEM4           0x0034

//
// AC97 Register Semaphore bit defines
//

#define AC97_SEM4_OWNED     0x01        // AC97 Semaphore Owned

//
// Physical region descriptor
//

typedef struct
{
    DWORD   dwPhysicalAddress;
    DWORD   wLength                 : 16;
    DWORD   wReserved               : 14;
    BOOL    fBufferUnderrunPolicy   : 1;
    BOOL    fInterruptOnCompletion  : 1;
} ACIPRD, *LPACIPRD;

//
// Physical region descriptor list
//

#define ACIPRDL_ENTRY_COUNT 32
#define ACIPRDL_ENTRY_SHIFT 5
#define ACIPRDL_ENTRY_MASK  0x1F

//
// SP/DIF STWD values
//

#define SPDIF_STWD_SURROUND 0x02000000
#define SPDIF_STWD_AC3      0x02000002

#endif // __ACIREG_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\adpcm\imaadpcm.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       CImaAdpcmCodec::.cpp
 *  Content:    IMA ADPCM CODEC.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  10/26/00    dereks  Created.
 *
 ****************************************************************************/

#include "dsoundi.h"

DEFINEREFTYPE(IMAADPCMWAVEFORMAT);
DEFINELPCTYPE(BYTE);
DEFINELPTYPE(SHORT);

#define IMAADPCM_BITS_PER_SAMPLE    4
#define IMAADPCM_HEADER_LENGTH      4

//
// IMA ADPCM encoder function prototype
//

typedef BOOL (*LPFNIMAADPCMCONVERT)(LPBYTE pbSrc, LPBYTE pbDst, UINT cBlocks, UINT nBlockAlignment, UINT cSamplesPerBlock, LPINT pnStepIndexL, LPINT pnStepIndexR);

//
// IMA ADPCM CODEC
//

class CImaAdpcmCodec
{
protected:
    IMAADPCMWAVEFORMAT      m_wfxEncode;                // Encoded format description
    BOOL                    m_fEncoder;                 // Is the object acting as an encoder?
    INT                     m_nStepIndexL;              // Left-channel stepping index
    INT                     m_nStepIndexR;              // Right-channel stepping index

private:
    static const SHORT      m_asNextStep[16];           // Step increment array
    static const SHORT      m_asStep[89];               // Step value array

private:
    LPFNIMAADPCMCONVERT     m_pfnConvert;               // Conversion function

public:
    CImaAdpcmCodec(void);
    ~CImaAdpcmCodec(void);

public:
    // Initialization
    void Initialize(REFIMAADPCMWAVEFORMAT wfxEncode, BOOL fEncoder);

    // Size conversions
    WORD GetEncodeAlignment(void);
    WORD GetDecodeAlignment(void);

    // Data conversions
    BOOL Convert(LPCVOID pvSrc, LPVOID pvDst, UINT cBlocks);

    // Format descriptions
    static void CreatePcmFormat(WORD nChannels, DWORD nSamplesPerSec, LPWAVEFORMATEX pwfxFormat);
    static void CreateImaAdpcmFormat(WORD nChannels, DWORD nSamplesPerSec, WORD nSamplesPerBlock, WORD nAlignmentMultiplier, LPIMAADPCMWAVEFORMAT pwfxFormat);

private:
    // En/decoded data alignment
    static WORD CalculateEncodeAlignment(WORD nSamplesPerBlock, WORD nChannels, WORD nAlignmentMultiplier);
    
    // Data conversion functions
    static BOOL EncodeM16(LPBYTE pbSrc, LPBYTE pbDst, UINT cBlocks, UINT nBlockAlignment, UINT cSamplesPerBlock, LPINT pnStepIndexL, LPINT pnStepIndexR);
    static BOOL EncodeS16(LPBYTE pbSrc, LPBYTE pbDst, UINT cBlocks, UINT nBlockAlignment, UINT cSamplesPerBlock, LPINT pnStepIndexL, LPINT pnStepIndexR);
    static BOOL DecodeM16(LPBYTE pbSrc, LPBYTE pbDst, UINT cBlocks, UINT nBlockAlignment, UINT cSamplesPerBlock, LPINT pnStepIndexL, LPINT pnStepIndexR);
    static BOOL DecodeS16(LPBYTE pbSrc, LPBYTE pbDst, UINT cBlocks, UINT nBlockAlignment, UINT cSamplesPerBlock, LPINT pnStepIndexL, LPINT pnStepIndexR);

    static INT EncodeSample(INT nInputSample, INT *nPredictedSample, INT nStepSize);
    static INT DecodeSample(INT nInputSample, INT nPredictedSample, INT nStepSize);

    static INT NextStepIndex(INT nEncodedSample, INT nStepIndex);
    static BOOL ValidStepIndex(INT nStepIndex);
};

__inline INT CImaAdpcmCodec::NextStepIndex(INT nEncodedSample, INT nStepIndex)
{
    nStepIndex += m_asNextStep[nEncodedSample];

    if(nStepIndex < 0)
    {
        nStepIndex = 0;
    }
    else if(nStepIndex >= NUMELMS(m_asStep))
    {
        nStepIndex = NUMELMS(m_asStep) - 1;
    }

    return nStepIndex;
}

__inline BOOL CImaAdpcmCodec::ValidStepIndex(INT nStepIndex)
{
    return (nStepIndex >= 0) && (nStepIndex < NUMELMS(m_asStep));
}

//
// IMA ADPCM Media Object implementation
//

class CImaAdpcmMediaObject
    : public XMediaObject, private CImaAdpcmCodec
{
    STDNEWDELETE

protected:
    ULONG                   m_ulRefCount;       // Object reference count

public:
    CImaAdpcmMediaObject(void);
    virtual ~CImaAdpcmMediaObject(void);

public:
    // Initialization
    void STDMETHODCALLTYPE Initialize(REFIMAADPCMWAVEFORMAT wfxEncode, BOOL fEncoder);
    
    // IUnknown methods
    virtual ULONG STDMETHODCALLTYPE AddRef(void);
    virtual ULONG STDMETHODCALLTYPE Release(void);

    // XMediaObject methods
    virtual HRESULT STDMETHODCALLTYPE GetInfo(LPXMEDIAINFO pInfo);
    virtual HRESULT STDMETHODCALLTYPE GetStatus(LPDWORD pdwStatus);
    virtual HRESULT STDMETHODCALLTYPE Process(LPCXMEDIAPACKET pxmbInput, LPCXMEDIAPACKET pxmbOutput);
    virtual HRESULT STDMETHODCALLTYPE Discontinuity(void);
    virtual HRESULT STDMETHODCALLTYPE Flush(void);

protected:
    // Size conversions
    WORD GetInputAlignment(void);
    WORD GetOutputAlignment(void);
};    

__inline void CImaAdpcmMediaObject::Initialize(REFIMAADPCMWAVEFORMAT wfxEncode, BOOL fEncoder)
{
    CImaAdpcmCodec::Initialize(wfxEncode, fEncoder);
}

__inline WORD CImaAdpcmMediaObject::GetInputAlignment(void)
{
    return m_fEncoder ? GetDecodeAlignment() : GetEncodeAlignment();
}

__inline WORD CImaAdpcmMediaObject::GetOutputAlignment(void)
{
    return m_fEncoder ? GetEncodeAlignment() : GetDecodeAlignment();
}


/****************************************************************************
 *
 *  CImaAdpcmCodec
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImaAdpcmCodec::CImaAdpcmCodec"

//
// This array is used by NextStepIndex to determine the next step index to use.  
// The step index is an index to the m_asStep[] array, below.
//

const SHORT CImaAdpcmCodec::m_asNextStep[16] =
{
    -1, -1, -1, -1, 2, 4, 6, 8,
    -1, -1, -1, -1, 2, 4, 6, 8
};

//
// This array contains the array of step sizes used to encode the ADPCM
// samples.  The step index in each ADPCM block is an index to this array.
//

const SHORT CImaAdpcmCodec::m_asStep[89] =
{
        7,     8,     9,    10,    11,    12,    13,
       14,    16,    17,    19,    21,    23,    25,
       28,    31,    34,    37,    41,    45,    50,
       55,    60,    66,    73,    80,    88,    97,
      107,   118,   130,   143,   157,   173,   190,
      209,   230,   253,   279,   307,   337,   371,
      408,   449,   494,   544,   598,   658,   724,
      796,   876,   963,  1060,  1166,  1282,  1411,
     1552,  1707,  1878,  2066,  2272,  2499,  2749,
     3024,  3327,  3660,  4026,  4428,  4871,  5358,
     5894,  6484,  7132,  7845,  8630,  9493, 10442,
    11487, 12635, 13899, 15289, 16818, 18500, 20350,
    22385, 24623, 27086, 29794, 32767
};

CImaAdpcmCodec::CImaAdpcmCodec
(
    void
)
{
    DPF_ENTER();
    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  ~CImaAdpcmCodec
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImaAdpcmCodec::~CImaAdpcmCodec"

CImaAdpcmCodec::~CImaAdpcmCodec
(
    void
)
{
    DPF_ENTER();
    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  Initialize
 *
 *  Description:
 *      Initializes the object.
 *
 *  Arguments:
 *      REFIMAADPCMWAVEFORMAT [in]: encoded data format.
 *      BOOL [in]: TRUE to initialize the object as an encoder.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImaAdpcmCodec::Initialize"

void
CImaAdpcmCodec::Initialize
(
    REFIMAADPCMWAVEFORMAT               wfxEncode, 
    BOOL                                fEncoder
)
{
    static const LPFNIMAADPCMCONVERT    apfnConvert[2][2] = 
    { 
        {
            DecodeM16,
            DecodeS16 
        },
        {
            EncodeM16,
            EncodeS16 
        }
    };
    
    DPF_ENTER();

    ASSERT(wfxEncode.wfx.nChannels <= 2);

    //
    // Save the format data
    //

    m_wfxEncode = wfxEncode;
    m_fEncoder = fEncoder;

    //
    // Set up the conversion function
    //

    m_pfnConvert = apfnConvert[!!fEncoder][wfxEncode.wfx.nChannels - 1];

    //
    // Initialize the stepping indeces
    //

    m_nStepIndexL = m_nStepIndexR = 0;

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  Convert
 *
 *  Description:
 *      Converts data from the source to destination format.
 *
 *  Arguments:
 *      LPCVOID [in]: source buffer.
 *      LPVOID [out]: destination buffer.
 *      UINT [in]: block count.
 *
 *  Returns:  
 *      BOOL: TRUE on success.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImaAdpcmCodec::Convert"

__inline
BOOL
CImaAdpcmCodec::Convert
(
    LPCVOID                 pvSrc,
    LPVOID                  pvDst,
    UINT                    cBlocks
)
{
    return m_pfnConvert((LPBYTE)pvSrc, (LPBYTE)pvDst, cBlocks, m_wfxEncode.wfx.nBlockAlign, m_wfxEncode.wSamplesPerBlock, &m_nStepIndexL, &m_nStepIndexR);
}


/****************************************************************************
 *
 *  GetEncodeAlignment
 *
 *  Description:
 *      Gets the alignment of an encoded buffer.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      WORD: alignment, in bytes.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImaAdpcmCodec::GetEncodeAlignment"

__inline WORD
CImaAdpcmCodec::GetEncodeAlignment
(
    void
)
{
    return m_wfxEncode.wfx.nBlockAlign;
}


/****************************************************************************
 *
 *  GetDecodeAlignment
 *
 *  Description:
 *      Gets the alignment of a decoded buffer.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      DWORD: alignment, in bytes.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImaAdpcmCodec::GetDecodeAlignment"

__inline WORD
CImaAdpcmCodec::GetDecodeAlignment
(
    void
)
{
    return m_wfxEncode.wSamplesPerBlock * m_wfxEncode.wfx.nChannels * 2;
}


/****************************************************************************
 *
 *  CalculateEncodeAlignment
 *
 *  Description:
 *      Calculates an encoded data block alignment based on a PCM sample
 *      count and an alignment multiplier.
 *
 *  Arguments:
 *      WORD [in]: channel count.
 *      WORD [in]: PCM samples per block.
 *      WORD [in]: encoded data alignment multiplier, in bytes.
 *
 *  Returns:  
 *      WORD: alignment, in bytes.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImaAdpcmCodec::CalculateEncodeAlignment"

__inline WORD
CImaAdpcmCodec::CalculateEncodeAlignment
(
    WORD                    nChannels,
    WORD                    nSamplesPerBlock,
    WORD                    nAlignmentMultiplier
)
{
    const WORD              nEncodedSampleBits  = nChannels * IMAADPCM_BITS_PER_SAMPLE;
    const WORD              nHeaderBytes        = nChannels * IMAADPCM_HEADER_LENGTH;
    WORD                    nBlockAlign;

    //
    // Calculate the raw block alignment that nSamplesPerBlock dictates.  This
    // value may include a partial encoded sample, so be sure to round up.
    //
    // Start with the samples-per-block, minus 1.  The first sample is actually
    // stored in the header.
    //

    nBlockAlign = nSamplesPerBlock - 1;

    //
    // Convert to encoded sample size
    //

    nBlockAlign *= nEncodedSampleBits;
    nBlockAlign += 7;
    nBlockAlign /= 8;

    //
    // The stereo encoder requires that there be at least two DWORDs to process
    //

    nBlockAlign += 7;
    nBlockAlign /= 8;
    nBlockAlign *= 8;

    //
    // Add the header
    //

    nBlockAlign += nHeaderBytes;

    //
    // Align the alignment, again rounding up.  The added amount will be
    // treated as padding by the en/decode routines.
    //

    if(nAlignmentMultiplier > 1)
    {
        nBlockAlign += nAlignmentMultiplier - 1;
        nBlockAlign /= nAlignmentMultiplier;
        nBlockAlign *= nAlignmentMultiplier;
    }

    return nBlockAlign;
}


/****************************************************************************
 *
 *  CreatePcmFormat
 *
 *  Description:
 *      Creates a PCM format descriptor.
 *
 *  Arguments:
 *      WORD [in]: channel count.
 *      DWORD [in]: sampling rate.
 *      LPWAVEFORMATEX [out]: format descriptor.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImaAdpcmCodec::CreatePcmFormat"

__inline
void
CImaAdpcmCodec::CreatePcmFormat
(
    WORD                    nChannels, 
    DWORD                   nSamplesPerSec, 
    LPWAVEFORMATEX          pwfx
)
{
    pwfx->wFormatTag = WAVE_FORMAT_PCM;
    pwfx->nChannels = nChannels;
    pwfx->nSamplesPerSec = nSamplesPerSec;
    pwfx->nBlockAlign = nChannels * 2;
    pwfx->nAvgBytesPerSec = pwfx->nBlockAlign * pwfx->nSamplesPerSec;
    pwfx->wBitsPerSample = 16;
    pwfx->cbSize = 0;
}


/****************************************************************************
 *
 *  CreateImaAdpcmFormat
 *
 *  Description:
 *      Creates an IMA ADPCM format descriptor.
 *
 *  Arguments:
 *      WORD [in]: channel count.
 *      DWORD [in]: sampling rate.
 *      LPIMAADPCMWAVEFORMAT [out]: format descriptor.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImaAdpcmCodec::CreateImaAdpcmFormat"

__inline
void
CImaAdpcmCodec::CreateImaAdpcmFormat
(
    WORD                    nChannels, 
    DWORD                   nSamplesPerSec, 
    WORD                    nSamplesPerBlock,
    WORD                    nAlignmentMultiplier,
    LPIMAADPCMWAVEFORMAT    pwfx
)
{
    pwfx->wfx.wFormatTag = WAVE_FORMAT_IMA_ADPCM;
    pwfx->wfx.nChannels = nChannels;
    pwfx->wfx.nSamplesPerSec = nSamplesPerSec;
    pwfx->wfx.nBlockAlign = CalculateEncodeAlignment(nChannels, nSamplesPerBlock, nAlignmentMultiplier);
    pwfx->wfx.nAvgBytesPerSec = nSamplesPerSec * pwfx->wfx.nBlockAlign / nSamplesPerBlock;
    pwfx->wfx.wBitsPerSample = IMAADPCM_BITS_PER_SAMPLE;
    pwfx->wfx.cbSize = sizeof(*pwfx) - sizeof(pwfx->wfx);
    pwfx->wSamplesPerBlock = nSamplesPerBlock;
}


/****************************************************************************
 *
 *  EncodeSample
 *
 *  Description:
 *      Encodes a sample.
 *
 *  Arguments:
 *      INT [in]: the sample to be encoded.
 *      LPINT [in/out]: the predicted value of the sample.
 *      INT [in]: the quantization step size used to encode the sample.
 *
 *  Returns:  
 *      INT: the encoded ADPCM sample.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImaAdpcmCodec::EncodeSample"

__inline INT
CImaAdpcmCodec::EncodeSample
(
    INT                 nInputSample,
    LPINT               pnPredictedSample,
    INT                 nStepSize
)
{
    INT                 nPredictedSample;
    LONG                lDifference;
    INT                 nEncodedSample;
    
    DPF_ENTER();

    nPredictedSample = *pnPredictedSample;

    lDifference = nInputSample - nPredictedSample;
    nEncodedSample = 0;

    if(lDifference < 0) 
    {
        nEncodedSample = 8;
        lDifference = -lDifference;
    }

    if(lDifference >= nStepSize)
    {
        nEncodedSample |= 4;
        lDifference -= nStepSize;
    }

    nStepSize >>= 1;

    if(lDifference >= nStepSize)
    {
        nEncodedSample |= 2;
        lDifference -= nStepSize;
    }

    nStepSize >>= 1;

    if(lDifference >= nStepSize)
    {
        nEncodedSample |= 1;
        lDifference -= nStepSize;
    }

    if(nEncodedSample & 8)
    {
        nPredictedSample = nInputSample + lDifference - (nStepSize >> 1);
    }
    else
    {
        nPredictedSample = nInputSample - lDifference + (nStepSize >> 1);
    }

    if(nPredictedSample > 32767)
    {
        nPredictedSample = 32767;
    }
    else if(nPredictedSample < -32768)
    {
        nPredictedSample = -32768;
    }

    *pnPredictedSample = nPredictedSample;
    
    DPF_LEAVE(nEncodedSample);
    
    return nEncodedSample;
}


/****************************************************************************
 *
 *  DecodeSample
 *
 *  Description:
 *      Decodes an encoded sample.
 *
 *  Arguments:
 *      INT [in]: the sample to be decoded.
 *      INT [in]: the predicted value of the sample.
 *      INT [i]: the quantization step size used to encode the sample.
 *
 *  Returns:  
 *      INT: the decoded PCM sample.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImaAdpcmCodec::DecodeSample"

__inline INT
CImaAdpcmCodec::DecodeSample
(
    INT                 nEncodedSample,
    INT                 nPredictedSample,
    INT                 nStepSize
)
{
    LONG                lDifference;
    LONG                lNewSample;

    DPF_ENTER();

    lDifference = nStepSize >> 3;

    if(nEncodedSample & 4) 
    {
        lDifference += nStepSize;
    }

    if(nEncodedSample & 2) 
    {
        lDifference += nStepSize >> 1;
    }

    if(nEncodedSample & 1) 
    {
        lDifference += nStepSize >> 2;
    }

    if(nEncodedSample & 8)
    {
        lDifference = -lDifference;
    }

    lNewSample = nPredictedSample + lDifference;

    if((LONG)(SHORT)lNewSample != lNewSample)
    {
        if(lNewSample < -32768)
        {
            lNewSample = -32768;
        }
        else
        {
            lNewSample = 32767;
        }
    }

    DPF_LEAVE(lNewSample);

    return (INT)lNewSample;
}


/****************************************************************************
 *
 *  Conversion Routines
 *
 *  Description:
 *      Converts a PCM buffer to ADPCM, or the reverse.
 *
 *  Arguments:
 *      LPBYTE [in]: source buffer.
 *      LPBYTE [out]: destination buffer.
 *      UINT [in]: block count.
 *      UINT [in]: block alignment of the ADPCM data, in bytes.
 *      UINT [in]: the number of samples in each ADPCM block (not used in
 *                 decoding).
 *      LPINT [in/out]: left-channel stepping index.
 *      LPINT [in/out]: right-channel stepping index.
 *
 *  Returns:  
 *      BOOL: TRUE on success.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImaAdpcmCodec::EncodeM16"

BOOL
CImaAdpcmCodec::EncodeM16
(
    LPBYTE                  pbSrc,
    LPBYTE                  pbDst,
    UINT                    cBlocks,
    UINT                    nBlockAlignment,
    UINT                    cSamplesPerBlock,
    LPINT                   pnStepIndexL,
    LPINT                   pnStepIndexR
)
{
    LPBYTE                  pbBlock;
    UINT                    cSamples;
    INT                     nSample;
    INT                     nStepSize;
    INT                     nEncSample1;
    INT                     nEncSample2;
    INT                     nPredSample;
    INT                     nStepIndex;

    //
    // Save a local copy of the step index so we're not constantly 
    // dereferencing a pointer.
    //
    
    nStepIndex = *pnStepIndexL;

    //
    // Enter the main loop
    //
    
    while(cBlocks--)
    {
        pbBlock = pbDst;
        cSamples = cSamplesPerBlock - 1;

        //
        // Block header
        //

        nPredSample = *(LPSHORT)pbSrc;
        pbSrc += sizeof(SHORT);

        *(LONG *)pbBlock = MAKELONG(nPredSample, nStepIndex);
        pbBlock += sizeof(LONG);

        //
        // We have written the header for this block--now write the data
        // chunk (which consists of a bunch of encoded nibbles).  Note
        // that if we don't have enough data to fill a complete byte, then
        // we add a 0 nibble on the end.
        //

        while(cSamples)
        {
            //
            // Sample 1
            //

            nSample = *(LPSHORT)pbSrc;
            pbSrc += sizeof(SHORT);
            cSamples--;

            nStepSize = m_asStep[nStepIndex];
            nEncSample1 = EncodeSample(nSample, &nPredSample, nStepSize);
            nStepIndex = NextStepIndex(nEncSample1, nStepIndex);

            //
            // Sample 2
            //

            if(cSamples)
            {
                nSample = *(LPSHORT)pbSrc;
                pbSrc += sizeof(SHORT);
                cSamples--;

                nStepSize = m_asStep[nStepIndex];
                nEncSample2 = EncodeSample(nSample, &nPredSample, nStepSize);
                nStepIndex = NextStepIndex(nEncSample2, nStepIndex);
            }
            else
            {
                nEncSample2 = 0;
            }

            //
            // Write out encoded byte.
            //

            *pbBlock++ = (BYTE)(nEncSample1 | (nEncSample2 << 4));
        }

        //
        // Skip padding
        //

        pbDst += nBlockAlignment;
    }

    //
    // Restore the value of the step index to be used on the next buffer.
    //

    *pnStepIndexL = nStepIndex;

    DPF_LEAVE(TRUE);
    
    return TRUE;
}


#undef DPF_FNAME
#define DPF_FNAME "CImaAdpcmCodec::EncodeS16"

BOOL
CImaAdpcmCodec::EncodeS16
(
    LPBYTE                  pbSrc,
    LPBYTE                  pbDst,
    UINT                    cBlocks,
    UINT                    nBlockAlignment,
    UINT                    cSamplesPerBlock,
    LPINT                   pnStepIndexL,
    LPINT                   pnStepIndexR
)
{
    LPBYTE                  pbBlock;
    UINT                    cSamples;
    UINT                    cSubSamples;
    INT                     nSample;
    INT                     nStepSize;
    DWORD                   dwLeft;
    DWORD                   dwRight;
    INT                     nEncSampleL;
    INT                     nPredSampleL;
    INT                     nStepIndexL;
    INT                     nEncSampleR;
    INT                     nPredSampleR;
    INT                     nStepIndexR;
    UINT                    i;

    //
    // Save a local copy of the step indeces so we're not constantly 
    // dereferencing a pointer.
    //
    
    nStepIndexL = *pnStepIndexL;
    nStepIndexR = *pnStepIndexR;

    //
    // Enter the main loop
    //
    
    while(cBlocks--)
    {
        pbBlock = pbDst;
        cSamples = cSamplesPerBlock - 1;

        //
        // LEFT channel block header
        //

        nPredSampleL = *(LPSHORT)pbSrc;
        pbSrc += sizeof(SHORT);

        *(LONG *)pbBlock = MAKELONG(nPredSampleL, nStepIndexL);
        pbBlock += sizeof(LONG);

        //
        // RIGHT channel block header
        //

        nPredSampleR = *(LPSHORT)pbSrc;
        pbSrc += sizeof(SHORT);

        *(LONG *)pbBlock = MAKELONG(nPredSampleR, nStepIndexR);
        pbBlock += sizeof(LONG);

        //
        // We have written the header for this block--now write the data
        // chunk.  This consists of 8 left samples (one DWORD of output)
        // followed by 8 right samples (also one DWORD).  Since the input
        // samples are interleaved, we create the left and right DWORDs
        // sample by sample, and then write them both out.
        //

        while(cSamples)
        {
            dwLeft = 0;
            dwRight = 0;

            cSubSamples = min(cSamples, 8);

            for(i = 0; i < cSubSamples; i++)
            {
                //
                // LEFT channel
                //

                nSample = *(LPSHORT)pbSrc;
                pbSrc += sizeof(SHORT);

                nStepSize = m_asStep[nStepIndexL];
                
                nEncSampleL = EncodeSample(nSample, &nPredSampleL, nStepSize);

                nStepIndexL = NextStepIndex(nEncSampleL, nStepIndexL);
                dwLeft |= (DWORD)nEncSampleL << (4 * i);

                //
                // RIGHT channel
                //

                nSample = *(LPSHORT)pbSrc;
                pbSrc += sizeof(SHORT);

                nStepSize = m_asStep[nStepIndexR];
                
                nEncSampleR = EncodeSample(nSample, &nPredSampleR, nStepSize);

                nStepIndexR = NextStepIndex(nEncSampleR, nStepIndexR);
                dwRight |= (DWORD)nEncSampleR << (4 * i);
            }

            //
            // Write out encoded DWORDs.
            //

            *(LPDWORD)pbBlock = dwLeft;
            pbBlock += sizeof(DWORD);

            *(LPDWORD)pbBlock = dwRight;
            pbBlock += sizeof(DWORD);

            cSamples -= cSubSamples;
        }

        //
        // Skip padding
        //

        pbDst += nBlockAlignment;
    }

    //
    // Restore the value of the step index to be used on the next buffer.
    //
    
    *pnStepIndexL = nStepIndexL;
    *pnStepIndexR = nStepIndexR;

    DPF_LEAVE(TRUE);
    
    return TRUE;

}


#undef DPF_FNAME
#define DPF_FNAME "CImaAdpcmCodec::DecodeM16"

BOOL
CImaAdpcmCodec::DecodeM16   
(
    LPBYTE                  pbSrc,
    LPBYTE                  pbDst,
    UINT                    cBlocks,
    UINT                    nBlockAlignment,
    UINT                    cSamplesPerBlock,
    LPINT                   pnStepIndexL,
    LPINT                   pnStepIndexR
)
{
    BOOL                    fSuccess    = TRUE;
    LPBYTE                  pbBlock;
    UINT                    cSamples;
    BYTE                    bSample;
    INT                     nStepSize;
    INT                     nEncSample;
    INT                     nPredSample;
    INT                     nStepIndex;
    DWORD                   dwHeader;

    DPF_ENTER();

    //
    // Enter the main loop
    //
    
    while(cBlocks--)
    {
        pbBlock = pbSrc;
        cSamples = cSamplesPerBlock - 1;
        
        //
        // Block header
        //

        dwHeader = *(LPDWORD)pbBlock;
        pbBlock += sizeof(DWORD);

        nPredSample = (INT)(SHORT)LOWORD(dwHeader);
        nStepIndex = (INT)(BYTE)HIWORD(dwHeader);

        if(!ValidStepIndex(nStepIndex))
        {
            //
            // The step index is out of range - this is considered a fatal
            // error as the input stream is corrupted.  We fail by returning
            // zero bytes converted.
            //

            DPF_ERROR("invalid step index %lu", nStepIndex);
            fSuccess = FALSE;
            break;
        }
        
        //
        // Write out first sample
        //

        *(LPSHORT)pbDst = (SHORT)nPredSample;
        pbDst += sizeof(SHORT);

        //
        // Enter the block loop
        //

        while(cSamples)
        {
            bSample = *pbBlock++;

            //
            // Sample 1
            //

            nEncSample = (bSample & (BYTE)0x0F);
            nStepSize = m_asStep[nStepIndex];
            nPredSample = DecodeSample(nEncSample, nPredSample, nStepSize);
            nStepIndex = NextStepIndex(nEncSample, nStepIndex);

            *(LPSHORT)pbDst = (SHORT)nPredSample;
            pbDst += sizeof(SHORT);

            cSamples--;

            //
            // Sample 2
            //

            if(cSamples)
            {
                nEncSample = (bSample >> 4);
                nStepSize = m_asStep[nStepIndex];
                nPredSample = DecodeSample(nEncSample, nPredSample, nStepSize);
                nStepIndex = NextStepIndex(nEncSample, nStepIndex);

                *(LPSHORT)pbDst = (SHORT)nPredSample;
                pbDst += sizeof(SHORT);

                cSamples--;
            }
        }

        //
        // Skip padding
        //

        pbSrc += nBlockAlignment;
    }

    DPF_LEAVE(fSuccess);

    return fSuccess;
}


#undef DPF_FNAME
#define DPF_FNAME "CImaAdpcmCodec::DecodeS16"

BOOL
CImaAdpcmCodec::DecodeS16
(
    LPBYTE                  pbSrc,
    LPBYTE                  pbDst,
    UINT                    cBlocks,
    UINT                    nBlockAlignment,
    UINT                    cSamplesPerBlock,
    LPINT                   pnStepIndexL,
    LPINT                   pnStepIndexR
)
{
    BOOL                    fSuccess    = TRUE;
    LPBYTE                  pbBlock;
    UINT                    cSamples;
    UINT                    cSubSamples;
    INT                     nStepSize;
    DWORD                   dwHeader;
    DWORD                   dwLeft;
    DWORD                   dwRight;
    INT                     nEncSampleL;
    INT                     nPredSampleL;
    INT                     nStepIndexL;
    INT                     nEncSampleR;
    INT                     nPredSampleR;
    INT                     nStepIndexR;
    UINT                    i;

    DPF_ENTER();    

    //
    // Enter the main loop
    //
    
    while(cBlocks--)
    {
        pbBlock = pbSrc;
        cSamples = cSamplesPerBlock - 1;

        //
        // LEFT channel header
        //

        dwHeader = *(LPDWORD)pbBlock;
        pbBlock += sizeof(DWORD);
        
        nPredSampleL = (INT)(SHORT)LOWORD(dwHeader);
        nStepIndexL = (INT)(BYTE)HIWORD(dwHeader);

        if(!ValidStepIndex(nStepIndexL)) 
        {
            //
            // The step index is out of range - this is considered a fatal
            // error as the input stream is corrupted.  We fail by returning
            // zero bytes converted.
            //

            DPF_ERROR("invalid step index %u (L)", nStepIndexL);
            fSuccess = FALSE;
            break;
        }
        
        //
        // RIGHT channel header
        //

        dwHeader = *(LPDWORD)pbBlock;
        pbBlock += sizeof(DWORD);
        
        nPredSampleR = (INT)(SHORT)LOWORD(dwHeader);
        nStepIndexR = (INT)(BYTE)HIWORD(dwHeader);

        if(!ValidStepIndex(nStepIndexR))
        {
            //
            // The step index is out of range - this is considered a fatal
            // error as the input stream is corrupted.  We fail by returning
            // zero bytes converted.
            //

            DPF_ERROR("invalid step index %u (R)",nStepIndexR);
            fSuccess = FALSE;
            break;
        }

        //
        // Write out first sample
        //

        *(LPDWORD)pbDst = MAKELONG(nPredSampleL, nPredSampleR);
        pbDst += sizeof(DWORD);

        //
        // The first DWORD contains 4 left samples, the second DWORD
        // contains 4 right samples.  We process the source in 8-byte
        // chunks to make it easy to interleave the output correctly.
        //

        while(cSamples)
        {
            dwLeft = *(LPDWORD)pbBlock;
            pbBlock += sizeof(DWORD);
            dwRight = *(LPDWORD)pbBlock;
            pbBlock += sizeof(DWORD);

            cSubSamples = min(cSamples, 8);
            
            for(i = 0; i < cSubSamples; i++)
            {
                //
                // LEFT channel
                //

                nEncSampleL = (dwLeft & 0x0F);
                nStepSize = m_asStep[nStepIndexL];
                nPredSampleL = DecodeSample(nEncSampleL, nPredSampleL, nStepSize);
                nStepIndexL = NextStepIndex(nEncSampleL, nStepIndexL);

                //
                // RIGHT channel
                //

                nEncSampleR = (dwRight & 0x0F);
                nStepSize = m_asStep[nStepIndexR];
                nPredSampleR = DecodeSample(nEncSampleR, nPredSampleR, nStepSize);
                nStepIndexR = NextStepIndex(nEncSampleR, nStepIndexR);

                //
                // Write out sample
                //

                *(LPDWORD)pbDst = MAKELONG(nPredSampleL, nPredSampleR);
                pbDst += sizeof(DWORD);

                //
                // Shift the next input sample into the low-order 4 bits.
                //

                dwLeft >>= 4;
                dwRight >>= 4;
            }

            cSamples -= cSubSamples;
        }

        //
        // Skip padding
        //

        pbSrc += nBlockAlignment;
    }

    DPF_LEAVE(fSuccess);

    return fSuccess;
}


/****************************************************************************
 *
 *  CImaAdpcmMediaObject
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImaAdpcmMediaObject::CImaAdpcmMediaObject"

CImaAdpcmMediaObject::CImaAdpcmMediaObject
(
    void
)
{
    DPF_ENTER();

    m_ulRefCount = 1;

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  ~CImaAdpcmMediaObject
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImaAdpcmMediaObject::~CImaAdpcmMediaObject"

CImaAdpcmMediaObject::~CImaAdpcmMediaObject
(
    void
)
{
    DPF_ENTER();
    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  AddRef
 *
 *  Description:
 *      Increments the object reference count.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      ULONG: reference count.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSecondaryBuffer::AddRef"

ULONG
CImaAdpcmMediaObject::AddRef
(
    void
)
{
    ULONG                   ulRefCount;

    DPF_ENTER();

    ASSERT(m_ulRefCount);
    
    ulRefCount = ++m_ulRefCount;

    DPF_LEAVE(ulRefCount);

    return ulRefCount;
}


/****************************************************************************
 *
 *  Release
 *
 *  Description:
 *      Decrements the object reference count.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      ULONG: reference count.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSecondaryBuffer::Release"

ULONG
CImaAdpcmMediaObject::Release
(
    void
)
{
    ULONG                   ulRefCount;

    DPF_ENTER();

    ASSERT(m_ulRefCount);
    
    if(!(ulRefCount = --m_ulRefCount))
    {
        delete this;
    }

    DPF_LEAVE(ulRefCount);

    return ulRefCount;
}


/****************************************************************************
 *
 *  GetInfo
 *
 *  Description:
 *      Gets information about the data the object supports.
 *
 *  Arguments:
 *      LPXMEDIAINFO [in/out]: info structure.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImaAdpcmMediaObject::GetInfo"

HRESULT
CImaAdpcmMediaObject::GetInfo
(
    LPXMEDIAINFO            pInfo
)
{
    DPF_ENTER();

    ASSERT(pInfo);

    pInfo->dwFlags = XMO_STREAMF_WHOLE_SAMPLES | XMO_STREAMF_FIXED_SAMPLE_SIZE;
    pInfo->dwMaxLookahead = 0;
    pInfo->dwInputSize = GetInputAlignment();
    pInfo->dwOutputSize = GetOutputAlignment();

    DPF_LEAVE_HRESULT(DS_OK);

    return DS_OK;
}


/****************************************************************************
 *
 *  Discontinuity
 *
 *  Description:
 *      Indicates a discontinuity in the stream data>
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CImaAdpcmMediaObject::Discontinuity"

HRESULT
CImaAdpcmMediaObject::Discontinuity
(
    void
)                                       
{                                           
    DPF_ENTER();
    
    //
    // Reset stepping indeces
    //

    m_nStepIndexL = m_nStepIndexR = 0;

    DPF_LEAVE_HRESULT(DS_OK);

    return DS_OK;
}


/****************************************************************************
 *
 *  Flush
 *
 *  Description:
 *      Resets the stream to it's default state.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CImaAdpcmMediaObject::Flush"

HRESULT
CImaAdpcmMediaObject::Flush
(
    void
)                                       
{                                           
    DPF_ENTER();
    
    //
    // Reset stepping indeces
    //

    m_nStepIndexL = m_nStepIndexR = 0;

    DPF_LEAVE_HRESULT(DS_OK);

    return DS_OK;
}


/****************************************************************************
 *
 *  GetStatus
 *
 *  Description:
 *      Gets stream status.
 *
 *  Arguments:
 *      LPDWORD [out]: stream status.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImaAdpcmMediaObject::GetStatus"

HRESULT
CImaAdpcmMediaObject::GetStatus
(
    LPDWORD                 pdwStatus
)
{
    DPF_ENTER();

    ASSERT(pdwStatus);

    *pdwStatus = XMO_STATUSF_ACCEPT_INPUT_DATA | XMO_STATUSF_ACCEPT_OUTPUT_DATA;

    DPF_LEAVE_HRESULT(DS_OK);

    return DS_OK;
}


/****************************************************************************
 *
 *  Process
 *
 *  Description:
 *      Submits buffers to the stream.
 *
 *  Arguments:
 *      LPCXMEDIAPACKET  [in]: input buffer.
 *      LPCXMEDIAPACKET  [in]: output buffer.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImaAdpcmMediaObject::Process"

HRESULT
CImaAdpcmMediaObject::Process
(
    LPCXMEDIAPACKET         pxmbSource, 
    LPCXMEDIAPACKET         pxmbDest 
)
{
    DWORD                   dwInputAlignment;
    DWORD                   dwOutputAlignment;
    DWORD                   dwInputBlocks;
    DWORD                   dwOutputBlocks;
    DWORD                   dwBlocks;
    DWORD                   dwInputSize;
    DWORD                   dwOutputSize;
    HRESULT                 hr;
    
    DPF_ENTER();

    ASSERT(pxmbSource && pxmbDest);

    //
    // Initialize the packets' output parameters
    //

    XMOAcceptPacket(pxmbSource);
    XMOAcceptPacket(pxmbDest);

    //
    // Align buffer sizes and convert to a block count
    //

    dwInputAlignment = GetInputAlignment();
    dwOutputAlignment = GetOutputAlignment();

    dwInputBlocks = pxmbSource->dwMaxSize / dwInputAlignment;
    dwOutputBlocks = pxmbDest->dwMaxSize / dwOutputAlignment;

    dwBlocks = min(dwInputBlocks, dwOutputBlocks);

    //
    // Convert
    //

    if(Convert((LPBYTE)pxmbSource->pvBuffer, (LPBYTE)pxmbDest->pvBuffer, dwBlocks))
    {
        hr = DS_OK;
    }
    else
    {
        DPF_ERROR("CODEC failure");
        hr = DSERR_GENERIC;
    }

    //
    // Complete the packets
    //

    if(SUCCEEDED(hr))
    {
        XMOCompletePacket(pxmbSource, dwBlocks * dwInputAlignment);
        XMOCompletePacket(pxmbDest, dwBlocks * dwOutputAlignment);
    }
    else
    {
        XMOCompletePacket(pxmbSource, 0, NULL, NULL, XMEDIAPACKET_STATUS_FAILURE);
        XMOCompletePacket(pxmbDest, 0, NULL, NULL, XMEDIAPACKET_STATUS_FAILURE);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  AdpcmCreateEncoder
 *
 *  Description:
 *      Creates an ADPCM CODEC Media Object.
 *
 *  Arguments:
 *      LPCWAVEFORMATEX [in]: source format description.
 *      DWORD [in]: bytes of PCM data per block.  This value must be aligned
 *                  to 8 samples.
 *      LPIMAADPCMWAVEFORMAT [out]: destination format description.
 *      XMediaObject ** [out]: CODEC Media Object.  The caller is responsbile
 *                             for freeing this object with Release.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "AdpcmCreateEncoder"

HRESULT
AdpcmCreateEncoder
(
    LPCWAVEFORMATEX         pwfxDecoded,
    DWORD                   dwDecodedBytesPerBlock,
    LPIMAADPCMWAVEFORMAT    pwfxEncoded,
    XMediaObject **         ppMediaObject
)
{
    CImaAdpcmMediaObject *  pMediaObject;
    IMAADPCMWAVEFORMAT      wfxEncoded;

#ifndef ASSUME_VALID_PARAMETERS

    BOOL                    fValidFormat;

#endif // ASSUME_VALID_PARAMETERS

    HRESULT                 hr;

    DPF_ENTER();

#ifndef ASSUME_VALID_PARAMETERS

    ASSERT(pwfxDecoded);
    ASSERT(ppMediaObject);

    fValidFormat = IsValidPcmFormat(pwfxDecoded);

    if(fValidFormat && (pwfxDecoded->nChannels > 2))
    {
        DPF_ERROR("The IMA ADPCM CODEC only supports MONO and STEREO");
        fValidFormat = FALSE;
    }            

    if(fValidFormat && (16 != pwfxDecoded->wBitsPerSample))
    {
        DPF_ERROR("The IMA ADPCM CODEC only supports 16-bit PCM data");
        fValidFormat = FALSE;
    }

    ASSERT(!(dwDecodedBytesPerBlock % pwfxDecoded->nBlockAlign));

#endif // ASSUME_VALID_PARAMETERS

    //
    // Create the destination format
    //

    CImaAdpcmCodec::CreateImaAdpcmFormat(pwfxDecoded->nChannels, pwfxDecoded->nSamplesPerSec, (WORD)(dwDecodedBytesPerBlock / pwfxDecoded->nBlockAlign), 1, &wfxEncoded);

    //
    // Create the CODEC object
    //

    hr = HRFROMP(pMediaObject = NEW(CImaAdpcmMediaObject));

    if(SUCCEEDED(hr))
    {
        pMediaObject->Initialize(wfxEncoded, TRUE);
    }

    //
    // Provide format data to the caller
    //

    if(SUCCEEDED(hr) && pwfxEncoded)
    {
        CopyMemory(pwfxEncoded, &wfxEncoded, sizeof(wfxEncoded));
    }

    //
    // Success
    //

    if(SUCCEEDED(hr))
    {
        *ppMediaObject = ADDREF(pMediaObject);
    }

    RELEASE(pMediaObject);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  AdpcmCreateDecoder
 *
 *  Description:
 *      Creates an ADPCM CODEC Media Object.
 *
 *  Arguments:
 *      LPCIMAADPCMWAVEFORMAT [in]: source format description.
 *      LPWAVEFORMATEX [out]: destination format description.
 *      XMediaObject ** [out]: CODEC Media Object.  The caller is responsbile
 *                             for freeing this object with Release.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "AdpcmCreateDecoder"

HRESULT
AdpcmCreateDecoder
(
    LPCIMAADPCMWAVEFORMAT   pwfxEncoded,
    LPWAVEFORMATEX          pwfxDecoded,
    XMediaObject **         ppMediaObject
)
{
    CImaAdpcmMediaObject *  pMediaObject;
    HRESULT                 hr;

    DPF_ENTER();

#ifndef ASSUME_VALID_PARAMETERS

    ASSERT(pwfxEncoded);
    ASSERT(ppMediaObject);

    IsValidImaAdpcmFormat(pwfxEncoded);

#endif // ASSUME_VALID_PARAMETERS

    //
    // Create the CODEC object
    //

    hr = HRFROMP(pMediaObject = NEW(CImaAdpcmMediaObject));

    if(SUCCEEDED(hr))
    {
        pMediaObject->Initialize(*pwfxEncoded, FALSE);
    }

    //
    // Provide format data to the caller
    //

    if(SUCCEEDED(hr) && pwfxDecoded)
    {
        CImaAdpcmCodec::CreatePcmFormat(pwfxEncoded->wfx.nChannels, pwfxEncoded->wfx.nSamplesPerSec, pwfxDecoded);
    }

    //
    // Success
    //

    if(SUCCEEDED(hr))
    {
        *ppMediaObject = ADDREF(pMediaObject);
    }

    RELEASE(pMediaObject);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\ac97\ac97.h ===
/***************************************************************************
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ac97.h
 *  Content:    DirectSound AC97 device driver.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  09/27/00    dereks  Created.
 *
 ****************************************************************************/

#ifndef __AC97_H__
#define __AC97_H__

#ifndef AC97_AMR
#define AC97_USE_MIO
#endif // AC97_AMR

#include "ac97reg.h"
#include "acireg.h"
#include <conio.h>

#pragma intrinsic(_inp,_inpw,_inpd,_outp,_outpw,_outpd)

//
// AC97 channel identifiers
//

typedef enum
{
    AC97_CHANNELTYPE_ANALOG = 0,
    AC97_CHANNELTYPE_DIGITAL,
    AC97_CHANNELTYPE_COUNT
} AC97CHANNELTYPE;

//
// AC97 channel interrupt bits
//

#define AC97_CHANNELINTERRUPT(line) \
    (1UL << (line))

#define AC97_CHANNELINTERRUPT_ANALOG    AC97_CHANNELINTERRUPT(AC97_CHANNELTYPE_ANALOG)
#define AC97_CHANNELINTERRUPT_DIGITAL   AC97_CHANNELINTERRUPT(AC97_CHANNELTYPE_DIGITAL)

#define AC97_CHANNELINTERRUPT_MASK      (AC97_CHANNELINTERRUPT(AC97_CHANNELTYPE_COUNT) - 1)

//
// AC97 channel interrupt callback
//

typedef void (CALLBACK *LPFNAC97CHANNELCALLBACK)(LPVOID pvContext);

//
// AC97 device object creation flags
//

#define AC97_OBJECTF_DIRECTISR      0x00000001      // The device does not spawn a DPC to handle interrupts

//
// AC97 channel object creation flags
//

#define AC97CHANNEL_OBJECTF_STREAM          0x00000001      // The channel removed played packets from the list
#define AC97CHANNEL_OBJECTF_DISCONTINUITY   0x00000002      // Internal channel flag.  Do not set

#ifdef __cplusplus

namespace DirectSound
{
    //
    // Forward declarations
    //

    class CAc97Channel;

    //
    // AC97 device object
    //

    class CAc97Device
    {
        friend class CAc97Channel;

    public:
        static const WAVEFORMATEX   m_wfxFormat;                                            // Device format
                                                                                        
    #ifdef AC97_AMR                                                                         
                                                                                        
        static const DWORD          m_dwVendorId;                                           // PCI device vendor identifier
        static const DWORD          m_dwDeviceId;                                           // PCI device identifier
        static const DWORD          m_dwBusNumber;                                          // PCI bus index
        static const DWORD          m_dwDeviceNumber;                                       // PCI device index
        static const DWORD          m_dwFunctionNumber;                                     // PCI device function index
                                                                                        
    #endif // AC97_AMR                                                                      
                                                                                        
        static const DWORD          m_dwAc97RegisterBase;                                   // AC97 register base address
        static const DWORD          m_dwAciRegisterBase;                                    // ACI register base address
        static CAc97Device *        m_pDevice;                                              // The one-and-only device object
        CAc97Channel *              m_apChannels[AC97_CHANNELTYPE_COUNT];                   // Channel objects
                                                                                        
    protected:                                                                              
        DWORD                       m_dwFlags;                                              // Object creation flags
        static KINTERRUPT           m_Interrupt;                                            // Interrupt object
        HAL_SHUTDOWN_REGISTRATION   m_HalShutdownData;                                      // HAL shutdown registration data
        KDPC                        m_dpc;                                                  // Interrupt DPC routine
        BYTE                        m_abPendingBufferCompletions[AC97_CHANNELTYPE_COUNT][2];// Count of buffer completions waiting to be handled (live and cached)

    public:
        CAc97Device(void);
        ~CAc97Device(void);

    public:
        CAc97Device &operator=(const CAc97Device &);

    public:
        // Initialization
        HRESULT Initialize(DWORD dwFlags = 0);
        void Terminate(void);

        // Channel allocation
        HRESULT CreateChannel(AC97CHANNELTYPE nChannelType, CAc97Channel **ppChannel = NULL);
        void ReleaseChannel(AC97CHANNELTYPE nChannelType);
        void ReleaseChannel(CAc97Channel *pChannel);

    protected:
        // CODEC power state
        BOOL CodecReady(void);
        HRESULT PowerUp(void);

        // Interrupt handlers
        DWORD ServiceAciInterrupt(void);
        void ServiceAciInterruptDpc(void);
        void SynchronizeAciInterrupt(void);
        DWORD GetInterruptStatus(void);

        // Register access
        static BOOL AcquireCodecSemaphore(void);
    
        static BYTE PeekRegister8(DWORD dwRegister);
        static void PokeRegister8(DWORD dwRegister, BYTE bValue);
        static WORD PeekRegister16(DWORD dwRegister);
        static void PokeRegister16(DWORD dwRegister, WORD wValue);
        static DWORD PeekRegister32(DWORD dwRegister);
        static void PokeRegister32(DWORD dwRegister, DWORD dwValue);

        static BYTE PeekAciRegister8(DWORD dwRegister);
        static void PokeAciRegister8(DWORD dwRegister, BYTE bValue);
        static WORD PeekAciRegister16(DWORD dwRegister);
        static void PokeAciRegister16(DWORD dwRegister, WORD wValue);
        static DWORD PeekAciRegister32(DWORD dwRegister);
        static void PokeAciRegister32(DWORD dwRegister, DWORD dwValue);

        static BOOL PeekAc97Register(AC97REGISTER reg, LPWORD pwValue);
        static BOOL PokeAc97Register(AC97REGISTER reg, WORD wValue);
        static BOOL VerifyPokeAc97Register(AC97REGISTER reg, WORD wValue);

        static void WaitRegisterRetry(void);

    private:
        // HAL callbacks
        static BOOLEAN AciInterruptServiceRoutine(PKINTERRUPT pInterrupt, LPVOID pvContext);
        static void AciInterruptDpcHandler(PKDPC pdpc, LPVOID pvDeferredContext, LPVOID pvSystemArgument1, LPVOID pvSystemArgument2);
        static void AciShutdownNotifier(PHAL_SHUTDOWN_REGISTRATION pHalShutdownData);
        static BOOLEAN AciSynchronizationRoutine(LPVOID pvContext);
    };

    __inline BYTE CAc97Device::PeekRegister8(DWORD dwRegister)
    {

    #ifdef AC97_USE_MIO

        return *(LPBYTE)dwRegister;

    #else // AC97_USE_MIO

        return (BYTE)_inp((WORD)dwRegister);

    #endif // AC97_USE_MIO

    }    

    __inline void CAc97Device::PokeRegister8(DWORD dwRegister, BYTE bValue)
    {

    #ifdef AC97_USE_MIO

        *(LPBYTE)dwRegister = bValue;

    #else // AC97_USE_MIO

        _outp((WORD)dwRegister, bValue);

    #endif // AC97_USE_MIO

    }

    __inline WORD CAc97Device::PeekRegister16(DWORD dwRegister)
    {

    #ifdef AC97_USE_MIO

        return *(LPWORD)dwRegister;

    #else // AC97_USE_MIO

        return _inpw((WORD)dwRegister);

    #endif // AC97_USE_MIO

    }

    __inline void CAc97Device::PokeRegister16(DWORD dwRegister, WORD wValue)
    {

    #ifdef AC97_USE_MIO

        *(LPWORD)dwRegister = wValue;

    #else // AC97_USE_MIO

        _outpw((WORD)dwRegister, wValue);

    #endif // AC97_USE_MIO

    }

    __inline DWORD CAc97Device::PeekRegister32(DWORD dwRegister)
    {

    #ifdef AC97_USE_MIO

        return *(LPDWORD)dwRegister;

    #else // AC97_USE_MIO

        return _inpd((WORD)dwRegister);

    #endif // AC97_USE_MIO

    }

    __inline void CAc97Device::PokeRegister32(DWORD dwRegister, DWORD dwValue)
    {

    #ifdef AC97_USE_MIO

        *(LPDWORD)dwRegister = dwValue;

    #else // AC97_USE_MIO

        _outpd((WORD)dwRegister, dwValue);

    #endif // AC97_USE_MIO

    }

    __inline BYTE CAc97Device::PeekAciRegister8(DWORD dwRegister)
    {
        return PeekRegister8(m_dwAciRegisterBase + dwRegister);
    }
    
    __inline void CAc97Device::PokeAciRegister8(DWORD dwRegister, BYTE bValue)
    {
        PokeRegister8(m_dwAciRegisterBase + dwRegister, bValue);
    }

    __inline WORD CAc97Device::PeekAciRegister16(DWORD dwRegister)
    {
        return PeekRegister16(m_dwAciRegisterBase + dwRegister);
    }

    __inline void CAc97Device::PokeAciRegister16(DWORD dwRegister, WORD wValue)
    {
        PokeRegister16(m_dwAciRegisterBase + dwRegister, wValue);
    }

    __inline DWORD CAc97Device::PeekAciRegister32(DWORD dwRegister)
    {
        return PeekRegister32(m_dwAciRegisterBase + dwRegister);
    }

    __inline void CAc97Device::PokeAciRegister32(DWORD dwRegister, DWORD dwValue)
    {
        PokeRegister32(m_dwAciRegisterBase + dwRegister, dwValue);
    }

    __inline void CAc97Device::WaitRegisterRetry(void)
    {
        KeStallExecutionProcessor(20);
    }

    __inline BOOLEAN CAc97Device::AciInterruptServiceRoutine(PKINTERRUPT pInterrupt, LPVOID pvContext)
    {
        CAc97Device *           pThis   = (CAc97Device *)pvContext;
    
        return (BOOLEAN)MAKEBOOL(pThis->ServiceAciInterrupt());
    }

    __inline void CAc97Device::AciInterruptDpcHandler(PKDPC pdpc, LPVOID pvDeferredContext, LPVOID pvSystemArgument1, LPVOID pvSystemArgument2)
    {
        CAc97Device *           pThis   = (CAc97Device *)pvDeferredContext;
    
        pThis->ServiceAciInterruptDpc();
    }

    __inline void CAc97Device::AciShutdownNotifier(PHAL_SHUTDOWN_REGISTRATION pHalShutdownData)
    {
        CAc97Device *           pThis   = CONTAINING_RECORD(pHalShutdownData, CAc97Device, m_HalShutdownData);
    
        pThis->Terminate();
    }

    __inline BOOLEAN CAc97Device::AciSynchronizationRoutine(LPVOID pvContext)
    {
        CAc97Device *           pThis   = (CAc97Device *)pvContext;
    
        pThis->SynchronizeAciInterrupt();

        return TRUE;
    }    

    //
    // AC97 channel object
    //

    class CAc97Channel
    {
        friend class CAc97Device;

    public:
        static const DWORD          m_adwRegisterOffsets[AC97_CHANNELTYPE_COUNT];   // Channel register offsets
        static const DWORD          m_dwSilenceSize;                                // Silent packet size

    public:
        const AC97CHANNELTYPE       m_nChannelType;                                 // Channel type
        DWORD                       m_dwPosition;                                   // Absolute channel position
                                                                                
    protected:                                                                      
        CAc97Device *               m_pDevice;                                      // Pointer back to the parent device
        DWORD                       m_dwFlags;                                      // Object creation flags
        LPFNAC97CHANNELCALLBACK     m_pfnCallback;                                  // Interrupt callback function
        LPVOID                      m_pvCallbackContext;                            // Callback function context
        LPACIPRD                    m_pPrdl;                                        // Physical resource descriptor list
        DWORD                       m_dwPrdlAddress;                                // PRDL physical address
        LPVOID                      m_pvSilence;                                    // Silent packet data
        BYTE                        m_bPrdCount;                                    // Count of PRDs in the PRDL
        BYTE                        m_bCurrentPrd;                                  // Current index into the PRDL
        DWORD                       m_dwMode;                                       // Channel mode
        DWORD                       m_dwLastPosition;                               // Last position returned from GetPosition

    public:
        CAc97Channel(CAc97Device *pDevice, AC97CHANNELTYPE nChannelType);
        ~CAc97Channel(void);

    public:
        CAc97Channel &operator=(const CAc97Channel &);

    public:
        // Initialization
        HRESULT Initialize(DWORD dwFlags = 0, LPFNAC97CHANNELCALLBACK pfnCallback = NULL, LPVOID pvContext = NULL);
        void Terminate(void);

        // Reference counting
        void Release(void);

        // Audio data packets
        DWORD GetFreePacketCount(void);
        void AttachPacket(LPCVOID pvBufferData, DWORD dwBufferSize);
        void AttachPacket(DWORD dwBufferAddress, DWORD dwBufferSize);
        void AttachBuffer(LPCVOID pvBufferData, DWORD dwBufferSize, DWORD dwPacketCount);
        void AttachBuffer(DWORD dwBufferAddress, DWORD dwBufferSize, DWORD dwPacketCount);

        // Channel state
        void Run(DWORD dwPosition = -1);
        void Pause(void);
        void Flush(BOOL fResetPosition = TRUE);
        void Discontinuity(void);
        void Reset(void);
    
        // Channel position
        DWORD GetPosition(void);

        // Channel mode
        void SetMode(DWORD dwMode);

    protected:
        // Channel position
        void SetPosition(DWORD dwPosition);

        // Interrupts
        void ServiceInterrupt(void);

        // Resource descriptor list
        void SetPrdIndeces(BYTE bCurrentPrd, BYTE bPrdCount, BOOL fApplyCurrent, BOOL fApplyLast);

        // Register access
        BYTE PeekAciRegister8(DWORD dwRegister);
        void PokeAciRegister8(DWORD dwRegister, BYTE bValue);
        WORD PeekAciRegister16(DWORD dwRegister);
        void PokeAciRegister16(DWORD dwRegister, WORD wValue);
        DWORD PeekAciRegister32(DWORD dwRegister);
        void PokeAciRegister32(DWORD dwRegister, DWORD dwValue);
    };

    __inline void CAc97Device::ReleaseChannel(CAc97Channel *pChannel)
    {
        ReleaseChannel(pChannel->m_nChannelType);
    }

    __inline void CAc97Channel::Release(void)
    {
        m_pDevice->ReleaseChannel(this);
    }

    __inline void CAc97Channel::AttachPacket(LPCVOID pvBufferData, DWORD dwBufferSize)
    {
        AttachPacket(MmGetPhysicalAddress((LPVOID)pvBufferData), dwBufferSize);
    }

    __inline void CAc97Channel::AttachBuffer(LPCVOID pvBufferData, DWORD dwBufferSize, DWORD dwPacketCount)
    {
        AttachBuffer(MmGetPhysicalAddress((LPVOID)pvBufferData), dwBufferSize, dwPacketCount);
    }

    __inline DWORD CAc97Channel::GetFreePacketCount(void)
    {
        return ACIPRDL_ENTRY_COUNT - m_bPrdCount;
    }

    __inline BYTE CAc97Channel::PeekAciRegister8(DWORD dwRegister)
    {
        return m_pDevice->PeekAciRegister8(dwRegister + m_adwRegisterOffsets[m_nChannelType]);
    }

    __inline void CAc97Channel::PokeAciRegister8(DWORD dwRegister, BYTE bValue)
    {
        m_pDevice->PokeAciRegister8(dwRegister + m_adwRegisterOffsets[m_nChannelType], bValue);
    }

    __inline WORD CAc97Channel::PeekAciRegister16(DWORD dwRegister)
    {
        return m_pDevice->PeekAciRegister16(dwRegister + m_adwRegisterOffsets[m_nChannelType]);
    }

    __inline void CAc97Channel::PokeAciRegister16(DWORD dwRegister, WORD wValue)
    {
        m_pDevice->PokeAciRegister16(dwRegister + m_adwRegisterOffsets[m_nChannelType], wValue);
    }

    __inline DWORD CAc97Channel::PeekAciRegister32(DWORD dwRegister)
    {
        return m_pDevice->PeekAciRegister32(dwRegister + m_adwRegisterOffsets[m_nChannelType]);
    }

    __inline void CAc97Channel::PokeAciRegister32(DWORD dwRegister, DWORD dwValue)
    {
        m_pDevice->PokeAciRegister32(dwRegister + m_adwRegisterOffsets[m_nChannelType], dwValue);
    }
}
    
#endif // __cplusplus

#endif // __AC97_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\ac97\ac97.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ac97.cpp
 *  Content:    DirectSound AC '97 device driver.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  09/27/00    dereks  Created based on NVidia code.
 *
 ****************************************************************************/

#include "dsoundi.h"

//#define DPF_AC97 DPF_ABSOLUTE
#define DPF_AC97()


/****************************************************************************
 *
 *  CAc97Device
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CAc97Device::CAc97Device"

#ifdef AC97_AMR

const DWORD CAc97Device::m_dwVendorId = 0x8086;
const DWORD CAc97Device::m_dwDeviceId = 0x2415;
const DWORD CAc97Device::m_dwBusNumber = 0;
const DWORD CAc97Device::m_dwDeviceNumber = 31;
const DWORD CAc97Device::m_dwFunctionNumber = 5;
const DWORD CAc97Device::m_dwAc97RegisterBase = 0xD800;
const DWORD CAc97Device::m_dwAciRegisterBase = 0xDC00;

#else // AC97_AMR

#ifdef AC97_USE_MIO

const DWORD CAc97Device::m_dwAc97RegisterBase = XPCICFG_ACI_MEMORY_REGISTER_BASE_2 + AC97_MIO_BASE;
const DWORD CAc97Device::m_dwAciRegisterBase = XPCICFG_ACI_MEMORY_REGISTER_BASE_2 + ACI_MIO_BASE;

#else // AC97_USE_MIO

const DWORD CAc97Device::m_dwAc97RegisterBase = XPCICFG_ACI_IO_REGISTER_BASE_0;
const DWORD CAc97Device::m_dwAciRegisterBase = XPCICFG_ACI_IO_REGISTER_BASE_1;

#endif // AC97_USE_MIO

#endif // AC97_AMR

const WAVEFORMATEX CAc97Device::m_wfxFormat = 
{ 
    WAVE_FORMAT_PCM,    // wFormatTag
    2,                  // nChannels
    48000,              // nSamplesPerSec
    192000,             // nAvgBytesPerSec
    4,                  // nBlockAlign
    16,                 // wBitsPerSample
    0                   // cbSize
};

CAc97Device *CAc97Device::m_pDevice = NULL;
KINTERRUPT CAc97Device::m_Interrupt = { 0 };

CAc97Device::CAc97Device
(
    void
)
{
    DPF_ENTER();

    if(m_pDevice)
    {
        DPF_ERROR("The AC97 device driver is already running");
    }

    m_pDevice = this;

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  ~CAc97Device
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CAc97Device::~CAc97Device"

CAc97Device::~CAc97Device
(
    void
)
{
    DPF_ENTER();

    Terminate();

    m_pDevice = NULL;

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  Initialize
 *
 *  Description:
 *      Initializes the object.
 *
 *  Arguments:
 *      DWORD [in]: flags.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CAc97Device::Initialize"

HRESULT
CAc97Device::Initialize
(
    DWORD                   dwFlags
)
{
    HRESULT                 hr                  = DS_OK;

#ifdef AC97_AMR

    DWORD                   dwRegisterValue;
    BYTE                    bInterruptLine;
    PCI_COMMON_CONFIG       PciConfig;
    PCI_SLOT_NUMBER         Slot;

#endif // AC97_AMR

    KIRQL                   Irql;
    ULONG                   ulInterruptVector;
    DWORD                   i;

    DPF_ENTER();

    //
    // Save the flags
    //
    
    m_dwFlags = dwFlags;

#ifdef AC97_AMR

    //
    // Poke the PCI controller to enable the AMR sound device
    //

    _outpd(0xCF8, 0x8000F8F0);

    dwRegisterValue = _inpd(0xCFC);

    if(dwRegisterValue & 0x200000)
    {
        _outpd(0xCFC, dwRegisterValue & ~0x200000);
    }

    //
    // Get the device's interrupt line, since it won't be in the PCI config
    //

    Slot.u.bits.DeviceNumber = m_dwDeviceNumber;
    Slot.u.bits.FunctionNumber = 0;
    Slot.u.bits.Reserved = 0;

    HalReadPCISpace(m_dwBusNumber, Slot.u.AsULONG, 0x61, &bInterruptLine, sizeof(bInterruptLine));

    //
    // Get the device's current PCI config data
    //

    Slot.u.bits.FunctionNumber = m_dwFunctionNumber;

    HalReadPCISpace(m_dwBusNumber, Slot.u.AsULONG, 0, &PciConfig, sizeof(PciConfig));

    ASSERT(m_dwVendorId == PciConfig.VendorID);
    ASSERT(m_dwDeviceId == PciConfig.DeviceID);

    //
    // Assign base addresses and IRQ
    //

    DPF_AC97("Using IRQ %x", (DWORD)bInterruptLine);

    PciConfig.Command = 5;

    PciConfig.u.type0.BaseAddresses[0] = m_dwAc97RegisterBase | 1;
    PciConfig.u.type0.BaseAddresses[1] = m_dwAciRegisterBase | 1;

    PciConfig.u.type0.InterruptLine = bInterruptLine;
    PciConfig.u.type0.InterruptPin = 0;

    HalWritePCISpace(m_dwBusNumber, Slot.u.AsULONG, 0, &PciConfig, sizeof(PciConfig));

#endif // AC97_AMR

    //
    // Make sure the CODEC is ready to be powered up
    //

    if(!CodecReady())
    {
        DPF_ERROR("CODEC not ready");
        hr = DSERR_NODRIVER;
    }
    
    //
    // Power up the CODEC
    //

    if(SUCCEEDED(hr))
    {
        hr = PowerUp();
    }

    //
    // Reset all channels
    //

    if(SUCCEEDED(hr))
    {
        for(i = 0; i < NUMELMS(CAc97Channel::m_adwRegisterOffsets); i++)
        {
            PokeAciRegister8(CAc97Channel::m_adwRegisterOffsets[i] + X_CTRL, X_CTRL_RBMR);
        }
    }

    //
    // Initialize the interrupt DPC
    //

    if(SUCCEEDED(hr) && !(m_dwFlags & AC97_OBJECTF_DIRECTISR))
    {
        KeInitializeDpc(&m_dpc, AciInterruptDpcHandler, this);
    }

    //
    // Set up the interrupt handler
    //

    if(SUCCEEDED(hr))
    {

#ifdef AC97_AMR

        ulInterruptVector = HalGetInterruptVector(PciConfig.u.type0.InterruptLine, &Irql);

#else // AC97_AMR

        ulInterruptVector = HalGetInterruptVector(XPCICFG_ACI_IRQ, &Irql);

#endif // AC97_AMR

        KeInitializeInterrupt(&m_Interrupt, AciInterruptServiceRoutine, this, ulInterruptVector, Irql, LevelSensitive, TRUE);

        if(!KeConnectInterrupt(&m_Interrupt))
        {
            DPF_ERROR("Failed to connect interrupt");
            hr = DSERR_GENERIC;
        }
    }

    //
    // Unmute the CODEC
    //

    if(SUCCEEDED(hr))
    {
        if(!PokeAc97Register(AC97REG_FRONT_VOLUME, 0))
        {
            DPF_ERROR("Unable to set front volume");
            hr = DSERR_GENERIC;
        }
    }

    if(SUCCEEDED(hr))
    {
        if(!PokeAc97Register(AC97REG_PCM_OUT_VOLUME, 0x0808))
        {
            DPF_ERROR("Unable to set PCM out volume");
            hr = DSERR_GENERIC;
        }
    }

    //
    // Register for HAL shutdown notification
    //

    if(SUCCEEDED(hr))
    {
        m_HalShutdownData.NotificationRoutine = AciShutdownNotifier;

        HalRegisterShutdownNotification(&m_HalShutdownData, TRUE);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  Terminate
 *
 *  Description:
 *      Shuts down the driver object.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CAc97Device::Terminate"

void
CAc97Device::Terminate
(
    void
)
{
    DWORD                   i;

    DPF_ENTER();
    AutoIrql();

    //
    // Disconnect the interrupt handler
    //

    if(m_Interrupt.ServiceRoutine)
    {
        KeDisconnectInterrupt(&m_Interrupt);
        m_Interrupt.ServiceRoutine = NULL;
    }

    //
    // Clear any pending DPCs
    //

    if(DpcObject == m_dpc.Type)
    {
        KeRemoveQueueDpc(&m_dpc);
        m_dpc.Type = ~m_dpc.Type;
    }

    //
    // Unregister the shutdown handler
    //

    if(m_HalShutdownData.NotificationRoutine)
    {
        HalRegisterShutdownNotification(&m_HalShutdownData, FALSE);
        m_HalShutdownData.NotificationRoutine = NULL;
    }

    //
    // Free all channels
    //

    for(i = 0; i < AC97_CHANNELTYPE_COUNT; i++)
    {
        ReleaseChannel((AC97CHANNELTYPE)i);
    }

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  CreateChannel
 *
 *  Description:
 *      Allocates a channel object.  The AC97 device object and it's channels
 *      are primitive enough that you can only allocate each channel once, and
 *      neither of them support ref counting.  Oh well...
 *
 *  Arguments:
 *      AC97CHANNELTYPE [in]: channel type.
 *      CAc97Channel ** [out]: receives channel object.  The caller can
 *                             release this object by calling ReleaseChannel,
 *                             but it's not required.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CAc97Device::CreateChannel"

HRESULT
CAc97Device::CreateChannel
(
    AC97CHANNELTYPE         nChannelType, 
    CAc97Channel **         ppChannel
)
{
    HRESULT                 hr;
    
    DPF_ENTER();
    AutoIrql();
    
    ASSERT(!m_apChannels[nChannelType]);

    hr = HRFROMP(m_apChannels[nChannelType] = NEW(CAc97Channel(this, nChannelType)));

    if(SUCCEEDED(hr) && ppChannel)
    {
        *ppChannel = m_apChannels[nChannelType];
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  ReleaseChannel
 *
 *  Description:
 *      Releases a previously allocated channel.
 *
 *  Arguments:
 *      AC97CHANNELTYPE [in]: channel type.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CAc97Device::ReleaseChannel"

void
CAc97Device::ReleaseChannel
(
    AC97CHANNELTYPE         Channel
)
{
    DPF_ENTER();
    AutoIrql();
    
    DELETE(m_apChannels[Channel]);

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  AcquireCodecSemaphore
 *
 *  Description:
 *      Acquires access to the CODEC semaphore.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      BOOL: TRUE if the semaphore was acquired.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CAc97Device::AcquireCodecSemaphore"

BOOL
CAc97Device::AcquireCodecSemaphore
(
    void
)
{
    DWORD                   dwAttempts  = 1000;
    BOOL                    fAcquired   = TRUE;

    DPF_ENTER();

    while(PeekAciRegister8(AC97_SEM4) & AC97_SEM4_OWNED)
    {
        if(!dwAttempts--)
        {
            DPF_ERROR("Failed to get CODEC semaphore");
            fAcquired = FALSE;
            break;
        }

        WaitRegisterRetry();
    }

    DPF_LEAVE(fAcquired);

    return fAcquired;
}


/****************************************************************************
 *
 *  CodecReady
 *
 *  Description:
 *      Checks the AC-Link state.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      BOOL: TRUE if the CODEC is ready.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CAc97Device::CodecReady"

BOOL
CAc97Device::CodecReady
(
    void
)
{
    BOOL                    fReady      = TRUE;
    DWORD                   dwAttempts  = 1000;
    DWORD                   dwValue;
    
    DPF_ENTER();

    //
    // Get the value of the control register.
    //

    dwValue = PeekAciRegister32(GLB_CTRL);
    
    //
    // If the AC_RST# line is low, raise it and do a cold reset.
    //

    if(!(dwValue & GLB_CTRL_COLD))
    {
        DPF_AC97("Performing cold reset");
        
        dwValue |= GLB_CTRL_COLD;

        PokeAciRegister32(GLB_CTRL, dwValue);
    }

    //
    // If the AC link is down, raise it and do a warm reset.  This is only
    // needed if agressive power management is used.
    //

    if(dwValue & GLB_CTRL_ACSD)
    {
        DPF_AC97("Performing warm reset");
        
        dwValue &= ~(GLB_CTRL_ACSD | GLB_CTRL_WARM);

        PokeAciRegister32(GLB_CTRL, dwValue);
    }

    //
    // Check to see if the ready bit is set.  This takes a maximum of 200us.
    //

    while(!(PeekAciRegister32(GLB_STATUS) & GLB_STATUS_PCR))
    {
        if(!dwAttempts--)
        {
            DPF_ERROR("Timed out waiting for ready bit");
            fReady = FALSE;
            break;
        }

        WaitRegisterRetry();
    }

    if(fReady)
    {
        DPF_AC97("CODEC ready");
    }

    DPF_LEAVE(fReady);

    return fReady;
}


/****************************************************************************
 *
 *  GetInterruptStatus
 *
 *  Description:
 *      Determines if there is an interrupt pending for the device.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      DWORD: interrupt status.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CAc97Device::GetInterruptStatus"

DWORD
CAc97Device::GetInterruptStatus
(
    void
)
{
    static const DWORD      dwStatusMask    = GLB_STATUS_AOINT | GLB_STATUS_SOINT | GLB_STATUS_GPINT;

    return PeekAciRegister32(GLB_STATUS) & dwStatusMask;
}


/****************************************************************************
 *
 *  ServiceAciInterrupt
 *
 *  Description:
 *      Services interrupts for the device.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      DWORD: bitmask of the channels that triggered the interrupt.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CAc97Device::ServiceAciInterrupt"

DWORD
CAc97Device::ServiceAciInterrupt
(
    void
)
{
    static const DWORD      adwChannelStatusMasks[AC97_CHANNELTYPE_COUNT] = 
    { 
        GLB_STATUS_AOINT, 
        GLB_STATUS_SOINT,
    };

    DWORD                   dwInterruptMask;
    DWORD                   dwStatus;
    WORD                    wChannelStatus;
    DWORD                   i;

    DPF_ENTER();

    //
    // Get the ACI interrupt status bits
    //

    if(dwStatus = GetInterruptStatus())
    {
        //
        // Set the interrupt mask to a non-zero value that won't conflict
        // with any of the channel-specific values.
        //
        
        dwInterruptMask = 0x80000000;

        //
        // Handle channel interrupts
        //
        
        for(i = 0; i < AC97_CHANNELTYPE_COUNT; i++)
        {
            if(dwStatus & adwChannelStatusMasks[i])
            {
                if(m_apChannels[i])
                {
                    //
                    // Ok, this channel had an interrupt.  The only ones we
                    // really care about are buffer completion interrupts.
                    // If either of those are set in the channel status 
                    // registers, increment the channel's count of pending
                    // completions and schedule a DPC to handle them.
                    //

                    wChannelStatus = m_apChannels[i]->PeekAciRegister16(X_STATUS);

                    if(wChannelStatus & X_STATUS_FIFOE) 
                    {
                        DPF_AC97("(channel %lu) FIFO underrun", i);
                    }

                    if(wChannelStatus & X_STATUS_CIELV)
                    {
                        DPF_AC97("(channel %lu) Current index equals last valid", i);
                    }

                    if(wChannelStatus & X_STATUS_LVBCI)
                    {
                        DPF_AC97("(channel %lu) Last valid buffer completion interrupt", i);
                    }
                
                    if(wChannelStatus & X_STATUS_BCI)
                    {
                        DPF_AC97("(channel %lu) Buffer completed", i);

                        dwInterruptMask |= AC97_CHANNELINTERRUPT(i);

                        if(m_dwFlags & AC97_OBJECTF_DIRECTISR)
                        {
                            m_apChannels[i]->ServiceInterrupt();
                        }
                        else
                        {
                            m_abPendingBufferCompletions[i][0]++;
                        }
                    }

                    m_apChannels[i]->PokeAciRegister16(X_STATUS, wChannelStatus);
                }
                else
                {
                    DPF_WARNING("Channel %lu not allocated!", i);
                }
            }
        }
    
        //
        // Schedule a DPC to handle any buffer completion interrupts
        //

        if(!(m_dwFlags & AC97_OBJECTF_DIRECTISR) && (dwInterruptMask & AC97_CHANNELINTERRUPT_MASK))
        {
            KeInsertQueueDpc(&m_dpc, NULL, NULL);
        }

        //
        // Acknowlege the interrupt
        //
        
        PokeAciRegister32(GLB_STATUS, dwStatus & ~GLB_STATUS_GPINT);
    }
    else
    {
        //
        // Not our interrupt
        //

        dwInterruptMask = 0;
    }

    DPF_LEAVE(dwInterruptMask);

    return dwInterruptMask;
}


/****************************************************************************
 *
 *  ServiceAciInterruptDpc
 *
 *  Description:
 *      Services interrupts for the device.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CAc97Device::ServiceAciInterruptDpc"

void
CAc97Device::ServiceAciInterruptDpc
(
    void
)
{
    BOOL                    fContinue;
    DWORD                   i;

    DPF_ENTER();

    do
    {
        //
        // Copy live buffer completion counts to cached
        //

        KeSynchronizeExecution(&m_Interrupt, AciSynchronizationRoutine, this);

        //
        // Handle all pending buffer completions
        //

        for(i = 0, fContinue = FALSE; i < AC97_CHANNELTYPE_COUNT; i++)
        {
            if(m_abPendingBufferCompletions[i][1])
            {
                fContinue = TRUE;

                if(m_apChannels[i])
                {
                    do
                    {
                        m_apChannels[i]->ServiceInterrupt();
                    }
                    while(--m_abPendingBufferCompletions[i][1]);
                }
                else
                {
                    m_abPendingBufferCompletions[i][1] = 0;
                }
            }
        }
    }
    while(fContinue);

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  SynchronizeAciInterrupt
 *
 *  Description:
 *      Interrupt synchonization function.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CAc97Device::SynchronizeAciInterrupt"

void
CAc97Device::SynchronizeAciInterrupt
(
    void
)
{
    DWORD                   i;

    DPF_ENTER();

    //
    // Copy live pending buffer completions to cached and clear the live
    // ones.
    //

    for(i = 0; i < AC97_CHANNELTYPE_COUNT; i++)
    {
        m_abPendingBufferCompletions[i][1] += m_abPendingBufferCompletions[i][0];

        m_abPendingBufferCompletions[i][0] = 0;
    }

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  PeekAc97Register
 *
 *  Description:
 *      Gets the contents of an AC '97 register.
 *
 *  Arguments:
 *      AC97REGISTER [in]: register.
 *      LPWORD [out]: register value.
 *
 *  Returns:  
 *      BOOL: TRUE on success.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CAc97Device::PeekAc97Register"

BOOL
CAc97Device::PeekAc97Register
(
    AC97REGISTER            reg,
    LPWORD                  pwValue
)
{
    DWORD                   dwStatus;
    BOOL                    fSuccess;

    DPF_ENTER();
    
    //
    // Acquire the CODEC semaphore
    //

    fSuccess = AcquireCodecSemaphore();

    //
    // Read the contents of the register
    //

    if(fSuccess)
    {
        *pwValue = PeekRegister16(m_dwAc97RegisterBase + (reg * 2));
    }

    //
    // Make sure the read was successful
    //

    if(fSuccess)
    {
        if((dwStatus = PeekAciRegister32(GLB_STATUS)) & GLB_STATUS_RCS)
        {
            //
            // Nope.  Clear the bit.
            //

            DPF_ERROR("AC '97 register peek failed");
            
            PokeAciRegister32(GLB_STATUS, dwStatus & ~GLB_STATUS_RCS);
            
            fSuccess = FALSE;
        }
    }

    DPF_LEAVE(fSuccess);

    return fSuccess;
}


/****************************************************************************
 *
 *  PokeAc97Register
 *
 *  Description:
 *      Writes the contents of an AC '97 register.
 *
 *  Arguments:
 *      AC97REGISTER [in]: register.
 *      WORD [in]: register value.
 *
 *  Returns:  
 *      BOOL: TRUE on success.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CAc97Device::PokeAc97Register"

BOOL
CAc97Device::PokeAc97Register
(
    AC97REGISTER            reg,
    WORD                    wValue
)
{
    BOOL                    fSuccess;

    DPF_ENTER();
    
    //
    // Acquire the CODEC semaphore
    //

    fSuccess = AcquireCodecSemaphore();

    //
    // Write to the register
    //

    if(fSuccess)
    {
        PokeRegister16(m_dwAc97RegisterBase + (reg * 2), wValue);
    }

    DPF_LEAVE(fSuccess);

    return fSuccess;
}


/****************************************************************************
 *
 *  VerifyPokeAc97Register
 *
 *  Description:
 *      Writes the contents of an AC '97 register and verifies that it 
 *      stuck.
 *
 *  Arguments:
 *      AC97REGISTER [in]: register.
 *      WORD [in]: register value.
 *
 *  Returns:  
 *      BOOL: TRUE on success.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CAc97Device::VerifyPokeAc97Register"

BOOL
CAc97Device::VerifyPokeAc97Register
(
    AC97REGISTER            reg,
    WORD                    wValue
)
{
    WORD                    wNewValue;
    BOOL                    fSuccess;

    DPF_ENTER();
    
    //
    // Write the new value
    //

    fSuccess = PokeAc97Register(reg, wValue);

    //
    // Read back the new value
    //

    if(fSuccess)
    {
        fSuccess = PeekAc97Register(reg, &wNewValue);
    }

    //
    // Did it stick?
    //

    if(fSuccess && (wValue != wNewValue))
    {
        fSuccess = FALSE;
    }

    DPF_LEAVE(fSuccess);

    return fSuccess;
}


/****************************************************************************
 *
 *  PowerUp
 *
 *  Description:
 *      Sets the CODEC to full power.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CAc97Device::PowerUp"

HRESULT
CAc97Device::PowerUp
(
    void
)
{
    HRESULT                 hr  = DS_OK;
    
    DPF_ENTER();

    //
    // Set the CODEC to full power
    //

    if(!PokeAc97Register(AC97REG_POWERDOWN, AC97REG_PCS_FULL_POWER))
    {
        DPF_ERROR("Failed to set power state");
        hr = DSERR_GENERIC;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  CAc97Channel
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      CAc97Device * [in]: parent device.
 *      DWORD [in]: channel register base offset.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CAc97Channel::CAc97Channel"

const DWORD CAc97Channel::m_adwRegisterOffsets[AC97_CHANNELTYPE_COUNT] = 
{ 
    AO_BL_BASE, 
    SO_BL_BASE,
};

const DWORD CAc97Channel::m_dwSilenceSize = 0x2000;

CAc97Channel::CAc97Channel
(
    CAc97Device *           pDevice,
    AC97CHANNELTYPE         nChannelType
)
:   m_nChannelType(nChannelType)
{

    DPF_ENTER();

    //
    // Initialize defaults
    //

    m_dwMode = DSAC97_MODE_DEFAULT;

    //
    // Save a pointer back to the parent device.  Note that we're not 
    // AddRef'ing it, since the device controls our construction and 
    // destruction.
    //

    m_pDevice = pDevice;

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  ~CAc97Channel
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CAc97Channel::~CAc97Channel"

CAc97Channel::~CAc97Channel
(
    void
)
{
    DPF_ENTER();
    
    Terminate();

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  Initialize
 *
 *  Description:
 *      Initializes the object.
 *
 *  Arguments:
 *      DWORD [in]: flags.
 *      LPFNAC97CHANNELCALLBACK [in]: interrupt callback function.
 *      LPVOID [in]: interrupt callback context.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CAc97Channel::Initialize"

HRESULT
CAc97Channel::Initialize
(
    DWORD                   dwFlags,
    LPFNAC97CHANNELCALLBACK pfnCallback,
    LPVOID                  pvContext
)
{
    HRESULT                 hr;
    
    DPF_ENTER();
    AutoIrql();


    m_dwFlags = dwFlags;
    m_pfnCallback = pfnCallback;
    m_pvCallbackContext = pvContext;

    //
    // Allocate the PRDL
    //

    hr = HRFROMP(m_pPrdl = PHYSALLOC(ACIPRD, ACIPRDL_ENTRY_COUNT, PAGE_SIZE, PAGE_READWRITE));

    if(SUCCEEDED(hr))
    {
        m_dwPrdlAddress = MmGetPhysicalAddress(m_pPrdl);
    }

    //
    // If we're a stream, allocate a packet of silence to loop on when we
    // starve.
    //

    if(SUCCEEDED(hr) && (dwFlags & AC97CHANNEL_OBJECTF_STREAM))
    {
        hr = HRFROMP(m_pvSilence = PHYSALLOC(BYTE, m_dwSilenceSize, PAGE_SIZE, PAGE_READWRITE));
    }

    //
    // Reset the channel
    //

    if(SUCCEEDED(hr))
    {
        Reset();
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  Terminate
 *
 *  Description:
 *      Uninitializes the object.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CAc97Channel::Terminate"

void
CAc97Channel::Terminate
(
    void
)
{
    DPF_ENTER();
    AutoIrql();

    //
    // Reset the channel
    //

    Flush();
    
    //
    // Free resources
    //

    PHYSFREE(m_pPrdl);
    PHYSFREE(m_pvSilence);

    m_dwPrdlAddress = 0;

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  AttachPacket
 *
 *  Description:
 *      Attaches an audio data packet to be played.
 *
 *  Arguments:
 *      DWORD [in]: data buffer physical memory address.
 *      DWORD [in]: data buffer size, in bytes.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CAc97Channel::AttachPacket"

void
CAc97Channel::AttachPacket
(
    DWORD                   dwBufferAddress,
    DWORD                   dwBufferSize
)
{
    BYTE                    bPrdIndex;
    
    DPF_ENTER();
    AutoIrql();

    ASSERT(m_bPrdCount < ACIPRDL_ENTRY_COUNT);
    ASSERT((dwBufferSize / (m_pDevice->m_wfxFormat.wBitsPerSample / 8)) <= 0xFFFF);
    ASSERT(!(dwBufferSize % m_pDevice->m_wfxFormat.nBlockAlign));

    if(!(m_dwFlags & AC97CHANNEL_OBJECTF_STREAM))
    {
        ASSERT(!m_bCurrentPrd);
    }

    //
    // If a discontinuity has been signaled, but another packet has been
    // attached, we can remove the discontinuity by resetting the flags and
    // removing the silence packet.  The easiest way to remove the silence
    // packet is to just stomp on the PRD.
    //

    if(m_dwFlags & AC97CHANNEL_OBJECTF_DISCONTINUITY)
    {
        ASSERT(m_dwFlags & AC97CHANNEL_OBJECTF_STREAM);
        ASSERT(m_bPrdCount);
        
        m_dwFlags &= ~AC97CHANNEL_OBJECTF_DISCONTINUITY;

        m_bPrdCount--;
    }

    //
    // Add the PRD to the end of the list.  We're assuming that the buffer
    // is already locked.
    //

    bPrdIndex = (m_bCurrentPrd + m_bPrdCount) & ACIPRDL_ENTRY_MASK;

    m_pPrdl[bPrdIndex].dwPhysicalAddress = dwBufferAddress;
    m_pPrdl[bPrdIndex].wLength = LOWORD(dwBufferSize / (m_pDevice->m_wfxFormat.wBitsPerSample / 8));
    m_pPrdl[bPrdIndex].wReserved = 0;
    m_pPrdl[bPrdIndex].fBufferUnderrunPolicy = TRUE;
    m_pPrdl[bPrdIndex].fInterruptOnCompletion = TRUE;

    DPF_AC97("(channel %lu) PRD %d set to %x %x", m_nChannelType, (int)bPrdIndex, m_pPrdl[bPrdIndex].dwPhysicalAddress, (DWORD)m_pPrdl[bPrdIndex].wLength);

    //
    // Inform the hardware that the last valid PRD has changed
    //

    SetPrdIndeces(m_bCurrentPrd, m_bPrdCount + 1, FALSE, TRUE);

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  AttachBuffer
 *
 *  Description:
 *      Attaches an audio data packet to be played.
 *
 *  Arguments:
 *      DWORD [in]: data buffer physical memory address.
 *      DWORD [in]: data buffer size, in bytes.
 *      DWORD [in]: count of packets to split the buffer into.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CAc97Channel::AttachBuffer"

void
CAc97Channel::AttachBuffer
(
    DWORD                   dwBufferAddress,
    DWORD                   dwBufferSize,
    DWORD                   dwPacketCount
)
{
    DPF_ENTER();
    AutoIrql();

    //
    // Attach the buffer in as many packets as were specified
    //

    ASSERT(!(dwBufferSize % dwPacketCount));

    dwBufferSize /= dwPacketCount;

    while(dwPacketCount--)
    {
        AttachPacket(dwBufferAddress, dwBufferSize);

        dwBufferAddress += dwBufferSize;
    }

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  Discontinuity
 *
 *  Description:
 *      Signals that the stream may starve.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CAc97Channel::Discontinuity"

void
CAc97Channel::Discontinuity
(
    void
)
{
    DPF_ENTER();
    AutoIrql();

    ASSERT(m_dwFlags & AC97CHANNEL_OBJECTF_STREAM);

    //
    // Attach a packet of silence that the DMA can spin on when we starve.
    //

    if(!(m_dwFlags & AC97CHANNEL_OBJECTF_DISCONTINUITY))
    {
        AttachPacket(m_pvSilence, m_dwSilenceSize);

        m_dwFlags |= AC97CHANNEL_OBJECTF_DISCONTINUITY;
    }

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  ServiceInterrupt
 *
 *  Description:
 *      Services interrupts for the channel.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CAc97Channel::ServiceInterrupt"

void
CAc97Channel::ServiceInterrupt
(
    void
)
{
    DPF_ENTER();

    if(m_bPrdCount)
    {
        //
        // A buffer has completed.  If we're a stream, we'll need to increment
        // the first PRD index and decrement the count in order to detach the
        // packet.
        //
        // If we're out of PRDs, stop the DMA.  This only happens because you
        // starved the stream.  Until we get a chance to stop the DMA, it's 
        // going to continue to play the last PRD over again.  If you know 
        // you're going to starve me, attach a packet of silence.
        //

        m_dwPosition += m_pPrdl[m_bCurrentPrd].wLength;

        if(m_dwFlags & AC97CHANNEL_OBJECTF_STREAM)
        {
            if(m_bPrdCount > 2)
            {
                SetPrdIndeces(m_bCurrentPrd + 1, m_bPrdCount - 1, FALSE, FALSE);
            }
            else
            {
                if(!(m_dwFlags & AC97CHANNEL_OBJECTF_DISCONTINUITY))
                {
                    DPF_WARNING("AC'97 stream starving");
                }
                
                Flush(FALSE);
            }
        }
        else
        {
            SetPrdIndeces(m_bCurrentPrd + 1, m_bPrdCount, FALSE, FALSE);
        }

        //
        // Notify the callback function
        //

        if(m_pfnCallback)
        {
            m_pfnCallback(m_pvCallbackContext);
        }
    }

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  Reset
 *
 *  Description:
 *      Resets DMA registers.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CAc97Channel::Reset"

void
CAc97Channel::Reset
(
    void
)
{
    DPF_ENTER();
    AutoIrql();

    DPF_AC97("(channel %lu) Resetting DMA registers", m_nChannelType);

    //
    // Reset the channel
    //

    PokeAciRegister8(X_CTRL, X_CTRL_RBMR);

    //
    // Wait for the reset to be acknowledged
    //

    while(PeekAciRegister8(X_CTRL) & X_CTRL_RBMR);

    //
    // Set the PRDL location
    //

    PokeAciRegister32(X_BL_BASE, m_dwPrdlAddress);

    //
    // If this is the S/PDIF channel, set the output mode
    //

    if(AC97_CHANNELTYPE_DIGITAL == m_nChannelType)
    {
        PokeAciRegister32(X_STWD, m_dwMode);
    }

    //
    // Reset PRD indeces
    //

    SetPrdIndeces(m_bCurrentPrd, m_bPrdCount, TRUE, TRUE);

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  Flush
 *
 *  Description:
 *      Resets the object and flushes all packets.
 *
 *  Arguments:
 *      BOOL [in]: TRUE to reset the cursor position.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CAc97Channel::Flush"

void
CAc97Channel::Flush
(
    BOOL                    fResetPosition
)
{
    BYTE                    bState;

    DPF_ENTER();
    AutoIrql();

    //
    // Stop the DMA
    //
    
    Pause();

    //
    // Reset the channel
    //

    Reset();

    //
    // Update PRD indeces
    //

    SetPrdIndeces(0, 0, TRUE, TRUE);

    //
    // Remove any existing discontinuity
    //

    m_dwFlags &= ~AC97CHANNEL_OBJECTF_DISCONTINUITY;

    //
    // Reset stored positions
    //

    if(fResetPosition)
    {
        m_dwPosition = 0;
        m_dwLastPosition = 0;
    }

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  Run
 *
 *  Description:
 *      Starts the DMA running.
 *
 *  Arguments:
 *      DWORD [in]: PRD position.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CAc97Channel::Run"

void
CAc97Channel::Run
(
    DWORD                   dwPosition
)
{
    DPF_ENTER();
    AutoIrql();

    ASSERT(m_bPrdCount);

    //
    // Check the channel status.  If the DMA is halted, we'll have to
    // reset before we can run.
    //

    if(PeekAciRegister16(X_STATUS) & X_STATUS_DCH)
    {
        Reset();
    }

    //
    // Set the buffer position
    //

    if(-1 != dwPosition)
    {
        SetPosition(dwPosition);
    }

    //
    // Set the channel to RUN state and enable interrupts
    //

    PokeAciRegister8(X_CTRL, X_CTRL_IOCE | X_CTRL_FEIE | X_CTRL_LVBIE | X_CTRL_RPBM);

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  Pause
 *
 *  Description:
 *      Pauses the DMA.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CAc97Channel::Pause"

void
CAc97Channel::Pause
(
    void
)
{
    DPF_ENTER();
    AutoIrql();

    PokeAciRegister8(X_CTRL, 0);

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  SetPrdIndeces
 *
 *  Description:
 *      Sets the current PRDL index and count.
 *
 *  Arguments:
 *      DWORD [in]: index.
 *      DWORD [in]: count.
 *      BOOL [in]: TRUE to apply the current PRD index to the hardware.
 *                 In some cases, we may be calling this function late and it
 *                 may be better not to overwrite the hardware value.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CAc97Channel::SetPrdIndeces"

void
CAc97Channel::SetPrdIndeces
(
    BYTE                    bCurrentPrd,
    BYTE                    bPrdCount,
    BOOL                    fApplyCurrent,
    BOOL                    fApplyLast
)
{
    BYTE                    bLastPrd;
    
    DPF_ENTER();
    AutoIrql();

    //
    // Calculate the current and last valid PRDs
    //

    if(bPrdCount)
    {
        ASSERT(bPrdCount <= ACIPRDL_ENTRY_COUNT);

        bLastPrd = bCurrentPrd + bPrdCount - 1;

        if(m_dwFlags & AC97CHANNEL_OBJECTF_STREAM)
        {
            bCurrentPrd &= ACIPRDL_ENTRY_MASK;
            bLastPrd &= ACIPRDL_ENTRY_MASK;
        }
        else
        {
            bCurrentPrd %= bPrdCount;
            bLastPrd %= bPrdCount;
        }
    }
    else
    {
        bCurrentPrd = 0;
        bLastPrd = 0;
    }

    //
    // Inform the hardware
    //
    
    if(fApplyCurrent)
    {
        PokeAciRegister8(X_CUR_IDX, bCurrentPrd);
    }

    if(fApplyLast)
    {
        PokeAciRegister8(X_LST_IDX, bLastPrd);
    }

    m_bCurrentPrd = bCurrentPrd;
    m_bPrdCount = bPrdCount;

    DPF_AC97("(channel %lu) PRD indeces set to %d, %d (%d)", m_nChannelType, (int)bCurrentPrd, (int)bLastPrd, (int)bPrdCount);

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  SetMode
 *
 *  Description:
 *      Sets the digital channel's output mode.
 *
 *  Arguments:
 *      DWORD [in]: mode.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CAc97Channel::SetMode"

void
CAc97Channel::SetMode
(
    DWORD                   dwMode
)
{
    BYTE                    bState;
    
    DPF_ENTER();
    AutoIrql();

    if(AC97_CHANNELTYPE_DIGITAL == m_nChannelType)
    {
        //
        // Save the mode
        //

        m_dwMode = dwMode;

        //
        // Update the STWD register
        //

        PokeAciRegister32(X_STWD, m_dwMode);
    }

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  GetPosition
 *
 *  Description:
 *      Gets the buffer or stream position
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      DWORD: absolute stream position.
 *
 ****************************************************************************/

#ifndef MCPX_BOOT_LIB

#undef DPF_FNAME
#define DPF_FNAME "CAc97Channel::GetPosition"

DWORD
CAc97Channel::GetPosition
(
    void
)
{
    DWORD               dwLastPosition;
    DWORD               dwPosition;
    DWORD               dwLength;
    BYTE                bCurrentPrd;
        
    DPF_ENTER();

    if(m_bPrdCount)
    {
        //
        // Calculate the position until we get the same position twice.
        // That way, we don't have to synchronize this function with the
        // ISR.
        //
    
        dwPosition = -1;

        int iTry = 0;

        while(TRUE)
        {
            iTry++;
            
            //
            // Save the last position we got
            //

            dwLastPosition = dwPosition;

            //
            // Check the PRD index register and compare it to our own index.
            // There seems to be some delay between when the DMA program
            // changes PRDs and when we get notified.
            //

            if((bCurrentPrd = PeekAciRegister8(X_CUR_IDX)) == m_bCurrentPrd)
            {

#ifdef DEBUG
                //
                // Since they're in sync, we should never be playing the
                // discontinuity packet.
                //

                if(m_dwFlags & AC97CHANNEL_OBJECTF_DISCONTINUITY)
                {
                    if(m_bPrdCount <= 1)
                    {
                        if((bCurrentPrd = PeekAciRegister8(X_CUR_IDX)) == m_bCurrentPrd)
                        {
                            ASSERTMSG("Improperly looping on the discontinuity packet");
                        }
                    }
                }

#endif // DEBUG

                //
                // The position in the ACI register is really the count of samples 
                // left to transfer.
                //

                dwLength = m_pPrdl[m_bCurrentPrd].wLength;

                dwPosition = PeekAciRegister16(X_CUR_POS);

                if(dwPosition <= dwLength)
                {
                    dwPosition = dwLength - dwPosition;
                }
                else
                {
                    dwPosition = 0;
                }
            }
            else
            {
                //
                // Our internal state and the hardware's aren't in synch.  Simply
                // return that we're at the end of the current packet
                //

                dwPosition = m_pPrdl[m_bCurrentPrd].wLength;
            }

            //
            // Add the absolute stream position.  If you're a buffer, well, you'll
            // need to MOD this value with the buffer size.  We don't currently 
            // have any buffer clients of this function, so why bother writing
            // the code?
            //

            dwPosition += m_dwPosition;

            //
            // Compare this position to the last one we calculated.  If they 
            // match, we can quit looping.
            //

            if(dwLastPosition == dwPosition)
            {
                //
                // Compare this position to the last one we returned.  If the 
                // current position is less than the last one, the buffer has 
                // wrapped, but the interrupt hasn't happened yet.
                //

                if(dwPosition >= m_dwLastPosition)
                {
                    m_dwLastPosition = dwPosition;
                }
                else
                {
                    dwPosition = m_dwLastPosition;
                }

                break;
            }

            //
            // If we're at raised IRQL, we can't loop
            //

            if(KeGetCurrentIrql() >= DISPATCH_LEVEL)
            {
                break;
            }
        }
    }
    else
    {
        dwPosition = m_dwPosition;
    }

    //
    // Convert sample position to bytes
    //

    dwPosition *= m_pDevice->m_wfxFormat.wBitsPerSample / 8;

    DPF_LEAVE(dwPosition);

    return dwPosition;
}

#endif


/****************************************************************************
 *
 *  SetPosition
 *
 *  Description:
 *      Sets the current PRD-relative position.
 *
 *  Arguments:
 *      DWORD [in]: PRD position.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CAc97Channel::SetPosition"

void
CAc97Channel::SetPosition
(
    DWORD               dwPosition
)
{
    DWORD               dwLength;

    DPF_ENTER();

    //
    // Make sure we're stopped
    //

    ASSERT(!PeekAciRegister8(X_CTRL));

    //
    // Convert byte position to samples
    //

    dwPosition /= m_pDevice->m_wfxFormat.wBitsPerSample / 8;

    //
    // Convert buffer position to samples remaining
    //

    dwLength = m_pPrdl[m_bCurrentPrd].wLength;
    ASSERT(dwPosition <= dwLength);
    
    dwPosition = dwLength - dwPosition;

    //
    // Set the position
    //

    ASSERT(dwPosition < 0xFFFF);
    PokeAciRegister16(X_CUR_POS, (WORD)dwPosition);

    //
    // Clear the last returned position
    //

    m_dwLastPosition = 0;

    DPF_LEAVE_VOID();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\inc\wmaxmo.h ===
/***************************************************************************
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       wmaxmo.h
 *  Content:    WMA XMO API.
 *  History:
 *   Date       By        Reason
 *   ====       ==        ======
 *  07/26/00    jpalevic  Created.
 *
 ****************************************************************************/

#ifndef __WMAXMO_H__
#define __WMAXMO_H__

#include <dsound.h>
#include "wma_dec_win32_x86.h"

//
// Xbox WMA decompressor interface
//

DWORD WINAPI WmaXmoThreadProc(
   LPVOID lpParameter   // thread data
);


// You must provide at least these many bytes of valid header data when
// initializing the CWMAMediaObject. (Of course, if the file is smaller
// than this size, just provide as many bytes as are in the file.)

#define WMAMO_HEADER_SIZE 2048


typedef struct _WMAXMO_ASYNC_CONTEXT {

    LIST_ENTRY ListEntry;
    PVOID pThis;
    XMEDIAPACKET Xmp;

} WMAXMO_ASYNC_CONTEXT, *PWMAXMO_ASYNC_CONTEXT;

VOID
WMAAsyncFileReadCallback (
    IN PVOID ApcContext,
    IN PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG Reserved
    );

class CWMAXMediaObject: public XWmaFileMediaObject {

public:
    CWMAXMediaObject();
    ~CWMAXMediaObject();

    HRESULT STDMETHODCALLTYPE Initialize(
        PCSTR pszFileName,
        HANDLE hFile,
        BOOL fAsyncMode,
        DWORD dwLookahead,
        DWORD dwMaxPackets,
        DWORD dwYieldRate,
        WAVEFORMATEX* pWave /* Pass NULL if you don't care */
		);

    HRESULT InitializeIntermediate(
        LPFNWMAXMODATACALLBACK     pCallback,
        PVOID                      pCallbackContext,
        DWORD                      dwYieldRate,
        LPWAVEFORMATEX             pwfxCompressed
        );

    STDMETHODIMP_(ULONG) AddRef() {
       return InterlockedIncrement((long*)&m_cRef);
    }

    STDMETHODIMP_(ULONG) Release() {
       long l = InterlockedDecrement((long*)&m_cRef);
       if (l == 0)
          delete this;
       return l;
    }

    HRESULT STDMETHODCALLTYPE Process( 
        LPCXMEDIAPACKET pSrcBuffer,
        LPCXMEDIAPACKET pDstBuffer
        );
    
    HRESULT STDMETHODCALLTYPE Decode( 
        LPCXMEDIAPACKET pDstBuffer
        );

	HRESULT STDMETHODCALLTYPE GetInfo(
			LPXMEDIAINFO pInfo
		);

    HRESULT STDMETHODCALLTYPE Flush();
    HRESULT STDMETHODCALLTYPE Discontinuity(void);

    HRESULT STDMETHODCALLTYPE GetStatus( 
            LPDWORD pdwStatus 
		);

	// Used in the implementation of the codec

	DWORD GetData(DWORD offset, DWORD num_bytes,
		void** ppData);

    HRESULT STDMETHODCALLTYPE Seek(LONG lOffset, DWORD dwOrigin, LPDWORD pdwAbsolute);
    HRESULT STDMETHODCALLTYPE GetLength(LPDWORD pdwLength);

    HRESULT STDMETHODCALLTYPE GetFileContentDescription(WMAXMOFileContDesc* pContentDesc);

    HRESULT STDMETHODCALLTYPE GetFileHeader(WMAXMOFileHeader *pFileHeader) {

        ASSERT(pFileHeader);
        memset(pFileHeader,0,sizeof(WMAXMOFileHeader));

        pFileHeader->dwVersion = m_hdr.version;
        pFileHeader->dwSampleRate = m_hdr.sample_rate;
        pFileHeader->dwNumChannels = m_hdr.num_channels;
        pFileHeader->dwDuration = m_hdr.duration;
        pFileHeader->dwBitrate = m_hdr.bitrate;

        return S_OK;
    }

private:

    VOID Reset();

    __inline DWORD WMASampleRateToHz(tWMAFileSampleRate sampleRate);
    HRESULT STDMETHODCALLTYPE GetFormat(
		WAVEFORMATEX* pWave);

    HRESULT ReadWmaDataFromFile(
        PVOID pvBuffer,
        DWORD dwSize,
        PWMAXMO_ASYNC_CONTEXT   pContext
        );

    friend VOID
    WMAAsyncFileReadCallback (
        IN PVOID ApcContext,
        IN PIO_STATUS_BLOCK IoStatusBlock,
        IN ULONG Reserved
        );

	tWMAFileHeader m_hdr;
	tHWMAFileState m_state;

    //
	// Used by the CBGetData callback
    //

    PUCHAR m_pSrcBuffer; 

    //
    // Used in async mode
    //

    PUCHAR m_pContextPool;

    DWORD  m_dwSrcBufferOffset;
    DWORD  m_dwCurrentWmaFileOffset;

    //
    // used for the in-memory decoder instance
    //

    LPFNWMAXMODATACALLBACK  m_pCallback;
    PVOID                   m_pCallbackContext;


protected:

    friend DWORD WINAPI WmaXmoThreadProc(
      LPVOID lpParameter   // thread data
    );

    VOID ThreadProc();

    HANDLE m_hDeleteThreadEvent;
    HANDLE m_hFile;
    OVERLAPPED m_overlapped;

    DWORD m_dwThreadId;
    CRITICAL_SECTION m_CS;
    HANDLE m_hThread;


    ULONG m_cRef;	// Reference count
    DWORD m_dwPendingPackets;
    DWORD m_dwLookaheadSize;
    DWORD m_dwMaxContexts;

    LIST_ENTRY m_AvailableList;
    LIST_ENTRY m_PendingList;

    BOOL m_bExternalHandle;
	BOOL m_bDecodeMore;
    BOOL m_bAsyncMode;

    DWORD m_dwYieldRate;

};


#endif // __WMAXMO_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voicedec\voicedecoderp.h ===
#if DBG

#define MY_ASSERT(x) if( !(x) ) _asm int 3;

extern "C"
{
	ULONG
	DebugPrint(
		PCHAR Format,
		...
		);
}

#define DEBUG_LEVEL_ERROR 0
#define DEBUG_LEVEL_WARNING 1
#define DEBUG_LEVEL_INFO 2
#define DEBUG_LEVEL_SPAM 5

extern ULONG g_VdXmoDebugLevel;
#define DBG_SPAM(_exp_) {if (g_VdXmoDebugLevel >= DEBUG_LEVEL_SPAM) DebugPrint _exp_;}
#define DBG_INFO(_exp) {if (g_VdXmoDebugLevel >= DEBUG_LEVEL_INFO) DebugPrint _exp;}
#define DBG_ERROR(_exp) {if (g_VdXmoDebugLevel >= DEBUG_LEVEL_ERROR) DebugPrint _exp;}
#define DBG_WARN(_exp) {if (g_VdXmoDebugLevel >= DEBUG_LEVEL_WARNING) DebugPrint _exp;}

#else

#define MY_ASSERT(x)
#define DBG_SPAM(_exp_)
#define DBG_INFO(_exp_)
#define DBG_ERROR(_exp_)
#define DBG_WARN(_exp_)

#endif


class CVoiceDecoderXmo: public XMediaObject
{
protected:
    DWORD m_dwMinOutputSize;
    DWORD m_dwMinInputSize;
    DWORD m_dwCurrentSeqNum;

    LPXMEDIAOBJECT m_pDecoderXmo;

    DWORD m_cRef;

public:

	CVoiceDecoderXmo() 
        : m_dwMinInputSize(sizeof(VOICE_ENCODER_HEADER))
        , m_dwMinOutputSize(0)
        , m_cRef(0)
        , m_dwCurrentSeqNum(0)
		{};

	~CVoiceDecoderXmo();
	
    STDMETHODIMP_(ULONG) AddRef() {
       return InterlockedIncrement((long*)&m_cRef);
    }

    STDMETHODIMP_(ULONG) Release() {
       long l = InterlockedDecrement((long*)&m_cRef);
       if (l == 0)
          delete this;
       return l;
    }

    HRESULT STDMETHODCALLTYPE Process( 
        LPCXMEDIAPACKET pSrcBuffer,
        LPCXMEDIAPACKET pDstBuffer
        );
    
	HRESULT STDMETHODCALLTYPE GetInfo(
        LPXMEDIAINFO pInfo
		);

    HRESULT STDMETHODCALLTYPE Flush();
    HRESULT STDMETHODCALLTYPE Discontinuity(void);

    HRESULT STDMETHODCALLTYPE GetStatus( 
        LPDWORD pdwStatus 
		);


	HRESULT Init(
        DWORD dwCodecTag,
        PWAVEFORMATEX pwfx);

private:

};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voicedec\voicedecoder.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  2/20/2001 georgioc created
 *
 ***************************************************************************/

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#ifdef __cplusplus
}
#endif // __cplusplus

#include "dsoundp.h"

#include "voiceencoder.h"
#include "voicedecoderp.h"

#include "xvocver.h"


EXTERN_C HRESULT WINAPI VoxwareCreateConverter(WORD wEncodeFormatTag, BOOL fCreateEncoder, LPVOICECODECWAVEFORMAT pwfxEncoded, LPWAVEFORMATEX pwfxDecoded, LPXMEDIAOBJECT *ppMediaObject);

#if DBG

    ULONG g_VdXmoDebugLevel = DEBUG_LEVEL_INFO;

#endif

XBOXAPI
EXTERN_C  HRESULT WINAPI
XVoiceDecoderCreateMediaObject(
    DWORD dwCodecTag,
    PWAVEFORMATEX pwfx,
    XMediaObject **ppXMO
    )
{
    XMediaObject *pXmo;
    HRESULT hr;

    pXmo = new CVoiceDecoderXmo();
    MY_ASSERT(pXmo);

    if (pXmo == NULL) {
        return E_OUTOFMEMORY;
    }

    hr = ((CVoiceDecoderXmo *)pXmo)->Init(
             dwCodecTag,
             pwfx);

    if (SUCCEEDED(hr)) {

        *ppXMO = pXmo;

    }

    return hr;

}



CVoiceDecoderXmo::~CVoiceDecoderXmo()
{

    if (m_pDecoderXmo) {

        m_pDecoderXmo->Release();
        m_pDecoderXmo = NULL;

    }

}

HRESULT CVoiceDecoderXmo::Init(
    DWORD dwCodecTag,
    PWAVEFORMATEX pwfx)
{

    MY_ASSERT(pwfx);


    AddRef();

    //
    // instantiate the proper vox compressor
    //
    
    return VoxwareCreateConverter((WORD)dwCodecTag,
                                  FALSE,
                                  NULL,
                                  pwfx,
                                  &m_pDecoderXmo);

    
}

HRESULT STDMETHODCALLTYPE CVoiceDecoderXmo::Flush()
{

    return S_OK;

}

HRESULT STDMETHODCALLTYPE CVoiceDecoderXmo::Process( 
    LPCXMEDIAPACKET pSrc,
    LPCXMEDIAPACKET pDst
    )
{
    PVOICE_ENCODER_HEADER pHeader;
    HRESULT hr = S_OK;

    MY_ASSERT(pSrc);
    MY_ASSERT(pDst);

    MY_ASSERT(pSrc->dwMaxSize >= m_dwMinInputSize);
    MY_ASSERT(pDst->dwMaxSize >= m_dwMinOutputSize);

    MY_ASSERT(pDst->pvBuffer);
    MY_ASSERT(pSrc->pvBuffer);

    //
    // get packet header form source packet
    //

    pHeader = (PVOICE_ENCODER_HEADER) pSrc->pvBuffer;
    

    //
    // now invoke the decoder XMO to decompress the data
    //

    if (pHeader->bType == VOICE_MESSAGE_TYPE_VOICE) {

        XMEDIAPACKET * pXmp;
        MY_ASSERT(pSrc->dwMaxSize >= sizeof(VOICE_ENCODER_HEADER));

        pXmp = (XMEDIAPACKET *)pSrc;

        //
        // change the src packet buffer so the decoder does not try to munge the header
        //

        pXmp->pvBuffer = (PUCHAR)pHeader + sizeof(VOICE_ENCODER_HEADER);
        pXmp->dwMaxSize -= sizeof(VOICE_ENCODER_HEADER);

        hr = m_pDecoderXmo->Process(pSrc,
                                    pDst);


        //
        // re adjust src packet buffer and size
        //

        pXmp->pvBuffer = (PUCHAR)pHeader;
        pXmp->dwMaxSize += sizeof(VOICE_ENCODER_HEADER);

        //
        // the intermediate codec XMO has already updated pdwstatus, etc
        // 


    } else {

        //
        // if not voice was send, return zero
        //

        if (pDst->pdwCompletedSize) {

            *pDst->pdwCompletedSize = 0;

        }

        if (pDst->pdwStatus) {

            *pDst->pdwStatus = XMEDIAPACKET_STATUS_SUCCESS;

        }

    }

    //
    // set input packet results
    //

    if (pSrc->pdwCompletedSize) {

        *pSrc->pdwCompletedSize = pSrc->dwMaxSize;

    }

    if (pSrc->pdwStatus) {

        if (FAILED(hr)) {

            *pSrc->pdwStatus = XMEDIAPACKET_STATUS_FAILURE;

        } else {

            *pSrc->pdwStatus = XMEDIAPACKET_STATUS_SUCCESS;

        }
        
    }

    return hr;
}


HRESULT STDMETHODCALLTYPE CVoiceDecoderXmo::GetInfo( LPXMEDIAINFO pInfo )
{
    HRESULT hr;
    MY_ASSERT(pInfo);

    //
    // use the info from the encoder xmo
    //

    hr = m_pDecoderXmo->GetInfo(pInfo);
    if (FAILED(hr)) {
        return hr;
    }

    //
    // our minimum size has to account for the header
    //
    pInfo->dwInputSize += sizeof(VOICE_ENCODER_HEADER); 
    m_dwMinOutputSize = pInfo->dwOutputSize;

    return S_OK;
}
                                                   
HRESULT STDMETHODCALLTYPE CVoiceDecoderXmo::Discontinuity(void){
   return S_OK;
}

HRESULT STDMETHODCALLTYPE CVoiceDecoderXmo::GetStatus( 
    LPDWORD pdwStatus
    )
{

    if (pdwStatus) {

        *pdwStatus = XMO_STATUSF_ACCEPT_OUTPUT_DATA | XMO_STATUSF_ACCEPT_INPUT_DATA;

    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\inc\wma_dec_win32_x86.h ===
/*
 * Windows Media Audio (WMA) Decoder API
 *
 * Copyright (c) Microsoft Corporation 1999.  All Rights Reserved.
 */

#ifndef _WMAUDIO_API_H_
#define _WMAUDIO_API_H_

#define PACKED
/*
#ifdef _MSC_VER
#define USE_PACK_HEADERS
#define PACKED
#else
#undef USE_PACK_HEADERS
#define PACKED  __packed
#endif

#ifdef USE_PACK_HEADERS
#include <pshpack1.h>
#endif
*/

/* ...........................................................................
 *
 * Types and Constants
 * ===================
 */

#define CHECK_NONSDMI_LIC	1
#define CHECK_SDMI_LIC		2
#define CHECK_ALL_LICENSE	3

#define WMA_MAX_DATA_REQUESTED  128

enum {
    ECD_STRING = 0,
    ECD_BINARY = 1,
    ECD_BOOL = 2,
    ECD_DWORD = 3,
    ECD_QWORD = 4,
    ECD_WORD = 5
};

#if defined(_Embedded_x86)
#pragma pack (1)
#endif

/* 8-bit signed type  */
#ifndef _WMAU8_DEFINED
#define _WMAU8_DEFINED
typedef unsigned char tWMA_U8;
#endif /* _WMAU8_DEFINED */

/* 16-bit signed type  */
#ifndef _WMAI16_DEFINED
#define _WMAI16_DEFINED
typedef short tWMA_I16;
#endif /* _WMAI16_DEFINED */

/* 16-bit unsigned type  */
#ifndef _WMAU16_DEFINED
#define _WMAU16_DEFINED
typedef short tWMA_U16;
#endif /* _WMAU16_DEFINED */

/* 32-bit unsigned type  */
#ifndef _WMAU32_DEFINED
#define _WMAU32_DEFINED
typedef unsigned long tWMA_U32;
#endif /* _WMAU32_DEFINED */

/* Bool */
#ifndef _WMABool_DEFINED
#define _WMABool_DEFINED
typedef long tWMA_Bool;
#endif /* _WMABool_DEFINED */

/* 64-bit unsigned type  */
#ifndef _WMAU64_DEFINED
#define _WMAU64_DEFINED
#if defined(macintosh) || defined(_Embedded_x86)
typedef unsigned long long  tWMA_U64;
#else
typedef unsigned __int64    tWMA_U64;
#endif
#endif /* _WMAU64_DEFINED */

#ifndef _QWORD_DEFINED
#define _QWORD_DEFINED
typedef PACKED struct tQWORD
{
    tWMA_U32   dwLo;
    tWMA_U32   dwHi;

}   QWORD;
#endif /* _QWORD_DEFINED */

#define DESC_NAME_MAX_LENGTH   64
typedef struct _MarkerEntry {
    QWORD   m_qOffset;
    QWORD   m_qtime;
    tWMA_U16    m_wEntryLen;
    tWMA_U32   m_dwSendTime;
    tWMA_U32   m_dwFlags;
    tWMA_U32   m_dwDescLen;
    tWMA_U16   m_pwDescName[DESC_NAME_MAX_LENGTH];
} MarkerEntry;

typedef struct _ECD_DESCRIPTOR {
    tWMA_U16         cbName;
    tWMA_U16     *pwszName;
    tWMA_U16         data_type;
    tWMA_U16         cbValue;
    union {
        tWMA_U16 *pwszString;
        tWMA_U8 *pbBinary;
        tWMA_Bool *pfBool;
        tWMA_U32 *pdwDword;
        tWMA_U64 *pqwQword;
        tWMA_U16  *pwWord;
    } uValue;
} ECD_DESCRIPTOR;

typedef struct tagWMAExtendedContentDescription
{
    tWMA_U16 cDescriptors;             // number of descriptors
    ECD_DESCRIPTOR *pDescriptors;  // pointer to all the descriptors
} tWMAExtendedContentDesc;

/* status */
#ifndef _WMAFILESTATUS_DEFINED
#define _WMAFILESTATUS_DEFINED
typedef enum tagWMAFileStatus
{
    cWMA_NoErr,                 /* -> always first entry */
                                /* remaining entry order is not guaranteed */
    cWMA_Failed,
    cWMA_BadArgument,
    cWMA_BadAsfHeader,
    cWMA_BadPacketHeader,
    cWMA_BrokenFrame,
    cWMA_NoMoreFrames,
    cWMA_BadSamplingRate,
    cWMA_BadNumberOfChannels,
    cWMA_BadVersionNumber,
    cWMA_BadWeightingMode,
    cWMA_BadPacketization,

    cWMA_BadDRMType,
    cWMA_DRMFailed,
    cWMA_DRMUnsupported,

    cWMA_DemoExpired,

    cWMA_BadState,
    cWMA_Internal,               /* really bad */
	cWMA_NoMoreDataThisTime
} tWMAFileStatus;
#endif /* _WMAFILESTATUS_DEFINED */

/* versions */
#ifndef _WMAFILEVERSION_DEFINED
#define _WMAFILEVERSION_DEFINED
typedef enum tagWMAFileVersion
{
    cWMA_V1 = 1,
    cWMA_V2 = 2

} tWMAFileVersion;
#endif /* _WMAFILEVERSION_DEFINED */

/* sample rates */
#ifndef _WMAFILESAMPLERATE_DEFINED
#define _WMAFILESAMPLERATE_DEFINED
typedef enum tagWMAFileSampleRate
{
    cWMA_SR_48kHz,
    cWMA_SR_44_1kHz,
    cWMA_SR_32kHz,
    cWMA_SR_22_05kHz,
    cWMA_SR_16kHz,
    cWMA_SR_11_025kHz,
    cWMA_SR_08kHz
} tWMAFileSampleRate;
#endif /* _WMAFILESAMPLERATE_DEFINED */

/* channels */
#ifndef _WMAFILECHANNELS_DEFINED
#define _WMAFILECHANNELS_DEFINED
typedef enum tagWMAFileChannels
{
    cWMA_C_Mono = 1,
    cWMA_C_Stereo = 2

} tWMAFileChannels;
#endif /* _WMAFILECHANNELS_DEFINED */


/* ...........................................................................
 *
 * Structures
 * ==========
 */

/* header */
#ifndef _WMAFILEHEADER_DEFINED
#define _WMAFILEHEADER_DEFINED
typedef PACKED struct tagWMAFileHeader
{
    tWMAFileVersion version;         /* version of the codec */
    tWMAFileSampleRate sample_rate;  /* sampling rate */
    tWMAFileChannels num_channels;   /* number of audio channels */
    tWMA_U32 duration;               /* of the file in milliseconds */
    tWMA_U32 packet_size;            /* size of an ASF packet */
    tWMA_U32 first_packet_offset;    /* byte offset to the first ASF packet */
    tWMA_U32 last_packet_offset;     /* byte offset to the last ASF packet */

    tWMA_U32 has_DRM;                /* does it have DRM encryption? */
 
    tWMA_U32 LicenseLength;          /* License Length in the header */

    tWMA_U32 bitrate;                /* bit-rate of the WMA bitstream */

    /* HongCho: what else? */

} tWMAFileHeader;
#endif /* _WMAFILEHEADER_DEFINED */


/* content description */
#ifndef _WMAFILECONTDESC_DEFINED
#define _WMAFILECONTDESC_DEFINED
typedef PACKED struct tagWMAFileContDesc
{
    /* *_len: as [in], they specify how large the corresponding
     *        buffers below are.
     *        as [out], they specify how large the returned
     *        buffers actually are.
     */

    tWMA_U16 title_len;
    tWMA_U16 author_len;
    tWMA_U16 copyright_len;
    tWMA_U16 description_len;   /* rarely used */
    tWMA_U16 rating_len;        /* rarely used */

    /* these are two-byte strings
     *   for ASCII-type character set, to convert these
     *   into a single-byte characters, simply skip
     *   over every other bytes.
     */

    unsigned char *pTitle;
    unsigned char *pAuthor;
    unsigned char *pCopyright;
    unsigned char *pDescription;
    unsigned char *pRating;

} tWMAFileContDesc;
#endif /* _WMAFILECONTDESC_DEFINED */

/* license params */
#ifndef _WMAFILELICPARAMS_DEFINED
#define _WMAFILELICPARAMS_DEFINED
typedef PACKED struct tagWMAFileLicParams
{
    unsigned char *pPMID;       /* portable media id */
    tWMA_U32 cbPMID;            /* length of the pPMID buffer */

} tWMAFileLicParams;
#endif /* _WMAFILELICPARAMS_DEFINED */


typedef void * tHWMAFileState;

/* another internal state */
#ifndef _WMAFILEHDRSTATE_DEFINED
#define _WMAFILEHDRSTATE_DEFINED
typedef PACKED struct tagWMAFileHdrState
{
    unsigned char internal[192];
//    unsigned char internal[188];

} tWMAFileHdrState;
#endif /* _WMAFILEHDRSTATE_DEFINED */

#ifdef _Embedded_x86
#pragma pack ()
#endif

/* ........................................................................... 
 *
 * Functions
 * =========
 */

#ifdef __cplusplus
extern "C"
{
#endif /* __cplusplus */


/*
 *        WMAFileIsWMA
 *        ============
 *
 * Description
 * -----------
 * Checks to see if the file is decodable.  Uses WMAFileCBGetData(),
 * but the first argument to it is not really of type tHWMAFileState,
 * but tWMAFileIdState.
 *
 * To decode the file, the app should call WMAFileDecodeInit()
 * instead.
 *
 * This function was added in case the app wants to determine the
 * type of the file without fully allocating tHWMAFileState.
 *
 * Syntax
 * ------
 *   tWMAFileStatus WMAFileIsWMA(tWMAFileHdrState *state);
 *
 * where:
 *
 *   state          pointer to the smaller structure that contains
 *                  state of the checking function
 *
 * Return Value
 * ------------
 *   cWMA_NoErr                yes, it's a WMA file
 *   cWMA_BadArgument          bad argument passed in
 *   cWMA_BadAsfHeader         bad ASF header
 *
 */
tWMAFileStatus WMAFileIsWMA (tWMAFileHdrState *state);


/*
 *        WMAGetNumberOfMarkers
 *        ============
 *
 * Description
 * -----------
 * Return the total number of Markers in the asf file
 *
 * Syntax
 * ------
 *  int WMAGetNumberOfMarkers(tWMAFileHdrState *state);  
 *
 * where:
 *
 *   state          pointer to the smaller structure that contains
 *                  state of the checking function
 *
 * Return Value
 * ------------
 *   total number of Markers in the asf file
 *
 */

int WMAGetNumberOfMarkers(tWMAFileHdrState *state);  



/*
 *        WMAGetMarker
 *        ============
 *
 * Description
 * -----------
 * WMAGetMarker(...) is designed to return the Marker specified by an index integer iIndex
 * If the total number of Markers returned by WMAGetNumberOfMarkers is total_num_of_markers, 
 * all the Markers are indexed from 0 to total_num_of_markers - 1.  
 * When a Marker structure MarkerEntry is allocated by the application
 * and the pointer to that Marker structure is passed in WMAGetMarker(...) with pEntry,
 * succesful calling of WMAGetMarker(...) will fill up the Marker structure *pEntry
 * with the Marker identified by the index iIndex.
 *
 * Syntax
 * ------
 *   tWMAFileStatus WMAGetMarker(tWMAFileHdrState *state, int iIndex, MarkerEntry *pEntry); 
 *
 * where:
 *
 *   state          pointer to the smaller structure that contains
 *                  state of the checking function
 *   pEntry         pointer to the Marker structure MarkerEntryEx 
 *                  allocated by the application  
 *   iIndex         index to specify which Marker to return
 *
 * Return Value
 * ------------
 * return cWMA_NoErr
 *      if WMAGetMarker(...) succeed in returning the Marker specified by iIndex.            
 * return cWMA_Failed 
 *      if WMAGetMarker(...) failed in returning the Marker specified by iIndex.  
 */

tWMAFileStatus WMAGetMarker(tWMAFileHdrState *state, int iIndex, MarkerEntry *pEntry); 



/*
 *        WMAGetLicenseStore
 *        ============
 *
 * Description
 * -----------
 * Get the marker list so the main program can seek the file freely.
 *
 * Syntax
 * ------
 * BYTE * WMAGetLicenseStore(tWMAFileHdrState *pstate,tWMA_U32 *pLen)
 *
 * where:
 *
 *   state          pointer to the smaller structure that contains
 *                  state of the checking function
 *   pLen           Address of the poitner to store the size of license.
 *
 * Return Value
 * ------------
 * Pointer of data chunck
 *
 */
unsigned char * WMAGetLicenseStore(tWMAFileHdrState *pstate,tWMA_U32 *pLen);

/*
 *        WMAFileCBGetData
 *        ================
 *
 * Description
 * -----------
 * Supplies more data to the WMAudio decoder.  Not implemented by
 * the WMAudio decoder library.
 *
 * It is a callback function implemented by the application.  When
 * the WMAudio library needs more data to process (both to parse
 * informatio and to decode the actual data bitstream), the library
 * will call this function.
 *
 * Called by WMAFileDecodeInit(), WMAFileContentDesc() and
 * WMAFileDecodeData().
 *
 * Syntax
 * ------
 *   tWMA_U32 WMAFileCBGetData(tHWMAFileState hstate,
 *                             tWMA_U32 offset,
 *                             tWMA_U32 num_bytes,
 *                             unsigned char **ppData);
 *
 * where:
 *
 *   state          pointer to the structure that holds the internal
 *                  state of the WMAudio decoder
 *   offset         offset into the WMA file to get the data from
 *   num_bytes      how many bytes to get
 *   ppData         pointer to contain the returned buffer with more
 *                  data
 *                  The WMA library may over-write this buffer
 *
 * Return Value
 * ------------
 *   tWMA_U32       how many actually returned
 *                  should be same as num_bytes except for at the
 *                  very end of the file
 *
 */
extern tWMA_U32 WMAFileCBGetData (
    tHWMAFileState hstate,
    PVOID pContext,
    tWMA_U32 offset,
    tWMA_U32 num_bytes,
    unsigned char **ppData);


/*
 *        WMAFileCBGetLicenseData
 *        =======================
 *
 * Description
 * -----------
 * Supplies more data to the WMAudio DRM decryption function.  Not
 * implemented by the WMAudio decoder library.
 *
 * It is a callback function implemented by the application.  When
 * the WMAudio's DRM decryption library needs more data to process
 * the library will call this function.
 *
 * Called by WMAFileLicenseInit().
 *
 * Syntax
 * ------
 *   tWMA_U32 WMAFileCBGetLicenseData(tHWMAFileState *state,
 *                                    tWMA_U32 offset,
 *                                    tWMA_U32 num_bytes,
 *                                    unsigned char **ppData);
 *
 * where:
 *
 *   state          pointer to the structure that holds the internal
 *                  state of the WMAudio decoder
 *   offset         offset into the license file to get the data from
 *   num_bytes      how many bytes to get
 *   ppData         pointer to contain the returned buffer with more
 *                  data
 *
 * Return Value
 * ------------
 *   tWMA_U32       how many actually returned
 *                  should be same as num_bytes except for at the
 *                  very end of the file
 *
 */
extern tWMA_U32 WMAFileCBGetLicenseData (
    tHWMAFileState *pstate,
    tWMA_U32 offset,
    tWMA_U32 num_bytes,
    unsigned char **ppData);


/*
 *        WMAFileDecodeCreate
 *        ===================
 *
 * Description
 * -----------
 * Create the WMAudio decoder.
 *
 * Must be called before starting to decode a WMA file.
 *
 * Syntax
 * ------
 *   tWMAFileStatus WMAFileDecodeCreate(tHWMAFileState *state);
 *
 * where:
 *
 *   phstate        pointer to the handle that holds the internal
 *                  state of the WMAudio decoder
 *                  This memory should be cleared before the first call
 *                  to WMAFileDecodeCreate
 *
 * Return Value
 * ------------
 *   cWMA_NoErr                decoder initialised
 *   cWMA_BadArgument          bad argument passed in
 *   cWMA_BadAsfHeader         bad ASF header
 *   cWMA_BadSamplingRate      invalid or unsupported sampling rate
 *   cWMA_BadNumberOfChannels  invalid or unsupported number of channels
 *   cWMA_BadVersionNumber     invalid or unsupported version number
 *   cWMA_BadWeightingMode     invalid or unsupported weighting mode
 *   cWMA_BadPacketisation     invalid or unsupported packetisation
 *   cWMA_BadDRMType           unknown encryption type
 *   cWMA_DRMFailed            DRM failed
 *   cWMA_DRMUnsupported       DRM is not supported for this version
 *
 */
tWMAFileStatus WMAFileDecodeCreate (tHWMAFileState* phstate, void *pCallbackContext);

/*
 *        WMAFileDecodeInit
 *        =================
 *
 * Description
 * -----------
 * Initializes the WMAudio decoder.
 *
 * Must be called before starting to decode a WMA file.
 *
 * Syntax
 * ------
 *   tWMAFileStatus WMAFileDecodeInit(tHWMAFileState state);
 *
 * where:
 *
 *   phstate        pointer to the handle that holds the internal
 *                  state of the WMAudio decoder
 *                  This memory should be cleared before the first call
 *                  to WMAFileDecodeInit
 *
 * Return Value
 * ------------
 *   cWMA_NoErr                decoder initialised
 *   cWMA_BadArgument          bad argument passed in
 *   cWMA_BadAsfHeader         bad ASF header
 *   cWMA_BadSamplingRate      invalid or unsupported sampling rate
 *   cWMA_BadNumberOfChannels  invalid or unsupported number of channels
 *   cWMA_BadVersionNumber     invalid or unsupported version number
 *   cWMA_BadWeightingMode     invalid or unsupported weighting mode
 *   cWMA_BadPacketisation     invalid or unsupported packetisation
 *   cWMA_BadDRMType           unknown encryption type
 *   cWMA_DRMFailed            DRM failed
 *   cWMA_DRMUnsupported       DRM is not supported for this version
 *
 */
tWMAFileStatus WMAFileDecodeInit (tHWMAFileState phstate);

tWMAFileStatus WMAFileDecodeClose (tHWMAFileState* phstate);

/*
 *       WMAFileDecodeInfo
 *       =================
 *
 * Description
 * -----------
 * Retrieves the header information for the WMA file.
 *
 * Syntax
 * ------
 *   tWMAFileStatus WMAFileDecodeInfo(tHWMAFileState hstate,
 *                                    tWMAFileHeader *hdr);
 *
 * where:
 *
 *   state          pointer to the structure that holds the internal
 *                  state of the WMAudio decoder
 *   hdr            pointer to the structure that holds the WMA file
 *                  header info
 *
 * Return Value
 * ------------
 *   cWMA_NoErr                header retrieved ok
 *   cWMA_BadArgument          bad argument(s)
 *
 */

tWMAFileStatus WMAFileDecodeInfo (tHWMAFileState hstate, tWMAFileHeader *hdr);


/*
 *       WMAFileContentDesc
 *       ==================
 *
 * Description
 * -----------
 * Retrieves the content description for the WMA file.  Content
 * descriptions are such as the song title, the author, the
 * copyright info, the song description, and the rating info.
 * All these are part of the standard ASF description.
 *
 * Not all songs have content descriptions.
 *
 * Syntax
 * ------
 *   tWMAFileStatus WMAFileContentDesc(tHWMAFileState hstate,
 *                                     tWMAFileContDesc *desc);
 *
 * where:
 *
 *   state          pointer to the structure that holds the internal
 *                  state of the WMAudio decoder
 *   desc           pointer to the structure that holds the WMA file
 *                  content description info
 *                  as [in], must provide the buffer(s) and the size(s)
 *
 * Return Value
 * ------------
 *   cWMA_NoErr                description retrieved ok
 *   cWMA_BadArgument          bad argument(s)
 *   cWMA_BadAsfHeader         bad ASF header
 *
 */
tWMAFileStatus WMAFileContentDesc (tHWMAFileState hstate, tWMAFileContDesc *desc);

/* WMAFileExtendedContentDesc
 *
 * Description
 * -----------
 * Retrieves the extended content descriptions for the ASF file.
 * Not all ASF files have extended content descriptions.
 *
 * Syntax
 * ------
 * tWMAFileStatus WMAFileExtendedContentDesc (tHWMAFileState hstate, const tWMAExtendedContentDesc **pECDesc);
 *
 * where:
 *
 *   hstate                     Pointer to the structure that holds the internal
 *                              state of the WMAudio decoder
 *   pECDesc                    pointer of pointer to the Extended Content Desc
 *                              structure that holds in the ASF file.
 *
 * Return Value
 * ------------
 *   cWMA_NoErr                  description retrieved ok
 *   cWMA_BadArgument            bad argument(s)
 *   pECDesc is the pointer of pointer to the ASF extended content desc object.
 ***** DO NOT RELEASE THIS POINTER *************
 */

tWMAFileStatus WMAFileExtendedContentDesc (tHWMAFileState hstate, const tWMAExtendedContentDesc **pECDesc);

/*
 *       WMAFileLicenseInit
 *       ==================
 *
 * Description
 * -----------
 * Reads the DRM license file and check the license for the file.
 *
 * Uses WMAFileCBGetLicenseData to retrieve the license file.
 *
 * Syntax
 * ------
 *   tWMAFileStatus WMAFileLicenseInit(tHWMAFileState hstate,
 *                                     tWMAFileLicParams *lic_params);
 *
 * where:
 *
 *   state          pointer to the structure that holds the internal
 *                  state of the WMAudio decoder
 *   lic_params     pointer to the structure that passes in the
 *                  parameters for the license initialization.
 *
 * Return Value
 * ------------
 *   cWMA_NoErr                license checked ok
 *   cWMA_BadArgument          bad argument
 *   cWMA_DRMFailed            no license
 *   cWMA_DRMUnsupported       DRM is not supported for this version
 *
 */
tWMAFileStatus WMAFileLicenseInit (tHWMAFileState hstate, tWMAFileLicParams *lic_params, tWMA_U16 CheckLicTypes);


/*
 *       WMAFileDecodeData
 *       =================
 *
 * Description
 * -----------
 * Decodes WMAudio bitstream.
 *
 * Syntax
 * ------
 *   tWMAFileStatus WMAFileDecodeData(tHWMAFileState hstate);
 *
 * where:
 *
 *   state          pointer to the structure that holds the internal
 *                  state of the WMAudio decoder
 *
 * Return Value
 * ------------
 *   cWMA_NoErr                frame decoded ok
 *   cWMA_BadArgument          bad argument
 *   cWMA_BrokenFrame          data is inconsistent
 *   cWMA_NoMoreFrames         no more data to decode
 *
 */
tWMAFileStatus WMAFileDecodeData (tHWMAFileState hstate);


/*
 *       WMAFileGetPCM
 *       =============
 *
 * Description
 * -----------
 * Write PCM samples from the WMAudio bitstream previously decoded by
 * WMAFileDecodeData().
 *
 * WMAFileGetPCM() may have to be called more than once to obtain all
 * of the samples for the frame. The frame is complete when the number
 * of samples written is less than the number of samples requested.
 *
 * Syntax
 * ------
 *   tWMA_U32 WMAFileGetPCM(tHWMAFileState hstate,
 *                          tWMA_I16 *left, tWMA_I16 *right,
 *                          tWMA_U32 max_nsamples);
 *
 * where:
 *
 *   state          pointer to the structure that holds the internal
 *                  state of the WMAudio decoder
 *   pi16Channel0   pointer to output buffer for left-channel PCM, or the entire PCM output if it is inter-leaved form
 *   pi16Channel1   pointer to output buffer for right-channel PCM, NULL if the output PCM is in parallel form
 *   max_nsamples   maximum number of samples to write per channel
 *
 * Return Value
 * ------------
 *   tWMA_U32       number of samples written
 *                  < max_nsamples when frame complete
 *
 */
tWMA_U32 WMAFileGetPCM (
    tHWMAFileState hstate,
    tWMA_I16 *pi16Channel0, tWMA_I16 *pi16Channel1,
    tWMA_U32 max_nsamples);


/*
 *       WMAFileSeek
 *       ===========
 *
 * Description
 * -----------
 * Seek to a time into the WMA file.  It seeks to the nearest seek
 * point.
 *
 * Syntax
 * ------
 *   tWMA_32 WMAFileSeek(tHWMAFileState hstate,
 *                       tWMA_U32 msSeek);
 *
 * where:
 *
 *   state          pointer to the structure that holds the internal
 *                  state of the WMAudio decoder
 *   msSeek         time position to seek from the beginning of the
 *                  clip, in milliseconds
 *
 * Return Value
 * ------------
 *   tWMA_32        actual time position from the beginning of the
 *                  clip, in milliseconds
 *
 */
tWMA_U32 WMAFileSeek (tHWMAFileState hstate, tWMA_U32 msSeek);


/*
 *       WMADebugMessage
 *       ===============
 *
 * Description
 * -----------
 * Display a debugging message. This function needs to be implemented by the app that calls WMEPAK.
 * These messages are meant for the device/application developer, not the end user.
 * Display the message using fprintf, messagebox, or whatever method is suitable to your platform.
 * See the sample code for an example implementation.
 * Make it a empty-body function if the intent is to skip this operation.
 *
 * Syntax
 * ------
 *		WMADebugMessage(const char* pszFmt,
 *						...);
 *
 * where:
 *
 *   pszFmt		    pointer to a null terminated printf like format string
 *   ...			variable number of arguments referenced by the format string
 *
 * Return Value
 * ------------
 *   none
 *
 */
extern void WMADebugMessage (const char*pszFmt, ...);



#ifdef __cplusplus
}
#endif /* __cplusplus */

/*
#ifdef USE_PACK_HEADERS
#include <poppack.h>
#endif
*/

#endif /* _WMAUDIO_API_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\inc\voiceencoder.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		agcva1.h
 *  Content:	Concrete class that implements CAutoGainControl
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *  12/01/99	pnewson Created it
 *  01/31/2000	pnewson re-add support for absence of DVCLIENTCONFIG_AUTOSENSITIVITY flag
 *  03/03/2000	rodtoll	Updated to handle alternative gamevoice build.   
 *  04/25/2000  pnewson Fix to improve responsiveness of AGC when volume level too low
 *
 ***************************************************************************/

#ifndef _VOICEENCODER_H_
#define _VOICEENCODER_H_

#define VOICE_MESSAGE_TYPE_SILENCE 0x00
#define VOICE_MESSAGE_TYPE_VOICE   0x01

typedef struct _VOICE_ENCODER_HEADER
{
	BYTE	bType;				// packet type
	BYTE	bMsgNum;			// Message # for message
	WORD	wSeqNum;			// Sequence # for message

} VOICE_ENCODER_HEADER, *PVOICE_ENCODER_HEADER;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voiceenc\voiceencoder.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       agcva1.cpp
 *  Content:    Concrete class that implements CAutoGainControl
 *
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  12/01/99    pnewson Created it
 *  2/9/2001    georgioc re-created it in xmo format + turned it in standalone mini filter graph
 *
 ***************************************************************************/

/*

How this voice activation code works:

The idea is this. The power of the noise signal is pretty much constant over
time. The power of a voice signal varies considerably over time. The power of
a voice signal is not always high however. Weak frictive noises and such do not
generate much power, but since they are part of a stream of speech, they represent
a dip in the power, not a constant low power like the noise signal. We therefore 
associate changes in power with the presence of a voice signal.

If it works as expected, this will allow us to detect voice activity even
when the input volume, and therefore the total power of the signal, is very
low. This in turn will allow the auto gain control code to be more effective.

To estimate the power of the signal, we run the absolute value of the input signal
through a recursive digital low pass filter. This gives us the "envelope" signal.
[An alternative way to view this is a low frequency envelope signal modulated by a 
higher frequency carrier signal. We're extracting the low frequency envelope signal.]

*/

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#ifdef __cplusplus
}
#endif // __cplusplus

#include "dsoundp.h"

#include "voiceencoder.h"
#include "voiceencoderp.h"

#include "xvocver.h"


EXTERN_C HRESULT WINAPI VoxwareCreateConverter(WORD wEncodeFormatTag, BOOL fCreateEncoder, LPVOICECODECWAVEFORMAT pwfxEncoded, LPWAVEFORMATEX pwfxDecoded, LPXMEDIAOBJECT *ppMediaObject);

#if DBG

    ULONG g_VeXmoDebugLevel = DEBUG_LEVEL_INFO;

#endif

XBOXAPI
EXTERN_C  HRESULT WINAPI
XVoiceEncoderCreateMediaObject(
    BOOL fAutoMode,
    DWORD dwCodecTag,
    LPWAVEFORMATEX pwfx,
    DWORD dwThreshold,
    LPXMEDIAOBJECT *ppXMO
    )
{
    XMediaObject *pXmo;
    HRESULT hr;

    pXmo = new CVoiceEncoderXmo();
    MY_ASSERT(pXmo);

    if (pXmo == NULL) {
        return E_OUTOFMEMORY;
    }

    hr = ((CVoiceEncoderXmo *)pXmo)->Init(
             fAutoMode,
             dwCodecTag,
             pwfx,
             dwThreshold);

    if (SUCCEEDED(hr)) {

        *ppXMO = pXmo;

    }

    return hr;

}



CVoiceEncoderXmo::~CVoiceEncoderXmo()
{

    if (m_pEncoderXmo) {

        m_pEncoderXmo->Release();
        m_pEncoderXmo = NULL;

    }

}



#undef DPF_MODNAME
#define DPF_MODNAME "CVoiceEncoderXmo::Init"
//
// Init - initializes the AGC and VA algorithms, including loading saved
// values from registry.
//
// dwFlags - the dwFlags from the dvClientConfig structure
// guidCaptureDevice - the capture device we're performing AGC for
// plInitVolume - the initial volume level is written here
//
HRESULT CVoiceEncoderXmo::Init(
    DWORD fAutoMode, 
    DWORD dwCodecTag,
    PWAVEFORMATEX pwfx,
    DWORD dwSensitivity)
{

    MY_ASSERT(pwfx);

    m_fAutoMode = fAutoMode;
    m_dwSensitivity = dwSensitivity;
    m_dwSampleRate = pwfx->nSamplesPerSec;

    //
    // Figure out the shift constants for this sample rate
    //

    m_iShiftConstantFast = (DV_log_2((m_dwSampleRate * 2) / 1000) + 1);

    //
    // This gives the slow filter a cutoff frequency 1/4 of 
    // the fast filter
    //

    m_iShiftConstantSlow = m_iShiftConstantFast + 2;

    // Start the envelope signal at zero
    Flush();

   
    AddRef();

    //
    // instantiate a codec
    //

    //
    // instantiate the proper vox compressor
    //
    
    return VoxwareCreateConverter((WORD)dwCodecTag,
                                  TRUE,
                                  NULL,
                                  pwfx,
                                  &m_pEncoderXmo);

   
}

HRESULT STDMETHODCALLTYPE CVoiceEncoderXmo::Flush()
{


    // Start the envelope signal at zero
    m_iCurEnvelopeValueFast = 0;
    m_iCurEnvelopeValueSlow = 0;
    m_iHangoverSamples = 2;
    return S_OK;

}

HRESULT STDMETHODCALLTYPE CVoiceEncoderXmo::Process( 
    LPCXMEDIAPACKET pSrc,
    LPCXMEDIAPACKET pDst
    )
{
    int iMaxValue;
    int iValueAbs;
    int iIndex;
    int iMaxPossiblePeak;
    int iNumberOfSamples;
    PVOICE_ENCODER_HEADER pHeader;
    HRESULT hr = S_OK;

    DWORD fVoiceDetectedPrevFrame = m_fVoiceDetectedThisFrame;

    MY_ASSERT(pSrc);
    MY_ASSERT(pDst);

    MY_ASSERT(pSrc->dwMaxSize >= 2);
    MY_ASSERT(pDst->dwMaxSize >= m_dwMinOutputSize);

    MY_ASSERT(pDst->pvBuffer);
    MY_ASSERT(pSrc->pvBuffer);

	//
    // Compute the upper bound for number of sequences in a message
    //
	if( 0 == m_wMaxSeqInMsg )
    {
		//
        // Normal talkspurt is about 30s long
        // We'll consider the maximum talkpurt to be 3 minutes 
		//
		m_wMaxSeqInMsg = (WORD)(MAX_MSG_TIME / (pSrc->dwMaxSize));
    }		

    // cast the audio data to signed 16 bit integers
    signed short* psiAudioData = (signed short *)pSrc->pvBuffer;

    // 16 bits per sample assumed!!
    iNumberOfSamples = pSrc->dwMaxSize / 2;

    //
    // BUGBUG the voice peripheral certainly regulates the volume so the max value is never above 600
    // we got to figure this out tho
    //

    iMaxPossiblePeak = 500;
    iMaxValue = 0;
    m_fVoiceDetectedThisFrame = FALSE;

    for (iIndex = 0; iIndex < (int)iNumberOfSamples; ++iIndex)
    {
        iValueAbs = DV_ABS((int)psiAudioData[iIndex]);

        // see if it is the new peak value
        iMaxValue = DV_MAX(iValueAbs, iMaxValue);

        // do the low pass filtering, but only if we are in autosensitivity mode
        int iNormalizedCurEnvelopeValueFast;
        int iNormalizedCurEnvelopeValueSlow;
        if (m_fAutoMode)
        {
            m_iCurEnvelopeValueFast = 
                iValueAbs + 
                (m_iCurEnvelopeValueFast - (m_iCurEnvelopeValueFast >> m_iShiftConstantFast));
            iNormalizedCurEnvelopeValueFast = m_iCurEnvelopeValueFast >> m_iShiftConstantFast;

            m_iCurEnvelopeValueSlow = 
                iValueAbs + 
                (m_iCurEnvelopeValueSlow - (m_iCurEnvelopeValueSlow >> m_iShiftConstantSlow));
            iNormalizedCurEnvelopeValueSlow = m_iCurEnvelopeValueSlow >> m_iShiftConstantSlow;

            // check to see if we consider this voice
            if (iNormalizedCurEnvelopeValueFast > VA_LOW_ENVELOPE &&
                (iNormalizedCurEnvelopeValueFast > VA_HIGH_ENVELOPE ||
                CALC_HIGH_PERCENT_RANGE( iNormalizedCurEnvelopeValueSlow ) ||
                CALC_LOW_PERCENT_RANGE( iNormalizedCurEnvelopeValueSlow ) ) )
            {
                m_fVoiceDetectedThisFrame = TRUE;
                m_iCurHangoverSamples = 0;
            }
            else
            {
                ++m_iCurHangoverSamples;
                if (m_iCurHangoverSamples > m_iHangoverSamples)
                {
                    m_fVoiceDetectedThisFrame = FALSE;
                }
                else
                {
                    m_fVoiceDetectedThisFrame = TRUE;
                }
            }
        }
    }

    // Normalize the peak value to the range DVINPUTLEVEL_MIN to DVINPUTLEVEL_MAX
    // This is what is returned for caller's peak meters...
    m_bPeak = (BYTE)(VE_INPUTLEVEL_MIN + 
        ((iMaxValue * (VE_INPUTLEVEL_MAX - VE_INPUTLEVEL_MIN)) / iMaxPossiblePeak));

    //
    // if we are in manual VA mode (not autovolume) check the peak against
    // the sensitivity threshold
    //

    if (!m_fAutoMode)
    {
        if (m_bPeak > m_dwSensitivity)
        {
            m_fVoiceDetectedThisFrame = TRUE;
            m_iCurHangoverSamples = 0;
        } 
		else 
		{
                ++m_iCurHangoverSamples;
                if (m_iCurHangoverSamples > m_iHangoverSamples)
                {
                    m_fVoiceDetectedThisFrame = FALSE;
                }
                else
                {
                    m_fVoiceDetectedThisFrame = TRUE;
                }
        }
    }

    //
    // now that we have performed the VA, create a packet header 
    //

    pHeader = (PVOICE_ENCODER_HEADER) pDst->pvBuffer;
    pHeader->bType = (m_fVoiceDetectedThisFrame ? VOICE_MESSAGE_TYPE_VOICE : VOICE_MESSAGE_TYPE_SILENCE);

    if ((!m_fVoiceDetectedThisFrame && fVoiceDetectedPrevFrame) ||
		 (m_wCurrentMsgSeqCount > m_wMaxSeqInMsg))
	{

        pHeader->bMsgNum = m_bMsgNum++;
		m_wCurrentMsgSeqCount = 0;

    }
	else
	{
	    pHeader->bMsgNum = m_bMsgNum;
	}

    pHeader->wSeqNum = m_wSeqNum++;
	m_wCurrentMsgSeqCount++;

    //
    // now invoke the encoder XMO to compress the data
    //

    if (m_fVoiceDetectedThisFrame) {

        XMEDIAPACKET * pXmp;

        pXmp = (XMEDIAPACKET *)pDst;

        //
        // change the destination packet to not stomp on the voice header we just inserted
        //

        pXmp->pvBuffer = (PUCHAR)pHeader + sizeof(VOICE_ENCODER_HEADER);

        hr = m_pEncoderXmo->Process(pSrc,
                                    pDst);


        //
        // re adjust destination packet buffer and size
        //

        pXmp->pvBuffer = pHeader;
  
        //
        // the intermediate codec XMO has already updated pdwstatus, etc
        //

		if (pDst->pdwCompletedSize) {

            *pDst->pdwCompletedSize += sizeof(VOICE_ENCODER_HEADER);

        }

    } else {

        //
        // if voice was not detected we just send a zeroed packet
        //

		memset(pDst->pvBuffer, 0 , pDst->dwMaxSize);

        if (pDst->pdwCompletedSize) {

            *pDst->pdwCompletedSize = 0;
        }

        if (pDst->pdwStatus) {

            *pDst->pdwStatus = XMEDIAPACKET_STATUS_SUCCESS;

        }

    }

    if (pSrc->pdwCompletedSize) {

        *pSrc->pdwCompletedSize = pSrc->dwMaxSize;

    }

    if (pSrc->pdwStatus) {

        if (FAILED(hr)) {

            *pSrc->pdwStatus = XMEDIAPACKET_STATUS_FAILURE;

        } else {

            *pSrc->pdwStatus = XMEDIAPACKET_STATUS_SUCCESS;

        }
        
    }

    return hr;
}


HRESULT STDMETHODCALLTYPE CVoiceEncoderXmo::GetInfo( LPXMEDIAINFO pInfo )
{
    HRESULT hr;

    MY_ASSERT(pInfo);

    //
    // use the info from the encoder xmo
    //
    hr = m_pEncoderXmo->GetInfo(pInfo);
    if (FAILED(hr)) {
        return hr;
    }


	//
    // our minimum output size has to account for the header
    //
    pInfo->dwOutputSize += sizeof(VOICE_ENCODER_HEADER); 
    m_dwMinOutputSize = pInfo->dwOutputSize;

    return S_OK;
}
                                                   
HRESULT STDMETHODCALLTYPE CVoiceEncoderXmo::Discontinuity(void){
   return S_OK;
}

HRESULT STDMETHODCALLTYPE CVoiceEncoderXmo::GetStatus( 
    LPDWORD pdwStatus
    )
{

    if (pdwStatus) {

        *pdwStatus = XMO_STATUSF_ACCEPT_OUTPUT_DATA | XMO_STATUSF_ACCEPT_INPUT_DATA;

    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\a03x3x10.h ===
3.21142614e-01F,
3.16248566e-01F,
2.52212614e-01F,
3.61412376e-01F,
2.65742004e-01F,
3.59099835e-01F,
2.57598311e-01F,
3.34833860e-01F,
3.06428939e-01F,
2.84401715e-01F,
3.32419932e-01F,
2.66113579e-01F,
3.18295568e-01F,
3.11226457e-01F,
3.37721676e-01F,
2.84926862e-01F,
3.46510053e-01F,
2.86924362e-01F,
3.28737199e-01F,
2.59195238e-01F,
2.44378433e-01F,
3.75245094e-01F,
3.13403040e-01F,
2.83519149e-01F,
3.31486136e-01F,
2.66807586e-01F,
3.80220681e-01F,
2.46393010e-01F,
2.79173613e-01F,
3.30324292e-01F,
2.71817982e-01F,
3.04980159e-01F,
4.02980655e-01F,
2.71150827e-01F,
3.44009101e-01F,
3.10812205e-01F,
2.98136324e-01F,
3.06375772e-01F,
2.64090210e-01F,
2.79504865e-01F,
3.22112143e-01F,
2.84691334e-01F,
3.19915920e-01F,
2.93818742e-01F,
2.93337792e-01F,
3.49281967e-01F,
3.01720828e-01F,
2.98630714e-01F,
2.33440146e-01F,
3.74405950e-01F,
2.54385918e-01F,
3.02450448e-01F,
3.31752986e-01F,
3.11648488e-01F,
3.04778129e-01F,
3.27210784e-01F,
2.71457434e-01F,
2.58206904e-01F,
3.62465411e-01F,
3.36917698e-01F,
2.89987504e-01F,
3.32335502e-01F,
2.29691282e-01F,
3.13273430e-01F,
2.83757001e-01F,
2.92378157e-01F,
3.30556750e-01F,
2.63902068e-01F,
3.26972663e-01F,
3.86421382e-01F,
2.53604591e-01F,
3.59059364e-01F,
2.71969855e-01F,
3.36969644e-01F,
2.95387745e-01F,
2.67725557e-01F,
3.19692016e-01F,
3.74713510e-01F,
2.67535925e-01F,
3.14218611e-01F,
-2.33412143e-02F,
-5.23227407e-03F,
-2.80494746e-02F,
6.66669011e-02F,
4.32420298e-02F,
-3.92031819e-02F,
-3.79796959e-02F,
7.46214390e-03F,
3.67704704e-02F,
-7.79815344e-03F,
5.66248819e-02F,
-4.77474928e-02F,
-2.09261645e-02F,
-8.82192701e-03F,
3.18372995e-02F,
-2.83487178e-02F,
6.30163550e-02F,
-8.87280330e-03F,
-2.59845667e-02F,
9.43756662e-03F,
1.24989999e-02F,
1.86608471e-02F,
-6.31057541e-04F,
3.88365472e-03F,
9.80503298e-03F,
7.29074255e-02F,
-1.92369334e-02F,
-6.06542379e-02F,
1.76779293e-02F,
-3.53550278e-02F,
-5.60459718e-02F,
1.43645471e-02F,
1.97666287e-02F,
-6.71490729e-02F,
4.26348411e-02F,
-3.13080251e-02F,
2.88948286e-02F,
3.15077486e-03F,
5.96786253e-02F,
-7.30514200e-03F,
1.31217046e-02F,
2.59951130e-02F,
-4.97901104e-02F,
-5.53938448e-02F,
4.85186875e-02F,
3.23674344e-02F,
-5.41500561e-02F,
4.43062708e-02F,
-2.19507627e-02F,
2.28089318e-02F,
-2.55210549e-02F,
-3.12386546e-02F,
1.34470956e-02F,
1.49729084e-02F,
-4.00841013e-02F,
6.28911704e-02F,
-3.18676047e-02F,
5.62190451e-02F,
-9.13296640e-03F,
8.61417223e-03F,
6.16628006e-02F,
1.85769107e-02F,
3.44391726e-02F,
-2.24893317e-02F,
-3.60810719e-02F,
-2.79859696e-02F,
-4.06954028e-02F,
-1.23882378e-02F,
1.91852043e-03F,
3.99310961e-02F,
-2.07145829e-02F,
-1.68237016e-02F,
1.14131728e-02F,
4.95755486e-02F,
-5.82984351e-02F,
-1.49425790e-02F,
5.10171615e-02F,
-4.49190028e-02F,
4.80508246e-02F,
-3.83646809e-03F,
-8.01807735e-03F,
4.30202708e-02F,
-4.38043363e-02F,
7.07508177e-02F,
-2.72129886e-02F,
-5.75525314e-03F,
-2.96396855e-02F,
-2.34966204e-02F,
-1.81485992e-02F,
4.50783074e-02F,
1.41575746e-03F,
2.90176328e-02F,
-2.35470515e-02F,
-7.70676462e-03F,
7.39751235e-02F,
-2.69300770e-02F,
1.70598682e-02F,
-1.83407068e-02F,
2.58636419e-02F,
-5.86084202e-02F,
7.99794346e-02F,
-6.89142048e-02F,
3.35165411e-02F,
-4.10663746e-02F,
3.08258645e-02F,
-2.40255129e-02F,
-3.23469676e-02F,
-6.89330418e-03F,
2.49670409e-02F,
1.27091687e-02F,
-5.72470501e-02F,
-4.83263880e-02F,
2.99481228e-02F,
-2.14498900e-02F,
2.67547071e-02F,
-1.94806103e-02F,
2.29691132e-03F,
6.77217031e-03F,
1.53322611e-02F,
6.48833141e-02F,
2.73135509e-02F,
-1.48380792e-03F,
8.35961010e-03F,
-6.64426312e-02F,
-3.98734584e-02F,
-1.18618542e-02F,
4.88483459e-02F,
8.70233215e-03F,
5.69755100e-02F,
-2.17604320e-02F,
-4.60157767e-02F,
-1.61326081e-02F,
-4.82211784e-02F,
3.13217603e-02F,
-2.22156122e-02F,
6.71451092e-02F,
2.96813156e-02F,
1.42293302e-02F,
1.06589366e-02F,
-1.31627666e-02F,
-3.30836736e-02F,
9.52051431e-02F,
-1.19610932e-02F,
-2.13737926e-03F,
-3.08756176e-02F,
2.69679874e-02F,
-3.41633223e-02F,
4.21176925e-02F,
1.84734887e-03F,
-4.54199277e-02F,
3.44038196e-02F,
-3.39086764e-02F,
3.59578766e-02F,
3.75858918e-02F,
-3.59404907e-02F,
-2.68897712e-02F,
1.78464241e-02F,
4.92218435e-02F,
-4.24103662e-02F,
-1.57215074e-02F
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voiceenc\voiceencoderp.h ===
#if DBG

#define MY_ASSERT(x) if( !(x) ) _asm int 3;

extern "C"
{
	ULONG
	DebugPrint(
		PCHAR Format,
		...
		);
}

#define DEBUG_LEVEL_ERROR 0
#define DEBUG_LEVEL_WARNING 1
#define DEBUG_LEVEL_INFO 2
#define DEBUG_LEVEL_SPAM 5

extern ULONG g_VaXmoDebugLevel;
#define DBG_SPAM(_exp_) {if (g_VeXmoDebugLevel >= DEBUG_LEVEL_SPAM) DebugPrint _exp_;}
#define DBG_INFO(_exp) {if (g_VeXmoDebugLevel >= DEBUG_LEVEL_INFO) DebugPrint _exp;}
#define DBG_ERROR(_exp) {if (g_VeXmoDebugLevel >= DEBUG_LEVEL_ERROR) DebugPrint _exp;}
#define DBG_WARN(_exp) {if (g_VeXmoDebugLevel >= DEBUG_LEVEL_WARNING) DebugPrint _exp;}

#else

#define MY_ASSERT(x)
#define DBG_SPAM(_exp_)
#define DBG_INFO(_exp_)
#define DBG_ERROR(_exp_)
#define DBG_WARN(_exp_)

#endif





// The following VA parameters were optimized for what I believe to be
// the hardest configuration: A cheap open stick mic with external speakers,
// with Echo Suppression turned on. Echo suppression penalizes false positives
// harshly, since the receiver cannot send which receiving the "noise". If 
// the VA parameters work for this case, then they should be fine for the 
// much better signal to noise ratio provided by a headset or collar mic.
// (As long as the user does not breathe directly on the headset mic.)
//
// Two source-to-mic distances were tested during tuning.
//
// 1) Across an enclosed office (approx 8 to 10 feet)
// 2) Seated at the workstation (approx 16 to 20 inches)
//
// At distance 1, the AGC was never invoked, gain was at 100%
// At distance 2, the AGC would take the mic down a few ticks.
//
// The office enviroment had the background noise from 3 computers,
// a ceiling vent, and a surprisingly noisy fan from the ethernet
// hub. There is no background talking, cars, trains, or things of
// that nature.
//
// Each parameter was tuned separately to reject 100% of the 
// background noise for case 1 (gain at 100%).
//
// Then they were tested together to see if they could detect
// across the room speech.
//
// Individually, none of the detection criteria could reliably
// detect all of the across the room speech. Together, they did
// not do much better. They even missed some speech while seated.
// Not very satifactory.
//
// Therefore, I decided to abandon the attempt to detect across
// the room speech. I retuned the parameters to reject noise 
// after speaking while seated (which allowed AGC to reduce
// the volume a couple of ticks, thereby increasing the signal
// to noise ratio) and to reliably detect seated speech.
//
// I also found that the "fast" envelope signal was better at
// detecting speech than the "slow" one in a straight threshold
// comparison, so it is used in the VA tests.
//

#define VE_INPUTLEVEL_MIN                    0x00000000
#define VE_INPUTLEVEL_MAX                    0x00000063  // 99 decimal

/// rodtoll
// Changing range so instead of 0 - 100 we have 0 - 128
// 
// The factor is the value we need to shift right by to get this division
// 
#define VA_MEASUREMENT_RANGE		128
#define VA_MEASUREMENT_RANGE_FACTOR	7

// VA_HIGH_PERCENT
//
// If the fast envelope signal is more than this percentage
// higher than the slow envelope signal, speech is detected.
//
// rodtoll : Modifying so that high and low values are factor of 2 values
//			 so that divisions can be removed.  Used 170 as reference point
//			 128 as the range.
//
#define VA_HIGH_PERCENT					218	

// Cannot have a factor because 218 cannot be factored by 2.
//
// #define VA_HIGH_PERCENT_FACTOR		

// Macro for doing x * VA_HIGH_PERCENT / VA_MEASUREMENT_RANGE
#define CALC_HIGH_PERCENT_RANGE(x)		((x*VA_HIGH_PERCENT)>>VA_MEASUREMENT_RANGE_FACTOR)
// #define VA_HIGH_PERCENT 170 // rejects most noise, still catches some.
							// decent voice detection. Catches the beginning
							// of speech a majority of the time, but does miss
							// once in a while. Will often drop out partway 
							// into a phrase when used alone. Must test in 
							// conjunction with VA_LOW_PERCENT.
							//
							// After testing in conjunction with VA_LOW_PERCENT,
							// the performance is reasonable. Low input volume
							// signals are usually detected ok, but dropouts are
							// a bit common. However, noise is sometimes still
							// detected, so making these parameters more sensitive
							// would not be useful.
//#define VA_HIGH_PERCENT 165 // catches occational noise
//#define VA_HIGH_PERCENT 160 // catches too much noise
//#define VA_HIGH_PERCENT 150 // catches most noise
//#define VA_HIGH_PERCENT 140 // catches almost all noise
//#define VA_HIGH_PERCENT 0x00007fff // select this to factor out this VA parameter

// VA_LOW_PERCENT
//
// If the fast envelope signal is more than this percentage
// lower than the slow envelope signal, speech is detected.
//
#define VA_LOW_PERCENT					64

// rodtoll -- Factor for shifting left instead of multiplying
#define VA_LOW_PERCENT_FACTOR			6

// Combination of shift left by low then right by VA_MEASUREMENT_RANGE_FACTOR, 
#define VA_LOW_PERCENT_RANGE_FACTOR		1

// Macro for doing x * VA_LOW_PERCENT / VA_MEASUREMENT_RANGE
#define CALC_LOW_PERCENT_RANGE(x)		(x>>VA_LOW_PERCENT_RANGE_FACTOR)

// Shift Right by 7

//#define VA_LOW_PERCENT 50 // excellent noise rejection. poor detection of speech.
						  // when used alone, could miss entire phrases. Must evaluate
						  // in conjunction with tuned VA_HIGH_PERCENT
						  //
						  // See note above re: testing in conjunction with VA_HIGH_PERCENT
//#define VA_LOW_PERCENT 55 // still catches too much noise
//#define VA_LOW_PERCENT 60 // catches most noise
//#define VA_LOW_PERCENT 65 // catches most noise
//#define VA_LOW_PERCENT 70 // still catches almost all noise
//#define VA_LOW_PERCENT 75 // catches almost all noise
//#define VA_LOW_PERCENT 80 // catches all noise
//#define VA_LOW_PERCENT 0 // select this to factor out this VA parameter

// VA_HIGH_ENVELOPE
//
// If the 16 bit normalized value of the envelope exceeds
// this number, the signal is considered voice.
//
//#define VA_HIGH_ENVELOPE (15 << 8) // still catches high gain noise, starting to get 
								   // speech dropouts, when "p" sounds lower the gain
//#define VA_HIGH_ENVELOPE (14 << 8) // Noise immunity good at "seated" S/N ratio. No speech
								   // dropouts encountered. Still catches noise at full gain.
//#define VA_HIGH_ENVELOPE (13 << 8) // Noise immunity not as good as expected (new day).
//#define VA_HIGH_ENVELOPE (12 << 8) // Good noise immunity. Speech recognition excellent.
								   // Only one dropout occured in the test with a 250ms
								   // hangover. I think the hangover time should be increased
								   // above 250 however, because a comma (properly read) tends 
								   // to cause a dropout. I'm going to tune the hangover time, 
								   // and return to this test.
								   //
								   // Hangover time is now 400ms. No dropouts occur with
								   // "seated" speech.
//#define VA_HIGH_ENVELOPE (11 << 8) // Catches almost no noise at "seated" gain
								   // however, if the gain creeped up a bit, noise would
								   // be detected. I therefore think a slightly higher 
								   // threshold would be a good idea. The speech recognition
								   // based on only this parameter at this level was flawless.
								   // No dropouts at all with a 250 ms hangover time. (commas
								   // excepted).
#define VA_HIGH_ENVELOPE (10 << 8) // catches some noise at "seated" gain - getting very close
//#define VA_HIGH_ENVELOPE (9 << 8) // catches some noise at "seated" gain - getting close
//#define VA_HIGH_ENVELOPE (8 << 8) // catches noise at "seated" gain
//#define VA_HIGH_ENVELOPE (7 << 8) // catches noise at "seated" gain
//#define VA_HIGH_ENVELOPE (0x7fffffff) // select this to factor out this VA parameter

// VA_LOW_ENVELOPE
//
// If the 16 bit normalized value of the envelope is below
// this number, the signal will never be considered voice.
// This reduces some false positives on the delta checks
// at very low signal levels
//#define VA_LOW_ENVELOPE (3 << 8)
//#define VA_LOW_ENVELOPE (2 << 8) // causes false VA at low input volumes
#define VA_LOW_ENVELOPE (1 << 8) // causes false VA at low input volumes

// VA_HANGOVER_TIME
//
// The time, in milliseconds, that voice activation sticks in
// the ON position following a voice detection. E.g. a value of 500
// means that voice will always be transmitted in at least 1/2 second
// bursts.
//
// I am trying to tune this so that a properly read comma will not cause
// a dropout. This will give the user a bit of leeway to pause in the
// speech stream without losing the floor when in Echo Suppression mode.
// It will also prevent dropouts even when not in Echo Suppression mode

#define VA_HANGOVER_TIME 500 // more forgiving

//#define VA_HANGOVER_TIME 400 // this gives satisfying performance
//#define VA_HANGOVER_TIME 375 // almost there, longest commas still goners
//#define VA_HANGOVER_TIME 350 // still drops long commas
//#define VA_HANGOVER_TIME 325 // does not drop fast commas, drops long ones
//#define VA_HANGOVER_TIME 300 // drops almost no commas, quite good
//#define VA_HANGOVER_TIME 275 // drops about half of the commas
//#define VA_HANGOVER_TIME 250 // commas are always dropped

// macros to avoid clib dependencies
#define DV_ABS(a) ((a) < 0 ? -(a) : (a))
#define DV_MAX(a, b) ((a) > (b) ? (a) : (b))
#define DV_MIN(a, b) ((a) < (b) ? (a) : (b))

// maximum msg time
#define MAX_MSG_TIME    3 * 60 * 1000 //3 minutes = 180000 ms

// A function to lookup the log of n base 1.354 (sort of)
// where 0 <= n <= 127
//
// Why the heck do we care about log n base 1.354???
//
// What we need is a function that maps 0 to 127 down to 0 to 15
// in a nice, smooth non-linear fashion that has more fidelity at
// the low end than at the high end.
//
// The function is actually floor(log(n, 1.354), 1) to keep things
// in the integer realm.
//
// Why 1.354? Because log(128, 1.354) = 16, so we are using the full
// range from 0 to 15.
// 
// This function also cheats and just defines fn(0) = 0 and fn(1) = 1
// for convenience.
BYTE DV_LOG_1_354_lookup_table[95] = 
{
	 0,  1,  2,  3,  4,  5,  5,  6,	//   0..  7
	 6,  7,  7,  7,  8,  8,  8,  8, //   8.. 15
	 9,  9,  9,  9,  9, 10, 10, 10, //  16.. 23
	10, 10, 10, 10, 10, 11, 11, 11,	//  24.. 31
	11, 11, 11, 11, 11, 11, 12, 12, //  32.. 39
	12, 12, 12, 12, 12, 12, 12, 12, //  40.. 47
	12, 12, 12, 12, 13, 13, 13, 13, //  48.. 55
	13, 13, 13, 13, 13, 13, 13, 13, //  56.. 63
	13, 13, 13, 13, 13, 13, 14, 14, //  64.. 71
	14, 14, 14, 14, 14, 14, 14, 14, //  72.. 79
	14, 14, 14, 14, 14, 14, 14, 14, //  80.. 87
	14, 14, 14, 14, 14, 14, 14		//  88.. 94 - stop table at 94 here, everything above is 15
};

BYTE DV_log_1_354(BYTE n)
{
	if (n > 94) return 15;
	return DV_LOG_1_354_lookup_table[n];
}

// function to lookup the base 2 log of (n) where n is 16 bits unsigned
// except that we cheat and say that log_2 of zero is zero
// and we chop of any decimals.
BYTE DV_log_2(WORD n)
{
	if (n & 0x8000)
	{
		return 0x0f;
	}
	if (n & 0x4000)
	{
		return 0x0e;
	}
	if (n & 0x2000)
	{
		return 0x0d;
	}
	if (n & 0x1000)
	{
		return 0x0c;
	}
	if (n & 0x0800)
	{
		return 0x0b;
	}
	if (n & 0x0400)
	{
		return 0x0a;
	}
	if (n & 0x0200)
	{
		return 0x09;
	}
	if (n & 0x0100)
	{
		return 0x08;
	}
	if (n & 0x0080)
	{
		return 0x07;
	}
	if (n & 0x0040)
	{
		return 0x06;
	}
	if (n & 0x0020)
	{
		return 0x05;
	}
	if (n & 0x0010)
	{
		return 0x04;
	}
	if (n & 0x0008)
	{
		return 0x03;
	}
	if (n & 0x0004)
	{
		return 0x02;
	}
	if (n & 0x0002)
	{
		return 0x01;
	}
	return 0x00;
}

class CVoiceEncoderXmo: public XMediaObject
{
protected:
	DWORD m_fAutoMode;
	DWORD m_dwSensitivity;
	int m_dwSampleRate;

	int m_iEnvelopeSampleRate;
	int m_iCurEnvelopeValueFast;
	int m_iCurEnvelopeValueSlow;
	int m_iHangoverSamples;
	int m_iCurHangoverSamples;
	int m_iShiftConstantFast;
	int m_iShiftConstantSlow;

	BYTE m_bPeak;
    BYTE m_bMsgNum;
    WORD m_wSeqNum;
	WORD m_wCurrentMsgSeqCount;
	WORD m_wMaxSeqInMsg;
    DWORD m_dwMinOutputSize;

    LPXMEDIAOBJECT m_pEncoderXmo;

	BOOL m_fVoiceDetectedThisFrame;
    DWORD m_cRef;

public:

	CVoiceEncoderXmo() 
		: m_bPeak(0)
		, m_fVoiceDetectedThisFrame(FALSE)
        , m_dwSampleRate(0)
        , m_iCurEnvelopeValueFast(0)
        , m_iCurEnvelopeValueSlow(0)
        , m_iCurHangoverSamples(0)
        , m_bMsgNum(0)
        , m_wSeqNum(0)
		, m_wCurrentMsgSeqCount(0)
		, m_wMaxSeqInMsg(0)
        , m_pEncoderXmo(NULL)
        , m_fAutoMode(FALSE)
        , m_dwSensitivity(0)
        , m_iHangoverSamples(0) // number of samples we still consider trailing voice
        , m_dwMinOutputSize(sizeof(VOICE_ENCODER_HEADER))
        , m_cRef(0)
		{};

	~CVoiceEncoderXmo();
	
    STDMETHODIMP_(ULONG) AddRef() {
       return InterlockedIncrement((long*)&m_cRef);
    }

    STDMETHODIMP_(ULONG) Release() {
       long l = InterlockedDecrement((long*)&m_cRef);
       if (l == 0)
          delete this;
       return l;
    }

    HRESULT STDMETHODCALLTYPE Process( 
        LPCXMEDIAPACKET pSrcBuffer,
        LPCXMEDIAPACKET pDstBuffer
        );
    
	HRESULT STDMETHODCALLTYPE GetInfo(
        LPXMEDIAINFO pInfo
		);

    HRESULT STDMETHODCALLTYPE Flush();
    HRESULT STDMETHODCALLTYPE Discontinuity(void);

    HRESULT STDMETHODCALLTYPE GetStatus( 
        LPDWORD pdwStatus 
		);


	HRESULT Init(
		DWORD fAutoMode, 
        DWORD dwCodecTag,
        PWAVEFORMATEX pwfx,
		DWORD dwSensitivity);

private:

};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\a13x3x10.h ===
4.34528589e-01F,
3.23646277e-01F,
2.32339054e-01F,
3.25607687e-01F,
2.51167625e-01F,
3.12711388e-01F,
2.82360196e-01F,
2.88141936e-01F,
2.75269359e-01F,
2.68657684e-01F,
4.49432015e-01F,
2.77628332e-01F,
2.64371604e-01F,
2.54050255e-01F,
3.38863283e-01F,
2.38981605e-01F,
3.13796073e-01F,
2.88915396e-01F,
2.93504745e-01F,
2.62676477e-01F,
2.78296947e-01F,
3.95728618e-01F,
3.41971040e-01F,
2.90715635e-01F,
3.00232440e-01F,
2.52291739e-01F,
3.41175675e-01F,
2.61983246e-01F,
2.61316746e-01F,
3.04067194e-01F,
1.85245261e-01F,
2.77873129e-01F,
4.20877546e-01F,
2.87934631e-01F,
3.17782998e-01F,
3.06854665e-01F,
2.93427050e-01F,
2.89289296e-01F,
2.90239006e-01F,
3.24226111e-01F,
3.39363813e-01F,
3.15062970e-01F,
3.25116605e-01F,
3.25241476e-01F,
2.91450351e-01F,
3.29294831e-01F,
2.81253159e-01F,
3.03614467e-01F,
2.25323483e-01F,
3.00783038e-01F,
2.40789056e-01F,
3.14497292e-01F,
3.18876058e-01F,
2.95732349e-01F,
2.85945654e-01F,
3.69208038e-01F,
2.86577910e-01F,
2.86495209e-01F,
3.36905450e-01F,
2.99165696e-01F,
2.32341111e-01F,
2.83639610e-01F,
2.64330298e-01F,
3.27710390e-01F,
3.45025241e-01F,
2.77519673e-01F,
3.76531780e-01F,
2.92306036e-01F,
3.14038962e-01F,
3.12228203e-01F,
2.74741203e-01F,
4.37688828e-01F,
2.77012527e-01F,
2.83251703e-01F,
2.57304728e-01F,
2.89131910e-01F,
2.79893816e-01F,
3.05389732e-01F,
2.68947512e-01F,
3.29961598e-01F,
3.03051807e-03F,
2.40188281e-04F,
-2.13418920e-02F,
1.80495195e-02F,
4.23515253e-02F,
-6.80540949e-02F,
-3.03395698e-03F,
3.26126106e-02F,
2.83027682e-02F,
1.25023155e-02F,
1.19206697e-01F,
-6.40491173e-02F,
-5.06462865e-02F,
1.26432218e-02F,
3.46492454e-02F,
-2.40348708e-02F,
1.15403403e-02F,
-3.21205072e-02F,
-2.44851839e-02F,
3.35349254e-02F,
2.86481176e-02F,
1.12875495e-02F,
5.74581698e-02F,
-1.13623822e-02F,
6.94123330e-03F,
2.74620689e-02F,
1.98209821e-03F,
-3.25033069e-02F,
-6.85801683e-03F,
-4.81090620e-02F,
-1.05502725e-01F,
6.54047951e-02F,
1.30485566e-02F,
-2.67246254e-02F,
1.56615153e-02F,
6.36068778e-03F,
-4.27408004e-03F,
1.98577642e-02F,
4.37142774e-02F,
-1.20035689e-02F,
8.89864713e-02F,
1.89115107e-02F,
-6.56093433e-02F,
-8.92011076e-02F,
6.28961921e-02F,
1.60196405e-02F,
-5.07246070e-02F,
-3.26584210e-03F,
7.84520619e-03F,
1.82019584e-02F,
-7.41049945e-02F,
-1.05339892e-01F,
1.38767594e-02F,
6.92652985e-02F,
-1.17592970e-02F,
5.88572174e-02F,
-1.05411336e-02F,
5.27619533e-02F,
3.84322042e-03F,
8.64684209e-03F,
8.93826336e-02F,
9.66348350e-02F,
2.41823364e-02F,
-6.28314540e-02F,
-5.40168956e-02F,
-2.30308827e-02F,
-2.36270111e-02F,
-3.87085937e-02F,
-2.98503530e-03F,
-1.51933255e-02F,
-3.30385379e-02F,
1.34453718e-02F,
6.10616840e-02F,
6.26206025e-03F,
-7.25786686e-02F,
-1.16222203e-02F,
4.32333536e-03F,
-2.06355401e-03F,
1.77896451e-02F,
4.36978303e-02F,
-3.17162685e-02F,
4.98514324e-02F,
-1.33065898e-02F,
-1.49056804e-03F,
2.63663195e-02F,
8.79927073e-03F,
-6.71835542e-02F,
-1.00627663e-02F,
3.22370119e-02F,
2.73442157e-02F,
4.86060791e-02F,
8.13156292e-02F,
-4.92906012e-02F,
-1.56299677e-02F,
3.60853970e-02F,
-3.97585183e-02F,
6.28308742e-04F,
-1.15991654e-02F,
-6.28054980e-03F,
-2.85309665e-02F,
1.53192297e-01F,
-1.36902794e-01F,
2.48406967e-03F,
-1.88932661e-02F,
-1.91858709e-02F,
-3.82807455e-03F,
-3.18738595e-02F,
-1.72909535e-02F,
2.36728918e-02F,
4.60120011e-03F,
-1.04100496e-01F,
-7.48869926e-02F,
1.59122106e-02F,
1.06957788e-02F,
6.26620278e-02F,
7.04855309e-04F,
3.51634473e-02F,
2.48385761e-02F,
1.88751332e-02F,
2.15133131e-02F,
2.17565298e-02F,
6.25973716e-02F,
-2.70869974e-02F,
-7.42046311e-02F,
-3.68696675e-02F,
3.95359844e-02F,
1.77059900e-02F,
1.01846410e-02F,
3.60655482e-03F,
-5.03541296e-03F,
-4.46620658e-02F,
2.90878932e-03F,
-9.87577625e-03F,
8.39654505e-02F,
-4.98661622e-02F,
5.71689242e-03F,
3.64869721e-02F,
-7.66397780e-03F,
1.44954296e-02F,
-1.52705815e-02F,
-1.04864947e-02F,
1.00121208e-01F,
4.71627042e-02F,
-3.10631772e-03F,
-3.21292691e-02F,
-3.32828686e-02F,
-3.61658596e-02F,
2.85748634e-02F,
-1.57548189e-02F,
-3.72190177e-02F,
5.47509491e-02F,
-4.44752723e-02F,
3.74437571e-02F,
-2.37916913e-02F,
-4.42729071e-02F,
-2.45271660e-02F,
3.69111635e-02F,
5.86856790e-02F,
-3.11319926e-03F,
-3.67043130e-02F
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\a1233x10.h ===
3.21638376e-01F,
3.02824467e-01F,
2.49614969e-01F,
3.54954034e-01F,
2.83376575e-01F,
3.31252873e-01F,
3.05225313e-01F,
3.51852655e-01F,
3.08233589e-01F,
1.96938977e-01F,
3.27282280e-01F,
3.05171818e-01F,
2.93039799e-01F,
3.12290817e-01F,
3.60521555e-01F,
2.74269462e-01F,
2.98902690e-01F,
3.46979856e-01F,
2.34793454e-01F,
2.59544671e-01F,
2.63170958e-01F,
3.18358362e-01F,
3.92936826e-01F,
3.59467506e-01F,
2.70180106e-01F,
2.26641670e-01F,
3.12330872e-01F,
3.41009647e-01F,
2.76230752e-01F,
2.13593885e-01F,
2.79050857e-01F,
3.16122323e-01F,
3.77324373e-01F,
2.77224690e-01F,
3.84880394e-01F,
3.36164713e-01F,
2.38055170e-01F,
2.69892603e-01F,
2.75849700e-01F,
2.32933894e-01F,
2.67770857e-01F,
3.36283386e-01F,
3.24288964e-01F,
3.67384851e-01F,
3.16530764e-01F,
3.40529829e-01F,
3.35254252e-01F,
2.66441613e-01F,
2.31540948e-01F,
2.10252151e-01F,
2.85899132e-01F,
3.49022776e-01F,
3.31893444e-01F,
2.47548357e-01F,
2.43898913e-01F,
4.12267238e-01F,
3.14594567e-01F,
2.76475459e-01F,
2.93081254e-01F,
2.24522367e-01F,
2.87734658e-01F,
2.86044985e-01F,
2.66640246e-01F,
3.12120080e-01F,
3.26292664e-01F,
3.13089132e-01F,
4.23046410e-01F,
2.79516160e-01F,
3.05795461e-01F,
2.05794975e-01F,
3.14245045e-01F,
3.56380880e-01F,
2.94105917e-01F,
3.12568754e-01F,
2.86054045e-01F,
2.65797168e-01F,
2.66527921e-01F,
2.72080064e-01F,
3.76806855e-01F,
2.56306946e-01F,
2.57500857e-02F,
2.86802296e-02F,
-1.96902938e-02F,
5.63780405e-02F,
2.32232530e-02F,
-3.74556961e-03F,
1.26262140e-02F,
-5.55681027e-02F,
3.32038440e-02F,
-5.29636666e-02F,
1.30520537e-01F,
-1.04827568e-01F,
2.80865864e-03F,
5.56796491e-02F,
1.74617022e-02F,
-3.11446339e-02F,
-3.36185768e-02F,
-2.10983884e-02F,
-2.35973727e-02F,
5.62302433e-02F,
6.18834347e-02F,
1.94047615e-02F,
8.99903651e-04F,
2.62847133e-02F,
-3.60009111e-02F,
3.08440309e-02F,
-6.80667385e-02F,
5.92301264e-02F,
-3.76021899e-02F,
-3.13800164e-02F,
-1.82800725e-01F,
1.29645199e-01F,
-1.15666948e-02F,
-3.93113904e-02F,
1.22409482e-02F,
1.84349692e-03F,
-2.19607516e-03F,
1.45770488e-02F,
2.20365729e-02F,
2.58273706e-02F,
3.82038131e-02F,
6.04825616e-02F,
-4.13052440e-02F,
-4.04654555e-02F,
6.02599755e-02F,
-1.90194733e-02F,
3.09716491e-03F,
2.17984915e-02F,
-3.27792182e-03F,
-4.00695316e-02F,
-1.49953291e-01F,
-5.14816716e-02F,
6.64101765e-02F,
8.09412524e-02F,
1.09661110e-02F,
1.21265352e-02F,
-3.01245227e-02F,
2.56900731e-02F,
2.49743145e-02F,
-1.32112587e-02F,
1.17764458e-01F,
-3.60488403e-03F,
6.91896826e-02F,
-6.40234351e-02F,
3.22787538e-02F,
-1.70592275e-02F,
-8.49060994e-03F,
-7.20863640e-02F,
-4.15786803e-02F,
6.00916799e-03F,
-5.99351935e-02F,
3.33808474e-02F,
8.43745992e-02F,
-1.78321321e-02F,
-2.51654312e-02F,
3.62145565e-02F,
2.49333140e-02F,
-1.43974265e-02F,
6.14973623e-03F,
-4.08687852e-02F,
-1.05048642e-02F,
2.65669040e-02F,
-2.97496328e-03F,
1.88229159e-02F,
-1.80872604e-02F,
8.14206079e-02F,
-9.35006216e-02F,
-2.20296178e-02F,
4.55993935e-02F,
-3.08359675e-02F,
-2.80574001e-02F,
4.13731933e-02F,
1.34653244e-02F,
-2.49351505e-02F,
8.08874592e-02F,
-4.89103347e-02F,
1.23389699e-02F,
-1.18401628e-02F,
1.69463176e-02F,
-3.97702232e-02F,
9.38551575e-02F,
-5.73961698e-02F,
-6.25315122e-03F,
-2.80130804e-02F,
-4.33588289e-02F,
1.98537484e-02F,
6.86083036e-03F,
1.50932800e-02F,
-4.46393900e-03F,
2.78326459e-02F,
-1.36063006e-02F,
-1.80431847e-02F,
-9.25025530e-03F,
3.73192038e-03F,
3.79646532e-02F,
-5.61369509e-02F,
-2.14944500e-02F,
7.21915513e-02F,
6.43940717e-02F,
-3.56665589e-02F,
2.51252335e-02F,
4.02805209e-02F,
-6.52349442e-02F,
1.15569336e-02F,
3.01566441e-02F,
1.59067772e-02F,
4.62853424e-02F,
6.09736284e-03F,
-9.91236717e-02F,
-1.81436017e-02F,
4.36740881e-03F,
4.50209752e-02F,
-3.35573889e-02F,
9.86769497e-02F,
-5.70462793e-02F,
-3.84026691e-02F,
1.41701289e-02F,
-2.91130766e-02F,
-1.01271840e-02F,
3.49457352e-03F,
-4.74586040e-02F,
5.08122109e-02F,
4.85870242e-02F,
-3.96610610e-02F,
-5.73087670e-03F,
6.12283451e-03F,
-5.77675505e-03F,
5.33055849e-02F,
-1.68784633e-02F,
-3.01444493e-02F,
1.35184322e-02F,
2.52146553e-02F,
9.02669579e-02F,
-6.23933561e-02F,
-1.04008734e-01F,
-7.79853091e-02F,
5.46014719e-02F,
2.86983163e-03F,
4.38291393e-02F,
-2.86037810e-02F
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\a1333x10.h ===
3.28831792e-01F,
3.04841816e-01F,
2.56995887e-01F,
3.49073321e-01F,
3.09141338e-01F,
3.33331734e-01F,
3.00751120e-01F,
3.46998185e-01F,
2.91665137e-01F,
2.04645306e-01F,
2.92980105e-01F,
3.01192224e-01F,
3.00187558e-01F,
3.42981130e-01F,
3.28595191e-01F,
3.03781211e-01F,
2.90490806e-01F,
3.30479652e-01F,
2.30861172e-01F,
3.24686825e-01F,
2.74864286e-01F,
3.15891325e-01F,
3.79185140e-01F,
3.39124680e-01F,
2.95170456e-01F,
2.11900681e-01F,
3.19636941e-01F,
3.38876694e-01F,
3.05338323e-01F,
2.15656564e-01F,
2.74709821e-01F,
3.03402483e-01F,
3.83273572e-01F,
2.86067337e-01F,
3.67489457e-01F,
3.20384353e-01F,
2.47088522e-01F,
2.98961818e-01F,
2.83075511e-01F,
2.45919809e-01F,
2.75622845e-01F,
3.32022697e-01F,
3.28393638e-01F,
3.74860376e-01F,
2.99087912e-01F,
3.54028940e-01F,
3.32105607e-01F,
2.43454695e-01F,
2.63972759e-01F,
2.09363103e-01F,
2.94221461e-01F,
3.57453763e-01F,
3.07746589e-01F,
2.54739344e-01F,
2.35290423e-01F,
3.95370871e-01F,
3.15659165e-01F,
2.78067231e-01F,
2.96083331e-01F,
2.65259236e-01F,
2.85172909e-01F,
2.82662511e-01F,
2.77548969e-01F,
3.08943570e-01F,
3.19705546e-01F,
3.03372473e-01F,
4.05431777e-01F,
3.03736389e-01F,
3.07165384e-01F,
2.35157281e-01F,
3.00378442e-01F,
3.79185081e-01F,
2.51595259e-01F,
2.98938274e-01F,
3.05857956e-01F,
2.49811962e-01F,
3.23828369e-01F,
2.73423314e-01F,
3.49465728e-01F,
2.91487455e-01F,
1.14509622e-02F,
2.94045508e-02F,
-6.91961963e-03F,
5.11404276e-02F,
2.75878124e-02F,
-2.88886880e-03F,
1.04924366e-02F,
-7.45433047e-02F,
3.60466950e-02F,
-3.13512348e-02F,
1.19258352e-01F,
-9.01259482e-02F,
2.50590425e-02F,
3.24009880e-02F,
4.65049129e-03F,
-3.75074111e-02F,
-4.84912284e-02F,
-1.46100409e-02F,
-2.34033056e-02F,
8.03656951e-02F,
7.77406693e-02F,
2.14986666e-03F,
-3.66136208e-02F,
3.50617357e-02F,
-3.71887982e-02F,
2.02656090e-02F,
-4.92406525e-02F,
5.31029627e-02F,
-2.58407537e-02F,
-1.00412127e-02F,
-1.68923289e-01F,
1.32968426e-01F,
1.08500812e-02F,
-5.34940585e-02F,
4.56776423e-03F,
-4.30595642e-03F,
-4.78016213e-03F,
1.45337475e-03F,
1.81423370e-02F,
3.10713612e-02F,
3.76710892e-02F,
4.49475460e-02F,
-3.72683443e-02F,
-2.63405927e-02F,
5.55646978e-02F,
-1.91352493e-03F,
6.32007560e-03F,
1.96555331e-02F,
-4.22515487e-03F,
-5.70928380e-02F,
-1.54396653e-01F,
-2.26640459e-02F,
6.75438419e-02F,
9.57628116e-02F,
-1.48855634e-02F,
2.04080325e-02F,
-5.36608361e-02F,
2.34313216e-02F,
1.91652682e-02F,
-1.01935500e-02F,
1.22508459e-01F,
-1.26753189e-02F,
4.57687527e-02F,
-4.95082699e-02F,
1.43647892e-02F,
-8.85856524e-03F,
-1.06378431e-02F,
-4.71475832e-02F,
-3.48684900e-02F,
7.22306129e-03F,
-5.64958155e-02F,
3.61428447e-02F,
6.67424574e-02F,
-1.28251556e-02F,
-3.59581504e-03F,
2.88654491e-02F,
2.52415892e-02F,
-1.04488432e-03F,
-1.06324423e-02F,
-4.87459749e-02F,
-1.91458836e-02F,
3.85971293e-02F,
-1.32425260e-02F,
-5.28580742e-03F,
4.69857827e-03F,
8.17479342e-02F,
-7.53978714e-02F,
-1.57476384e-02F,
3.96745056e-02F,
-4.72200736e-02F,
-1.58481896e-02F,
4.11371663e-02F,
6.95493480e-04F,
-3.08291856e-02F,
5.97963929e-02F,
-4.48840745e-02F,
2.12129410e-02F,
-2.57427115e-02F,
2.33024415e-02F,
-3.29729775e-03F,
8.20653737e-02F,
-8.85325745e-02F,
-6.52924879e-03F,
1.79987755e-02F,
-2.03355346e-02F,
1.69820525e-02F,
3.26013775e-03F,
-1.30655337e-03F,
1.77007599e-03F,
3.18099000e-02F,
-2.93475576e-03F,
-2.85372175e-02F,
7.55899772e-03F,
-7.12615321e-04F,
3.33768986e-02F,
-4.81183752e-02F,
-9.60802380e-03F,
6.81652725e-02F,
4.44320701e-02F,
-4.16848361e-02F,
1.65008493e-02F,
6.17373697e-02F,
-6.07083067e-02F,
3.81529927e-02F,
1.44321267e-02F,
-2.78539141e-03F,
2.29880363e-02F,
-6.13650191e-04F,
-9.18951407e-02F,
-2.26829238e-02F,
-1.78515837e-02F,
2.75792181e-02F,
-1.15831215e-02F,
7.17852786e-02F,
-8.09790641e-02F,
-1.92514360e-02F,
2.71942317e-02F,
-1.55247338e-02F,
2.07751803e-02F,
2.07195561e-02F,
-2.90636942e-02F,
6.06497452e-02F,
3.91462930e-02F,
-2.81862225e-02F,
-8.64120759e-03F,
-8.46686959e-03F,
-1.76014602e-02F,
7.15054348e-02F,
-3.95085737e-02F,
-4.84316051e-02F,
2.67844256e-02F,
2.63433866e-02F,
7.51834512e-02F,
-8.77239257e-02F,
-8.36788937e-02F,
-7.10060298e-02F,
3.06394417e-02F,
1.06680552e-02F,
5.08286245e-02F,
-8.31500441e-03F
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\a1033x15.h ===
1.57249764e-01F,
2.89550364e-01F,
3.39304686e-01F,
3.38549912e-01F,
2.91041523e-01F,
2.32684299e-01F,
2.10174143e-01F,
2.46594101e-01F,
2.62066513e-01F,
2.46624514e-01F,
2.47003540e-01F,
2.81629056e-01F,
2.03678504e-01F,
1.33125246e-01F,
1.34821251e-01F,
3.69674712e-01F,
3.03654045e-01F,
2.30758607e-01F,
2.72433758e-01F,
2.72610724e-01F,
2.62973994e-01F,
2.55952597e-01F,
2.38172546e-01F,
1.93881273e-01F,
1.67758986e-01F,
2.14389920e-01F,
1.93182155e-01F,
2.41168931e-01F,
1.71091780e-01F,
2.50749499e-01F,
1.04629450e-01F,
1.86084077e-01F,
2.53712654e-01F,
2.83119321e-01F,
3.07132632e-01F,
3.14132869e-01F,
3.00533026e-01F,
2.93165177e-01F,
2.48741925e-01F,
2.37631589e-01F,
2.63874352e-01F,
2.74775922e-01F,
2.66925573e-01F,
1.29707322e-01F,
1.34579688e-01F,
5.40106930e-02F,
2.16010064e-01F,
3.89186144e-01F,
3.06689799e-01F,
2.60343015e-01F,
2.61068761e-01F,
2.61174023e-01F,
2.50210524e-01F,
2.34259784e-01F,
1.99713036e-01F,
2.37461254e-01F,
2.77339518e-01F,
2.29976922e-01F,
1.83584720e-01F,
1.92153275e-01F,
3.45978171e-01F,
3.12337220e-01F,
2.09284917e-01F,
2.55284756e-01F,
2.49601915e-01F,
2.45279670e-01F,
2.31536478e-01F,
2.39892319e-01F,
2.31576070e-01F,
2.17835709e-01F,
2.05395356e-01F,
3.12292933e-01F,
2.28922695e-01F,
2.07645774e-01F,
1.67462036e-01F,
2.83223063e-01F,
3.47175062e-01F,
2.76620328e-01F,
2.71448225e-01F,
3.15543294e-01F,
1.73822880e-01F,
1.88909054e-01F,
2.14840293e-01F,
1.91234887e-01F,
2.65379131e-01F,
2.07855240e-01F,
2.40686163e-01F,
2.74681866e-01F,
1.95177704e-01F,
1.61862001e-01F,
2.44548947e-01F,
3.60182106e-01F,
2.95959026e-01F,
2.47700855e-01F,
2.51051605e-01F,
2.67753124e-01F,
2.21955523e-01F,
2.58816034e-01F,
2.64593750e-01F,
1.91606611e-01F,
2.48941883e-01F,
2.39494428e-01F,
2.22853556e-01F,
1.70060053e-01F,
1.72064424e-01F,
1.76869154e-01F,
3.23347807e-01F,
3.39556992e-01F,
3.16172510e-01F,
2.60713637e-01F,
2.22178653e-01F,
2.88765997e-01F,
3.01675856e-01F,
2.09169954e-01F,
2.03309104e-01F,
2.28922278e-01F,
2.58297324e-01F,
2.42184997e-01F,
1.40511513e-01F,
1.36355102e-01F,
-3.02919261e-02F,
3.07194255e-02F,
-1.88568551e-02F,
-1.18889082e-02F,
1.05352059e-01F,
1.75075140e-02F,
-9.03333724e-02F,
-5.22451103e-02F,
1.93612669e-02F,
1.85630098e-03F,
2.62439791e-02F,
-2.49459408e-02F,
-7.22061843e-03F,
-9.62158013e-03F,
2.25258470e-02F,
-1.81110855e-02F,
-1.71302317e-03F,
-1.44916512e-02F,
-2.16567609e-02F,
4.40150825e-03F,
3.40038687e-02F,
6.53558597e-02F,
4.01245244e-02F,
2.56729163e-02F,
-1.55804735e-02F,
-1.39781982e-02F,
2.12762468e-02F,
-4.33673263e-02F,
-4.73202625e-03F,
-5.57758659e-03F,
-1.76326130e-02F,
-1.45391584e-03F,
1.61794797e-02F,
4.86962646e-02F,
4.73372452e-03F,
-6.61938861e-02F,
-1.64593142e-02F,
3.86793949e-02F,
7.44071007e-02F,
-3.54470722e-02F,
-5.23775183e-02F,
3.32409213e-03F,
-9.59148258e-03F,
1.25394983e-03F,
-2.34690960e-03F,
1.54910143e-02F,
3.50837074e-02F,
-2.67927516e-02F,
-6.00883253e-02F,
6.90405397e-03F,
7.74979144e-02F,
-1.16599537e-02F,
-6.21991744e-03F,
-2.09702794e-02F,
2.84300465e-02F,
-3.88500206e-02F,
3.21092643e-02F,
-1.04459040e-02F,
1.39664812e-02F,
-1.79495569e-03F,
-1.43101839e-02F,
-4.57944861e-03F,
3.24043399e-03F,
-5.69898810e-04F,
-3.60541046e-02F,
-5.63302748e-02F,
1.02233710e-02F,
1.86669137e-02F,
1.68875959e-02F,
8.70188400e-02F,
2.93700341e-02F,
7.68944481e-03F,
-2.63167340e-02F,
4.88559436e-03F,
-1.28850050e-03F,
-1.45876249e-02F,
-8.35724699e-04F,
1.95756950e-03F,
-1.81809943e-02F,
5.05275885e-03F,
5.27702719e-02F,
1.30346101e-02F,
-4.21038736e-03F,
4.15633060e-02F,
2.84204390e-02F,
-8.11495539e-03F,
-6.16433136e-02F,
3.39934640e-02F,
-1.70705002e-02F,
-5.83089702e-03F,
-7.88484048e-03F,
2.06488837e-03F,
-7.46392366e-03F,
-2.17950754e-02F,
-9.56313405e-03F,
4.18880135e-02F,
6.63699359e-02F,
-1.69427302e-02F,
-3.96235660e-02F,
7.30160950e-03F,
7.57804140e-02F,
-1.78106483e-02F,
-2.56699696e-02F,
4.04196093e-03F,
1.20113627e-03F,
-2.56074360e-03F,
2.31688451e-02F,
3.90578061e-02F,
7.82672837e-02F,
-5.02567971e-03F,
-4.51835394e-02F,
-2.65723541e-02F,
-4.72287424e-02F,
-3.02813202e-02F,
-7.60977250e-03F,
3.19807753e-02F,
-1.57786608e-02F,
1.50421867e-02F,
-4.73250728e-03F,
2.55916454e-03F,
-2.06182487e-02F,
-4.52921279e-02F,
-1.77671164e-02F,
2.89574172e-02F,
5.81659749e-02F,
3.12678777e-02F,
3.25506413e-03F,
-1.38280345e-02F,
-2.61274520e-02F,
3.91273759e-02F,
1.70142297e-02F,
-2.79319678e-02F,
-1.45190116e-03F,
-2.17184238e-03F,
-5.71529614e-03F,
-2.70785764e-03F,
-1.46284830e-02F,
6.43159403e-03F,
-6.59703510e-03F,
-1.82096623e-02F,
-7.33629277e-04F,
2.62355190e-02F,
4.35663536e-02F,
4.60861064e-02F,
3.77302952e-02F,
2.21321918e-02F,
-3.70063223e-02F,
-7.63384998e-02F,
4.81091626e-03F,
-8.63106549e-03F,
-1.87712591e-04F,
-1.51859578e-02F,
-2.62246095e-03F,
2.87242550e-02F,
2.30799280e-02F,
-3.78817804e-02F,
-3.37731168e-02F,
1.00178994e-01F,
-4.94234525e-02F,
-4.47494797e-02F,
-2.09941044e-02F,
-9.90222767e-03F,
2.57306360e-02F,
1.41308270e-03F,
-3.79792415e-04F,
-6.21220050e-03F,
-5.42946253e-03F,
-9.39581916e-03F,
-2.18832847e-02F,
-7.57896807e-03F,
1.20784983e-03F,
3.67785664e-03F,
2.08063889e-02F,
1.36083458e-02F,
-1.04121435e-02F,
7.55571201e-02F,
-2.99983174e-02F,
3.26166041e-02F,
-1.40728606e-02F,
-1.45502307e-03F,
-9.99849383e-03F,
-1.07525680e-02F,
-9.07191634e-03F,
-2.28956863e-02F,
1.58440210e-02F,
2.59272810e-02F,
-5.99308051e-02F,
-1.86648630e-02F,
1.03669085e-01F,
2.73311585e-02F,
-2.21088063e-02F,
4.86030197e-03F,
-2.20831716e-03F,
-1.11757293e-02F,
-7.99458101e-03F,
8.27210397e-03F,
1.68123506e-02F,
6.93370122e-03F,
5.56284282e-03F,
1.26332399e-02F,
1.21949250e-02F,
-3.34332809e-02F,
-3.88178490e-02F,
-1.68712847e-02F,
-2.90232040e-02F,
2.46390384e-02F,
5.34930788e-02F,
-4.27525155e-02F,
3.14658135e-03F,
1.33786509e-02F,
-5.74533083e-03F,
-2.06755102e-03F,
3.78382276e-03F,
1.45182889e-02F,
9.94532462e-03F,
-2.36508902e-02F,
8.63325670e-02F,
-2.76712216e-02F,
-2.64385268e-02F,
2.94844154e-03F,
-5.33275902e-02F,
1.02371965e-02F,
1.35411713e-02F,
-1.24399445e-03F,
5.30236587e-03F,
3.66299860e-02F,
6.12285323e-02F,
1.52658746e-02F,
-7.10411295e-02F,
-8.26776922e-02F,
-2.42214929e-02F,
3.64239654e-03F,
-9.47542768e-03F,
2.53386516e-02F,
4.63442691e-02F,
-1.45126721e-02F,
-1.28140720e-02F,
2.19079833e-02F,
1.58675611e-02F,
5.23842126e-03F
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\a1433x10.h ===
3.14945340e-01F,
2.97814250e-01F,
2.55805016e-01F,
3.53551924e-01F,
2.95480520e-01F,
3.46654773e-01F,
3.01926404e-01F,
3.31269383e-01F,
3.07200521e-01F,
2.47798413e-01F,
2.98731685e-01F,
2.90983081e-01F,
3.10583770e-01F,
3.10313672e-01F,
3.40011001e-01F,
2.98866540e-01F,
2.88654685e-01F,
3.24669152e-01F,
2.34730527e-01F,
3.51103961e-01F,
2.43660346e-01F,
3.11517626e-01F,
3.78673702e-01F,
3.19687068e-01F,
3.06353897e-01F,
2.37234965e-01F,
3.37396711e-01F,
3.46401662e-01F,
3.07392210e-01F,
2.46913344e-01F,
2.57102937e-01F,
2.99687147e-01F,
3.61956954e-01F,
2.98946917e-01F,
3.67148101e-01F,
3.11082661e-01F,
2.51563042e-01F,
3.07135582e-01F,
3.01980376e-01F,
2.90656716e-01F,
2.80181468e-01F,
3.30439925e-01F,
3.39852214e-01F,
3.66815537e-01F,
2.98635215e-01F,
3.47759962e-01F,
3.19606036e-01F,
2.63252616e-01F,
2.53466278e-01F,
2.29766488e-01F,
2.82038718e-01F,
3.74728382e-01F,
2.93042183e-01F,
2.44653895e-01F,
2.74909407e-01F,
3.79656583e-01F,
2.88952887e-01F,
2.89201766e-01F,
2.98896313e-01F,
2.95752108e-01F,
3.07155222e-01F,
2.90457904e-01F,
2.40504444e-01F,
3.31537008e-01F,
2.76949733e-01F,
3.11118066e-01F,
4.19624597e-01F,
3.09571028e-01F,
2.79820830e-01F,
2.60160416e-01F,
2.92644143e-01F,
3.95773888e-01F,
2.49668047e-01F,
3.22367460e-01F,
3.01300049e-01F,
2.58988529e-01F,
3.22153032e-01F,
2.77518630e-01F,
3.18122208e-01F,
2.89336473e-01F,
3.00133554e-03F,
1.49962716e-02F,
-5.85748255e-03F,
5.50056957e-02F,
4.09001205e-03F,
2.53628287e-02F,
-1.34000869e-03F,
-5.78494966e-02F,
3.01655792e-02F,
-2.12136507e-02F,
1.07836217e-01F,
-7.17905015e-02F,
3.52368765e-02F,
2.10343432e-02F,
1.84092857e-02F,
-3.11654527e-02F,
-7.47463480e-02F,
-2.01621074e-02F,
-2.95086205e-02F,
6.88024685e-02F,
9.52828974e-02F,
8.71895719e-03F,
-4.23319302e-02F,
2.25530621e-02F,
-4.61542681e-02F,
1.14486767e-02F,
-2.10912712e-02F,
4.34115306e-02F,
-1.93342455e-02F,
-1.73687879e-02F,
-1.73043966e-01F,
1.16166562e-01F,
-1.87971853e-02F,
-4.66775410e-02F,
1.60809234e-02F,
-2.74573709e-03F,
4.27152403e-03F,
-8.08698125e-03F,
3.35148275e-02F,
3.48048955e-02F,
3.28758769e-02F,
5.18218428e-02F,
-4.28010486e-02F,
-1.72898471e-02F,
3.52085494e-02F,
3.35992081e-03F,
-3.90725769e-03F,
2.34337654e-02F,
-2.29096711e-02F,
-2.17853971e-02F,
-1.59545362e-01F,
-1.36267422e-02F,
7.41903111e-02F,
7.27491900e-02F,
-5.69937797e-03F,
2.20439620e-02F,
-5.89574054e-02F,
2.59219613e-02F,
-8.66833981e-03F,
2.44021304e-02F,
1.05626963e-01F,
-4.47243489e-02F,
3.18179615e-02F,
-2.37946864e-02F,
1.39535731e-02F,
-1.43264411e-02F,
1.84305608e-02F,
-3.20543163e-02F,
-1.41950632e-02F,
3.38092766e-04F,
-3.39825228e-02F,
4.27876562e-02F,
4.46872190e-02F,
-1.58107020e-02F,
-5.02940780e-03F,
6.52271742e-03F,
2.23471411e-02F,
-2.22067488e-03F,
-3.35532725e-02F,
2.29634512e-02F,
3.99577944e-03F,
4.86406274e-02F,
1.02236017e-03F,
1.97433727e-03F,
5.03772579e-04F,
4.25436646e-02F,
-7.18899220e-02F,
-3.47506404e-02F,
3.44594009e-02F,
-1.69786029e-02F,
-2.52592675e-02F,
1.38041861e-02F,
1.20780235e-02F,
-3.28291417e-03F,
5.46302833e-02F,
-5.62043227e-02F,
1.44307083e-02F,
-2.74556559e-02F,
2.38180067e-02F,
1.62800420e-02F,
8.15483183e-02F,
-6.85418472e-02F,
-1.60110276e-02F,
1.39023503e-03F,
-1.25079472e-02F,
1.40606267e-02F,
9.63946991e-03F,
-5.85249672e-03F,
-1.26548149e-02F,
3.81996445e-02F,
-4.08289861e-03F,
-6.69289287e-03F,
-2.27946769e-02F,
-2.61507686e-02F,
1.96864549e-02F,
-3.01425010e-02F,
1.51680410e-02F,
5.95187172e-02F,
5.42649999e-02F,
-3.60501520e-02F,
8.38266779e-03F,
6.44722506e-02F,
-7.21458495e-02F,
3.46192606e-02F,
1.52050955e-02F,
3.32331797e-03F,
2.71064811e-03F,
1.62422843e-02F,
-9.65851247e-02F,
-8.54252931e-03F,
-7.62440776e-03F,
2.32872218e-02F,
-1.73938517e-02F,
7.03851432e-02F,
-8.14960599e-02F,
-3.09130177e-02F,
9.84654855e-03F,
7.50816660e-04F,
2.39320714e-02F,
1.13340626e-02F,
-1.79677829e-02F,
5.35709932e-02F,
2.85107549e-02F,
-1.85333826e-02F,
-1.97672378e-02F,
7.25901639e-03F,
-2.59587318e-02F,
7.38252103e-02F,
-3.66970785e-02F,
-4.60644402e-02F,
6.17302535e-03F,
8.00315943e-03F,
8.72887373e-02F,
-7.51162618e-02F,
-6.78454265e-02F,
-4.54123132e-02F,
2.20348388e-02F,
2.15473343e-02F,
2.46121846e-02F,
1.19045675e-02F
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\a1133x10.h ===
3.34587455e-01F,
2.89742827e-01F,
2.41175249e-01F,
3.57111245e-01F,
2.93720990e-01F,
3.37017864e-01F,
2.95045614e-01F,
3.69654745e-01F,
2.96875149e-01F,
2.00953349e-01F,
3.64659816e-01F,
2.94358790e-01F,
3.17953616e-01F,
3.20581734e-01F,
3.72639894e-01F,
2.63663083e-01F,
2.76916355e-01F,
3.40494990e-01F,
2.01585308e-01F,
2.19002470e-01F,
2.47352943e-01F,
3.34372789e-01F,
4.03868824e-01F,
3.49298567e-01F,
2.57326484e-01F,
2.56991267e-01F,
2.86994010e-01F,
3.33978772e-01F,
2.62122780e-01F,
2.33352885e-01F,
2.88998038e-01F,
3.46082717e-01F,
3.73679310e-01F,
2.35365108e-01F,
3.66604120e-01F,
3.41174811e-01F,
2.20937014e-01F,
2.74058878e-01F,
2.62832671e-01F,
2.44358718e-01F,
2.77251095e-01F,
3.29573870e-01F,
3.27427566e-01F,
3.68525416e-01F,
3.16023678e-01F,
3.51640731e-01F,
3.32412779e-01F,
2.41381481e-01F,
2.39974245e-01F,
2.06092268e-01F,
2.78025717e-01F,
3.45669746e-01F,
3.34431827e-01F,
2.56211042e-01F,
2.51837522e-01F,
3.93198997e-01F,
3.39871347e-01F,
2.87910104e-01F,
3.02382618e-01F,
2.13211492e-01F,
2.63373315e-01F,
2.94773281e-01F,
2.78178811e-01F,
3.33455116e-01F,
3.26853663e-01F,
3.00932258e-01F,
4.26716596e-01F,
2.84599394e-01F,
2.83549249e-01F,
2.13172823e-01F,
3.18444282e-01F,
3.61719966e-01F,
2.85061538e-01F,
2.99167901e-01F,
2.92208910e-01F,
2.44155660e-01F,
2.91841686e-01F,
2.57516563e-01F,
3.58974904e-01F,
2.83731997e-01F,
2.31944844e-02F,
2.16299165e-02F,
-1.36322528e-02F,
7.37909451e-02F,
3.25909592e-02F,
-3.24800285e-03F,
-1.00090550e-02F,
-4.35220823e-02F,
1.29216919e-02F,
-4.95217443e-02F,
1.39870539e-01F,
-8.97587091e-02F,
-2.39283708e-03F,
3.48494239e-02F,
2.20721290e-02F,
-2.00360455e-02F,
-1.98448431e-02F,
-4.26190309e-02F,
-4.49531898e-02F,
6.99180588e-02F,
6.68826252e-02F,
3.05199679e-02F,
1.44641865e-02F,
2.09619515e-02F,
-2.88886148e-02F,
2.99554225e-02F,
-9.03626606e-02F,
5.01026213e-02F,
-4.82627414e-02F,
-1.65177546e-02F,
-1.61594808e-01F,
1.34860530e-01F,
-2.19143908e-02F,
7.53149507e-05F,
-1.26000876e-02F,
-2.63978378e-03F,
-2.01953948e-03F,
7.86511879e-03F,
2.45176852e-02F,
3.86177003e-03F,
4.98724096e-02F,
3.39787863e-02F,
-3.88622172e-02F,
-5.50556406e-02F,
8.17201212e-02F,
-3.37779373e-02F,
2.34199484e-04F,
3.22172791e-02F,
1.03182560e-02F,
-3.47501859e-02F,
-1.33391753e-01F,
-6.73929825e-02F,
2.38923915e-02F,
7.73373768e-02F,
2.41489988e-03F,
5.12397513e-02F,
3.92491603e-03F,
4.41334024e-02F,
1.72528382e-02F,
-2.17963047e-02F,
8.18289518e-02F,
3.14443074e-02F,
6.95686489e-02F,
-5.93920723e-02F,
1.04327295e-02F,
-3.80137004e-02F,
2.97388732e-02F,
-9.84852836e-02F,
-8.65491852e-03F,
-1.67112462e-02F,
-6.61649704e-02F,
3.21807712e-02F,
1.04291283e-01F,
-1.95987560e-02F,
-1.84237976e-02F,
2.71015149e-02F,
2.11402532e-02F,
-1.28741562e-02F,
-1.52111240e-03F,
-4.62426096e-02F,
-3.62546854e-02F,
3.65945101e-02F,
1.14977807e-02F,
1.16623398e-02F,
-1.43625529e-03F,
6.79231361e-02F,
-5.95567562e-02F,
-3.12779732e-02F,
3.95785645e-02F,
-3.25955115e-02F,
-2.82580405e-02F,
4.32405807e-02F,
9.57046077e-03F,
-1.14218425e-02F,
8.38888288e-02F,
-4.75787781e-02F,
1.29440688e-02F,
-1.98189709e-02F,
-2.55444495e-04F,
-3.44529487e-02F,
1.03661105e-01F,
-4.98167351e-02F,
-3.13448124e-02F,
-3.56927589e-02F,
-4.77527939e-02F,
3.75636220e-02F,
-2.22852882e-02F,
2.89956890e-02F,
3.32262926e-02F,
1.17432894e-02F,
-9.44121089e-03F,
-1.20018022e-02F,
-1.11736432e-02F,
1.03001893e-02F,
4.42406759e-02F,
-5.93351535e-02F,
-3.55196670e-02F,
4.92210500e-02F,
6.39205500e-02F,
-1.95225291e-02F,
2.54113320e-02F,
6.23484701e-02F,
-7.36689121e-02F,
3.76767502e-03F,
-1.56559572e-02F,
3.57972793e-02F,
3.98073457e-02F,
1.20898774e-02F,
-8.86684656e-02F,
-1.53278578e-02F,
-1.07916715e-02F,
1.31550021e-02F,
2.54431623e-03F,
1.12904891e-01F,
-4.03623208e-02F,
-5.61612956e-02F,
1.71661600e-02F,
-2.51621194e-02F,
-1.00119347e-02F,
2.50627543e-03F,
-5.91028668e-02F,
5.95209002e-02F,
6.55248612e-02F,
-4.59381454e-02F,
3.47198755e-03F,
-1.61494054e-02F,
1.13566276e-02F,
5.31522036e-02F,
-3.96676622e-02F,
-3.27865742e-02F,
8.85567740e-02F,
-1.20505709e-02F,
7.61542395e-02F,
-6.25333339e-02F,
-1.10281914e-01F,
-6.56938329e-02F,
2.85568740e-02F,
3.51341665e-02F,
1.78248528e-02F,
-3.47239524e-02F
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\a23x3x10.h ===
4.26374078e-01F,
2.98883110e-01F,
1.99530870e-01F,
3.42382103e-01F,
2.66806662e-01F,
3.04889292e-01F,
2.98219711e-01F,
2.76028991e-01F,
2.75695592e-01F,
2.80752450e-01F,
4.59526390e-01F,
2.76623458e-01F,
2.63570815e-01F,
2.40455940e-01F,
3.68050009e-01F,
2.41792813e-01F,
3.04649681e-01F,
2.42338121e-01F,
2.83578813e-01F,
2.82986730e-01F,
2.69599169e-01F,
3.75122547e-01F,
4.40542072e-01F,
3.52920681e-01F,
2.59731412e-01F,
2.32746989e-01F,
2.59948283e-01F,
2.38122299e-01F,
2.45424315e-01F,
2.67321408e-01F,
1.97445557e-01F,
2.89753318e-01F,
4.77254689e-01F,
2.65839487e-01F,
2.98000723e-01F,
2.86190420e-01F,
3.06451678e-01F,
2.85713792e-01F,
2.65056282e-01F,
2.75410146e-01F,
3.01629126e-01F,
3.54252696e-01F,
3.35216880e-01F,
3.25859785e-01F,
2.90642142e-01F,
3.12617451e-01F,
2.75587291e-01F,
2.91561604e-01F,
2.28268191e-01F,
2.91570753e-01F,
2.56313890e-01F,
2.98861057e-01F,
3.13916415e-01F,
2.90793955e-01F,
3.01540613e-01F,
3.55561942e-01F,
2.98143834e-01F,
2.83170313e-01F,
3.23324263e-01F,
3.02267820e-01F,
2.98182845e-01F,
2.87839860e-01F,
2.18901798e-01F,
3.07182819e-01F,
3.09708297e-01F,
2.69780010e-01F,
3.84609550e-01F,
3.02939355e-01F,
3.00797284e-01F,
3.31169575e-01F,
2.80750513e-01F,
4.53660488e-01F,
2.48964265e-01F,
2.90841818e-01F,
2.52129018e-01F,
2.86732346e-01F,
2.72227228e-01F,
3.00832182e-01F,
2.75070637e-01F,
3.08033705e-01F,
3.67188547e-03F,
6.94839691e-05F,
-6.67870091e-03F,
4.93738689e-02F,
2.98041385e-02F,
-4.09426577e-02F,
-3.86134721e-02F,
1.84752308e-02F,
2.72299517e-02F,
9.93900746e-03F,
1.39740482e-01F,
-5.80418706e-02F,
-4.78026383e-02F,
-1.37920212e-02F,
2.30396278e-02F,
-1.10843731e-02F,
9.29139275e-03F,
-1.81538500e-02F,
-3.84443477e-02F,
4.20310125e-02F,
4.25022431e-02F,
5.62275350e-02F,
4.62782122e-02F,
1.16609680e-02F,
-1.93778332e-02F,
-5.51915320e-04F,
-9.23496485e-03F,
-2.70185731e-02F,
-1.42438374e-02F,
-5.67183718e-02F,
-1.03340849e-01F,
8.43561515e-02F,
-2.34162118e-02F,
-3.62337753e-02F,
2.48138737e-02F,
2.13731583e-02F,
1.30596422e-02F,
2.02004053e-02F,
2.94957161e-02F,
-6.68155216e-03F,
7.57724121e-02F,
4.74688299e-02F,
-4.62892577e-02F,
-9.81733799e-02F,
6.92358837e-02F,
-3.18662412e-02F,
-1.66355856e-02F,
-4.58265562e-03F,
2.56970283e-02F,
8.51904787e-03F,
-8.66131186e-02F,
-1.22559212e-01F,
-8.20423849e-03F,
1.30800545e-01F,
9.63284262e-03F,
4.27970067e-02F,
-1.97012462e-02F,
3.30165103e-02F,
6.00266177e-03F,
7.70692481e-03F,
9.89500657e-02F,
1.07826985e-01F,
6.58679605e-02F,
-1.01973996e-01F,
-7.45158717e-02F,
-2.90098619e-02F,
-2.93128509e-02F,
-4.81613576e-02F,
-1.57611351e-02F,
-1.40643306e-02F,
-3.97942327e-02F,
-1.39838746e-02F,
1.28082544e-01F,
1.55602563e-02F,
-5.74591570e-02F,
-8.72763281e-04F,
-7.86977634e-03F,
-1.26422942e-02F,
5.00767434e-04F,
9.40387417e-03F,
-2.85217892e-02F,
4.79434021e-02F,
-1.68980248e-02F,
-4.25463961e-03F,
2.47038249e-02F,
1.52570847e-02F,
-6.32195845e-02F,
1.37073305e-02F,
3.06789968e-02F,
1.06596574e-02F,
3.92115824e-02F,
1.06248483e-01F,
-7.24342093e-02F,
-3.14442329e-02F,
3.76971923e-02F,
-4.56254035e-02F,
2.51108967e-02F,
-6.55535748e-03F,
-7.19095441e-03F,
-3.71870734e-02F,
1.51659235e-01F,
-1.43996730e-01F,
-2.09187828e-02F,
-2.31142286e-02F,
-2.79214811e-02F,
3.28195430e-02F,
-2.38748584e-02F,
2.55625951e-03F,
2.24978868e-02F,
1.39545966e-02F,
-1.09675214e-01F,
-6.36999533e-02F,
4.98970039e-03F,
3.98536446e-03F,
4.84650210e-02F,
9.10654571e-03F,
4.29650992e-02F,
1.96329206e-02F,
2.11526249e-02F,
4.50256839e-02F,
4.90908809e-02F,
1.09369516e-01F,
-2.93141734e-02F,
-8.38210061e-02F,
-4.73758020e-02F,
3.25090922e-02F,
-2.60052290e-02F,
2.54483745e-02F,
-8.30242131e-03F,
-3.19098979e-02F,
-4.49108668e-02F,
1.20593868e-02F,
6.24067010e-03F,
9.80432555e-02F,
-5.58507293e-02F,
-2.22162604e-02F,
3.47495116e-02F,
-1.37436204e-02F,
8.81312229e-03F,
-8.51904880e-03F,
-3.31473053e-02F,
9.46696624e-02F,
9.88166481e-02F,
7.77031714e-03F,
-5.03185093e-02F,
-4.87999171e-02F,
-2.05311533e-02F,
-1.85945164e-03F,
-2.69708540e-02F,
-3.57054323e-02F,
8.63557756e-02F,
-8.61520246e-02F,
7.18852356e-02F,
-2.29521804e-02F,
-1.72243509e-02F,
-3.99219766e-02F,
6.79079816e-03F,
5.32048903e-02F,
3.29528679e-03F,
-4.96552065e-02F
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\a1533x10.h ===
3.11404139e-01F,
2.79287666e-01F,
2.60796517e-01F,
3.16733629e-01F,
2.83894271e-01F,
3.49789709e-01F,
3.17851305e-01F,
3.36627215e-01F,
3.38314772e-01F,
2.48066649e-01F,
2.89166063e-01F,
2.85854012e-01F,
3.39227945e-01F,
2.89663613e-01F,
3.49944770e-01F,
2.75354534e-01F,
3.15643132e-01F,
3.29790235e-01F,
2.27795526e-01F,
3.40915233e-01F,
2.85379976e-01F,
3.03634673e-01F,
3.49332601e-01F,
3.18155020e-01F,
3.10436964e-01F,
2.55599886e-01F,
3.10009807e-01F,
3.36058736e-01F,
3.17247450e-01F,
2.75560200e-01F,
2.99526960e-01F,
3.04936528e-01F,
3.36510092e-01F,
2.96725094e-01F,
3.85457218e-01F,
2.99984485e-01F,
2.50973254e-01F,
2.92853087e-01F,
2.92562693e-01F,
2.91517913e-01F,
2.67355651e-01F,
2.90361196e-01F,
3.40084821e-01F,
3.82350087e-01F,
2.87188351e-01F,
3.61847639e-01F,
3.39902937e-01F,
2.71723747e-01F,
2.50914603e-01F,
2.50360727e-01F,
2.76003182e-01F,
3.47953111e-01F,
3.00168574e-01F,
2.78606772e-01F,
2.87318200e-01F,
3.59646052e-01F,
3.11145872e-01F,
2.77125090e-01F,
3.17214519e-01F,
3.12729985e-01F,
2.84062296e-01F,
2.92345107e-01F,
2.22107261e-01F,
3.72507691e-01F,
3.09683353e-01F,
3.23730528e-01F,
3.80841136e-01F,
3.12274009e-01F,
2.61198133e-01F,
2.66058087e-01F,
2.86093116e-01F,
3.97607684e-01F,
2.50378460e-01F,
3.27208519e-01F,
2.70501614e-01F,
2.61066407e-01F,
3.52309048e-01F,
3.03145766e-01F,
2.83917427e-01F,
2.87799895e-01F,
1.72253028e-02F,
3.82389463e-02F,
-3.69040333e-02F,
2.88046859e-02F,
-2.18535447e-03F,
3.13106403e-02F,
-2.70828269e-02F,
-5.14366999e-02F,
7.85674248e-03F,
5.22783250e-02F,
8.98244381e-02F,
-8.14354792e-02F,
3.98125872e-02F,
1.44707812e-02F,
1.18939346e-02F,
-3.47315557e-02F,
-5.66989407e-02F,
7.55812041e-03F,
-4.72546704e-02F,
7.89410323e-02F,
1.10588759e-01F,
4.83251037e-03F,
-3.49322483e-02F,
1.62086766e-02F,
-5.09221926e-02F,
6.89375028e-03F,
-1.99999548e-02F,
2.82870829e-02F,
-2.82648318e-02F,
-2.19667722e-02F,
-1.86935052e-01F,
9.80184898e-02F,
1.17248180e-03F,
-4.21812795e-02F,
1.02191884e-02F,
3.33280093e-03F,
2.20788475e-02F,
-1.15801636e-02F,
3.26949805e-02F,
3.21188532e-02F,
4.40489240e-02F,
4.85967249e-02F,
-7.15692192e-02F,
-1.43838506e-02F,
3.17475609e-02F,
-1.26439175e-02F,
-5.75513020e-03F,
2.73181032e-02F,
-1.36971311e-03F,
-1.71889551e-02F,
-1.62742570e-01F,
2.02386617e-03F,
8.52647051e-02F,
5.71841635e-02F,
-2.06707995e-02F,
-6.82563381e-03F,
-1.35451248e-02F,
1.24654090e-02F,
2.24298295e-02F,
7.78267439e-03F,
9.78073180e-02F,
-5.26664294e-02F,
2.76265945e-02F,
1.33371900e-03F,
3.47225554e-02F,
3.06639541e-03F,
-6.71914220e-03F,
-2.78110169e-02F,
-8.64420459e-03F,
-1.43242897e-02F,
3.03283730e-03F,
4.06470150e-02F,
3.83402519e-02F,
-9.66375973e-03F,
1.50921755e-02F,
3.03187710e-03F,
1.51829636e-02F,
-2.33387426e-02F,
-1.86993498e-02F,
-2.95735267e-03F,
-1.50315231e-03F,
3.34898978e-02F,
1.38677619e-02F,
3.99733037e-02F,
1.65493088e-03F,
1.02996472e-02F,
-6.72161877e-02F,
-2.09668484e-02F,
2.58431882e-02F,
-2.30462197e-02F,
-8.72448646e-03F,
1.95425972e-02F,
2.70919316e-03F,
3.21241654e-03F,
5.32701388e-02F,
-6.72922656e-02F,
5.41091943e-03F,
-2.79202219e-02F,
1.27661685e-02F,
1.80810317e-02F,
5.71163818e-02F,
-7.81086534e-02F,
-9.31098964e-03F,
1.52091859e-02F,
5.94281405e-03F,
2.01232154e-02F,
1.34566072e-02F,
-3.71089182e-03F,
-1.59802865e-02F,
9.48701985e-03F,
4.28989326e-04F,
-5.64765139e-03F,
-8.64079746e-04F,
-2.39170287e-02F,
1.66646484e-02F,
-5.02144657e-02F,
6.79969788e-03F,
6.93672448e-02F,
4.25624847e-02F,
-3.87108661e-02F,
8.87591112e-03F,
8.30667168e-02F,
-5.92144094e-02F,
1.70393270e-02F,
-1.37012275e-02F,
9.93171986e-03F,
3.70706506e-02F,
-1.74924228e-02F,
-5.69169037e-02F,
-2.21795589e-02F,
6.21230667e-03F,
1.96558405e-02F,
-3.19666602e-02F,
5.17964363e-02F,
-8.34738612e-02F,
-5.81443729e-03F,
-1.03012482e-02F,
7.02708960e-03F,
1.05383899e-02F,
4.02693227e-02F,
-7.37347966e-03F,
2.54609808e-02F,
-1.43604344e-02F,
-1.24528576e-02F,
-4.55387495e-03F,
1.37188118e-02F,
-1.33895632e-02F,
6.16581477e-02F,
-8.17036908e-03F,
-1.57118570e-02F,
4.46067601e-02F,
1.45441340e-02F,
6.67837113e-02F,
-9.87469330e-02F,
-5.95402382e-02F,
-4.91785593e-02F,
3.49085368e-02F,
1.23286843e-02F,
4.18852046e-02F,
4.36855294e-03F
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\a43x3x10.h ===
4.11216170e-01F,
2.68744260e-01F,
2.06575796e-01F,
3.60030204e-01F,
2.30064481e-01F,
3.30873191e-01F,
2.80327797e-01F,
2.90611327e-01F,
2.92925149e-01F,
2.65809268e-01F,
4.01232868e-01F,
2.41215795e-01F,
2.80858070e-01F,
2.43143588e-01F,
4.26768571e-01F,
2.61407882e-01F,
2.87401617e-01F,
2.66073912e-01F,
2.67537564e-01F,
2.48495787e-01F,
3.03915292e-01F,
3.84279728e-01F,
4.38608199e-01F,
3.14597189e-01F,
2.70300061e-01F,
2.36349583e-01F,
2.33968437e-01F,
2.33462617e-01F,
2.29878172e-01F,
2.58363038e-01F,
2.01919794e-01F,
3.00023824e-01F,
4.61808562e-01F,
2.83846676e-01F,
3.77062351e-01F,
2.64476001e-01F,
2.61030883e-01F,
2.53178895e-01F,
2.41043717e-01F,
2.75743395e-01F,
3.11334848e-01F,
3.33884269e-01F,
3.42216611e-01F,
3.88723463e-01F,
3.06062847e-01F,
2.79707491e-01F,
2.84103006e-01F,
2.47163907e-01F,
2.23409534e-01F,
2.57813215e-01F,
2.61465460e-01F,
3.26402277e-01F,
3.67514431e-01F,
2.71940678e-01F,
2.47035429e-01F,
3.78415883e-01F,
2.77335852e-01F,
2.62895316e-01F,
2.87476093e-01F,
2.84094304e-01F,
3.28427225e-01F,
3.03231686e-01F,
2.29321554e-01F,
2.58014053e-01F,
3.16225290e-01F,
2.74127752e-01F,
3.94966930e-01F,
2.86071599e-01F,
2.62877405e-01F,
3.15908849e-01F,
3.00892889e-01F,
4.17894721e-01F,
2.41185471e-01F,
3.08007300e-01F,
2.93940157e-01F,
2.55985975e-01F,
2.61584938e-01F,
2.86356658e-01F,
2.61785269e-01F,
3.22941452e-01F,
3.41152214e-02F,
-3.02573182e-02F,
-3.59198786e-02F,
1.02633834e-01F,
8.30437988e-02F,
-2.29633208e-02F,
-2.68704444e-02F,
-1.96366645e-02F,
-1.91791449e-02F,
-1.61093324e-02F,
1.47892788e-01F,
-3.25553268e-02F,
-2.90647093e-02F,
-4.67322059e-02F,
-2.43521128e-02F,
-3.77429537e-02F,
-8.63556564e-03F,
-3.45051922e-02F,
2.26738341e-02F,
5.71150705e-02F,
7.48681799e-02F,
7.43574426e-02F,
5.04199751e-02F,
3.32012735e-02F,
-3.32998037e-02F,
-2.24211589e-02F,
-6.99733049e-02F,
-2.87695602e-02F,
-3.73874307e-02F,
-3.80869918e-02F,
-1.27775013e-01F,
1.14831254e-01F,
-4.16631810e-02F,
-1.35966036e-02F,
1.41942408e-02F,
-1.56993093e-03F,
-1.61309168e-03F,
2.98066456e-02F,
4.84272540e-02F,
1.08890049e-02F,
6.49127439e-02F,
4.97410744e-02F,
-3.73555869e-02F,
-9.76374596e-02F,
1.15903132e-01F,
-4.10443358e-02F,
-3.35167125e-02F,
-2.31702300e-03F,
3.94216506e-03F,
-1.67434290e-02F,
-1.10491723e-01F,
-6.98996037e-02F,
3.63110267e-02F,
1.64180085e-01F,
1.93797946e-02F,
7.96924159e-03F,
-3.10080573e-02F,
1.80092752e-02F,
-1.67974283e-03F,
3.40159959e-03F,
1.09493911e-01F,
7.28312209e-02F,
8.71915296e-02F,
-1.16319910e-01F,
-7.12257400e-02F,
-1.34214452e-02F,
-1.32123567e-02F,
-5.43936305e-02F,
-9.54342633e-03F,
-2.94361301e-02F,
-4.73987684e-02F,
-2.94742007e-02F,
1.21303394e-01F,
-1.02026165e-02F,
-5.67933358e-02F,
3.47254463e-02F,
2.24350523e-02F,
1.08306454e-02F,
2.89539131e-03F,
-8.66903365e-03F,
-7.35415369e-02F,
3.03634647e-02F,
9.25630704e-03F,
1.08970255e-02F,
4.94356044e-02F,
9.20580328e-02F,
-3.90163139e-02F,
-1.63690578e-02F,
-2.59961821e-02F,
-2.52236240e-02F,
-8.00076686e-03F,
8.38936195e-02F,
-2.60812026e-02F,
-1.51108773e-02F,
1.14389271e-01F,
-6.60146400e-02F,
-2.15972774e-02F,
-2.63454560e-02F,
-1.18041076e-02F,
-3.94275561e-02F,
1.32990882e-01F,
-9.08572152e-02F,
-2.08852049e-02F,
-6.02909401e-02F,
-3.45557779e-02F,
2.39617229e-02F,
-2.11660713e-02F,
6.18977696e-02F,
-3.78922373e-03F,
1.00037241e-02F,
-3.45448181e-02F,
-1.24423966e-01F,
-2.06105458e-03F,
1.42601170e-02F,
8.85798857e-02F,
-1.96031202e-02F,
1.83218755e-02F,
-1.96145917e-03F,
4.86140475e-02F,
2.20886711e-02F,
9.31386128e-02F,
1.19872250e-01F,
-5.37470877e-02F,
-6.86566159e-02F,
-6.52703345e-02F,
1.95797943e-02F,
-1.48715572e-02F,
1.36159258e-02F,
-1.35327009e-02F,
-3.47532369e-02F,
-2.77138106e-03F,
3.09115350e-02F,
-1.55106587e-02F,
1.41530961e-01F,
-8.12231228e-02F,
-4.75986488e-02F,
1.71744302e-02F,
-8.30708630e-03F,
5.43972198e-03F,
-2.34286785e-02F,
-4.29552011e-02F,
1.01609625e-01F,
7.71947205e-02F,
-2.67266650e-02F,
-3.91132832e-02F,
-4.17532586e-02F,
-1.91109031e-02F,
1.22319106e-02F,
2.69403402e-03F,
-2.45481990e-02F,
8.52171630e-02F,
-6.10262714e-02F,
9.96214598e-02F,
-5.11584617e-02F,
-8.32596570e-02F,
-6.94424734e-02F,
3.18229534e-02F,
3.68662067e-02F,
8.06665141e-03F,
-1.05404826e-02F
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\a63x3x15.h ===
1.84717402e-01F,
3.40806514e-01F,
3.52387637e-01F,
3.27840269e-01F,
2.94022530e-01F,
2.71878660e-01F,
2.29819268e-01F,
2.12299511e-01F,
2.08446816e-01F,
2.49861240e-01F,
2.03995317e-01F,
1.90485656e-01F,
1.75044298e-01F,
1.68576106e-01F,
1.74350679e-01F,
3.54742020e-01F,
2.92869627e-01F,
2.15735212e-01F,
3.03704113e-01F,
2.16312572e-01F,
2.21689224e-01F,
2.63572425e-01F,
2.44448155e-01F,
1.89738765e-01F,
1.73497990e-01F,
2.30950341e-01F,
2.38537252e-01F,
2.17390627e-01F,
2.15547770e-01F,
2.25236014e-01F,
1.30459234e-01F,
2.35478505e-01F,
2.68828928e-01F,
2.86229163e-01F,
3.26289564e-01F,
3.43792886e-01F,
3.29590380e-01F,
3.09929013e-01F,
2.62534291e-01F,
1.83675796e-01F,
1.85989738e-01F,
1.87788785e-01F,
1.78960055e-01F,
1.57830894e-01F,
1.70707032e-01F,
5.73700294e-02F,
1.90747410e-01F,
3.16279918e-01F,
2.79812396e-01F,
2.96108991e-01F,
2.81518787e-01F,
2.53495514e-01F,
2.33784258e-01F,
2.44936332e-01F,
2.32223541e-01F,
2.40952834e-01F,
2.57224083e-01F,
2.13715866e-01F,
2.17297629e-01F,
2.18967885e-01F,
4.14792150e-01F,
2.00342417e-01F,
2.21826985e-01F,
1.80721954e-01F,
2.60100365e-01F,
2.37876728e-01F,
1.94097236e-01F,
2.13647604e-01F,
2.30097279e-01F,
2.37534106e-01F,
2.33750135e-01F,
2.43995860e-01F,
2.44097307e-01F,
2.20072404e-01F,
2.18000069e-01F,
3.10771763e-01F,
3.76342505e-01F,
2.85463423e-01F,
2.75062859e-01F,
2.75530696e-01F,
1.83179542e-01F,
1.58181876e-01F,
2.02034488e-01F,
1.90793514e-01F,
2.48630166e-01F,
1.99876174e-01F,
2.33499438e-01F,
2.37454802e-01F,
2.07610250e-01F,
1.96496516e-01F,
2.22145885e-01F,
3.78692687e-01F,
3.11276138e-01F,
2.73120254e-01F,
2.79734373e-01F,
2.22792968e-01F,
1.97602540e-01F,
2.59870917e-01F,
3.03175479e-01F,
2.02413127e-01F,
1.81453094e-01F,
2.06108630e-01F,
1.90576375e-01F,
1.87613487e-01F,
1.81184366e-01F,
1.67840272e-01F,
3.15710753e-01F,
3.53471309e-01F,
3.59651744e-01F,
2.70677537e-01F,
1.90303728e-01F,
3.11490446e-01F,
3.19713473e-01F,
2.07833573e-01F,
1.62238404e-01F,
1.91237465e-01F,
1.88162863e-01F,
1.80189997e-01F,
1.62676439e-01F,
1.65793464e-01F,
-1.94525570e-02F,
-4.45394637e-03F,
-2.73865834e-02F,
-5.71636483e-03F,
1.10710867e-01F,
-3.79358046e-02F,
-2.92604491e-02F,
7.38304630e-02F,
-2.82320250e-02F,
-1.81471612e-02F,
-1.59565341e-02F,
-1.38867367e-02F,
-9.02322354e-04F,
1.13262190e-03F,
8.37567635e-03F,
-9.22536664e-03F,
-1.22460974e-02F,
-1.75267272e-02F,
-2.93750912e-02F,
-3.40620130e-02F,
5.16743679e-03F,
8.12971815e-02F,
7.06224069e-02F,
6.13449067e-02F,
2.13473253e-02F,
1.96403335e-03F,
-2.54062545e-02F,
-2.06980202e-02F,
-1.09798647e-02F,
-1.90733075e-02F,
2.45613774e-04F,
2.48898044e-02F,
5.10145314e-02F,
6.92568645e-02F,
3.29618505e-03F,
-6.79373816e-02F,
-5.98744228e-02F,
2.66748443e-02F,
6.44384846e-02F,
-4.37285416e-02F,
-2.40309257e-02F,
-1.78896245e-02F,
-1.82659347e-02F,
-1.91827286e-02F,
-9.40751750e-03F,
2.32813004e-02F,
3.37039120e-02F,
-1.90569945e-02F,
-5.64041175e-02F,
1.63065083e-02F,
9.01676863e-02F,
-1.78051200e-02F,
2.17485074e-02F,
-1.97278569e-03F,
-2.74954084e-02F,
-2.62666289e-02F,
1.22502120e-02F,
-7.19243148e-03F,
1.83330011e-02F,
-5.56962611e-03F,
-2.34378986e-02F,
-2.03521736e-02F,
-5.59789967e-03F,
4.83430289e-02F,
7.06324540e-03F,
-4.60822582e-02F,
-4.05710116e-02F,
-3.41578461e-02F,
4.49500158e-02F,
1.27902985e-01F,
-9.60155297e-03F,
-1.86942834e-02F,
-1.36834225e-02F,
8.50464124e-03F,
-2.37031141e-03F,
-1.97027600e-03F,
1.42854303e-02F,
1.33570451e-02F,
2.95783039e-02F,
8.11092556e-02F,
7.05183819e-02F,
-2.53097899e-02F,
-8.76124129e-02F,
-2.09023654e-02F,
-3.83802783e-03F,
-1.00155296e-02F,
-1.96857434e-02F,
-1.58492494e-02F,
-9.33961850e-03F,
-4.55287891e-03F,
-3.64974767e-05F,
-1.22787966e-03F,
-3.51123065e-02F,
-3.97544652e-02F,
-3.37380394e-02F,
5.22675253e-02F,
1.11597799e-01F,
-2.93357857e-02F,
-5.40156662e-02F,
3.86309363e-02F,
1.73454918e-02F,
-6.79080049e-03F,
1.48000559e-02F,
9.66159452e-04F,
1.71281788e-02F,
2.05696262e-02F,
4.97776419e-02F,
7.20802769e-02F,
1.80983040e-02F,
-5.63484356e-02F,
-3.28826420e-02F,
2.77184267e-02F,
-4.52849343e-02F,
-9.50421020e-03F,
-3.62563767e-02F,
1.21239359e-02F,
-1.67356748e-02F,
-9.66826221e-04F,
6.56279037e-04F,
6.27654837e-03F,
-3.35048251e-02F,
-5.65256625e-02F,
-9.08670295e-03F,
7.65710622e-02F,
7.22836778e-02F,
-2.15916056e-03F,
-3.74092460e-02F,
-8.47453810e-03F,
-2.34273337e-02F,
1.56900063e-02F,
1.25306305e-02F,
-7.82601442e-03F,
-7.76338764e-03F,
1.01878783e-02F,
-5.43031469e-03F,
-1.74801424e-02F,
-1.59315523e-02F,
2.11345661e-03F,
-1.92240551e-02F,
-1.12798121e-02F,
4.35690619e-02F,
1.51021751e-02F,
2.84113549e-02F,
3.35341319e-02F,
8.43006000e-02F,
-2.44643129e-02F,
-2.95961872e-02F,
-2.24412456e-02F,
-1.69968959e-02F,
-9.15579312e-03F,
-2.48940475e-03F,
1.72106642e-02F,
6.28819391e-02F,
6.64112419e-02F,
-5.73306391e-03F,
-5.06824218e-02F,
-1.52250994e-02F,
6.24862909e-02F,
-5.25555387e-02F,
-7.91055057e-03F,
-4.23757322e-02F,
-1.94291119e-02F,
-1.96233988e-02F,
-1.37437470e-02F,
-1.18351998e-02F,
7.33276037e-03F,
-1.61411986e-02F,
-3.48644815e-02F,
-6.17157705e-02F,
-3.91143374e-02F,
2.83514038e-02F,
1.17000751e-03F,
5.69216274e-02F,
-3.19058895e-02F,
7.68646365e-03F,
9.82592404e-02F,
-6.45290315e-03F,
8.72736424e-03F,
9.38908476e-03F,
1.21614523e-02F,
-1.71975009e-02F,
-3.74445021e-02F,
-1.11546665e-02F,
7.07958173e-03F,
1.90184340e-02F,
4.37329803e-03F,
-3.49702463e-02F,
-2.13570818e-02F,
1.42223850e-01F,
-2.62612128e-03F,
-1.87928807e-02F,
-1.33845294e-02F,
-1.40991211e-02F,
-1.12347025e-03F,
-6.28146017e-03F,
1.49067976e-02F,
4.40123565e-02F,
2.26095673e-02F,
-4.20384668e-03F,
4.54299115e-02F,
3.39346342e-02F,
-2.91829389e-02F,
-3.83576863e-02F,
-7.76823657e-03F,
-5.72903454e-02F,
1.27186337e-02F,
-1.47351082e-02F,
1.03348144e-03F,
-4.96584410e-03F,
-1.01884566e-02F,
5.17029092e-02F,
-6.32309308e-03F,
-4.03143242e-02F,
-1.53531311e-02F,
4.05532047e-02F,
-5.33285886e-02F,
8.64542797e-02F,
-3.55806984e-02F,
-3.86151187e-02F,
1.84443919e-03F,
-2.01245751e-02F,
3.53629305e-03F,
2.50856322e-03F,
2.37270277e-02F,
-2.31725839e-03F,
1.99360158e-02F,
7.93594420e-02F,
2.29198784e-02F,
-7.27792159e-02F,
-7.56699592e-02F,
-4.93187793e-02F,
2.25544255e-02F,
-2.74695996e-02F,
3.21010724e-02F,
1.13797598e-02F,
-2.69018044e-03F,
8.22527055e-03F,
1.68767702e-02F,
-4.73085558e-03F,
2.20088232e-02F
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\a73x3x15.h ===
1.70344844e-01F,
3.34560603e-01F,
3.61444950e-01F,
3.27957213e-01F,
2.89794207e-01F,
2.60746688e-01F,
2.21343189e-01F,
2.18167350e-01F,
2.30449125e-01F,
2.54724354e-01F,
2.27539062e-01F,
1.99218616e-01F,
1.63508266e-01F,
1.59000188e-01F,
1.66478366e-01F,
3.63415360e-01F,
2.98318803e-01F,
2.34911755e-01F,
3.06315303e-01F,
2.45908082e-01F,
2.28040189e-01F,
2.60006607e-01F,
2.47669354e-01F,
1.79305226e-01F,
1.66048735e-01F,
2.13816509e-01F,
2.24752948e-01F,
2.26281911e-01F,
1.94874734e-01F,
2.19851211e-01F,
1.22694649e-01F,
2.38416284e-01F,
2.70604819e-01F,
2.84171373e-01F,
3.21817130e-01F,
3.41988236e-01F,
3.18559945e-01F,
3.05564463e-01F,
2.79876560e-01F,
1.90110162e-01F,
2.02335954e-01F,
1.92902014e-01F,
1.71622336e-01F,
1.47582784e-01F,
1.64898977e-01F,
5.92169799e-02F,
2.00161546e-01F,
3.22413474e-01F,
2.87556767e-01F,
2.65817642e-01F,
2.57988662e-01F,
2.73859829e-01F,
2.49248639e-01F,
2.52789974e-01F,
2.55782098e-01F,
2.62461662e-01F,
2.53094524e-01F,
1.98937073e-01F,
1.94002330e-01F,
2.10371107e-01F,
3.72219205e-01F,
2.37919465e-01F,
2.32761964e-01F,
1.70543671e-01F,
2.38539994e-01F,
2.37489626e-01F,
2.29697853e-01F,
2.22534314e-01F,
2.22476304e-01F,
2.35084906e-01F,
2.16919705e-01F,
2.67277122e-01F,
2.40673542e-01F,
2.54769385e-01F,
2.14850068e-01F,
3.00280809e-01F,
3.80482614e-01F,
2.92944551e-01F,
2.76321113e-01F,
2.78211653e-01F,
1.68762833e-01F,
1.64786220e-01F,
2.05801576e-01F,
1.97907954e-01F,
2.63964891e-01F,
1.92524329e-01F,
2.26055369e-01F,
2.26784110e-01F,
2.17913106e-01F,
1.80524871e-01F,
2.60667890e-01F,
3.73373032e-01F,
2.94675946e-01F,
2.72607982e-01F,
2.94476867e-01F,
2.33931854e-01F,
1.95762351e-01F,
2.50534356e-01F,
2.80907065e-01F,
1.73545241e-01F,
2.29006439e-01F,
2.06367835e-01F,
1.82917356e-01F,
1.76008224e-01F,
1.87895238e-01F,
1.68379828e-01F,
3.15596402e-01F,
3.44761789e-01F,
3.36914539e-01F,
2.74309248e-01F,
2.09318116e-01F,
3.00820857e-01F,
3.22533667e-01F,
2.12873980e-01F,
1.74078703e-01F,
2.29560509e-01F,
1.85712546e-01F,
1.74713075e-01F,
1.59161910e-01F,
1.62676483e-01F,
-1.87458331e-03F,
2.68901885e-02F,
-1.52111193e-02F,
-3.07888426e-02F,
1.19943932e-01F,
-4.88866456e-02F,
-4.74255271e-02F,
3.09918895e-02F,
-4.33175862e-02F,
-2.75604166e-02F,
-2.26588789e-02F,
3.72472964e-03F,
2.38411278e-02F,
1.11701582e-02F,
6.30240329e-03F,
-6.65202411e-03F,
-5.37199154e-03F,
-2.17081551e-02F,
-2.53412183e-02F,
-2.69719400e-02F,
1.24393012e-02F,
8.42201784e-02F,
6.20276257e-02F,
5.71736023e-02F,
-5.89570543e-03F,
-2.64689908e-04F,
-2.01490764e-02F,
-2.28761565e-02F,
-1.13556692e-02F,
-1.56028997e-02F,
-8.96022562e-03F,
3.44636152e-03F,
3.14873420e-02F,
5.71348593e-02F,
1.18089793e-02F,
-6.76488429e-02F,
-5.46971485e-02F,
3.74004394e-02F,
7.40871280e-02F,
-1.86060723e-02F,
-3.75995599e-02F,
-1.86243057e-02F,
-1.28101213e-02F,
-7.46739656e-03F,
-3.63991456e-03F,
3.00247893e-02F,
5.35153262e-02F,
-3.07363030e-02F,
-6.21569864e-02F,
2.74140475e-04F,
8.48244503e-02F,
-9.63567197e-03F,
2.18440164e-02F,
-1.18932687e-02F,
-4.41159820e-03F,
-3.83163802e-02F,
3.89851164e-03F,
5.61774243e-03F,
1.42947976e-02F,
-2.82706716e-03F,
-1.93106886e-02F,
-1.96863916e-02F,
-7.92739261e-03F,
3.71345803e-02F,
1.44356936e-02F,
-4.37667929e-02F,
-4.26834673e-02F,
-2.55318545e-02F,
2.69609317e-02F,
1.10119365e-01F,
4.19174470e-02F,
-2.53107008e-02F,
-1.34388115e-02F,
-4.28602798e-03F,
-2.69475020e-03F,
-7.03014340e-03F,
8.83298460e-03F,
3.09996717e-02F,
2.25242153e-02F,
4.53753509e-02F,
7.42649511e-02F,
-1.48787526e-02F,
-5.38050644e-02F,
2.38381373e-03F,
1.02313459e-02F,
-1.92807857e-02F,
-2.49864329e-02F,
-2.57386230e-02F,
-1.66529398e-02F,
7.43909623e-04F,
1.03611853e-02F,
1.48138497e-02F,
-1.93741526e-02F,
-5.26657961e-02F,
-3.30249183e-02F,
3.01151332e-02F,
9.78717059e-02F,
-4.08684053e-02F,
-3.93952169e-02F,
5.90068661e-02F,
2.10270640e-02F,
-1.18567664e-02F,
6.47058384e-03F,
-3.41171806e-04F,
1.13278832e-02F,
-8.98684282e-03F,
1.30353058e-02F,
4.67592478e-02F,
6.56619519e-02F,
-2.38345079e-02F,
-1.62304398e-02F,
3.33437952e-03F,
-2.99464278e-02F,
-9.65913001e-04F,
-5.19624352e-02F,
5.19746356e-02F,
-1.60378963e-02F,
-1.92710571e-02F,
8.09554663e-03F,
-1.04380231e-02F,
-3.45876440e-02F,
-7.20871985e-02F,
-2.27255486e-02F,
5.89902103e-02F,
7.43158236e-02F,
1.32932412e-02F,
-1.81466322e-02F,
1.26904640e-02F,
-1.80031303e-02F,
3.52403596e-02F,
8.79718084e-03F,
-1.75373685e-02F,
-9.96784493e-03F,
1.61178771e-03F,
-9.29846801e-03F,
-4.31551179e-03F,
-1.05321668e-02F,
-6.50447095e-04F,
-2.22371966e-02F,
-7.74478726e-03F,
1.39205605e-02F,
1.75043307e-02F,
3.39779444e-02F,
3.03971022e-02F,
7.53801465e-02F,
-5.40740183e-03F,
-3.00907046e-02F,
-2.91203149e-02F,
-9.60202143e-03F,
-1.13480594e-02F,
-2.62624980e-03F,
1.55012123e-02F,
5.25765195e-02F,
2.49849446e-02F,
-2.85747647e-03F,
-4.27387431e-02F,
-2.06717458e-02F,
9.78982449e-02F,
-4.63209972e-02F,
-3.15374136e-02F,
-6.96788952e-02F,
-2.30248901e-03F,
-5.18195890e-03F,
6.97354181e-03F,
-1.02419881e-02F,
-2.20353901e-03F,
-1.30670657e-02F,
-3.20804976e-02F,
-4.02426384e-02F,
-3.21113574e-03F,
3.05297468e-02F,
-1.28094829e-03F,
3.28150131e-02F,
-1.52802952e-02F,
-2.18769955e-03F,
1.08091980e-01F,
-1.79106165e-02F,
1.71004201e-03F,
-1.03425048e-02F,
-4.87116980e-04F,
-2.28616851e-03F,
-7.64699327e-03F,
-1.50677422e-02F,
-2.06612572e-02F,
1.76763646e-02F,
1.83553454e-02F,
-4.78672460e-02F,
-3.45343165e-02F,
1.36513337e-01F,
4.78269672e-03F,
-3.84045392e-02F,
-5.29329199e-03F,
-5.96355600e-03F,
-3.22002266e-03F,
-9.48661380e-03F,
9.85005219e-03F,
4.35344614e-02F,
1.98782459e-02F,
2.16094870e-03F,
4.76090573e-02F,
3.90785038e-02F,
-5.35592288e-02F,
-6.70285746e-02F,
-2.78344005e-02F,
-3.31536159e-02F,
2.06859000e-02F,
2.31415383e-03F,
-2.62308121e-03F,
3.14419274e-03F,
5.97497122e-03F,
2.01486126e-02F,
-3.24813649e-04F,
4.49863262e-03F,
3.04201804e-02F,
-9.77832451e-03F,
-5.33106215e-02F,
9.28613767e-02F,
-4.21362482e-02F,
-2.93207113e-02F,
-1.35558005e-03F,
-6.19968511e-02F,
-3.63769359e-03F,
1.41650625e-02F,
6.99998206e-03F,
1.58886332e-02F,
3.85131389e-02F,
6.84820935e-02F,
1.68434773e-02F,
-5.58976009e-02F,
-8.38234201e-02F,
-5.69230132e-02F,
1.29134143e-02F,
-5.24590584e-03F,
2.80583464e-02F,
7.96572212e-03F,
2.84663122e-02F,
-4.65510972e-03F,
1.45173753e-02F,
4.69144434e-03F,
1.02769416e-02F
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\a33x3x10.h ===
4.16277170e-01F,
2.90147215e-01F,
2.14418039e-01F,
3.71287316e-01F,
2.40557954e-01F,
3.11073959e-01F,
2.80519664e-01F,
2.78759569e-01F,
2.84029037e-01F,
2.70691335e-01F,
4.41108137e-01F,
2.52210677e-01F,
2.75959581e-01F,
2.46846691e-01F,
3.85197610e-01F,
2.44985074e-01F,
2.98590511e-01F,
2.53135890e-01F,
2.75128990e-01F,
2.61086017e-01F,
2.69994318e-01F,
3.68383437e-01F,
4.57130671e-01F,
3.61595750e-01F,
2.59147525e-01F,
2.36953080e-01F,
2.33945414e-01F,
2.22577870e-01F,
2.29102299e-01F,
2.58069158e-01F,
2.02299640e-01F,
2.95698792e-01F,
4.43366408e-01F,
2.68418103e-01F,
3.77511442e-01F,
2.70813465e-01F,
2.80628860e-01F,
2.70146698e-01F,
2.54249483e-01F,
2.78282017e-01F,
3.08218777e-01F,
3.60356331e-01F,
3.40749383e-01F,
3.50032866e-01F,
2.88940966e-01F,
3.00297737e-01F,
2.89782941e-01F,
2.45380223e-01F,
2.23643988e-01F,
2.72389740e-01F,
2.71219850e-01F,
3.13882560e-01F,
3.43925655e-01F,
2.50946730e-01F,
2.68997461e-01F,
3.35498750e-01F,
2.88288057e-01F,
2.85639077e-01F,
3.17810893e-01F,
3.22516680e-01F,
3.27032208e-01F,
2.79526979e-01F,
2.08894759e-01F,
2.70977944e-01F,
3.46015990e-01F,
2.63791353e-01F,
3.83280247e-01F,
3.04247171e-01F,
2.78315008e-01F,
3.19047153e-01F,
2.69040644e-01F,
4.38337743e-01F,
2.59017885e-01F,
3.05090934e-01F,
2.60332018e-01F,
2.69447953e-01F,
2.56846160e-01F,
3.11990470e-01F,
2.53688544e-01F,
3.20499241e-01F,
1.87706444e-02F,
-8.56594648e-03F,
-2.87401732e-02F,
8.42267498e-02F,
6.73302040e-02F,
-3.24385501e-02F,
-3.29178907e-02F,
-2.57872307e-04F,
6.10448001e-03F,
-1.21193063e-02F,
1.41533449e-01F,
-8.06545019e-02F,
-3.91332619e-02F,
2.34408900e-02F,
1.15471054e-02F,
-3.32205631e-02F,
1.40573159e-02F,
-4.09472585e-02F,
-2.14386880e-02F,
4.23607305e-02F,
6.04846515e-02F,
8.49858448e-02F,
4.45988588e-02F,
2.03697514e-02F,
-3.85056511e-02F,
-1.93085393e-03F,
-5.20185530e-02F,
-2.57084221e-02F,
-2.98596900e-02F,
-3.42664719e-02F,
-1.19728237e-01F,
9.59590971e-02F,
-7.73599148e-02F,
-4.39313427e-02F,
5.40262945e-02F,
4.69172411e-02F,
2.02008504e-02F,
-3.15519888e-03F,
2.81982906e-02F,
1.24076474e-02F,
7.25892633e-02F,
4.59481664e-02F,
-2.62705050e-02F,
-1.14361979e-01F,
9.96008143e-02F,
-4.31930684e-02F,
-4.49438542e-02F,
-8.84304754e-03F,
2.10706200e-02F,
-1.50128012e-03F,
-9.42183360e-02F,
-1.06360719e-01F,
3.86880827e-03F,
1.66939959e-01F,
-7.90725183e-03F,
2.20118258e-02F,
-1.04555655e-02F,
2.76080854e-02F,
7.83674186e-05F,
8.01188126e-03F,
1.04761966e-01F,
9.04646367e-02F,
9.02323872e-02F,
-1.24667577e-01F,
-7.14329183e-02F,
-4.73398119e-02F,
-1.91800203e-02F,
-3.44452113e-02F,
-7.63286324e-03F,
-2.56591961e-02F,
-5.41309975e-02F,
-5.36005432e-03F,
1.43047154e-01F,
-2.17027869e-02F,
-6.11460209e-02F,
1.31459944e-02F,
2.35430780e-03F,
2.97062821e-03F,
8.44830181e-03F,
-2.88706250e-03F,
-6.02382571e-02F,
3.92102748e-02F,
1.07177692e-02F,
-3.23330984e-02F,
2.83870082e-02F,
4.35208976e-02F,
-4.02492061e-02F,
3.68697457e-02F,
3.31373629e-03F,
7.63771497e-03F,
1.24360193e-02F,
8.33319798e-02F,
-5.13321608e-02F,
-9.55322757e-04F,
9.68089849e-02F,
-5.54797053e-02F,
-1.35643948e-02F,
-1.84800234e-02F,
-2.18380969e-02F,
-4.28947918e-02F,
1.66224122e-01F,
-1.08915061e-01F,
-3.17245871e-02F,
-5.86185791e-02F,
-2.87986435e-02F,
5.77696227e-02F,
-3.70688997e-02F,
5.47997234e-03F,
1.40124392e-02F,
3.09410226e-03F,
-4.84147854e-02F,
-8.69552568e-02F,
-1.00951269e-02F,
3.79704796e-02F,
6.50605932e-02F,
-1.75940152e-02F,
5.21821231e-02F,
-1.11862747e-02F,
4.28010263e-02F,
9.43170115e-03F,
7.36295357e-02F,
1.19515039e-01F,
-4.91258129e-02F,
-8.48621055e-02F,
-6.57827184e-02F,
3.16426554e-03F,
-3.72991269e-03F,
9.81795508e-03F,
5.38407825e-03F,
-1.50795057e-02F,
-4.17414233e-02F,
2.61329189e-02F,
-3.37328948e-03F,
1.16921782e-01F,
-7.08701983e-02F,
-3.95388305e-02F,
6.04691450e-03F,
-3.19279643e-04F,
2.53804047e-02F,
-7.11752241e-03F,
-4.52697165e-02F,
9.42852348e-02F,
1.06905349e-01F,
1.33264363e-02F,
-5.42048737e-02F,
-5.00468127e-02F,
-1.53343631e-02F,
-1.92655181e-03F,
-3.26896869e-02F,
-4.13447767e-02F,
9.13800672e-02F,
-8.41463953e-02F,
7.92012289e-02F,
-7.27162361e-02F,
-4.47877869e-02F,
-3.43874507e-02F,
1.99787617e-02F,
5.73480688e-02F,
2.05702707e-03F,
-2.39353254e-02F
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\a53x3x10.h ===
4.07213360e-01F,
2.90653765e-01F,
2.15348631e-01F,
3.64818633e-01F,
2.35381067e-01F,
3.17883998e-01F,
2.89227009e-01F,
3.03329855e-01F,
2.71074295e-01F,
2.45589316e-01F,
4.09005433e-01F,
2.70025790e-01F,
2.78094858e-01F,
2.19038635e-01F,
4.20632064e-01F,
2.45717019e-01F,
2.76548028e-01F,
2.83135474e-01F,
2.45095164e-01F,
2.81537265e-01F,
3.01436096e-01F,
3.74863446e-01F,
4.26170707e-01F,
3.28597337e-01F,
2.64333993e-01F,
2.22606391e-01F,
2.36701846e-01F,
2.61955887e-01F,
2.35265151e-01F,
2.53906190e-01F,
2.35435277e-01F,
3.18877846e-01F,
4.27536964e-01F,
3.00381422e-01F,
3.79899561e-01F,
3.09390843e-01F,
2.40981713e-01F,
2.22768560e-01F,
2.27151453e-01F,
2.53179818e-01F,
2.97153234e-01F,
3.21979403e-01F,
3.33785683e-01F,
3.98285687e-01F,
3.02360296e-01F,
3.27469528e-01F,
2.78824300e-01F,
2.23007753e-01F,
2.28196159e-01F,
2.52875865e-01F,
2.70521045e-01F,
3.52207571e-01F,
3.72708052e-01F,
2.53338903e-01F,
2.35892236e-01F,
4.16550636e-01F,
2.66326934e-01F,
2.50339001e-01F,
2.50281155e-01F,
2.65543818e-01F,
2.88788170e-01F,
2.76771426e-01F,
2.60713398e-01F,
2.70407110e-01F,
3.08225036e-01F,
2.96739221e-01F,
4.11494315e-01F,
2.95692652e-01F,
2.71076709e-01F,
2.89457560e-01F,
3.33045453e-01F,
3.89069945e-01F,
2.69333959e-01F,
2.68120557e-01F,
3.26631963e-01F,
2.12824732e-01F,
2.91770011e-01F,
2.39285797e-01F,
2.88194388e-01F,
3.21729720e-01F,
3.02212872e-02F,
-1.21509535e-02F,
-2.02144962e-02F,
8.22136104e-02F,
8.48999396e-02F,
-1.67599972e-02F,
-2.06252597e-02F,
-3.05936653e-02F,
-1.42364232e-02F,
-3.47245671e-02F,
1.43937334e-01F,
-5.57336025e-02F,
-3.70910317e-02F,
-3.80120277e-02F,
-3.83390822e-02F,
-8.81526910e-04F,
-1.35129206e-02F,
-1.60867721e-02F,
2.34183599e-03F,
7.63268024e-02F,
6.58787861e-02F,
7.31158704e-02F,
4.66835350e-02F,
3.04260142e-02F,
-4.36794758e-02F,
2.02013757e-02F,
-7.04365671e-02F,
-2.66831014e-02F,
-4.14010473e-02F,
-3.83055843e-02F,
-1.27094507e-01F,
1.13779902e-01F,
-4.87018228e-02F,
-9.56575107e-03F,
-1.86012115e-03F,
1.95082370e-03F,
-3.47802253e-03F,
3.86264436e-02F,
3.03362366e-02F,
2.06914041e-02F,
8.84314254e-02F,
4.72505949e-02F,
-3.79652530e-02F,
-7.04713985e-02F,
1.14655375e-01F,
-5.19104674e-02F,
-3.78862098e-02F,
-1.95191987e-02F,
2.03157240e-03F,
-3.03482432e-02F,
-8.58645067e-02F,
-7.41137788e-02F,
1.12333586e-02F,
1.54623136e-01F,
1.25137223e-02F,
7.67540187e-03F,
-1.05295209e-02F,
1.15611339e-02F,
4.27960930e-03F,
4.10651229e-03F,
9.94004160e-02F,
6.91464916e-02F,
8.52277800e-02F,
-1.16439402e-01F,
-4.01562192e-02F,
-4.65882942e-02F,
-2.51861336e-03F,
-3.71447690e-02F,
-1.56595185e-02F,
-2.39736196e-02F,
-4.96380143e-02F,
-4.30051563e-03F,
1.53277159e-01F,
-1.13389865e-02F,
-4.19912152e-02F,
4.10279259e-02F,
-3.03103793e-02F,
-1.70823801e-02F,
-4.13471600e-03F,
-2.73296889e-02F,
-6.84361905e-02F,
3.23853791e-02F,
-2.92226505e-02F,
8.49419180e-03F,
4.13931683e-02F,
1.34801194e-01F,
-5.31447791e-02F,
-1.33497920e-02F,
-3.09059191e-02F,
-1.72033906e-02F,
-1.94698218e-02F,
6.69604316e-02F,
6.58107316e-03F,
-2.69462280e-02F,
1.29644454e-01F,
-5.88661246e-02F,
-3.09705809e-02F,
-2.84376033e-02F,
-1.76135376e-02F,
-3.81091833e-02F,
1.39420882e-01F,
-5.62289245e-02F,
-2.30920780e-02F,
-7.27325305e-02F,
-5.08646294e-02F,
6.14053644e-02F,
-1.64504778e-02F,
7.99515098e-03F,
2.11493634e-02F,
-3.97994649e-03F,
-3.22456844e-02F,
-1.30979806e-01F,
1.97494254e-02F,
-2.57096570e-02F,
6.46486580e-02F,
-3.37674469e-02F,
1.62796918e-02F,
4.94784750e-02F,
6.54012933e-02F,
3.88313718e-02F,
8.43234062e-02F,
1.27031952e-01F,
-7.85902515e-02F,
-2.61708777e-02F,
-8.34559277e-02F,
9.09368228e-03F,
2.15839059e-03F,
8.26303009e-03F,
-2.12797094e-02F,
-2.59700865e-02F,
-1.53790647e-02F,
2.40642782e-02F,
6.53315568e-03F,
1.40744776e-01F,
-4.94289435e-02F,
-5.41853607e-02F,
-2.50081532e-03F,
-5.16669732e-03F,
-1.11248791e-02F,
-1.63453389e-02F,
-3.08200736e-02F,
1.01334117e-01F,
1.01159401e-01F,
-2.24670246e-02F,
-3.02825850e-02F,
-6.83467165e-02F,
-1.24375606e-02F,
1.38202962e-02F,
-2.32300628e-02F,
-2.98041478e-02F,
1.21977486e-01F,
-6.02197014e-02F,
6.48660883e-02F,
-5.86696342e-02F,
-8.53882730e-02F,
-8.76641423e-02F,
4.11712527e-02F,
4.43437621e-02F,
3.66585888e-02F,
-3.55496109e-02F
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\a83x3x15.h ===
1.70374259e-01F,
3.28502983e-01F,
3.41479719e-01F,
3.29235375e-01F,
2.93775678e-01F,
2.44977042e-01F,
2.12659732e-01F,
2.20778197e-01F,
2.43938059e-01F,
2.65259355e-01F,
2.23731741e-01F,
2.49121696e-01F,
1.56390220e-01F,
1.49809271e-01F,
1.54528201e-01F,
3.67978245e-01F,
3.14492851e-01F,
2.16468990e-01F,
2.87867427e-01F,
2.73448139e-01F,
2.71764040e-01F,
2.47092053e-01F,
2.66876698e-01F,
1.78488016e-01F,
1.68863624e-01F,
2.05016151e-01F,
2.00373471e-01F,
2.03429267e-01F,
1.74015731e-01F,
2.28144675e-01F,
1.12306409e-01F,
2.03745797e-01F,
2.49885157e-01F,
2.96002597e-01F,
3.34202021e-01F,
3.10452312e-01F,
3.02258790e-01F,
3.10749173e-01F,
2.69734859e-01F,
2.18880817e-01F,
2.54135102e-01F,
2.26231009e-01F,
1.62097439e-01F,
1.42859176e-01F,
1.59831703e-01F,
5.86199872e-02F,
1.93286806e-01F,
3.56502295e-01F,
3.09195161e-01F,
2.57333636e-01F,
2.84277886e-01F,
2.66879052e-01F,
2.29661584e-01F,
2.42858216e-01F,
2.27103367e-01F,
2.57283598e-01F,
2.91283488e-01F,
1.81695417e-01F,
1.86737731e-01F,
2.04811484e-01F,
3.78083974e-01F,
2.71284133e-01F,
2.53597945e-01F,
2.53577411e-01F,
2.47037694e-01F,
1.99327484e-01F,
2.40987554e-01F,
2.07343251e-01F,
2.09415302e-01F,
2.18063623e-01F,
1.81123793e-01F,
2.97063917e-01F,
2.21625075e-01F,
2.21710458e-01F,
2.05404952e-01F,
2.92694777e-01F,
3.68902862e-01F,
2.81726480e-01F,
2.98164666e-01F,
2.89182693e-01F,
1.68280199e-01F,
2.13346377e-01F,
2.10009530e-01F,
1.95585757e-01F,
2.70146042e-01F,
1.81541756e-01F,
2.32085943e-01F,
2.09438637e-01F,
1.99010417e-01F,
1.79653212e-01F,
2.63894945e-01F,
3.73422831e-01F,
3.01035553e-01F,
2.36514732e-01F,
2.64916867e-01F,
2.42614672e-01F,
2.06924036e-01F,
2.76266783e-01F,
2.67255157e-01F,
1.85244486e-01F,
2.30924934e-01F,
2.24292561e-01F,
1.94214001e-01F,
1.87086701e-01F,
1.75263584e-01F,
1.70610696e-01F,
3.16299409e-01F,
3.41643214e-01F,
3.24289083e-01F,
2.75680333e-01F,
2.26913020e-01F,
2.82730252e-01F,
3.08733076e-01F,
2.30474144e-01F,
1.79052502e-01F,
2.43866146e-01F,
2.48279780e-01F,
1.49337560e-01F,
1.48569182e-01F,
1.49805740e-01F,
-1.71345882e-02F,
3.55055556e-02F,
-3.09694447e-02F,
-5.30074760e-02F,
1.11408539e-01F,
-4.89854515e-02F,
-5.09355962e-02F,
-1.61567945e-02F,
-9.89894103e-03F,
7.67377391e-03F,
1.62452124e-02F,
-1.69067606e-02F,
1.80533398e-02F,
2.26235166e-02F,
2.29193922e-02F,
-2.12325305e-02F,
-1.69415809e-02F,
-1.96421370e-02F,
-1.81767102e-02F,
-8.86039063e-03F,
3.65196653e-02F,
7.26803020e-02F,
3.95319909e-02F,
4.89264727e-02F,
-1.90852266e-02F,
-2.65894923e-02F,
2.80684475e-02F,
-2.29577925e-02F,
-2.33039563e-03F,
-1.00445710e-02F,
-1.97866019e-02F,
2.83224112e-03F,
1.75844114e-02F,
7.94055611e-02F,
3.39173041e-02F,
-5.59014753e-02F,
-2.04862747e-02F,
3.29803564e-02F,
1.16481846e-02F,
-3.27491835e-02F,
-7.75740743e-02F,
1.16323456e-02F,
-5.84559143e-03F,
-6.99598528e-03F,
-1.55041541e-03F,
2.40072552e-02F,
4.66861390e-02F,
-3.14102247e-02F,
-5.85997738e-02F,
1.47816073e-02F,
7.53666908e-02F,
-5.48472814e-03F,
5.17211156e-03F,
-1.05909957e-02F,
2.60256007e-02F,
-4.13149446e-02F,
-1.03903748e-02F,
1.06467605e-02F,
9.81579162e-03F,
2.69232830e-03F,
-1.68866813e-02F,
-4.55881981e-03F,
5.43360412e-03F,
1.34379510e-02F,
-2.43640393e-02F,
-3.93809788e-02F,
-2.98639685e-02F,
9.72232595e-03F,
5.11329398e-02F,
1.01996854e-01F,
1.70031786e-02F,
-9.22827888e-03F,
-1.97674409e-02F,
-1.06125290e-03F,
-1.35305775e-02F,
-1.12931933e-02F,
5.69301331e-03F,
2.04813015e-02F,
2.30347738e-02F,
2.71377899e-02F,
7.25397393e-02F,
7.06786942e-03F,
-3.96314487e-02F,
2.26317588e-02F,
-5.96695719e-03F,
-1.16384833e-03F,
-5.93568012e-02F,
-1.23454425e-02F,
-1.59402303e-02F,
-2.10035651e-04F,
-7.59680802e-03F,
-3.28466832e-03F,
-1.57196838e-02F,
-3.84338945e-02F,
-2.48602647e-02F,
5.30163758e-02F,
7.58134872e-02F,
-2.33919937e-02F,
-2.56389230e-02F,
3.66910174e-02F,
7.19030946e-02F,
-1.20317526e-02F,
-1.75830554e-02F,
-6.48135319e-03F,
1.49708078e-03F,
3.64427408e-03F,
3.78575251e-02F,
6.83509931e-02F,
6.17217496e-02F,
-2.56061312e-02F,
-7.77607709e-02F,
-3.22882272e-02F,
-2.26028841e-02F,
-4.82623000e-03F,
-1.38550932e-02F,
5.39673157e-02F,
-5.82883768e-02F,
-6.88609481e-03F,
7.39443442e-03F,
-2.89584137e-03F,
-2.27817204e-02F,
-5.45839444e-02F,
-9.28796642e-03F,
4.00166176e-02F,
6.51390254e-02F,
2.73257997e-02F,
-5.25065549e-02F,
-2.56291274e-02F,
-1.32020342e-03F,
5.23550808e-02F,
1.63729843e-02F,
-2.70784497e-02F,
-3.65199475e-03F,
9.45392251e-03F,
-9.04714968e-03F,
-3.37755401e-03F,
-1.78481732e-02F,
6.05892995e-03F,
-1.48982638e-02F,
-1.00663174e-02F,
-5.97746484e-03F,
2.24464294e-02F,
2.28876956e-02F,
2.96447910e-02F,
8.62905756e-02F,
-1.02953902e-02F,
-6.52433261e-02F,
-7.13021960e-03F,
-1.10994922e-02F,
-7.09786313e-03F,
5.76214306e-03F,
8.50186870e-03F,
2.74795331e-02F,
1.29187051e-02F,
1.75765716e-02F,
-3.19999680e-02F,
-1.44167086e-02F,
9.77230072e-02F,
-3.49945277e-02F,
-2.22894903e-02F,
-3.69172990e-02F,
-3.18705179e-02F,
1.81883830e-03F,
7.55755370e-03F,
-1.07458774e-02F,
-1.91373099e-03F,
-1.84386112e-02F,
-1.98847596e-02F,
-1.42014297e-02F,
7.75063410e-04F,
-4.31573344e-03F,
-7.99073256e-04F,
2.55435072e-02F,
2.29542609e-02F,
-3.46165267e-03F,
1.00099124e-01F,
-9.95632634e-03F,
-1.82920024e-02F,
-1.06775276e-02F,
-9.00197215e-03F,
-2.80709076e-03F,
8.40161927e-03F,
9.93666705e-04F,
-1.53848892e-02F,
1.45685356e-02F,
2.41661910e-02F,
-5.76975159e-02F,
-2.23961119e-02F,
1.05142131e-01F,
-5.87103830e-04F,
-3.88751961e-02F,
-1.89336960e-03F,
-5.67601016e-03F,
-9.44146514e-03F,
5.61203575e-04F,
-3.81728132e-05F,
3.55931409e-02F,
-2.37827213e-03F,
1.48260966e-02F,
2.65449341e-02F,
1.01458980e-02F,
-5.15286326e-02F,
-4.28464636e-02F,
-4.67912219e-02F,
-4.62331735e-02F,
1.37621760e-02F,
6.41542003e-02F,
-4.34255740e-03F,
5.53678814e-03F,
-7.45802827e-05F,
-1.13308495e-02F,
-2.34627984e-02F,
3.12294881e-03F,
2.71827169e-02F,
5.76793507e-04F,
1.37022492e-02F,
9.46652070e-02F,
-2.12657433e-02F,
-3.37060206e-02F,
-1.61694363e-02F,
-2.12249160e-02F,
6.00139285e-03F,
-4.16795351e-03F,
-1.56662543e-03F,
5.42882504e-03F,
2.74317693e-02F,
5.73723428e-02F,
8.57586600e-03F,
-7.61353076e-02F,
-9.23753157e-02F,
-3.30781452e-02F,
5.14926538e-02F,
9.79770068e-03F,
1.50415162e-02F,
1.56878084e-02F,
3.13225947e-03F,
-9.43314750e-04F,
1.46091068e-02F,
8.35679285e-03F,
1.85501296e-02F
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\a93x3x15.h ===
1.64373741e-01F,
3.12299013e-01F,
3.38496774e-01F,
3.24166924e-01F,
2.94580579e-01F,
2.33509004e-01F,
2.16330871e-01F,
2.35524461e-01F,
2.49921158e-01F,
2.60575533e-01F,
2.23690957e-01F,
2.89156199e-01F,
1.81547120e-01F,
1.33709222e-01F,
1.44838348e-01F,
3.63716334e-01F,
2.98699647e-01F,
2.34864965e-01F,
2.83168703e-01F,
2.78590530e-01F,
2.74035931e-01F,
2.53787875e-01F,
2.30868533e-01F,
1.82709098e-01F,
1.65759638e-01F,
2.16709629e-01F,
2.02982545e-01F,
2.26948231e-01F,
1.58053577e-01F,
2.47167051e-01F,
1.06113851e-01F,
2.00000897e-01F,
2.59002805e-01F,
2.89425015e-01F,
3.16047937e-01F,
3.00652862e-01F,
3.03833783e-01F,
2.97763109e-01F,
2.51175940e-01F,
2.26090148e-01F,
2.61182278e-01F,
2.77909666e-01F,
1.96300641e-01F,
1.35671139e-01F,
1.51066974e-01F,
5.08772098e-02F,
2.16007411e-01F,
3.98721039e-01F,
2.96918690e-01F,
2.58394033e-01F,
2.68593431e-01F,
2.70668894e-01F,
2.39672437e-01F,
2.35205427e-01F,
2.18604654e-01F,
2.43455619e-01F,
2.66036391e-01F,
1.82226509e-01F,
1.88679740e-01F,
2.02351317e-01F,
3.62846971e-01F,
2.98561573e-01F,
2.22679541e-01F,
2.59240657e-01F,
2.39063531e-01F,
2.21736938e-01F,
2.38877550e-01F,
2.39461258e-01F,
2.43760496e-01F,
2.14975044e-01F,
1.85045555e-01F,
3.08020324e-01F,
2.01054633e-01F,
2.08313555e-01F,
1.84247598e-01F,
2.89343238e-01F,
3.59702945e-01F,
2.74917543e-01F,
3.04915875e-01F,
2.97007531e-01F,
1.69003636e-01F,
2.01257512e-01F,
2.38803446e-01F,
2.10285634e-01F,
2.52355069e-01F,
1.81284383e-01F,
2.36101940e-01F,
2.32464015e-01F,
1.83651969e-01F,
1.77167788e-01F,
2.60182977e-01F,
3.71050239e-01F,
3.04541767e-01F,
2.32656226e-01F,
2.48849154e-01F,
2.71623671e-01F,
1.92905024e-01F,
2.42593646e-01F,
2.48362526e-01F,
1.97533429e-01F,
2.28773966e-01F,
2.37560168e-01F,
2.15601787e-01F,
2.00640291e-01F,
1.69610083e-01F,
1.73235089e-01F,
3.13775390e-01F,
3.38984340e-01F,
3.21584076e-01F,
2.80344635e-01F,
2.39277169e-01F,
2.89351553e-01F,
3.04193944e-01F,
2.17552081e-01F,
1.88546881e-01F,
2.60822713e-01F,
2.27149233e-01F,
1.65351748e-01F,
1.43538892e-01F,
1.41352370e-01F,
-1.34287253e-02F,
3.25698964e-02F,
-3.10795009e-02F,
-4.99615185e-02F,
1.09602258e-01F,
-3.69837992e-02F,
-3.92362364e-02F,
-3.59542780e-02F,
-2.26004608e-02F,
-3.10530118e-03F,
1.39250653e-02F,
-1.91999637e-02F,
2.43216977e-02F,
3.35474238e-02F,
2.73214113e-02F,
-2.50709858e-02F,
-1.58430561e-02F,
-6.52672816e-03F,
-7.73582142e-03F,
-6.33962965e-03F,
2.62194686e-02F,
6.66775778e-02F,
2.90164463e-02F,
3.56186181e-02F,
3.74192838e-04F,
-3.74495354e-03F,
2.90826447e-02F,
-5.33470623e-02F,
-3.96717759e-03F,
-4.88284649e-03F,
-1.82368122e-02F,
-5.51334722e-03F,
1.47038233e-02F,
4.91957106e-02F,
8.53815489e-03F,
-4.99904044e-02F,
-5.84692834e-03F,
5.96099682e-02F,
3.92068438e-02F,
-3.16266008e-02F,
-6.82815835e-02F,
4.73178457e-03F,
5.57388319e-03F,
-1.50964141e-03F,
-5.30448928e-03F,
1.58622190e-02F,
5.11845462e-02F,
-2.76307911e-02F,
-6.46877810e-02F,
7.78687466e-03F,
8.05278718e-02F,
3.64829926e-03F,
1.50765758e-02F,
3.43875075e-03F,
2.76340195e-03F,
-4.18946594e-02F,
-9.10827890e-03F,
-3.53806629e-03F,
5.32159721e-03F,
7.41509302e-03F,
-1.79197751e-02F,
-2.54902546e-03F,
1.30134420e-02F,
6.68742880e-03F,
-1.86587106e-02F,
-1.87219884e-02F,
-4.15870324e-02F,
-1.01111373e-02F,
4.70733643e-02F,
1.06233552e-01F,
1.91869866e-02F,
-6.56639831e-03F,
-3.47737819e-02F,
-4.45166789e-03F,
-8.57756380e-03F,
-1.38000501e-02F,
-5.78038115e-03F,
7.64442002e-03F,
2.87239701e-02F,
3.85149494e-02F,
5.97116090e-02F,
-1.51503924e-02F,
-3.52114141e-02F,
4.88063460e-03F,
-1.76877454e-02F,
1.13117490e-02F,
-3.65447327e-02F,
2.95823868e-02F,
-6.87414967e-03F,
-1.30343400e-02F,
6.26352988e-03F,
1.39988242e-02F,
-1.44898137e-02F,
-4.22133692e-02F,
-3.84184755e-02F,
4.84053493e-02F,
9.35078338e-02F,
-2.41856426e-02F,
-3.88004109e-02F,
3.25428993e-02F,
5.12299947e-02F,
-5.70656732e-03F,
-1.33327469e-02F,
-1.20283701e-02F,
4.41937987e-03F,
-1.46139425e-03F,
2.66622473e-02F,
5.01529537e-02F,
8.08561221e-02F,
-2.66862568e-02F,
-8.37019384e-02F,
-4.36258763e-02F,
-2.84321848e-02F,
-2.81750946e-03F,
-1.06685923e-03F,
4.74984013e-02F,
-5.66072688e-02F,
5.09927049e-03F,
5.55906771e-03F,
4.14480921e-03F,
-1.55311450e-02F,
-4.42262739e-02F,
-3.17101227e-03F,
3.80993262e-02F,
6.48458153e-02F,
4.71806973e-02F,
-4.03360352e-02F,
-5.10403961e-02F,
-1.59318577e-02F,
4.90788333e-02F,
-8.23283941e-03F,
-1.14328079e-02F,
-2.39760466e-02F,
3.08529614e-03F,
-1.85171550e-03F,
3.80540499e-03F,
-1.46662751e-02F,
-8.11737683e-03F,
-2.05781758e-02F,
-4.31645755e-03F,
2.07508518e-03F,
-4.75773076e-03F,
2.30982024e-02F,
4.60168198e-02F,
8.65951255e-02F,
-7.30011519e-03F,
-6.94472268e-02F,
6.89856010e-03F,
-8.10065027e-03F,
-2.06128368e-03F,
4.49013198e-03F,
2.61967245e-04F,
4.86617768e-03F,
1.94566778e-03F,
1.55565869e-02F,
-2.72396468e-02F,
-1.73111223e-02F,
1.14409283e-01F,
-5.48621453e-02F,
-1.66192465e-02F,
-1.66534465e-02F,
-1.00137787e-02F,
-2.69924547e-03F,
7.56338099e-03F,
-6.44681370e-03F,
-7.67407240e-03F,
-2.30052434e-02F,
-1.65763609e-02F,
-1.90418679e-02F,
-1.03895105e-02F,
1.80034898e-02F,
2.92292573e-02F,
2.44270787e-02F,
1.24232415e-02F,
9.54427291e-03F,
9.26406309e-02F,
-1.60984434e-02F,
-1.96270421e-02F,
-8.62683821e-03F,
-1.19192582e-02F,
-3.63079202e-03F,
1.32609354e-02F,
-5.71880257e-03F,
-1.01564350e-02F,
2.23594699e-02F,
-2.15923833e-03F,
-6.62337616e-02F,
-1.58602316e-02F,
1.13499194e-01F,
-1.38450181e-02F,
-1.75340269e-02F,
-9.86617431e-03F,
-1.37233213e-02F,
-1.97079289e-03F,
1.18383055e-03F,
-4.27531730e-03F,
3.77488369e-03F,
1.08474516e-03F,
1.47089213e-02F,
2.86384020e-02F,
5.27926348e-03F,
-4.01424207e-02F,
-3.86584327e-02F,
-3.83559391e-02F,
-3.50093767e-02F,
1.46325827e-02F,
8.60432014e-02F,
-6.83706999e-03F,
-3.15618212e-03F,
-1.05050765e-02F,
-1.33159868e-02F,
-8.33918806e-03F,
2.61384267e-02F,
1.86465979e-02F,
-1.45872813e-02F,
-3.79383098e-04F,
9.93270501e-02F,
-1.95106808e-02F,
-3.33899930e-02F,
-1.51711479e-02F,
-3.11023630e-02F,
-1.10483272e-02F,
-1.44842302e-03F,
3.58029385e-03F,
7.98245426e-03F,
2.54686791e-02F,
6.13123141e-02F,
1.43506965e-02F,
-5.84007129e-02F,
-8.35418925e-02F,
-5.40118143e-02F,
2.74289474e-02F,
8.22046772e-03F,
1.67757068e-02F,
5.78898890e-03F,
1.37354620e-02F,
5.58373798e-03F,
3.00750099e-02F,
6.69579953e-03F,
1.10203978e-02F
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\ampmsvq.h ===
#ifndef AMPMSVQ_H
#define AMPMSVQ_H

/**************************************************************
 * AMP - MSVQ Definitions
 **************************************************************/


unsigned short VoxAmpMSVQ(STACK_R float lpcin[], unsigned short cbNdx[], unsigned short numStages, 
                  unsigned short numCand, int order, unsigned short tableSize, 
                  const float **cb);

unsigned short VoxDecAmpMSVQ(unsigned short index[], float vect[], const float **cb,
                     short dim, short numStages);

#endif /* AMPMSVQ_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\ask0_1ui.h ===
/******************************************************************************
*                        Voxware Proprietary Material
*                        Copyright 1996, Voxware, Inc
*                            All Rights Reserved
*
*                       DISTRIBUTION PROHIBITED without
*                      written authorization from Voxware
******************************************************************************/
 
/******************************************************************************
* Filename:    ASK0_1Ui.h
*
* Purpose:     outer cell indices for 1st ASK pair -- only for unvoiced frame
*
* $Header:   /export/phobos/pvcs/r_and_d/archives/scaleable/tables/ASK0_1Ui.h_v   1.0   06 Feb 1998 10:12:20   johnp  $
*
******************************************************************************/
#ifndef _ASK0_1_UI_H_
#define _ASK0_1_UI_H_
3,
5,
6,
7,
8,
13,
15,
23,
24,
25,
29,
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\ampcb_4.h ===
0.2236067977F,
0.2236067977F,
0.2236067977F,
0.2236067977F,
0.2236067977F,
0.2236067977F,
0.2236067977F,
0.2236067977F,
0.2236067977F,
0.2236067977F,
0.2236067977F,
0.2236067977F,
0.2236067977F,
0.2236067977F,
0.2236067977F,
0.2236067977F,
0.2236067977F,
0.2236067977F,
0.2236067977F,
0.2236067977F,
0.0959546645F,
0.1900759891F,
0.2757929602F,
0.2805037522F,
0.2393056918F,
0.2006955904F,
0.2000454070F,
0.2187373041F,
0.2349408208F,
0.2450877745F,
0.2411103459F,
0.2226421805F,
0.2065121601F,
0.2305386458F,
0.2424867669F,
0.2281434641F,
0.2375366516F,
0.2345864189F,
0.2214862330F,
0.1561583932F,
0.0465695368F,
0.0918996998F,
0.1360647630F,
0.1630708915F,
0.1697668433F,
0.1723585230F,
0.1870056055F,
0.2140569469F,
0.2471910078F,
0.2728574313F,
0.2658840092F,
0.2535110066F,
0.2587243745F,
0.2809327552F,
0.2689024775F,
0.2736760089F,
0.2717315598F,
0.2651208271F,
0.2706093854F,
0.1549787610F,
0.1605315301F,
0.2741256829F,
0.2645180314F,
0.2147803795F,
0.1915930654F,
0.2314267676F,
0.2567784119F,
0.2212969172F,
0.2100413240F,
0.2383467740F,
0.2400661679F,
0.2144466199F,
0.2067419544F,
0.2166276931F,
0.2278799225F,
0.2286466000F,
0.2422081740F,
0.2176938491F,
0.2520612217F,
0.0989765451F,
0.0691156174F,
0.1196606630F,
0.1714921251F,
0.2195104706F,
0.2535952058F,
0.2769125800F,
0.2771428861F,
0.2224720563F,
0.1753568554F,
0.2013313839F,
0.2682764996F,
0.2616984775F,
0.2065242933F,
0.2249733207F,
0.2626579740F,
0.2224395557F,
0.2719262786F,
0.2401745025F,
0.2326385455F,
0.1636823237F,
0.1203800122F,
0.2323338590F,
0.2842457784F,
0.2648320341F,
0.2516092291F,
0.2659330239F,
0.2542153255F,
0.1716465143F,
0.1237189140F,
0.1497523031F,
0.2102259761F,
0.2399120022F,
0.2331974425F,
0.2277487208F,
0.2274966769F,
0.2359541804F,
0.2436003562F,
0.2301767626F,
0.2344897394F,
0.1789134466F,
0.0327458598F,
0.0618470421F,
0.0996483078F,
0.1395399900F,
0.1844738087F,
0.2549854364F,
0.3148234737F,
0.3025568108F,
0.2583712367F,
0.2441816517F,
0.2478656237F,
0.2477633031F,
0.2334783007F,
0.2373328276F,
0.2425947463F,
0.2437079855F,
0.2446725453F,
0.2537398094F,
0.2471586450F,
0.1112372998F,
0.1707307806F,
0.2723477848F,
0.2653793990F,
0.2009593909F,
0.1865264805F,
0.1990921958F,
0.2605158062F,
0.2728997407F,
0.2063969389F,
0.1838224110F,
0.2105793206F,
0.2297369546F,
0.2233572972F,
0.2169382341F,
0.2227044847F,
0.2211995039F,
0.2224914732F,
0.2205776771F,
0.2181539945F,
0.2331432699F,
0.0818462182F,
0.1591886795F,
0.2232024910F,
0.2391106191F,
0.2324694957F,
0.2309554876F,
0.2443080259F,
0.2489323393F,
0.2192548234F,
0.2014196844F,
0.2026571361F,
0.2204383315F,
0.2517379563F,
0.2641527703F,
0.2257987903F,
0.2829150402F,
0.2233357473F,
0.2743883176F,
0.2185837033F,
0.1284671855F,
0.0890449577F,
0.1578914286F,
0.2219852137F,
0.2450824404F,
0.2387871268F,
0.2288822662F,
0.2325661445F,
0.2235698191F,
0.2094953447F,
0.2200213137F,
0.2265299672F,
0.2217534514F,
0.2185980957F,
0.2298482379F,
0.2329491053F,
0.2335433438F,
0.2340531384F,
0.2227819005F,
0.2426822064F,
0.2807188612F,
0.0950403007F,
0.1239860629F,
0.1623882744F,
0.2535749687F,
0.3395036892F,
0.2668823872F,
0.2132040642F,
0.1935942064F,
0.2126773776F,
0.2482067914F,
0.2475464439F,
0.2162798753F,
0.2144691669F,
0.2396553285F,
0.2241824741F,
0.2275509196F,
0.2314081979F,
0.2249618869F,
0.2195119462F,
0.2068681254F,
0.0731187649F,
0.1463974950F,
0.2313761497F,
0.2776800944F,
0.2639377499F,
0.2363925726F,
0.2183567213F,
0.2173056560F,
0.2127612153F,
0.2184490013F,
0.2260235572F,
0.2296890810F,
0.2149197019F,
0.2333046834F,
0.2370549700F,
0.2283518745F,
0.2117098755F,
0.2477115142F,
0.3194865769F,
0.0899350849F,
0.2427432302F,
0.2194499835F,
0.1521637179F,
0.1600820607F,
0.2091806158F,
0.2364625362F,
0.2629135491F,
0.2526610222F,
0.2240342864F,
0.2263121648F,
0.2310255653F,
0.2233598199F,
0.2366984468F,
0.2351738723F,
0.2326910816F,
0.2375069770F,
0.2346944943F,
0.2379195468F,
0.2283363201F,
0.1453337533F,
0.1788135044F,
0.2697861405F,
0.2588192417F,
0.2195409906F,
0.2394230277F,
0.2171475408F,
0.1954225839F,
0.1727242635F,
0.2118420047F,
0.2748429998F,
0.2245002375F,
0.1874995312F,
0.2145938418F,
0.2453816281F,
0.2100955932F,
0.2270426359F,
0.2293354066F,
0.2200303097F,
0.2214682135F,
0.2226563977F,
0.1761558477F,
0.2851453703F,
0.2737481812F,
0.2071682549F,
0.1699096553F,
0.1617416908F,
0.1889558215F,
0.2513255701F,
0.2819169120F,
0.2293100179F,
0.2074190368F,
0.2097294480F,
0.2255151128F,
0.2531839763F,
0.2200784256F,
0.2420093878F,
0.2181361036F,
0.2400982660F,
0.2218793045F,
0.1428755849F,
0.0309522990F,
0.0675757916F,
0.1434052017F,
0.2243004778F,
0.2712634372F,
0.2820980908F,
0.2593101629F,
0.2443939996F,
0.2563035321F,
0.2510458534F,
0.2205590659F,
0.2035976269F,
0.2142458132F,
0.2362948668F,
0.2486114079F,
0.2387679070F,
0.2339355795F,
0.2547894646F,
0.2795116491F,
0.0795484472F,
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\ask0_1vi.h ===
/******************************************************************************
*                        Voxware Proprietary Material
*                        Copyright 1996, Voxware, Inc
*                            All Rights Reserved
*
*                       DISTRIBUTION PROHIBITED without
*                      written authorization from Voxware
******************************************************************************/
 
/******************************************************************************
* Filename:    ASK0_1Vi.h
*
* Purpose:     outer cell indices for 1st ASK pair -- only for voiced frame
*
* $Header:   /export/phobos/pvcs/r_and_d/archives/scaleable/tables/ASK0_1Vi.h_v   1.0   06 Feb 1998 10:12:20   johnp  $
*
******************************************************************************/
#ifndef _ASK0_1_VI_H_
#define _ASK0_1_VI_H_
5,
7,
10,
12,
14,
15,
21,
23,
26,
30,
31,
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\ask0_1u.h ===
/******************************************************************************
*                        Voxware Proprietary Material
*                        Copyright 1996, Voxware, Inc
*                            All Rights Reserved
*
*                       DISTRIBUTION PROHIBITED without
*                      written authorization from Voxware
******************************************************************************/
 
/******************************************************************************
* Filename:    ASK0_1U.h
*
* Purpose:     codebooks for 1st ASK pair, which include 5 bits stage 1 codebook,
*              5 bit rotation-scaling matrix, 5 bit stage 2 inner cell codebook
*              and 5 bit stage 2 outer cell codebook. Those codebooks are designed 
*              for unvoiced frame.
*
* $Header:   /export/phobos/pvcs/r_and_d/archives/scaleable/tables/ASK0_1U.h_v   1.0   06 Feb 1998 10:12:18   johnp  $
*
******************************************************************************/
#ifndef _ASK0_1UV_H_
#define _ASK0_1UV_H_
5.346080e-001F, -2.664800e-002F,  /*    Stage 1 codebook   (5 bits) */
-7.315710e-001F, -1.067840e-001F,
5.545200e-001F, -8.732390e-001F,
-1.388620e-001F, -6.173690e-001F,
-1.145860e-001F, -2.426080e-001F,
-1.646715e+000F, -5.555210e-001F,
1.810100e-001F, -7.415380e-001F,
-1.080797e+000F, -3.857420e-001F,
2.757710e-001F, 6.284650e-001F,
-1.022302e+000F, 4.740630e-001F,
2.691220e-001F, 1.512120e-001F,
-6.456890e-001F, 2.273390e-001F,
-5.576760e-001F, 5.870270e-001F,
-1.588281e+000F, 5.492110e-001F,
-3.897670e-001F, -3.216600e-002F,
-1.783118e+000F, 2.189600e-002F,
5.327120e-001F, 1.616290e-001F,
-6.619200e-002F, 1.006160e-001F,
4.889410e-001F, -3.056130e-001F,
1.933000e-001F, -4.359960e-001F,
2.243300e-001F, -1.296420e-001F,
-9.830650e-001F, 6.724300e-002F,
5.011230e-001F, -5.915750e-001F,
-5.559490e-001F, -4.871650e-001F,
9.395000e-002F, 1.015221e+000F,
-4.693910e-001F, 1.040591e+000F,
4.457890e-001F, 3.434880e-001F,
-2.884950e-001F, 3.371480e-001F,
-1.120130e-001F, 6.302960e-001F,
-1.092578e+000F, 9.320080e-001F,
9.762100e-002F, 3.421660e-001F,
-1.359483e+000F, 3.691600e-002F, 
1.197622e+001F, 0.000000e+000F,       /* scaling and rotation codebook (5 bits) */
-5.473183e+000F, -5.473183e+000F,
0.000000e+000F, -9.567114e+000F,
-2.346564e+000F, -6.113009e+000F,
-4.737762e+000F, -6.064059e+000F,
-2.067132e+000F, -4.056975e+000F,
-2.778737e+000F, -7.238858e+000F,
4.621751e-001F, -5.282686e+000F,
6.674952e+000F, 2.971880e+000F,
-5.738080e+000F, -1.011778e+000F,
8.560416e+000F, 4.942359e+000F,
7.563557e+000F, 2.026649e+000F,
6.284680e+000F, 1.683975e+000F,
-3.669446e+000F, 2.765126e+000F,
-4.314700e+000F, -6.396806e+000F,
-4.815127e+000F, 0.000000e+000F,
1.434556e+001F, 2.272114e+000F,
-6.034344e+000F, 6.034344e+000F,
9.383263e+000F, -4.917560e-001F,
8.508529e+000F, -1.485169e-001F,
8.639927e+000F, -6.041626e-001F,
-2.960525e+000F, -6.649448e+000F,
9.357885e+000F, 3.267846e-001F,
-1.127190e+000F, -5.303013e+000F,
3.026769e+000F, 4.322675e+000F,
-2.462139e-001F, 4.698040e+000F,
8.993511e+000F, 5.192406e+000F,
-5.437171e-001F, 7.775517e+000F,
-2.584510e-001F, 7.401068e+000F,
-1.340366e+000F, 4.125221e+000F,
6.355361e+000F, 6.355361e+000F,
0.000000e+000F, 5.716511e+000F,
-3.689370e-001F, 7.284960e-001F,    /* stage 2 inner cell codebook (5 bits) */
9.890650e-001F, 4.882320e-001F,
-1.312897e+000F, 7.767640e-001F,
6.278100e-002F, 8.835180e-001F,
-4.261960e-001F, -2.561540e-001F,
6.963430e-001F, -6.519790e-001F,
-1.289014e+000F, -3.634020e-001F,
-2.468930e-001F, -7.322210e-001F,
-2.804180e-001F, 1.260715e+000F,
9.564890e-001F, 1.136400e+000F,
-8.134410e-001F, 1.074187e+000F,
3.471590e-001F, 1.257091e+000F,
8.138800e-002F, 4.041290e-001F,
1.385320e+000F, 7.117900e-002F,
-8.851230e-001F, -1.982800e-002F,
4.031270e-001F, -2.622580e-001F,
-4.036960e-001F, 2.359050e-001F,
8.979540e-001F, -1.419460e-001F,
-1.418555e+000F, 1.852740e-001F,
1.182600e-002F, -1.382330e-001F,
-5.792290e-001F, -1.135800e+000F,
9.723100e-001F, -1.100621e+000F,
-1.162367e+000F, -9.777620e-001F,
-3.641100e-002F, -1.222577e+000F,
5.397330e-001F, 7.543810e-001F,
1.555048e+000F, 7.269100e-001F,
-8.615620e-001F, 5.074220e-001F,
5.429300e-001F, 2.184310e-001F,
1.909680e-001F, -7.088340e-001F,
1.247367e+000F, -5.702140e-001F,
-7.811680e-001F, -6.135670e-001F,
4.776820e-001F, -1.171449e+000F,
9.467470e-001F, -7.964760e-001F,  /* stage 2 outer cell codebook */
2.056197e+000F, 2.331590e-001F,
-5.249660e-001F, -3.631910e-001F,
8.569580e-001F, 7.814150e-001F,
-2.489300e-001F, 8.470100e-002F,
1.229369e+000F, 1.196587e+000F,
-9.227100e-001F, 7.431310e-001F,
-2.944800e-002F, 1.190333e+000F,
3.529100e-002F, -3.254440e-001F,
1.815008e+000F, 1.154408e+000F,
-7.212640e-001F, 4.833700e-002F,
3.625540e-001F, 7.354990e-001F,
-5.801710e-001F, 4.654920e-001F,
5.559260e-001F, 1.350522e+000F,
-1.113965e+000F, 2.980620e-001F,
-5.201220e-001F, 1.048562e+000F,
1.356565e+000F, -1.229959e+000F,
2.212666e+000F, -9.018570e-001F,
-4.786700e-002F, -1.185486e+000F,
1.086926e+000F, -1.770570e-001F,
3.773470e-001F, -8.436830e-001F,
1.351700e+000F, 3.794640e-001F,
-8.050260e-001F, -7.061850e-001F,
2.128770e-001F, 2.517420e-001F,
6.001950e-001F, -1.308107e+000F,
1.542591e+000F, -5.610400e-001F,
-5.539760e-001F, -1.111319e+000F,
5.145440e-001F, -3.403320e-001F,
-2.330810e-001F, -7.583730e-001F,
7.282810e-001F, 2.160780e-001F,
-1.057276e+000F, -2.468670e-001F,
-1.821850e-001F, 6.986970e-001F
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\as2lspe.c ===
/*******************************************************************************
*                        Voxware Proprietary Material                          *
*                        Copyright 1996, Voxware, Inc                          *
*                            All Rights Reserved                               *
*                                                                              *
*                       DISTRIBUTION PROHIBITED without                        *
*                      written authorization from Voxware                      *
*******************************************************************************/
 
/*******************************************************************************
* Filename:       as2lspe.c
*
* Purpose:        Compute LSPs from predictor coefficients for EVEN all-pole
*                   model orders.
*
* Functions:      VoxAsToLspEven()
*
* Author/Date:    Bob Dunn 2/2/98 (with code scarfed from many others...
*                            S. Yeldner, R. Zopf, W. Wang, I. Berci)
********************************************************************************
* Implementation/Detailed Description:
*
*            1) Compute reduced polynomials RP(z) and RQ(z)
*            2) Decimate RP(z) and RQ(z) by a factor of 2
*            3) Search for roots of decimated polynomials
*            4) Check that roots are valid
*            5) Convert the roots to the LSP domain and scale
*
* References:  "Speech Analysis and Synthesis Methods Developed at ECL in
*                NTT - From LPC to LSP -", Noboru Sugamura and Fumitada
*                Itakura, Speech Communication 5 (1986) pp 199-215.
*
*              "Line Spectrum Pair (LSP) and Speech Data Compression",
*                Frank k. Soong and Bing-Hwang Juang, Proc. ICASSP 1984,
*                pp 1.10.1-1.10.4
*
*              "Application of Line-Spectrum Pairs to Low-Bit_rate Speech
*                Encoders", George S. Kang and Lawrence J. Fransen, Proc.
*                ICASSP 1985, PP 7.3.1-7.3.4
*
*              "A Novel Two-Level Method for the Computation of LSP
*                Frequencies Using a Decimation-in-Degree Algorithm",
*                C. Wu and J. Chen, IEEE Trans. on Speech and Audio
*                Proc., Vol. 5, No. 2, March 1977.
********************************************************************************
*
* Modifications:  
*
* Comments:    The inverse filter is defined as:
*
*                      A(Z) = 1 + SUM(i=1...p) A_i Z^(-i)
*
*              The LSPs are normalized in frequency and range
*                from 0 to 0.5.  Since many codecs require LSPs in
*                Hertz, fScaleFactor is included to allow the conversion
*                to Hertz.  If fScaleFactor is the sampling rate, the
*                LPSs will be in Hertz.  If fScaleFactor is 1.0 the LPSs
*                will range from 0 to 0.5.
*
* Concerns:
*
*              There are two methods for root finding used here.  One method
*                is to use Newton's method to find all but the last root.
*                The second method is to use the closed form solution to
*                find the last 4 roots.  The closed form solution is faster
*                in both peak and average times.  The closed form solution
*                is also more accurate for 10th and 12th order all-pole
*                models.  However, the accuracy of the closed form solution
*                is lower than Newton's method when the all-pole model
*                order is 18.  I may be desirable to add a refinement step
*                where a single additional iteration of Newton's method is
*                applied for each estimated root using the original polynomial.
*
*              The closed form solution for 4th order polynomials may not
*                be appropriate for fixed point processing.  If this is the
*                case then it can be replaced with Newton's method.
*
*              In this routine a 1st order Newton's method is used to find
*                roots of polynomials.  A 2nd order routine (i.e. using 1st
*                and 2nd derivatives) could be used for this and it would
*                require fewer iterations (both average and peak) to solve
*                for roots.  However, the increased computation for each
*                iteration of a 2nd order routine offsets the reduction in 
*                the total number of iterations.  The more simple 1st order
*                routine is used since it has a slightly smaller code size.
*
* $Header:   /export/phobos/pvcs/pvcsproj/voxlib.prj/as2lspe.c_v   1.7   03 Mar 1998 08:06:38   bobd  $
*******************************************************************************/
#include <math.h>
#include <string.h>
#include <assert.h>

#include "vLibDef.h"
#include "vLibTran.h"

#include "xvocver.h"

/*----------------------------------------------------------
  Use closed form solution for all pole model orders 8
    through MAX_QUAD_ROOT_ORDER.  The closed form solution
    for fourth order polynomials cannot be used for model
    orders lees than 8 and its accuracy declines above
    MAX_QUAD_ROOT_ORDER. NOTE: It is possible to use
    the closed form soultion to get a good initial guess 
    for the iterative method, but that is not done here.
----------------------------------------------------------*/
#define MAX_QUAD_ROOT_ORDER  14

#define SUCCESS 0
#define FAILURE 1

/*----------------------------------------------------------
  Defines for root finding
----------------------------------------------------------*/
#define ROOT_CONVERGE      0
#define ROOT_NOT_CONVERGE -1
#define ROOT_MAXIMUM       1

#define THRESH_ZERO  1.0e-6F
#define THRESH_ONE   0.01F

/*----------------------------------------------------------
  MAX_ITER is the maximum number of iterations per root.
    This is set conservatively.  The maximum values that
    have been observed are:

       13 for 18th order model
       11 for 16th order model
       11 for 14th order model
       11 for 12th order model
       10 for 10th order model
----------------------------------------------------------*/
#define MAX_ITER     15

/*----------------------------------------------------------
  Internal function declarations.
----------------------------------------------------------*/
static void VoxDIDeven( float *pfRP, float *pfRQ, int iOrder, float *pfDP,
                        float *pfDQ );


static int iFindRoot( float *pfRoot, int iDegree, const float *pfOrgCoef,
                      float *pfNewCoef);

static void VoxCompRedPoly( float *pfAs, int iOrder, float *pfRP, float *pfRQ );

static void VoxSetArbitraryLSP( float *pfLSP, int iOrder, float  fScaleFactor);

static void SolveQuad( float *pfCoef, float *pfRoots );

/*******************************************************************************
* Function:  VoxAsToLspEven()
*
* Action:    Compute LSPs from predictor coefficients for an even ordered
*              all-pole model.
*
* Input:     float *pfAs          --> predictor coefficients
*            int    iOrder        --> all-pole model order
*            float  fScaleFactor  --> scale factor to apply to LSPs (if the
*                                       factor is 1.0, the LSPs range from
*                                       0 to 0.5).
*
* Output:    float *pfLSP         --> LSPs
*
* Globals:   none
*
* Return:    int        (0/1) (success/fail)
********************************************************************************
* Modifications:
*
* Comments:    The inverse filter is defined as:
*
*                      A(Z) = 1 + SUM(i=1...p) A_i Z^(-i)
*
*              The LSPs are normalized in frequency and range 
*                from 0 to 0.5.  Since many codecs require LSPs in 
*                Hertz, fScaleFactor is included to allow the conversion
*                to Hertz.  If fScaleFactor is the sampling rate, the 
*                LPSs will be in Hertz.  If fScaleFactor is 1.0 the LPSs
*                will range from 0 to 0.5.
*
* Concerns/TBD:
*
*******************************************************************************/
int VoxAsToLspEven( float *pfAs, 
                    int    iOrder, 
                    float  fScaleFactor,
                    float *pfLSP
                  )
{
   int    i, j;
   int    iDegree;
   int    iOrder2;
   int    iStatus = SUCCESS;
   int    iQuadRootFlag;
   int    iMinDegree;
   float  fRoot;
   float  fScale;
   float *pfTemp;
   float  fRP[(MAX_LPC_ORDER>>1)+1];
   float  fRQ[(MAX_LPC_ORDER>>1)+1];
   float  fDP[(MAX_LPC_ORDER>>1)+1];
   float  fDQ[(MAX_LPC_ORDER>>1)+1];
   float  fQuadRootsD[4];
   float  fQuadRootsQ[4];

   assert( pfAs );
   assert( pfLSP );
   assert( !(iOrder&1) );             /* model order must be even!  */
   assert( iOrder <= MAX_LPC_ORDER ); /* don't exceed MAX_LPC_ORDER */

   if ((iOrder>MAX_QUAD_ROOT_ORDER) || (iOrder<8))
      iQuadRootFlag = 0;
   else
      iQuadRootFlag = 1;

   iOrder2 = iOrder>>1;

   /*--------------------------------------------------------
     Compute reduced P and Q polynomials from the predictor
       coefficients.
   --------------------------------------------------------*/
   VoxCompRedPoly( pfAs, iOrder, fRP, fRQ );

   fRP[iOrder2] = 1.0F;  /* set high order coefficient */
   fRQ[iOrder2] = 1.0F;  /* set high order coefficient */

   /*--------------------------------------------------------
     Decimate reduced P and Q polynomials
   --------------------------------------------------------*/
   VoxDIDeven( fRP, fRQ, iOrder, fDP, fDQ );

   fRoot = 1.99999999F;  /* Initial guess for first root */
   pfTemp = fRP;         /* re-use this memory for       */
   j = 0;                /* initialize index for LSPs    */

   /*-----------------------------------------------------
     Solve for roots of the decimated polynomials.
   -----------------------------------------------------*/
   if (iQuadRootFlag)
      iMinDegree = 4;
   else 
      iMinDegree = 1;

   for (iDegree = iOrder2; iDegree>iMinDegree; iDegree--)
   {
      /*-----------------------------------------------------
        Find a root of fDP[].
      -----------------------------------------------------*/
      if (iFindRoot(&fRoot, iDegree, fDP, pfTemp)!= ROOT_CONVERGE)
         iStatus = FAILURE;

      pfLSP[j++] = fRoot;

      /*-----------------------------------------------------
        Copy reduced order polynomial from pfTemp[] to fDP[]
      -----------------------------------------------------*/
      memcpy( fDP, pfTemp, (iDegree+1)*sizeof(float) );

      /*-----------------------------------------------------
        Find root of fDQ[].
      -----------------------------------------------------*/
      if (iFindRoot(&fRoot, iDegree, fDQ, pfTemp)!= ROOT_CONVERGE)
         iStatus = FAILURE;

      pfLSP[j++] = fRoot;

      /*-----------------------------------------------------
        Copy reduced order polynomial from pfTemp[] to fDQ[]
      -----------------------------------------------------*/
      memcpy( fDQ, pfTemp, (iDegree+1)*sizeof(float) );
   }

   if (iQuadRootFlag)
   {
      /*-----------------------------------------------------
        Use the closed form solution to find the roots
          of the 4th order polynomial.
      -----------------------------------------------------*/
      SolveQuad( fDP, fQuadRootsD );
      SolveQuad( fDQ, fQuadRootsQ );
   
      pfLSP[j++] = fQuadRootsD[0];
      pfLSP[j++] = fQuadRootsQ[0];

      pfLSP[j++] = fQuadRootsD[1];
      pfLSP[j++] = fQuadRootsQ[1];

      pfLSP[j++] = fQuadRootsD[2];
      pfLSP[j++] = fQuadRootsQ[2];

      pfLSP[j++] = fQuadRootsD[3];
      pfLSP[j++] = fQuadRootsQ[3];
   } else {
      /*-----------------------------------------------------
        Solve for 1st order roots.  If (fDP[1]==0.0F) or 
         (fDQ[1]==0.0F) then these cannot be found.
      -----------------------------------------------------*/
      if ( (fDP[1]==0.0F) || (fDQ[1]==0.0F))
      {
         iStatus = FAILURE;
      } else {
         pfLSP[j++] = -fDP[0]/fDP[1];
         pfLSP[j++] = -fDQ[0]/fDQ[1];
      }
   }

   /*---------------------------------------------------------------
     Check if LPSs are valid.  This is done in the domain of 
       x[i] = 2*cos( 2*PI*LSP[i] ).  In this domain the 
       realtionship is:

     (-2 < x[iOrder-1] < ... < x[i+1] < x[i] < ... < x[0] < 2)

     NOTE: In the above expression the ordering property of the 
             LSPs has been reversed by the cosine.
   ---------------------------------------------------------------*/
   if ((pfLSP[0]>=2.0F) || (pfLSP[iOrder-1]<=-2.0F))
      iStatus = FAILURE;

   for (i=1; i<iOrder; i++)
      if (pfLSP[i]>pfLSP[i-1])
         iStatus = FAILURE;

   if (iStatus==SUCCESS)
   {
      /*-----------------------------------------------------
        Convert roots to normalized frequencies.
      -----------------------------------------------------*/
      fScale = fScaleFactor*(1.0F/DB_PI);
      for (i=0; i<iOrder; i++)
         pfLSP[i] = (float)acos( pfLSP[i]*0.5F )*fScale;
   } else {
      /*-----------------------------------------------------
        Root finding failed....compute evenly spaced LSPs.
      -----------------------------------------------------*/
      VoxSetArbitraryLSP( pfLSP, iOrder, fScaleFactor );
   }

   return iStatus;

} /* VoxAsToLspEven() */

/*******************************************************************************
* Function:  VoxCompRedPoly()
*
* Action:    Compute reduced polynomials RP(z) and RQ(z) from the predictor
*              coefficients for an even ordered all-pole model.
*
* Input:     float *pfAs    --> predictor coefficients
*            int    iOrder  --> all-pole model order
*
* Output:    float *pfRP    --> reduced polynomial RP(z)
*            float *pfRQ    --> reduced polynomial RQ(z)
*
* Globals:   none
*
* Return:    void
********************************************************************************
* Implementation/Detailed Description:
*
* References:
********************************************************************************
* Modifications:
*
* Comments:    The inverse filter is defined as:
*
*                      A(Z) = 1 + SUM(1...p) A_p Z^(-p)
*
*            Since the reduced polynomials are symmetric, only half of
*              the coefficients are needed for this computation.  The
*              format of pfRP[] and pfRQ[] is:
*
*  RP(z) = pfRP[N]*z^(-2N) + pfRP[N-1]*z^(1-2N) + ... 
*           + pfRP[1]*z^(-1-N) + pfRP[0]*z^(-N) + pfRP[1]*z^(1-N) + ... 
*           + pfRP[N-1]*z + pfRP[N]
*
*  RQ(z) = pfRQ[N]*z^(-2N) + pfRQ[N-1]*z^(1-2N) + ...
*           + pfRQ[1]*z^(-1-N) + pfRQ[0]*z^(-N) + pfRQ[1]*z^(1-N) + ...
*           + pfRQ[N-1]*z + pfRQ[N]
*
*              where N = iOrder/2
*
* Concerns/TBD:
*******************************************************************************/
static void VoxCompRedPoly( float *pfAs, 
                            int    iOrder, 
                            float *pfRP, 
                            float *pfRQ 
                          )
{
   int    i;
   float  fTemp0;
   float  fTemp1;
   float *pfAs0;
   float *pfAs1;

   fTemp0  = 1.0F;
   fTemp1  = 1.0F;
   pfAs0   = pfAs+1;
   pfAs1   = pfAs+iOrder;
   for (i = (iOrder>>1)-1; i>=0; i--)
   {
      fTemp0 = pfRP[i] = *pfAs0   + *pfAs1   - fTemp0;
      fTemp1 = pfRQ[i] = *pfAs0++ - *pfAs1-- + fTemp1;
   }
} /* VoxCompRedPoly */

/*******************************************************************************
* Function:  VoxDIDeven()
*
* Action:    Decimate reduced P(z) and reduced Q(z) polynomials by
*              a factor of 2.  This only works for even all-pole
*              model orders because for odd all-pole model orders
*              the reduced polynomials have different lengths.
*
* Input:     float *pfRP   --> coefficients of reduced polynomial RP(z)
*            float *pfRQ   --> coefficients of reduced polynomial RQ(z)
*            int    iOrder --> all-pole model order
*
* Output:    float *pfDP   --> coefficients of decimated polynomial DP(z)
*            float *pfDQ   --> coefficients of decimated polynomial DQ(z)
*
* Globals:   none
*
* Return:    void
********************************************************************************
* Implementation/Detailed Description:
*            Since the reduced polynomials are symmetric, only half of
*              the coefficients are needed for this computation.  The
*              format of pfRP[] and pfRQ[] is:
*
*  RP(z) = pfRP[N]*z^(-2N) + pfRP[N-1]*z^(1-2N) + ... 
*           + pfRP[1]*z^(-1-N) + pfRP[0]*z^(-N) + pfRP[1]*z^(1-N) + ... 
*           + pfRP[N-1]*z + pfRP[N]
*
*  RQ(z) = pfRQ[N]*z^(-2N) + pfRQ[N-1]*z^(1-2N) + ... 
*           + pfRQ[1]*z^(-1-N) + pfRQ[0]*z^(-N) + pfRQ[1]*z^(1-N) + ... 
*           + pfRQ[N-1]*z + pfRQ[N]
*
*              where N = iOrder/2
*
* References:
*******************************************************************************/
static void VoxDIDeven( float *pfRP, 
                        float *pfRQ,
                        int    iOrder, 
                        float *pfDP,
                        float *pfDQ
                      )
{
   int   i, j, k;
   int   N;
   int   Nv2;
   float fS[MAX_LPC_ORDER>>1];

   N   = iOrder>>1;
   Nv2 = N>>1;

   /*---------------------------------------
     Initialize coefficients
   ---------------------------------------*/
   fS[0] = 1.0F;
   fS[1] = -2.0F;
   fS[2] = 2.0F;
   for (i=3; i<=Nv2; i++)
      fS[i] = fS[i-2];

   /*---------------------------------------
     Decimate polynomials
   ---------------------------------------*/
   for (k=0; k<=N; k++)
   {
      pfDP[k] = pfRP[k];
      pfDQ[k] = pfRQ[k];
      for (i=k+2, j=1; i<=N; i+=2, j++)
      {
         pfDP[k] += fS[j]*pfRP[i];
         pfDQ[k] += fS[j]*pfRQ[i];
         fS[j]   -= fS[j-1];
      }
   }
} /* VoxDIDeven() */

/*******************************************************************************
* Function: iFindRoot()
*
* Action:   Find a single root of a polynomial using Newton's method.
*             Also compute coefficients of a new polynomial with the
*             root divided out.
*
* Input:    float *const pfRoot          --> pointer to initial guess
*           int iDegree                  --> order of the polynomial
*           const float *const pfOrgCoef --> coefficients of the polynomial
*
* Output:   float *const pfRoot          --> pointer to new root
*           float *const pfNewCoef       --> coefficients of reduced polynomial
*
* Globals:  none
*
* Return:   int   ROOT_CONVERGE/ROOT_NOT_CONVERGE/ROOT_MAXIMUM
********************************************************************************
* Implementation/Detailed Description:
*
* References:
*******************************************************************************/
static int iFindRoot( float       *pfRoot, 
                      int          iDegree, 
                      const float *pfOrgCoef,
                      float       *pfNewCoef
                    )
{
  float  df;        /* deviation of polynomial at *pfRoot                   */
  float  dx;        /* difference of previous position and current position */
  float  f=0.0F;    /* evaluation of polynomial at *pfRoot                  */
  int    iCount, i;
  const float    *pfOrg;
  float          *pfNew;
  const float    *pfO;
  float          *pfN;
  int             iStatus = ROOT_MAXIMUM;

  /*-------------------------------------
    pfOrg = &(pfOrgCoef[iDegree]);
    iDegreeOld = iDegree;
    pfNew = &(pfNewCoef[iDegree-1]);
    iDegree = iDegree - 2;
  -------------------------------------*/
  pfOrg = pfOrgCoef+iDegree--;
  pfNew = pfNewCoef+iDegree--;

  for (iCount = 0; (iCount<MAX_ITER) && (iStatus==ROOT_MAXIMUM); iCount++) 
  {
    /*-------------------------------------
      f = pfOrgCoef[old_degree];
      pfNewCoef[old_degree-1] = f;

      first df = 0; so 
        df = df*a+f ==> df = f;

      f = f*a + pfOrgCoef[iDegreeOld-1];
    -------------------------------------*/
    pfO = pfOrg;    pfN = pfNew;
    df = f = *pfN-- = *pfO--;

    f = f*(*pfRoot) + *pfO--;


    for (i = iDegree; i >= 0; i--) 
    {
      /*-------------------------------------
        pfNewCoef[i] = f;
        df = df*a + f;
        f = f*a + pfOrgCoef[i];
      -------------------------------------*/
      *pfN-- = f;
      df = df*(*pfRoot) + f;
      f = f*(*pfRoot) + *pfO--;
    }

    /*-----------------------------------------------------------
      derivative == 0 -- may need to move initial guess
    -----------------------------------------------------------*/
    if (df == 0.0F) 
    {
       iStatus = ROOT_NOT_CONVERGE;
    } else {
       dx = f/df;

       *pfRoot -= dx;              /* set the new root */

       if (dx <= THRESH_ZERO)  
          iStatus = ROOT_CONVERGE;     /* succeed!! */
    }
  }

  if (f < 0.0F)   
    f = -f;

  if (f >= (float)THRESH_ONE)  
     iStatus = ROOT_NOT_CONVERGE;   /* not converge */

  return iStatus;

} /* iFindRoot() */

/*******************************************************************************
* Function:  VoxSetArbitraryLSP()
*
* Action:    Create and arbitrary set of LPSs corresponding to a flat spectrum.
*
* Input:     int    iOrder        --> all-pole model order
*            float  fScaleFactor  --> frequency scaling factor
*
* Output:    float *pfLSP         --> pointer to LPSs
*
* Globals:   none
*
* Return:    void
*******************************************************************************/
static void VoxSetArbitraryLSP( float *pfLSP, 
                                int    iOrder, 
                                float  fScaleFactor 
                              )
{
   float fStep;
   float fVal;

   fStep = fScaleFactor/(float)iOrder;
   fVal = 0.5F*fStep;

   for ( ; iOrder>0; iOrder--)
   {
      *pfLSP++  = fVal;
      fVal     += fStep;
   }
} /* VoxSetArbitraryLSP() */

/*******************************************************************************
* Function:  SolveQuad()
*
* Action:    Find the 4 roots of a 4th order polynomial.
*
* Input:     float *pfCoef  --> coefficients of the polynomial
*
* Output:    float *pfRoots --> the 4 roots of the polynomial
*
* Globals:   none
*
* Return:    void
********************************************************************************
*
* Comments:  
*
* The polynomial is defined as:
*
*   pfCoef[4]*X^4 + pfCoef[3]*X^3 + pfCoef[2]*X^2 + pfCoef[1]*X + pfCoef[0] = 0
*
* The 4 roots are ordered such that:
*
*   pfRoots[3] < pfRoots[2] < pfRoots[1] < pfRoots[0]
*
* References:
*              "A Novel Two-Level Method for the Computation of LSP
*                Frequencies Using a Decimation-in-Degree Algorithm",
*                C. Wu and J. Chen, IEEE Trans. on Speech and Audio
*                Proc., Vol. 5, No. 2, March 1977.
*******************************************************************************/

static void SolveQuad( float *pfCoef,
                       float *pfRoots
                     )
{
   float fInv;
   float fa, fb, fc, fd;      /* coefficients of quartic to solve */
   float faa, fbb, fcc;       /* coefficients of cubic            */
   float fA, fB, fC, fD, fE;  /* intermediate values              */
   float fAlpha;
   float fY1;
   float fAE;
   float fSqrt;

   /*-----------------------------------------------------------
     Coefficients of quartic
   -----------------------------------------------------------*/
   fInv = 1.0F/pfCoef[4];

   fa = fInv*pfCoef[3];
   fb = fInv*pfCoef[2];
   fc = fInv*pfCoef[1];
   fd = fInv*pfCoef[0];

   /*-----------------------------------------------------------
     Coefficients of cubic
   -----------------------------------------------------------*/
   faa = -fb;
   fbb = fa*fc-4.0F*fd;
   fcc = 4.0F*fb*fd - fa*fa*fd - fc*fc;

   /*-----------------------------------------------------------
     solve cubic
   -----------------------------------------------------------*/
   fE = faa*(1.0F/3.0F);
   fA = fbb - faa*fE;
   fB = 2.0F*fE*fE*fE - fbb*fE + fcc;
   fC = 2.0F * (float)sqrt((-fA)*(1.0F/3.0F));
   fAlpha = (float)acos(3.0F*fB/(fA*fC));
   fD = fC*(float)cos(fAlpha*(1.0F/3.0F));
   fY1 = fD - fE;

   /*-----------------------------------------------------------
     Solve the quartic.  In this result the following 
       inequality holds:

        pfRoots[3] < pfRoots[2] < pfRoots[1] < pfRoots[0]
   -----------------------------------------------------------*/
   fE = 0.5F*fa;
   fA = (float)sqrt( fa*fa*0.25F - fb + fY1 );
   fB = (fE * fY1 - fc) / fA;

   fAE = fA - fE;
   fSqrt = (float)sqrt( fAE*fAE - 2.0F*(fY1-fB) );

   pfRoots[0] = 0.5F * (fAE+fSqrt);
   pfRoots[1] = 0.5F * (fAE-fSqrt);

   fAE = fA + fE;
   fSqrt = (float)sqrt( fAE*fAE - 2.0F*(fY1+fB) );

   pfRoots[2] = 0.5F * (-fAE+fSqrt);
   pfRoots[3] = 0.5F * (-fAE-fSqrt);

} /* SolveQuad() */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\ask10_11.h ===
/******************************************************************************
*                        Voxware Proprietary Material
*                        Copyright 1996, Voxware, Inc
*                            All Rights Reserved
*
*                       DISTRIBUTION PROHIBITED without
*                      written authorization from Voxware
******************************************************************************/
 
/******************************************************************************
* Filename:    ASK10_11.h
*
* Purpose:     5-bits codebook for 6th ASK pair
*
* $Header:   /export/phobos/pvcs/r_and_d/archives/scaleable/tables/ASK10_11.h_v   1.0   06 Feb 1998 10:12:22   johnp  $
*
******************************************************************************/
#ifndef _ASK10_11_H_
#define _ASK10_11_H_
-0.006447F, -0.157984F,
0.309185F, -0.078486F,
0.284091F, 0.085250F,
-0.085561F, 0.196965F,
0.146764F, -0.326275F,
-0.028815F, -0.064740F,
-0.202567F, 0.057179F,
0.165501F, 0.217725F,
-0.122359F, -0.220926F,
-0.226105F, 0.316395F,
-0.001451F, -0.285183F,
0.040366F, -0.014769F,
-0.317739F, -0.004761F,
0.053720F, 0.168325F,
0.207210F, -0.001693F,
-0.007252F, 0.295610F,
-0.186752F, 0.165055F,
0.173625F, -0.103786F,
-0.109517F, -0.007791F,
-0.111566F, -0.109296F,
0.072158F, -0.096065F,
-0.326067F, 0.145343F,
0.055143F, 0.068572F,
-0.022379F, 0.118820F,
0.142187F, 0.088145F,
-0.190161F, -0.044785F,
0.250236F, -0.204596F,
0.116277F, -0.013339F,
-0.254087F, -0.146538F,
0.106269F, -0.189196F,
-0.031700F, 0.028774F,
-0.104340F, 0.090241F,
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\ask0_1v.h ===
/******************************************************************************
*                        Voxware Proprietary Material
*                        Copyright 1996, Voxware, Inc
*                            All Rights Reserved
*
*                       DISTRIBUTION PROHIBITED without
*                      written authorization from Voxware
******************************************************************************/
 
/******************************************************************************
* Filename:    ASK0_1V.h
*
* Purpose:     codebooks for 1st ASK pair, which include 5 bits stage 1 codebook,
*              5 bit rotation-scaling matrix, 5 bit stage 2 inner cell codebook
*              and 5 bit stage 2 outer cell codebook. Those codebooks are designed 
*              for voiced frame.
*
* $Header:   /export/phobos/pvcs/r_and_d/archives/scaleable/tables/ASK0_1V.h_v   1.0   06 Feb 1998 10:12:20   johnp  $
*
******************************************************************************/
#ifndef _ASK0_1V_H_
#define _ASK0_1V_H_
2.913850e-001F, -2.145170e-001F,  /*    Stage 1 codebook   (5 bits) */
2.650260e-001F, 1.377740e-001F,
-7.023400e-002F, -2.578350e-001F,
7.615000e-003F, 3.844360e-001F,
8.127700e-002F, 2.076540e-001F,
1.427750e-001F, 8.230680e-001F,
-4.267760e-001F, 3.213600e-001F,
-4.235470e-001F, 1.074654e+000F,
3.284990e-001F, -5.092180e-001F,
1.292920e-001F, -1.839740e-001F,
-8.844700e-002F, -4.146560e-001F,
-2.152200e-001F, -1.179950e-001F,
1.274270e-001F, -3.806390e-001F,
-1.779560e-001F, 2.413840e-001F,
-4.251920e-001F, -1.704480e-001F,
-7.674290e-001F, 4.722770e-001F,
2.810970e-001F, -5.028800e-002F,
2.348300e-001F, 3.521820e-001F,
-9.380400e-002F, 6.280800e-002F,
-1.392670e-001F, 7.781110e-001F,
1.497260e-001F, 5.739770e-001F,
-2.490300e-002F, 1.134357e+000F,
-4.951630e-001F, 6.396290e-001F,
-8.958640e-001F, 9.393790e-001F,
3.074480e-001F, -3.618670e-001F,
1.140160e-001F, 1.506500e-002F,
-2.586100e-001F, -3.266790e-001F,
-3.126260e-001F, 6.814100e-002F,
-3.334600e-002F, -1.001700e-001F,
-1.845930e-001F, 4.993470e-001F,
-6.307390e-001F, 8.097500e-002F,
-1.277376e+000F, 5.398820e-001F,
1.654336e+001F, 1.040820e+000F,  /* Rotation and scaling matrix (5bits)*/
1.376112e+001F, 1.909513e+000F,
1.440380e+001F, -3.591270e+000F,
6.482849e+000F, 1.062061e+001F,
1.238850e+001F, 5.412402e+000F,
9.092524e+000F, 1.882971e+000F,
-7.290978e+000F, 6.053086e+000F,
-1.489380e+000F, 5.370530e+000F,
1.266289e+000F, -1.540217e+001F,
6.526928e+000F, 1.303397e+001F,
-2.225406e+000F, -1.389367e+001F,
-3.787190e+000F, 1.374931e+001F,
0.000000e+000F, -1.280876e+001F,
-9.771700e+000F, 7.417124e+000F,
-7.516310e+000F, -6.839315e+000F,
-4.274687e+000F, -5.510893e+000F,
1.535557e+001F, 1.410978e+000F,
1.117642e+001F, 4.335049e+000F,
-1.292214e+001F, -4.780044e+000F,
-3.050499e+000F, 7.824124e+000F,
9.922658e+000F, 3.811901e-001F,
2.828365e+000F, 5.648114e+000F,
-3.941170e+000F, 6.690778e+000F,
-2.632595e+000F, 4.262535e+000F,
1.652859e+001F, 1.795579e+000F,
-8.488723e+000F, 1.212315e+001F,
-7.603828e+000F, -1.054297e+001F,
-9.993848e+000F, 6.076355e+000F,
-1.546218e+001F, 3.998793e+000F,
-5.198190e+000F, 8.860101e+000F,
-6.692835e+000F, -2.569139e+000F,
-3.346042e+000F, -1.406547e+000F,
1.182980e+000F, 1.058207e+000F,  /* inner cell codebook (5 bits) */
1.436938e+000F, 5.365370e-001F,
3.079340e-001F, 6.705480e-001F,
1.328098e+000F, -5.267330e-001F,
-4.506960e-001F, 1.164219e+000F,
2.039990e-001F, -2.350950e-001F,
-6.368260e-001F, 6.447090e-001F,
5.365600e-002F, -1.066111e+000F,
8.619300e-001F, 6.297310e-001F,
1.457796e+000F, -2.920600e-002F,
4.995270e-001F, 1.772430e-001F,
9.726480e-001F, -8.559780e-001F,
-1.994340e-001F, 7.065710e-001F,
-1.715660e-001F, -6.882840e-001F,
-8.948840e-001F, -3.329900e-002F,
-9.824900e-002F, -1.620232e+000F,
6.180820e-001F, 1.148526e+000F,
9.970990e-001F, 1.316720e-001F,
1.960000e-003F, 2.398160e-001F,
3.908590e-001F, -6.618330e-001F,
-9.584530e-001F, 1.003040e+000F,
-3.103970e-001F, -2.393120e-001F,
-1.378606e+000F, 7.332300e-002F,
-5.209040e-001F, -1.079022e+000F,
5.744600e-002F, 1.136005e+000F,
7.929290e-001F, -3.105280e-001F,
-4.833840e-001F, 1.907680e-001F,
5.611390e-001F, -1.123197e+000F,
-1.080732e+000F, 4.734210e-001F,
-6.903270e-001F, -5.288710e-001F,
-1.204703e+000F, -4.127670e-001F,
-9.951310e-001F, -9.324500e-001F,
1.013353e+000F, 1.440477e+000F,  /* outer cell codebook (5bits) */
-4.191080e-001F, 5.464140e-001F,
1.753296e+000F, -3.347280e-001F,
3.907540e-001F, -1.273030e-001F,
2.432006e+000F, 1.324332e+000F,
1.270020e-001F, 7.473420e-001F,
2.560863e+000F, 4.058700e-002F,
1.122961e+000F, -6.822220e-001F,
1.715730e-001F, 1.258912e+000F,
-8.331220e-001F, 8.961740e-001F,
1.010889e+000F, -3.706000e-003F,
-6.194860e-001F, -3.574800e-001F,
6.240530e-001F, 1.043717e+000F,
-3.381480e-001F, 1.033946e+000F,
1.592964e+000F, 3.671560e-001F,
-3.277260e-001F, -8.102690e-001F,
6.154660e-001F, 4.464120e-001F,
-1.038918e+000F, -4.223950e-001F,
1.481806e+000F, -1.210138e+000F,
1.303740e-001F, -1.280125e+000F,
1.131675e+000F, 7.737270e-001F,
-1.112170e-001F, -2.844050e-001F,
2.785811e+000F, -1.159111e+000F,
6.932750e-001F, -1.238278e+000F,
-5.160350e-001F, 8.802200e-002F,
-1.070987e+000F, 2.042300e-002F,
9.627600e-002F, -6.967670e-001F,
-8.411670e-001F, -8.819230e-001F,
5.399300e-002F, 2.339030e-001F,
-9.300450e-001F, 4.506030e-001F,
5.894460e-001F, -6.709410e-001F,
-4.156530e-001F, -1.245033e+000F
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\ask2_3.h ===
/******************************************************************************
*                        Voxware Proprietary Material
*                        Copyright 1996, Voxware, Inc
*                            All Rights Reserved
*
*                       DISTRIBUTION PROHIBITED without
*                      written authorization from Voxware
******************************************************************************/
 
/******************************************************************************
* Filename:    ASK2_3.h
*
* Purpose:     codebooks for 2nd ASK pair, which include 5 bits stage 1 codebook,
*              5 bits rotation-scaling matrix, 4 bits stage 2 inner cell codebook
*              and 4 bits stage 2 outer cell codebook. 
*
* $Header:   /export/phobos/pvcs/r_and_d/archives/scaleable/tables/ASK2_3.h_v   1.0   06 Feb 1998 10:12:22   johnp  $
*
******************************************************************************/
#ifndef _ASK2_3_H_
#define _ASK2_3_H_
-2.166900e-001F, -3.710770e-001F,  /* stage 1 codebook (5 bits) */
-6.734050e-001F, -5.024200e-002F,
2.429490e-001F, -4.974030e-001F,
-4.607860e-001F, -2.801770e-001F,
-3.421200e-002F, -2.218770e-001F,
-4.813530e-001F, 1.448540e-001F,
4.197650e-001F, -3.167680e-001F,
-5.832300e-002F, -2.967000e-002F,
9.588000e-003F, -4.222880e-001F,
-4.052140e-001F, -5.458000e-002F,
4.774280e-001F, -5.769300e-001F,
1.252240e-001F, -8.821500e-002F,
3.078860e-001F, -1.498860e-001F,
-2.730990e-001F, 2.554760e-001F,
6.425310e-001F, -3.571430e-001F,
2.932080e-001F, 2.412830e-001F,
-2.301690e-001F, -1.610500e-001F,
-7.211490e-001F, 3.330810e-001F,
1.698280e-001F, -2.881230e-001F,
-2.288990e-001F, 5.685900e-002F,
-5.824100e-002F, 1.943300e-001F,
-5.881060e-001F, 6.096300e-001F,
3.260370e-001F, 3.841500e-002F,
-1.001240e-001F, 4.402140e-001F,
1.113860e-001F, 1.083860e-001F,
-3.981510e-001F, 4.416280e-001F,
5.614500e-001F, -7.579100e-002F,
1.089460e-001F, 3.479780e-001F,
3.626020e-001F, 4.622620e-001F,
-2.159130e-001F, 7.241810e-001F,
5.263550e-001F, 1.950030e-001F,
1.210430e-001F, 6.942010e-001F,
-5.507942e+000F, -9.432233e+000F,/* rotation and scaling matrix  (5bits) */
-8.196916e+000F, -6.115628e-001F,
4.766227e+000F, -9.758161e+000F,
-8.081575e+000F, -4.913933e+000F,
-2.129407e+000F, -1.380996e+001F,
-1.036512e+001F, 3.119184e+000F,
9.584132e+000F, -7.232491e+000F,
-1.237169e+001F, -6.293712e+000F,
2.689830e-001F, -1.184692e+001F,
-1.237100e+001F, -1.666302e+000F,
5.859698e+000F, -7.080932e+000F,
1.141988e+001F, -8.044820e+000F,
1.229765e+001F, -5.986777e+000F,
-9.098209e+000F, 8.511104e+000F,
7.893990e+000F, -4.387778e+000F,
9.630482e+000F, 7.924994e+000F,
-1.072099e+001F, -7.501509e+000F,
-7.063102e+000F, 3.262273e+000F,
6.769702e+000F, -1.148519e+001F,
-1.293456e+001F, 3.212973e+000F,
-3.797188e+000F, 1.266990e+001F,
-5.388318e+000F, 5.585524e+000F,
1.245148e+001F, 1.467083e+000F,
-2.311352e+000F, 1.016229e+001F,
9.590225e+000F, 9.331928e+000F,
-6.621080e+000F, 7.344084e+000F,
9.500374e+000F, -1.282470e+000F,
3.428724e+000F, 1.095149e+001F,
5.418812e+000F, 6.908155e+000F,
-2.159258e+000F, 7.242240e+000F,
8.489594e+000F, 3.145209e+000F,
1.291632e+000F, 7.407719e+000F,
1.269273e+000F, 3.115160e-001F,/* stage 2: inner cell codebook (4 bits) */
1.204180e-001F, 1.185055e+000F,
1.263555e+000F, -4.734160e-001F,
-5.913970e-001F, -1.301750e-001F,
8.322400e-001F, 9.805060e-001F,
-5.889530e-001F, 1.017518e+000F,
6.193280e-001F, -2.728970e-001F,
-1.158240e+000F, -2.262230e-001F,
4.617510e-001F, 4.460220e-001F,
-2.633000e-001F, 4.985650e-001F,
6.436600e-001F, -1.025385e+000F,
-9.717100e-002F, -6.435230e-001F,
1.214800e-002F, -4.388500e-002F,
-1.025943e+000F, 4.478290e-001F,
-1.016160e-001F, -1.235394e+000F,
-7.727690e-001F, -8.420660e-001F,
-4.254000e-002F, 1.069669e+000F,/* stage 2: outer cell codebook (4 bits) */
-2.695590e-001F, 3.171820e-001F,
1.244445e+000F, 2.177800e-001F,
1.758824e+000F, -6.903490e-001F,
-9.421400e-001F, 2.290820e-001F,
-8.208730e-001F, -3.271190e-001F,
-7.758800e-002F, -3.039150e-001F,
8.794400e-002F, -1.118762e+000F,
6.912410e-001F, 1.188970e+000F,
4.232820e-001F, 3.916830e-001F,
1.724002e+000F, 1.123967e+000F,
2.884475e+000F, -9.557000e-003F,
-6.694170e-001F, 8.215700e-001F,
-5.424410e-001F, -8.449980e-001F,
6.350820e-001F, -4.417170e-001F,
9.167120e-001F, -1.215032e+000F
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\ask6_7.h ===
/******************************************************************************
*                        Voxware Proprietary Material
*                        Copyright 1996, Voxware, Inc
*                            All Rights Reserved
*
*                       DISTRIBUTION PROHIBITED without
*                      written authorization from Voxware
******************************************************************************/
 
/******************************************************************************
* Filename:    ASK6_7.h
*
* Purpose:     codebooks for 4th ASK pair, which include 5 bits stage 1 codebook,
*              5 bits rotation-scaling matrix, 2 bits stage 2 inner cell codebook
*              and 2 bits stage 2 outer cell codebook. 
*
* $Header:   /export/phobos/pvcs/r_and_d/archives/scaleable/tables/ASK6_7.h_v   1.0   06 Feb 1998 10:12:26   johnp  $
*
******************************************************************************/
#ifndef _ASK6_7_H_
#define _ASK6_7_H_
-2.495900e-002F, 3.662900e-002F,/* stage 1 codebook (5bits) */
-2.270260e-001F, 4.855760e-001F,
3.271550e-001F, -1.207020e-001F,
6.101300e-002F, 3.264910e-001F,
2.390530e-001F, -2.688820e-001F,
1.599500e-002F, 1.742840e-001F,
4.526200e-001F, -2.904730e-001F,
2.749670e-001F, 4.621100e-002F,
-4.680240e-001F, -2.880560e-001F,
-4.511370e-001F, 1.363840e-001F,
7.289900e-002F, -2.487450e-001F,
-2.703220e-001F, 2.869500e-002F,
-2.215680e-001F, -3.765620e-001F,
-6.889980e-001F, -4.991600e-002F,
-7.276000e-003F, -4.128180e-001F,
-1.269780e-001F, -6.122000e-002F,
1.143030e-001F, 4.321800e-002F,
3.668000e-003F, 5.135820e-001F,
3.848370e-001F, 2.231430e-001F,
2.454070e-001F, 3.955430e-001F,
1.690450e-001F, -1.065010e-001F,
-1.087780e-001F, 2.848100e-001F,
4.815810e-001F, -5.475000e-003F,
1.869980e-001F, 2.036600e-001F,
-2.521450e-001F, -1.582070e-001F,
-5.005390e-001F, 4.249370e-001F,
2.434100e-002F, -9.745400e-002F,
-2.797220e-001F, 2.496170e-001F,
-8.229600e-002F, -2.208130e-001F,
-4.291660e-001F, -7.525800e-002F,
2.037630e-001F, -4.457730e-001F,
-1.409590e-001F, 1.136690e-001F,
-1.125884e+001F, 1.652310e+001F,  /* rotation and scaling codebook (5 bits) */
-4.247031e+000F, 9.083789e+000F,
1.448902e+001F, -5.345642e+000F,
2.893914e+000F, 1.548583e+001F,
1.017476e+001F, -1.144437e+001F,
1.586438e+000F, 1.728608e+001F,
8.360306e+000F, -5.365302e+000F,
1.513238e+001F, 2.543151e+000F,
-8.363366e+000F, -5.147424e+000F,
-1.097256e+001F, 3.317133e+000F,
4.619695e+000F, -1.576326e+001F,
-1.552030e+001F, 1.647499e+000F,
-5.399458e+000F, -9.176553e+000F,
-8.116620e+000F, -5.880267e-001F,
-2.206840e-001F, -1.252094e+001F,
-1.643840e+001F, -7.925459e+000F,
1.637029e+001F, 6.189611e+000F,
7.604300e-002F, 1.064730e+001F,
1.026061e+001F, 5.949486e+000F,
6.133957e+000F, 9.886612e+000F,
1.449876e+001F, -9.134448e+000F,
-5.456295e+000F, 1.428604e+001F,
1.103346e+001F, -1.254372e-001F,
1.056891e+001F, 1.151063e+001F,
-1.282550e+001F, -8.047291e+000F,
-5.863376e+000F, 4.977765e+000F,
4.500559e+000F, -1.801888e+001F,
-9.832911e+000F, 8.774646e+000F,
-5.718499e+000F, -1.534362e+001F,
-1.273499e+001F, -2.233191e+000F,
4.713946e+000F, -1.031271e+001F,
-1.338976e+001F, 1.079747e+001F,
-7.781290e-001F, -2.476610e-001F,  /* stage 2 inner cell codebook (2 bits) */
-2.267920e-001F, 8.665780e-001F,
2.531220e-001F, -8.855370e-001F,
9.647740e-001F, 2.386200e-001F,
-3.206020e-001F, 6.348380e-001F,   /* stage 2 outer cell codebook (2 bits) */
-5.766810e-001F, -4.480670e-001F,
1.151865e+000F, 7.990510e-001F,
7.474910e-001F, -8.211200e-001F
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\ask6_7ix.h ===
/******************************************************************************
*                        Voxware Proprietary Material
*                        Copyright 1996, Voxware, Inc
*                            All Rights Reserved
*
*                       DISTRIBUTION PROHIBITED without
*                      written authorization from Voxware
******************************************************************************/
 
/******************************************************************************
* Filename:    ASK6_7ix.h
*
* Purpose:     outer cell indices for 4th ASK pair.
*
* $Header:   /export/phobos/pvcs/r_and_d/archives/scaleable/tables/ASK6_7ix.h_v   1.0   06 Feb 1998 10:12:26   johnp  $
*
******************************************************************************/
#ifndef _ASK6_7IX_H_
#define _ASK6_7IX_H_
1,
6,
8,
12,
13,
14,
17,
18,
19,
22,
25,
30,
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\ask2_3ix.h ===
/******************************************************************************
*                        Voxware Proprietary Material
*                        Copyright 1996, Voxware, Inc
*                            All Rights Reserved
*
*                       DISTRIBUTION PROHIBITED without
*                      written authorization from Voxware
******************************************************************************/
 
/******************************************************************************
* Filename:    ASK2_3ix.h
*
* Purpose:     outer cell indices for 2nd ASK pair.
*
* $Header:   /export/phobos/pvcs/r_and_d/archives/scaleable/tables/ASK2_3ix.h_v   1.0   06 Feb 1998 10:12:24   johnp  $
*
******************************************************************************/
#ifndef _ASK2_3IX_H_
#define _ASK2_3IX_H_
0,
1,
2,
3,
8,
10,
14,
17,
21,
26,
28,
29,
30,
31,
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\ask4_5ix.h ===
/******************************************************************************
*                        Voxware Proprietary Material
*                        Copyright 1996, Voxware, Inc
*                            All Rights Reserved
*
*                       DISTRIBUTION PROHIBITED without
*                      written authorization from Voxware
******************************************************************************/
 
/******************************************************************************
* Filename:    ASK4_5ix.h
*
* Purpose:     outer cell indices for 3rd ASK pair.
*
* $Header:   /export/phobos/pvcs/r_and_d/archives/scaleable/tables/ASK4_5ix.h_v   1.0   06 Feb 1998 10:12:26   johnp  $
*
******************************************************************************/
#ifndef _ASK4_5IX_H_
#define _ASK4_5IX_H_
0,
2,
3,
4,
10,
11,
20,
21,
25,
27,
28,
29,
31,
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\ask4_5.h ===
/******************************************************************************
*                        Voxware Proprietary Material
*                        Copyright 1996, Voxware, Inc
*                            All Rights Reserved
*
*                       DISTRIBUTION PROHIBITED without
*                      written authorization from Voxware
******************************************************************************/
 
/******************************************************************************
* Filename:    ASK4_5.h
*
* Purpose:     codebooks for 3rd ASK pair, which include 5 bits stage 1 codebook,
*              5 bits rotation-scaling matrix, 3 bits stage 2 inner cell codebook
*              and 3 bits stage 2 outer cell codebook. 
*
* $Header:   /export/phobos/pvcs/r_and_d/archives/scaleable/tables/ASK4_5.h_v   1.0   06 Feb 1998 10:12:24   johnp  $
*
******************************************************************************/
#ifndef _ASK4_5_H_
#define _ASK4_5_H_
5.729110e-001F, -4.441100e-002F,  /* stage 1 codebook (5 bits) */
1.910400e-002F, -2.647900e-002F,
4.685990e-001F, 2.309660e-001F,
5.517000e-002F, 4.823500e-001F,
5.332150e-001F, -3.284490e-001F,
3.353600e-002F, -3.657360e-001F,
3.785420e-001F, 5.252600e-002F,
-4.780900e-002F, 1.256810e-001F,
2.139100e-001F, -8.139000e-003F,
-2.049380e-001F, 1.182560e-001F,
2.738800e-001F, 3.836320e-001F,
-2.139930e-001F, 5.094260e-001F,
3.842780e-001F, -1.419810e-001F,
-1.886540e-001F, -2.896650e-001F,
2.469480e-001F, 1.921830e-001F,
-1.021440e-001F, 3.089880e-001F,
2.625970e-001F, -3.422390e-001F,
-3.278220e-001F, -1.597070e-001F,
1.065600e-001F, 1.145750e-001F,
-3.216730e-001F, 2.469620e-001F,
4.053750e-001F, -5.691150e-001F,
-1.693250e-001F, -5.111600e-001F,
1.608820e-001F, -1.736240e-001F,
-3.708500e-001F, 2.832000e-002F,
-3.940600e-002F, -1.737460e-001F,
-5.268830e-001F, -1.447340e-001F,
7.170900e-002F, 2.809880e-001F,
-4.842760e-001F, 3.875650e-001F,
1.218140e-001F, -5.766810e-001F,
-4.076600e-001F, -3.864260e-001F,
-1.695070e-001F, -5.300600e-002F,
-5.727540e-001F, 1.321520e-001F, 
9.892215e+000F, -7.668262e-001F, /* rotation and scaling matrix (5 bits) */
9.420018e+000F, -1.305657e+001F,
9.006369e+000F, 4.439115e+000F,
1.240516e+000F, 1.084581e+001F,
7.871369e+000F, -4.848594e+000F,
1.123737e+000F, -1.225522e+001F,
1.457933e+001F, 2.023010e+000F,
-5.787798e+000F, 1.521505e+001F,
1.536391e+001F, -5.845768e-001F,
-1.343288e+001F, 7.751216e+000F,
6.346276e+000F, 8.889421e+000F,
-3.562309e+000F, 8.480338e+000F,
1.215845e+001F, -4.492239e+000F,
-7.172324e+000F, -1.101260e+001F,
1.176538e+001F, 9.156204e+000F,
-4.305764e+000F, 1.302504e+001F,
7.499327e+000F, -9.773768e+000F,
-1.245941e+001F, -6.069924e+000F,
1.161812e+001F, 1.249198e+001F,
-1.017811e+001F, 7.814164e+000F,
5.027794e+000F, -7.058632e+000F,
-3.065886e+000F, -9.255326e+000F,
9.596067e+000F, -1.035608e+001F,
-1.334698e+001F, 1.019243e+000F,
-3.309622e+000F, -1.459254e+001F,
-1.013671e+001F, -2.784540e+000F,
3.672817e+000F, 1.439174e+001F,
-7.178088e+000F, 5.744608e+000F,
1.881737e+000F, -8.908352e+000F,
-7.226082e+000F, -6.849693e+000F,
-1.412621e+001F, -4.417363e+000F,
-9.500831e+000F, 2.192134e+000F, 
4.271000e-002F, 1.613100e-002F,    /* stage 2 inner cell codebook (3 bits) */
4.442900e-002F, 1.100067e+000F,
1.104499e+000F, -2.301630e-001F,
8.749920e-001F, 7.274760e-001F,
-9.451950e-001F, -3.002340e-001F,
-7.892750e-001F, 6.294330e-001F,
5.545670e-001F, -1.000008e+000F,
-3.674820e-001F, -9.551640e-001F,
-4.612130e-001F, -7.579180e-001F,  /* stage 2 inner cell codebook (3 bits) */
-7.673170e-001F, -2.748900e-002F,
4.837350e-001F, -1.048276e+000F,
-5.124220e-001F, 7.374370e-001F,
3.683950e-001F, -1.879300e-002F,
3.828040e-001F, 1.010899e+000F,
1.777711e+000F, -7.106510e-001F,
1.652714e+000F, 8.651050e-001F
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\ask8_9.h ===
/******************************************************************************
*                        Voxware Proprietary Material
*                        Copyright 1996, Voxware, Inc
*                            All Rights Reserved
*
*                       DISTRIBUTION PROHIBITED without
*                      written authorization from Voxware
******************************************************************************/
 
/******************************************************************************
* Filename:    ASK8_9.h
*
* Purpose:     5-bits codebook for 5th ASK pair
*
* $Header:   /export/phobos/pvcs/r_and_d/archives/scaleable/tables/ASK8_9.h_v   1.0   06 Feb 1998 10:12:28   johnp  $
*
******************************************************************************/
#ifndef _ASK8_9_H_
#define _ASK8_9_H_
-0.086479F, -0.062940F,
0.346698F, -0.375744F,
0.210708F, 0.007463F,
-0.348723F, 0.017477F,
0.088825F, -0.361759F,
0.366071F, 0.017970F,
-0.172338F, -0.153423F,
0.070757F, -0.215146F,
-0.112483F, 0.051040F,
-0.274559F, 0.360988F,
-0.011665F, 0.115516F,
-0.322948F, -0.153702F,
0.234016F, 0.143996F,
0.096529F, 0.174869F,
0.005433F, 0.010672F,
-0.006846F, 0.240376F,
-0.092616F, -0.300902F,
0.263553F, -0.105529F,
0.215358F, -0.240165F,
-0.051147F, -0.181413F,
-0.223884F, 0.104488F,
-0.206181F, 0.230456F,
0.390324F, -0.189086F,
0.025568F, -0.103677F,
0.134806F, 0.338967F,
-0.107601F, 0.171985F,
0.101838F, -0.034283F,
-0.365410F, 0.190889F,
-0.214674F, -0.028042F,
0.152000F, -0.125089F,
-0.102242F, 0.327971F,
0.105531F, 0.069058F,
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\askcbsc3.h ===
/******************************************************************************
*                        Voxware Proprietary Material
*                        Copyright 1996, Voxware, Inc
*                            All Rights Reserved
*
*                       DISTRIBUTION PROHIBITED without
*                      written authorization from Voxware
******************************************************************************/
 
/******************************************************************************
* Filename:    ASKCBSC3.h
*
* Purpose:     structures and tables for MSVQPred.c
*
* Functions:   
*
* Author/Date:    Wei Wang, 02/09/98
*******************************************************************************
*
* Modifications:  
*
* Comments: 
*
* Concerns:
*
* $Header:   /export/phobos/pvcs/r_and_d/archives/scaleable/quan/ASKCBSC3.h_v   1.0   06 Feb 1998 10:11:26   johnp  $
*
******************************************************************************/

#ifndef _ASKCBSC3_H_
#define _ASKCBSC3_H_

/*************************************************************
  The structure for rotation-scaling 2 stages MSVQ codebook
  ************************************************************/
typedef struct {
  const int iStage1Size;
  const float *pfStage1CB;
  const float *pfRotScaleCB;

  const int iStage2Size;
  const float *pfStage2InCellCB;
  const float *pfStage2OutCellCB;

  const int iNumOfOutCell;
  const int *piIndexOfStage2OutCell;
} RS2StageVQ_MBlk;


/*************************************************************
  The structure for VQ codebook
  ************************************************************/
typedef struct {
  const int iCodebookSize;
  const float *fCodeBook;
} VQ2_MBlk;



/*--------------------------------------------
  Number of sub vectors
--------------------------------------------*/
#define SUB_DIMENSION  2
#define SUB_VECTORS (LPC_ORDER/SUB_DIMENSION)
#define MSVQ_PAIRS  4

/*--------------------------------------------------
  Number of candidates
  --------------------------------------------------*/
#define NUMCAND  2


/******************************************************************************
*
*  These numbers are hard wired for 12th order. 
*
******************************************************************************/

/*************************************************************
  Means 
  ************************************************************/
/* Voiced ASK Means */
static const float tab_ASK12_V_Means[] = {
#include "MASK12V.h"
};
/* Unvoiced ASK Means */
static const float tab_ASK12_UV_Means[] = {
#include "MASK12UV.h"
};

/*************************************************************
  Predictor 
  ************************************************************/
/* Voiced Codebook Predictors (2+4+...+10)*2 = 60 words */ 
static const float tab_ASK12_V_Predictors[] = {
#include "PASK12V.h"
};

static const float *ptab_ASK12_V_Pred[SUB_VECTORS] = {
  NULL,
  &(tab_ASK12_V_Predictors[0]), &(tab_ASK12_V_Predictors[2*2]),
  &(tab_ASK12_V_Predictors[(2+4)*2]), &(tab_ASK12_V_Predictors[(2+4+6)*2]),
  &(tab_ASK12_V_Predictors[(2+4+6+8)*2])
};

/* Unvoiced Codebook Predictors (2+4+...+10)*2 = 60 words */ 
static const float tab_ASK12_UV_Predictors[] = {
#include "PASK12UV.h"
};

static const float *ptab_ASK12_UV_Pred[SUB_VECTORS] = {
  NULL,
  &(tab_ASK12_UV_Predictors[0]), &(tab_ASK12_UV_Predictors[2*2]),
  &(tab_ASK12_UV_Predictors[(2+4)*2]), &(tab_ASK12_UV_Predictors[(2+4+6)*2]),
  &(tab_ASK12_UV_Predictors[(2+4+6+8)*2])
};


/*************************************************************
  1st pair (ASK[0-1]) codebooks -- voiced
  (1) Stage 1 codebook  (5bits)
  (2) Stage 1 rotation and scaling codebook (5bits)
  (3) Stage 2 inner cell codebook (5bits)
  (4) Stage 2 outter cell codebook (5bits)
  ************************************************************/
static const float tab_ASK0_1_V_CB[] = {
#include "ASK0_1V.h"
};

static const int tab_ASK0_1_V_OutCellIndex[] = {
#include "ASK0_1Vi.h"
};

static const RS2StageVQ_MBlk ASK0_1_V_mblk = {
  (1<<STAGE1_BITS_ASKS_0_1_SC36), 
  &(tab_ASK0_1_V_CB[0]),
  &(tab_ASK0_1_V_CB[SUB_DIMENSION*(1<<STAGE1_BITS_ASKS_0_1_SC36)]),
  (1<<STAGE2_BITS_ASKS_0_1_SC36), 
  &(tab_ASK0_1_V_CB[SUB_DIMENSION*(2*(1<<STAGE1_BITS_ASKS_0_1_SC36))]),
  &(tab_ASK0_1_V_CB[SUB_DIMENSION*(2*(1<<STAGE1_BITS_ASKS_0_1_SC36)+(1<<STAGE2_BITS_ASKS_0_1_SC36))]),
  sizeof(tab_ASK0_1_V_OutCellIndex)/sizeof(int),
  tab_ASK0_1_V_OutCellIndex
};


/*************************************************************
  1st pair (ASK[0-1]) codebooks -- unvoiced
  (1) Stage 1 codebook  (5bits)
  (2) Stage 1 rotation and scaling codebook (5bits)
  (3) Stage 2 inner cell codebook (5bits)
  (4) Stage 2 outter cell codebook (5bits)
  ************************************************************/
static const float tab_ASK0_1_UV_CB[] = {
#include "ASK0_1U.h"
};

static const int tab_ASK0_1_UV_OutCellIndex[] = {
#include "ASK0_1Ui.h"
};

static const RS2StageVQ_MBlk ASK0_1_UV_mblk = {
  (1<<STAGE1_BITS_ASKS_0_1_SC36), 
  &(tab_ASK0_1_UV_CB[0]),
  &(tab_ASK0_1_UV_CB[SUB_DIMENSION*(1<<STAGE1_BITS_ASKS_0_1_SC36)]),
  (1<<STAGE2_BITS_ASKS_0_1_SC36), 
  &(tab_ASK0_1_UV_CB[SUB_DIMENSION*(2*(1<<STAGE1_BITS_ASKS_0_1_SC36))]),
  &(tab_ASK0_1_UV_CB[SUB_DIMENSION*(2*(1<<STAGE1_BITS_ASKS_0_1_SC36)+(1<<STAGE2_BITS_ASKS_0_1_SC36))]),
  sizeof(tab_ASK0_1_UV_OutCellIndex)/sizeof(int),
  tab_ASK0_1_UV_OutCellIndex
};


/*************************************************************
  2nd pair (ASK[2-3]) codebooks
  (1) Stage 1 codebook  (5bits)
  (2) Stage 1 rotation and scaling codebook (5bits)
  (3) Stage 2 inner cell codebook (4bits)
  (4) Stage 2 outter cell codebook (4bits)
  ************************************************************/
static const float tab_ASK2_3_CB[] = {
#include "ASK2_3.h"
};

static const int tab_ASK2_3_OutCellIndex[] = {
#include "ASK2_3ix.h"
};

static const RS2StageVQ_MBlk ASK2_3_mblk = {
  (1<<STAGE1_BITS_ASKS_2_3_SC36), 
  &(tab_ASK2_3_CB[0]),
  &(tab_ASK2_3_CB[SUB_DIMENSION*(1<<STAGE1_BITS_ASKS_2_3_SC36)]),
  (1<<STAGE2_BITS_ASKS_2_3_SC36), 
  &(tab_ASK2_3_CB[SUB_DIMENSION*(2*(1<<STAGE1_BITS_ASKS_2_3_SC36))]),
  &(tab_ASK2_3_CB[SUB_DIMENSION*(2*(1<<STAGE1_BITS_ASKS_2_3_SC36)+(1<<STAGE2_BITS_ASKS_2_3_SC36))]),
  sizeof(tab_ASK2_3_OutCellIndex)/sizeof(int),
  tab_ASK2_3_OutCellIndex
};


/*************************************************************
  3rd pair (ASK[4-5]) codebooks
  (1) Stage 1 codebook  (5bits)
  (2) Stage 1 rotation and scaling codebook (5bits)
  (3) Stage 2 inner cell codebook (3bits)
  (4) Stage 2 outter cell codebook (3bits)
  ************************************************************/
static const float tab_ASK4_5_CB[] = {
#include "ASK4_5.h"
};

static const int tab_ASK4_5_OutCellIndex[] = {
#include "ASK4_5ix.h"
};

static const RS2StageVQ_MBlk ASK4_5_mblk = {
  (1<<STAGE1_BITS_ASKS_4_5_SC36), 
  &(tab_ASK4_5_CB[0]),
  &(tab_ASK4_5_CB[SUB_DIMENSION*(1<<STAGE1_BITS_ASKS_4_5_SC36)]),
  (1<<STAGE2_BITS_ASKS_4_5_SC36), 
  &(tab_ASK4_5_CB[SUB_DIMENSION*(2*(1<<STAGE1_BITS_ASKS_4_5_SC36))]),
  &(tab_ASK4_5_CB[SUB_DIMENSION*(2*(1<<STAGE1_BITS_ASKS_4_5_SC36)+(1<<STAGE2_BITS_ASKS_4_5_SC36))]),
  sizeof(tab_ASK4_5_OutCellIndex)/sizeof(int),
  tab_ASK4_5_OutCellIndex
};

/*************************************************************
  4th pair (ASK[6-7]) codebooks
  (1) Stage 1 codebook  (5bits)
  (2) Stage 1 rotation and scaling codebook (5bits)
  (3) Stage 2 inner cell codebook (2bits)
  (4) Stage 2 outter cell codebook (2bits)
  ************************************************************/
static const float tab_ASK6_7_CB[] = {
#include "ASK6_7.h"
};

static const int tab_ASK6_7_OutCellIndex[] = {
#include "ASK6_7ix.h"
};

static const RS2StageVQ_MBlk ASK6_7_mblk = {
  (1<<STAGE1_BITS_ASKS_6_7_SC36), 
  &(tab_ASK6_7_CB[0]),
  &(tab_ASK6_7_CB[SUB_DIMENSION*(1<<STAGE1_BITS_ASKS_6_7_SC36)]),
  (1<<STAGE2_BITS_ASKS_6_7_SC36), 
  &(tab_ASK6_7_CB[SUB_DIMENSION*(2*(1<<STAGE1_BITS_ASKS_6_7_SC36))]),
  &(tab_ASK6_7_CB[SUB_DIMENSION*(2*(1<<STAGE1_BITS_ASKS_6_7_SC36)+(1<<STAGE2_BITS_ASKS_6_7_SC36))]),
  sizeof(tab_ASK6_7_OutCellIndex)/sizeof(int),
  tab_ASK6_7_OutCellIndex
};



/*************************************************************
  Last 2 pairs (8-9, 10-11), single stage 5 bits VQ 
  ************************************************************/
static const float tab_ASK8_9_CB[SUB_DIMENSION*(1<<STAGE1_BITS_ASKS_8_9_SC36)]={
#include "ASK8_9.h"
};
static const float tab_ASK10_11_CB[SUB_DIMENSION*(1<<STAGE1_BITS_ASKS_10_11_SC36)]={
#include "ASK10_11.h"
};


static const VQ2_MBlk ASK8_9_mblk = {
  (1<<STAGE1_BITS_ASKS_8_9_SC36), 
  tab_ASK8_9_CB 
};

static const VQ2_MBlk ASK10_11_mblk = {
  (1<<STAGE1_BITS_ASKS_10_11_SC36), 
  tab_ASK10_11_CB 
};

static const VQ2_MBlk *pASK8_11_VQ[2] = {
  &ASK8_9_mblk,
  &ASK10_11_mblk
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\asktoenv.c ===
/******************************************************************************
*                        Voxware Proprietary Material                         *
*                        Copyright 1996, Voxware, Inc                         *
*                            All Rights Reserved                              *
*                                                                             *
*                       DISTRIBUTION PROHIBITED without                       *
*                      written authorization from Voxware                     *
******************************************************************************/

/******************************************************************************
* Filename:       AskToEnv.c
*                                                                              
* Purpose:        Compute magnitude and phase envelopes from arcsin of
*                   reflection coefficients.  
*                                                                              
* Functions:      VoxAskToEnv()
*                                                                              
* Author/Date:    Bob Dunn 1/98
*******************************************************************************
* Modifications:                                                               
*                                                                              
* Comments:                                                                    
* 
* Concerns:
*
* $Header:   /export/phobos/pvcs/r_and_d/archives/scaleable/decode/AskToEnv.c_v   1.8   10 Apr 1998 16:47:34   bobd  $
******************************************************************************/
#include <stdlib.h>
#include <assert.h>
#include "VoxMem.h"
#include "codec.h"
#include "vLibTran.h"
#include "PostFilt.h"
#include "AskToEnv.h"

#include "xvocver.h"

/*******************************************************************************
*
* Function:  VoxAskToEnv()
*
* Action:    Get the spectrum envelope from ASKs. 
*
* Input:    *pfASK -- input ASKs
*           fLog2Gain -- Log2 of residuel gain
*           pfEnv -- pointer to the output envelope amplitudes
*           pfPhase -- pointer to the output phases
*
* Output:   pfEnv -- output envelope amplitudes
*           pfPhase -- the output phases
*
* Globals:   none
*
* Return:    void
********************************************************************************
*
* Modifications:
*
* Comments:
*
* Concerns/TBD:
*******************************************************************************/

void VoxAskToEnv( STACK_R 
                  const float *pfASK, 
                  const float  fLog2Gain, 
                  float       *pfEnv, 
                  float       *pfPhase
                 )
{
STACK_INIT
   float  fCS[ORDER_CEPSTRAL];
   float  fSW[CSENV_NFFT+2];
   float  fKS[LPC_ORDER];
   float  fAS[LPC_ORDER+1];
STACK_INIT_END

   STACK_ATTACH(float *, fCS)
   STACK_ATTACH(float *, fSW)
   STACK_ATTACH(float *, fKS)
   STACK_ATTACH(float *, fAS)

   STACK_START

   assert((pfASK != NULL) && (pfEnv != NULL) && (pfPhase != NULL));

   /*-------------------------------------------------------------------
     Compute the predictor coefficients from the ASKs
   -------------------------------------------------------------------*/
   ASK2K(LPC_ORDER, pfASK, fKS );
   VoxKsToAs(fKS, fAS, LPC_ORDER);
 
   /*-------------------------------------------------------------------
     Compute amplitude and phase envelopes from cepstral coefficients
   -------------------------------------------------------------------*/
   VoxAsToCs(fLog2Gain, fAS, LPC_ORDER, fCS, ORDER_CEPSTRAL);
 
   VoxCsToEnv(fCS, ORDER_CEPSTRAL, CSENV_FFT_ORDER, fSW);

   VoxDemultiplex(fSW,  pfEnv, pfPhase, CSENV_NFFT_2);

   /*-------------------------------------------------------------------
     Postfilter the envelope.
   -------------------------------------------------------------------*/
   PostFilter(pfEnv, fLog2Gain, fKS);

   STACK_END
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\bk1d_3bn.h ===
8.0805480957031250e+01F, 
1.4046551513671875e+02F, 
1.9094317626953125e+02F, 
2.4089358520507812e+02F, 
2.9791757202148438e+02F, 
3.6415841674804688e+02F, 
4.4456192016601562e+02F, 
5.6694146728515625e+02F
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\asktoenv.h ===
/******************************************************************************
*                        Voxware Proprietary Material                         *
*                        Copyright 1996, Voxware, Inc                         *
*                            All Rights Reserved                              *
*                                                                             *
*                       DISTRIBUTION PROHIBITED without                       *
*                      written authorization from Voxware                     *
******************************************************************************/

/******************************************************************************
* Filename:       AskToEnv.h
*                                                                              
* Purpose:        Compute magnitude and phase envelopes from arcsin of
*                   reflection coefficients. 
*                                                                              
* Functions:      VoxAskToEnv()
*                                                                              
* Author/Date:    Bob Dunn 1/98
*******************************************************************************
* Modifications:                                                               
*                                                                              
* Comments:                                                                    
* 
* Concerns:
*
* $Header:   /export/phobos/pvcs/r_and_d/archives/scaleable/decode/AskToEnv.h_v   1.4   10 Apr 1998 11:46:34   weiwang  $
******************************************************************************/
#ifndef ASKTOENV_H
#define ASKTOENV_H

/*******************************************************************************
*
* Function:  VoxAskToEnv()
*
* Action:    Get the spectrum envelope from ASKs.
*
* Input:    *pfASK -- input ASKs
*           fLog2Gain -- Log2 of residuel gain
*           pfEnv -- pointer to the output envelope amplitudes
*           pfPhase -- pointer to the output phases
*
* Output:   pfEnv -- output envelope amplitudes
*           pfPhase -- the output phases
*
* Globals:   none
*
* Return:    void
*******************************************************************************/

void VoxAskToEnv( STACK_R 
                  const float *pfASK, 
                  const float  fLog2Gain, 
                  float       *pfEnv, 
                  float       *pfPhase
                 );

#endif /* ASKTOENV_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\bandexpd.c ===
/*******************************************************************************
*                        Voxware Proprietary Material                          *
*                        Copyright 1996, Voxware Inc.                          *
*                        All Rights Reserved                                   *
*                                                                              *
*                        DISTRIBUTION PROHIBITED without                       *
*                        written authorization from Voxware.                   *
*******************************************************************************/

/*******************************************************************************
*
* Filename: BandExpd.c
*
* Purpose:  expand the bandwidth of LPC poles.
*
* Author:   Ilan
*
* Date:     Oct. 07, 1996.
*
* Modified by Wei so that the input and output share the same array.
*
* $Header:   /export/phobos/pvcs/pvcsproj/voxlib.prj/BandExpd.c_v   1.8   02 Mar 1998 17:40:56   weiwang  $
*******************************************************************************/

#include "vLibSpch.h"

#include "xvocver.h"

/*******************************************************************************
*
* Function: BandExpand()
*
* Input:    pIn:            pointer of the input LPC coefficients.
*           iLPCOrder:      order of the LPC coefficients.
*           fExpandCoeff:   expandion coefficient.
*
* Output:   pOut:           pointer of the output LPC coefficients.
*
* Globals:  none
*
* Return:   none
*******************************************************************************
*
* Implementation/Detailed Description:
*
* References:
*******************************************************************************
*
* Modifications:
*
* Comments:
*           In place and out of place operation are supported.
*
*           We define A(z) as:
*
*               A(z) = 1 + SUM(k=1...p) a_k * z^(-k)
*
*           with the format:
*
*              pIn[0] = 1.0
*              pIn[1] = a_1
*              pIn[2] = a_2
*                :       :
*                :       :
*              pIn[p] = a_p
*
* Concerns/TBD:
******************************************************************************/
void BandExpand( const float *pIn, 
                 float       *pOut, 
                 int          iLPCOrder,
                 float       fExpandCoeff
               )
{
   int   i;
   float dMultiplier;
 
   dMultiplier = 1.0F;
   for(i=0;i<=iLPCOrder;i++) 
   {
     *pOut++ = (float)(*pIn++ * dMultiplier);
     dMultiplier *= (float)fExpandCoeff;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\autocor.c ===
/*******************************************************************************
*                        Voxware Proprietary Material                          *
*                        Copyright 1996, Voxware, Inc                          *
*                            All Rights Reserved                               *
*                                                                              *
*                       DISTRIBUTION PROHIBITED without                        *
*                      written authorization from Voxware                      *
*******************************************************************************/
 
/*******************************************************************************
* Filename:       AutoCor.c
*
* Purpose:        Compute autocorrelation sequence
*
* Functions:      AutoCor()
*
* Author/Date:
********************************************************************************
* $Header:   /export/phobos/pvcs/pvcsproj/voxlib.prj/autocor.c_v   1.10   02 Mar 1998 17:41:02   weiwang  $
*******************************************************************************/

/*******************************************************************************
*
* Function:  AutoCor()
*
* Action:    Compute autocorrelation sequence.
*
* Input:     int          iOrder   -> number of autocorrelation samples to 
*                                       compute
*            const float *pcfVecIn -> input sequence
*            int          iLength  -> length of input sequence
*
* Output:    float *pfVecOut       -> the scaled vector
*
* Globals:   none
*
* Return:    void
********************************************************************************
*
* Modifications:
*
* Comments:
*
* Concerns/TBD:
*******************************************************************************/
#include <assert.h>

#include "vLibVec.h"

#include "xvocver.h"

void AutoCor( int iOrder, const float *pcfVecIn, int iLength, float *pfVecOut)
{
    const float *pcfData;

    assert( iOrder > 0 );
    assert( pcfVecIn );
    assert( pfVecOut );

    for(pcfData=pcfVecIn;iOrder > 0;pcfData++, iLength--, iOrder--) 
       *pfVecOut++= DotProd(pcfVecIn, pcfData, iLength);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\bitpackc.c ===
/******************************************************************************
*                        Voxware Proprietary Material
*                        Copyright 1996, Voxware, Inc
*                            All Rights Reserved
*
*                       DISTRIBUTION PROHIBITED without
*                      written authorization from Voxware
******************************************************************************/
 
/******************************************************************************
* Filename:      BitPackC.c
*
* Purpose:       Defines Circular buffer bit packing and unpacking routines.
*
* Functions:     BitPackCBuffer
*                BitUnPackCBuffer
*
* Author/Date:   Epiphany Vera
*******************************************************************************
*
* Modifications:
* (Oct 25, '96)
*    Created from original linear buffer packing routines written by Lee
*    Stewart and modified by Wei Wang and Ilan Berci. Ref: BitPack.c.  (E.V)
* (Aug 13, '97)
*    Added the compiler define PACK_BITS_PER_CHAR to allow DSP platforms to
*    use all bits in a char in cases whereby sizeof(char) > 8 bits.    (E.V)
*
* Comments:
*
* Concerns:
*
* $Header:   /export/phobos/pvcs/pvcsproj/voxlib.prj/BitPackC.c_v   1.2   02 Mar 1998 16:25:34   weiwang  $
*
******************************************************************************/

#include <assert.h>
#include "vLibPack.h"

#include "xvocver.h"


/******************************************************************************
*
* Function:  BitPackCBuffer
*
* Action:    Packs a bitstream into a circular bitstream buffer.
*
* Input:     CBuffer -- The circular buffer into which data is to be packed. 
*                       The data struct is defined in BitPackC.h. This routine
*                       only writes to the buffer, thus the read offsets are 
*                       not needed. 
*            cElement -- The char containing the data
*            cDataWidth -- The number of bits to be written into the buffer.
*
* Output:    CBuffer -- The circular buffer, the write-byte-offset and write-
*                       bit-offset are updated.
*
* Globals:   none
*
* Return:    void
*******************************************************************************
*
* Implementation/Detailed Description:
*           The algorithm is written to write at most 8 bits, which are 
*           all from a single byte, into the buffer. The diagrams below 
*           illustrate the addition of 7 bits into the buffer. The symbol |
*           represents a byte boundary, symbol ` represents a bit boundary,
*           symbol x represents a valid bit and a space represents a vacant
*           bit position. The data to be written into the buffer looks like:
*           | `x`x`x`x`x`x`x|                                               
*           The circular buffer size is 4 bytes                              
*                                                                           
*           BEFORE ADDING SEVEN BITS:                                       
*           | ` ` ` ` ` ` ` |x`x`x`x`x`x`x`x| ` `x`x`x`x`x`x| ` ` ` ` ` ` ` |
*           WriteByteOffset = 2                                              
*           WriteBitOffset  = 6                                              
*           (ReadByteOffset = 1  Not needed for this operation.)             
*           (ReadBitOffset  = 0  Not needed for this operation.)             
*                                                                            
*           AFTER ADDING 7 BITS:                                             
*                                                                            
*           | ` ` ` ` ` ` ` |x`x`x`x`x`x`x`x|x`x`x`x`x`x`x`x| ` ` `x`x`x`x`x|
*           WriteByteOffset = 3                                              
*           WriteBitOffset  = 5                                              
*           (ReadByteOffset = 1  Not needed for this operation.)             
*           (ReadBitOffset  = 0  Not needed for this operation.)             
*                                                                            
*           AFTER ADDING ANOTHER 7 BITS:                                     
*                                                                            
*           | ` ` ` `x`x`x`x|x`x`x`x`x`x`x`x|x`x`x`x`x`x`x`x|x`x`x`x`x`x`x`x|
*           WriteByteOffset = 0                                              
*           WriteBitOffset  = 4                                              
*           (ReadByteOffset = 1  Not needed for this operation.)             
*           (ReadBitOffset  = 0  Not needed for this operation.)             
*                                                                            
*         NOTE: When the routine advances to the next byte in the buffer it  
*               clears it first.                                             
*
* References:
*******************************************************************************
*
* Modifications:
*
* Comments:  
*
* Concerns/TBD:
******************************************************************************/

void BitPackCBuffer(C_BUFFER_TYPE *CBuffer, unsigned char cElement, short cDataWidth) 
{
  unsigned char  *pBuffer;                                       
  unsigned short wBufferSize;
  unsigned short *pByteOffset;
  unsigned char  *pBitOffset;
  short          dwElement;

  assert(cDataWidth<=8); /* This routine only writes up to 8 bits at a time.  */


  /*--------------------------------------------------
    Set the circular buffer to the right position.
    And initialize the variables.
    --------------------------------------------------*/
  wBufferSize = CBuffer->wBufferSize;
  pByteOffset = CBuffer->pBufferWriteByteOffset;
  pBitOffset  = CBuffer->pBufferWriteBitOffset;
  pBuffer     = CBuffer->pBuffer + *pByteOffset;                                       
  dwElement   = cElement;

  /*--------------------------------------------------
    Pack to the current byte
    --------------------------------------------------*/
  if(*pBitOffset==0)
     *pBuffer = ((unsigned char)(dwElement&0x00ff));
  else
     *pBuffer |= ((unsigned char)((dwElement << *pBitOffset)&0x00ff));
  

  /*--------------------------------------------------
    When bit-offset >= PACK_BITS_PER_CHAR, pack the 
    next byte of the circular buffer.
    --------------------------------------------------*/
  *pBitOffset = (unsigned char)(*pBitOffset+cDataWidth); 
  if (*pBitOffset > PACK_BITS_PER_CHAR) 
  {
    pBuffer++;
    (*pByteOffset)++;
    if(*pByteOffset>=wBufferSize)
    {
      *pByteOffset=0;
      pBuffer = CBuffer->pBuffer; 
    }
    *pBuffer = (unsigned char)
               (dwElement>>(PACK_BITS_PER_CHAR-(*pBitOffset-cDataWidth)));
    *pBitOffset=(unsigned char)(*pBitOffset-PACK_BITS_PER_CHAR);
  }
  else if (*pBitOffset == PACK_BITS_PER_CHAR)
  {
    *pBitOffset = 0;
    (*pByteOffset)++;
    if(*pByteOffset>=wBufferSize)
      *pByteOffset=0;
  }
}

/******************************************************************************
*
* Function:  BitUnPackCBuffer
*
* Action:    Unpacks a bitstream from a circular bitstream buffer.
*
* Input:     CBuffer -- The circular buffer into which data is to be packed. 
*                       The data struct is defined in BitPackC.h. This routine
*                       only reads to the buffer, thus the write offsets are 
*                       not needed. 
*            cElement -- The char containing the data
*            cDataWidth -- The number of bits to be read from the buffer.
*
* Output:    CBuffer -- The read-byte-offset and read-bit-offset are updated.
*
* Globals:   none
*
* Return:    void
*******************************************************************************
*
* Implementation/Detailed Description:
*           The algorithm is written to read at most 8 bits.
*           The diagrams below illustrate the reading of 7 bits from the     
*           buffer. The symbol | represents a byte boundary, symbol `        
*           represents a bit boundary, symbol x represents a valid bit and a 
*           space represents a vacant bit position. The data to be read from 
*           the buffer looks like:                                           
*                                 | `x`x`x`x`x`x`x|                          
*           The circular buffer size is 4 bytes                              
*                                                                            
*           BEFORE READING SEVEN BITS:                                       
*           | ` ` ` `x`x`x`x|x` ` ` ` ` ` ` |x`x`x`x`x`x`x`x|x`x`x`x`x`x`x`x|
*           ReadByteOffset = 1                                               
*           ReadBitOffset  = 7                                               
*           (WriteByteOffset = 0 Not needed for this operation.)             
*           (WriteBitOffset  = 4 Not needed for this operation.)             
*                                                                            
*           AFTER READING 7 BITS:                                            
*           |x`x`x`x`x`x`x`x| ` ` ` ` ` ` ` |x`x` ` ` ` ` ` |x`x`x`x`x`x`x`x|
*           ReadByteOffset = 2                                               
*           ReadBitOffset  = 6                                               
*           (WriteByteOffset = 0 Not needed for this operation.)             
*           (WriteBitOffset  = 4 Not needed for this operation.)             
*                                                                            
*           AFTER READING ANOTHER 7 BITS:                                    
*           |x`x`x`x` ` ` ` | ` ` ` ` ` ` ` | ` ` ` ` ` ` ` |x`x`x` ` ` ` ` |
*           ReadByteOffset = 3                                               
*           ReadBitOffset  = 5                                               
*           (WriteByteOffset = 0 Not needed for this operation.)             
*           (WriteBitOffset  = 4 Not needed for this operation.)             
*                                                                            
* References:
*******************************************************************************
*
* Modifications:
*
* Comments:  
*
* Concerns/TBD:
******************************************************************************/

void BitUnpackCBuffer(C_BUFFER_TYPE *CBuffer, unsigned char *cElement,
                      short cDataWidth)
{
  int Mask = (1<<cDataWidth) - 1;
  int Shift;
  unsigned char NewBitOffset;
 
  unsigned char  *pBuffer;                                       
  unsigned short wBufferSize;
  unsigned short *pByteOffset;
  unsigned char  *pBitOffset;



  /*--------------------------------------------------
    Set the circular buffer to the right position.
    And initialize the variables.
    --------------------------------------------------*/
  wBufferSize = CBuffer->wBufferSize;
  pByteOffset = CBuffer->pBufferReadByteOffset;
  pBitOffset  = CBuffer->pBufferReadBitOffset;
  pBuffer     = CBuffer->pBuffer + *pByteOffset;                                       

  NewBitOffset = (unsigned char)(*pBitOffset + cDataWidth);

  /*--------------------------------------------------
    When NewBitOffset > PACK_BITS_PER_CHAR, need unpack
    two bytes. Otherwise, only unpack the current byte.
    --------------------------------------------------*/
  if (NewBitOffset > PACK_BITS_PER_CHAR) 
  {
    Shift = (int)(PACK_BITS_PER_CHAR - *pBitOffset);
    *cElement = (unsigned char)(*pBuffer >> *pBitOffset);
    pBuffer++;
    (*pByteOffset)++;
    if(*pByteOffset>=wBufferSize)
    {
      *pByteOffset=0;
      pBuffer = CBuffer->pBuffer;                                       
    }
    *cElement |= (*pBuffer & (Mask >> Shift)) << Shift;
    NewBitOffset = (unsigned char)(NewBitOffset - PACK_BITS_PER_CHAR);
  }
  else
  {
    *cElement = (unsigned char)((*pBuffer >> *pBitOffset) & Mask);
    if (NewBitOffset == PACK_BITS_PER_CHAR)
    {
      NewBitOffset = 0;
      (*pByteOffset)++;
      if(*pByteOffset>=wBufferSize)
        *pByteOffset=0;
    }
  }
  
  *pBitOffset = NewBitOffset;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\barkvec.h ===
55.657841F, 
112.635620F,
172.284592F,
236.019379F,
305.351440F,
381.925018F,
467.556061F,
564.275391F,
674.376709F,
800.471130F,
945.549011F,
1113.050903F,
1306.949097F,
1531.842285F,
1793.063354F,
2096.808105F,
2450.278564F,
2861.859131F,
3341.309082F,
3900.000000F
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\astocs.c ===
/******************************************************************************
*                        Voxware Proprietary Material
*                        Copyright 1997, Voxware, Inc
*                            All Rights Reserved
*
*                       DISTRIBUTION PROHIBITED without
*                      written authorization from Voxware
******************************************************************************/
 
/******************************************************************************
*
* Filename:    AsToCs.c
*
* Purpose:    Convert the predictor coefficients to cepstral coefficients using
*               Atal's recursion.
*
* Functions: void asToCs (float gain, float *as, int order_allpole, float *cs,
*                         int order_cepstral)
*
* Author/Date: Bob McAulay
*
*******************************************************************************
*
* Modifications:  Wei Wang, clean up the code 11/97.
*
* Comments: 
*
* Concerns: the prediction coefficients using the format [1 a1 a2 ...]. 
*
* $Header:   /export/phobos/pvcs/pvcsproj/voxlib.prj/AsToCs.c_v   1.6   24 Feb 1998 17:08:56   bobd  $
******************************************************************************/

#include <assert.h>

#include "vLibTran.h"
#include "vLibMath.h" /* VoxMIN() */

#include "xvocver.h"

/* constants */
static const float CsTable[] = 
{
#include "csTab.h"
};

#define MAX_CS_TABLE_ORDER    (sizeof(CsTable)/sizeof(float)-1)

/******************************************************************************
*
* Function:  asToCs()
*
* Action:    Convert the prediction coefficients to cepstrum coefficients
*
* Input:     fGain       -- residual energy in the log domain
*            pfAs        -- prediction coefficients in the format [1 a1 a2 ...]
*            iOrder_As   -- the order of prediction coefficients 
*                             (or the length of pfAs plus 1).
*            pfCs        -- the pointer to the cepstrum coefficients.
*            iLength_Cs  -- the length of pfCs (or the order of cepstrum 
*                             coefficients plus 1).
*
* Output:    pfCs     -- the output cepstrum coefficients
*
* Globals:   none
*
* Return:    void
*******************************************************************************
*
* Implementation/Detailed Description:
*
* References:  Page 115 of "Fundamentals of Speech Recognition" by L. Rabiner 
*                and B. H. Juang, Prentice Hall 1993
*******************************************************************************
*
* Modifications:
*
* Comments:     The format for pfAs[] is:
*                  A(z) = 1 + SUM(1...p) a_p z^(-p) where pfAs[0]=1.
*
* Concerns/TBD: The conventional cepstral coefficients are based on the 
*                 log_base_e allpole envelope. In this function, they are 
*                 based on the half of log_base_2 allpole envelope. So the 
*                 coefficients are scaled by 0.5/ln(2) = 0.72134752. 
******************************************************************************/

void VoxAsToCs( const float  fGain, 
                const float *pfAs, 
                const int    iOrder_As, 
                float       *pfCs, 
                const int    iLength_Cs
              )
 {
   int   m, k;
   int   iOrder_Cs;
   int   P;
   float fSum;

   iOrder_Cs = iLength_Cs - 1;

   assert(iOrder_Cs >= 0);    
   assert(iOrder_Cs <= MAX_CS_TABLE_ORDER);    

   /*-----------------------------------------------------------------------
     chose the order of recursion is min(iOrder_As, iLength_Cs-1)
   -----------------------------------------------------------------------*/
   P = VoxMIN( iOrder_As, iOrder_Cs );

   /*-----------------------------------------------------------------------
     Use the recursion to convert LPC parameter to Cepstrum Coefficients.
   -----------------------------------------------------------------------*/
   pfCs[0] = fGain;      /* gain = .5*log_b2(Residue_Eng) */

   /*----------------------------------------------------------------------
     For cepstrum order smaller than or equal to LPC order.
     using recursion (3.83b) as in P.115 of the reference.
     Note: fSum is the normalized cepstrum here: fSum = m*pfCs[m].
   ----------------------------------------------------------------------*/
   for (m = 1; m <= P; m ++)
   {
      fSum = -(float)m*pfAs[m];
      for (k=1; k<m; k++)
         fSum -= pfAs[k]*pfCs[m-k];
      pfCs[m] = fSum;
   }

   /*----------------------------------------------------------------------
     For cepstrum order larger than LPC order.
     using recursion (3.83c) as in P.115 of the reference.
     Note: fSum is the normalized cepstrum here: fSum = m*pfCs[m].
   ----------------------------------------------------------------------*/
   for (; m <= iOrder_Cs; m++)
   {
      fSum = 0.0F;
      for (k=1; k<=iOrder_As; k++)
         fSum -= pfAs[k]*pfCs[m-k];
      pfCs[m] = fSum;
   }

   /*-----------------------------------------------------------------------
      (1) Remove the normalization (i.e. pfCs[m] = pfCs[m]/m).
      (2) Convert the log_base_e transform to 0.5*log_base_2 transform.
      The constants .5*1.442695041/n are stored in  CsTable[] for speed.
   -----------------------------------------------------------------------*/
   for(m=1; m<=iOrder_Cs; m++)
     pfCs[m] = CsTable[m] * pfCs[m];

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\bk2d_5bn.h ===
31.680872F,
51.287071F,
68.506882F,
84.037087F,
98.168129F,
111.956940F,
125.766655F,
139.069962F,
152.629349F,
166.449448F,
180.352631F,
194.845322F,
209.483353F,
224.577286F,
240.583374F,
256.596039F,
273.026733F,
290.544708F,
308.435638F,
326.699249F,
345.514404F,
365.074677F,
385.516846F,
406.729980F,
429.826416F,
455.574341F,
483.890594F,
516.699402F,
555.478821F,
605.140259F,
673.249634F,
801.957275F,
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\bk3d_4bn.h ===
8.0337806701660156e+01F, 
1.2525933837890625e+02F, 
1.6380519104003906e+02F, 
2.0109777832031250e+02F, 
2.3937902832031250e+02F, 
2.7907138061523438e+02F, 
3.2079263305664062e+02F, 
3.6592440795898438e+02F, 
4.1321405029296875e+02F, 
4.5936672973632812e+02F, 
5.0548013305664062e+02F, 
5.5329431152343750e+02F, 
6.0833685302734375e+02F, 
6.8033691406250000e+02F, 
7.8799987792968750e+02F, 
9.7781542968750000e+02F
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\bk2d_4bn.h ===
4.2425800323486328e+01F, 
7.6445686340332031e+01F, 
1.0500779724121094e+02F, 
1.3109226989746094e+02F, 
1.5655366516113281e+02F, 
1.8317581176757812e+02F, 
2.1299562072753906e+02F, 
2.4506671142578125e+02F, 
2.8023214721679688e+02F, 
3.1877032470703125e+02F, 
3.5979071044921875e+02F, 
4.0371801757812500e+02F, 
4.5289202880859375e+02F, 
5.1113357543945312e+02F, 
5.8419897460937500e+02F, 
7.0493658447265625e+02F
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\bk1d_5bn.h ===
51.358425F,
76.090347F,
97.943054F,
116.566986F,
129.432037F,
140.706497F,
152.159576F,
164.130173F,
176.301025F,
187.845520F,
199.679626F,
212.101868F,
224.684952F,
237.477249F,
251.333878F,
265.661469F,
280.380890F,
295.367035F,
310.917664F,
327.477692F,
345.536102F,
364.456116F,
384.037079F,
404.633698F,
427.024170F,
452.306580F,
479.698212F,
512.827576F,
549.879150F,
603.085815F,
684.726807F,
855.159546F,
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\bk3d_5bn.h ===
64.263954F,
93.492943F,
116.893158F,
137.767899F,
157.782608F,
177.185516F,
196.585632F,
216.172867F,
236.658401F,
257.094666F,
278.104553F,
299.329132F,
320.735596F,
342.987762F,
365.051208F,
387.983734F,
411.009064F,
433.043182F,
455.648590F,
478.258972F,
501.278107F,
524.497742F,
549.075195F,
574.045532F,
600.442566F,
629.503113F,
665.222412F,
710.211548F,
769.613159F,
843.306213F,
958.832703F,
1114.214480F,
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\bk4d_5bn.h ===
73.754501F,
111.990601F,
142.338211F,
168.887131F,
193.742065F,
217.432755F,
240.355225F,
262.849213F,
284.301208F,
305.038086F,
325.222321F,
344.363770F,
363.582825F,
383.401428F,
402.808655F,
422.064423F,
443.004761F,
464.399780F,
487.172150F,
511.093628F,
536.172485F,
563.351196F,
591.006042F,
623.388062F,
658.695740F,
696.300293F,
737.233704F,
785.763245F,
838.390442F,
901.827271F,
990.632690F,
1121.507690F,
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\bk4d_4bn.h ===
1.0333330535888672e+02F, 
1.6158682250976562e+02F, 
2.1084530639648438e+02F, 
2.5658514404296875e+02F, 
2.9928240966796875e+02F, 
3.4030722045898438e+02F, 
3.7958285522460938e+02F, 
4.1981063842773438e+02F, 
4.6340643310546875e+02F, 
5.1186145019531250e+02F, 
5.6643200683593750e+02F, 
6.2829400634765625e+02F, 
7.0140460205078125e+02F, 
7.9052856445312500e+02F, 
8.9151641845703125e+02F, 
1.0359449462890625e+03F
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\bk5d_4bn.h ===
9.5787345886230469e+01F, 
1.5002532958984375e+02F, 
2.0581956481933594e+02F, 
2.6063586425781250e+02F, 
3.1291439819335938e+02F, 
3.6119305419921875e+02F, 
4.0729650878906250e+02F, 
4.5495715332031250e+02F, 
5.0473895263671875e+02F, 
5.6123852539062500e+02F, 
6.2855792236328125e+02F, 
7.0548681640625000e+02F, 
7.9171148681640625e+02F, 
8.9048553466796875e+02F, 
1.0090026245117188e+03F, 
1.1769664306640625e+03F
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\bk6d_4bn.h ===
9.2856437683105469e+01F, 
1.4093011474609375e+02F, 
1.8739489746093750e+02F, 
2.3396873474121094e+02F, 
2.7968353271484375e+02F, 
3.2327709960937500e+02F, 
3.6517007446289062e+02F, 
4.0867428588867188e+02F, 
4.5607180786132812e+02F, 
5.1032788085937500e+02F, 
5.7456066894531250e+02F, 
6.4825646972656250e+02F, 
7.3789068603515625e+02F, 
8.4292443847656250e+02F, 
9.8445611572265625e+02F, 
1.1959749755859375e+03F
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\bk7d_4bn.h ===
118.466362F,
177.887161F,
232.366150F,
283.656921F,
330.446228F,
373.448425F,
416.388123F,
461.050629F,
509.319305F,
563.941040F,
628.626099F,
701.051270F,
782.677979F,
880.042603F,
1006.480770F,
1195.659550F,
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\bk9d_3bn.h ===
1.7244256591796875e+02F, 
2.8188064575195312e+02F, 
3.6976580810546875e+02F, 
4.5390655517578125e+02F, 
5.5437371826171875e+02F, 
6.8428070068359375e+02F, 
8.5531329345703125e+02F, 
1.1470659179687500e+03F
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\bkad_3bn.h ===
1.0866685485839844e+02F, 
1.8021560668945312e+02F, 
2.4612800598144531e+02F, 
3.0818142700195312e+02F, 
3.7658279418945312e+02F, 
4.6168280029296875e+02F, 
5.8167736816406250e+02F, 
7.5525500488281250e+02F
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\bk7d_3bn.h ===
1.6466590881347656e+02F, 
2.7271469116210938e+02F, 
3.6144085693359375e+02F, 
4.4384936523437500e+02F, 
5.3716741943359375e+02F, 
6.6035803222656250e+02F, 
8.1994262695312500e+02F, 
1.0609611816406250e+03F
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\bk8d_3bn.h ===
1.2297349548339844e+02F, 
2.0798709106445312e+02F, 
2.8715408325195312e+02F, 
3.5893423461914062e+02F, 
4.3498934936523438e+02F, 
5.3270794677734375e+02F, 
6.7491784667968750e+02F, 
9.1253491210937500e+02F
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\calccost.h ===
/*******************************************************************************
*                        Voxware Proprietary Material                          *
*                        Copyright 1996, Voxware, Inc                          *
*                            All Rights Reserved                               *
*                                                                              *
*                       DISTRIBUTION PROHIBITED without                        *
*                      written authorization from Voxware                      *
*******************************************************************************/
/*******************************************************************************
* Filename:     CalcCost.c
*                                                                              
* Purpose:      calculate likelyhood function for LDPDA.
*                                                                              
* Functions:    CalcCostFunc
*                                                                              
* Author/Date:  Gerard Aguilar 01/97
*               Wei Wang       04/97
********************************************************************************
* Modifications: To reduce the complexity, all float to int conversions are 
*                eliminated by using fix-point indices. And time-consuming 
*                floating point comparisons are speed-up using long integer
*                comparisons by assigning numbers to float-int union (assuming
*                IEEE floating point). 
*
*              1. Use fixed-point code to prevent float-int conversion 
*              2. Use pitch table instead of F0 table 
*              3. Fewer input arrays (lower ROM and RAM). 
*           
*               -- Wei Wang 12/97
*
* Comments:                                                                    
* 
* Concerns:  
*
* $Header:   /export/phobos/pvcs/r_and_d/archives/scaleable/pea/CalcCost.h_v   1.1   02 Apr 1998 14:46:52   weiwang  $
*******************************************************************************/

#ifndef CALC_COST_H
#define CALC_COST_H

/******************************************************************************
* Function:  CalcCostFunc()
*
* Action:    Compute the frequency domain pitch likelyhood function.
*
* Input:     fPitch     --  pitch value
*            piPeakFreq --  peak indices of spectrum
*            pfMag      --  compressed magnitude spectrum
*            iNBand     --  length of spectrum for 
*            fEngScale  --  energy scale factor
*
* Output:    none
*
* Globals:   none
*
* Return:    cost function (or likelyhood function) of input pitch
*******************************************************************************
*
* Implementation/Detailed Description:
*
*******************************************************************************
*
* Modifications:
*
* Comments:
*
* Concerns/TBD:
*
******************************************************************************/

float CalcCostFunc( float         fPitch, 
                    const int     *piPeakFreq, 
                    const float   *pfMag, 
                    int           iNBand, 
                    float         fEngScale
                  );

#endif /* CALC_COST_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\cb10_3lp.h ===
0.00625644F,
0.07005645F,
0.02075082F,
-0.03675349F,
0.03980618F,
-0.02098562F,
-0.00697696F,
-0.05748083F
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\calclpc.h ===
#ifndef _CALCLPC_H_
#define _CALCLPC_H_
/***********************************************************************
 *
 * Filename:  calcLPC.h
 *
 * Purpose:   calculate the LPC coefficients using autocorrelation method.
 *
 * Reference: any digital speech processing book.
 *
 * Author:    Wei Wang
 *
 * Date:      Oct. 07, 1996.
 *
 * Modification: Add LSF interpolation  and perceptual weighting, Jan.22, 1997
 *
 * $Header:   /export/phobos/pvcs/r_and_d/archives/realtime/pda/calcLPC.h_v   1.2   12 May 1998 12:55:12   weiwang  $
 ***********************************************************************/
void VoxLPCAnaly4PDA(STACK_R float *sigin, float *sigout, int length, void *myCorrPDA_mblk);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\cb2_5lp.h ===
0.02540229F,
0.04467124F,
0.05824589F,
0.02956263F,
0.03414777F,
-0.00946446F,
-0.04632474F,
-0.02834525F,
-0.03189515F,
-0.00636145F,
0.00705854F,
0.06661220F,
-0.01255891F,
-0.04015338F,
-0.01875343F,
-0.02496401F,
-0.03566110F,
-0.02180381F,
-0.01568039F,
0.00024247F,
0.01763676F,
0.05102730F,
0.14704848F,
0.09122421F,
0.03916788F,
0.11074440F,
0.02142960F,
0.07760281F,
0.01409647F,
0.01056814F,
-0.00305575F,
0.00359193F
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\cb1_5lp.h ===
-0.02584568F,
-0.01273823F,
-0.01533212F,
0.00408624F,
-0.03297200F,
-0.01780589F,
0.02352675F,
0.00834072F,
-0.03682575F,
-0.02028422F,
-0.00691952F,
-0.04493519F,
0.01293687F,
0.03640872F,
0.05242331F,
0.10686615F,
0.08758112F,
0.04392900F,
-0.00351515F,
-0.04078631F,
0.02962537F,
0.06213901F,
-0.04996020F,
-0.05521363F,
0.00013484F,
-0.02926694F,
-0.06160685F,
-0.08147515F,
0.07342171F,
-0.00999832F,
0.01796631F,
-0.02283720F
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\calccost.c ===
/*******************************************************************************
*                        Voxware Proprietary Material                          *
*                        Copyright 1996, Voxware, Inc                          *
*                            All Rights Reserved                               *
*                                                                              *
*                       DISTRIBUTION PROHIBITED without                        *
*                      written authorization from Voxware                      *
*******************************************************************************/
/*******************************************************************************
* Filename:     CalcCost.c
*                                                                              
* Purpose:      calculate likelyhood function for LDPDA.
*                                                                              
* Functions:    CalcCostFunc
*                                                                              
* Author/Date:  Gerard Aguilar 01/97
*               Wei Wang       04/97
********************************************************************************
* Modifications: To reduce the complexity, all float to int conversions are 
*                eliminated by using fix-point indices. And time-consuming 
*                floating point comparisons are speed-up using long integer
*                comparisons by assigning numbers to float-int union (assuming
*                IEEE floating point). 
*
*              1. Use fixed-point code to prevent float-int conversion 
*              2. Use pitch table instead of F0 table 
*              3. Fewer input arrays (lower ROM and RAM). 
*           
*               -- Wei Wang 12/97
*
* Comments:                                                                    
* 
* Concerns:  
*
* $Header:   /export/phobos/pvcs/r_and_d/archives/scaleable/pea/CalcCost.c_v   1.5   02 Apr 1998 14:46:52   weiwang  $
*******************************************************************************/

/*** system include files ***/
#include <stdlib.h>
#include <assert.h>

/*** Research lib include files ***/
#include "vLibType.h"

/*** codec related include files ***/
#include "codec.h"
#include "CalcCost.h"
#include "trigSC.h"

#include "xvocver.h"

/*** Table ***/
extern const float *cosTBL_32;

/*** local definitions ***/
#define PITCH_SHIFT_BITS           (15-LOG2_TRIG_SIZE)
#define PITCH_SHIFT_SCALE          (float)(1<<PITCH_SHIFT_BITS)
#define SCALED_TABLE_SIZE          ((long)TRIG_SIZE << PITCH_SHIFT_BITS)
#define SCALED_TABLE_SIZE_D_NFFT   (SCALED_TABLE_SIZE >> FFT_ORDER)
#define SCALED_HALF_TBL_SIZE       ((long)SCALED_TABLE_SIZE>>1)
#define SCALED_TABLE_MASK          ((long)SCALED_TABLE_SIZE-1)
#define LDF0_SHIFT_BITS            12
#define LDF0_SCALED_05             ((long)1<<(LDF0_SHIFT_BITS-1))
#define F0_FFT_PITCH_SHIFT_BITS    (LDF0_SHIFT_BITS+FFT_ORDER+PITCH_SHIFT_BITS)

#define CALC_TAB_INDEX(Fk, TP0)  ((long)Fk*(long)TP0)


/******************************************************************************
* Function:  CalcCostFunc()
*
* Action:    Compute the frequency domain pitch likelyhood function.
*
* Input:     fPitch     --  pitch value
*            piPeakFreq --  peak indices of spectrum
*            pfMag      --  compressed magnitude spectrum
*            iNBand     --  length of spectrum for 
*            fEngScale  --  energy scale factor
*
* Output:    none
*
* Globals:   none
*
* Return:    cost function (or likelyhood function) of input pitch
*******************************************************************************
*
* Implementation/Detailed Description:
*
* Reference: Pitch Estimation and Vocing Detection Based on a Sinusoidal
*            Speech Model. R. McAulay and T. Quatieri, ICASSP 1990.
*
*******************************************************************************
*
* Modifications:
*
* Comments:
*
* Concerns/TBD:
*
******************************************************************************/

float CalcCostFunc( float         fPitch, 
                    const int     *piPeakFreq, 
                    const float   *pfMag, 
                    int           iNBand, 
                    float         fEngScale
                  )
{
  long lPitch, lScaledPitch;
  long lF0, lHarmF0;
  float fCrossCost, fHarmPower;
  float fHarmMag;
  long lRightBound, lTableIndex;
  int iHarmF0;
  int iPeaks;
  int i;
  UnionFltLng uMaxMag, uPeakMag;

  assert(piPeakFreq != NULL);
  assert(pfMag != NULL);

  /*------------------------------------------------------------
    (1) Initializations.
    ------------------------------------------------------------*/
  /* initialize lPitch: shift fPitch by PITCH_SHIFT_BITS */
  lPitch = (long)(fPitch*PITCH_SHIFT_SCALE);

  /* initialize lScaledPitch: scaled lPitch by TRIG_SIZE over NFFT */
  lScaledPitch = (long)(fPitch*SCALED_TABLE_SIZE_D_NFFT); 

  /* initialize lF0: shift F0=NFFT/fPitch by LDF0_SHIFT_BITS */
  assert(F0_FFT_PITCH_SHIFT_BITS < 31);
  lF0 = ((long)1<<F0_FFT_PITCH_SHIFT_BITS)/lPitch;

  /* lHarmF0: iHarm * lF0 */
  lHarmF0 = lF0;
  
  /* initialize the accumulators: 
     fCrossCosts -- sum of cross correlation term.
     fHarmPower  -- sum of harmonics' power */
  fCrossCost = EPS;
  fHarmPower = EPS;

  /*---------------------------------------------------------------
    (2) Skip peak indices which are smaller than 0.5F0.
    ---------------------------------------------------------------*/
  /* lRightBound: mapped from harmonic's boundary to scaled 
     Cosine table index. */
  lRightBound = SCALED_HALF_TBL_SIZE;
  iPeaks = 0;

  /* lTableIndex: mapped to unwarped scaled Cosine table. 
     This index should related to fPitch and peaks in frequency domain. */
  lTableIndex = CALC_TAB_INDEX(piPeakFreq[iPeaks], lScaledPitch);

  /* skip first few peaks ... */
  while (lTableIndex < lRightBound)
    lTableIndex = CALC_TAB_INDEX(piPeakFreq[++iPeaks], lScaledPitch);

  /*------------------------------------------------------------
    (3) Compute fCrossCost and fHarmPower for all harmonics
    within [0.5F0, iNBand].
    ------------------------------------------------------------*/

  /* iHarmF0:  round(N * F0), N refers to number of harmonics */
  iHarmF0 = (int)((lHarmF0+LDF0_SCALED_05) >> LDF0_SHIFT_BITS);

  /* main loop: search all harmonics within [0.5F0, iNBand]. */
  while (iHarmF0 < iNBand) 
    {
      /* lRightBound: mapped from (N+0.5)*F0 to (N+0.5)*SCALED_TABLE_SIZE */
      lRightBound += SCALED_TABLE_SIZE;

      /* Find out the most confident peak within one harmonic band */
      uMaxMag.f = EPS;

      while (lTableIndex < lRightBound)
        {
          /* peak magnitude is scaled by 1+cos[i], where i can be calculated 
           * by lTableIndex. And i refers to how closely the peak to center
           * harmonic frequency. */
          i = (int)((lTableIndex & SCALED_TABLE_MASK) >> PITCH_SHIFT_BITS);
          uPeakMag.f = pfMag[piPeakFreq[iPeaks]] * (1.0F+cosTBL_32[i]);

          if (uPeakMag.l > uMaxMag.l)
             uMaxMag.l = uPeakMag.l;

          lTableIndex = CALC_TAB_INDEX(piPeakFreq[++iPeaks], lScaledPitch);
        }

      /* accumulate fCrossCost and fHarmPower: */
      fHarmMag = pfMag[iHarmF0];
      fCrossCost += uMaxMag.f * fHarmMag;
      fHarmPower += fHarmMag * fHarmMag;

      /* update lHarmF0 and iHarmF0 */
      lHarmF0 += lF0;
      iHarmF0 = (int)((lHarmF0+LDF0_SCALED_05)>>LDF0_SHIFT_BITS);
    }

  /* return the final likelyhood function. */
  return  (fEngScale*(0.5F*fCrossCost - 0.375F*fHarmPower));
} /* CalcCostFunc() */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\cb3_5lp.h ===
0.00265068F,
0.01162798F,
-0.01694951F,
-0.04124799F,
-0.05087033F,
-0.02457433F,
-0.06150100F,
-0.06876475F,
-0.04595469F,
-0.03262517F,
-0.02855248F,
-0.00934650F,
-0.02070049F,
0.02149475F,
0.02706234F,
0.06454223F,
0.00699845F,
-0.03684355F,
-0.05588062F,
-0.00152137F,
0.03983168F,
0.03314180F,
0.13238803F,
0.04725110F,
0.05541831F,
-0.01313160F,
0.08995573F,
0.01637337F,
0.10767109F,
-0.00551869F,
0.07584226F,
0.17226163F
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\calclpc.c ===
/***********************************************************************
 *
 * Filename:  calcLPC.c
 *
 * Purpose:   calculate the LPC coefficients using autocorrelation method.
 *
 * Reference: any digital speech processing text book.
 *
 * Author:    Wei Wang
 *
 * Date:      Oct. 07, 1996.
 *
 * Modification: Add LSF interpolation  and perceptual weighting, Jan.22, 1997
 *
 * $Header:   /export/phobos/pvcs/r_and_d/archives/realtime/pda/calcLPC.c_v   1.7   12 May 1998 12:55:12   weiwang  $
 *
 ***********************************************************************/

#include <stdlib.h>
#include <assert.h>
#include <string.h>

#include "vLibTran.h" /* VoxAsToLspEven(), VoxLspToAsEven() */
#include "vLibSpch.h" /* BandExpand(), VoxDurbin()          */
#include "vLibVec.h"  /* AutoCor()                          */

#include "VoxMem.h"
#include "CorrPDA.h"
#include "PitchDef.h"
#include "NspIIR.h"

#include "calcLPC.h"

#include "xvocver.h"

void VoxLPCAnaly4PDA( STACK_R 
                      float *sigin, 
                      float *sigout, 
                      int    length, 
                      void  *pCorrPDA_mblk
                    )
{
  CorrPDA_mblk *myCorrPDA_mblk=(CorrPDA_mblk *)pCorrPDA_mblk;

STACK_INIT
  float psigBuf[FRAME_LEN];   /* psigBuf[FRAME_LEN] */
  float fPARCOR[PDA_LPC_ORDER];
  float pAutoCorrBuf[PDA_LPC_ORDER+1];
  float pAlpc[PDA_LPC_ORDER+1];
  float pAlsf1[PDA_LPC_ORDER];
  float pAlsf[PDA_LPC_ORDER];
  float pWeightCoef[2*PDA_LPC_ORDER+1];
STACK_INIT_END

STACK_ATTACH(float *, psigBuf)
STACK_ATTACH(float *, fPARCOR)
STACK_ATTACH(float *, pAutoCorrBuf)
STACK_ATTACH(float *, pAlpc)
STACK_ATTACH(float *, pAlsf1)
STACK_ATTACH(float *, pAlsf)
STACK_ATTACH(float *, pWeightCoef)

  float ResidueEng;

  int i, j;

  float diffLsf;
  float *pAlsf0;               /* LSF of previous frame */
  float fSlope;
  float weight_den, weight_num;

  float *psigIn, *psigOut;
  float *pwin;

STACK_START

  /*------------------------------------------------------------
    (1). asymmetric windowing the signal. 
    ------------------------------------------------------------*/
  pwin = myCorrPDA_mblk->LpcWindow;
  psigIn = sigin;
  for (i = 0; i < length; i++)
    psigBuf[i] = psigIn[i] * pwin[i]; 


  /*------------------------------------------------------------
    (2). calcualte auto-correlation coefficients.
    ------------------------------------------------------------*/
  AutoCor( (PDA_LPC_ORDER+1), psigBuf, length, pAutoCorrBuf);

  
  /*------------------------------------------------------------
    (3). calculate LPC coefficients by using Levinson-Durbin
    algorithm.
    ------------------------------------------------------------*/
  VoxDurbin(pAutoCorrBuf, PDA_LPC_ORDER, pAlpc, fPARCOR, &ResidueEng);

  /*------------------------------------------------------------
    (4). expand the LPC pole. pAlpc is overwritten.
    ------------------------------------------------------------*/
  BandExpand(pAlpc, pAlpc, PDA_LPC_ORDER, PDA_EXPAND_COEF);


  /*------------------------------------------------------------
    (5). calculate LSFs.
    ------------------------------------------------------------*/
  VoxAsToLspEven(pAlpc, PDA_LPC_ORDER, RATE8K, pAlsf1);

  /*------------------------------------------------------------
    (6). check the difference of LSFs.
    ------------------------------------------------------------*/
  weight_num = PERCEP_WEIGHT_NUM_BIG;
  for (i = 1; i < PDA_LPC_ORDER; i++) {
    diffLsf = pAlsf1[i]-pAlsf1[i-1];
    if (diffLsf < MIN_DIFF_LSF)
      weight_num = PERCEP_WEIGHT_NUM_SMALL;
  }
  
  /*------------------------------------------------------------
    (7). interpolate the LSFs between subframes. 
    do perceptual weighting of signal.
    ------------------------------------------------------------*/
  pAlsf0 = myCorrPDA_mblk->Alsf0;
  fSlope = INTERP_LSF_COEF;
  weight_den = PERCEP_WEIGHT_DEN; 
  psigIn = sigin;
  psigOut = sigout;
  for (i = 0; i < NUM_SUBFRAME; i++) {
    /* interpolate LSFs */
    for (j = 0; j < PDA_LPC_ORDER; j++)
      pAlsf[j] = pAlsf0[j] + fSlope*(pAlsf1[j]-pAlsf0[j]);
    fSlope += INTERP_LSF_COEF;


    /* Lsf converts to Lpc */
    VoxLspToAsEven(pAlsf, PDA_LPC_ORDER, INV_RATE8K, pAlpc);

    /** numerator of weighting filter **/
    BandExpand(pAlpc, &(pWeightCoef[0]), PDA_LPC_ORDER, weight_num);
    /** denominator of weighting filter **/
    BandExpand(pAlpc, pAlpc, PDA_LPC_ORDER, weight_den);
    memcpy( &(pWeightCoef[PDA_LPC_ORDER+1]), pAlpc+1, PDA_LPC_ORDER*sizeof(float));

    /** filter the signal using IIR filter.**/
    VoxNspIIRFlt(psigIn, psigOut, SUBFRAME_LEN, pWeightCoef, PDA_LPC_ORDER,
		 myCorrPDA_mblk->percWeight_mem);
    
    psigIn += SUBFRAME_LEN;
    psigOut += SUBFRAME_LEN;
  }


  /*------------------------------------------------------------
    (8) copy Alsf1[0:9] to Alsf0[0:9] for next frame.
    ------------------------------------------------------------*/
  memcpy(pAlsf0, pAlsf1, PDA_LPC_ORDER*sizeof(float));

STACK_END
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\cb5_4lp.h ===
0.12062541F,
0.09059991F,
0.04900831F,
-0.01807006F,
0.01823943F,
-0.00637602F,
-0.04170695F,
-0.08027743F,
0.00558148F,
0.06775720F,
0.03253702F,
0.16137051F,
-0.09679494F,
-0.02978497F,
-0.05404378F,
-0.06656656F
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\cb4_5lp.h ===
-0.05045161F,
0.02634145F,
-0.02304400F,
0.01291896F,
-0.01178007F,
0.03593851F,
0.17402521F,
0.12464047F,
-0.02916232F,
0.02185910F,
0.00351906F,
-0.08369115F,
-0.03575844F,
-0.06973252F,
-0.04282151F,
-0.01728271F,
0.06750711F,
0.10944161F,
0.09657351F,
0.04689044F,
0.01741800F,
-0.00143241F,
0.04120412F,
0.05308053F,
0.08538139F,
0.07574665F,
0.05978568F,
-0.05917983F,
0.00827490F,
0.03109700F,
0.14406087F,
-0.00651915F
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\cb8_3lp.h ===
0.00860666F,
0.09457597F,
0.02805084F,
0.05390383F,
-0.00889993F,
-0.02655371F,
-0.04685136F,
-0.07913118F
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\cb6_4lp.h ===
0.08637049F,
0.02196319F,
0.03386186F,
0.16460061F,
0.11607978F,
0.00204487F,
-0.01661975F,
0.01163941F,
-0.02614044F,
0.04792484F,
0.06504860F,
-0.08070158F,
-0.00722031F,
-0.04830425F,
-0.06227489F,
-0.03649135F
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\cb9_3lp.h ===
-0.09321205F,
-0.05525302F,
-0.01246984F,
0.04678076F,
0.00516594F,
0.02389793F,
0.07999303F,
-0.03165680F
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\cb7_4lp.h ===
0.08870724F,
0.01843048F,
0.06386620F,
-0.12449965F,
-0.04328889F,
0.03084037F,
0.04534225F,
-0.03187670F,
0.12726288F,
-0.01169508F,
-0.00204075F,
-0.07241660F,
-0.09326251F,
-0.02151315F,
-0.05618147F,
0.00780861F
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\cbufutil.c ===
/******************************************************************************
*                        Voxware Proprietary Material
*                        Copyright 1996, Voxware, Inc
*                            All Rights Reserved
*
*                       DISTRIBUTION PROHIBITED without
*                      written authorization from Voxware
******************************************************************************/
 
/******************************************************************************
* Filename:      cBufUtil.c  
*
* Purpose:       Defines Circular buffer utility routines.
*
* Functions:     copyCBuf2LBuf
*
* Author/Date:   Epiphany Vera
*******************************************************************************
*
* Modifications:
*
* Comments:
*
* Concerns:
*
* $Header:   /export/phobos/pvcs/pvcsproj/voxlib.prj/cBufUtil.c_v   1.0   07 Apr 1998 17:58:04   weiwang  $
*
******************************************************************************/
#include "vLibPack.h"

#include "xvocver.h"

/******************************************************************************
*
* Function:  copyCBuf2LBuf
*
* Action:    copy circular buffer to linear buffer
*
* Input:     CBuffer -- The circular buffer into which data is to be packed. 
*            ByteOffset -- byte offset 
*            BitOffset -- bit offset
*            BufferSize -- circular buffer size
*            bitsToCopy  -- how many bits need to copy to linear buffer
*            LBuffer -- linear buffer to copy to 
*
* Output:    ByteOffset -- updated byte offset
*            BitOffset -- updated bit offset
*            LBuffer  -- updated linear buffer
*
* Globals:   none
*
* Return:    void
*******************************************************************************
*
* Implementation/Detailed Description:
*
* References:
*******************************************************************************
*
* Modifications:
*
* Comments:  
*
* Concerns/TBD:
******************************************************************************/
void copyCBuf2LBuf(unsigned char *CBuffer,    unsigned short *ByteOffset,  
                   unsigned char *BitOffset,  unsigned short  BufferSize,
                   unsigned long  bitsToCopy, unsigned char  *LBuffer)
{
   C_BUFFER_TYPE CircBuffer;
  
   CircBuffer.wBufferSize = BufferSize;
   CircBuffer.pBufferReadByteOffset = ByteOffset;
   CircBuffer.pBufferReadBitOffset  = BitOffset;
   CircBuffer.pBuffer = CBuffer;                                       

   while(bitsToCopy>=PACK_BITS_PER_CHAR)
   {
      BitUnpackCBuffer(&CircBuffer, LBuffer++, PACK_BITS_PER_CHAR);
      bitsToCopy-=PACK_BITS_PER_CHAR;
   }
   BitUnpackCBuffer(&CircBuffer, LBuffer, (short)bitsToCopy);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\centcorr.c ===
/***********************************************************************
 *
 * Filename: CentCorr.c
 *
 * Purpose:  centerize the pitch by calculating the autocorrelation value.
 *
 * Author:   Wei Wang
 *
 * Date:     Jan. 22, 1996
 *
 * $Header:   /export/phobos/pvcs/r_and_d/archives/realtime/pda/CentCorr.c_v   1.6   12 May 1998 12:55:02   weiwang  $
 ***********************************************************************/

#include <math.h>
#include <assert.h>
#include <string.h>
#include <stdlib.h>

#include "VoxMem.h"
#include "vLibSpch.h"  /* QuadraticPeak() */
#include "vLibVec.h"   /* DotProd()       */
#include "vLibSgPr.h"  /* WindowKernel() */

#include "PitchDef.h"
#include "CorrPDA.h"
#include "CentCorr.h"

#include "xvocver.h"


float calcCenterCorr(STACK_R CorrPDA_mblk *myCorrPDA_mblk, float *lpfBuf1, 
                     int pitch, float *maxCost )
{
  float *lpfbuf = myCorrPDA_mblk->lpfbuf;
  STACK_INIT
  float psigBuf[2*LFRAME_LEN];           /* psigBuf[2*LFRAME_LEN] */
  float pCorrCosts[9];
  STACK_INIT_END
  STACK_ATTACH(float*,psigBuf)
  STACK_ATTACH(float*,pCorrCosts)
  int delta, Left_lag, Right_lag;
  int win_length;
  int half_win_length;
  int jlag, i, bestI;
  float eng1, eng2;
  float *biasTab = myCorrPDA_mblk->biasTab;
  float maxCorr, totalCorr;
  int bestLag;
  float refine_pitch;

  STACK_START
  /*------------------------------------------------------------
    Find out the pitch searching range.
    ------------------------------------------------------------*/
  delta = (int)(0.1F*(float)pitch+0.5F);
  if (delta > 4)
    delta = 4;
  Left_lag = pitch-delta;
  if (Left_lag < LPITCH_MIN)
    Left_lag = LPITCH_MIN;
  
  Right_lag = pitch+delta;
  if (Right_lag > LPITCH_MAX)
    Right_lag = LPITCH_MAX;

  
  /*------------------------------------------------------------
    Calculate the length of window and copy the data to temporary 
    buffer.
    ------------------------------------------------------------*/
  win_length = 3*Right_lag;
  if (win_length < 65)     /* smallest window size */
    win_length = 65;
  if (win_length > (2*LFRAME_LEN))    /* largest window size */
    win_length = 2*LFRAME_LEN;

  half_win_length = win_length >> 1;
  if (half_win_length > LFRAME_LEN_2) {
    /* copy the signal of previous frame and current frame */
    memcpy(psigBuf, &(lpfbuf[LFRAME_LEN-half_win_length]), 
	   (half_win_length+LFRAME_LEN_2)*sizeof(float));
    /* copy the signal of future frame */
    memcpy(&(psigBuf[half_win_length+LFRAME_LEN_2]),lpfBuf1,(win_length-(half_win_length+LFRAME_LEN_2))*sizeof(float));
  }
  else {
    /* only need the signal of current frame */
    memcpy(psigBuf, &(lpfbuf[LFRAME_LEN-half_win_length]), 
	   win_length*sizeof(float));
  }

  /*------------------------------------------------------------
    Windowing the signal.
    ------------------------------------------------------------*/
  WindowKernel(psigBuf, win_length, CENT_WIN_A, CENT_WIN_B);


  /*--------------------------------------------------
    calculate the autocorrelation function.
    --------------------------------------------------*/
  jlag = Left_lag;
  maxCorr = -MAXFLT;
  bestI = 0;
  i=0;
  do {
    totalCorr = (float)DotProd(psigBuf, psigBuf+jlag, win_length-jlag);

    pCorrCosts[i] = totalCorr;
    if (totalCorr > maxCorr) {
      maxCorr = totalCorr;
      bestI = i;
    }
    i++;
    jlag++;
  } while (jlag <= Right_lag);
  

  /*-------------------------------------------------------
    use quadratic interpolation to get refined pitch.
    -------------------------------------------------------*/
  bestLag = bestI+Left_lag;

  if ((bestLag > Left_lag) && (bestLag < Right_lag)) 
    refine_pitch = (float)bestLag + QuadraticPeak(pCorrCosts[bestI-1], 
                       maxCorr, pCorrCosts[bestI+1], maxCost);
  else {
    refine_pitch = (float)bestLag;
    *maxCost = maxCorr;
  }
  
  /*------------------------------------------------------------
    now normalized the cost value.
    ------------------------------------------------------------*/
  /* calculate energy of psigBuf[0:win_length-bestLag-1] and psigBuf[bestLag:win_length-1] */
  eng1 = (float)DotProd(psigBuf, psigBuf, win_length-bestLag);
  eng2 = (float)DotProd(psigBuf+bestLag, psigBuf+bestLag, win_length-bestLag);

  *maxCost *= (biasTab[bestLag-LPITCH_MIN]/((float)sqrt((double)eng1*eng2+MINCON)));


  STACK_END
  return refine_pitch;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\coder.c ===
/******************************************************************************
*                        Voxware Proprietary Material
*                        Copyright 1996, Voxware, Inc
*                            All Rights Reserved
*
*                       DISTRIBUTION PROHIBITED without
*                      written authorization from Voxware
******************************************************************************/
 
/******************************************************************************
* Filename:        Coder.c
*
* Purpose:         Code parameters for both SC3 and SC6
*
* Functions:   VoxQuantSC3, VoxQuantSC6, VoxUnQuantSC3 and VoxUnQuantSC6,
*              VoxInitQuantizer and VoxFreeQuantizer
*
* Author/Date:     Bob Dunn 1/22/97
*******************************************************************************
*
* Modifications:  Clean up the code by Wei Wang, 1/27/98
*
* Comments:
*
* Concerns:
*
* $Header:   /export/phobos/pvcs/r_and_d/archives/scaleable/quan/Coder.c_v   1.9   13 Apr 1998 16:17:44   weiwang  $
******************************************************************************/
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <assert.h>

#include "VoxMem.h"
#include "codec.h"
#include "paramSC.h"
#include "CodeStr.h"
#include "SVqPhase.h"
#include "QP0SC3.h"
#include "quansc36.h"
#include "CodeGain.h"
#include "CodePv.h"
#include "MSVqPred.h"
#include "VqResi.h"
#include "Coder.h"

#ifndef DECODE_ONLY
#include "EncSC.h"
#endif

#include "DecPlsSC.h"

#include "xvocver.h"


#ifndef DECODE_ONLY
/******************************************************************************
*
* Function:  VoxQuantSC3
*
* Action:    Quantize parameters for SC3
*
* Input:     STACK_R -- the pointer to the Voxware stack 
*            piQuanIndex -- quantization indices
*            pvParamMblk_1 -- parameter structure of previous frame
*            pvParamMblk -- parameter structure of the current frame
*
* Output:    piQuanIndex -- the updated quantization indices
*            pvParamMblk -- quantized parameters (except gain)
*
* Globals:   none
*
* Return:    void
*******************************************************************************
*
* Implementation/Detailed Description:
*
* References:
*******************************************************************************
*
* Modifications:
*
* Comments:  
*
* Concerns/TBD:
******************************************************************************/

void VoxQuantSC3(STACK_R int *piQuanIndex, void *pvEncMblk,
                 void *pvParamMblk)
{
   ENC_MEM_BLK *pEncMblk = (ENC_MEM_BLK *)pvEncMblk;
   PARAM_SC *pParamMblk   = (PARAM_SC *)pvParamMblk;
   SUBFRAME_PARAM_SC *pSubParam_Mid, *pSubParam_End;


   assert((piQuanIndex != NULL) && (pvEncMblk != NULL));
   assert(pvParamMblk != NULL);

   pSubParam_Mid = &(pParamMblk->SubParam[PARAM_MIDFRAME]); 
   pSubParam_End = &(pParamMblk->SubParam[PARAM_ENDFRAME]); 

   /*--------------------------------------------------------
     Quantize VOICING and Get the quantized voicing.
     Quantize voicing vector on outer frame boundary
     -----------------------------------------------------*/
   piQuanIndex[INDEX_PV] = QuanPvSC3(pEncMblk->Pv_1, pSubParam_Mid->Pv,
                                     pSubParam_End->Pv);
   UnQuanPvSC3(piQuanIndex[INDEX_PV], pEncMblk->Pv_1,
               &(pSubParam_Mid->Pv), &(pSubParam_End->Pv));

 
   /*--------------------------------------------------------
     Quantize PITCH and Get the quantized pitch
     Quantize pitch on outer frame boundary
     -----------------------------------------------------*/
   piQuanIndex[INDEX_PITCH] = VoxQuanPitchSC3(pSubParam_End->Pitch);
   pSubParam_End->Pitch = VoxUnQuanPitchSC3(piQuanIndex[INDEX_PITCH]);

  
   /*------------------------------------------------------------------------
     Get the quantized the middle frame pitch:
     No frame-fill bits: Use voicing-dependent, 20ms  pitch interpolation
     -------------------------------------------------------------------------*/
   pSubParam_Mid->Pitch = UnQuanMidPitchSC3(pEncMblk->Pitch_1,
                                            pSubParam_End->Pitch,
                                            pEncMblk->Pv_1,
                                            pSubParam_End->Pv);
   
   /*--------------------------------------------------------
     Quantize GAIN
     Quantize gain on outer frame boundary
     -----------------------------------------------------*/
   piQuanIndex[INDEX_GAIN] = QuanGainSC3(pParamMblk->fLog2Gain);
  
   
   /*--------------------------------------------------------
     Preserve the unquantized ASKs.
     --------------------------------------------------------*/
   memcpy(pParamMblk->pfASKunquant, pParamMblk->pfASK, LPC_ORDER*sizeof(float));

   /*-----------------------------------------------------
     Quantize ASKs on outer frame boundary and Get the
     quantized ASKs.
     -----------------------------------------------------*/
   VoxMSVQEncPred( STACK_S pParamMblk->pfASK,
                   &(piQuanIndex[INDEX_ASK]),
                   LPC_ORDER,
                   pSubParam_End->Pv);

   /*-----------------------------------------------------
      Update the memory 
     ----------------------------------------------------*/
    pEncMblk->Pv_1 = pSubParam_End->Pv;
    pEncMblk->Pitch_1 = pSubParam_End->Pitch;
}



/******************************************************************************
*
* Function:  VoxQuantSC6
*
* Action:    Quantize parameters for SC6
*
* Input:     piQuanIndex -- pointer to quantization indices
*            pvParamMblk -- parameter structure of the current frame
*
* Output:    piQuanIndex -- the updated quantization indices
*
* Globals:   none
*
* Return:    void
*******************************************************************************
*
* Implementation/Detailed Description:
*
* References:
*******************************************************************************
*
* Modifications:
*
* Comments:  
*
* Concerns/TBD:
******************************************************************************/

void VoxQuantSC6(int *piQuanIndex, void *pvParamMblk)
{
   PARAM_SC    *pParamMblk   = (PARAM_SC *)pvParamMblk;
   SUBFRAME_PARAM_SC *pSubParam_Mid, *pSubParam_End;

   assert((piQuanIndex != NULL) && (pvParamMblk != NULL));


   pSubParam_Mid = &(pParamMblk->SubParam[PARAM_MIDFRAME]); 
   pSubParam_End = &(pParamMblk->SubParam[PARAM_ENDFRAME]); 

   /*--------------------------------------------------------
     Quantize Phase
     --------------------------------------------------------*/
   /*-----------------------------------------------------
     Compute the predicted phase based on the quantized pitch
     -----------------------------------------------------*/
   VoxEncPhasePrediction(pSubParam_Mid->Pitch, pSubParam_End->Pitch,
                         pSubParam_Mid->pfVEVphase, 
                         pSubParam_End->pfVEVphase);
  
   /*-----------------------------------------------------
     Vector quantize mid-frame and outer frame Phases
     -----------------------------------------------------*/
   VoxSVQEncPhase(pSubParam_Mid->pfVEVphase, pSubParam_End->pfVEVphase, 
                  &(piQuanIndex[INDEX_PHASE]));
  
   /*--------------------------------------------------------
     Quantize the residue ASKs
     --------------------------------------------------------*/
   VoxASKResiEnc(pParamMblk->pfASK, pParamMblk->pfASKunquant, 
                 &(piQuanIndex[INDEX_ASKRESI]));
}
#endif

/******************************************************************************
*
* Function:  VoxUnQuantSC3
*
* Action:    Unquantize parameters for SC3
*
* Input:     STACK_R -- stack memory pointer
*            piQuanIndex -- quantization indices
*            pvParamMblk_1 -- parameter structure of previous frame
*            pvParamMblk -- parameter structure of the current frame
*
* Output:    pvParamMblk -- quantized parameters 
*
* Globals:   none
*
* Return:    void
*******************************************************************************
*
* Implementation/Detailed Description:
*
* References:
*******************************************************************************
*
* Modifications:
*
* Comments:  
*
* Concerns/TBD:
******************************************************************************/

void VoxUnQuantSC3(STACK_R int *piQuanIndex, void *pvDecMblk,
                   void *pvParamMblk)
{
   PARAM_SC *pParamMblk   = (PARAM_SC *)pvParamMblk;
   float Pv_1;
   float Pitch_1;
   SUBFRAME_PARAM_SC *pSubParam_Mid, *pSubParam_End;

   assert((piQuanIndex != NULL) && (pvDecMblk != NULL));
   assert(pvParamMblk != NULL);

   pSubParam_Mid = &(pParamMblk->SubParam[PARAM_MIDFRAME]); 
   pSubParam_End = &(pParamMblk->SubParam[PARAM_ENDFRAME]); 

   Pv_1    = VoxGetDecPrevPvSC(pvDecMblk);
   Pitch_1 = VoxGetDecPrevPitchSC(pvDecMblk);

   /*--------------------------------------------------------
     UnQuantize VOICING
     Since Pv was used to quantize mid-frame pitch,
     it must be unquantized first
     --------------------------------------------------------*/
   /*-------------------------------------------------------
   Unquantize voicing vector of two subframes 
   -------------------------------------------------------*/
   UnQuanPvSC3(piQuanIndex[INDEX_PV], Pv_1,
               &(pSubParam_Mid->Pv), &(pSubParam_End->Pv));

   /*--------------------------------------------------------
     UnQuantize PITCH
     --------------------------------------------------------*/
   /*--------------------------------------------------------
     UnQuantize pitch on 20ms outer frame boundary
     --------------------------------------------------------*/
   pSubParam_End->Pitch = VoxUnQuanPitchSC3(piQuanIndex[INDEX_PITCH]);

   /*--------------------------------------------------------
     No frame-fill bits: Use voicing-dependent, 20ms pitch interpolation
     --------------------------------------------------------*/
   pSubParam_Mid->Pitch = UnQuanMidPitchSC3(Pitch_1,
                                            pSubParam_End->Pitch,
                                            Pv_1,
                                            pSubParam_End->Pv);

   /*--------------------------------------------------------
     UnQuantize GAIN
     --------------------------------------------------------*/
   /*--------------------------------------------------------
     UnQuantize gain on outer frame boundary
     --------------------------------------------------------*/
   pParamMblk->fLog2Gain = UnQuanGainSC3(piQuanIndex[INDEX_GAIN]);


   /*--------------------------------------------------------
     UnQuantize ASK
     --------------------------------------------------------*/

   /*--------------------------------------------------------
     UnQuantize ASKs on outer frame boundary
     --------------------------------------------------------*/
   VoxMSVQDecPred( STACK_S &(piQuanIndex[INDEX_ASK]), pParamMblk->pfASK,
                   LPC_ORDER, pSubParam_End->Pv);
}


/******************************************************************************
*
* Function:  VoxUnQuantSC6
*
* Action:    Unquantize parameters for SC6
*
* Input:     piQuanIndex -- quantization indices
*            pvParamMblk -- parameter structure of the current frame
*
* Output:    pvParamMblk -- pointer to the quantized parameters
*
* Globals:   none
*
* Return:    void
*******************************************************************************
*
* Implementation/Detailed Description:
*
* References:
*******************************************************************************
*
* Modifications:
*
* Comments:  
*
* Concerns/TBD:
******************************************************************************/

void VoxUnQuantSC6(int *piQuanIndex,void *pvParamMblk)
{
   PARAM_SC *pParamMblk   = (PARAM_SC *)pvParamMblk;
   SUBFRAME_PARAM_SC *pSubParam_Mid, *pSubParam_End;

   assert((piQuanIndex != NULL) && (pvParamMblk != NULL));

   pSubParam_Mid = &(pParamMblk->SubParam[PARAM_MIDFRAME]); 
   pSubParam_End = &(pParamMblk->SubParam[PARAM_ENDFRAME]); 

   /*--------------------------------------------------------
     UnQuantize Phase
     --------------------------------------------------------*/
   /*--------------------------------------------------------
     UnQuantize mid-frame and outer frame Phase Vectors
     --------------------------------------------------------*/
   VoxSVQDecPhase(&(piQuanIndex[INDEX_PHASE]), pSubParam_Mid->pfVEVphase,
                  pSubParam_End->pfVEVphase);

   /*-----------------------------------------------------
     Compute the mid-frame phase from the quantized phase prediction
     -----------------------------------------------------*/
   VoxDecPhasePrediction(pSubParam_Mid->Pitch, pSubParam_End->Pitch,
                         pSubParam_Mid->pfVEVphase,
                         pSubParam_End->pfVEVphase);

   /*--------------------------------------------------------
     UnQuantize ASK residuals
     --------------------------------------------------------*/
   VoxASKResiDec(pParamMblk->pfASK, &(piQuanIndex[INDEX_ASKRESI]));
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\codepv.h ===
/******************************************************************************
*                        Voxware Proprietary Material
*                        Copyright 1996, Voxware, Inc
*                            All Rights Reserved
*
*                       DISTRIBUTION PROHIBITED without
*                      written authorization from Voxware
******************************************************************************/
 
/******************************************************************************
*
* Filename:        CodePv.h
*
* Purpose:         quantize / unquantize voicing vector
*
* Functions:   QuanPvSC3(), UnQuanPvSC3()
*
* Author/Date:     Wei Wang,   06/10/97
*
*******************************************************************************
*
* Modifications: Clean up the program by Wei Wang, 01/27/98
*
* Comments:
*
* Concerns:
*
* $Header:   /export/phobos/pvcs/r_and_d/archives/scaleable/quan/CodePv.h_v   1.4   13 Apr 1998 16:17:40   weiwang  $
*
******************************************************************************/

#ifndef _CODEPV_H_
#define _CODEPV_H_

/******************************************************************************
*
* Function:  int QuanPvSC3(  float Pv_1,  float Pv_Mid, float Pv)
*
* Action:    Quantize voicing for SC36
*
* Input:     Pv_1 -- voicing of the previous frame
*            Pv_Mid -- voicing of the middle frame
*            Pv     -- voicing of the end frame
*
* Output:    same as the return
*
* Globals:   none
*
* Return:    index from the voicing quantizer
******************************************************************************/

int QuanPvSC3(  float Pv_1,  float Pv_Mid, float Pv);


/******************************************************************************
*
* Function:  void UnQuanPvSC3( int index,  float Pv_1,
*                              float *Pv_Mid, float *Pv)
*
* Action:    Unquantize voicing for SC36
*
* Input:     index -- the quantization index for Pvs.
*            Pv_1 -- voicing of the previous frame
*            Pv_Mid -- pointer to the voicing of the middle frame
*            Pv     -- pointer to the voicing of the end frame
*
* Output:    Pv_Mid -- voicing of the middle frame
*            Pv     -- voicing of the end frame
*
* Globals:   none
*
* Return:    none
*******************************************************************************/

void UnQuanPvSC3(  int index,  float Pv_1, float *Pv_Mid, float *Pv);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\codepv.c ===
/******************************************************************************
*                        Voxware Proprietary Material
*                        Copyright 1996, Voxware, Inc
*                            All Rights Reserved
*
*                       DISTRIBUTION PROHIBITED without
*                      written authorization from Voxware
******************************************************************************/
 
/******************************************************************************
*
* Filename:        CodePv.c
*
* Purpose:         quantize / unquantize voicing vector
*
* Functions:   QuanPvSC3(), UnQuanPvSC3()
*
* Author/Date:     Wei Wang,   06/10/97
*
*******************************************************************************
*
* Modifications: Clean up the program by Wei Wang, 01/27/98
*
* Comments:
*
* Concerns:
*
* $Header:   /export/phobos/pvcs/r_and_d/archives/scaleable/quan/CodePv.c_v   1.6   13 Apr 1998 16:17:40   weiwang  $
*
******************************************************************************/

#include <stdlib.h>
#include <assert.h>

/* Use scalar quantizer. ==> I need to redesign it use better condition */
#include "vLibQuan.h"

#include "quansc36.h"
#include "CodePv.h"

#include "xvocver.h"

/* 3 bits Pv + 1 bits frame-fill. */
#define LENGTH_PV_CB              (int)(1<<(BITS_PV_SC3-1))

static const float PvCodeBook[LENGTH_PV_CB] = {
  0.0F, 0.143F, 0.286F, 0.429F, 0.571F, 0.714F, 0.857F, 1.0F
};

#ifndef DECODE_ONLY
/******************************************************************************
*
* Function:  int QuanPvSC3(  float Pv_1,  float Pv_Mid, float Pv)
*
* Action:    Quantize voicing for SC36
*
* Input:     Pv_1 -- voicing of the previous frame
*            Pv_Mid -- voicing of the middle frame
*            Pv     -- voicing of the end frame
*
* Output:    same as the return
*
* Globals:   none
*
* Return:    index from the voicing quantizer
*******************************************************************************
*
* Implementation/Detailed Description: 3-bits scalar quantizer + 1-bit frame-fill
*
* References:
*******************************************************************************
*
* Modifications:
*
* Comments:  
*
* Concerns/TBD:
******************************************************************************/

int QuanPvSC3(  float Pv_1,  float Pv_Mid, float Pv)
{
  int index, index_ff = 0;
  float t1, t2;

  /* scalar-quantize the end frame Pv */
  index = ScalarQuant(Pv, PvCodeBook, LENGTH_PV_CB );
  
  /* then do one bit frame-fill of the middle-frame Pv */
  t1 = Pv_1-Pv_Mid;
  t1 = t1*t1;

  t2 = PvCodeBook[index]-Pv_Mid;
  t2 = t2*t2;

  if (t2 < t1)
    index_ff = 1;

  /* pack the index */
  index += (index_ff<<(BITS_PV_SC3-1));

  return index;
}
#endif

/******************************************************************************
*
* Function:  void UnQuanPvSC3( int index,  float Pv_1,
*                              float *Pv_Mid, float *Pv)
*
* Action:    Unquantize voicing for SC36
*
* Input:     index -- the quantization index for Pvs.
*            Pv_1 -- voicing of the previous frame
*            Pv_Mid -- pointer to the voicing of the middle frame
*            Pv     -- pointer to the voicing of the end frame
*
* Output:    Pv_Mid -- voicing of the middle frame
*            Pv     -- voicing of the end frame
*
* Globals:   none
*
* Return:    none
*******************************************************************************
*
* Implementation/Detailed Description: 3-bits scalar quantizer + 1-bit frame-fill
*
* References:
*******************************************************************************
*
* Modifications:
*
* Comments:  
*
* Concerns/TBD:
******************************************************************************/

void UnQuanPvSC3(  int index,  float Pv_1, float *Pv_Mid, float *Pv)
{
  int index1, index2;

  assert(Pv_Mid != NULL);
  assert(Pv != NULL);

  /* unpack the bits */
  index2 = index & (LENGTH_PV_CB);
  index1 = index - index2;
  
  /* unquan the 3-bit scalar quantizer */
  *Pv = ScalarLUT( PvCodeBook, LENGTH_PV_CB, index1);
  
  /* unquan the 1-bit frame-fill */
  if (index2 == 0)
    *Pv_Mid = Pv_1;
  else
    *Pv_Mid = *Pv;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\codegain.c ===
/******************************************************************************
*
*                        Voxware Proprietary Material
*
*                        Copyright 1996, Voxware, Inc
*
*                            All Rights Reserved
*
*
*
*                       DISTRIBUTION PROHIBITED without
*
*                      written authorization from Voxware
*
******************************************************************************/
 
/******************************************************************************
*
* Filename:        CodeGain.c
*
* Purpose:         quantize / unquantize gain
*
* Functions:   QuanGainSC3(),  UnQuanGainSC3()
*
* Author/Date:     Wei Wang,   06/10/97
*
*******************************************************************************
*
* Modifications:
*
* Comments:
*
* Concerns:
*
* $Header:   /export/phobos/pvcs/r_and_d/archives/scaleable/quan/CodeGain.c_v   1.3   20 Mar 1998 10:30:12   weiwang  $
*
******************************************************************************/

#include <assert.h>

#include "quansc36.h"
#include "vLibQuan.h"
#include "CodeGain.h"

#include "xvocver.h"


#define LENGTH_Gain_CB              (int)(1<<BITS_GAIN_SC3)


static const float GainCodeBook[LENGTH_Gain_CB] = {
#include "Gain6bit.h"
};

#ifndef DECODE_ONLY
/******************************************************************************
*
* Function:  int QuanGainSC3(float flog2Gain)
*
* Action:    Quantize gain for SC36 using scalar quantizer
*
* Input:     flog2Gain -- input log2(Gain) for quantization.
*
* Output:    same as the return
*
* Globals:   none
*
* Return:    index from the gain quantizer
*******************************************************************************
*
* Implementation/Detailed Description: 
*
* References:
*******************************************************************************
*
* Modifications:
*
* Comments:  
*
* Concerns/TBD:
******************************************************************************/

int QuanGainSC3(float flog2Gain)
{
  int iIndex;

  iIndex = ScalarQuant(flog2Gain, GainCodeBook, LENGTH_Gain_CB);

  return iIndex;
}
#endif


/******************************************************************************
*
* Function:  float UnQuanGainSC3(int iIndex)
*
* Action:    unquantize gain for SC36
*
* Input:     iIndex -- index from gain quantizer.
*
* Output:    same as the return
*
* Globals:   none
*
* Return:    quantized log2(Gain)
*******************************************************************************
*
* Implementation/Detailed Description: 3-bits scalar quantizer + 1-bit frame-fill
*
* References:
*******************************************************************************
*
* Modifications:
*
* Comments:  
*
* Concerns/TBD:
******************************************************************************/

float UnQuanGainSC3(int iIndex)
{
  float flog2Gain;

  flog2Gain = ScalarLUT( GainCodeBook, LENGTH_Gain_CB, (unsigned int) iIndex);
  
  return flog2Gain;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\centcorr.h ===
#ifndef _CENTCORR_H_
#define _CENTCORR_H_

/***********************************************************************
 *
 * Filename: CentCorr.c
 *
 * Purpose:  centerize the pitch by calculating cross-correlation.
 *
 * Reference: "Super Resolution Pitch Determination of Speech Signals".
 *             By Y. Medan, etc. IEEE ASSP, 1991.
 *
 * Author:   Wei Wang
 *
 * Date:     Oct. 09, 1996.
 *
 ***********************************************************************/


float calcCenterCorr(STACK_R CorrPDA_mblk *myCorrPDA_mblk, float *lpfBuf1, int pitch, 
		     float *maxCost );

#endif /* end of #ifndef _CENTCORR_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\codec.h ===
/*******************************************************************************
*                        Voxware Proprietary Material                          *
*                        Copyright 1996, Voxware, Inc                          *
*                            All Rights Reserved                               *
*                                                                              *
*                       DISTRIBUTION PROHIBITED without                        *
*                      written authorization from Voxware                      *
******************************************************************************/

/*******************************************************************************
* Filename:       Codec.h
*                                                                              
* Purpose:        Provides global defines for entire codec
*                                                                              
* Author/Date:    Ilan Berci  96/10/25
********************************************************************************
* $Header:   /export/phobos/pvcs/r_and_d/archives/scaleable/include/codec.h_v   1.10   13 Apr 1998 18:26:22   weiwang  $                                                                     
******************************************************************************/

/* The objective is to keep this file as SMALL AS POSSIBLE!!!! */

#ifndef _CODEC_H
#define _CODEC_H

#undef PI

#ifndef PI
#define PI           3.1415926535897931032F
#define TWOPI        6.2831853071795862064F
#define INVTWOPI     0.1591549430918953456F
#define PIO2         1.5707963267948965580F
#endif /* PI */

#define D_PI         (double)(PI*(double)2.0)
#define D_PI_PERIOD  (double)(D_PI/(double)8000)

/***** Frame length...80 samples in 10ms sub-frame *****/
#define HALF_FRAME_LENGTH_SC   80
#define FRAME_LENGTH_SC        (HALF_FRAME_LENGTH_SC<<1)

/***** DATA length for coarse pitch analysis *****/
#define PDA_FRAME_SIZE0        291   /** was 261**/
#define INV_PEA_FRAME_SIZE0    (1.0F/(float)PDA_FRAME_SIZE0)

/***** DATA length for pitch-adaptive analysis *****/

#define PDA_FRAME_SIZE1        261   /** 32.5ms **/
#define PDA_FRAME_SIZE2        241   /** 30.0ms **/
#define PDA_FRAME_SIZE3        221   /** 27.5ms **/
#define PDA_FRAME_SIZE4        201   /** 25.0ms **/
#define PDA_FRAME_SIZE5        181   /** 22.5ms **/
#define PDA_FRAME_SIZE6        161   /** 20.0ms **/
#define PDA_FRAME_SIZE7        161   /** 20.0ms **/
#define PDA_FRAME_SIZE8        161   /** 20.0ms **/
#define PDA_FRAME_SIZE9        161   /** 20.0ms **/
#define PDA_FRAME_SIZE10       161   /** 20.0ms **/


/* The maximum number of harmonics is 4000*0.9275/64 = 58 */
#define MAXHARM            100    
#define MAXHARM_2          50


/*** Pitch period range in samples ***/
#define MIN_PITCH      8      /** 500Hz...was 16 (500Hz) **/
#define MAX_PITCH      160     /** 64Hz...was 165 (50Hz) **/


/*** Initial Pitch in DFT points ***/
#define INITIAL_PITCH     100.0F
#define INITIAL_PITCH_DFT 5    /** ~75Hz using 512-pt FFT and 8000Hz sampling */


/*** Analysis FFT parameters ***/
#define NFFT              512
#define NFFT_2            256
#define NFFT_4            128
#define FFT_ORDER           9

#define INV_NFFT        (1.0F/(float)NFFT)

#define RATE8K           8000   /* sampling rate */
#define HZ2DFT           ((float)NFFT/(float)RATE8K)
#define TWOPIONFFT       (TWOPI/(float)NFFT)

/*** Define number of measured phases for 6K bit rate ***/
#define SC6_PHASES          8

 
/***** Spectral parameters */
#define LPC_ORDER         12  /* LPC order for onset estimation */

#define ORDER_CEPSTRAL    44   

#define ASK_RES_ORDER      2

/***** preprocessing and circular buffer parameters *****/
#define PREPROC_COEF         0.99F

/* to be analysed */
#define CIRCBUF_LENGTH       (PDA_FRAME_SIZE0+HALF_FRAME_LENGTH_SC) 



#define CSENVDWNSMP         2  /* amount to downsample cs2env      */
#define CSENV_FFT_ORDER    (FFT_ORDER-CSENVDWNSMP)
#define CSENV_NFFT         (1<<CSENV_FFT_ORDER)
#define CSENV_NFFT_2       (CSENV_NFFT>>1)


/*-------------------------------------------------------
  Definitions for FHT 
  -------------------------------------------------------*/
#define FHT_EXP_SHIFT     8
#define FHT_EXP_SIZE      (1<<FHT_EXP_SHIFT)


/*------------------------------------------------------------
  project related defintions 
  ------------------------------------------------------------*/
/***** delay related definitions for LM project *****/
#define ENC_DELAY_SIZE  (PDA_FRAME_SIZE0>>1)  /****** the encoder delay ******/

/***** definition related to pitch refinement (for both RefineC0.c and MidPitch.c) *****/
#define MAX_DELTA   4            /***** maximum time-domain pitch refinement range ****/

#define   SRANGE1      0.75F
#define   FRACTION1    0.375F

#define   SRANGE2      0.25F 
#define   FRACTION2    0.125F


#define EPS 1e-16F

#define F0_SHIFT_BITS               12
#define SCALED_05                   ((long)1<<(F0_SHIFT_BITS-1))

#define COMPRESS_RATIO_MAG           0.125F   /* 0.25/2 */

#define POLY_ORDER_p1  6
#define N_REGION       6

#define   F0_SHIFT_11B          11
#define VF_CEP_ORDER         12
#define INV_ORDER            (1.0F/(float)VF_CEP_ORDER)
#define VF_BAD_PITCH         1000.0F

#define NOISE_LEVEL  0.001F  /** add noise to the coarse pitch FFT for stability...was 1.0 **/
#define NOISE_FLOOR     0.00001F     /* reject STFT peaks 50dB down */

#define PARAM_MIDFRAME     0
#define PARAM_ENDFRAME     1

#endif /* _CODEC_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\codegain.h ===
/******************************************************************************
*
*                        Voxware Proprietary Material
*
*                        Copyright 1996, Voxware, Inc
*
*                            All Rights Reserved
*
*
*
*                       DISTRIBUTION PROHIBITED without
*
*                      written authorization from Voxware
*
******************************************************************************/
 
/******************************************************************************
*
* Filename:        CodeGain.h
*
* Purpose:         quantize / unquantize gain
*
* Functions:   QuanGainSC3(),  UnQuanGainSC3()
*
* Author/Date:     Wei Wang,   06/10/97
*
*******************************************************************************
*
* Modifications:
*
* Comments:
*
* Concerns:
*
* $Header:   /export/phobos/pvcs/r_and_d/archives/scaleable/quan/CodeGain.h_v   1.1   16 Mar 1998 15:25:54   weiwang  $
*
******************************************************************************/

#ifndef _CODEGAIN_H_
#define _CODEGAIN_H_


/******************************************************************************
*
* Function:  int QuanGainSC3(float flog2Gain)
*
* Action:    Quantize gain for SC36 using scalar quantizer
*
* Input:     flog2Gain -- input log2(Gain) for quantization.
*
* Output:    same as the return
*
* Globals:   none
*
* Return:    index from the gain quantizer
*******************************************************************************/

int QuanGainSC3(float flog2Gain);


/******************************************************************************
*
* Function:  float UnQuanGainSC3(int iIndex)
*
* Action:    unquantize gain for SC36
*
* Input:     iIndex -- index from gain quantizer.
*
* Output:    same as the return
*
* Globals:   none
*
* Return:    quantized log2(Gain)
*******************************************************************************/

float UnQuanGainSC3(int iIndex);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\coder.h ===
/******************************************************************************
*                        Voxware Proprietary Material
*                        Copyright 1996, Voxware, Inc
*                            All Rights Reserved
*
*                       DISTRIBUTION PROHIBITED without
*                      written authorization from Voxware
******************************************************************************/
 
/******************************************************************************
* Filename:        Coder.h
*
* Purpose:         Code parameters for both SC3 and SC6
*
* Functions:   VoxQuantSC3, VoxQuantSC6, VoxUnQuantSC3 and VoxUnQuantSC6,
*              VoxInitQuantizer and VoxFreeQuantizer
*
* Author/Date:     Bob Dunn 1/22/97
*******************************************************************************
*
* Modifications:  Clean up the code by Wei Wang, 1/27/98
*
* Comments:
*
* Concerns:
*
* $Header:   /export/phobos/pvcs/r_and_d/archives/scaleable/quan/Coder.h_v   1.3   06 Apr 1998 17:32:50   weiwang  $
******************************************************************************/

#ifndef _CODER_H
#define _CODER_H

/******************************************************************************
*
* Function:  VoxQuantSC3
*
* Action:    Quantize parameters for SC3
*
* Input:     STACK_R -- the pointer to the Voxware stack 
*            piQuanIndex -- quantization indices
*            pvParamMblk_1 -- parameter structure of previous frame
*            pvParamMblk -- parameter structure of the current frame
*
* Output:    piQuanIndex -- the updated quantization indices
*            pvParamMblk -- quantized parameters (except gain)
*
* Globals:   none
*
* Return:    void
*******************************************************************************/
void VoxQuantSC3(STACK_R int *piQuanIndex, void *pvEncMblk,
                 void *pvParamMblk);


/******************************************************************************
*
* Function:  VoxQuantSC6
*
* Action:    Quantize parameters for SC6
*
* Input:     piQuanIndex -- pointer to quantization indices
*            pvParamMblk -- parameter structure of the current frame
*
* Output:    piQuanIndex -- the updated quantization indices
*
* Globals:   none
*
* Return:    void
*******************************************************************************/

void VoxQuantSC6(int *piQuanIndex, void *pvParamMblk);


/******************************************************************************
*
* Function:  VoxUnQuantSC3
*
* Action:    Unquantize parameters for SC3
*
* Input:     STACK_R -- stack memory pointer
*            piQuanIndex -- quantization indices
*            pvParamMblk_1 -- parameter structure of previous frame
*            pvParamMblk -- parameter structure of the current frame
*
* Output:    pvParamMblk -- quantized parameters 
*
* Globals:   none
*
* Return:    void
*******************************************************************************/
void VoxUnQuantSC3(STACK_R int *piQuanIndex, void *pvDecMblk,
                   void *pvParamMblk);

/******************************************************************************
*
* Function:  VoxUnQuantSC6
*
* Action:    Unquantize parameters for SC6
*
* Input:     piQuanIndex -- quantization indices
*            pvParamMblk -- parameter structure of the current frame
*
* Output:    pvParamMblk -- pointer to the quantized parameters
*
* Globals:   none
*
* Return:    void
*******************************************************************************/
void VoxUnQuantSC6(int *piQuanIndex,void *pvParamMblk);

#endif /* _CODER_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\corrcost.h ===
/***********************************************************************
 *
 * File: CorrCost.h
 *
 * Purpose: Calculate cross correlator based pitch cost function. Use
 *          subframes instead of full frame. Then dynamicly align the
 *          correlation cost values and normalize them.
 *
 * Reference: (1) "A 5.85kb/s CELP Algorithm For Cellular Application."
 *                 W. Kleijn etc, ICASSP 1993, p.596.
 *            (2) Email from W. Kleijn to B. McAulay, 1995.
 *
 * Author:    Wei Wang
 *
 * Date:      Oct. 08, 1996
 *
 * $Header:   /export/phobos/pvcs/r_and_d/archives/realtime/pda/CorrCost.h_v   1.2   12 May 1998 12:55:06   weiwang  $
 ***********************************************************************/

#ifndef _CORRCOST_H_
#define _CORRCOST_H_


void VoxCalcCrossCorrCost(STACK_R float *sigBuf, float *normcost, 
		       CorrPDA_mblk *myCorrPDA_mblk, float *pbias_floor);


#endif
/* end of #ifndef _CORRCOST_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\codestr.h ===
/*****************************************************************************
 *                        Voxware Proprietary Material                       *
 *                        Copyright 1996, Voxware Inc.                       *
 *                        All Rights Reserved                                *
 *                                                                           *
 *                        DISTRIBUTION PROHIBITED without                    *
 *                        written authorization from Voxware.                *
 *****************************************************************************/

/******************************************************************************
* Filename:    CodeStr.h
*
* Purpose:     index structure which is referenced by Coder.c and PackSC.c
*
* Functions:   
*
* Author/Date:     Bob Dunn 7/18/97
*******************************************************************************
*
* Modifications: Cleaned up by Wei Wang Feb. 5, 1998
*
* Comments: 
*
* Concerns:
*
* $Header:   /export/phobos/pvcs/r_and_d/archives/scaleable/quan/CodeStr.h_v   1.3   13 Apr 1998 16:17:42   weiwang  $
******************************************************************************/
#ifndef _CODESTR_H
#define _CODESTR_H

#include "codec.h"

#define INDEX_PITCH   0
#define INDEX_GAIN    1
#define INDEX_PV      2
#define INDEX_ASK     3     /* [LPC_ORDER] */
#define INDEX_RESERVE_BIT_SC3 (INDEX_ASK+LPC_ORDER)
#define INDEX_FLAG_BIT_SC3 (INDEX_ASK+LPC_ORDER+1)

#define TOTAL_SC3_QUAN_INDICES   (INDEX_FLAG_BIT_SC3+1)

#define INDEX_ASKRESI 0      /* [ASK_RES_ORDER] */
#define INDEX_PHASE   ASK_RES_ORDER    /* [SC6_PHASES] */
#define INDEX_RESERVE_BIT_SC6    (INDEX_PHASE+SC6_PHASES)
#define INDEX_FLAG_BIT_SC6       (INDEX_RESERVE_BIT_SC6+1)

#define EXTRA_SC6_QUAN_INDICES   (INDEX_FLAG_BIT_SC6+1)


#endif /*_CODESTR_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\comppow.c ===
/*******************************************************************************
*                        Voxware Proprietary Material                          *
*                        Copyright 1997, Voxware, Inc                          *
*                            All Rights Reserved                               *
*                                                                              *
*                       DISTRIBUTION PROHIBITED without                        *
*                      written authorization from Voxware                      *
*******************************************************************************/
/*******************************************************************************
* Filename:     CompPow.c
*                                                                              
* Purpose:      approximate pow(x, 1/8) using polynomial evaluation.
*                                                                              
* Functions:    powerpoly_125()
*                                                                              
* Author/Date:  Wei Wang, 07/08/97. (powerpoly_125 is modified from RZ's 
*               code in enhance.c of RT29).
********************************************************************************
* Modifications:
*                                                                              
* Comments:                                                                    
* 
* Concerns:
*
* $Header:   /export/phobos/pvcs/r_and_d/archives/scaleable/pea/CompPow.c_v   1.2   02 Apr 1998 14:46:54   weiwang  $
*******************************************************************************/

#include <assert.h>
#include "CompPow.h"
#include "vLibType.h"

#include "xvocver.h"

#define POLY_ORDER_p1  6
#define N_REGION       6

const static float cpfBoundary[N_REGION+1] = {
1.0F, 1.0e-1F, 1.0e-2F, 1.0e-3F, 1.0e-4F, 1.0e-5F, 1.0e-6F
};

/* scale factor is 1.0/Boundary */
const static float cpfScaleFactor[N_REGION] = {
1.0F, 1.0e+1F, 1.0e+2F, 1.0e+3F, 1.0e+4F, 1.0e+5F
};

const static float cpfPowTab_125[N_REGION*POLY_ORDER_p1] = {
#include "pow_125.h"
}; 

/*******************************************************************************
* Function:        powerpoly_125()
*
* Action:         calculate fX^(1/8)
*
* Input:          fX -- floating number which should be between [0 1].
*
* Output:         none
*
* Globals:        none
*
* Return:         fX^(0.125)
********************************************************************************
* Implementation/Detailed Description:
*     - routine is for a 5th order approximation.
*     - polynomial should be :
*         z = y(0).x^5 + y(1).x^4 ... + y(4).x + y(5)
*
*     - x^y is broken into 4 parts accroding to x (x always > 1)
*           poly1 : 1         <= x < BOUNDARY1
*           poly2 : BOUNDARY1 <= x < BOUNDARY2
*           poly3 : BOUNDARY2 <= x < BOUNDARY3
*           poly4 : BOUNDARY3 <= x < BOUNDARYMAX
*
*     - y should be ordered poly1, poly2, poly3, poly4
*
* References:
*     - used Matlab :=> polyfit, polyval
* RZ - 01/17/97
********************************************************************************
* Modifications:  Wei Wang: x is broken into 6 parts. And regenerate the 
*                 coefficients for x.^(1/8).   07/08/97.
* Comments:
*
* Concerns/TBD:
*******************************************************************************/

float powerpoly_125(float fX)
{
   float fRes;
   float *pfTab;
   int i;
   Uint32 *uiBoundary = (Uint32 *)cpfBoundary;
   UnionFltLng   union_x;

   union_x.f = fX;

 
   /***** we can only afford 0 =< x <= 1 *****/
   if (union_x.l <= uiBoundary[6])   /* truncate the limite */
     union_x.l = uiBoundary[6];

   assert(union_x.l <= uiBoundary[0]);  /* make sure number between 0 to 1. */


   /***** find out which region fX falls in *****/
   if (union_x.l > uiBoundary[3]) {
     if (union_x.l > uiBoundary[2]) {
       if (union_x.l > uiBoundary[1]) 
         i = 0;
       else
         i = 1;
     }
     else
       i = 2;
   }
   else {
     if (union_x.l <= uiBoundary[4]) {
       if (union_x.l <= uiBoundary[5]) 
         i = 5;
       else
         i = 4;
     }
     else
       i = 3;
   }

   /***** find out the table *****/
   pfTab = (float *) &(cpfPowTab_125[i*POLY_ORDER_p1]);

   /***** scale-up the input *****/
   union_x.f *= cpfScaleFactor[i];

   /***** evaluate the polynomial in fast way ******/
   fRes  = union_x.f* *pfTab++;
   fRes += *pfTab++;
   fRes *= union_x.f;
   fRes += *pfTab++;
   fRes *= union_x.f;
   fRes += *pfTab++;
   fRes *= union_x.f;
   fRes += *pfTab++;
   fRes *= union_x.f;
   fRes += *pfTab;
   
   return(fRes);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\comppow.h ===
/*******************************************************************************
*                        Voxware Proprietary Material                          *
*                        Copyright 1997, Voxware, Inc                          *
*                            All Rights Reserved                               *
*                                                                              *
*                       DISTRIBUTION PROHIBITED without                        *
*                      written authorization from Voxware                      *
*******************************************************************************/
/*******************************************************************************
* Filename:     CompPow.h
*                                                                              
* Purpose:      approximate pow(x, 1/8) using polynomial evaluation.
*                                                                              
* Functions:    powerpoly_125()
*                                                                              
* Author/Date:  Wei Wang, 07/08/97. (powerpoly_125 is modified from RZ's 
*               code in enhance.c of RT29).
********************************************************************************
* Modifications:
*                                                                              
* Comments:                                                                    
* 
* Concerns:
*
* $Header:   /export/phobos/pvcs/r_and_d/archives/scaleable/pea/CompPow.h_v   1.1   02 Apr 1998 14:46:54   weiwang  $
*******************************************************************************/

#ifndef _COMP_POW_H_
#define _COMP_POW_H_


/*******************************************************************************
* Function:        powerpoly_125()
*
* Action:         calculate fX^(1/8)
*
* Input:          fX -- floating number which should be between [0 1].
*
* Output:         none
*
* Globals:        none
*
* Return:         fX^(0.125)
********************************************************************************
* Implementation/Detailed Description:
*     - routine is for a 5th order approximation.
*     - polynomial should be :
*         z = y(0).x^5 + y(1).x^4 ... + y(4).x + y(5)
*
*     - x^y is broken into 4 parts accroding to x (x always > 1)
*           poly1 : 1         <= x < BOUNDARY1
*           poly2 : BOUNDARY1 <= x < BOUNDARY2
*           poly3 : BOUNDARY2 <= x < BOUNDARY3
*           poly4 : BOUNDARY3 <= x < BOUNDARYMAX
*
*     - y should be ordered poly1, poly2, poly3, poly4
*
* References:
*     - used Matlab :=> polyfit, polyval
* RZ - 01/17/97
********************************************************************************
* Modifications:  Wei Wang: x is broken into 6 parts. And regenerate the 
*                 coefficients for x.^(1/8).   07/08/97.
* Comments:
*
* Concerns/TBD:
*******************************************************************************/

float powerpoly_125(float fX);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\corrcost.c ===
/*******************************************************************************
*                        Voxware Proprietary Material                          *
*                        Copyright 1996, Voxware, Inc                          *
*                            All Rights Reserved                               *
*                                                                              *
*                       DISTRIBUTION PROHIBITED without                        *
*                      written authorization from Voxware                      *
*******************************************************************************/

/***********************************************************************
 *
 * File: CorrCost.c
 *
 * Purpose: Calculate cross correlator based pitch cost function. Use
 *          subframes instead of full frame. Then dynamicly align the
 *          correlation cost values and normalize them.
 *
 * Reference: (1) "A 5.85kb/s CELP Algorithm For Cellular Application."
 *                 W. Kleijn etc, ICASSP 1993, p.596.
 *            (2) Email from W. Kleijn to B. McAulay, 1995.
 *            (3) Bias function from B. McAulay.
 *
 * Author:    Wei Wang
 *
 * Date:      Oct. 08, 1996.
 *
 * History:  
 *
 *   --   Rewrite the code for decimated signal.  Wei Wang, 01/22/97.
 *
 *   --   Optimized in C level, get rid of warnings, Xiangdong Fu 12/11/96
 *       
 *   --   Add bias function as STC PDA.  Oct. 25, 1996.   Wei Wang.
 *   --   Split to a lot of small functions.  Nov. 11-13, 1996,  Wei Wang.
 *   --   Interpolate the cost value when pitch is above 100 samples.
 *
 * $Header:   /export/phobos/pvcs/r_and_d/archives/realtime/pda/CorrCost.c_v   1.5   12 May 1998 12:55:04   weiwang  $
 ***********************************************************************/

#include <stdlib.h>
#include <math.h>
#include <string.h>
#include <assert.h>

#include "VoxMem.h"
#include "vLibSpch.h" /* QuadraticPeak()              */
#include "vLibVec.h"  /* FindMaxValueFlt(), DotProd() */

#include "CorrPDA.h"
#include "PitchDef.h"
#include "CorrCost.h"

#include "xvocver.h"

static void CalcSubCross(float *sigRef, float *psubcosts);
static void CalcEnergy(float *sigRef, float *EngRef);
static int FindRefFrame(float *EnergyRef, float *frameEnergy);
static void CalcFrameCosts(float *normcost, int ref_Frame, float frameEnergy, 
			   int *dLagStart, int *dLagLength, float *EnergyRef, 
			   float *psubcosts);
static void BiasCosts(float *costs, float *biasTab, float *bias_floor);

/***********************************************************************
 * Function: calcCrossCorrCost()
 *
 * Action:   calculate cross-orrelated cost function using decimated signal.
 *
 * Input:    sigBuf:  signal buffer (from 0:LPITCH_MAX+LFRAME_LEN-1)
 *           normcost:  normalization costs (output)         
 *           myCorrPDA_mblk: correlation related structure.
 *
 * Output:   None.
 ***********************************************************************/

void VoxCalcCrossCorrCost(STACK_R float *sigBuf, float *normcost, 
		       CorrPDA_mblk *myCorrPDA_mblk, float *pbias_floor)
{
  STACK_INIT
  float subcosts[3*PITCH_CAND];
  float EnergyRef[LPITCH_MAX+LFRAME_LEN-LSUBFRAME_LEN+1];
  STACK_INIT_END
  STACK_ATTACH(float*,subcosts)
  STACK_ATTACH(float*,EnergyRef)
  float *sigRef;
  float frameEnergy;
  int ref_Frame;
  float *pEnergyRef;
  float fSlope, fDSlope;
  int i;

  STACK_START

  assert(LPITCH_MAX <= LFRAME_LEN);

  /*--------------------------------------------------
    Window the decimated signal: keep the current frame
    signal and decay the previous frame signal.
    --------------------------------------------------*/
  fSlope = PDA_WIN_COEF;
  fDSlope = PDA_WIN_DIFFC;
  for (i = 0; i < LFRAME_LEN; i++) {
    sigBuf[i] *= fSlope;
    fSlope += fDSlope;
  }

  /*------------------------------------------------------------
    reference signal:sigBuf[LFRAME_LEN ... LFRAME_LEN+LFRAME_LEN].
    ------------------------------------------------------------*/
  sigRef = sigBuf+LFRAME_LEN;

  /*--------------------------------------------------
    calculate the cross correlation of subframes.
    --------------------------------------------------*/
  CalcSubCross(sigRef, subcosts); 


  /*--------------------------------------------------
    calculate the energy of subframes and the cross-
    referenced energy.
    I calculate from backward.
    --------------------------------------------------*/
  CalcEnergy(sigRef, EnergyRef);


  /*--------------------------------------------------
    calculate the energy of subframes.
    find out which subframe as the center reference.
    --------------------------------------------------*/
  /***** point EnergyRef[] to the start of the frame ******/
  pEnergyRef = EnergyRef + LFRAME_LEN - LSUBFRAME_LEN;

  ref_Frame = FindRefFrame(pEnergyRef, &frameEnergy);
  

  /*------------------------------------------------------------
    calculate the total cost by aligning three subcosts.
    ------------------------------------------------------------*/
  CalcFrameCosts(normcost, ref_Frame, frameEnergy, 
		 myCorrPDA_mblk->dIntraLagStart,
		 myCorrPDA_mblk->dIntraLagLength,
		 pEnergyRef, subcosts);


  /*------------------------------------------------------------
    Sharp the peaks of costs function.
    ------------------------------------------------------------*/
  for (i = 1; i < (LPITCH_CONF-LPITCH_MIN+1); i++)
    if (normcost[i] > NOISE_FLOOR) {
      if (normcost[i] > normcost[i-1] && normcost[i] > normcost[i+1])  /* find a peak */
	QuadraticPeak(normcost[i-1], normcost[i], normcost[i+1], &normcost[i]);
    }


  /*------------------------------------------------------------
    bias the cost function. 
    ------------------------------------------------------------*/
  BiasCosts(normcost, myCorrPDA_mblk->biasTab, pbias_floor);
  STACK_END
}



/*
 * Calculate cross correlation value of subframes
 */

static void CalcSubCross(float *sigRef, float *psubcosts)
{
  register int jlag;
  int isub;

  for (isub = 0; isub < NUM_SUBFRAME; isub++, sigRef += LSUBFRAME_LEN)
    {
      jlag = LPITCH_MIN;
      do {    
	  *psubcosts++ = (float)DotProd(sigRef, sigRef-jlag,LSUBFRAME_LEN);
	} while(++jlag <= LPITCH_MAX);
    }
}



/*
 * calculate the energy of subframes.
 */

static void CalcEnergy(float *sigRef, float *EngRef)
{
  register float *pS1, *pS2;
  register double dsum;
  register int k;

  pS1 = sigRef + LFRAME_LEN - 1;

  pS2 = pS1-LSUBFRAME_LEN + 1;

  dsum = DotProd(pS2, pS2, LSUBFRAME_LEN);
  *EngRef++ = (float)dsum;

  pS2--;
  for (k = 1; k <= LPITCH_MAX+LFRAME_LEN-LSUBFRAME_LEN; k++) {
    /*** we just need to take one sample out and add one sample in ***/
    dsum += ((double)*pS2 * *pS2); 
    pS2--;
    dsum -= ((double)*pS1 * *pS1);
    pS1--;
    if (dsum < 0) dsum = 0;
    *EngRef ++ = (float)dsum;
  }
}


/*
 * Find out the center subframe for correlation alignment.
 *
 * The simplest version, we only consider the last two subframes.
 */

static int FindRefFrame(float *EnergyRef, float *frameEnergy)
{
  float TotalEnergy = 0.0f;
  int isub;
  float dsum;
  float energy1, energy2;

  /* The first subframe */
  for (isub = 0; isub < NUM_SUBFRAME - 2; isub++) {
    TotalEnergy += EnergyRef[-isub*LSUBFRAME_LEN];
  }

  /* the NUM_SUBFRAME-1th subframe */
  dsum = EnergyRef[-isub*LSUBFRAME_LEN];
  TotalEnergy += dsum;
  energy1 = dsum;

  /* the last subframe */
  isub++;
  dsum = EnergyRef[-isub*LSUBFRAME_LEN];
  TotalEnergy += dsum;
  energy2 = LAST_SUBFRAME_WEIGHT * dsum;

  *frameEnergy = TotalEnergy;

  /* find out the reference frame */
  if (energy1 >= energy2)
    return NUM_SUBFRAME-2;
  else
    return NUM_SUBFRAME-1;
}


/*
 * calculate the total costs value of one frame and normalize them by energy
 */


static void CalcFrameCosts(float *normcost, int ref_Frame, float frameEnergy, 
			   int *dLagStart, int *dLagLength, float *EnergyRef, 
			   float *psubcosts)
{
  float *tempcrossEnergy;
  float *pEnergyRef;
  float *psubcosts_isub;
  int isub;
  int jlag;
  int istart;
  int tmpmaxlag;
  float tmpmaxcost;
  float small_corr_energy;

  /* first find out which subframe will be center one. */
  assert(ref_Frame == NUM_SUBFRAME-2 || ref_Frame == NUM_SUBFRAME-1);

  /* We do not need tracking the reference subframe, so copy its costs to normcost */
  /* then borrow the subcosts array of the reference subframe for tempcrossEnergy array */
  EnergyRef += LPITCH_MIN;
  tempcrossEnergy = &(psubcosts[ref_Frame*PITCH_CAND]);
  memcpy(normcost, tempcrossEnergy, PITCH_CAND*sizeof(float));
  memcpy(tempcrossEnergy, EnergyRef-ref_Frame*LSUBFRAME_LEN, PITCH_CAND*sizeof(float));
    

  /* If the reference subframe is the last subframe, we do not need to track the first
     subframe. */
  if (ref_Frame == NUM_SUBFRAME - 2) {
    isub = 0;
    pEnergyRef = EnergyRef;
    psubcosts_isub = psubcosts;
  }
  else {
    isub = 1;
    pEnergyRef = EnergyRef-LSUBFRAME_LEN;
    psubcosts_isub = &(psubcosts[PITCH_CAND]);
  }    


  /* then process other subframes */
  for(; isub < NUM_SUBFRAME; isub++) {
    if (isub != ref_Frame) {
      {
	int length;
	int iend;
	float tmpmaxcost1;
	int tmpmaxlag1;

	/* faster searching code */
	/* search for the maximum costs within the pitch range */
	iend = 0;
	tmpmaxlag = -1;
	tmpmaxcost = -1.0F;
          
	for (jlag = 0; jlag < PITCH_CAND; jlag++) {
	  istart = dLagStart[jlag];
	  if(tmpmaxlag < istart) {
	    FindMaxValueFlt(&psubcosts_isub[istart], dLagLength[jlag], 
			    &tmpmaxlag, &tmpmaxcost);
	    tmpmaxlag +=istart;
	  }
	  else {
	    length = istart + dLagLength[jlag] - iend;
	    if(length) {
	      assert(iend < PITCH_CAND);
	      tmpmaxcost1 = psubcosts_isub[iend];
	      tmpmaxlag1 = iend;
	      if(length == 2) {
		assert(iend+1 < PITCH_CAND);
		if(psubcosts_isub[iend+1] >tmpmaxcost1) {
		  tmpmaxcost1 = psubcosts_isub[iend+1];
		  tmpmaxlag1 = iend+1;
		}
	      }
	      if(tmpmaxcost1 > tmpmaxcost) {
		tmpmaxcost = tmpmaxcost1;
		tmpmaxlag = tmpmaxlag1;
	      }
	    }
	  }/* end if(tmpmaxlag ...) */
	  iend = istart + dLagLength[jlag];
	  normcost[jlag] += tmpmaxcost;
	  tempcrossEnergy[jlag] += (float)pEnergyRef[tmpmaxlag];
        } /* end jlag */
      }
    } /* end if(iframe == 0) */
    pEnergyRef -= LSUBFRAME_LEN;
    psubcosts_isub += PITCH_CAND;
  }


  FindMaxValueFlt(tempcrossEnergy, PITCH_CAND, &tmpmaxlag, &tmpmaxcost);
  small_corr_energy = LOW_ENERGY_RATIO * tmpmaxcost + MINCON;

  /* truncate low energy to the threshold value */
  for (jlag = 0; jlag < PITCH_CAND; jlag ++)
    if (tempcrossEnergy[jlag] < small_corr_energy)
      tempcrossEnergy[jlag] = small_corr_energy;


  /* now calculate the normalized pitch costs */
  for(jlag=0; jlag+2<PITCH_CAND; jlag+=3) {
    register float temp1; 
    register float temp2; 
    register float temp3; 

    temp1 = (float)sqrt((double)(frameEnergy*tempcrossEnergy[jlag]+MINCON));

    temp2 = (float)sqrt((double)(frameEnergy*tempcrossEnergy[jlag+1]+MINCON));

    temp3 = (float)sqrt((double)(frameEnergy*tempcrossEnergy[jlag+2]+MINCON));

    normcost[jlag] = normcost[jlag]/temp1;
    normcost[jlag+1] = normcost[jlag+1]/temp2;
    normcost[jlag+2] = normcost[jlag+2]/temp3;
  }

  for( ;jlag<PITCH_CAND; jlag++) {
    normcost[jlag] = normcost[jlag]/(float)sqrt((double)(frameEnergy*tempcrossEnergy[jlag]+MINCON));
  } 
}



static void BiasCosts(float *costs, float *biasTab, float *bias_floor)
{
  register int i;
  register float bias_f = 1.0F;

  /*------------------------------------------------------------
    Apply the new bias to the cost function.
    ------------------------------------------------------------*/
  for (i = 0; i+2 < PITCH_CAND; i+=3) {
    costs[i] *= biasTab[i];
    costs[i+1] *= biasTab[i+1];
    costs[i+2] *= biasTab[i+2];
  }

  for (; i < PITCH_CAND; i++)
    costs[i] *= biasTab[i];

  *bias_floor = bias_f;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\compress.h ===
/*******************************************************************************
*                        Voxware Proprietary Material                          *
*                        Copyright 1996, Voxware, Inc                          *
*                            All Rights Reserved                               *
*                                                                              *
*                       DISTRIBUTION PROHIBITED without                        *
*                      written authorization from Voxware                      *
*******************************************************************************/
 
/*******************************************************************************
* $Header:   /export/phobos/pvcs/r_and_d/archives/scaleable/pea/Compress.h_v   1.1   11 Apr 1998 15:18:18   bobd  $
*******************************************************************************/
#ifndef _COMPRESS_H
#define _COMPRESS_H

/******************************************************************************
*
* Function:   ScaleAndCompress()
*
* Action:     Scales and array and compress using fourth root compression.
*
* Input:      const float *pfIn      --> input array
*             int          iLength   --> length of input array
*             float        fMaxVal   --> inverse of scale factor (maximum value)
*
* Output:     float       *pfOut     --> output array
*
* Globals:    none
*
* Return:     none
*******************************************************************************
*
* Implementation/Detailed Description:
*
* References:
*******************************************************************************
*
* Modifications:
*
* Comments:    In place operation is supported.
*
* Concerns/TBD:
******************************************************************************/
void ScaleAndCompress( const float *pfIn,
                       int          iLength,
                       float        fMaxVal,
                       float       *pfOut
                     );

#endif /* _COMPRESS_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\compress.c ===
/*******************************************************************************
*                        Voxware Proprietary Material                          *
*                        Copyright 1996, Voxware, Inc                          *
*                            All Rights Reserved                               *
*                                                                              *
*                       DISTRIBUTION PROHIBITED without                        *
*                      written authorization from Voxware                      *
*******************************************************************************/

/*******************************************************************************
* Filename:     Compress.c                        
*                                                                              
* Purpose:      Scale and compress an array using fourth root compression.
*
* Functions:    ScaleAndCompress()
*
* Author/Date:  Bob Dunn   3/30/98
********************************************************************************
* Modifications:
*                                                                              
* Comments:                                                                    
* 
* Concerns:
*
* $Header:   /export/phobos/pvcs/r_and_d/archives/scaleable/pea/Compress.c_v   1.4   11 Apr 1998 15:25:02   bobd  $
*******************************************************************************/

#include "vLibMath.h"
#include "vLibVec.h"

#include "Compress.h"

#include "xvocver.h"

/******************************************************************************
*
* Function:   ScaleAndCompress()
*
* Action:     Scales and compress an array using fourth root compression.
*
* Input:      const float *pfIn      --> input array
*             int          iLength   --> length of input array
*             float        fMaxVal   --> inverse of scale factor (maximum value)
*
* Output:     float       *pfOut     --> output array
*
* Globals:    none
*
* Return:     none
*******************************************************************************
*
* Implementation/Detailed Description:
*
* References:
*******************************************************************************
*
* Modifications:
*
* Comments:    In place operation is supported.
*
* Concerns/TBD:
******************************************************************************/
void ScaleAndCompress( const float *pfIn, 
                       int          iLength, 
                       float        fMaxVal, 
                       float       *pfOut
                     ) 
{
   int   i;
   float fScale;
   
   /*------------------------------------------------------
     Compute the scale factor: 1/fMaxVal
   ------------------------------------------------------*/
   if (fMaxVal == 0.0F)
     fScale = 1.0F;
   else
     fScale = 1.0F/fMaxVal;

   /*------------------------------------------------------
     Scale 
   ------------------------------------------------------*/
   ScaleVector( (float*) pfIn, iLength, fScale, pfOut );

   /*------------------------------------------------------
     Compress with an approximation to the fourth root
   ------------------------------------------------------*/
   for (i = 0; i < iLength; i++)
      pfOut[i] = fQuadRoot( pfOut[i] ); 
 
} /* ScaleAndCompress() */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\corrfunc.c ===
/*******************************************************************************
*                        Voxware Proprietary Material                          *
*                        Copyright 1996, Voxware, Inc                          *
*                            All Rights Reserved                               *
*                                                                              *
*                       DISTRIBUTION PROHIBITED without                        *
*                      written authorization from Voxware                      *
*******************************************************************************/

/*******************************************************************************
* Filename:     corrfunc.c                        
*                                                                              
* Purpose:      Refine the coarse pitch estimate using correlation function
*                                                                              
* Functions:    void corrfunc( float pitch, float fHiEdge, float fRefinMax)
*                                                                              
* Author/Date:  Bob McAulay/ 1/97                                              
********************************************************************************
* Modifications: Xiaoqin Sun     6/97
*
*                Wei Wang  6/19/97: share the trigle table.
*                                                                              
* Comments:   Index of cosine table has been replaced by fix point
*             Pitch was timed by 2^12, and fPeakFrq was timed by 2^11, then 
*             down shift 23 bits                                                        
* 
* Concerns:   Though run on PC the refined pitch values with fixed point version 
*             is very similar with floating point version, it may have a potectial 
*             overflow problem on another type of machines (e.g. UNIX machine).
*             Suggestion ----test on UNIX machine
*
* $Header:   /export/phobos/pvcs/r_and_d/archives/scaleable/pea/corrfunc.c_v   1.2   27 Mar 1998 16:58:18   weiwang  $
*******************************************************************************/
#include <math.h>
#include <assert.h>

#include "VoxMem.h"
#include "codec.h"
#include "corrfunc.h"
#include "trigSC.h"

#include "xvocver.h"

#define   ARG0                  (TRIG_SIZE>>FFT_ORDER)
#define   N_SHIFTS       (F0_SHIFT_BITS +F0_SHIFT_11B-LOG2_TRIG_SIZE+FFT_ORDER)
#define   OFFSET_ROUND          (1 << (N_SHIFTS-1))
#define   TRIG_TABLE_MASK       (TRIG_SIZE-1)

       
extern const float *cosTBL_32;

void corrfunc(float dpitch, float fpitch, 
              float fHiEdge, float *fRefinedMax,
              int iBpeaks, float *pfFltPwr, 
              float fFltEnergy, unsigned long *iPeakFrq,
              float *fRefinedPeriod)
{
  float fSum_k;

  int j;
  unsigned long lIndex;
  int iIndex;
  unsigned long ipitch;
  unsigned long mult_v1;

  /*** Refine the pitch about the previously estimated value ***/
  
  mult_v1= (unsigned long) (1<<F0_SHIFT_BITS );
  
  while (fpitch <= fHiEdge)
    { 
      ipitch =(unsigned long)(fpitch*mult_v1+0.5);
      fSum_k = fFltEnergy;

      for (j = 0; j < iBpeaks; j++)
        {  
          lIndex = (ipitch*iPeakFrq[j])+ OFFSET_ROUND;
          iIndex = (int)(lIndex >>N_SHIFTS) & TRIG_TABLE_MASK;
          fSum_k += pfFltPwr[j]*cosTBL_32[iIndex];
        }

      /*** Test for a correlation peak and store winning pitch period ***/
      if (fSum_k > *fRefinedMax)
        {
          *fRefinedMax = fSum_k;
          *fRefinedPeriod = fpitch;   /** 1 sample ahead **/
        }
      fpitch += dpitch; 
    }

 
} /* corrfunc.c*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\decodert.h ===
#ifndef DECODERT_H
#define DECODERT_H

#ifndef __VEM_KEY
#define __VEM_KEY
typedef void * VEM_KEY;
#endif /* __VEM_KEY */

/*---------------------------------------------------------------------
  Decoder Structure ...
  ---------------------------------------------------------------------*/
typedef struct tagDecode_mblk
{
  /* structure for VCI */
   void *    pFadeIOMemBlk;

  /* private structure */
   void*     Synthesis_mblk;
   void*     UVexcite_mblk;
   void*     Vexcite_mblk;
   void*     OutputBuffer_mblk;
   void*     SubFrameParam_mblk;
   void*     PrevFrameParam_mblk;
   void*     Param_mblk;
   void*     Sws_mblk;
   void*     myFHT_mblk;

   void*     Effects_mblk;
   
   float     fWarpedLengthFactor;
   short     drop;
   short     dropLeft;
   short     dropRate; 
   float     Warp;
   unsigned char writeFLAG;
   unsigned char unpackFLAG;

   void      *pVemMem;  /* attachment to Vem memory */
   VEM_KEY   vemKeyPreDecode;
   VEM_KEY   vemKeyPostDecode;
} DEC_MEM_BLK;

unsigned short VoxDecodeRT(STACK_R short *pPCMBuffer,void *pMemBlkD);

unsigned short VoxInitDecodeRT(void **ppMemBlkD, void *pVemMem);

unsigned short VoxFreeDecodeRT(void **hMemBlkD);

#endif /* DECODERT_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\cstoenv.c ===
/******************************************************************************
*                        Voxware Proprietary Material
*                        Copyright 1996, Voxware, Inc
*                            All Rights Reserved
*
*                       DISTRIBUTION PROHIBITED without
*                      written authorization from Voxware
******************************************************************************/
 
/******************************************************************************
*
* Filename:    CsToEnv.c
*
* Purpose:
*
* Functions:
*
* Author/Date: Bob Dunn 12/27/96
*
*******************************************************************************
*
* Modifications: Wei Wang, cleaned up the code at 12/22/97
*                Wei Wang, Support inter-leave data format
*                Bob Dunn, changed output to inter-leave data format
*
* Comments:      void VoxCsToEnv(const float *pfCs, int iOrderCepstral, 
*                                int iLogLfft, float *pfSW)
*
* Concerns:      
*
* $Header:   G:/pvcsproj/voxlib.prj/CsToEnv.c_v   1.8   03 Mar 1998 09:44:02   weiwang  $
******************************************************************************/
#include <assert.h>
#include <string.h>
#include "vLibTran.h"

#include "xvocver.h"

/* ln(2) to convert cepstral phase to radians */
#define LN_OF_2 0.69314718F

/******************************************************************************
*
* Function:  VoxCsToEnv()
*
* Action:    Compute the cepstral log-amplitude and phase envelopes (using 
*            interleave-formated FFT)
*
* Input:     float *pfCs           --> Cepstral coefficients
*            int iOrderCepstral    --> number of Cepstral coefficients
*            int iLogLfft          --> Log (base 2) of FFT length
*
* Output:    float *pfSW           --> interleaved output array. The real part
*                                          (odd indices) is the Log (base 2) 
*                                          magnitude of spectrum (0 to iLfft/2)
*                                          The imaginary part (even indices)
*                                          is the unwrapped phase (in radians)
*                                          of spectrum (0 to iLfft/2). The 
*                                          length of *pfSW must be 
*                                          (1<<iLogLfft)+2).
*
* Globals:   none
*
* Return:    void
*******************************************************************************
*
* Implementation/Detailed Description:
*
*   NOTE:   The cepstral coefficients have been computed based on
*             the "log_base_2" amplitude data. So to convert the
*             phase to radians it is necessary to multiply the
*             phase envelope by "log_base_e(2)".
* 
*             log_base_2(x) = log_base_e(2)/log_base_2(x) for magnitude
* 
*             log_base_e(x) = log_base_2(x)*log_base_e(2) for phase in radians
*
*
* References:
*******************************************************************************
*
* Modifications:
*
* Comments:    
*
* Concerns/TBD:
******************************************************************************/
void VoxCsToEnv( const float *pfCs,  
                 int          iOrderCepstral, 
                 int          iLogLfft,     
                 float       *pfSW
               )
{
   int   i, j;
   int   iLfft;

   assert(pfSW != NULL && pfCs != NULL);

   /* FFT size */

   iLfft = (1<<iLogLfft);

   
   /* initialize the memory */

   memset(pfSW, 0, sizeof(float)*(iLfft+2));

   
   /* put cepstral coefficients to buffer before taking real FFT */

   pfSW[0] = pfCs[0];
  
   for(i = 1,j = iLfft - 1;i < iOrderCepstral;i++, j--)
   {
      /*--------------------------------------------------
        This code used to be written as:

           fEvenPart = pfCs[i];
           fOddPart = pfCs[i]*LN_OF_2;
           pfSW[i] = fEvenPart + fOddPart;
           pfSW[j] = fEvenPart - fOddPart;

         which might be better for fixed point.
      --------------------------------------------------*/

      pfSW[i] = pfCs[i] * (1.0F + LN_OF_2);
      pfSW[j] = pfCs[i] * (1.0F - LN_OF_2);
   }

   /* Take the inter-leaved formated real FFT */
   VoxRealFft(pfSW, iLogLfft);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\cstab.h ===
/*******************************************************************************
*                        Voxware Proprietary Material                          *
*                        Copyright 1996, Voxware Inc.                          *
*                        All Rights Reserved                                   *
*                                                                              *
*                        DISTRIBUTION PROHIBITED without                       *
*                        written authorization from Voxware.                   *
*******************************************************************************/

/*******************************************************************************
*
* Filename: csTab.h
*
* Purpose:  table for CsToEnv.c
*
* Author/Date:   Bob McAulay
*
* $Header:   /export/phobos/pvcs/pvcsproj/voxlib.prj/csTab.h_v   1.2   26 Feb 1998 17:00:40   weiwang  $
*******************************************************************************/
#ifndef CSTAB_H
#define CSTAB_H
1.0F,
0.72134752F,
0.360674F,
0.240449F,
0.180337F,
0.144269F,
0.120225F,
0.103050F,
0.090168F,
0.080150F,
0.072135F,
0.065577F,
0.060112F,
0.055488F,
0.051525F,
0.048090F,
0.045084F,
0.042432F,
0.040075F,
0.037966F,
0.036067F,
0.034350F,
0.032789F,
0.031363F,
0.030056F,
0.028854F,
0.027744F,
0.026717F,
0.025762F,
0.024874F,
0.024045F,
0.023269F,
0.022542F,
0.021859F,
0.021216F,
0.020610F,
0.020037F,
0.019496F,
0.018983F,
0.018496F,
0.018034F,
0.017594F,
0.017175F,
0.016776F
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\corrfunc.h ===
/*******************************************************************************
*                        Voxware Proprietary Material                          *
*                        Copyright 1996, Voxware, Inc                          *
*                            All Rights Reserved                               *
*                                                                              *
*                       DISTRIBUTION PROHIBITED without                        *
*                      written authorization from Voxware                      *
*******************************************************************************/

/*******************************************************************************
* Filename:          corrfunc.h
*
* Purpose:           calculate correlation function for pitch refinement
*
* Functions:
*
* Author/Date:
********************************************************************************
* Modifications:
*
* Comments:
*
* Concerns:
*
* $Header:   /export/phobos/pvcs/r_and_d/archives/scaleable/pea/corrfunc.h_v   1.0   06 Feb 1998 10:11:00   johnp  $
*******************************************************************************/
#ifndef _CORRFUNC_H_
#define _CORRFUNC_H_


void corrfunc( float dpitch, float fpitch, float fHiEdge, float *fRefinedMax,
	       int iBpeaks, float *pfFltPwr, float fFltEnergy, 
               unsigned long *iPeakFrq, float *fRefinedPeriod);

#endif /* _CORRFUNC_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\decplssc.c ===
/******************************************************************************
*                        Voxware Proprietary Material                         *
*                        Copyright 1996, Voxware, Inc                         *
*                            All Rights Reserved                              *
*                                                                             *
*                       DISTRIBUTION PROHIBITED without                       *
*                      written authorization from Voxware                     *
******************************************************************************/

/******************************************************************************
* Filename:       DecPlsSC.c
*                                                                              
* Purpose:        Provide decoder plus functions as the interface for the private
*                 decoder structure.
*                                                                              
* Functions:     voxSetDecodeSC(), ... etc.
*                                                                              
* Author/Date:    Wei Wang, 3/98.
*******************************************************************************
* Modifications: 
*                                                                              
* Comments:                                                                    
* 
* Concerns:
*
* $Header:   /export/phobos/pvcs/r_and_d/archives/scaleable/decode/DecPlsSC.c_v   1.5   13 Apr 1998 16:16:54   weiwang  $
******************************************************************************/

#include <stdlib.h>
#include <assert.h>

#include "codec.h"
#include "rate.h"
#include "paramSC.h"
#include "DecPriSC.h"
#include "DecPlsSC.h"

#include "xvocver.h"

/*******************************************************************************
*
* Function:  voxSetDecodeSC()
*
* Action:   Set the compression rate for SC36 (either 3K or 6K)
*
* Input:    pMemBlkD -- decoder memory block
*           wScale -- codec rate 
*
* Output:   pMemBlkD -- updated decoder memory block
*
* Globals:   none
*
* Return:    0: succeed, 1: failed
*******************************************************************************/

unsigned short voxSetDecodeSC(void *pMemBlkD, unsigned short wScale)
{
   DEC_MEM_BLK *pDecode_mblk=(DEC_MEM_BLK*)pMemBlkD;
   unsigned short ret = 1;   /* default: fail */

   assert(pMemBlkD != NULL);

   switch(wScale) {
      case SC_RATE_3K:
         if(pDecode_mblk->iSCRateValid&SC_RATE_3K) {
            pDecode_mblk->iSCTargetRate=SC_RATE_3K;
            ret = 0;  /* ok */
         }
         break;
      case SC_RATE_6K:
         if(pDecode_mblk->iSCRateValid&SC_RATE_6K) {
            pDecode_mblk->iSCTargetRate=SC_RATE_6K;
            ret = 0;  /* ok */
         }
   }

   return ret;
}


/*******************************************************************************
*
* Function:  voxGetDecodeRateSC()
*
* Action:   Get the compression rate 
*
* Input:    pMemBlkD -- decoder memory block
*
* Output:   none
*
* Globals:   none
*
* Return:    the target rate for SC codec.
*******************************************************************************/

int voxGetDecodeRateSC(const void *pMemBlkD)
{
   assert(pMemBlkD != NULL);
   return(((DEC_MEM_BLK*)pMemBlkD)->iSCTargetRate);
}

/*******************************************************************************
*
* Function:  voxGetDecodeInitRateSC()
*
* Action:   Get the initialized compression rate 
*
* Input:    pMemBlkD -- decoder memory block
*
* Output:   none
*
* Globals:   none
*
* Return:    the initial rate for SC codec.
*******************************************************************************/

int voxGetDecodeInitRateSC(const void *pMemBlkD)
{
   assert(pMemBlkD != NULL);
   return(((DEC_MEM_BLK*)pMemBlkD)->iSCRateValid);
}  


/*******************************************************************************
*
* Function:  voxGetDecReqDataFlagSC()
*
* Action:    Get the RequestDataFLAG flag
*
* Input:     pMemBlkD -- decoder memory block
*
* Output:    none
*
* Globals:   none
*
* Return:    RequestDataFLAG
*******************************************************************************/

unsigned char voxGetDecReqDataFlagSC(const void *pMemBlkD)
{
   assert(pMemBlkD != NULL);

   assert((((DEC_MEM_BLK*)pMemBlkD)->iNewFrame==1)||
          (((DEC_MEM_BLK*)pMemBlkD)->iNewFrame==0));

   return (unsigned char)(((DEC_MEM_BLK*)pMemBlkD)->iNewFrame);
}  


/*******************************************************************************
*
* Function:  voxSetFrameSkippedSC()
*
* Action:   Set frame skipped flag
*
* Input:    pMemBlkD -- decoder memory block
*           iFrameSkipped -- frame skip flag
*
* Output:   none
*
* Globals:   none
*
* Return:    none
*******************************************************************************/
void voxSetFrameSkippedSC(void *pMemBlkD, int iFrameSkipped)
{
  assert(pMemBlkD != NULL);
  ((DEC_MEM_BLK*)pMemBlkD)->iFramesSkipped = iFrameSkipped;
}

/*******************************************************************************
*
* Function:  voxSetRepeatFrameSC()
*
* Action:   Set repeat frame flag
*
* Input:    pMemBlkD -- decoder memory block
*           iRepeatFrameFlag -- repeat-frame flag
*
* Output:   none
*
* Globals:   none
*
* Return:    nont
*******************************************************************************/
void voxSetRepeatFrameSC(void *pMemBlkD, int iRepeatFrameFlag)
{
  assert(pMemBlkD != NULL);
  ((DEC_MEM_BLK*)pMemBlkD)->iRepeatFrameFlag = iRepeatFrameFlag;
}


/*******************************************************************************
*
* Function:  voxSetWarpFactorSC()
*
* Action:   Set wWarpFactor
*
* Input:    pMemBlkD -- decoder memory block
*           wWarpFactor -- warp factor
*
* Output:   none
*
* Globals:   none
*
* Return:    none
*******************************************************************************/
void voxSetWarpFactorSC(void *pMemBlkD, float fWarpFactor)
{
  assert(pMemBlkD != NULL);
  ((DEC_MEM_BLK*)pMemBlkD)->fWarpedLengthFactor = fWarpFactor;
}


/*******************************************************************************
*
* Function:  voxGetWarpFactorSC()
*
* Action:   Get Warp Factor
*
* Input:    pMemBlkD -- decoder memory block
*
* Output:   none
*
* Globals:   none
*
* Return:    the warp factor
*******************************************************************************/
float voxGetWarpFactorSC(const void *pMemBlkD)
{
  assert(pMemBlkD != NULL);
  return ((DEC_MEM_BLK*)pMemBlkD)->fWarpedLengthFactor;
}


/*******************************************************************************
*
* Function:  VoxGetDecPrevPvSC()
*
* Action:   Get Pv_1
*
* Input:    pMemBlkD -- decoder memory block
*
* Output:   none
*
* Globals:   none
*
* Return:    Pv_1
*******************************************************************************/
float VoxGetDecPrevPvSC(const void *pMemBlkD)
{
  assert(pMemBlkD != NULL);
  return ((DEC_MEM_BLK*)pMemBlkD)->PrevSubParam.Pv;
}

/*******************************************************************************
*
* Function:  VoxGetDecPrevPitchSC()
*
* Action:   Get Pitch_1
*
* Input:    pMemBlkD -- decoder memory block
*
* Output:   none
*
* Globals:   none
*
* Return:    Pitch_1
*******************************************************************************/
float VoxGetDecPrevPitchSC(const void *pMemBlkD)
{
  assert(pMemBlkD != NULL);
  return ((DEC_MEM_BLK*)pMemBlkD)->PrevSubParam.Pitch;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\decodert.c ===
/*
 * File:     Decode.c
 *
 * Project:  RT29
 * *
 * 
 *
 * Written by Rob Zopf.
 *
 * Copyright 1996  Voxware, Inc.
 *
 *
 * $Header:   /export/phobos/pvcs/r_and_d/archives/realtime/decode/DecodeRT.c_v   1.5   01 Dec 1998 14:37:36   zopf  $
 *
 */

#include <stdlib.h>
#include <math.h>
#include <string.h>
#include <assert.h>
#include <stdio.h>

#include "VoxMem.h"
#include "model.h"
#include "vLibTran.h" /* VoxLspToAsEven() */

#include "vem2.h"
#include "vem2Prm.h"
#include "research.h"

#include "enhance.h"
#include "lpcSynth.h"
#include "Setup.h"
#include "OutBuf.h"
#include "param.h"
#include "Sws.h"
#include "GetnHarm.h"

#include "DecodeRT.h"

#include "xvocver.h"


#ifdef WIN32
#include "vLibTran.h"
#endif

static const float cfInvRate8k = 1.0F/RATE8K;
void SmoothSpectrumInNoise( float *CurrentLsf, float *AveLsf, int *Hangover, float Pv );

unsigned short VoxDecodeRT(STACK_R signed short *pPCMBuffer,void *pMemBlkD)
{
   DEC_MEM_BLK* pDecMemBlk=(DEC_MEM_BLK*)pMemBlkD;
   PARAM	*Param_mblk = (PARAM *)(pDecMemBlk->Param_mblk);
   Synthesis *Synthesis_mblk = (Synthesis *)(pDecMemBlk->Synthesis_mblk);
   SubFrameParam *SubFrameParam_mblk = (SubFrameParam *)(pDecMemBlk->SubFrameParam_mblk);
   PrevFrameParam *PrevFrameParam_mblk = (PrevFrameParam *)(pDecMemBlk->PrevFrameParam_mblk);
STACK_INIT
   float lpc[LPC_ORDER+1];
   float OutBufFloat[FRAME_LEN+LPC_ORDER];
STACK_INIT_END

STACK_ATTACH(float *, lpc)
STACK_ATTACH(float *, OutBufFloat)

   short nHarm;

STACK_START

/* service the "pre decode" state */
   vemServiceState(pDecMemBlk->vemKeyPreDecode);

   VoxSetup(STACK_S Param_mblk, SubFrameParam_mblk, PrevFrameParam_mblk, 
            pDecMemBlk->Warp, &(pDecMemBlk->unpackFLAG));

   nHarm = getnHarm(SubFrameParam_mblk->Pitch);
   if (nHarm > MAXHARM)
       nHarm = MAXHARM;

   SmoothSpectrumInNoise( SubFrameParam_mblk->Lsf, SubFrameParam_mblk->AveLsf, 
                        &(SubFrameParam_mblk->Hangover), SubFrameParam_mblk->Pv );

   /****** perceptually weight the spectrum using the lpc's *********/
   VoxLspToAsEven(SubFrameParam_mblk->Lsf, LPC_ORDER, cfInvRate8k, lpc);

   VoxEnhance(STACK_S lpc, SubFrameParam_mblk->Pv, SubFrameParam_mblk->Pitch, 
           nHarm, SubFrameParam_mblk->Amp);

   memset(OutBufFloat+LPC_ORDER, 0, sizeof(float)*SubFrameParam_mblk->frameLEN);


   /****** Calculate the unvoiced excitation with sine waves *******/
     VoxSws(
           STACK_S
           pDecMemBlk->Sws_mblk,
           SubFrameParam_mblk->Amp,
           SubFrameParam_mblk->Amp_1,
           SubFrameParam_mblk->Pitch,
           SubFrameParam_mblk->Pitch_1,
           SubFrameParam_mblk->Pv,
           SubFrameParam_mblk->Pv_1,
           SubFrameParam_mblk->frameLEN,
           SubFrameParam_mblk->nSubs,
           OutBufFloat+LPC_ORDER
         );
   /****** Do the synthesis using the unvoiced and voiced excitations ******/ 
   VoxLPCSyn(STACK_S SubFrameParam_mblk->Lsf, OutBufFloat, Synthesis_mblk, SubFrameParam_mblk->frameLEN);


   /****** Do the output buffer management *******/
   VoxOutputManager(pDecMemBlk->OutputBuffer_mblk,SubFrameParam_mblk->frameLEN, OutBufFloat+LPC_ORDER);

   /****** Output the speech from the double buffer to the API buffer ******/
   if (((OutputBuffer *)pDecMemBlk->OutputBuffer_mblk)->writeBuffer==1)
   {
      memcpy(pPCMBuffer, ((OutputBuffer *)(pDecMemBlk->OutputBuffer_mblk))->outBufferB1, sizeof(short)*FRAME_LEN);
      pDecMemBlk->writeFLAG=1;
   }
   else if (((OutputBuffer*)(pDecMemBlk->OutputBuffer_mblk))->writeBuffer==2)
   {
      memcpy(pPCMBuffer,((OutputBuffer *)(pDecMemBlk->OutputBuffer_mblk))->outBufferB2, sizeof(short)*FRAME_LEN);
      pDecMemBlk->writeFLAG=1;
   }
   else pDecMemBlk->writeFLAG=0;

   VoxUpdateSubframe(SubFrameParam_mblk);

   /* service the "post decode" state */
   vemServiceState(pDecMemBlk->vemKeyPostDecode);
STACK_END

return 0;
}

unsigned short VoxInitDecodeRT(void **ppMemBlkD, void *pVemMem)
{
   DEC_MEM_BLK *pDecode_mblk;

   if(VOX_MEM_INIT(pDecode_mblk=*ppMemBlkD,1,sizeof(DEC_MEM_BLK))) 
      return 1;

   /****************************************************
    Initialize the Sws block
    ****************************************************/
   if (VoxInitSws(&pDecode_mblk->Sws_mblk)) 
      return 1;

   /****************************************************
    Initialize the LPC Synthesis block
    ****************************************************/
   if (VoxInitLPCSyn(&pDecode_mblk->Synthesis_mblk))
      return 1;

   /****************************************************
    Initialize the Output Buffer block
    ****************************************************/
   if (VoxInitOutputBuffers(&pDecode_mblk->OutputBuffer_mblk)) 
      return 1;

   /****************************************************
    Initialize the subframe parameters block
    ****************************************************/
   if (VoxInitSubframe(&pDecode_mblk->SubFrameParam_mblk)) 
      return 1;

   /****************************************************
    Initialize the prev frame memory parameters block
    ****************************************************/
   if (VoxInitPrevFrame(&pDecode_mblk->PrevFrameParam_mblk)) 
      return 1;

   /****************************************************
    initialize parameter structure
    ****************************************************/
   if (VoxInitParam(&pDecode_mblk->Param_mblk, pVemMem)) 
      return 1;


   /****************************************************
    initialize the dropRate and fWarpedLengthFactor
    ****************************************************/
   pDecode_mblk->dropRate=1;
   pDecode_mblk->fWarpedLengthFactor=1.0F;
   pDecode_mblk->unpackFLAG=1;

   pDecode_mblk->pVemMem=pVemMem;

   if(!(pDecode_mblk->vemKeyPreDecode=vemRegisterState(
      ((VEM_MAIN_STRUCT *)pVemMem)->pMemoryHandler, "pre decode")))
      return 1;

   if(!(pDecode_mblk->vemKeyPostDecode=vemRegisterState(
      ((VEM_MAIN_STRUCT *)pVemMem)->pMemoryHandler, "post decode")))
      return 1;
   
   vemRegisterConstShort(((VEM_MAIN_STRUCT *)pVemMem)->pMemoryHandler, 
      (short)RATE8K, "rate");
   vemRegisterConstShort(((VEM_MAIN_STRUCT *)pVemMem)->pMemoryHandler, 
      (short)FRAME_LEN, "frame length");
   vemRegisterVariable(((VEM_MAIN_STRUCT *)pVemMem)->pMemoryHandler, 
      &pDecode_mblk->writeFLAG, VEM_U_CHAR, "write flag");
      
   return 0;
}


unsigned short VoxFreeDecodeRT(void **hMemBlkD)
{
    DEC_MEM_BLK *pDecode_mblk=(DEC_MEM_BLK*)*hMemBlkD;
  
    if (*hMemBlkD) {

       VoxFreeSws(&pDecode_mblk->Sws_mblk);

       VoxFreeLPCSyn(&pDecode_mblk->Synthesis_mblk);

       VoxFreeOutputBuffers(&pDecode_mblk->OutputBuffer_mblk);

       VoxFreeSubframe(&pDecode_mblk->SubFrameParam_mblk);

       VoxFreePrevFrame(&pDecode_mblk->PrevFrameParam_mblk);

       VoxFreeParam(&pDecode_mblk->Param_mblk);

#ifdef WIN32
       nspFreeFftResources();
#endif

       VOX_MEM_FREE(*hMemBlkD);
    }
    return 0;
}



void SmoothSpectrumInNoise( float *CurrentLsf, float *AveLsf, int *Hangover, float Pv )
{
   int i;

   if (Pv >0.0F)
      *Hangover=HANGOVER_TIME;
   else
      (*Hangover)--;

   if (*Hangover == HANGOVER_TIME-1)
      memcpy(AveLsf, CurrentLsf, LPC_ORDER*sizeof(float));

   if (*Hangover < HANGOVER_TIME)
   {
      for (i=0;i<LPC_ORDER;i++)
         AveLsf[i] = AveLsf[i]*(1.0F-AVE_FACTOR) + CurrentLsf[i]*AVE_FACTOR;
   }

   if (*Hangover < 0)
   {
      *Hangover = 0;
      memcpy(CurrentLsf, AveLsf, LPC_ORDER*sizeof(float));
   }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\corrpda.h ===
#ifndef _CORRPDA_H_
#define _CORRPDA_H_
/***********************************************************************
 * 
 * Filename:  CorrPDA.h
 *
 * Purpose:   Calculate cross-correlation related pitch esti-
 *            mator. Then backward / forward track the pitch.
 *           
 * Reference: (1) "A 5.85kb/s CELP Algorithm For Cellular Application."
 *                 W. Kleijn etc, ICASSP 1993, p.596.
 *            (2) Email from W. Kleijn to B. McAulay, 1995.
 *            (3) ITU-T Draft G.723, p.13.
 *
 * Author:    Wei Wang
 *
 * Date:      Oct. 4, 1996
 *
 * History:
 *            Rewrite the code for decimated signal.
 *
 * $Header:   /export/phobos/pvcs/r_and_d/archives/realtime/pda/CorrPDA.h_v   1.5   04 Dec 1998 16:24:50   weiwang  $
 ***********************************************************************/


/**************************************************
 * structure for cross-correlation PDA.
 **************************************************/

#define USE_HPF    1     /* if 1: use HPF */
                         /*    0: no HPF -- good for fixed-point implementation */

typedef struct
{
  /****** inter-frame memory -- total (252) ******/
  /****** if considering the PDA delay and circular buffer and input speech ((261-180)/2+2*180=401)
    then the total inter-frame memory will be (653) *******/
#if USE_HPF == 1
  float *hpf_mem;         /* memory for high-pass filter (4) */
#endif

  float *lpf_mem;         /* memory for low-pass filter (3) */

  float *lpfbuf;          /* decimated signal buffer (90+45) */
  
  float *costs0;          /* normalized costs value of previous frame (90-5+1=86)*/

  float *Alsf0;           /* LSF of previous frame -- for interpolation (10) */

  float *percWeight_mem;  /* memory for perceptual weighting filter (10) */

  int pitch_1;            /* pitch of previous frame (1) */

  int pitch_2;            /* pitch of previous-previous frame (1) */

  float cost_1;           /* cost value of previous frame (1) */

  float cost_2;           /* cost value of previous-previous frame (1) */
  

  /****** tables: pre-calculated for general application
    or load-in to ROM for DSP application *******/
  /****** total :  (626) *******/
  float *lpfCoefs;        /* (3+4 = 7) */

#if USE_HPF == 1
  float *hpfCoefs;        /* (4+5 = 9) */
#endif

  float *LpcWindow;       /* asymmetric window for LPC calculation (180) */

  float *biasTab;         /* table for biasing the normalized costs (86) */

  int *dInterLagStart;    /* for interframe tracking: starting lags (86) */

  int *dInterLagLength;   /* for interframe tracking: tracking length (86) */

  int *dIntraLagStart;    /* for intraframe tracking: starting lags (86) */

  int *dIntraLagLength;   /* for intraframe tracking: tracking length (86) */


  /****** For scratch memories: (re-usable) *******/
  /****** total: 589 *******/
  void *myLPC2LSP_mblk;    /* for lpc to lsp. Will take out this structure after changing lpctolsp.c */

  void *myDurbin_mblk;     /* for calcDurbin. Will take out this structure after using new stack memory strategy */

  void *VADMemBlk;         /* Memory required by VAD.                         */

  /****** others need reuse tmpSigBuf, or tmpSubCosts or tmpEnergyRef ********/
} CorrPDA_mblk;

/*************************************************************
 *
 * Function: VoxCorrPDA()
 *
 * Get input speech from circular buffer and then apply corrPitchEst().
 *
 * Wei Wang.   05/05/97
 *************************************************************/
float VoxCorrPDA (STACK_R float *speechIn, short framelen, 
		void *pvCorrPDA_mblk, float *pda_delay_size, 
                short *VAD,short *UV);



/***********************************************************************
 * Function: initCorrPitchEst()
 *
 * Input:    myCorrPDA_mblk:  pointer for the structure.
 *
 * Output:   error code:   error with initialization.
 *           0:            no error
 ***********************************************************************/

unsigned short VoxInitCorrPitchEst(void **myCorrPDA_mblk);



/***********************************************************************
 * Function: freeCorrPitchEst()
 *
 * Input:    myCorrPDA_mblk:   pointer for the structure.
 *
 * Output:   None
 ***********************************************************************/

unsigned short VoxFreeCorrPitchEst(void **myCorrPDA_mblk);

float PvRefine( float Pv, float Pv_1, float Pitch, float MaxCost, float *biasTab);

#endif /* end of #ifndef _CORRPDA_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\corrpda.c ===
/***********************************************************************
 * 
 * Filename:  CorrPDA.c
 *
 * Purpose:   Calculate cross-correlation related pitch esti-
 *            mator. Then backward / forward track the pitch.
 *           
 * References:(1) "A 5.85kb/s CELP Algorithm For Cellular Application."
 *                 W. Kleijn etc, ICASSP 1993, p.596.
 *            (2) Email from W. Kleijn to B. McAulay, 1995.
 *            (3) ITU-T Draft G.723, p.13.
 *
 * Author:    Wei Wang
 *
 * Date:      Oct. 04, 1996
 *
 *
 * Modification:  May 5, 1997, W.W. Add higher level function:
 *                VoxTDPDA().
 *
 *                Jan. 20, 1997, W.W. Change to lower complexity, 
 *                  lower memory version.
 *                (1) Asymmetric window for LPC calculation.
 *                (2) Interpolate LSPs instead of calculating LPC every 
 *                     subframe.
 *                (3) Decimate low-passed signal by 2. 
 *                (4) Calculate only the half pitch candidates.
 *                (5) Use auto-correlation for pitch centralization.
 *                (6) Limit memory usage and delay only one frame.
 *                (7) Incorporate Aguilars VAD + make LPC order dependent on PitchDef.h
 *
 * Comments:      reuse speechIn buffer inside of VoxCorrPitchEst() 
 *
 * $Header:   /export/phobos/pvcs/r_and_d/archives/realtime/pda/CorrPDA.c_v   1.12   04 Dec 1998 16:24:40   weiwang  $
 ***********************************************************************/
#include <stdlib.h>
#include <math.h>
#include <assert.h>
#include <string.h>

#include "VoxMem.h"
#include "vLibSpch.h"
#include "vLibSnd.h"   /* GetFrameSpCBM() */
#include "vLibVec.h"   /* GetFrameSpCBM() */

#include "CorrPDA.h"
#include "PitchDef.h"
#include "calcLPC.h"
#include "CorrCost.h"
#include "trackPth.h"
#include "CentCorr.h"
#include "NspIIR.h"
#include "hamming.h"
#include "VAD2.h"

#include "xvocver.h"

/*************************************************************
 *
 * Function: VoxCorrPDA()
 *
 * Action:   Calculate subframe based cross-correlation of 
 *           all pitch lags. Do pitch tracking based on two 
 *           previous frames and one future frame.
 *           
 * Input:    speechIn:  preprocessed speech buffer (in short format).
 *           framelen: length of speech.
 *           myCorrPDA_mblk: pitch estimator structure.
 *           pda_delay_size: delay size for encoder.
 *
 * Output:   pitch value of the previous frame.
 *
 *************************************************************/
float VoxCorrPDA(STACK_R float *speechIn, short framelen, 
                 void *pvCorrPDA_mblk, float *pda_delay_size,
                 short *VAD, short *UV)
{
  CorrPDA_mblk *myCorrPDA_mblk = (CorrPDA_mblk *)pvCorrPDA_mblk;
  int i;
  float *tmpSigBuf = speechIn;
  float *ptmpSigBuf = tmpSigBuf;    
  float *pSigLPF;
  float *corr_cost1;
  float bias_floor;
  int coarse_pitch;
  float refine_pitch;
  float maxCost, lowBandEng;
  float CentCorrValue;


  assert(framelen == FRAME_LEN);

#if USE_HPF  == 1
  /*------------------------------------------------------------
    Add a little offset to prevent underflow 
    ------------------------------------------------------------*/
  for (i = 0; i < framelen; i++)
    speechIn[i] += 0.1F;

  /*------------------------------------------------------------
    (1) Preprocessing signal by using high-pass filter.
    ------------------------------------------------------------*/
  VoxNspIIRFlt(ptmpSigBuf, ptmpSigBuf, FRAME_LEN, myCorrPDA_mblk->hpfCoefs,
	       HPF_ORDER, myCorrPDA_mblk->hpf_mem);
#endif


  /* Calculate lowBandEng; needed for VAD estimation.                         */
  lowBandEng = DotProd(ptmpSigBuf, ptmpSigBuf, FRAME_LEN)/(float)FRAME_LEN;

  /*------------------------------------------------------------
    (2) Do LPC analysis and perceptually weight the high-pass 
    filtered signal.
    ------------------------------------------------------------*/
  VoxLPCAnaly4PDA(STACK_S ptmpSigBuf, ptmpSigBuf, FRAME_LEN, myCorrPDA_mblk);


  /*------------------------------------------------------------
    (3) Low pass filter the perceptual weighting signal.
    ------------------------------------------------------------*/
  VoxNspIIRFlt(ptmpSigBuf, ptmpSigBuf, FRAME_LEN, myCorrPDA_mblk->lpfCoefs, 
	       LPF_ORDER, myCorrPDA_mblk->lpf_mem);


  /*------------------------------------------------------------
    (4) Calculate cross correlation and reture the cost function
    of frame (1).
    ------------------------------------------------------------*/
  /* The signal of previous frame has been put to tmpBuf[0:89] and current 
     frame signal is at tmpBuf[90:179].
     So the decimated signal is put to [90:179]. */
  pSigLPF = tmpSigBuf + FRAME_LEN-1;
  ptmpSigBuf = tmpSigBuf + FRAME_LEN-2;
  for (i = LFRAME_LEN; i > 0; i--) {
    *pSigLPF-- = *ptmpSigBuf;
    ptmpSigBuf -= 2;
  }

  /* lpbuf has kept the previous 135 samples signal. 
     The previous frame signal is put to tmpBuf[0:89].*/
  pSigLPF = tmpSigBuf;
  memcpy(pSigLPF, &(myCorrPDA_mblk->lpfbuf[LFRAME_LEN_2]), sizeof(float)*LFRAME_LEN);



  /* Since tmpBuf[0:89] is identical to lpbuf[45:134],
     we borrow tmpBuf[0:89] for returned normalized costs. */
  corr_cost1 = tmpSigBuf;
  VoxCalcCrossCorrCost(STACK_S pSigLPF, corr_cost1, myCorrPDA_mblk, &bias_floor);
  

  /*------------------------------------------------------------
    (5) Backward and forward tracking the cost function to 
    get the coarse pitch value of frame (0).
    ------------------------------------------------------------*/
  coarse_pitch = VoxTrackPitch(STACK_S corr_cost1, myCorrPDA_mblk);


  /*------------------------------------------------------------
    (6) centerize the pitch.
    ------------------------------------------------------------*/
  /* the previous frame: lpfbuf[0:44],
     current frame: lpfbuf[45:134],
     future frame: ptmpSigBuf[90:179] */
  pSigLPF = &(tmpSigBuf[LFRAME_LEN]);
  refine_pitch = calcCenterCorr(STACK_S myCorrPDA_mblk,	pSigLPF, coarse_pitch, 
				&maxCost );


  /* update the costs value of current frame */
  if (maxCost > myCorrPDA_mblk->cost_1)
    myCorrPDA_mblk->cost_1 = maxCost;

  /* check if maxCost is too small */
  if (maxCost <= 0.01F) {
    myCorrPDA_mblk->cost_1 = INIT_COST;
    myCorrPDA_mblk->pitch_1 = myCorrPDA_mblk->pitch_2;
    refine_pitch = (float)myCorrPDA_mblk->pitch_2;
  }
   
 
  /* update the signal buffer */
  memcpy(myCorrPDA_mblk->lpfbuf, &(myCorrPDA_mblk->lpfbuf[LFRAME_LEN]), LFRAME_LEN_2*sizeof(float));
  memcpy(&(myCorrPDA_mblk->lpfbuf[LFRAME_LEN_2]), pSigLPF, LFRAME_LEN*sizeof(float));


  /* get the pitch delay size */
  *pda_delay_size = (float)(FRAME_LEN+LFRAME_LEN);

  /* Calculate Center Correlation Value for voiceActivity Function */
  CentCorrValue=maxCost/myCorrPDA_mblk->biasTab[(int)(refine_pitch+0.5F)-LPITCH_MIN];

  VoiceActivity(myCorrPDA_mblk->VADMemBlk, lowBandEng, CentCorrValue, VAD, UV);

  return (2.0F*refine_pitch);
}



/***********************************************************************
 * Function: initCorrPitchEst()
 *
 * Input:    myCorrPDA_mblk:  pointer for the structure.
 *
 * Output:   error code:   error with initialization.
 *           0:            no error
 ***********************************************************************/

static const float LpfCoefs2k[2*LPF_ORDER+1] = {
0.13209632758491F, 0.16441597660485F, 0.16441597660485F, 0.13209632758491F,
-1.00457576781968F, 0.75391007092870F,  -0.15630969472949F
};

#if USE_HPF == 1
static const float HpfCoefs100[2*HPF_ORDER+1] = {
0.89669841138219F, -3.58456196150319F,
5.37572784022113F, -3.58456196150319F, 0.89669841138219F,
-3.79077226063959F, 5.39682474557460F, -3.41970282566249F,
0.81372436653670F
};
#endif

unsigned short VoxInitCorrPitchEst(void **hCorrPDA_mblk)
{
  CorrPDA_mblk *myCorrPDA_mblk;
  float *pbias;
  float bias0;
  int i;
  int *pTabStart, *pTabLength;
  int delta;
  float x1;

  /* initialize the structure */
  if(VOX_MEM_INIT(myCorrPDA_mblk=(CorrPDA_mblk *)*hCorrPDA_mblk,1,
     sizeof(CorrPDA_mblk)) != 0)
	  return 1;

  /*------------------------------------------------------------
    initialize the inter-frame memory 
    ------------------------------------------------------------*/
#if USE_HPF == 1
  if(VOX_MEM_INIT(myCorrPDA_mblk->hpf_mem, HPF_ORDER, sizeof(float))!=0) 
    return 1;
#endif

  if(VOX_MEM_INIT(myCorrPDA_mblk->lpf_mem, LPF_ORDER, sizeof(float))!=0) 
    return 1;
 
  if(VOX_MEM_INIT(myCorrPDA_mblk->lpfbuf, (LFRAME_LEN+LFRAME_LEN_2), sizeof(float))!=0)
    return 1;

  if(VOX_MEM_INIT(myCorrPDA_mblk->costs0, (PITCH_CAND), sizeof(float))!=0)
    return 1;

  for (i = 0; i < PITCH_CAND; i++)
    myCorrPDA_mblk->costs0[i] = INIT_COST;

  if(VOX_MEM_INIT(myCorrPDA_mblk->Alsf0, PDA_LPC_ORDER, sizeof(float))!=0) 
    return 1;
  /* initialize Alsf0 */
  for (i = 0, x1=0.0F; i < PDA_LPC_ORDER; i++) 
    myCorrPDA_mblk->Alsf0[i] = x1 = (float)(ZERO_LSF + x1);
  

  if (VOX_MEM_INIT(myCorrPDA_mblk->percWeight_mem, PDA_LPC_ORDER, sizeof(float))!=0) 
    return 1;  

  myCorrPDA_mblk->pitch_1 = INIT_PITCH;
  myCorrPDA_mblk->pitch_2 = INIT_PITCH;

  myCorrPDA_mblk->cost_1 = INIT_COST;
  myCorrPDA_mblk->cost_2 = INIT_COST;


  /*------------------------------------------------------------
    Tables:  pre-caculated for general application 
    or load-in to ROM for DSP application 
    ------------------------------------------------------------*/
  myCorrPDA_mblk->lpfCoefs = (float *)LpfCoefs2k;

#if USE_HPF == 1
  myCorrPDA_mblk->hpfCoefs = (float *)HpfCoefs100;
#endif

  /* calculate the asymmetric Hamming window */
  if (VOX_MEM_INIT(myCorrPDA_mblk->LpcWindow, FRAME_LEN, sizeof(float))!=0) 
    return 1;

  hamming_half(myCorrPDA_mblk->LpcWindow, 2*LEFT_ASYM_WIN);
  hamming_right(myCorrPDA_mblk->LpcWindow+LEFT_ASYM_WIN, 2*RIGHT_ASYM_WIN);

  /* calculate the bias table */
  if(VOX_MEM_INIT(myCorrPDA_mblk->biasTab,PITCH_CAND,sizeof(float))!=0) 
     return 1;

  pbias = myCorrPDA_mblk->biasTab;
  bias0 = (float)pow((double)LPITCH_MIN, (double)BIAS_C0);   /*   *pbias++ = 1.0 - (float)i * BIAS_LAG;  */
  *pbias++ = 1.0F;
  for (i = LPITCH_MIN+1; i <= LPITCH_MAX; i++)
    *pbias++ = (float)(bias0/pow((double)i, (double)BIAS_C0));   /*   *pbias++ = 1.0 - (float)i * BIAS_LAG;  */


  /* calculate the tables for intra-frame tracking */
  if(VOX_MEM_INIT(myCorrPDA_mblk->dIntraLagStart, PITCH_CAND, sizeof(int))!=0) 
     return 1;
  
  if(VOX_MEM_INIT(myCorrPDA_mblk->dIntraLagLength, PITCH_CAND, sizeof(int))!=0) 
     return 1;
  pTabStart =  myCorrPDA_mblk->dIntraLagStart;
  pTabLength = myCorrPDA_mblk->dIntraLagLength;

  for (i = 0; i < PITCH_CAND; i++) {
    delta = (short)((float)(i+LPITCH_MIN)*INTRA_FRAME_TRACK_RATIO+0.5);

    *pTabStart = i-delta;
    if (*pTabStart < 0)
      *pTabStart = 0;

    *pTabLength = i+delta;
    if (*pTabLength >= PITCH_CAND)
      *pTabLength = PITCH_CAND-1;
    *pTabLength++ -= (*pTabStart++ - 1);
  }


  /* calculate the tables for inter-frame tracking */
  if(VOX_MEM_INIT(myCorrPDA_mblk->dInterLagStart, PITCH_CAND, sizeof(int))!=0) 
     return 1;
  
  if(VOX_MEM_INIT(myCorrPDA_mblk->dInterLagLength, PITCH_CAND, sizeof(int))!=0) 
     return 1;
  pTabStart = myCorrPDA_mblk->dInterLagStart;
  pTabLength = myCorrPDA_mblk->dInterLagLength;

  for (i = 0; i < PITCH_CAND; i++) {
    delta = (short)((float)(i+LPITCH_MIN)*INTER_FRAME_TRACK_RATIO+0.5);

    *pTabStart = i-delta;
    if (*pTabStart < 0)
      *pTabStart = 0;

    *pTabLength = i+delta;
    if (*pTabLength >= PITCH_CAND)
      *pTabLength = PITCH_CAND-1;
    *pTabLength++ -= (*pTabStart++ - 1);
  }
  if(initVAD(&(myCorrPDA_mblk->VADMemBlk)))
     return 1;

  return 0;
}


/***********************************************************************
 * Function: freeCorrPitchEst()
 *
 * Input:    myCorrPDA_mblk:   pointer for the structure.
 *
 * Output:   None
 ***********************************************************************/

unsigned short VoxFreeCorrPitchEst(void **hCorrPDA_mblk)
{
  CorrPDA_mblk *myCorrPDA_mblk=(CorrPDA_mblk *)*hCorrPDA_mblk;
  freeVAD(&(myCorrPDA_mblk->VADMemBlk));

  if(*hCorrPDA_mblk) {
#if USE_HPF == 1
    VOX_MEM_FREE(myCorrPDA_mblk->hpf_mem);
#endif

    VOX_MEM_FREE(myCorrPDA_mblk->lpf_mem);

    VOX_MEM_FREE(myCorrPDA_mblk->lpfbuf);

    VOX_MEM_FREE(myCorrPDA_mblk->costs0);

    VOX_MEM_FREE(myCorrPDA_mblk->Alsf0);

    VOX_MEM_FREE(myCorrPDA_mblk->percWeight_mem);

    VOX_MEM_FREE(myCorrPDA_mblk->LpcWindow);
    
    VOX_MEM_FREE(myCorrPDA_mblk->biasTab);

    VOX_MEM_FREE(myCorrPDA_mblk->dInterLagStart);

    VOX_MEM_FREE(myCorrPDA_mblk->dInterLagLength);

    VOX_MEM_FREE(myCorrPDA_mblk->dIntraLagStart);

    VOX_MEM_FREE(myCorrPDA_mblk->dIntraLagLength);
  
    VOX_MEM_FREE(*hCorrPDA_mblk);
  }

  return 0;
}


#define  MAGIC1 0.65F
#define  MAGIC2 0.6F
#define  MAGIC3 0.1F
#define  MAGIC4 0.16F
#define  MAGIC5 0.4F
#define  MAGIC6 0.4F
#define  MAGIC7 0.4F
#define  MAGIC8 0.60F

/*************************************************************
 *
 * Function: PvRefine()
 *
 * Action:   Refines Pv according to some black magic.
 *           
 * Input:    Pv           - Voicing for the current frame
 * Input:    Pv_1         - Refined Voicing for the last frame
 *           MaxCost      - biased pitch correlation
 *           MaxCostShift - shift of
 * Output:   Return refined Pv.
 *
 *************************************************************/


float PvRefine( float Pv, float Pv_1, float Pitch, float MaxCost, float *biasTab)
{
   float CentCorrValue;
   float RefinedPv;

   CentCorrValue = MaxCost/biasTab[(int)(Pitch+0.5F)-LPITCH_MIN];
   if (CentCorrValue < 0.0F)
      CentCorrValue = 0.0F;

   if (CentCorrValue > 1.0F)
      CentCorrValue = 1.0F;


   RefinedPv = Pv;
   if ((CentCorrValue>MAGIC2)&&(Pv>MAGIC3))
   {
      RefinedPv = (float) (Pv+CentCorrValue)* ((float) 0.5);
   }
   else if ((Pv*CentCorrValue < MAGIC4)&&(CentCorrValue<MAGIC8))
   {
      if (Pv_1 < MAGIC5)
         RefinedPv =0;
   }
   else if ((Pv > MAGIC6)&&(CentCorrValue>MAGIC7))
   {     
      RefinedPv = (float) sqrt(Pv);
   }
   
   return(RefinedPv);

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\decvcfry.c ===
/******************************************************************************
*                        Voxware Proprietary Material
*                        Copyright 1996, Voxware, Inc
*                            All Rights Reserved
*
*                       DISTRIBUTION PROHIBITED without
*                      written authorization from Voxware
******************************************************************************/
 
/******************************************************************************
*
* Filename: DecVcFry.c
*
* Purpose: Simple Vocal Fry detector -- only for pitch double case.
*
* Author:  Wei Wang
*
* Date:    July 11, 1997.
*
*******************************************************************************
*
* $Header:   /export/phobos/pvcs/r_and_d/archives/scaleable/encode/DecVcFry.c_v   1.2   13 Apr 1998 16:17:08   weiwang  $
* 
*******************************************************************************/

#include <assert.h>
#include <math.h>
#include <stdlib.h>
#include <string.h>

#include "vLibTran.h"

#include "codec.h"
#include "paramSC.h"
#include "VoxMem.h"
#include "DecVcFry.h"

#include "xvocver.h"

typedef struct
{
  float averagePitch;
  float confident;
  float *averageCepstrum;
} VocalFry_mblk;

static const float fCepWeight[VF_CEP_ORDER] = {
  2.552914F, 4.0F, 5.24264F,  6.19615F,
  6.795555F, 7.0F, 6.795555F, 6.1961524F,
  5.24264F,  4.0F, 2.552914F, 1.0F
};


static void Cepstrum4VocalFry(STACK_R float fGain, float *pfAS,
                              float *fAverageCepstrum,
                              float *dGain, float *dCep,
                              int lpcorder);

short Detect_VocalFry(STACK_R void *hParamMblk, void *hVocalFryMblk, 
                      float *fAS, int lpcorder)
{
  VocalFry_mblk *pVocalFryMblk = (VocalFry_mblk *)hVocalFryMblk;
  PARAM_SC *pParamMblk = (PARAM_SC *)hParamMblk;
  float dGain, dCep;
  float averagePitch = pVocalFryMblk->averagePitch;
  float confident = pVocalFryMblk->confident;
  float vfPitch;
  short VFflag = 0;
  SUBFRAME_PARAM_SC *pSubParam;

  assert(hParamMblk != NULL);

  pSubParam = &(pParamMblk->SubParam[PARAM_ENDFRAME]);

  /* Calculate the cepstrum coefficients to verify the decision */
  Cepstrum4VocalFry(STACK_S pParamMblk->fLog2Gain, fAS,
                    pVocalFryMblk->averageCepstrum, &dGain, &dCep, lpcorder);

  /* Find out when the pitch suddently doubled */
  if ((averagePitch < pSubParam->Pitch) && (pSubParam->Pv>=0.2F))
  {
    vfPitch = 0.5F*pSubParam->Pitch;      /* find half pitch */

    if ((averagePitch>(0.87F*vfPitch))&&(averagePitch<(1.15F*vfPitch)))
      VFflag = 1;
  }


  /* use dGain and dCep to eliminate the wrong decision */
  if ((VFflag == 1) && (dGain <= 2.0F)
      && (((dCep <= 0.5F) && (confident >= 3.5F))
      || ((dCep <= 0.4F)&&(confident>=2.5F))
      ||((dCep<=0.1)&&(confident>=1.5F))))
    VFflag = 1;
  else
    VFflag = 0;

  return VFflag;
}


/* update the vocal fry detector states */
void UpdateVF_States(void *hParamMblk, void *hVocalFryMblk )
{
  VocalFry_mblk *pVocalFryMblk = (VocalFry_mblk *)hVocalFryMblk;
  PARAM_SC *pParamMblk = (PARAM_SC *)hParamMblk;
  float averagePitch = pVocalFryMblk->averagePitch;
  float confident = pVocalFryMblk->confident;
  float vfPitch;
  SUBFRAME_PARAM_SC *pSubParam_Mid, *pSubParam_End;

  pSubParam_Mid = &(pParamMblk->SubParam[PARAM_MIDFRAME]);
  pSubParam_End = &(pParamMblk->SubParam[PARAM_ENDFRAME]);

  /* update the average pitch and confident */
  vfPitch = pSubParam_End->Pitch;

  if ((averagePitch>(0.8F*vfPitch))&&(averagePitch<(1.2F*vfPitch))) {
    averagePitch = 0.3F*averagePitch + 0.7F*vfPitch;
    confident += 1.0F;
  }
  else {
    if (pSubParam_End->Pv >= 0.3F) {  /*** probably voiced ****/
      averagePitch = vfPitch;
      confident = pSubParam_End->Pv;
    }
    else {
      averagePitch = VF_BAD_PITCH;
      confident = 0.0F;
    }
  }

  if ((averagePitch>(0.9F*pSubParam_Mid->Pitch))
      &&(averagePitch<(1.1F*pSubParam_Mid->Pitch)))
    confident += 1.0F;

  pVocalFryMblk->confident = confident;
  pVocalFryMblk->averagePitch = averagePitch;
}



/*
 * Cepstrum4VocalFry: calculate the difference of cepstrum and gain 
 */

static void Cepstrum4VocalFry(STACK_R float fGain, float *pfAS,
                              float *fAverageCepstrum,
                              float *dGain, float *dCep,
                              int lpcorder)
{
  STACK_INIT 
    float fCepstrum[VF_CEP_ORDER+1];
  STACK_INIT_END
  int i;
  register float dis;
  
  STACK_ATTACH(float *, fCepstrum)

  STACK_START

  /***** Change LPC coefficients to cepstrum *****/
  VoxAsToCs(fGain, pfAS, lpcorder, fCepstrum, VF_CEP_ORDER+1);

  /***** Compute the distortion *****/
  *dGain =(float)fabs(-fCepstrum[0] + fAverageCepstrum[0]);

  *dCep = 0.0F;
  for (i = 1; i <= VF_CEP_ORDER; i++) {
    fCepstrum[i] *= fCepWeight[i-1];

    dis = fCepstrum[i] - fAverageCepstrum[i];

    *dCep += dis * dis;
  }
  *dCep *= (float)INV_ORDER;


  /**** Get the average cepstrum ****/
  if (*dCep < 0.05F) {
    for (i = 0; i <= VF_CEP_ORDER; i++)
      fAverageCepstrum[i] = 0.9F*fCepstrum[i] + 0.1F*fAverageCepstrum[i];
  }
  else {
    for (i = 0; i <= VF_CEP_ORDER; i++)
      fAverageCepstrum[i] = fCepstrum[i];
  }

  STACK_END
}


/*
 * Initialize vocal fry structure 
 */
unsigned short VoxInitVocalFry(void **hVocalFryMblk)
{
  
  VocalFry_mblk *pVocalFryMblk;

  /**** initialize the structure pointer ****/
  if (VOX_MEM_INIT(pVocalFryMblk=*hVocalFryMblk, 1, sizeof(VocalFry_mblk)))
    return 1;

  /**** initialize the averageCepstrum array *****/
  if (VOX_MEM_INIT(pVocalFryMblk->averageCepstrum, VF_CEP_ORDER+1,
         sizeof(float)))
    return 1;
  
  
  /**** initialize the values ****/
  pVocalFryMblk->averagePitch = VF_BAD_PITCH;
  pVocalFryMblk->confident = 0.0F;
  memset(pVocalFryMblk->averageCepstrum, 0, sizeof(float)*(VF_CEP_ORDER+1));
  
  return 0;
}


/* 
 * free vocal fry structure 
 */
unsigned short VoxFreeVocalFry(void **hVocalFryMblk)
{
  VocalFry_mblk *pVocalFryMblk = (VocalFry_mblk *) *hVocalFryMblk;


  if (pVocalFryMblk) {

    /* free averageCepstrum */
    VOX_MEM_FREE(pVocalFryMblk->averageCepstrum);
    
    /* free pVocalFryMblk */
    VOX_MEM_FREE(pVocalFryMblk);

  }

  return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\decvcfry.h ===
/*******************************************************************************
*                        Voxware Proprietary Material                          *
*                        Copyright 1996, Voxware, Inc                          *
*                            All Rights Reserved                               *
*                                                                              *
*                       DISTRIBUTION PROHIBITED without                        *
*                      written authorization from Voxware                      *
*******************************************************************************/

/*******************************************************************************
* $Header:   /export/phobos/pvcs/r_and_d/archives/scaleable/encode/DecVcFry.h_v   1.0   06 Feb 1998 10:06:40   johnp  $
*******************************************************************************/
#ifndef _DETECT_VOCAL_FRY_
#define _DETECT_VOCAL_FRY_

short Detect_VocalFry(STACK_R void *hParamMblk, void *hVocalFryMblk, 
                      float *fAS, int lpcorder);

/* update the vocal fry detector states */
void UpdateVF_States(void *hParamMblk, void *hVocalFryMblk );

unsigned short VoxInitVocalFry(void **hVocalFryMblk);

unsigned short VoxFreeVocalFry(void **hVocalFryMblk);

#endif /* _DETECT_VOCAL_FRY_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\demltplx.c ===
/*******************************************************************************
*                        Voxware Proprietary Material
*                        Copyright 1997, Voxware, Inc
*                            All Rights Reserved
*
*                       DISTRIBUTION PROHIBITED without
*                      written authorization from Voxware
*******************************************************************************/
 
/*******************************************************************************
*
* Filename:    DeMltplx.c
*
* Purpose:     Demultiplex the real and imaginary part of the spectrum
*
* Functions:   VoxDeMultiplex()
*
* Author/Date: Bob Dunn  1/16/98
*
********************************************************************************
*
* Modifications:  
*
* Comments: 
*
* Concerns: 
*
* $Header:   /export/phobos/pvcs/pvcsproj/voxlib.prj/DeMltplx.c_v   1.3   02 Mar 1998 15:35:42   weiwang  $
*******************************************************************************/

#include "vLibTran.h"

#include "xvocver.h"

/*******************************************************************************
*
* Function:  VoxDeMultiplex()
*
* Action:    Demultiplex the real and imaginary part of the spectrum
*
* Input:     const float *pfSW    --> interleaved spectrum
*            int          iLength --> length of output arrays
*
* Output:    float *pfRE          --> real part of spectrum
*            float *pfIM          --> imaginary part of spectrum
*
* Globals:   none
*
* Return:    void
********************************************************************************
*
* Modifications:
*
* Comments:       The length of the output array is left to the user to 
*                   define, since they may or may not have room for the
*                   point at PI.
*
* Concerns/TBD:   WARNING:  In order to save memory it is possible to 
*                   demultiplex the real part "in place".  That is, it
*                   is possible that pfSW=pfRE!!!  It is critical 
*                   that the order of operations in this function 
*                   maintain compatability with "in place" operation
*                   on the real part.
*******************************************************************************/

void VoxDemultiplex( const float *pfSW,
                     float       *pfRE,
                     float       *pfIM,
                     int          iLength
                   )
{
   while ((iLength--) > 0)
   {
      *pfRE++ = *pfSW++;
      *pfIM++ = *pfSW++;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\decsc.h ===
/******************************************************************************
*                        Voxware Proprietary Material                         *
*                        Copyright 1996, Voxware, Inc                         *
*                            All Rights Reserved                              *
*                                                                             *
*                       DISTRIBUTION PROHIBITED without                       *
*                      written authorization from Voxware                     *
******************************************************************************/

/******************************************************************************
* Filename:       DecSC.h
*                                                                              
* Purpose:        Decode speech model parameters and synthesize speech
*                 frame by frame and store in output buffer
*                                                                              
* Functions:      VoxDecodeSC(), VoxInitDecodeSC(), VoxFreeDecodeSC()
*                                                                              
* Author/Date:    Original developed by Bob McAulay and Bob Dunn 1/97
*******************************************************************************
* Modifications: changed output buffer manager, Wei Wang, 2/18/98
*                remove paramMblk from decoder structure, 2/19/98, Wei Wang
*                                                                              
* Comments:                                                                    
* 
* Concerns:
*
* $Header:   /export/phobos/pvcs/r_and_d/archives/scaleable/decode/DecSC.h_v   1.9   10 Apr 1998 16:10:46   weiwang  $
******************************************************************************/

#ifndef DECSC_H
#define DECSC_H

/*******************************************************************************
*
* Function:  VoxDecodeSC()
*
* Action:    main decoder function
*
* Input:    pPCMBuffer   -- pointer to the output PCM buffer
*           hMemBlkD     -- the decoder memory block
*           hParamMblk   -- parameter memory block
*
* Output:   pPCMBuffer   -- output PCM buffer
*           pwPCMsamples -- number of samples in the output PCM buffer
*           hMemBlkD     -- updated decoder memory block
*
* Globals:   none
*
* Return:    none
*******************************************************************************/


void VoxDecodeSC( STACK_R 
                  void           *hMemBlkD,
                  void           *hParamMblk,
                  short          *pPCMBuffer, 
                  unsigned short *pwPCMsamples 
                );

/*******************************************************************************
*
* Function:  VoxInitDecodeSC3()
*
* Action:    initialize decoder structure for SC3
*
* Input:    ppMemBlkD -- pointer to the decoder memory block (NULL)
*
* Output:   ppMemBlkD -- initialized decoder memory block
*
* Globals:   none
*
* Return:    0: succeed, 1: failed
********************************************************************************/

unsigned short VoxInitDecodeSC3(void **hMemBlkD);


/*******************************************************************************
*
* Function:  VoxFreeDecodeSC3()
*
* Action:    free decoder structure for SC3
*
* Input:    hMemBlkD -- pointer to the decoder memory block
*
* Output:   hMemBlkD -- freed decoder memory block (NULL)
*
* Globals:   none
*
* Return:    0: succeed, 1: failed
********************************************************************************/

unsigned short VoxFreeDecodeSC3(void **hMemBlkD);

/*******************************************************************************
*
* Function:  VoxInitDecodeSC6()
*
* Action:    initialize decoder structure for SC6
*
* Input:    ppMemBlkD -- pointer to the decoder memory block
*
* Output:   ppMemBlkD -- initialized decoder memory block
*
* Globals:   none
*
* Return:    0: succeed, 1: failed
********************************************************************************/

unsigned short VoxInitDecodeSC6(void **hMemBlkD);


/*******************************************************************************
*
* Function:  VoxFreeDecodeSC6()
*
* Action:    free decoder structure for SC6
*
* Input:    hMemBlkD -- pointer to the decoder memory block
*
* Output:   hMemBlkD -- modified decoder memory block with SC6 related fields
*                       freed.
*
* Globals:   none
*
* Return:    0: succeed, 1: failed
********************************************************************************
* Modifications:
*
* Comments:    Need call this function before call VoxFreeDecodeSC3().
*
* Concerns/TBD:
********************************************************************************/

unsigned short VoxFreeDecodeSC6(void **hMemBlkD);

#endif /* DECSC_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\decsc.c ===
/******************************************************************************
*                        Voxware Proprietary Material                         *
*                        Copyright 1996, Voxware, Inc                         *
*                            All Rights Reserved                              *
*                                                                             *
*                       DISTRIBUTION PROHIBITED without                       *
*                      written authorization from Voxware                     *
******************************************************************************/

/******************************************************************************
* Filename:       DecSC.c
*                                                                              
* Purpose:        Decode speech model parameters and synthesize speech
*                 frame by frame and store in output buffer
*                                                                              
* Functions:      VoxDecodeSC(), VoxInitDecodeSC(), VoxFreeDecodeSC()
*                                                                              
* Author/Date:    Original developed by Bob McAulay and Bob Dunn 1/97
*******************************************************************************
* Modifications: changed output buffer manager, Wei Wang, 2/18/98
*                remove paramMblk from decoder structure, 2/19/98, Wei Wang
*                                                                              
* Comments:                                                                    
* 
* Concerns:
*
* $Header:   /export/phobos/pvcs/r_and_d/archives/scaleable/decode/DecSC.c_v   1.21   13 Apr 1998 16:16:58   weiwang  $
******************************************************************************/


#include <stdlib.h>
#include <math.h>
#include <assert.h>
#include <string.h>

#include "vLibTran.h"
#include "vLibVec.h"
#include "vLibMath.h"
#include "VoxMem.h"

#include "paramSC.h"
#include "codec.h"
#include "quansc36.h"
#include "SWSynth.h"
#include "rate.h"
#include "AskToEnv.h"
#include "HFRegen.h"
#include "OutBufSC.h"
#include "SubFmSyn.h"
#include "DecPriSC.h"
#include "DecSC.h"

#include "xvocver.h"
 
/*--------------------------------------------------
  Private functions
  --------------------------------------------------*/
static void DecFrameInit(DEC_MEM_BLK *pDecMemBlk );

static void DecFrameCleanUp(DEC_MEM_BLK *pDecMemBlk, 
                            PARAM_SC *pParamMblk, 
                            float *pfEnv, 
                            float *pfPhase);



/*******************************************************************************
*
* Function:  VoxDecodeSC()
*
* Action:    main decoder function
*
* Input:    pPCMBuffer   -- pointer to the output PCM buffer
*           hMemBlkD     -- the decoder memory block
*           hParamMblk   -- parameter memory block
*
* Output:   pPCMBuffer   -- output PCM buffer
*           pwPCMsamples -- number of samples in the output PCM buffer
*           hMemBlkD     -- updated decoder memory block
*
* Globals:   none
*
* Return:    none
********************************************************************************
*
* Modifications:
*
* Comments:
*
* Concerns/TBD:
*******************************************************************************/

void VoxDecodeSC( STACK_R 
                  void           *hMemBlkD,
                  void           *hParamMblk,
                  short          *pPCMBuffer, 
                  unsigned short *pwPCMsamples 
                )
{
   DEC_MEM_BLK *pDecMemBlk=(DEC_MEM_BLK*)hMemBlkD;

   PARAM_SC  *pParamMblk   = (PARAM_SC *)hParamMblk;

   float *fSpeechBuf;

   /*---------------------------------------------------
     The arrays pfEnv[] and pfPhase[] require
       CSENV_NFFT_2+1 points in SetAmpAndPhase().
   ---------------------------------------------------*/
STACK_INIT
   float pfEnv[CSENV_NFFT_2+1];
   float pfPhase[CSENV_NFFT_2+1];
STACK_INIT_END
 
   STACK_ATTACH(float *, pfEnv)
   STACK_ATTACH(float *, pfPhase)
  
   int    iSynSamples = 0;

   STACK_START

   /*----------------------------------------------------------------------
     Initialize some things in the decoder block to prepare for synthesis
   ----------------------------------------------------------------------*/
   DecFrameInit( pDecMemBlk );

   /*----------------------------------------------------------------------
     Copy the content of pSaveBuffer to pPCMBuffer.
    ----------------------------------------------------------------------*/
   PreOutputManagerSC(pDecMemBlk->pfSaveBuffer, pDecMemBlk->iSaveSamples,
                      pPCMBuffer);

   fSpeechBuf = pDecMemBlk->pfSaveBuffer; /* Re-use pSaveBuffer for synthesis */

   /*--------------------------------------------------------------------
     Compute envelope and phase from arcsin reflection coefficients
   --------------------------------------------------------------------*/
   VoxAskToEnv(STACK_S pParamMblk->pfASK, pParamMblk->fLog2Gain,
               pfEnv, pfPhase);

   /*--------------------------------------------------------------------
     Synthesize 10 ms speech sub-frames (0, 1, or 2 may be synthesized)
   --------------------------------------------------------------------*/
   SubFrameSynth( STACK_S pDecMemBlk, (void *)(pParamMblk->SubParam),
                  fSpeechBuf, pfEnv, pfPhase,
                  &iSynSamples);

   /*----------------------------------------------------------------------
     Do output buffering and put output in pPCMBuffer
   ----------------------------------------------------------------------*/
   PostOutputManagerSC(pDecMemBlk->pfSaveBuffer, &(pDecMemBlk->iSaveSamples),
                       iSynSamples, pPCMBuffer, pwPCMsamples);

   /*----------------------------------------------------------------------
     Do book-keeping for next time
   ----------------------------------------------------------------------*/
   DecFrameCleanUp(pDecMemBlk, pParamMblk, pfEnv, pfPhase );

   STACK_END
}


/*******************************************************************************
*
* Function:  VoxInitDecodeSC3()
*
* Action:    initialize decoder structure for SC3
*
* Input:    ppMemBlkD -- pointer to the decoder memory block (NULL)
*
* Output:   ppMemBlkD -- initialized decoder memory block
*
* Globals:   none
*
* Return:    0: succeed, 1: failed
********************************************************************************
*
* Modifications:
*
* Comments:
*
* Concerns/TBD:
*******************************************************************************/

unsigned short VoxInitDecodeSC3(void **ppMemBlkD)
{
   DEC_MEM_BLK *pDecode_mblk;

   if(VOX_MEM_INIT(pDecode_mblk=*ppMemBlkD,1,sizeof(DEC_MEM_BLK)))
      return 1;

   /****************************************************
    Ensure bit allocation is byte aligned
    ****************************************************/
   assert(TOTAL_BITS_SC3%8 == 0);

   /****************************************************
     Initialize Overlapadd 
     ***************************************************/
   if (VOX_MEM_INIT(pDecode_mblk->pWaveform_1, HALF_FRAME_LENGTH_SC, 
                    sizeof(float)))
       return 1;

   /****************************************************
    Initialize the Output Buffer block
    ****************************************************/
   if (VOX_MEM_INIT(pDecode_mblk->pfSaveBuffer, FRAME_LENGTH_SC, sizeof(float)))
      return 1;
   
   /****************************************************
    initialize HFRegen structure
    ****************************************************/
   if(VoxInitHFRegen(&pDecode_mblk->hHFRegenMblk))
      return 1;

   /****************************************************
    initialize the fWarpedLengthFactor
    ****************************************************/
   pDecode_mblk->fWarpedLengthFactor=1.0F;
   pDecode_mblk->fActualWarp=1.0F;
   pDecode_mblk->iNewFrame=1;
   pDecode_mblk->fSynTimeOffset=(float)HALF_FRAME_LENGTH_SC;

   pDecode_mblk->piFrameCount[0] = 1;   /* value of 1 assumes no warping */
   pDecode_mblk->piFrameCount[1] = 1;   /* value of 1 assumes no warping */

   /****************************************************
    Set the random seed for unvoiced phases 
    ****************************************************/
   pDecode_mblk->lUVPhaseRandSeed = 1;

   /****************************************************
    Set the rate valid flag
    ****************************************************/
   pDecode_mblk->iSCRateValid = SC_RATE_3K;
   pDecode_mblk->iSCTargetRate = SC_RATE_3K;
   pDecode_mblk->iSCRate_1 = SC_RATE_3K;

   /****************************************************
    Allocate space for phase and magnitude envelopes
    ****************************************************/
   if(VOX_MEM_INIT(pDecode_mblk->pfEnv_1,(CSENV_NFFT_2+1),
                   sizeof(float)))
      return 1;
 
   if(VOX_MEM_INIT(pDecode_mblk->pfPhase_1,(CSENV_NFFT_2+1),
                   sizeof(float)))
      return 1;

   /***************************************************
     Initialize the parameters of previous frame
    **************************************************/
   pDecode_mblk->Pitch_1_mid = INITIAL_PITCH;
   pDecode_mblk->PrevSubParam.Pitch = INITIAL_PITCH;

   return 0;
}

/*******************************************************************************
*
* Function:  VoxInitDecodeSC6()
*
* Action:    initialize decoder structure for SC6
*
* Input:    ppMemBlkD -- pointer to the decoder memory block
*
* Output:   ppMemBlkD -- initialized decoder memory block
*
* Globals:   none
*
* Return:    0: succeed, 1: failed
********************************************************************************
*
* Modifications:
*
* Comments:
*
* Concerns/TBD:
*******************************************************************************/

unsigned short VoxInitDecodeSC6(void **ppMemBlkD)
{
   DEC_MEM_BLK *pDecode_mblk=(DEC_MEM_BLK *)*ppMemBlkD;

   /****************************************************
    Ensure bit allocation is byte aligned
    ****************************************************/
   assert( ADDITIONAL_BITS_SC6 == ADDITIONAL_BYTES_SC6*8 );

   /****************************************************
    check for valid pointer
    ****************************************************/
   if (pDecode_mblk==NULL)
      return 1;

   /****************************************************
    make sure SC_RATE_3K was already initialized
    ****************************************************/
   if(!(pDecode_mblk->iSCRateValid & SC_RATE_3K))
      return 1;


   /****************************************************
    Set the rate valid flag
    ****************************************************/
   pDecode_mblk->iSCRateValid |= SC_RATE_6K;
   pDecode_mblk->iSCTargetRate = SC_RATE_6K;
   pDecode_mblk->iSCRate_1 = SC_RATE_6K;

   return 0;
}

/*******************************************************************************
*
* Function:  VoxFreeDecodeSC3()
*
* Action:    free decoder structure for SC3
*
* Input:    hMemBlkD -- pointer to the decoder memory block
*
* Output:   hMemBlkD -- freed decoder memory block (NULL)
*
* Globals:   none
*
* Return:    0: succeed, 1: failed
********************************************************************************
*
* Modifications:
*
* Comments:
*
* Concerns/TBD:
*******************************************************************************/

unsigned short VoxFreeDecodeSC3(void **hMemBlkD)
{
    DEC_MEM_BLK *pDecode_mblk=(DEC_MEM_BLK*)*hMemBlkD;

#ifdef WIN32
    nspFreeFftResources();
#endif

    if (pDecode_mblk) {

       VOX_MEM_FREE(pDecode_mblk->pWaveform_1);

       VOX_MEM_FREE(pDecode_mblk->pfSaveBuffer);

       VoxFreeHFRegen(&pDecode_mblk->hHFRegenMblk);

       VOX_MEM_FREE(pDecode_mblk->pfEnv_1);

       VOX_MEM_FREE(pDecode_mblk->pfPhase_1);

       VOX_MEM_FREE(pDecode_mblk);
    }
    return 0;
}

/*******************************************************************************
*
* Function:  VoxFreeDecodeSC6()
*
* Action:    free Decoder structure for SC6
*
* Input:    hMemBlkD -- pointer to the decoder memory block
*
* Output:   hMemBlkD -- modified decoder memory block with SC6 related fields
*                       freed.
* Globals:   none
*
* Return:    0: succeed, 1: failed
********************************************************************************
* Modifications:
*
* Comments:    Need call this function before call VoxFreeDecodeSC3().
*
* Concerns/TBD:
*******************************************************************************/

unsigned short VoxFreeDecodeSC6(void **hMemBlkD)
{
    DEC_MEM_BLK *pDecode_mblk=(DEC_MEM_BLK*)*hMemBlkD;
  
    if (pDecode_mblk) {

       /****************************************************
        clear the rate valid flag
        ****************************************************/
       pDecode_mblk->iSCRateValid &= (~(SC_RATE_6K));
    }

    return 0;
}



/*******************************************************************************
*
* Function:  DecFrameInit()
*
*******************************************************************************/

static void DecFrameInit( DEC_MEM_BLK *pDecMemBlk )
{
   /*-------------------------------------------------------------------------
     When decoding a new frame of data, the following must be initialized:
   -------------------------------------------------------------------------*/
   if (pDecMemBlk->iNewFrame)
   {
      /*----------------------------------------------
        Read the time warp factor and the number of
          frames skipped.
      ----------------------------------------------*/
      pDecMemBlk->fActualWarp          = pDecMemBlk->fWarpedLengthFactor;
      pDecMemBlk->iActualFramesSkipped = pDecMemBlk->iFramesSkipped;
   
      /*----------------------------------------------
        Determine if the phase offset should be 
          adjusted in HighFrequencyRegeneration()
          (i.e the value of iSetOffsetFlag)
      ----------------------------------------------*/
      if (pDecMemBlk->iActualFramesSkipped || (pDecMemBlk->iFramesRepeated
          && !(pDecMemBlk->iRepeatFrameFlag)))
         pDecMemBlk->iSetOffsetFlag = 1;
      else
         pDecMemBlk->iSetOffsetFlag = 0;
   
      /*----------------------------------------------
        Set the number of frame repeats
      ----------------------------------------------*/
      if (pDecMemBlk->iRepeatFrameFlag)
         pDecMemBlk->iFramesRepeated += 1;
      else
         pDecMemBlk->iFramesRepeated = 0;

      /*----------------------------------------------
        Reset these values
      ----------------------------------------------*/
      pDecMemBlk->iFramesSkipped = 0;
      pDecMemBlk->iRepeatFrameFlag = 0;
      pDecMemBlk->iNewFrame = 0;
   }
}


/*******************************************************************************
*
* Function:  DecFrameCleanUp()
*
*******************************************************************************/

static void DecFrameCleanUp(DEC_MEM_BLK *pDecMemBlk, PARAM_SC *pParamMblk,
                            float *pfEnv, float *pfPhase )
{
   int *piFrameCount;

   /*----------------------------------------------------------------------
     Save some things and set up for next time
   ----------------------------------------------------------------------*/
   if (pDecMemBlk->iNewFrame) 
   {
      /*----------------------------------------------------------------------
        Save/reset frame counters
      ----------------------------------------------------------------------*/
      piFrameCount = pDecMemBlk->piFrameCount;
     
      piFrameCount[0] = piFrameCount[2];
      piFrameCount[1] = piFrameCount[3];
      piFrameCount[2] = 0;
      piFrameCount[3] = 0;

      /*----------------------------------------------------------------------
        save amplitude and phase envelopes
      ----------------------------------------------------------------------*/
      memcpy( pDecMemBlk->pfEnv_1, pfEnv, (CSENV_NFFT_2+1)*sizeof(float));

      memcpy( pDecMemBlk->pfPhase_1, pfPhase, (CSENV_NFFT_2+1)*sizeof(float));
 
      /*----------------------------------------------------------------------
       copy the parameters
      ----------------------------------------------------------------------*/
      memcpy(&(pDecMemBlk->PrevSubParam), 
             &(pParamMblk->SubParam[PARAM_ENDFRAME]),
             sizeof(SUBFRAME_PARAM_SC));

      pDecMemBlk->Pitch_1_mid = pParamMblk->SubParam[PARAM_MIDFRAME].Pitch;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\decprisc.h ===
/******************************************************************************
*                        Voxware Proprietary Material                         *
*                        Copyright 1996, Voxware, Inc                         *
*                            All Rights Reserved                              *
*                                                                             *
*                       DISTRIBUTION PROHIBITED without                       *
*                      written authorization from Voxware                     *
******************************************************************************/

/******************************************************************************
* Filename:       DecPrivSC.h
*                                                                              
* Purpose:        The private structure for decoder. 
*                                                                              
* Functions:      no
*                                                                              
* Author/Date:    Original developed by Bob McAulay and Bob Dunn 1/97
*******************************************************************************
* Modifications:  Remove ParamMblk to save memory. 
*
* Comments:  This is the private structure which can only be used for
*            DecSC.c and DecPlsSC.c
* 
* Concerns:  ParamMblk is removed however warping needs it. Instead, the 
*            current Vox Buffer is saved (packed bits) in VCI block. So 
*            warping can always work under quantization mode but not model 
*            mode (only encoder and decoder).
*
* $Header:   /export/phobos/pvcs/r_and_d/archives/scaleable/decode/DecPriSC.h_v   1.7   22 Jun 1998 14:29:30   weiwang  $
******************************************************************************/
#ifndef DECPRISC_H
#define DECPRISC_H

/*---------------------------------------------------------------------
  Decoder Structure ...
  ---------------------------------------------------------------------*/
typedef struct tagDecode_mblk
{
  /* structure for VCI */
   void           *pFadeIOMemBlk;   /* Fade IO memory block                   */
   unsigned char  *pbSaveVoxBuffer; /* Save current Vox Buffer for later use  */

   void*     hHFRegenMblk;
   float*    pWaveform_1; /* overlapadd.. no need for a structure IB 97/05/15*/

   float*    pfSaveBuffer;  /* for output buffer manager */
   int       iSaveSamples;  /* for output buffer manager */

   int   iSCRateValid;       /** valid bit rates to use **/
   int   iSCRate_1;          /** bit rate for previous frame **/
   int   iSCTargetRate;      /** user modified bit rate **/

   long   lUVPhaseRandSeed;   /* random seed for unvoiced phases */

   float     *pfEnv_1;
   float     *pfPhase_1;

  /**** parameters of previous frame ****/
  float  Pitch_1_mid;
  SUBFRAME_PARAM_SC  PrevSubParam;

   float     fWarpedLengthFactor;
   float     fActualWarp;  
   int       iNewFrame;
   float     fSynTimeOffset;
   float     fPhaseOffset;
   int       iFramesSkipped;
   int       iActualFramesSkipped;
   int       iRepeatFrameFlag;
   int       iFramesRepeated;
   int       iSetOffsetFlag;

   int       piFrameCount[4];
} DEC_MEM_BLK;


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\dft.c ===
/******************************************************************************
*                        Voxware Proprietary Material
*                        Copyright 1996, Voxware, Inc
*                            All Rights Reserved
*
*                       DISTRIBUTION PROHIBITED without
*                      written authorization from Voxware
******************************************************************************/
 
/******************************************************************************
* Filename:       dft.c
* Purpose:        Compute the dft at harmonic frequencies.
* Functions:      VoxDFT()
* Author/Date:    Bob Dunn 4/8/97
*
* $Header:   /export/phobos/pvcs/r_and_d/archives/scaleable/utils/dft.c_v   1.1   10 Feb 1998 13:43:10   weiwang  $
*
******************************************************************************/
#include <math.h>

#include "vLibMath.h"
#include "trigSC.h"
#include "dft.h"

#include "xvocver.h"


extern const float *sinTBL_32;
extern const float *cosTBL_32;
extern const float fRadiansToIndex;


/******************************************************************************
*
* Function:  VoxDFT()
*
* Action:    Compute the dft at harmonic frequencies.
*
* Input:     *pfx:    windowed input signal
*            iLength: length of windowed input signal
*            fOmega:  fundamental frequency for DFT in radians
*            iNFreq:  number of spectral samples to compute
*
* Output:    pfXr:    real part of spectrum at harmonic frequencies
*            pfXi:    imaginary part of spectrum at harmonic frequencies
*
* Globals:   Sine and Cosine tables.
*
* Return:    none.
*******************************************************************************
*
* Implementation/Detailed Description:
*
*    The real and imaginary parts of the spectral samples are 
*      computed at:
*
*        Omega, 2*Omega, 3*Omega, ..., iNFreq*Omega
*
*    If the length of the analysis window is odd, the center point of
*      the window is placed at the origin.  If the length of the
*      analysis window is even, the point at pfx[iLength/2] is placed at
*      the origin.
*
*    There are two segments of code below.  The first code segment
*      is a straight forward implementation of the DFT.  The second
*      code segment is an optimized implementation which uses tables
*      for the sine and cosine and takes advantage of the symmetry
*      of the sine and cosine.
*
* References: 
******************************************************************************/

void VoxDFT( float *pfx, 
             int    iLength, 
             float  fOmega, 
             int    iNFreq, 
             float *pfXr, 
             float *pfXi
           )
{
   int   i, j;
   int   iArg0;
   int   iArg;
   float fArg0;
   float fCosArg;
   float fSinArg;
   float fReal;
   float fImag;
   float *pfx1;
   float *pfx2;
   float ftmp;

   fArg0 = 0.0F;
   for (i=iNFreq; i; i--) 
   {
      /*-------------------------------------------
        Set the data pointers to the center of the
          analysis window.
      -------------------------------------------*/
      pfx1 = pfx2 = pfx + (iLength>>1);

      /*-------------------------------------------
        Set the frequency
      -------------------------------------------*/
      fArg0 += fOmega;

      /*-------------------------------------------
        Quantize the frequency and set up indexing
          constants.
      -------------------------------------------*/
      ftmp = fRadiansToIndex*fArg0;
      VoxROUND2pos(ftmp, iArg0);
      iArg = iArg0 & TRIG_MASK;

      /*-------------------------------------------
        Start with the point at the center of the
          analysis window.
      -------------------------------------------*/
      fReal = *pfx1;           /* cos(0.0) = 1.0 */
      fImag = 0.0F;            /* sin(0.0) = 0.0 */

      /*-------------------------------------------
        Increment/decrement pointers
      -------------------------------------------*/
      pfx1++;
      pfx2--;

      /*-------------------------------------------
        Process most of the analysis window.
      -------------------------------------------*/
      for (j=(iLength>>1)-1; j; j--) 
      {
         fCosArg = cosTBL_32[iArg];        /* get cos(w)            */
         fSinArg = sinTBL_32[iArg];        /* get sin(w)            */
         fReal += *pfx1 * fCosArg;         /* cos(-w) = cos(w)      */
         fReal += *pfx2 * fCosArg;
         fImag -= *pfx1++ * fSinArg;       /* sin(-w) = -sin(-w)    */
         fImag += *pfx2-- * fSinArg;
         iArg += iArg0;                    /* increment phase index */
         iArg &= TRIG_MASK;                /* mask phase index      */
      }

      /*-------------------------------------------
        Add the first point in the of the analysis
          window.
      -------------------------------------------*/
      fCosArg = cosTBL_32[iArg];
      fSinArg = sinTBL_32[iArg];
      fReal += *pfx2 * fCosArg;
      fImag += *pfx2 * fSinArg;

      /*-------------------------------------------
        An odd length window has one more point
          at the end.
      -------------------------------------------*/
      if (iLength&1) 
      {
         fReal += *pfx1 * fCosArg;
         fImag -= *pfx1 * fSinArg;
      }

      /*-------------------------------------------
        Store the spectral sample.
      -------------------------------------------*/
      *pfXr++ = fReal;
      *pfXi++ = fImag;
   }


}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\decplssc.h ===
/******************************************************************************
*                        Voxware Proprietary Material                         *
*                        Copyright 1996, Voxware, Inc                         *
*                            All Rights Reserved                              *
*                                                                             *
*                       DISTRIBUTION PROHIBITED without                       *
*                      written authorization from Voxware                     *
******************************************************************************/

/******************************************************************************
* Filename:       DecPlsSC.h
*                                                                              
* Purpose:        Provide decoder plus functions as the interface for the private
*                 decoder structure.
*                                                                              
* Functions:     voxSetDecodeSC(), ... etc.
*                                                                              
* Author/Date:    Wei Wang, 3/98.
*******************************************************************************
* Modifications: 
*                                                                              
* Comments:     
* 
* Concerns:
*
* $Header:   /export/phobos/pvcs/r_and_d/archives/scaleable/decode/DecPlsSC.h_v   1.5   13 Apr 1998 16:16:56   weiwang  $
******************************************************************************/

#ifndef DECPLSSC_H
#define DECPLSSC_H


/*******************************************************************************
*
* Function:  voxSetDecodeSC()
*
* Action:   Set the compression rate for SC36 (either 3K or 6K)
*
* Input:    pMemBlkD -- decoder memory block
*           wScale -- codec rate 
*
* Output:   pMemBlkD -- updated decoder memory block
*
* Globals:   none
*
* Return:    0: succeed, 1: failed
*******************************************************************************/
unsigned short voxSetDecodeSC(void *pMemBlkD, unsigned short wScale);

/*******************************************************************************
*
* Function:  voxGetDecodeRateSC()
*
* Action:   Get the compression rate 
*
* Input:    pMemBlkD -- decoder memory block
*
* Output:   none
*
* Globals:   none
*
* Return:    the target rate for SC codec.
*******************************************************************************/
int voxGetDecodeRateSC(const void *pMemBlkD);

/*******************************************************************************
*
* Function:  voxGetDecodeInitRateSC()
*
* Action:   Get the initialized compression rate 
*
* Input:    pMemBlkD -- decoder memory block
*
* Output:   none
*
* Globals:   none
*
* Return:    the initial rate for SC codec.
*******************************************************************************/
int voxGetDecodeInitRateSC(const void *pMemBlkD);

/*******************************************************************************
*
* Function:  voxGetDecReqDataFlagSC()
*
* Action:    Get the RequestDataFLAG flag
*
* Input:     pMemBlkD -- decoder memory block
*
* Output:    none
*
* Globals:   none
*
* Return:    RequestDataFLAG
*******************************************************************************/
 
unsigned char voxGetDecReqDataFlagSC(const void *pMemBlkD);

/*******************************************************************************
*
* Function:  voxSetFrameSkippedSC()
*
* Action:   Set frame skipped flag
*
* Input:    pMemBlkD -- decoder memory block
*           iFrameSkipped -- frame skip flag
*
* Output:   none
*
* Globals:   none
*
* Return:    write flag
*******************************************************************************/
void voxSetFrameSkippedSC(void *pMemBlkD, int iFrameSkipped);

/*******************************************************************************
*
* Function:  voxSetRepeatFrameSC()
*
* Action:   Set repeat frame flag
*
* Input:    pMemBlkD -- decoder memory block
*           iRepeatFrameFlag -- repeat-frame flag
*
* Output:   none
*
* Globals:   none
*
* Return:    nont
*******************************************************************************/
void voxSetRepeatFrameSC(void *pMemBlkD, int iRepeatFrameFlag);

/*******************************************************************************
*
* Function:  voxSetWarpFactorSC()
*
* Action:   Set wWarpFactor
*
* Input:    pMemBlkD -- decoder memory block
*           wWarpFactor -- warp factor
*
* Output:   none
*
* Globals:   none
*
* Return:    none
*******************************************************************************/
void voxSetWarpFactorSC(void *pMemBlkD, float wWarpFactor);

/*******************************************************************************
*
* Function:  voxGetWarpFactorSC()
*
* Action:   Get Warp Factor
*
* Input:    pMemBlkD -- decoder memory block
*
* Output:   none
*
* Globals:   none
*
* Return:    the warp factor
*******************************************************************************/
float voxGetWarpFactorSC(const void *pMemBlkD);

/*******************************************************************************
*
* Function:  VoxGetDecPrevPvSC()
*
* Action:   Get Pv_1
*
* Input:    pMemBlkD -- decoder memory block
*
* Output:   none
*
* Globals:   none
*
* Return:    Pv_1
*******************************************************************************/
float VoxGetDecPrevPvSC(const void *pMemBlkD);

/*******************************************************************************
*
* Function:  VoxGetDecPrevPitchSC()
*
* Action:   Get Pitch_1
*
* Input:    pMemBlkD -- decoder memory block
*
* Output:   none
*
* Globals:   none
*
* Return:    Pitch_1
*******************************************************************************/
float VoxGetDecPrevPitchSC(const void *pMemBlkD);



#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\dft.h ===
/******************************************************************************
*                        Voxware Proprietary Material
*                        Copyright 1996, Voxware, Inc
*                            All Rights Reserved
*
*                       DISTRIBUTION PROHIBITED without
*                      written authorization from Voxware
******************************************************************************/
 
/******************************************************************************
* Filename:       dft.h
* Purpose:        Compute the dft at harmonic frequencies.
* Functions:      VoxDFT()
* Author/Date:    Bob Dunn 4/8/97
*
* $Header:   /export/phobos/pvcs/r_and_d/archives/scaleable/utils/dft.h_v   1.0   06 Feb 1998 10:14:10   johnp  $
*
******************************************************************************/

/******************************************************************************
*
* Function:  VoxDFT()
*
* Action:    Compute the dft at harmonic frequencies.
*
* Input:     *pfx:    windowed input signal
*            iLength: length of windowed input signal
*            fOmega:  fundamental frequency for DFT in radians
*            iNFreq:  number of spectral samples to compute
*
* Output:    pfXr:    real part of spectrum at harmonic frequencies
*            pfXi:    imaginary part of spectrum at harmonic frequencies
*
* Globals:   Sine and Cosine tables.
*
* Return:    none.
******************************************************************************/
#ifndef DFT_H
#define DFT_H

void VoxDFT( float *pfx, int iLength, float fOmega, int iNFreq, 
             float *pfXr, float *pfXi);

#endif /* DFT_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\drpframe.h ===
/******************************************************************************
 *                                                                            *
 *		                  Voxware Proprietary Material                          *
 *		                  Copyright 1996, Voxware, Inc.                         *
 *		                       All Rights Resrved                               *
 *                                                                            *
 *		                 DISTRIBUTION PROHIBITED without                        *
 *		               written authorization from Voxware                       *
 *                                                                            *
 ******************************************************************************/

/******************************************************************************
 *                                                                            *
 * FILENAME:  DrpFrame.h                                                      *
 * PURPOSE:   Routines for droping frames during speedup.                     *
 *                                                                            *
 * AUTHOR:                                                                    *
 *                                                                            *
 *****************************************************************************/

#ifndef DRPFRAME_H
#define DRPFRAME_H

short DropFrameFast(float *WarpFact, short *DropCounter, 
					short *dropLeft, short *DropRateId);
#endif /* DRPFRAME_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\encodert.c ===
/*******************************************************************************
*                        Voxware Proprietary Material                          *
*                        Copyright 1996, Voxware, Inc                          *
*                            All Rights Reserved                               *
*                                                                              *
*                       DISTRIBUTION PROHIBITED without                        *
*                      written authorization from Voxware                      *
*******************************************************************************/

/*******************************************************************************
* Filename:       EncodeRT.c
*
* Purpose:        Encode function which will analysis input speech 
*                 frame by frame and then store speech model parameters
*
* Functions:      VOXErr VoxEncode(short *pPCMBuffer, void *pMemBlkE);
*                 VOXErr VoxInitEncode(void **ppMemBlkE);
*                 VOXErr VoxFreeEncode(void *pMemBlkE);
*
* Author/Date:
*                 Modified by Rob Zopf, Rewritten by Wei Wang, 2/96
********************************************************************************
* Modifications:                                                               
*                                                                              
* Comments:                                                                    
* 
* Concerns:
*
* $Header:   /export/phobos/pvcs/r_and_d/archives/realtime/encode/EncodeRT.c_v   1.13   04 Dec 1998 16:08:48   weiwang  $
*******************************************************************************/
#include <stdio.h>

#include <stdlib.h>
#include <math.h>
#include <assert.h>

#include "VoxMem.h"
#include "model.h"
#include "vem2.h"
#include "vem2Prm.h"

#include "LPC.h"
#include "param.h"

#include "vLibSgPr.h"  /* InitKaiserWindow(), FreeKaiserWindow(), 
                          symWindowSignal(), NormSymWindowByPower() */
#include "vLibSnd.h"   /* InitSpCBM(), FreeSpCBM(), PutFrameSpCBM(),
                          GetFrameSpCBM() */
#include "vLibVec.h"   /* MagSq() */
#include "vLibTran.h"  /* VoxFftCenter(), VoxDemultiplex() */
#include "vLibFilt.h"  /* VoxInitPreProc(), VoxPreProcess(), VoxFreePreProc() */

#include "CorrPDA.h"
#include "VoicDeci.h"
#include "Refine.h"
#include "VAD2.h"
#include "EncodeRT.h"

#include "xvocver.h"

static short VoxGetWinLength(float pitch);

/*******************************************************************************
* Function:       VOXErr VoxEncode(short *pPCMBuffer, void *pMemBlkE)
*
* Action:
*
* Input:
*
* Output:
*
* Globals:        none
*
* Return:		  VOXErr : Voxware return code
********************************************************************************
* Implementation/Detailed Description:
*
* References:
********************************************************************************
* Modifications:
*                 Put correlator PDA with TIME_DOMAIN_PDA == 1
*
* Comments:
*
* Concerns/TBD:
*******************************************************************************/
unsigned short VoxEncodeRT(STACK_R short *pPCMBuffer, void *hEncMemBlk)
{
   ENC_MEM_BLK *pEncMemBlk= (ENC_MEM_BLK *)hEncMemBlk;

   PARAM *Param_mblk = (PARAM *)pEncMemBlk->Param_mblk;
   
   STACK_INIT
   float SpBuf[FRAME_SIZE3];
   STACK_INIT_END
   float *SWR = pEncMemBlk->SWR;
   float *SWI = pEncMemBlk->SWI;
   short  UV;

   STACK_ATTACH(float *, SpBuf)

   float *win;        /* window pointer */
   float pitch, Pv, pdaDelaySize;
   int i;
   STACK_START
   

  /* pre-processing the speech using HPF */
  VoxPreProcess(pPCMBuffer, SpBuf, FRAME_LEN, pEncMemBlk->PreProc_mblk);

  /* put 8k speech to the circular buffer */
  PutFrameSpCBM(pEncMemBlk->CircBuf_mblk, 0, (const int) FRAME_LEN, SpBuf);
  
  /* pitch detection */
  pitch = VoxCorrPDA(STACK_S SpBuf, FRAME_LEN, pEncMemBlk->PDA_mblk,
                     &pdaDelaySize, &(Param_mblk->VAD),&UV);

  /***** decide the length and window by the pitch of the current frame *****/
  pEncMemBlk->Nwin = VoxGetWinLength(pitch);

  /**** take an frame of speech out and apply windowing ****/
  GetFrameSpCBM(pEncMemBlk->CircBuf_mblk, (const int) pdaDelaySize, 
                (const int) pEncMemBlk->Nwin, SpBuf);

  switch(pEncMemBlk->Nwin) {
  case FRAME_SIZE1:
      win=pEncMemBlk->win1;
      break;
   case FRAME_SIZE2:
      win=pEncMemBlk->win2;
      break;
   case FRAME_SIZE3:
      win=pEncMemBlk->win3;
      break;
   }
  
  /**** window signal from high end to low end ****/
  SymWindowSignal(SpBuf, win, SpBuf, pEncMemBlk->Nwin);
  
  /***************************************************/
  /*     1. calculate LPC                            */
  /***************************************************/

  VoxCalcLPC(STACK_S SpBuf, pEncMemBlk->Nwin, Param_mblk->Alpc, &Param_mblk->Energy,
	     (float)EXPAND_COEF,pEncMemBlk->dwLpc);


   /*****************************************************/
   /*    2. calculate pitch, pv and number of harmonics */
   /*****************************************************/
  {  
   STACK_INIT
   float fSW[NFFT+2];
   STACK_INIT_END
   STACK_ATTACH(float*,fSW)
   STACK_START

   /***** calculate the spectrum *****/

   VoxFftCenter( SpBuf, pEncMemBlk->Nwin, fSW, FFT_ORDER );
   VoxDemultiplex( fSW, SWR, SWI, NFFT_2 );

   STACK_END
  }

  {
   STACK_INIT
   float power[NFFT_2];
   float BandError[MAXHARM];
   STACK_INIT_END
   STACK_ATTACH(float*,power)
   STACK_ATTACH(float*,BandError)

   STACK_START

   /**** calculate the power structrum of the signal ****/
   MagSq( SWR, SWI, NFFT_2, power);
   
   VoxPitchRefine_TIME(&pitch, SWR, SWI, power, pEncMemBlk->Nwin, BandError);  

   /* find the voicing probability */
   VoxVocDecision(pitch, pEncMemBlk->Voicing_mblk, &Pv, power, BandError, pEncMemBlk->Nwin, &(Param_mblk->VAD));
   Pv = (float) PvRefine( Pv, pEncMemBlk->Pv_1, (float) ((CorrPDA_mblk *)pEncMemBlk->PDA_mblk)->pitch_1, 
                 ((CorrPDA_mblk *)pEncMemBlk->PDA_mblk)->cost_1, 
                 ((CorrPDA_mblk *)pEncMemBlk->PDA_mblk)->biasTab);

   if(UV!=ACTIVE_SPEECH)
      Pv=0;
   pEncMemBlk->Pv_1 = Pv;

   STACK_END
  }

  /*****************************************************/
  /*    3.  pack pitch, pv                             */
  /*****************************************************/
  if (Pv == 0)
    pitch = (float)PITCH_UV;

  Param_mblk->Pitch = pitch;
  Param_mblk->Pv = Pv;

  pEncMemBlk->uQPitch = pitch;

  /*****************************************************/
  /*    4. Perform backward compatibility operations   */
  /*          (talk to Wei or John)                    */
  /*****************************************************/
  
  for (i = 0; i < LPC_ORDER; i++)
       Param_mblk->Blpc[i] = -(Param_mblk->Alpc[i+1]);

  /* service the "post encode" state */
  vemServiceState(pEncMemBlk->vemKeyPostEncode);

  STACK_END
  return 0;
} /* Encode() */


/*******************************************************************************
* Function:       VOXErr VoxInitEncode(void **ppMemBlkE, void *pVemMem))
*
* Action:         Initializes encoder structure
*
* Input:
*
* Output:
*
* Globals:        none
*
* Return:		   VOXErr : Voxware return code
********************************************************************************
* Implementation/Detailed Description:
*
* References:
********************************************************************************
* Modifications:
*               Add initialization of CorrPDA_mblk.  W.W. 11/6/96.
*
* Comments:
*
* Concerns/TBD:
*******************************************************************************/

unsigned short VoxInitEncodeRT(void **ppMemBlkE, void *pVemMem)
{

  ENC_MEM_BLK *pEncode_mblk;

  if(VOX_MEM_INIT(pEncode_mblk=*ppMemBlkE,1,sizeof(ENC_MEM_BLK))) 
      return 1;

  /****************************************************
  initialize circular buffer structure 
  ****************************************************/
  /* initialize the circular buffer manager */
  if (InitSpCBM((const int) CIRCBUF_LENGTH, &pEncode_mblk->CircBuf_mblk))
      return 1;
  
  /* initialize the pre-process structure */
  if (VoxInitPreProc(&pEncode_mblk->PreProc_mblk, PRE_PROC_COEF))
      return 1;

  /****************************************************
  initialize Voicing structure
  ****************************************************/
  if(VoxInitVoicing(&pEncode_mblk->Voicing_mblk)) 
      return 1;

  /****************************************************
   initialize correlation PDA structure
   ****************************************************/
  if(VoxInitCorrPitchEst(&pEncode_mblk->PDA_mblk)) 
      return 1;

  /****************************************************
  initialize FFT coefficients 
  ****************************************************/

  /*-------------------------------------------------------
    LOOK OUT!!! WHOA!!! NOW HOLD EVERYTHING!  This should
      not be frame to frame memory, but....these values
      are used in ResidAmp.c! That needs to be changed.
  -------------------------------------------------------*/
  if(VOX_MEM_INIT(pEncode_mblk->SWR,NFFT_2,sizeof(float))) 
     return 1;

  if(VOX_MEM_INIT(pEncode_mblk->SWI,NFFT_2,sizeof(float))) 
     return 1;

 
  /****************************************************
  initialize the kaiser window 
  initialize only for API codec. For DSP application, read from table
  ****************************************************/
  if(InitKaiserWindow(&pEncode_mblk->win1, FRAME_SIZE1, 6.0F))
     return 1;
  NormSymWindowByPower(pEncode_mblk->win1, FRAME_SIZE1);


  if(InitKaiserWindow(&pEncode_mblk->win2, FRAME_SIZE2, 6.0F))
     return 1;
  NormSymWindowByPower(pEncode_mblk->win2, FRAME_SIZE2);

  if(InitKaiserWindow(&pEncode_mblk->win3, FRAME_SIZE3, 6.0F))
     return 1;
  NormSymWindowByPower(pEncode_mblk->win3, FRAME_SIZE3);

  /****************************************************
  initialize parameter structure
  ****************************************************/
  if(VoxInitParam(&pEncode_mblk->Param_mblk, pVemMem)) 
      return 1;

  if(VOX_MEM_INIT(pEncode_mblk->dwLpc,LPC_ORDER+1,sizeof(double))) 
     return 1;

  /****************************************************
  attaching the Vem memory
  ****************************************************/
  pEncode_mblk->pVemMem=pVemMem;
  if(!(pEncode_mblk->vemKeyPostEncode=vemRegisterState(
     ((VEM_MAIN_STRUCT *)pVemMem)->pMemoryHandler, "post encode"))) 
  {
#if VEM_DEFINED == 1
     return 1;
#endif
  }

  if(!(pEncode_mblk->vemKeyPostCalcResAmps=vemRegisterState(
     ((VEM_MAIN_STRUCT *)pVemMem)->pMemoryHandler, "post calc res amps rt")))
  {
#if VEM_DEFINED == 1
     return 1;
#endif
  }

  vemRegisterConstShort(((VEM_MAIN_STRUCT *)pVemMem)->pMemoryHandler, (short)RATE8K, "rate");
  vemRegisterConstShort(((VEM_MAIN_STRUCT *)pVemMem)->pMemoryHandler, (short)MAXHARM, "max harmonics");
  vemRegisterConstShort(((VEM_MAIN_STRUCT *)pVemMem)->pMemoryHandler, (short)FRAME_LEN, "frame length");
  vemRegisterVariable(((VEM_MAIN_STRUCT *)pVemMem)->pMemoryHandler, 
     pEncode_mblk->dwLpc, VEM_FLOAT, "energy");

  
  return 0; 
}

/*******************************************************************************
* Function:       VOXErr VoxFreeEncode(void *pMemBlkE)
*
* Action:         Free's encoder structure
*
* Input:
*
* Output:
*
* Globals:        none
*
* Return:		   VOXErr : Voxware return code
********************************************************************************
* Implementation/Detailed Description:
*
* References:
********************************************************************************
* Modifications:
*                Add free CorrPDA_mblk.  W.W. 11/6/96.
*
* Comments:
*
* Concerns/TBD:
*******************************************************************************/
unsigned short VoxFreeEncodeRT(void **hMemBlkE)
{
  ENC_MEM_BLK *pMemBlkE=(ENC_MEM_BLK *)*hMemBlkE;

  if (*hMemBlkE) {

     /**** free circular structure ****/
     FreeSpCBM(&pMemBlkE->CircBuf_mblk);

     /**** free preprocess structure ****/
     VoxFreePreProc(&pMemBlkE->PreProc_mblk); 

     /**** free Voicing structure ****/
     VoxFreeVoicing(&pMemBlkE->Voicing_mblk);

     /**** free CorrPDA structure ****/
     VoxFreeCorrPitchEst(&pMemBlkE->PDA_mblk);

     /**** free Param structure ****/
     VoxFreeParam(&pMemBlkE->Param_mblk);

     /**** free the kaiser windows ****/
     FreeKaiserWindow(&pMemBlkE->win1);
     FreeKaiserWindow(&pMemBlkE->win2);
     FreeKaiserWindow(&pMemBlkE->win3);

     VOX_MEM_FREE(pMemBlkE->SWR);    
     VOX_MEM_FREE(pMemBlkE->SWI);

     VOX_MEM_FREE(pMemBlkE->dwLpc);
     
#ifdef WIN32
     nspFreeFftResources();
#endif

     VOX_MEM_FREE(*hMemBlkE);
  }
  return 0;
}

static short VoxGetWinLength(float pitch)
{
  if(pitch> PITCH4FRAME_SIZE3) {   /* 60 & 261 window */
      return FRAME_SIZE3;
   }
   else {                                  
     if (pitch > PITCH4FRAME_SIZE2) { /* 43 & 241 window */
         return FRAME_SIZE2;
      }
     else {
       return FRAME_SIZE1;
     }
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\encodert.h ===
/*******************************************************************************
*                        Voxware Proprietary Material                          *
*                        Copyright 1996, Voxware, Inc                          *
*                            All Rights Reserved                               *
*                                                                              *
*                       DISTRIBUTION PROHIBITED without                        *
*                      written authorization from Voxware                      *
*******************************************************************************/

/*******************************************************************************
* Filename:       EncodeRT.h
*
* Purpose:       Encode function which will analysis input speech
*                frame by frame and then store speech model parameters
*
*
* Author/Date:
*                 Modified by Rob Zopf, Rewritten by Wei Wang, 2/96
********************************************************************************
* $Header:   /export/phobos/pvcs/r_and_d/archives/realtime/encode/EncodeRT.h_v   1.4   04 Dec 1998 16:09:18   weiwang  $
*******************************************************************************/

#ifndef ENCODERT_H
#define ENCODERT_H

#ifndef __VEM_KEY
#define __VEM_KEY
typedef void * VEM_KEY;
#endif /* __VEM_KEY */

/** Encoder main structure **/
typedef struct
{
  void* CircBuf_mblk;                /** in-data handling structure including preprocessing **/
  void* PreProc_mblk;                /** preprocess structure            **/

  void* Voicing_mblk;                /** PDA related structure           **/
  void* PDA_mblk;                    /** Cross-Correlation PDA structure **/
  void* hPreFiltMblk;                /** PreFilter memory                **/

  void* Param_mblk;

  /*** Memories needed dynamic allocated ***/
  float *SWR;                             /** FFT real part **/
  float *SWI;                             /** FFT imaginary part **/

  /*** Kaiser windows which can be precalculated or loaded from tables ***/
  float *win1;                            /** kaiser(221, 6) **/
  float *win2;                            /** kaiser(241, 6) **/
  float *win3;                            /** kaiser(261, 6) **/

  short Nwin;                             /** Analysis Window length used for Theo Amp Scale  **/
  float *dwLpc;                           /** need to keep here for VMG! **/

  /*float winScale; No longer needed IB 97/01/22 */

  float uQPitch;                             /** unquantized Pitch **/
  float Pv_1;                             /** Pv for Rob's Magic **/

  void *pVemMem;  /* attachment to Vem memory */
  /* enocoder states that the RT supports */
  VEM_KEY vemKeyPostEncode;
  VEM_KEY vemKeyPostCalcResAmps;

} ENC_MEM_BLK;

unsigned short VoxEncodeRT(STACK_R short *pPCMBuffer, void *hEncMemBlk);

unsigned short VoxInitEncodeRT(void **ppMemBlkE, void *pVemMem);

unsigned short VoxFreeEncodeRT(void **hMemBlkE);

void* voxReturnPDAStruct(void *pMemBlkE);

#endif /* ENCODE_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\encsc.c ===
/*******************************************************************************
*                        Voxware Proprietary Material                          *
*                        Copyright 1996, Voxware, Inc                          *
*                            All Rights Reserved                               *
*                                                                              *
*                       DISTRIBUTION PROHIBITED without                        *
*                      written authorization from Voxware                      *
******************************************************************************/

/*******************************************************************************
* Filename:       EncSC.c
*                                                                              
* Purpose:        Encode function which will analysis input speech 
*                 frame by frame and then store speech model parameters.
*                 There are two 10ms analysis frames for each 20ms outer
*                 transmit frame.
*                                                                              
* Functions:      VOXErr VoxEncodeSC(short *pPCMBuffer, void *pMemBlkE);
*                 VOXErr VoxInitEncodeSC(void **ppMemBlkE);
*                 VOXErr VoxFreeEncodeSC(void *pMemBlkE);
*                                                                              
* Author/Date:    Original developed by Suat Yeldner  1995
*                 Modified by Rob Zopf, Rewritten by Wei Wang, 2/96            
*                 Modified by Bob McAulay, 11/96
*                 Modified by Xiaoqin Sun,  10/97
*                 Modified by Wei Wang,  2/19/98 -- remove ParamMblk from 
*                                                     structure
********************************************************************************
* Modifications:                                                               
*                                                                              
* Comments:                                                                    
* 
* Concerns:
*
* $Header:   /export/phobos/pvcs/r_and_d/archives/scaleable/encode/EncSC.c_v   1.14   14 Apr 1998 10:14:18   weiwang  $
******************************************************************************/
#include <stdlib.h>
#include <math.h>
#include <assert.h>
#include <string.h>

#include "VoxMem.h"
#include "vem2.h"
#include "vem2Prm.h"

#include "vLibSnd.h"
#include "vLibSgPr.h"
#include "vLibTran.h"
#include "vLibSpch.h"
#include "vLibVec.h"
#include "vLibFilt.h"

#include "codec.h"
#include "quansc36.h"
#include "paramSC.h"
#include "STFTpks.h"
#include "Seevoc.h"
#include "EnvToAs.h"
#include "Voicing.h"
#include "STFTfaze.h"
#include "Window.h"
#include "LDPDA.h"
#include "MidFrame.h"
#include "rate.h"
#include "MidPitch.h"

#include "DecVcFry.h"
#include "EstOnset.h"
#include "EncSC.h"
#include "Lineintp.h"

#include "xvocver.h"


const float Kaiwin0[]={
#include "Kaiw291.h"
};

static float CoarsePitchAndFrameEnergy( STACK_R
                                        void  *hCircBufBlk,
                                        void  *hLdPdaBlk,
                                        float *fFrameEnergy
                                      );

static void PitchAdaptiveSpectrum( STACK_R
                                   float  fPitch,
                                   void  *hOnsetBlk,
                                   void  *hCircBufBlk,
                                   float *pfSWR,
                                   float *pfSWI,
                                   int   *piLength,
                                   int   *piWinShift
                                  );

static void OuterFrameParam( STACK_R
                             void        *hCircBufBlk,
                             float       *pfSWR,
                             float       *pfSWI,
                             PARAM_SC    *pParamMblk,
                             ENC_MEM_BLK *pEncMemBlk,
                             int          iLength,
                             int          iWinShift,
                             int         *piVFflag,
                             float       *pfCorrCost
                           );

/*******************************************************************************
* Function:       VOXErr VoxEncodeSC(short *pPCMBuffer, void *pMemBlkE, 
*                                     void *hParamMblk)
*
* Action:
*
* Input:
*
* Output:
*
* Globals:        none
*
* Return:        VOXErr : Voxware return code
********************************************************************************
* Implementation/Detailed Description:
*
* References:
********************************************************************************
* Modifications:
*
* Comments:
*
* Concerns/TBD:
******************************************************************************/
unsigned short VoxEncodeSC( STACK_R 
                            short *pPCMBuffer, 
                            void  *hEncMemBlk, 
                            void  *hParamMblk
                          )
{
   ENC_MEM_BLK *pEncMemBlk   = (ENC_MEM_BLK *)hEncMemBlk;
   PARAM_SC    *pParamMblk   = (PARAM_SC *)hParamMblk;
   void        *hCircBufBlk = pEncMemBlk->CircBuf_mblk;
   SUBFRAME_PARAM_SC *pSubParam;


   int    iLength;              /* window length */
   int    vfFlag = 0;
   int    WinShift = 0;
   float  fCorrCost;
   
   pSubParam = &(pParamMblk->SubParam[PARAM_ENDFRAME]);

   /*--------------------------------------------------------------
     Test for a valid bitrate
   --------------------------------------------------------------*/
   if (!(pEncMemBlk->iSCTargetRate & pEncMemBlk->iSCRateValid))
      return 1;

   /*--------------------------------------------------------------
     Preprocess two 10ms frames of speech with a high-pass filter
       and store the result in the circular buffer.
   --------------------------------------------------------------*/
   {
      STACK_INIT
      float fSpBuf[FRAME_LENGTH_SC];
      STACK_INIT_END
 
      STACK_ATTACH(float *, fSpBuf)
 
      STACK_START

      VoxPreProcess( pPCMBuffer, fSpBuf, FRAME_LENGTH_SC, 
                     pEncMemBlk->PreProc_mblk );

      PutFrameSpCBM( hCircBufBlk, 0, FRAME_LENGTH_SC, fSpBuf );

      STACK_END
   }


   /*--------------------------------------------------------------
     Make a coarse pitch estimate and compute the frame energy
   --------------------------------------------------------------*/
   pSubParam->Pitch = CoarsePitchAndFrameEnergy( STACK_S
                                               hCircBufBlk,
                                               pEncMemBlk->LDPDA_mblk,
                                               &(pEncMemBlk->frameEnergy) );

   
   {
   STACK_INIT    /*%#  scratch memory #%*/
      float SWR[NFFT+2];
      float SWI[NFFT_2];
   STACK_INIT_END
 
      STACK_ATTACH(float *, SWR)
      STACK_ATTACH(float *, SWI)
 
      STACK_START

      /*--------------------------------------------------------------
        Compute the spectrum based on a pitch-adaptive Hamming
          window
      --------------------------------------------------------------*/
      PitchAdaptiveSpectrum( STACK_S pSubParam->Pitch,
                             pEncMemBlk->Onset_mblk, 
                             hCircBufBlk, SWR, SWI, &iLength, &WinShift );

      /*--------------------------------------------------------------
        Compute outer frame parameters (i.e. at 20 ms)
      --------------------------------------------------------------*/
      OuterFrameParam( STACK_S hCircBufBlk, SWR, SWI, pParamMblk, pEncMemBlk,
                               iLength, WinShift, &vfFlag, &fCorrCost);
      STACK_END
   }

   /*--------------------------------------------------------------
     Compute mid-frame parameters (i.e. at 10 ms)
   --------------------------------------------------------------*/
   MidFrameParam( STACK_S pEncMemBlk, hParamMblk, 
                  ENC_DELAY_SIZE+HALF_FRAME_LENGTH_SC, 
                  (short)pEncMemBlk->iSCTargetRate, fCorrCost, vfFlag );

   /*--------------------------------------------------------------
     update the states of vocal fry detector
   --------------------------------------------------------------*/
   UpdateVF_States((void *)pParamMblk, pEncMemBlk->VocalFry_mblk );

   /*--------------------------------------------------------------
     Save pitch and voicing estimates and the bit-rate
   --------------------------------------------------------------*/
   pEncMemBlk->uq_Pitch_1 = pSubParam->Pitch;
   pEncMemBlk->uq_Pv_1    = pSubParam->Pv;
   pEncMemBlk->iSCRate_1  = pEncMemBlk->iSCTargetRate;


   /*--------------------------------------------------------------
     Service the Voxware Extention Manager (VEM).
   --------------------------------------------------------------*/
   vemServiceState(pEncMemBlk->postEnc);

   return 0;

} /*VoxEncodeSC()*/


/******************************************************************************
* Function:       VOXErr VoxInitEncodeSC(void **ppMemBlkE, void *pVemMem)
*
* Action:         Initializes encoder structure
*
* Input:
*
* Output:
*
* Globals:        none
*
* Return:         VOXErr : Voxware return code
********************************************************************************
* Implementation/Detailed Description:
*
* References:
********************************************************************************
* Modifications:
*               Add initialization of PEA_mblk.  RJM 11/21/96.
*
* Comments:
*
* Concerns/TBD:
******************************************************************************/
unsigned short VoxInitEncodeSC3(void **hMemBlkE, void *pVemMem)
{

  ENC_MEM_BLK *pEncode_mblk;

   
  if(VOX_MEM_INIT(pEncode_mblk=*hMemBlkE,1,sizeof(ENC_MEM_BLK)))
     return 1;

  /****************************************************
   Ensure bit allocation is byte aligned
   ****************************************************/
  assert(!(TOTAL_BITS_SC3%8));

  /****************************************************
   Attaching the main vem mem handle
   ****************************************************/
  pEncode_mblk->pVemMem=pVemMem;


  /****************************************************
  initialize circular buffer structure
  ****************************************************/
  /* initialize the circular buffer manager */
  if(InitSpCBM(CIRCBUF_LENGTH, &pEncode_mblk->CircBuf_mblk))
      return 1;
 
 
  /****************************************************
  initialize the pre-process structure
  ****************************************************/
  if(VoxInitPreProc(&pEncode_mblk->PreProc_mblk, PREPROC_COEF))
      return 1;
   
 
  /****************************************************
  initialize PEA structure
  ****************************************************/
  pEncode_mblk->fVoicing_km1 = 0.0F;

  /****************************************************
  initialize LDPDA structure
  ****************************************************/
  VoxInitLDPDA(&pEncode_mblk->LDPDA_mblk);

  /****************************************************
    initialize vocal fry detector structure 
  ***************************************************/
  VoxInitVocalFry(&pEncode_mblk->VocalFry_mblk);

  /***************************************************
    Initialize onset detector structure 
  **************************************************/
  VoxInitEstOnset(&pEncode_mblk->Onset_mblk);

  /**** set the rate valid bit for SC_RATE_3K ****/
  pEncode_mblk->iSCRateValid = SC_RATE_3K;
  pEncode_mblk->iSCTargetRate = SC_RATE_3K;

  /***** Set the Cost for middle-frame ******/
  pEncode_mblk->lastCorrCost = 0.0F;

  /***** set the unquantized parameters of previous frame *****/
  pEncode_mblk->uq_Pv_1 = 0.0F;
  pEncode_mblk->uq_Pitch_1 = INITIAL_PITCH;

  /***** set the unquantized parameters of previous frame *****/
  pEncode_mblk->Pv_1 = 0.0F;
  pEncode_mblk->Pitch_1 = INITIAL_PITCH;

  vemRegisterVariable(((VEM_MAIN_STRUCT *)pVemMem)->pMemoryHandler,  
                      &pEncode_mblk->uq_Pv_1, VEM_FLOAT, "pv");

  vemRegisterVariable(((VEM_MAIN_STRUCT *)pVemMem)->pMemoryHandler,  
                      &pEncode_mblk->frameEnergy, VEM_FLOAT, "energy");
  
  pEncode_mblk->postEnc=vemRegisterState(((VEM_MAIN_STRUCT *)pVemMem)->pMemoryHandler, "post encode");

  return 0; 
}

unsigned short VoxInitEncodeSC6(void **hMemBlkE)
{
 
   ENC_MEM_BLK *pEncode_mblk=(ENC_MEM_BLK *)*hMemBlkE;


   /****************************************************
     Ensure bit allocation is byte aligned
   ****************************************************/
   assert( ADDITIONAL_BITS_SC6 == ADDITIONAL_BYTES_SC6*8 );

   /****************************************************
     check for a valid pointer
   ****************************************************/
   if (pEncode_mblk==NULL)
      return 1;

   /****************************************************
     make sure SC_RATE_3K was already initialized
   ****************************************************/
   if(!(pEncode_mblk->iSCRateValid & SC_RATE_3K))
      return 1;

  /**** set the rate valid bit for SC_RATE_6K ****/
  pEncode_mblk->iSCRateValid |= SC_RATE_6K;
  pEncode_mblk->iSCTargetRate = SC_RATE_6K;

  return 0;
}

/******************************************************************************
* Function:       VOXErr VoxFreeEncodeSC(void *pMemBlkE)
*
* Action:         Free's encoder structure
*
* Input:
*
* Output:
*
* Globals:        none
*
* Return:         VOXErr : Voxware return code
********************************************************************************
* Implementation/Detailed Description:
*
* References:
********************************************************************************
* Modifications:
*
* Comments:
*
* Concerns/TBD:
******************************************************************************/
unsigned short VoxFreeEncodeSC3(void **hMemBlkE)
{
  ENC_MEM_BLK *pEncode_mblk=(ENC_MEM_BLK*)*hMemBlkE;

   if (pEncode_mblk) {

     /**** free circular structure ****/
     FreeSpCBM(&pEncode_mblk->CircBuf_mblk);
 
     /**** free preprocess structure ****/
     VoxFreePreProc(&pEncode_mblk->PreProc_mblk);

     /**** free LDPDA structure *****/
     VoxFreeLDPDA(&pEncode_mblk->LDPDA_mblk);

     /**** free vocal fry structure ****/
     VoxFreeVocalFry(&pEncode_mblk->VocalFry_mblk);

     /**** free onset structure ****/
     VoxFreeEstOnset(&pEncode_mblk->Onset_mblk);
    
     VOX_MEM_FREE(pEncode_mblk);

#ifdef WIN32
     nspFreeFftResources();
#endif
  }
  return 0;
}

unsigned short VoxFreeEncodeSC6(void **hMemBlkE)
{
  ENC_MEM_BLK *pEncode_mblk=(ENC_MEM_BLK*)*hMemBlkE;

  if (pEncode_mblk) {
     /**** clear the rate valid bit for SC_RATE_6K ****/
     pEncode_mblk->iSCRateValid &= (~(SC_RATE_6K));

  }
  return 0;
}

/****************************************************************************/

/*********************************************************************
* voxSetEncode sets and returns the highest rate possible accroding to the
* bit field that was sent in     
**********************************************************************/
unsigned short voxSetEncodeRate(void *pMemBlkE, unsigned long wBitField)
{
   ENC_MEM_BLK *pEncode_mblk=(ENC_MEM_BLK*)pMemBlkE;
   unsigned short check=0;

   /* determine the highest rate in the field and set accordingly */
   if(wBitField&SC_RATE_6K) 
      if(pEncode_mblk->iSCRateValid&SC_RATE_6K) 
         return((unsigned short)(pEncode_mblk->iSCTargetRate=SC_RATE_6K));
      else
         check=1;

   if(wBitField&SC_RATE_3K||check) {
      if(pEncode_mblk->iSCRateValid&SC_RATE_3K) 
         return((unsigned short)(pEncode_mblk->iSCTargetRate=SC_RATE_3K));
      else
         return 0; /* couldn't find the rate */
   }
   return 0; /* couldn't find the bit rate */
}

int voxGetEncodeRate(const void *pMemBlkE)
{
   return(((ENC_MEM_BLK*)pMemBlkE)->iSCTargetRate);
}

int voxGetEncodeInitRate(const void *pMemBlkE)
{
   return(((ENC_MEM_BLK*)pMemBlkE)->iSCRateValid);
}

/******************************************************************************
*
* Function:  CoarsePitchAndFrameEnergy()
*
* Action:    Make a coarse estimate of the pitch and compute the power in
*              frame based on a fixed window.
*
* Input:     hCircBufBlk  - handle for the circular buffer structure
*            hLdPdaBlk    - handle for the LDPDA structure
*
* Output:    fFrameEnergy - the power in the speech for this frame
*
* Globals:   none
*
* Return:    float fPitch - the coarse pitch estimate
*******************************************************************************
*
* Implementation/Detailed Description:
*
* References:
*******************************************************************************
*
* Modifications:
*
* Comments:
*
* Concerns/TBD:
******************************************************************************/
static float CoarsePitchAndFrameEnergy( STACK_R
                                        void  *hCircBufBlk,
                                        void  *hLdPdaBlk,
                                        float *fFrameEnergy
                                      )
{
   float  fPitch;
   float *pfSpBuf;
STACK_INIT
   float pfSW[NFFT+2];
STACK_INIT_END
 
   STACK_ATTACH(float *, pfSW)
 
   STACK_START

   assert((NFFT+2) >= PDA_FRAME_SIZE0);
   pfSpBuf = pfSW; /* make sure sharing is ok */

   /*-------------------------------------------------------------------
     Get a segment of speech from the circular buffer and window it
       with a 291 point Kaiser window.
   -------------------------------------------------------------------*/
   GetFrameSpCBM( hCircBufBlk, ENC_DELAY_SIZE, PDA_FRAME_SIZE0, pfSpBuf);
   SymWindowSignal( pfSpBuf, Kaiwin0, pfSpBuf, PDA_FRAME_SIZE0);

   /*-------------------------------------------------------------------
     Compute fFrameEnergy as the power of the windowed speech.
   -------------------------------------------------------------------*/
   *fFrameEnergy  = DotProd( pfSpBuf, pfSpBuf, PDA_FRAME_SIZE0);
   *fFrameEnergy *= INV_PEA_FRAME_SIZE0;

   /*------------------------------------------------------------
      Take the FFT of fSpBuf[] -- (in-place operation).
      The output is interleaved.
     ------------------------------------------------------------*/
   VoxFftCenter( pfSpBuf, PDA_FRAME_SIZE0, pfSW, FFT_ORDER);

   /*------------------------------------------------------------
      Coarse pitch estimation.
     ------------------------------------------------------------*/
    fPitch = VoxLDPDA(STACK_S pfSW, hLdPdaBlk);

   STACK_END

   return fPitch;

} /* CoarsePitchAndFrameEnergy() */

/******************************************************************************
*
* Function:  PitchAdaptiveSpectrum()
*
* Action:    Compute the spectrum of a the speech using a pitch-adaptive
*              Hamming window.  Shift the window in time (if necessary) to
*              account for onsets within the window.
*
* Input:     
*
* Output:    
*
* Globals:   none
*
* Return:    none
*******************************************************************************
*
* Implementation/Detailed Description:
*
* References:
*******************************************************************************
*
* Modifications:
*
* Comments:
*
* Concerns/TBD:
******************************************************************************/

static void PitchAdaptiveSpectrum( STACK_R
                                   float  fPitch, 
                                   void  *hOnsetBlk,
                                   void  *hCircBufBlk,
                                   float *pfSWR, 
                                   float *pfSWI,
                                   int   *piLength, 
                                   int   *piWinShift 
                                  )
{
 
   int    iLength;

STACK_INIT
   float fSpBuf[PDA_FRAME_SIZE1];
STACK_INIT_END
 
   STACK_ATTACH(float *, fSpBuf)
 
   STACK_START

   /*-------------------------------------------------------------------
     Set pitch-adaptive window length.
   -------------------------------------------------------------------*/
   iLength = VoxAdaptiveWindow( fPitch );
 
   /*-------------------------------------------------------------------
     Compute an adjustment of the window location to account for
       onsets within the window.
   -------------------------------------------------------------------*/
   *piWinShift = EstOnset( hOnsetBlk, hCircBufBlk, ENC_DELAY_SIZE, iLength, 
                           fSpBuf);
 
   /*-------------------------------------------------------------------
     Get the speech
   -------------------------------------------------------------------*/
   assert((iLength>>1) <= (ENC_DELAY_SIZE+*piWinShift));
   GetFrameSpCBM( hCircBufBlk, ENC_DELAY_SIZE+*piWinShift, iLength, fSpBuf );
 
   /*-------------------------------------------------------------------
     Multiply by 2.0 because of complex analysis
   -------------------------------------------------------------------*/
   ScaleVector( fSpBuf, iLength, 2.0F, fSpBuf );
 
   /*-------------------------------------------------------------------
     Apply a unit area Hamming window (NOTE: the area of the window in
       HammingWindowNormSC() is 8% too big, but it is not changed for
       backward compatability with coding tables)
   -------------------------------------------------------------------*/
   HammingWindowNormSC(fSpBuf, iLength);
 
   /*-------------------------------------------------------------------
     Take the FFT of fSpBuf[].  The output is interleaved
       so demultiplex it.  (the real part is demultiplexed
       "in place")
   -------------------------------------------------------------------*/
   VoxFftCenter( fSpBuf, iLength, pfSWR, FFT_ORDER);
   VoxDemultiplex( pfSWR, pfSWR, pfSWI, NFFT_2);

   *piLength = iLength;

   STACK_END

} /* PitchAdaptiveSpectrum() */

/******************************************************************************
*
* Function:  OuterFrameParam()
*
* Action:    Compute the outer frame parameters:  pitch, voicing, gain, and
*              spectral envelope (arcsin of reflcetion coefficients).
*
* Input:
*
* Output:
*
* Globals:   none
*
* Return:    none
*******************************************************************************
*
* Implementation/Detailed Description:
*
* References:
*******************************************************************************
*
* Modifications:
*
* Comments:
*
* Concerns/TBD:
******************************************************************************/

static void OuterFrameParam( STACK_R 
                             void        *hCircBufBlk, 
                             float       *pfSWR, 
                             float       *pfSWI, 
                             PARAM_SC    *pParamMblk,
                             ENC_MEM_BLK *pEncMemBlk,
                             int          iLength,
                             int          iWinShift,
                             int         *piVFflag,
                             float       *pfCorrCost 
                           )

{
   int   iPeakCount;
   float fPitchDFT;

   SUBFRAME_PARAM_SC *pSubParam;
   STACK_INIT
     float PeakPwr[MAXHARM];
     float PeakFrq[MAXHARM];
     float MagSq[NFFT_2];
     float fSpBuf[PDA_FRAME_SIZE0];
   STACK_INIT_END
    
   STACK_ATTACH(float *, PeakPwr)
   STACK_ATTACH(float *, PeakFrq)
   STACK_ATTACH(float *, MagSq)
   STACK_ATTACH(float *, fSpBuf)

   float *fAS = (float *)PeakPwr;        /***** fAS[LPC_ORDER_SC6+1]    *****/
   float *fKS = (float *)PeakFrq;        /***** fKS[LPC_ORDER_SC6]      *****/
   float *fLogSeeEnv = (float *)MagSq;   /***** share MagSq with the    *****/
                                         /***** memory fLogSeeEnv       *****/
   
   STACK_START

   assert(PDA_FRAME_SIZE0>=(2*MAXHARM)); /**** make sure the memory     *****/
                                         /**** sharing is ok            *****/
   assert(MAXHARM>=LPC_ORDER);           /**** make sure the memory     *****/
                                         /**** sharing is ok            *****/

   pSubParam = &(pParamMblk->SubParam[PARAM_ENDFRAME]);
      
   memset(PeakPwr, 0, MAXHARM*sizeof(float));
   memset(PeakFrq, 0, MAXHARM*sizeof(float));
    

   /*-------------------------------------------------------------------
     Compute the magnitude-squared STFT envelope and pick peaks
   -------------------------------------------------------------------*/
   VoxSTFTpeaks(STACK_S pfSWR, pfSWI, MagSq, PeakPwr, PeakFrq, &iPeakCount);

   /*-------------------------------------------------------------------
     Compute the flattop envelope of the squared STFT seevoc peaks
   -------------------------------------------------------------------*/
   fPitchDFT = (float)NFFT/pSubParam->Pitch;
   VoxSeevocFlattop(STACK_S MagSq, PeakPwr, PeakFrq, iPeakCount,fLogSeeEnv, 
                    fPitchDFT);
 
   /*-------------------------------------------------------------------
     Refine the pitch and compute the voicing probability
   -------------------------------------------------------------------*/
   VoxSTCVoicing(STACK_S &(pEncMemBlk->fVoicing_km1), fLogSeeEnv,
                 &(pSubParam->Pitch), 
                 &(pSubParam->Pv), 
                 PeakPwr, PeakFrq, iPeakCount);

   /*-------------------------------------------------------------------
     Interpolate the spectrum, fit a frequency-domain all-pole model,
       and compute the arcsin reflection coefficients.
   -------------------------------------------------------------------*/
   linearinterp (fPitchDFT, fLogSeeEnv, NFFT_2);

   LogEnvelopeToAs(STACK_S fLogSeeEnv, LPC_ORDER, &(pParamMblk->fLog2Gain),
                   fAS, fKS);

   K2ASK( LPC_ORDER,fKS, pParamMblk->pfASK );

   /*-------------------------------------------------------------------
     Compute a pitch correlation coefficient
   -------------------------------------------------------------------*/
   GetFrameSpCBM(hCircBufBlk, ENC_DELAY_SIZE+iWinShift, iLength, fSpBuf);

   ScaleVector( fSpBuf, iLength, 2.0F, fSpBuf );

   HammingWindowNormSC( fSpBuf, iLength);

   TDPitchRefine(fSpBuf, (short)iLength, pSubParam->Pitch,
                 pfCorrCost, 0.0F);
   
   /*-------------------------------------------------------------------
     Modify the voicing probability if it changes too sharply.
   -------------------------------------------------------------------*/
   pSubParam->Pv = ModifyPv(*pfCorrCost, pSubParam->Pv,
                            pEncMemBlk->uq_Pv_1,
                            pSubParam->Pitch,
                            pEncMemBlk->uq_Pitch_1);

   /*-------------------------------------------------------------------
     Detect the presence of vocal fry.  When it is present, cut the
       pitch period in half.
   -------------------------------------------------------------------*/
   *piVFflag = Detect_VocalFry( STACK_S (void *)pParamMblk,
                                pEncMemBlk->VocalFry_mblk, fAS, LPC_ORDER);

   if (*piVFflag == 1)
     pSubParam->Pitch *= 0.5F;

   STACK_END

   /*-------------------------------------------------------------------
     Compute the baseband measured phases for SC6.
   -------------------------------------------------------------------*/
   if (pEncMemBlk->iSCTargetRate==SC_RATE_6K)
   {
      /*** sample the 20ms STFT phase at the 20ms harmonics ***/
      VoxSTFTPhase(pfSWR, pfSWI, (int)SC6_PHASES,
                   pSubParam->pfVEVphase,
                   (float)NFFT/(pSubParam->Pitch),
                   (short)iWinShift);
   }

} /* OuterFrameParam() */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\encsc.h ===
/******************************************************************************
*                        Voxware Proprietary Material                          *
*                        Copyright 1996, Voxware, Inc                          *
*                            All Rights Reserved                               *
*                                                                              *
*                       DISTRIBUTION PROHIBITED without                        *
*                      written authorization from Voxware                      *
******************************************************************************/

/******************************************************************************
* Filename:       EncSTC.h
*                                                                              
* Purpose:       Encode function which will analysis input speech 
*                frame by frame and then store speech model parameters 
*                                                                      
*                                                                              
* Author/Date:    Original developped by Suat Yeldner  1995
*                 Modified by Rob Zopf, Rewritten by Wei Wang, 2/96
********************************************************************************
* $Header:   /export/phobos/pvcs/r_and_d/archives/scaleable/encode/EncSC.h_v   1.2   13 Apr 1998 16:17:14   weiwang  $                                                                     
******************************************************************************/

#ifndef ENCSC_H
#define ENCSC_H

#ifndef __VEM_KEY
#define __VEM_KEY
typedef void * VEM_KEY;
#endif /*  __VEM_KEY */

/** Encoder main structure **/
typedef struct
{
  void* CircBuf_mblk;       /** in-data handling structure                  **/
  void* PreProc_mblk;       /** data preprocessing structure                **/
  float fVoicing_km1;       /** RJM's PEA related structure                 **/
  void* pParamMblk;         /** current frame parameters                    **/
  /*  void* pParamMblk_1; */      /** previoud frame parameters                   **/

  void* LDPDA_mblk;         /** structure for LDPDA **/
  void* VocalFry_mblk;      /** structure for vocal-fry detector **/

  void* Onset_mblk;         /** structure for onset detector **/

  float lastCorrCost;       /** correlation coefficients of last frame for middle **/

  int   iSCRateValid;       /** valid bit rates to use                      **/
  int   iSCRate_1;          /** bit rate for previous frame                 **/
  int   iSCTargetRate;      /** user modified bit rate **/

  /*** the non-inter-frame memory for VEM access ***/
  float frameEnergy;

  /**** unquantized parameters ****/
  float uq_Pv_1;
  float uq_Pitch_1;

  /**** quantized parameters ****/
  float Pv_1;
  float Pitch_1;

  void *pVemMem;               /*** IB 97/08/06 main vem mem handle ***/

  VEM_KEY postEnc;

} ENC_MEM_BLK;


#define FIXED_BETA 10.0F  /** controls sidelobs of Kaiser fixed window...was 6.0 **/

#define ADAPTIVE_BETA 6.0F  /** controls sidelobs of Kaiser adaptive windows...was 5.0 **/


unsigned short VoxEncodeSC(STACK_R short *pPCMBuffer, void *hEncMemBlk, 
                           void *pParamMblk);

unsigned short VoxInitEncodeSC3(void **hMemBlkE, void *pVemMem);

unsigned short VoxFreeEncodeSC3(void **hMemBlkE);

unsigned short VoxInitEncodeSC6(void **hMemBlkE);

unsigned short VoxFreeEncodeSC6(void **hMemBlkE);

unsigned short voxSetEncodeRate(void *pMemBlkE, unsigned long wScale);
int voxGetEncodeRate(const void *pMemBlkE);
int voxGetEncodeInitRate(const void *pMemBlkE);

#endif /* ENCSC_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\enhance.c ===
/*******************************************************************************
*                        Voxware Proprietary Material                          *
*                        Copyright 1996, Voxware, Inc                          *
*                            All Rights Reserved                               *
*                                                                              *
*                       DISTRIBUTION PROHIBITED without                        *
*                      written authorization from Voxware                      *
*******************************************************************************/

/*******************************************************************************
* Filename:     enhance.c
*                                                                              
* Purpose:      Frequency-domain based perceptual weighting of the 
*		          harmonic amplitudes based upon the spectrum of the LPC
*		          coefficients.
*                                                                              
* Functions:    VOXErr VoxEnhance(float *lpc, float Pv, float PitchLag, 
*                                 int nHarm, float *HarmAmp, 
*                                 ENHANCE *EnhancePTR);
*               VOXErr VoxInitEnhance(ENHANCE *EnhancePTR);
*               VOXErr VoxFreeEnhance(ENHANCE *EnhancePTR);
*                                                                              
* Author/Date:  Rob Zopf (originally from Suat)                                                              
********************************************************************************
* Modifications:Ilan Berci/ 10/96 Removed global dependencies
*                                 Modularized code segments (Encapsulation)
*                                 Removed scope changes
*                                 Changed error code procedure
*                                 Removed useless code segments
*                                 General optimization
*
*               XF    1/15/97     Add comments and explanations for optimization
*                                                                              
* Comments:                                                                    
* 
* Concerns:
*
* $Header:   /export/phobos/pvcs/r_and_d/archives/realtime/decode/enhance.c_v   1.6   20 Apr 1998 14:41:34   weiwang  $
*******************************************************************************/

#include <stdlib.h>
#include <string.h>
#include <math.h> 
#include <assert.h>

#include "vLibTran.h" /* VoxRealFft() */

#include "model.h"
#include "VoxMem.h"

#ifdef _WIN64
#undef WIN32
#endif

#ifdef WIN32
static float myPower(float x, float y);
#endif

#include "enhance.h"

#include "xvocver.h"

/*******************************************************************************
* Function:   VOXErr VoxEnhance(float *lpc, float Pv, float PitchLag, int nHarm,
*                               float *HarmAmp, ENHANCE *EnhancePTR)
*
* Action:     Perceptual weighting filter
*
* Input:      lpc		- the lpc coefficients
*		        Pv		- voicing probability
*		        PitchLag	- time-domain pitch lag
*		        nHarm		- number of harmonics to be weighted
*		        HarmAmp	- pointer to the harmonic amplitudes
*		        EnhancePTR	- pointer to the Enhance structure
*
*
* Output:     HarmAmp	- weighted harmonic amplitudes
*
* Globals:    none
*
* Return:     VOVErr : Voxware return code
********************************************************************************
* Implementation/Detailed Description:
*
* References:
********************************************************************************
* Modifications:
*
* Comments:
*
* Concerns/TBD:
*******************************************************************************/

#define SMALL_NUMBER                      0.000001F

#if (USE_POWER_ESTIMATE==1)
const float Poly125[] = 
{
#include "pow125.h"
};

const float Poly150[] =
{
#include "pow150.h"
};
#endif


unsigned short VoxEnhance(STACK_R float *lpc, float Pv, float PitchLag, int nHarm, float *HarmAmp)
{
   STACK_INIT
   float HWR[ENHANCE_FFT+2];
   float amp[MAXHARM_2];
   short freq[MAXHARM_2];
   STACK_INIT_END

   STACK_ATTACH(float*,HWR)
   STACK_ATTACH(float*,amp)
   STACK_ATTACH(short*,freq)
   float *TT = HWR;
   float slope, lf;
   float TTt;
   float scale;

   float XK;
   register int i = 0,k;
   int PeakPos = 1;
	long Fi, Fo;
	int FiInt;

#if USE_POWER_ESTIMATE==0
   float POWFactor; 
#endif

   STACK_START
   /********************************************************
    Check if LPCs are zero since this leads to trouble later
    ********************************************************/
   while ((i<LPC_ORDER) && (lpc[i+1]!=0.0F))
   {
      i++;
   }/*i==LPC_ORDER is check passes, no LPC is zero*/
   
   if ((i==LPC_ORDER) && (nHarm!=0))
   {

   /********************************************************
    			Calculate LPC Filter Response
    ********************************************************/

      memcpy( HWR, lpc, (LPC_ORDER+1)*sizeof(float) );
      memset( HWR+LPC_ORDER+1, 0, (ENHANCE_FFT-LPC_ORDER-1)*sizeof(float) );

      VoxRealFft( HWR, ENHANCE_FFT_REAL_ORDER );

      /** calculate the power spectrum of the LPCs **/
      for (i=0; i<ENHANCE_FFT2; i++)
         TT[i] = (HWR[2*i]*HWR[2*i] + HWR[2*i+1]*HWR[2*i+1] + SMALL_NUMBER);
         /* add small number to prevent divide by 0 */

   /********************************************************
    			Search For Formant Peaks
    ********************************************************/

   /*********************************************************
   *  Locate the peaks of 1/TT(or valleys of TT) and        *
   *        find  1/sqrt(TT) at those values                *
   *********************************************************/


      for (i=1; i < ENHANCE_FFT2-1; i++)
      {
     	  if ((TT[i]<TT[i-1]) && (TT[i]<TT[i+1]))
    	  { 
              amp[PeakPos] = (float)sqrt((double)(1.0F/TT[i]));
              freq[PeakPos++] = (short)i; /* Typically never exceeds 6 */
              i++;        /* can't hit another peak right away */
          }
      }
      
      amp[0] = (float)sqrt((double)(1.0F/TT[0])); 
      freq[0] = 0;

      amp[PeakPos] = (float)sqrt((double)(1.0F/TT[ENHANCE_FFT2-1]));
      freq[PeakPos++] = ENHANCE_FFT2-1;

    /********************************************************
     multiply by -0.5 instead of taking square root
     and then division, used the following two identities 
     to eliminate sqrt and div operation
     (sqrt(y))^k = y^(k/2)
     (1/y)^x = y^(-x)

     since interpolations are only needed at the harmonics, 
     there is no need to calculate the whole XK[] array, the
     trick here is : just calculate XK at the harmonics
    ********************************************************/
#if USE_POWER_ESTIMATE
      pwrTbl = (Pv<=0.1F)?Poly125:Poly150;
#else
#if 0 
      POWFactor = (Pv<=0.25F)?(SUPPRESSION_FACTOR2*-0.5F):(float)(SUPPRESSION_FACTOR*-0.5F);
#else
/* Pitch adaptive Post filter AGUILAR 2/26/97 */
if(Pv<=0.25){
	POWFactor=SF_0*(-0.5F);
  }
  else
 {
	if(PitchLag<=SF_P1){
		POWFactor=SF_1*(-0.5F);
	}
	else
	{
		if(PitchLag>SF_P1 && PitchLag <=SF_P2 ){
			POWFactor=SF_2*(-0.5F);
		}
		else
		{
			if(PitchLag>SF_P2)
				POWFactor=SF_3*(-0.5F);
		}
	}

 }
#endif
#endif

    /************************************************
      Fi = Fo = (float)(ENHANCE_FFT)/PitchLag;
     ************************************************/
      Fi = (long)((((long)1)<<(F_QFACTOR))*(((float)ENHANCE_FFT)/PitchLag));
      Fo = Fi;

      for (i=0,k=0; i<PeakPos-1; i++)
      {
         slope = (amp[i+1]-amp[i])/(float)(freq[i+1]-freq[i]); 
       /***********************************************
         FiInt = (int)Fi;
        ***********************************************/
			FiInt = (int)(Fi>>F_QFACTOR);

         while ((k<nHarm)&&(FiInt<freq[i+1]))
         {
            /*calculation the interpolation*/
#if (INTERPOLATE_BETWEEN_FFT_BINS==1)
            XK = amp[i] + slope*(float)((Fi*F_TO_FLOAT)-freq[i]);
#else
            XK = amp[i] + slope*(float)(((Fi+( ((long)1) <<(F_QFACTOR-1) ))>>F_QFACTOR)-freq[i]);
#endif

            /* calculate the weighting factor */
            /********************************************************************************
             Since the FFT size may be reduced, we can increase precision by interpolating
             between FFT bins to the frequency of the k'th harmonic instead of just
             selecting the nearest bin.  Ideally, we would like to do this interpolation
             on the magnitude spectrum of the inverse lpc spectrum, but to reduce complexity,
             we interpolate on the PSD of the lpc's, and leave the sqrt and the divide to 
             the power function which will handle it all together.  Interpolating the PSD
             of the lpc's will perform no worse than just selecting the nearest bin, since
             the interpolation is still monotonic, it's just not linear in the 1/MAG domain.

             Note that (Fi&(F_FRACTION_MASK))*F_TO_FLOAT = the fractional part of the FFT
                                                           frequency bin.
             ********************************************************************************/
#if (INTERPOLATE_BETWEEN_FFT_BINS==1)
            TTt = TT[FiInt] + (TT[FiInt+1]-TT[FiInt])*((Fi&(F_FRACTION_MASK))*F_TO_FLOAT);

           /*************************************************************************************
            This commented code is the optimal way to do the interpolation.
            -------------------------------------------------------------------------------------
            
            TTt  = 1.0/( (1.0/sqrt(TT[FiInt])) +  ((1.0/sqrt(TT[FiInt+1]))-(1.0/sqrt(TT[FiInt])))*
                   ((Fi&(F_FRACTION_MASK))*F_TO_FLOAT));
            TTt *= TTt;
            -------------------------------------------------------------------------------------
            *************************************************************************************/
#else
           /**************************************************************************************
            Just select the closest FFT bin 
            **************************************************************************************/
            TTt = TT[(Fi+( ((long)1) <<(F_QFACTOR-1) ))>>F_QFACTOR];
#endif
            scale = XK*XK*TTt;
            if (scale > 1.0)
            {
#if (USE_POWER_ESTIMATE==1)
               lf = powerpoly(scale, pwrTbl);  /* this function could be inlined */
#else
#ifndef WIN32
               lf = (float)pow((double)(scale), (double)POWFactor);
#else  /*WIN32 */
               lf = myPower(scale, POWFactor);
#endif /*WIN32 */
#endif
               if (lf < 0.3F) 
                  lf = 0.3F;

               /* weight the harmonic amplitudes */
               HarmAmp[k] *= lf;
            }
            Fi+=Fo;
            FiInt = (int)(Fi>>F_QFACTOR);
            k++;
         }          
      }
   } /* if fail */

   STACK_END
   return 0;
}

#ifdef WIN32

/** assmbly power **/
static float myPower(float x, float y)     /* result = x^^y*/   													 
{
	int IntPow;	
	float result;
   _asm												 		
   {											
      fld1					/*load 1*/				 
      fld		y			/*load y*/				 
      fld		x		    /*load x*/               
      fyl2x                /* y*log2(x)*/           
      fist     IntPow      /*save the integer part*/
      fisub    IntPow      /*fraction part left   */
      f2xm1                /* 2^^st(0)-1*/          
      faddp    st(1), st(0) /*2^^st(0), add 1*/     
      fstp     result                               
   }												 	
   if(IntPow>=0)   result *=(1<<IntPow);				 
   else   	    result /=(1<<(-IntPow));				 	
   return result;
}

#endif

#ifdef _WIN64
#define WIN32
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\dotprod.c ===
/*******************************************************************************
*                        Voxware Proprietary Material                          *
*                        Copyright 1996, Voxware, Inc                          *
*                            All Rights Reserved                               *
*                                                                              *
*                       DISTRIBUTION PROHIBITED without                        *
*                      written authorization from Voxware                      *
*******************************************************************************/

/*******************************************************************************
* Filename:       DotProd.c
*
* Purpose:        Calculate the inner product of two vectors
*
* Functions:      float VoxDotProd(const float*, const float *, const int)
*
* Author/Date:    Xiangdong Fu   12/4/96
********************************************************************************
* $Header:   /export/phobos/pvcs/pvcsproj/voxlib.prj/dotprod.c_v   1.12   25 Mar 1998 14:04:04   weiwang  $
*******************************************************************************/

/******************************************************************************
*
* Function:  DotProd()
*
* Action:    Calculate the inner product of two vector
*
* Input:     const float *pfVecA  -> 1st input vector
*            const float *pfVecA  -> 2nd input vector
*            int iLength          -> the length of input vectors
*
* Globals:   none
*
* Return:    float fDotProduct    -> the inner product
********************************************************************************
*
* Comments:   Two versions are available for this function. 
*             1. General C level Version
*             2. Optimized Pentium specific version
*             Turn on the WIN32 switch in "codec.h" to use the P5 version.
* Concerns:
*
********************************************************************************
* Modifications:                                                               
*******************************************************************************/
#include <stdlib.h>
#include <assert.h>

#include "vLibVec.h"

#include "xvocver.h"

#ifdef _WIN64
#undef WIN32
#endif


#ifndef WIN32
/*------------------------------------------------------------------------
  This is the general version of DotProd()
------------------------------------------------------------------------*/
float DotProd(const float *pfVecA, const float *pfVecB, int iLength)
{
   float fDotProduct = 0.0F;

   assert( iLength >= 0 );
   assert( pfVecA != NULL);
   assert( pfVecB != NULL);

   while ((iLength--)>0)
      fDotProduct += (*pfVecA++) * (*pfVecB++);

   return (fDotProduct);
}

#else /* end of general version of dotProd() */

/*------------------------------------------------------------------------
  This is the Pentium specific version of dotProd() which is 
    written in assembly code.
------------------------------------------------------------------------*/
#pragma warning(disable:4035)
float DotProd(const float* pfVecA, const float* pfVecB,  int iLength)
{
   _asm{
     
      mov ebx, pfVecA;
      mov eax, iLength;

      mov edx, pfVecB;
      cmp eax, 6; 

      fldz;
      fld st(0);

      jnge loop12;

loop1:
      faddp st(1), st(0);         

      fld DWORD PTR[ebx];

      fmul DWORD PTR[edx];

      fld DWORD PTR[ebx+4];

      fmul DWORD PTR[edx+4];

      fld DWORD PTR[ebx+8];

      fmul DWORD PTR[edx+8];

      fld DWORD PTR[ebx+12];

      fmul DWORD PTR[edx+12];

      fld DWORD PTR[ebx+16];

      fmul DWORD PTR[edx+16];

      fld DWORD PTR[ebx+20];

      fmul DWORD PTR[edx+20];
      fxch st(5);

      faddp st(3),st(0);

      faddp st(3),st(0);

      faddp st(3),st(0);

      faddp st(3),st(0);

      sub eax, 6;
      add edx ,24;

      faddp st(1),st(0);

      add ebx, 24;
      cmp eax, 6;
      
      jge loop1;
loop12:
      test eax, eax;

      jz  exitdot;
      

loop2:         
      faddp st(1),st(0);

      fld DWORD PTR[ebx];
      fmul DWORD PTR[edx];

      add ebx, 4;
      add edx, 4;

      dec eax;
      jnz loop2;
exitdot:
      faddp st(1), st(0);


   }
}
#endif /* WIN32 */

#ifdef _WIN64
#define WIN32
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\envtoas.c ===
/******************************************************************************
*                        Voxware Proprietary Material
*                        Copyright 1996, Voxware, Inc
*                            All Rights Reserved
*
*                       DISTRIBUTION PROHIBITED without
*                      written authorization from Voxware
******************************************************************************/
 
/******************************************************************************
*
* Filename:    EnvToAs.c
*
* Purpose:     Compute predictor coefficients and gain from the log (base 2)
*                of the spine fit to the SeeVoc power peaks.
*
* Functions:
*
* Author/Date: Bob Dunn 12/28/96
*
*******************************************************************************
*
* Modifications:  Removed call to rfft2() and rewritted for readability.
*
* Comments:
*
* Concerns:
*
* $Header:   /export/phobos/pvcs/r_and_d/archives/scaleable/encode/EnvToAs.c_v   1.2   11 Apr 1998 15:19:16   bobd  $
******************************************************************************/
#include <stdlib.h>
#include <assert.h>
#include <math.h>
 
#include "vLibMath.h"
#include "vLibVec.h"
#include "vLibTran.h"
#include "vLibSpch.h"

#include "codec.h"
#include "VoxMem.h"
#include "warp.h"

#include "EnvToAs.h"

#include "xvocver.h"

/*-----------------------------------------------------------------
  Constants for downsampling the spectrum to reduce the size of
   the FFT used to compute the correlation coefficients.
-----------------------------------------------------------------*/
#define DWNSMP      2
#define DFFT       (NFFT>>DWNSMP)
#define DFFT_ORDER (FFT_ORDER-DWNSMP)

/*-----------------------------------------------------------------
  White noise scale factor for autocorrelation coefficients.
-----------------------------------------------------------------*/
#define WHITE_NOISE_SCALE 0.999999F

/******************************************************************************
*
* Function:  LogEnvelopeToAs()
*
* Action:    Compute predictor coefficients and gain from the log (base 2)
*              of the spine fit to the SeeVoc power peaks.
*
* Input:     float *pfLogSeeEnv --> spine fit to the SeeVoc power peaks
*            int iOrderAllpole  --> allpole model order
*
* Output:    float *pfLogSeeEnv --> perceptually warped spine fit to the 
*                                     SeeVoc power peaks
*            float *pfGain      --> gain
*            float *pfAS        --> predictor coefficients
*            float *pfKS        --> reflection coefficients
*
* Globals:   none
*
* Return:    void
*******************************************************************************
*
* Implementation/Detailed Description:
*
*            pfLogSeeEnv[] ranges from 0 to (NFFT_2-1)
*            pfAS[]        ranges from 0 to (iOrderAllpole+1) (pfAS[0] = 1.0F)
*
* References:
*******************************************************************************
*
* Modifications:
*
* Comments:
*
* Concerns/TBD:
******************************************************************************/

void LogEnvelopeToAs( STACK_R  
                      float *pfLogSeeEnv, 
                      int    iOrderAllpole, 
                      float *pfGain, 
                      float *pfAS, 
                      float *pfKS
                     ) 
{
   int   i, j;
   int   iStride;
   float fSigma;
   STACK_INIT
   float fRs[DFFT+2];
   STACK_INIT_END
   STACK_ATTACH(float *,fRs) 

   STACK_START

   /*-----------------------------------------------------------------
      Warp spectrum for better all-pole fit to low frequencies.
   -----------------------------------------------------------------*/
   VoxWarpSC36( pfLogSeeEnv, pfLogSeeEnv );

   /*-----------------------------------------------------------------
      Down sample the log spline power envelope and place it in the
        real part of the FFT buffer. Clear imaginary part of FFT buffer.
   -----------------------------------------------------------------*/
   iStride = 1 << DWNSMP;
   for (i=0, j=0; i<NFFT_2; i+=iStride, j+=2)
   {
       fRs[j] = fInvLog2(pfLogSeeEnv[i]);
       fRs[j+1] = 0.0F;
   }
   fRs[DFFT] = fInvLog2(pfLogSeeEnv[NFFT_2-1]); /* approximate value at PI */
   fRs[DFFT+1] = 0.0F;

   /*-----------------------------------------------------------------
      Compute autocorrelation function with inverse FFT.
   -----------------------------------------------------------------*/
   VoxRealInverseFft( fRs, DFFT_ORDER, IFFT_SCALE_FLAG);

   /*-----------------------------------------------------------------
     Apply the white noise scale factor to all but the first
      autocorrelation coefficient.
   -----------------------------------------------------------------*/
   ScaleVector( &fRs[1], iOrderAllpole, WHITE_NOISE_SCALE, &fRs[1] );

   /*-----------------------------------------------------------------
      Compute the predictor coefficients and the reflection 
       coefficients.
   -----------------------------------------------------------------*/
   VoxDurbin( fRs, iOrderAllpole, pfAS, pfKS, &fSigma);
   
   /*-----------------------------------------------------------------
      Use the prediction gain calculated within Durbin's recursion.
   -----------------------------------------------------------------*/
   *pfGain = 0.5F*fLog2(fSigma);

   STACK_END

} /* LogEnvelopeToAs() */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\exphase.h ===
/*******************************************************************************
*                        Voxware Proprietary Material
*                        Copyright 1996, Voxware, Inc
*                            All Rights Reserved
*
*                       DISTRIBUTION PROHIBITED without
*                      written authorization from Voxware
*******************************************************************************/

/*******************************************************************************
*
* Filename:     ExPhase.c
*
* Purpose:      Create voiced and measured phase components of the 
*                 excitation phase.
*
* Functions:    ExcitationPhase()
*
* Author/Date:  Bob McAulay, Spring 1997
*
********************************************************************************
*
* Modifications:  Code cleaning and such. Bob Dunn 12/97.
*
* Comments:
*
* Concerns:
*
* $Header:   /export/phobos/pvcs/r_and_d/archives/scaleable/decode/ExPhase.h_v   1.1   16 Mar 1998 10:33:36   weiwang  $
*
*******************************************************************************/

/*******************************************************************************
*
* Function:  ExcitationPhase()
*
* Action:    Create voiced and measured phase components of the
*                 excitation phase.
*
* Input:     float  fOnsetPhase -> the onset phase
*            float  fBeta       -> the beta factor
*            float *pfVEVPhase  -> measured phase residuals
*            float *pfMinPhase  -> minimum-phase phases
*            int    iNpeaks     -> total number of harmonics
*            int    iBasePeaks  -> number of measured phase residuals
*
* Output:    float *pfMinPhase  -> output phases with voiced and measured
*                                    phase components
*
* Globals:   none
*
* Return:    void
********************************************************************************
*
* Modifications:
*
* Comments:
*
* Concerns/TBD:
*******************************************************************************/
#ifndef EXPHASE_H
#define EXPHASE_H

void ExcitationPhase( float  fOnsetPhase,
                      float  fBeta,
                      const float *pfVEVPhase,
                      float *pfMinPhase,
                      int    iNpeaks,
                      int    iBasePeaks
                    );

#endif /* EXPHASE_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\enhance.h ===
/*******************************************************************************
*                        Voxware Proprietary Material                          *
*                        Copyright 1996, Voxware, Inc                          *
*                            All Rights Reserved                               *
*                                                                              *
*                       DISTRIBUTION PROHIBITED without                        *
*                      written authorization from Voxware                      *
*******************************************************************************/

/*******************************************************************************
* Filename:    enhance.h                                                                  
*                                                                              
* Purpose:     Frequency-domain based perceptual weighting of the 
*		         harmonic amplitudes based upon the spectrum of the LPC
*		         coefficients.                                                                  
*                                                                              
* Author/Date: Rob Zopf 02/06/96                                                                
********************************************************************************
* $Header:   /export/phobos/pvcs/r_and_d/archives/realtime/decode/enhance.h_v   1.3   20 Apr 1998 14:41:36   weiwang  $                                                                     
*******************************************************************************/

#ifndef ENHANCE_H
#define ENHANCE_H

#define ORIGINAL		1
#define AGRESSIVE  		2
#define CONSERVATIVE  	3

#define FILTER_TYPE CONSERVATIVE 

#define ENHANCE_FFT           (1<<ENHANCE_FFT_REAL_ORDER)
#define ENHANCE_FFT2          (ENHANCE_FFT>>1)

/* Distance Supression between formants and nulls */
#define SUPPRESSION_FACTOR    0.3/* 0.3F needs to be pitch adaptive [.3-.8] Pfw=0.3 for F0>=200 && Pfw=0.8  F0<=120 && Pfw=0.5  F0<=120 */
#define SUPPRESSION_FACTOR2   0.25/* 0.25F if Pv <=0.1 */

#if FILTER_TYPE == ORIGINAL 
	#define SF_0   0.1F   /*        Pv<=0.1 */
	#define SF_1    .1F   /*  150<F0                P0 <53.33 */
	#define SF_2   .3F    /*  100<F0<=150   53.3 >= P0 <80 */
	#define SF_3   .5F    /*  F0<=100    	 80  >= P0 */
#endif

#if FILTER_TYPE == CONSERVATIVE /*  Conservative  */
		#define SF_0    0.35F   /* 0.7F                 Pv<=0.1 */
		#define SF_1    0.2F    /* 0.4F  150<F0                P0 <53.33 */ 
		#define SF_2    0.35F   /* 0.7F  100<F0<=150   53.3 >= P0 <80 */ 
		#define SF_3    0.5F    /* 0.9F  F0<=100    	 80  >= P0 */
#endif 

#if FILTER_TYPE == AGRESSIVE   /*  Aggresive */
	#define SF_0    0.7F        /*                 Pv<=0.1 */
	#define SF_1    0.4F        /*  150<F0                P0 <53.33 */
	#define SF_2    0.7F        /*  100<F0<=150   53.3 >= P0 <80 */
	#define SF_3    0.9F        /*  F0<=100    	 80  >= P0 */
#endif
#define SF_P1 53.33F
#define SF_P2 80.0F






/*------------------------------------------------------------------------------
  In order to eliminate casting from a float to an int for indexing, the index
  is now a long.  The definitions below are used for quick shifting and 
  normalization of the indexing, eliminating the cast.  This is seen as a 
  significant speed-up, especially on the PC.

  RZ - 01/17/97
  ------------------------------------------------------------------------------*/
#define F_QFACTOR                        (31-(ENHANCE_FFT_REAL_ORDER+1))
#define F_TO_FLOAT                       (1.0F/(((long)1)<<F_QFACTOR))
#define F_FRACTION_MASK                  ((((long)1)<<F_QFACTOR)-1) 

/*------------------------------------------------------------------------------
  During enhancement, it is better to interpolate between fft bins to obtain
  a better estimate of the lpc inverse spectrum at the given harmonic freq.
  Previously, we just selected the nearest fft bin, which meant that a high
  order fft was necessary to maintain a small fft bin width, and minimize
  error from selecting the nearest fft value.  By interpolating, the fft
  size can be reduced, hence reducing both complexity and memory requirements.

  RZ - 01/17/97
  ------------------------------------------------------------------------------*/
#define INTERPOLATE_BETWEEN_FFT_BINS      1

/*------------------------------------------------------------------------------
   A 5th order polynomial can be used to estimate the power function for a 
   significant complexity reduction.  There are 4 different polynomials
   corresponding to a certain range of input.  The BOUNDARY definitions below
   specify the cutoff points for validity of each polynomial.  There are 
   separate sets of polynomials for x^(-0.125) and x^(-0.150).  The polynomial
   estimates are very accurate and the speech quality is identical to using
   the power function.

   RZ - 01/17/97
  ------------------------------------------------------------------------------*/         
#define USE_POWER_ESTIMATE                0
#define POLYORDER                         5
#define BOUNDARY1                         8.0F
#define BOUNDARY2                         50.0F
#define BOUNDARY3                         1000.0F
#define BOUNDARYMAX                       15000.0F

     

/*---------------------------------------------------------------------
  Enhancement Decoder Structure ...
  ---------------------------------------------------------------------*/
typedef struct tagEnhance_mblk
{
   float        *RE;          /* 256 -- only inside enhance_29 */
   float        *IM;          /* 256 -- only inside enhance_29 */
   float        *TT;          /* 128 -- only inside enhance_29 */
   float        *amp;         /* 60  -- only inside enhance_29 */
   short        *freq;        /* 60  -- only inside enhance_29 */
   float        *lpc;
} ENHANCE;


unsigned short VoxEnhance(STACK_R float *lpc, float Pv, float PitchLag, int nHarm, float *HarmAmp);


#endif /* ENHANCE_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\envtoas.h ===
/*******************************************************************************
*                        Voxware Proprietary Material
*                        Copyright 1996, Voxware, Inc
*                            All Rights Reserved
*
*                       DISTRIBUTION PROHIBITED without
*                      written authorization from Voxware
*******************************************************************************/
 
/*******************************************************************************
*
* Filename:    EnvToAs.c
*
* Purpose:     Compute predictor coefficients and gain from the log (base 2)
*                of the spine fit to the SeeVoc power peaks.
*
* Functions:
*
* Author/Date: Bob Dunn 12/28/96
*
********************************************************************************
* $Header:   /export/phobos/pvcs/r_and_d/archives/scaleable/encode/EnvToAs.h_v   1.1   11 Apr 1998 15:19:22   bobd  $
*******************************************************************************/

#ifndef LOGENVTOAS_H
#define LOGENVTOAS_H

void LogEnvelopeToAs( STACK_R
                      float *pfLogSeeEnv,
                      int    iOrderAllpole,
                      float *pfGain,
                      float *pfAS,
                      float *pfKS
                     );

#endif /* LOGENVTOAS_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\fadeio.c ===
/*******************************************************************************
*                        Voxware Proprietary Material                          *
*                        Copyright 1996, Voxware, Inc                          *
*                            All Rights Reserved                               *
*                                                                              *
*                       DISTRIBUTION PROHIBITED without                        *
*                      written authorization from Voxware                      *
*******************************************************************************/

/*******************************************************************************
* Filename: FadeIO.c                                                                    
*                                                                              
* Purpose: Fade-In/ Fade-Out during frame loss conditions                                                                    
*                                                                              
* Functions:                                                                   
*                                                                              
* Author/Date: RZ/ 02-26-97                                                                
********************************************************************************
* Modifications:
*                   
* Comments:                                                                    
* 
* Concerns:
*
* 
*******************************************************************************/
#include <stdlib.h>
#include <math.h>
#include <assert.h>

#include "model.h"
#include "VoxMem.h"
#include "param.h"
#include "GetnHarm.h"
#include "FadeIO.h"

#include "xvocver.h"

/*******************************************************************************
* Function:    void VoxFadeIO(void *pvFadeIOMemBlk, void *pvParamMemBlk)
*
* Action: Perform FadeIn/ FadeOut during frame loss
*
* Input:
*
* Output:
*
* Globals:        none
*
* Return:		   VOXErr : Voxware return code
********************************************************************************
* Implementation/Detailed Description:
*
* References:
********************************************************************************
* Modifications:
*
* Comments:
*
* Concerns/TBD:
*******************************************************************************/
 
void VoxFadeIO(void *pvFadeIOMemBlk, void *pvParamMemBlk)
{
   PARAM *Param_mblk = (PARAM *)pvParamMemBlk;
   FadeIOstruct *FadeIO_mblk = (FadeIOstruct *)pvFadeIOMemBlk;

   short nHarm;
   int   i;
   float AmpLevel;
   float FadeFactor;

   /*====================================================================
     Check to see if there should be silence/background noise injection.
     ====================================================================*/
   if (FadeIO_mblk->CurrentFrameState == SILENCE)
   {
    /*===================================================================
      Set the energy, pitch, pv, amplitudes, and lsfs to either preset
      "noise" values, current noise estimates.
      ===================================================================*/
      Param_mblk->Energy = FadeIO_mblk->BackgroundEnergyEst;
      Param_mblk->Pitch  = SILENCE_PITCH;
      Param_mblk->Pv     = 0.0F;
      nHarm              = getnHarm(Param_mblk->Pitch);
      AmpLevel           = (float)sqrt(2.0F*Param_mblk->Energy/nHarm);

      for (i=0; i< nHarm; i++)
      {
         Param_mblk->Amp[i] = AmpLevel;
      }
      for (; i<MAXHARM; i++)
      {
         Param_mblk->Amp[i] = 0.0F;
      }

      for (i=0; i<LPC_ORDER; i++)
      {
         Param_mblk->Lsf[i] = FadeIO_mblk->BackgroundLsf[i];
      }
      for (i=1;i<LPC_ORDER;i++)
      {
         if (Param_mblk->Lsf[i]<(Param_mblk->Lsf[i-1]+LSP_SEPERATION_HZ))
         {
            Param_mblk->Lsf[i] = Param_mblk->Lsf[i-1]+LSP_SEPERATION_HZ;
         }
      }  
   }
 /*========================================================================
   If we are not in silence, and the voicing is zero, we must update our
   background noise estimates of energy and lsfs.
   ========================================================================*/
   else if (Param_mblk->Pv == 0.0F)
   {
      for (i=0; i<LPC_ORDER; i++)  /* running average of silence lsfs  */
      {
         FadeIO_mblk->BackgroundLsf[i] = (float)((1.0-RUNNING_AVE)*Param_mblk->Lsf[i] 
            +RUNNING_AVE*FadeIO_mblk->BackgroundLsf[i]);
      }
      if (Param_mblk->Energy < FadeIO_mblk->BackgroundEnergyEst)
      {
         FadeIO_mblk->BackgroundEnergyEst = Param_mblk->Energy;
      }
      else
      {
         FadeIO_mblk->BackgroundEnergyEst *= ENERGY_INCREASE;
      }
   }


 /*=========================================================================
   We want to fade in over a few frames.  Check to see if the codec must 
   fade in.  If it does, set the fade in length counting.
   =========================================================================*/
   if ((FadeIO_mblk->CurrentFrameState == NORMAL)
      &&(FadeIO_mblk->LastFrameState   == SILENCE))
   {
      FadeIO_mblk->FadeInCount = FADEIN_LEN;
   }

 /*=========================================================================
   Check if the decoder needs to fade in this frame
   =========================================================================*/
   if (FadeIO_mblk->FadeInCount > 0)
   {
      FadeIO_mblk->FadeInCount--;
      FadeFactor = (FADEIN_LEN-FadeIO_mblk->FadeInCount)*(1.0F/((float)FADEIN_LEN));
      for (i=0;i<MAXHARM;i++)
      {
         Param_mblk->Amp[i] *= FadeFactor;
      }
   }
  
   FadeIO_mblk->LastFrameState    = FadeIO_mblk->CurrentFrameState;
   FadeIO_mblk->CurrentFrameState = NORMAL;
}


/*******************************************************************************
* Function:       VOXErr VoxinitFadeIO(void **hFadeIOMemBlk)
*
* Action:         Initializes the LPCSyn struct
*
* Input:
*
* Output:
*
* Globals:        none
*
* Return:		   VOXErr : Voxware return code
********************************************************************************
* Implementation/Detailed Description:
*
* References:
********************************************************************************
* Modifications:
*
* Comments:
*
* Concerns/TBD:
*******************************************************************************/
unsigned short VoxinitFadeIO(void **hFadeIOMemBlk)
{
   FadeIOstruct *FadeIO_mblk;
   short i;

   if(VOX_MEM_INIT(FadeIO_mblk=*hFadeIOMemBlk,1,sizeof(FadeIOstruct))) 
      return 1;

   if(VOX_MEM_INIT(FadeIO_mblk->BackgroundLsf,LPC_ORDER,sizeof(float))) 
      return 1;

  for(i=0;i<LPC_ORDER;i++) 
	FadeIO_mblk->BackgroundLsf[i] = LSP_INITIAL_COND_DEL*i + LSP_INITIAL_COND_0;

   FadeIO_mblk->FadeInCount         = 0; 
   FadeIO_mblk->CurrentFrameState   = NORMAL;
   FadeIO_mblk->LastFrameState      = NORMAL;
   FadeIO_mblk->BackgroundEnergyEst = INITIAL_BACKGROUND_ENERGY;


   return 0;
}


/*******************************************************************************
* Function:       VOXErr VoxfreeFadeIO(void **hFadeIOMemBlk)
*
* Action:         frees up the LPCSyn struct
*
* Input:
*
* Output:
*
* Globals:        none
*
* Return:		  VOXErr : Voxware return code
********************************************************************************
* Implementation/Detailed Description:
*
* References:
********************************************************************************
* Modifications:
*
* Comments:
*
* Concerns/TBD:
*******************************************************************************/
unsigned short VoxfreeFadeIO(void **hFadeIOMemBlk)
{
   FadeIOstruct *FadeIO_mblk=(FadeIOstruct *)*hFadeIOMemBlk;

   if(*hFadeIOMemBlk) {
      VOX_MEM_FREE(FadeIO_mblk->BackgroundLsf);
      VOX_MEM_FREE(*hFadeIOMemBlk);
   }
   return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\estonset.h ===
/*******************************************************************************
*                        Voxware Proprietary Material                          *
*                        Copyright 1996, Voxware, Inc                          *
*                            All Rights Reserved                               *
*                                                                              *
*                       DISTRIBUTION PROHIBITED without                        *
*                      written authorization from Voxware                      *
*******************************************************************************/
 
/*******************************************************************************
* $Header:   /export/phobos/pvcs/r_and_d/archives/scaleable/encode/EstOnset.h_v   1.0   06 Feb 1998 10:06:46   johnp  $
*******************************************************************************/
#ifndef _ESTONSET_H_
#define _ESTONSET_H_

int EstOnset(void *pOnsetMblk, void *pCircBufMblk, int codec_delay_size,
               int winLength, float *SpBuf);

short VoxInitEstOnset(void **hOnsetMblk);

short VoxFreeEstOnset(void **hOnsetMblk);

#endif /* _ESTONSET_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\estonset.c ===
/*******************************************************************************
*                        Voxware Proprietary Material                          *
*                        Copyright 1996, Voxware, Inc                          *
*                            All Rights Reserved                               *
*                                                                              *
*                       DISTRIBUTION PROHIBITED without                        *
*                      written authorization from Voxware                      *
******************************************************************************/

/*******************************************************************************
* Filename:       EstOnset.c
*                                                                              
* Purpose:        Estimate the onset position of current frame. Calculate how 
*                 much to shift for window placement.
*                                                                              
* Functions:   
*                                                                              
* Author/Date: Wei Wang,  Aug. 21, 1997
*
* Reference:  Improvement of the Narrowband Linear Predictive Coder, 
*             NRL Report 8645 Page 8-14.
*          
********************************************************************************
* Modifications:  (1) change the algorithm to avoid the division. (v 1.9)
*                 (2) do 2:1 decimation.   (v 2.0)
*                                                                              
* Comments:                                                                    
* 
* Concerns:
*
* $Header:   /export/phobos/pvcs/r_and_d/archives/scaleable/encode/EstOnset.c_v   1.3   11 Apr 1998 16:09:04   bobd  $
******************************************************************************/
#include <assert.h>
#include <stdlib.h>
#include <math.h>
#include <string.h>
#include "codec.h"
#include "VoxMem.h"
#include "vLibSnd.h"
#include "vLibMath.h"
#include "EstOnset.h"

#include "xvocver.h"

#define DECIM_R             2
#define AC_WEIGHT1           (0.03100586F)     /***** 1-(63/64)^2 *****/
#define AC_WEIGHT2           (0.96899414F)    /***** (63/64)^2 ****/
#define R                    (4)

#define MAX_KS                1.05F
#define MIN_ONSET_DIFF        10              /**** 10 samples difference ****/
#define ONSET_THRESHOLD       0.16F    /* 1.8/8,  was 1.7F */
#define INV_FRAME_LEN         0.0125F   /* 1/80 */
#define MAX_SHIFT             (HALF_FRAME_LENGTH_SC>>1)

typedef struct {
  float saveAC0[R];
  float saveAC1[R];
  float sumAC0;
  float sumAC1;
  int ptr0;
  int Onset_1;
} ONSET_Mblk;

/* estimate the onset time and return the window position */
int EstOnset(void *hOnsetMblk, void *pCircBufMblk, int codec_delay_size,
               int winLength, float *SpBuf)
{
  ONSET_Mblk *pOnsetMblk = (ONSET_Mblk *)hOnsetMblk;
  int OnsetK=0, OnsetDur = pOnsetMblk->Onset_1+MIN_ONSET_DIFF-FRAME_LENGTH_SC;

  float *psaveAC0 = pOnsetMblk->saveAC0;
  float *psaveAC1 = pOnsetMblk->saveAC1;

  int ptr0 = pOnsetMblk->ptr0;     /**** the pointer for the buffer ****/

  float AC0 = psaveAC0[ptr0];    /**** point to the previous sample ****/
  float AC1 = psaveAC1[ptr0];

  float sumAC0 = pOnsetMblk->sumAC0;
  float sumAC1 = pOnsetMblk->sumAC1;
  float ftmp;
  int WinShift;
  int k;
  register float t0, t1;
  float maxT0 = 1.0F;
  float maxT1 = ONSET_THRESHOLD;
  
#ifdef WIN32
  union {
    float f;
    long l;
  } union_t0, union_t1;
#else
  float s0, s1;
#endif

  /*----------------------------------------------------------------------
    (1) Get the current frame of speech out. 
    ----------------------------------------------------------------------*/
  GetFrameSpCBM(pCircBufMblk, codec_delay_size, FRAME_LENGTH_SC+1, SpBuf);

  for (k = 0; k < FRAME_LENGTH_SC; k+=DECIM_R, SpBuf+=DECIM_R) {

    /*-----------------------------------------------------------------
      (2) increase the pointer: point to k-8 sample.
      -----------------------------------------------------------------*/
    ptr0 = (ptr0+1)%R;

    /*-----------------------------------------------------------------
      (3) Calculate the 1st order forward-autocorrelation coefficients.      
      -----------------------------------------------------------------*/
    t1 = AC_WEIGHT1*SpBuf[0];
    AC0 = t1*SpBuf[0] + AC_WEIGHT2*AC0;
    AC1 = t1*SpBuf[1] + AC_WEIGHT2*AC1;

    /*-----------------------------------------------------------------
      (4) Find the fabs(AC1/AC0-sumAC1/sumAC0) > maxDCep ? 
      -----------------------------------------------------------------*/
    t1 = (float)fabs(AC1*sumAC0-AC0*sumAC1);
    t0 = (sumAC0*AC0);

    /*-----------------------------------------------------------------
      (5) calculate the cumulative Ac: sumAC = sumAC+AC[0]-AC[-8]
      -----------------------------------------------------------------*/
    sumAC0 = sumAC0 + AC0 - psaveAC0[ptr0];
    sumAC1 = sumAC1 + AC1 - psaveAC1[ptr0];
    psaveAC0[ptr0] = AC0;
    psaveAC1[ptr0] = AC1;

    if (k < OnsetDur) 
      continue;

#ifndef WIN32
    s0 = t1*maxT0;
    s1 = t0*maxT1;
    if (s0 > s1) {
      maxT0 = t0;
      maxT1 = t1;
      OnsetK = k;
    }
#else
    union_t0.f = t1*maxT0;
    union_t1.f = t0*maxT1;
    if (union_t0.l > union_t1.l) {
      maxT0 = t0;
      maxT1 = t1;
      OnsetK = k;
    }
#endif
  }

  /*------------------------------------------------------------
    (6) Update the memory 
    ------------------------------------------------------------*/
  pOnsetMblk->Onset_1 = OnsetK;
  pOnsetMblk->sumAC0 = sumAC0;
  pOnsetMblk->sumAC1 = sumAC1;
  pOnsetMblk->ptr0 = ptr0;

  /*-----------------------------------------------------------------
    (7) Compute the window shift based on the onset time.
    -----------------------------------------------------------------*/
  if (OnsetK > HALF_FRAME_LENGTH_SC) {
    ftmp = ((float)(FRAME_LENGTH_SC-OnsetK)*(codec_delay_size-(winLength>>1)))*INV_FRAME_LEN;
    VoxROUND2pos(ftmp, WinShift);
    if (WinShift > MAX_SHIFT)
      WinShift = MAX_SHIFT;
  }
  else {
    ftmp = (float)(OnsetK*(codec_delay_size-(winLength>>1)))*INV_FRAME_LEN;
    VoxROUND2pos(ftmp, WinShift);
    WinShift = -WinShift;
    if (WinShift < -MAX_SHIFT)
      WinShift = -MAX_SHIFT;
  }

  return WinShift;
}

/*
 * Initialize the structure.
 */
short VoxInitEstOnset(void **hOnsetMblk)
{
  ONSET_Mblk *pOnsetMblk;

  /* init the structure */
  if (VOX_MEM_INIT(*hOnsetMblk, 1, sizeof(ONSET_Mblk)))
    return 1;

  pOnsetMblk = (ONSET_Mblk *)*hOnsetMblk;
  
  pOnsetMblk->Onset_1 = 0;
  pOnsetMblk->sumAC0 = 0.0F;
  pOnsetMblk->sumAC1 = 0.0F;
  pOnsetMblk->ptr0 = 0;
  memset(pOnsetMblk->saveAC0, 0, R*sizeof(float));
  memset(pOnsetMblk->saveAC1, 0, R*sizeof(float));

  return 0;
}

/* Free structure */
short VoxFreeEstOnset(void **hOnsetMblk)
{
  if (*hOnsetMblk) {
    VOX_MEM_FREE(*hOnsetMblk);
  }

  return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\exphase.c ===
/*******************************************************************************
*                        Voxware Proprietary Material
*                        Copyright 1996, Voxware, Inc
*                            All Rights Reserved
*
*                       DISTRIBUTION PROHIBITED without
*                      written authorization from Voxware
*******************************************************************************/

/*******************************************************************************
*
* Filename:     ExPhase.c
*
* Purpose:      Create voiced and measured phase components of the 
*                 excitation phase.
*
* Functions:    ExcitationPhase()
*
* Author/Date:  Bob McAulay, Spring 1997
*
********************************************************************************
*
* Modifications:  Code cleaning and such. Bob Dunn 12/97.
*
* Comments:
*
* Concerns:
*
* $Header:   /export/phobos/pvcs/r_and_d/archives/scaleable/decode/ExPhase.c_v   1.1   16 Mar 1998 10:33:36   weiwang  $
*
*******************************************************************************/
#include <stdlib.h>
#include <assert.h>
#include "ExPhase.h"

#include "xvocver.h"

/*******************************************************************************
*
* Function:  ExcitationPhase()
*
* Action:    Create voiced and measured phase components of the
*                 excitation phase.
*
* Input:     float  fOnsetPhase -> the onset phase
*            float  fBeta       -> the beta factor
*            float *pfVEVPhase  -> measured phase residuals
*            float *pfMinPhase  -> minimum-phase phases
*            int    iNpeaks     -> total number of harmonics
*            int    iBasePeaks  -> number of measured phase residuals
*
* Output:    float *pfMinPhase  -> output phases with voiced and measured
*                                    phase components
*
* Globals:   none
*
* Return:    void
********************************************************************************
*
* Modifications:
*
* Comments:
*
* Concerns/TBD:
*******************************************************************************/

void ExcitationPhase( float  fOnsetPhase,
                      float  fBeta,
                      const float *pfVEVPhase,
                      float *pfMinPhase,
                      int    iNpeaks,
                      int    iBasePeaks
                    )
{
   int   i;
   float fLinearPhase;
   
   assert((pfMinPhase != NULL) && (pfVEVPhase != NULL));

 /*--------------------------------------------------------------------------
   Compute the linear phase component with phase offset
 --------------------------------------------------------------------------*/
   fLinearPhase = fOnsetPhase + fBeta;
   for (i=0; i<iNpeaks; i++)
   {     
      pfMinPhase[i] += fLinearPhase;
      fLinearPhase += fOnsetPhase;
   }


 /*--------------------------------------------------------------------------
   Append the quantized phase residuals to the linear phase if iBasePeaks > 0
 --------------------------------------------------------------------------*/
   for (i=0; i<iBasePeaks; i++)
      pfMinPhase[i] += pfVEVPhase[i];

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\fadeio.h ===
/*******************************************************************************
*                        Voxware Proprietary Material                          *
*                        Copyright 1996, Voxware, Inc                          *
*                            All Rights Reserved                               *
*                                                                              *
*                       DISTRIBUTION PROHIBITED without                        *
*                      written authorization from Voxware                      *
*******************************************************************************/

/*******************************************************************************
* Filename: FadeIO.h                                                                    
*                                                                              
* Purpose: Fade-In/ Fade-Out during frame loss conditions                                                                    
*                                                                              
* Functions:                                                                   
*                                                                              
* Author/Date: RZ/ 02-26-97                                                                
********************************************************************************
* Modifications:
*                   
* Comments:                                                                    
* 
* Concerns:
*
* 
*******************************************************************************/
#ifndef FADEIO_H
#define FADEIO_H

#define SILENCE_PITCH              125.0F
#define RUNNING_AVE                0.97F
#define ENERGY_INCREASE            1.01F
#define FADEIN_LEN                 3
#define INITIAL_BACKGROUND_ENERGY  500.0F;

#define SILENCE                    0
#define NORMAL                     1

typedef struct tagFadeIO
{
   short   CurrentFrameState;
   short   LastFrameState;
   float   BackgroundEnergyEst;
   float  *BackgroundLsf;
   short   FadeInCount;

} FadeIOstruct;

void VoxFadeIO(void *pvFadeIOMemBlk, void *pvParamMemBlk);
unsigned short VoxinitFadeIO(void **hFadeIOMemBlk);
unsigned short VoxfreeFadeIO(void **hFadeIOMemBlk);

#endif /* FADEIO_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\fadesc.c ===
/*******************************************************************************
*                        Voxware Proprietary Material                          *
*                        Copyright 1996, Voxware, Inc                          *
*                            All Rights Reserved                               *
*                                                                              *
*                       DISTRIBUTION PROHIBITED without                        *
*                      written authorization from Voxware                      *
*******************************************************************************/

/*******************************************************************************
* Filename: FadeSC.c
*                                                                              
* Purpose: Fade-In/ Fade-Out during frame loss conditions 
*                                                                              
* Functions: VoxFadeSC,  VoxinitFadeIO,  VoxfreeFadeIO,  
*         SetCurrentFrameState, GetCurrentFrameState, GetLastFrameState
*
* Author/Date: RZ/ 02-26-97
********************************************************************************
* Modifications: 07/30/97 RZ Adapted for SC codecs.
*                02/10/98 Wei Wang, cleaned up code
* Comments: 
* 
* Concerns:
*
* $Header:   /export/phobos/pvcs/r_and_d/archives/scaleable/utils/FadeSC.c_v   1.6   13 Apr 1998 16:17:56   weiwang  $
* 
*******************************************************************************/
#include <stdlib.h>
#include <math.h>
#include <assert.h>
#include <string.h>
#include "codec.h"
#include "VoxMem.h"
#include "paramSC.h"
#include "FadeSC.h"

#include "xvocver.h"

/*----------------------------------------------------------------------
  Definitions 
  ------------------------------------------------------------*/
#define SILENCE_PITCH              125.0F
#define RUNNING_AVE                0.97F
#define ENERGY_INCREASE            0.014355 /* log2(1.01F) */
#define FADEIN_LEN                 1 /* 3*/
#define INV_FADEIN_LEN             1.0F
#define INITIAL_BACKGROUND_ENERGY  0.0F; 


/*-----------------------------------------------------------------------------
  This is an array of initial values of arcsin reflection coefficients
-----------------------------------------------------------------------------*/
static const float fASKinit[LPC_ORDER] = {
-0.1329334F, 0.05232841F, -0.1199983F, -0.08337834F,
-0.1486588F, -0.1050886F, -0.08690762F, 0.0473017F,
-0.05771337F, -0.08524013F, 0.04383065F, 0.02077087F
};

/*------------------------------------------------------------
  Structure
  ------------------------------------------------------------*/
typedef struct tagFadeSC
{
  int CurrentFrameState;
  int LastFrameState;
  float  BackgroundEnergyEst;
  float  *BackgroundASK;
  int  FadeInCount;
} FadeSCstruct;


/*******************************************************************************
* Function:    void VoxFadeSC(void *pvFadeIOMemBlk, void *pvParamMemBlk)
*
* Action:      Perform FadeIn/ FadeOut during frame loss
*
* Input:  pvFadeSCMemBlk -- pointer to FadeSC memory block
*         pvParamMemBlk --  pointer to parameter memory block
* 
* Output: pvFadeSCMemBlk -- updated FadeSC memory block
*         pvParamMemBlk --  updated parameter memory block
*
* Globals:  none
*
* Return:   none
********************************************************************************
* Implementation/Detailed Description:
*
* References:
********************************************************************************
* Modifications:
*
* Comments:
*
* Concerns/TBD:
*******************************************************************************/
 
void VoxFadeSC(void *pvFadeSCMemBlk, void *pvParamMemBlk)
{
   PARAM_SC *Param_mblk = (PARAM_SC *)pvParamMemBlk;
   FadeSCstruct *FadeSC_mblk = (FadeSCstruct *)pvFadeSCMemBlk;
   SUBFRAME_PARAM_SC *pSubParamMid = &(Param_mblk->SubParam[PARAM_MIDFRAME]);
   SUBFRAME_PARAM_SC *pSubParamEnd = &(Param_mblk->SubParam[PARAM_ENDFRAME]);

   float FadeFactor;

   /*====================================================================
     Check to see if there should be silence/background noise injection.
     ====================================================================*/
   if (FadeSC_mblk->CurrentFrameState == SILENCE)
   {
    /*===================================================================
      Set the energy, pitch, pv, nad spectrum to either preset
      "noise" values, current noise estimates.
      ===================================================================*/
      Param_mblk->fLog2Gain     = FadeSC_mblk->BackgroundEnergyEst;
      pSubParamMid->Pitch = pSubParamEnd->Pitch = SILENCE_PITCH;
      pSubParamMid->Pv = pSubParamEnd->Pv = 0.0F;

      memcpy(Param_mblk->pfASK, FadeSC_mblk->BackgroundASK, 
             LPC_ORDER*sizeof(float));
   }
 /*========================================================================
   If we are not in silence, and the voicing is zero, we must update our
   background noise estimates of energy and ASKs.
   ========================================================================*/
   else if ((pSubParamMid->Pv == 0.0F)&&(pSubParamEnd->Pv == 0.0F))
   {
     memcpy(FadeSC_mblk->BackgroundASK, Param_mblk->pfASK, 
            LPC_ORDER*sizeof(float));

     if (Param_mblk->fLog2Gain < FadeSC_mblk->BackgroundEnergyEst)
       FadeSC_mblk->BackgroundEnergyEst = Param_mblk->fLog2Gain;
     else
       FadeSC_mblk->BackgroundEnergyEst += (float)ENERGY_INCREASE;
   }


 /*=========================================================================
   We want to fade in over a few frames.  Check to see if the codec must 
   fade in.  If it does, set the fade in length counting.
   =========================================================================*/
   if ((FadeSC_mblk->CurrentFrameState == NORMAL)
      &&(FadeSC_mblk->LastFrameState   == SILENCE))
   {
     FadeSC_mblk->FadeInCount = FADEIN_LEN;
   }

 /*=========================================================================
   Check if the decoder needs to fade in this frame
   =========================================================================*/
   if (FadeSC_mblk->FadeInCount > 0)
   {
      FadeSC_mblk->FadeInCount--;
      FadeFactor = 1.0F - (float)FadeSC_mblk->FadeInCount * INV_FADEIN_LEN;
      if (Param_mblk->fLog2Gain > FadeSC_mblk->BackgroundEnergyEst)
         Param_mblk->fLog2Gain = FadeSC_mblk->BackgroundEnergyEst + 
        (Param_mblk->fLog2Gain-FadeSC_mblk->BackgroundEnergyEst)*FadeFactor;
   }
  
   FadeSC_mblk->LastFrameState    = FadeSC_mblk->CurrentFrameState;
   FadeSC_mblk->CurrentFrameState = NORMAL;
}


/*******************************************************************************
* Function:  unsigned short VoxinitFadeIO(void **hFadeSCMemBlk)
*
* Action:    Initializes the LPCSyn struct
*
* Input:     hFadeSCMemBlk -- pointer to FadeSC memory block
*
* Output:    hFadeSCMemBlk -- memory allocated and initialized FadeSC memory 
*                               block
*
* Globals:   none
*
* Return:    0: succeed, 1: failed
********************************************************************************
* Implementation/Detailed Description:
*
* References:
********************************************************************************
* Modifications:
*
* Comments:
*
* Concerns/TBD:
*******************************************************************************/
unsigned short VoxinitFadeSC(void **hFadeSCMemBlk)
{
   FadeSCstruct *FadeSC_mblk;

   if(VOX_MEM_INIT(FadeSC_mblk=*hFadeSCMemBlk,1,sizeof(FadeSCstruct))) 
      return 1;

   if(VOX_MEM_INIT(FadeSC_mblk->BackgroundASK,LPC_ORDER,sizeof(float))) 
      return 1;

   memcpy(FadeSC_mblk->BackgroundASK, fASKinit, LPC_ORDER*sizeof(float));
  
   FadeSC_mblk->FadeInCount         = 0; 
   FadeSC_mblk->CurrentFrameState   = NORMAL;
   FadeSC_mblk->LastFrameState      = NORMAL;
   FadeSC_mblk->BackgroundEnergyEst = INITIAL_BACKGROUND_ENERGY; 
 
  return 0;
}


/*******************************************************************************
* Function:  unsigned short VoxfreeFadeIO(void **hFadeSCMemBlk)
*
* Action:   free up fade SC memory block
*
* Input:   hFadeSCMemBlk -- pointer to FadeSC memory block
*
* Output:  hFadeSCMemBlk -- memory freed FadeSC structure
*
* Globals:  none
*
* Return:  0 -- succeed
********************************************************************************
* Implementation/Detailed Description:
*
* References:
********************************************************************************
* Modifications:
*
* Comments:
*
* Concerns/TBD:
*******************************************************************************/
unsigned short VoxfreeFadeSC(void **hFadeSCMemBlk)
{
   FadeSCstruct *FadeSC_mblk=(FadeSCstruct *)*hFadeSCMemBlk;

   if(*hFadeSCMemBlk) {
      VOX_MEM_FREE(FadeSC_mblk->BackgroundASK);
      VOX_MEM_FREE(*hFadeSCMemBlk);
   }
   return 0;
}


/*******************************************************************************
* Function:  SetCurrentFrameStateSC()
*
* Action:    Set the current frame state inside FadeSC structure
*
* Input:     pvFadeSCMemBlk -- FadeSC structure
*            iFrameFlag -- the frame state (either 0 or 1)
*
* Output:    pvFadeSCMemBlk -- the updated FadeSC structure
*
* Globals:   none
*
* Return:    none
********************************************************************************
* Implementation/Detailed Description:
*
* References:
********************************************************************************
* Modifications:
*
* Comments:
*
* Concerns/TBD:
*******************************************************************************/

void SetCurrentFrameStateSC(void *pvFadeSCMemBlk, const int iFrameFlag)
{
  ((FadeSCstruct *)pvFadeSCMemBlk)->CurrentFrameState = iFrameFlag;
}


/*******************************************************************************
* Function:  GetCurrentFrameStateSC()
*
* Action:    Get the current frame state from FadeSC structure
*
* Input:     pvFadeSCMemBlk -- FadeSC structure
*            
* Output:    same as return
*
* Globals:   none
*
* Return:    the current frame state from FadeSC structure
********************************************************************************
* Implementation/Detailed Description:
*
* References:
********************************************************************************
* Modifications:
*
* Comments:
*
* Concerns/TBD:
*******************************************************************************/

int GetCurrentFrameStateSC(const void *pvFadeSCMemBlk)
{
  return ((FadeSCstruct *)pvFadeSCMemBlk)->CurrentFrameState;
}

/*******************************************************************************
* Function:  GetLastFrameStateSC()
*
* Action:    Get the last frame state from FadeSC structure
*
* Input:     pvFadeSCMemBlk -- FadeSC structure
*            
* Output:    same as return
*
* Globals:   none
*
* Return:    the last frame state from FadeSC structure
********************************************************************************
* Implementation/Detailed Description:
*
* References:
********************************************************************************
* Modifications:
*
* Comments:
*
* Concerns/TBD:
*******************************************************************************/

int GetLastFrameStateSC(const void *pvFadeSCMemBlk)
{
  return ((FadeSCstruct *)pvFadeSCMemBlk)->LastFrameState;
}

/*******************************************************************************
* Function:  UpdateFadeStateSC()
*
* Action:    Update the state of the Fade routine for the case where the
*              the decoder requires multiple calls to decode one frame of 
*              parameters.  
*
* Input:     pvFadeSCMemBlk  -- fade memory block
*            DecReqDataFlag  -- flag from decoder if decoder needs new data.
*            
* Output:    none
*
* Globals:   none
*
* Return:    none
********************************************************************************
* Implementation/Detailed Description:
*              If the DecReqDataFlag is NOT true, then the decoder is still
*          working on the last frame.  When this happens CurrentFrameState
*          must be set to LastFrameState if LastFrameState is SILENCE.
*
* References:
********************************************************************************
* Modifications:
*
* Comments:
*
* Concerns/TBD:
*******************************************************************************/

void UpdateFadeStateSC(const void *pvFadeSCMemBlk, unsigned char DecReqDataFlag)
{
  if (!DecReqDataFlag)
  {
     if (((FadeSCstruct *)pvFadeSCMemBlk)->LastFrameState == SILENCE)
        ((FadeSCstruct *)pvFadeSCMemBlk)->CurrentFrameState = SILENCE;
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\fadesc.h ===
/*******************************************************************************
*                        Voxware Proprietary Material                          *
*                        Copyright 1996, Voxware, Inc                          *
*                            All Rights Reserved                               *
*                                                                              *
*                       DISTRIBUTION PROHIBITED without                        *
*                      written authorization from Voxware                      *
*******************************************************************************/

/*******************************************************************************
* Filename: FadeSC.h
*                                                                              
* Purpose: Fade-In/ Fade-Out during frame loss conditions 
*
* Functions: VoxFadeSC,  VoxinitFadeIO,  VoxfreeFadeIO,  
*         SetCurrentFrameState, GetCurrentFrameState, GetLastFrameState
*                                                                              
* Author/Date: RZ/ 02-26-97
********************************************************************************
* Modifications: RZ/ 07/30/97 Modified for SC
*                   
* Comments:                                                                    
* 
* Concerns:
*
* $Header:   /export/phobos/pvcs/r_and_d/archives/scaleable/utils/FadeSC.h_v   1.3   24 Mar 1998 10:14:42   bobd  $
*******************************************************************************/
#ifndef FADESC_H
#define FADESC_H

/*--------------------------------------------------
  global definitions
  --------------------------------------------------*/
#ifndef SILENCE
#define SILENCE                    0
#endif

#ifndef NORMAL
#define NORMAL                     1
#endif

/*******************************************************************************
* Function:    void VoxFadeSC(void *pvFadeIOMemBlk, void *pvParamMemBlk)
*
* Action:      Perform FadeIn/ FadeOut during frame loss
*
* Input:  pvFadeSCMemBlk -- pointer to FadeSC memory block
*         pvParamMemBlk --  pointer to parameter memory block
* 
* Output: pvFadeSCMemBlk -- updated FadeSC memory block
*         pvParamMemBlk --  updated parameter memory block
*
* Globals:  none
*
* Return:   none
*******************************************************************************/
void VoxFadeSC(void *pvFadeSCMemBlk, void *pvParamMemBlk);

/*******************************************************************************
* Function:  unsigned short VoxinitFadeIO(void **hFadeSCMemBlk)
*
* Action:    Initializes the LPCSyn struct
*
* Input:     hFadeSCMemBlk -- pointer to FadeSC memory block
*
* Output:    hFadeSCMemBlk -- memory allocated and initialized FadeSC memory 
*                               block
*
* Globals:   none
*
* Return:    0: succeed, 1: failed
*******************************************************************************/
unsigned short VoxinitFadeSC(void **hFadeSCMemBlk);

/*******************************************************************************
* Function:  unsigned short VoxfreeFadeIO(void **hFadeSCMemBlk)
*
* Action:   free up fade SC memory block
*
* Input:   hFadeSCMemBlk -- pointer to FadeSC memory block
*
* Output:  hFadeSCMemBlk -- memory freed FadeSC structure
*
* Globals:  none
*
* Return:  0 -- succeed
*******************************************************************************/
unsigned short VoxfreeFadeSC(void **hFadeSCMemBlk);

/*******************************************************************************
* Function:  SetCurrentFrameStateSC()
*
* Action:    Set the current frame state inside FadeSC structure
*
* Input:     pvFadeSCMemBlk -- FadeSC structure
*            iFrameFlag -- the frame state (either 0 or 1)
*
* Output:    pvFadeSCMemBlk -- the updated FadeSC structure
*
* Globals:   none
*
* Return:    none
*******************************************************************************/
void SetCurrentFrameStateSC(void *pvFadeSCMemBlk, const int iFrameFlag);


/*******************************************************************************
* Function:  GetCurrentFrameStateSC()
*
* Action:    Get the current frame state from FadeSC structure
*
* Input:     pvFadeSCMemBlk -- FadeSC structure
*            
* Output:    same as return
*
* Globals:   none
*
* Return:    the current frame state from FadeSC structure
*******************************************************************************/

int GetCurrentFrameStateSC(const void *pvFadeSCMemBlk);

/*******************************************************************************
* Function:  GetLastFrameStateSC()
*
* Action:    Get the last frame state from FadeSC structure
*
* Input:     pvFadeSCMemBlk -- FadeSC structure
*            
* Output:    same as return
*
* Globals:   none
*
* Return:    the last frame state from FadeSC structure
*******************************************************************************/

int GetLastFrameStateSC(const void *pvFadeSCMemBlk);

/*******************************************************************************
* Function:  UpdateFadeStateSC()
*
* Action:    Update the state of the Fade routine for the case where the
*              the decoder requires multiple calls to decode one frame of
*              parameters.
*
* Input:     pvFadeSCMemBlk  -- fade memory block
*            DecReqDataFlag  -- flag from decoder if decoder needs new data.
*
* Output:    none
*
* Globals:   none
*
* Return:    none
********************************************************************************
* Implementation/Detailed Description:
*              If the DecReqDataFlag is NOT true, then the decoder is still
*          working on the last frame.  When this happens CurrentFrameState
*          must be set to LastFrameState if LastFrameState is SILENCE.
*
* References:
********************************************************************************
* Modifications:
*
* Comments:
*
* Concerns/TBD:
*******************************************************************************/
 
void UpdateFadeStateSC(const void *pvFadeSCMemBlk, 
                       unsigned char DecReqDataFlag);

#endif /* FADESC_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\fb8krt29.h ===
#ifndef FB8K_H 
#define FB8K_H

typedef struct 
{
  float *Barkvec;              /**** Bark scale -- static table (10)****/
  float *BarkWts;              /**** Weights for each Bark Scale -- (10) ****/

  float  **BarkMat;
  float  **BarkMatWts;

} FB_RT29 ;


/***** definitions *****/
#define DIST_THRESH 3.0e-4F
#define KMAX 5
#define mEPS 1e-16F	
#define BANDS1	10
#define BANDS2	10
	
#define LENGTH1	BANDS1*(1<<QB1)
#define LENGTH2	BANDS2*(1<<QB2)

#define BARK_MAX 	15			
#define GAMMAQ		2.7F 		
#define	MAX_FREQ	3200.0F	


#define FIXED_BANDS BARK_MAX 		
#define BW_DEF 4000.0F
#define FO_FIX	BW_DEF/FIXED_BANDS


#define BARK_MAX_DIST 	20	
#define GAMMAQ_DIST	6.0F	
#define MAX_FREQ_DIST	3400.0F	
#define FIXED_BANDS_DIST BARK_MAX_DIST 		

unsigned short VoxQFB_8kRT29(STACK_R void *Param_mblk, void *Quan_mblk);

unsigned short VoxUQFB_8kRT29(STACK_R void *Param_mblk, void *Quan_mblk);

unsigned short VoxInitFB_8kRT29(void **FB_mblk);

unsigned short VoxFreeFB_8kRT29(void **FB_mblk);

#endif  /*FB8k.h*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\fft_cent.c ===
/******************************************************************************
*                        Voxware Proprietary Material
*                        Copyright 1997, Voxware, Inc
*                            All Rights Reserved
*
*                       DISTRIBUTION PROHIBITED without
*                      written authorization from Voxware
******************************************************************************/
 
/******************************************************************************
*
* Filename:   fft_cent.c
*
* Purpose:    Compute the FFT of a REAL signal with the signal centered at
*               FFT sample 0.
*
* Functions:  fftCenter()
*
* Author/Date:  Wei Wang, 95-97
*
*******************************************************************************
*
* Modifications: Support the output with the inter-leave format spectrum.
*
* Comments: 
*
* Concerns:      If pfSig and pfSW share the same buffer, their lengths must 
*                  satisfy the condition:  iNfft - iLength > (iLength>>1)
*
* $Header:   /export/phobos/pvcs/pvcsproj/voxlib.prj/fft_cent.c_v   1.8   07 Apr 1998 17:55:14   weiwang  $
******************************************************************************/
#include <string.h>
#include <assert.h>
#include "vLibTran.h"

#include "xvocver.h"


/******************************************************************************
*
* Function:  VoxFftCenter()
*
* Action:    Compute the FFT of a REAL signal with the signal centered at
*              FFT sample 0.  Calculate the real FFT using inter-leaved 
*              formated FFT. 
* 
* Input:     pfSig     -- input signal buffer
*            iLength   -- the length of the input signal
*            pfSW      -- pointer to the output spectrum (need length N+2)
*            iFFTorder -- the order of FFT
*
* Output:    pfSW      -- output spectrum (inter-leaved)
*
* Globals:   none
*
* Return:    void
*******************************************************************************
*
* Implementation/Detailed Description:
*      Change the signal from __/====\__ to ==\____/==,  
*          so the spectrum is smoothed but not centered.
*
* References: 
*
*******************************************************************************
*
* Modifications:
*
* Comments:
*
* Concerns: If pfSig and pfSW share the same buffer, their lengths must
*           satisfy the condition:  iNfft - iLength >= (iLength>>1)
* 
******************************************************************************/

void VoxFftCenter( const float *pfSig, 
                   int          iLength,
                   float *       pfSW, 
                   int           iFFTorder
                 )
{
  int iNfft = 1 << iFFTorder; 
  int iHalfLen = iLength >> 1;

  /*** do error checking ***/ 
  assert(pfSig != NULL && pfSW != NULL);
  assert(((pfSig == pfSW)&&(iNfft>=(iLength+iHalfLen))) 
         ||((pfSig != pfSW)&&(iNfft>=iLength)));

  /*** Put the beginning part of pfSig to the end of pfSWR ******/
  memcpy(&(pfSW[iNfft-iHalfLen]), &(pfSig[0]), iHalfLen*sizeof(float));

  /*** Put the end part of pfSig to the beginning of pfSWR ***/
  memcpy(&(pfSW[0]), &(pfSig[iHalfLen]), (iLength-iHalfLen)*sizeof(float));
     
  /*** Zero the center of pfSig ***/
  memset(&(pfSW[iLength-iHalfLen]), 0, (iNfft-iLength)*sizeof(float));

  /*** FFT computation ***/
  VoxRealFft(pfSW, iFFTorder);
} /* VoxFftCenter() */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\fftsmcos.h ===
/******************************************************************************
*                        Voxware Proprietary Material
*                        Copyright 1996, Voxware, Inc
*                            All Rights Reserved
*
*                       DISTRIBUTION PROHIBITED without
*                      written authorization from Voxware
******************************************************************************/

/******************************************************************************
* Filename:      FftSmCos.h
* Purpose:       Compute sum of cosines with an FFT
* Functions:     FftSumCos()
* Author/Date:   Bob Dunn    4/22/98
*******************************************************************************
*
* Modifications:  
*
* Comments:
*
* Concerns:
*
* $Header:   /export/phobos/pvcs/r_and_d/archives/scaleable/decode/FftSmCos.h_v   1.0   23 Apr 1998 12:01:08   bobd  $
*
******************************************************************************/
#ifndef FFTSMCOS_H
#define FFTSMCOS_H

/******************************************************************************
*
* Function:   FftSumCos()
*
* Action:     Compute sum of cosines with FFT.
*
* Input:      fPitchDFT  --> pitch in DFT samples
*             pfAmps     --> cosine amplitudes
*             pfPhase    --> cosine phase (in radians)
*             iHarm      --> number of harmonics
*             iLength    --> number of samples to synthesize
*
* Output:     pfOutBuf   --> sum of cosines (with length iLength)
*
* Globals:    cosTBL_32[], sinTBL_32[], fRadiansToIndex
*
* Return:     none
******************************************************************************/

void FftSumCos( STACK_R
                float  fPitchDFT, 
                float *pfAmps, 
                float *pfPhase, 
                int    iHarm, 
                int    iLength, 
                float *pfOutBuf
              );

#endif /* FFTSMCOS_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\fhtkrnl.c ===
/******************************************************************************
*                        Voxware Proprietary Material
*                        Copyright 1997, Voxware, Inc
*                            All Rights Reserved
*
*                       DISTRIBUTION PROHIBITED without
*                      written authorization from Voxware
******************************************************************************/
/******************************************************************************
*
* Filename:    FHTkrnl.c
*
* Purpose:     A generalized version of the Fast Harmonic Transform.
*
* Functions:   FHTkrnl()
*
* Author/Date: Bob Dunn (converted from Rob Zopf's fixed point code)
*                       (of course, based on JGA's FHT :-) )
*
*
*******************************************************************************
*
* Modifications: 
*
*  2/24/97 - RZ : Uses a conjugate symmetric FFT or inverse Real FFT.
*                 The phase input should be have the range of the Sin/Cos
*                 table used in the codec.
*                 
*                 NOTE : the phase is not checked to see if it is in the range
*                        of the sin/cos tables.  The calling function must 
*                        ensure that 0 <= fPhase[i] < N, where N is the size 
*                        of the sin and cos tables.
*
*  3/21/97 - WW : Use inverse Real FFT. The input data have to arrange to:
*                 re(0), re(1), re(2)...re(N/2), Im(1)...Im(N>>1-1) and output
*                 data is :  re(0), re(1), re(2)....re(N-1)
*
*  6/18/97 - WW: put exp_shift and fFHTWeights as input so that RT and SC can 
*                share the same code.
*
*  12/97   - WW: clean up code for VOX library.
*
*  1/98    - BD: more code cleaning and removing external trig tables
*
*  2/98    - WW: remove the scaling factor
*
* Comments: 
*
* Concerns:
*
* $Header:   /export/phobos/pvcs/pvcsproj/voxlib.prj/FHTkrnl.c_v   1.2   02 Mar 1998 16:19:50   weiwang  $
******************************************************************************/
#include <stdlib.h>
#include <assert.h>
#include <string.h>
#include "vLibTran.h"

#include "xvocver.h"

/******************************************************************************
*
* Function:  VoxFHTkrnl()
*
* Action:    A fast harmonic sum of sinusoids algorithm (the fastest 
*            known to mankind as of 10/22/96 :-) ).
*            Returns a single pitch cycle of speech
*
* Input:     pfAmps       - array of harmonic amplitudes
*            piPhaseIndex - array of harmonic phase indexes (indexes into
*                             pfSinTbl[] and pfCosTbl[])
*            iHarm        - number of harmonics for synthesis
*            pfSig        - pointer to buffer for speech accumulation
*            iFFTorder    - the FFT order for FHT
*            pfFHTWeights - table of FHT weights
*            pfSinTbl     - pointer to sine table
*            pfCosTbl     - pointer to cosine table
*
* Output:    pfSig        - single pitch cycle of speech.
*
* Globals:   none
*
* Return:    void
*******************************************************************************
*
* Implementation/Detailed Description:
*
* References:  
*
*******************************************************************************
*
* Modifications: remove scaling factor at end
*
* Comments:
*
* Concerns/TBD: For speed, this routine currently uses table 
*               lookup for the sine and cosine of the phase.
*               The table size is variable and the phase indexes
*               are assumed to be within the table's limits.
*
*               For inter-leaved formatted inverse FFT, the size for pfSig has 
*               to be (1<<iFFTorder)+2.
*
******************************************************************************/

void VoxFHTkrnl( const float *pfAmps, 
                 const int   *piPhaseIndex, 
                 int   iHarm,    
                 float   *pfSig, 
                 int   iFFTorder, 
                 const float *pfFHTWeights,
                 const float *pfSinTbl,
                 const float *pfCosTbl)
{
  float fMag;
  int   i, j;
  int   iNfft = 1<<iFFTorder;

  assert(pfAmps != NULL && piPhaseIndex != NULL);
  assert(pfSig != NULL);
  assert(pfFHTWeights != NULL);
  assert(pfSinTbl != NULL && pfCosTbl != NULL);

  /*---------------------------------------------------------
    Zero the FFT buffer
  ---------------------------------------------------------*/
  memset(pfSig, 0, sizeof(float)*(iNfft+2));

  /*---------------------------------------------------------
    Fill the interleaved FFT buffer with real and imaginary
      parts corresponding to the harmonic amplitudes and 
      phases.  Multiply the harmonic amplitudes by the FHT 
      weight (pfFHTWeights[]).  
  ---------------------------------------------------------*/
  for (i=0, j=2; i < iHarm; i++, j+=2)
  {
     fMag       =  pfAmps[i] * pfFHTWeights[i];
     pfSig[j]   =  fMag * pfSinTbl[piPhaseIndex[i]];
     pfSig[j+1] = -fMag * pfCosTbl[piPhaseIndex[i]];
  }

  /*---------------------------------------------------------
    Take the inverse REAL FFT without scaling.
  ---------------------------------------------------------*/
  VoxRealInverseFft(pfSig, iFFTorder, IFFT_NO_SCALE_FLAG);

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\fd291sc.h ===
1.9030000e-02F,
2.0480393e-02F,
2.3308713e-02F,
2.6317289e-02F,
2.9510713e-02F,
3.2893453e-02F,
3.6469840e-02F,
4.0244058e-02F,
4.4220132e-02F,
4.8401923e-02F,
5.2793108e-02F,
5.7397179e-02F,
6.2217428e-02F,
6.7256935e-02F,
7.2518563e-02F,
7.8004947e-02F,
8.3718481e-02F,
8.9661312e-02F,
9.5835332e-02F,
1.0224217e-01F,
1.0888317e-01F,
1.1575941e-01F,
1.2287168e-01F,
1.3022045e-01F,
1.3780591e-01F,
1.4562794e-01F,
1.5368609e-01F,
1.6197961e-01F,
1.7050740e-01F,
1.7926805e-01F,
1.8825980e-01F,
1.9748057e-01F,
2.0692793e-01F,
2.1659909e-01F,
2.2649095e-01F,
2.3660003e-01F,
2.4692252e-01F,
2.5745427e-01F,
2.6819075e-01F,
2.7912712e-01F,
2.9025817e-01F,
3.0157837e-01F,
3.1308182e-01F,
3.2476232e-01F,
3.3661330e-01F,
3.4862789e-01F,
3.6079888e-01F,
3.7311876e-01F,
3.8557969e-01F,
3.9817354e-01F,
4.1089187e-01F,
4.2372596e-01F,
4.3666682e-01F,
4.4970516e-01F,
4.6283146e-01F,
4.7603594e-01F,
4.8930857e-01F,
5.0263910e-01F,
5.1601705e-01F,
5.2943177e-01F,
5.4287237e-01F,
5.5632783e-01F,
5.6978691e-01F,
5.8323827e-01F,
5.9667040e-01F,
6.1007168e-01F,
6.2343038e-01F,
6.3673468e-01F,
6.4997267e-01F,
6.6313240e-01F,
6.7620185e-01F,
6.8916900e-01F,
7.0202178e-01F,
7.1474816e-01F,
7.2733610e-01F,
7.3977362e-01F,
7.5204879e-01F,
7.6414973e-01F,
7.7606466e-01F,
7.8778191e-01F,
7.9928993e-01F,
8.1057729e-01F,
8.2163274e-01F,
8.3244517e-01F,
8.4300367e-01F,
8.5329754e-01F,
8.6331628e-01F,
8.7304964e-01F,
8.8248761e-01F,
8.9162043e-01F,
9.0043864e-01F,
9.0893305e-01F,
9.1709480e-01F,
9.2491532e-01F,
9.3238640e-01F,
9.3950014e-01F,
9.4624902e-01F,
9.5262588e-01F,
9.5862394e-01F,
9.6423680e-01F,
9.6945847e-01F,
9.7428336e-01F,
9.7870629e-01F,
9.8272251e-01F,
9.8632769e-01F,
9.8951796e-01F,
9.9228987e-01F,
9.9464042e-01F,
9.9656708e-01F,
9.9806776e-01F,
9.9914084e-01F,
9.9978515e-01F,
1.0000000e+00F,
9.9978515e-01F,
9.9914084e-01F,
9.9806776e-01F,
9.9656708e-01F,
9.9464042e-01F,
9.9228987e-01F,
9.8951796e-01F,
9.8632769e-01F,
9.8272251e-01F,
9.7870629e-01F,
9.7428336e-01F,
9.6945847e-01F,
9.6423680e-01F,
9.5862394e-01F,
9.5262588e-01F,
9.4624902e-01F,
9.3950014e-01F,
9.3238640e-01F,
9.2491532e-01F,
9.1709480e-01F,
9.0893305e-01F,
9.0043864e-01F,
8.9162043e-01F,
8.8248761e-01F,
8.7304964e-01F,
8.6331628e-01F,
8.5329754e-01F,
8.4300367e-01F,
8.3244517e-01F,
8.2163274e-01F,
8.1057729e-01F,
7.9928993e-01F,
7.8778191e-01F,
7.7606466e-01F,
7.6414973e-01F,
7.5204879e-01F,
7.3977362e-01F,
7.2733610e-01F,
7.1474816e-01F,
7.0202178e-01F,
6.8916900e-01F,
6.7620185e-01F,
6.6313240e-01F,
6.4997267e-01F,
6.3673468e-01F,
6.2343038e-01F,
6.1007168e-01F,
5.9667040e-01F,
5.8323827e-01F,
5.6978691e-01F,
5.5632783e-01F,
5.4287237e-01F,
5.2943177e-01F,
5.1601705e-01F,
5.0263910e-01F,
4.8930857e-01F,
4.7603594e-01F,
4.6283146e-01F,
4.4970516e-01F,
4.3666682e-01F,
4.2372596e-01F,
4.1089187e-01F,
3.9817354e-01F,
3.8557969e-01F,
3.7311876e-01F,
3.6079888e-01F,
3.4862789e-01F,
3.3661330e-01F,
3.2476232e-01F,
3.1308182e-01F,
3.0157837e-01F,
2.9025817e-01F,
2.7912712e-01F,
2.6819075e-01F,
2.5745427e-01F,
2.4692252e-01F,
2.3660003e-01F,
2.2649095e-01F,
2.1659909e-01F,
2.0692793e-01F,
1.9748057e-01F,
1.8825980e-01F,
1.7926805e-01F,
1.7050740e-01F,
1.6197961e-01F,
1.5368609e-01F,
1.4562794e-01F,
1.3780591e-01F,
1.3022045e-01F,
1.2287168e-01F,
1.1575941e-01F,
1.0888317e-01F,
1.0224217e-01F,
9.5835332e-02F,
8.9661312e-02F,
8.3718481e-02F,
7.8004947e-02F,
7.2518563e-02F,
6.7256935e-02F,
6.2217428e-02F,
5.7397179e-02F,
5.2793108e-02F,
4.8401923e-02F,
4.4220132e-02F,
4.0244058e-02F,
3.6469840e-02F,
3.2893453e-02F,
2.9510713e-02F,
2.6317289e-02F,
2.3308713e-02F,
2.0480393e-02F,
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\fhtw64.h ===
0.5002008420F,
0.5008039005F,
0.5018107763F,
0.5032241453F,
0.5050477726F,
0.5072865301F,
0.5099464206F,
0.5130346076F,
0.5165594503F,
0.5205305452F,
0.5249587746F,
0.5298563608F,
0.5352369290F,
0.5411155765F,
0.5475089516F,
0.5544353402F,
0.5619147632F,
0.5699690832F,
0.5786221235F,
0.5878997990F,
0.5978302607F,
0.6084440543F,
0.6197742963F,
0.6318568661F,
0.6447306190F,
0.6584376197F,
0.6730233996F,
0.6885372406F,
0.7050324870F,
0.7225668902F,
0.7412029879F,
0.7610085237F,
0.7820569094F,
0.8044277369F,
0.8282073438F,
0.8534894399F,
0.8803758018F,
0.9089770424F,
0.9394134669F,
0.9718160224F,
1.0063273565F,
1.0431029949F,
1.0823126563F,
1.1241417195F,
1.1687928642F,
1.2164879081F,
1.2674698654F,
1.3220052576F,
1.3803867112F,
1.4429358807F,
1.5100067441F,
1.5819893223F,
1.6593138845F,
1.7424557108F,
1.8319404921F,
1.9283504662F,
2.0323313997F,
2.1446005469F,
2.2659557385F,
2.3972857803F,
2.5395823718F,
2.6939537948F,
2.8616406649F,
3.0440340948F,
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\fhtw128.h ===
0.5000502022F,
0.5002008420F,
0.5004520192F,
0.5008039005F,
0.5012567193F,
0.5018107763F,
0.5024664395F,
0.5032241453F,
0.5040843984F,
0.5050477726F,
0.5061149117F,
0.5072865301F,
0.5085634136F,
0.5099464206F,
0.5114364831F,
0.5130346076F,
0.5147418768F,
0.5165594503F,
0.5184885668F,
0.5205305452F,
0.5226867863F,
0.5249587746F,
0.5273480802F,
0.5298563608F,
0.5324853639F,
0.5352369290F,
0.5381129896F,
0.5411155765F,
0.5442468197F,
0.5475089516F,
0.5509043098F,
0.5544353402F,
0.5581046005F,
0.5619147632F,
0.5658686195F,
0.5699690832F,
0.5742191942F,
0.5786221235F,
0.5831811766F,
0.5878997990F,
0.5927815806F,
0.5978302607F,
0.6030497336F,
0.6084440543F,
0.6140174439F,
0.6197742963F,
0.6257191841F,
0.6318568661F,
0.6381922937F,
0.6447306190F,
0.6514772021F,
0.6584376197F,
0.6656176736F,
0.6730233996F,
0.6806610776F,
0.6885372406F,
0.6966586862F,
0.7050324870F,
0.7136660023F,
0.7225668902F,
0.7317431205F,
0.7412029879F,
0.7509551264F,
0.7610085237F,
0.7713725370F,
0.7820569094F,
0.7930717870F,
0.8044277369F,
0.8161357666F,
0.8282073438F,
0.8406544174F,
0.8534894399F,
0.8667253910F,
0.8803758018F,
0.8944547810F,
0.9089770424F,
0.9239579338F,
0.9394134669F,
0.9553603502F,
0.9718160224F,
0.9887986883F,
1.0063273565F,
1.0244218793F,
1.0431029949F,
1.0623923719F,
1.0823126563F,
1.1028875212F,
1.1241417195F,
1.1461011396F,
1.1687928642F,
1.1922452330F,
1.2164879081F,
1.2415519449F,
1.2674698654F,
1.2942757374F,
1.3220052576F,
1.3506958403F,
1.3803867112F,
1.4111190068F,
1.4429358807F,
1.4758826159F,
1.5100067441F,
1.5453581732F,
1.5819893223F,
1.6199552653F,
1.6593138845F,
1.7001260336F,
1.7424557108F,
1.7863702449F,
1.8319404921F,
1.8792410467F,
1.9283504662F,
1.9793515107F,
2.0323313997F,
2.0873820857F,
2.1446005469F,
2.2040891007F,
2.2659557385F,
2.3303144845F,
2.3972857803F,
2.4669968958F,
2.5395823718F,
2.6151844926F,
2.6939537948F,
2.7760496128F,
2.8616406649F,
2.9509056839F,
3.0440340948F,
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\findmax.c ===
/******************************************************************************
*                        Voxware Proprietary Material
*                        Copyright 1997, Voxware, Inc
*                            All Rights Reserved
*
*                       DISTRIBUTION PROHIBITED without
*                      written authorization from Voxware
******************************************************************************/
 
/******************************************************************************
*
* Filename:     FindMax.c
*
* Purpose:      Find the maximum value of an array and return the index
*
* Functions:    FindMaxValueFlt()
*
* Author/Date:  Wei Wang
*
*******************************************************************************
*
* Modifications: 
*
* Comments:    
*
* Concerns:   
*
* $Header:   /export/phobos/pvcs/pvcsproj/voxlib.prj/FindMax.c_v   1.9   04 Mar 1998 11:48:30   weiwang  $
******************************************************************************/
#include <stdlib.h>
#include <assert.h>
#include "vLibVec.h"

#include "xvocver.h"


/*******************************************************************************
*
* Function:  FindMaxValueFlt()
*
* Action:    Finds the maximum value (and its location) of a floating 
*              point vector.
*
* Input:     *pfX  -> the vector to be scaled
*            iLength -> the length of the vector
*
* Output:    *piMaxIndex -> index of maximum value
*            *pfXmax     -> maximum value
*
* Globals:   none
*
* Return:    void
********************************************************************************
* Modifications: Version 2.0, Originated from Intel NSP Lib
*                Modified by Xiangdong Fu 12/11/96
*
*
* Concerns:    This version is an optimized version on Pentium or IEEE 
*              floating point format machine. It assumes interger
*              comparision is faster than floating point comparision. 
*              This version is 3 times faster than version  1.0 on Pentium.
*              It is proved to work on Sun as well, but not faster(or slower)
*
*              If choose pre-definition "IEEE", float and long of this platform
*              need to be 32 bits.
*
* Comments:    Input vector length >= 1
*
*******************************************************************************/
#if ((defined(WIN32) == 1) || (defined(IEEE) == 1))
/*-------------------------------------------------------------------
  VERSION 2.0
 
  This is pentium optimized code.  Although it works on some other 
    platforms such as the Sun, it makes assumptions about the 
    hardware representations of type float and type int, and we have 
    decided to use it only on the PC. It is therefore under the
    WIN32 compiler switch.
-------------------------------------------------------------------*/
void FindMaxValueFlt( const float *pfX, 
                      int         iLength, 
                      int         *piMaxIndex, 
                      float       *pfXmax
                    )
{
  int   i;
  long  *plElement;
  long   lMax;
  long   lMin;
  int   iIndexMax;
  int   iIndexMin;
  union dt
  {
    float f;
    long   l;
  } uMax;


  /* do error checking */
  assert(pfX != NULL && piMaxIndex != NULL && pfXmax != NULL);
  assert(iLength >= 1);

  /* do block comparison */
  plElement = (long *)pfX;
  lMin = ( lMax = plElement[0] );
  iIndexMax = iIndexMin = 0;
  for ( i = 1; ( ( lMax < 0 ) && ( ( i + 4 ) <= iLength ) ); i += 4 )
  {
    if ( plElement[i  ] > lMax ) {lMax = plElement[i  ];  iIndexMax = i;}
    if ( plElement[i  ] < lMin ) {lMin = plElement[i  ];  iIndexMin = i;}
    if ( plElement[i+1] > lMax ) {lMax = plElement[i+1];  iIndexMax = i+1;}
    if ( plElement[i+1] < lMin ) {lMin = plElement[i+1];  iIndexMin = i+1;}
    if ( plElement[i+2] > lMax ) {lMax = plElement[i+2];  iIndexMax = i+2;}
    if ( plElement[i+2] < lMin ) {lMin = plElement[i+2];  iIndexMin = i+2;}
    if ( plElement[i+3] > lMax ) {lMax = plElement[i+3];  iIndexMax = i+3;}
    if ( plElement[i+3] < lMin ) {lMin = plElement[i+3];  iIndexMin = i+3;}
  }
  for ( ; ( ( lMax < 0 ) && ( i < iLength ) ); i++ )
  {
    if ( plElement[i] > lMax ) {lMax = plElement[i]; iIndexMax = i;}
    if ( plElement[i] < lMin ) {lMin = plElement[i]; iIndexMin = i;}
  }
  for ( ; ( i + 4 ) <= iLength; i += 4 )
  {
    if ( plElement[i  ] > lMax ){ lMax = plElement[i  ];iIndexMax = i;}
    if ( plElement[i+1] > lMax ){ lMax = plElement[i+1];iIndexMax = i+1;}
    if ( plElement[i+2] > lMax ){ lMax = plElement[i+2];iIndexMax = i+2;}
    if ( plElement[i+3] > lMax ){ lMax = plElement[i+3];iIndexMax = i+3;}
  }
  for ( ; i < iLength; i++ ) 
    if ( plElement[i] > lMax ) {
       lMax = plElement[i];
       iIndexMax = i;
    }

  uMax.l = ( lMax >= 0 ) ? lMax : lMin;
  *piMaxIndex = ( lMax >= 0 ) ? iIndexMax : iIndexMin;
  *pfXmax = uMax.f;
}

#else /* end of VERSION 2.0 code */

/*-------------------------------------------------------------------
  VERSION 1.0

  This is the general purpose verion to be used.
-------------------------------------------------------------------*/
void FindMaxValueFlt( const float *pfX, 
                      int         iLength, 
                      int         *piMaxIndex,
                      float       *pfXmax
                    )
{
  int   i;
  int   iMaxIndex;
  float fXmax;
  float fX;

  /* error checking */
  assert(pfX != NULL && piMaxIndex != NULL && pfXmax != NULL);
  assert(iLength >= 1);

  /* find the max value */
  fXmax = *pfX++;
  iMaxIndex = 0;

  for (i = 1; i < iLength; i++) 
  {
    fX = *pfX++;
    if (fX > fXmax) 
    {
      fXmax = fX;
      iMaxIndex = i;
    }
  }
  
  *piMaxIndex = iMaxIndex;
  *pfXmax = fXmax;
}
#endif /* end of VERSION 1.0 code */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\g5lgrt29.h ===
#if 0
1.7453317344188690e-01F, 
6.3018810749053955e-01F, 
7.2512394189834595e-01F, 
7.8432649374008179e-01F, 
8.4283244609832764e-01F, 
9.0048265457153320e-01F, 
9.6679157018661499e-01F, 
1.0474995374679565e+00F, 
1.1361066102981567e+00F, 
1.2219737768173218e+00F, 
1.3074259757995605e+00F, 
1.3884115219116211e+00F, 
1.4681798219680786e+00F, 
1.5400635004043579e+00F, 
1.6064603328704834e+00F, 
1.6662454605102539e+00F, 
1.7265022993087769e+00F, 
1.7845876216888428e+00F, 
1.8410156965255737e+00F, 
1.8970497846603394e+00F, 
1.9529516696929932e+00F, 
2.0067188739776611e+00F, 
2.0658359527587891e+00F, 
2.1272106170654297e+00F, 
2.1918764114379883e+00F, 
2.2605969905853271e+00F, 
2.3317644596099854e+00F, 
2.4073512554168701e+00F, 
2.4991092681884766e+00F, 
2.6071612834930420e+00F, 
2.7453591823577881e+00F, 
2.9320304393768311e+00
#endif
/* I altered the first 3 entries to allow for
   a very small first entry   */
#if 0
-3.5379961016968786e-01F,
2.7453317344188690e-01F, 
6.5018810749053955e-01F, 
7.8432649374008179e-01F, 
8.4283244609832764e-01F, 
9.0048265457153320e-01F, 
9.6679157018661499e-01F, 
1.0474995374679565e+00F, 
1.1361066102981567e+00F, 
1.2219737768173218e+00F, 
1.3074259757995605e+00F, 
1.3884115219116211e+00F, 
1.4681798219680786e+00F, 
1.5400635004043579e+00F, 
1.6064603328704834e+00F, 
1.6662454605102539e+00F, 
1.7265022993087769e+00F, 
1.7845876216888428e+00F, 
1.8410156965255737e+00F, 
1.8970497846603394e+00F, 
1.9529516696929932e+00F, 
2.0067188739776611e+00F, 
2.0658359527587891e+00F, 
2.1272106170654297e+00F, 
2.1918764114379883e+00F, 
2.2605969905853271e+00F, 
2.3317644596099854e+00F, 
2.4073512554168701e+00F, 
2.4991092681884766e+00F, 
2.6071612834930420e+00F, 
2.7453591823577881e+00F, 
2.9320304393768311e+00F
#endif


  -1.42492175102234F,
  -0.60102242231369F,
   0.04660389199853F,
   0.58741033077240F,
   0.95356029272079F,
   1.25348472595215F,
   1.55513036251068F,
   1.82637035846710F,
   2.09570789337158F,
   2.35816240310669F,
   2.64766025543213F,
   2.82875895500183F,
   2.98835730552673F,
   3.16677069664001F,
   3.38036823272705F,
   3.59256410598755F,
   3.80499148368835F,
   4.01020240783691F,
   4.20326137542725F,
   4.38750076293945F,
   4.56415271759033F,
   4.73127698898315F,
   4.89598369598389F,
   5.05491542816162F,
   5.21471071243286F,
   5.37983751296997F,
   5.55446529388428F,
   5.73179244995117F,
   5.92647361755371F,
   6.14225721359253F,
   6.39957857131958F,
   6.75436258316040F
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\g5lg.h ===
#if 0
1.7453317344188690e-01F, 
6.3018810749053955e-01F, 
7.2512394189834595e-01F, 
7.8432649374008179e-01F, 
8.4283244609832764e-01F, 
9.0048265457153320e-01F, 
9.6679157018661499e-01F, 
1.0474995374679565e+00F, 
1.1361066102981567e+00F, 
1.2219737768173218e+00F, 
1.3074259757995605e+00F, 
1.3884115219116211e+00F, 
1.4681798219680786e+00F, 
1.5400635004043579e+00F, 
1.6064603328704834e+00F, 
1.6662454605102539e+00F, 
1.7265022993087769e+00F, 
1.7845876216888428e+00F, 
1.8410156965255737e+00F, 
1.8970497846603394e+00F, 
1.9529516696929932e+00F, 
2.0067188739776611e+00F, 
2.0658359527587891e+00F, 
2.1272106170654297e+00F, 
2.1918764114379883e+00F, 
2.2605969905853271e+00F, 
2.3317644596099854e+00F, 
2.4073512554168701e+00F, 
2.4991092681884766e+00F, 
2.6071612834930420e+00F, 
2.7453591823577881e+00F, 
2.9320304393768311e+00
#endif
/* I altered the first 3 entries to allow for
   a very small first entry   */
#if 0
-3.5379961016968786e-01F,
2.7453317344188690e-01F, 
6.5018810749053955e-01F, 
7.8432649374008179e-01F, 
8.4283244609832764e-01F, 
9.0048265457153320e-01F, 
9.6679157018661499e-01F, 
1.0474995374679565e+00F, 
1.1361066102981567e+00F, 
1.2219737768173218e+00F, 
1.3074259757995605e+00F, 
1.3884115219116211e+00F, 
1.4681798219680786e+00F, 
1.5400635004043579e+00F, 
1.6064603328704834e+00F, 
1.6662454605102539e+00F, 
1.7265022993087769e+00F, 
1.7845876216888428e+00F, 
1.8410156965255737e+00F, 
1.8970497846603394e+00F, 
1.9529516696929932e+00F, 
2.0067188739776611e+00F, 
2.0658359527587891e+00F, 
2.1272106170654297e+00F, 
2.1918764114379883e+00F, 
2.2605969905853271e+00F, 
2.3317644596099854e+00F, 
2.4073512554168701e+00F, 
2.4991092681884766e+00F, 
2.6071612834930420e+00F, 
2.7453591823577881e+00F, 
2.9320304393768311e+00F
#endif


  -1.42492175102234F,
  -0.60102242231369F,
   0.04660389199853F,
   0.58741033077240F,
   0.95356029272079F,
   1.25348472595215F,
   1.55513036251068F,
   1.82637035846710F,
   2.09570789337158F,
   2.35816240310669F,
   2.64766025543213F,
   2.82875895500183F,
   2.98835730552673F,
   3.16677069664001F,
   3.38036823272705F,
   3.59256410598755F,
   3.80499148368835F,
   4.01020240783691F,
   4.20326137542725F,
   4.38750076293945F,
   4.56415271759033F,
   4.73127698898315F,
   4.89598369598389F,
   5.05491542816162F,
   5.21471071243286F,
   5.37983751296997F,
   5.55446529388428F,
   5.73179244995117F,
   5.92647361755371F,
   6.14225721359253F,
   6.39957857131958F,
   6.75436258316040F
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\g6lgrt29.h ===
-1.1573572159F,
0.0311178546F,
0.4118664265F,
0.6462672353F,
0.8399616480F,
1.0402206182F,
1.2170730829F,
1.4002740383F,
1.5516121387F,
1.6699004173F,
1.7841913700F,
1.8959027529F,
2.0334069729F,
2.1768398285F,
2.3219175339F,
2.4712705612F,
2.6216845512F,
2.7293775082F,
2.8194236755F,
2.9072728157F,
2.9978315830F,
3.0941405296F,
3.1866173744F,
3.2890675068F,
3.3981750011F,
3.5045354366F,
3.6005048752F,
3.6937422752F,
3.7866163254F,
3.8750576973F,
3.9681460857F,
4.0602364540F,
4.1479496956F,
4.2390737534F,
4.3296275139F,
4.4196667671F,
4.5085020065F,
4.5963339806F,
4.6800575256F,
4.7683343887F,
4.8563127518F,
4.9429001808F,
5.0254807472F,
5.1116900444F,
5.1980996132F,
5.2861428261F,
5.3727540970F,
5.4640617371F,
5.5608406067F,
5.6558752060F,
5.7559304237F,
5.8625826836F,
5.9733257294F,
6.0858697891F,
6.2038292885F,
6.3245534897F,
6.4531941414F,
6.5795578957F,
6.7219591141F,
6.8799505234F,
7.0567741394F,
7.2544922829F,
7.4606642723F,
7.7259564400F,
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\g6lg.h ===
-1.1573572159F,
0.0311178546F,
0.4118664265F,
0.6462672353F,
0.8399616480F,
1.0402206182F,
1.2170730829F,
1.4002740383F,
1.5516121387F,
1.6699004173F,
1.7841913700F,
1.8959027529F,
2.0334069729F,
2.1768398285F,
2.3219175339F,
2.4712705612F,
2.6216845512F,
2.7293775082F,
2.8194236755F,
2.9072728157F,
2.9978315830F,
3.0941405296F,
3.1866173744F,
3.2890675068F,
3.3981750011F,
3.5045354366F,
3.6005048752F,
3.6937422752F,
3.7866163254F,
3.8750576973F,
3.9681460857F,
4.0602364540F,
4.1479496956F,
4.2390737534F,
4.3296275139F,
4.4196667671F,
4.5085020065F,
4.5963339806F,
4.6800575256F,
4.7683343887F,
4.8563127518F,
4.9429001808F,
5.0254807472F,
5.1116900444F,
5.1980996132F,
5.2861428261F,
5.3727540970F,
5.4640617371F,
5.5608406067F,
5.6558752060F,
5.7559304237F,
5.8625826836F,
5.9733257294F,
6.0858697891F,
6.2038292885F,
6.3245534897F,
6.4531941414F,
6.5795578957F,
6.7219591141F,
6.8799505234F,
7.0567741394F,
7.2544922829F,
7.4606642723F,
7.7259564400F,
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\g6lgrt28.h ===
-1.1573572159F,
0.0311178546F,
0.4118664265F,
0.6462672353F,
0.8399616480F,
1.0402206182F,
1.2170730829F,
1.4002740383F,
1.5516121387F,
1.6699004173F,
1.7841913700F,
1.8959027529F,
2.0334069729F,
2.1768398285F,
2.3219175339F,
2.4712705612F,
2.6216845512F,
2.7293775082F,
2.8194236755F,
2.9072728157F,
2.9978315830F,
3.0941405296F,
3.1866173744F,
3.2890675068F,
3.3981750011F,
3.5045354366F,
3.6005048752F,
3.6937422752F,
3.7866163254F,
3.8750576973F,
3.9681460857F,
4.0602364540F,
4.1479496956F,
4.2390737534F,
4.3296275139F,
4.4196667671F,
4.5085020065F,
4.5963339806F,
4.6800575256F,
4.7683343887F,
4.8563127518F,
4.9429001808F,
5.0254807472F,
5.1116900444F,
5.1980996132F,
5.2861428261F,
5.3727540970F,
5.4640617371F,
5.5608406067F,
5.6558752060F,
5.7559304237F,
5.8625826836F,
5.9733257294F,
6.0858697891F,
6.2038292885F,
6.3245534897F,
6.4531941414F,
6.5795578957F,
6.7219591141F,
6.8799505234F,
7.0567741394F,
7.2544922829F,
7.4606642723F,
7.7259564400F,
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\g6rt24.h ===
/****** 6 bit ***/
-3.5379961016968786e-01F, 
-1.8885760339060420e-02F, 
1.8012833711310328e-01F, 
2.6406246539755762e-01F, 
3.1513071176215113e-01F, 
3.6259517189665735e-01F, 
4.0851123747034968e-01F, 
4.5652009662791193e-01F, 
5.0886198249264658e-01F, 
5.5633644875689447e-01F, 
5.9619093569546044e-01F, 
6.3296368647917212e-01F, 
6.6953241196080149e-01F, 
7.0540432002945841e-01F, 
7.4319118377371729e-01F, 
7.8223769482775629e-01F, 
8.2389415916605890e-01F, 
8.6135333892508448e-01F, 
8.9546036836310328e-01F, 
9.2784261819525660e-01F, 
9.6055039879485071e-01F, 
9.9266809341116846e-01F, 
1.0245226633231252e+00F, 
1.0577783596198171e+00F, 
1.0930733394305319e+00F, 
1.1311194014231771e+00F, 
1.1684746455828756e+00F, 
1.2049383830706686e+00F, 
1.2432096910159200e+00F, 
1.2805303048770040e+00F, 
1.3165954661051840e+00F, 
1.3552066397349447e+00F, 
1.3934678148905844e+00F, 
1.4299021672885031e+00F, 
1.4665307712237448e+00F, 
1.5025673222224325e+00F, 
1.5390558552424520e+00F, 
1.5741507720629782e+00F, 
1.6090665173213095e+00F, 
1.6453252148310751e+00F, 
1.6818663191477865e+00F, 
1.7184063505808920e+00F, 
1.7539425205866903e+00F, 
1.7894351792018026e+00F, 
1.8252749752680868e+00F, 
1.8635795426051229e+00F, 
1.9015041899363607e+00F, 
1.9389577221552938e+00F, 
1.9784620117823690e+00F, 
2.0192251515071007e+00F, 
2.0593760323206993e+00F, 
2.1014784884135338e+00F, 
2.1440490793864342e+00F, 
2.1886680435816857e+00F, 
2.2338737559001061e+00F, 
2.2823721480052086e+00F, 
2.3341535639445397e+00F, 
2.3918800663630577e+00F, 
2.4542773079554649e+00F, 
2.5248586249034020e+00F, 
2.6134692740122887e+00F, 
2.7145818781535240e+00F, 
2.8443574022929283e+00F, 
3.0357472014109703e+00F
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\gain6bit.h ===
/******************************************************************************
*                        Voxware Proprietary Material
*                        Copyright 1996, Voxware, Inc
*                            All Rights Reserved
*
*                       DISTRIBUTION PROHIBITED without
*                      written authorization from Voxware
******************************************************************************/
 
/******************************************************************************
* Filename:    Gain6bit.h
*
* Purpose:     gain codebook for CodeGain.c
*
* $Header:   /export/phobos/pvcs/r_and_d/archives/scaleable/tables/Gain6bit.h_v   1.0   06 Feb 1998 10:12:30   johnp  $
*
******************************************************************************/
#ifndef _GAIN6BIT_H_
#define _GAIN6BIT_H_
 -2.6784650e+000F,
 -1.8227140e+000F,
 -1.3836860e+000F,
 -1.0736360e+000F,
 -7.5958200e-001F,
 -4.6916800e-001F,
 -1.9299000e-001F,
  9.6286000e-002F,
  3.3732600e-001F,
  5.5046300e-001F,
  7.4868100e-001F,
  9.6338100e-001F,
  1.1878270e+000F,
  1.4110520e+000F,
  1.6634200e+000F,
  1.9263550e+000F,
  2.1718400e+000F,
  2.3517910e+000F,
  2.5169470e+000F,
  2.6869390e+000F,
  2.8491960e+000F,
  3.0164870e+000F,
  3.1949700e+000F,
  3.3850080e+000F,
  3.5813650e+000F,
  3.7719620e+000F,
  3.9438350e+000F,
  4.1186750e+000F,
  4.2966280e+000F,
  4.4657100e+000F,
  4.6338540e+000F,
  4.8228860e+000F,
  4.9861840e+000F,
  5.1613500e+000F,
  5.3268450e+000F,
  5.5057220e+000F,
  5.6709640e+000F,
  5.8348190e+000F,
  6.0047960e+000F,
  6.1615580e+000F,
  6.3285040e+000F,
  6.4911940e+000F,
  6.6553800e+000F,
  6.8313820e+000F,
  7.0066350e+000F,
  7.1881190e+000F,
  7.3640340e+000F,
  7.5506080e+000F,
  7.7288190e+000F,
  7.9082850e+000F,
  8.0859880e+000F,
  8.2683710e+000F,
  8.4579970e+000F,
  8.6522580e+000F,
  8.8719320e+000F,
  9.1038260e+000F,
  9.3399930e+000F,
  9.5890820e+000F,
  9.8576100e+000F,
  1.0150709e+001F,
  1.0453777e+001F,
  1.0812710e+001F,
  1.1228319e+001F,
  1.1725975e+001F,
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\getnharm.h ===
/*******************************************************************************
*                        Voxware Proprietary Material                          *
*                        Copyright 1996, Voxware, Inc                          *
*                            All Rights Reserved                               *
*                                                                              *
*                       DISTRIBUTION PROHIBITED without                        *
*                      written authorization from Voxware                      *
*******************************************************************************/

/*******************************************************************************
* Filename:       GetnHarm.h                                                            
*                                                                              
* Purpose:        Provide a consistent means of calculating the number of 
*                 harmonics.                                                             
*    
*                                                                              
* Author/Date:    Rob Zopf   02/01/97                                                           
********************************************************************************
* Modifications:                                                                 
*                                                                              
* Comments: the way that it is currently calculated is bogus, and should be 
*           changed, but it is the way it is currently calculated, and I want
*           it to be same for comparison. 
* 
* Concerns: 
*******************************************************************************/
#ifndef GETNHARM_H
#define GETNHARM_H

short getnHarm(float Pitch);
short getvHarm(float Pitch, float Pv);
float getPv(short iVHarm, short nHarm);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\hamming.c ===
/***********************************************************************
 *
 * Filename:  hamming.c
 *
 * Purpose:   calculate Hamming window.
 *
 * Author:    Wei Wang
 *
 * Date:      Oct. 09, 1996
 *
 ***********************************************************************/

#include <math.h>

#include "hamming.h"

#include "xvocver.h"


#ifndef M_PI
#define M_PI            3.14159265358979323846
#endif


void hamming(float *win, short N)
{
  double tmp = 2.0 * M_PI /  ((double)N - 1.0);
  int i;
  
  for (i = 0; i < N; i++)
    win[i] = (float)(0.54 - 0.46 * cos(tmp * (double)i));
}


void hamming_half(float *win, short N)
{
  double tmp = 2.0 * M_PI /  ((double)N - 1.0);
  short half_N = (short)(N >> 1);
  int i;

  for (i = 0; i < half_N; i++)
    win[i] = (float)(0.54 - 0.46 * cos(tmp * (double)i));
}



void hamming_right(float *win, short N)
{
  double tmp = 2.0 * M_PI /  ((double)N - 1.0);
  short half_N = (short)((N+1) >> 1);
  int i;

  for (i = half_N; i < N; i++)
    *win++ = (float)(0.54 - 0.46 * cos(tmp * (double)i));
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\getnharm.c ===
/*******************************************************************************
*                        Voxware Proprietary Material                          *
*                        Copyright 1996, Voxware, Inc                          *
*                            All Rights Reserved                               *
*                                                                              *
*                       DISTRIBUTION PROHIBITED without                        *
*                      written authorization from Voxware                      *
*******************************************************************************/

/*******************************************************************************
* Filename:       GetnHarm.c                                                             
*                                                                              
* Purpose:        Provide a consistent means of calculating the number of 
*                 harmonics.                                                             
*    
*                                                                              
* Author/Date:    Rob Zopf   02/01/97
********************************************************************************
* Modifications: Wei Wang 02/25/97, change all the cast through math library floor(). 
*                                                                              
* Comments: the way that it is currently calculated is bogus, and should be 
*           changed, but it is the way it is currently calculated, and I want
*           it to be same for comparison. 
* 
* Concerns: 
*******************************************************************************/

#include <stdlib.h>
#include <math.h>
#include <string.h>
#include <limits.h>

#include "model.h"

#include "GetnHarm.h"

#include "xvocver.h"


short getnHarm(float Pitch)
{
   short nHarm;
   nHarm        = (short)floor(Pitch*0.5F*ARBITRARY_CUTOFF);   /* 255/(512/pitch) */
   return(nHarm);
}

short getvHarm(float Pitch, float Pv)
{
   short nHarm;
   nHarm        = (short)floor(Pitch*0.5F*ARBITRARY_CUTOFF);   /* 255/(512/pitch) */
   nHarm        = (short)floor((float)nHarm*Pv+0.5F);
   return(nHarm);
}

float getPv(short iVHarm, short nHarm)
{
  float Pv;

  if (nHarm <= 0) Pv = 0.0F;      /* should never happen */
  Pv=(float)(iVHarm)/(float)nHarm;

  if (Pv > 1.0F)   Pv = 1.0F;     /* should never happen too! */
  return Pv;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\hamming.h ===
#ifndef _HAMMING_H_
#define _HAMMING_H_

/***********************************************************************
 *
 * Filename:  hamming.h
 *
 * Purpose:   calculate Hamming window.
 *
 * Author:    Wei Wang
 *
 * Date:      Oct. 09, 1996
 *
 ***********************************************************************/

void hamming(float *win, short N);

void hamming_half(float *win, short N);

void hamming_right(float *win, short N);

#endif /* end of #ifndef _HAMMING_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\hasc.h ===
/*******************************************************************************
*                        Voxware Proprietary Material                          *
*                        Copyright 1997, Voxware, Inc                          *
*                            All Rights Reserved                               *
*                                                                              *
*                       DISTRIBUTION PROHIBITED without                        *
*                      written authorization from Voxware                      *
*******************************************************************************/

/*******************************************************************************
* Filename:       HASC.c
*                                                                              
* Purpose:        Compute the harmonic amplitudes.
*                                                                              
* Functions:  void HASC_pwr(float *power, short iStartHarm, short iEndHarm, float pitch,
	      float *pAmp, short nfft, short nwin);
*
* Author:   Wei Wang, 2/24/97 based on Gerard's HASC algorithm.
*
********************************************************************************
* Modification:
*                                                                              
* Comments:                                                                    
* 
* Concerns:   Maximum Bandwidth should depend on FFT points, length of window and
*             window type.
*
* $Header:   /export/phobos/pvcs/r_and_d/archives/realtime/utils/HASC.h_v   1.0   26 Jan 1998 11:20:14   johnp  $
*******************************************************************************/
#ifndef _HASC_H_
#define _HASC_H_

#define NFFT_BW                512
#define MAX_BW                 4          /* the maximum bandwidth is 4 for 512 points FFT */
#define HASC_SHIFT             22
#define FIXED_POINT_INDEX_HASC      1
/*
 * calculate power of harmonic amplitude using Gerard's HASC algorithm.
 *
 */
void HASC_pwr(float *power, short iStartHarm, short iEndHarm, float pitch,
	      float *pAmp, short nfft, short nwin);

#endif
/*ifndef _HASC_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\harmsynf.c ===
/*****************************************************************************
 *                        Voxware Proprietary Material                       *
 *                        Copyright 1996, Voxware Inc.                       *
 *                        All Rights Reserved                                *
 *                                                                           *
 *                        DISTRIBUTION PROHIBITED without                    *
 *                        written authorization from Voxware.                *
 *****************************************************************************/

/*****************************************************************************
 * FILE      : HarmSynFloat.c
 *
 * CONTAINS  : Synthesis of input harmonics
 *
 * CREATION  : 11/7/96
 *
 * AUTHOR    : Bob Dunn (derived from Rob Zopf's code for fixed point FHT) 
 *
 * $Header:   /export/phobos/pvcs/r_and_d/archives/realtime/decode/HarmSynF.c_v   1.5   20 Apr 1998 14:40:16   weiwang  $
 *****************************************************************************/

#include <math.h>
#include <string.h>
#include <assert.h>
#include <stdlib.h>

#include "vLibTran.h" /* VoxFHTkrnl()      */
#include "vLibFilt.h" /* PolyCycleIntp()       */
#include "vLibVec.h"  /* OlAdd()           */
#include "vLibMath.h"

#include "model.h"
#include "VoxMem.h"

#include "HarmSynF.h"

#include "xvocver.h"

#if USE_FHT_SYN==1
const static float fFHTWeights64[] = {
#include "FHTW64.h"      
};

const static float fFHTWeights128[] = {
#include "FHTW128.h"      
};

extern const float *sinTBL;
extern const float *cosTBL;

/*****************************************************************************
 * FUNCTION    : HarmSyn()
 *
 * PURPOSE     : Synthesis of speech harmonics and phases
 *
 * INPUT
 *     pfAmps     - harmonic amplitudes
 *     piPhases   - harmonic phases at the current frame boundary (0-2PI)
 *     fPitch     - time-domain pitch lag
 *     fVPitch    - the original voiced pitch (before sub-multiple change)
 *     fNormPhase - the pitch-dependent linear phase for FHT for fPitch
 *     fVoicePhase - the linear-phase for FHT for fVPitch
 *     fResampRate - pitch-dependent resampling rate for pitch cycle interpolation
 *     nHarm      - number of harmonics to synthesize
 *     pfPrevSyn  - previous synthesis buffer for use in current frame
 *     pfOutBuf   - output buffer for synthesized harmonics
 *     frameLEN   - synthesis frame length
 *     olLEN      - overlap length 
 *
 * OUTPUT
 *     pfOutBuf   - synthesized harmonics
 *     pfPrevSyn  - updated for use next time
 *     fNormPhase   - updated FHT linear phase
 *     fVoicePhase - updated FHT linear phase for fVPitch
 *     fResampRate - updated resampling ratio
 *
 *
 * AUTHOR      : Rob Zopf
 *
 * DATE        : 11/7/96
 *
 * SPECIAL NOTES : This routine ACCUMULATES into pfOutBuf.  If needed, pfOutBuf
 *                 should be set to zero prior to calling this routine.
 *
 * WARNING     :   frameLEN+olLEN MUST BE EVEN !!!!
 *
 * MODIFICATION HISTORY :
 *
 *
 ******************************************************************************/
void HarmSynFHTFloat ( STACK_R
                       float    *pfAmps,
                       int    *piPhases,
                       float     fPitch,
                       float     fVPitch,
                       float     fVPitch_1,
                       float    *fNormPhase,
                       float    *fVoicePhase,
                       float    *fResampRate,
                       short     nHarm,
                       float    *fPitchCycle,
                       float    *pfOutBuf,
                       short     frameLEN,
                       short     olLEN
                )
{
   STACK_INIT
   float  fSynBuf[MAXSYNLEN];  /* scratch */
   float  pfPrevSyn[MAXSYNLEN];  /* scratch */
   STACK_INIT_END
   STACK_ATTACH(float*,fSynBuf)
   STACK_ATTACH(float*,pfPrevSyn)
   short  synLEN;
   float  *fFHTWeights;
   short  exp_size;
   short  exp_shift;
   short  maxHarm;

   STACK_START

   maxHarm = MAXHARM;


   if (maxHarm < 64 )
   {
      fFHTWeights = (float *)fFHTWeights64;
      exp_shift = 7;
      exp_size = 1<<exp_shift;
   }
   else
   {
      fFHTWeights = (float *)fFHTWeights128;
      exp_shift = 8;
      exp_size = 1<<exp_shift;
   }

 /*---------------------------------------------
    Make sure that frameLEN+olLEN is even
   ---------------------------------------------*/
   if (((olLEN+frameLEN)&1)==1)
      olLEN--;

 /*---------------------------------------------
    Make sure that frameLEN >= olLEN 
   ---------------------------------------------*/
   if (olLEN>frameLEN)
      olLEN=frameLEN;

   synLEN   = olLEN + ((frameLEN-olLEN)>>1);

 /*----------------------------------------------------
    Perform the synthesis (for now, use either 
    sum of sinusoids or FHT )
   ----------------------------------------------------*/ 
   *fNormPhase = PolyCycleIntp(pfPrevSyn, (int)synLEN, fPitchCycle+PP_DELAY,
                               (int)exp_shift, *fResampRate, *fNormPhase);

   VoxFHTkrnl(pfAmps, piPhases, (int)nHarm, fPitchCycle+1, 
              (int) exp_shift, fFHTWeights, sinTBL, cosTBL);

/*--------------------------------------------------
   Now sample the pitch epoch using a polyphase 
   filter to get our waveform ...
  --------------------------------------------------*/
   *fResampRate = (float)(exp_size)/fPitch;

   *fNormPhase = *fVoicePhase + (float)(synLEN-olLEN)/fVPitch_1;
   *fNormPhase *= (fVPitch/fPitch);

   *fNormPhase = PolyCycleIntp(fSynBuf, (int)synLEN, fPitchCycle+PP_DELAY,
                               (int)exp_shift, *fResampRate, *fNormPhase);

   *fVoicePhase += (float)frameLEN/((fVPitch+fVPitch_1)*0.5F);
   *fVoicePhase -= (float)(VoxFLOOR(*fVoicePhase)); /* mod phase to get fractional part */

 /*----------------------------------------------------
     Do overlap-add of buffers ...
   ----------------------------------------------------*/
   OlAdd(pfPrevSyn, fSynBuf, (const int) olLEN, (const int) frameLEN, pfOutBuf);

   STACK_END
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\harmsynf.h ===
/*****************************************************************************
 *                        Voxware Proprietary Material                       *
 *                        Copyright 1996, Voxware Inc.                       *
 *                        All Rights Reserved                                *
 *                                                                           *
 *                        DISTRIBUTION PROHIBITED without                    *
 *                        written authorization from Voxware.                *
 *****************************************************************************/

/*****************************************************************************
 * FILE      : HarmSynFloat.h
 *
 * CONTAINS  : Synthesis of input harmonics
 *
 * CREATION  : 12/7/96
 *
 * AUTHOR    : Bob Dunn (derived from Rob Zopf's code for fixed point FHT) 
 *
 * $Header:   /export/phobos/pvcs/r_and_d/archives/realtime/decode/HarmSynF.h_v   1.1   02 Mar 1998 10:30:58   weiwang  $
 *
 *****************************************************************************/

#ifndef HARMSYNFLOAT_H
#define HARMSYNFLOAT_H
void HarmSynFHTFloat ( STACK_R
                       float    *pfAmps,
                       int    *piPhases,
                       float     fPitch,
                       float     fVPitch,
                       float     fVPitch_1,
                       float    *fNormPhase,
                       float    *fVoicePhase,
                       float    *fResampRate,
                       short     nHarm,
                       float    *fPitchCycle,
                       float    *pfOutBuf,
                       short     frameLEN,
                       short     olLEN
                );


#endif /* HARMSYNFLOAT_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\hfregen.c ===
/******************************************************************************
*                        Voxware Proprietary Material
*                        Copyright 1996, Voxware, Inc
*                            All Rights Reserved
*
*                       DISTRIBUTION PROHIBITED without
*                      written authorization from Voxware
******************************************************************************/

/******************************************************************************
*
* Filename:     HFRegen.c
*
* Purpose:   Subroutine of "DecSTC.c" to compute the parameters of the
*               excitation phase, the onset phase and the phase offset (a
*               poor man's glottal pulse) from the quantized STFT phases
*               received at the synthesizer. The excitation phases are
*               computed by subtracting the quantized minimum-phase
*               system phase from the measured phase. The onset-phase,
*               the phase of the fundamental, 
*               is estimated using nonlinear processing. The
*               phase offset is then computed by fitting the straight-line
*               phase to the measured excitation phases. 
*
* Functions:  VoxHFRegeneration(), VoxInitHFRegen(), VoxFreeHFRegen()
*
* Author/Date:  Bob McAulay 21-Mar-97
*
*******************************************************************************
*
* Modifications:
*
* Comments:
*
* Concerns:
*
* $Header:   /export/phobos/pvcs/r_and_d/archives/scaleable/decode/HFRegen.c_v   1.7   12 Apr 1998 10:36:54   bobd  $
*
******************************************************************************/
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <assert.h>

#include "vLibMath.h"

#include "VoxMem.h"
#include "codec.h"
#include "rate.h"
#include "trigSC.h"

#include "HFRegen.h"

#include "xvocver.h"

/*-----------------------------------------------------------------
  Sine and cosine tables
-----------------------------------------------------------------*/
extern const float *sinTBL_32;
extern const float *cosTBL_32;
extern const float fRadiansToIndex;

/*-----------------------------------------------------------------
  Amplitude compression for phase coding
-----------------------------------------------------------------*/
#define GAMMA_HFREGENERATION 0.250F  /** was 0.250 **/
 
/*-----------------------------------------------------------------
  Limit bandwidth for onset phase estimation due to 
    minimum phase=0 at PI
-----------------------------------------------------------------*/
#define BANDWIDTH_HFREGENERATION 3000.0F  /** was 1250.0F **/
#define BANDLIMIT                (BANDWIDTH_HFREGENERATION*HZ2DFT)
 
/*-----------------------------------------------------------------
  private structure
-----------------------------------------------------------------*/
typedef struct {
   float fOnsetPhase_1;
   float fBeta_1;
   float fBetaOffset;
   float fPhaseOffset;
   float fPitchDFT_1;
} HFRegenStruct;

/*-----------------------------------------------------------------
  local functions
-----------------------------------------------------------------*/ 
static float fComputeOnsetPhase( STACK_R 
                                 int    iBasePeaks, 
                                 float *pfRE, 
                                 float *pfIM
                               );

static float fComputeBeta( int    iBasePeaks, 
                           float *pfExcitationPhase, 
                           float *pfAmp, 
                           float  fOnsetPhase
                          );

static void SC6Excitation( STACK_R
                           HFRegenStruct *pHFRegenMblk,
                           int            iHarmonics,
                           float          fPitchDFT,
                           int            iSynSamples,
                           int            iUpdatePhaseOffsetFlag,
                           const float    *pfLogAmp,
                           const float    *pfMinPhase,
                           float         *pfVEVphase,
                           float         *pfOnsetPhase,
                           float         *pfBeta
                         );

/*******************************************************************************
*
* Function:  VoxHFRegeneration()
*
* Action:    Generate excitation phase parameters for synthetic phase and mixed
*              synthetic/measured phase systems.
*
* Input:     void  *hHFRegenMblk           -> frame-to frame memory block
*            float *pfVEVphase             -> measures phases in
*            float  fPitchDFT              -> pitch in DFT samples
*            float *pfLogAmp               -> harmonic log magnitudes
*            float *pfMinPhase             -> harmonic minimum-phase phases
*            int    iHarmonics             -> number of harmonics
*            int    iSCRate                -> coding rate flag (3.2k/6.4k)
*            int    iSynSamples            -> number of samples to synthesize
*            int    iUpdatePhaseOffsetFlag -> flag for updating phase offset
*
* Output:    void  *hHFRegenMblk           -> Updated structure
*            float *pfVEVphase             -> measured phase residuals out
*            float *pfOnsetPhase           -> onset phase
*            float *pfBeta                 -> beta value
*
* Globals:   none
*
* Return:    void
********************************************************************************
*
* Modifications:
*
* Comments:  
*
* Concerns/TBD:
*******************************************************************************/

void VoxHFRegeneration( STACK_R 
                        void  *hHFRegenMblk,
                        float *pfVEVphase,
                        float  fPitchDFT,
                        const float *pfLogAmp,
                        const float *pfMinPhase,
                        int    iHarmonics,
                        float *pfOnsetPhase,
                        float *pfBeta,
                        int    iSCRate,
                        int    iSynSamples,
                        int    iUpdatePhaseOffsetFlag
                      )
{
   HFRegenStruct *pHFRegenMblk = (HFRegenStruct*) hHFRegenMblk;

   int   iMhat;

   float fOnsetPhase;
   float fBeta;
   float fDeltaPhase;
   float ftmp;

   assert(hHFRegenMblk != NULL && pfLogAmp != NULL && pfMinPhase != NULL);
   assert(pfOnsetPhase != NULL && pfBeta != NULL);
   
   /*------------------------------------------------------------------------
     Compute the onset phase for 3kb/s using quadratic prediction
   ------------------------------------------------------------------------*/
   if(iSCRate == SC_RATE_3K)
   {
      /*---------------------------------------------------------------------
        Apply quadratic phase projection
      ---------------------------------------------------------------------*/
      fDeltaPhase =  0.5F*TWOPIONFFT*(fPitchDFT+pHFRegenMblk->fPitchDFT_1)
                     *iSynSamples;
      fOnsetPhase = pHFRegenMblk->fOnsetPhase_1 + fDeltaPhase;

      /*---------------------------------------------------------------------
        Use previous Beta value for consistency
      ---------------------------------------------------------------------*/
      fBeta = pHFRegenMblk->fBeta_1;

   } else {

      SC6Excitation( STACK_S pHFRegenMblk, iHarmonics, fPitchDFT, iSynSamples, 
                     iUpdatePhaseOffsetFlag, pfLogAmp, pfMinPhase, pfVEVphase, 
                     &fOnsetPhase, &fBeta);

   }

   /*-----------------------------------------------------------------------
     Compute modulo 2PI of the onset phase
   -----------------------------------------------------------------------*/
   ftmp=fOnsetPhase*INVTWOPI;
   VoxROUND2(ftmp,iMhat);
   fOnsetPhase -= iMhat*TWOPI;

   /*-----------------------------------------------------------------------
     Set output parameter values
   -----------------------------------------------------------------------*/
   *pfOnsetPhase = fOnsetPhase;
   *pfBeta       = fBeta;

   /*-----------------------------------------------------------------------
     Save for next time
   -----------------------------------------------------------------------*/
   pHFRegenMblk->fOnsetPhase_1 = fOnsetPhase;
   pHFRegenMblk->fPitchDFT_1   = fPitchDFT;

} /*VoxHFRegen*/

/*******************************************************************************
*
* Function:  VoxInitHFRegen()
*
* Action:    Initialize memory block for VoxHFRegeneration()
*
* Input:     void **hHFRegenMblk  -> pointer to memory block (invalid)
*
* Output:    void **hHFRegenMblk  -> pointer to memory block (hopefully valid)
*
* Globals:   none
*
* Return:    unsigned short (0/1 success/fail)
********************************************************************************
*
* Modifications:
*
* Comments:  
*
* Concerns/TBD:
*******************************************************************************/

unsigned short VoxInitHFRegen(void **hHFRegenMblk)
{
   HFRegenStruct  *pHFRegenMblk;
   unsigned short  usStatus = 0;

   if(VOX_MEM_INIT(pHFRegenMblk=*hHFRegenMblk,1, sizeof(HFRegenStruct)))
   {
      usStatus = 1;
   } else {

    /*---------------------------------------------------------------
      VOX_MEM_INIT sets pHFRegenMblk to zero on the Sun and PC, so
      to reduce code size we can skip the next four lines of code.
      On some platforms this code will be necessary.

      pHFRegenMblk->fOnsetPhase_1 = 0.0F;
      pHFRegenMblk->fBeta_1       = 0.0F;
      pHFRegenMblk->fBetaOffset   = 0.0F;
      pHFRegenMblk->fPhaseOffset  = 0.0F;
    ---------------------------------------------------------------*/
      pHFRegenMblk->fPitchDFT_1   = (float)INITIAL_PITCH_DFT; 
   }

   return usStatus;
} /* VoxInitHFRegen */

/*******************************************************************************
*
* Function:  VoxFreeHFRegen()
*
* Action:    Free memory block for VoxHFRegeneration()
*
* Input:     void **hHFRegenMblk  -> pointer to memory block (hopefully valid)
*
* Output:    none
*
* Globals:   none
*
* Return:    unsigned short (0 for always successful)
********************************************************************************
*
* Modifications:
*
* Comments:  
*
* Concerns/TBD:
*******************************************************************************/

void VoxFreeHFRegen(void **hHFRegenMblk)
{
   if (*hHFRegenMblk)
      VOX_MEM_FREE(*hHFRegenMblk);
} /* VoxFreeHFRegen */

/*******************************************************************************
*
* Function:  fComputeOnsetPhase()
*
* Action:    Compute the onset phase from real and imaginary parts of 
*              baseband peaks.
*
* Input:     int    iBasePeaks  -> number of baseband peaks
*            float *pfRE        -> real part of baseband peaks
*            float *pfIM        -> imaginary part of baseband peaks
*
* Output:    none
*
* Globals:   none
*
* Return:    float fOnsetPhase  -> the onset phase
********************************************************************************
*
* Modifications:
*
* Comments:  
*
* Concerns/TBD:
*******************************************************************************/

static float fComputeOnsetPhase(STACK_R int    iBasePeaks, 
                                        float *pfRE, 
                                        float *pfIM)
{
   int   j, k;
   int   iIndex;
   int   iMhat;
   float fOnsetPhase;
   float fNewOnsetPhase;
   float fTemp1;
   float fTemp2;
   float ftmp;

STACK_INIT
   float fXR[SC6_PHASES];
   float fYR[SC6_PHASES];
STACK_INIT_END

   STACK_ATTACH(float *, fXR)
   STACK_ATTACH(float *, fYR)

   STACK_START

   /*-----------------------------------------------------------------------
     Compute the onset time for the first phase difference 
   -----------------------------------------------------------------------*/
   memset(fXR, 0, SC6_PHASES*sizeof(float));
   memset(fYR, 0, SC6_PHASES*sizeof(float));

   for (j = 0; j < iBasePeaks; j++)
   {  
     for (k=j+1, iIndex=1; k < iBasePeaks; k++, iIndex++)
      {
         fXR[iIndex] += (pfRE[j]*pfRE[k] + pfIM[j]*pfIM[k]);
         fYR[iIndex] += (pfRE[j]*pfIM[k] - pfIM[j]*pfRE[k]); 
      }
   }
   fOnsetPhase = VoxATAN2(fYR[1], fXR[1]);


   /*-----------------------------------------------------------------------
       Compute the onset time for the 2nd-order phase difference 
   -----------------------------------------------------------------------*/
   fTemp2 = 2.0F*fOnsetPhase;
   fTemp1 = VoxATAN2(fYR[2], fXR[2]);
   ftmp = (fTemp2 - fTemp1)*INVTWOPI;
   VoxROUND2(ftmp, iMhat);
   fNewOnsetPhase = 0.5F*(fTemp1 + (float)iMhat*TWOPI);
   fOnsetPhase = 0.5F*(fOnsetPhase + fNewOnsetPhase);

   STACK_END

   return fOnsetPhase;
} /* fComputeOnsetPhase */

/*******************************************************************************
*
* Function:  fComputeBeta()
*
* Action:    Compute Beta (the phase offset at DC)
*
* Input:     int    iBasePeaks        -> number of basaeband peaks
*            float *pfExcitationPhase -> excitation phases
*            float *pfAmp             -> amplitudes (compressed, but not log 2)
*            float  fOnsetPhase       -> estimated onset phase
*
* Output:    none
*
* Globals:   none
*
* Return:    float fBeta (the phase offset at DC)
********************************************************************************
*
* Modifications:
*
* Comments:  
*
* Concerns/TBD:
*******************************************************************************/

static float fComputeBeta( int    iBasePeaks, 
                           float *pfExcitationPhase, 
                           float *pfAmp, 
                           float  fOnsetPhase)
{
   int   j;
   int   iResPhase;
   float fRESum = 0.0F;
   float fIMSum = 0.0F;
   float fModelPhase = 0.0F;
   float fResPhase;
   float fBeta;

   for (j = 0; j < iBasePeaks; j++)
   {
      /*-------------------------------------------------
        Compute residual phase
      -------------------------------------------------*/
      fModelPhase += fOnsetPhase;
      fResPhase = pfExcitationPhase[j] - fModelPhase;

      /*-------------------------------------------------
        Compute trig table index.

        NOTE: This assumes a 2's complement integer
              representation.  Using the trig mask 
              (iResPhase&TRIG_MASK) yeilds the correct
              positive index, even if iResPhase is
              negative.  This would not be true for
              signed magnitude integer representation.
      -------------------------------------------------*/
      fResPhase *= fRadiansToIndex;
      VoxROUND2( fResPhase, iResPhase );
      iResPhase &= TRIG_MASK;

      /*-------------------------------------------------
        Accumulate real and imaginary parts using
          trig tables
      -------------------------------------------------*/
      fRESum += pfAmp[j]*cosTBL_32[iResPhase];
      fIMSum += pfAmp[j]*sinTBL_32[iResPhase];
   }

   fBeta = VoxATAN2(fIMSum, fRESum);

   return fBeta;
} /* fComputeBeta */

/*******************************************************************************
*
* Function:  SC6Excitation()
*
* Action:    Compute onset phase, beta factor and measured phase residuals
*              for generation of excitation phase in SC6.
*
* Input:     HFRegenStruct *pHFRegenMblk  -> frame-to frame memory block
*            int            iHarmonics    -> number of harmonics
*            float          fPitchDFT     -> pitch in DFT samples
*            int            iSynSamples   -> number of samples to synthesize
*            float         *pfLogAmp      -> harmonics log amplitudes
*            float         *pfMinPhase    -> harmonic minimum-phase phases
*            float         *pfVEVphase    -> measured phases (in)
*            int            iUpdatePhaseOffsetFlag -> update phase offset flag
*
* Output:    float         *pfOnsetPhase  -> the onset phase
*            float         *pfBeta        -> Beta (DC phase offset)
*            float         *pfVEVphase    -> measured phase residuals (out)
*
* Globals:   none
*
* Return:    void
********************************************************************************
*
* Modifications:
*
* Comments:  
*
* Concerns/TBD:
*******************************************************************************/

static void SC6Excitation( STACK_R 
                           HFRegenStruct *pHFRegenMblk, 
                           int            iHarmonics, 
                           float          fPitchDFT, 
                           int            iSynSamples, 
                           int            iUpdatePhaseOffsetFlag,
                           const float   *pfLogAmp,
                           const float   *pfMinPhase, 
                           float         *pfVEVphase, 
                           float         *pfOnsetPhase,
                           float         *pfBeta
                         )
{
   int i;
   int iMpeaks;
   int iBasePeaks;
   int iPhase;

   float fFreq;
   float fPhase;
   float fOnsetPhase;
   float fModelPhase;
   float fDeltaPhase;
   float fBeta;
STACK_INIT
   float pfAmp[SC6_PHASES];
   float pfRE[SC6_PHASES];
   float pfIM[SC6_PHASES];
STACK_INIT_END

   STACK_ATTACH(float *, pfAmp)
   STACK_ATTACH(float *, pfRE)
   STACK_ATTACH(float *, pfIM)

STACK_START

   /*-----------------------------------------------------------------------
     Set actual number of measured phases
   -----------------------------------------------------------------------*/
   iMpeaks = VoxMIN( SC6_PHASES, iHarmonics );

   /*-----------------------------------------------------------------------
     Limit bandwidth of onset phase estimator so that it will not be
       affected by the fact that the system phase is zero at PI
   -----------------------------------------------------------------------*/
   for (iBasePeaks=0, fFreq=fPitchDFT; iBasePeaks<iMpeaks; 
        iBasePeaks++, fFreq+=fPitchDFT)
     {
        if (fFreq > BANDLIMIT)
           break;
     }

   /*-----------------------------------------------------------------------
     Compute the real and imaginary parts of the excitation phase
   -----------------------------------------------------------------------*/
   for (i = 0; i < iMpeaks; i++)
   {
      /*-------------------------------------------------
        Remove minimum-phase system phase
      -------------------------------------------------*/
      pfVEVphase[i] -= pfMinPhase[i];

      /*-------------------------------------------------
        Compute trig table index.
 
        NOTE: This assumes a 2's complement integer
              representation.  Using the trig mask 
              (iResPhase&TRIG_MASK) yeilds the correct
              positive index, even if iResPhase is
              negative.  This would not be true for  
              signed magnitude integer representation.
      -------------------------------------------------*/
      fPhase = pfVEVphase[i]*fRadiansToIndex;
      VoxROUND2( fPhase, iPhase );
      iPhase &= TRIG_MASK;

      /*-------------------------------------------------
        Compute real and imaginary parts of compressed 
          amplitude
      -------------------------------------------------*/
      pfAmp[i] = fInvLog2(GAMMA_HFREGENERATION*pfLogAmp[i]);
      pfRE[i]  = pfAmp[i]*cosTBL_32[iPhase];
      pfIM[i]  = pfAmp[i]*sinTBL_32[iPhase];
   }

   /*-----------------------------------------------------------------------
     Compute onset phase
   -----------------------------------------------------------------------*/
   fOnsetPhase = fComputeOnsetPhase(STACK_S iBasePeaks, pfRE, pfIM);

   /*-----------------------------------------------------------------------
        Determine the phase offset at DC 
   -----------------------------------------------------------------------*/
   fBeta = fComputeBeta( iBasePeaks, pfVEVphase, pfAmp, fOnsetPhase);

   /*-----------------------------------------------------------------------
        Compute the phase residuals (NOTE: these are WRAPPED)
   -----------------------------------------------------------------------*/
   fModelPhase = fBeta;
   for (i = 0; i < iMpeaks; i++)
   {
      fModelPhase   += fOnsetPhase;
      pfVEVphase[i] -= fModelPhase;
   }

   /*-----------------------------------------------------------------------
     update phase offset and beta when frame loss occurs
   -----------------------------------------------------------------------*/
   if (iUpdatePhaseOffsetFlag)
   {
      fDeltaPhase =  (0.5F*TWOPIONFFT)*(fPitchDFT+pHFRegenMblk->fPitchDFT_1)
                     *iSynSamples;
      pHFRegenMblk->fPhaseOffset = pHFRegenMblk->fOnsetPhase_1 +
                                   fDeltaPhase - fOnsetPhase;
      
      pHFRegenMblk->fBetaOffset = pHFRegenMblk->fBeta_1 - fBeta;
   }

   fBeta       += pHFRegenMblk->fBetaOffset;
   fOnsetPhase += pHFRegenMblk->fPhaseOffset;

   /*-----------------------------------------------------------------------
     Save this parameter for next time
   -----------------------------------------------------------------------*/
   pHFRegenMblk->fBeta_1 = fBeta;

   /*-----------------------------------------------------------------------
     Set output values
   -----------------------------------------------------------------------*/
   *pfOnsetPhase = fOnsetPhase;
   *pfBeta = fBeta;

STACK_END
} /* SC6Excitation */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\hfregen.h ===
/******************************************************************************
*                        Voxware Proprietary Material
*                        Copyright 1996, Voxware, Inc
*                            All Rights Reserved
*
*                       DISTRIBUTION PROHIBITED without
*                      written authorization from Voxware
******************************************************************************/

/******************************************************************************
*
* Filename:     HFRegen.h
*
* Purpose:   Subroutine of "DecSTC.c" to compute the parameters of the
*               excitation phase, the onset phase and the phase offset (a
*               poor man's glottal pulse) from the quantized STFT phases
*               received at the synthesizer. The excitation phases are
*               computed by subtracting the quantized minimum-phase
*               system phase from the measured phase. The onset-phase,
*               the phase of the fundamental, 
*               is estimated using nonlinear processing. The
*               phase offset is then computed by fitting the straight-line
*               phase to the measured excitation phases. 
*
* Functions:  VoxHFRegeneration(), VoxInitHFRegen(), VoxFreeHFRegen()
*
* Author/Date:  Bob McAulay 21-Mar-97
*
*******************************************************************************
*
* Modifications:
*
* Comments:
*
* Concerns:
*
* $Header:   /export/phobos/pvcs/r_and_d/archives/scaleable/decode/HFRegen.h_v   1.2   16 Mar 1998 10:55:36   weiwang  $
*
******************************************************************************/
#ifndef HFREGEN_H
#define HFREGEN_H

/*******************************************************************************
*
* Function:  VoxHFRegeneration()
*
* Action:    Generate excitation phase parameters for synthetic phase and mixed
*              synthetic/measured phase systems.
*
* Input:     void  *hHFRegenMblk           -> frame-to frame memory block
*            float *pfVEVphase             -> measures phases in
*            float  fPitchDFT              -> pitch in DFT samples
*            float *pfLogAmp               -> harmonic log magnitudes
*            float *pfMinPhase             -> harmonic minimum-phase phases
*            int    iHarmonics             -> number of harmonics
*            int    iSCRate                -> coding rate flag (3.2k/6.4k)
*            int    iSynSamples            -> number of samples to synthesize
*            int    iUpdatePhaseOffsetFlag -> flag for updating phase offset
*
* Output:    void  *hHFRegenMblk           -> Updated structure
*            float *pfVEVphase             -> measured phase residuals out
*            float *pfOnsetPhase           -> onset phase
*            float *pfBeta                 -> beta value
*
* Globals:   none
*
* Return:    void
********************************************************************************
*
* Modifications:
*
* Comments:  
*
* Concerns/TBD:
*******************************************************************************/

void VoxHFRegeneration( STACK_R 
                        void  *hHFRegenMblk,
                        float *pfVEVphase,
                        float  fPitchDFT,
                        const float *pfLogAmp,
                        const float *pfMinPhase,
                        int    iHarmonics,
                        float *pfOnsetPhase,
                        float *pfBeta,
                        int    iSCRate,
                        int    iSynSamples,
                        int    iUpdatePhaseOffsetFlag
                      );

/*******************************************************************************
*
* Function:  VoxInitHFRegen()
*
* Action:    Initialize memory block for VoxHFRegeneration()
*
* Input:     void **hHFRegenMblk  -> pointer to memory block (invalid)
*
* Output:    void **hHFRegenMblk  -> pointer to memory block (hopefully valid)
*
* Globals:   none
*
* Return:    unsigned short (0/1 success/fail)
********************************************************************************
*
* Modifications:
*
* Comments:  
*
* Concerns/TBD:
*******************************************************************************/

unsigned short VoxInitHFRegen(void **hHFRegenMblk);

/*******************************************************************************
*
* Function:  VoxFreeHFRegen()
*
* Action:    Free memory block for VoxHFRegeneration()
*
* Input:     void **hHFRegenMblk  -> pointer to memory block (hopefully valid)
*
* Output:    none
*
* Globals:   none
*
* Return:    none
********************************************************************************
*
* Modifications:
*
* Comments:  
*
* Concerns/TBD:
*******************************************************************************/

void VoxFreeHFRegen(void **hHFRegenMblk);

#endif /* HFREGEN_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\hwin.c ===
/******************************************************************************
*                        Voxware Proprietary Material
*                        Copyright 1996, Voxware, Inc
*                            All Rights Reserved
*
*                       DISTRIBUTION PROHIBITED without
*                      written authorization from Voxware
******************************************************************************/
 
/******************************************************************************
*
* Filename:       HWin.c
*
* Purpose:        Window signal using Hamming or Hanning window. The window 
*                 is calculated recursively.
*
* Functions:
*
* Author/Date:    Wei Wang 2/18/97
*
* $Header:   /export/phobos/pvcs/pvcsproj/voxlib.prj/HWin.c_v   1.7   02 Mar 1998 18:24:26   bobd  $
*******************************************************************************
*
* Modifications:  Added option for Hanning window, and window normalization.
*                 Bob Dunn 5/1/97
*
* Comments:
*
* This code is based on Gerard's Magical 
* 2nd Order Difference Equation for Sinusoids.
* 
* Let
* 
*     x0 = theta                y0 = A * cos(x0)
*     x1 = theta + k            y1 = A * cos(x1)
*     x2 = theta + 2 * k        y2 = A * cos(x2)
* 
* then,
* 
*    y2 = diffCoef * y1 - y0
* 
* where,
* 
*    diffCoef = 2 * cos(k)
* 
* The code is modified from Dave's RecSine.c
*
*
* Concerns:
*
******************************************************************************/
#include <stdlib.h> 
#include <assert.h>
#include <math.h>
#include "vLibDef.h"
#include "vLibSgPr.h"

#include "xvocver.h"

/******************************************************************************
*
* Function:   HammingWindowNormSC()
*
* Action:     Window a signal with a Hamming window.  This window was suppose
*              to have unit area, but the area is really 1.08.  The function
*              is kept around because SC36 codebooks are currently trained 
*              on it.
*
* Input:      float *pfX      the input signal
*             int   iLength   the length of the input signal
*
* Output:     float *pfX      the output signal
*
* Globals:    none
*
* Return:     none
******************************************************************************/
void HammingWindowNormSC( float *pfX, int iLength )
{
   float fScale;

   assert(pfX != NULL);
   assert(iLength > 0);

   fScale = 2.0F/(float) iLength;
   WindowKernel( pfX, iLength, 0.54F*fScale, 0.46F*fScale);
}

/******************************************************************************
*
* Function:   HammingWindowNorm()
*
* Action:     Window a signal with a Hamming window with unit area.
*
* Input:      float *pfX      the input signal
*             int   iLength   the length of the input signal
*
* Output:     float *pfX      the output signal
*
* Globals:    none
*
* Return:     none
******************************************************************************/

void HammingWindowNorm( float *pfX, int iLength )
{
   float fScale;
 
   assert(pfX != NULL);
   assert(iLength > 0);
 
   fScale = 1.0F/(0.54F*iLength-0.46F);
   WindowKernel( pfX, iLength, 0.54F*fScale, 0.46F*fScale);
}


/******************************************************************************
*
* Function:   HanningWindowNorm()
*
* Action:     Window a signal with a Hanning window that has unit area.
*
* Input:      float *pfX      the input signal
*             int   iLength   the length of the input signal
*
* Output:     float *pfX      the output signal
*
* Globals:    none
*
* Return:     none
******************************************************************************
*
* Concerns:   The first and the last samples are zeros
*
******************************************************************************/

void HanningWindowNorm( float *pfX, int iLength )
{
   float fScale;

   assert(pfX != NULL);
   assert(iLength > 0);

   fScale = 1.0F/(float) iLength;
   WindowKernel( pfX, iLength, fScale, fScale);
}

/******************************************************************************
*
* Function:   WindowKernel()
*
* Action:     Window a signal (Hamming or Hanning) 
*
* Input:      float *x        input signal
*             int   length    length of signal
*             float a         window constant A
*             float b         window constant B
*
* Output:     float *x        output windowed signal
*
* Globals:    none
*
* Return:     none
*******************************************************************************
*
* Implementation/Detailed Description:
*
*    Window a signal with the window:
*
*           w[n] = A - B * cos( 2*pi*n/(length-1) )
*
*    For a Hamming window A = 0.540 and B = 0.460
*    For a Hanning window A = 0.500 and B = 0.500
*
*    For unit area windows, multiply A and B by 2.0/length
*
* References:
*******************************************************************************
*
* Modifications:  multiply b before the recursion. So it causes non-bit exactness
*                 but the error is every small, in the order of 10^(-5).
*
* Comments:
*
* Concerns/TBD:
******************************************************************************/
void WindowKernel(float *x, int length, float a, float b)
{
  int i;
  float r2 = b;
  float r3;
  float r1;
  float rwin;
  float *y = &(x[length-1]);
  int half_length = length>>1;
  float diffCoef = (float)cos(DB_PI/(float)(length-1));

  assert(x != NULL);

  r3 = diffCoef * b;
  diffCoef *= 2.0F;

  assert(half_length > 2);
  
  /* first windowing the first two points */
  rwin = (a-r2); 
  *x++ *= rwin;    *y-- *= rwin;

  rwin = (a-r3);
  *x++ *= rwin;    *y-- *= rwin;

  /* then recursively calculate other points */
  for (i = 2; i+2 < half_length; i+=3) {
    r1 = diffCoef * r3;     /* diffCoef * y1              */
    r1 -= r2;               /* y2 = diffCoef * y1 - y0    */
    rwin = (a-r1);       /* outBuf = y2                */
    *x++ *= rwin;  *y-- *= rwin;
 
    r2 = diffCoef * r1;     /* diffCoef * y1              */
    r2 -= r3;               /* y2 = diffCoef * y1 - y0    */
    rwin = (a-r2);       /* outBuf = y2                */
    *x++ *= rwin;  *y-- *= rwin;
 
    r3 = diffCoef * r2;     /* diffCoef * y1              */
    r3 -= r1;               /* y2 = diffCoef * y1 - y0    */
    rwin = (a-r3);       /* outBuf = y2                */
    *x++ *= rwin;  *y-- *= rwin;
  }

  if (i < half_length) {
    r1 = diffCoef * r3;     /* diffCoef * y1              */
    r1 -= r2;               /* y2 = diffCoef * y1 - y0    */
    rwin = (a-r1);       /* outBuf = y2                */
    *x++ *= rwin;  *y-- *= rwin;
    i++;

    if (i < half_length) {
      r2 = diffCoef * r1;     /* diffCoef * y1              */
      r2 -= r3;               /* y2 = diffCoef * y1 - y0    */
      rwin = (a-r2);       /* outBuf = y2                */
      *x++ *= rwin;  *y-- *= rwin;
    }
  }

  if (length & 1)
    *x++ *= (a+b);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\jitter.c ===
/*******************************************************************************
*                        Voxware Proprietary Material
*                        Copyright 1996, Voxware, Inc
*                            All Rights Reserved
*
*                       DISTRIBUTION PROHIBITED without
*                      written authorization from Voxware
*******************************************************************************/
 
/*******************************************************************************
*
* Filename:     Jitter.c
*
* Purpose:      Add a pitch-dependent phase perturbation to account for
*               irregular glottal pulse timing.
*
* Functions:    PhaseJitter()
*
* Author/Date:  Bob Dunn 1/98 (original Bob McAulay)
*
********************************************************************************
*
* Modifications:
*
* Comments:
*
* Concerns:
*
* $Header:   /export/phobos/pvcs/r_and_d/archives/scaleable/decode/Jitter.c_v   1.3   13 Apr 1998 18:26:16   weiwang  $
*
*******************************************************************************/
#include <stdlib.h>
#include <assert.h>
#include "vLibMath.h"
#include "codec.h"
#include "Jitter.h"

#include "xvocver.h"

/*--------------------------------------------------------------------
  There is no phase jitter below fJitterCutoff
--------------------------------------------------------------------*/
#define JITTER_CUTOFF      (1500.0F/(float)RATE8K) /*(1500.0F*HZ2DFT) */
#define PERTURB_FACTOR     (2.0F*INVTWOPI)
#define PERTURB_SLOPE      (0.1F*INVTWOPI)

/*******************************************************************************
*
* Function:  PhaseJitter()
*
* Action:    Add a pitch-dependent phase perturbation to account for
*               irregular glottal pulse timing.
*
* Input:     float     fPitch   -> pitch period
*            float    *pfPhase     -> harmonic phases (in)
*            int       iBasePeaks  -> number of baseband measure phases
*            int       iHarmonics  -> number of harmonics
*
* Output:    float    *pfPhase     -> harmonic phases (out)
*
* Globals:   none
*
* Return:    void
********************************************************************************
*
* Modifications:
*
* Comments:
*
* Concerns/TBD:
*******************************************************************************/


void PhaseJitter ( float     fPitch,
                   float    *pfPhase,
                   int       iBasePeaks,
                   int       iHarmonics
                 )
{
   int   n;
   int iJitterHarm;
   float fPerturb = PERTURB_FACTOR;

   assert(pfPhase != NULL);

   iJitterHarm = VoxFLOORpos(JITTER_CUTOFF * fPitch);

   if (iJitterHarm < iBasePeaks)
     fPerturb = PERTURB_FACTOR + (float)(iBasePeaks-iJitterHarm)*PERTURB_SLOPE;

   for (n = iBasePeaks; n < iHarmonics; n++)
     {
       if (n >= iJitterHarm)  /* increase perturbation factor */
         fPerturb += PERTURB_SLOPE;
       
       if (( n & 1) == 0)  /* only apply to odd harmonics */
         pfPhase[n] += fPerturb;
     }
} /* PhaseJitter */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\jitter.h ===
/*******************************************************************************
*                        Voxware Proprietary Material
*                        Copyright 1996, Voxware, Inc
*                            All Rights Reserved
*
*                       DISTRIBUTION PROHIBITED without
*                      written authorization from Voxware
*******************************************************************************/
 
/*******************************************************************************
*
* Filename:     Jitter.c
*
* Purpose:      Add a pitch-dependent phase perturbation to account for
*               irregular glottal pulse timing.
*
* Functions:    PhaseJitter()
*
* Author/Date:  Bob Dunn 1/98 (original Bob McAulay)
*
********************************************************************************
*
* Modifications:
*
* Comments:
*
* Concerns:
*
* $Header:   /export/phobos/pvcs/r_and_d/archives/scaleable/decode/Jitter.h_v   1.1   13 Apr 1998 18:26:16   weiwang  $
*
*******************************************************************************/
#ifndef JITTER_H
#define JITTER_H

/*******************************************************************************
*
* Function:  PhaseJitter()
*
* Action:    Add a pitch-dependent phase perturbation to account for
*               irregular glottal pulse timing.
*
* Input:     float     fPitchDFT   -> pitch period
*            float    *pfPhase     -> harmonic phases (in)
*            int       iBasePeaks  -> number of baseband measure phases
*            int       iHarmonics  -> number of harmonics
*
* Output:    float    *pfPhase     -> harmonic phases (out)
*
* Globals:   none
*
* Return:    void
********************************************************************************
*
* Modifications:
*
* Comments:
*
* Concerns/TBD:
*******************************************************************************/


void PhaseJitter ( float     fPitchDFT,
                   float    *pfPhase,
                   int       iBasePeaks,
                   int       iHarmonics
                 );

#endif /* JITTER_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\kaiwin.c ===
/******************************************************************************
*                        Voxware Proprietary Material
*                        Copyright 1997, Voxware, Inc
*                            All Rights Reserved
*
*                       DISTRIBUTION PROHIBITED without
*                      written authorization from Voxware
******************************************************************************/

/******************************************************************************
*
* Filename:    KaiWin.c
*
* Purpose:    Generate Kaiser window.
*
* Functions: KaiserWindow(), InitKaiserWindow()
*            FreeKaiserWindow()
*
* Author/Date: Wei Wang, Jan, 1998
*
*******************************************************************************
*
* Modifications:  KaiserWindow() only compute the left half size of window 
*    instead of the full size of window. InitKaiserWindow() does not contain 
*    normalization. All the normalization should call another function : 
*    NormSymWindowByPower() or NormSymWindowByArea().
*
* Comments: 
*
* Concerns: 
*
* $Header:   /export/phobos/pvcs/pvcsproj/voxlib.prj/kaiwin.c_v   1.14   06 Mar 1998 16:57:48   weiwang  $
******************************************************************************/

#include <stdlib.h>
#include <assert.h>
#include <math.h>
#include "vLibMacr.h"
#include "vLibSgPr.h"

#include "xvocver.h"

static float Bessel(const float x);

#define BESSEL_ITERATIONS 20  /* number of iterations in Bessel function */

/******************************************************************************
*
* Function:  float Bessel(const float x)
*
* Action: Compute zero_order Bessel function.
*
* Input:     x -- input index
*
* Output:    
*
* Globals:   none.
*
* Return:    output value from Bessle function.
*******************************************************************************/

static float Bessel(const float x)
{
   int i;
   float y,z,xk,z0;
   float halfx;
   float ftmp;
   const int MAXiteration = BESSEL_ITERATIONS;

   halfx = 0.5F*x;
   z = 1.0F;
   y = halfx;
   xk = 1.0F;

   for (i=1; i<=MAXiteration; i++)    /* iterate BESSEL_ITERATIONS times */
   {  
      z0 = y * xk;
      ftmp = z0 * z0;   /* ftmp added to improve cross-platform effects */
      z += ftmp;
      xk = xk /(float)(i+1);
      y *= halfx;
   }
   return((float)z);
}


/******************************************************************************
*
* Function:  KaiserWindow()
*
* Action:    Compute the Kaiser window coefficients. Only return left side
*            of window.
*
* Input:     fWindow -- pointer for Kaiser window
*            iWindowSize -- the length of full size window
*            fBeta -- the beta factor for Kaiser window.
*
* Output:    fWindow -- the left half side of Kaiser window.
*
* Globals:   none.
*
* Return:    none.
*
*******************************************************************************
*
* Modifications:
*
* Comments: All the normalization should call another function : 
*           NormSymWindowByPower() or NormSymWindowByArea().
*
* Concerns/TBD:
******************************************************************************/

void KaiserWindow(float *fWindow, int iWindowSize, float fBeta)
{
  float fI0B;
  float fInvI0B;
  float fInvN;
  int iN;
  int iHalfSize;
  int i;
  float x, y, z;
  
  assert(fWindow != NULL);
  assert( (iWindowSize-1) > 0 );

  /**** initialization ****/
  iN = iWindowSize - 1;
  fI0B = Bessel(fBeta);
  fInvI0B=1.0F/fI0B;
  fInvN=1.0F/(float)iN;
  iHalfSize = iWindowSize >> 1;

  /**** compute the window value of the most left point ****/
  fWindow[0] = fInvI0B;

  /**** compute window value at [1...iHalfSize] ****/
  for (i=1 ; i<iHalfSize; i++) 
    { 
      z = 2.0F*((float)i*fInvN);
      z -= 1.0F;  /*** 1/N to prevent sensitivity calculation ***/
      x = -(z * z);
      x += 1.0F;
      y = fBeta*(float)sqrt(x);
      fWindow[i] = Bessel(y)*fInvI0B;
    }
  
  /**** Compute the center point ****/
  if ( iWindowSize & 1 )
     fWindow[i] = 1.0F;
}


/******************************************************************************
*
* Function:  InitKaiserWindow()
*
* Action:    Allocate memory and compute the Kaiser window coefficients.
*            !!! The array *pfWindow only has the half of the window length.
*
* Input:     pfWindow -- pointer to Kaiser window buffer.
*            iWindowSize -- the length of full size window
*            fBeta -- the beta factor for Kaiser window.
*
* Output:    pfWindow -- the return address of the left side of Kaiser window.
*
* Globals:   none.
*
* Return:    1 : fail to allocate the memory.
*            0:  succeed.
*
*******************************************************************************
* Modifications:
*
* Comments: All the normalization should call another function : 
*           NormSymWindowByPower() or NormSymWindowByArea().
*
* Concerns/TBD:
******************************************************************************/

unsigned short InitKaiserWindow(float **pfWindow, int iWindowSize, float fBeta)
{
  unsigned short retFlag = 0;

  /***** allocate the memory *****/
  *pfWindow = (float *)malloc(((iWindowSize+1)>>1) * sizeof(float));
  if (*pfWindow == NULL)
    retFlag = 1;
  else 
    {
      /***** compute the Kaiser window ******/
      KaiserWindow(*pfWindow, iWindowSize, fBeta);
    }
  
  return retFlag;
}

/******************************************************************************
*
* Function:  FreeKaiserWindow()
*
* Action:    Free the Kaiser window memory.
*
* Input:     pfWindow -- pointer to Kaiser window buffer.
*
* Output:    
*
* Globals:   none.
*
* Return:    none
*******************************************************************************/

void FreeKaiserWindow(float **pfWindow)
{
  SafeFree(*pfWindow);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\kaiw291.h ===
2.4602240e-002F,
2.7741211e-002F,
3.1052573e-002F,
3.4540161e-002F,
3.8207740e-002F,
4.2059015e-002F,
4.6097610e-002F,
5.0327070e-002F,
5.4750856e-002F,
5.9372343e-002F,
6.4194798e-002F,
6.9221400e-002F,
7.4455217e-002F,
7.9899207e-002F,
8.5556217e-002F,
9.1428958e-002F,
9.7520046e-002F,
1.0383195e-001F,
1.1036699e-001F,
1.1712735e-001F,
1.2411511e-001F,
1.3133214e-001F,
1.3878025e-001F,
1.4646095e-001F,
1.5437573e-001F,
1.6252582e-001F,
1.7091240e-001F,
1.7953630e-001F,
1.8839829e-001F,
1.9749899e-001F,
2.0683879e-001F,
2.1641785e-001F,
2.2623621e-001F,
2.3629369e-001F,
2.4658988e-001F,
2.5712427e-001F,
2.6789609e-001F,
2.7890441e-001F,
2.9014793e-001F,
3.0162540e-001F,
3.1333506e-001F,
3.2527533e-001F,
3.3744419e-001F,
3.4983930e-001F,
3.6245829e-001F,
3.7529862e-001F,
3.8835731e-001F,
4.0163141e-001F,
4.1511762e-001F,
4.2881235e-001F,
4.4271216e-001F,
4.5681289e-001F,
4.7111049e-001F,
4.8560071e-001F,
5.0027913e-001F,
5.1514083e-001F,
5.3018093e-001F,
5.4539418e-001F,
5.6077564e-001F,
5.7631928e-001F,
5.9201938e-001F,
6.0787046e-001F,
6.2386614e-001F,
6.4000016e-001F,
6.5626621e-001F,
6.7265725e-001F,
6.8916678e-001F,
7.0578772e-001F,
7.2251260e-001F,
7.3933458e-001F,
7.5624597e-001F,
7.7323902e-001F,
7.9030621e-001F,
8.0743933e-001F,
8.2463050e-001F,
8.4187180e-001F,
8.5915440e-001F,
8.7646997e-001F,
8.9381033e-001F,
9.1116655e-001F,
9.2852956e-001F,
9.4589120e-001F,
9.6324241e-001F,
9.8057407e-001F,
9.9787676e-001F,
1.0151418e+000F,
1.0323595e+000F,
1.0495210e+000F,
1.0666170e+000F,
1.0836382e+000F,
1.1005753e+000F,
1.1174185e+000F,
1.1341586e+000F,
1.1507863e+000F,
1.1672919e+000F,
1.1836667e+000F,
1.1999005e+000F,
1.2159851e+000F,
1.2319092e+000F,
1.2476653e+000F,
1.2632440e+000F,
1.2786350e+000F,
1.2938305e+000F,
1.3088208e+000F,
1.3235970e+000F,
1.3381501e+000F,
1.3524717e+000F,
1.3665526e+000F,
1.3803852e+000F,
1.3939599e+000F,
1.4072691e+000F,
1.4203044e+000F,
1.4330578e+000F,
1.4455214e+000F,
1.4576875e+000F,
1.4695482e+000F,
1.4810969e+000F,
1.4923249e+000F,
1.5032270e+000F,
1.5137945e+000F,
1.5240222e+000F,
1.5339032e+000F,
1.5434303e+000F,
1.5525987e+000F,
1.5614020e+000F,
1.5698341e+000F,
1.5778910e+000F,
1.5855660e+000F,
1.5928546e+000F,
1.5997529e+000F,
1.6062557e+000F,
1.6123585e+000F,
1.6180582e+000F,
1.6233506e+000F,
1.6282320e+000F,
1.6327004e+000F,
1.6367511e+000F,
1.6403831e+000F,
1.6435937e+000F,
1.6463799e+000F,
1.6487410e+000F,
1.6506743e+000F,
1.6521802e+000F,
1.6532558e+000F,
1.6539021e+000F,
1.6541170e+000F,
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\klpitch.h ===
/*******************************************************************************
*                         Voxware Proprietary Material                         *
*                         Copyright 1996, Voxware, Inc                         *
*                             All Rights Reserved                              *
*                                                                              *
*                        DISTRIBUTION PROHIBITED without                       *
*                       written authorization from Voxware                     *
*******************************************************************************/
 
/*******************************************************************************
* Filename:       KLPitch.h
*
* Purpose:        Set the scale factor for unvoiced speech.
*
* Functions:      float fSetKLFactor()
*
* Author/Date:    Original developed by Bob McAulay and Bob Dunn 1/97
********************************************************************************
* Modifications:
*
* Comments:
*
* Concerns: 
*
* $Header:   /export/phobos/pvcs/r_and_d/archives/scaleable/decode/KLPitch.h_v   1.1   13 Apr 1998 18:26:18   weiwang  $
*******************************************************************************/

/*******************************************************************************
*
* Function:  fSetKLFactor()
*
* Action:    Determine scale factor for unvoiced harmonics
*
* Input:     float fAnaPitch  -> the analysis pitch period
*            float fSynF0   -> the synthesis pitch in DFT samples
*
* Output:    none
*
* Globals:   none
*
* Return:    float fLogAlpha  -> the scale factor (to add in log base 2)
********************************************************************************
*
* Modifications:
*
* Comments:
*
* Concerns/TBD:
*******************************************************************************/
#ifndef KLPITCH_H
#define KLPITCH_H

float fSetKLFactor( float fAnaPitch, float fSynPitch );

#endif /* KLPITCH_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\k2ask.c ===
/******************************************************************************
*
*                        Voxware Proprietary Material
*
*                        Copyright 1997, Voxware, Inc
*
*                            All Rights Reserved
*
*
*                       DISTRIBUTION PROHIBITED without
*
*                      written authorization from Voxware
*
******************************************************************************/
 
/******************************************************************************
*
* Filename:    K2ASK.c
*
* Purpose:    transform the reflection coefficients to acsin reflection coefficients.
*
* Functions: void K2ASK(const int iLPCorder, const float *pfk, float *pfASK)
*            void ASK2K(const int iLPCorder, const float *pfASK, float *pfk)
*
* Author/Date: Xiaoqin Sun   08/97
*
*******************************************************************************
*
* Modifications:  Wei Wang, clean up the code 11/97.
*
* Comments:
*
* Concerns:
*
* $Header:   /export/phobos/pvcs/pvcsproj/voxlib.prj/K2ASK.c_v   1.4   02 Mar 1998 17:40:58   weiwang  $
******************************************************************************/
#include <stdlib.h>
#include <assert.h>
#include <math.h>
#include "vLibTran.h"

#include "xvocver.h"

/******************************************************************************
*
* Function:  K2ASK()
*
* Action:    Convert reflection coefficients to Arcsin reflection coefficients.
*
* Input:     iLPCorder -- the order or the length of the coefficients.
*            pfk       -- reflection coefficients.
*            pfASK     -- the pointer for the output Arcsin reflection coefficients.
*
* Output:    pfASK     -- Arcsin reflection coefficients 
*
* Globals:   none
*
* Return:    void
*******************************************************************************
*
* Implementation/Detailed Description:
*
*
* References:
*******************************************************************************
*
* Modifications:
*
* Comments:
*
* Concerns/TBD:
******************************************************************************/
void K2ASK (int iLPCorder, const float *pfk, float *pfASK)
{
  assert(pfk != NULL && pfASK != NULL);

  while ((iLPCorder --) > 0)
    *pfASK++ = (float)(asin(*pfk++));
}


/******************************************************************************
*
* Function:  ASK2K()
*
* Action:    Convert Arcsin reflection coefficients to reflection coefficients.
*
* Input:     iLPCorder -- the order or the length of the coefficients.
*            pfASK     -- Arcsin reflection coefficients.
*            pfk       -- the pointer for the output reflection coefficients.
*
* Output:    pfk       -- reflection coefficients 
*
* Globals:   none
*
* Return:    void
*******************************************************************************
*
* Implementation/Detailed Description:
*
*
* References:
*******************************************************************************
*
* Modifications:
*
* Comments:
*
* Concerns/TBD:
******************************************************************************/

void ASK2K (int iLPCorder, const float *pfASK, float *pfk)
{
  assert(pfASK != NULL && pfk != NULL);
 
  while ((iLPCorder--) > 0)
    *pfk++ = (float)sin(*pfASK++);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\l2scale.c ===
/*******************************************************************************
*                        Voxware Proprietary Material                          *
*                        Copyright 1996, Voxware, Inc                          *
*                            All Rights Reserved                               *
*                                                                              *
*                       DISTRIBUTION PROHIBITED without                        *
*                      written authorization from Voxware                      *
*******************************************************************************/

/*******************************************************************************
* Filename:       L2Scale.c
*                                                                              
* Purpose:        Perform an L2 energy scaling
*                                                                              
* Functions:      L2Scale() 
*                        
* Author/Date:    Bob Dunn 3/97
********************************************************************************
* $Header:   /export/phobos/pvcs/pvcsproj/voxlib.prj/l2scale.c_v   1.7   02 Mar 1998 17:41:04   weiwang  $
*******************************************************************************/

/******************************************************************************
*
* Function:  L2Scale()
*
* Action:    Perform an L2 scaling of a vector.
*
* Input:     float *pfX       -> the vector to be scaled
*            int iLength      -> the length of the vector
*            float fEnergySqr -> the desired output energy of the vector
*
* Output:    float *pfX       -> the scaled vector
*
* Globals:   none
*
* Return:    void
*******************************************************************************
*
* Modifications:
*
* Comments:
*
* Concerns/TBD:
******************************************************************************/
#include <assert.h>
#include <math.h>

#include "vLibVec.h"

#include "xvocver.h"

void L2Scale(float *pfX, int iLength, float fEnergySqr)
{
  float fTemp;

  assert( pfX );
  assert( iLength >= 0 );

  /*------------------------------------------------------
    Compute the energy in the vector
  ------------------------------------------------------*/
  fTemp = DotProd(pfX, pfX, iLength);

  /*------------------------------------------------------
    If the energy (fTemp) is non-zero then compute the 
      scale factor and scale the vector, Otherwise,
      avoid a divide by zero and don't scale.
  ------------------------------------------------------*/
  if (fTemp>0.0)
  {
    fTemp=(float)(sqrt(fEnergySqr/fTemp));
    ScaleVector( pfX, iLength, fTemp, pfX );
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\kstoas.c ===
/******************************************************************************
*                        Voxware Proprietary Material
*                        Copyright 1997, Voxware, Inc
*                            All Rights Reserved
*
*                       DISTRIBUTION PROHIBITED without
*                      written authorization from Voxware
******************************************************************************/
 
/******************************************************************************
*
* Filename:    KsToAs.c
*
* Purpose:     Convert reflection coefficients to predictor coefficients.
*
* Functions:
*
* Author/Date: Bob Dunn 1/29/97
*
*******************************************************************************
*
* Modifications: clean up by Wei Wang 11/97
*
* Comments:    Algorithm from p 443 of "Digital Processing of Speech Signals" 
*                L.R.Rabiner and R.W.Schafer. Prentice-Hall 1978.
*
* Concerns:   The prediction coefficients are in the format [1 a1 a2 ... ap]
*
* $Header:   /export/phobos/pvcs/pvcsproj/voxlib.prj/KsToAs.c_v   1.4   24 Feb 1998 17:34:54   weiwang  $
******************************************************************************/
#include <assert.h>
#include "vLibDef.h"
#include "vLibTran.h"

#include "xvocver.h"

/******************************************************************************
*
* Function:  VoxKsToAs()
*
* Action:    Convert the reflection coefficients to prediction 
*              coefficients (LPC).
*
* Input:     pfKS     -- the input reflection coefficients.
*            pfAS     -- the pointer for the output LPC coefficients.
*            iOrder   -- the order of both reflection coefficients and LPCs.
*
* Output:    pfAS     -- the output prediction coefficients.
*
* Globals:   none
*
* Return:    void
*******************************************************************************
*
* Implementation/Detailed Description:
*
* References:  p 443 of "Digital Processing of Speech Signals" 
*                L.R.Rabiner and R.W.Schafer. Prentice-Hall 1978.
*******************************************************************************
*
* Modifications:
*
* Comments:     The format for pfAs[] is:
*                  A(z) = 1 + SUM(1...p) a_p z^(-p) where pfAs[0]=1.
*
* Concerns/TBD: (1) Need scratch memory at least MAX_LPC_ORDER+1 (19).
******************************************************************************/

void VoxKsToAs( const float *pfKS, 
                float       *pfAS, 
                int          iOrder
              )
{
   float *pfA_1;              /* point to AS for previous iteration           */
   float *pfSwap;             /* point for swapping the memory */
   float fTemp1[MAX_LPC_ORDER+1]; /*%#  scratch memory #%*/
   float fK;               /* reflection coefficient for current iteration */
   int i, j, k;

   assert(iOrder <= MAX_LPC_ORDER);

   pfAS[0] = 1.0F;

   /*-------------------------------------------------------
     Set up pointers so that the predictor coefficients 
     will be placed in their final location.
   -------------------------------------------------------*/
   if (iOrder&1)           /* an odd number of iterations */
   {
      pfA_1 = pfAS;
      pfAS = fTemp1;      
   }
   else                    /* an even number of iterations */
   {
      pfA_1 = fTemp1;
   }
  
   /*---------------------
      Do the interation.
   ---------------------*/
   for (i=0;i<iOrder; i++)
   {
      pfSwap = pfAS;   /* swap pfA with pfA_1 */
      pfAS = pfA_1;
      pfA_1 = pfSwap;

      fK =  pfKS[i];  /* get (i+1)th reflection coefficient */
      /*------------------------------------------------------
         Compute (i+1)th order predictor coefficients
      ------------------------------------------------------*/
      pfAS[i+1] = -fK;
      for (j=1, k=i; j<=i; j++, k--)
         pfAS[j] = pfA_1[j] - fK*pfA_1[k];
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\ldpda.c ===
/*******************************************************************************
*                        Voxware Proprietary Material                          *
*                        Copyright 1997, Voxware, Inc                          *
*                            All Rights Reserved                               *
*                                                                              *
*                       DISTRIBUTION PROHIBITED without                        *
*                      written authorization from Voxware                      *
******************************************************************************/

/*******************************************************************************
* Filename:       LDPDA.c
*                                                                              
* Purpose:        Estimate pitch using frequency domain cost function and back-
*                 ward tracking.
*                                                                              
* Functions:      VoxLDPDA(), GetPitchTable(),
*                 VoxInitLDPDA(), VoxFreeLDPDA()
*
* Author/Date:    Original developed by Gerard Aguilar   01/97
*                 Enhanced R&D by Wei Wang   04/97
*
********************************************************************************
* Modifications:
*                3/30/98, W.W. Rewrite whole file and use inter-leave format
*                spectrum. 
*  
*                05/97, W.W.
*                (1) Use longer table and change the boundary calculation. 
*                      (LDPDA.1)
*                (2) Change the boundary calculation using masker value and 
*                      use cosine table. (LDPDA.2).
*                (3) Use pitch table instead of fundamental frequency table.
*                (4) reduce table to 86 entries and expand the candidate from 
*                      8 to 160.
*                (5) add refinement for best candidates.
*                (6) when pitch is noise-like or (plusive), put pitch value 
*                      higher.
*                (7) put fix-point indeces for Calc_Cost_Func and VoicingLD.
*                                                                              
* Comments:                                                                    
* 
* Concerns:
*
* $Header:   /export/phobos/pvcs/r_and_d/archives/scaleable/pea/LDPDA.c_v   1.3   08 Apr 1998 11:01:38   weiwang  $
******************************************************************************/
/*** system include files ***/
#include <string.h>
#include <stdlib.h>
#include <math.h>
#include <assert.h>

/*** Research lib include files ***/
#include "vLibVec.h"
#include "vLibMath.h"

/*** codec related include files ***/
#include "VoxMem.h"
#include "codec.h"
#include "LDPDAdef.h"
#include "SelePeak.h"
#include "CompPow.h"
#include "PtchCand.h"
#include "VoicLD.h"
#include "LDPDA.h"

#include "xvocver.h"

/*--------------------------------------------------
   Local table -- pitch candidates
  --------------------------------------------------*/
const float CpfPitchTable[PITCH_TABLE_SIZE] =
{
#include "PitchTBL.h"
};

/*---------------------------------------------------
   Private functions
  ---------------------------------------------------*/
static 
int FindBaseBand(const float *pfPower, int iLength);

static
int FindBestCandidates(const float *pfPv, int iNumCand, int iHpIndex);

static
void UpdateLDPDA_MBlk(void *hLD_PDA_mblk, float fPitch, float fCost);


/******************************************************************************
* Function:  VoxLDPDA
*
* Action:    Estimate pitch value from frequency domain spectrum. This is 
*            the main function for coarse pitch calculation.
*
* Input:     pfSW -- input spectrum
*            hLD_PDA_mblk -- PDA structure
*
* Output:    none
*
* Globals:   none
*
* Return:    pitch value
*******************************************************************************
*
* Implementation/Detailed Description:
*
*******************************************************************************
*
* Modifications:
*
* Comments:
*
* Concerns/TBD:
*
******************************************************************************/

float VoxLDPDA( STACK_R 
                const float *pfSW, 
                void        *hLD_PDA_mblk
              )

{
  /***** STACK memory ******/
STACK_INIT
  float pfPower[FAR_EXTEND_CUT_LC];
  float pfCandCost[NCAND];
  float pfPitchCand[NCAND];
  float pfPv[NCAND];
  int   piPeakFreq[MAX_NPEAKS];
STACK_INIT_END

  STACK_ATTACH(float *, pfPower)
  STACK_ATTACH(float *, pfCandCost)
  STACK_ATTACH(float *, pfPitchCand)
  STACK_ATTACH(float *, pfPv)
  STACK_ATTACH(int *, piPeakFreq)

  /***** regular varibles *****/
  int iBaseBand;    
  float fMaxPower;  
  int i;
  int iNumCand;
  int iHP_Index;
  float fPitch;

STACK_START
  /*-------------------------------------------
    (0) Check input arrays.
    -------------------------------------------*/
  assert(pfSW != NULL);
  assert(hLD_PDA_mblk != NULL);

  /*----------------------------------------------------------------------
    (1) compute the power spectrum of the STFT of the signal.
    Then find the maximum value.
    ----------------------------------------------------------------------*/
  MagSqIL(pfSW, FAR_EXTEND_CUT_LC, pfPower);

  FindMaxValueFlt(pfPower, FAR_EXTEND_CUT_LC, &i, &fMaxPower);
  assert(fMaxPower >= 0.0F);


  /*----------------------------------------------------------------------
    (2) Choose the baseband. Then select the peaks for pitch estimation.
    ----------------------------------------------------------------------*/
  iBaseBand = FindBaseBand(pfPower, EXTEND_CUT_LC);
  
  SelectPeaks(STACK_S pfPower, iBaseBand, piPeakFreq, fMaxPower); 


  /*----------------------------------------------------------------------
    (3) Normalize the power spectrum between 0 and 1. Then compress it to 
    get the magnitude spectrum by x^(1/8).
    ----------------------------------------------------------------------*/
  if (fMaxPower > 0.0F)
    fMaxPower = 1.0F/fMaxPower;

  for (i = iBaseBand-1; i >= 0; i--)
    {
      pfPower[i] *= fMaxPower;
      pfPower[i] = powerpoly_125(pfPower[i]);
   }

  /*----------------------------------------------------------------------
    (4) Select the good candidates and do pitch refinement.
    ----------------------------------------------------------------------*/
  iNumCand = SelectPitchCandidates(STACK_S pfPower, iBaseBand, piPeakFreq, 
                                   pfPitchCand, pfCandCost, 
                                   ((LD_PDA_MBlk *)hLD_PDA_mblk)->fLastP0, 
                                   ((LD_PDA_MBlk *)hLD_PDA_mblk)->fLastCost,
                                   &iHP_Index);

  
  /*----------------------------------------------------------------------
    (5) Find the estimated pitch from at most 3 candidates: 
    pfPitchCand[0], pfPitchCand[iHP_Index], pfPitchCand[iNumCand-1]
    using frequency-domain analysis-by-synthesis.
    ----------------------------------------------------------------------*/
  /* Re-calculate iBaseBand for voicingLD calculation. */
  iBaseBand = FindBand4VoicLD(iBaseBand, pfPitchCand[iNumCand-1]);
    
  /* do freqeuncy-domain analysis-by-synthesis voicing calculation */
  for (i = iNumCand-1; i >= 0; i--) 
    pfPv[i] = VoicingLD(pfPitchCand[i], pfSW, iBaseBand);

  /* do the final decision and pitch is pfPitchCand[iHP_Index] */
  iHP_Index = FindBestCandidates(pfPv, iNumCand, iHP_Index);

  fPitch = pfPitchCand[iHP_Index];
  
  /*----------------------------------------------------------------------
    (6) update the information.
    ----------------------------------------------------------------------*/
  UpdateLDPDA_MBlk(hLD_PDA_mblk, fPitch, pfCandCost[iHP_Index]);

STACK_END

  return fPitch;  
}


/******************************************************************************
* Function:  GetPitchTable()
*
* Action:    Export pitch table and table size.
*
* Input:     pfPitchTable -- pointer for output pitch table
*            piSize       -- pointer for output table size  
*
* Output:    pfPitchTable -- pitch table
*            piSize       -- table size
*
* Globals:   none
*
* Return:    none
*******************************************************************************
*
* Modifications:
*
* Comments:
*
* Concerns/TBD:
*
******************************************************************************/

void GetPitchTable( float  **pfPitchTable, 
                    int    *piSize
                  )
{
  assert(pfPitchTable != NULL);
  assert(piSize != NULL);

  *pfPitchTable = (float *)CpfPitchTable;
  *piSize = PITCH_TABLE_SIZE;
}


/******************************************************************************
* Function:  VoxInitLDPDA()
*
* Action:    initialize LDPDA memory block.
*
* Input:     hLD_PDA_mblk -- pointer to LDPDA memory block
*
* Output:    hLD_PDA_mblk -- initialized LDPDA memory block
*
* Globals:   none
*
* Return:    none
*******************************************************************************
*
* Modifications:
*
* Comments:
*
* Concerns/TBD:
*
******************************************************************************/

unsigned short VoxInitLDPDA(void **hLD_PDA_mblk)
{
  assert(hLD_PDA_mblk != NULL);

  /* initialize the structure */
  if(VOX_MEM_INIT(*hLD_PDA_mblk, 1, sizeof(LD_PDA_MBlk))) 
    return 1;

  ((LD_PDA_MBlk *)*hLD_PDA_mblk)->fLastP0 = 100.0F;
  ((LD_PDA_MBlk *)*hLD_PDA_mblk)->fLastCost = 0.0F;

  return 0;
}


/******************************************************************************
* Function:  VoxFreeLDPDA()
*
* Action:    free the memory which's allocated for LDPDA memory block.
*
* Input:     hLD_PDA_mblk -- pointer to LDPDA memory block
*
* Output:    hLD_PDA_mblk -- memory-freed LDPDA memory block
*
* Globals:   none
*
* Return:    none
*******************************************************************************
*
* Modifications:
*
* Comments:
*
* Concerns/TBD:
*
******************************************************************************/

unsigned short VoxFreeLDPDA(void **hLD_PDA_mblk)
{
  assert(hLD_PDA_mblk != NULL);

  if (*hLD_PDA_mblk) 
    VOX_MEM_FREE(*hLD_PDA_mblk);

  return 0;
}


/******************************************************************************
* Function:  FindBaseBand()
*
* Action:    Find the baseband length for cost function calculation
*
* Input:     pfPower  -- input power spectrum
*            iLength  -- length of power spectrum for calculation
*
* Output:    none
*
* Globals:   none
*
* Return:    baseband length
*******************************************************************************
*
* Implementation/Detailed Description:
*
*******************************************************************************
*
* Modifications:
*
* Comments:
*
* Concerns/TBD:
*
******************************************************************************/

int FindBaseBand( const float *pfPower, 
                  int         iLength
                )
{
  float fEnergyThreshold;
  float fHighEndEnergy;
  int i;

  assert(pfPower != NULL);

  iLength --;
  /*--------------------------------------------------
    (1) Compute the energy cutoff threshold
    --------------------------------------------------*/
  fEnergyThreshold = 0.0F;
  for (i = iLength; i >= 0; i--)
    fEnergyThreshold += pfPower[i];
  fEnergyThreshold *= ENERGY_CUT_OFF;

  /*--------------------------------------------------
    (2) Find the cutoff BaseBand.
    --------------------------------------------------*/
  fHighEndEnergy = 0.0F;
  for (i = iLength; i>=0; i--)
    {
      fHighEndEnergy += pfPower[i];
      if (fHighEndEnergy >= fEnergyThreshold)
        break;
    }
  
  i += 2;
  if (i < FREQ_CUT_LC)
    i = FREQ_CUT_LC;

  return i;
}


/******************************************************************************
* Function:  FindBestCandidates()
*
* Action:    Decide the final pitch from Pv and other information.
*
* Input:     pfPv      -- input estimated voicing array
*            iNumCand  -- number of final candidates
*            iHpIndex  -- index for high possibility candidate
*
* Output:    none
*
* Globals:   none
*
* Return:    index for final pitch value
*******************************************************************************
*
* Implementation/Detailed Description:
*
*******************************************************************************
*
* Modifications:
*
* Comments:
*
* Concerns/TBD:
*
******************************************************************************/

static
int FindBestCandidates( const float *pfPv, 
                        int          iNumCand, 
                        int          iHpIndex
                      )
{
  int iLastIndex = iNumCand - 1;
  int iBestIndex;
  const static float PV_TH[3] = {0.75F, 1.1F, 0.88F};

  assert(pfPv != NULL);

  /*------------------------------------------------------------
    Resolve most likely pitch candidate using the following 
    conditions:
    ------------------------------------------------------------*/
  iBestIndex = 0; 

  if (iHpIndex<(iLastIndex))    
    {      
      if ((iHpIndex == 0) || (pfPv[iHpIndex] >= (PV_TH[0]*pfPv[0])))
        {
          if (pfPv[iLastIndex] >= (PV_TH[1]*pfPv[iHpIndex]))
            iBestIndex = iLastIndex;
          else
            iBestIndex = iHpIndex;
        } 
    }
  else 
    {
      if (pfPv[iLastIndex] >= (PV_TH[2]*pfPv[0]))
        iBestIndex  = iLastIndex;
    }

  return iBestIndex;
}

/******************************************************************************
* Function:  UpdateLDPDA_MBlk()
*
* Action:    update the content of LDPDA memory block.
*
* Input:     hLD_PDA_mblk -- pointer to LDPDA memory block
*            fPitch        -- final pitch
*            fCost         -- cost value for the final pitch
*
* Output:    hLD_PDA_mblk -- updated LDPDA memory block
*
* Globals:   none
*
* Return:    none
*******************************************************************************
*
* Modifications:
*
* Comments:
*
* Concerns/TBD:
*
******************************************************************************/
static void UpdateLDPDA_MBlk( void  *hLD_PDA_mblk, 
                              float  fPitch, 
                              float  fCost
                            )
{
  assert(hLD_PDA_mblk != NULL);

  ((LD_PDA_MBlk *)hLD_PDA_mblk)->fLastP0 = fPitch;
  ((LD_PDA_MBlk *)hLD_PDA_mblk)->fLastCost = fCost;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\klpitch.c ===
/*******************************************************************************
*                         Voxware Proprietary Material                         *
*                         Copyright 1996, Voxware, Inc                         *
*                             All Rights Reserved                              *
*                                                                              *
*                        DISTRIBUTION PROHIBITED without                       *
*                       written authorization from Voxware                     *
*******************************************************************************/
 
/*******************************************************************************
* Filename:       KLPitch.c
*
* Purpose:        Set the scale factor for unvoiced speech.
*
* Functions:      float fSetKLFactor()
*
* Author/Date:    Original developed by Bob McAulay and Bob Dunn 1/97
********************************************************************************
* Modifications:  Change fWinScale[] to fLog2WinScale[] by Wei Wang, 4/98
*
* Comments:
*
* Concerns: 
*
* $Header:   /export/phobos/pvcs/r_and_d/archives/scaleable/decode/KLPitch.c_v   1.3   13 Apr 1998 18:26:18   weiwang  $
*******************************************************************************/
#include <assert.h>

#include "vLibMath.h"
#include "codec.h"
#include "KLPitch.h"

#include "xvocver.h"

/*---------------------------------------------------------------------
  The number of analysis windows used minus one.
---------------------------------------------------------------------*/
#define NUMBER_OF_WINDOWS_M1 5

/*---------------------------------------------------------------------
  The table fWinScale[] contains the scale factor 
    (window area)/sqrt(window energy) for each possible analysis window.
  Table now convert to fLog2(fWinScale[]).
---------------------------------------------------------------------*/
static const float fLog2WinScale[NUMBER_OF_WINDOWS_M1+1]={
#include "winscale.h"
};

/*---------------------------------------------------------------------
  Define the pitch periods for the analysis windows.
---------------------------------------------------------------------*/
static const float fWinPeriod[NUMBER_OF_WINDOWS_M1] = {
 96.0F, /* period of 32.5ms window */
 88.0F, /* period of 30.0ms window */
 80.0F, /* period of 27.5ms window */
 72.0F, /* period of 25.0ms window */
 64.0F, /* period of 22.0ms window */
};

/*---------------------------------------------------------------------
  Must scale by 1/sqrt(2/3) to adjust for the variance reduction
    due to overlapping and adding the triangular window.
    Also, take log base 2 of this facto.
---------------------------------------------------------------------*/
#define WINDOW_SCALING  0.29248125F  /*0.29248125036057792681F*/
 
/*---------------------------------------------------------------------
  Since the noise spectral density was fitted to the sine-wave peaks
    we can expect the synthesized noise level to be too high. So we
    reduce it to account for the peak-to-rms level.
---------------------------------------------------------------------*/
#define PEAKPICK_SCALING -0.33779991F  /*-0.33779990790610769924F*/

/*---------------------------------------------------------------------
  To get a noise level that RJM "likes" use the fudge factor
---------------------------------------------------------------------*/
#define FUDGEFACTOR_SCALING -0.50F

/*---------------------------------------------------------------------
  MUTLTI_SCALING: sum up the above 3 scaling factor and 0.5*fLog2(1/NFFT)
---------------------------------------------------------------------*/
#define MULTI_SCALING  (WINDOW_SCALING+PEAKPICK_SCALING+FUDGEFACTOR_SCALING \
                        -0.5F*(float)FFT_ORDER)

/*******************************************************************************
*
* Function:  fSetKLFactor()
*
* Action:    Determine scale factor for unvoiced harmonics
*
* Input:     float fAnaPitch  -> the analysis pitch period
*            float fSynF0  -> the synthesis pitch in DFT samples
*
* Output:    none
*
* Globals:   none
*
* Return:    float fLogAlpha  -> the scale factor (to add in log base 2)
********************************************************************************
*
* Modifications:
*
* Comments:
*
* Concerns/TBD:
*******************************************************************************/

float fSetKLFactor( float fAnaPitchPeriod, float fSynF0)
{
   int   i;
   float fLogAlpha;

   /*-----------------------------------------------------------------
     Set the Scaling ratio: (window area)/sqrt(window energy).
       This raio is a function of the analysis window used.  The
       window used depends on the coarse pitch estimate at the
       encoder, so the best we can do is guess based on the pitch
       received by the decoder.
   -----------------------------------------------------------------*/
   for (i=0; i<NUMBER_OF_WINDOWS_M1; i++)
      if (fAnaPitchPeriod>fWinPeriod[i])
        break;

   /*-----------------------------------------------------------------
    fLogAlpha = fLog2(fWinScale[i])+0.5*fLog2(fSynPitch/NFFT)
                + WINDOW_SCALING+PEAKPICK_SCALING+FUDGEFACTOR_SCALING

     fLog2(fWinScale[i])         normalizes for the energy in the 
                                   analysis window
     0.5F*fLog2(fSynPitch/NFFT)  normalizes for the synthesis pitch
   -----------------------------------------------------------------*/
   fLogAlpha = fLog2WinScale[i]+0.5F*fLog2(fSynF0)
               + MULTI_SCALING;
   
   return fLogAlpha;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\ldpdadef.h ===
/*******************************************************************************
*                        Voxware Proprietary Material                          *
*                        Copyright 1997, Voxware, Inc                          *
*                            All Rights Reserved                               *
*                                                                              *
*                       DISTRIBUTION PROHIBITED without                        *
*                      written authorization from Voxware                      *
******************************************************************************/

/*******************************************************************************
* Filename:       LDPDAdef.h
*                                                                              
* Purpose:        definitions and structure for LDPDA related files.
*                                                                              
* Functions:      
*
* Author/Date:    Wei Wang, 12/97
*
********************************************************************************
* Modifications:
*                                                                              
* Comments:                                                                    
* 
* Concerns:
*
* $Header:   /export/phobos/pvcs/r_and_d/archives/scaleable/pea/LDPDAdef.h_v   1.1   02 Apr 1998 14:46:58   weiwang  $
******************************************************************************/

#ifndef _LDPDA_DEF_H_
#define _LDPDA_DEF_H_

#define PITCH_TABLE_SIZE      89  

#define EXTEND_CUT_LC   96   
#define FAR_EXTEND_CUT_LC   102

#define MAX_NPEAKS     (EXTEND_CUT_LC>>1)

#define NCAND   3 /* only 3 candidates: first one, high-possibility, last one */

#define FREQ_CUT_LC      76   /* 80 1200Hz;  was 64 (1000Hz) */
#define ENERGY_CUT_OFF  0.05F    /* 20% cut-off for the high end */


typedef struct
{
  float fLastP0;
  float fLastCost;
} LD_PDA_MBlk;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\lineintp.h ===
/*******************************************************************************
*                        Voxware Proprietary Material                          *
*                        Copyright 1996, Voxware, Inc                          *
*                            All Rights Reserved                               *
*                                                                              *
*                       DISTRIBUTION PROHIBITED without                        *
*                      written authorization from Voxware                      *
*******************************************************************************/
 
/*******************************************************************************
* $Header:   /export/phobos/pvcs/r_and_d/archives/scaleable/utils/Lineintp.h_v   1.0   06 Feb 1998 10:14:04   johnp  $
*******************************************************************************/
#ifndef LINEAR_H
#define LINEAR_H
 
void linearinterp ( const float fPitchDFT, float *fLogSeeVoc, 
                    const int iLfft2 );

#endif /* LINEAR_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\lineintp.c ===
/******************************************************************************
*
*                        Voxware Proprietary Material
*
*                        Copyright 1996, Voxware, Inc
*
*                            All Rights Reserved
*
*                       DISTRIBUTION PROHIBITED without
*
*                      written authorization from Voxware
*
******************************************************************************/
/******************************************************************************
*
* Filename:    Lineintp.c
*
* Purpose:     Linearly interpolate the harmonic samples  
*
* Author:      Xiaoqin Sun
* Date         11/24/97
*
* $Header:   /export/phobos/pvcs/r_and_d/archives/scaleable/utils/Lineintp.c_v   1.1   10 Feb 1998 13:43:02   weiwang  $
*******************************************************************************
* Modifications:  
*
* Comments:
*
* Concerns:  
******************************************************************************/
#include <stdlib.h>
#include <math.h>
#include <assert.h>

#include "vLibMath.h"

#include "Lineintp.h"

#include "xvocver.h"

/******************************************************************************
*
* Function:  linearinterp()
*
* Action:    Sample the SeeVoc flat-top envelope at the pitch harmonics
*            and linearly interpolate through the peaks to create an
*            up-sampled envelope.
*
* Input:     float  fPitchDFT  --> pitch in DFT samples
*            float  fSeeVoc --> the SeeVoc flat-top (linear, not log)
*            int    iLfft2     --> length of input and output envelopes
*
* Output:    float  fLogSeeVoc --> log (base 2) of the spline envelope
*
* Return:    None
*******************************************************************************
*
* Implementation/Detailed Description:
*
*   Subroutine which samples the flattop seevoc envelope
*   at the pitch harmonics and linearly interpolate them to 
*   create the upsampled envelope. By using the
*   equally-spaced harmonic samples, the computational
*   complexity is reduced significantly. To maintain control
*   on real-time, the number of peaks allowed in the interpolation
*   is limited to NPEAKS_LINEAR. This has the effect of 
*   fitting a linear envelope in at least the baseband region
*   for low-pitched speakers and over the whole range for
*   high-pitch speakers. It is probably the latter case that is
*   more important. In that region for which the linear interpolation was
*   not computed, the flattop envelope is used.
*
* References:
******************************************************************************/

/* Limit number of peaks in spline routine to maintain real-time */
#define NPEAKS_LINEAR   80  
 
void linearinterp (const float fPitchDFT, float *fSeeVoc, const int iLfft2 ) 
{
   int    i, k;
   int    iPeaks;
   int    iTemp;
   int   *piFreqLoc;
   float  fSeeFreq;
   float *pfX;
   float *pfY;
   float  fScratchRam[4*NPEAKS_LINEAR+8];     /* scratch memory */

   /* Compute the number of harmonic peaks to interpolate */
   iPeaks = (int)((iLfft2-1)/fPitchDFT);
   iPeaks ++;                           /* count the extra peak at DC */
   if (iPeaks > NPEAKS_LINEAR)
      iPeaks = NPEAKS_LINEAR;
   
   pfY = fScratchRam;
   pfX = fScratchRam + iPeaks + 4;
   piFreqLoc = (int *) (fScratchRam + 2*(iPeaks+4)) ;

   /* Sample the flattop envelope at the pitch harmonics */
   fSeeFreq = 0.0F;
   for (i = 0; i < iPeaks; i++)
   {
      VoxROUND2pos( fSeeFreq, iTemp );
      pfY[i] = fLog2( fSeeVoc[iTemp] );
      piFreqLoc[i] = iTemp;
      pfX[i] = fSeeFreq;
      fSeeFreq += fPitchDFT;
   }

   pfY[iPeaks]=fLog2(fSeeVoc[iLfft2-1]);
   piFreqLoc[iPeaks] =iLfft2;
   pfX[iPeaks]=(float) (iLfft2-1);

   for(i=1; i<iPeaks+1;i++)
   {
   for(k=piFreqLoc[i-1]; k<piFreqLoc[i]; k++)
   fSeeVoc[k]=pfY[i-1]+(pfY[i]-pfY[i-1])*(k-pfX[i-1])/(pfX[i]-pfX[i-1]);
   }
 }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\lpc.h ===
#ifndef LPC_H_
#define LPC_H_
/***********************************************************************
 *
 * Filename:  calcLPC.h
 *
 * Purpose:   calculate the LPC coefficients using autocorrelation method.
 *
 * Reference: any digital speech processing book.
 *
 * Author:    Wei Wang
 *
 * Date:      Oct. 07, 1996.
 *
 ***********************************************************************/

/***************************************************
 * Function: calcLPC()
 *
 * Input:  pIn:  input data pointer.
 *         length: input data length.
 *         pLPCoef: LPC coefficients pointer (output).
 *         pResidueEng:  residue energy (output).
 *         pWinFrameEng: windowed signal energy (output).
 *         lpcOrder: LPC order.
 *         expandCoef: expansion coefficients.
 *         myLPC_mblk: pointer of the LPC structure.
 *
 * Output:  None.
 ***************************************************/
void VoxCalcLPC(STACK_R float *pIn, int length, float *pLPCoef, float *pResidueEng,
	     float expandCoef, float *autocorr_buf);

#endif /* end of #ifndef LPC_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\ldpda.h ===
/*******************************************************************************
*                        Voxware Proprietary Material                          *
*                        Copyright 1997, Voxware, Inc                          *
*                            All Rights Reserved                               *
*                                                                              *
*                       DISTRIBUTION PROHIBITED without                        *
*                      written authorization from Voxware                      *
******************************************************************************/

/*******************************************************************************
* Filename:       LDPDA.h
*                                                                              
* Purpose:        Estimate pitch using frequency domain cost function and back-
*                 ward tracking.
*                                                                              
* Functions:      VoxLDPDA(), GetPitchTable(),
*                 VoxInitLDPDA(), VoxFreeLDPDA()
*
* Author/Date:    Original developed by Gerard Aguilar   01/97
*                 Enhanced R&D by Wei Wang   04/97
*
********************************************************************************
* Modifications:
*                3/30/98, W.W. Rewrite whole file and use inter-leave format
*                spectrum. 
*  
*                05/97, W.W.
*                (1) Use longer table and change the boundary calculation. 
*                      (LDPDA.1)
*                (2) Change the boundary calculation using masker value and 
*                      use cosine table. (LDPDA.2).
*                (3) Use pitch table instead of fundamental frequency table.
*                (4) reduce table to 86 entries and expand the candidate from 
*                      8 to 160.
*                (5) add refinement for best candidates.
*                (6) when pitch is noise-like or (plusive), put pitch value 
*                      higher.
*                (7) put fix-point indeces for Calc_Cost_Func and VoicingLD.
*                                                                              
* Comments:                                                                    
* 
* Concerns:
*
* $Header:   /export/phobos/pvcs/r_and_d/archives/scaleable/pea/LDPDA.h_v   1.1   02 Apr 1998 14:46:56   weiwang  $
******************************************************************************/

#ifndef _LDPDA_H_
#define _LDPDA_H_

/******************************************************************************
* Function:  VoxLDPDA
*
* Action:    Estimate pitch value from frequency domain spectrum. This is 
*            the main function for coarse pitch calculation.
*
* Input:     pfSW -- input spectrum
*            hLD_PDA_mblk -- PDA structure
*
* Output:    none
*
* Globals:   none
*
* Return:    pitch value
*******************************************************************************
*
* Implementation/Detailed Description:
*
*******************************************************************************
*
* Modifications:
*
* Comments:
*
* Concerns/TBD:
*
******************************************************************************/

float VoxLDPDA( STACK_R 
                const float *pfSW, 
                void        *hLD_PDA_mblk
              );

/******************************************************************************
* Function:  GetPitchTable()
*
* Action:    Export pitch table and table size.
*
* Input:     pfPitchTable -- pointer for output pitch table
*            piSize       -- pointer for output table size  
*
* Output:    pfPitchTable -- pitch table
*            piSize       -- table size
*
* Globals:   none
*
* Return:    none
*******************************************************************************
*
* Modifications:
*
* Comments:
*
* Concerns/TBD:
*
******************************************************************************/

void GetPitchTable( float  **pfPitchTable, 
                    int    *piSize
                  );

/******************************************************************************
* Function:  VoxInitLDPDA()
*
* Action:    initialize LDPDA memory block.
*
* Input:     hLD_PDA_mblk -- pointer to LDPDA memory block
*
* Output:    hLD_PDA_mblk -- initialized LDPDA memory block
*
* Globals:   none
*
* Return:    none
*******************************************************************************
*
* Modifications:
*
* Comments:
*
* Concerns/TBD:
*
******************************************************************************/

unsigned short VoxInitLDPDA(void **hLD_PDA_mblk);



/******************************************************************************
* Function:  VoxFreeLDPDA()
*
* Action:    free the memory which's allocated for LDPDA memory block.
*
* Input:     hLD_PDA_mblk -- pointer to LDPDA memory block
*
* Output:    hLD_PDA_mblk -- memory-freed LDPDA memory block
*
* Globals:   none
*
* Return:    none
*******************************************************************************
*
* Modifications:
*
* Comments:
*
* Concerns/TBD:
*
******************************************************************************/

unsigned short VoxFreeLDPDA(void **hLD_PDA_mblk);

#endif  /* _PITCH_H*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\lpcorder.h ===
#define MAXLPC_ORDER 10

#define CODEC_LPC_ORDER 10
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\lpcsynth.c ===
/*******************************************************************************
*                        Voxware Proprietary Material                          *
*                        Copyright 1996, Voxware, Inc                          *
*                            All Rights Reserved                               *
*                                                                              *
*                       DISTRIBUTION PROHIBITED without                        *
*                      written authorization from Voxware                      *
*******************************************************************************/

/*******************************************************************************
* Filename:       lpcSynth.c
*                                                                              
* Purpose:        Pass the excitation throught the lpc synthesis filter.
*                 Interpolate the filter for each subframe.
*                                                                              
* Functions:      VOXErr VoxInitLPCSyn(Synthesis *mySynthesis_mblk);
*                 VOXErr VoxFreeLPCSyn(Synthesis *mySynthesis_mblk);
*                 VOXErr VoxLPCSyn(float *lsp, short *SpeechOutBuf, 
*                                  float *exciteIN, Synthesis *mySynthesis_mblk,
*                                  short outputLEN);
*                                                                              
* Author/Date:    Rob Zopf   02/08/96
*
********************************************************************************
* Modifications:Ilan Berci/ 10/96 Removed global dependencies
*                                 Modularized code segments (Encapsulation)
*                                 Removed scope changes
*                                 Changed error code procedure
*                                 Removed useless code segments
*                                 General optimization
*                                                                              
* Comments:                                                                    
* 
* Concerns:        !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
*                  /   - NOTE : this buffer must be of length
*                  /     FRAMELEN+LPC_ORDER with the first sample
*                  /     of the excitation at exciteIN[LPC_ORDER].
*                  /     This is to allow for the filter memory.
*                  /
*                  /   - ANOTHER NOTE: this routine will spoil the data
*                  /     inside of exciteIN
*                  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
*
* $Header:   /export/phobos/pvcs/r_and_d/archives/realtime/decode/lpcSynth.c_v   1.4   20 Apr 1998 14:41:38   weiwang  $
*******************************************************************************/

#include <stdlib.h>
#include <math.h>
#include <string.h>
#include <limits.h>
#include <assert.h>

#include "VoxMem.h"
#include "model.h"
#include "vLibTran.h" /* VoxLspToAsEven() */
#include "vLibVec.h"  /* DotProd()        */

#include "lpcSynth.h"

#include "xvocver.h"

static const float cfInvRate8k = 1.0F/RATE8K;

/*******************************************************************************
* Function:
*
* Action:
*
* Input:          lsp      : the quantized original lsp's
*           SpeechOutBuf   : the output buffer of length "FRAMELEN_29"
*               exciteIN   : the excitation
*                prevLSP   : the previous frame lsp's
*              interpLSP   : buffer for interpolating into
*               interLPC   : buffer for converting interpolated lsp's
*                 lpcMEM   : the memory of the synthesis filter
*
* Output:   SpeechOutBuf   : the synthetic speech
*                 lpcMEM   : the updated synthesis filter memory
*
* Globals:        none
*
* Return:        VOXErr : Voxware return code
********************************************************************************
* Implementation/Detailed Description:
*
* References:
********************************************************************************
* Modifications:
*
* Comments:
*
* Concerns/TBD:
*******************************************************************************/
unsigned short VoxLPCSyn( STACK_R 
                          float *lsp, 
                          float *exciteIN, 
                          void  *pSynthesis_mblk, 
                          short  outputLEN
                        )
{
   Synthesis *Synthesis_mblk = (Synthesis *)pSynthesis_mblk;
   float     *prevLSP        = Synthesis_mblk->prevLSP;

   STACK_INIT
   float    interpLSP[LPC_ORDER];
   float    interpLPC[LPC_ORDER+1];
   STACK_INIT_END
   STACK_ATTACH(float*,interpLSP)
   STACK_ATTACH(float*,interpLPC)
   float   *lpcMEM = Synthesis_mblk->lpcMEM;
   int      SubFrame, Samp, Index;
   float    InterpFactor;
   int      SampsDone;
   float    temp;
   float   *pexciteIN, *Offset_exciteIN;
   short    SubframeLen;
   short    TrueSubLen;
   float    deltaInterp;
   int      i;
   float   *pSpeech;

   STACK_START

 /*--------------------------------------------------
   Compute the number of lsf subframes we should use
   --------------------------------------------------*/
   TrueSubLen  = (short)(((float)outputLEN)*(1.0/(float)LPCSYN_SUBFRAMES));
   SubframeLen = TrueSubLen>>1;  /* first subframe is half */
   deltaInterp = (1.0F/((float)LPCSYN_SUBFRAMES));

 /*------------------------------------------------
   Copy the memory into the input buffer
   ------------------------------------------------*/
   memcpy(exciteIN, lpcMEM, LPC_ORDER*sizeof(*exciteIN));

 /*------------------------------------------------
   For each Subframe ...
      1. Interpolate the lsp's
      2. Convert lsp's to lpc's
      3. Filter 1 subframe worth of excitation
   ------------------------------------------------*/
   SampsDone=0;
   Offset_exciteIN = exciteIN; /* speeds stuff up below */
   InterpFactor = 0.0F;
   VoxLspToAsEven(prevLSP, LPC_ORDER, cfInvRate8k, interpLPC);

   for (SubFrame=0; SubFrame<=LPCSYN_SUBFRAMES; SubFrame++)
   {
      for (i=0;i<(LPC_ORDER>>1);i++)
      {
         temp = interpLPC[i+1];
         interpLPC[i+1] = -interpLPC[LPC_ORDER-i];
         interpLPC[LPC_ORDER-i] = -temp;
      }

      if (SubFrame == (LPCSYN_SUBFRAMES))
          SubframeLen = outputLEN - SampsDone;

      for (Samp = SampsDone; Samp<(SampsDone+SubframeLen); Samp++)
      {
         temp=0.0F;
         pexciteIN = Offset_exciteIN+Samp;

         temp = (float)DotProd(pexciteIN, interpLPC+1, LPC_ORDER);
         *(pexciteIN+LPC_ORDER)+=temp;
      }
      SampsDone+=SubframeLen;
      SubframeLen = TrueSubLen;

      InterpFactor += deltaInterp;
      if (SubFrame == (LPCSYN_SUBFRAMES-1))
      {
         VoxLspToAsEven(lsp, LPC_ORDER, cfInvRate8k, interpLPC);   
      }
      else
      {
         for (Index=0; Index<LPC_ORDER; Index++)
         {
            interpLSP[Index] = prevLSP[Index]+((lsp[Index]-prevLSP[Index])*InterpFactor);
         }

       /*-----------------------------------------------------
         Make sure that after interpolation, that the lsp's
         are seperated by at least LSP_SEPERATION_HZ Hertz
         -----------------------------------------------------*/
         for (Index=1; Index<LPC_ORDER; Index++)
            if ((interpLSP[Index] + LSP_SEPERATION_HZ)<interpLSP[Index-1])
               interpLSP[Index] = (float)(interpLSP[Index-1]+LSP_SEPERATION_HZ);

         VoxLspToAsEven(interpLSP, LPC_ORDER, cfInvRate8k, interpLPC);
      }
   }

 /*---------------------------------------------------------
   Update frame-to-frame memory of lsps, filter...
   ---------------------------------------------------------*/ 
   memcpy(Synthesis_mblk->prevLSP, lsp, LPC_ORDER*sizeof(*Synthesis_mblk->prevLSP));
   memcpy(Synthesis_mblk->lpcMEM, &(Offset_exciteIN[outputLEN]),
          sizeof(*Synthesis_mblk->lpcMEM)*LPC_ORDER);

 /*--------------------------------------------------------
   Check overflow before writing to the SHORT output buffer
   --------------------------------------------------------*/
   pSpeech = Offset_exciteIN + LPC_ORDER;
   for (Index=0; Index<outputLEN; Index++)
   {
      if (pSpeech[Index] > (float)SPEECH_CLIP_MAX)
         pSpeech[Index] = (float)SPEECH_CLIP_MAX;
      else if (pSpeech[Index] < (float)SPEECH_CLIP_MIN)
         pSpeech[Index] = (float)SPEECH_CLIP_MIN;
   }


   STACK_END
   return 0;
} 

/*******************************************************************************
* Function:       VOXErr VoxInitLPCSyn(Synthesis *Synthesis_mblk)
*
* Action:         Initializes the LPCSyn struct
*
* Input:
*
* Output:
*
* Globals:        none
*
* Return:         VOXErr : Voxware return code
********************************************************************************
* Implementation/Detailed Description:
*
* References:
********************************************************************************
* Modifications:
*
* Comments:
*
* Concerns/TBD:
*******************************************************************************/
unsigned short VoxInitLPCSyn(void **hSynthesis_mblk)
{
   Synthesis *Synthesis_mblk;
   short i;

   if(VOX_MEM_INIT(Synthesis_mblk=*hSynthesis_mblk,1,sizeof(Synthesis)))
      return 1;

   if(VOX_MEM_INIT(Synthesis_mblk->prevLSP,LPC_ORDER,sizeof(float))) 
      return 1;

   if(VOX_MEM_INIT(Synthesis_mblk->lpcMEM,LPC_ORDER,sizeof(float))) 
      return 1;

   for(i=0;i<LPC_ORDER;i++) 
      (Synthesis_mblk->lpcMEM)[i]=0.0F;

      for(i=0;i<LPC_ORDER;i++) 
		Synthesis_mblk->prevLSP[i] = LSP_INITIAL_COND_DEL*i + LSP_INITIAL_COND_0;

   return 0;
}

/*******************************************************************************
* Function:       VOXErr VoxFreeLPCSyn(Synthesis *Synthesis_mblk)
*
* Action:         frees up the LPCSyn struct
*
* Input:
*
* Output:
*
* Globals:        none
*
* Return:        VOXErr : Voxware return code
********************************************************************************
* Implementation/Detailed Description:
*
* References:
********************************************************************************
* Modifications:
*
* Comments:
*
* Concerns/TBD:
*******************************************************************************/
unsigned short VoxFreeLPCSyn(void **hSynthesis_mblk)
{
   Synthesis *Synthesis_mblk=(Synthesis *)*hSynthesis_mblk;

   if(*hSynthesis_mblk) {
      VOX_MEM_FREE(Synthesis_mblk->prevLSP);
      VOX_MEM_FREE(Synthesis_mblk->lpcMEM);

      VOX_MEM_FREE(*hSynthesis_mblk);
   }

   return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\log2.c ===
/******************************************************************************
*                        Voxware Proprietary Material
*                        Copyright 1996, Voxware, Inc
*                            All Rights Reserved
*
*                       DISTRIBUTION PROHIBITED without
*                      written authorization from Voxware
******************************************************************************/
 
/******************************************************************************
*
* Filename:    fLog2.c
*
* Purpose:     approximations to log and inverse log base 2
*
* Functions:   fLog2() and fInvLog2()
*
* Author/Date: Bob Dunn 1/16/97
*
*******************************************************************************
*
* Modifications:  Xiaoqin Sun: speed up for IEEE floating point machine
*                 Wei Wang: clean up the code. And add define IEEE.
*
* Comments:       To speed up the code on other non-IEEE floating point machine,
*                 we just need to know the bits for mantissa and exponent.
*
* Concerns:     (1) Need choose LINEAR_LOG2 or QUAD_LOG2
*               (2) If choose pre-definition IEEE, float and long should be 32 bits
*
* $Header:   /export/phobos/pvcs/pvcsproj/voxlib.prj/Log2.c_v   1.8   07 Apr 1998 17:55:52   weiwang  $
*
******************************************************************************/
#include <assert.h>
#include <math.h>
#include "vLibMath.h"

#include "xvocver.h"

#define LINEAR_LOG2         1
#define QUAD_LOG2           2

#define LOG2_TYPE        LINEAR_LOG2 

/*------------------------------------------------------------------
  If IEEE or WIN32 is defined then use hard-wired fast code to 
    break a floating point number into its exponent and mantissa,
    or to create a floating point number into its exponent and 
    mantissa.
------------------------------------------------------------------*/
#if ((defined(IEEE) == 1) || (defined(WIN32) == 1))

static float VoxfrExp(float fx, int *piExponent);
static float VoxldExp(float fMant, int iExponent);

/*------------------------------------------------------------------
  If IEEE or WIN32 is not defined then use frexp() break a floating 
    point number into its exponent and mantissa and use ldexp() 
    to create a floating point number into its exponent and mantissa.
------------------------------------------------------------------*/
#else

#define VoxfrExp(fx, piExponent)  (float)frexp((double)fx, piExponent)
#define VoxldExp(fMant, iExponent) (float)ldexp((double)fMant, iExponent)

#endif /* else of ((defined(IEEE) == 1) || (defined(WIN32) == 1)) */


/******************************************************************************
  Forward and inverse of the base 2 logarithm using linear interpolation.
    This is less accurate than quadratic interpolation but it is exactly
    invertable because a linear function has an exact linear inverse function.
******************************************************************************/
#if (LOG2_TYPE == LINEAR_LOG2)

/******************************************************************************
*
* function:  float fLog2 (float fx) 
*
* Action:    approximation to log_base_2
*
* Input:     fx -- input number 
*
* Output:    same as return
*
* Globals:   none
*
* Return:    approximation to log_base_2 value
*
*******************************************************************************
*
* Implementation/Detailed Description: 
*
*     The base 2 logarithm is approximated by LINEAR interpolation in
*  region (0.5 <= X < 1.0).  The floating point input number is normalized to 
*  this region by separating it into mantissa and exponent.  The integer
*  portion of the logarithm is the exponent and the fractional portion
*  of the logarithm is approximated by LINEAR interpolation the mantissa.
*
* References:
*******************************************************************************
*
* Modifications:
*
* Comments:
*
* Concerns/TBD:
******************************************************************************/
float fLog2 (float fx) 
{
  int    iExponent;
  float  fLogB2;
  float  fMant;

  /*------------------------------------------------------------
    Change fx to fMant * 2**iExponent,  with 0.5 <= fMant < 1.0.
  ------------------------------------------------------------*/
  fMant = (float)VoxfrExp(fx, &iExponent);  

  /*------------------------------------------------------------
    Do linear interpolation.
  ------------------------------------------------------------*/
  fLogB2 = (float)iExponent + 2.0F*(fMant - 1.0F);

  return (fLogB2);
}

/******************************************************************************
*
* Function:  float fInvLog2 (float fLogB2) 
*
* Action:    approximation to 2**log_b2
*
* Input:     fLogB2 -- input number 
*
* Output:    same as return
*
* Globals:   none
*
* Return:    inverse log2 value of fx
*
*******************************************************************************
*
* Implementation/Detailed Description:
*
*     The inverse of the base 2 logarithm is approximated by LINEAR 
*  interpolation in region (0.5 <= X < 1.0).  The integer part of the
*  floating point input number is loaded into the exponent of the result.
*  The fractional part of the input number is LINEARLY interpolated
*  to be in the region (0.5 <= X < 1.0) and is loaded into the 
*  mantissa portion of the result.
*
* References:
*******************************************************************************
*
* Modifications:
*
* Comments:
*
* Concerns/TBD:
******************************************************************************/
float fInvLog2 (float fLogB2) 
{
  int   iExponent;
  float fx, fLogMant, fMant;

  /*------------------------------------------------------------
    Find exponent value.
  ------------------------------------------------------------*/
  iExponent = (int)VoxFLOOR(fLogB2)+1;

  /*------------------------------------------------------------
    compute mantissa which between 0.5 to 1.0 
  ------------------------------------------------------------*/
  fLogMant = fLogB2 - iExponent;      /* -1.0 <= fLogMant < 0.0 */
  //assert((fLogMant < 0.0F) && (fLogMant >= -1.0F));

  fMant = 0.5F*fLogMant + 1.0F;       /* 0.5 <= fMant < 1.0 */
  //assert((fMant < 1.0F) && (fMant >= 0.5F));

  /*------------------------------------------------------------
    fx = fMant * 2**iExponent 
  ------------------------------------------------------------*/
  fx = (float)VoxldExp(fMant, iExponent);  
 
  return ( fx );
}

/******************************************************************************
  Forward and inverse of the base 2 logarithm using quadratic interpolation.
    This is more accurate than linear interpolation but it is not exactly
    invertable because the quadratic function does not have an exact 
    quadratic inverse function.
******************************************************************************/
#elif (LOG2_TYPE == QUAD_LOG2) /* else use quadratic interpolation */


/*------------------------------------------------------------
  Constants for quadratic interpolation of the base 2 
    logarithm on the interval (0.5 <= X < 1.0)
------------------------------------------------------------*/
static const float a_logb2 = -1.3594F;
static const float b_logb2 =  4.0391F;
static const float c_logb2 = -2.6797F;
static const float a_ilogb2 = 0.171572F;
static const float b_ilogb2 = 0.671572F;
static const float c_ilogb2 = 1.000000F;
 
/******************************************************************************
*
* function:  float fLog2 (float fx) 
*
* Action:    approximation to log_base_2
*
* Input:     fx -- input number 
*
* Output:    same as return
*
* Globals:   none
*
* Return:    approximation to log_base_2 value
*
*******************************************************************************
*
* Implementation/Detailed Description: 
*
*     The base 2 logarithm is approximated by QUADRATIC interpolation in
*  region (0.5 <= X < 1.0).  The floating point input number is normalized to 
*  this region by separating it into mantissa and exponent.  The integer
*  portion of the logarithm is the exponent and the fractional portion
*  of the logarithm is approximated by QUADRATIC interpolation the mantissa.
*
* References:
*******************************************************************************
*
* Modifications:
*
* Comments:
*
* Concerns/TBD:
******************************************************************************/
float fLog2 (float fx) 
{
  int    iExponent;
  float  fLogB2;
  float  fMant;

  /*------------------------------------------------------------
    Change fx to fMant * 2**iExponent,  with 0.5 <= fMant < 1.0.
  ------------------------------------------------------------*/
  fMant = (float)VoxfrExp(fx, &iExponent);  /* 0.5 <= fMant < 1.0 */

  /*------------------------------------------------------------
    Do quadratic approximation.
  ------------------------------------------------------------*/
  fLogB2  =  b_logb2 + a_logb2*fMant;
  fLogB2  =  c_logb2 + fLogB2*fMant;
  fLogB2 += (float)iExponent;

  return (fLogB2);
}

/******************************************************************************
*
* Function:  float fInvLog2 (float fLogB2) 
*
* Action:    approximation to 2**log_b2
*
* Input:     fLogB2 -- input number 
*
* Output:    same as return
*
* Globals:   none
*
* Return:    inverse log2 value of fx
*
*******************************************************************************
*
* Implementation/Detailed Description:
*
*     The inverse of the base 2 logarithm is approximated by QUADRATIC 
*  interpolation in region (0.5 <= X < 1.0).  The integer part of the
*  floating point input number is loaded into the exponent of the result.
*  The fractional part of the input number is QUADRATICLY interpolated
*  to be in the region (0.5 <= X < 1.0) and is loaded into the 
*  mantissa portion of the result.
*
* References:
*******************************************************************************
*
* Modifications:
*
* Comments:
*
* Concerns/TBD:
******************************************************************************/
float fInvLog2 (float fLogB2) 
{
  int   iExponent;
  float fx, fLogMant, fMant;

  /*------------------------------------------------------------
    Find exponent value.
  ------------------------------------------------------------*/
  iExponent = (int)VoxFLOOR(fLogB2)+1;

  /*------------------------------------------------------------
    compute mantissa which between 0.5 to 1.0 
  ------------------------------------------------------------*/
  fLogMant = fLogB2 - iExponent;      /* -1.0 < fLogMant < 0.0 */

  /* approximates 2**fLogMant */
  fx = b_ilogb2 + a_ilogb2*fLogMant;
  fMant = c_ilogb2 + fx*fLogMant;
  
  /*------------------------------------------------------------
    fx = fMant * 2**iExponent 
  ------------------------------------------------------------*/
  fx = (float)VoxldExp(fMant, iExponent);      /* fx = fMant * 2**iExponent */

  return ( fx );
}
#endif


#if ((defined(IEEE) == 1) || (defined(WIN32) == 1))

#define  MANT_BITS   23
#define  EXP_BITS    8
#define  EXP_MASK    (0x7F800000L)        /* ((1<<8)-1)<<23 */
#define  EXP_OFFSET  127               /* offset for exponent (2^(8-1)) */
#define  MANT_MASK   (0x007FFFFFL)        /* (1<<23-1) */
#define  EXP_SHIFT_MASK   ((long)EXP_MASK >> MANT_BITS)
#define  SHIFT_EXP_OFFSET  ((long)EXP_OFFSET << MANT_BITS)

typedef union {
  float f;
  long  l;
} UnionFltInt;


/******************************************************************************
*
* Function:  static float VoxfrExp(float fx, int *piExponent)
*
* Action:    find out exponent and mantissa of a floating number
*
* Input:     fx -- input number
*            *piExponent -- address to output exponent.
*
* Output:    *piExponent -- exponent of fx.
*
* Globals:   none
*
* Return:    mantissa of fx
*
*******************************************************************************/

static float VoxfrExp(float fx, int *piExponent)
{
  UnionFltInt ux;
  int iExponent;
  float fMant;

  /**** change the float to 32 bits int */
  ux.f = fx;
  /**** find the exponent by shifting out mantissa bits ****/
  iExponent = (int)((ux.l & EXP_MASK) >> MANT_BITS);
  iExponent -= EXP_OFFSET;
  
  /**** find the mantissa part by masking out the exponent bits ****/
  ux.l= (ux.l & MANT_MASK) | SHIFT_EXP_OFFSET;   /* 1.0 < ux.f < 2.0 */
  fMant = ux.f * 0.5F;   /*    0.5< fMant < 1.0 */
  iExponent ++;        /*   normalize iExponent   */

  *piExponent = iExponent;
  return fMant;
}


/******************************************************************************
*
* Function:  static float VoxldExp(float fMant, int iExponent)
*
* Action:    reconstruct a number from exponent and mantissa.
*
* Input:     fMant -- mantissa
*            iExponent -- exponent
*
* Output:    same as Return
*
* Globals:   none
*
* Return:    reconstructed number from fMant and iExponent.
*
*******************************************************************************/

static float VoxldExp(float fMant, int iExponent)
{
  UnionFltInt ux;
  float fx;
  long lExponent;

  /* reconstruct exponent part */
  iExponent --;
  lExponent = ((long)(iExponent+EXP_OFFSET)<<MANT_BITS) & EXP_MASK;

  /* reconstruct mantissa part */
  ux.f = fMant;
  ux.l = (ux.l & MANT_MASK);

  /* combine exponent and mantissa parts */
  ux.l |= lExponent;

  fx = ux.f;

  return fx;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\lsfmeans.h ===
0.10912769F,
0.08262001F,
0.07525391F,
0.06680944F,
0.05781475F,
0.07241241F,
0.17121615F,
0.12163067F,
0.11356869F,
0.11027470F,
0.11181328F,
0.12813650F,
0.24106951F,
0.20312575F,
0.18237612F,
0.18318250F,
0.19332724F,
0.21179096F,
0.32244856F,
0.27881635F,
0.26635510F,
0.26887181F,
0.29535888F,
0.31519017F,
0.40456506F,
0.39200013F,
0.38821710F,
0.38316026F,
0.39532312F,
0.40060226F,
0.49018149F,
0.47113935F,
0.46139180F,
0.46226018F,
0.47895205F,
0.49248077F,
0.59056391F,
0.58094382F,
0.57220708F,
0.57260393F,
0.58677315F,
0.59634768F,
0.67202014F,
0.67733475F,
0.66447171F,
0.66235625F,
0.66845701F,
0.67315619F,
0.78800974F,
0.77461102F,
0.76271044F,
0.76533801F,
0.77688964F,
0.78942320F,
0.85491866F,
0.84413055F,
0.83658918F,
0.84099653F,
0.85051266F,
0.85571767F
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\lspmsvq.h ===
#ifndef LSPMSVQ_H
#define LSPMSVQ_H

typedef struct tagMSVQ_RT29
{
   float			*dMin;
   float			*cand;
   short			*index;
   short			*nextIndex;
   float			*u;
   float			*weight;
   float			*lpc;
   short *newIndex;
   float *newresidue;
} MSVQ_mblk;

/**************************************************************
 * LSF - MSVQ Definitions
 **************************************************************/
#ifndef GLOBAL_MSVQ_DEFINES
#define GLOBAL_MSVQ_DEFINES

#define MAX_TABLESIZE_MSVQ      16
#define MAX_NUMSTAGES_MSVQ      8
#define MAX_TABLEDIM_MSVQ       10
#define MAX_NUMCAND_MSVQ        16

/* the max for the combination */
#define MAX_NUMCANDxTABLEDIM_MSVQ   (MAX_NUMCAND_MSVQ*MAX_TABLEDIM_MSVQ)
#define MAX_NUMCANDxNUMSTAGES       (MAX_NUMCAND_MSVQ*MAX_NUMSTAGES_MSVQ) 

#define D_MAX    180.0F   /* max group delay (sec) * fs */
#define D_CRIT   11.0F    /* critical value (sec) * fs */
#define D_RATIO  0.02247F /* 1/sqrt(D_MAX*D_CRIT) */
#define W_CRIT   0.25F    /* lsp corresponding to 1000 Hz */
#define LSPDIFF_THRESHOLD 0.01F
#ifndef     MTH_MIN
#define     MTH_MIN(a,b)   ((a <= b) ? a : b)
#endif

#ifndef		FLT_MAX
#define     FLT_MAX     3.40282E+38
#endif

#ifndef		FLT_MIN
#define     FLT_MIN     1.17549E-38
#endif

#ifndef     MTH_SQR
#define     MTH_SQR(x) ((x) * (x))
#endif

typedef struct
{
   float re,im;   /* real & imaginary part */
} MTHT_complex;


#endif /* GLOBAL_MSVQ_DEFINES */

unsigned short VoxLspMSVQ(float vectin[], float lpcin[], unsigned short cbNdx[], 
                         MSVQ_mblk *myMSVQ_mblk, short numStages, short numCand, 
                         int dim, short tableSize, const float **cb);

unsigned short VoxDecLspMSVQ(unsigned short index[], float vect[], const float **cb, 
                               short dim, short numStages);

unsigned short VoxInitMSVQ(void** hMSVQ_mblk);
unsigned short VoxFreeMSVQ(void **hMSVQ_mblk);

#endif /* LSPMSVQ_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\lspmsvq.c ===
/*
 * File:     MSVQlpc.c
 *
 * Project:  RT24-HQ
 * 
 * Written by Rob Zopf.
 *
 * Modified by Xiangdong Fu
 *
 * Copyright 1996  Voxware, Inc.
 *
 */
#include <stdlib.h>
#include <math.h>
#include <assert.h>
#include "VoxMem.h"
#include "LspMSVQ.h"
#include "model.h"

#include "xvocver.h"

#ifdef _WIN64
#undef WIN32
#endif

#ifdef WIN32
static float CalcWeightedMSE(float *weight,float *x, float *y, int Len);
#endif
/* *******************************************************************
   NAME: VQstfCoeffs

   DESCRIPTION:
      Vector quantizes a set of short term filter coefficients
      using a multi-stage M-L tree search algorithm.

   INPUTS:
         vectin	     : vector for quantization [0...n-1]
         lpcin       : lpc coeffs for weighting (if quantizing lsf's) [0...n-1]
         myMSVQ_mblk : pointer to MSVQ structure
         numStages   : number of codebook stages
         numCand     : number of search candidates
         dim         : the dimension of vectin
         tableSize   : number of vectors in each MSVQ table
         cb          : codebooks;   cb[1..numStages]
         DoLSF       : 0 = general input, 1 = LSF input
   OUTPUTS:
         vectin      : quantized coefficients
         cbNdx       : codebook indeces; cbNdx[1..numStages]

   ***********************************************************************/
unsigned short VoxLspMSVQ (float vectin[], float lpcin[], unsigned short cbNdx[], MSVQ_mblk *myMSVQ_mblk,
                  short numStages, short numCand, int dim, short tableSize, 
                  const float **cb)
{
   short    c, s, entry, ncPrev,  i, r;
   float       d;
   short    *newIndex=myMSVQ_mblk->newIndex,*tempshort;
   float    *tempfloat,*u;
   float	*newresidue = myMSVQ_mblk->newresidue; 
   float	*dMin = myMSVQ_mblk->dMin;
   float	*residue = myMSVQ_mblk->cand;
   float	*cand = myMSVQ_mblk->cand;
   short	*index = myMSVQ_mblk->index;
   short	*nextIndex = myMSVQ_mblk->nextIndex;
   float	*uHat;
   float	*tbl;
   float	weight[LPC_ORDER];
   short	bestIndex, candBAD;   
   MTHT_complex      hw, dhw;
   float             dm_sq, cs, sn, tmp;
   int               k,j;


   for (r=0;r<dim;r++)  
 	  residue[r] =  vectin[r]/4000.0F;
    
   for(j=0; j <dim; j++) {
     cs = (float)cos((double)(residue[j]*PI));
     sn = -(float)sin((double)(residue[j]*PI));

     dhw.re = cs*dim*(-lpcin[dim-1]);
     dhw.im = sn*dim*(-lpcin[dim-1]);

     hw.re = cs*(-lpcin[dim-1]);
     hw.im = sn*(-lpcin[dim-1]);  
    
     for(i=dim-2; i >= 0; i--) {
        /* add a[i] */
        dhw.re += (float)(i+1)*(-lpcin[i]);
        hw.re += -lpcin[i];

        /* multiply by exp(-jw) */
        dhw.im = cs*(tmp=dhw.im) + sn*dhw.re;
        dhw.re = cs*dhw.re - sn*tmp;

        /* multiply by exp(-jw) */
        hw.im = cs*(tmp=hw.im) + sn*hw.re;
        hw.re = cs*hw.re - sn*tmp;

     }
     /* scale result by j and add 1 */
     tmp = dhw.re;
     dhw.re = -dhw.im;
     dhw.im = tmp;

     hw.re = 1.0F - hw.re;
     hw.im = -hw.im;

     dm_sq = hw.re*hw.re + hw.im*hw.im;

     /* catch divide by zero (zero on or very near unit circle)
        -1 indicates to calling routine that error (or something funny
            occurred) */
     if (dm_sq <= (float)FLT_MIN)
       weight[j] = 1.0F;  
     else if (dm_sq >= (float)FLT_MAX)
        weight[j] = (float)(dim+1)*D_RATIO;
        
     else  {
       weight[j] = (float)dim + 1.0F + 2.0F*(dhw.im*hw.re - dhw.re*hw.im)/dm_sq;

       if (weight[j] > D_MAX)
         weight[j] = 1.0F;
       else if (weight[j] > D_CRIT)
         weight[j] = (float)sqrt((double)weight[j]/D_MAX);
       else
         weight[j] *= D_RATIO;
     }
     if (residue[j] > W_CRIT)
         weight[j] *= 1.0F-2.0F*(residue[j]-W_CRIT)/3.0F;

   }

   

/*********************************************************************
   Initialize the data before starting the tree search.
      - the number of candidates from the "previous" stage is set
        to 1 since there is no previous stage!
      - the candidate vector from the previous stage is set to zero
      - the list of indeces for each candidate is set to 1
  *********************************************************************/
   for (c=0; c<numCand; c++) {
       for (s=0; s<numStages; s++)
         index[c*numStages+s] = nextIndex[c*numStages+s] = 0;
   }
   ncPrev = 1;
   
/* ********************************************************************
   Now we start the search:
      For each stage
         For each candidate from the previous stage
            For each entry in the current stage codebook
               * add the codebook vector to the current candidate
               * compute the distortion with the target
               * retain as a candidate if it is one of the best so far

   ******************************************************************** */
   for (s=0; s<numStages; s++) {
      /* set the distortions to huge values */
      for (c=0; c<numCand; c++)
         dMin[c] = (float)FLT_MAX;

	   /* Loop for each previous candidate selected, and try each entry */
     
      for (c=0, u=residue; c<ncPrev; u+=dim, c++) {   
         for (entry=0,uHat=(float *)cb[s]; entry <tableSize; entry++, uHat+=dim) {
#ifndef WIN32
            for(i=dim-1,d=0.0F;i>=0;i--)
 	            d += weight[i]*(MTH_SQR(uHat[i] - u[i]));
#else  /* WIN32 */
            d=CalcWeightedMSE(weight,uHat,u,dim);
#endif /* WIN32 */
/* ********************************************************************
   If the error for this entry is less than the worst retained
   candidate so far, keep it. Note that the error list is maintained
   in order of best (min error) to worst.
   ******************************************************************** */
            if (d < dMin[numCand-1]) { 
               for(k=numCand-1;k>0&&d<=dMin[k-1];k--) {
		            dMin[k] = dMin[k-1];
		            newIndex[k+k] = newIndex[k+k-2];
		            newIndex[k+k+1] = newIndex[k+k-1];
		         }
               dMin[k] = d;
               newIndex[k+k] = c;
               newIndex[k+k+1] = entry;
            }

         } /* for each entry */
      } /* Try out each previous candidate codevector */
    
/* ********************************************************************
   Compute the number of candidate vectors which we kept for the next
   stage. Note that if the size of the stages is less than the number
   of candidates, we build them up using all entries until we have
   kept numCand candidates.
   ******************************************************************** */
      ncPrev = MTH_MIN (ncPrev*tableSize, numCand);

/* ********************************************************************
   We now have the  best indeces for the stage just completed, so
   compute the new candidate vectors for the next stage...
   ******************************************************************** */
 	  for (c=0; c<ncPrev; c++) {
         register short newcand;
         newcand = newIndex[c+c]; 
         nextIndex[c*numStages+s] = newIndex[c+c+1];
         for (i=0; i<s; i++)
            nextIndex[c*numStages+i] = index[newcand*numStages+i];
         tbl = (float *)cb[s]+newIndex[c+c+1]*dim;
		   for (i =0; i<dim; i++)
			   newresidue[c*dim+i] = residue[newcand*dim+i]-tbl[i];
     }
     tempshort = index;
	  tempfloat = residue;
	  index = nextIndex;
	  residue = newresidue;
      nextIndex = tempshort;
      newresidue = tempfloat;
   } /* for each stage */
   for (c=0; c<numCand; c++) {
      for(i = 0; i<dim; i++) 
         cand[c*dim+i] = 0.0F;
         for (i=0; i<numStages; i++) {
            tbl = (float *)cb[i]+index[c*numStages+i]*dim;
            u = cand+c*dim;
            for (r=0; r<dim; r++)
                *u++ += *tbl++;
         }
   }

   i=1;    
   while (i<dim&&cand[i]>=cand[i-1]) i++;
   if (i<dim&&cand[i]<cand[i-1]) {
   for (j=2;j<=dim;j++) {
      i=j-1;
      while (i>0 && cand[i-1] > cand[j-1]) {
         cand[i]=cand[i-1];
         i--;
      }
      cand[i]=cand[j-1];
   }
   }
   for (c=0; c<numCand; c++){
      candBAD=0;
      for (i=1;i<dim;i++){
         if ((cand[c*dim+i]-cand[c*dim+i-1]) <LSPDIFF_THRESHOLD){
            candBAD=1; 
         }
      }
      if (candBAD==0){
         bestIndex=c;
         break;
      }
   }
   if ((c>=numCand)&&(candBAD==1)){
      bestIndex=0;
      for (i=1;i<dim;i++){
         if ((cand[c*dim+i]-cand[c*dim+i-1]) <LSPDIFF_THRESHOLD){
            cand[i] = cand[i-1]+LSPDIFF_THRESHOLD;
         }
      }
   }
   for (r=0; r<dim; r++)
      vectin[r] = cand[bestIndex*dim+r]*4000.0F;
   
   for (s=0; s<numStages; s++)
      cbNdx[s] = index[bestIndex*numStages+s];

   return 0;
} /* VQstfCoeffs */

/* *******************************************************************
   NAME: DecodeMSVQcoeffs

   DESCRIPTION:
         Decode the quantized vector using the MSVQ structure and
         the quantized indices.

   ********************************************************************/
unsigned short VoxDecLspMSVQ (unsigned short index[], float vect[], const float **cb, short dim, 
                       short numStages)
{
   int         i,j, s, ndx;
   float	*tbl;

   for (i=0; i<dim;i++)
         vect[i] = 0.0F;

   for (s=0; s<numStages; s++) {
       ndx = index[s];
       tbl = (float *)cb[s]+(ndx)*dim;
       for (i=0; i<dim; i++) 
           vect[i] += tbl[i];
   }


   /* ********************************************************************
      Note that we check to see if the quantized LSPs are stable, and if
      not, we sort them so that they are stable.  The this "trick" is
      (of course!) also used in the encoder.
      ******************************************************************** */
   i=1;    
   while (i<dim&&vect[i]>=vect[i-1]) i++;
   if (i<dim&&vect[i]<vect[i-1]) {
     for (j=2;j<=dim;j++) {
         i=j-1;
         while (i>0 && vect[i-1] > vect[j-1]) {
           vect[i]=vect[i-1];
           i--;
         }
         vect[i]=vect[j-1];
     }
   }
                  
     for (i=1;i<dim;i++){
         if ((vect[i]-vect[i-1]) < LSPDIFF_THRESHOLD)
             vect[i] = vect[i-1]+LSPDIFF_THRESHOLD;
     }

     /* un-normalize */
     for (i=0; i<dim; i++)
         vect[i] *= (4000.0F);

     return 0;

} /* DecodeMSVQcoeffs */


unsigned short VoxInitMSVQ(void** hMSVQ_mblk)
{
   MSVQ_mblk *pMSVQ_mblk;

   if (VOX_MEM_INIT(pMSVQ_mblk=*hMSVQ_mblk, 1, sizeof(MSVQ_mblk))) 
      return 1;


   if(VOX_MEM_INIT(pMSVQ_mblk->dMin,MAX_NUMCAND_MSVQ,sizeof(float))) 
      return 1;

   if(VOX_MEM_INIT(pMSVQ_mblk->cand,MAX_NUMCANDxTABLEDIM_MSVQ,sizeof(float))) 
      return 1;

   if(VOX_MEM_INIT(pMSVQ_mblk->index,MAX_NUMCANDxNUMSTAGES,sizeof(short))) 
      return 1;

   if(VOX_MEM_INIT(pMSVQ_mblk->nextIndex,MAX_NUMCANDxNUMSTAGES,sizeof(short))) 
      return 1;

   if(VOX_MEM_INIT(pMSVQ_mblk->u,MAX_TABLEDIM_MSVQ,sizeof(float))) 
      return 1;

   if(VOX_MEM_INIT(pMSVQ_mblk->lpc,MAX_TABLEDIM_MSVQ,sizeof(float))) 
      return 1;
  
   if(VOX_MEM_INIT(pMSVQ_mblk->newIndex,MAX_NUMCAND_MSVQ<<1,sizeof(short))) 
      return 1;

   if(VOX_MEM_INIT(pMSVQ_mblk->newresidue,MAX_NUMCANDxTABLEDIM_MSVQ,sizeof(float))) 
      return 1;

   return 0;
}


unsigned short VoxFreeMSVQ(void **hMSVQ_mblk)
{
   MSVQ_mblk *myMSVQ_mblk = (MSVQ_mblk *) *hMSVQ_mblk;

   VOX_MEM_FREE(myMSVQ_mblk->dMin);
   VOX_MEM_FREE(myMSVQ_mblk->cand);
   VOX_MEM_FREE(myMSVQ_mblk->index);
   VOX_MEM_FREE(myMSVQ_mblk->nextIndex);
   VOX_MEM_FREE(myMSVQ_mblk->lpc);
   VOX_MEM_FREE(myMSVQ_mblk->u);

   VOX_MEM_FREE(myMSVQ_mblk->newIndex);
   VOX_MEM_FREE(myMSVQ_mblk->newresidue);

   VOX_MEM_FREE(*hMSVQ_mblk);

   return 0;
}

#ifdef WIN32
#pragma warning(disable:4035)
static float CalcWeightedMSE(float *weight,float *x, float *y, int Len)
{
  _asm
  {
     mov ecx, Len;
     mov esi, x;
   
     mov ebx, weight;
     mov edi, y;
   
     fldz;
   
     fld st(0);

loop1:

     faddp st(1), st(0);

     /** difference **/
     fld DWORD PTR[esi];
   
     fsub DWORD PTR[edi];
   
     fld DWORD PTR[esi+4];
	  
	  fsub DWORD PTR[edi+4];
	  
	  fld DWORD PTR[esi+8];

     fsub DWORD PTR[edi+8];
 
     fld DWORD PTR[esi+12];
	  
	  fsub DWORD PTR[edi+12];
	  
	  fld DWORD PTR[esi+16];

     fsub DWORD PTR[edi+16];

     /** square **/
     fxch st(4);
     fmul st(0), st(0);   /* 1 ~4 ~3 ~2 ~5 */

     fxch st(3);
     fmul st(0), st(0);  /* 2,~4,~3 1, ~5 */

     fxch st(2);
     fmul st(0), st(0);  /* 3 ~4, 2, 1, ~5 */

     fxch st(1);
     fmul st(0), st(0);  /* 4, 3, 2, 1, ~5 */

     fxch st(4);
     fmul st(0), st(0);  /* 5, 3, 2, 1, 4 */

     /** multiple the weights **/
     fxch st(3);         /* ~1, 3, 2, 5, 4 */
     fmul DWORD PTR[ebx];

     fxch st(2);         /* ~2, 3, ~1, 5, 4 */
     fmul DWORD PTR[ebx+4];

     fxch st(1);
     fmul DWORD PTR[ebx+8]; /* ~3, ~2, ~1, 5, 4 */

     fxch st(4);
     fmul DWORD PTR[ebx+12];/* ~4, ~2, ~1, 5, ~3 */

     fxch st(3);
     fmul DWORD PTR[ebx+16];/* ~5, ~2, ~1, ~4, ~3 */

     fxch st(2);
     faddp st(5), st(0); /* 2, 5, 4, 3, 1+sum */

     faddp st(3), st(0); /* 5,4, 3+2 1+sum */

     faddp st(1), st(0); /* 4+5, 3+2, 1+sum */

     add ebx, 20;
     add esi, 20;

     add edi, 20;
     sub ecx, 5;

     fxch st(2);         /* 1+sum, 3+2 , 4+5 */
     faddp st(1), st(0); /* 1+sum+3+2, 4+5 */

     jnz    loop1;

     faddp st(1), st(0); /* add to one term */
  }
}

#ifdef _WIN64
#define WIN32
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\lsp2ase.c ===
/*******************************************************************************
*                        Voxware Proprietary Material
*                        Copyright 1996, Voxware, Inc
*                            All Rights Reserved
*
*                       DISTRIBUTION PROHIBITED without
*                      written authorization from Voxware
*******************************************************************************/
 
/*******************************************************************************
*
* Filename:     lsp2ase.c
*
* Purpose:      Convert LSPs to predictor coefficients for even order all-pole
*                 models.
*
* Functions:   void VoxLspToAsEven()
*
* Author/Date: Bob Dunn 1/28/98
*
********************************************************************************
*
* Modifications:
*
* Comments:
*
* Concerns:
*
* $Header:   G:/pvcsproj/voxlib.prj/lsp2ase.c_v   1.5   03 Mar 1998 09:44:06   weiwang  $
*******************************************************************************/
#include <math.h>
#include <assert.h>
 
#include "vLibDef.h"
#include "vLibTran.h"

#include "xvocver.h"

/*******************************************************************************
* Function:       void VoxLspToAsEven()
*
* Action:         Compute order predictor coefficients from LSPs for
*                   even ordered all-pole models.
*
* Input:          const float *pfLSP       -> LSPs
*                 int         iOrder       -> all-pole model order
*                 float       fScaleFactor -> scale factor to apply to LSPs
*                                               (when multiplied by fScaleFactor
*                                               the LSPs should range from 
*                                               0 to 0.5).
*
* Output:         float       *pfAs        -> 10th order predictor coefficients
*                                                where pfAs[0] = A_0 = 1.0
*
* Globals:        none
*
* Return:         void
********************************************************************************
* Implementation/Detailed Description:
*
*
* References:  "Speech Analysis and Synthesis Methods Developed at ECL in
*                NTT - From LPC to LSP -", Noboru Sugamura and Fumitada 
*                Itakura, Speech Communication 5 (1986) pp 199-215.
*
*              "Line Spectrum Pair (LSP) and Speech Data Compression",
*                Frank k. Soong and Bing-Hwang Juang, Proc. ICASSP 1984,
*                pp 1.10.1-1.10.4
*
*              "Application of Line-Spectrum Pairs to Low-Bit_rate Speech
*                Encoders", George S. Kang and Lawrence J. Fransen, Proc.
*                ICASSP 1985, PP 7.3.1-7.3.4
********************************************************************************
* Modifications:
*
* Comments:    The inverse filter is defined as:
*
*                      A(Z) = 1 + SUM(1...p) A_p Z^(-p)
*
*              The LSPs are normalized in frequency and should range
*                from 0 to 0.5.  Since many codecs require LSPs in
*                Hertz, fScaleFactor is included to allow the conversion
*                from Hertz to normalized frequency.  If the input LSPs are 
*                in Hertz, fScaleFactor should be set to one over the 
*                sampling rate.  If the LSPs are normalized in frequency
*                (ranging from 0 to 0.5) fScaleFactor should be set to 1.0.
*
* Concerns/TBD:
*******************************************************************************/

void VoxLspToAsEven( const float  *pfLSP, 
                     int          iOrder, 
                     float        fScaleFactor,
                     float        *pfAs 
                   )
{
   int   i, j;
   int   iOrder2 = iOrder>>1;

   float fScale;
   float fRp[(MAX_LPC_ORDER>>1)+1];
   float fRq[(MAX_LPC_ORDER>>1)+1];
   float fDp;
   float fDq;

   
   /*------------------------------------------------------
     Make sure the model order is even and that it is less 
       than or equal to MAX_LPC_ORDER.  
   ------------------------------------------------------*/ 
   assert( !(iOrder&1) );
   assert( iOrder <= MAX_LPC_ORDER );
   assert( pfLSP );
   assert( pfAs );

   fScale = fScaleFactor*DB_PI;

   /*------------------------------------------------------
     Compute reduced polynomials Rp(z) and Rq(z).
       These are computed from:

       Rp(z) = PROD(i=1...N/2) (1 + Dp_i z^(-1) + z^(-2))
       Rq(z) = PROD(i=1...N/2) (1 + Dq_i z^(-1) + z^(-2))

       where:

          Dp_i = -2.0*cos( 2*PI * LSP(2*i-1) )
          Dq_i = -2.0*cos( 2*PI * LSP(2*i) )

       Due to the symmetry, only half of the coefficients 
       of Rp(z) and Rq(z) need to be computed.  Also,
       in each term of the product, the coefficients of 
       z^0 and z^(-2) are 1, so multiplication 
       by either of these two coefficients is replaced 
       by a simple assignment operation.
   ------------------------------------------------------*/


   /*------------------------------------------------------
     Assign coefficient values of the first stage of the
       product.  The values of fRp[2] and fRq[2] are not
       assigned since they are symmetric with fRp[0] and 
       fRq[0].
   ------------------------------------------------------*/
   fRp[0] = 1.0F;
   fRq[0] = 1.0F;

   /*------------------------------------------------------
     Compute the coefficients Dp_0 and Dq_0 from the LSPs.
   ------------------------------------------------------*/
   fRp[1] = -2.0F * (float) cos( fScale * (*pfLSP++) );
   fRq[1] = -2.0F * (float) cos( fScale * (*pfLSP++) );

   /*------------------------------------------------------
     Multiply out each sucessive stage of the product.
   ------------------------------------------------------*/
   for (i=1; i<iOrder2; i++)
   {

      /*------------------------------------------------------
        Compute the coefficients Dp_i and Dq_i from the LSPs.
      ------------------------------------------------------*/
      fDp = -2.0F * (float) cos( fScale * (*pfLSP++) );
      fDq = -2.0F * (float) cos( fScale * (*pfLSP++) );

      /*------------------------------------------------------
         This first step in the product is actually:

           fRp[i+1] = fRp[i+1] + fDp*fRp[i] + fRp[i-1]

         but there is no value for fRp[i+1] from the
         previous stage of the product since only half
         of the symmetric coefficients are computed.  
         The value of fRp[i+1] from the previous stage
         can be found from the symmetry:

            fRp[i+1] = fRp[i-1]

         so the new value of fRp[i+1] is computed as:

            fRp[i+1] = fRp[i-1] + fDp*fRp[i] + fRp[i-1]

      ------------------------------------------------------*/
      fRp[i+1] = fDp*fRp[i] + 2.0F*fRp[i-1];
      fRq[i+1] = fDq*fRq[i] + 2.0F*fRq[i-1];

      for (j=i; j>1; j--)
      {
         fRp[j] = fRp[j] + fDp*fRp[j-1] + fRp[j-2];
         fRq[j] = fRq[j] + fDq*fRq[j-1] + fRq[j-2];
      }

      /*------------------------------------------------------
        This step is actually:

           fRp[1] = fRp[1] + fRp[0]*fDp;

        but fRp[0] = 1.0 always, so the multiplication by
        fRp[0] is omitted.
      ------------------------------------------------------*/
      fRp[1] += fDp;
      fRq[1] += fDq;

      /*------------------------------------------------------
        The final step in this stage of the product is 
          fRp[0] = fRp[0] but since that is redundant it
          is omitted.
      ------------------------------------------------------*/
   }

   /*------------------------------------------------------
     Compute polynomials P(z) and Q(z).  

       P(z) = (1 + z^(-1)) Rp(z)
       Q(z) = (1 - z^(-1)) Rq(z)

       These are computed in place! Again, due to symmetry 
       only half of the coefficients are computed.
   ------------------------------------------------------*/
   for (i=iOrder2; i; i--)
   {
      fRp[i] += fRp[i-1];
      fRq[i] -= fRq[i-1];
   }

   /*------------------------------------------------------
     Compute predictor coefficients:

        A(z) = 0.5 * (P(z) + Q(z))
   ------------------------------------------------------*/
   pfAs[0] = 1.0F;
   for (i=1; i<=iOrder2; i++)
   {
      pfAs[i]          = 0.5F*(fRp[i]+fRq[i]);
      pfAs[iOrder+1-i] = 0.5F*(fRp[i]-fRq[i]);
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\lsprt.h ===
#ifndef LSPRT_H
#define LSPRT_H

void VoxLspDiff(STACK_R float *freq, unsigned short *findex, 
		const float **lspdiff, const int *levels);
void VoxLspDiffDec(unsigned short *findex, float *freq, const float **lspdiff);

#endif /* LSPRT_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\lpcsynth.h ===
/*******************************************************************************
*                        Voxware Proprietary Material                          *
*                        Copyright 1996, Voxware, Inc                          *
*                            All Rights Reserved                               *
*                                                                              *
*                       DISTRIBUTION PROHIBITED without                        *
*                      written authorization from Voxware                      *
*******************************************************************************/

/*******************************************************************************
* Filename:       lpcSynth.h                                                                 
*                                                                              
* Purpose:        Pass the excitation throught the lpc synthesis filter.
*                 Interpolate the filter for each subframe.                                                             
*                                                                              
* Author/Date:    Rob Zopf  02/08/96                                                            
********************************************************************************
* $Header:   /export/phobos/pvcs/r_and_d/archives/realtime/decode/lpcSynth.h_v   1.0   26 Jan 1998 10:52:18   johnp  $                                                                     
*******************************************************************************/
#ifndef LPCSYNTH_H
#define LPCSYNTH_H

typedef struct tagSynthesis
{
   float        *prevLSP;
   float        *lpcMEM;
} Synthesis;

unsigned short VoxInitLPCSyn(void **mySynthesis_mblk);

unsigned short VoxFreeLPCSyn(void **mySynthesis_mblk);

unsigned short VoxLPCSyn(STACK_R float *lsp, float *exciteIN, void *mySynthesis_mblk, short outputLEN);

#endif /* LPCSYNTH_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\lsppred.h ===
/*******************************************************************************
*                        Voxware Proprietary Material                          *
*                        Copyright 1996, Voxware, Inc                          *
*                            All Rights Reserved                               *
*                                                                              *
*                       DISTRIBUTION PROHIBITED without                        *
*                      written authorization from Voxware                      *
*******************************************************************************/

/*******************************************************************************
* Filename:          LspPred.h                                                         
*                                                                              
* Purpose:           Quantize lsfs using scalar quantization                                                          
*                                                                              
* Functions:                                                                   
*                                                                              
* Author/Date:                                                                 
********************************************************************************
* Modifications:
*                   
* Comments:                                                                      
* 
* Concerns:
*
* 
*******************************************************************************/
#ifndef LSPPRED_H
#define LSPPRED_H

void LspPredQuan(float *lsf, unsigned short *index, const float **cb, float qPitch);
void LspPredUnQuan(float *lsf, unsigned short *index, const float **cb, float qPitch);

#endif /* LSPPRED_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\lsp_6_16.h ===
0.0773260295F,
0.1214717776F,
0.1820846349F,
0.2797223032F,
0.3489941955F,
0.4112727940F,
0.4859273732F,
0.5580559969F,
0.7711638808F,
0.8452367187F,
0.0684124380F,
0.1025724262F,
0.1766858250F,
0.3850378394F,
0.4749597609F,
0.5324330330F,
0.6203660369F,
0.6920681596F,
0.7967494130F,
0.8600224257F,
0.0706600696F,
0.1061330214F,
0.1691361815F,
0.2409852743F,
0.4015980363F,
0.4740914404F,
0.5675306320F,
0.6719819307F,
0.7509231567F,
0.8288312554F,
0.0666057095F,
0.1700106114F,
0.2721432745F,
0.3894392848F,
0.4825329185F,
0.5580611825F,
0.6434382200F,
0.7210455537F,
0.7956796885F,
0.8695018888F,
0.1135741323F,
0.1558015794F,
0.2179514021F,
0.3002110720F,
0.3701158464F,
0.4429075420F,
0.5720595717F,
0.6537122726F,
0.7676472664F,
0.8480318189F,
0.0683566704F,
0.1047505960F,
0.1724158376F,
0.2888568640F,
0.4488824010F,
0.5060578585F,
0.6101008654F,
0.6871967316F,
0.7763477564F,
0.8591256738F,
0.0594901629F,
0.0890449136F,
0.1690561771F,
0.2846552432F,
0.3589315414F,
0.4854442775F,
0.5868054032F,
0.6599588394F,
0.7602225542F,
0.8466732502F,
0.0537688658F,
0.1051326022F,
0.2407698780F,
0.3519805968F,
0.4470320344F,
0.5286570787F,
0.6300004721F,
0.7198119164F,
0.8006455898F,
0.8758332133F,
0.0818738937F,
0.1236449480F,
0.1944262683F,
0.2898337245F,
0.3581026196F,
0.4171819091F,
0.5050235987F,
0.6713018417F,
0.7592540383F,
0.8302176595F,
0.1225138530F,
0.1663146019F,
0.2622042596F,
0.3632063568F,
0.4453313649F,
0.5075801015F,
0.6075732708F,
0.6845016479F,
0.7708860040F,
0.8424706459F,
0.0755698010F,
0.1200968400F,
0.1783721596F,
0.2500716448F,
0.3153934777F,
0.3863134682F,
0.5216906071F,
0.6079764962F,
0.7110418081F,
0.8139132857F,
0.1049849018F,
0.1867310703F,
0.3176755011F,
0.4214792550F,
0.5104848146F,
0.5984959602F,
0.6910139918F,
0.7652392983F,
0.8248919249F,
0.8812943697F,
0.0668385103F,
0.1036857963F,
0.1727072597F,
0.2727754116F,
0.3634607494F,
0.4294577837F,
0.6045987606F,
0.6749745607F,
0.7751817107F,
0.8511065841F,
0.0620530806F,
0.0907925665F,
0.1498744786F,
0.2366070151F,
0.4653483033F,
0.5537604094F,
0.6317827702F,
0.7005567551F,
0.7756559849F,
0.8432044983F,
0.0754339769F,
0.1143754348F,
0.1684950441F,
0.2355610877F,
0.2885247469F,
0.3880560994F,
0.6099367142F,
0.6911324263F,
0.7812859416F,
0.8578943014F,
0.0595706291F,
0.1617591381F,
0.2369465679F,
0.3322271705F,
0.4093870223F,
0.4921189249F,
0.6031857729F,
0.6916595101F,
0.7902778983F,
0.8665953279F,
0.0139547912F,
0.0429238454F,
0.0373008326F,
0.0206220560F,
0.0158600491F,
0.0238503553F,
0.0244704541F,
0.0240400285F,
0.0183374956F,
0.0104327369F,
-0.0089164078F,
-0.0136314090F,
0.0297455341F,
-0.0038329228F,
-0.0224937070F,
-0.0265819747F,
-0.0247895289F,
-0.0177209992F,
-0.0078563076F,
-0.0179438908F,
-0.0100680105F,
-0.0162534360F,
0.0491400696F,
0.0357233882F,
0.0248781256F,
0.0204771962F,
-0.0006734582F,
-0.0097688222F,
-0.0214007627F,
-0.0305677988F,
-0.0111950664F,
-0.0138372686F,
-0.0124032535F,
-0.0106190266F,
-0.0259002279F,
-0.0131994477F,
-0.0162639078F,
0.0044535277F,
0.0017702213F,
0.0022893010F,
0.0104492763F,
0.0394091643F,
0.0345627181F,
0.0148121566F,
0.0089286519F,
-0.0052370429F,
-0.0261738040F,
-0.0308003370F,
-0.0423512906F,
-0.0391747430F,
-0.0082154246F,
-0.0111561492F,
-0.0217524245F,
-0.0516923852F,
-0.0555590466F,
-0.0088415174F,
-0.0093074581F,
-0.0093392171F,
-0.0092797885F,
-0.0104552759F,
-0.0114693167F,
-0.0143238455F,
0.0103474241F,
0.0218266137F,
0.0328242779F,
0.0462787114F,
0.0496072918F,
0.0443262011F,
0.0230274070F,
0.0123332199F,
-0.0186295956F,
-0.0272732098F,
-0.0439157821F,
-0.0113102878F,
-0.0151154092F,
-0.0145777669F,
0.0111474758F,
-0.0013541357F,
0.0132748242F,
0.0126308752F,
-0.0002552753F,
-0.0035797085F,
-0.0091368724F,
-0.0309881214F,
-0.0557002388F,
0.0669384599F,
0.0474474877F,
0.0305960812F,
0.0316746794F,
0.0090222638F,
-0.0001267376F,
0.0048762606F,
-0.0070311986F,
-0.0235943049F,
-0.0489497148F,
-0.0559911504F,
-0.0383022018F,
-0.0398022607F,
0.0064199301F,
0.0044816760F,
-0.0161981527F,
-0.0180817265F,
0.0076243654F,
0.0193767548F,
0.0151846204F,
0.0067761778F,
-0.0071588103F,
-0.0159506276F,
0.0217439551F,
0.0123160919F,
0.0057746135F,
0.0175203905F,
0.0037690008F,
-0.0261868928F,
-0.0009697252F,
-0.0049586999F,
-0.0063967453F,
-0.0066077006F,
-0.0113748582F,
0.0118953995F,
0.0262853336F,
0.0292828232F,
0.0182994101F,
0.0060077650F,
-0.0174729712F,
-0.0156252645F,
-0.0069052945F,
0.0014932184F,
0.0085423039F,
0.0020011833F,
-0.0119714839F,
-0.0139079988F,
-0.0269270763F,
-0.0217163395F,
0.0063770697F,
-0.0099379746F,
-0.0399591401F,
-0.0501492433F,
-0.0250835344F,
-0.0125746112F,
0.0033858668F,
0.0049226070F,
-0.0100541068F,
0.0389943868F,
0.0259946156F,
-0.0010452995F,
-0.0003215275F,
-0.0115630310F,
-0.0332852378F,
-0.0038245518F,
-0.0083807698F,
-0.0108538754F,
-0.0269424655F,
-0.0231888983F,
0.0290923491F,
0.0185484458F,
0.0151624866F,
0.0175171494F,
0.0102372030F,
0.0087336143F,
-0.0000464125F,
0.0156472307F,
0.0069551882F,
0.0196367651F,
0.0202552006F,
-0.0147875417F,
-0.0132854665F,
-0.0132207582F,
0.0249366444F,
0.0242763609F,
-0.0079324516F,
-0.0126366848F,
-0.0103619955F,
-0.0223817434F,
-0.0049608760F,
-0.0117756939F,
-0.0068281689F,
-0.0217612647F,
-0.0012205575F,
0.0035855346F,
0.0108414562F,
0.0156036615F,
-0.0005853758F,
-0.0151930964F,
-0.0133567089F,
-0.0283624046F,
-0.0310223754F,
0.0147841228F,
-0.0071411054F,
0.0006788897F,
-0.0088124173F,
-0.0179420058F,
-0.0149491308F,
-0.0160012245F,
0.0170719456F,
0.0274650548F,
0.0090394868F,
0.0011690190F,
-0.0212156214F,
-0.0185016114F,
0.0181952436F,
0.0160181578F,
0.0042915284F,
0.0132022696F,
0.0150978127F,
0.0053672274F,
-0.0061811185F,
-0.0104322610F,
-0.0349988937F,
-0.0395287499F,
0.0295691285F,
0.0244694110F,
0.0230316781F,
0.0192518812F,
0.0009512468F,
-0.0083463397F,
-0.0245371386F,
-0.0424763188F,
0.0045049861F,
0.0037380003F,
0.0021150080F,
-0.0016126634F,
-0.0027725040F,
-0.0016778876F,
-0.0188784171F,
-0.0157630909F,
0.0289807394F,
0.0137712825F,
-0.0127804698F,
-0.0244569872F,
-0.0222491231F,
0.0177968964F,
0.0193509106F,
0.0017354881F,
0.0049006175F,
0.0007895040F,
-0.0010842724F,
0.0148775810F,
0.0134477708F,
0.0163445845F,
-0.0016833494F,
-0.0051476448F,
-0.0150702465F,
-0.0057544811F,
-0.0211868845F,
-0.0317947455F,
-0.0642372221F,
0.0077348012F,
0.0268016700F,
0.0160374120F,
-0.0088622160F,
-0.0135948258F,
0.0344561674F,
0.0173550062F,
-0.0083781593F,
-0.0164302941F,
-0.0170184728F,
-0.0078749880F,
0.0021304986F,
0.0078160213F,
0.0089705260F,
0.0094025414F,
-0.0080118189F,
0.0381898247F,
0.0200570878F,
0.0086511755F,
0.0223420225F,
0.0061381198F,
0.0270090606F,
0.0161574669F,
-0.0100656897F,
0.0141670192F,
0.0160493311F,
0.0130709643F,
-0.0090552773F,
0.0091940565F,
0.0258368906F,
0.0109564718F,
0.0180117935F,
0.0174578726F,
0.0013262234F,
-0.0007251590F,
-0.0074389568F,
-0.0174983926F,
-0.0202916842F,
0.0170656759F,
-0.0098829623F,
0.0119141638F,
0.0209126417F,
0.0142661408F,
-0.0028983331F,
-0.0068187360F,
-0.0221344419F,
-0.0337292887F,
-0.0287727676F,
-0.0264372267F,
0.0160626080F,
0.0236539114F,
0.0173801258F,
0.0205079224F,
-0.0036910062F,
-0.0077163558F,
-0.0134750530F,
-0.0055901906F,
0.0000193365F,
-0.0105469860F,
-0.0173701867F,
-0.0348325446F,
-0.0606323220F,
0.0123701934F,
-0.0005279758F,
-0.0012549238F,
0.0025348687F,
0.0054198257F,
0.0317136534F,
0.0013028969F,
-0.0173144918F,
0.0047295704F,
-0.0074821715F,
-0.0114729879F,
-0.0106763216F,
-0.0166242048F,
-0.0060086064F,
-0.0030928787F,
0.0056105875F,
0.0111253150F,
-0.0001162425F,
-0.0041077523F,
-0.0000310071F,
0.0093526719F,
-0.0014720398F,
-0.0083325235F,
0.0088082626F,
0.0157761443F,
0.0225175265F,
0.0137416385F,
0.0141074797F,
0.0085598854F,
0.0057844887F,
0.0031508903F,
-0.0099518327F,
0.0159239173F,
0.0048560225F,
-0.0003802209F,
-0.0023724332F,
-0.0155621022F,
0.0052668406F,
0.0011592512F,
0.0081162788F,
-0.0015093089F,
-0.0005389678F,
-0.0036254192F,
-0.0224511623F,
0.0195758473F,
-0.0124867996F,
0.0028147388F,
-0.0041358559F,
-0.0182007719F,
0.0241000969F,
0.0007794359F,
-0.0036123968F,
-0.0087561635F,
-0.0221641529F,
-0.0032437965F,
-0.0062794788F,
-0.0086666252F,
-0.0033488134F,
-0.0101461140F,
-0.0181859974F,
-0.0218976419F,
0.0123686399F,
0.0114725800F,
0.0045656040F,
0.0007514915F,
0.0071059614F,
-0.0101176193F,
0.0161259193F,
0.0078080213F,
-0.0129176481F,
0.0150304260F,
0.0028820792F,
0.0067047835F,
-0.0027982697F,
-0.0050851339F,
-0.0012891567F,
0.0087815356F,
0.0159331392F,
0.0327384658F,
0.0192393940F,
-0.0025654638F,
-0.0032475668F,
-0.0085359700F,
-0.0062324055F,
-0.0116211521F,
-0.0115540763F,
0.0023935088F,
-0.0252066590F,
0.0067184716F,
-0.0079189371F,
-0.0041179624F,
0.0005017060F,
0.0009445878F,
-0.0119774966F,
0.0031292904F,
0.0114141302F,
0.0009235340F,
-0.0117964679F,
-0.0331986882F,
0.0235514734F,
0.0073282183F,
0.0054960200F,
0.0059984531F,
0.0063796388F,
-0.0033165361F,
-0.0065969168F,
-0.0052794470F,
-0.0171983335F,
-0.0306288637F,
-0.0444029793F,
-0.0141626131F,
-0.0070772311F,
-0.0113241775F,
0.0080502881F,
0.0024823707F,
-0.0041016759F,
-0.0145889111F,
0.0089631500F,
0.0333559960F,
0.0095950896F,
0.0008110127F,
-0.0097952718F,
0.0112893302F,
0.0087470375F,
0.0044689588F,
0.0023732665F,
-0.0004677930F,
-0.0188584290F,
-0.0268124565F,
-0.0034904841F,
-0.0146110971F,
0.0002220559F,
-0.0041604964F,
-0.0011216669F,
-0.0198609158F,
-0.0004718607F,
0.0129291294F,
-0.0023161336F,
0.0021840273F,
0.0369896777F,
0.0208190326F,
0.0082485545F,
0.0068775094F,
-0.0021484187F,
0.0170517713F,
0.0123162046F,
0.0238989573F,
-0.0080613922F,
-0.0047561196F,
-0.0060234708F,
-0.0193432719F,
0.0186099708F,
0.0211393777F,
0.0096349474F,
-0.0174172167F,
-0.0097116325F,
0.0028494291F,
0.0101780491F,
0.0020017901F,
0.0149174733F,
0.0007524099F,
0.0005299844F,
0.0005713341F,
0.0015842972F,
-0.0182106774F,
-0.0273239445F,
-0.0056370851F,
-0.0068069911F,
-0.0148227997F,
0.0055787950F,
0.0082554333F,
-0.0045110295F,
-0.0098023545F,
-0.0134265600F,
0.0109360721F,
-0.0093150390F,
0.0070604584F,
0.0030842340F,
0.0036105018F,
0.0104056187F,
0.0104329763F,
-0.0024022472F,
-0.0074086902F,
-0.0052942107F,
0.0163841378F,
0.0019077382F,
-0.0102625024F,
-0.0117820352F,
-0.0149868904F,
-0.0087404503F,
-0.0194686465F,
-0.0010834669F,
0.0015263037F,
-0.0091328109F,
-0.0063932231F,
-0.0193579532F,
0.0191351846F,
0.0058961655F,
-0.0116508054F,
0.0113769984F,
-0.0086874915F,
-0.0085456492F,
0.0120581873F,
0.0024064451F,
-0.0000822522F,
0.0112881232F,
-0.0007736103F,
-0.0111890333F,
-0.0062087327F,
0.0093763163F,
0.0033912379F,
0.0095311031F,
0.0075931894F,
0.0022383714F,
-0.0051985723F,
-0.0029794963F,
0.0207563266F,
0.0114040393F,
0.0018442665F,
-0.0035794792F,
0.0051951432F,
-0.0013128672F,
-0.0023845735F,
-0.0052053174F,
-0.0097896894F,
-0.0011540803F,
-0.0115916561F,
-0.0172255002F,
-0.0216724947F,
0.0126291038F,
0.0035791113F,
-0.0057407138F,
-0.0016586548F,
-0.0096613243F,
-0.0238063466F,
-0.0055451626F,
-0.0072974265F,
0.0000846576F,
0.0039602048F,
-0.0020280739F,
-0.0058350363F,
-0.0014486562F,
-0.0055987495F,
-0.0017396988F,
-0.0107906889F,
0.0093499487F,
-0.0018631924F,
-0.0025926074F,
-0.0066724108F,
-0.0222893581F,
0.0164987948F,
-0.0078923339F,
-0.0102675864F,
0.0099972365F,
-0.0045257816F,
-0.0029379884F,
0.0164195560F,
-0.0010841186F,
-0.0047454466F,
-0.0066254190F,
-0.0142041827F,
0.0028152573F,
0.0015756800F,
0.0092361858F,
0.0079885470F,
-0.0008864487F,
-0.0051420755F,
0.0006770060F,
0.0078166313F,
0.0159948431F,
0.0199587643F,
-0.0029760257F,
-0.0022223352F,
-0.0076000676F,
-0.0055734301F,
-0.0022039362F,
0.0019916529F,
0.0239958372F,
0.0127340108F,
-0.0042292695F,
-0.0038473459F,
-0.0041782572F,
-0.0042271316F,
-0.0182232596F,
-0.0122815864F,
0.0145356944F,
0.0107066361F,
0.0013544926F,
-0.0040514665F,
0.0070075439F,
0.0048656575F,
0.0047344049F,
0.0144174816F,
0.0112253651F,
0.0045381542F,
-0.0053181336F,
-0.0089342343F,
-0.0027751648F,
-0.0017633428F,
-0.0034074420F,
-0.0093779480F,
0.0028702875F,
0.0014805240F,
-0.0176552814F,
0.0019320770F,
0.0017443210F,
-0.0222493242F,
0.0006638521F,
-0.0008441877F,
0.0026741440F,
0.0021496599F,
-0.0081770699F,
-0.0029459880F,
-0.0020588355F,
0.0178005472F,
0.0119167501F,
0.0005057627F,
0.0103319837F,
0.0048148255F,
0.0058464035F,
-0.0081910519F,
0.0019488294F,
0.0012952681F,
-0.0042766635F,
-0.0074665244F,
0.0052015977F,
-0.0022813387F,
-0.0019334244F,
0.0015210778F,
-0.0127230641F,
-0.0324843489F,
-0.0001054298F,
-0.0031264375F,
0.0031362090F,
-0.0012290345F,
-0.0030821878F,
-0.0178470071F,
0.0161806047F,
-0.0071227392F,
-0.0039339033F,
0.0044870973F,
-0.0047876923F,
-0.0135938358F,
0.0180520788F,
-0.0035957310F,
0.0014729023F,
-0.0000619982F,
0.0079066949F,
0.0019754819F,
0.0038844433F,
-0.0020161839F,
0.0046693678F,
0.0002483254F,
0.0094507141F,
0.0106360512F,
0.0063624289F,
-0.0011869706F,
0.0049609179F,
0.0065972228F,
-0.0120947482F,
-0.0085049449F,
0.0014771211F,
-0.0010763052F,
-0.0120632397F,
0.0013112478F,
0.0069817044F,
0.0025670100F,
-0.0065649268F,
-0.0075487695F,
-0.0075499932F,
-0.0080489879F,
0.0067521250F,
-0.0058854548F,
0.0121865701F,
0.0016386280F,
-0.0132770482F,
-0.0021440156F,
0.0011386205F,
-0.0098565519F,
0.0043848865F,
0.0026479594F,
-0.0030318939F,
0.0038035184F,
-0.0009274163F,
0.0045415508F,
-0.0108119361F,
0.0040978068F,
-0.0167203564F,
0.0010974304F,
0.0072567724F,
-0.0039533656F,
-0.0025361725F,
-0.0043565216F,
0.0031205378F,
-0.0042851707F,
-0.0161400866F,
0.0158567112F,
0.0039780582F,
0.0068895807F,
-0.0041846498F,
-0.0057466263F,
0.0011047061F,
-0.0005331254F,
0.0021060572F,
-0.0177562572F,
0.0130570093F,
0.0033249266F,
0.0132463621F,
0.0011160541F,
0.0023563092F,
-0.0058339313F,
0.0054611936F,
0.0002335242F,
0.0064095082F,
-0.0039737974F,
0.0000918407F,
-0.0075098937F,
-0.0143292192F,
0.0238526519F,
0.0059197424F,
-0.0048470465F,
-0.0016558232F,
-0.0030223334F,
0.0001452981F,
0.0052700029F,
-0.0077845277F,
-0.0127363224F,
-0.0077458932F,
0.0068604234F,
-0.0081820935F,
0.0163041465F,
-0.0044041378F,
-0.0048863357F,
-0.0018954743F,
0.0107167698F,
-0.0030498470F,
0.0134758344F,
0.0065161176F,
-0.0072926981F,
-0.0112759955F,
0.0123657621F,
-0.0104534980F,
-0.0110057667F,
-0.0055546379F,
-0.0050922954F,
-0.0032706084F,
-0.0077986130F,
0.0020176747F,
-0.0021368051F,
0.0069173118F,
-0.0057384074F,
-0.0023518351F,
0.0020812580F,
-0.0069743916F,
-0.0038117589F,
0.0106201181F,
0.0015190031F,
-0.0019391921F,
0.0137446271F,
-0.0033041670F,
0.0133250449F,
0.0003929129F,
-0.0012104517F,
0.0104834717F,
0.0040057413F,
0.0104763610F,
0.0094546219F,
-0.0055435514F,
-0.0099092321F,
0.0148216169F,
0.0008209560F,
-0.0075294683F,
0.0082484502F,
0.0055459011F,
0.0022299543F,
-0.0028180766F,
0.0014294698F,
0.0123123294F,
-0.0033967609F,
0.0146127557F,
0.0093084536F,
0.0010488397F,
-0.0102037583F,
-0.0001681929F,
-0.0097184619F,
0.0008422480F,
0.0015470340F,
0.0004748712F,
0.0092283618F,
0.0155273173F,
0.0118205333F,
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\mask12uv.h ===
/******************************************************************************
*                        Voxware Proprietary Material
*                        Copyright 1996, Voxware, Inc
*                            All Rights Reserved
*
*                       DISTRIBUTION PROHIBITED without
*                      written authorization from Voxware
******************************************************************************/
 
/******************************************************************************
* Filename:    MASK12UV.h
*
* Purpose:     mean vector for 12th ASK coefficients of unvoiced frame
*
* $Header:   /export/phobos/pvcs/r_and_d/archives/scaleable/tables/MASK12UV.h_v   1.0   06 Feb 1998 10:12:32   johnp  $
*
******************************************************************************/
#ifndef _MASK12UV_H_
#define _MASK12UV_H_
 0.8053F,
-0.3096F,
 0.1103F,
-0.2070F,
 0.0065F,
-0.1164F,
 0.0594F,
-0.0918F,
 0.0206F,
-0.0976F,
 0.0441F,
-0.0838F,
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\lsp_8_16.h ===
0.0795584470F,
0.1235027164F,
0.1858746409F,
0.2809404433F,
0.3545641303F,
0.4123750925F,
0.4859536290F,
0.5587683916F,
0.7694147825F,
0.8437217474F,
0.0650831386F,
0.0956360027F,
0.1743450314F,
0.3793554902F,
0.4833318591F,
0.5334042907F,
0.6137399077F,
0.6913856268F,
0.7953307033F,
0.8585596681F,
0.0689340979F,
0.1074964106F,
0.1756139845F,
0.2436030060F,
0.4022297561F,
0.4731981456F,
0.5647158027F,
0.6748796105F,
0.7511599064F,
0.8302336335F,
0.0715994984F,
0.1615730822F,
0.2777726650F,
0.3913194239F,
0.4837756157F,
0.5609604716F,
0.6425219774F,
0.7223789692F,
0.7942274809F,
0.8643714786F,
0.1162561700F,
0.1602935791F,
0.2247152925F,
0.2967643440F,
0.3674999475F,
0.4411450028F,
0.5707392097F,
0.6577602625F,
0.7646196485F,
0.8466596007F,
0.0674884543F,
0.1047814041F,
0.1751729399F,
0.2916922569F,
0.4543735087F,
0.5066226721F,
0.6031411886F,
0.6843919158F,
0.7754221559F,
0.8557465672F,
0.0546493270F,
0.0838552490F,
0.1692845374F,
0.2885895371F,
0.3594807088F,
0.4813590050F,
0.5791530609F,
0.6555795074F,
0.7622498274F,
0.8424357176F,
0.0459783338F,
0.0948011354F,
0.2469110787F,
0.3584627509F,
0.4481209517F,
0.5228549838F,
0.6197109818F,
0.7214927673F,
0.8059331179F,
0.8714827299F,
0.0780499950F,
0.1184502542F,
0.1917727739F,
0.2941408455F,
0.3613291383F,
0.4140203297F,
0.4881021976F,
0.6666951776F,
0.7548218369F,
0.8202995062F,
0.1092976332F,
0.1526714414F,
0.2508000731F,
0.3679660261F,
0.4458998740F,
0.5075962543F,
0.6023873687F,
0.6826860905F,
0.7692132592F,
0.8405272365F,
0.0768658891F,
0.1218207106F,
0.1827514768F,
0.2505320311F,
0.3127520680F,
0.3865327537F,
0.5238879323F,
0.6121063828F,
0.7132396102F,
0.8185811639F,
0.1084922627F,
0.1890787333F,
0.3182294369F,
0.4196157753F,
0.5152273178F,
0.5958585739F,
0.6918621659F,
0.7708726525F,
0.8302132487F,
0.8851048946F,
0.0634844974F,
0.0984395444F,
0.1686027497F,
0.2739019096F,
0.3615219891F,
0.4246375263F,
0.6070407033F,
0.6866686344F,
0.7684228420F,
0.8435115218F,
0.0591261499F,
0.0873948932F,
0.1503321081F,
0.2340644598F,
0.4604282975F,
0.5523674488F,
0.6376436949F,
0.7073323131F,
0.7772819400F,
0.8417997956F,
0.0734731853F,
0.1118185446F,
0.1687451303F,
0.2306621075F,
0.2840754390F,
0.4031526744F,
0.6053850651F,
0.6902469397F,
0.7881332040F,
0.8609808683F,
0.0672441795F,
0.1634023339F,
0.2454434633F,
0.3346211016F,
0.4100862741F,
0.4905810952F,
0.5982077718F,
0.6999070644F,
0.7972555161F,
0.8707859516F,
0.0204675440F,
0.0415729471F,
0.0344466902F,
0.0088257715F,
0.0155437980F,
0.0196955428F,
0.0250577386F,
0.0303544179F,
0.0195901971F,
0.0141591895F,
-0.0136691388F,
-0.0120240673F,
0.0389502831F,
0.0045737680F,
-0.0167778246F,
-0.0298936572F,
-0.0363009796F,
-0.0192507021F,
-0.0061521842F,
-0.0206521451F,
-0.0107206479F,
-0.0186883900F,
0.0453455299F,
0.0360396430F,
0.0221709348F,
0.0175000839F,
-0.0013700714F,
-0.0134342127F,
-0.0329747573F,
-0.0381712466F,
-0.0178707819F,
-0.0251209103F,
-0.0104607474F,
-0.0056329817F,
-0.0293556247F,
-0.0130884917F,
-0.0257049948F,
0.0083189802F,
0.0052697966F,
0.0017637269F,
0.0147832539F,
0.0413928963F,
0.0308609884F,
0.0190045275F,
0.0098494031F,
-0.0009690248F,
-0.0184052978F,
-0.0313370451F,
-0.0374963656F,
-0.0388377123F,
-0.0081102196F,
-0.0133269066F,
-0.0209611729F,
-0.0454593301F,
-0.0486324765F,
-0.0087282993F,
-0.0209600255F,
-0.0031569269F,
-0.0063214744F,
-0.0138632320F,
-0.0146564506F,
-0.0167256556F,
0.0104397628F,
0.0157113969F,
0.0312545262F,
0.0517894216F,
0.0461195447F,
0.0376140811F,
0.0178119261F,
0.0098160123F,
-0.0198960043F,
-0.0261894558F,
-0.0461252108F,
-0.0141343987F,
-0.0192930885F,
-0.0177560337F,
0.0156035377F,
-0.0010878245F,
0.0128741190F,
0.0078614578F,
-0.0017243685F,
-0.0052863401F,
-0.0143752797F,
-0.0255712792F,
-0.0455243327F,
0.0673478544F,
0.0447110198F,
0.0256459136F,
0.0243411846F,
0.0040602046F,
-0.0014920189F,
0.0037399619F,
-0.0079208007F,
-0.0240596887F,
-0.0517537594F,
-0.0563415065F,
-0.0287434459F,
-0.0315480195F,
0.0099996738F,
0.0064425962F,
-0.0198737476F,
-0.0282100160F,
0.0191195998F,
0.0202274974F,
0.0194468070F,
0.0003217869F,
-0.0172701981F,
-0.0172947831F,
0.0287328251F,
0.0061648404F,
0.0081424462F,
0.0130964220F,
0.0065973187F,
-0.0270749535F,
-0.0035772230F,
-0.0098650027F,
-0.0064313710F,
-0.0033964361F,
-0.0081739835F,
0.0150269214F,
0.0255722702F,
0.0234600957F,
0.0176816173F,
0.0073448387F,
-0.0181935392F,
-0.0175275039F,
-0.0082439221F,
-0.0075217634F,
0.0137536852F,
0.0007750065F,
-0.0148403272F,
-0.0168820098F,
-0.0254902299F,
-0.0219453387F,
0.0136078838F,
-0.0060437927F,
-0.0348314419F,
-0.0525110587F,
-0.0247391369F,
-0.0151242064F,
0.0055341837F,
0.0058360002F,
-0.0037931532F,
0.0354406424F,
0.0224570800F,
0.0031239851F,
0.0006475435F,
-0.0128033785F,
-0.0323973298F,
0.0014631287F,
-0.0116285086F,
-0.0039142366F,
-0.0255621634F,
-0.0133923283F,
0.0248950366F,
0.0169492289F,
0.0123864627F,
0.0143952230F,
0.0156269949F,
0.0107841138F,
-0.0022317579F,
0.0097412495F,
0.0144501617F,
0.0278797820F,
0.0171404313F,
-0.0143011911F,
-0.0239031762F,
0.0022363402F,
0.0264784601F,
0.0191529281F,
-0.0128492285F,
-0.0167954527F,
-0.0040277978F,
-0.0179312360F,
-0.0028939154F,
-0.0153047582F,
-0.0031173422F,
-0.0204832070F,
0.0007588658F,
0.0016838217F,
0.0091391122F,
0.0143950721F,
0.0045274836F,
-0.0183827095F,
-0.0054611382F,
-0.0258879643F,
-0.0315545164F,
0.0162566975F,
-0.0052191294F,
0.0038548061F,
-0.0097947856F,
-0.0207962636F,
-0.0160517748F,
-0.0166979693F,
0.0143574663F,
0.0240288880F,
0.0011951966F,
0.0000112124F,
-0.0201341864F,
-0.0219159666F,
0.0238300990F,
0.0220056903F,
0.0068068621F,
0.0026853958F,
0.0116960807F,
0.0014584039F,
0.0023402865F,
-0.0039585782F,
-0.0307261609F,
-0.0332910083F,
0.0213769246F,
0.0226341560F,
0.0192482639F,
0.0142139615F,
0.0039313394F,
-0.0023616774F,
-0.0287436694F,
-0.0468445010F,
0.0009356201F,
-0.0027394698F,
0.0026279141F,
-0.0046001836F,
0.0054263817F,
0.0025441835F,
-0.0152285453F,
-0.0148609765F,
0.0224956777F,
0.0131551996F,
-0.0125227720F,
-0.0173409078F,
-0.0334568731F,
0.0222369954F,
0.0158341508F,
0.0033126618F,
0.0008353491F,
-0.0023746125F,
0.0002819404F,
0.0067635854F,
0.0172801521F,
0.0124562914F,
-0.0028647587F,
-0.0082706623F,
-0.0232660845F,
-0.0092105716F,
-0.0277851168F,
-0.0239675660F,
-0.0559065640F,
0.0084982477F,
0.0329639651F,
0.0191796254F,
-0.0130737843F,
-0.0179390833F,
0.0387049168F,
0.0267003607F,
-0.0047452124F,
-0.0234230738F,
-0.0138002532F,
-0.0003532217F,
0.0043278257F,
0.0088920426F,
0.0105878981F,
0.0086520752F,
-0.0143969897F,
0.0321417600F,
0.0130763799F,
0.0034621584F,
0.0182412602F,
0.0021481456F,
0.0250985622F,
0.0133535378F,
-0.0115211140F,
0.0034059365F,
0.0202818606F,
0.0177417044F,
-0.0102192536F,
0.0026552193F,
0.0191933457F,
0.0105286455F,
0.0119937276F,
0.0188748688F,
-0.0016073944F,
-0.0049486188F,
-0.0042634569F,
-0.0149756772F,
-0.0101325577F,
0.0278907884F,
-0.0245314017F,
0.0150618553F,
0.0221380871F,
0.0092332186F,
-0.0033614337F,
-0.0074431933F,
-0.0203280617F,
-0.0297983140F,
-0.0307069980F,
-0.0232154541F,
0.0148959570F,
0.0190369245F,
0.0159686282F,
0.0182852969F,
-0.0056694723F,
-0.0109595032F,
-0.0216019955F,
-0.0079311598F,
0.0014495825F,
-0.0089483038F,
-0.0123558613F,
-0.0285336077F,
-0.0490597263F,
0.0128616728F,
0.0024479078F,
0.0016424695F,
0.0025258516F,
0.0126044275F,
0.0328528620F,
-0.0060962848F,
-0.0194723699F,
0.0088162096F,
-0.0072646388F,
-0.0125541771F,
-0.0157451704F,
-0.0217903405F,
0.0046672081F,
0.0036903664F,
0.0044079064F,
0.0119792335F,
-0.0096959686F,
-0.0153274778F,
0.0046435441F,
0.0052346736F,
-0.0017005641F,
-0.0139048714F,
0.0071442472F,
0.0187637005F,
0.0177266654F,
0.0085753901F,
0.0176255479F,
0.0062300153F,
0.0090142051F,
0.0005307300F,
-0.0164273698F,
0.0123934271F,
0.0029087283F,
0.0019208050F,
0.0008392213F,
-0.0184910744F,
-0.0063169794F,
0.0129217301F,
0.0093803825F,
-0.0017697151F,
-0.0041398979F,
-0.0055126487F,
-0.0219608005F,
0.0172727723F,
-0.0101758623F,
-0.0029216611F,
-0.0069896691F,
-0.0177273192F,
0.0159201398F,
0.0084128771F,
-0.0086620608F,
-0.0137621099F,
-0.0215587728F,
-0.0049177967F,
-0.0077757300F,
-0.0074166292F,
-0.0084185069F,
-0.0093217436F,
-0.0172230899F,
-0.0253022630F,
0.0091109015F,
0.0117738964F,
0.0008532185F,
0.0007882803F,
0.0086751822F,
-0.0139052318F,
0.0193056259F,
0.0105531272F,
-0.0046873046F,
0.0063935933F,
0.0073325871F,
0.0034202775F,
0.0009238647F,
-0.0023247981F,
-0.0036453872F,
0.0108386604F,
0.0169193409F,
0.0372098722F,
0.0191264804F,
-0.0046722600F,
-0.0042663263F,
-0.0103596868F,
-0.0056376089F,
-0.0117572863F,
-0.0136019029F,
-0.0013279972F,
-0.0379350670F,
0.0109035084F,
-0.0032772606F,
-0.0044832802F,
0.0013885851F,
0.0014607862F,
-0.0098237162F,
-0.0037942706F,
0.0105930427F,
-0.0004448903F,
-0.0038165976F,
-0.0302412584F,
0.0214058701F,
0.0020141448F,
0.0077240020F,
0.0046030576F,
0.0072737942F,
-0.0028304397F,
-0.0122328475F,
-0.0003568449F,
-0.0176214688F,
-0.0309199430F,
-0.0415678099F,
-0.0090751918F,
-0.0045258943F,
-0.0096089905F,
0.0094828615F,
0.0056731445F,
-0.0024146957F,
-0.0239618365F,
0.0271537974F,
0.0430931151F,
0.0130742900F,
0.0004108066F,
-0.0160365589F,
0.0104339989F,
0.0025582600F,
0.0053148656F,
0.0043572341F,
0.0003275741F,
-0.0247071926F,
-0.0248694196F,
-0.0056534559F,
-0.0169784892F,
0.0053412402F,
-0.0025431227F,
-0.0033564945F,
-0.0136306155F,
0.0005878843F,
0.0149862785F,
-0.0063076639F,
0.0026535599F,
0.0359084271F,
0.0233750343F,
0.0074692052F,
0.0043321126F,
-0.0022903448F,
0.0156852864F,
0.0139595633F,
0.0259229802F,
-0.0094651757F,
-0.0031775248F,
0.0011311243F,
-0.0180561319F,
0.0093808500F,
0.0149532007F,
0.0194350313F,
-0.0160321724F,
-0.0092018079F,
0.0030781687F,
0.0113818785F,
0.0023926625F,
0.0158182681F,
0.0054275114F,
-0.0070681586F,
0.0026371854F,
0.0003696630F,
-0.0166839790F,
-0.0244655050F,
-0.0058918474F,
-0.0090442821F,
-0.0083234534F,
0.0016714681F,
0.0048220200F,
-0.0070095723F,
-0.0115146814F,
-0.0103080813F,
0.0155950040F,
-0.0064762114F,
0.0095272111F,
0.0055462774F,
0.0030438378F,
0.0162005462F,
0.0069534890F,
0.0008196560F,
-0.0087142065F,
-0.0037928924F,
0.0144185387F,
-0.0002725107F,
-0.0113759227F,
-0.0205731131F,
-0.0197034944F,
-0.0065663755F,
-0.0221732240F,
-0.0001607933F,
-0.0024643682F,
-0.0082815485F,
-0.0099391108F,
-0.0206805244F,
0.0165504627F,
-0.0000785497F,
-0.0136111099F,
0.0127586257F,
-0.0078742560F,
-0.0133471638F,
0.0058548972F,
0.0029648729F,
0.0038695836F,
0.0123363864F,
-0.0044817361F,
-0.0155663686F,
-0.0054765376F,
0.0074791797F,
0.0050282786F,
0.0083258711F,
0.0116386898F,
-0.0005788784F,
-0.0070890896F,
-0.0023909037F,
0.0213048030F,
0.0124414815F,
0.0031599964F,
0.0039985534F,
0.0017294518F,
-0.0010372963F,
-0.0040416415F,
-0.0030977640F,
-0.0126764644F,
0.0018469124F,
-0.0126282508F,
-0.0168725140F,
-0.0199973658F,
0.0145830866F,
0.0111843878F,
-0.0030635705F,
-0.0029210232F,
-0.0128392447F,
-0.0221237186F,
-0.0040699407F,
-0.0129184267F,
-0.0042677755F,
0.0117219910F,
-0.0040378780F,
-0.0109913517F,
-0.0038960753F,
-0.0054851030F,
-0.0041613220F,
-0.0117151756F,
0.0103111183F,
0.0002111848F,
-0.0020225020F,
-0.0073574567F,
-0.0214522276F,
0.0156240761F,
-0.0084866565F,
-0.0140025476F,
0.0154207917F,
0.0006601235F,
-0.0037075956F,
0.0139374398F,
-0.0047850874F,
-0.0041077593F,
-0.0043462706F,
-0.0156041859F,
0.0006485386F,
0.0000052033F,
0.0109734042F,
0.0077042510F,
0.0040811859F,
-0.0087885456F,
-0.0023101063F,
0.0111058932F,
0.0221293923F,
0.0222729128F,
-0.0079465630F,
-0.0079297852F,
-0.0086825658F,
-0.0080503356F,
-0.0033454294F,
0.0099347774F,
0.0241804644F,
0.0153931230F,
-0.0048428564F,
-0.0043261442F,
-0.0091055678F,
-0.0089883711F,
-0.0159166493F,
-0.0107871201F,
0.0133657362F,
0.0144305509F,
0.0019358301F,
-0.0035829840F,
0.0083325412F,
0.0069547594F,
0.0028009200F,
0.0158243198F,
0.0119186202F,
0.0086121997F,
-0.0071317032F,
-0.0104956087F,
-0.0079436852F,
-0.0070899986F,
-0.0060996236F,
-0.0090450905F,
0.0004727925F,
-0.0043176427F,
-0.0163920671F,
0.0059033791F,
-0.0012460073F,
-0.0239145942F,
0.0061375843F,
0.0013049549F,
0.0046689231F,
-0.0034814125F,
-0.0151580712F,
-0.0012839348F,
0.0030503708F,
0.0165153686F,
0.0109784147F,
0.0027000611F,
0.0097531294F,
0.0088120811F,
0.0031509749F,
-0.0090778107F,
0.0031929254F,
0.0036799149F,
-0.0039002590F,
-0.0007260174F,
0.0041221785F,
-0.0062911571F,
0.0009040115F,
0.0023100071F,
-0.0128176659F,
-0.0367466174F,
-0.0007558992F,
-0.0028082503F,
0.0050804042F,
-0.0013116708F,
-0.0014868685F,
-0.0112136118F,
0.0120365890F,
-0.0089560365F,
-0.0048567895F,
0.0015774209F,
-0.0063261301F,
-0.0163183063F,
0.0204613656F,
-0.0019680785F,
-0.0012695518F,
0.0015951315F,
0.0083191432F,
0.0027038525F,
0.0009688986F,
-0.0009697235F,
-0.0004420634F,
-0.0069119828F,
0.0111703295F,
0.0125367455F,
0.0090477318F,
-0.0053845495F,
-0.0022150129F,
0.0065550786F,
-0.0099204713F,
-0.0087623522F,
-0.0009183970F,
-0.0020367564F,
-0.0109317964F,
-0.0017184479F,
0.0028413157F,
-0.0006005041F,
-0.0102135129F,
-0.0083974767F,
-0.0098504145F,
-0.0092808772F,
0.0027755913F,
-0.0076047303F,
0.0125492681F,
0.0052706446F,
-0.0142558310F,
-0.0067723687F,
-0.0025712275F,
-0.0074076252F,
0.0073463893F,
0.0012568693F,
-0.0092693316F,
0.0024117089F,
-0.0004355443F,
0.0089236367F,
-0.0113052465F,
0.0011091735F,
-0.0117574735F,
-0.0028089476F,
0.0102157453F,
-0.0032720549F,
-0.0052400064F,
-0.0088306759F,
0.0004521244F,
-0.0066760867F,
-0.0173489619F,
0.0072656092F,
-0.0001789572F,
0.0082359212F,
-0.0061934525F,
-0.0025545787F,
-0.0043706391F,
-0.0031934979F,
0.0034179520F,
-0.0102455206F,
0.0161494110F,
0.0095692948F,
0.0097051058F,
0.0061856275F,
0.0067034564F,
-0.0035637638F,
0.0078649698F,
0.0042179669F,
0.0085331919F,
-0.0000145259F,
-0.0027997389F,
-0.0095387315F,
-0.0079772864F,
0.0229416676F,
0.0077093332F,
0.0009068570F,
-0.0003754457F,
-0.0040157894F,
-0.0038660974F,
0.0082142400F,
-0.0084112752F,
-0.0104988497F,
-0.0102298828F,
0.0093741585F,
-0.0038217227F,
0.0123435678F,
-0.0024621887F,
-0.0025611033F,
0.0064648530F,
0.0061222557F,
-0.0009033508F,
0.0192516427F,
0.0058172639F,
-0.0047329757F,
-0.0077478713F,
0.0057438430F,
-0.0126013635F,
-0.0105646057F,
-0.0085861357F,
-0.0057952311F,
0.0001630210F,
-0.0050982344F,
0.0056068050F,
-0.0021352910F,
0.0041997530F,
0.0003141594F,
0.0003971652F,
-0.0021237372F,
-0.0072206059F,
0.0056322445F,
0.0120074442F,
0.0000674527F,
0.0006406546F,
0.0148444707F,
-0.0021082733F,
0.0118219256F,
-0.0021367564F,
-0.0043930155F,
0.0090227174F,
0.0000901929F,
0.0108631281F,
0.0023348103F,
-0.0171430185F,
-0.0068512606F,
0.0112681072F,
0.0001436152F,
-0.0089700893F,
0.0060399286F,
0.0067507848F,
-0.0006260347F,
-0.0048991623F,
0.0042550098F,
0.0103369765F,
0.0001184050F,
0.0177346542F,
0.0048905960F,
0.0005699839F,
-0.0138303097F,
0.0021224641F,
-0.0088854432F,
0.0021688705F,
0.0001224668F,
0.0071150702F,
0.0084813489F,
0.0192889236F,
0.0083034672F,
-0.0031937845F,
0.0013039474F,
0.0034250892F,
-0.0031475567F,
0.0047588139F,
-0.0001085527F,
0.0037918622F,
0.0020401869F,
-0.0179401208F,
-0.0081613297F,
0.0018999685F,
-0.0027890936F,
-0.0008499482F,
-0.0024113795F,
-0.0081958231F,
0.0098850429F,
-0.0071753571F,
0.0023308587F,
-0.0011607161F,
0.0054150070F,
0.0025809109F,
0.0021841761F,
-0.0003606293F,
0.0115933130F,
-0.0031318313F,
0.0058881170F,
0.0049028774F,
0.0073036770F,
-0.0069727502F,
0.0023739005F,
0.0001634016F,
-0.0040462255F,
-0.0030362033F,
0.0008043553F,
0.0106302565F,
-0.0000707765F,
-0.0089402003F,
0.0104439482F,
0.0014913459F,
-0.0104950117F,
-0.0067967237F,
0.0084566427F,
-0.0055216048F,
0.0052766060F,
0.0001089700F,
-0.0004889190F,
0.0053533274F,
-0.0050853379F,
0.0006105793F,
-0.0022941572F,
-0.0007899221F,
0.0000077696F,
0.0018682150F,
-0.0032426864F,
-0.0002130569F,
-0.0035942064F,
0.0029139097F,
-0.0050741741F,
-0.0091159679F,
0.0214996301F,
0.0066395425F,
0.0058221845F,
0.0124701615F,
0.0051577119F,
0.0020900695F,
0.0000773520F,
-0.0036863938F,
-0.0054018553F,
-0.0028074554F,
-0.0036382736F,
0.0007181581F,
-0.0001187854F,
0.0009924191F,
-0.0040061800F,
0.0032487516F,
-0.0093025919F,
-0.0177847594F,
0.0017083238F,
-0.0050286679F,
0.0076317769F,
0.0010070853F,
-0.0015673121F,
0.0026100648F,
-0.0109556699F,
0.0072808089F,
0.0012133104F,
-0.0052511077F,
-0.0120310187F,
-0.0055640098F,
-0.0049849083F,
0.0037475296F,
0.0016959914F,
0.0002765003F,
0.0053366423F,
0.0088621248F,
-0.0017204017F,
0.0028781458F,
-0.0063961851F,
0.0098762643F,
0.0065722880F,
-0.0017059626F,
-0.0009773881F,
0.0068440596F,
0.0031712651F,
0.0065880162F,
0.0101603847F,
-0.0106016733F,
-0.0003544872F,
-0.0102595743F,
0.0071937577F,
0.0087191435F,
0.0015627096F,
-0.0042188917F,
-0.0060320413F,
0.0016168379F,
0.0060296920F,
0.0049343873F,
-0.0025421192F,
-0.0070157163F,
0.0003456741F,
-0.0059315087F,
-0.0089481883F,
-0.0011581498F,
0.0069120135F,
0.0068297824F,
-0.0063055353F,
0.0019779196F,
-0.0031461278F,
-0.0031654534F,
0.0057370150F,
-0.0059953006F,
-0.0033806791F,
0.0049343999F,
0.0007494717F,
-0.0040173209F,
-0.0040903608F,
-0.0014630966F,
-0.0092813559F,
-0.0033563802F,
-0.0135203181F,
-0.0069812918F,
-0.0043872967F,
0.0018802857F,
0.0068758815F,
-0.0032285827F,
-0.0053376206F,
-0.0048984340F,
0.0151870232F,
-0.0067086387F,
0.0001979329F,
0.0029682473F,
0.0066591892F,
-0.0000052861F,
-0.0027642676F,
-0.0066039423F,
-0.0091433469F,
0.0056516253F,
0.0007934469F,
-0.0056917286F,
-0.0005805113F,
0.0013195856F,
-0.0011912442F,
-0.0041092047F,
-0.0096087046F,
-0.0067235874F,
-0.0060152961F,
0.0037464115F,
-0.0027352367F,
-0.0038646001F,
-0.0035735653F,
-0.0002494070F,
0.0051536886F,
-0.0084499074F,
-0.0087256404F,
-0.0012957151F,
0.0053589051F,
0.0002836787F,
0.0022518281F,
0.0070756283F,
-0.0014894948F,
0.0047394983F,
0.0072435685F,
-0.0012451708F,
-0.0055015315F,
-0.0043471954F,
-0.0014323741F,
-0.0075187804F,
-0.0074349470F,
-0.0009440595F,
0.0010027116F,
-0.0001222800F,
0.0028189439F,
0.0040250379F,
-0.0076480657F,
0.0002316882F,
0.0111477673F,
0.0043940740F,
-0.0045971549F,
0.0042418391F,
0.0041457773F,
0.0083936080F,
0.0062091174F,
-0.0047159363F,
0.0001826046F,
0.0049927025F,
-0.0030984229F,
0.0056347218F,
-0.0004409053F,
0.0044463160F,
-0.0010047428F,
0.0051762597F,
-0.0007154210F,
-0.0023247991F,
0.0038428979F,
-0.0056869052F,
-0.0017445874F,
0.0063753803F,
-0.0068159839F,
-0.0089804195F,
0.0086519681F,
0.0037255797F,
0.0020873386F,
0.0017873065F,
0.0048907967F,
-0.0049329768F,
0.0084283762F,
0.0065655936F,
-0.0053761336F,
0.0008129079F,
-0.0083755478F,
0.0023099128F,
0.0013542637F,
-0.0032062973F,
-0.0062208674F,
-0.0002095983F,
-0.0011494517F,
0.0098564913F,
0.0087460373F,
-0.0006886160F,
0.0094846440F,
-0.0008283305F,
0.0109887989F,
-0.0033743705F,
-0.0014757121F,
-0.0031124330F,
0.0015595851F,
0.0006148904F,
-0.0015849777F,
0.0013920047F,
0.0117106419F,
0.0027959442F,
0.0004971341F,
-0.0052488223F,
0.0052064313F,
0.0003275867F,
0.0046610315F,
-0.0013694694F,
-0.0103303296F,
0.0078862738F,
0.0082692131F,
-0.0013903881F,
0.0062796567F,
-0.0045419191F,
0.0046822852F,
0.0039786794F,
0.0013565432F,
0.0063469321F,
-0.0088937012F,
-0.0060556876F,
-0.0012684481F,
0.0005680441F,
0.0046375087F,
0.0039857682F,
-0.0029625667F,
-0.0025154462F,
-0.0060355826F,
0.0051141637F,
0.0025079607F,
0.0104511576F,
-0.0029706939F,
0.0041680187F,
0.0018138500F,
-0.0115963351F,
0.0059337718F,
-0.0019757017F,
0.0021035832F,
-0.0021191726F,
0.0018544802F,
-0.0017296949F,
-0.0045335726F,
-0.0067784516F,
0.0059005781F,
0.0011687935F,
-0.0028207870F,
-0.0027332935F,
0.0002101308F,
0.0105224587F,
-0.0017276197F,
-0.0058719781F,
0.0036399530F,
0.0036662815F,
-0.0069987387F,
-0.0053315600F,
-0.0012586227F,
-0.0005233319F,
0.0050415574F,
0.0114262085F,
-0.0024176543F,
0.0029365183F,
0.0026172982F,
0.0050407983F,
0.0049206209F,
0.0038247686F,
-0.0010050018F,
0.0042705117F,
0.0001384253F,
-0.0033162963F,
0.0044644522F,
-0.0064455247F,
0.0067112595F,
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\metatest.h ===
/* Metasound codecs */
#define AC8		0
#define AC10	0
#define AC24	0
#define ACS20	0
#define ACS48	0

/* Real time codecs */
#define RT24	0
#define RT28	0
#define RT29	0
#define VR12	1
#define VR15	0
#define VFII	0

/* Scalable codecs */
#define SC6		0
#define SCX		1
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\midframe.h ===
/*******************************************************************************
*                        Voxware Proprietary Material                          *
*                        Copyright 1996, Voxware, Inc                          *
*                            All Rights Reserved                               *
*                                                                              *
*                       DISTRIBUTION PROHIBITED without                        *
*                      written authorization from Voxware                      *
*******************************************************************************/
 
/*******************************************************************************
* Filename: MidFrame.h
*
* Purpose: Calculate the middle-frame parameters.
*
* Author:  Wei Wang
*
* Date:    June 2, 1997.
*
* $Header:   /export/phobos/pvcs/r_and_d/archives/scaleable/encode/MidFrame.h_v   1.2   25 Mar 1998 18:12:36   bobd  $
*******************************************************************************/
#ifndef _MIDFRAME_H_
#define _MIDFRAME_H_

void MidFrameParam(STACK_R void *hEncMemBlk, void *hParamMblk, int iCodecDelay,
                           int iSCRate, float Cost1, int vfFlag);

#endif /* _MIDFRAME_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\mask12v.h ===
/******************************************************************************
*                        Voxware Proprietary Material
*                        Copyright 1996, Voxware, Inc
*                            All Rights Reserved
*
*                       DISTRIBUTION PROHIBITED without
*                      written authorization from Voxware
******************************************************************************/
 
/******************************************************************************
* Filename:    MASK12V.h
*
* Purpose:     mean vector for 12th ASK coefficients of voiced frame
*
* $Header:   /export/phobos/pvcs/r_and_d/archives/scaleable/tables/MASK12V.h_v   1.0   06 Feb 1998 10:12:32   johnp  $
*
******************************************************************************/
#ifndef _MASK12V_H_
#define _MASK12V_H_
    1.0303F,
   -0.7667F,
    0.2321F,
   -0.3457F,
    0.1043F,
   -0.0944F,
    0.1424F,
   -0.1151F,
    0.0550F,
   -0.1067F,
    0.0604F,
   -0.1017F,
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\magsq.c ===
/*******************************************************************************
*                        Voxware Proprietary Material                          *
*                        Copyright 1996, Voxware, Inc                          *
*                            All Rights Reserved                               *
*                                                                              *
*                       DISTRIBUTION PROHIBITED without                        *
*                      written authorization from Voxware                      *
*******************************************************************************/

/*******************************************************************************
* Filename:          MagSq.c
*                                                                              
* Purpose:           Compute vector magnitude squared.
*                                                                              
* Functions:         MagSq()
*                                                                              
* Author/Date:       Bob Dunn   4/7/97
********************************************************************************
* $Header:   /export/phobos/pvcs/pvcsproj/voxlib.prj/magsq.c_v   1.9   07 Apr 1998 17:56:56   weiwang  $
*******************************************************************************/
#include <stdlib.h>
#include <assert.h>

#include "vLibVec.h"

#include "xvocver.h"

/******************************************************************************
*
* Function: MagSq()
*
* Action:   Compute magnitude squared of a complex vector
*
* Input:    const float *pcfRe    -> real part of complex vector
*           const float *pcfIm    -> imaginary part of complex vector
*           int    iLength        -> length of vector
*
* Output:   float *pfMagSq        -> magnitude squared of the vector
*
* Globals:  none
*
* Return:   void
*******************************************************************************
*
* Modifications:
*
* Comments:
*
* Concerns/TBD:
******************************************************************************/
void MagSq(const float *pcfRe, const float *pcfIm, int iLength, float *pfMagSq)
{

  assert( iLength > 0 );
  assert( pcfRe != NULL);
  assert( pcfIm != NULL);
  assert( pfMagSq != NULL);

  for (; iLength > 0; iLength--, pcfRe++, pcfIm++)
    *pfMagSq++ = (*pcfRe)*(*pcfRe) + (*pcfIm)*(*pcfIm);
}


/******************************************************************************
*
* Function: MagSqIL()
*
* Action:   Compute magnitude squared of a inter-leave formatted complex vector
*
* Input:    const float *pcfVec    -> inter-leave complex vector
*           int    iLength        -> length of vector
*
* Output:   float *pfMagSq        -> magnitude squared of the vector
*
* Globals:  none
*
* Return:   void
*******************************************************************************
*
* Modifications:
*
* Comments:
*
* Concerns/TBD:
******************************************************************************/
void MagSqIL(const float *pcfVec, int iLength, float *pfMagSq)
{

  assert( iLength > 0 );
  assert( pcfVec != NULL);
  assert( pfMagSq != NULL);

  for (; iLength > 0; iLength--, pcfVec+=2)
    *pfMagSq++ = pcfVec[0]*pcfVec[0] + pcfVec[1]*pcfVec[1];
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\midframe.c ===
/******************************************************************************
*                        Voxware Proprietary Material
*                        Copyright 1996, Voxware, Inc
*                            All Rights Reserved
*
*                       DISTRIBUTION PROHIBITED without
*                      written authorization from Voxware
******************************************************************************/
 
/******************************************************************************
*
* Filename: MidFrame.c
*
* Purpose: Calculate the middle-frame parameters.
*
* Author:  Wei Wang
*
* Date:    June 2, 1997.
*
*******************************************************************************
*
* $Header:   /export/phobos/pvcs/r_and_d/archives/scaleable/encode/MidFrame.c_v   1.11   14 Apr 1998 10:14:18   weiwang  $
*
******************************************************************************/
#include <math.h>
#include <assert.h>

#include "vLibSnd.h"
#include "vLibVec.h"
#include "vLibSgPr.h"
#include "vLibMath.h"

#include "codec.h"
#include "VoxMem.h"
#include "paramSC.h"
#include "dft.h"
#include "Window.h"
#include "MidPitch.h"
#include "EncSC.h"
#include "rate.h"

#include "MidFrame.h"

#include "xvocver.h"

static void GetWindowedSpeech(float pitch, void *hCircBufBlk, 
                              float *pfSpBuf, int *piLength, int iDelay);

static float MidFramePv(float Pv_1, float Pv1, float Cost1, 
                        float Cost0, float *Cost_1);

static void MidFramePhases(STACK_R float *SpBuf, int iLength, float fPitch, 
                           float *pfPhases);


/******************************************************************************
*
* Function: MidFrameParam()
*
******************************************************************************/
void MidFrameParam(STACK_R void *hEncMemBlk, void *hParamMblk,
                   int iCodecDelay, int iSCRate, float Cost1, 
                   int vfFlag)
{
  ENC_MEM_BLK *pEncMemBlk = (ENC_MEM_BLK *)hEncMemBlk;
  PARAM_SC *pParamMblk    = (PARAM_SC *)hParamMblk;

  int   iLength;
  float fCoarsePitchPeriod;
  float fCorrCostMid;
  SUBFRAME_PARAM_SC *pSubParam_Mid, *pSubParam_End;
  
  STACK_INIT
  float fSpBuf[PDA_FRAME_SIZE1];
  STACK_INIT_END
 
  STACK_ATTACH(float *, fSpBuf)

  STACK_START

  pSubParam_Mid = &(pParamMblk->SubParam[PARAM_MIDFRAME]);
  pSubParam_End = &(pParamMblk->SubParam[PARAM_ENDFRAME]);

  /*-----------------------------------------------------------------------
    Interpolate for a coarse estimate of the mid-frame pitch
  -----------------------------------------------------------------------*/
  fCoarsePitchPeriod = MidEstPitch( pEncMemBlk->uq_Pitch_1, 
                                    pSubParam_End->Pitch,
                                    pEncMemBlk->uq_Pv_1, 
                                    pSubParam_End->Pv);
  
  /*-----------------------------------------------------------------------
    If this is vocal fry, then the pitch has been modified and we want to
      undo this.
  -----------------------------------------------------------------------*/
  if (vfFlag == 1) 
    fCoarsePitchPeriod *= 2.0F;

  /*-----------------------------------------------------------------------
    Get windowed mikd-frame speech
  -----------------------------------------------------------------------*/
  GetWindowedSpeech( fCoarsePitchPeriod, pEncMemBlk->CircBuf_mblk, fSpBuf, 
                     &iLength, iCodecDelay);

  /*-----------------------------------------------------------------------
    Refine the pitch using autocorrelation calculation.
  -----------------------------------------------------------------------*/
  pSubParam_Mid->Pitch = TDPitchRefine( fSpBuf, (short)iLength,
                                        fCoarsePitchPeriod, 
                                        &fCorrCostMid, 0.1F);


  /*-----------------------------------------------------------------------
    If this is vocal fry, the reapply the vocal fry pitch period halving
  -----------------------------------------------------------------------*/
  if (vfFlag == 1) 
    pSubParam_Mid->Pitch *= 0.5F;

  /*-----------------------------------------------------------------------
    If encoding SC6, compute the mid-frame measured phases with a DFT.
  -----------------------------------------------------------------------*/
  if (iSCRate==SC_RATE_6K) 
    MidFramePhases( STACK_S fSpBuf, iLength, pSubParam_Mid->Pitch,
                    pSubParam_Mid->pfVEVphase);

  /*-----------------------------------------------------------------------
    Compute mid-frame voicing probability.
  -----------------------------------------------------------------------*/
  pSubParam_Mid->Pv = MidFramePv( pEncMemBlk->uq_Pv_1, 
                                  pSubParam_End->Pv,
                                  Cost1, fCorrCostMid, 
                                  &(pEncMemBlk->lastCorrCost));

  STACK_END

}
    

/******************************************************************************
*
* Function: MidFramePv()
*
* Action:   Find the middle-frame voicing
*
******************************************************************************/
static float MidFramePv(float Pv_1, float Pv1, float Cost1, 
                        float Cost0, float *Cost_1)
{
  float Pv;
  

  /******************************************************************
    calculate the cost value of end-frame.
    *****************************************************************/
  /********* Make the decision. ***********/
  if (*Cost_1 < 0.1F)    *Cost_1 = 0.1F;
  if (Cost1 < 0.1F)       Cost1 = 0.1F;

  if (fabs(Pv1 - Pv_1) < 0.15F)
    Pv = 0.5F*(Pv1+Pv_1);
  else 
  {
    if (Cost0 < 0.35F)     /* noise-like */
    {
      if (Pv1 > Pv_1) 
        Pv = Pv_1 * Cost0 / *Cost_1;
      else
        Pv = Pv1 * Cost0 / Cost1;
    } else {
      if (Pv1 > Pv_1) 
        Pv = Pv1 * Cost0 / Cost1;
      else
        Pv = Pv_1 * Cost0 / *Cost_1;
    }
  }

  if (Pv < 0)    
     Pv = 0.0F;
  if (Pv > 1)    
     Pv = 1.0F;

  /******* Replace last frame's cost value with this frame's one. ******/
  *Cost_1 = Cost1;

  return Pv;
}

/******************************************************************************
*
* Function: GetWindowedSpeech()
*
******************************************************************************/

static void GetWindowedSpeech( float fPitch, void *hCircBufBlk, 
                               float *pfSpBuf, int *piLength, int iDelay)
{
  /****** Get the window length and window the signal ******/
  *piLength = VoxAdaptiveWindow( fPitch );

  /**** Take the middle frame speech out ****/
  GetFrameSpCBM( hCircBufBlk, iDelay, *piLength, pfSpBuf );

  /**** window the speech signal ****/
  HammingWindowNormSC( pfSpBuf, *piLength );
}

/******************************************************************************
*
* Function: MidFramePhases()
*
* Action:   calculate middle-frame Phases using DFT or FFT
*
******************************************************************************/

static void MidFramePhases(STACK_R float *SpBuf, int iLength, float fPitch, 
                           float *pfPhases)
{
  int   i;
  float fSTFTphase;
  float fRadianPitch;

STACK_INIT
  float SWR[SC6_PHASES];
  float SWI[SC6_PHASES];
STACK_INIT_END

STACK_ATTACH(float *, SWR)
STACK_ATTACH(float *, SWI)

STACK_START

  /*---------------------------------------------------------------
    Compute the pitch in radians
  ---------------------------------------------------------------*/
  fRadianPitch = TWOPI/fPitch;

  /*---------------------------------------------------------------
    Calculate the DFT at the pitch harmonics. (NOTE: It is possible
      that fRadianPitch*SC6_PHASES is greater than PI.  If this 
      happens we are computing the DFT at frequencies beyond the 
      Nyquist rate.  This is okay, because the DFT will just
      return the aliased values and they will not be used by 
      the decoder.  The other alternative is to compute the number
      of harmonics, but that increases code size.)
  ---------------------------------------------------------------*/
  VoxDFT(SpBuf, iLength, fRadianPitch, SC6_PHASES, SWR, SWI);

  /*---------------------------------------------------------------
    Calculate the phases
  ---------------------------------------------------------------*/
  for (i = 0; i < SC6_PHASES; i++) 
  {
    fSTFTphase = VoxATAN2(SWI[i], SWR[i]);
    if (fSTFTphase < 0.0F)
      fSTFTphase += TWOPI;
    pfPhases[i] = fSTFTphase;
  }

STACK_END
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\midpitch.h ===
/*******************************************************************************
*                        Voxware Proprietary Material                          *
*                        Copyright 1996, Voxware, Inc                          *
*                            All Rights Reserved                               *
*                                                                              *
*                       DISTRIBUTION PROHIBITED without                        *
*                      written authorization from Voxware                      *
*******************************************************************************/

/*******************************************************************************
*
* Filename: MidPitch.c
*
* Purpose:  centerize the pitch by calculating the autocorrelation value.
*
* Author:   Wei Wang
*
* Date:     Jan. 22, 1996
*
* Modified : Xiaoqin Sun for middle frame pitch estimation
*
* Date:    May   30  1997
*
* $Header:   /export/phobos/pvcs/r_and_d/archives/scaleable/encode/MidPitch.h_v   1.0   06 Feb 1998 10:06:48   johnp  $
*******************************************************************************/
#ifndef _MIDPITCH_H_
#define _MIDPITCH_H_

#define   MAXFLT           3.402823466E+38F  
#define   MINCON           1.0e-6F    /* minimum constant */

float MidEstPitch(float Pitchm1, float Pitchp1, float Pvm1, float Pvp1);

float TDPitchRefine(float *Spbuf, short length, float pitch, float *maxCost, 
		    float deltaP0);

#endif /* end of #ifndef _MIDPITCH_H_  */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\midpitch.c ===
/*******************************************************************************
*                        Voxware Proprietary Material                          *
*                        Copyright 1996, Voxware, Inc                          *
*                            All Rights Reserved                               *
*                                                                              *
*                       DISTRIBUTION PROHIBITED without                        *
*                      written authorization from Voxware                      *
*******************************************************************************/

/*******************************************************************************
*
* Filename: MidPitch.c
*
* Purpose:  centerize the pitch by calculating the autocorrelation value.
*
* Author:   Wei Wang
*
* Date:     Jan. 22, 1996
*
* Modified : Xiaoqin Sun for middle frame pitch estimation
* 
* Date:    May   30  1997 
*
* $Header:   /export/phobos/pvcs/r_and_d/archives/scaleable/encode/MidPitch.c_v   1.3   20 Mar 1998 10:26:22   weiwang  $
*******************************************************************************/

#include <math.h>
#include <assert.h>
#include <string.h>
#include <stdlib.h>

#include "vLibVec.h"
#include "vLibMath.h"
#include "vLibSpch.h"
#include "codec.h"

#include "MidPitch.h"

#include "xvocver.h"

/* MidEstPitch:  estimiate the possible pitch range. */
float MidEstPitch(float Pitchm1, float Pitchp1, float Pvm1, float Pvp1)
{
  float pitch, Pv;

  /*----------------------------------------------------------------------------
    Determine the initial pitch value at the middle frame from pitch values 
    and voicing probability values at k-1 and k+1 frames.
    ----------------------------------------------------------------------------*/
  if( (Pitchp1 <= 1.25F*Pitchm1)  && (Pitchp1 >= Pitchm1*0.8F))
    pitch = (Pitchm1 + Pitchp1) *0.5F;
  else 
    {
      if(Pvm1>Pvp1) {       /* prevent quantization rounding error */
        pitch=Pitchm1;
        Pv = Pvm1;
      }
      else {
        pitch=Pitchp1;
        Pv = Pvp1;
      }

      if (pitch < 30 && (Pv*pitch*0.5F) < 1.0F)   /* to prevent pulsive sound */
        {
         if (Pitchp1 > Pitchm1)
            pitch = Pitchp1;
         else
            pitch = Pitchm1;
        }
    }

  return pitch;
}


/* MidPitchRefine: refine the estimated pitch using time-domain auto-correlation
   calculation. */
float TDPitchRefine(float *Spbuf, short length, float pitch, float *maxCost, 
                    float deltaP0)
{
  int delta;
  int Left_lag, Right_lag;
  float maxCorr;
  float refine_pitch;
  int bestLag, bestI;
  int jlag, i;
  float totalCorr;
  float pCorrCosts[3];
  float eng1, eng2;
  float ftmp;

  /*------------------------------------------------------------
    Find out the pitch searching range.
    ------------------------------------------------------------*/
  ftmp = deltaP0*pitch;
  VoxROUND2pos(ftmp, delta);
  if (delta > MAX_DELTA)
    delta = MAX_DELTA;
  
  ftmp = pitch-delta;
  VoxROUND2pos(ftmp, Left_lag);

  ftmp = pitch+delta;
  VoxROUND2pos(ftmp, Right_lag);

  if (Left_lag < MIN_PITCH)
  Left_lag = MIN_PITCH;
    
  if (Right_lag > MAX_PITCH)
  Right_lag = MAX_PITCH;


  /*--------------------------------------------------
    calculate the autocorrelation function.
    --------------------------------------------------*/
  jlag = Left_lag;
  maxCorr = -MAXFLT;
  bestI = 0;
  pCorrCosts[0] = pCorrCosts[1] = pCorrCosts[2] = 0.0F;
  i=0;
  do {
    totalCorr = DotProd(Spbuf, Spbuf+jlag, length-jlag);
    if (totalCorr > maxCorr) {
      maxCorr = totalCorr;
      bestI = i;
      pCorrCosts[0] = pCorrCosts[1];
    }
    else {
      if (bestI == (i-1)) {
        pCorrCosts[2] = totalCorr;
      }
    }

    pCorrCosts[1] = totalCorr;

    i++;
    jlag++;
  } while (jlag <= Right_lag);
  

  /*-------------------------------------------------------
    use quadratic interpolation to get refined pitch.
    -------------------------------------------------------*/
  bestLag = bestI+Left_lag;

  if ((bestLag > Left_lag) && (bestLag < Right_lag)) 
    refine_pitch = (float)bestLag + QuadraticPeak(pCorrCosts[0], maxCorr, 
                             pCorrCosts[2], maxCost);
  else {
    refine_pitch = (float)bestLag;
    *maxCost = maxCorr;
  }
     
  /*------------------------------------------------------------
    now normalized the cost value.
    ------------------------------------------------------------*/
  /* calculate energy of psigBuf[0:win_length-bestLag-1] and psigBuf[bestLag:win_length-1] */
  eng1 = DotProd(Spbuf, Spbuf, length-bestLag);
  eng2 = DotProd(Spbuf+bestLag, Spbuf+bestLag, length-bestLag);

  *maxCost /= ((float)sqrt(eng1*eng2+MINCON));

 
  return refine_pitch;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\msvqpred.c ===
/******************************************************************************
*                        Voxware Proprietary Material
*                        Copyright 1996, Voxware, Inc
*                            All Rights Reserved
*
*                       DISTRIBUTION PROHIBITED without
*                      written authorization from Voxware
******************************************************************************/
 
/******************************************************************************
* Filename:    MSVqPred.c
*
* Purpose:     quantization coefficients using multi-stage predictive VQ
*
* Functions:   VoxMSVQEncPred
*              VoxMSVQDecPred
*
* Author/Date:     Bob Dunn 7/18/97
*******************************************************************************
*
* Modifications:   Write MSVQ encode and decode functions 
*                  Xiaoqin Sun   7/25/97
*
*                  Wei Wang, 1/30/98, Rewrite whole code and simplify the 
*                  initialization by adding "ASKCBSC3.h".
*
* Comments: 
*
* Concerns: the dimension for sub-vector is 2.
*
* $Header:   /export/phobos/pvcs/r_and_d/archives/scaleable/quan/MSVqPred.c_v   1.5   08 Apr 1998 11:03:02   weiwang  $
*
******************************************************************************/
#include <stdlib.h>
#include <assert.h>
#include <string.h>

#include "vLibQuan.h"
#include "VoxMem.h"

#include "codec.h"
#include "quansc36.h"
#include "CodeStr.h"

#include "RSMSVq.h"
#include "MSVqPred.h"

#include "ASKCBSC3.h"

#include "xvocver.h"

#define PV_THRESHOLD 0.8F

static void CompPredCoef(const float *fZMCoef, int iNumPredOrd, 
                         const float *tab_Pred, float *pfPredCoef, int iSubDim);

#ifndef DECODE_ONLY
/******************************************************************************
*
* Function: VoxMSVQEncPred
*
* Action:   quantize vector using split and predicted 2-stage Rotation-Scaling VQ.
*
* Input:  pfCoef -- input vector
*         piIndices -- the pointer for the output indices.
*         iOrder -- order of the vector
*         fPv -- voicing probability.
*
* Output: piIndices -- quantization indices.
*
* Globals:   none
*
* Return:    none
*******************************************************************************
*
* Implementation/Detailed Description: 
*
* References:
*******************************************************************************
*
* Modifications:
*
* Comments:  
*
* Concerns/TBD:
******************************************************************************/

void VoxMSVQEncPred(STACK_R float *pfCoef, int *piIndices, 
                    int iOrder, float fPv)
{
  float *tab_Means;
  float **tab_Pred;
  int iFirstLag;
  int i, j;

STACK_INIT
  float  pfZMCoef[LPC_ORDER];
  float  pfPredCoef[SUB_DIMENSION];
  RS2StageVQ_MBlk * ASKCB_mblk[MSVQ_PAIRS];

STACK_INIT_END
  STACK_ATTACH (float *, pfZMCoef)
  STACK_ATTACH (float *, pfPredCoef)
  STACK_ATTACH (RS2StageVQ_MBlk **, ASKCB_mblk)

STACK_START

  assert(iOrder == (SUB_VECTORS*SUB_DIMENSION));
  assert(SUB_DIMENSION == 2);
  assert((pfCoef != NULL) && (piIndices != NULL));

  /* choose the tables by comparing the voicing */
  if (fPv>PV_THRESHOLD)
    {
      tab_Means = (float *)tab_ASK12_V_Means;
      tab_Pred = (float **)ptab_ASK12_V_Pred;
      ASKCB_mblk[0] = (RS2StageVQ_MBlk *)&ASK0_1_V_mblk;
    } 
  else 
    {
      tab_Means = (float *)tab_ASK12_UV_Means;
      tab_Pred = (float **)ptab_ASK12_UV_Pred;
      ASKCB_mblk[0] = (RS2StageVQ_MBlk *)&ASK0_1_UV_mblk;
    }
   
   ASKCB_mblk[1] = (RS2StageVQ_MBlk *)&ASK2_3_mblk;
   ASKCB_mblk[2] = (RS2StageVQ_MBlk *)&ASK4_5_mblk;
   ASKCB_mblk[3] = (RS2StageVQ_MBlk *)&ASK6_7_mblk;


   /*--------------------------------------------
     Mean remover
     --------------------------------------------*/
   for (i=0; i<iOrder; i++)
     pfZMCoef[i] = pfCoef[i] - tab_Means[i];

   /*--------------------------------------------
     Encode each subvector
   --------------------------------------------*/
   iFirstLag = 0;

   for (i = 0; i < SUB_VECTORS; i++)
     {
       /*--------------------------------------------
         predict the ASK values and find the residual
         --------------------------------------------*/
       CompPredCoef(pfZMCoef, iFirstLag, tab_Pred[i], pfPredCoef, SUB_DIMENSION);

       pfZMCoef[iFirstLag] -= pfPredCoef[0];
       pfZMCoef[iFirstLag+1] -= pfPredCoef[1];
 
       if ( i < MSVQ_PAIRS) {
         /*--------------------------------------------
           Encode the ASK residual using RSMSVQ
           --------------------------------------------*/
         RS2StageVQ2Enc(STACK_S &(piIndices[iFirstLag]), &pfZMCoef[iFirstLag], 
                        NUMCAND, ASKCB_mblk[i]->iStage1Size, 
                        ASKCB_mblk[i]->pfStage1CB, ASKCB_mblk[i]->pfRotScaleCB,
                        ASKCB_mblk[i]->iStage2Size,
                        ASKCB_mblk[i]->pfStage2InCellCB, 
                        ASKCB_mblk[i]->pfStage2OutCellCB,
                        ASKCB_mblk[i]->iNumOfOutCell, 
                        ASKCB_mblk[i]->piIndexOfStage2OutCell);
       }
       else {
         /*--------------------------------------------------
           Encode the residual using 2-dimensional VQ 
           --------------------------------------------------*/
         j = i - MSVQ_PAIRS;
         piIndices[iFirstLag] = Dim2VectorQuantize(&pfZMCoef[iFirstLag],
                                      pASK8_11_VQ[j]->fCodeBook, 
                                      pASK8_11_VQ[j]->iCodebookSize);

         piIndices[iFirstLag+1] = 0;   /* single stage VQ */

        /*--------------------------------------------
          Decode the residual for the next sub-vector.
          --------------------------------------------*/
         Dim2VectorLUT( piIndices[iFirstLag], 
                        pASK8_11_VQ[j]->fCodeBook, 
                        pASK8_11_VQ[j]->iCodebookSize,
                        &pfZMCoef[iFirstLag]);
       }

       /*---------------------------------------------
         Compute the quantized coefficients.
        ---------------------------------------------*/
       pfZMCoef[iFirstLag++] += pfPredCoef[0];
       pfZMCoef[iFirstLag++] += pfPredCoef[1];
     }

   /*--------------------------------------------------
     add the mean vector
     --------------------------------------------------*/
   for (i = 0; i < iOrder; i++)
     pfCoef[i] = pfZMCoef[i] + tab_Means[i];
    
   STACK_END
}

#endif

/******************************************************************************
*
* Function:  VoxMSVQDecPred
*
* Action:    unquantize coefficients
*
* Input:   piIndices -- input quantization indices
*          pfCoef -- pointer for the output vector
*          iOrder -- the order for the vector
*          fPv -- voicing probability
*
* Output:  pfCoef -- quantized vector
*
* Globals:   none
*
* Return:    none
*******************************************************************************
*
* Implementation/Detailed Description: 
*
* References:
*******************************************************************************
*
* Modifications:
*
* Comments:  
*
* Concerns/TBD:
******************************************************************************/

void VoxMSVQDecPred(STACK_R const int *piIndices, float *pfCoef, 
                    int iOrder, float fPv)
{
  float *tab_Means;
  float **tab_Pred;
  int i, j; 
  int iFirstLag;

STACK_INIT
  float  pfZMCoef[LPC_ORDER];
  float  pfPredCoef[SUB_DIMENSION];
  RS2StageVQ_MBlk *ASKCB_mblk[MSVQ_PAIRS];

STACK_INIT_END
  STACK_ATTACH (float *, pfZMCoef)
  STACK_ATTACH (float *, pfPredCoef)
  STACK_ATTACH (RS2StageVQ_MBlk **, ASKCB_mblk)

STACK_START

  assert(iOrder == (SUB_VECTORS*SUB_DIMENSION));
  assert(SUB_DIMENSION == 2);
  assert((piIndices != NULL) && (pfCoef != NULL));

  /* choose the tables by comparing the voicing */
  if (fPv>PV_THRESHOLD)
    {
      tab_Means = (float *)tab_ASK12_V_Means;
      tab_Pred = (float **)ptab_ASK12_V_Pred;
      ASKCB_mblk[0] = (RS2StageVQ_MBlk *)&ASK0_1_V_mblk;
    } 
  else 
    {
      tab_Means = (float *)tab_ASK12_UV_Means;
      tab_Pred = (float **)ptab_ASK12_UV_Pred;
      ASKCB_mblk[0] = (RS2StageVQ_MBlk *)&ASK0_1_UV_mblk;
    }
   
  ASKCB_mblk[1] = (RS2StageVQ_MBlk *)&ASK2_3_mblk;
  ASKCB_mblk[2] = (RS2StageVQ_MBlk *)&ASK4_5_mblk;
  ASKCB_mblk[3] = (RS2StageVQ_MBlk *)&ASK6_7_mblk;


  /*--------------------------------------------
    Decode each subvector
   --------------------------------------------*/
  iFirstLag = 0;

  for (i = 0; i < SUB_VECTORS; i++)
     {
       if (i < MSVQ_PAIRS) {

         /*--------------------------------------------------
           Decode residual using RSMSVQ.
           --------------------------------------------------*/
         RS2StageVQ2Dec(STACK_S &(piIndices[iFirstLag]), 
                        &(pfZMCoef[iFirstLag]), 
                        ASKCB_mblk[i]->iStage1Size,
                        ASKCB_mblk[i]->pfStage1CB,
                        ASKCB_mblk[i]->pfRotScaleCB,
                        ASKCB_mblk[i]->iStage2Size,
                        ASKCB_mblk[i]->pfStage2InCellCB,
                        ASKCB_mblk[i]->pfStage2OutCellCB,
                        ASKCB_mblk[i]->iNumOfOutCell,
                        ASKCB_mblk[i]->piIndexOfStage2OutCell);
       }
       else {
          j = i-MSVQ_PAIRS;
         /*--------------------------------------------
           Decode the residual using 2-dimensional VQ
           --------------------------------------------*/
         Dim2VectorLUT( piIndices[iFirstLag], 
                        pASK8_11_VQ[j]->fCodeBook, 
                        pASK8_11_VQ[j]->iCodebookSize,
                        &pfZMCoef[iFirstLag]);
       }
         
       /*--------------------------------------------
         predict the ASK values
         --------------------------------------------*/
         CompPredCoef(pfZMCoef, iFirstLag, 
                      tab_Pred[i], pfPredCoef, SUB_DIMENSION);

       /*--------------------------------------------
         Add predicted value to decoded residual
         --------------------------------------------*/
        pfZMCoef[iFirstLag++] += pfPredCoef[0];
        pfZMCoef[iFirstLag++] += pfPredCoef[1];
     }

  /*--------------------------------------------
    Add the mean value to the ASKs
    --------------------------------------------*/
  for (i=0; i<iOrder; i++)
    pfCoef[i] = pfZMCoef[i] + tab_Means[i];

STACK_END
}

/******************************************************************************
*
* Function:  CompPredCoef
*
* Action:    Compute the predictor based on the previous coefficients.
*
* Input:     pfZMCoef -- input zero-mean coefficients.
*            iNumPredOrd -- the predictor order
*            tab_Pred -- the table for predictor
*            pfPredCoef -- the address for the output prediction coefficients
*            iSubDim -- the dimension for sub-vector
*
* Output:    pfPredCoef -- output prediction coefficients
*
* Globals:   none
*
* Return:    none
*******************************************************************************
*
* Implementation/Detailed Description: 
*
* References:
*******************************************************************************
*
* Modifications:
*
* Comments:  
*
* Concerns/TBD:   tab_Pred may be nil pointer when iNumPredOrd == 0.
******************************************************************************/
static void CompPredCoef(const float *pfZMCoef, int iNumPredOrd, 
                         const float *tab_Pred, 
                         float *pfPredCoef, int iSubDim)
{
  register int i, j;
  register float rPred;
  float *pfPredTab;

  assert(pfZMCoef != NULL && pfPredCoef != NULL);

  for (i = 0; i < iSubDim; i++) {
    rPred = 0.0F;
    pfPredTab = (float *)&(tab_Pred[i*iNumPredOrd]);
    for (j = 0; j < iNumPredOrd; j++)
      rPred += pfPredTab[j] * pfZMCoef[j];

    pfPredCoef[i] = rPred;
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\model.h ===
/*******************************************************************************
*                        Voxware Proprietary Material                          *
*                        Copyright 1996, Voxware, Inc                          *
*                            All Rights Reserved                               *
*                                                                              *
*                       DISTRIBUTION PROHIBITED without                        *
*                      written authorization from Voxware                      *
*******************************************************************************/

/*******************************************************************************
* Filename:       model.h
*                                                                              
* Purpose:        Provide definitions pertaining to the model codec ONLY.
*                                                                              
* Author/Date:    Rob Zopf  02/17/97
********************************************************************************
* $Header:   /export/phobos/pvcs/r_and_d/archives/realtime/include/model.h_v   1.4   01 Dec 1998 14:37:48   zopf  $                                                                      
*******************************************************************************/

#ifndef _MODEL_H
#define _MODEL_H

#include "lpcorder.h"
/*-----------------------------------------------------------------------------
    C U R R E N T L Y   S U P P O R T E D   C O M P I L E   S W I T C H E S 
 -----------------------------------------------------------------------------*/
#define FULL_BAND_PV                1   /* 1: using whole band for voicing decision 0:3984.375Hz */

/*-----------------------------------------------------------------------------
            G E N E R A L   C O D E C   D E F I N I T I O N S
 -----------------------------------------------------------------------------*/
#define FRAME_LEN                   180
#define MAXFRAMELEN                 180
#define RATE8K                      8000.0F
#define INV_RATE8K                  (1.0F/RATE8K) /* RTE */
#undef PI
#define PI                          (double)3.141592654
#define D_PI                        (2.0*PI)


#if FULL_BAND_PV == 0
#define ARBITRARY_CUTOFF            0.9254F
#else
#define ARBITRARY_CUTOFF           0.99609375F /* (255/256) using whole band 0:3984.375Hz */
#endif

/*------------------------------------------------------------------------------
          E N C O D E R   S P E C I F I C   D E F I N I T I O N S 
------------------------------------------------------------------------------*/

#define PRE_PROC_COEF               0.99F

#define MIN_PITCH                   8
#define MAX_PITCH                   180
#define CIRCBUF_LENGTH              401

#define FRAME_SIZE1                 221
#define FRAME_SIZE2                 241
#define FRAME_SIZE3                 261

#define PITCH4FRAME_SIZE2           60.0F   
#define PITCH4FRAME_SIZE3           43.0F   

#define EXPAND_COEF                 0.994F

#define MAXHARM                     (MAX_PITCH>>1)
#define MAXHARM_2                   (MAXHARM>>1)

#define MAX_F0                      (RATE8K/MIN_PITCH)

#define PITCH_UV                  125     /* 64 Hz */

/* Encoder FFT Lengths */
#define FFT_ORDER                   9   /* change this to something more descriptive */
#define NFFT                        (1<<FFT_ORDER)
#define NFFT_2                      (NFFT>>1)
#define NFFT_4                      (NFFT>>2)

/*------------------------------------------------------------------------------
          D E C O D E R   S P E C I F I C   D E F I N I T I O N S 
------------------------------------------------------------------------------*/
#define LPCSYN_SUBFRAMES            4
#define SYNSUBFRAMES                3
#define LPC_ORDER                   CODEC_LPC_ORDER    
#define OVERLAPFACTOR               1.0F
#define PITCH_RANGE_FOR_INTERP      0.15F
#define MAXSUBFRAMELEN             (short)(FRAME_LEN/SYNSUBFRAMES)
#define MAXSYNLEN                   MAXSUBFRAMELEN*2-1
#define ENHANCE_FFT_REAL_ORDER      6
#define LSP_SEPERATION_HZ           45.0F
#define MAX_PITCH_MULT              125

#define LSP_INITIAL_COND_0			300.0F 	/*%# 300Hz -- RTE */
#define LSP_INITIAL_COND_DEL        (3600.0F/(float)(LPC_ORDER-1)) /* RTE */
#define SPEECH_CLIP_MAX        		32000   
#define SPEECH_CLIP_MIN        		-32000  

#define USE_FHT_SYN                 1

#if (MAXHARM < 64)
#define EXP_SHIFT                   7
#elif (MAXHARM < 128)
#define EXP_SHIFT                   8
#endif
#if (MAXHARM >=128)
#error                              "MAXHARM Exceeds FHT Range"
#endif
#define EXP_SIZE                    (1<<EXP_SHIFT) 

#define QPHASE                      10




#define BARK_PW_BANDS 				20	 /* # of perceptual weighting bands for Amplitude quantization */
										 /* this must match to quantizer !!! */

/*----------------------------------------------------
  BackGround Noise Smoothing
  ----------------------------------------------------*/
#define HANGOVER_TIME 10
#define AVE_FACTOR  0.2F


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\msvqpred.h ===
/******************************************************************************
*                        Voxware Proprietary Material
*                        Copyright 1996, Voxware, Inc
*                            All Rights Reserved
*
*                       DISTRIBUTION PROHIBITED without
*                      written authorization from Voxware
******************************************************************************/
 
/******************************************************************************
* Filename:    MSVqPred.h
*
* Purpose:     quantization coefficients using multi-stage predictive VQ
*
* Functions:   VoxMSVQEncPred
*              VoxMSVQDecPred
*
* Author/Date:     Bob Dunn 7/18/97
*******************************************************************************
*
* Modifications:   Write MSVQ encode and decode functions 
*                  Xiaoqin Sun   7/25/97
*
*                  Wei Wang, 1/30/98, Rewrite whole code and simplify the 
*                  initialization by adding "ASKCBSC3.h".
*
* Comments: 
*
* Concerns: the dimension for sub-vector is 2.
*
* $Header:   /export/phobos/pvcs/r_and_d/archives/scaleable/quan/MSVqPred.h_v   1.1   16 Mar 1998 15:58:08   weiwang  $
*
******************************************************************************/

#ifndef MSVQPRED_H
#define MSVQPRED_H


/******************************************************************************
*
* Function: VoxMSVQEncPred
*
* Action:   quantize vector using split and predicted 2-stage Rotation-Scaling VQ.
*
* Input:  pfCoef -- input vector
*         piIndices -- the pointer for the output indices.
*         iOrder -- order of the vector
*         fPv -- voicing probability.
*
* Output: piIndices -- quantization indices.
*
* Globals:   none
*
* Return:    none
*******************************************************************************/

void VoxMSVQEncPred(STACK_R float *pfCoef, int *piIndices, 
                    int iOrder, float fPv);

/******************************************************************************
*
* Function:  VoxMSVQDecPred
*
* Action:    unquantize the vector
*
* Input:   piIndices -- input quantization indices
*          pfCoef -- pointer for the output vector
*          iOrder -- the order for vector
*          fPv -- voicing probability
*
* Output:  pfCoef -- quantized vector
*
* Globals:   none
*
* Return:    none
*******************************************************************************/

void VoxMSVQDecPred(STACK_R const int *piIndices, float *pfCoef, 
                    int iOrder, float fPv);

#endif /* MSVQPRED_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\new.asm ===
016f:7cc61156 e822010000     call      7cc6127d
016f:7cc6115b d94508         fld       dword ptr [ebp+08]
016f:7cc6115e d80de422c47c   fmul      dword ptr [7cc422e4]
016f:7cc61164 8b45fc         mov       eax,dword ptr [ebp-04]
016f:7cc61167 3bc3           cmp       eax,ebx
016f:7cc61169 d95d08         fstp      dword ptr [ebp+08]
016f:7cc6116c d94514         fld       dword ptr [ebp+14]
016f:7cc6116f d80de86cc47c   fmul      dword ptr [7cc46ce8]
25df##u
016f:7cc61175 7e37           jle       7cc611ae
016f:7cc61177 8b7510         mov       esi,dword ptr [ebp+10]
016f:7cc6117a 894514         mov       dword ptr [ebp+14],eax
016f:7cc6117d 8bd6           mov       edx,esi
016f:7cc6117f 8b0e           mov       ecx,dword ptr [esi]				;== TOP OF lOOP
016f:7cc61181 3b4d0c         cmp       ecx,dword ptr [ebp+0c]
016f:7cc61184 7d20           jge       7cc611a6
016f:7cc61186 d9848d20feffff fld       dword ptr [ebp+ecx*4+fffffe20]
016f:7cc6118d d80c8f         fmul      dword ptr [edi+ecx*4]
016f:7cc61190 d85d08         fcomp     dword ptr [ebp+08]
016f:7cc61193 dfe0           fstsw     ax
016f:7cc61195 9e             sahf
25df##u
016f:7cc61196 720e           jc        7cc611a6
016f:7cc61198 d8148f         fcom      dword ptr [edi+ecx*4]
016f:7cc6119b dfe0           fstsw     ax
016f:7cc6119d 9e             sahf
016f:7cc6119e 7306           jnc       7cc611a6
016f:7cc611a0 890a           mov       dword ptr [edx],ecx
016f:7cc611a2 43             inc       ebx
016f:7cc611a3 83c204         add       edx,+04
016f:7cc611a6 83c604         add       esi,+04
016f:7cc611a9 ff4d14         dec       dword ptr [ebp+14]
016f:7cc611ac 75d1           jnz       7cc6117f
016f:7cc611ae 8b4510         mov       eax,dword ptr [ebp+10]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\nspiir.c ===
/*******************************************************************************
*                        Voxware Proprietary Material                          *
*                        Copyright 1996, Voxware, Inc                          *
*                            All Rights Reserved                               *
*                                                                              *
*                       DISTRIBUTION PROHIBITED without                        *
*                      written authorization from Voxware                      *
*******************************************************************************/

/*******************************************************************************
* Filename:   NspIIR.c                                                                    
*                                                                              
* Purpose:    IIR filter routine                                                                 
*                                                                              
* Functions:  VoxNspIIRFlt()                                                                
*                                                                              
* Author/Date: Xiangdong Fu(originated from Intel NSP Lib)  12/10/96                                                              
********************************************************************************
* Modifications:
*                   
* Comments:   1. Inplace filtering is available for order > 1
*             2. The first coefficient of Denominator should always
*                be normalized to 1.0 and be ignored when filter
*                coefficients are packed into the "taps" array                                                         
*             -- 
*             Xiangdong Fu  12/10/96
* Concerns:
*
*******************************************************************************/



#include "NspIIR.h"

#include "xvocver.h"
/******************************************************************************
*  Input:
*          inSamps       --       input signal
*          numIters      --       Length of IIR filtering
*          order         --       IIR filter order
*          taps          --       filter taps([NUM:DEN])
*          dlyl          --       filter delay line
*  OutPut:
*          outSamps      --       output signal
*******************************************************************************/

void VoxNspIIRFlt(float *inSamps, float *outSamps, int numIters,
		   float *taps, int order, float *dlyl)


{
	
  int    ni; 
  float  taps0;
  float  out, out1;


  {
	/* arbitrary filter 2-nd order unrolling algorithm */
    int                i, ordm1, ordm2;
    float              inp ,  inp1;
    float              taps1, tapsh1, tapsh2, tapsh0 , tapsh00;
    float              *tapsh;
    float              dl;  

    if (order > 1 ) {    /*  filter order  > 0 */
      taps0   = taps[0];
      taps1   = taps[1];
      tapsh   = &taps[order];
      tapsh1  = taps[order-1];
      tapsh2  = tapsh[order-1];
      tapsh0  = taps[order];
      tapsh00 = taps[2*order];
      ordm1   = order - 1;
      ordm2   = order - 2;
      if ( numIters > 1  ) {
        if (numIters % 2) {   /* Sample number is odd */
          for (ni = 0; ni < numIters-1; ni += 2) {
            inp  = inSamps[ni];
            inp1 = inSamps[ni+1];
            out  = taps0 * inp + dlyl[0];
            outSamps[ni] = out;
            out1 = taps0 * inp1 + taps1 * inp - tapsh[1]*out + dlyl[1];
            outSamps[ni+1]=out1;
            for (i = 2; i < order; i++)
              dlyl[i-2] = taps[i-1] * inp1 - tapsh[i-1] * out1
                        + taps[i]   * inp  - tapsh[i]   * out  + dlyl[i];
            dlyl[ordm2] = tapsh1 * inp1 - tapsh2  * out1 + tapsh0 * inp
                        - tapsh00 * out;
            dlyl[ordm1] = tapsh0 * inp1 - tapsh00 * out1;
          } /* end ni */
          outSamps[numIters-1] = taps0 * inSamps[numIters-1] + dlyl[0]; /* last sample */
          for (i = 1; i < order; i++)
            dlyl[i-1] = taps[i] * inSamps[numIters-1]
                      - tapsh[i] * outSamps[numIters-1] + dlyl[i];
          dlyl[ordm1] = tapsh0 * inSamps[numIters-1]
                     - tapsh00 * outSamps[numIters-1];
        } /* end  if odd */
        else {              /* Sample number is even */
          for (ni = 0; ni < numIters; ni+=2) {
            inp  = inSamps[ni];
            inp1 = inSamps[ni+1];
            out  = taps0 * inp + dlyl[0];
            out1 = taps0 * inp1 + taps1 * inp - tapsh[1] * out + dlyl[1];
            outSamps[ni]   = out;
            outSamps[ni+1] = out1;
            for (i = 2; i < order; i++){
              dl = taps[i-1] * inp1 - tapsh[i-1] * out1
                 + taps[i]   * inp  - tapsh[i]   * out + dlyl[i];
              dlyl[i-2] = dl;
            }/* end i */
            dlyl[ordm2] = tapsh1 * inp1 - tapsh2  * out1
                        + tapsh0 * inp  - tapsh00 * out;
            dlyl[ordm1] = tapsh0 * inp1 - tapsh00 * out1;
          } /* end ni */
        } /* end else even */ 
      }
      else  { /*  numIters = 1 */
        outSamps[0] = taps0 * inSamps[0] + dlyl[0]; 
        for (i = 1; i < order; i++)
          dlyl[i-1] = taps[i] * inSamps[0]
                    - tapsh[i] * outSamps[0] + dlyl[i];
        dlyl[ordm1] = tapsh0 * inSamps[0]
                    - tapsh00 * outSamps[0];
      }
    } /* end if order > 1 */

    else {
      if (order) {
        for (ni = 0; ni < numIters; ni++) {
          outSamps[ni] = taps[0] * inSamps[ni] + dlyl[0];
          dlyl[0] = taps[1] * inSamps[ni]
                  - taps[2] * outSamps[ni];
        }
      }
      else {
        for (ni = 0; ni < numIters; ni++)
        outSamps[ni] = taps[0] * inSamps[ni];
      }
    }
  }
}  /* end voxnspiirflt()  */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\nspiir.h ===
#ifndef NSPIIR_H
#define NSPIIR_H

void VoxNspIIRFlt(float *sigIn, float *sigOut, int sigLen, 
                  float *coeffs, int order, float *inter_mem);

#endif /* NSPIIR_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\normwin.c ===
/*****************************************************************************
*                        Voxware Proprietary Material                       *
*                        Copyright 1996, Voxware Inc.                       *
*                        All Rights Reserved                                *
*                                                                           *
*                        DISTRIBUTION PROHIBITED without                    *
*                        written authorization from Voxware.                *
*****************************************************************************/
/*******************************************************************************
*
* File:  NormWin.c
*
* Purpose: Normalize window by either power or area function.
*
* Author: Wei Wang
*
* Date:  Jan., 1998
*
* $Header:   /export/phobos/pvcs/pvcsproj/voxlib.prj/NormWin.c_v   1.2   26 Feb 1998 16:46:14   weiwang  $
*
******************************************************************************
* Modifications:
*
* Comments:
*
* Concerns:
*
******************************************************************************/
#include <stdlib.h>
#include <assert.h>
#include <math.h>
#include "vLibSgPr.h"

#include "xvocver.h"

/*******************************************************************************
* 
* Function: NormSymWindowByPower()
*
* Action: Normalize the symmetric window by power
*
* Input:  pfWindow: non-normalized window data (either left half or whole size).
*         iWindowSize : the length of window.
*
* Output: pfWindow: normalized window data.
*
* return: None.
*
******************************************************************************
* Modifications:
*
* Comments:
*
* Concerns/TBD: Since the window is symmetric, the total power is:
*   2.0*sum(Win[i]*Win[i]), i = 0...(N>>1)-1,
*   if N is odd number, add center point.
*   However, since the variable is float, it's not identical to:
*   sum(Win[i]*Win[i]), i = 0...(N-1).
*
******************************************************************************/

void NormSymWindowByPower(float *pfWindow, int iWindowSize)
{
  int iHalfSize;
  float fWindowPower, fNormFactor;
  int i;

  iHalfSize = iWindowSize >> 1;

  assert(pfWindow != NULL);

  /**** compute the left half size of window Power *****/
  fWindowPower = 0.0F;
  for (i = 0; i < iHalfSize; i++)
    fWindowPower += pfWindow[i] * pfWindow[i];

  /**** add the right half size of window Power *****/
  fWindowPower *= 2.0F;

  /**** consider the center point *****/
  if (iWindowSize & 1)
    fWindowPower += pfWindow[iHalfSize] * pfWindow[iHalfSize];

  /***** compute the normalization factor *****/
  fNormFactor = (float)sqrt((float)iWindowSize/fWindowPower);
  
  /***** apply the normalization factor to the window *****/
  for (i = 0; i < iHalfSize; i++)
    pfWindow[i] *= fNormFactor;

  if (iWindowSize & 1)
    pfWindow[i] *= fNormFactor;
}


/*******************************************************************************
* 
* Function: NormSymWindowByArea()
*
* Action: Normalize the symmetric window by area function.
*
* Input:  pfWindow: non-normalized window data (either left half or whole size).
*         iWindowSize : the length of window.
*
* Output: pfWindow: normalized window data.
*
* return: None.
*******************************************************************************/

void NormSymWindowByArea(float *pfWindow, int iWindowSize)
{
  int iHalfSize;
  float fWindowArea, fNormFactor;
  int i;

  iHalfSize = iWindowSize >> 1;

  /**** compute the left half size of window area function ****/
  fWindowArea = 0.0F;
  for (i = 0; i < iHalfSize; i++)
    fWindowArea += pfWindow[i];

  /**** add the right half size of window energy *****/
  fWindowArea *= 2.0F;

  /**** consider the center point *****/
  if (iWindowSize & 1)
    fWindowArea += pfWindow[iHalfSize];

  /***** compute the normalization factor *****/
  fNormFactor = 1.0F/fWindowArea;
  
  /***** apply the normalization factor to the window *****/
  for (i = 0; i < iHalfSize; i++)
    pfWindow[i] *= fNormFactor;
  if (iWindowSize & 1)
    pfWindow[i] *= fNormFactor;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\nsptimer.h ===
/*M*
//
//               INTEL CORPORATION PROPRIETARY INFORMATION
//  This software is supplied under the terms of a license agreement or
//  nondisclosure agreement with Intel Corporation and may not be copied
//  or disclosed except in accordance with the terms of that agreement.
//        Copyright (c) 1995 Intel Corporation. All Rights Reserved.
//
//  RCS:
//      $Source: d:/rcs/nsp20/test_sys/src/demo/tstapi.h $
//      $Revision:   1.0  $
//      $Date:   10 Feb 1998 14:21:32  $
//
//  Author: Smirnov I.
//
//  Purpose: Lite Test System Program Interface
//
//  Modification Log:
//	95/8/22: Smirnov I. Creation
//
*M*/

#if !defined _TSTAPI_H
# define _TSTAPI_H
#include <malloc.h> /* for size_t */


/*---------------------------------------------------------------*/
/* --- Global defintions ----------------------------------------*/
/*---------------------------------------------------------------*/

#define TSTAPI(ftype)                       extern ftype


/*---------------------------------------------------------------*/
/* --- Benchmark Timing functions -------------------------------*/
/*---------------------------------------------------------------*/

#define USECS     		1000000.0

TSTAPI(void) tstTimerStart(int TimerNo);
TSTAPI(void) tstTimerStop(int TimerNo);
/* TSTAPI(void) tstTimerContinue(int TimerNo); */

TSTAPI(double) tstTimerClock(int TimerNo);
TSTAPI(double) tstTimerSec(int TimerNo);
TSTAPI(double) tstTimerUSec(int TimerNo);

  
#endif /* _TSTAPI_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\nurand.c ===
/******************************************************************************
*                        Voxware Proprietary Material
*                        Copyright 1996, Voxware, Inc
*                            All Rights Reserved
*
*                       DISTRIBUTION PROHIBITED without
*                      written authorization from Voxware
******************************************************************************/
 
/******************************************************************************
*
* Filename:   nurand.c
*
* Purpose:    Compute the random number in long (31 bit).
*
* Functions:  long NuRand(long *plSeed)
*
* Author/Date: Rob Zopf, 1996.
*
*******************************************************************************
*
* Modifications: 
*
* Comments:      
*
* Concerns:   The initial seed must be larger than 0 
*
* $Header:   G:/pvcsproj/voxlib.prj/nurand.c_v   1.6   10 Mar 1998 16:29:32   weiwang  $
******************************************************************************/

#include <stdlib.h>
#include <assert.h>
#include "vLibMath.h"

#include "xvocver.h"

/******************************************************************************
*
* Function:  long NuRand(long *plSeed)
*
* Action:    Generate a long random number (31-bit long) from lSeed.
*
* Input:     plSeed -- address to the input seed for random number generator.
*
* Output:    plSeed -- address to the updated seed.
*
* Globals:   none
*
* Return:    New random number in long (31 bit)
*
*******************************************************************************
*
* Implementation/Detailed Description:
*     The sequence used is x' = (A*x) mod M,  (A = 16807, M = 2^31 - 1).  
*     This is the "minimal standard" generator from CACM Oct 1988, p. 1192.
*     The implementation is based on an algorithm using 2 31-bit registers 
*     to represent the product (A*x), from CACM Jan 1990, p. 87.           
*
* References:
*******************************************************************************
*
* Modifications:
*
* Comments:    
*
* Concerns/TBD:  The initial seed must be larger than 0 
******************************************************************************/

long NuRand(long *plSeed)
{
  const long A = 16807;
  const unsigned long LONG_MASK = 0xFFFFFFFFL;
  unsigned long x0 = ((*plSeed<< 16)&LONG_MASK)>>16;  /* 16 LSBs OF SEED  */
  unsigned long x1 = *plSeed >> 16;                  /* 16 MSBs OF SEED   */
  unsigned long p, q;                                /* MSW, LSW OF PRODUCT */

  assert(plSeed != NULL);
  assert(*plSeed != 0);

  /*---------------------------------------------------------------------*/
  /* COMPUTE THE PRODUCT (A * lSeed) USING CROSS MULTIPLICATION OF        */
  /* 16-BIT HALVES OF THE INPUT VALUES.  THE RESULT IS REPRESENTED AS 2  */
  /* 31-BIT VALUES.  SINCE 'A' FITS IN 15 BITS, ITS UPPER HALF CAN BE    */
  /* DISREGARDED.  USING THE NOTATION val[m::n] TO MEAN "BITS n THROUGH  */
  /* m OF val", THE PRODUCT IS COMPUTED AS:                              */
  /*   q = (A * x)[0::30]  = ((A * x1)[0::14] << 16) + (A * x0)[0::30]   */
  /*   p = (A * x)[31::60] =  (A * x1)[15::30]       + (A * x0)[31]  + C */
  /* WHERE C = q[31] (CARRY BIT FROM q).  NOTE THAT BECAUSE A < 2^15,    */
  /* (A * x0)[31] IS ALWAYS 0.                                           */
  /*---------------------------------------------------------------------*/
  q = ((((A * x1) << 17) & LONG_MASK) >> 1) + (A * x0);
  q = q & LONG_MASK;
  p = ((A * x1) >> 15) + (q >> 31);
  p = p & LONG_MASK;
  q = ((q << 1) & LONG_MASK) >> 1;             /* CLEAR CARRY */

  /*---------------------------------------------------------------------*/
  /* IF (p + q) < 2^31, RESULT IS (p + q).  OTHERWISE, RESULT IS         */
  /* (p + q) - 2^31 + 1.                                                 */
  /*---------------------------------------------------------------------*/
  p += q;
  p = p & LONG_MASK;

  /* ADD CARRY, THEN CLEAR IT */
  *plSeed = (((p + (p >> 31)) << 1) & LONG_MASK) >> 1;

  return *plSeed;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\nsptimer.c ===
/*******************************************************************************
*                        Voxware Proprietary Material                          *
*                        Copyright 1996, Voxware, Inc                          *
*                            All Rights Reserved                               *
*                                                                              *
*                       DISTRIBUTION PROHIBITED without                        *
*                      written authorization from Voxware                      *
*******************************************************************************/

/*******************************************************************************
* Filename:   NspTimer.c                                                                    
*                                                                              
* Purpose:    High resolution((1 microsecond)Win32 Timer                                                                
*                                                                              
* Functions:  
*
*           TSTAPI(void)   tstTimerStart(int No)   : start Timer #No
*
*           TSTAPI(void)   tstTimerStop(int No)    : Stop  Timer #No
*
*           TSTAPI(double) tstTimerClock(int No)   : return Timer #No Counts 
*                                                    in clock ticks
*
*           TSTAPI(double) tstTimerSec(int No)     : return Timer #No Counts
*                                                    in second
*
*           TSTAPI(double) tstTimerUSec(int No)    : return Timer #No Counts 
*                                                    in micro-second
*
*                                                                         
* Author/Date: Xiangdong Fu
*              (originated from Intel NSP Lib)  1/6/97                                                              
********************************************************************************
* Modifications:
*                   
* Comments:      Up to ten timers is available for use(0-9)
*                Users can increase the available timer by 
*                increase TST_MAX_TIMER
*                
*                
*
*
* Concerns:
*
*******************************************************************************/

#ifdef WIN32

#include <stdlib.h>
#include <string.h>
#include <stdarg.h>
#include <time.h>
#include <windows.h>

#include "NspTimer.h"

#include "xvocver.h"


/*****************************************************************/
/* --- Timer relatied routines ----------------------------------*/
/*****************************************************************/

/* #define DBG_PRINT(s) printf s*/
#define DBG_PRINT(s)

#define USE_WIN32_TIMER
//#define HIGH_PRIORITY
#define REAL_TIME_PRIORITY

/*---------------------------------------------------------------*/
/* --- Define the timer structure -------------------------------*/
/*---------------------------------------------------------------*/
/* Timers [0..TST_MAX_TIMER], where               */
/*        the first half are High Priority Timers */
#define TST_MAX_TIMER		9
#define TST_MIN_HP_TIMER	0
#define TST_MAX_HP_TIMER	TST_MAX_TIMER/2

#define TIMER_STOPPED 0
#define TIMER_RUNNING 1

typedef struct _Timer_t {
   int state;
   double total;
   double start;
} Timer_t;

static Timer_t     Timer[TST_MAX_TIMER+1]={{0}};
static int         HighPriorityTimerCount=0;

/*---------------------------------------------------------------*/
/* --- Decide if priority will raise priority while looping -----*/
/*---------------------------------------------------------------*/

#ifdef HIGH_PRIORITY 
static void tstHighPriority(void) {
   SetThreadPriority(GetCurrentThread(),THREAD_PRIORITY_TIME_CRITICAL);
}
static void tstNormalPriority(void) {
   SetThreadPriority(GetCurrentThread(),THREAD_PRIORITY_NORMAL);
}
#elif defined REAL_TIME_PRIORITY
static void tstHighPriority(void) {
   SetPriorityClass(GetCurrentProcess(),REALTIME_PRIORITY_CLASS);
   SetThreadPriority(GetCurrentThread(),THREAD_PRIORITY_TIME_CRITICAL);
}
static void tstNormalPriority(void) {
   SetPriorityClass(GetCurrentProcess(),NORMAL_PRIORITY_CLASS);
   SetThreadPriority(GetCurrentThread(),THREAD_PRIORITY_NORMAL);
}

#else
#define tstHighPriority()
#define tstNormalPriority()
#endif

/*---------------------------------------------------------------*/
/* --- Private Timing routines : use Win32 high performance -----*/
/* ---    Counter or  use clock function    ---------------------*/
/*---------------------------------------------------------------*/

#ifdef USE_WIN32_TIMER

static int first_time = TRUE;
static double tick_frequency;
static LARGE_INTEGER tick_counts = {{0,0}};

static double getCounter(void)
{
   if (!QueryPerformanceCounter(&tick_counts)) 
      return (double)clock();
   return ((double)tick_counts.u.HighPart * 65536.0 * 65536.0 +
      (double)tick_counts.u.LowPart);
}

static double getFrequency(void)
{
   LARGE_INTEGER cps;
   if (!first_time) return tick_frequency;

   if (!QueryPerformanceFrequency(&cps))  {
      tick_frequency = (double)CLOCKS_PER_SEC;
   } else {
      tick_frequency = (double)cps.u.HighPart * 65536.0 * 65536.0 +
         (double)cps.u.LowPart;
   }
   first_time = FALSE;
   return tick_frequency;
}
#else /* use clock() function */
#define getCounter(ptr)		(double)clock()
#define getFrequency(ptr)	(double)CLOCKS_PER_SEC
#endif

/*****************************************************************/
/* ---      API Timer routines ----------------------------------*/
/*****************************************************************/

TSTAPI(void) tstTimerStart(int No)
{
   if ((No<0) || (No>TST_MAX_TIMER) || 
      (Timer[No].state ==TIMER_RUNNING)) return;

   /* Priority Timers will raise priority */
   if ((No>=TST_MIN_HP_TIMER) && (No<=TST_MAX_HP_TIMER)) {
      if (HighPriorityTimerCount==0) tstHighPriority();
      HighPriorityTimerCount++;
   }

   Timer[No].state=TIMER_RUNNING;
   Timer[No].total=0.0;
   Timer[No].start=getCounter();
   DBG_PRINT(("\nIn TimerStart/start: %10.2f ", Timer[No].start));
   return;
}

TSTAPI(void) tstTimerStop(int No)
{
   double tempClock = getCounter();
   DBG_PRINT(("\nIn TimerStop/stop : %10.2f ", tempClock));

   if ((No<0) || (No>TST_MAX_TIMER) || 
      (Timer[No].state==TIMER_STOPPED)) return;

   /* Priority Timers will raise priority */
   if ((No>=TST_MIN_HP_TIMER) && (No<=TST_MAX_HP_TIMER)) {
      HighPriorityTimerCount--;
      if (HighPriorityTimerCount==0) tstNormalPriority();
   }

   Timer[No].state=TIMER_STOPPED;
   Timer[No].total=Timer[No].total+tempClock-Timer[No].start;
   DBG_PRINT(("\nIn TimerStop/total: %10.2f ", Timer[No].total));
   return;
}

TSTAPI(double) tstTimerClock(int No)
{
   double tempClock = getCounter();

   if ((No<0) || (No>TST_MAX_TIMER)) return 0;
   if (Timer[No].state==TIMER_STOPPED)
      return Timer[No].total;
   else
      return Timer[No].total-Timer[No].start+tempClock;
}

TSTAPI(double) tstTimerSec(int No)
{
   return tstTimerClock(No) / getFrequency();
}

TSTAPI(double) tstTimerUSec(int No)
{
   return tstTimerClock(No) / getFrequency() * USECS;
}

/*****************************************************************/
/* --- End of timer routines ------------------------------------*/
/*****************************************************************/
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\oladd.c ===
/*******************************************************************************
*                        Voxware Proprietary Material                          *
*                        Copyright 1996, Voxware, Inc                          *
*                            All Rights Reserved                               *
*                                                                              *
*                       DISTRIBUTION PROHIBITED without                        *
*                      written authorization from Voxware                      *
*******************************************************************************/
 
/*******************************************************************************
* Filename:       OlAdd.c
*
* Purpose:        a generalized trapezoidal overlap-add routine.
*
* Functions:      OlAdd()
*
* Author/Date:    Rob Zopf 11/7/96
********************************************************************************
* $Header:   /export/phobos/pvcs/pvcsproj/voxlib.prj/oladd.c_v   1.11   25 Mar 1998 14:31:20   weiwang  $
*******************************************************************************/
#include <stdlib.h>
#include <assert.h>
#include <math.h>
#include <string.h>

#include "vLibVec.h"

#include "xvocver.h"

/*******************************************************************************
*
* Function:  OlAdd()
*
* Action:    a generalized trapezoidal overlap-add routine.
*
* Input:     const float *pfFadeOutBuf -> fade-out input buffer
*            const float *pfFadeInBuf  -> fade-in input buffer
*            int          iOverlapLen  -> length of overlap
*            int          iFrameLen    -> length of frame
*
* Output:    float       *pfOutBuf     -> output buffer
*
* Globals:   none
*
* Return:    void
********************************************************************************
*
*           iFrameLen
* /-------------------------------------\
*               iOverlapLen
*           /-----------------\
*
* ----------\__             __/
*              \__       __/
*                 \__ __/
*                  __X__
*               __/     \__
*            __/           \__
*           /                 \----------
*
*   pfFadeOutBuf
* |---------------------------|
*
*             pfFadeInBuf
*           |---------------------------|
*
********************************************************************************
*
* Modifications: Removed some variables and changed type (short) in call
*                to type (int). Bod Dunn 7/24/97.
*
* Comments: IMPORTANT: this routine ACCUMULATES into the output buffer.  If
*                      needed, the output buffer should be set to zero before
*                      calling this routine.
*
* Concerns/TBD:
*******************************************************************************/

void OlAdd ( const float *pfFadeOutBuf,
             const float *pfFadeInBuf,
             int         iOverlapLen,
             int         iFrameLen,
             float       *pfOutBuf
           )
{
   int      i;
   int      iNonOverlap;
   float    fInStep;
   float    fOutStep;
   float    fStep;

   assert( pfFadeOutBuf != NULL);
   assert( pfFadeInBuf != NULL);
   assert( pfOutBuf != NULL);
   assert( iOverlapLen >= 0 );
   assert( iFrameLen >= iOverlapLen );

   iNonOverlap = iFrameLen-iOverlapLen;

   /*--------------------------------------------------------
     If the non-overlap region has an odd length,
       there is an extra sample to add in.
   --------------------------------------------------------*/
   if (iNonOverlap&1)
      *pfOutBuf++ += *pfFadeOutBuf++;

   iNonOverlap >>= 1; /* process half now, half later */

   /*-------------------------------------------------------
     Accumulate non-overlap section into the output buffer 
   -------------------------------------------------------*/
   for (i=iNonOverlap; i>0; i--)
      *pfOutBuf++ += *pfFadeOutBuf++;

   /*-------------------------------------------------------
     Now process the overlap section
   -------------------------------------------------------*/
   if (iOverlapLen>0)
      fStep = 1.0F/((float)(iOverlapLen));
   else
      fStep = 0.0F;

   fInStep  = 0.0F;
   fOutStep = 1.0F;


   for (i=iOverlapLen; i>0; i--, fInStep+=fStep, fOutStep-=fStep)
   {
      *pfOutBuf++ += (*pfFadeOutBuf++ * fOutStep) + 
                     (*pfFadeInBuf++  * fInStep );
   }

   /*--------------------------------------------------------
     Finally, accumulate non-overlap section into end of
     the output buffer ...
   --------------------------------------------------------*/
   for (i=iNonOverlap; i>0; i--)
      *pfOutBuf++ += *pfFadeInBuf++;

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\outbuf.h ===
/*******************************************************************************
*                        Voxware Proprietary Material                          *
*                        Copyright 1996, Voxware, Inc                          *
*                            All Rights Reserved                               *
*                                                                              *
*                       DISTRIBUTION PROHIBITED without                        *
*                      written authorization from Voxware                      *
*******************************************************************************/

/*******************************************************************************
* Filename:       OutBuf.h                                                          
*                                                                              
* Purpose:        Prepare all frame parameters for the current frame or subframe                                                            
*                                                                              
* Author/Date:    Rob Zopf  03/01/96                                                             
********************************************************************************
* $Header:   /export/phobos/pvcs/r_and_d/archives/realtime/decode/OutBuf.h_v   1.0   26 Jan 1998 10:52:08   johnp  $                                                                     
*******************************************************************************/
#ifndef OUTBUF_H
#define OUTBUF_H

typedef struct tagOutputBuffer
{
   short                        *outBufferB1;           /* double-buffered output 1 */
   short                        *outBufferB2;           /* double-buffered output 2 */
   short                        dataB;                  /* amount of data currently buffered */
   short                        *outBufferB;            /* pointer to current buffer (B1 or B2 */
   short                        dataAstart;             /* start of left over data in A */
   short                        dataAend;               /* end of left over data in A */
   short                        writeBuffer;            /* indicates if there is a full buffer */

} OutputBuffer;

unsigned short VoxInitOutputBuffers(void **OutputBuffer_mblk);

unsigned short VoxFreeOutputBuffers(void **OutputBuffer_mblk);

unsigned short VoxOutputManager(void *OutputBuffer_mblk, int outLen, float *InBuf);

#endif /* OUTBUF_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\outbuf.c ===
/*******************************************************************************
*                        Voxware Proprietary Material                          *
*                        Copyright 1996, Voxware, Inc                          *
*                            All Rights Reserved                               *
*                                                                              *
*                       DISTRIBUTION PROHIBITED without                        *
*                      written authorization from Voxware                      *
*******************************************************************************/

/*******************************************************************************
* Filename:       OutBuf.c                                                           
*                                                                              
* Purpose:        Prepare all frame parameters for the current frame or subframe                                                             
*                                                                              
* Functions:      VOXErr VoxInitOutputBuffers(OutputBuffer *myOutputBuffer_mblk);
*                 VOXErr VoxFreeOutputBuffers(OutputBuffer *myOutputBuffer_mblk);
*                 VOXErr VoxOutputManager(OutputBuffer *myOutputBuffer_mblk, 
*                                         void *mySubFrameParam_mblk);                                                             
*                                                                              
* Author/Date:    Rob Zopf 03/01/96                                                            
********************************************************************************
* Modifications:Ilan Berci/ 10/96 Removed global dependencies
*                                 Modularized code segments (Encapsulation)
*                                 Removed scope changes
*                                 Changed error code procedure
*                                 Removed useless code segments
*                                 General optimization                                                                 
*                                                                              
* Comments:                                                                    
* 
* Concerns:
*
* $Header:   /export/phobos/pvcs/r_and_d/archives/realtime/decode/OutBuf.c_v   1.0   26 Jan 1998 10:52:06   johnp  $
*******************************************************************************/
#include <stdlib.h>
#include <math.h>
#include <string.h>
#include <assert.h>

#include "model.h"
#include "VoxMem.h"

#include "param.h"

#include "OutBuf.h"

#include "xvocver.h"

#ifdef _WIN64
#undef WIN32
#endif

/*******************************************************************************
* Function:      VOXErr VoxOutputManager(OutputBuffer *myOutputBuffer_mblk, 
*                                        void *SubFrameParam_mblk)
*
* Action:        The basic idea involves the desire to output frame buffers of
*                180 samples, no matter what the warp factor is, and also to minimize
*                the amount of RAM necessary.
*
*                - there are 3 buffers used :
*
*                      1) outBufferA - used to store the current WHOLE synthesized 
*                                      frame or subframe
*                      2) outBufferB1- 1 of 2 buffers for a double-buffered output
*                      3) outBufferB2- 2 of 2 buffers for a double-buffered output
*
*                ALGORITHM
*                
*                - synthesize current frame into A (done in LPCsynthesis)
*                - if current frame does not overflow B
*                       - append all of A to B
*                - else
*                       - append as much of A to B in order to fill B
*                       - switch output buffers
*                       - wait for DSP (if necessary)
*                       - copy remaining part of A to start of B
*
* Input:
*
* Output:
*
* Globals:        none
*
* Return:		   VOXErr : Voxware return code
********************************************************************************
* Implementation/Detailed Description:
*
* References:
********************************************************************************
* Modifications:
*
* Comments:
*
* Concerns/TBD:
*******************************************************************************/
unsigned short VoxOutputManager(void *OutputBuffer_mblk, int outFrameLEN, float *InBuf)
{
   OutputBuffer *myOutputBuffer_mblk=(OutputBuffer *)OutputBuffer_mblk;

   short		*outBufB1 = myOutputBuffer_mblk->outBufferB1;
   short		*outBufB2 = myOutputBuffer_mblk->outBufferB2;
   short		*outBufB = myOutputBuffer_mblk->outBufferB;
   int		dataB = myOutputBuffer_mblk->dataB;
   short		dataAstart, dataAend;
   int      i;
   short    *pOutBufB;
   float    *pInBuf;

   /* check if buffer B will be overflowed if the current frame is copied to it */
   if ((outFrameLEN+dataB) < FRAME_LEN)
   { 
      pOutBufB = outBufB + dataB;
#ifndef WIN32
      for (i=0; i<outFrameLEN; i++)
         pOutBufB[i] = (short) InBuf[i];
#else
      _asm
      {
         push ecx
         push eax

         push ebx
         mov ecx, outFrameLEN

         mov eax, pOutBufB
         mov ebx, InBuf

l1:      fld dword ptr [ebx]
         
         fistp word ptr [eax]
         
         add eax, 2
         add ebx, 4
         
         dec ecx
         
         jnz l1
         
         pop ebx
         pop eax

         pop ecx
      }
#endif
      myOutputBuffer_mblk->dataB = dataB + outFrameLEN;
      myOutputBuffer_mblk->writeBuffer = 0;
   }
   else
   {
   /* Copy only part of buffer A */
      pOutBufB = outBufB + dataB;
#ifndef WIN32
      for (i=0; i<(FRAME_LEN-dataB); i++)
         pOutBufB[i] = (short) InBuf[i];
#else
      _asm
      {
         push ecx
         push eax

         push ebx
         mov ecx, FRAME_LEN

         mov eax, pOutBufB
         sub ecx, dataB

         mov ebx, InBuf
         jle l2

l3:      fld dword ptr [ebx]
         
         fistp word ptr [eax]
         
         add eax, 2
         add ebx, 4
         
         dec ecx
         jnz l3
         
l2:      pop ebx
         pop eax

         pop ecx
      }

#endif

      dataAstart = FRAME_LEN-dataB;
      dataAend = (short) outFrameLEN;    

   /* switch data buffers */
      if (outBufB==outBufB1)
      {
         outBufB = myOutputBuffer_mblk->outBufferB = outBufB2;
         myOutputBuffer_mblk->writeBuffer = 1;
      }
      else if (outBufB==outBufB2)
      {
         outBufB = myOutputBuffer_mblk->outBufferB = outBufB1;
         myOutputBuffer_mblk->writeBuffer = 2;
      }
      else {
         return 1;
      }

   /* Copy remaining part of buffer A to start of new Buffer B */
      if (dataAstart < FRAME_LEN)
      {
         pInBuf = InBuf + dataAstart;
         for (i=0; i<(dataAend-dataAstart); i++)
         {
            outBufB[i] = (short) pInBuf[i];
         }
      }
      myOutputBuffer_mblk->dataB = dataAend-dataAstart;
   } 
    
   return 0; 
}

/*******************************************************************************
* Function:       VOXErr VoxInitOutputBuffers(OutputBuffer *myOutputBuffer_mblk)
*
* Action:
*
* Input:
*
* Output:
*
* Globals:        none
*
* Return:		  VOXErr : Voxware return code
********************************************************************************
* Implementation/Detailed Description:
*
* References:
********************************************************************************
* Modifications:
*
* Comments:
*
* Concerns/TBD:
*******************************************************************************/
unsigned short VoxInitOutputBuffers(void **OutputBuffer_mblk)
{
   OutputBuffer *myOutputBuffer_mblk;

   if(VOX_MEM_INIT(myOutputBuffer_mblk=*OutputBuffer_mblk,1,sizeof(OutputBuffer))) 
      return 1;

   if(VOX_MEM_INIT(myOutputBuffer_mblk->outBufferB1,FRAME_LEN,sizeof(short))) 
      return 1;

   if(VOX_MEM_INIT(myOutputBuffer_mblk->outBufferB2,FRAME_LEN,sizeof(short))) 
      return 1;

   myOutputBuffer_mblk->outBufferB = myOutputBuffer_mblk->outBufferB1;

   return 0;
}

/*******************************************************************************
* Function:       VOXErr VoxFreeOutputBuffers(OutputBuffer *myOutputBuffer_mblk)
*
* Action:
*
* Input:
*
* Output:
*
* Globals:        none
*
* Return:		   VOXErr : Voxware return code
********************************************************************************
* Implementation/Detailed Description:
*
* References:
********************************************************************************
* Modifications:
*
* Comments:
*
* Concerns/TBD:
*******************************************************************************/ 
unsigned short VoxFreeOutputBuffers(void **OutputBuffer_mblk)
{
   OutputBuffer *myOutputBuffer_mblk=(OutputBuffer *)*OutputBuffer_mblk;

   if(*OutputBuffer_mblk) {
      VOX_MEM_FREE(myOutputBuffer_mblk->outBufferB1);
      VOX_MEM_FREE(myOutputBuffer_mblk->outBufferB2);

      VOX_MEM_FREE(*OutputBuffer_mblk);
   }
   return 0;
}

#ifdef _WIN64
#define WIN32
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\outbufsc.c ===
/******************************************************************************
*                        Voxware Proprietary Material                         *
*                        Copyright 1996, Voxware, Inc                         *
*                            All Rights Reserved                              *
*                                                                             *
*                       DISTRIBUTION PROHIBITED without                       *
*                      written authorization from Voxware                     *
******************************************************************************/

/******************************************************************************
* Filename:   OutBufSC.c
*                                                                              
* Purpose:    Output speech to PCM buffer
*                                                                              
* Functions:  PreOutputManagerSC(), PostOutputManagerSC()
*
* Author/Date:   Wei Wang, 2/18/98
*******************************************************************************
* Modifications: 
*            
* Comments: Only for half frame synthesizer
* 
* Concerns:
*
* $Header:   /export/phobos/pvcs/r_and_d/archives/scaleable/decode/OutBufSC.c_v   1.7   14 Apr 1998 10:14:16   weiwang  $
******************************************************************************/

#include <stdlib.h>
#include <string.h>
#include <assert.h>
#include "codec.h"
#include "vLibMath.h"
#include "OutBufSC.h"

#include "xvocver.h"

/******************************************************************************
* Function:   void PreOutputManagerSC()
*
* Action: output pfSaveBuffer to psPCMBuffer. Then pvSaveBuffer
*         can be reused later.
*
* Input:      pfSaveBuffer -- samples from previous frame
*             iSaveSamples -- number of samples in pfSaveBuffer
*             psPCMBuffer --  pointer to output speech buffer
*
* Output:     psPCMBuffer -- output speech
*
* Globals:    none
*
* Return:     none
*******************************************************************************
* Implementation/Detailed Description:
*
* References:
*******************************************************************************
* Modifications:
*
* Comments:   iSaveSamples can only be 0 or HALF_FRAME_LENGTH_SC.
*
* Concerns/TBD:
******************************************************************************/

void PreOutputManagerSC(const float *pfSaveBuffer, int iSaveSamples, 
                        short *psPCMBuffer)
{
  int i;
  int iTemp; 
  float ftmp;

  assert(iSaveSamples <= HALF_FRAME_LENGTH_SC);
  assert((pfSaveBuffer != NULL) && (psPCMBuffer != NULL));

  /*--------------------------------------------------
    Copy pfSaveBuffer to psPCMBuffer.
    --------------------------------------------------*/
  for (i = 0; i < iSaveSamples; i++) {
    ftmp = pfSaveBuffer[i];
    VoxROUND2(ftmp, iTemp);
    psPCMBuffer[i] = (short)iTemp;
  }
}


/******************************************************************************
* Function:   void PostOutputManagerSC()
*
* Action:     Output speech to PCM buffer and update pfSaveBuffer.
*
* Input:      *pfSaveBuffer -- synthesized speech buffer
*             *piSaveSamples -- number of saved samples
*             iSynSamples -- number of synthesized speech
*             *psPCMBuffer -- pointer to output speech buffer
*
* Output:     *pfSaveBuffer -- saved samples for next frame
*             *piSaveSamples -- updated number of saved samples
*             *psPCMBuffer -- output PCM buffer
*             *pwPCMsamples -- number of samples in psPCMBuffer 
*                              (either 0 or FRAME_LENGTH_SC).
*
* Globals:    none
*
* Return:     none
*******************************************************************************
* Implementation/Detailed Description:
*
* References:
*******************************************************************************
* Modifications:
*
* Comments: iSaveSamples is 0 or HALF_FRAME_LENGTH_SC (80) and iSynSamples is
*           0, HALF_FRAME_LENGTH_SC (80) or FRAME_LENGTH_SC (160).
*
* Concerns/TBD:  
******************************************************************************/

void PostOutputManagerSC( float          *pfSaveBuffer, 
                          int            *piSaveSamples, 
                          int             iSynSamples,
                          short          *psPCMBuffer, 
                          unsigned short *pwPCMsamples
                        )

{
  int i;
  int iSaveSamples = *piSaveSamples;
  int iWriteSamples;
  short *psTemp;
  int iTemp;
  float ftmp;

  assert(iSaveSamples <= HALF_FRAME_LENGTH_SC);
  assert((pfSaveBuffer!=NULL)&&(psPCMBuffer!=NULL)&&(pwPCMsamples!=NULL));

  /*----------------------------------------------------------------------
    Case 1: When sum of iSaveSamples and iSynSamples is less than 
            FRAME_LENGTH_SC, write_flag is set to 0. 
            Then speech should not output to PCMBuffer. 
            Such as: iSaveSamples = 0,  iSynSamples = 0 or 80.
                     iSaveSamples = 80, iSynSamples = 0
   ----------------------------------------------------------------------*/
   if ((iSaveSamples+iSynSamples) < FRAME_LENGTH_SC) 
     {
       *pwPCMsamples = 0;

       /*------------------------------------------------------------
         Since pfSynBuffer shares with pfSaveBuffer, we need to make 
         sure that pfSaveBuffer won't share with other memory. 
         Otherwise, speech in PCMBuffer need be re-written
         to pfSaveBuffer if iSaveSamples is larger than 0.

         Such as iSaveSamples = 80, iSynSamples = 0;
        ------------------------------------------------------------*/
       for (i = 0; i < iSaveSamples; i++)
          pfSaveBuffer[i] = (float)psPCMBuffer[i];

       if (iSynSamples > iSaveSamples)
         iSaveSamples = iSynSamples;
     }
   else
     {
        /*----------------------------------------------------------------------
         Case 2: If sum of iSaveSamples and iSynSamples is larger or equal to 
             FRAME_LENGTH_SC, one frame of speech will be output to PCMBuffer.
             such as: iSaveSamples = 80, iSynSamples = 80 or 160,
                      iSaveSamples = 0, iSynSamples = 160.
         ---------------------------------------------------------------------*/
        *pwPCMsamples = FRAME_LENGTH_SC;

        psTemp = &(psPCMBuffer[iSaveSamples]);    
        iWriteSamples = FRAME_LENGTH_SC - iSaveSamples;
        for (i = 0; i < iWriteSamples; i++) {
          ftmp = pfSaveBuffer[i];
          VoxROUND2(ftmp, iTemp);
          psTemp[i] = (short)iTemp;
	}


        /*------------------------------------------------------------
          If sum of iSaveSamples and iSynSamples is larger than 
          FRAME_LENGTH_SC, such as iSaveSamples = 80, iSynSamples = 160, 
          the extra 80 samples in pfSaveBuffer need to be shuffled to 
          the beginning.
         ------------------------------------------------------------*/
        iSaveSamples = iSynSamples - iWriteSamples;
        memcpy(pfSaveBuffer, &(pfSaveBuffer[iWriteSamples]), 
               iSaveSamples*sizeof(float));
     }

    *piSaveSamples = iSaveSamples;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\overadd.c ===
/******************************************************************************
*                        Voxware Proprietary Material
*                        Copyright 1996, Voxware, Inc
*                            All Rights Reserved
*
*                       DISTRIBUTION PROHIBITED without
*                      written authorization from Voxware
******************************************************************************/
 
/******************************************************************************
*
* Filename:      OverAdd.c
*
* Purpose:       Overlap/Add harmonics synthesizer using Fast Harmonic
*                  Transform and triangular window.
*
* Functions:     FHTOverlapAdd()
*
* Author/Date:   Bob Dunn 3/97
*******************************************************************************
*
* Modifications:
*
* Comments:
*
* Concerns:
*
* $Header:   /export/phobos/pvcs/r_and_d/archives/scaleable/decode/OverAdd.c_v   1.16   23 Apr 1998 12:50:40   bobd  $
*
******************************************************************************/

#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <limits.h>
#include <assert.h>

#include "vLibFilt.h"
#include "vLibTran.h"
#include "vLibVec.h"
#include "vLibMath.h"

#include "VoxMem.h"
#include "codec.h"
#include "trigSC.h"
#include "SumCos.h"
#include "FftSmCos.h"

#include "OverAdd.h"

#include "xvocver.h"

/*-------------------------------------------------------------
  Define synthesis types
-------------------------------------------------------------*/
#define FHT_SYNTHESIS 0
#define FFT_SYNTHESIS 1
#define COS_SYNTHESIS 2

/*-------------------------------------------------------------
  Select method of sine wave synthesis
-------------------------------------------------------------*/
#define SYNTHESIS_TYPE FHT_SYNTHESIS

/*-------------------------------------------------------------
  constants 
-------------------------------------------------------------*/
#define CLIP_LEVEL  (float)SHRT_MAX
 
/*-------------------------------------------------------------
  static functions
-------------------------------------------------------------*/
static void ClipOverflows( float *pfAmp, int iHarm);

#if (SYNTHESIS_TYPE==FHT_SYNTHESIS)

static void GetPhaseIndices( float *pfPhase, int *piPhaseIndex, int iHarm );

static void FHTSumCos( STACK_R
                float   fPitchDFT,
                float  *pfAmps,
                float  *pfPhase,
                int     iHarm,
                int     iLength,
                float  *pfWaveform
              );

/*-------------------------------------------------------------
  FHT weights
-------------------------------------------------------------*/
const static float fFHTWeights[] = {
#include "FHTW128.h"     
};

/*-------------------------------------------------------------
  external trig tables
-------------------------------------------------------------*/
extern const float *sinTBL_32;
extern const float *cosTBL_32;
extern const float fRadiansToIndex;

#endif /* (SYNTHESIS_TYPE==FHT_SYNTHESIS) */
 
/*******************************************************************************
*
* Function:  FHTOverlapAdd()
*
* Action:    Overlap/Add harmonics synthesizer using Fast Harmonic
*                  Transform and triangular window.
*
* Input:     float *pfAmps             -> harmonics amplitudes
*            float *pfPhase            -> harmonics phases
*            float  fPitchDFT          -> pitch in DFT samples
*            int    iHarm              -> number of harmonics
*            int    iSynSubFrameLength -> number of samples to synthesize
*            float *pfWaveform_1       -> previous waverform for overlap
*
* Output:    float *pfOutputBuffer     -> output waveform
*            float *pfWaveform_1        -> waverform for next overlap
*
* Globals:   none
*
* Return:    void
********************************************************************************
*
* Modifications:
*
* Comments:
*
* Concerns/TBD:
*******************************************************************************/

void FHTOverlapAdd( STACK_R 
                    float *pfAmps, 
                    float  fPitchDFT, 
                    float *pfPhase, 
                    int    iHarm, 
                    int    iSynSubFrameLength, 
                    float *pfOutputBuffer,
                    float *pfWaveform_1
                  )
{
   int   iTotalSynLength;        /* overlap/add window length                 */
   STACK_INIT
   float pfWaveform[FRAME_LENGTH_SC]; 
   STACK_INIT_END

   STACK_ATTACH(float*,pfWaveform)

   STACK_START

   assert((pfAmps!=NULL) && (pfPhase!=NULL));
   assert((pfOutputBuffer!=NULL) && (pfWaveform_1!=NULL));

   iTotalSynLength = iSynSubFrameLength<<1;

   /*--------------------------------------------------
     Clear waveform array
   --------------------------------------------------*/
   memset(pfWaveform, 0, iTotalSynLength*sizeof(float) );

   /*---------------------------------------------------
     clip overflows by rescaling the harmonic amplitudes
   ---------------------------------------------------*/
   ClipOverflows(pfAmps, iHarm);


#if (SYNTHESIS_TYPE==FHT_SYNTHESIS)
   /*---------------------------------------------------
     Sum of cosines using Fast Harmonic Transform
   ---------------------------------------------------*/
   FHTSumCos(STACK_S fPitchDFT, pfAmps, pfPhase, iHarm, iTotalSynLength, 
                     pfWaveform);

#endif

#if (SYNTHESIS_TYPE==FFT_SYNTHESIS)
   /*---------------------------------------------------
     Sum of cosines using FFT
   ---------------------------------------------------*/
   FftSumCos(STACK_S fPitchDFT, pfAmps, pfPhase, iHarm, iTotalSynLength, 
                     pfWaveform);

#endif

#if (SYNTHESIS_TYPE==COS_SYNTHESIS)
   /*---------------------------------------------------
     Sum of cosines
   ---------------------------------------------------*/
   SumCos(fPitchDFT, pfAmps, pfPhase, iHarm, iTotalSynLength, pfWaveform);

#endif

   /*---------------------------------------------------
     clear temporary output buffer
   ---------------------------------------------------*/
   memset( pfOutputBuffer, 0, iSynSubFrameLength*sizeof(float) );
 
   /*---------------------------------------------------
     overlap and add waveforms
   ---------------------------------------------------*/
   OlAdd ( pfWaveform_1, pfWaveform, (short)iSynSubFrameLength,
           (short) iSynSubFrameLength, pfOutputBuffer);
 
   /*---------------------------------------------------
     Save half of the waveform for next time
   ---------------------------------------------------*/
   memcpy( pfWaveform_1, pfWaveform+iSynSubFrameLength,
           iSynSubFrameLength*sizeof(float) );

   STACK_END

   return;
}

#if (SYNTHESIS_TYPE==FHT_SYNTHESIS)
/*******************************************************************************
*
* Function:  FHTSumCos()
*
* Action:    Sum of cosines using Fast Harmonic Transform
*
* Input:     fPitchDFT  --> pitch in DFT samples
*            pfAmps     --> cosine amplitudes
*            pfPhase    --> cosine phase (in radians)
*            iHarm      --> number of harmonics
*            iLength    --> number of samples to synthesize
*
* Output:    pfOutBuf   --> sum of cosines (with length iLength)
*
* Globals:   none
*
* Return:    None
********************************************************************************
*
* Modifications:
*
* Comments:
*
* Concerns/TBD:
*******************************************************************************/

void FHTSumCos( STACK_R 
                float   fPitchDFT, 
                float  *pfAmps, 
                float  *pfPhase, 
                int     iHarm, 
                int     iLength,
                float  *pfWaveform
              )
{
   float fNormFreq;              /* normalized pitch frequency                */
   float fNormPhase;
   float fResampRate;
   STACK_INIT
   float pfPitchCycle[FHT_EXP_SIZE+PP_NUM_SAMPLES];
   int   piPhaseIndex[MAXHARM];
   STACK_INIT_END
 
   STACK_ATTACH(float*,pfPitchCycle)
   STACK_ATTACH(int*,piPhaseIndex)
 
   STACK_START

   /*--------------------------------------------------
     Get phase indices
   --------------------------------------------------*/
   GetPhaseIndices( pfPhase, piPhaseIndex, iHarm );
 
   /*--------------------------------------------------
      Create the pitch epoch
   --------------------------------------------------*/
   VoxFHTkrnl( pfAmps, piPhaseIndex, iHarm, pfPitchCycle+PP_DELAY,
               FHT_EXP_SHIFT, fFHTWeights, sinTBL_32, cosTBL_32);
 
   /*--------------------------------------------------
     Interpolate the pitch epoch to generate the
       synthesized sum of sine waves.
   --------------------------------------------------*/
   fNormFreq   = fPitchDFT*INV_NFFT;
   fResampRate = (float)FHT_EXP_SIZE*fNormFreq;
   fNormPhase  = (float)(-(iLength>>1))*fNormFreq;
 
   PolyCycleIntp(pfWaveform, iLength, pfPitchCycle+PP_DELAY,
                  FHT_EXP_SHIFT, fResampRate, fNormPhase);

   STACK_END
}

/*******************************************************************************
*
* Function:  GetPhaseIndices()
*
* Action:    Get indices into trig tables for FHT phases
*
* Input:     float *pfPhase      -> pointer to array of phases (in radians)
*            int    iHarm        -> number of harmonics
*
* Output:    int   *piPhaseIndex -> pointer to array of indices
*
* Globals:   none
*
* Return:    None
********************************************************************************
*
* Modifications:
*
* Comments:
*
* Concerns/TBD:
*******************************************************************************/
static void GetPhaseIndices( float *pfPhase, 
                             int   *piPhaseIndex, 
                             int    iHarm 
                           )
{
   int   i;
   int   iTemp;
   float fTemp;

   for (i=0; i<iHarm; i++)
   {
      /*-------------------------------------------------
        Compute trig table index.
 
        NOTE: This assumes a 2's complement integer
              representation.  Using the trig mask 
              (iResPhase&TRIG_MASK) yeilds the correct
              positive index, even if iResPhase is
              negative.  This would not be true for  
              signed magnitude integer representation.
      -------------------------------------------------*/
      fTemp = (pfPhase[i]+PIO2)*fRadiansToIndex;
      VoxROUND2( fTemp, iTemp );
      piPhaseIndex[i] = iTemp & TRIG_MASK;
   }
}

#endif /* (SYNTHESIS_TYPE==FHT_SYNTHESIS) */

/*******************************************************************************
*
* Function:  ClipOverflows()
*
* Action:    Prevent overflows by rescaling the entire harmonic amplitudes
*              
* Input:     float *pfAmps       -> input harmonic amplitudes
*            int    iHarm        -> number of harmonics
*
* Output:    float *pfAmps       -> scaled harmonic amplitudes
*
* Globals:   none
*
* Return:    None
********************************************************************************
* Modifications:
*
* Comments:
*
* Concerns/TBD:
*******************************************************************************/

static void ClipOverflows( float *pfAmps,
                           int    iHarm
                         )
{
   int   i;
   float fSumAmp;
   float fScale = 1.0F;

   assert(pfAmps != NULL);
   assert(iHarm > 0);

   /*--------------------------------------------------
     Prevent clipping by scaling the output to have
       a maximum value of fClipLevel.
   --------------------------------------------------*/
   fSumAmp = 0.0F;
   for (i = 0; i < iHarm; i++)
     fSumAmp += pfAmps[i];
 
   if (fSumAmp > CLIP_LEVEL) 
     fScale = CLIP_LEVEL/fSumAmp;

   ScaleVector( pfAmps, iHarm, fScale, pfAmps);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\overadd.h ===
/******************************************************************************
*                        Voxware Proprietary Material
*                        Copyright 1996, Voxware, Inc
*                            All Rights Reserved
*
*                       DISTRIBUTION PROHIBITED without
*                      written authorization from Voxware
******************************************************************************/

/******************************************************************************
*
* Filename:      OverAdd.h
*
* Purpose:       Overlap/Add harmonics synthesizer using Fast Harmonic
*                  Transform and triangular window.
*
* Functions:     FHTOverlapAdd() 
*
* Author/Date:   Bob Dunn 3/97
*******************************************************************************
*
* Modifications:
*
* Comments:
*
* Concerns: 
*
* $Header:   /export/phobos/pvcs/r_and_d/archives/scaleable/decode/OverAdd.h_v   1.2   10 Apr 1998 16:10:50   weiwang  $
*
******************************************************************************/
#ifndef OVERADD_H
#define OVERADD_H

/*******************************************************************************
*
* Function:  FHTOverlapAdd()
*
* Action:    Overlap/Add harmonics synthesizer using Fast Harmonic
*                  Transform and triangular window.
*
* Input:     float *pfAmps             -> harmonics amplitudes
*            float *pfPhase            -> harmonics phases
*            float  fPitchDFT          -> pitch in DFT samples
*            int    iHarm              -> number of harmonics
*            int    iSynSubFrameLength -> number of samples to synthesize
*            float *fWaveform_1        -> previous waverform for overlap
*
* Output:    float *pfOutputBuffer     -> output waveform
*            float *pfWaveform_1        -> waverform for next overlap
*
* Globals:   none
*
* Return:    void
********************************************************************************
*
* Modifications:
*
* Comments:
*
* Concerns/TBD:
*******************************************************************************/

void FHTOverlapAdd( STACK_R 
                    float *pfAmps, 
                    float fPitchDFT, 
                    float *pfPhase, 
                    int iHarm, 
                    int iSynSubFrameLength, 
                    float *pfOutputBuffer,
                    float *pfWaveform_1
                   );

#endif /* OVERADD_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\outbufsc.h ===
/******************************************************************************
*                        Voxware Proprietary Material                         *
*                        Copyright 1996, Voxware, Inc                         *
*                            All Rights Reserved                              *
*                                                                             *
*                       DISTRIBUTION PROHIBITED without                       *
*                      written authorization from Voxware                     *
******************************************************************************/

/******************************************************************************
* Filename:   OutBufSC.h
*                                                                              
* Purpose:    Output speech to PCM buffer
*                                                                              
* Functions:  PreOutputManagerSC(), PostOutputManagerSC()
*
* Author/Date:   Wei Wang, 2/18/98
*******************************************************************************
* Modifications: 
*            
* Comments: Only for half frame synthesizer
* 
* Concerns:
*
* $Header:   /export/phobos/pvcs/r_and_d/archives/scaleable/decode/OutBufSC.h_v   1.4   10 Apr 1998 11:49:32   weiwang  $
******************************************************************************/
#ifndef OUTBUF_H
#define OUTBUF_H


/******************************************************************************
* Function:   void PreOutputManagerSC()
*
* Action: output pfSaveBuffer to psPCMBuffer. Then pvSaveBuffer
*         can be reused later.
*
* Input:      pfSaveBuffer -- samples from previous frame
*             iSaveSamples -- number of samples in pfSaveBuffer
*             psPCMBuffer --  pointer to output speech buffer
*
* Output:     psPCMBuffer -- output speech
*
* Globals:    none
*
* Return:     none
*******************************************************************************
* Implementation/Detailed Description:
*
* References:
*******************************************************************************
* Modifications:
*
* Comments:   iSaveSamples can only be 0 or FRAME_LEN.
*
* Concerns/TBD:
******************************************************************************/

void PreOutputManagerSC(const float *pfSaveBuffer, int iSaveSamples, 
                        short *psPCMBuffer);

/******************************************************************************
* Function:   void PostOutputManagerSC()
*
* Action:     Output speech to PCM buffer and update pfSaveBuffer.
*
* Input:      *pfSaveBuffer -- synthesized speech buffer
*             *piSaveSamples -- number of saved samples
*             iSynSamples -- number of synthesized speech
*             *psPCMBuffer -- pointer to output speech buffer
*
* Output:     *pfSaveBuffer -- saved samples for next frame
*             *piSaveSamples -- updated number of saved samples
*             *psPCMBuffer -- output PCM buffer
*             *pwPCMsamples -- number of samples in psPCMBuffer 
*                              (either 0 or FULL_FRAME_LEN).
*
* Globals:    none
*
* Return:     none
*******************************************************************************
* Implementation/Detailed Description:
*
* References:
*******************************************************************************
* Modifications:
*
* Comments: iSaveSamples is 0 or FRAME_LEN (80) and iSynSamples is
*           0, FRAME_LEN (80) or FULL_FRAME_LEN (160).
*
* Concerns/TBD:  
******************************************************************************/

void PostOutputManagerSC( float          *pfSaveBuffer, 
                          int            *piSaveSamples, 
                          int             iSynSamples,
                          short          *psPCMBuffer, 
                          unsigned short *pwPCMsamples
                        );

#endif /* OUTBUF_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\pack15.h ===
#ifndef PACK15_H
#define PACK15_H

unsigned short VoxPackVR15(void *pvQuan_mblk,unsigned char *PacketBuffer,
				unsigned short *ByteOffset,  unsigned char *BitOffset,
            unsigned short BufferSize);


unsigned short VoxUnPackVR15(void *pvQuan_mblk, unsigned char *PacketBuffer,
				unsigned short *ByteOffset,  unsigned char *BitOffset,
            unsigned short BufferSize);

#endif /* PACK15_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\pack12.h ===
#ifndef PACK12_H
#define PACK12_H

unsigned short VoxPackVR12(void *pvQuan_mblk,unsigned char *PacketBuffer,
				unsigned short *ByteOffset,  unsigned char *BitOffset,
            unsigned short BufferSize);


unsigned short VoxUnPackVR12(void *pvQuan_mblk, unsigned char *PacketBuffer,
				unsigned short *ByteOffset,  unsigned char *BitOffset,
            unsigned short BufferSize);

#endif /* PACK12_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\p5fft.c ===
/*******************************************************************************
*                        Voxware Proprietary Material                          *
*                        Copyright 1996, Voxware, Inc                          *
*                            All Rights Reserved                               *
*                                                                              *
*                       DISTRIBUTION PROHIBITED without                        *
*                      written authorization from Voxware                      *
*******************************************************************************/

/*******************************************************************************
* Filename:   P5FFT.c                                                                 
*                                                                              
* Purpose:    Fast FFT algorithm pulled out from Intel NSP library                                                                 
*                                                                              
* Functions:  Real FFT
*             Complex Conjugate FFT 
*             Complex FFT                                                                
*                                                                              
* Author/Date:  Xiangdong Fu (From Intel NSP)    12/17/96                                              
********************************************************************************
* Modifications:  
*                   
* Comments:                                                                    
* 
* Concerns:
*
* $Header:   /export/phobos/pvcs/pvcsproj/common.prj/intel.fld/P5FFT.c_v   1.3   02 Mar 1998 17:16:32   weiwang  $
*******************************************************************************/

#include <stdlib.h>
#include <math.h>

#include "vLibTran.h"
#include "vLibDef.h"

#include "xvocver.h"

#define V707107 ((float)0.707107)
#define SizeBlock 1024

#define  FFT_OrderSplit          11       /* max order for split algorithm  */
static SCplx *ctxFftTbl [32];        /***** static should be pointer based -- Toby ******/
static int   *ctxRevTbl [32];        /***** static should be pointer based -- Toby ******/

/*F*
//  Name:      nspcUndCalcFftTwdTbl_great
//  Purpose:   Computes twiddle factors for FFT computations (float).
//  Arguments:
//     tbl   - Pointer to the table to be filled with twiddle factors.
//     order - The base-2 logarithm of the length
//             of the twiddle factor table.
//  Calls:
//             cos,
//             sin.
*F*/

static void
nspcUndCalcFftTwdTbl_great(
   SCplx  *tbl,
   int     order)
{
   int     i,                         /*  loop index                */
           j,
           n,                         /*  pow(2,order)              */
           n2;                        /*  n/2                       */
   double  ang,                       /*  6.283185307179586 / n     */
           wpr,  wpi,                 /*  ( cos(ang),  -sin(ang) )  */
           wr,   wi,
           ang3,                      /*  ang * 3                   */
           wpr3, wpi3,                /*  ( cos(ang3), -sin(ang3) ) */
           wr3,  wi3,
           wtemp;

   n    = 1 << order;
   n2   = n/2;

   ang  = DB_PI/n;

   if ( order < FFT_OrderSplit )   {  /* ---- For Split algorithm --------- */

      wpr  =  cos(ang);
      wpi  = -sin(ang);
      ang3 = ang * 3.0;
      wpr3 =  cos(ang3);
      wpi3 = -sin(ang3);
      wr   = wpr;
      wi   = wpi;
      wr3  = wpr3;
      wi3  = wpi3;
      for ( i = 0 ; i < (n2-1) ; i+=2 ) {
         tbl[ i ].re = (float)wr;
         tbl[ i ].im = (float)wi;
                 wr  = (wtemp=wr)*wpr - wi*wpi;
                 wi  = wi*wpr + wtemp*wpi;
         tbl[i+1].re = (float)wr3;
         tbl[i+1].im = (float)wi3;
                 wr3 = (wtemp=wr3)*wpr3 - wi3*wpi3;
                 wi3 = wi3*wpr3 + wtemp*wpi3;
      }

   } else                          {  /* ---- For Radix algorithm --------- */

      for ( i = 0 ; i < n2 ; i++ ) {
          tbl[i].re = (float) cos(ang * i);
          tbl[i].im = (float)-sin(ang * i);
      }

   } /* if for algorithm type */

   /*  Compute the table of sin/cos for the trigonometric recombination  */

   /* Real Type */
   ang = PI/n;
   wpr = cos(ang);
   wpi = sin(ang);
   wr  = wpr;
   wi  = wpi;
   for ( i = n2 ; i < n ; i++ ) {
      tbl[i].re = (float)( wr*0.5 );
      tbl[i].im = (float)( -wi*0.5 + 0.5 );
             wr = (wtemp=wr)*wpr - wi*wpi;
             wi = wi*wpr + wtemp*wpi;
   }

   /* Ccs Type */
   for ( i = n, j = 0 ; i < (n+n2) ; i++, j++ ) {
       tbl[i].re = (float) cos(ang * j);
       tbl[i].im = (float)-sin(ang * j);
   }

   return;
}  /* nspcUndCalcFftTwdTbl_great */


/*F*
//  Name:      nspcUndGetFftTwdTbl_great
//  Purpose:   Allocates and fills a table for twiddle factors
//             for FFT computations (float).
//  Returns:   Pointer to the table of twiddle factors or NULL.
//  Argument:
//     order - The base-2 logarithm of the number of twiddle factors
//             in the table to be allocated.
//  Calls:
//             nspUndContext,
//             free,
//             calloc,
//             nspcUndCalcFftTwdTbl_great.
*F*/


static const SCplx*
nspcUndGetFftTwdTbl_great(
    int            order)
{
    int            length;
    SCplx         *A;
    if(!ctxFftTbl[order]){
       length = ( ( 1 << order ) * 3 )/2 + 4;
       A = (SCplx*) calloc(length,sizeof(SCplx));
       if ( !A ) {
          return(NULL);
       }
    }
    else { A = ctxFftTbl[order];  return(A); }

    nspcUndCalcFftTwdTbl_great(A,order);

    ctxFftTbl[order] = A;
    return(A);

} /* nspcUndGetFftTwdTbl_great */


 static void nspCalcBitRevTbl(
   int *tbl,
   int  order)
{
   int  n, i, j, k;

   n=1<<order;
   tbl[0]=0;
   tbl[n-1]=n-1;
   j = 0;
   for (i = 1 ; i < (n-1) ; i++) {
      k=n>>1;
      while (k<=j) {
         j=j-k;
         k=k>>1;
      }
      j=j+k;
      if (i<=j){
         tbl[j]=i;
         tbl[i]=j;
      }
   }
} /* nspCalcBitRevTbl */


const int* nspGetBitRevTbl(
    int           order)
{
    int          *ptbl;
    ptbl=ctxRevTbl[order];
    if (!ptbl) {
        ptbl=(int*) malloc((1<<order) *sizeof(int));
        if (!ptbl){
            ptbl=(int*) malloc((1<<order) *sizeof(int));
            return(NULL);
        } else {
           nspCalcBitRevTbl(ptbl,order);
           ctxRevTbl[order]=ptbl;
        }
    }
    return ptbl;
}

static void nspcbBitRev1(
    SCplx   *vec,
    int     order)
{
   typedef struct { long l0; long l1; } Memcb;
   Memcb  *vecm_00, *vecm_n0, *vecm_nn;
   long   temp;
   int    *tabrev;
   int    n, i, j;

#define CHANGE(mem1, mem2) \
    { temp = mem1.l0; mem1.l0 = mem2.l0; mem2.l0 = temp;     \
      temp = mem1.l1; mem1.l1 = mem2.l1; mem2.l1 = temp; };

     vecm_00 = (Memcb*) vec;
     if (order<3) {
       if (order>1) {
          CHANGE( vecm_00 [1], vecm_00 [2] );
        };
       return;
     };
     n = (1<<order);
     vecm_n0 = (Memcb*) vecm_00 + (n>>1);
     vecm_nn = (Memcb*) vecm_00 + (n>>1) + (n>>2);
     tabrev = (int*) nspGetBitRevTbl(order);
     for (i=0; i<=(n>>1)-4; i+=4) {
        j = tabrev[i];
        CHANGE( vecm_00 [i+1], vecm_n0 [j  ] );
        CHANGE( vecm_00 [i+3], vecm_nn [j  ] );
        if (i>j) {
           CHANGE( vecm_00 [i  ], vecm_00 [j  ] );
           CHANGE( vecm_n0 [i+1], vecm_n0 [j+1] );
        };
        j = tabrev[i+2];
        if (i+2>j) {
          CHANGE( vecm_00 [i+2], vecm_00 [j  ] );
          CHANGE( vecm_n0 [i+3], vecm_n0 [j+1] );
        };
    };
#undef CHANGE
}



#if P5_OPT == 0

/*F*
//  Name:       nspcUndSplit_FFT
//  Purpose:    Internal function.
//              Computes the forward or inverse fast Fourier transform (FFT)
//              of complex signal (in-place).
//  Arguments:
//       x   -  input and output Complex sequense of signal
//       n   -  length of signal
//       inv -  transform flag ( 1 - forward,  -1 - inverse )
//       w   -  table of twiddle factors
//  Calls:
//     nspcUndSplit_FFT_forward  -  for forward transform,
//     nspcUndSplit_FFT_inverse  -  for inverse transform.
*F*/

/*static float V707107 = (float)0.707107; */  /* 1/sqrt(2) */
#define V707107 ((float)0.707107)

static void
nspcUndSplit_FFT_forward(
   SCplx        *x,
   int           n,
   const SCplx  *w)
{
   int           k,
                 its, is, id, i1, it, j, l,
                 nn, n2, n4, n8;
   float         t1re, t1im, t2re, t2im, t3re, t3im;
   float        *x_1, *x_2, *x_3, *x_4, *ww;

   /* --------------- Main Loop --------------- */

   its = 4;
   n2  = n << 2;

   nn  = n << 1;

   x_1 = (float *)x;
   ww  = (float *)w;

   for  ( k = 2 ; k < (n >> 2) ; k = (k << 1) )  {

      is   = 0;
      id   = n2;
      n2   = n2 >> 1;
      n4   = n2 >> 2;
      n8   = n4 >> 1;

      x_2  = x_1 + n4;
      x_3  = x_2 + n4;
      x_4  = x_3 + n4;

      m10:
      for  ( i1 = is ; i1 < nn ; i1 += id )  {

         /* ............... Zero butterfly ............... */
         t1re         =  x_1[ i1   ]  -  x_3[ i1   ];
         t1im         =  x_1[ i1+1 ]  -  x_3[ i1+1 ];
         x_1[ i1   ]  =  x_1[ i1   ]  +  x_3[ i1   ];
         x_1[ i1+1 ]  =  x_1[ i1+1 ]  +  x_3[ i1+1 ];
         t2re         =  x_2[ i1   ]  -  x_4[ i1   ];
         t2im         =  x_2[ i1+1 ]  -  x_4[ i1+1 ];
         x_2[ i1   ]  =  x_2[ i1   ]  +  x_4[ i1   ];
         x_2[ i1+1 ]  =  x_2[ i1+1 ]  +  x_4[ i1+1 ];
         x_3[ i1   ]  =  t1re  + t2im;
         x_3[ i1+1 ]  =  t1im  - t2re;
         x_4[ i1   ]  =  t1re  - t2im;
         x_4[ i1+1 ]  =  t1im  + t2re;

         /* ...................... N/8 butterfly ...................... */
         l = i1 + n8;
         t1re        =  x_1[ l   ]  -  x_3[ l   ];
         t1im        =  x_1[ l+1 ]  -  x_3[ l+1 ];
         x_1[ l   ]  =  x_1[ l   ]  +  x_3[ l   ];
         x_1[ l+1 ]  =  x_1[ l+1 ]  +  x_3[ l+1 ];
         t2re        =  x_2[ l   ]  -  x_4[ l   ];
         t2im        =  x_2[ l+1 ]  -  x_4[ l+1 ];
         x_2[ l   ]  =  x_2[ l   ]  +  x_4[ l   ];
         x_2[ l+1 ]  =  x_2[ l+1 ]  +  x_4[ l+1 ];
         x_3[ l   ]  =  V707107*( (t1re + t2im) + (t1im - t2re) );
         x_3[ l+1 ]  =  V707107*( (t1im - t2re) - (t1re + t2im) );
         x_4[ l   ]  = -V707107*( (t1re - t2im) - (t1im + t2re) );
         x_4[ l+1 ]  = -V707107*( (t1im + t2re) + (t1re - t2im) );

         /* ...................... General butterfly ................... */
         for ( j=i1+2, it=its-4; j < l ; j+=2 , it+=its ) {
            t1re        =  x_1[ j   ]  -  x_3[ j   ];
            t1im        =  x_1[ j+1 ]  -  x_3[ j+1 ];
            x_1[ j   ]  =  x_1[ j   ]  +  x_3[ j   ];
            x_1[ j+1 ]  =  x_1[ j+1 ]  +  x_3[ j+1 ];
            t2im        =  x_2[ j   ]  -  x_4[ j   ];
            t2re        =  x_4[ j+1 ]  -  x_2[ j+1 ];
            x_2[ j   ]  =  x_2[ j   ]  +  x_4[ j   ];
            x_2[ j+1 ]  =  x_2[ j+1 ]  +  x_4[ j+1 ];
            x_3[ j   ]  =  (t1re - t2re )*ww[ it   ]  -
                           (t1im - t2im )*ww[ it+1 ];
            x_3[ j+1 ]  =  (t1im - t2im )*ww[ it   ]  +
                           (t1re - t2re )*ww[ it+1 ];
            x_4[ j   ]  =  (t1re + t2re )*ww[ it+2 ] -
                           (t1im + t2im )*ww[ it+3 ];
            x_4[ j+1 ]  =  (t1im + t2im )*ww[ it+2 ]  +
                           (t1re + t2re )*ww[ it+3 ];
         }
         for ( j=i1+n4-2, it=its-4; j > l ; j-=2 , it+=its ) {
            t1re        =  x_1[ j   ]  -  x_3[ j   ];
            t1im        =  x_1[ j+1 ]  -  x_3[ j+1 ];
            x_1[ j   ]  =  x_1[ j   ]  +  x_3[ j   ];
            x_1[ j+1 ]  =  x_1[ j+1 ]  +  x_3[ j+1 ];
            t2im        =  x_2[ j   ]  -  x_4[ j   ];
            t2re        =  x_4[ j+1 ]  -  x_2[ j+1 ];
            x_2[ j   ]  =  x_2[ j   ]  +  x_4[ j   ];
            x_2[ j+1 ]  =  x_2[ j+1 ]  +  x_4[ j+1 ];
            x_3[ j   ]  =  (t2re - t1re )*ww[ it+1 ]  -
                           (t2im - t1im )*ww[ it   ];
            x_3[ j+1 ]  =  (t2im - t1im )*ww[ it+1 ]  +
                           (t2re - t1re )*ww[ it   ];
            x_4[ j   ]  =  (t2re + t1re )*ww[ it+3 ]  -
                           (t2im + t1im )*ww[ it+2 ];
            x_4[ j+1 ]  =  (t2im + t1im )*ww[ it+3 ]  +
                           (t2re + t1re )*ww[ it+2 ];
         }

      }  /*  Loop  i1  end  */

      /* control */
      is = (id << 1) - n2;
      id =  id << 2 ;
      if ( is < nn ) goto m10;

      its = its << 1;

   }  /* --------  Main Loop  k  end  ----------- */

   is  = 0;
   id  = n2;
   n2  = n2 >> 1;

   x_2 = x_1 + 4;
   x_3 = x_2 + 4;
   x_4 = x_3 + 4;

   m20:
   for ( i1 = is, j = is + 2 ; i1 < nn ; i1+=id, j+=id ) {
      /* ............... Zero butterfly .............. */
      t1re         =  x_1[ i1   ]  -  x_3[ i1   ];
      t1im         =  x_1[ i1+1 ]  -  x_3[ i1+1 ];
      x_1[ i1   ]  =  x_1[ i1   ]  +  x_3[ i1   ];
      x_1[ i1+1 ]  =  x_1[ i1+1 ]  +  x_3[ i1+1 ];
      t2re         =  x_2[ i1   ]  -  x_4[ i1   ];
      t2im         =  x_2[ i1+1 ]  -  x_4[ i1+1 ];
      x_2[ i1   ]  =  x_2[ i1   ]  +  x_4[ i1   ];
      x_2[ i1+1 ]  =  x_2[ i1+1 ]  +  x_4[ i1+1 ];
      x_3[ i1   ]  =  t1re  +  t2im;
      x_3[ i1+1 ]  =  t1im  -  t2re;
      x_4[ i1   ]  =  t1re  -  t2im;
      x_4[ i1+1 ]  =  t1im  +  t2re;
      /* ............. N/8 butterfly ................. */
      t1re         =  x_1[ j   ]  -  x_3[ j   ];
      t1im         =  x_1[ j+1 ]  -  x_3[ j+1 ];
      x_1[ j   ]   =  x_1[ j   ]  +  x_3[ j   ];
      x_1[ j+1 ]   =  x_1[ j+1 ]  +  x_3[ j+1 ];
      t2re         =  x_2[ j   ]  -  x_4[ j   ];
      t2im         =  x_2[ j+1 ]  -  x_4[ j+1 ];
      x_2[ j   ]   =  x_2[ j   ]  +  x_4[ j   ];
      x_2[ j+1 ]   =  x_2[ j+1 ]  +  x_4[ j+1 ];
      x_3[ j   ]   =  V707107*( (t1re + t2im) + (t1im - t2re) );
      x_3[ j+1 ]   =  V707107*( (t1im - t2re) - (t1re + t2im) );
      x_4[ j   ]   = -V707107*( (t1re - t2im) - (t1im + t2re) );
      x_4[ j+1 ]   = -V707107*( (t1im + t2re) + (t1re - t2im) );
   }
   is = ( id << 1 ) - n2;
   id =  id << 2 ;
   if ( is < nn ) goto m20;

   if ( n == 8 ) {
      is =  0;
      id = 16;
      goto m30;
   }

   for ( i1 = 0 ; i1 < nn ; ) {

      t1re          =           x_1[ i1+ 8 ];
      t1im          =           x_1[ i1+ 9 ];
      x_1[ i1+ 8 ]  =  t1re  +  x_1[ i1+10 ];
      x_1[ i1+ 9 ]  =  t1im  +  x_1[ i1+11 ];
      x_1[ i1+10 ]  =  t1re  -  x_1[ i1+10 ];
      x_1[ i1+11 ]  =  t1im  -  x_1[ i1+11 ];
      t2re          =           x_1[ i1+12 ];
      t2im          =           x_1[ i1+13 ];
      x_1[ i1+12 ]  =  t2re  +  x_1[ i1+14 ];
      x_1[ i1+13 ]  =  t2im  +  x_1[ i1+15 ];
      x_1[ i1+14 ]  =  t2re  -  x_1[ i1+14 ];
      x_1[ i1+15 ]  =  t2im  -  x_1[ i1+15 ];

      j  = i1;
      i1 = i1 + 32;
      for ( ; j < i1 ; j+=16 ) {
         t1re        =            x_1[ j   ]  -  x_1[ j+4 ];
         t1im        =            x_1[ j+1 ]  -  x_1[ j+5 ];
         t3re        =            x_1[ j   ]  +  x_1[ j+4 ];
         t3im        =            x_1[ j+1 ]  +  x_1[ j+5 ];
         x_1[ j   ]  =  t3re  +  (x_1[ j+2 ]  +  x_1[ j+6 ]);
         x_1[ j+1 ]  =  t3im  +  (x_1[ j+3 ]  +  x_1[ j+7 ]);
         t2re        =            x_1[ j+2 ]  -  x_1[ j+6 ];
         t2im        =            x_1[ j+3 ]  -  x_1[ j+7 ];
         x_1[ j+2 ]  =  t3re  -  (x_1[ j+2 ]  +  x_1[ j+6 ]);
         x_1[ j+3 ]  =  t3im  -  (x_1[ j+3 ]  +  x_1[ j+7 ]);
         x_1[ j+4 ]  =  t1re  +  t2im;
         x_1[ j+5 ]  =  t1im  -  t2re;
         x_1[ j+6 ]  =  t1re  -  t2im;
         x_1[ j+7 ]  =  t1im  +  t2re;
      }
   }

   is = 24;
   id = 64;
   m30:
   for ( i1 = is ; i1 < nn ; i1+=id ) {
      t1re         =            x_1[ i1   ]  -  x_1[ i1+4 ];
      t1im         =            x_1[ i1+1 ]  -  x_1[ i1+5 ];
      t2re         =            x_1[ i1+2 ]  -  x_1[ i1+6 ];
      t2im         =            x_1[ i1+3 ]  -  x_1[ i1+7 ];
      t3re         =            x_1[ i1   ]  +  x_1[ i1+4 ];
      t3im         =            x_1[ i1+1 ]  +  x_1[ i1+5 ];
      x_1[ i1   ]  =  t3re  +  (x_1[ i1+2 ]  +  x_1[ i1+6 ]);
      x_1[ i1+1 ]  =  t3im  +  (x_1[ i1+3 ]  +  x_1[ i1+7 ]);
      x_1[ i1+2 ]  =  t3re  -  (x_1[ i1+2 ]  +  x_1[ i1+6 ]);
      x_1[ i1+3 ]  =  t3im  -  (x_1[ i1+3 ]  +  x_1[ i1+7 ]);
      x_1[ i1+4 ]  =  t1re  +  t2im;
      x_1[ i1+5 ]  =  t1im  -  t2re;
      x_1[ i1+6 ]  =  t1re  -  t2im;
      x_1[ i1+7 ]  =  t1im  +  t2re;
   }
   is = (id << 1) - 8;
   id =  id << 2;
   if ( is < nn ) goto m30;

   if ( n == 8 ) {
      for ( i1 = 8 ; i1 < 16 ; i1+=4 ) {
         t1re         =           x_1[ i1   ];
         t1im         =           x_1[ i1+1 ];
         x_1[ i1   ]  =  t1re  +  x_1[ i1+2 ];
         x_1[ i1+1 ]  =  t1im  +  x_1[ i1+3 ];
         x_1[ i1+2 ]  =  t1re  -  x_1[ i1+2 ];
         x_1[ i1+3 ]  =  t1im  -  x_1[ i1+3 ];
      }
   }

   is =  56;
   id = 128;
   m40:
   for ( i1 = is ; i1 < nn ; i1+=id ) {
      t1re         =           x_1[ i1   ];
      t1im         =           x_1[ i1+1 ];
      x_1[ i1   ]  =  t1re  +  x_1[ i1+2 ];
      x_1[ i1+1 ]  =  t1im  +  x_1[ i1+3 ];
      x_1[ i1+2 ]  =  t1re  -  x_1[ i1+2 ];
      x_1[ i1+3 ]  =  t1im  -  x_1[ i1+3 ];
      t1re         =           x_1[ i1+4 ];
      t1im         =           x_1[ i1+5 ];
      x_1[ i1+4 ]  =  t1re  +  x_1[ i1+6 ];
      x_1[ i1+5 ]  =  t1im  +  x_1[ i1+7 ];
      x_1[ i1+6 ]  =  t1re  -  x_1[ i1+6 ];
      x_1[ i1+7 ]  =  t1im  -  x_1[ i1+7 ];
   }
   is = (id << 1) - 8;
   id =  id << 2;
   if ( is < nn ) goto m40;

   return;
}  /* nspcUndSplit_FFT_forward */


static void
nspcUndSplit_FFT_inverse(
   SCplx        *x,
   int           n,
   const SCplx  *w)
{
   int           k,
                 its, is, id, i1, it, j,
                 n2, n4, n8, n4_2, n4_3;
   float         t1re, t1im, t2re, t2im, t3re, t3im;

   /* --------------- Main Loop --------------- */

   its = 2;
   n2  = n << 1;

   for  ( k = 2 ; k < (n >> 2) ; k = (k << 1) )  {

      is   = 0;
      id   = n2;
      n2   = n2 >> 1;
      n4   = n2 >> 2;
      n8   = n4 >> 1;
      n4_2 = n4 << 1;
      n4_3 = n4_2 + n4;

      m10:
      for  ( i1 = is ; i1 < n ; i1 += id )  {

         /* ............... Zero butterfly ............... */
         t1re            = x[ i1 ].re    - x[ n4_2 + i1 ].re;
         t1im            = x[ i1 ].im    - x[ n4_2 + i1 ].im;
         x[ i1 ].re      = x[ i1 ].re    + x[ n4_2 + i1 ].re;
         x[ i1 ].im      = x[ i1 ].im    + x[ n4_2 + i1 ].im;
         t2re            = x[ n4+i1 ].re - x[ n4_3 + i1 ].re;
         t2im            = x[ n4+i1 ].im - x[ n4_3 + i1 ].im;
         x[ n4+i1 ].re   = x[ n4+i1 ].re + x[ n4_3 + i1 ].re;
         x[ n4+i1 ].im   = x[ n4+i1 ].im + x[ n4_3 + i1 ].im;
         x[ n4_2+i1 ].re = t1re - t2im;
         x[ n4_2+i1 ].im = t1im + t2re;
         x[ n4_3+i1 ].re = t1re + t2im;
         x[ n4_3+i1 ].im = t1im - t2re;

         /* ...................... N/8 butterfly ...................... */
         t1re                 = x[ i1+n8 ].re      - x[ n4_2 + i1+n8 ].re;
         t1im                 = x[ i1+n8 ].im      - x[ n4_2 + i1+n8 ].im;
         x[ i1+n8 ].re        = x[ i1+n8 ].re      + x[ n4_2 + i1+n8 ].re;
         x[ i1+n8 ].im        = x[ i1+n8 ].im      + x[ n4_2 + i1+n8 ].im;
         t2re                 = x[ n4 + i1+n8 ].re - x[ n4_3 + i1+n8 ].re;
         t2im                 = x[ n4 + i1+n8 ].im - x[ n4_3 + i1+n8 ].im;
         x[ n4 + i1+n8 ].re   = x[ n4 + i1+n8 ].re + x[ n4_3 + i1+n8 ].re;
         x[ n4 + i1+n8 ].im   = x[ n4 + i1+n8 ].im + x[ n4_3 + i1+n8 ].im;
         x[ n4_2 + i1+n8 ].re =  V707107*( (t1re - t2im) - (t1im + t2re) );
         x[ n4_2 + i1+n8 ].im =  V707107*( (t1im + t2re) + (t1re - t2im) );
         x[ n4_3 + i1+n8 ].re = -V707107*( (t1re + t2im) + (t1im - t2re) );
         x[ n4_3 + i1+n8 ].im = -V707107*( (t1im - t2re) - (t1re + t2im) );

         /* ...................... General butterfly ................... */
         it = -1;
         for ( j = i1+1 ; j < i1+n8 ; j++ ) {
            it = it + its;
            t1re             = x[ j ].re        - x[ n4_2 + j ].re;
            t1im             = x[ j ].im        - x[ n4_2 + j ].im;
            x[ j ].re        = x[ j ].re        + x[ n4_2 + j ].re;
            x[ j ].im        = x[ j ].im        + x[ n4_2 + j ].im;
            t2im             = x[ n4 + j ].re   - x[ n4_3 + j ].re;
            t2re             = x[ n4_3 + j ].im - x[ n4 + j ].im;
            x[ n4 + j ].re   = x[ n4 + j ].re   + x[ n4_3 + j ].re;
            x[ n4 + j ].im   = x[ n4 + j ].im   + x[ n4_3 + j ].im;
            x[ n4_2 + j ].re =  (t1re + t2re )*w[ it-1 ].re +
                                (t1im + t2im )*w[ it-1 ].im;
            x[ n4_2 + j ].im =  (t1im + t2im )*w[ it-1 ].re -
                                (t1re + t2re )*w[ it-1 ].im;
            x[ n4_3 + j ].re =  (t1re - t2re )*w[  it  ].re +
                                (t1im - t2im )*w[  it  ].im;
            x[ n4_3 + j ].im =  (t1im - t2im )*w[  it  ].re -
                                (t1re - t2re )*w[  it  ].im;
         }
         it = -1;
         for ( j = i1+n4-1 ; j > i1+n8 ; j-- ) {
            it = it + its;
            t1re             = x[ j ].re        - x[ n4_2 + j ].re;
            t1im             = x[ j ].im        - x[ n4_2 + j ].im;
            x[ j ].re        = x[ j ].re        + x[ n4_2 + j ].re;
            x[ j ].im        = x[ j ].im        + x[ n4_2 + j ].im;
            t2im             = x[ n4 + j ].re   - x[ n4_3 + j ].re;
            t2re             = x[ n4_3 + j ].im - x[ n4 + j ].im;
            x[ n4 + j ].re   = x[ n4 + j ].re   + x[ n4_3 + j ].re;
            x[ n4 + j ].im   = x[ n4 + j ].im   + x[ n4_3 + j ].im;
            x[ n4_2 + j ].re = -(t2re + t1re )*w[ it-1 ].im -
                                (t2im + t1im )*w[ it-1 ].re;
            x[ n4_2 + j ].im =  (t2re + t1re )*w[ it-1 ].re -
                                (t2im + t1im )*w[ it-1 ].im;
            x[ n4_3 + j ].re =  (t1re - t2re )*w[  it  ].im +
                                (t1im - t2im )*w[  it  ].re;
            x[ n4_3 + j ].im =  (t1im - t2im )*w[  it  ].im -
                                (t1re - t2re )*w[  it  ].re;
         }

      }  /*  Loop  i1  end  */

      /* control */
      is = (id << 1) - n2;
      id =  id << 2 ;
      if ( is < n ) goto m10;

      its = its << 1;

   }  /* --------  Main Loop  k  end  ----------- */

   is = 0;
   id = n2;
   n2 = n2 >> 1;

   m20:
   for ( i1 = is ; i1 < n ; i1+=id ) {

      /* ............... Zero butterfly .............. */
      t1re           = x[     i1 ].re  -  x[ 4 + i1 ].re;
      t1im           = x[     i1 ].im  -  x[ 4 + i1 ].im;
      x[ i1 ].re     = x[     i1 ].re  +  x[ 4 + i1 ].re;
      x[ i1 ].im     = x[     i1 ].im  +  x[ 4 + i1 ].im;
      t2re           = x[ 2 + i1 ].re  -  x[ 6 + i1 ].re;
      t2im           = x[ 2 + i1 ].im  -  x[ 6 + i1 ].im;
      x[ 2 + i1 ].re = x[ 2 + i1 ].re  +  x[ 6 + i1 ].re;
      x[ 2 + i1 ].im = x[ 2 + i1 ].im  +  x[ 6 + i1 ].im;
      x[ 4 + i1 ].re = t1re - t2im;
      x[ 4 + i1 ].im = t1im + t2re;
      x[ 6 + i1 ].re = t1re + t2im;
      x[ 6 + i1 ].im = t1im - t2re;

      /* ............. N/8 butterfly ................. */
      t1re           = x[ 1 + i1 ].re  -  x[ 5 + i1 ].re;
      t1im           = x[ 1 + i1 ].im  -  x[ 5 + i1 ].im;
      x[ 1 + i1 ].re = x[ 1 + i1 ].re  +  x[ 5 + i1 ].re;
      x[ 1 + i1 ].im = x[ 1 + i1 ].im  +  x[ 5 + i1 ].im;
      t2re           = x[ 3 + i1 ].re  -  x[ 7 + i1 ].re;
      t2im           = x[ 3 + i1 ].im  -  x[ 7 + i1 ].im;
      x[ 3 + i1 ].re = x[ 3 + i1 ].re  +  x[ 7 + i1 ].re;
      x[ 3 + i1 ].im = x[ 3 + i1 ].im  +  x[ 7 + i1 ].im;
      x[ 5 + i1 ].re =  V707107*( (t1re - t2im) - (t1im + t2re) );
      x[ 5 + i1 ].im =  V707107*( (t1im + t2re) + (t1re - t2im) );
      x[ 7 + i1 ].re = -V707107*( (t1re + t2im) + (t1im - t2re) );
      x[ 7 + i1 ].im = -V707107*( (t1im - t2re) - (t1re + t2im) );

   }
   is = ( id << 1 ) - n2;
   id =  id << 2 ;
   if ( is < n ) goto m20;

   if ( n == 8 ) {
      is = 0;
      id = 8;
      goto m30;
   }

   for ( i1 = 0 ; i1 < n ; i1+=16 ) {

      t1re           =         x[     i1 ].re  -  x[ 2 + i1 ].re;
      t1im           =         x[     i1 ].im  -  x[ 2 + i1 ].im;
      t2re           =         x[ 1 + i1 ].re  -  x[ 3 + i1 ].re;
      t2im           =         x[ 1 + i1 ].im  -  x[ 3 + i1 ].im;
      t3re           =         x[     i1 ].re  +  x[ 2 + i1 ].re;
      t3im           =         x[     i1 ].im  +  x[ 2 + i1 ].im;
      x[     i1 ].re = t3re + (x[ 1 + i1 ].re  +  x[ 3 + i1 ].re);
      x[     i1 ].im = t3im + (x[ 1 + i1 ].im  +  x[ 3 + i1 ].im);
      x[ 1 + i1 ].re = t3re - (x[ 1 + i1 ].re  +  x[ 3 + i1 ].re);
      x[ 1 + i1 ].im = t3im - (x[ 1 + i1 ].im  +  x[ 3 + i1 ].im);
      x[ 2 + i1 ].re = t1re - t2im;
      x[ 2 + i1 ].im = t1im + t2re;
      x[ 3 + i1 ].re = t1re + t2im;
      x[ 3 + i1 ].im = t1im - t2re;

      t1re           =          x[ 4 + i1 ].re;
      t1im           =          x[ 4 + i1 ].im;
      x[ 4 + i1 ].re = t1re  +  x[ 5 + i1 ].re;
      x[ 4 + i1 ].im = t1im  +  x[ 5 + i1 ].im;
      x[ 5 + i1 ].re = t1re  -  x[ 5 + i1 ].re;
      x[ 5 + i1 ].im = t1im  -  x[ 5 + i1 ].im;
      t2re           =          x[ 6 + i1 ].re;
      t2im           =          x[ 6 + i1 ].im;
      x[ 6 + i1 ].re = t2re  +  x[ 7 + i1 ].re;
      x[ 6 + i1 ].im = t2im  +  x[ 7 + i1 ].im;
      x[ 7 + i1 ].re = t2re  -  x[ 7 + i1 ].re;
      x[ 7 + i1 ].im = t2im  -  x[ 7 + i1 ].im;

      t1re            =           x[ 8 + i1 ].re  -  x[ 10 + i1 ].re;
      t1im            =           x[ 8 + i1 ].im  -  x[ 10 + i1 ].im;
      t2re            =           x[ 9 + i1 ].re  -  x[ 11 + i1 ].re;
      t2im            =           x[ 9 + i1 ].im  -  x[ 11 + i1 ].im;
      t3re            =           x[ 8 + i1 ].re  +  x[ 10 + i1 ].re;
      t3im            =           x[ 8 + i1 ].im  +  x[ 10 + i1 ].im;
      x[  8 + i1 ].re = t3re  +  (x[ 9 + i1 ].re  +  x[ 11 + i1 ].re);
      x[  8 + i1 ].im = t3im  +  (x[ 9 + i1 ].im  +  x[ 11 + i1 ].im);
      x[  9 + i1 ].re = t3re  -  (x[ 9 + i1 ].re  +  x[ 11 + i1 ].re);
      x[  9 + i1 ].im = t3im  -  (x[ 9 + i1 ].im  +  x[ 11 + i1 ].im);
      x[ 10 + i1 ].re = t1re - t2im;
      x[ 10 + i1 ].im = t1im + t2re;
      x[ 11 + i1 ].re = t1re + t2im;
      x[ 11 + i1 ].im = t1im - t2re;

   }

   is = 12;
   id = 32;

   m30:
   for ( i1 = is ; i1 < n ; i1+=id ) {
      t1re           =           x[     i1 ].re  -  x[ 2 + i1 ].re;
      t1im           =           x[     i1 ].im  -  x[ 2 + i1 ].im;
      t2re           =           x[ 1 + i1 ].re  -  x[ 3 + i1 ].re;
      t2im           =           x[ 1 + i1 ].im  -  x[ 3 + i1 ].im;
      t3re           =           x[     i1 ].re  +  x[ 2 + i1 ].re;
      t3im           =           x[     i1 ].im  +  x[ 2 + i1 ].im;
      x[     i1 ].re = t3re  +  (x[ 1 + i1 ].re  +  x[ 3 + i1 ].re);
      x[     i1 ].im = t3im  +  (x[ 1 + i1 ].im  +  x[ 3 + i1 ].im);
      x[ 1 + i1 ].re = t3re  -  (x[ 1 + i1 ].re  +  x[ 3 + i1 ].re);
      x[ 1 + i1 ].im = t3im  -  (x[ 1 + i1 ].im  +  x[ 3 + i1 ].im);
      x[ 2 + i1 ].re = t1re - t2im;
      x[ 2 + i1 ].im = t1im + t2re;
      x[ 3 + i1 ].re = t1re + t2im;
      x[ 3 + i1 ].im = t1im - t2re;
   }
   is = (id << 1) - 4;
   id =  id << 2;
   if ( is < n ) goto m30;

   if ( n == 8 ) {
      i1 = 4;
      t1re           =          x[     i1 ].re;
      t1im           =          x[     i1 ].im;
      x[     i1 ].re = t1re  +  x[ 1 + i1 ].re;
      x[     i1 ].im = t1im  +  x[ 1 + i1 ].im;
      x[ 1 + i1 ].re = t1re  -  x[ 1 + i1 ].re;
      x[ 1 + i1 ].im = t1im  -  x[ 1 + i1 ].im;
      t2re           =          x[ 2 + i1 ].re;
      t2im           =          x[ 2 + i1 ].im;
      x[ 2 + i1 ].re = t2re  +  x[ 3 + i1 ].re;
      x[ 2 + i1 ].im = t2im  +  x[ 3 + i1 ].im;
      x[ 3 + i1 ].re = t2re  -  x[ 3 + i1 ].re;
      x[ 3 + i1 ].im = t2im  -  x[ 3 + i1 ].im;
   }

   is = 28;
   id = 64;
   m40:
   for ( i1 = is; i1 < n ; i1+=id ) {
      t1re           =          x[     i1 ].re;
      t1im           =          x[     i1 ].im;
      x[     i1 ].re = t1re  +  x[ 1 + i1 ].re;
      x[     i1 ].im = t1im  +  x[ 1 + i1 ].im;
      x[ 1 + i1 ].re = t1re  -  x[ 1 + i1 ].re;
      x[ 1 + i1 ].im = t1im  -  x[ 1 + i1 ].im;
      t2re           =          x[ 2 + i1 ].re;
      t2im           =          x[ 2 + i1 ].im;
      x[ 2 + i1 ].re = t2re  +  x[ 3 + i1 ].re;
      x[ 2 + i1 ].im = t2im  +  x[ 3 + i1 ].im;
      x[ 3 + i1 ].re = t2re  -  x[ 3 + i1 ].re;
      x[ 3 + i1 ].im = t2im  -  x[ 3 + i1 ].im;
   }
   is = (id << 1) - 4;
   id =  id << 2;
   if ( is < n ) goto m40;

   return;
}  /* nspcUndSplit_FFT_inverse */



static void
nspcUndSplit_FFT(
   SCplx        *x,
   int           n,
   int           inv,
   const SCplx  *w)
{
   SCplx         t1, t2, t3;

   if ( n < 8 ) {           /* -------- easy cases ---------- */
      if ( n > 2 ) {        /*  .........  n = 4  ..........  */
            t1.re      =             x[ 0 ].re  -  x[ 2 ].re;
            t1.im      =             x[ 0 ].im  -  x[ 2 ].im;
            t2.re      =             x[ 1 ].re  -  x[ 3 ].re;
            t2.im      =             x[ 1 ].im  -  x[ 3 ].im;
            t3.re      =             x[ 0 ].re  +  x[ 2 ].re;
            t3.im      =             x[ 0 ].im  +  x[ 2 ].im;
            x[ 0 ].re  =  t3.re  +  (x[ 1 ].re  +  x[ 3 ].re);
            x[ 0 ].im  =  t3.im  +  (x[ 1 ].im  +  x[ 3 ].im);
            x[ 1 ].re  =  t3.re  -  (x[ 1 ].re  +  x[ 3 ].re);
            x[ 1 ].im  =  t3.im  -  (x[ 1 ].im  +  x[ 3 ].im);
         if ( inv > 0 ) {   /*  forward  transform  */
            x[ 2 ].re  =  t1.re  +  t2.im;
            x[ 2 ].im  =  t1.im  -  t2.re;
            x[ 3 ].re  =  t1.re  -  t2.im;
            x[ 3 ].im  =  t1.im  +  t2.re;
         }  else        {   /*  inverse  transform  */
            x[ 2 ].re  =  t1.re  -  t2.im;
            x[ 2 ].im  =  t1.im  +  t2.re;
            x[ 3 ].re  =  t1.re  +  t2.im;
            x[ 3 ].im  =  t1.im  -  t2.re;
         }
      }
      else {
         if ( n > 1 ) {     /*  .........  n = 2  ..........  */
            t1         =            x[ 0 ];
            x[ 0 ].re  =  t1.re  +  x[ 1 ].re;
            x[ 0 ].im  =  t1.im  +  x[ 1 ].im;
            x[ 1 ].re  =  t1.re  -  x[ 1 ].re;
            x[ 1 ].im  =  t1.im  -  x[ 1 ].im;
         }
      }
      return;
   }                        /* ----- end for easy cases ----- */

   if ( inv > 0 ) {         /*  forward  transform  */
      nspcUndSplit_FFT_forward( x, n, w);
   }  else        {         /*  inverse  transform  */
      nspcUndSplit_FFT_inverse( x, n, w);
   }
   return;
} /* nspcUndSplit_FFT */

#else
extern void
nspcUndSplit_FFT(
   SCplx        *x,
   int           n,
   int           inv,
   const SCplx  *w);

#endif


#if P5_OPT == 0
/*F*
//  Name:       nspcUndRadix2_FFT
//  Purpose:    Internal function.
//              Computes the forward or inverse fast Fourier transform (FFT)
//              of complex signal (in-place).
//  Arguments:
//        d   -  input and output Complex sequense of signal
//        n   -  length of signal
//        inv -  transform flag ( 1 - forward,  -1 - inverse )
//        w   -  table of twiddle factors
*F*/

#define SizeBlock 1024
static void
nspcUndRadix2_FFT(
  SCplx       *d,
  int          n,
  int          inv,
  const SCplx *w)
{
  int     nn=0, m;
  int     mmax=0, k, k1, k2, j1, i1, i2, i3, i4;
  int     kk, kk1, kk2, ki, kii, ki1, ki2, ik1=0, ik2;
  int     j, istep, i, nj, kj, kkj, kkj1, kkj2;
  SCplx   t, t1, temp, temp1, t01, t11;

  if ( n < 1 ) return;

  if ( n == 2 ) {
      temp.re  = d[0].re - d[1].re;
      temp.im  = d[0].im - d[1].im;
      d[0].re  = d[0].re + d[1].re;
      d[0].im  = d[0].im + d[1].im;
      d[1].re  = temp.re;
      d[1].im  = temp.im;
      return;
  }

  m = n<SizeBlock ? n : SizeBlock;
  if (inv<0) goto inverse;

  for (j1=0; j1<n; j1+=m) {

    kk  = j1-3;
    kk1 = j1-2;
    kk2 = j1-1;
    for (j=j1; j<j1+m; j+=4) {

      kk2 += 4;
      kk  += 4;
      kk1 += 4;

      temp.re  = d[j].re - d[kk].re;
      temp1.re = d[kk1].im - d[kk2].im;
      temp.im  = d[j].im - d[kk].im;
      temp1.im = d[kk2].re - d[kk1].re;
      d[j].re   = (t.re  = d[j].re + d[kk].re)
                + (t1.re = d[kk1].re + d[kk2].re);
      d[j].im   = (t.im  = d[j].im + d[kk].im)
                + (t1.im = d[kk1].im + d[kk2].im);
      d[kk].re  = temp.re + temp1.re;
      d[kk].im  = temp.im + temp1.im;
      d[kk1].re = t.re - t1.re;
      d[kk1].im = t.im - t1.im;
      d[kk2].re = temp.re - temp1.re;
      d[kk2].im = temp.im - temp1.im;
    } /* for */
    nn = 4;
    mmax = 8;
    istep = 16;
    if (nn==n) { return; }
    ik1 = n>>3;
    ik2 = n>>4;
 nextBlock:

    if (istep>n) goto label5;
    kk2 = (kk = j1+nn-istep) + mmax;
    kk1 = j1+mmax-istep;
    nj = nn>>1;
    for (j=j1; j<j1+m; j+=istep) {
      kk2 += istep;
      kk  += istep;
      kk1 += istep;

      temp.re  = d[j].re - d[kk].re;
      temp.im  = d[j].im - d[kk].im;
      temp1.re = d[kk1].im - d[kk2].im;
      temp1.im = d[kk2].re - d[kk1].re;

      t.re      = d[j].re + d[kk].re;
      t1.re     = d[kk1].re + d[kk2].re;
      t.im      = d[j].im + d[kk].im;
      t1.im     = d[kk1].im + d[kk2].im;
      d[j].re   = t.re + t1.re;
      d[j].im   = t.im + t1.im;

      d[kk].re  = temp.re + temp1.re;
      d[kk].im  = temp.im + temp1.im;
      d[kk1].re = t.re - t1.re;
      d[kk1].im = t.im - t1.im;
      d[kk2].re = temp.re - temp1.re;
      d[kk2].im = temp.im - temp1.im;

      kj   = j+nj;
      kkj2 = kk2+nj;
      kkj  = kk+nj;
      kkj1 = kk1+nj;

      temp.re  = d[kj].re - d[kkj].im;  /* tkk */
      temp.im  = d[kj].im + d[kkj].re;
      t.re  = d[kj].re + d[kkj].im;     /* tk  */
      t.im  = d[kj].im - d[kkj].re;

      temp1.re = d[kkj1].re - d[kkj2].im;     /* tk2 */
      temp1.im = d[kkj1].im + d[kkj2].re;
      t1.re = d[kkj1].re + d[kkj2].im;        /* tk1 */
      t1.im = d[kkj1].im - d[kkj2].re;

      t11.re =-V707107*(temp1.re-temp1.im); /* tr1 */
      t11.im =-V707107*(temp1.im+temp1.re);
      t01.re = V707107*(t1.re+t1.im);        /* tr  */
      t01.im = V707107*(t1.im-t1.re);

      d[kj].re   = t.re + t01.re;
      d[kj].im   = t.im + t01.im;
      d[kkj].re  = temp.re + t11.re;
      d[kkj].im  = temp.im + t11.im;
      d[kkj1].re = t.re - t01.re;
      d[kkj1].im = t.im - t01.im;
      d[kkj2].re = temp.re - t11.re;
      d[kkj2].im = temp.im - t11.im;

      k2 = (k = j+nn) + mmax;
      k1 = j+mmax;
      i1 = i2 = 0;
      ki  = k;
      ki1 = k2;
      kii = k1;
      ki2 = ki1 + nn;
      for (i=j+1; i<j+nj; i++) {
        k2++; k1++; k++;
        i1+=ik1; i2+=ik2;

        t.re  = w[i1].re*d[k].re - w[i1].im*d[k].im;
        t.im  = w[i1].re*d[k].im + w[i1].im*d[k].re;
        t1.re = w[i1].re*d[k2].re - w[i1].im*d[k2].im;
        t1.im = w[i1].re*d[k2].im + w[i1].im*d[k2].re;

        temp.re  = w[i2].re*(d[k1].re + t1.re) - w[i2].im*(d[k1].im + t1.im);
        temp.im  = w[i2].re*(d[k1].im + t1.im) + w[i2].im*(d[k1].re + t1.re);
        temp1.re = w[i2].im*(d[k1].re - t1.re) + w[i2].re*(d[k1].im - t1.im);
        temp1.im = w[i2].im*(d[k1].im - t1.im) - w[i2].re*(d[k1].re - t1.re);

        d[k].re  = d[i].re - t.re + temp1.re;
        d[k2].re = d[i].re - t.re - temp1.re;
        d[k].im  = d[i].im - t.im + temp1.im;
        d[k2].im = d[i].im - t.im - temp1.im;
        d[k1].im = d[i].im + t.im - temp.im;
        d[k1].re = d[i].re + t.re - temp.re;
        d[i].im += t.im + temp.im;
        d[i].re += t.re + temp.re;

        ki--; ki1--; kii--; ki2--;
        t.re  =-w[i1].re*d[kii].re - w[i1].im*d[kii].im;
        t.im  =-w[i1].re*d[kii].im + w[i1].im*d[kii].re;
        t1.re =-w[i1].re*d[ki2].re - w[i1].im*d[ki2].im;
        t1.im =-w[i1].re*d[ki2].im + w[i1].im*d[ki2].re;

        temp.re  =-w[i2].im*(d[ki1].re + t1.re) + w[i2].re*(d[ki1].im + t1.im);
        temp.im  =-w[i2].im*(d[ki1].im + t1.im) - w[i2].re*(d[ki1].re + t1.re);
        temp1.re =-w[i2].re*(d[ki1].re - t1.re) - w[i2].im*(d[ki1].im - t1.im);
        temp1.im =-w[i2].re*(d[ki1].im - t1.im) + w[i2].im*(d[ki1].re - t1.re);

        d[kii].re = d[ki].re - t.re + temp1.re;
        d[ki2].re = d[ki].re - t.re - temp1.re;
        d[kii].im = d[ki].im - t.im + temp1.im;
        d[ki2].im = d[ki].im - t.im - temp1.im;
        d[ki1].im = d[ki].im + t.im - temp.im;
        d[ki1].re = d[ki].re + t.re - temp.re;
        d[ki].im  = d[ki].im + t.im + temp.im;
        d[ki].re  = d[ki].re + t.re + temp.re;
      }  /* for i */
    }   /* for j */
    nn = istep;
    mmax <<= 2;
    istep <<= 2;
    ik1>>=2;
    ik2>>=2;
    if (nn < m) goto nextBlock;
  } /* for */
  if (m<n) {
    nextB:

    i1 = i4 = 0;
    ik2 = ik1<<1;
    for (i2=0; i2<nn; i2+=256,i4=i1) {
      kk = i2+nn;
      for (j=0; j<n; j += mmax) {
        i3 = i2+j;
        i1 = i4;
        k=kk+j;
        for (i=0 ; i<256; i+=2,i1+=ik2) {
          t.re = w[i1].re*d[k+i].re - w[i1].im*d[k+i].im;
          t.im = w[i1].im*d[k+i].re + w[i1].re*d[k+i].im;
          t1.re = w[i1+ik1].re*d[k+i+1].re - w[i1+ik1].im*d[k+i+1].im;
          t1.im = w[i1+ik1].im*d[k+i+1].re + w[i1+ik1].re*d[k+i+1].im;
          d[k+i].re = d[i+i3].re - t.re;
          d[k+i].im = d[i+i3].im - t.im;
          d[i+i3].re += t.re;
          d[i+i3].im += t.im;
          d[k+i+1].re = d[i+i3+1].re - t1.re;
          d[k+i+1].im = d[i+i3+1].im - t1.im;
          d[i+i3+1].re += t1.re;
          d[i+i3+1].im += t1.im;
        }  /* for i */
      }  /* for j */
    }  /* for i2 */
    nn = mmax;
    mmax <<= 1;
    ik1 >>= 1;
    if (nn<n) goto nextB;
  } /* if */

    return;
  label5:
    nj = nn>>1;
    for (i=0; i<nj; i++) {
      t.im = w[i].im*d[nn+i].re + w[i].re*d[nn+i].im;
      t.re = w[i].re*d[nn+i].re - w[i].im*d[nn+i].im;
      d[nn+i].re = d[i].re - t.re;
      d[nn+i].im = d[i].im - t.im;
      d[i].re += t.re;
      d[i].im += t.im;
      t.im = -w[i].re*d[nn+nj+i].re + w[i].im*d[nn+nj+i].im;
      t.re = w[i].im*d[nn+nj+i].re + w[i].re*d[nn+nj+i].im;
      d[nn+nj+i].re = d[i+nj].re - t.re;
      d[nn+nj+i].im = d[i+nj].im - t.im;
      d[i+nj].re += t.re;
      d[i+nj].im += t.im;
    }  /* for i */
    return;

    inverse:
  for (j1=0; j1<n; j1+=m) {

    kk  = j1-3;
    kk1 = j1-2;
    kk2 = j1-1;
    for (j=j1; j<j1+m; j+=4) {
      kk2 += 4;
      kk  += 4;
      kk1 += 4;

      temp.re  = d[j].re - d[kk].re;
      temp1.re =-d[kk1].im + d[kk2].im;
      temp.im  = d[j].im - d[kk].im;
      temp1.im =-d[kk2].re + d[kk1].re;
      d[j].re   = (t.re  = d[j].re + d[kk].re)
                + (t1.re = d[kk1].re + d[kk2].re);
      d[j].im   = (t.im  = d[j].im + d[kk].im)
                + (t1.im = d[kk1].im + d[kk2].im);
      d[kk].re  = temp.re + temp1.re;
      d[kk].im  = temp.im + temp1.im;
      d[kk1].re = t.re - t1.re;
      d[kk1].im = t.im - t1.im;
      d[kk2].re = temp.re - temp1.re;
      d[kk2].im = temp.im - temp1.im;
    } /* for */
    nn = 4;
    mmax = 8;
    istep = 16;
    if (nn==n) return;
    ik1 = n>>3;
    ik2 = n>>4;
    invnext:

    if (istep>n) goto inv;
    kk2 = (kk = j1+nn-istep) + mmax;
    kk1 = j1+mmax-istep;
    nj = nn>>1;
    for (j=j1; j<j1+m; j+=istep) {
      kk2 += istep;
      kk  += istep;
      kk1 += istep;

      temp.re  = d[j].re - d[kk].re;
      temp.im  = d[j].im - d[kk].im;
      temp1.re =-d[kk1].im + d[kk2].im;
      temp1.im =-d[kk2].re + d[kk1].re;

      t.re      = d[j].re + d[kk].re;
      t1.re     = d[kk1].re + d[kk2].re;
      t.im      = d[j].im + d[kk].im;
      t1.im     = d[kk1].im + d[kk2].im;
      d[j].re   = t.re + t1.re;
      d[j].im   = t.im + t1.im;
      d[kk].re  = temp.re + temp1.re;
      d[kk].im  = temp.im + temp1.im;
      d[kk1].re = t.re - t1.re;
      d[kk1].im = t.im - t1.im;
      d[kk2].re = temp.re - temp1.re;
      d[kk2].im = temp.im - temp1.im;

      kj   = j+nj;
      kkj2 = kk2+nj;
      kkj  = kk+nj;
      kkj1 = kk1+nj;

      temp.re  = d[kj].re + d[kkj].im;  /* tkk */
      temp.im  = d[kj].im - d[kkj].re;
      t.re  = d[kj].re - d[kkj].im;     /* tk  */
      t.im  = d[kj].im + d[kkj].re;

      temp1.re = d[kkj1].re + d[kkj2].im;     /* tk2 */
      temp1.im = d[kkj1].im - d[kkj2].re;
      t1.re = d[kkj1].re - d[kkj2].im;        /* tk1 */
      t1.im = d[kkj1].im + d[kkj2].re;

      t11.re =-V707107*(temp1.re+temp1.im); /* tr1 */
      t11.im =-V707107*(temp1.im-temp1.re);
      t01.re = V707107*(t1.re-t1.im);        /* tr  */
      t01.im = V707107*(t1.im+t1.re);

      d[kj].re   = t.re + t01.re;
      d[kj].im   = t.im + t01.im;
      d[kkj].re  = temp.re + t11.re;
      d[kkj].im  = temp.im + t11.im;
      d[kkj1].re = t.re - t01.re;
      d[kkj1].im = t.im - t01.im;
      d[kkj2].re = temp.re - t11.re;
      d[kkj2].im = temp.im - t11.im;

      k2 = (k = j+nn) + mmax;
      k1 = j+mmax;
      i1 = i2 = 0;
      ki  = k;
      ki1 = k2;
      kii = k1;
      ki2 = ki1 + nn;
      for (i=j+1; i<j+nj; i++) {
        k2++; k1++; k++;
        i1+=ik1; i2+=ik2;

        t.re  = w[i1].re*d[k].re + w[i1].im*d[k].im;
        t.im  = w[i1].re*d[k].im - w[i1].im*d[k].re;
        t1.re = w[i1].re*d[k2].re + w[i1].im*d[k2].im;
        t1.im = w[i1].re*d[k2].im - w[i1].im*d[k2].re;

        temp.re  = w[i2].re*(d[k1].re + t1.re) + w[i2].im*(d[k1].im + t1.im);
        temp.im  = w[i2].re*(d[k1].im + t1.im) - w[i2].im*(d[k1].re + t1.re);
        temp1.re = w[i2].im*(d[k1].re - t1.re) - w[i2].re*(d[k1].im - t1.im);
        temp1.im = w[i2].im*(d[k1].im - t1.im) + w[i2].re*(d[k1].re - t1.re);

        d[k].re  = d[i].re - t.re + temp1.re;
        d[k2].re = d[i].re - t.re - temp1.re;
        d[k].im  = d[i].im - t.im + temp1.im;
        d[k2].im = d[i].im - t.im - temp1.im;
        d[k1].im = d[i].im + t.im - temp.im;
        d[k1].re = d[i].re + t.re - temp.re;
        d[i].im += t.im + temp.im;
        d[i].re += t.re + temp.re;

        ki--; ki1--; kii--; ki2--;
        t.re  =-w[i1].re*d[kii].re + w[i1].im*d[kii].im;
        t.im  =-w[i1].re*d[kii].im - w[i1].im*d[kii].re;
        t1.re =-w[i1].re*d[ki2].re + w[i1].im*d[ki2].im;
        t1.im =-w[i1].re*d[ki2].im - w[i1].im*d[ki2].re;

        temp.re  =-w[i2].im*(d[ki1].re + t1.re) - w[i2].re*(d[ki1].im + t1.im);
        temp.im  =-w[i2].im*(d[ki1].im + t1.im) + w[i2].re*(d[ki1].re + t1.re);
        temp1.re =-w[i2].re*(d[ki1].re - t1.re) + w[i2].im*(d[ki1].im - t1.im);
        temp1.im =-w[i2].re*(d[ki1].im - t1.im) - w[i2].im*(d[ki1].re - t1.re);

        d[kii].re = d[ki].re - t.re + temp1.re;
        d[ki2].re = d[ki].re - t.re - temp1.re;
        d[kii].im = d[ki].im - t.im + temp1.im;
        d[ki2].im = d[ki].im - t.im - temp1.im;
        d[ki1].im = d[ki].im + t.im - temp.im;
        d[ki1].re = d[ki].re + t.re - temp.re;
        d[ki].im  = d[ki].im + t.im + temp.im;
        d[ki].re  = d[ki].re + t.re + temp.re;
      }  /* for i */
    }   /* for j */
    nn = istep;
    mmax <<= 2;
    istep <<= 2;
    ik1>>=2;
    ik2>>=2;
    if (nn < m) goto invnext;
  } /* for */

  if (m<n) {

    invnextB:

    i1 = i4 = 0;
    ik2 = ik1 << 1;
    for (i2=0; i2<nn; i2+=256,i4=i1) {
      kk = i2+nn;
      for (j=0; j<n; j += mmax) {
        i3 = i2+j;
        k=kk+j;
        i1 = i4;
        for (i=0 ; i<256; i+=2,i1+=ik2) {
          t.re = w[i1].re*d[k+i].re + w[i1].im*d[k+i].im;
          t.im =-w[i1].im*d[k+i].re + w[i1].re*d[k+i].im;
          t1.re = w[i1+ik1].re*d[k+i+1].re + w[i1+ik1].im*d[k+i+1].im;
          t1.im =-w[i1+ik1].im*d[k+i+1].re + w[i1+ik1].re*d[k+i+1].im;
          d[k+i].re = d[i+i3].re - t.re;
          d[k+i].im = d[i+i3].im - t.im;
          d[i+i3].re += t.re;
          d[i+i3].im += t.im;
          d[k+i+1].re = d[i+i3+1].re - t1.re;
          d[k+i+1].im = d[i+i3+1].im - t1.im;
          d[i+i3+1].re += t1.re;
          d[i+i3+1].im += t1.im;
        }  /* for i */
      }  /* for j */
    }  /* for i2 */
    nn = mmax;
    mmax <<= 1;
    ik1 >>= 1;
    if (nn<n) goto invnextB;
  } /* if */
    goto norm;
  inv:
    k = nn;
    nj = nn>>1;
    k1= k + nj;
    for (i=0; i<nj; i++) {
      t.im =-w[i].im*d[k+i].re + w[i].re*d[k+i].im;
      t.re = w[i].re*d[k+i].re + w[i].im*d[k+i].im;
      d[k+i].re = d[i].re - t.re;
      d[k+i].im = d[i].im - t.im;
      d[i].re += t.re;
      d[i].im += t.im;
      t.im =  w[i].re*d[k1+i].re + w[i].im*d[k1+i].im;
      t.re = w[i].im*d[k1+i].re - w[i].re*d[k1+i].im;
      d[k1+i].re = d[nj+i].re - t.re;
      d[k1+i].im = d[nj+i].im - t.im;
      d[nj+i].re += t.re;
      d[nj+i].im += t.im;
    }  /* for i */

    norm:

    /*t.re = 1.0/n;
    for (i=0; i<n; i++) {
        d[i].re *= t.re;
        d[i].im *= t.re;
    }*/ /* for */

    return;

} /* nspcUndRadix2_FFT */
#else

extern void
nspcUndRadix2_FFT(
  SCplx       *d,
  int          n,
  int          inv,
  const SCplx *w);

#endif

#if P5_OPT == 0
/*F*
//  Name :      nspcUndRealRecom_Fft
//  Purpose:    Internal function.
//              Computes  triginometric recombination of real signal
//              (in-place) using RCPerm format.
//  Arguments:
//        x   - Pointer to the real array which holds the input and
//              output complex samples.  The x[] array must be of length
//              pow(2,order+1),  where (order-1) - Base-2 logarithm
//              of the number of complex samples in FFT.
//        n   - pow(2,order-2).
//        is  - Indicates the direction of the fast Fourier transform:
//                 1 - forward transform,
//                -1 - inverse transform.
//        c   - Pointer to the table of special twiddle factors.
*F*/

void
nspcUndRealRecom_Fft(
   float  *x,
   int     n,
   int     is,
   float  *c)
{
   float   s1, s2, t3, t4, t1, t2;
   int     i, j;

   if ( n == 1 ) return;

   if ( is < 0 ) {                    /* inverse transform */

      for ( i=2, j=2*n-2 ; i < n ; i+=2, j-=2 ) {
         t2     = x[i+1] + x[j+1];
         t1     = x[ i ] - x[ j ];
         t4     = c[i-1]*t2 + c[i-2]*t1;
         x[j+1] = x[j+1] - t4;
         x[i+1] = x[i+1] - t4;
         t3     = c[i-2]*t2 - c[i-1]*t1;
         s1     = x[ i ] + t3;
         x[ j ] = x[ j ] - t3;
         x[ i ] = s1;
      } /* end for */

   } else {                           /* forward transform */

      for ( i=2, j=2*n-2 ; i < n ; i+=2, j-=2 ) {
         t2     = x[i+1] + x[j+1];
         t1     = x[ i ] - x[ j ];
         t4     = c[i-1]*t2 - c[i-2]*t1;
         t3     = c[i-2]*t2 + c[i-1]*t1;
         s1     = x[ j ] + t3;
         x[ j ] = x[ i ] - t3;
         x[ i ] = s1;
         s2     = -x[j+1] + t4;
         x[j+1] = -x[i+1] + t4;
         x[i+1] = s2;
      } /* end for */
      x[n+1] = -x[n+1];

   } /* end if */

   return;
}  /* nspcUndRealRecom_Fft */

#else

extern void
nspcUndRealRecom_Fft(
   float  *x,
   int     n,
   int     is,
   float  *c);

#endif

/*F*
//  Name :      nspcUndCcsRecom_Fft
//  Purpose:    Internal function.
//  Purpose:    Computes triginometric recombination for complex
//              conjugate-symmetric data (in-place) using RCPerm format.
//  Arguments:
//     x      - Pointer to the complex array which holds the input and
//              output complex samples.  The x[] array must be of length
//              N=pow(2,order+1).
//     order  - Base-2 logarithm of the number of samples in FFT  (N).
//     flags  - Indicates the direction of the fast Fourier transform.
//              Integer number in which every bit have next specifications:
//                 NSP_Forw - forward transform,
//                 NSP_Inv  - inverse transform.
//     expTbl - Pointer to the table of twiddle factors.
*F*/


static void
nspcUndCcsRecom_Fft(
   SCplx       *x,
   int          order,
   int          flags,
   const SCplx *expTbl)
{
  float         reTmp, imTmp, reSum, imSum, reDif, imDif;
  int           len, limit, k, l;

  len   = 1<<order;
  limit = len>>1;
  
  if ( limit ) {

     if ( flags & NSP_Forw ) {     /*  forward transform  */

        for ( k=1, l=len-k ; k < limit ; k++, l-- ) {
           reDif  = x[k].re - x[l].re;
           imDif  = x[k].im + x[l].im;
           reSum  = x[k].re + x[l].re;
           imSum  = x[k].im - x[l].im;
           imTmp   = reDif*expTbl[k].re - imDif*expTbl[k].im;
           x[k].im = imSum + imTmp;
           reTmp   =-reDif*expTbl[k].im - imDif*expTbl[k].re;
           x[l].im =-imSum + imTmp;
           x[k].re = reSum + reTmp;
           x[l].re = reSum - reTmp;
        } /* for */
        x[ limit ].re *= (float)2;
        x[ limit ].im *= (float)2;

     } else {                      /*  inverse transform  */

        for ( k=1, l=len-k ; k < limit ; k++, l-- ) {
           reDif  = x[k].re - x[l].re;
           imDif  = x[k].im + x[l].im;
           reSum  = x[k].re + x[l].re;
           imSum  = x[k].im - x[l].im;
           imTmp   = reDif*expTbl[k].re + imDif*expTbl[k].im;
           x[k].im = imSum + imTmp;
           reTmp   = reDif*expTbl[k].im - imDif*expTbl[k].re;
           x[l].im =-imSum + imTmp;
           x[k].re = reSum + reTmp;
           x[l].re = reSum - reTmp;
        } /* for */
        x[ limit ].re *= (float)2;
        x[ limit ].im *= -(float)2;

     } /* if for transform */

  } /* if ( limit ) */

  return;
} /* nspcUndCcsRecom_Fft */


void nspsbMpy1(const float val, float *dst, int n)
{
  float r0, r1, r2, r3;
  int k;


  for (k=n-8; k>=0; k-=8) {
     r0 = dst[k  ] * val;
     r1 = dst[k+1] * val;
     r2 = dst[k+2] * val;
     r3 = dst[k+3] * val;
     dst[k  ] = r0;
     dst[k+1] = r1;
     dst[k+2] = r2;
     dst[k+3] = r3;
     r0 = dst[k+4] * val;
     r1 = dst[k+5] * val;
     r2 = dst[k+6] * val;
     r3 = dst[k+7] * val;
     dst[k+4] = r0;
     dst[k+5] = r1;
     dst[k+6] = r2;
     dst[k+7] = r3;
   };
   for (k=k+7; k>=0; k--) {
       r0 = dst[k  ] * val;
       dst[k  ] = r0;
   };
}


/* ---------------------- FFTs of Real Signals ---------------------------- */

/*F*
//  Name:      nspsRealFft
//  Purpose:   Computes the forward or inverse fast Fourier transform (FFT)
//             of real signal (in-place) using RCCcs format.
//  Arguments:
//     samps - Pointer to the real array which holds the input and
//             output samples. The samps[] array must be of length
//             N+2 elements (float).  ( N=pow(2,order) ).
//             On input, samps[] should be considered as a real array,
//             the first N elements of which are data and the last two
//             elements are ignored.
//             On output, samps[] should be considered as a complex array
//             of length N/2+1 complex samples in RCCcs format.
//     order - Base-2 logarithm of the number of samples in FFT  (N).
//     flags - Indicates the direction of the fast Fourier transform.
//             Integer number in which every bit have next specifications:
//                NSP_Forw    - forward transform,
//                NSP_Inv     - inverse transform,
//                NSP_Init    - init of coeficient table without transform,
//                NSP_NoScale - in inverse transform absent to scale.
//  Calls:
//        nspcUndGetFftTwdTbl_great,
//        nspcbBitRev1,   
//        nspcUndSplit_FFT,
//        nspcUndRadix2_FFT,
//        nspcUndRealRecom_Fft,
//        nspsbMpy1.
*F*/

void vox_nspsRealFft(
   float       *samps,
   int          order,
   int          flags)
{
   int          p,                 /* For (order-1) */
                n,                 /* For pow(2,(order-1)) and pow(2,order) */
                inv_fl;            /* Transform flag: forward or inverse */
   const SCplx *w=NULL;            /* Table of twiddle factors */
   SCplx       *cx;                /* For interpretation samps as SCplx */
   float        Scale;             /* For scale in inverse transform */

   /* Computes the tables of twiddle factors */
        p = order-1;                                               
        if ( p > 0 ) {                                             
           w = nspcUndGetFftTwdTbl_great(p);                       
           if(!w) 
             return;
        }
        if ( flags & NSP_Init ) return;


   if ( order == 0 ) return;                               /* Control order */

   cx = (SCplx *)samps;      /* Form pointer cx for interpr. samps as SCplx */

   n = 1 << p;                                   /* Form  pow(2,(order-1))  */

   inv_fl = ( flags & NSP_Forw ) ? 1 : -1;           /* Form transform flag */

   if ( p > 0 ) {

      if ( p < FFT_OrderSplit )    {  /* ---------Split algorithm --------- */

         nspcUndSplit_FFT(cx,n,inv_fl,w);            /* Computes FFT for cx */
         nspcbBitRev1(cx,p);                         /* Form BitRev  for cx */

      } else                       {  /* ---------Radix algorithm --------- */

         nspcbBitRev1(cx,p);                         /* Form BitRev  for cx */
         nspcUndRadix2_FFT(cx,n,inv_fl,w);           /* Computes FFT for cx */

      } /* if for algorithm type */

   } /* if for p */

   Scale      = samps[0] - samps[1];         /* Triginometric recombination */
   samps[0]   = samps[0] + samps[1];
   samps[1]   = (float)0.0;
   nspcUndRealRecom_Fft(samps,n,inv_fl,(float *)(w+n/2));
   n          = 1 << order;
   samps[n  ] = Scale;
   samps[n+1] = (float)0.0;

         if ( flags & NSP_Inv ) {                                   
           if ( !( flags & NSP_NoScale ) ) {                       
              Scale    = (float)(1.0/n);                          
              nspsbMpy1(Scale,samps,n+2);                           
           }                                                       
        }
   return;
} /* nspsRealFft */


/* --------------------- FFTs of Conjugate-symmetric Signals -------------- */

/*F*
//  Name:       nspsCcsFft
//  Purpose:    Computes the forward or inverse fast Fourier transform (FFT)
//              of a complex conjugate symmetric (CCS) signal
//              using RCCcs format (in-place).
//  Arguments:
//      samps - Pointer to the real array which holds the input and
//              output samples. The samps[] array must be of length N+2
//              (N=pow(2,order))  elements (float).
//              On input, samps[] should be considered as a complex array
//              of length N/2+1 complex samples in RCCcs format.
//              On output, samps[] should be considered as a real array,
//              the first N elements of which are data and the last two
//              elements are ignored.
//      order - Base-2 logarithm of the number of samples in FFT  (N).
//      flags - Indicates the direction of the fast Fourier transform.
//              Integer number in which every bit have next specifications:
//                 NSP_Forw    - forward transform,
//                 NSP_Inv     - inverse transform,
//                 NSP_Init    - init of coeficient table without transform,
//                 NSP_NoScale - in inverse transform absent to scale.
//  Calls:
//        nspcUndGetFftTwdTbl_great,
//        nspcUndCcsRecom_Fft,
//        nspcbBitRev1,
//        nspcUndSplit_FFT,
//        nspcUndRadix2_FFT,
//        nspsbMpy1.
*F*/

void vox_nspsCcsFft(
   float       *samps,
   int          order,
   int          flags)
{
   int          p,                   /* For (order-1) */
                n,                   /* For pow(2,order) */
                n2,                  /* For pow(2,order-1) */
                inv_fl;              /* Transform flag: forward or inverse */
   const SCplx *w=NULL;              /* Table of twiddle factors (order-1) */
   SCplx       *cx;                  /* For interpretation samps as SCplx */
   float        Scale,               /* For scale in inverse transform */
                Zcale;

   /* Computes the tables of twiddle factors */

   p = order-1;                                                
   if ( p > 0 ) {                                              
      w = nspcUndGetFftTwdTbl_great(p);                        
      if(!w) 
        return;
   }

   if ( order == 0 ) return;                               /* Control order */

   n     = 1 << order;                                 /* Form pow(2,order) */

   Scale = samps[0] + samps[n];          /* for triginometric recombination */
   Zcale = samps[0] - samps[n];

   if ( p > 0 ) {

      cx = (SCplx *)samps;   /* Form pointer cx for interpr. samps as SCplx */
      n2 = 1 << p;                                   /* Form pow(2,order-1) */
      inv_fl = ( flags & NSP_Forw ) ? 1 : -1;        /* Form transform flag */

      nspcUndCcsRecom_Fft(cx,p,flags,(w+n2));     /* Computes trig. recomb. */
      samps[0] = Scale;
      samps[1] = Zcale;

      if ( p < FFT_OrderSplit )    {  /* ---------Split algorithm --------- */

         nspcUndSplit_FFT(cx,n2,inv_fl,w);           /* Computes FFT for cx */
         nspcbBitRev1(cx,p);                         /* Form BitRev  for cx */

      } else                       {  /* ---------Radix algorithm --------- */

         nspcbBitRev1(cx,p);                         /* Form BitRev  for cx */
         nspcUndRadix2_FFT(cx,n2,inv_fl,w);          /* Computes FFT for cx */

      } /* if for algorithm type */

   }  else  {   /* p == 0 */
      samps[0] = Scale; samps[1] = Zcale;
   }  /* if for p */

   if ( flags & NSP_Inv ) {                                    
      if ( !( flags & NSP_NoScale ) ) {                        
         Scale    = (float)(1.0/n);                                  
         nspsbMpy1(Scale,samps,n);                            
      }                                                        
   }

   return;
} /* nspsCcsFft */







/* ------------------------- Basic FFT functions -------------------------- */
/*F*
//  Name:      nspcFft
//  Purpose:   Computes the forward or inverse fast Fourier transform (FFT)
//             of complex signal (in-place).
//  Arguments:
//     samps - Pointer to the complex array which holds the input and
//             output complex samples.  The samps[] array
//             must be of length N=pow(2,order).
//     order - Base-2 logarithm of the number of samples in FFT  (N).
//     flags - Indicates the direction of the fast Fourier transform and
//             whether bit-reversal is performed.
//             Integer number in which every bit have next specifications:
//                NSP_Forw      - forward transform,
//                NSP_Inv       - inverse transform,
//                NSP_Init      - init of coeficient table without transform,
//                NSP_NoScale   - in inverse transform absent to scale,
//                NSP_NoBitRev  - input and output signals in normal order,
//                NSP_InBitRev  - input  signal in bit-reverse,
//                NSP_OutBitRev - output signal in bit-reverse.
//  Calls:
//        nspcUndGetFftTwdTbl_great,
//        nspsUndControlFlags_Fft,
//        nspcbBitRev1,
//        nspcUndSplit_FFT,
//        nspcUndRadix2_FFT,
//        nspsbMpy1.
*F*/


void
vox_nspcFft(
   SCplx       *samps,
   int          order,
   int          flags)
{
   int          n,                 /* Length of signal */
                inv_fl;            /* Transform flag: forward or inverse */
   const SCplx *w;                 /* Table of twiddle factors */
   float        Scale;             /* For scale in inverse transform */

   /* Computes the table of twiddle factors */
   w = nspcUndGetFftTwdTbl_great(order);                       

   /* Control argument flags: NSP_NoBitRev, NSP_InBitRev, NSP_OutBitRev */
   if ( ! ( (flags & NSP_InBitRev ) |                          
            (flags & NSP_OutBitRev) |                          
            (flags & NSP_NoBitRev ) ) ) 
   {                      
      flags = flags | NSP_NoBitRev;                            
   }

   if ( order == 0 )  return;                     /* Control order */

   n = 1 << order;                                /* Form length of signal */

   inv_fl = ( flags & NSP_Forw ) ? 1 : -1;        /* Form transform flag */

   if ( order < FFT_OrderSplit )   {  /* ---------Split algorithm --------- */

      if ( flags & NSP_InBitRev ) {               /* Control NSP_InBitRev */
         nspcbBitRev1(samps,order);
      }
      nspcUndSplit_FFT(samps,n,inv_fl,w);         /* Computes FFT */
      if ( !( flags & NSP_OutBitRev ) ) {         /* Control NSP_OutBitRev */
         nspcbBitRev1(samps,order);
      }

   } else                          {  /* ---------Radix algorithm --------- */

      if ( !( flags & NSP_InBitRev ) ) {          /* Control NSP_InBitRev */
         nspcbBitRev1(samps,order);
      }
      nspcUndRadix2_FFT(samps,n,inv_fl,w);        /* Computes FFT */
      if ( flags & NSP_OutBitRev ) {              /* Control NSP_OutBitRev */
         nspcbBitRev1(samps,order);
      }

   } /* if for algorithm type */

   /* Control NSP_Inv and NSP_NoScale */
   if ( flags & NSP_Inv ) 
   {                                    
      if ( !( flags & NSP_NoScale ) ) 
      {                        
          Scale    = (float)(1.0/n);                           
          nspsbMpy1(Scale,(float *)samps,n*2);                           
      }                                                        
   }

   return;
}  /* nspcFft */

// nsp forgot to free their resources???!!!!  so I guess I have to do it!
void nspFreeFftResources() 
{
   unsigned short i;
   for(i=0;i<32;i++) 
      if(ctxFftTbl[i]) {
         free(ctxFftTbl[i]);
         ctxFftTbl[i]=NULL;
      }

   for(i=0;i<32;i++)
      if(ctxRevTbl[i]) {
         free(ctxRevTbl[i]);
         ctxRevTbl[i]=NULL;
      }


   return;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\pack24.h ===
#ifndef PACK24_H
#define PACK24_H

unsigned short VoxPackRT24(void *pvQuan_mblk,unsigned char *PacketBuffer,
				unsigned short *ByteOffset,  unsigned char *BitOffset,
            unsigned short BufferSize);


unsigned short VoxUnPackRT24(void *pvQuan_mblk, unsigned char *PacketBuffer,
				unsigned short *ByteOffset,  unsigned char *BitOffset,
            unsigned short BufferSize);

#endif /* PACK24_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\pack12.c ===
/*
 *  File:       PackRT29.c
 *
 *  Project:    RT29 codec.
 *          
 *  By:         Rob Zopf  09/12/95
 *
 *  Contains:   do quantization of all the parameters for codec for compression ID 51
 * 
 *  OS:         ANSI
 *
 *  Machine:    SPARC 5
 *      
 *		Voxware Proprietary Material
 *		Copyright 1996, Voxware, Inc.
 *		All Rights Resrved
 *
 *		DISTRIBUTION PROHIBITED without
 *		written authorization from Voxware
 *
 *  Modified and Rewritten by Wei Wang,  2/13/96
 *
 * $Header:   /export/phobos/pvcs/r_and_d/archives/realtime/pack/Pack12.c_v   1.1   16 Feb 1998 15:47:50   bobd  $
 */ 
#include <string.h>
#include <assert.h>

#include "VoxMem.h"
#include "vLibPack.h" /* BitPackCBuffer(), BitUnpackCBuffer() */
#include "quanvr12.h"

#include "Quan12.h"

#include "Pack12.h"

#include "xvocver.h"

unsigned short VoxPackVR12(void *pvQuan_mblk, unsigned char *PacketBuffer,
                   unsigned short *ByteOffset,  unsigned char *BitOffset,
                   unsigned short BufferSize)
{
  QUAN_12 *Quan_mblk = (QUAN_12 *)pvQuan_mblk;
  int i;

  C_BUFFER_TYPE CBuffer; 

  CBuffer.wBufferSize = BufferSize;
  CBuffer.pBufferWriteByteOffset = ByteOffset;
  CBuffer.pBufferWriteBitOffset  = BitOffset;
  CBuffer.pBuffer = PacketBuffer;                                       


  BitPackCBuffer(&CBuffer, (unsigned char)Quan_mblk->Class, CLASS_BITS_VR12);

  if (Quan_mblk->Class==UV_FRAME)
  {
     for (i=0; i<NUMSTAGES_LSPVQ_VR12_UNVOICED; i++)
        BitPackCBuffer(&CBuffer, (unsigned char)Quan_mblk->Lsf_INDEX[i], TABLEBITS_LSPVQ_VR12);

     BitPackCBuffer(&CBuffer, (unsigned char)Quan_mblk->Energy_INDEX, GAIN_BITS_VR12_UNVOICED);
  }
  if (Quan_mblk->Class==MIX_FRAME)
  {
     BitPackCBuffer(&CBuffer, (unsigned char)Quan_mblk->Pv_INDEX, PV_BITS_VR12_MIXED);
     BitPackCBuffer(&CBuffer, (unsigned char)Quan_mblk->Pitch_INDEX, F0_BITS_VR12_MIXED);
     for (i=0; i<NUMSTAGES_LSPVQ_VR12_MIXED; i++)
        BitPackCBuffer(&CBuffer, (unsigned char)Quan_mblk->Lsf_INDEX[i], TABLEBITS_LSPVQ_VR12);

     BitPackCBuffer(&CBuffer, (unsigned char)Quan_mblk->Energy_INDEX, GAIN_BITS_VR12_MIXED);
  }

  if (Quan_mblk->Class==V_FRAME)
  {
     BitPackCBuffer(&CBuffer, (unsigned char)Quan_mblk->Pitch_INDEX, F0_BITS_VR12_VOICED);
     for (i=0; i<NUMSTAGES_LSPVQ_VR12_VOICED; i++)
        BitPackCBuffer(&CBuffer, (unsigned char)Quan_mblk->Lsf_INDEX[i], TABLEBITS_LSPVQ_VR12);

     BitPackCBuffer(&CBuffer, (unsigned char)Quan_mblk->Energy_INDEX, GAIN_BITS_VR12_VOICED);
  }



  return 0;
}

unsigned short VoxUnPackVR12(void *pvQuan_mblk, unsigned char *PacketBuffer,
				unsigned short *ByteOffset,  unsigned char *BitOffset,
            unsigned short BufferSize)
{
  QUAN_12 *Quan_mblk = (QUAN_12 *)pvQuan_mblk;
  unsigned char pC;
  int i;

  C_BUFFER_TYPE CBuffer;
  
  CBuffer.wBufferSize = BufferSize;
  CBuffer.pBufferReadByteOffset = ByteOffset;
  CBuffer.pBufferReadBitOffset  = BitOffset;
  CBuffer.pBuffer = PacketBuffer;                                       


  BitUnpackCBuffer(&CBuffer, &pC, CLASS_BITS_VR12);
  Quan_mblk->Class = (short)pC;
  if (Quan_mblk->Class==UV_FRAME)
  {
     for (i=0; i<NUMSTAGES_LSPVQ_VR12_UNVOICED;i++)
     {
        BitUnpackCBuffer(&CBuffer, &pC, TABLEBITS_LSPVQ_VR12);
        Quan_mblk->Lsf_INDEX[i] = (short)pC;
     }
     BitUnpackCBuffer(&CBuffer, &pC, GAIN_BITS_VR12_UNVOICED);
     Quan_mblk->Energy_INDEX = (short)pC;
  }
  if (Quan_mblk->Class==MIX_FRAME)
  {
     BitUnpackCBuffer(&CBuffer, &pC, PV_BITS_VR12_MIXED);
     Quan_mblk->Pv_INDEX = (short)pC;
     BitUnpackCBuffer(&CBuffer, &pC, F0_BITS_VR12_MIXED);
     Quan_mblk->Pitch_INDEX = (short)pC;
     for (i=0; i<NUMSTAGES_LSPVQ_VR12_MIXED;i++)
     {
        BitUnpackCBuffer(&CBuffer, &pC, TABLEBITS_LSPVQ_VR12);
        Quan_mblk->Lsf_INDEX[i] = (short)pC;
     }
     BitUnpackCBuffer(&CBuffer, &pC, GAIN_BITS_VR12_MIXED);
     Quan_mblk->Energy_INDEX = (short)pC;
  }

  if (Quan_mblk->Class==V_FRAME)
  {
     BitUnpackCBuffer(&CBuffer, &pC, F0_BITS_VR12_VOICED);
     Quan_mblk->Pitch_INDEX = (short)pC;
     for (i=0; i<NUMSTAGES_LSPVQ_VR12_VOICED;i++)
     {
        BitUnpackCBuffer(&CBuffer, &pC, TABLEBITS_LSPVQ_VR12);
        Quan_mblk->Lsf_INDEX[i] = (short)pC;
     }
     BitUnpackCBuffer(&CBuffer, &pC, GAIN_BITS_VR12_VOICED);
     Quan_mblk->Energy_INDEX = (short)pC;
  }


  return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\pack29.h ===
#ifndef PACK29_H
#define PACK29_H

unsigned short VoxPackRT29(void *pvQuan_mblk,unsigned char *PacketBuffer,
				unsigned short *ByteOffset,  unsigned char *BitOffset,
            unsigned short BufferSize);


unsigned short VoxUnPackRT29(void *pvQuan_mblk, unsigned char *PacketBuffer,
				unsigned short *ByteOffset,  unsigned char *BitOffset,
            unsigned short BufferSize);

#endif /* PACKRT29_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\pack28.h ===
#ifndef PACK28_H
#define PACK28_H

unsigned short VoxPackRT28(void *pvQuan_mblk,unsigned char *PacketBuffer,
				unsigned short *ByteOffset,  unsigned char *BitOffset,
            unsigned short BufferSize);


unsigned short VoxUnPackRT28(void *pvQuan_mblk, unsigned char *PacketBuffer,
				unsigned short *ByteOffset,  unsigned char *BitOffset,
            unsigned short BufferSize);

#endif /* PACK28_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\packsc.c ===
/******************************************************************************
*                        Voxware Proprietary Material
*                        Copyright 1996, Voxware, Inc
*                            All Rights Reserved
*
*                       DISTRIBUTION PROHIBITED without
*                      written authorization from Voxware
******************************************************************************/
 
/******************************************************************************
* Filename:      PackSC.c
*
* Purpose:       Bit packing for SC36 codecs
*
* Functions:     VoxPackSC3, VoxPackSC6, VoxUnPackSC3, VoxUnPackSC6
*
* Author/Date:   Bob Dunn (scarfed code from Zopf/Wang)
*******************************************************************************
*
* Modifications:
*
* Comments:
*
* Concerns:
*
*    WARNING: This code is currently hard wired and will not work with 
*               various multiple quan_files!
*
* $Header:   /export/phobos/pvcs/r_and_d/archives/scaleable/pack/PackSC.c_v   1.7   13 Apr 1998 16:17:36   weiwang  $
*
******************************************************************************/
#include <string.h>
#include <assert.h>

#include "vLibPack.h"
#include "VoxMem.h"
#include "codec.h"
#include "quansc36.h"

#include "CodeStr.h"

#include "PackSC.h"

#include "xvocver.h"


const static short BitTable_SC3[TOTAL_SC3_QUAN_INDICES] = {
BITS_PITCH_SC3, BITS_GAIN_SC3, BITS_PV_SC3,
STAGE1_BITS_ASKS_0_1_SC36, STAGE2_BITS_ASKS_0_1_SC36,
STAGE1_BITS_ASKS_2_3_SC36, STAGE2_BITS_ASKS_2_3_SC36,
STAGE1_BITS_ASKS_4_5_SC36, STAGE2_BITS_ASKS_4_5_SC36,
STAGE1_BITS_ASKS_6_7_SC36, STAGE2_BITS_ASKS_6_7_SC36,
STAGE1_BITS_ASKS_8_9_SC36, STAGE2_BITS_ASKS_8_9_SC36,
STAGE1_BITS_ASKS_10_11_SC36, STAGE2_BITS_ASKS_10_11_SC36,
RESERVED_BITS_SC3, VCI_FLAG_BITS_SC3
};

const static short BitTable_SC6[EXTRA_SC6_QUAN_INDICES] = {
RESIDUAL_BITS_ASKS_8_9_SC6,
RESIDUAL_BITS_ASKS_10_11_SC6,
BITS_PHASE_PAIR_SC6, BITS_PHASE_PAIR_SC6, 
BITS_PHASE_PAIR_SC6, BITS_PHASE_PAIR_SC6, 
BITS_PHASE_PAIR_SC6, BITS_PHASE_PAIR_SC6, 
BITS_PHASE_PAIR_SC6, BITS_PHASE_PAIR_SC6,
RESERVED_BITS_SC6, VCI_FLAG_BITS_SC6
};

#ifndef DECODE_ONLY
/******************************************************************************
*
* Function:  VoxPackSC3
*
* Action:    Pack quantization indices for SC3
*
* Input:     piQuanIndex -- quantization indices
*            pchPacketBuffer -- start pointer to the packet buffer
*            psByteOffset -- the pointer to the write byte offset
*            pchBitOffset -- the pointer to the write bit offset
*            sBufferSize -- packet buffer size
*            sLongerFrameFlag -- continuous flag
*
* Output:    pchPacketBuffer -- bit packed buffer
*            psByteOffset -- updated write byte offset
*            pchBitOffset -- updated write bit offset
*
* Globals:   none
*
* Return:    void
*******************************************************************************
*
* Implementation/Detailed Description:
*
* References:
*******************************************************************************
*
* Modifications:
*
* Comments:  
*
* Concerns/TBD:
******************************************************************************/

void VoxPackSC3(int *piQuanIndex, unsigned char  *pchPacketBuffer,
                unsigned short *psByteOffset, unsigned char  *pchBitOffset,
                unsigned short  sBufferSize, unsigned short  sLongerFrameFlag)
{
  C_BUFFER_TYPE  CBuffer; 
  int i;

  /*-------------------------------------------------------------------
    Error checking 
  --------------------------------------------------------------------*/
  assert(piQuanIndex != NULL && pchPacketBuffer != NULL);
  assert(psByteOffset != NULL && pchBitOffset != NULL);


  CBuffer.wBufferSize = sBufferSize;
  CBuffer.pBufferWriteByteOffset = psByteOffset;
  CBuffer.pBufferWriteBitOffset  = pchBitOffset;
  CBuffer.pBuffer = pchPacketBuffer;                                       

  /*---------------------------------------------------
    Set for reserved bit
    --------------------------------------------------*/
   piQuanIndex[INDEX_RESERVE_BIT_SC3] = 0;

  /*---------------------------------------------------
    Set for longer frame flag
    --------------------------------------------------*/
   piQuanIndex[INDEX_FLAG_BIT_SC3] = sLongerFrameFlag;

  /*--------------------------------------------------------------------
    Pack All
  --------------------------------------------------------------------*/
  for (i = 0; i < TOTAL_SC3_QUAN_INDICES; i++) 
    BitPackCBuffer(&CBuffer, (unsigned char)piQuanIndex[i], BitTable_SC3[i]);
}


/******************************************************************************
*
* Function:  VoxPackSC6
*
* Action:    Pack quantization indices for SC6
*
* Input:     piQuanIndex -- quantization indices
*            pchPacketBuffer -- start pointer to the packet buffer
*            psByteOffset -- the pointer to the write byte offset
*            pchBitOffset -- the pointer to the write bit offset
*            sBufferSize -- packet buffer size
*            sLongerFrameFlag -- continuous flag
*
* Output:    pchPacketBuffer -- bit packed buffer
*            psByteOffset -- updated write byte offset
*            pchBitOffset -- updated write bit offset
*
* Globals:   none
*
* Return:    void
*******************************************************************************
*
* Implementation/Detailed Description:
*
* References:
*******************************************************************************
*
* Modifications:
*
* Comments:  
*
* Concerns/TBD:
******************************************************************************/

void VoxPackSC6(int *piQuanIndex, unsigned char  *pchPacketBuffer,
                unsigned short *psByteOffset, unsigned char  *pchBitOffset,
                unsigned short  sBufferSize, unsigned short  sLongerFrameFlag)
{
  C_BUFFER_TYPE  CBuffer; 
  int i;

  /*-------------------------------------------------------------------
    Error checking 
  --------------------------------------------------------------------*/
  assert(piQuanIndex != NULL && pchPacketBuffer != NULL);
  assert(psByteOffset != NULL && pchBitOffset != NULL);

  CBuffer.wBufferSize = sBufferSize;
  CBuffer.pBufferWriteByteOffset = psByteOffset;
  CBuffer.pBufferWriteBitOffset  = pchBitOffset;
  CBuffer.pBuffer = pchPacketBuffer;                                       


  /*---------------------------------------------------
    Set for reserved bit
    --------------------------------------------------*/
   piQuanIndex[INDEX_RESERVE_BIT_SC6] = 0;

  /*---------------------------------------------------
    Set for longer frame flag
    --------------------------------------------------*/
   piQuanIndex[INDEX_FLAG_BIT_SC6] = sLongerFrameFlag;

  /*--------------------------------------------------------------------
    Pack Phase VQ indices 
  --------------------------------------------------------------------*/
  for (i = 0; i < EXTRA_SC6_QUAN_INDICES; i++)
    BitPackCBuffer(&CBuffer, (unsigned char)piQuanIndex[i], BitTable_SC6[i]);

}
#endif

/******************************************************************************
*
* Function:  VoxUnPackSC3
*
* Action:    Unpack quantization indices for SC3
*
* Input:     piQuanIndex -- pointer to the quantization indices
*            pchPacketBuffer -- packet buffer
*            psByteOffset -- the pointer to the read byte offset
*            pchBitOffset -- the pointer to the read bit offset
*            sBufferSize -- packet buffer size
*            psLongerFrameFlag -- pointer to the continuous flag
*
* Output:    piQuanIndex -- unpacked quantization indices
*            psByteOffset -- updated read byte offset
*            pchBitOffset -- updated read bit offset
*            psLongerFrameFlag -- continuous flag
*
* Globals:   none
*
* Return:    void
*******************************************************************************
*
* Implementation/Detailed Description:
*
* References:
*******************************************************************************
*
* Modifications:
*
* Comments:  
*
* Concerns/TBD:
******************************************************************************/

void VoxUnPackSC3(int *piQuanIndex, unsigned char *pchPacketBuffer,
                  unsigned short *psByteOffset, unsigned char *pchBitOffset,
                  unsigned short sBufferSize, unsigned short *psLongerFrameFlag)
{
  unsigned char pC;
  int i;

  C_BUFFER_TYPE CBuffer;

  /*-------------------------------------------------------------------
    Error checking 
  --------------------------------------------------------------------*/
  assert(piQuanIndex != NULL && pchPacketBuffer != NULL);
  assert(psByteOffset != NULL && pchBitOffset != NULL);
  assert(psLongerFrameFlag != NULL);
  
  CBuffer.wBufferSize = sBufferSize;
  CBuffer.pBufferReadByteOffset = psByteOffset;
  CBuffer.pBufferReadBitOffset  = pchBitOffset;
  CBuffer.pBuffer = pchPacketBuffer;                                       

  /*--------------------------------------------------------------------
    unpack all
  --------------------------------------------------------------------*/
  for (i = 0; i < TOTAL_SC3_QUAN_INDICES; i++) {
    BitUnpackCBuffer(&CBuffer, &pC, BitTable_SC3[i]);
    piQuanIndex[i] = (int)pC;
  }


  /*---------------------------------------------------
    Set for longer frame flag
    --------------------------------------------------*/
   *psLongerFrameFlag = (unsigned short)piQuanIndex[INDEX_FLAG_BIT_SC3];
}

/******************************************************************************
*
* Function:  VoxUnPackSC6
*
* Action:    Unpack quantization indices for SC6
*
* Input:     piQuanIndex -- pointer to the quantization indices
*            pchPacketBuffer -- packet buffer
*            psByteOffset -- the pointer to the read byte offset
*            pchBitOffset -- the pointer to the read bit offset
*            sBufferSize -- packet buffer size
*            psLongerFrameFlag -- pointer to the continuous flag
*
* Output:    piQuanIndex -- unpacked quantization indices
*            psByteOffset -- updated read byte offset
*            pchBitOffset -- updated read bit offset
*            psLongerFrameFlag -- continuous flag
*
* Globals:   none
*
* Return:    void
*******************************************************************************
*
* Implementation/Detailed Description:
*
* References:
*******************************************************************************
*
* Modifications:
*
* Comments:  
*
* Concerns/TBD:
******************************************************************************/

void VoxUnPackSC6(int *piQuanIndex, unsigned char *pchPacketBuffer,
                  unsigned short *psByteOffset, unsigned char *pchBitOffset,
                  unsigned short sBufferSize, unsigned short *psLongerFrameFlag)
{
  unsigned char pC;
  int i;
  C_BUFFER_TYPE CBuffer;

  /*-------------------------------------------------------------------
    Error checking 
  --------------------------------------------------------------------*/
  assert(piQuanIndex != NULL && pchPacketBuffer != NULL);
  assert(psByteOffset != NULL && pchBitOffset != NULL);
  assert(psLongerFrameFlag != NULL);

  CBuffer.wBufferSize = sBufferSize;
  CBuffer.pBufferReadByteOffset = psByteOffset;
  CBuffer.pBufferReadBitOffset  = pchBitOffset;
  CBuffer.pBuffer = pchPacketBuffer;                                       

  /*--------------------------------------------------------------------
    Unpack all
  --------------------------------------------------------------------*/
  for (i = 0; i < EXTRA_SC6_QUAN_INDICES; i++)
    {
      BitUnpackCBuffer(&CBuffer, &pC, BitTable_SC6[i]);
      piQuanIndex[i] = (int)pC;
    }

  *psLongerFrameFlag = (unsigned short)piQuanIndex[INDEX_FLAG_BIT_SC6];
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\packsc.h ===
/******************************************************************************
*                        Voxware Proprietary Material
*                        Copyright 1996, Voxware, Inc
*                            All Rights Reserved
*
*                       DISTRIBUTION PROHIBITED without
*                      written authorization from Voxware
******************************************************************************/
 
/******************************************************************************
* Filename:      PackSC.h
*
* Purpose:       Bit packing for SC36 codecs
*
* Functions:     VoxPackSC3, VoxPackSC6, VoxUnPackSC3, VoxUnPackSC6
*
* Author/Date:   Bob Dunn (scarfed code from Zopf/Wang)
*******************************************************************************
*
* Modifications:
*
* Comments:
*
* Concerns:
*
*    WARNING: This code is currently hard wired and will not work with 
*               various multiple quan_files!
*
* $Header:   /export/phobos/pvcs/r_and_d/archives/scaleable/pack/PackSC.h_v   1.6   06 Apr 1998 17:32:44   weiwang  $
*
******************************************************************************/
#ifndef _PACKSC_H
#define _PACKSC_H

/******************************************************************************
*
* Function:  VoxPackSC3
*
* Action:    Pack quantization indices for SC3
*
* Input:     piQuanIndex -- quantization indices
*            pchPacketBuffer -- start pointer to the packet buffer
*            psByteOffset -- the pointer to the write byte offset
*            pchBitOffset -- the pointer to the write bit offset
*            sBufferSize -- packet buffer size
*            sLongerFrameFlag -- continuous flag

* Output:    pchPacketBuffer -- bit packed buffer
*            psByteOffset -- updated write byte offset
*            pchBitOffset -- updated write bit offset
*
* Globals:   none
*
* Return:    void
*******************************************************************************/

void VoxPackSC3(int *piQuanIndex, unsigned char  *pchPacketBuffer,
                unsigned short *psByteOffset, unsigned char  *pchBitOffset,
                unsigned short  sBufferSize, unsigned short  sLongerFrameFlag);


/******************************************************************************
*
* Function:  VoxPackSC6
*
* Action:    Pack quantization indices for SC6
*
* Input:     piQuanIndex -- quantization indices
*            pchPacketBuffer -- start pointer to the packet buffer
*            psByteOffset -- the pointer to the write byte offset
*            pchBitOffset -- the pointer to the write bit offset
*            sBufferSize -- packet buffer size
*            sLongerFrameFlag -- continuous flag

* Output:    pchPacketBuffer -- bit packed buffer
*            psByteOffset -- updated write byte offset
*            pchBitOffset -- updated write bit offset
*
* Globals:   none
*
* Return:    void
*******************************************************************************/

void VoxPackSC6(int *piQuanIndex, unsigned char *pchPacketBuffer,
                unsigned short *psByteOffset, unsigned char  *pchBitOffset,
                unsigned short  sBufferSize, unsigned short  sLongerFrameFlag);

/******************************************************************************
*
* Function:  VoxUnPackSC3
*
* Action:    Unpack quantization indices for SC3
*
* Input:     piQuanIndex -- pointer to the quantization indices
*            pchPacketBuffer -- packet buffer
*            psByteOffset -- the pointer to the read byte offset
*            pchBitOffset -- the pointer to the read bit offset
*            sBufferSize -- packet buffer size
*            psLongerFrameFlag -- pointer to the continuous flag
*
* Output:    piQuanIndex -- unpacked quantization indices
*            psByteOffset -- updated read byte offset
*            pchBitOffset -- updated read bit offset
*            psLongerFrameFlag -- continuous flag
*
* Globals:   none
*
* Return:    void
*******************************************************************************/

void VoxUnPackSC3(int *piQuanIndex, unsigned char *pchPacketBuffer,
                  unsigned short *psByteOffset, unsigned char *pchBitOffset,
                  unsigned short psBufferSize, unsigned short *psLongerFrameFlag);


/******************************************************************************
*
* Function:  VoxUnPackSC6
*
* Action:    Unpack quantization indices for SC6
*
* Input:     piQuanIndex -- pointer to the quantization indices
*            pchPacketBuffer -- packet buffer
*            psByteOffset -- the pointer to the read byte offset
*            pchBitOffset -- the pointer to the read bit offset
*            sBufferSize -- packet buffer size
*            psLongerFrameFlag -- pointer to the continuous flag
*
* Output:    piQuanIndex -- unpacked quantization indices
*            psByteOffset -- updated read byte offset
*            pchBitOffset -- updated read bit offset
*            psLongerFrameFlag -- continuous flag
*
* Globals:   none
*
* Return:    void
*******************************************************************************/

void VoxUnPackSC6(int *piQuanIndex, unsigned char *pchPacketBuffer,
                  unsigned short *psByteOffset, unsigned char *pchBitOffset,
                  unsigned short sBufferSize, unsigned short *psLongerFrameFlag);

#endif /* _PACKSC_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\param.h ===
/*******************************************************************************
*                        Voxware Proprietary Material                          *
*                        Copyright 1996, Voxware, Inc                          *
*                            All Rights Reserved                               *
*                                                                              *
*                       DISTRIBUTION PROHIBITED without                        *
*                      written authorization from Voxware                      *
*******************************************************************************/

/*******************************************************************************
* Filename:       param.h                                                             
*                                                                              
* Purpose:                                                                    
*                                                                              
* Author/Date:    Ilan Berci 09/96                                                             
********************************************************************************
* $Header:   /export/phobos/pvcs/r_and_d/archives/realtime/utils/param.h_v   1.2   01 Dec 1998 14:38:02   zopf  $                                                                     
*******************************************************************************/
#ifndef PARAM_H
#define PARAM_H

#define INITIAL_PITCH  100.0F

#define INITIAL_LSF_0  343.0F
#define INITIAL_LSF_1  752.0F
#define INITIAL_LSF_2 1176.0F
#define INITIAL_LSF_3 1536.0F
#define INITIAL_LSF_4 1841.0F
#define INITIAL_LSF_5 2189.0F
#define INITIAL_LSF_6 2463.0F
#define INITIAL_LSF_7 2854.0F
#define INITIAL_LSF_8 3171.0F
#define INITIAL_LSF_9 3555.0F

/***** Parameter structure *****/
typedef struct            /** all members of this structure need to be used in encoder **/
{
  float Pv;               /** voice probability                                        **/
  float Pitch;            /** pitch value                                              **/
  float Energy;           /** residue energy                                           **/
  float *Lsf;             /** line spectrum frequencies -- 10 point                    **/
  float *Amp;             /** residue amplitude -- 60 point                            **/
  float *Alpc;
  float *Blpc;            /** for backward compatibility - VFII - see John or Wei      **/
  short VAD;

} PARAM;

typedef struct tagPrevFrameParam
{
   float Pitch;
   float Pv;
   float Energy;
   float *Amp;
   float *Lsf;
} PrevFrameParam;

typedef struct tagSubFrameParam
{
   float                        Pitch;
   float                        Pv;
   float                        Energy;
   float                        *Amp;
   float                        *Lsf;
   float                        Pitch_1;                /* _1 = prev sub frame */
   float                        Pv_1;
   float                        Energy_1;
   float                        *Amp_1;
   float                        *Lsf_1;

   short                        WarpFrame;
   short                        totalWarpFrame;
   short                        frameLEN;               /* current frame len */
   short                        nSubs;
   
   float                        *AveLsf;
   int                          Hangover;

} SubFrameParam;


unsigned short VoxFreeParam(void **pParam);
unsigned short VoxInitParam(void **hParam, void *pVemMem);

unsigned short VoxInitPrevFrame(void **hPrevFrameParam_mblk);
unsigned short VoxFreePrevFrame(void **hPrevFrameParam_mblk);

unsigned short VoxInitSubframe(void **hSubFrameParam_mblk);
unsigned short VoxFreeSubframe(void **hSubFrameParam_mblk);

#endif /* PARAM_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\pask12uv.h ===
/******************************************************************************
*                        Voxware Proprietary Material
*                        Copyright 1996, Voxware, Inc
*                            All Rights Reserved
*
*                       DISTRIBUTION PROHIBITED without
*                      written authorization from Voxware
******************************************************************************/
 
/******************************************************************************
* Filename:    PASK12UV.h
*
* Purpose:     predictor vector of unvoiced frame for each code-vectors 
*              -- size: 2*(2+4+6+8+10)
*
* $Header:   /export/phobos/pvcs/r_and_d/archives/scaleable/tables/PASK12UV.h_v   1.0   06 Feb 1998 10:12:34   johnp  $
*
******************************************************************************/
#ifndef _PASK12UV_H_
#define _PASK12UV_H_
-0.12822074F,  -0.06531171F,  
-0.08632167F,  -0.04006885F,  
-0.03256955F,  -0.10241605F,  -0.12122924F,  0.03700236F,  
0.03804741F,  -0.02910260F,  -0.03702656F,  -0.06999546F,  
0.00950567F,  -0.03936877F,  0.05141811F,  -0.08297337F,  -0.11166547F,  0.15294425F,  
0.02564152F,  -0.01242114F,  0.03668303F,  0.04803946F,  -0.05063203F,  -0.05953401F,  
-0.00995511F,  0.00077094F,  -0.02389857F,  -0.00325885F,  -0.01512445F,  0.00208021F,  -0.12415593F,  -0.00780528F,  
0.03754212F,  0.02330815F,  -0.01027264F,  0.02231556F,  0.03931654F,  0.03545403F,  0.05882185F,  -0.01949542F,  
0.00421867F,  0.01151329F,  0.00589413F,  -0.01088887F,  -0.03714535F,  0.02374630F,  -0.06008506F,  0.06232196F,  -0.01804417F,  -0.02434121F,  
0.02387223F,  0.03733295F,  0.00748525F,  0.05246982F,  0.01404419F,  0.05679075F,  0.00455582F,  -0.03726856F,  0.05090660F,  0.10098963F,  
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\pask12v.h ===
/******************************************************************************
*                        Voxware Proprietary Material
*                        Copyright 1996, Voxware, Inc
*                            All Rights Reserved
*
*                       DISTRIBUTION PROHIBITED without
*                      written authorization from Voxware
******************************************************************************/
 
/******************************************************************************
* Filename:    PASK12V.h
*
* Purpose:     predictor vector of voiced frame for each code-vectors 
*              -- size: 2*(2+4+6+8+10)
*
* $Header:   /export/phobos/pvcs/r_and_d/archives/scaleable/tables/PASK12V.h_v   1.0   06 Feb 1998 10:12:34   johnp  $
*
******************************************************************************/
#ifndef _PASK12V_H_
#define _PASK12V_H_
-0.52555230F,  -0.48076764F,  
0.18061745F,  -0.37937756F,  
0.22606818F,  -0.24675419F,  -0.39149974F,  -0.29388561F,  
0.35220522F,  -0.03028140F,  0.00598225F,  -0.31140657F,  
0.15001104F,  -0.02020646F,  -0.03332609F,  -0.13252916F,  -0.29194369F,  -0.00654147F,  
0.18977997F,  -0.01241252F,  0.02427604F,  -0.04642717F,  -0.17719230F,  -0.26494251F,  
0.05997461F,  0.00083741F,  -0.03667998F,  0.03307862F,  -0.04448916F,  -0.04518944F,  -0.28858952F,  -0.24764263F,  
0.07186103F,  -0.02726507F,  0.04512600F,  -0.02575736F,  0.09611595F,  0.03119487F,  0.17647722F,  -0.09367203F,  
0.01224906F,  0.03042412F,  -0.02833427F,  0.00739590F,  -0.05197324F,  0.07797740F,  -0.11040253F,  0.05650469F,  -0.09913961F,  -0.25653822F,  
0.06119398F,  -0.03762331F,  0.05915156F,  0.01319067F,  0.06663618F,  0.06008965F,  0.08530400F,  -0.08495827F,  0.07747230F,  0.04412201F,  
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\param.c ===
/*******************************************************************************
*                        Voxware Proprietary Material                          *
*                        Copyright 1996, Voxware, Inc                          *
*                            All Rights Reserved                               *
*                                                                              *
*                       DISTRIBUTION PROHIBITED without                        *
*                      written authorization from Voxware                      *
*******************************************************************************/

/*******************************************************************************
* Filename:                                                                    
*                                                                              
* Purpose:                                                                     
*                                                                              
* Functions:                                                                   
*                                                                              
* Author/Date:                                                                 
********************************************************************************
* Modifications:Ilan Berci/ 10/96 Removed global dependencies
*                                 Modularized code segments (Encapsulation)
*                                 Removed scope changes
*                                 Changed error code procedure
*                                 Removed useless code segments
*                                 General optimization                                                                 
*                                                                              
* Comments:                                                                    
* 
* Concerns:
*
* $Header:   /export/phobos/pvcs/r_and_d/archives/realtime/utils/param.c_v   1.4   01 Dec 1998 14:38:02   zopf  $
*******************************************************************************/
#include <stdlib.h>
#include <assert.h>

#include "model.h"
#include "VoxMem.h"

#include "param.h"
#include "vem2.h"
#include "vem2Prm.h"

#include "xvocver.h"

/*******************************************************************************
* Function:       VOXErr VoxInitParam(PARAM* pParam)
*
* Action:
*
* Input:
*
* Output:
*
* Globals:        none
*
* Return:		   VOXErr : Voxware return code
********************************************************************************
* Implementation/Detailed Description:
*
* References:
********************************************************************************
* Modifications:
*
* Comments:
*
* Concerns/TBD:
*******************************************************************************/
unsigned short VoxInitParam(void **hParam, void *pVemMem)
{
   PARAM *pParam;
   void  *pVemMemHandle;

   if(VOX_MEM_INIT(pParam=*hParam,1,sizeof(PARAM))) 
      return 1;

   if(VOX_MEM_INIT(pParam->Amp,MAXHARM,sizeof(float))) 
      return 1;

   if(VOX_MEM_INIT(pParam->Lsf,LPC_ORDER,sizeof(float))) 
      return 1;

   if(VOX_MEM_INIT(pParam->Alpc,LPC_ORDER+1,sizeof(float))) 
      return 1;

   if(VOX_MEM_INIT(pParam->Blpc,LPC_ORDER,sizeof(float))) 
      return 1;
   
   if(pVemMem) {
      pVemMemHandle = ((VEM_MAIN_STRUCT *)pVemMem)->pMemoryHandler;
      vemRegisterArray(pVemMemHandle, pParam->Amp, VEM_FLOAT, MAXHARM, "amplitudes");
      vemRegisterConstShort(pVemMemHandle, (short)LPC_ORDER, "lpc order");

	  /* This change is for VoiceFont backward compatibility - see Wei or John      */
      /* vemRegisterArray(pVemMemHandle, pParam->Alpc, VEM_FLOAT, LPC_ORDER, "lpc");*/

	  vemRegisterArray(pVemMemHandle, pParam->Blpc, VEM_FLOAT, LPC_ORDER, "lpc");

      vemRegisterVariable(pVemMemHandle, &pParam->Pv, VEM_FLOAT, "pv");
      vemRegisterVariable(pVemMemHandle, &pParam->Pitch, VEM_FLOAT, "pitch");
      vemRegisterVariable(pVemMemHandle, &pParam->Energy, VEM_FLOAT, "resEnergy");  
   }

   return 0;
}

/*******************************************************************************
* Function:       VOXErr VoxFreeParam(PARAM* pParam)
*
* Action:
*
* Input:
*
* Output:
*
* Globals:        none
*
* Return:		   VOXErr : Voxware return code
********************************************************************************
* Implementation/Detailed Description:
*
* References:
********************************************************************************
* Modifications:
*
* Comments:
*
* Concerns/TBD:
*******************************************************************************/
unsigned short VoxFreeParam(void **pParam)
{
   if(*pParam) {
      VOX_MEM_FREE(((PARAM*)*pParam)->Amp);
      VOX_MEM_FREE(((PARAM*)*pParam)->Lsf);
      VOX_MEM_FREE(((PARAM*)*pParam)->Alpc);
	  VOX_MEM_FREE(((PARAM*)*pParam)->Blpc);
      VOX_MEM_FREE(*pParam);
   }
   return 0;
}

/*******************************************************************************
* Function:       VOXErr VoxInitPrevFrame(PrevFrameParam *PrevFrameParam_mblk)
*
* Action:
*
* Input:
*
* Output:
*
* Globals:        none
*
* Return:		   VOXErr : Voxware return code
********************************************************************************
* Implementation/Detailed Description:
*
* References:
********************************************************************************
* Modifications:
*
* Comments:
*
* Concerns/TBD:
*******************************************************************************/
unsigned short VoxInitPrevFrame(void **hPrevFrameParam_mblk)
{
   PrevFrameParam *PrevFrameParam_mblk;
	short i;

   if(VOX_MEM_INIT(PrevFrameParam_mblk=*hPrevFrameParam_mblk,1,sizeof(PrevFrameParam))) 
      return 1;

   if(VOX_MEM_INIT(PrevFrameParam_mblk->Amp,MAXHARM,sizeof(float))) 
      return 1;

   if(VOX_MEM_INIT(PrevFrameParam_mblk->Lsf,LPC_ORDER,sizeof(float))) 
      return 1;

   PrevFrameParam_mblk->Pitch = INITIAL_PITCH;
   PrevFrameParam_mblk->Pv=0.0F;

  for(i=0;i<LPC_ORDER;i++) 
	PrevFrameParam_mblk->Lsf[i] = LSP_INITIAL_COND_DEL*i + LSP_INITIAL_COND_0;


   PrevFrameParam_mblk->Energy = 0.0F;

   return 0;
}

/*******************************************************************************
* Function:       VOXErr VoxFreePrevFrame(PrevFrameParam *PrevFrameParam_mblk)
*
* Action:
*
* Input:
*
* Output:
*
* Globals:        none
*
* Return:		   VOXErr : Voxware return code
********************************************************************************
* Implementation/Detailed Description:
*
* References:
********************************************************************************
* Modifications:
*
* Comments:
*
* Concerns/TBD:
*******************************************************************************/
unsigned short VoxFreePrevFrame(void **hPrevFrameParam_mblk)
{
   PrevFrameParam *PrevFrameParam_mblk=(PrevFrameParam *)*hPrevFrameParam_mblk;

   if(*hPrevFrameParam_mblk) {
      VOX_MEM_FREE(PrevFrameParam_mblk->Amp);
      VOX_MEM_FREE(PrevFrameParam_mblk->Lsf);

      VOX_MEM_FREE(*hPrevFrameParam_mblk);
   }

   return 0;
}

/*******************************************************************************
* Function:       VOXErr VoxInitSubframe(SubFrameParam *SubFrameParam_mblk)
*
* Action:
*
* Input:
*
* Output:
*
* Globals:        none
*
* Return:		   VOXErr : Voxware return code
********************************************************************************
* Implementation/Detailed Description:
*
* References:
********************************************************************************
* Modifications:
*
* Comments:
*
* Concerns/TBD:
*******************************************************************************/
unsigned short VoxInitSubframe(void **hSubFrameParam_mblk)
{

   SubFrameParam *SubFrameParam_mblk;

   if(VOX_MEM_INIT(SubFrameParam_mblk=*hSubFrameParam_mblk,1,sizeof(SubFrameParam))) 
      return 1;

   if(VOX_MEM_INIT(SubFrameParam_mblk->Amp,MAXHARM,sizeof(float))) 
      return 1;

   if(VOX_MEM_INIT(SubFrameParam_mblk->Lsf,LPC_ORDER,sizeof(float))) 
      return 1;

   if(VOX_MEM_INIT(SubFrameParam_mblk->Amp_1,MAXHARM,sizeof(float)))
      return 1;

   if(VOX_MEM_INIT(SubFrameParam_mblk->Lsf_1,LPC_ORDER,sizeof(float))) 
      return 1;

   if(VOX_MEM_INIT(SubFrameParam_mblk->AveLsf,LPC_ORDER,sizeof(float))) 
      return 1;

   SubFrameParam_mblk->frameLEN = FRAME_LEN;
   SubFrameParam_mblk->Pitch_1= 50.0F; /*INITIAL_PITCH; //### MUST FIX INITIAL PITCH */
   SubFrameParam_mblk->nSubs = SYNSUBFRAMES;
   SubFrameParam_mblk->WarpFrame = 0;
   SubFrameParam_mblk->totalWarpFrame = 1;
   SubFrameParam_mblk->Hangover = HANGOVER_TIME;
   return 0;
}

/*******************************************************************************
* Function:       VOXErr VoxFreeSubframe(SubFrameParam *SubFrameParam_mblk)
*
* Action:
*
* Input:
*
* Output:
*
* Globals:        none
*
* Return:		   VOXErr : Voxware return code
********************************************************************************
* Implementation/Detailed Description:
*
* References:
********************************************************************************
* Modifications:
*
* Comments:
*
* Concerns/TBD:
*******************************************************************************/ 
unsigned short VoxFreeSubframe(void **hSubFrameParam_mblk)
{
   SubFrameParam *SubFrameParam_mblk=(SubFrameParam *)*hSubFrameParam_mblk;

   if(*hSubFrameParam_mblk) {
      VOX_MEM_FREE(SubFrameParam_mblk->Amp);
      VOX_MEM_FREE(SubFrameParam_mblk->Lsf);
      VOX_MEM_FREE(SubFrameParam_mblk->Amp_1);
      VOX_MEM_FREE(SubFrameParam_mblk->Lsf_1);
      VOX_MEM_FREE(SubFrameParam_mblk->AveLsf);

      VOX_MEM_FREE(*hSubFrameParam_mblk);
   }
   return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\paramsc.h ===
/*******************************************************************************
*                        Voxware Proprietary Material                          *
*                        Copyright 1996, Voxware, Inc                          *
*                            All Rights Reserved                               *
*                                                                              *
*                       DISTRIBUTION PROHIBITED without                        *
*                      written authorization from Voxware                      *
******************************************************************************/

/******************************************************************************
* Filename:       param.h
*                                                                              
* Purpose:                                                                    
*                                                                              
* Author/Date:    Ilan Berci 09/96
********************************************************************************
* $Header:   /export/phobos/pvcs/r_and_d/archives/scaleable/utils/paramSC.h_v   1.5   13 Apr 1998 16:17:58   weiwang  $                                                                     
******************************************************************************/
#ifndef PARAM_H
#define PARAM_H

#include "codec.h"

typedef struct
{
  float Pitch;
  float Pv; 
  float pfVEVphase[SC6_PHASES];
} SUBFRAME_PARAM_SC;


typedef struct /** all members of this structure need to be used in encoder **/
{
  SUBFRAME_PARAM_SC SubParam[2];

  float fLog2Gain;      /** Spectral level                                  **/
  float pfASK[LPC_ORDER];         /** arc sinc area ratios                            **/
  float pfASKunquant[LPC_ORDER];  /** copy of unquantized arc sinc area ratios        **/
} PARAM_SC;


#if 0
/***** Parameter structure *****/
typedef struct /** all members of this structure need to be used in encoder **/
{
  float Pitch[2];      /** pitch value in time samples                     **/
  float Pv[2];         /** voice probability                               **/
  float fLog2Gain;      /** Spectral level                                  **/
  float pfASK[LPC_ORDER];         /** arc sinc area ratios                            **/
  float pfASKunquant[LPC_ORDER];  /** copy of unquantized arc sinc area ratios        **/
  float pfVEVphase[2][SC6_PHASES];  /** excitation phase -- NPEAKS                      **/
} PARAM_SC;
#endif

#endif /* PARAM_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\peakpick.c ===
/*******************************************************************************
*                        Voxware Proprietary Material                          *
*                        Copyright 1996, Voxware Inc.                          *
*                        All Rights Reserved                                   *
*                                                                              *
*                        DISTRIBUTION PROHIBITED without                       *
*                        written authorization from Voxware.                   *
*******************************************************************************/
/******************************************************************************
* File:         PeakPick.c
*
* Description:  Pick peaks from a segment of an array of floats
*
* Author:       
*
* $Header:   /export/phobos/pvcs/pvcsproj/voxlib.prj/PeakPick.c_v   1.8   25 Mar 1998 14:04:26   weiwang  $ 
******************************************************************************/
#include <stdlib.h>
#include <assert.h>

#include "vLibSpch.h"

#include "xvocver.h"

/*******************************************************************************
* FUNCTION    : PeakPick()
*
* PURPOSE     : Pick peaks from a segment of an array of floats
*
* INPUT
*      pfMag      - segment of an array of floating point magintudes
*      iStart     - starting index of the segment
*      iStop      - ending index of the segment
*      iMaxPeaks  - maximum number of peaks to be picked
*
* OUTPUT
*      piPeakFreq - indices of peaks
*      piNPeaks   - number of peaks
*
* RETURN          None    
*******************************************************************************/

void PeakPick( const float *pfMag, 
               int          iStart,
               int          iStop,
               int          iMaxPeaks,
               int         *piPeakFreq,
               int         *piNPeaks
             )             
{
   int    i;
   int    iNPeaks;
  
   assert( pfMag != NULL);
   assert( piPeakFreq != NULL);
   assert( piNPeaks != NULL);

   iNPeaks = 0;
   i=iStart+1;
   iStop--;    /* the ending test index is 1 less than the end of the array */

   while (i<iStop)
   {
      /*----------------------------------------------------------
        A peak is defined as:

           (pfMag[i]>=pfMag[i-1]) && (pfMag[i]>pfMag[i+1])

        (There are other valid ways to define a peak but this
         one has been chosen.)
      ----------------------------------------------------------*/
      if ( (pfMag[i]>=pfMag[i-1]) && (pfMag[i]>pfMag[i+1]) )
      {
         *piPeakFreq++ = i;
         i++;                     /* (adjacent peaks are not possible)   */
         iNPeaks++;
         if (iNPeaks==iMaxPeaks)  /* If the maximum number of peaks has   */
           break;                 /*   been found, then stop the search.  */
      }
      i++;
   }

   *piNPeaks = iNPeaks;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\phasecb.h ===
/******************************************************************************
*                        Voxware Proprietary Material
*                        Copyright 1996, Voxware, Inc
*                            All Rights Reserved
*
*                       DISTRIBUTION PROHIBITED without
*                      written authorization from Voxware
******************************************************************************/
 
/******************************************************************************
* Filename:    PhaseCB.h
*
* Purpose:     phase quantization codebook when phase predictive error is larger
*              than a threshold. The size is only 48. The 7bits phase quantizer 
*              include 1-bit sign bit and 6-bit quantizer. The quantizer include
*              linear quantizer (16) and vector quantizer (48) which uses this codebook.
*
* $Header:   /export/phobos/pvcs/r_and_d/archives/scaleable/tables/PhaseCB.h_v   1.0   06 Feb 1998 10:12:36   johnp  $
*
******************************************************************************/
#ifndef _PHASECB_H_
#define _PHASECB_H_
0.440993F, 4.451386F, 
0.434557F, 1.567719F, 
0.479647F, 5.528316F, 
0.947584F, 3.590784F, 
0.623178F, 0.665376F, 
0.422077F, 2.742028F, 
0.426003F, 6.034402F, 
0.428224F, 5.009378F, 
0.443973F, 2.157422F, 
0.460140F, 3.911678F, 
0.916509F, 5.977030F, 
0.928030F, 4.221321F, 
0.414535F, 3.337251F, 
0.394595F, 1.081679F, 
0.842349F, 3.031343F, 
0.497648F, 0.229197F, 
1.497687F, 5.986917F, 
2.803304F, 4.646498F, 
1.412886F, 3.080948F, 
1.937371F, 1.572907F, 
0.993890F, 5.388539F, 
1.981803F, 3.414683F, 
0.896000F, 1.859717F, 
1.358992F, 0.827856F, 
2.173102F, 4.973801F, 
2.717006F, 3.064277F, 
1.525723F, 2.172197F, 
2.699136F, 0.308721F, 
0.940119F, 4.830658F, 
2.241114F, 2.161922F, 
0.884311F, 1.213171F, 
1.115611F, 0.289077F, 
2.122149F, 5.881092F, 
2.723665F, 5.364179F, 
1.512325F, 3.890119F, 
2.755901F, 1.636237F, 
1.584076F, 5.286568F, 
2.116587F, 4.218071F, 
1.000601F, 2.471424F, 
2.079800F, 0.920738F, 
2.789337F, 5.994799F, 
2.767567F, 3.833364F, 
1.978786F, 2.748608F, 
2.795609F, 0.988444F, 
1.491328F, 4.586208F, 
2.840800F, 2.385704F, 
1.369782F, 1.455270F, 
1.851116F, 0.278767F, 
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\phaseind.h ===
/******************************************************************************
*                        Voxware Proprietary Material
*                        Copyright 1996, Voxware, Inc
*                            All Rights Reserved
*
*                       DISTRIBUTION PROHIBITED without
*                      written authorization from Voxware
******************************************************************************/
 
/******************************************************************************
* Filename:    PhaseInd.h
*
* Purpose:     table for the channel optimized indices for phase quantization.
*
* $Header:   /export/phobos/pvcs/r_and_d/archives/scaleable/tables/PhaseInd.h_v   1.0   06 Feb 1998 10:12:36   johnp  $
*
******************************************************************************/
#ifndef _PHASEIND_H_
#define _PHASEIND_H_
0,
16,
1,
17,
2,
3,
4,
5,
18,
19,
6,
20,
7,
21,
8,
9,
22,
23,
10,
24,
11,
25,
12,
13,
26,
27,
28,
29,
14,
30,
15,
31,
32,
33,
34,
35,
36,
37,
38,
39,
40,
41,
42,
43,
44,
45,
46,
47,
48,
49,
50,
51,
52,
53,
54,
55,
56,
57,
58,
59,
60,
61,
62,
63,
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\pitchtbl.h ===
8.0000F,
8.3125F,
8.6250F,
9.0000F,
9.3750F,
9.8125F,
10.2500F,
10.7500F,
11.2500F,
11.8750F,
12.5625F,
13.3125F,
13.6875F,
14.1250F,
14.6250F,
15.1250F,
15.6250F,
16.1875F,
16.8125F,
17.5000F,
18.1875F,
19.0000F,
19.8125F,
20.4375F,
21.0625F,
21.7500F,
22.5000F,
23.2500F,
24.1250F,
25.0000F,
26.0000F,
26.7500F,
27.6250F,
28.5000F,
29.4375F,
30.4375F,
31.5000F,
32.6250F,
33.6250F,
34.6875F,
35.8125F,
37.0000F,
38.2500F,
39.6250F,
40.8125F,
42.1250F,
43.5000F,
44.9375F,
46.5625F,
47.9375F,
49.5000F,
51.1250F,
52.8750F,
54.4375F,
56.1875F,
58.0000F,
59.9375F,
61.8125F,
63.7500F,
65.8750F,
67.8750F,
70.0000F,
72.3125F,
74.5000F,
76.8125F,
79.3125F,
81.7500F,
84.3125F,
86.8750F,
89.5625F,
92.3750F,
95.2500F,
98.2500F,
101.1875F,
104.3750F,
107.5000F,
110.8750F,
114.1875F,
117.7500F,
121.3125F,
125.1250F,
128.9375F,
133.0000F,
137.0625F,
141.2500F,
145.6250F,
150.0625F,
154.6250F,
159.4375F
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\postfilt.c ===
/******************************************************************************
*                        Voxware Proprietary Material
*                        Copyright 1996, Voxware, Inc
*                            All Rights Reserved
*
*                       DISTRIBUTION PROHIBITED without
*                      written authorization from Voxware
******************************************************************************/
 
/******************************************************************************
*
* Filename:      PostFilt.c
*
* Purpose:       Postfilter the log-base-2 warped allpole envelope
*
* Functions:     PostFilter()
*
* Author/Date:   R.J.McAulay/6/17/97
*
*******************************************************************************
*
* Modifications: Extensively re-written by Bob Dunn 4/8/98
*
* Comments:  
*
* Concerns:
*
* $Header:   /export/phobos/pvcs/r_and_d/archives/scaleable/decode/PostFilt.c_v   1.5   14 Apr 1998 10:14:16   weiwang  $   
*
******************************************************************************/
#include <stdlib.h>
#include <math.h>
#include <assert.h>

#include "vLibMath.h"
#include "vLibVec.h"

#include "codec.h"

#include "trigSC.h"
#include "PostFilt.h"

#include "xvocver.h"


/*-----------------------------------------------------------------------
  Set the number of linear segments to use for approximation of the 
   tilt.
-----------------------------------------------------------------------*/
#define LOGNSEGMENTS  2
#define NSEGMENTS     (1<<LOGNSEGMENTS)
#define TILT_MASK     ((1<<(CSENV_FFT_ORDER-LOGNSEGMENTS-1))-1)

/*-----------------------------------------------------------------------
  Compression factor for the postfilter
-----------------------------------------------------------------------*/
#define BETA      0.50F

/*-----------------------------------------------------------------------
  Clipping thresholds for the postfilter.
    fLogWOver  = Log2( 1.20 )
    fLogWUnder = Log2( 0.50 )
-----------------------------------------------------------------------*/
static const float fLogWOver  =  0.26303441F;
static const float fLogWUnder = -1.0F;

/*-----------------------------------------------------------------------
  Set a transition region (0<omega<LO_EDGE*PI) where the amount
    of postfiltering is gradually increased.  The increase is 
    logarithmic with respect to frequency. (i.e. a linear increase
    in the log domain)
-----------------------------------------------------------------------*/
#define LO_EDGE   0.250F
static const int iK0 = (int)((float)CSENV_NFFT_2*LO_EDGE);
static const float fInverseK0 = 1.0F / (float)
                                  ((int)((float)CSENV_NFFT_2*LO_EDGE));



/*-----------------------------------------------------------------------
  Use a table for cosine.
-----------------------------------------------------------------------*/
extern const float *cosTBL_32;
static const int iFund = (1<<(LOG2_TRIG_SIZE-LOGNSEGMENTS-1));

/*******************************************************************************
*
* Function:  PostFilter()
*
* Action:    Use the LPC parameters to compute the spectral tilt and the
*            energy, flatten the allpole envelope and compute the post-filter,
*            apply the post-filter and re-normalize to equalize the energy.
*            The log-base-2 envelope is stored in place of the log-amplitudes.
*
* Input:     float *pfLogEnv  --> log (base 2) magnitude of all-pole envelope
*                                   with length CSENV_NFFT_2
*            float  fLog2Gain --> log (base 2) gain of the all-pole envelope
*            float *pfKS      --> reflection coefficients for all-pole envelope
*                                   with length LPC_ORDER
*
* Output:    float *pfLogEnv  --> postfiltered envelope
*                                   with length CSENV_NFFT_2
*
* Globals:   extern const float *cosTBL_32 --> cosine table
*
* Return:    none
********************************************************************************
*
* Modifications:
*
* Comments:
*
* Concerns/TBD:   hard-wire coded for envelope length equal to CSENV_NFFT_2
*******************************************************************************/

void PostFilter(float *pfLogEnv, float fLog2Gain, float *pfKS)
{
   int   i, k;
   int   iIndex;
   int   iInterp;
   int   iMax;
   int   iMaxNew;
   int   iArg;
   float fMax;
   float fMaxNew;
   float fLogWeight;
   float fTemp1, fTemp2, fTemp3;
   float fProd;
   float fGain;
   float fInterp;

   float fTilt;
   float fTiltSamples[NSEGMENTS+1];
   
   assert((pfLogEnv != NULL) && (pfKS != NULL));

   /*-------------------------------------------------------------------------
     Check cosine table size...must re-work code if this fails
   -------------------------------------------------------------------------*/
   assert( iFund > 0 );

   /*-------------------------------------------------------------------------
     Find the peak of the spectral log magnitude.  This will be used to 
       normalize the gain of the postfiltered speech.  It is a poor man's 
       estimate of R0.  It is a reasonably good approximation when 
       the tilt is at least (15 dB / 4000 Hz)
   -------------------------------------------------------------------------*/
   FindMaxValueFlt( pfLogEnv, CSENV_NFFT_2, &iMax, &fMax );

   /*-------------------------------------------------------------------------
     A 1st order all pole model of the spectrum is used to normalize out
       the spectral tilt.  The model is:

         Tilt(w) = | G1/(1.0+a_1*exp(-j*w)) |

     where a_1 is the predictor coefficient for a 1st order all pole model,
     G1 is the gain of that model, and w is the frequency in radians.  
     The value of a_1 is determined from:

         a_1 = - k_1 

     where k_1 is the first reflection coefficient.  The value of G1 can 
     found from:

         G1^2 = R0 * (1.0 - k_1^2)

     where R0 is the 0th autocorrelation coefficient.  Finally, R0 is 
     determined from the equation:

         G12^2 = R0 * PROD( i=1...12 ) (1.0 - k_i^2)

     where G12 is the gain of the 12th order all pole model and k_i
     are the reflection coefficients.

     First compute 1st order system gain from the original gain and the 
     reflection coefficients.
   -------------------------------------------------------------------------*/
   fProd = 1.0F;
   for (i=1; i<LPC_ORDER; i++)
   {
      fTemp1 = pfKS[i]*pfKS[i];
      fProd *= (1.0F-fTemp1);
   }
   fGain = fLog2Gain - 0.5F*fLog2(fProd);
 
   /*-------------------------------------------------------------------------
     Compute samples of the log of the tilt curve using:

         Tilt(w) = | G1/(1.0+a_1*exp(-j*w)) |
                 = G1/sqrt(1.0+a_1*a_1-2.0*A_1*cos(w))

         Log2(Tilt(w)) = Log2(G1) - 0.5*Log2(1.0+a_1*a_1-2.0*A_1*cos(w))
   -------------------------------------------------------------------------*/
   fTemp2 = 1.0F + pfKS[0]*pfKS[0];
   fTemp3 = -2.0F*pfKS[0];
   iArg   = 0;
   for (i=0; i<=NSEGMENTS; i++)
   {
      fTemp1           = fTemp2 + fTemp3*cosTBL_32[iArg];
      iArg            += iFund;
      fTiltSamples[i]  = fGain - 0.5F*fLog2(fTemp1);
   }

   /*------------------------------------------------------------------------
     Postfilter using approximation to 1st order all-pole envelope
   ------------------------------------------------------------------------*/
   iIndex  = 0;
   iInterp = 0;
   for (k = 1; k < CSENV_NFFT_2; k++)
   {
      iInterp = k&TILT_MASK;
      iIndex  = (k>>(CSENV_FFT_ORDER-LOGNSEGMENTS-1));
      fInterp = (float) iInterp*((float)NSEGMENTS/(float)CSENV_NFFT_2);
      fTilt = VoxINTERP( fTiltSamples[iIndex], fTiltSamples[iIndex+1], fInterp);

      /*-----------------------------------------------------------------
        Compute postfilter weight
      -----------------------------------------------------------------*/
      fLogWeight = BETA*(pfLogEnv[k] - fTilt);
 
      /*-----------------------------------------------------------------
        Clip the postfilter weight
      -----------------------------------------------------------------*/
      fLogWeight = VoxMIN( fLogWeight, fLogWOver );
      fLogWeight = VoxMAX( fLogWeight, fLogWUnder );
 
      /*-----------------------------------------------------------------
        Fade in the postfilter weight in the region (0<omega<LO_EDGE*PI)
      -----------------------------------------------------------------*/
      if(k < iK0)
         fLogWeight *= (k*fInverseK0);
 
      /*-----------------------------------------------------------------
        Apply the weight
      -----------------------------------------------------------------*/
      pfLogEnv[k] += fLogWeight;
   }

   /*-------------------------------------------------------------------------
     Re-scale the post-filtered log-envelope to achieve the measured energy
   -------------------------------------------------------------------------*/
   FindMaxValueFlt( pfLogEnv, CSENV_NFFT_2, &iMaxNew, &fMaxNew );

   fLogWeight = fMax - fMaxNew;
   for (k = 0; k < CSENV_NFFT_2; k++)
      pfLogEnv[k] += fLogWeight;

} /* PostFilter() */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\polyintp.c ===
/******************************************************************************
*                        Voxware Proprietary Material
*                        Copyright 1997, Voxware, Inc
*                            All Rights Reserved
*
*                       DISTRIBUTION PROHIBITED without
*                      written authorization from Voxware
******************************************************************************/

/*****************************************************************************
* Filename:   PolyIntp.c
*
* Purpose:    Floating Point Poly-Phase Cycle Interpolation.
*
* Functions:  PolyCycleIntp()
*
* Author/Date : Wei Wang, 2/26/98
*
*******************************************************************************
*
* Modifications:  (converted Rob Zopf's fixed point code)
*                      (of course, based on JGA's :-) )
*                 Based on Bob Dunn's code 10/25/96
* Comments: 
*
* Concerns: 
*
* $Header:   /export/phobos/pvcs/pvcsproj/voxlib.prj/PolyIntp.c_v   1.8   20 Mar 1998 10:24:32   weiwang  $
******************************************************************************/
#include <stdlib.h>
#include <assert.h>
#include <math.h>
#include "vLibFilt.h"

#include "xvocver.h"

#define PP_RESAMP_ORDER                   6
#define PP_RESAMP_RATE                    (1<<PP_RESAMP_ORDER)

#define PP_SHIFT                          16
#define PP_SHIFT_SCALE                    (float)((long)1<<PP_SHIFT)
#define PP_SHIFT_MASK                     (((long)1<<PP_SHIFT)-1)
#define INV_PP_SHIFT_SCALE                (1.0F/PP_SHIFT_SCALE)

#define PP_WEIGHTS_INDEX_SHIFT            (PP_SHIFT-PP_RESAMP_ORDER)

static const float PPWts[PP_RESAMP_RATE*PP_NUM_SAMPLES] = {
#include "PPWeight.h"
};

/******************************************************************************
*
* Function:  PolyCycleIntp()
*
* Action:    Poly-Phase Cycle Interpolation.
*
* Input:    pfOut       - address to the resampling signal.
*           iOutLength  - the length of the resampling signal.
*           pfCycle     - input proto-type signal, usually refer to a single
*                         pitch epoch with 0 phase.
*           iLog2CycleLength 
*                       - log2 of the input signal length. 
*           fResampRate - the resampling ratio of the input cycle with
*                         the output cycle (calculated by input cycle length 
*                         over the pitch period).
*           fNormPhase  - the starting phase of the output signal 
*                         (calculated by starting time over the pitch period).
*
* Output:   pfOut       - the output data
*
* Globals:  none
*
* Return:   fNormPhase  - the ending phase of the resampled signal. If use 
*                         it as input for next PolyCycleIntp() call, the phases
*                         can be guaranteed to be continous.
*
*******************************************************************************
*
* Implementation/Detailed Description:
*
* References:  
*
*******************************************************************************
*
* Modifications:
*
* Comments:  
*     (1) In order to use fix point technique to speech up the function, the 
*       cycle length has to be in the order of 2 (2^iLog2CycleLength).
*     (2) To use LONG operation (32 bits), iOutLength, iCycleLength and fIndex
*       can not exceed 2^15.
*     (3) In order to speech up FIR operation, the real length of pfCycle has 
*       to be (2^iLog2CycleLength + PP_NUM_SAMPLES). The input pfCycle has 
*       already been shifted by PP_DELAY so that the address of 
*       pfCycle[-PP_DELAY] is valid.
*
* Concerns/TBD:
******************************************************************************/
float PolyCycleIntp( float       *pfOut,
                     int         iOutLength,
                     float       *pfCycle,
                     int         iLog2CycleLength,  
                     float       fResampRate,
                     float       fNormPhase
                   )
{  
  float fSum;
  float *pfW, *pfC;
  float fIndex;
  long lIndex, lResampFactor;
  int iCycleLength;
  long lScaledCycleMask;
  int i;

  /*-----------------------------------------------------
    Error checking :
    -----------------------------------------------------*/
   assert(pfOut != NULL && pfCycle != NULL);
   assert(iLog2CycleLength < 15);  /* to make sure no overflow */
   assert(PP_NUM_SAMPLES == 4);  /* the code is hardwired only for 4 */

   /*--------------------------------------------------
     Get the prototype cycle length:
    --------------------------------------------------*/
   iCycleLength        = 1<<iLog2CycleLength;
   lScaledCycleMask    = ((long)1<<(iLog2CycleLength+PP_SHIFT))-1;


   /*-------------------------------------------------        
     Extend Cycle in both forward & Backward  
     direction for extrapolation in upsampling 
    -------------------------------------------------*/
    pfCycle[iCycleLength]   = pfCycle[0];     
    pfCycle[iCycleLength+1] = pfCycle[1];    
    pfCycle[iCycleLength+2] = pfCycle[2];     
    pfCycle[-1]             = pfCycle[iCycleLength-1]; 
    pfCycle                -=PP_DELAY;   

    /*--------------------------------------------------
      Convert to fix point for speeding up:
      (1) Resample factor
      (2) start index at proto-type cycle.
      --------------------------------------------------*/
    lResampFactor   = (long)(PP_SHIFT_SCALE*fResampRate);

    fIndex          = fNormPhase * (float)iCycleLength;
    assert(fabs(fIndex)<(PP_SHIFT_SCALE*0.5F)); 

    lIndex          = (long)(PP_SHIFT_SCALE*fIndex);
    lIndex         &= lScaledCycleMask;
    
    /*--------------------------------------------------
      To interpolate the prototype cycle and get the
      output data.
      --------------------------------------------------*/
    while (iOutLength-- > 0)
      { 
        /*-------------------------------------------------------
          The length of prototype cycle is in order of 2. And
          the fractional part of lIndex is in the last 16 bits.
          So the weights' index can be calculated by:
          fract(lIndex) * PP_RESAMP_RATE / PP_SHIFT_SCALE
          ------------------------------------------------------*/
         i      = (int)((lIndex&PP_SHIFT_MASK)>>PP_WEIGHTS_INDEX_SHIFT);
         pfW    = (float *)&(PPWts[i<<2]);

        /*-----------------------------------------------------
          The integer part of lIndex is in the first 16 bits.
          To make sure the operation won't overflow, need to 
          make sure the integer index is between 
          0 to (iCycleLength - 1).
          -----------------------------------------------------*/
        i      = (int)(lIndex >> PP_SHIFT);
        pfC    = &(pfCycle[i]);
  
        /*--------------------------------------------------
          Convolve samples in the prototype cycle with 
          weights (hardwired to use 4 samples).
          --------------------------------------------------*/
        fSum    = (*pfC++**pfW++);
        fSum   += (*pfC++**pfW++);
        fSum   += (*pfC++**pfW++);
        fSum   += (*pfC++**pfW++);
        *pfOut++ = fSum;

        /*-------------------
          Update lIndex:
         -------------------*/
        lIndex += lResampFactor;
        lIndex &= lScaledCycleMask;
   }


    /*------------------------
      Get the ending phase:
      ------------------------*/
    lIndex     = lIndex >> iLog2CycleLength;  /* remove the cycle length */
    fNormPhase = (float)(lIndex * INV_PP_SHIFT_SCALE);

    return fNormPhase;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\pow125.h ===
-3.849798e-05F,
1.037728e-03F,
-1.116614e-02F,
6.214871e-02F,
-2.035933e-01F,
1.149591e+00F,
-2.895383e-09F,
4.950828e-07F,
-3.385246e-05F,
1.200239e-03F,
-2.512983e-02F,
9.108656e-01F,
-2.177189e-15F,
6.618268e-12F,
-7.766816e-09F,
4.481697e-06F,
-1.405510e-03F,
6.686011e-01F,
-1.440078e-21F,
6.746126e-17F,
-1.232355e-12F,
1.124969e-08F,
-5.737742e-05F,
4.664688e-01F,
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\pitchdef.h ===
#ifndef _PITCHDEF_H_
#define _PITCHDEF_H_

/*************************************************************
 * 
 * Filename:   PitchDef.h
 *
 * Purpose:    Definitions for pitch estimation algorithm.
 *
 * Author:     Wei Wang
 *
 * Date:       Oct. 4, 1996
 *
 * $Header:   /export/phobos/pvcs/r_and_d/archives/realtime/pda/PitchDef.h_v   1.4   12 May 1998 12:55:10   weiwang  $
 *************************************************************/

#include "lpcorder.h"

#define FRAME_LEN          180
#define RATE8K                      8000.0F
#define INV_RATE8K                  (1.0F/RATE8K) /* RTE */

#define PITCH_MIN          10
#define PITCH_MAX          180 

#define NUM_SUBFRAME       3

#define SUBFRAME_LEN      (FRAME_LEN/NUM_SUBFRAME)

#define PDA_EXPAND_COEF             0.9921875F    /* == (254/256) */

#define PERCEP_WEIGHT_NUM_BIG       0.9921875F    /* == (254/256) */
#define PERCEP_WEIGHT_NUM_SMALL     0.98828125F   /* == (253/256) */
#define PERCEP_WEIGHT_DEN           0.8F

#define MIN_DIFF_LSF                64.0F    /* 64.0Hz if Lsfs is normalized by 8000.0Hz */

#define INTERP_LSF_COEF          ((float)1.0F/(float)NUM_SUBFRAME)

#define HPF_ORDER                   4

#define LPF_ORDER                   3

#define PDA_LPC_ORDER               10

#define LEFT_ASYM_WIN               135
#define RIGHT_ASYM_WIN              (FRAME_LEN-LEFT_ASYM_WIN)

#define HAMMING_CONST               0.54F

/* decimated domain */
#define LFRAME_LEN         (FRAME_LEN/2)
#define LFRAME_LEN_2       (LFRAME_LEN/2)

#define LPITCH_MIN         (PITCH_MIN/2)
#define LPITCH_MAX         (PITCH_MAX/2)

#define LSUBFRAME_LEN     (SUBFRAME_LEN/2)

#define PITCH_CAND         (LPITCH_MAX-LPITCH_MIN+1)

#define INIT_PITCH          40
#define INIT_COST           -1.0F

#define INTRA_FRAME_TRACK_RATIO    0.155F
#define INTER_FRAME_TRACK_RATIO    0.25F
#define CENTER_TRACK_RATIO         0.1F

#define LAST_SUBFRAME_WEIGHT       0.5F


#define BIAS_BACKWARD         0.93F            /* was 0.9166666667  */

#define BIAS_FORWARD          0.98F           /* was 0.95  */

#define BIAS_C0               0.27777777777778F  /* (1/3.6) (0.2631578947368  ==>  1/3.8)  */

#define NOISE_FLOOR            0.15F

#define INV_NOISE_FLR          1.17647059F

#define LOW_ENERGY_RATIO        0.25F
#define SQRT_LOW_ENERGY_RATIO   0.5F

#define CENT_WIN_A              0.75F
#define CENT_WIN_B              0.25F

#define MINCON                  1.0e-6F
#define MAXFLT                  3.402823466E+38F  

#ifndef M_PI
#define M_PI                       (double)3.14159265358979323846
#endif

#ifndef ZERO_LSF                   
#define ZERO_LSF                   363.6F
#endif

#ifndef LSP_INITIAL_COND_0                   
#define LSP_INITIAL_COND_0			300.0F 	/*%# 300Hz #%*/
#define LSP_INITIAL_COND_DEL        (3600.0F/(float)(PDA_LPC_ORDER-1))
#endif


#define LPITCH_CONF                 20 

#define LPITCH_MIN_CONF             10    /* if pitch == 20, we feel more confidence */

#define PDA_WIN_COEF                0.58F            /* was 64F */
#define PDA_WIN_DIFFC               ((1.0F-PDA_WIN_COEF)/(float)LFRAME_LEN)

#endif /* end of #ifndef _PITCHDEF_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\pow150.h ===
-4.712394e-05F,
1.268911e-03F,
-1.362950e-02F,
7.559101e-02F,
-2.451501e-01F,
1.179473e+00F,
-3.382943e-09F,
5.778432e-07F,
-3.944132e-05F,
1.393441e-03F,
-2.888278e-02F,
8.920256e-01F,
-2.389072e-15F,
7.255203e-12F,
-8.500078e-09F,
4.888305e-06F,
-1.518136e-03F,
6.156773e-01F,
-1.470950e-21F,
6.883838e-17F,
-1.255374e-12F,
1.142060e-08F,
-5.767677e-05F,
3.996589e-01F,
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\pow_125.h ===
7.52104624e-01F,
-2.68381951e+00F,
3.79859060e+00F,
-2.78019633e+00F,
1.26350229e+00F,
6.49376199e-01F,
5.63998902e-01F,
-2.01258071e+00F,
2.84854110e+00F,
-2.08485313e+00F,
9.47493049e-01F,
4.86963452e-01F,
4.22939511e-01F,
-1.50922262e+00F,
2.13610447e+00F,
-1.56341929e+00F,
7.10519551e-01F,
3.65171072e-01F,
3.17159890e-01F,
-1.13175730e+00F,
1.60185238e+00F,
-1.17239907e+00F,
5.32814497e-01F,
2.73839673e-01F,
2.37836365e-01F,
-8.48698248e-01F,
1.20121982e+00F,
-8.79175274e-01F,
3.99554506e-01F,
2.05350785e-01F,
1.78352113e-01F,
-6.36433902e-01F,
9.00787787e-01F,
-6.59288447e-01F,
2.99623610e-01F,
1.53991364e-01F,
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\postfilt.h ===
/******************************************************************************
*                        Voxware Proprietary Material
*                        Copyright 1996, Voxware, Inc
*                            All Rights Reserved
*
*                       DISTRIBUTION PROHIBITED without
*                      written authorization from Voxware
******************************************************************************/
 
/******************************************************************************
*
* Filename:      PostFilt.h
*
* Purpose:       Postfilter the log-base-2 warped allpole envelope
*
* Functions:     void PostFilter(float *pfLogEnv)
*
* Author/Date:   R.J.McAulay/6/17/97
*
*******************************************************************************
*
* Modifications:
*
* Comments:  Could save some time using the natural log in place of log-base-2.
*            Originally used the synthesizer predictor coefficients and gain
*            to determine the energy and the spectral tilt, but when the
*            parameters were quantized, this let to instabilties in the 
*            As[] to Ks[] routine, and "pops" in the synthetic speech. So it is
*            prudent to compute these parameters directly, even though it
*            increases the complexity.
*
* Concerns:
*
* $Header:   /export/phobos/pvcs/r_and_d/archives/scaleable/decode/PostFilt.h_v   1.2   10 Apr 1998 16:47:10   bobd  $   
*
******************************************************************************/


#ifndef _POST_FILT_H_
#define _POST_FILT_H_

/*******************************************************************************
*
* Function:  PostFilter()
*
* Action:    Use the LPC parameters to compute the spectral tilt and the
*            energy, flatten the allpole envelope and compute the post-filter,
*            apply the post-filter and re-normalize to equalize the energy.
*            The log-base-2 envelope is stored in place of the log-amplitudes.
*
* Input:     float *pfLogEnv  --> log (base 2) magnitude of all-pole envelope
*                                   with length CSENV_NFFT_2
*            float  fLog2Gain --> log (base 2) gain of the all-pole envelope
*            float *pfKS      --> reflection coefficients for all-pole envelope
*                                   with length LPC_ORDER
*
* Output:    float *pfLogEnv  --> postfiltered envelope
*                                   with length CSENV_NFFT_2
*
* Globals:   extern const float *cosTBL_32 --> cosine table
*
* Return:    none
********************************************************************************
*
* Modifications:
*
* Comments:
*
* Concerns/TBD:   hard-wire coded for envelope length equal to CSENV_NFFT_2
*******************************************************************************/

void PostFilter(float *pfLogEnv, float fLog2Gain, float *pfKS);

#endif /* _POST_FILT_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\ppweight.h ===
/*******************************************************************************
*                        Voxware Proprietary Material                          *
*                        Copyright 1996, Voxware Inc.                          *
*                        All Rights Reserved                                   *
*                                                                              *
*                        DISTRIBUTION PROHIBITED without                       *
*                        written authorization from Voxware.                   *
*******************************************************************************/

/*******************************************************************************
*
* Filename: PPWeight.h
*
* Purpose:  table for PolyIntp.c
*
* Author/Date:   Gerard Agular
*
* $Header:   /export/phobos/pvcs/pvcsproj/voxlib.prj/PPWeight.h_v   1.1   26 Feb 1998 17:00:38   weiwang  $
*******************************************************************************/
#ifndef PPWEIGHT_H_
#define PPWEIGHT_H_
0.1666666667F,0.6666666667F,0.1666666667F,0.0000000000F,
0.1589756012F,0.6664244334F,0.1745993296F,0.0000006358F,
0.1515248617F,0.6657053630F,0.1827646891F,0.0000050863F,
0.1443106333F,0.6645208995F,0.1911513011F,0.0000171661F,
0.1373291016F,0.6628824870F,0.1997477214F,0.0000406901F,
0.1305764516F,0.6608015696F,0.2085425059F,0.0000794729F,
0.1240488688F,0.6582895915F,0.2175242106F,0.0001373291F,
0.1177425385F,0.6553579966F,0.2266813914F,0.0002180735F,
0.1116536458F,0.6520182292F,0.2360026042F,0.0003255208F,
0.1057783763F,0.6482817332F,0.2454764048F,0.0004634857F,
0.1001129150F,0.6441599528F,0.2550913493F,0.0006357829F,
0.0946534475F,0.6396643321F,0.2648359934F,0.0008462270F,
0.0893961589F,0.6348063151F,0.2746988932F,0.0010986328F,
0.0843372345F,0.6295973460F,0.2846686045F,0.0013968150F,
0.0794728597F,0.6240488688F,0.2947336833F,0.0017445882F,
0.0747992198F,0.6181723277F,0.3048826853F,0.0021457672F,
0.0703125000F,0.6119791667F,0.3151041667F,0.0026041667F,
0.0660088857F,0.6054808299F,0.3253866831F,0.0031236013F,
0.0618845622F,0.5986887614F,0.3357187907F,0.0037078857F,
0.0579357147F,0.5916144053F,0.3460890452F,0.0043608348F,
0.0541585286F,0.5842692057F,0.3564860026F,0.0050862630F,
0.0505491892F,0.5766646067F,0.3668982188F,0.0058879852F,
0.0471038818F,0.5688120524F,0.3773142497F,0.0067698161F,
0.0438187917F,0.5607229869F,0.3877226512F,0.0077355703F,
0.0406901042F,0.5524088542F,0.3981119792F,0.0087890625F,
0.0377140045F,0.5438810984F,0.4084707896F,0.0099341075F,
0.0348866781F,0.5351511637F,0.4187876383F,0.0111745199F,
0.0322043101F,0.5262304942F,0.4290510813F,0.0125141144F,
0.0296630859F,0.5171305339F,0.4392496745F,0.0139567057F,
0.0272591909F,0.5078627268F,0.4493719737F,0.0155061086F,
0.0249888102F,0.4984385173F,0.4594065348F,0.0171661377F,
0.0228481293F,0.4888693492F,0.4693419139F,0.0189406077F,
0.0208333333F,0.4791666667F,0.4791666667F,0.0208333333F,
0.0189406077F,0.4693419139F,0.4888693492F,0.0228481293F,
0.0171661377F,0.4594065348F,0.4984385173F,0.0249888102F,
0.0155061086F,0.4493719737F,0.5078627268F,0.0272591909F,
0.0139567057F,0.4392496745F,0.5171305339F,0.0296630859F,
0.0125141144F,0.4290510813F,0.5262304942F,0.0322043101F,
0.0111745199F,0.4187876383F,0.5351511637F,0.0348866781F,
0.0099341075F,0.4084707896F,0.5438810984F,0.0377140045F,
0.0087890625F,0.3981119792F,0.5524088542F,0.0406901042F,
0.0077355703F,0.3877226512F,0.5607229869F,0.0438187917F,
0.0067698161F,0.3773142497F,0.5688120524F,0.0471038818F,
0.0058879852F,0.3668982188F,0.5766646067F,0.0505491892F,
0.0050862630F,0.3564860026F,0.5842692057F,0.0541585286F,
0.0043608348F,0.3460890452F,0.5916144053F,0.0579357147F,
0.0037078857F,0.3357187907F,0.5986887614F,0.0618845622F,
0.0031236013F,0.3253866831F,0.6054808299F,0.0660088857F,
0.0026041667F,0.3151041667F,0.6119791667F,0.0703125000F,
0.0021457672F,0.3048826853F,0.6181723277F,0.0747992198F,
0.0017445882F,0.2947336833F,0.6240488688F,0.0794728597F,
0.0013968150F,0.2846686045F,0.6295973460F,0.0843372345F,
0.0010986328F,0.2746988932F,0.6348063151F,0.0893961589F,
0.0008462270F,0.2648359934F,0.6396643321F,0.0946534475F,
0.0006357829F,0.2550913493F,0.6441599528F,0.1001129150F,
0.0004634857F,0.2454764048F,0.6482817332F,0.1057783763F,
0.0003255208F,0.2360026042F,0.6520182292F,0.1116536458F,
0.0002180735F,0.2266813914F,0.6553579966F,0.1177425385F,
0.0001373291F,0.2175242106F,0.6582895915F,0.1240488688F,
0.0000794729F,0.2085425059F,0.6608015696F,0.1305764516F,
0.0000406901F,0.1997477214F,0.6628824870F,0.1373291016F,
0.0000171661F,0.1911513011F,0.6645208995F,0.1443106333F,
0.0000050863F,0.1827646891F,0.6657053630F,0.1515248617F,
0.0000006358F,0.1745993296F,0.6664244334F,0.1589756012F,
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\ptchcand.h ===
/*******************************************************************************
*                        Voxware Proprietary Material                          *
*                        Copyright 1996, Voxware, Inc                          *
*                            All Rights Reserved                               *
*                                                                              *
*                       DISTRIBUTION PROHIBITED without                        *
*                      written authorization from Voxware                      *
******************************************************************************/

/*******************************************************************************
* Filename:       PtchCand.h
*                                                                              
* Purpose:        Choose the best pitch candidates for further analysis.
*                                                                              
* Functions:      
*
* Author/Date:    Original developed by Gerard Aguilar.
*                 Enhanced by Wei Wang.
*
********************************************************************************
* Modifications:
*                                                                              
* Comments:                                                                    
* 
* Concerns:
*
* $Header:   /export/phobos/pvcs/r_and_d/archives/scaleable/pea/PtchCand.h_v   1.1   02 Apr 1998 14:47:00   weiwang  $
******************************************************************************/

#ifndef _PTCH_CAND_H_
#define _PTCH_CAND_H_


/******************************************************************************
* Function:  SelectPitchCandidates()
*
* Action:    Select most possible candidates.
*
* Input:     pfMag       -- compressed magnitude spectrum
*            iBaseBand   -- length of base bandwidth
*            piPeakFreq  -- peak indecies
*            pfPitchCand -- address to the output pitch candidates
*            pfCandCost  -- address to the cost values of selected candidates
*            fLastP0     -- previous pitch for backward tracking
*            flastCost   -- the cost value of previous pitch period
*            piHP_Index  -- address to the index of pfPitchCand to get the high-
*                           possibility pitch candidate
*
* Output:    pfPitchCand -- pitch periods of selected candidates
*            piHP_Index  -- index of pfPitchCand to get the high-
*                           possibility pitch candidate
*
* Globals:   none
*
* Return:    number of candidates
******************************************************************************/
int SelectPitchCandidates( STACK_R 
                           const float *pfMag, 
                           int         iBaseBand, 
		 	   const int   *piPeakFreq, 
                           float       *pfPitchCand, 
			   float       *pfCandCost, 
                           float       fLastP0,
                           float       fLastCost,
			   int         *piHP_Index
                         );

#endif /* _PTCH_CAND_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\predcoef.h ===
0.82429486F,
-0.15280492F,
0.96574481F,
-0.13954766F,
-0.05911247F,
0.82155888F,
-0.20361284F,
-0.04844672F,
-0.01753178F,
0.78519690F,
-0.06843720F,
-0.20631622F,
0.23587462F,
-0.12696905F,
0.70323259F,
-0.16648379F,
0.09804764F,
0.00643375F,
0.10218618F,
-0.09970229F,
0.58567490F,
-0.24948001F,
0.07108887F,
0.16285527F,
-0.08120650F,
-0.00238869F,
0.07919904F,
0.58047633F,
-0.21491106F,
0.10417305F,
-0.04668164F,
0.18070620F,
-0.16236990F,
0.09585280F,
0.06350366F,
0.31612628F,
-0.28881350F,
0.10717150F,
-0.05893013F,
0.01339335F,
0.01514042F,
-0.09073499F,
0.11037806F,
-0.01045532F,
0.46552280F
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\preproc.c ===
/******************************************************************************
*
*                        Voxware Proprietary Material
*
*                        Copyright 1997, Voxware, Inc
*
*                            All Rights Reserved
*
*
*                       DISTRIBUTION PROHIBITED without
*
*                      written authorization from Voxware
*
******************************************************************************/
 
/******************************************************************************
*
* Filename:    PreProc.c
*
* Purpose:    Preprocess input speech to remove the DC component. 
*
* Functions: VoxPreProcess()
*            VoxInitPreProc()
*            VoxFreePreProc()
*
* Author/Date: Wei Wang, 1995.
*
*******************************************************************************
*
* Modifications: 11/25/97, 
*                According to Raymond's suggestion, check the first value
*                of each frame. If it's too small, set it to 0.
*
*                11/24/97, 
*                Wei Wang, only add the noise floor to the first sample of 
*                each frame.
*
* Comments: 
*
* Concerns: (1) need convert short to float.
*
* $Header:   /export/phobos/pvcs/pvcsproj/voxlib.prj/PreProc.c_v   1.3   06 Mar 1998 16:57:46   weiwang  $
******************************************************************************/

#include <stdlib.h>
#include <assert.h>
#include "vLibFilt.h"
#include "vLibMacr.h"
#include "vLibMath.h"

#include "xvocver.h"

/***** preprocessing structure (local structure)******/
typedef struct
{
  float fInX;                 /* direct-form IIR filter internal memory */
  float fOutY;                /* direct-form IIR filter internal memory */
  float cPP_Coef;            /* IIR filter coefficient, which is close to 1 */
} PRE_PROC_mblk;


/***** Definition to prevent under-flow *****/
static const float minValue = 1.0e-5F;  


/******************************************************************************
*
* Function:  VoxPreProcess()
*
* Action:    First-order high-pass filter to remove DC.
*
* Input:     piIn -- the input speech signal (16-bit PCM)
*            pfOut -- the point for the output speech
*            N -- number of samples for both input and output signal
*            hPreProc_mblk  -- internal memory for the processing
*
* Output:    pfOut -- the output speech after the preprocessing.
*
* Globals:   none
*
* Return:    void
*******************************************************************************
*
* Implementation/Detailed Description:
*
*    first order IIR filter:  pfOut[n]=(piIn[n]-piIn[n-1])+C*pfOut[n-1],
*    where C is the filter coefficient.
*******************************************************************************
*
* Modifications:
*
* Comments: 
*
* Concerns/TBD:  (1) Need to convert from short to float.
*                (2) For some machine, like SPARC, under-flow problem may occur
*                    for floating point operation. So a very small offset is 
*                    updated every frame to prevent it. For fix point 
*                    implementation, just set this value to 0.
*                    For example, if x[0] = 1 at first frame, then all 0s. For
*                    minimum floating number 1.175494351E-38, only 8690 samples 
*                    0 input will cause under-flow problem.
******************************************************************************/

void VoxPreProcess(const short *psIn, float *pfOut, int N, void *hPreProcMblk)
{
  float x1, x, y;
  float Coef = ((PRE_PROC_mblk *)hPreProcMblk)->cPP_Coef;

  /***** error checking *****/
  assert((psIn != NULL) && (pfOut != NULL));
  assert(hPreProcMblk != NULL);

  /***** get the memory from the previous frame *****/
  x = ((PRE_PROC_mblk *)hPreProcMblk)->fInX;
  y = ((PRE_PROC_mblk *)hPreProcMblk)->fOutY;

  if (VoxABS(y) < minValue)
     y =  0.0F;

  /***** filter the signal sample-by-sample *****/
  while ((N--) > 0)
    {
      x1 = (float)*psIn++;
      y = x1 - x + Coef * y;
      x = x1;
      *pfOut++ = y;
    }
  
  /***** update the internal memory *****/ 
  ((PRE_PROC_mblk *)hPreProcMblk)->fInX = x;
  ((PRE_PROC_mblk *)hPreProcMblk)->fOutY = y;
}



/******************************************************************************
*
* Function:  VoxInitPreProc()
*
* Action:    initialize the preprocessing structure.
*
* Input:     hPreProcMblk -- pointer to the preprocess structure (NULL pointer).
*            cPP_Coef -- filter coefficient
*
* Output:    hPreProcMblk -- memory allocated preprocess structure.
*
* Globals:   none
*
* Return:    0 : succeed
*            1 : fail
*******************************************************************************/
unsigned short VoxInitPreProc(void **hPreProcMblk, const float cPP_Coef)
{
  unsigned short RetFlag = 0;

  *hPreProcMblk = (void *)calloc(1, sizeof(PRE_PROC_mblk));
  if (*hPreProcMblk == NULL)
      RetFlag = 1;
  else {
     /* initialize the internal memories */
    ((PRE_PROC_mblk *)*hPreProcMblk)->fInX = 0.0F;
    ((PRE_PROC_mblk *)*hPreProcMblk)->fOutY = 0.0F;
    ((PRE_PROC_mblk *)*hPreProcMblk)->cPP_Coef = cPP_Coef;
  }

  return RetFlag;
}

/******************************************************************************
*
* Function:  VoxFreePreProc()
*
* Action:    free the preprocessing structure.
*
* Input:     hPreProcMblk -- the pointer of the preprocess structure 
*
* Output:    hPreProcMblk -- NULL preprocess structure
*
* Globals:   none
*
* Return:    none
*******************************************************************************/

void VoxFreePreProc(void **hPreProcMblk)
{
  SafeFree(*hPreProcMblk);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\psquan29.h ===
#ifndef PSQUAN29_H
#define PSQUAN29_H

#ifndef _VEM_RETCODE_
#define _VEM_RETCODE_
typedef unsigned short VEM_RETCODE; /* Voxware Core Interface error type.     */

#endif  /** #ifndef _VEM_RETCODE_ **/

/* main functions for init and free */
VEM_RETCODE PsInitQuan(void *pvCodecBlkEnc, void *pvCodecBlkDec);

#endif /*PSQUAN29_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\qenrgy12.c ===
/*******************************************************************************
*                        Voxware Proprietary Material                          *
*                        Copyright 1996, Voxware, Inc                          *
*                            All Rights Reserved                               *
*                                                                              *
*                       DISTRIBUTION PROHIBITED without                        *
*                      written authorization from Voxware                      *
*******************************************************************************/

/*******************************************************************************
* Filename:          QEnrgy12.c
*
* Purpose:           Energy Quantization for VR12                            
*                                                                              
* Functions:                                                                   
*                                                                              
* Author/Date:                                                                 
********************************************************************************
* Modifications:
*                   
* Comments:
* 
* Concerns:
*
* $Header:   /export/phobos/pvcs/r_and_d/archives/realtime/quan/QEnrgy12.c_v   1.2   26 Feb 1998 11:30:06   bobd  $
*******************************************************************************/
#include <stdlib.h>
#include <math.h>

#include "vLibQuan.h" /* ScalarQuant(), ScalarLUT() */

#include "quanvr12.h"
#include "QEnrgy12.h"

#include "xvocver.h"

/*******************************************************************************
* Function: VoxQuanEnergyVR12
*
* Action:
*
* Input:
*
* Output:
*
* Globals:        none
*
* Return:
********************************************************************************
* Implementation/Detailed Description:
*
* References:
********************************************************************************
* Modifications:
*
* Comments:
*
* Concerns/TBD:
*******************************************************************************/
 
void VoxQuanEnergyVR12( float           fEnergy, 
                        const float    *pfCodeBook, 
                        short           size, 
                        unsigned short *index
                      )
{ 
   unsigned int iIndex;

   if (fEnergy==0.0F) 
      fEnergy = 0.0000001F;
   fEnergy = (float)log10((double)fEnergy);
   iIndex = ScalarQuant(fEnergy, pfCodeBook, (int) size);

   *index = (unsigned short) iIndex;
}


float VoxUnQuanEnergyVR12( const float   *pfCodeBook, 
                           short          size, 
                           unsigned short index
                         )
{
   float fEnergy;

   fEnergy = ScalarLUT(pfCodeBook, (int) size, (unsigned int) index);
   fEnergy = (float)pow((double)10.0, (double)fEnergy);

   return(fEnergy);

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\qenrgy12.h ===
/*******************************************************************************
*                        Voxware Proprietary Material                          *
*                        Copyright 1996, Voxware, Inc                          *
*                            All Rights Reserved                               *
*                                                                              *
*                       DISTRIBUTION PROHIBITED without                        *
*                      written authorization from Voxware                      *
*******************************************************************************/

/*******************************************************************************
* Filename:          QEnrgy12.h                                                         
*                                                                              
* Purpose:           Energy Quantization for VR12                            
*                                                                              
* Functions:                                                                   
*                                                                              
* Author/Date:                                                                 
********************************************************************************
* Modifications:
*                   
* Comments:                                                                      
* 
* Concerns:
*
* 
*******************************************************************************/
#ifndef QENRGY12_H
#define QENRGY12_H

void VoxQuanEnergyVR12(float Energy, const float *cb, short size, unsigned short *index);
float VoxUnQuanEnergyVR12(const float *cb, short size, unsigned short index);

#endif /* QENRGY12_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\ptchcand.c ===
/*******************************************************************************
*                        Voxware Proprietary Material                          *
*                        Copyright 1996, Voxware, Inc                          *
*                            All Rights Reserved                               *
*                                                                              *
*                       DISTRIBUTION PROHIBITED without                        *
*                      written authorization from Voxware                      *
******************************************************************************/

/*******************************************************************************
* Filename:       PtchCand.c
*                                                                              
* Purpose:        Select pitch candidates for further analysis.
*                                                                              
* Functions:      SelectPitchCandidates()
*
* Author/Date:    Original developed by Gerard Aguilar, 97.
*                 Enhanced and R&D by Wei Wang, 4/97.
*
********************************************************************************
* Modifications:  12/97, splitted to small functions by WW.
*                                                                              
* Comments:                                                                    
* 
* Concerns:
*
* $Header:   /export/phobos/pvcs/r_and_d/archives/scaleable/pea/PtchCand.c_v   1.2   02 Apr 1998 14:46:58   weiwang  $
******************************************************************************/

/*** system include files ***/
#include <stdlib.h>
#include <assert.h>

/*** Research lib include files ***/
#include "vLibVec.h"

/*** codec related include files ***/
#include "VoxMem.h"
#include "LDPDAdef.h"
#include "PtchCand.h"
#include "CalcCost.h"

#include "xvocver.h"

/*--------------------------------------------------
   Local table -- pitch candidates
  --------------------------------------------------*/
extern const float CpfPitchTable[PITCH_TABLE_SIZE];

/*--------------------------------------------------
   local definitions
  --------------------------------------------------*/

#define SUB_MAX        5 
#define MINCON         1.0e-6F    
#define RIGHT_P0_SCALE   1.333F
#define LEFT_P0_SCALE    0.75F
#define COST_THRESHOLD    0.78F
#define HP_COST_THRESHOLD  0.84F
#define SEARCH_BOUND  (1.0F/1.2F)
#define LOW_THRESHOLD  0.2F
#define CONF_PITCH  30.0F
#define COST_THRESHOLD_BACK  0.72F

#define LD_TRUE  1
#define LD_FALSE 0

/* Macro for exchanging floating value */
#define ExchangeFltValue(x, y) {float a; a=x; x=y; y=a;}

/* Macro for computing the total cost of current frame
   and backward tracking frame */
#define CompBackCost(x_1, x) ((x_1 > x) ? (0.5F*(x_1+x)) : x)


/*--------------------------------------------------
  Private functions
  --------------------------------------------------*/
static 
int BackWard_Check(const float *pfCostFunc, float fLastP0, float fLastCost,
                   float *pfNewBackCost);

static 
int HarmThreshold(float *CostFunc, int *Ind_Cand, int *piHP_Index);

static 
void EliminateSmallP0(float *CostFunc, int *Ind_Cand, int *piNumCand, 
                      int *piHP_Index);

static 
void AddBackTrackCand(float *CostFunc, int iBackIndex, int *Ind_Cand,
                      int *piNumCand, int *piHP_Index);

static 
float RefineLDPitch(int iIndex, const int *piPeakFreq, const float *pfMag, 
                    int iBaseBand, float fNormEng, float *pfMaxCost);


/******************************************************************************
* Function:  SelectPitchCandidates()
*
* Action:    Select most possible candidates.
*
* Input:     pfMag       -- compressed magnitude spectrum
*            iBaseBand   -- length of base bandwidth
*            piPeakFreq  -- peak indices
*            pfPitchCand -- address to the output pitch candidates
*            pfCandCost  -- address to the cost values of selected candidates
*            fLastP0     -- previous pitch for backward tracking
*            flastCost   -- the cost value of previous pitch period
*            piHP_Index  -- address to the index of pfPitchCand to get the high-
*                           possibility pitch candidate
*
* Output:    pfPitchCand -- pitch periods of selected candidates
*            piHP_Index  -- index of pfPitchCand to get the high-
*                           possibility pitch candidate
*
* Globals:   none
*
* Return:    number of candidates
*******************************************************************************
*
* Implementation/Detailed Description:
*
*******************************************************************************
*
* Modifications:
*
* Comments:
*
* Concerns/TBD:
*
******************************************************************************/
int SelectPitchCandidates( STACK_R 
                           const float *pfMag, 
                           int         iBaseBand, 
                           const int   *piPeakFreq, 
                           float       *pfPitchCand, 
                           float       *pfCandCost, 
                           float       fLastP0,
                           float       fLastCost,
                           int         *piHP_Index
                         )
{
  int iBackIndex;
  float fNewBackCost;
  int iNumCand, iNumCand_1;
  int i, k;
  int iHP_Index;
  float fCost;
  int iIndex;
  float fNormEnergy;

STACK_INIT
  int piCandInd_0[SUB_MAX+1];
  float pfCostFunc[PITCH_TABLE_SIZE];
STACK_INIT_END

STACK_ATTACH(int *, piCandInd_0)
STACK_ATTACH(float *, pfCostFunc)

STACK_START

  assert(pfMag != NULL);
  assert(piPeakFreq != NULL);
  assert(pfPitchCand != NULL);
  assert(piHP_Index != NULL);

  /*----------------------------------------------------------------------
    (0) Compute normalization factor .
    ----------------------------------------------------------------------*/
  fNormEnergy = MINCON + DotProd(pfMag, pfMag, iBaseBand);
  
  fNormEnergy = 10.0F/fNormEnergy;

  /*----------------------------------------------------------------------
    (1) Compute the cost function (or likelyhood function) of all pitch
        candidates.
    ----------------------------------------------------------------------*/
  for (i = 0; i < PITCH_TABLE_SIZE; i++)
    pfCostFunc[i] = CalcCostFunc(CpfPitchTable[i], piPeakFreq, pfMag,
                                 iBaseBand, fNormEnergy);


  /*----------------------------------------------------------------------
    (2) Backward tracking and modify the cost function for pre-selection.
    ----------------------------------------------------------------------*/
  iBackIndex = BackWard_Check(pfCostFunc, fLastP0, fLastCost,
                              &fNewBackCost);


  /*----------------------------------------------------------------------
    (3) Replace the cost value of iBackIndex using fNewBackCost.
    Then extract good pitch candidates using progressive harmonic thresholding.
    Then change back to the original value.
    ----------------------------------------------------------------------*/

  /*----------------------------------------------------------------------
    Get the regular candidates using Harmonic Progressive thresholding.
    ----------------------------------------------------------------------*/
  ExchangeFltValue(fNewBackCost, pfCostFunc[iBackIndex]);

  iNumCand = HarmThreshold(pfCostFunc, piCandInd_0, &iHP_Index);
  
  /*----------------------------------------------------------------------
    Prevent pick up too small pitch candidate, -- important for the plusive
    speech.
    ----------------------------------------------------------------------*/
  EliminateSmallP0(pfCostFunc, piCandInd_0, &iNumCand, &iHP_Index);


  /*----------------------------------------------------------------------
    Add the backward-tracked candidate.
    ----------------------------------------------------------------------*/
  AddBackTrackCand(pfCostFunc, iBackIndex, piCandInd_0, &iNumCand, &iHP_Index);

  ExchangeFltValue(fNewBackCost, pfCostFunc[iBackIndex]);

  
  /*----------------------------------------------------------------------
    (4) Refine the pitch and only choose at most 3 candidates for later
    calculateion.
    ----------------------------------------------------------------------*/
  k = 0;  
  iNumCand_1 = iNumCand-1;
  for (i = 0; i < iNumCand; i++)
    {
      if ((i != 0) && (i != (iNumCand_1)) && (i != iHP_Index))
        continue;

      /*** find the new high possibility index ***/
      if (i == iHP_Index)
        *piHP_Index = k;

      iIndex = piCandInd_0[i];

      /*** find the cost value ***/
      fCost = pfCostFunc[iIndex];

      /*** refine pitch value ***/
      pfPitchCand[k] = RefineLDPitch(iIndex, piPeakFreq, pfMag,
                                     iBaseBand, fNormEnergy, &fCost);

      /*** put back the backward tracking information ***/
      if (iIndex == iBackIndex)
        fCost = CompBackCost(fLastCost, fCost);

      /*** Save to New arrays ***/
      pfCandCost[k] = fCost;

      k++;
    } 

  iNumCand = k;

STACK_END

  return iNumCand;
}


/******************************************************************************
* Function:  BackWard_Check()
*
* Action:    find potential pitch candidate by backward tracking
*
* Input:     pfCostFunc    -- cost values of all pitch candidates (from table)
*            fLastP0       -- pitch period of last frame
*            fLastCost     -- cost value of last frame pitch period
*            pfNewBackCost -- array to cost value from backward tracking
*
* Output:    pfNewBackCost -- modified cost value for the pitch from backward
*                             tracking
*
* Globals:   none
*
* Return:    pitch index from backward tracking
*******************************************************************************
*
* Implementation/Detailed Description:
*
*******************************************************************************
*
* Modifications:
*
* Comments:
*
* Concerns/TBD:
*
******************************************************************************/

static 
int BackWard_Check( const float *pfCostFunc, 
                    float        fLastP0, 
                    float        fLastCost,
                    float       *pfNewBackCost
                  )
{
  float fRightP0, fLeftP0;
  int i;
  float fMaxCost;
  int iBackIndex;

  assert(pfCostFunc != NULL);
  assert(pfNewBackCost != NULL);

  /* Find the boundaries */
  fRightP0 = fLastP0*RIGHT_P0_SCALE;
  fLeftP0 = fLastP0*LEFT_P0_SCALE;

  /* find the left boundary */
  i = 0;
  while (CpfPitchTable[i] < fLeftP0) 
     i++;

  /* Find the candidate with the maximum cost value from the 
     backward tracking */
  fMaxCost = pfCostFunc[i];
  iBackIndex = i;

  do {
    if (fMaxCost < pfCostFunc[i])
      {
        fMaxCost = pfCostFunc[i];
        iBackIndex = i;
      }
    i++;
  } while((i < PITCH_TABLE_SIZE) && (CpfPitchTable[i] <= fRightP0));
  
  /* Now compute the total cost value (combine the cost from the last 
     frame and the current frame) */
  *pfNewBackCost = CompBackCost(fLastCost, fMaxCost);

  return iBackIndex;
}


/******************************************************************************
* Function:  HarmThreshold()
*
* Action:    Get selected candidates using Harmonic Progressive Thresholding
*            algorithm
*
* Input:     pfCostFunc  -- cost values of all pitch candidates (from table)
*            piIndCand   -- address to the indices of selected candidates
*            piHPIndex   -- address to the high-possibility candidate 
*
* Output:    piIndCand -- the indices of selected candidates
*            piHPIndex -- high-possibility candidate
*
* Globals:   none
*
* Return:    number of selected candidates
*******************************************************************************
*
* Implementation/Detailed Description:
*
*******************************************************************************
*
* Modifications:
*
* Comments:
*
* Concerns/TBD:
*
******************************************************************************/
static 
int HarmThreshold( float   *pfCostFunc, 
                   int     *piIndCand, 
                   int     *piHPIndex
                 )
{
  float fMaxCost;
  int iPitchIndex;
  float fP0;
  int iHPIndex;
  float fLocalMaxCost;
  int iLocalMaxInd;
  int iLocalLength;
  int iNumCand;


  assert(pfCostFunc != NULL);
  assert(piIndCand != NULL);
  assert(piHPIndex != NULL);

  /*--------------------------------------------------
    Initializing ...
    --------------------------------------------------*/
  iHPIndex = 0;
  iNumCand = 0;
  iPitchIndex = PITCH_TABLE_SIZE-1;   /* the end point index */
  fMaxCost = -1.0F;

  while (iNumCand < SUB_MAX)
    { 
      /*--------------------------------------------------
        Find the local maxima.
        --------------------------------------------------*/
      iLocalLength = iPitchIndex+1;
      FindMaxValueFlt(pfCostFunc, iLocalLength, &iLocalMaxInd,
                      &fLocalMaxCost);

      /*--------------------------------------------------
        Only choose the candidate > threshold.
        --------------------------------------------------*/
      if (fLocalMaxCost < (COST_THRESHOLD*fMaxCost)) 
         break;

      /*--------------------------------------------------
        Fill up the local candidate.
        --------------------------------------------------*/
      piIndCand[iNumCand] = iLocalMaxInd;

      /*--------------------------------------------------
        Find the high probability candidate.
        --------------------------------------------------*/
      if (fLocalMaxCost >= (HP_COST_THRESHOLD*fMaxCost))
        iHPIndex = iNumCand;

      /*--------------------------------------------------
        Replace global maxima with the local one.
        --------------------------------------------------*/
      fMaxCost = fLocalMaxCost;

      /*--------------------------------------------------
        Update ... 
        --------------------------------------------------*/
      iNumCand++;

      /*--------------------------------------------------
        Find the next search range 
        --------------------------------------------------*/
      iPitchIndex = iLocalMaxInd;
      fP0 = CpfPitchTable[iPitchIndex]*SEARCH_BOUND;  
      if (fP0 < CpfPitchTable[0])   /* don't go over table length */
         break;

      while (CpfPitchTable[iPitchIndex] > fP0)  
         iPitchIndex--;

      /*--------------------------------------------------
        Pass a valley to make sure the new candidate is
        a peak.
        --------------------------------------------------*/
      while ((iPitchIndex >= 0)&&
             (pfCostFunc[iPitchIndex] < pfCostFunc[iPitchIndex+1]))
          iPitchIndex --;         

      if (iPitchIndex<0) break;
    }

  *piHPIndex = iHPIndex;

  return iNumCand;
}



/******************************************************************************
* Function:  EliminateSmallP0()
*
* Action:    To prevent pick up too small pitch period as candidates (high 
*            frequency pitch). This is important to get better quality for
*            plusive speech.
*
* Input:     pfCostFunc  -- cost function for all candidates in pitch table
*            piIndCand   -- indices for seleted pitch candidates
*            piNumCand   -- the number of seleted pitch candidates
*            piHPIndex   -- the index of high-possibility pitch candidate
*
* Output:    piIndCand   -- updated indices for seleted pitch candidates
*            piNumCand   -- updated number of seleted pitch candidates
*            piHPIndex   -- updated index for high-possiblity pitch candidate
*
* Globals:   none
*
* Return:    none
*******************************************************************************
*
* Implementation/Detailed Description:
*
*******************************************************************************
*
* Modifications:
*
* Comments:
*
* Concerns/TBD:
*
******************************************************************************/
static 
void EliminateSmallP0( float  *pfCostFunc, 
                       int    *piIndCand, 
                       int    *piNumCand, 
                       int    *piHPIndex
                     )
{
  float fMaxCost;
  int iPitchIndex;
  int iLocalMaxInd;
  float fOrgP0, fTryP0;
  int iHPIndex;
  int iHitFlag;
  float fHitThreshold;
  int iNumP0Index;
  int iNumCand;

  assert(pfCostFunc != NULL);
  assert(piIndCand != NULL);
  assert(piNumCand != NULL);
  assert(piHPIndex != NULL);

  iHPIndex = *piHPIndex;
  iNumCand = *piNumCand;

  /*--------------------------------------------------
    Get the pitch value of the smallest candidate.
    --------------------------------------------------*/
  iPitchIndex = piIndCand[iNumCand-1];
  fOrgP0 = CpfPitchTable[iPitchIndex];

  /*--------------------------------------------------
    Only search if Pitch < 30.0F
    --------------------------------------------------*/
  if (fOrgP0 <= CONF_PITCH)
    {
      /*--------------------------------------------------
        Set the cost threshold.
        --------------------------------------------------*/
      iHitFlag = LD_FALSE;
      fHitThreshold = pfCostFunc[iPitchIndex] * LOW_THRESHOLD;

      /*--------------------------------------------------
        check the cost values around 2*P0.
        --------------------------------------------------*/
      fTryP0 = fOrgP0 * 2.0F;

      while(CpfPitchTable[++iPitchIndex] < fTryP0);

      if ((pfCostFunc[iPitchIndex-1]<fHitThreshold)
          && (pfCostFunc[iPitchIndex]<fHitThreshold))
        iHitFlag = LD_TRUE;


      /*--------------------------------------------------
        check the cost values around 3*P0.
        -------------------------------------------------*/
      fTryP0 = fOrgP0 * 3.0F;

      while(CpfPitchTable[++iPitchIndex] < fTryP0);

      if ((pfCostFunc[iPitchIndex-1]<fHitThreshold)
          && (pfCostFunc[iPitchIndex]<fHitThreshold))
        iHitFlag = LD_TRUE;

      
      /*--------------------------------------------------
        Re-select the pitch candidate if the conditions
        are failed.
        --------------------------------------------------*/
      if (iHitFlag == LD_TRUE) {
        if (iNumCand == LD_TRUE) 
          {
            /*--------------------------------------------------
              if there is only one candidate, replace it using 
              the largest cost from [3*P0 MAX_PITCH].
              --------------------------------------------------*/
            iNumP0Index = PITCH_TABLE_SIZE-iPitchIndex;
            FindMaxValueFlt(&(pfCostFunc[iPitchIndex]), iNumP0Index,
                            &iLocalMaxInd, &fMaxCost);
            piIndCand[0] = iLocalMaxInd + iPitchIndex;
          }
        else 
          {
            /*--------------------------------------------------
              if there are more than one candidate, remove the
              smallest pitch candidate.
              --------------------------------------------------*/
            iNumCand--;
            
            /*--------------------------------------------------
              if the removed one is with high-possibility,
              reset the HP candidate with the largest cost value.
              --------------------------------------------------*/
            if (iHPIndex == iNumCand)
              iHPIndex = 0;
          }
      }
    }

  *piHPIndex = iHPIndex;
  *piNumCand = iNumCand;
}



/******************************************************************************
* Function:  AddBackTrackCand()
*
* Action:    Add backward tracked pitch to the seleted pitch candidates list
*
* Input:     pfCostFunc  -- cost function for all candidates in pitch table
*            iBackIndex  -- backward tracked pitch index
*            piIndCand   -- indices for seleted pitch candidates
*            piNumCand   -- the number of seleted pitch candidates
*            piHPIndex   -- the index of high-possibility pitch candidate
*
* Output:    piIndCand   -- updated indices for seleted pitch candidates
*            piNumCand   -- updated number of seleted pitch candidates
*            piHPIndex   -- updated index for high-possiblity pitch candidate
*
* Globals:   none
*
* Return:    none
*******************************************************************************
*
* Implementation/Detailed Description:
*
*******************************************************************************
*
* Modifications:
*
* Comments:
*
* Concerns/TBD:
*
******************************************************************************/

static 
void AddBackTrackCand( float  *pfCostFunc, 
                       int    iBackIndex, 
                       int    *piIndCand,
                       int    *piNumCand, 
                       int    *piHPIndex
                      )
{
  float fMaxCost;
  int iHPIndex;
  int iHitFlag;
  float fHitThreshold;
  int iNumCand;
  int iInsertPoint;
  float fBackCost;
  int i;

  assert(pfCostFunc != NULL);
  assert(piIndCand != NULL);
  assert(piNumCand != NULL);
  assert(piHPIndex != NULL);
  
  iHPIndex = *piHPIndex;
  iNumCand = *piNumCand;

  /*--------------------------------------------------
    Search whether the backward tracked candidate
    is in the list. And find the location 
    where BackIndex>Ind_Cand[i].
    --------------------------------------------------*/
  iHitFlag = LD_FALSE;
  for (i = 0; i < iNumCand; i++) {
    if (iBackIndex == piIndCand[i])
       iHitFlag = LD_TRUE;
    if (iBackIndex > piIndCand[i]) 
       break;
  }
  iInsertPoint = i;

  /*-----------------------------------------------------
    If the backward-tracked candidate is an extra one ...
    -----------------------------------------------------*/
  if (iHitFlag == LD_FALSE) 
    {
      /*--------------------------------------------------
        Find the thresholds
        --------------------------------------------------*/
      fBackCost = pfCostFunc[iBackIndex];
      fHitThreshold = COST_THRESHOLD_BACK*pfCostFunc[piIndCand[0]];
      fMaxCost = HP_COST_THRESHOLD*pfCostFunc[piIndCand[iHPIndex]];

      /*--------------------------------------------------
        If the new candidate is smaller than whole selected
        candidatesthe, or if it's small than the 
        high-possibility one, add it to the list.
        --------------------------------------------------*/
      if ((iInsertPoint==iNumCand && fBackCost>=fHitThreshold)
          || (iInsertPoint>iHPIndex && fBackCost>=fMaxCost))
        {
          /*----------------------------------------
            Shift the indeces.
            ----------------------------------------*/
          for (i = iNumCand; i > iInsertPoint; i--) 
            piIndCand[i] = piIndCand[i-1];
        
          /*----------------------------------------
            Insert the new candidate.
            ----------------------------------------*/
          piIndCand[iInsertPoint] = iBackIndex;

          /*----------------------------------------
            Test and reset the high-possibility 
            index.
            ----------------------------------------*/
          if (fBackCost>=fMaxCost)
            iHPIndex = iInsertPoint;

          /*----------------------------------------
            Increase the number of candidates.
            ----------------------------------------*/
          iNumCand++;
        }
    }

  /*--------------------------------------------------
    Return the HP_Index and number of candidates.
    --------------------------------------------------*/
  *piHPIndex = iHPIndex;
  *piNumCand = iNumCand;

}

/******************************************************************************
* Function:  RefineLDPitch()
*
* Action:    Get the refined pitch by choosing the maximum likely-hood functions
*            from two neighbor pitches.
*
* Input:     iIndex      -- index of the pitch who needs to be refined
*            piPeakFreq  -- peaks' indices 
*            pfMag       -- compressed magnitude spectrum
*            iBaseBand   -- length of base-band
*            fNormEng    -- energy normalization factor
*            pfMaxCost   -- address to the output maximum cost value
*
* Output:    pfMaxCost   -- cost value of the refined pitch
*
* Globals:   none
*
* Return:    refined pitch value
*******************************************************************************
*
* Implementation/Detailed Description:
*
*******************************************************************************
*
* Modifications:
*
* Comments:
*
* Concerns/TBD:
*
******************************************************************************/

static
float RefineLDPitch( int         iIndex,
                     const int   *piPeakFreq, 
                     const float *pfMag, 
                     int         iBaseBand,
                     float       fNormEng, 
                     float       *pfMaxCost
                   )
{
  float fBestPitch;
  float fPitch;
  float fCost;
  float pfPitchCand[2];
  int k, i;

  assert(piPeakFreq != NULL);
  assert(pfMag != NULL);
  assert(pfMaxCost != NULL);

  /* get the pitch candidates */
  fBestPitch = CpfPitchTable[iIndex];

  k = 0;
  /* find pitch period on the left side of input candidate */
  if (iIndex > 0)
    pfPitchCand[k++] = 0.5F*(fBestPitch + CpfPitchTable[iIndex-1]);
  iIndex++;
  /* find pitch period on the right side of input candidate */
  if (iIndex < PITCH_TABLE_SIZE)
    pfPitchCand[k++] = 0.5F*(fBestPitch + CpfPitchTable[iIndex]);


  /* compute the cost values of two refined pitch period. 
     And find the maximum among the original and the two refined ones. */
  for (i = 0; i < k; i++)
    {
      fPitch = pfPitchCand[i];
      fCost = CalcCostFunc(fPitch, piPeakFreq, pfMag, 
                           iBaseBand, fNormEng);
      if (fCost > *pfMaxCost) {
        fBestPitch = fPitch;
        *pfMaxCost = fCost;
      }
    }

  return fBestPitch;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\qenrgy15.h ===
/*******************************************************************************
*                        Voxware Proprietary Material                          *
*                        Copyright 1996, Voxware, Inc                          *
*                            All Rights Reserved                               *
*                                                                              *
*                       DISTRIBUTION PROHIBITED without                        *
*                      written authorization from Voxware                      *
*******************************************************************************/

/*******************************************************************************
* Filename:          QEnrgy15.h                                                         
*                                                                              
* Purpose:           Energy Quantization for VR15                            
*                                                                              
* Functions:                                                                   
*                                                                              
* Author/Date:                                                                 
********************************************************************************
* Modifications:
*                   
* Comments:                                                                      
* 
* Concerns:
*
* 
*******************************************************************************/
#ifndef QENRGY15_H
#define QENRGY15_H

void VoxQuanEnergyVR15(float Energy, const float *cb, short size, unsigned short *index);
float VoxUnQuanEnergyVR15(const float *cb, short size, unsigned short index);

#endif /* QENRGY15_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\qenrgy28.h ===
/*******************************************************************************
*                        Voxware Proprietary Material                          *
*                        Copyright 1996, Voxware, Inc                          *
*                            All Rights Reserved                               *
*                                                                              *
*                       DISTRIBUTION PROHIBITED without                        *
*                      written authorization from Voxware                      *
*******************************************************************************/

/*******************************************************************************
* Filename:          QEnrgy28.h                                                         
*                                                                              
* Purpose:           Energy Quantization for RT28                            
*                                                                              
* Functions:                                                                   
*                                                                              
* Author/Date:                                                                 
********************************************************************************
* Modifications:
*                   
* Comments:                                                                      
* 
* Concerns:
*
* 
*******************************************************************************/
#ifndef QENRGY28_H
#define QENRGY28_H

void VoxQuanEnergyRT28(float Energy, const float *cb, short size, unsigned short *index);
float VoxUnQuanEnergyRT28(const float *cb, short size, unsigned short index);

#endif /* QENRGY28_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\qenrgy24.h ===
/*******************************************************************************
*                        Voxware Proprietary Material                          *
*                        Copyright 1996, Voxware, Inc                          *
*                            All Rights Reserved                               *
*                                                                              *
*                       DISTRIBUTION PROHIBITED without                        *
*                      written authorization from Voxware                      *
*******************************************************************************/

/*******************************************************************************
* Filename:          QEnrgy.h                                                         
*                                                                              
* Purpose:           Energy Quantization for RT24                            
*                                                                              
* Functions:                                                                   
*                                                                              
* Author/Date:                                                                 
********************************************************************************
* Modifications:
*                   
* Comments:                                                                      
* 
* Concerns:
*
* 
*******************************************************************************/
#ifndef QENRGY24_H
#define QENRGY24_H

void VoxQuanEnergy24(float Energy, const float *cb, short size, unsigned short *index);
float VoxUnQuanEnergy24(const float *cb, short size, unsigned short index);

#endif /* QENRGY24_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\qenrgy29.h ===
/*******************************************************************************
*                        Voxware Proprietary Material                          *
*                        Copyright 1996, Voxware, Inc                          *
*                            All Rights Reserved                               *
*                                                                              *
*                       DISTRIBUTION PROHIBITED without                        *
*                      written authorization from Voxware                      *
*******************************************************************************/

/*******************************************************************************
* Filename:          QEnrgy29.h                                                         
*                                                                              
* Purpose:           Energy Quantization for RT29                            
*                                                                              
* Functions:                                                                   
*                                                                              
* Author/Date:                                                                 
********************************************************************************
* Modifications:
*                   
* Comments:                                                                      
* 
* Concerns:
*
* 
*******************************************************************************/
#ifndef QENRGYRT29_H
#define QENRGYRT29_H

void VoxQuanEnergyRT29(float Energy, const float *cb, short size, unsigned short *index);
float VoxUnQuanEnergyRT29(const float *cb, short size, unsigned short index);

#endif /* QENRGYRT29_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\qotstrct.h ===
/******************************************************************************
*                        Voxware Proprietary Material
*                        Copyright 1996, Voxware, Inc
*                            All Rights Reserved
*
*                       DISTRIBUTION PROHIBITED without
*                      written authorization from Voxware
******************************************************************************/

/******************************************************************************
* Filename:        QoTstrct.h
*
* Purpose:         internal structure for VCI QOT
*
* Functions:       
*
* Author/Date:     Robert Zopf 08/18/97
*******************************************************************************
*
* Modifications: 
*
* Comments:
*
* Concerns:
*
* $Header:   /export/phobos/pvcs/r_and_d/archives/scaleable/vci/QoTstrct.h_v   1.1   13 Feb 1998 10:42:46   weiwang  $
******************************************************************************/

#ifndef QOT_STRCT_H
#define QOT_STRCT_H

typedef struct
{
   float FrameStatus;
   short LastFrameUsed;
   unsigned long wNumOfBits;
   short SkippedFrames;
} VCI_QOT_BLOCK;


#endif /* QOT_STRCT_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\qotlogic.h ===
/******************************************************************************
*                        Voxware Proprietary Material
*                        Copyright 1996, Voxware, Inc
*                            All Rights Reserved
*
*                       DISTRIBUTION PROHIBITED without
*                      written authorization from Voxware
******************************************************************************/

/******************************************************************************
* Filename:        QoTlogic.h
*
* Purpose:         Brains of the codec QoT.
*
* Functions:       QoTFrameLogic
*
* Author/Date:     Robert Zopf 08/18/97
*******************************************************************************
*
* Modifications: 
*
* Comments:
*
* Concerns:
*
* $Header:   /export/phobos/pvcs/r_and_d/archives/common/vci/QoTlogic.h_v   1.2   16 Mar 1998 17:04:40   weiwang  $
******************************************************************************/

#ifndef QOT_LOGIC_H
#define QOT_LOGIC_H

#define REPEAT_FRAMES     2            /* can repeat up to these many frames */


/******************************************************************************
* Function:  QoTFrameLogic() 
*
* Action:    Brains of the codec QoT.
*
* Input: 
*        wLookaheadCount        - number of frames ahead that frame information
*                                 is present in lpaFrames.
*
*        wLookbackCount         - number of frames back that frame information
*                                 is present in lpaFrames.
*
*        *lpaFrames             - pointer to an array of structures describing
*                                 the frames for which frame information is 
*                                 available.  This array starts with the frame
*                                 [n-wLookbackCount] and continues until frame
*                                 [n+wLookaheadCount] for a total array size of
*                                 wLookbackCount+wLookaheadCount+1.  The current
*                                 frame [n] is located at 
*                                 lpaFrames[wLookbackCount].
*
*        fWarp                  - the desired warp for the current frame.
*
*
* Output:
*        *pwUseFrame            - the index of the frame into lpaFrames of the 
*                                 frame use for synthesis of the current frame.
*        *pfUseFrameWarp        - the warp to apply with *pwUseFrame.
*
*        *pwFrameStatus         - internal memory required by the function. This
*                                 variable keeps track of the number of frames 
*                                 the QoT is up or down with respect to the 
*                                 current time. That is, 0 indicates we are up 
*                                 to date, -n indicates we are currently delayed 
*                                 by n frames, and +n indicates we have 
*                                 synthesized n future frames.
*
*        *pwSkipFrame           - flag to indicate whether or not to skip this 
*                                 frame entirely. This may occur if the current
*                                 frame is not present.
*
*        *pwFadeToSilence       - flag to indicate whether or not to fade to 
*                                 silence for the current frame. This may occure 
*                                 if the current frame is not present.
* Globals:    none
*
* Return:     none
*
******************************************************************************/
void QoTFrameLogic(short wLookaheadCount, 
                   short wLookbackCount,
                   const QoTFrame *lpaFrames, 
                   float fWarp,
                   short *pwUseFrame, 
                   float *pfUseFrameWarp,
                   float *pwFrameStatus, 
                   short *pwSkipFrame,
                   short *pwFadeToSilence);

#endif /* QOT_LOGIC_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\qp0sc3.c ===
/******************************************************************************
*                        Voxware Proprietary Material                         *
*                        Copyright 1996, Voxware, Inc                         *
*                            All Rights Reserved                              *
*                                                                             *
*                       DISTRIBUTION PROHIBITED without                       *
*                      written authorization from Voxware                     *
******************************************************************************/

/******************************************************************************
* Filename:          QPitchSC3.c
*                                                                             
* Purpose:           Pitch Quantization for SC36
*                                                                             
* Functions:    VoxQuanPitchSC3, VoxUnQuanPitchSC3, UnQuanMidPitchSC3
*
* Author/Date:  
********************************************************************************
* Modifications:  (1) Change from Log10 to faster fLog2(). And simplify the 
*                 implementation.
*                 (2) Change fLog2() back to log() to support old bitstream.
* Comments:
* 
* Concerns: If not use linear-approximated fLog2, LOG2PMAX, LOG2STEP and 
*           INV_LOG2STEP have to be recalculated.
*
* $Header:   /export/phobos/pvcs/r_and_d/archives/scaleable/quan/QP0SC3.c_v   1.6   17 Aug 1998 18:14:16   weiwang  $
* 
******************************************************************************/
#include <stdlib.h>
#include <math.h>
#include <assert.h>
#include "vLibMath.h"

#include "quansc36.h"
#include "QP0SC3.h"
#include "MidPitch.h"

#include "xvocver.h"

#define LOGExpPMAX         5.0751738F   /* Log(PMAX) = Log(160) */
#define LOGExpPMIN         2.0794415F         /* Log(PMIN) = Log(8) */
#define LOGExpSTEP         1.1747970e-2F  /* (LOGExpPMAX-LOGExpPMIN)/MaxLevel */
#define INV_LOGExpSTEP     85.121091F    /* MaxLevel/(LOGExpPMAX-LOGExpPMIN) */

#ifndef DECODE_ONLY
/******************************************************************************
* Function: VoxQuanPitchSC3
*
* Action:  Quantize pitch for SC36
*
* Input:   fPitch -- input pitch value
*
* Output:  same as return
*
* Globals:   none
*
* Return: pitch quantization index
*******************************************************************************
* Implementation/Detailed Description:
*   This is exponential pitch quantizer. 
*   Assume: (Pmax/Pitch)^(1/Level) = (Pmax/Pmin)^(1/MaxLevel), where Pmax = 160,
*   Pmin = 8, MaxLevel = 2^7-1=255. For quantization, we need get Level with 
*   known Pitch value.
*
*   Use log function, the equation can change to: 
*    (log(Pmax)-log(Pitch))/Level = (log(Pmax)-log(Pmin))/MaxLevel
*   Then quantization level can be solved by:
*     Level = (log(Pmax)-log(Pitch))/{(log(Pmax)-log(Pmin))/MaxLevel}
*
* References:
********************************************************************************
* Modifications:
*
* Comments:
*
* Concerns/TBD:
******************************************************************************/

int VoxQuanPitchSC3( float fPitch)
{
  float fLevel;
  int iIndex;

  /* truncate pitch value */
  fPitch = VoxMAX(fPitch, MIN_QUAN_PITCH_PERIOD_SC3);
  fPitch = VoxMIN(fPitch, MAX_QUAN_PITCH_PERIOD_SC3);

  /* convert pitch to level */
  fLevel = (float) (LOGExpPMAX - log(fPitch))*INV_LOGExpSTEP;

  /* round to integer level */
  VoxROUND2(fLevel, iIndex);

  return iIndex;
}
#endif

/******************************************************************************
* Function: VoxUnQuanPitchSC3
*
* Action: unquantize pitch for SC36
*
* Input:  iIndex -- pitch quantization index
*
* Output: same as return
*
* Globals: none
*
* Return: quantized pitch 
*******************************************************************************
* Implementation/Detailed Description:
*   Assume: (Pmax/Pitch)^(1/Level) = (Pmax/Pmin)^(1/MaxLevel), where Pmax = 160,
*   Pmin = 8, MaxLevel = 2^7-1=255. For unquantization, we need get Pitch with 
*   known quantization level.
*
*   Use log function, the equantion can change to:
*    (log(Pmax)-log(Pitch))/Level = (log(Pmax)-log(Pmin))/MaxLevel
*   Then log(Pitch) can be obtained by:
*     log(Pitch) = log(Pmax)- Level * (log(Pmax)-log(Pmin))/MaxLevel.
*
*   Use inverse of log -- exp, Pitch = exp(fLog2(Pmax) - Level * LOGExpSTEP).
*
* References:
********************************************************************************
* Modifications:
*
* Comments:
*
* Concerns/TBD:
******************************************************************************/

float VoxUnQuanPitchSC3( int iIndex)
{
  float fPitch;

  assert((iIndex >= 0) && (iIndex < (1<<BITS_PITCH_SC3)));

  fPitch = (float)exp(LOGExpPMAX-(float)iIndex*LOGExpSTEP);

  return fPitch;
}


/******************************************************************************
* Function: UnQuanMidPitchSC3
*
* Action: Use conditional interpolation to get the quantized middle frame pitch.
*
* Input:    fPitch_1 -- the quantized previous frame pitch
*           fPitch -- the quantized current frame pitch
*           fPv_1  -- the quantized previous voicing
*
* Output:   same as return
*
* Globals:        none
*
* Return: quantized middle frame pitch.
*******************************************************************************
* Implementation/Detailed Description:
*
* References:
********************************************************************************
* Modifications:
*
* Comments:
*
* Concerns/TBD:
******************************************************************************/

float UnQuanMidPitchSC3( float fPitch_1,  float fPitch, 
                         float fPv_1,  float fPv)
{
  return MidEstPitch(fPitch_1, fPitch, fPv_1, fPv);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\qpitch12.c ===
/*******************************************************************************
*                        Voxware Proprietary Material                          *
*                        Copyright 1996, Voxware, Inc                          *
*                            All Rights Reserved                               *
*                                                                              *
*                       DISTRIBUTION PROHIBITED without                        *
*                      written authorization from Voxware                      *
*******************************************************************************/

/*******************************************************************************
* Filename:          QPitch12.c                                                         
*                                                                              
* Purpose:           Pitch Quantization for VR12                             
*                                                                              
* Functions:                                                                   
*                                                                              
* Author/Date:                                                                 
********************************************************************************
* Modifications:
*                   
* Comments:                                                                      
* 
* Concerns:
*
* 
*******************************************************************************/
#include <stdlib.h>
#include <math.h>
#include <assert.h>

#include "quanvr12.h"
#include "QPitch12.h"

#include "xvocver.h"

/*******************************************************************************
* Function: VoxQuanPitchVR12
*
* Action:
*
* Input:
*
* Output:
*
* Globals:        none
*
* Return:
********************************************************************************
* Implementation/Detailed Description:
*
* References:
********************************************************************************
* Modifications:
*
* Comments:
*
* Concerns/TBD:
*******************************************************************************/
 
#define Q_PITCH_LEVEL           (1<<F0_BITS_VR12_VOICED)
#define M_T0      1.023868851    /* alpha = pow(10, log10(Pmax/Pmin)/(Level-1)) */

short VoxQuanPitchVR12(float pitch)
{
  short qP0;

  assert(pitch > 0);
  qP0 = (short)floor((log10((double)QUANT_MAX_PITCH_VR/(double)pitch)) / log10(M_T0)+0.5);
  if (qP0 >= Q_PITCH_LEVEL)   qP0 = Q_PITCH_LEVEL-1;
  if (qP0 < 0)  qP0 = 0;
  return qP0;
}


float VoxLutPitchVR12(short qP0)
{	
  float pitch;
  
  pitch = (float)((double)QUANT_MAX_PITCH_VR * pow(M_T0, (double)(-qP0)));
  
  if (pitch < (float)QUANT_MIN_PITCH_VR)  pitch = (float)QUANT_MIN_PITCH_VR;
  if (pitch > (float)QUANT_MAX_PITCH_VR)  pitch = (float)QUANT_MAX_PITCH_VR;

#if 1  /* WIN16 ?? */

/* if (486) */
  {
     if (pitch > 125.0)
        pitch*=0.5F;
  }
/* endif */

#endif
  
  return pitch;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\qpitch15.h ===
/*******************************************************************************
*                        Voxware Proprietary Material                          *
*                        Copyright 1997, Voxware, Inc                          *
*                            All Rights Reserved                               *
*                                                                              *
*                       DISTRIBUTION PROHIBITED without                        *
*                      written authorization from Voxware                      *
*******************************************************************************/

/*******************************************************************************
* Filename:          QPitch15.h                                                         
*                                                                              
* Purpose:           Pitch Quantization for VR12                             
*                                                                              
* Functions:                                                                   
*                                                                              
* Author/Date:                                                                 
********************************************************************************
* Modifications:
*                   
* Comments:                                                                      
* 
* Concerns:
*
* 
*******************************************************************************/
#ifndef QPITCH15_H
#define QPITCH15_H

short VoxQuanPitchVR15(float pitch);
float VoxLutPitchVR15(short qP0);

#endif /* QPITCH15_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\qpitch24.h ===
/*******************************************************************************
*                        Voxware Proprietary Material                          *
*                        Copyright 1996, Voxware, Inc                          *
*                            All Rights Reserved                               *
*                                                                              *
*                       DISTRIBUTION PROHIBITED without                        *
*                      written authorization from Voxware                      *
*******************************************************************************/

/*******************************************************************************
* Filename:          QPitch24.h                                                         
*                                                                              
* Purpose:           Pitch Quantization for RT24                             
*                                                                              
* Functions:                                                                   
*                                                                              
* Author/Date:                                                                 
********************************************************************************
* Modifications:
*                   
* Comments:                                                                      
* 
* Concerns:
*
* 
*******************************************************************************/
#ifndef QPITCH24_H
#define QPITCH24_H

short VoxQuanPitch24(float pitch);
float VoxLutPitch24(short qP0);

#endif /* QPITCH24_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\qp0sc3.h ===
/******************************************************************************
*                        Voxware Proprietary Material                         *
*                        Copyright 1996, Voxware, Inc                         *
*                            All Rights Reserved                              *
*                                                                             *
*                       DISTRIBUTION PROHIBITED without                       *
*                      written authorization from Voxware                     *
******************************************************************************/

/******************************************************************************
* Filename:          QPitchSC3.h
*                                                                             
* Purpose:           Pitch Quantization for SC36
*                                                                             
* Functions:    VoxQuanPitchSC3, VoxUnQuanPitchSC3, UnQuanMidPitchSC3
*
* Author/Date:  
********************************************************************************
* Modifications:  (1) Change from Log10 to faster fLog2(). And simplify the 
*                 implementation.
*                 (2) Change fLog2() back to log() to support old bitstream.
* Comments:
* 
* Concerns: If not use linear-approximated fLog2, LOG2PMAX, LOG2STEP and 
*           INV_LOG2STEP have to be recalculated.
*
* $Header:   /export/phobos/pvcs/r_and_d/archives/scaleable/quan/QP0SC3.h_v   1.2   17 Aug 1998 18:14:18   weiwang  $
* 
******************************************************************************/
#ifndef QPITCHSC_H
#define QPITCHSC_H

/******************************************************************************
* Function: VoxQuanPitchSC3
*
* Action:  Quantize pitch for SC36
*
* Input:   fPitch -- input pitch value
*
* Output:  same as return
*
* Globals:   none
*
* Return: pitch quantization index
*******************************************************************************
* Implementation/Detailed Description:
*   This is exponential pitch quantizer. 
*   Assume: (Pmax/Pitch)^(1/Level) = (Pmax/Pmin)^(1/MaxLevel), where Pmax = 160,
*   Pmin = 8, MaxLevel = 2^7-1=255. For quantization, we need get Level with 
*   known Pitch value.
*
*   Use log function, the equation can change to: 
*    (log(Pmax)-log(Pitch))/Level = (log(Pmax)-log(Pmin))/MaxLevel
*   Then quantization level can be solved by:
*     Level = (log(Pmax)-log(Pitch))/{(log(Pmax)-log(Pmin))/MaxLevel}
*
* References:
********************************************************************************
* Modifications:
*
* Comments:
*
* Concerns/TBD:
******************************************************************************/
int VoxQuanPitchSC3( float fPitch);


/******************************************************************************
* Function: VoxUnQuanPitchSC3
*
* Action: unquantize pitch for SC36
*
* Input:  iIndex -- pitch quantization index
*
* Output: same as return
*
* Globals: none
*
* Return: quantized pitch 
*******************************************************************************
* Implementation/Detailed Description:
*   Assume: (Pmax/Pitch)^(1/Level) = (Pmax/Pmin)^(1/MaxLevel), where Pmax = 160,
*   Pmin = 8, MaxLevel = 2^7-1=255. For unquantization, we need get Pitch with 
*   known quantization level.
*
*   Use log function, the equantion can change to:
*    (log(Pmax)-log(Pitch))/Level = (log(Pmax)-log(Pmin))/MaxLevel
*   Then log(Pitch) can be obtained by:
*     log(Pitch) = log(Pmax)- Level * (log(Pmax)-log(Pmin))/MaxLevel.
*
*   Use inverse of log -- exp, Pitch = exp(fLog2(Pmax) - Level * LOGExpSTEP).
*
* References:
********************************************************************************
* Modifications:
*
* Comments:
*
* Concerns/TBD:
******************************************************************************/
float VoxUnQuanPitchSC3( int iIndex);

/******************************************************************************
* Function: UnQuanMidPitchSC3
*
* Action: Use conditional interpolation to get the quantized middle frame pitch.
*
* Input:    fPitch_1 -- the quantized previous frame pitch
*           fPitch -- the quantized current frame pitch
*           fPv_1  -- the quantized previous voicing
*
* Output:   same as return
*
* Globals:        none
*
* Return: quantized middle frame pitch.
*******************************************************************************/
float UnQuanMidPitchSC3( float fPitch_1,  float fPitch, 
                         float fPv_1,  float fPv);


#endif /* QPITCHSC_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\qpitch12.h ===
/*******************************************************************************
*                        Voxware Proprietary Material                          *
*                        Copyright 1997, Voxware, Inc                          *
*                            All Rights Reserved                               *
*                                                                              *
*                       DISTRIBUTION PROHIBITED without                        *
*                      written authorization from Voxware                      *
*******************************************************************************/

/*******************************************************************************
* Filename:          QPitch12.h                                                         
*                                                                              
* Purpose:           Pitch Quantization for VR12                             
*                                                                              
* Functions:                                                                   
*                                                                              
* Author/Date:                                                                 
********************************************************************************
* Modifications:
*                   
* Comments:                                                                      
* 
* Concerns:
*
* 
*******************************************************************************/
#ifndef QPITCH12_H
#define QPITCH12_H

short VoxQuanPitchVR12(float pitch);
float VoxLutPitchVR12(short qP0);

#endif /* QPITCH12_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\qpitch28.h ===
/*******************************************************************************
*                        Voxware Proprietary Material                          *
*                        Copyright 1997, Voxware, Inc                          *
*                            All Rights Reserved                               *
*                                                                              *
*                       DISTRIBUTION PROHIBITED without                        *
*                      written authorization from Voxware                      *
*******************************************************************************/

/*******************************************************************************
* Filename:          QPitch28.h                                                         
*                                                                              
* Purpose:           Pitch Quantization for RT28                             
*                                                                              
* Functions:                                                                   
*                                                                              
* Author/Date:                                                                 
********************************************************************************
* Modifications:
*                   
* Comments:                                                                      
* 
* Concerns:
*
* 
*******************************************************************************/
#ifndef QPITCH28_H
#define QPITCH28_H

short VoxQuanPitchRT28(float pitch);
float VoxLutPitchRT28(short qP0);

#endif /* QPITCH28_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\qpitch29.h ===
/*******************************************************************************
*                        Voxware Proprietary Material                          *
*                        Copyright 1996, Voxware, Inc                          *
*                            All Rights Reserved                               *
*                                                                              *
*                       DISTRIBUTION PROHIBITED without                        *
*                      written authorization from Voxware                      *
*******************************************************************************/

/*******************************************************************************
* Filename:          QPitch29.h                                                         
*                                                                              
* Purpose:           Pitch Quantization for RT29                             
*                                                                              
* Functions:                                                                   
*                                                                              
* Author/Date:                                                                 
********************************************************************************
* Modifications:
*                   
* Comments:                                                                      
* 
* Concerns:
*
* 
*******************************************************************************/
#ifndef QPITCH29_H
#define QPITCH29_H 

#define Q_PITCH_LEVEL           (1<<F0_BITS_29)
#define M_T0    ((float)(QUANT_MIN_PITCH_29-QUANT_MAX_PITCH_29)/(float)(Q_PITCH_LEVEL-1))

short VoxQuanPitchRT29(float pitch);
float VoxLutPitchRT29(short qP0);

#endif /* QPITCHBC_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\qtable12.h ===
#ifndef QTABLE12_H
#define QTABLE12_H

const float* voxQuanGetPvTableVR12(void);
const float* voxQuanGetEnergyTableVR12_Voiced(void);
const float* voxQuanGetEnergyTableVR12_UnVoiced(void);
unsigned short voxQuanFillLsfMSVQTableVR12(const float ***phLsfTable);

#endif /* QTABLE12_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\qtable15.h ===
#ifndef QTABLE15_H
#define QTABLE15_H

const float* voxQuanGetPvTableVR15(void);
const float* voxQuanGetEnergyTableVR15_Voiced(void);
const float* voxQuanGetEnergyTableVR15_UnVoiced(void);
unsigned short voxQuanFillLsfMSVQTableVR15(const float ***phLsfTable);

#endif /* QTABLE15_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\qpvvr15.h ===
/*******************************************************************************
*                        Voxware Proprietary Material                          *
*                        Copyright 1996, Voxware, Inc                          *
*                            All Rights Reserved                               *
*                                                                              *
*                       DISTRIBUTION PROHIBITED without                        *
*                      written authorization from Voxware                      *
*******************************************************************************/

#ifndef QPV_VR15
#define QPV_VR15

unsigned short VoxQuanPvVR15(float pv);
float VoxUnQuanPvVR15(unsigned short index);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\qpvrt.h ===
/*******************************************************************************
*                        Voxware Proprietary Material                          *
*                        Copyright 1996, Voxware, Inc                          *
*                            All Rights Reserved                               *
*                                                                              *
*                       DISTRIBUTION PROHIBITED without                        *
*                      written authorization from Voxware                      *
*******************************************************************************/

/*******************************************************************************
* Filename:          QPvRT.c                                                         
*                                                                              
* Purpose:           Pv Quantization for RT series codecs                            
*                                                                              
* Functions:                                                                   
*                                                                              
* Author/Date:                                                                 
********************************************************************************
* Modifications:
*                   
* Comments:                                                                      
* 
* Concerns:
*
* 
*******************************************************************************/
#ifndef QPVRT_H
#define QPVRT_H

unsigned short VoxQuanPvRT(float pv, const float *cb, short size);
float VoxUnQuanPvRT(const float *cb, short size, unsigned short index);

#endif /* QPVRT_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\qpvvr12.c ===
/*******************************************************************************
*                        Voxware Proprietary Material                          *
*                        Copyright 1996, Voxware, Inc                          *
*                            All Rights Reserved                               *
*                                                                              *
*                       DISTRIBUTION PROHIBITED without                        *
*                      written authorization from Voxware                      *
*******************************************************************************/

/*******************************************************************************
* Filename:          QPvVR.c                                                         
*                                                                              
* Purpose:           Pv Quantization for VR series codecs                            
*                                                                              
* Functions:                                                                   
*                                                                              
* Author/Date:                                                                 
********************************************************************************
* Modifications:
*                   
* Comments:                                                                      
* 
* Concerns:
*
* 
*******************************************************************************/
#include <stdlib.h>
#include <math.h>
#include "quanvr12.h"
#include "VoxRound.h"
#include "QPvVR12.h"

#include "xvocver.h"

/*******************************************************************************
* Function: VoxQuanPvVR
*
* Action:
*
* Input:
*
* Output:
*
* Globals:        none
*
* Return:
********************************************************************************
* Implementation/Detailed Description:
*
* References:
********************************************************************************
* Modifications:
*
* Comments:
*
* Concerns/TBD:
*******************************************************************************/

#define PV_STEP  (( PV_V_BOUND-PV_RESET )/ ((1<<PV_BITS_VR12_MIXED)-1))
#define PV_BIAS  0.25

unsigned short VoxQuanPvVR12(float pv)
{
  unsigned short index;

  index = (unsigned short) VoxPosRound((float)((pv-PV_RESET)*(1.0/PV_STEP)+PV_BIAS));
  
  return(index);
}

float VoxUnQuanPvVR12(unsigned short index)
{
   float Pv;

   Pv = (float)((PV_STEP*index)+PV_RESET);
   return(Pv);

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\qtable12.c ===
#include <stdlib.h>
#include <assert.h>

#include "model.h"
#include "quanvr12.h"
#include "research.h"
#include "VoxMem.h"

#include "QTable12.h"

#include "xvocver.h"
 
const float Energy_Table_VR12_VOICED[] = 
{
#include "G5Lg.h"
};

const float Pv_TableVR12[] = {
  0.00000000F, 0.06666667F, 0.13333333F, 0.200000F, 0.26666667F,
  0.33333333F, 0.40000000F, 0.46666667F, 0.53333333F, 0.600000F,
  0.66666667F, 0.73333333F, 0.800000F, 0.86666667F, 0.93333333F,
  1.00000000F
};

const float Lsf_MSVQ12[] =
{
#include "lsp_6_16.h"
};



const float* voxQuanGetPvTableVR12(void)
{
   return(Pv_TableVR12);
}

const float* voxQuanGetEnergyTableVR12_Voiced(void)
{
   return Energy_Table_VR12_VOICED;
}

const float* voxQuanGetEnergyTableVR12_UnVoiced(void)
{
   return Energy_Table_VR12_VOICED;
}

unsigned short voxQuanFillLsfMSVQTableVR12(const float ***phLsfTable)
{
   int i;

  /*** Inilialize the Lspdiff table here **/
  if(VOX_MEM_INIT(*phLsfTable, NUMSTAGES_LSPVQ_VR12_VOICED,sizeof(float *)))
      return 1;

   for (i=0;i<NUMSTAGES_LSPVQ_VR12_VOICED;i++)
      (*phLsfTable)[i] = &(Lsf_MSVQ12[LPC_ORDER*TABLESIZE_LSPVQ_VR12*i]);

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\qpvvr12.h ===
/*******************************************************************************
*                        Voxware Proprietary Material                          *
*                        Copyright 1996, Voxware, Inc                          *
*                            All Rights Reserved                               *
*                                                                              *
*                       DISTRIBUTION PROHIBITED without                        *
*                      written authorization from Voxware                      *
*******************************************************************************/

#ifndef QPV_VR12
#define QPV_VR12

unsigned short VoxQuanPvVR12(float pv);
float VoxUnQuanPvVR12(unsigned short index);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\quan12.h ===
#ifndef		QUAN12_H
#define     QUAN12_H

#ifndef __VEM_KEY
#define __VEM_KEY
typedef void * VEM_KEY;
#endif /* __VEM_KEY */

typedef struct
{
  /***** quantize Pv ******/
  const float    *Pv_TABLE;
  unsigned short Pv_SIZE;
  unsigned short Pv_INDEX;

  /***** quantize pitch ******/
  float          *Pitch_TABLE;
  float          QuanPitch;
  unsigned short Pitch_SIZE;
  unsigned short Pitch_INDEX;

  /***** quantize energy ******/
  const float   *Energy_TABLE_Voiced;
  unsigned short Energy_SIZE_Voiced;
  const float   *Energy_TABLE_UnVoiced;
  unsigned short Energy_SIZE_UnVoiced;

  unsigned short Energy_INDEX;
  
  /**** quantize multistage LSF VQ ****/
  const float    **Lsf_TABLE;
  unsigned short *Lsf_SIZE;
  unsigned short *Lsf_INDEX;

  const float    **Lsf_MSVQ_TABLE;

  /**** quantize amplitude VQ ****/
  short          Amp_NVec;
  const float    *Amp_TABLE;
  unsigned short Amp_INDEX;

  float          *Bark_pw_amp;

  void           *MSVQ_struct;

  const int      *levels;

  short          Class;
  short          PrevClass;
  float          *PrevLsf;
  float          *UVLsf;
  long           Seed;
  float          BckGrndEnergyEst;

  void           *pVemMem;
  VEM_KEY        vemKeyPostQuan;
  VEM_KEY        vemKeyPostUnQuan;

} QUAN_12;

unsigned short VoxQuanVR12(void *pvQuanMemBlk, void *pvParamMemBlk) ;

unsigned short VoxUnQuanVR12(void *pvQuanMemBlk, void *pvParamMemBlk);

unsigned short VoxInitQuanVR12(void **hQuan_mblk, void *pVemMem);

unsigned short VoxFreeQuanVR12(void **Quan_mblk);

short VoxQuanPitchVR12(float pitch);

float VoxLutPitchVR12(short qP0);
#endif  /*ifndef QUAN12_H*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\quaamp28.h ===
/*******************************************************************************
*                        Voxware Proprietary Material                          *
*                        Copyright 1996, Voxware, Inc                          *
*                            All Rights Reserved                               *
*                                                                              *
*                       DISTRIBUTION PROHIBITED without                        *
*                      written authorization from Voxware                      *
*******************************************************************************/

/*******************************************************************************
* Filename:          QuaAmp28.h                                                         
*                                                                              
* Purpose:           Quantize residual amplitudes for RT28                                                          
*                                                                              
* Functions:                                                                   
*                                                                              
* Author/Date:                                                                 
********************************************************************************
* Modifications:
*                   
* Comments:                                                                      
* 
* Concerns:
*
* 
*******************************************************************************/
#ifndef QUAAMP28_H
#define QUAAMP28_H

void QuaAmpRT28(STACK_R void *vpParam_mblk, void *QUAN_mblk);
void UnQuaAmpRT28(STACK_R void *vpParam_mblk, void *QUAN_mblk);

#endif /* QUAAMP28_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\qtable28.h ===
#ifndef QTABLE28_H
#define QTABLE28_H

unsigned short voxQuanFillLsfTableRT28(const float ***phLsfTable);
const int* voxQuanGetLevelsRT28(void);
const float* voxQuanGetPvTableRT28(void);
const float* voxQuanGetEnergyTableRT28(void);

#endif /* QTABLE29_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\quadpeak.c ===
/*******************************************************************************
*                        Voxware Proprietary Material                          *
*                        Copyright 1996, Voxware Inc.                          *
*                        All Rights Reserved                                   *
*                                                                              *
*                        DISTRIBUTION PROHIBITED without                       *
*                        written authorization from Voxware.                   *
*******************************************************************************/

/*******************************************************************************
*
* File:         quadPeak.c
*
* Purpose:      Using quadratic interpolation to get the interpolated peak
*               value.
*
* Functions:    QuadraticPeak()
*
* Author/Date:  Wei Wang, Oct. 09, 1996
*******************************************************************************
* Modifications:
*
* Comments:
*
* Concerns:
*
* $Header:   /export/phobos/pvcs/pvcsproj/voxlib.prj/quadPeak.c_v   1.5   02 Mar 1998 17:41:08   weiwang  $
******************************************************************************/

#include <assert.h>
#include "vLibSpch.h"

#include "xvocver.h"

/******************************************************************************
*
* Function:  QuadraticPeak()
*
* Action:    Compute the interpolated peak value using quandratic interpolation.
*
* Input:     fY_1, fY0, fY1 -- the output of three continuous indices 
*            pfYpeak -- the pointer to the output peak value
*
* Output:    pfYpeak -- output of the interpolated peak
*
* Globals:   none
*
* Return:    the index for the interpolated peak which is between -1 to 1.
*******************************************************************************
* Implementation/Detailed Description:
*    Assume the function Y(x) satisfy the quandratic polynomial equation:
*         Y(x) = a*x^2 + b*x + c.
*    Then the peak value can be obtain by:
*         fYpeak = a*(fXpeak)^2 + b*fXpeak + c.
*    Since at peak, the derivative of Y(x) at fXpeak is 0:
*         2*a*fXpeak + b = 0.
*    So fXpeak = - (b / 2*a).
*
*    In order to get a, b and c, we shift the x-axis so that 3 indices are
*    at -1, 0, 1, and the integer peak is at x = 0. Then:
*           fY_1 = Y(-1) = a - b + c              (1)
*           fY0  = Y(0)  = c                      (2)
*           fY1  = Y(1)  = a + b + c              (3)
*    By solving the equation (1), (2) and (3), we can easily get:
*           a = (fY_1+fY1)*0.5-fY0,
*           b = (fY1-fY_1)*0.5
*       and c = fY0. 
*
* References:  Bob McAulay
*
*******************************************************************************
*
* Modifications:
*
* Comments:     (1) Need fY0 >= fY_1 and fY0 >= fY1 to get meaningful value.
*               (2) The output fXpeak is relative value to X0.
*
* Concerns/TBD: 
*
******************************************************************************/
float QuadraticPeak(float  fY_1, float fY0, float fY1, float *pfYpeak)
{
   float a, b, c;   /* the coefficients for quadratic equation */
   float fXpeak;

   /* do error checking */
   assert((fY0 >= fY_1) && (fY0 >= fY1));

   /* compute the coefficients */
   a = (fY_1 + fY1 ) * 0.5F - fY0;
   b = (fY1  - fY_1) * 0.5F;
   c = fY0;

   /* compute the peak index */
   if (a != 0.0F)
      fXpeak = - b / (2.0F*a);
   else
      fXpeak = 0.0F;
  
   /* peak value */
   *pfYpeak = (a*fXpeak + b)*fXpeak + c;

   return fXpeak;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\quan12.c ===
/*******************************************************************************
*                        Voxware Proprietary Material                          *
*                        Copyright 1996, Voxware, Inc                          *
*                            All Rights Reserved                               *
*                                                                              *
*                       DISTRIBUTION PROHIBITED without                        *
*                      written authorization from Voxware                      *
*******************************************************************************/

/*******************************************************************************
* Filename:   Quan12.c                                                                  
*                                                                              
* Purpose:    Quan/Dequan functions for VR12                                                                  
*                                                                               
* Functions:  VoxQuanVR12(), VoxUnQuanVR12(), VoxInitQuanVR12(), VoxFreeQuanVR12() 
*                                                                              
* Author/Date:                                                                 
********************************************************************************
* Modifications:
*                   
* Comments:                                                                    
* 
* Concerns:
*
* $Header:   P:/r_and_d/archives/realtime/quan/Quan12.c_v   1.5   01 Dec 1998 12:56:38   zopf  $
*******************************************************************************/

#include <stdlib.h>
#include <math.h>
#include <assert.h>
#include <string.h>

#include "model.h"
#include "research.h"
#include "vem2.h"
#include "vem2Prm.h"

#include "quanvr12.h" 
#include "VoxMem.h"
#include "vLibTran.h" /* VoxAsToLspEven() */
#include "vLibMath.h"

#include "param.h"

#include "QTable12.h"
#include "QEnrgy12.h"
#include "QPitch12.h"
#include "QPvVR12.h"
#include "LspMSVQ.h"
#include "GetnHarm.h"
#include "Quan12.h"

#include "xvocver.h"

/*******************************************************************************
* Function:       VOXErr VoxInitQuanVR12(void *QUAN_mblk)
*
* Action:
*
* Input:
*
* Output:
*
* Globals:        none
*
* Return:		   VOXErr : Voxware return code
********************************************************************************
* Implementation/Detailed Description:
*
* References:
********************************************************************************
* Modifications:
*
* Comments:
*
* Concerns/TBD:
*******************************************************************************/
unsigned short VoxQuanVR12(void *pvQuanMemBlk, void *pvParamMemBlk) 
{
   PARAM *Param_mblk = (PARAM *)pvParamMemBlk;
   QUAN_12 *Quan_mblk = (QUAN_12*)pvQuanMemBlk;

   /*************************************************
              Set the Class 
    *************************************************/
   if (Param_mblk->VAD == 0)
      Quan_mblk->Class = SILENCE_FRAME;
   else if (Param_mblk->Pv<=PV_RESET)
      Quan_mblk->Class = UV_FRAME;   
   else if (Param_mblk->Pv<PV_V_BOUND)
      Quan_mblk->Class = MIX_FRAME;
   else 
      Quan_mblk->Class = V_FRAME;

   if (Quan_mblk->Class==UV_FRAME)
   {

      /***** convert lpc to lsp *****/
      VoxAsToLspEven(Param_mblk->Alpc, LPC_ORDER, RATE8K, Param_mblk->Lsf);

      VoxLspMSVQ (Param_mblk->Lsf, Param_mblk->Alpc+1, Quan_mblk->Lsf_INDEX, Quan_mblk->MSVQ_struct,
                  NUMSTAGES_LSPVQ_VR12_UNVOICED, NUMCAND_LSPVQ_VR12, LPC_ORDER, TABLESIZE_LSPVQ_VR12,
                  Quan_mblk->Lsf_MSVQ_TABLE);

      VoxQuanEnergyVR12(Param_mblk->Energy, Quan_mblk->Energy_TABLE_UnVoiced, 
                   Quan_mblk->Energy_SIZE_UnVoiced, &(Quan_mblk->Energy_INDEX) );

   }

   if (Quan_mblk->Class==MIX_FRAME)
   {

      Quan_mblk->Pitch_INDEX = VoxQuanPitchVR12(Param_mblk->Pitch);

      /***** convert lpc to lsp *****/
      VoxAsToLspEven(Param_mblk->Alpc, LPC_ORDER, RATE8K, Param_mblk->Lsf);

      VoxLspMSVQ (Param_mblk->Lsf, Param_mblk->Alpc+1, Quan_mblk->Lsf_INDEX, Quan_mblk->MSVQ_struct,
                  NUMSTAGES_LSPVQ_VR12_MIXED, NUMCAND_LSPVQ_VR12, LPC_ORDER, TABLESIZE_LSPVQ_VR12,
                  Quan_mblk->Lsf_MSVQ_TABLE);

      Quan_mblk->Pv_INDEX = VoxQuanPvVR12(Param_mblk->Pv);

      VoxQuanEnergyVR12(Param_mblk->Energy, Quan_mblk->Energy_TABLE_Voiced, 
                   Quan_mblk->Energy_SIZE_Voiced, &(Quan_mblk->Energy_INDEX) );
   }

   if (Quan_mblk->Class==V_FRAME)
   {

      Quan_mblk->Pitch_INDEX = VoxQuanPitchVR12(Param_mblk->Pitch);

      /***** convert lpc to lsp *****/
      VoxAsToLspEven(Param_mblk->Alpc, LPC_ORDER, RATE8K, Param_mblk->Lsf);

      VoxLspMSVQ (Param_mblk->Lsf, Param_mblk->Alpc+1, Quan_mblk->Lsf_INDEX, Quan_mblk->MSVQ_struct,
                  NUMSTAGES_LSPVQ_VR12_VOICED, NUMCAND_LSPVQ_VR12, LPC_ORDER, TABLESIZE_LSPVQ_VR12,
                  Quan_mblk->Lsf_MSVQ_TABLE);

      VoxQuanEnergyVR12(Param_mblk->Energy, Quan_mblk->Energy_TABLE_Voiced, 
                   Quan_mblk->Energy_SIZE_Voiced, &(Quan_mblk->Energy_INDEX) );
   }

   vemServiceState(Quan_mblk->vemKeyPostQuan);
 
   return 0;
}

/*******************************************************************************
* Function:       VOXErr VoxUnQuanVR12(void *pvDecMemBlk)
*
* Action:  Unquantize the frame parameters for VR12.
*
* Input:  *pvQuanMemBlk - the quantization memory block
*
* Output: *pvParamMemBlk - the Param block filled in with the unquantized values.
*
* Globals:        none
*
* Return:		  VOXErr : Voxware return code
********************************************************************************
* Implementation/Detailed Description:
*
* References:
********************************************************************************
* Modifications: 10/27/98 - background noise estimation improvements - RZ
*
* Comments:
*
* Concerns/TBD:
*******************************************************************************/
#define  BCKGRND_RND_HZ       50.0F   /* maximum amount to randomize the lsfs */
#define  BCKGRND_MULT_FACTOR  1.01F   /* increase noise estimate              */
#define  BCKGRND_ADD_FACTOR   5.0F    /* increase noise estimate              */
#define  BCKGRND_FADE_FACTOR  0.99F   /* fade to silence during bckgrnd noise */
#define  INIT_CLASS           999     /* used to avoid first frame energy     */
#define  LONGTERM_AVE         0.6F    /* running average of lsfs              */

unsigned short VoxUnQuanVR12(void *pvQuanMemBlk, void *pvParamMemBlk)
{
   PARAM *Param_mblk  = (PARAM *)pvParamMemBlk;
   QUAN_12 *Quan_mblk = (QUAN_12 *)pvQuanMemBlk;
   short   nHarm;
   float   scale;
   int     i;

   if (Quan_mblk->Class==SILENCE_FRAME)
   {
      Param_mblk->Pv    = 0.0F;
      Param_mblk->Pitch = (float)PITCH_UV;

      if (Quan_mblk->PrevClass!=SILENCE_FRAME)
      {
         /**************************************************************************/
         /* Calculate a running average of the lsfs, and the energy for use        */
         /* during the voice inactive frames ...                                   */
         /**************************************************************************/
         for (i=0;i<LPC_ORDER;i++)
         {
            Quan_mblk->UVLsf[i] = LONGTERM_AVE*Quan_mblk->UVLsf[i] + 
                                 (1.0F-LONGTERM_AVE)*Quan_mblk->PrevLsf[i];
         }
      }

      Param_mblk->Energy = Quan_mblk->BckGrndEnergyEst;

      /**********************************************************************
       Add a random component to the background noise fill spectrum so that
       we don't repeat the exact same spectrum over and over again.
       **********************************************************************/
      for (i=0;i<LPC_ORDER;i++)
         Param_mblk->Lsf[i] = Quan_mblk->UVLsf[i] +
                              (((NuRand(&(Quan_mblk->Seed))*NURAND_SCALE)-0.5F)*2.0F)*BCKGRND_RND_HZ;

      /**********************************************************************
                             Stability check
       **********************************************************************/
      for (i=1;i<LPC_ORDER;i++)
         if (Param_mblk->Lsf[i] < Param_mblk->Lsf[i-1]+LSP_SEPERATION_HZ)
             Param_mblk->Lsf[i] = Param_mblk->Lsf[i-1]+LSP_SEPERATION_HZ;
   } /* end SILENCE_FRAME */

   if (Quan_mblk->Class==UV_FRAME)
   {
      Param_mblk->Pitch = (float)PITCH_UV;
      Param_mblk->Pv    = 0.0F;
      Param_mblk->Energy= VoxUnQuanEnergyVR12(Quan_mblk->Energy_TABLE_UnVoiced,  
                          Quan_mblk->Energy_SIZE_UnVoiced, Quan_mblk->Energy_INDEX);
      VoxDecLspMSVQ (Quan_mblk->Lsf_INDEX, Param_mblk->Lsf, Quan_mblk->Lsf_MSVQ_TABLE, 
                  LPC_ORDER, NUMSTAGES_LSPVQ_VR12_UNVOICED);
   }

   if (Quan_mblk->Class==MIX_FRAME)
   {
      /***** Unquantize Pitch *****/
      Param_mblk->Pitch = VoxLutPitchVR12(Quan_mblk->Pitch_INDEX);

      /***** Unquantize Pv    *****/
      Param_mblk->Pv = VoxUnQuanPvVR12( Quan_mblk->Pv_INDEX );

      /***** Unquantize Energy ****/
      Param_mblk->Energy= VoxUnQuanEnergyVR12(Quan_mblk->Energy_TABLE_Voiced,  Quan_mblk->Energy_SIZE_Voiced,
                                         Quan_mblk->Energy_INDEX);

      VoxDecLspMSVQ (Quan_mblk->Lsf_INDEX, Param_mblk->Lsf, Quan_mblk->Lsf_MSVQ_TABLE, 
                  LPC_ORDER, NUMSTAGES_LSPVQ_VR12_MIXED);
   }

   if (Quan_mblk->Class==V_FRAME)
   {
      /***** Unquantize Pitch *****/
      Param_mblk->Pitch = VoxLutPitchVR12(Quan_mblk->Pitch_INDEX);

      /***** Unquantize Pv    *****/
      Param_mblk->Pv = (float)PV_V;

      /***** Unquantize Energy ****/
      Param_mblk->Energy= VoxUnQuanEnergyVR12(Quan_mblk->Energy_TABLE_Voiced,  Quan_mblk->Energy_SIZE_Voiced,
                                         Quan_mblk->Energy_INDEX);

      VoxDecLspMSVQ (Quan_mblk->Lsf_INDEX, Param_mblk->Lsf, Quan_mblk->Lsf_MSVQ_TABLE, 
                  LPC_ORDER, NUMSTAGES_LSPVQ_VR12_MIXED);
   }

   /*******************************************************************
    Calculate the harmonic amplitudes
    *******************************************************************/
   nHarm = getnHarm(Param_mblk->Pitch);
   scale = (float)sqrt(2.0*Param_mblk->Energy/nHarm);
   for (i=0; i< nHarm; i++)
      Param_mblk->Amp[i] = scale;
   for (i=nHarm; i< MAXHARM; i++)
      Param_mblk->Amp[i] = 0.0F; 
 
   /*******************************************************************
    Update the background noise estimate.  First, fade to silence 
    during background noise.  Second, update the background noise 
    estimate based on the frame energy and our current estimate
    *******************************************************************/
   if (Quan_mblk->Class==SILENCE_FRAME)
   {
      Quan_mblk->BckGrndEnergyEst *= BCKGRND_FADE_FACTOR;
   }
   else
   {
      Quan_mblk->BckGrndEnergyEst = (Quan_mblk->BckGrndEnergyEst*BCKGRND_MULT_FACTOR) + BCKGRND_ADD_FACTOR;
      if (Quan_mblk->PrevClass!= INIT_CLASS)  /* first frame is always low energy due to zero-padding */
         if (Param_mblk->Energy < Quan_mblk->BckGrndEnergyEst)
            Quan_mblk->BckGrndEnergyEst = Param_mblk->Energy;
   }

   /**********************************************************************
    Update our memory 
    **********************************************************************/
   Quan_mblk->PrevClass = Quan_mblk->Class;
   memcpy(Quan_mblk->PrevLsf, Param_mblk->Lsf, sizeof(float)*LPC_ORDER);

   vemServiceState(Quan_mblk->vemKeyPostUnQuan);
    
   return 0;
}

/*******************************************************************************
* Function:       VOXErr VoxInitQuanVR12(QUAN_12* Quan_mblk)
*
* Action:
*
* Input:
*
* Output:
*
* Globals:        none
*
* Return:		   VOXErr : Voxware return code
********************************************************************************
* Implementation/Detailed Description:
*
* References:
********************************************************************************
* Modifications:
*
* Comments:
*
* Concerns/TBD:
*******************************************************************************/

unsigned short VoxInitQuanVR12(void **hQuan_mblk, void *pVemMem)
{
  QUAN_12 *Quan_mblk;

  if(VOX_MEM_INIT(Quan_mblk=*hQuan_mblk,1,sizeof(QUAN_12))) 
     return 1;

  /**** initialize Pv table ****/
  Quan_mblk->Pv_INDEX = 0;
  Quan_mblk->Pv_SIZE = (1<<PV_BITS_VR12_MIXED); 
  Quan_mblk->Pv_TABLE = voxQuanGetPvTableVR12();

  /**** initialize pitch table ****/
  Quan_mblk->Pitch_INDEX = 0;
  Quan_mblk->Pitch_SIZE = (1<<F0_BITS_VR12_VOICED);
  Quan_mblk->Pitch_TABLE = NULL;    /* calculate in the function */

  /***** initialize Energy table *****/
  Quan_mblk->Energy_INDEX = 0;
  Quan_mblk->Energy_SIZE_Voiced = ((short)1<<GAIN_BITS_VR12_VOICED);
  Quan_mblk->Energy_TABLE_Voiced = voxQuanGetEnergyTableVR12_Voiced();
  Quan_mblk->Energy_SIZE_UnVoiced = ((short)1<<GAIN_BITS_VR12_UNVOICED);
  Quan_mblk->Energy_TABLE_UnVoiced = voxQuanGetEnergyTableVR12_UnVoiced();


  if(VOX_MEM_INIT(Quan_mblk->Lsf_INDEX, NUMSTAGES_LSPVQ_VR12_VOICED,sizeof(unsigned short))) 
     return 1;

  if(voxQuanFillLsfMSVQTableVR12(&Quan_mblk->Lsf_MSVQ_TABLE)) 
      return 1;
  
  if (VoxInitMSVQ(&(Quan_mblk->MSVQ_struct)))
     return 1;

  if(VOX_MEM_INIT(Quan_mblk->PrevLsf, LPC_ORDER,sizeof(float))) 
     return 1;

  if(VOX_MEM_INIT(Quan_mblk->UVLsf, LPC_ORDER,sizeof(float))) 
     return 1;

  Quan_mblk->PrevLsf[0] = INITIAL_LSF_0;
  Quan_mblk->PrevLsf[1] = INITIAL_LSF_1;
  Quan_mblk->PrevLsf[2] = INITIAL_LSF_2;
  Quan_mblk->PrevLsf[3] = INITIAL_LSF_3;
  Quan_mblk->PrevLsf[4] = INITIAL_LSF_4;
  Quan_mblk->PrevLsf[5] = INITIAL_LSF_5;
  Quan_mblk->PrevLsf[6] = INITIAL_LSF_6;
  Quan_mblk->PrevLsf[7] = INITIAL_LSF_7;
  Quan_mblk->PrevLsf[8] = INITIAL_LSF_8;
  Quan_mblk->PrevLsf[9] = INITIAL_LSF_9;

  Quan_mblk->UVLsf[0] = INITIAL_LSF_0;
  Quan_mblk->UVLsf[1] = INITIAL_LSF_1;
  Quan_mblk->UVLsf[2] = INITIAL_LSF_2;
  Quan_mblk->UVLsf[3] = INITIAL_LSF_3;
  Quan_mblk->UVLsf[4] = INITIAL_LSF_4;
  Quan_mblk->UVLsf[5] = INITIAL_LSF_5;
  Quan_mblk->UVLsf[6] = INITIAL_LSF_6;
  Quan_mblk->UVLsf[7] = INITIAL_LSF_7;
  Quan_mblk->UVLsf[8] = INITIAL_LSF_8;
  Quan_mblk->UVLsf[9] = INITIAL_LSF_9;

  Quan_mblk->PrevClass        = INIT_CLASS;
  Quan_mblk->Seed             = 55;   /* some non-zero number */
  Quan_mblk->BckGrndEnergyEst = 1000000.0F;  /* some large number */  

  Quan_mblk->pVemMem=pVemMem;
  if(!(Quan_mblk->vemKeyPostQuan=vemRegisterState(
     ((VEM_MAIN_STRUCT *)pVemMem)->pMemoryHandler,"post quan")))
  {
#if VEM_DEFINED == 1
     return 1;
#endif
  }

  if(!(Quan_mblk->vemKeyPostUnQuan=vemRegisterState(
     ((VEM_MAIN_STRUCT *)pVemMem)->pMemoryHandler,"post unquan")))
  {
#if VEM_DEFINED == 1
     return 1;
#endif
  }
  vemRegisterConstShort(((VEM_MAIN_STRUCT *)pVemMem)->pMemoryHandler, 
     (short)QUANT_MAX_PITCH_VR, "max pitch");

  vemRegisterConstShort(((VEM_MAIN_STRUCT *)pVemMem)->pMemoryHandler, 
     (short)QUANT_MIN_PITCH_VR, "min pitch");

  return 0;
}

/*******************************************************************************
* Function:       VOXErr VoxFreeQuanVR12(void *QUAN_mblk)
*
* Action:
*
* Input:
*
* Output:
*
* Globals:        none
*
* Return:		   VOXErr : Voxware return code
********************************************************************************
* Implementation/Detailed Description:
*
* References:
********************************************************************************
* Modifications:
*
* Comments:
*
* Concerns/TBD:
*******************************************************************************/
unsigned short VoxFreeQuanVR12(void **hQuan_mblk)
{
  QUAN_12* pQuan=(QUAN_12 *)*hQuan_mblk;
  if(*hQuan_mblk) {
     /***** free LSF Table *****/
     VOX_MEM_FREE(pQuan->Lsf_INDEX);
     VOX_MEM_FREE(pQuan->PrevLsf);
     VOX_MEM_FREE(pQuan->UVLsf);
     VOX_MEM_FREE_CONST(pQuan->Lsf_MSVQ_TABLE);  
     
     VoxFreeMSVQ(&(pQuan->MSVQ_struct));

     VOX_MEM_FREE(*hQuan_mblk);
  }

  return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\quan15.h ===
#ifndef		QUAN15_H
#define     QUAN15_H

#ifndef __VEM_KEY
#define __VEM_KEY
typedef void * VEM_KEY;
#endif /* __VEM_KEY */

typedef struct
{
  /***** quantize Pv ******/
  const float    *Pv_TABLE;
  unsigned short Pv_SIZE;
  unsigned short Pv_INDEX;

  /***** quantize pitch ******/
  float          *Pitch_TABLE;
  float          QuanPitch;
  unsigned short Pitch_SIZE;
  unsigned short Pitch_INDEX;

  /***** quantize energy ******/
  const float   *Energy_TABLE_Voiced;
  unsigned short Energy_SIZE_Voiced;
  const float   *Energy_TABLE_UnVoiced;
  unsigned short Energy_SIZE_UnVoiced;

  unsigned short Energy_INDEX;
  
  /**** quantize multistage LSF VQ ****/
  const float    **Lsf_TABLE;
  unsigned short *Lsf_SIZE;
  unsigned short *Lsf_INDEX;

  const float    **Lsf_MSVQ_TABLE;

  /**** quantize amplitude VQ ****/
  short          Amp_NVec;
  const float    *Amp_TABLE;
  unsigned short Amp_INDEX;

  float          *Bark_pw_amp;

  void           *MSVQ_struct;

  const int      *levels;

  short          Class;
  short          PrevClass;
  float          *PrevLsf;
  float          *UVLsf;
  float          BckGrndEnergyEst;
  long           Seed;

  void           *pVemMem;
  VEM_KEY        vemKeyPostQuan;
  VEM_KEY        vemKeyPostUnQuan;

} QUAN_15;

unsigned short VoxQuanVR15(void *pvQuanMemBlk, void *pvParamMemBlk) ;

unsigned short VoxUnQuanVR15(void *pvQuanMemBlk, void *pvParamMemBlk);

unsigned short VoxInitQuanVR15(void **hQuan_mblk, void *pVemMem);

unsigned short VoxFreeQuanVR15(void **Quan_mblk);

short VoxQuanPitchVR15(float pitch);

float VoxLutPitchVR15(short qP0);
#endif  /*ifndef QUAN12_H*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\qtable29.h ===
#ifndef QTABLE29_H
#define QTABLE29_H

unsigned short voxQuanFillLsfTableRT29(const float ***phLsfTable);
unsigned short voxQuanFreeLsfTableRT29(const float ***phLsfTable);
unsigned short voxQuanFillAmpTableRT29(const float ****phAmpTable);
unsigned short voxQuanFreeAmpTableRT29(const float ****phAmpTable);
const int* voxQuanGetLevelsRT29(void);
const float* voxQuanGetPvTableRT29(void);
const float* voxQuanGetEnergyTableRT29(void);

#endif /* QTABLE29_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\qtable24.h ===
/*******************************************************************************
*                        Voxware Proprietary Material                          *
*                        Copyright 1996, Voxware, Inc                          *
*                            All Rights Reserved                               *
*                                                                              *
*                       DISTRIBUTION PROHIBITED without                        *
*                      written authorization from Voxware                      *
*******************************************************************************/

/*******************************************************************************
* Filename:          QTable24.h                                                         
*                                                                              
* Purpose:           Quantization table setup for RT24                             
*                                                                              
* Functions:                                                                   
*                                                                              
* Author/Date:                                                                 
********************************************************************************
* Modifications:
*                   
* Comments:                                                                      
* 
* Concerns:
*
* 
*******************************************************************************/
#ifndef QTABLE24_H
#define QTABLE24_H

const int* voxQuanGetLevels24(void);
const float* voxQuanGetPvTable24(void);
const float* voxQuanGetEnergyTable24(void);
unsigned short voxQuanFillLsfTable24(const float ***phLsfTable);

#endif /* QTABLE24_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\quan29.h ===
#ifndef	    QUAN29_H
#define     QUAN29_H

#ifndef __VEM_KEY
#define __VEM_KEY
typedef void * VEM_KEY;
#endif /* __VEM_KEY */

typedef struct
{
  /***** quantize Pv ******/
  const float    *Pv_TABLE;
  unsigned short Pv_SIZE;
  unsigned short Pv_INDEX;

  /***** quantize pitch ******/
  float          *Pitch_TABLE;
  float          QuanPitch;
  unsigned short Pitch_SIZE;
  unsigned short Pitch_INDEX;

  /***** quantize energy ******/
  const float   *Energy_TABLE;
  unsigned short Energy_SIZE;
  unsigned short Energy_INDEX;
  
  /**** quantize multistage LSF VQ ****/
  const float    **Lsf_TABLE;
  unsigned short *Lsf_SIZE;
  unsigned short *Lsf_INDEX;

  /**** quantize amplitude VQ ****/
  short          Amp_NVec;
  const float    ***Amp_TABLE;
  unsigned short *Amp_INDEX;

  /**** the MSVQ structure ****/
  void           *myFB_mblk;

  float          *Bark_pw_amp;

  const int      *levels;

  void           *pVemMem;
  VEM_KEY        vemKeyPostQuan;
  VEM_KEY        vemKeyPostUnQuan;

} QUAN_29;

unsigned short VoxQuanRT29(STACK_R void *pvQuanMemBlk, void *pvParamMemBlk) ;

unsigned short VoxQuanAmpRT29(STACK_R void *pvQuanMemBlk, void *pvParamMemBlk);

unsigned short VoxUnQuanRT29(STACK_R void *pvQuanMemBlk, void *pvParamMemBlk);

unsigned short VoxInitQuanRT29(void **hQuan_mblk, void *pVemMem);

unsigned short VoxFreeQuanRT29(void **Quan_mblk);

#endif  /*ifndef QUAN29_H*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\quan24.h ===
#ifndef		QUAN24_H
#define     QUAN24_H

#ifndef __VEM_KEY
#define __VEM_KEY
typedef void * VEM_KEY;
#endif /* __VEM_KEY */

typedef struct
{
  /***** quantize Pv ******/
  const float    *Pv_TABLE;
  unsigned short Pv_SIZE;
  unsigned short Pv_INDEX;

  /***** quantize pitch ******/
  float          *Pitch_TABLE;
  float          QuanPitch;
  unsigned short Pitch_SIZE;
  unsigned short Pitch_INDEX;

  /***** quantize energy ******/
  const float   *Energy_TABLE;
  unsigned short Energy_SIZE;
  unsigned short Energy_INDEX;
  
  /**** quantize multistage LSF VQ ****/
  const float    **Lsf_TABLE;
  unsigned short *Lsf_SIZE;
  unsigned short *Lsf_INDEX;
  const int      *levels;

  void           *pVemMem;
  VEM_KEY        vemKeyPostQuan;
  VEM_KEY        vemKeyPostUnQuan;

} QUAN_24;

unsigned short VoxQuan24(STACK_R void *pvQuanMemBlk, void *pvParamMemBlk) ;

unsigned short VoxUnQuan24(void *pvQuanMemBlk, void *pvParamMemBlk);

unsigned short VoxInitQuan24(void **hQuan_mblk, void *pVemMem);

unsigned short VoxFreeQuan24(void **Quan_mblk);

short VoxQuanPitch(float pitch);

float VoxLutPitch(short qP0);
#endif  /*ifndef QUAN24_H*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\quansc36.h ===
/******************************************************************************
*                        Voxware Proprietary Material
*                        Copyright 1996, Voxware, Inc
*                            All Rights Reserved
*
*                       DISTRIBUTION PROHIBITED without
*                      written authorization from Voxware
******************************************************************************/

/******************************************************************************
* Filename:       quansc36.h
*
* Purpose:        File containing all quantization definitions for sc36.
*
* Author/Date:    Bob Dunn  06/03/97
*******************************************************************************
*
* Comments: WARNING: WARNING: WARNING: (Yes, that means you should read this!)

*            The bit allocations for both SC3 and SC6 MUST be byte aligned 
*            or the VCI and other things may break.  The byte alignment can
*            be accomplished by modifying UNUSED_BITS_SC3
*            and/or UNUSED_BITS_SC6.
*
* $Header:   /export/phobos/pvcs/r_and_d/archives/scaleable/include/quansc36.h_v   1.4   13 Apr 1998 16:17:36   weiwang  $
*
******************************************************************************/

#ifndef _QUANSC36_H
#define _QUANSC36_H

/*------------------------------------------------------
  Pitch quantization for SC3 and SC6
------------------------------------------------------*/
#define BITS_PITCH_SC3              8
#define MAX_QUAN_PITCH_PERIOD_SC3   160.0F   /* 50 Hz */
#define MIN_QUAN_PITCH_PERIOD_SC3   8.0F     /* 1000 Hz */

/*------------------------------------------------------
  Gain quantization for SC3 and SC6
------------------------------------------------------*/
#define BITS_GAIN_SC3               6
#define MIN_QUAN_GAIN               -3.0F
#define MAX_QUAN_GAIN               12.0F


/*------------------------------------------------------
  Voicing quantization for SC3 and SC6
------------------------------------------------------*/
#define BITS_PV_SC3                 4 /*%#  5 #%*/


/*------------------------------------------------------
  ASK quantization for SC3 and SC6
------------------------------------------------------*/
#define BITS_ASKS_SC36             44


#define STAGE1_BITS_ASKS_0_1_SC36      5
#define STAGE2_BITS_ASKS_0_1_SC36      5
#define STAGE1_BITS_ASKS_2_3_SC36      5
#define STAGE2_BITS_ASKS_2_3_SC36      4
#define STAGE1_BITS_ASKS_4_5_SC36      5
#define STAGE2_BITS_ASKS_4_5_SC36      3
#define STAGE1_BITS_ASKS_6_7_SC36      5
#define STAGE2_BITS_ASKS_6_7_SC36      2
#define STAGE1_BITS_ASKS_8_9_SC36      5
#define STAGE2_BITS_ASKS_8_9_SC36      0
#define STAGE1_BITS_ASKS_10_11_SC36    5
#define STAGE2_BITS_ASKS_10_11_SC36    0

#define RESIDUAL_BITS_ASKS_8_9_SC6     3
#define RESIDUAL_BITS_ASKS_10_11_SC6   3

/*------------------------------------------------------
  Phase quantization for SC6
------------------------------------------------------*/
#define BITS_PHASE_SC6             56

#define BITS_PHASE_PAIR_SC6   (BITS_PHASE_SC6/SC6_PHASES)

/*------------------------------------------------------
  Reserved bits for SC3 and SC6.  These are place
    holders in the bitstream for bits to be defined
    in the future definition.
------------------------------------------------------*/
#define RESERVED_BITS_SC3           1  /* one reserved bit for SC3 */

#define RESERVED_BITS_SC6           1  /* one reserved bit in SC6 */


/*------------------------------------------------------
  These bits are flags for the VCI to determine if
    the embeded bitstream contains higher rate data.
------------------------------------------------------*/
#define VCI_FLAG_BITS_SC3           1
#define VCI_FLAG_BITS_SC6           1


/*------------------------------------------------------
  Total bit number of bits for SC3 and SC6
------------------------------------------------------*/
#define TOTAL_BITS_SC3    (  BITS_PITCH_SC3 \
                           + BITS_GAIN_SC3 \
                           + BITS_PV_SC3 \
                           + BITS_ASKS_SC36 \
                           + RESERVED_BITS_SC3 \
                           + VCI_FLAG_BITS_SC3 )

#define ADDITIONAL_BITS_SC6 (  BITS_PHASE_SC6 \
                             + RESIDUAL_BITS_ASKS_8_9_SC6 \
                             + RESIDUAL_BITS_ASKS_10_11_SC6 \
                             + RESERVED_BITS_SC6 \
                             + VCI_FLAG_BITS_SC6 )


/*------------------------------------------------------
  Total bit number of bytes for SC3 and SC6
------------------------------------------------------*/
#define TOTAL_BYTES_SC3             (TOTAL_BITS_SC3>>3)
#define ADDITIONAL_BYTES_SC6        (ADDITIONAL_BITS_SC6>>3)


#endif /* _QUANSC36_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\quanvr12.h ===
/*******************************************************************************
*                        Voxware Proprietary Material                          *
*                        Copyright 1996, Voxware, Inc                          *
*                            All Rights Reserved                               *
*                                                                              *
*                       DISTRIBUTION PROHIBITED without                        *
*                      written authorization from Voxware                      *
*******************************************************************************/

/*******************************************************************************
* Filename:       quanvr12.h                                                           
*                                                                              
* Purpose:        File containing all quantization definitions for vr12.
*                                                                              
* Author/Date:    Rob Zopf  03/18/97                                                       
********************************************************************************
*                                                                      
*******************************************************************************/
#ifndef QUANVR12_H
#define QUANVR12_H 

#define	TABLESIZE_LSPVQ_VR12            16 
#define	TABLEBITS_LSPVQ_VR12             4
#define	NUMCAND_LSPVQ_VR12              16   
#define NUMSTAGES_LSPVQ_VR12_VOICED      6
#define NUMSTAGES_LSPVQ_VR12_MIXED      6
#define NUMSTAGES_LSPVQ_VR12_UNVOICED    2

#define CLASS_BITS_VR12                  2

#define GAIN_BITS_VR12_VOICED            5
#define F0_BITS_VR12_VOICED              7
#define LSP_BITS_VR12_VOICED             (NUMSTAGES_LSPVQ_VR12_VOICED*TABLEBITS_LSPVQ_VR12)
#define TOTAL_BITS_VR12_VOICED           (CLASS_BITS_VR12+GAIN_BITS_VR12_VOICED+F0_BITS_VR12_VOICED+LSP_BITS_VR12_VOICED)

#define GAIN_BITS_VR12_MIXED            GAIN_BITS_VR12_VOICED
#define PV_BITS_VR12_MIXED              3
#define F0_BITS_VR12_MIXED              F0_BITS_VR12_VOICED
#define LSP_BITS_VR12_MIXED             (NUMSTAGES_LSPVQ_VR12_MIXED*TABLEBITS_LSPVQ_VR12)
#define TOTAL_BITS_VR12_MIXED           (CLASS_BITS_VR12+GAIN_BITS_VR12_MIXED+PV_BITS_VR12_MIXED+F0_BITS_VR12_MIXED+LSP_BITS_VR12_MIXED)


#define GAIN_BITS_VR12_UNVOICED          5
#define LSP_BITS_VR12_UNVOICED           (NUMSTAGES_LSPVQ_VR12_UNVOICED*TABLEBITS_LSPVQ_VR12)
#define TOTAL_BITS_VR12_UNVOICED         (CLASS_BITS_VR12+GAIN_BITS_VR12_UNVOICED+LSP_BITS_VR12_UNVOICED)

#define TOTAL_BITS_VR12_SILENCE          CLASS_BITS_VR12 

/* use whole range to quantize pitch */
#define QUANT_MIN_PITCH_VR     8     /* 1000 Hz */
#define QUANT_MAX_PITCH_VR     160   /* 50 Hz */

#define BYTESPERFRAME_VR                 7

#define SILENCE_FRAME 3
#define UV_FRAME      2
#define MIX_FRAME     1
#define V_FRAME       0

#define PV_RESET      0.05    /* if pv < PV_RESET, set pv = 0.0 */
#define PV_V_BOUND          0.70    /* above which, pv will be synthesized at PV_V */
#define PV_V          0.94       /* */

#define ENERGY_HISTORY  10

#define RATE_V     0.1F
#define RATE_MIX   0.55F
#define RATE_UV    0.1F
#define RATE_S     0.25F

#endif /* QUANVR12_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\quan28.h ===
#ifndef		QUAN28_H
#define     QUAN28_H

#ifndef __VEM_KEY
#define __VEM_KEY
typedef void * VEM_KEY;
#endif /* __VEM_KEY */

typedef struct
{
  /***** quantize Pv ******/
  const float    *Pv_TABLE;
  unsigned short Pv_SIZE;
  unsigned short Pv_INDEX;

  /***** quantize pitch ******/
  float          *Pitch_TABLE;
  float          QuanPitch;
  unsigned short Pitch_SIZE;
  unsigned short Pitch_INDEX;

  /***** quantize energy ******/
  const float   *Energy_TABLE;
  unsigned short Energy_SIZE;
  unsigned short Energy_INDEX;
  
  /**** quantize multistage LSF VQ ****/
  const float    **Lsf_TABLE;
  unsigned short *Lsf_SIZE;
  unsigned short *Lsf_INDEX;

  /**** quantize amplitude VQ ****/
  short          Amp_NVec;
  const float    *Amp_TABLE;
  unsigned short Amp_INDEX;

  float          *Bark_pw_amp;

  const int      *levels;

  void           *pVemMem;
  VEM_KEY        vemKeyPostQuan;
  VEM_KEY        vemKeyPostUnQuan;

} QUAN_28;

unsigned short VoxQuanRT28(void *pvQuanMemBlk, void *pvParamMemBlk) ;

unsigned short VoxQuanAmpRT28(STACK_R void *pvQuanMemBlk, void *pvParamMemBlk);

unsigned short VoxUnQuanRT28(STACK_R void *pvQuanMemBlk, void *pvParamMemBlk);

unsigned short VoxInitQuanRT28(void **hQuan_mblk, void *pVemMem);

unsigned short VoxFreeQuanRT28(void **Quan_mblk);

short VoxQuanPitchRT28(float pitch);

float VoxLutPitchRT28(short qP0);
#endif  /*ifndef QUAN29_H*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\quanrt29.h ===
/*******************************************************************************
*                        Voxware Proprietary Material                          *
*                        Copyright 1996, Voxware, Inc                          *
*                            All Rights Reserved                               *
*                                                                              *
*                       DISTRIBUTION PROHIBITED without                        *
*                      written authorization from Voxware                      *
*******************************************************************************/

/*******************************************************************************
* Filename:       quanrt29.h                                                           
*                                                                              
* Purpose:        File containing all quantization definitions for rt29.
*                                                                              
* Author/Date:    Rob Zopf  03/18/97                                                       
********************************************************************************
*                                                                      
*******************************************************************************/
#ifndef QUANRT29_H
#define QUANRT29_H 

#define GAIN_BITS_29                     5
#define	PV_BITS_29                       4
#define	F0_BITS_29                       8
#define	LSP_BITS_29                      41
#define	LSP_BITS_1_29                    5
#define	LSP_BITS_2_29                    5
#define	LSP_BITS_3_29                    5
#define	LSP_BITS_4_29                    5
#define	LSP_BITS_5_29                    4
#define	LSP_BITS_6_29                    4
#define	LSP_BITS_7_29                    4
#define	LSP_BITS_8_29                    3
#define	LSP_BITS_9_29                    3
#define	LSP_BITS_10_29                   3
#define	LSP_TABLES_29                    10
#define	AMP_TABLES_29                    3
#define AMP_BITS_1_29                    3  
#define AMP_BITS_2_29                    3  
#define AMP_BITS_3_29                    3 
#define	AMP_BITS_29                      (AMP_BITS_1_29+AMP_BITS_2_29+AMP_BITS_3_29)
#define RESERVED_BITS_29                 0

#define TOTAL_BITS_29                    (GAIN_BITS_29+PV_BITS_29+F0_BITS_29+LSP_BITS_29+AMP_BITS_29+RESERVED_BITS_29)

/* use whole range to quantize pitch */
#define QUANT_MIN_PITCH_29     16     /* 1000 Hz */
#define QUANT_MAX_PITCH_29     125   /* 50 Hz */

#define BYTESPERFRAME_29                 9

#define NUMSTAGES_AMPVQ_29               3 
#define NUMCAND_AMPVQ_29                 16  
#define TABLESIZE_AMPVQ_29               8


#endif /* QUANRT29_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\quanrt28.h ===
/*******************************************************************************
*                        Voxware Proprietary Material                          *
*                        Copyright 1996, Voxware, Inc                          *
*                            All Rights Reserved                               *
*                                                                              *
*                       DISTRIBUTION PROHIBITED without                        *
*                      written authorization from Voxware                      *
*******************************************************************************/

/*******************************************************************************
* Filename:       quanrt29.h                                                           
*                                                                              
* Purpose:        File containing all quantization definitions for rt29.
*                                                                              
* Author/Date:    Rob Zopf  03/18/97                                                       
********************************************************************************
*                                                                      
*******************************************************************************/
#ifndef QUANRT28_H
#define QUANRT28_H 

#define GAIN_BITS_28                     6
#define	PV_BITS_28                       4
#define	F0_BITS_28                       8
#define	LSP_BITS_28                      41
#define	LSP_BITS_1_28                    5
#define	LSP_BITS_2_28                    5
#define	LSP_BITS_3_28                    5
#define	LSP_BITS_4_28                    5
#define	LSP_BITS_5_28                    4
#define	LSP_BITS_6_28                    4
#define	LSP_BITS_7_28                    4
#define	LSP_BITS_8_28                    3
#define	LSP_BITS_9_28                    3
#define	LSP_BITS_10_28                   3
#define	LSP_TABLES_28                    10
#define	AMP_BITS_28                      4
#define	AMP_TABLES_28                    2
#define AMP_BITS_1_28                    4  
#define AMP_BITS_2_28                    0  
#define AMP_BITS_3_28                    0 
#define RESERVED_BITS_28                    1

#define TOTAL_BITS_28                    (GAIN_BITS_28+PV_BITS_28+F0_BITS_28+LSP_BITS_28+AMP_BITS_28+RESERVED_BITS_28)

/* use whole range to quantize pitch */
#define QUANT_MIN_PITCH_28     8     /* 1000 Hz */
#define QUANT_MAX_PITCH_28     160   /* 50 Hz */

#define BYTESPERFRAME_28                 8



#endif /* QUANRT28_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\quanrt24.h ===
/*******************************************************************************
*                        Voxware Proprietary Material                          *
*                        Copyright 1996, Voxware, Inc                          *
*                            All Rights Reserved                               *
*                                                                              *
*                       DISTRIBUTION PROHIBITED without                        *
*                      written authorization from Voxware                      *
*******************************************************************************/

/*******************************************************************************
* Filename:       quanrt24.h    
*                                                                              
* Purpose:        File containing all quantization definitions.
*                                                                              
* Author/Date:    Rob Zopf  03/17/97                                                       
********************************************************************************
*                                                                      
*******************************************************************************/
#ifndef QUANRT24_H
#define QUANRT24_H

#define GAIN_BITS_24                     6
#define	PV_BITS_24                       4
#define	F0_BITS_24                       8
#define	LSP_BITS_24                      35
#define	LSP_BITS_1_24                    3
#define	LSP_BITS_2_24                    4
#define	LSP_BITS_3_24                    4
#define	LSP_BITS_4_24                    4
#define	LSP_BITS_5_24                    4
#define	LSP_BITS_6_24                    4
#define	LSP_BITS_7_24                    3
#define	LSP_BITS_8_24                    3
#define	LSP_BITS_9_24                    3
#define	LSP_BITS_10_24                   3
#define	LSP_TABLES_24                    10
#define RESERVED_BITS_24                 1

#define TOTAL_BITS_24                    (GAIN_BITS_24+PV_BITS_24+F0_BITS_24+LSP_BITS_24+RESERVED_BITS_24)

#define QUANT_MIN_PITCH_24               16   
#define QUANT_MAX_PITCH_24               125 

#define BYTESPERFRAME_24                 7



#endif /* QUANRT24_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\quanvr15.h ===
/*******************************************************************************
*                        Voxware Proprietary Material                          *
*                        Copyright 1996, Voxware, Inc                          *
*                            All Rights Reserved                               *
*                                                                              *
*                       DISTRIBUTION PROHIBITED without                        *
*                      written authorization from Voxware                      *
*******************************************************************************/

/*******************************************************************************
* Filename:       quanvr15.h                                                           
*                                                                              
* Purpose:        File containing all quantization definitions for vr15.
*                                                                              
* Author/Date:    Rob Zopf  06/01/97                                                       
********************************************************************************
*                                                                      
*******************************************************************************/
#ifndef QUANVR15_H
#define QUANVR15_H 

#define	TABLESIZE_LSPVQ_VR15            16
#define	TABLEBITS_LSPVQ_VR15             4
#define	NUMCAND_LSPVQ_VR15              16   
#define NUMSTAGES_LSPVQ_VR15_VOICED      8
#define NUMSTAGES_LSPVQ_VR15_MIXED      8
#define NUMSTAGES_LSPVQ_VR15_UNVOICED    3

#define CLASS_BITS_VR15                  2

#define GAIN_BITS_VR15_VOICED            6
#define F0_BITS_VR15_VOICED              7
#define LSP_BITS_VR15_VOICED             (NUMSTAGES_LSPVQ_VR15_VOICED*TABLEBITS_LSPVQ_VR15)
#define TOTAL_BITS_VR15_VOICED           (CLASS_BITS_VR15+GAIN_BITS_VR15_VOICED+F0_BITS_VR15_VOICED+LSP_BITS_VR15_VOICED)

#define GAIN_BITS_VR15_MIXED             GAIN_BITS_VR15_VOICED
#define F0_BITS_VR15_MIXED               F0_BITS_VR15_VOICED
#define PV_BITS_VR15_MIXED               3
#define LSP_BITS_VR15_MIXED              (NUMSTAGES_LSPVQ_VR15_MIXED*TABLEBITS_LSPVQ_VR15)
#define TOTAL_BITS_VR15_MIXED            (CLASS_BITS_VR15+GAIN_BITS_VR15_MIXED+F0_BITS_VR15_MIXED+LSP_BITS_VR15_MIXED+PV_BITS_VR15_MIXED)


#define GAIN_BITS_VR15_UNVOICED          5
#define LSP_BITS_VR15_UNVOICED           (NUMSTAGES_LSPVQ_VR15_UNVOICED*TABLEBITS_LSPVQ_VR15)
#define TOTAL_BITS_VR15_UNVOICED         (CLASS_BITS_VR15+GAIN_BITS_VR15_UNVOICED+LSP_BITS_VR15_UNVOICED)

#define TOTAL_BITS_VR15_SILENCE          CLASS_BITS_VR15 

/* use whole range to quantize pitch */
#define QUANT_MIN_PITCH_VR     8     /* 1000 Hz */
#define QUANT_MAX_PITCH_VR     160   /* 50 Hz */

#define BYTESPERFRAME_VR                 7

#define SILENCE_FRAME 3
#define UV_FRAME      2
#define MIX_FRAME     1
#define V_FRAME       0

#define PV_RESET      0.05    /* if pv < PV_RESET, set pv = 0.0 */
#define PV_V_BOUND    0.70    /* above which, pv will be synthesized at PV_V */
#define PV_V          0.94       /* */

#define ENERGY_HISTORY  10

#define RATE_V     0.10F
#define RATE_MIX   0.55F
#define RATE_UV    0.10F
#define RATE_S     0.25F

#endif /* QUANVR15_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\refinec0.c ===
/*******************************************************************************
*                        Voxware Proprietary Material                          *
*                        Copyright 1996, Voxware, Inc                          *
*                            All Rights Reserved                               *
*                                                                              *
*                       DISTRIBUTION PROHIBITED without                        *
*                      written authorization from Voxware                      *
*******************************************************************************/

/*******************************************************************************
* Filename:     RefineC0.c                        
*                                                                              
* Purpose:      Refine the coarse pitch estimate using the comb-filter
*               correlation to account for the possibly different analysis
*               window used in computing the voicing probability.
*                                                                              
* Functions:    VOXErr VoxRefineC0 ( float fCoarsePeriod, float *pfFltPwr, 
*                      float *pfPeakFrq, int iBpeaks, float *pfRefinedPeriod,
*                      float *pfRefinedRho ) 
*                                                                              
* Author/Date:  Bob McAulay/ 1/97                                              
********************************************************************************
* Modifications: Xiaoqin Sun, nonlinear pitch searching range.
*                                                                              
* Comments:                                                                    
* 
* Concerns:
*
* $Header:   /export/phobos/pvcs/r_and_d/archives/scaleable/pea/RefineC0.c_v   1.3   02 Apr 1998 14:49:58   weiwang  $
*******************************************************************************/
#include <math.h>
#include <assert.h>

#include "VoxMem.h"
#include "vLibQuan.h"
#include "vLibMath.h"

#include "RefineC0.h"
#include "codec.h"

#include "corrfunc.h"
#include "LDPDA.h"

#include "xvocver.h"


/******************************************************************************/
unsigned short VoxRefineC0 (STACK_R float fCoarsePeriod, float *pfFltPwr, float *pfPeakFrq, 
			     int iBpeaks, float *pfFltEnergy, float *pfRefinedPeriod,
			     float *pfRefinedRho ) 
{
  int j;
  float  fLoEdge, fHiEdge;
  float  fFltEnergy, fRefinedMax, fRefinedPeriod;
  float  *PitchTable;
  int  PitchTableSize;
  unsigned int iPitchIndex;
  float  deltapitch, dpitch;
  unsigned long mult_v2;

    
  STACK_INIT
  unsigned long iPeakFrq[MAXHARM];
  STACK_INIT_END
  STACK_ATTACH (unsigned long *, iPeakFrq) 

  STACK_START

  mult_v2= (unsigned long) (1<<F0_SHIFT_11B);
  
  for (j = 0; j < iBpeaks; j++)
	iPeakFrq[j]=(unsigned long)(pfPeakFrq[j]*mult_v2+0.5);

  /*** Get the pitch table ***/
  GetPitchTable(&PitchTable, &PitchTableSize);
 
  /*** Locate the search range for the refined pitch ***/

  fRefinedPeriod = fCoarsePeriod;

  /*search pitch index from the PitchFunction table*/
  iPitchIndex = ScalarQuant( fRefinedPeriod, PitchTable, PitchTableSize );
   
  /* Find the pitch difference */
  if( iPitchIndex >=1) 
    {
      deltapitch = PitchTable[iPitchIndex]-PitchTable[iPitchIndex-1];
      if (iPitchIndex < (unsigned int)(PitchTableSize -1)) 
	      deltapitch = 0.5F*(PitchTable[iPitchIndex+1]-PitchTable[iPitchIndex-1]);
    }
  else 
    {
      deltapitch = PitchTable[iPitchIndex+1]-PitchTable[iPitchIndex];
    }
  assert(deltapitch > 0);

  /*** Compute the energy in the flattened peaks ***/

  fFltEnergy = 1.E-10F;
  for (j = 0; j < iBpeaks; j++)
    fFltEnergy += pfFltPwr[j];

  fRefinedMax = 0.0F;

   
  /********************************************************************
    Find the best pitch candidates from the range: P-0.75dP:P+0.75dP
    *******************************************************************/
  /* get pitch step-size */
  dpitch =FRACTION1*deltapitch;

  /* find the pitch searching range */
  fLoEdge = fRefinedPeriod - SRANGE1*deltapitch;
  if (fLoEdge < (float) MIN_PITCH)
    fLoEdge = (float) MIN_PITCH;

  fHiEdge = fRefinedPeriod + SRANGE1*deltapitch;
  if (fHiEdge > (float) MAX_PITCH)
    fHiEdge = (float) MAX_PITCH;
  
  /* calculate the correlation function and get the best candidate */
  corrfunc( dpitch, fLoEdge, fHiEdge, &fRefinedMax, iBpeaks, pfFltPwr, fFltEnergy, 
	   iPeakFrq, &fRefinedPeriod);

  /********************************************************************
    Second run: test from fine resolution: P-0.25dP:P+0.25dP
    *******************************************************************/
  /* get pitch step-size */
  dpitch =FRACTION2*deltapitch;

  /* find the pitch searching range */
  fLoEdge = fRefinedPeriod - SRANGE2*deltapitch;
  if (fLoEdge < (float) MIN_PITCH)
    fLoEdge = (float) MIN_PITCH;
  fHiEdge = fRefinedPeriod + SRANGE2*deltapitch;
  if (fHiEdge > (float) MAX_PITCH)
    fHiEdge = (float) MAX_PITCH;
  
  /* calculate the correlation function and get the best candidate */
  corrfunc(dpitch, fLoEdge, fHiEdge, &fRefinedMax, iBpeaks, pfFltPwr, fFltEnergy, 
	   iPeakFrq, &fRefinedPeriod);

  /*** Compute the correlation coefficient and final refined pitch period ***/
 *pfFltEnergy = fFltEnergy;

 fRefinedMax = 0.5F * fRefinedMax;

 *pfRefinedRho = (fRefinedMax/fFltEnergy);

 *pfRefinedPeriod = fRefinedPeriod;
  
 STACK_END

 return 0;
 
} /*VoxRefineC0()*/
 
/***************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\realfft.c ===
/******************************************************************************
*                        Voxware Proprietary Material
*                        Copyright 1996, Voxware, Inc
*                            All Rights Reserved
*
*                       DISTRIBUTION PROHIBITED without
*                      written authorization from Voxware
******************************************************************************/
 
/******************************************************************************
*
* Filename:     RealFFT.c
*
* Purpose:      FFT and IFFT of real signal with inter-leaved format
*
* Functions:    void RealFft(float *pfInOut, int log2N, int iFlags);
*
*               void RealInverseFft(float *pfInOut, int log2N, int iFlags);
*
* Author/Date:  David Campana, 05/07/97
*
* $Header:   /export/phobos/pvcs/pvcsproj/voxlib.prj/RealFFT.c_v   1.13   03 Mar 1998 11:22:42   weiwang  $
*******************************************************************************/
/*************************************************************************
**
** This is an implementation of the packing/unpacking algorithm for 
** Real FFT / Inverse Real FFT (also known as conjugate symmetrix IFFT).
**
** I am happy with this code because:
**    - pretty fast
**    - pretty clean
**    - uses small twiddle table (1/4 cycle of sine)
**    - uses same format for frequency domain (interleaved) as NSP.
**    - uses stock FFT as part of algorithm. Can be sped up by using
**      a different (ie Radix 4) FFT kernel.
**    - uses no additional memory, and very small stack space.
**
** General Comment:
**    The code uses a mixture of arrays and pointers. On some machines, 
**    the code may run faster if the twiddle index (array) is converted
**    to a pointer. This is pretty easy to do.
**
** Improvements/TBD?
**    Some use of a radix 4 algorithm would be nice. Perhaps, the real FFT/IFFT
**    could call radix 4 kernels where appropriate.
**    Perhaps we could write a radix 4 kernel that had the ability to handle
**    N = 2^k != 4^j.
**
** Author:  David Campana
** Created: May 7, 1997.
**
** Modification:
**         June 24, 1997   Changed to fixpoint by Xiangdong Fu
**         Dec  23, 1997   Took improved fixed point code and converted to floating pt.
**                         Added ComplexFft(), InverseComplexFft() functions 
**                         for completeness and did some general cleanup and commenting.
**         Feb  23, 1997   Added in Wei's changes.
**                         Changed to in place only
**                         Changed variable names to Hungarian.
**
*****************
** Data Format **
*****************
** 
** Real FFT/IFFT:
**
** Time Domain: x[0]  x[1]  x[2]  x[3]  ... x[N-2]    x[N-1]
**
** Frequency:   Xr[0] Xi[0] Xr[1] Xi[1] ... Xr[N/2-1] Xi[N/2-1] Xr[N/2] Xi[N/2]
**
** There are therefore two more frequency domain data points than there
** are for time domain!!! 
** Xi[0] == Xi[N/2] == 0
**
**
**************************************************************************/

#include <math.h>
#include <stdlib.h>
#include <assert.h>
#include "vLibTran.h"

#include "xvocver.h"

/*************
**************
**          **
** Defines  **
**          **
**************
*************/

/*************
**************
**          **
** globals  **
**          **
**************
*************/

static const float twiddle[] =
{
#include "SinTab.h"
};

#define  TWIDDLE_TABLE_SIZE  (sizeof(twiddle)/sizeof(float))
/* if assumes the twiddle table contains 1/4 period of the twiddle table. */
#define  TWIDDLE_PERIOD  ((TWIDDLE_TABLE_SIZE - 1)*4)
#define  STAGE_3_TWIDDLE_INC  (TWIDDLE_PERIOD/8)

const float *sin0Index = twiddle;
const float *cos0Index = (&(twiddle[TWIDDLE_PERIOD/4]));


/****************
*****************
**             **
** Prototypes  **
**             **
*****************
****************/

static void Fft(float *pfInOut, int log2N);

static void Unpack(float *pfInOut, int log2N);

static void InverseUnpack(float *pfInOut, int log2N);

static void InverseFft(float *pfInOut, int log2N);

static void BitRev(float *pfInOut, int N);



/******************************************************************************
*
* Function:  RealFft()
*
* Action:    Fast-conversion of real signal to conjugate-symmetric spectrum.
*            The output is inter-leaved.
*
*            float *pfInOut        --> pfInOut real signal/output complex signal
*            int    log2N          --> the order for FFT
*
* Globals:   none
*
* Return:    void
*******************************************************************************
*
* Implementation/Detailed Description:
*
* References:
*******************************************************************************
*
* Modifications:
*
**          - This is the umbrella function. It calls out the other functions
**          that do the actual work.
**          - Frequency domain signal is interleaved, and has 2 extra locations.
**          See data format discussion above for more info.
**          - "Packing" algorithm, based on manipulating the output of
**          a complex FFT of half the size of the real FFT.
**          Not the most efficient algorithm, but good by most standards.
* Comments:  pfInOut length N and output length N+2.
*
* Concerns/TBD: 
******************************************************************************/

void RealFft(float *pfInOut, int log2N)
{
  int N;
  
  N = 1<<log2N;

  assert(pfInOut != NULL);
  assert(N >= 8);
  assert(N <= TWIDDLE_PERIOD);
  assert(log2N>0);
  
  BitRev(pfInOut, (N>>1));
  
  Fft(pfInOut, (log2N-1));

  Unpack(pfInOut, log2N);
}



/******************************************************************************
*
* Function:  RealInverseFft()
*
* Action:    Fast-conversion of conjugate-symmetric spectrum to real signal.
*            The pfInOut is inter-leaved.
*
*            float *pfInOut        --> pfInOut conjugate-symmetric spectrum
*                                      output real time signal
*            int    log2N          --> the order for FFT
*            int    iFlags         --> controls special functions
*
* Globals:   none
*
* Return:    void
*******************************************************************************
*
* Implementation/Detailed Description:
*
* References:
*******************************************************************************
*
* Modifications:
*
**          - This is the umbrella function. It calls out the other functions
**          that do the actual work.
**          - Frequency domain signal is interleaved, and has 2 extra locations.
**          See data format discussion above for more info.
**          - "Packing" algorithm, based on manipulating the output of
**          a complex FFT of half the size of the real FFT.
**          Not the most efficient algorithm, but good by most standards.
*
* Comments:  pfInOut length N+2 and output length N.
*
* Concerns/TBD: 
******************************************************************************/

void RealInverseFft(float *pfInOut, int log2N, int iFlags)
{
   int   i,
         N,
         N_2;

   float fScale;
   
   N = 1 << log2N;

   assert (pfInOut != NULL);
   assert (N >= 8);
   assert (N <= TWIDDLE_PERIOD);
   assert (log2N >= 3);

   InverseUnpack(pfInOut, log2N);

   N_2 = N>>1;

   BitRev(pfInOut, N_2);
   InverseFft(pfInOut, log2N-1);

   if ((iFlags & IFFT_NO_SCALE_FLAG) == 0)
   {
      /***** then do the scaling *****/
     fScale = 1.0F / (float)N;
     for (i = 0; i < N; i++)
       pfInOut[i] *= fScale;
   }
    
}




/***************************************************************************
**
** Fft
** ---
**
**
** Note:    This is an inplace only algorithm.
**
** Each butterfly iStage looks like ...
**
**
** (n-1)th iStage        nth iStage 
**
** p o-----------o-----o p
**           \  / 
**            \/ 
**            /\ 
**           /  \ 
** q o-- w -- -1 o-----o q
**
** where w is the approriate twiddle factor, and all multiplications
** and additions are complex.
**
** Stages 1 and 2 are calculated separately for speed (twiddle values are
** all -1, 0, +1 for stages 1 and 2).
**
** Stages 3 through log2N are unrolled inside. This allows us to use the
** smaller twiddle table, and saves a few multiplications.
** Woops! We don't do this (as much) anymore, which is fine for floating point,
** but you may still want to do it for fixed point.
**
** This is a radix 2 algorithm. Radix 4 algorithms generally require fewer
** multiplications and are faster (but are limited to powers of 4).
**
**************************************************************************/

static void Fft(float *pfInOut, int log2N)
{

  float        *pfBase,
               *pfPReal,
               *pfPImag,
               *pfQReal,
               *pfQImag;

  const float  *pfWReal,
               *pfWImag;

  int          iWInc,
               iWIndex,
               iButterflySep,
               iGroupsPerStage;
  int          i,
               iStage,
               j;
  float        a, b, c, d;
  int          N;
  
  N = 1<<log2N;

   /*
   ** The first couple of stages I can save significant complexity by
   ** taking advantage of the fact that pfWReal[iWIndex] and pfWImag[iWIndex]
   ** have a lot of nice values for the first couple stages (0, +1, -1)
   */

  assert(pfInOut != NULL);
  assert(N >= 4);
  assert(N <= TWIDDLE_PERIOD/2);
  assert(log2N >= 2);
  
   /************
   *************
   **         **
   ** Stage 1 **
   **         **
   *************
   ************/
   pfBase = pfInOut;
   for (i = (N>>1); i > 0; i--)
   {
      pfPReal = pfBase;
      pfPImag = pfPReal + 1;
      pfQReal = pfPReal + 2;
      pfQImag = pfQReal + 1;

      /* Calculate cross terms in butterfly (W * Q) */

      a = (*pfPReal) - (*pfQReal);
      b = (*pfPReal) + (*pfQReal);
      c = (*pfPImag) - (*pfQImag);
      d = (*pfPImag) + (*pfQImag);

      *pfQReal = a;
      *pfPReal = b;
      *pfQImag = c;
      *pfPImag = d;

      pfBase += 4;  /* Move ahead to next butterfly */
   }


   /************
   *************
   **         **
   ** Stage 2 **
   **         **
   *************
   ************/
   pfBase = pfInOut;
   for (i = (N>>2); i > 0; i--)
   {
      pfPReal = pfBase;
      pfPImag = pfPReal + 1;
      pfQReal = pfPReal + 4;
      pfQImag = pfQReal + 1;

      /* Calculate cross terms in butterfly (W * Q) */
      a = (*pfPReal) - (*pfQReal); 
      b = (*pfPReal) + (*pfQReal);     
      c = (*pfPImag) - (*pfQImag);       
      d = (*pfPImag) + (*pfQImag); 

      *pfQReal = a; 
      *pfPReal = b;
      *pfQImag = c;
      *pfPImag = d;

      pfBase += 2;  /* Move ahead to next butterfly */

      pfPReal = pfBase;
      pfPImag = pfPReal + 1;
      pfQReal = pfPReal + 4;
      pfQImag = pfQReal + 1;

      /* Calculate cross terms in butterfly (W * Q) */
      a = (*pfPReal) - (*pfQImag);
      b = (*pfPReal) + (*pfQImag);
      c = (*pfPImag) + (*pfQReal);
      d = (*pfPImag) - (*pfQReal);

      *pfQReal = a;
      *pfPReal = b;
      *pfQImag = c;
      *pfPImag = d;

      pfBase += 6;  /* Move ahead to next group */
   }


   /*********************
   **********************
   **                  **
   ** Stage 3 to log2N **
   **                  **
   **********************
   *********************/
   iWInc = STAGE_3_TWIDDLE_INC;
   iButterflySep = 4;
   iGroupsPerStage = N>>3;
   pfWReal = cos0Index;
   pfWImag = sin0Index;
   iWIndex = 0;

   for (iStage = 3; iStage <= log2N; iStage++)
   {
      pfBase = pfInOut;
      for (j = 0; j < iGroupsPerStage; j++)
      {
         for (i = (iButterflySep>>1); i > 0; i--)
         {
            pfPReal = pfBase;
            pfPImag = pfPReal + 1;
            pfQReal = pfPReal + (iButterflySep<<1);
            pfQImag = pfQReal + 1;

            /* Calculate cross terms in butterfly (W * Q) */            
            a = (*pfQReal) * pfWReal[-iWIndex]; 
            b = (*pfQReal) * pfWImag[iWIndex];
            
            a += (*pfQImag) * pfWImag[iWIndex];
            b -= (*pfQImag) * pfWReal[-iWIndex];
           
            c = (*pfPReal) - a;             /* c==>*pfQReal */
            a = (*pfPReal) + a;             /* a==>*pfPReal */

            d = (*pfPImag) + b;             /* d==>*pfQImag */
            b = (*pfPImag) - b;             /* b==>*pfPImag */

            *pfQReal = c;
            *pfPReal = a;
            *pfQImag = d;
            *pfPImag = b;

            /* Modulo addressing */
            assert(iWIndex <= TWIDDLE_TABLE_SIZE);
            iWIndex = (iWIndex + iWInc);
            pfBase += 2;  /* Move ahead to next butterfly */
         }

         for (i = (iButterflySep>>1); i > 0; i--)
         {
            pfPReal = pfBase;
            pfPImag = pfPReal + 1;
            pfQReal = pfPReal + (iButterflySep<<1);
            pfQImag = pfQReal + 1;

            /* Calculate cross terms in butterfly (W * Q) */
            a = (*pfQReal) * pfWReal[-iWIndex]; 
            b = (*pfQReal) * pfWImag[iWIndex];
            
            a -= (*pfQImag) * pfWImag[iWIndex];
            b += (*pfQImag) * pfWReal[-iWIndex];
           
            c = (*pfPReal) + a;       /* c==>*pfQReal */
            a = (*pfPReal) - a;       /* a==>*pfPReal */
            d = (*pfPImag) + b;       /* d==>*pfQImag */
            b = (*pfPImag) - b;       /* b==>*pfPImag */

            (*pfQReal) = c;
            (*pfPReal) = a;
            (*pfQImag) = d;
            (*pfPImag) = b;

            /* Modulo addressing */
            assert(iWIndex <= TWIDDLE_TABLE_SIZE);
            assert(iWIndex >= 0);
            iWIndex = (iWIndex - iWInc);
            pfBase += 2;  /* Move ahead to next butterfly */
         }

        /* Prepare for next group in current iStage */
         pfBase += (iButterflySep<<1);
      }

      /* Prepare for next iStage */
      iButterflySep <<= 1;          /* iButterflySep *= 2   */
      iWInc >>= 1;                  /* iWInc /= 2           */
      iGroupsPerStage >>= 1;        /* iGroupsPerStage /= 2 */
   }
}






/***************************************************************************
**
** InverseFft
** ----------
**
**
** Note:    This is an inplace algorithm.
**
** Each butterfly iStage looks like ...
**
**
** (n-1)th iStage        nth iStage 
**
** p o-----------o-----o p
**           \  / 
**            \/ 
**            /\ 
**           /  \ 
** q o-- w -- -1 o-----o q
**
** where w is the approriate twiddle factor, and all multiplications
** and additions are complex.
**
** Stages 1 and 2 are calculated separately for speed (twiddle values are
** all -1, 0, +1 for stages 1 and 2).
**
** Stages 3 through log2N are unrolled inside. This allows us to use the
** smaller twiddle table, and saves a few multiplications.
** Woops! We don't do this (as much) anymore, which is fine for floating point,
** but you may still want to do it for fixed point.
**
** This is a radix 2 algorithm. Radix 4 algorithms generally require fewer
** multiplications and are faster (but are limited to powers of 4).

***************************************************************************/

static void InverseFft(float *pfInOut, int log2N)
{
   float       *pfBase,
               *pfPReal,
               *pfPImag,
               *pfQReal,
               *pfQImag;

   float       a, b, c, d;

   const float *pfWReal,
               *pfWImag;

   int         iWInc,
               iWIndex,
               iButterflySep,
               iGroupsPerStage;

   int         i,
               iStage,
               j;

   int         N;

   N = 1<<log2N;

   assert(pfInOut != NULL);
   assert(N >= 4);
   assert(N <= TWIDDLE_PERIOD);
   assert(log2N >= 2);

   /*
   ** The first couple of stages I can save significant complexity by
   ** taking advantage of the fact that pfWReal[iWIndex] and pfWImag[iWIndex]
   ** have a lot of nice values for the first couple stages (0, +1, -1)
   */

   /************
   *************
   **         **
   ** Stage 1 **
   **         **
   *************
   ************/
   pfBase = pfInOut;
   for (i = 0; i < (N>>1); i++)
   {
      pfPReal = pfBase;
      pfPImag = pfPReal + 1;
      pfQReal = pfPReal + 2;
      pfQImag = pfQReal + 1;

      a = (*pfPReal) - (*pfQReal);
      b = (*pfPReal) + (*pfQReal);
      c = (*pfPImag) - (*pfQImag);
      d = (*pfPImag) + (*pfQImag);

      *pfQReal = a;
      *pfPReal = b;
      *pfQImag = c;
      *pfPImag = d;
      pfBase += 4;  /* Move ahead to next butterfly */
   }
  
   /************
   *************
   **         **
   ** Stage 2 **
   **         **
   *************
   ************/
   pfBase = pfInOut;
   for (i = 0; i < (N>>2); i++)
   {
      pfPReal = pfBase;
      pfPImag = pfPReal + 1;
      pfQReal = pfPReal + 4;
      pfQImag = pfQReal + 1;

      /* Calculate cross terms in butterfly (W * Q) */    
      a = (*pfPReal) - (*pfQReal); 
      b = (*pfPReal) + (*pfQReal);     
      c = (*pfPImag) - (*pfQImag);       
      d = (*pfPImag) + (*pfQImag); 

      (*pfQReal) = a;
      (*pfPReal) = b;
      (*pfQImag) = c;
      (*pfPImag) = d;
      
      pfBase += 2;  /* Move ahead to next butterfly */

      pfPReal = pfBase;
      pfPImag = pfPReal + 1;
      pfQReal = pfPReal + 4;
      pfQImag = pfQReal + 1;

      /* Calculate cross terms in butterfly (W * Q) */


      a = (*pfPReal) + (*pfQImag);
      b = (*pfPReal) - (*pfQImag);
      c = (*pfPImag) - (*pfQReal);
      d = (*pfPImag) + (*pfQReal);

      *pfQReal = a;
      *pfPReal = b;
      *pfQImag = c;
      *pfPImag = d;

      pfBase += 6;  /* Move ahead to next group */

   }
   
   /*********************
   **********************
   **                  **
   ** Stage 3 to log2N **
   **                  **
   **********************
   *********************/

   iWInc = STAGE_3_TWIDDLE_INC;
   iButterflySep = 4;
   iGroupsPerStage = N >> 3;
   iWIndex = 0;
   pfWReal = cos0Index;
   pfWImag = sin0Index;
   
   for (iStage = 3; iStage <= log2N; iStage++)
   {
      pfBase = pfInOut;
      for (j = 0; j < iGroupsPerStage; j++)
      {
         for (i = (iButterflySep>>1); i > 0; i--)
         {
            pfPReal = pfBase;
            pfPImag = pfPReal + 1;
            pfQReal = pfPReal + (iButterflySep<<1);
            pfQImag = pfQReal + 1;

            /* Calculate cross terms in butterfly (W * Q) */
            a = (*pfQReal) * pfWReal[-iWIndex]; 
            b = (*pfQReal) * pfWImag[iWIndex];
            
            a -= (*pfQImag) * pfWImag[iWIndex];
            b += (*pfQImag) * pfWReal[-iWIndex];
           
            /* convert data from Q15 to Q30 format before 
            addition/substraction */
            c = (*pfPReal) - a;    /* c==>*pfQReal */
            a = (*pfPReal) + a;    /* a==>*pfPReal */
            d = (*pfPImag) - b;    /* d==>*pfQImag */
            b = (*pfPImag) + b;    /* b==>*pfPImag */

            *pfQReal = c;
            *pfPReal = a;
            *pfQImag = d;
            *pfPImag = b;

            assert(iWIndex <= TWIDDLE_TABLE_SIZE);
            iWIndex = iWIndex + iWInc;
            pfBase += 2;  /* Move ahead to next butterfly */
         }
        
         for (i = (iButterflySep>>1); i > 0; i--)
         {
            assert(pfBase <= (pfInOut + (N << 1)));
            pfPReal = pfBase;
            pfPImag = pfPReal + 1;
            pfQReal = pfPReal + (iButterflySep<<1);
            pfQImag = pfQReal + 1;

            /* Calculate cross terms in butterfly (W * Q) */
            a = (*pfQReal) * pfWReal[-iWIndex]; 
            b = (*pfQReal) * pfWImag[iWIndex];
            
            a += (*pfQImag) * pfWImag[iWIndex];
            b -= (*pfQImag) * pfWReal[-iWIndex];
           
            c = (*pfPReal) + a;       /* c==>*pfQReal */
            a = (*pfPReal) - a;       /* a==>*pfPReal */
            d = (*pfPImag) - b;       /* d==>*pfQImag */
            b = (*pfPImag) + b;       /* b==>*pfPImag */

            *pfQReal = c;
            *pfPReal = a;
            *pfQImag = d;
            *pfPImag = b;

            assert(iWIndex <= TWIDDLE_TABLE_SIZE);
            assert(iWIndex >= 0);
            iWIndex = iWIndex - iWInc;
            pfBase += 2;  /* Move ahead to next butterfly */
         }
         pfBase += (iButterflySep<<1);
      }
      iButterflySep <<= 1;
      iWInc >>= 1;
      iGroupsPerStage >>= 1;
   }
}








/*************************************************************************
**
** Unpack
** ------
**
** Converts the output of the complex FFT into 
** a real FFT output.
**
** First iStage is to form the realEven, realOdd, imagEven, and
** imagOdd components of the FFT output.
** The second iStage is to combine these components in a 
** "butterfly" operation to form the real FFT output.
**
*************************************************************************/
static void Unpack(float *pfInOut, int log2N)
{
   int         k;
   const float *pfCos,
               *pfSin;
   int         twiddleMod;
   float       a, b, c, d;
   float       x0, x1, y0, y1;
   int         N;
   
   N = 1<<log2N;

   assert(pfInOut != NULL);
   assert(N >= 8);
   assert(N <= TWIDDLE_PERIOD);

   /* Define the boundary conditions */
   /* The 0 and 1 terms and the N and N+1 terms */
   a = pfInOut[0] - pfInOut[1];
   b = pfInOut[0] + pfInOut[1];
   
   pfInOut[N] = a;
   pfInOut[0] = b;

   pfInOut[N+1] = 0.0F;
   pfInOut[1] = 0.0F;

   pfCos = cos0Index;
   pfSin = sin0Index;
   twiddleMod = TWIDDLE_PERIOD >> log2N;

   for (k = 2; k < (N>>1); k+=2)
   {
      x0 = 0.5f * (pfInOut[k]   + pfInOut[N-k]);
      x1 = 0.5f * (pfInOut[k]   - pfInOut[N-k]);
      y0 = 0.5f * (pfInOut[k+1] + pfInOut[N-k+1]); 
      y1 = 0.5f * (pfInOut[k+1] - pfInOut[N-k+1]);     

      pfCos -= twiddleMod;
      pfSin += twiddleMod;

      a =  (*pfCos) * y0;
      b =  (*pfCos) * x1;
      a -= (*pfSin) * x1;      /* a = Wr*IE-Wi*RO  */
      b += (*pfSin) * y0;      /* b = Wr*RO+Wi*IE  */

      c = x0 + a;             /* pfInOut[k]         */
      d = x0 - a;             /* pfInOut[N-k]       */
      a = y1 - b;             /* pfInOut[k+1]       */
      b = y1 + b;             /* -pfInOut[N-k+1]    */

      pfInOut[k]         =  c; 
      pfInOut[N - k]     =  d;
      pfInOut[k + 1]     =  a;
      pfInOut[N - k + 1] =  -b;
   }

   /* The N/2 term */
   /* at this point k = N/2 */
   /* pfInOut[k] = pfInOut[k]; */
   pfInOut[k + 1] = -pfInOut[k+1];
}






/*************************************************************************
**
** InverseUnpack
** --------------
**
** Converts the complex FFT values into a packed sequence,
** after which the FFT is performed.
**
** First iStage is to form the realEven, realOdd, imagEven, and
** imagOdd components of the FFT output.
** The second iStage is to combine these components in a 
** "butterfly" operation to form another sequence.
** The output sequence will be used as an pfInOut to a size N IFFT.
**
** This function conjugates the imaginary
** components as it goes along.
**
**
*************************************************************************/
static void InverseUnpack(float *pfInOut, int log2N)
{
   int         k;
   const float *pfCos,
               *pfSin;
   int         twiddleMod;
   float       a, b, c, d;
   float       x0, x1, y0, y1;
   int         N;
   int         Nv2;

   N = 1<<log2N;

   assert(pfInOut != NULL);
   assert(N >= 8);
   assert(N <= TWIDDLE_PERIOD);
   assert(log2N >= 3);

   /* Define boundary conditions */

   /* the 0th and 1st terms */
   a =  pfInOut[0] + pfInOut[N];   /* realEven   */
   b =  pfInOut[1] + pfInOut[N+1]; /* imagEven   */
   c =  pfInOut[0] - pfInOut[N];   /* realOdd    */
   d =  pfInOut[1] - pfInOut[N+1]; /* imagOdd    */

   c = c + d;
   a = a - b;

   pfInOut[0] = a;
   pfInOut[1] = c;

   /* The N/2 term */
   Nv2 = N>>1;

   pfInOut[Nv2]   =  2.0f * pfInOut[Nv2];
   pfInOut[Nv2+1] = -2.0f * pfInOut[Nv2+1];

   /* second iStage - combine in "butterfly" fashion" */
   pfCos = cos0Index;
   pfSin = sin0Index;
   twiddleMod = TWIDDLE_PERIOD >> log2N;

   for (k=2; k < Nv2; k+=2)
   {
      x0 = pfInOut[k]   + pfInOut[N-k];
      x1 = pfInOut[k]   - pfInOut[N-k];
      y0 = pfInOut[k+1] + pfInOut[N-k+1]; 
      y1 = pfInOut[k+1] - pfInOut[N-k+1];     

      pfCos -= twiddleMod;
      pfSin += twiddleMod;

      a =  (*pfCos) * y0;
      b =  (*pfCos) * x1;
      a += (*pfSin) * x1;   /* a = -(Wr*IE-Wi*RO) */
      b -= (*pfSin) * y0;   /* b = Wr*RO+Wi*IE    */

      c = x0 - a;          /* output[k]      */
      d = x0 + a;          /* output[N-k]    */
      a = y1 + b;          /* output[k+1]    */
      b = y1 - b;          /* -output[N-k+1] */
    
      pfInOut[k]           = c; 
      pfInOut[N - k]       = d;
      pfInOut[k + 1]       = a;
      pfInOut[N - k + 1]   = -b;
   }
}


   





/*************************************************************************
**
** BitRev
** ------
**
** Interprets the data as an interleaved complex array and bit reverses
** the data in place.
**
** The total effect of the packing and bit reversal process
** is shown in the following example
**
**
** pfInOut             Packed         Bit Reversed
** -----             ------         ------------
** x[000]            r[00]          r[00]
** x[001]            i[00]          i[00]
** x[010]            r[01]          r[10] 
** x[011]   -->      i[01]    -->   i[10]
** x[100]            r[10]          r[01]
** x[101]            i[10]          i[01] 
** x[110]            r[11]          r[11]
** x[111]            i[11]          i[11]
**
** Note:
** The pfInOut N is the number of _complex_ elements in the output
** sequence. Therefore, the function expects 2N realvalued pfInOut
** elements.
**
** This version compes from Numerical Recipes (page 507)
**
*************************************************************************/
static void BitRev(float *pfInOut, int N)
{
   int   i, j, n, m;
   float temp;

   /* This algorithm is for in place manipulation */
   
   n = (N << 1);
   j = 1;
   for (i = 1; i < n; i +=2)
   {
      if (j > i)
      {
         /* swap i and j (imaginary part) */
         temp = pfInOut[j];
         pfInOut[j] = pfInOut[i];
         pfInOut[i] = temp;
         
         /* swap (i - 1) and (j - 1) (real part) */
         temp = pfInOut[j-1];
         pfInOut[j-1] = pfInOut[i-1];
         pfInOut[i-1] = temp;
      }
      m = (n >> 1);
      while (m >= 2 && j > m)
      {
         j = j - m;
         m >>= 1;
      }
      j = j + m;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\refine.h ===
/*******************************************************************************
*                        Voxware Proprietary Material                          *
*                        Copyright 1996, Voxware, Inc                          *
*                            All Rights Reserved                               *
*                                                                              *
*                       DISTRIBUTION PROHIBITED without                        *
*                      written authorization from Voxware                      *
*******************************************************************************/

/*******************************************************************************
* Filename:       Refine.h                                                          
*                                                                              
* Purpose:        Performs spectrum reconstruction                                                             
*                                                                              
* Author/Date:    Original developped by Suat Yeldener   1995
*                 Written by Rob Zopf  Sept. 12/95
*                 Modified by Wei Wang,  2/28/96                                            
********************************************************************************
* $Header:   /export/phobos/pvcs/r_and_d/archives/realtime/encode/Refine.h_v   1.0   26 Jan 1998 10:54:48   johnp  $                                                                     
*******************************************************************************/
#ifndef REFINE_H
#define REFINE_H


unsigned short VoxPitchRefine_TIME(float *const pitch, const float *const SWR, 
			   const float *const SWI, float *pPower, 
			   const unsigned int uiWinLen, float *BandError);

#endif /* REFINE_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\rate.h ===
/*******************************************************************************
*                        Voxware Proprietary Material                          *
*                        Copyright 1996, Voxware, Inc                          *
*                            All Rights Reserved                               *
*                                                                              *
*                       DISTRIBUTION PROHIBITED without                        *
*                      written authorization from Voxware                      *
*******************************************************************************/

/*******************************************************************************
* Filename:       rate.h
*                                                                              
* Purpose:        all bit manipulations for the rate change
*                                                                              
* Functions:
*                                                                              
* Author/Date:    Ilan Berci 97/09/23
*
*******************************************************************************
* Modifications:
*
* Comments:
*
* Concerns:
*
* $Header:   /export/phobos/pvcs/r_and_d/archives/scaleable/utils/rate.h_v   1.1   13 Feb 1998 11:24:02   weiwang  $
******************************************************************************/
#ifndef _RATE_H
#define _RATE_H

#define SC_BYTES_ADDITIONAL_3K 8
#define SC_BYTES_ADDITIONAL_6K 8

/* Listing of every byte size for every rate */
#define SC_BYTES_3K SC_BYTES_ADDITIONAL_3K
#define SC_BYTES_6K (SC_BYTES_3K+SC_BYTES_ADDITIONAL_6K)

/* Listing of every current rate */ 
#define SC_RATE_3K 1
#define SC_RATE_6K (1<<1)
#define SC_RATE_8K (1<<2)

/* Listing of valid fields */
#define SC_FIELD_3K SC_RATE_3K
#define SC_FIELD_6K (SC_FIELD_3K|SC_RATE_6K)

/* Defines for masking */
#define SC_RATE_SUPPORTED (SC_RATE_3K|SC_RATE_6K)
#define SC_RATE_UNSUPORTED (0xFFFF&~SC_RATE_SUPPORTED)

/* Listings of current rates that this instance of a codec supports */ 
#define SC_RATE_LOWEST  SC_RATE_3K
#define SC_RATE_HIGHEST SC_RATE_6K


/* ************************************************************************* */
/*                                                                           */
/* FUNCTION: isSingleStream()                                                */
/* PURPOSE : determines if the stream is a single instance                   */
/*                                                                           */
/*                                                                           */
/* ************************************************************************* */
unsigned char isSingleStream(unsigned long dwStream);

/* ************************************************************************* */
/*                                                                           */
/* FUNCTION: isValidStream()                                                 */
/* PURPOSE : determines if the stream is a valid stream                      */
/*                                                                           */
/*                                                                           */
/* ************************************************************************* */
unsigned char isValidStream(unsigned long dwStream, const unsigned short *wStreamTable);

/* ************************************************************************* */
/*                                                                           */
/* FUNCTION: bytesInStream()                                                 */
/* PURPOSE : determines the number of bytes in the stream                    */
/*                                                                           */
/*                                                                           */
/* ************************************************************************* */
unsigned short bytesInStream(unsigned long dwStream, const unsigned short *wStreamTable);

/* ************************************************************************* */
/*                                                                           */
/* FUNCTION: bytesToStream()                                                 */
/* PURPOSE : Put the number of bytes to the stream.                          */
/*                                                                           */
/*                                                                           */
/* ************************************************************************* */
unsigned long bytesToStream(unsigned short wBytes, const unsigned short *wStreamTable);

/* ************************************************************************* */
/*                                                                           */
/* FUNCTION: seekForward()                                                   */
/* PURPOSE : returns the byte offset after seeking to desired frame          */
/*           returns -1 on insufficient buffer and -2 on corrupted stream    */
/*                                                                           */
/* ************************************************************************* */
short seekForward(unsigned char *pVoxBuffer,
                  unsigned short wReadByteOffset,
                  unsigned short wWriteByteOffset,
                  unsigned short wBufferSize,
                  unsigned short wNumFrames,
                  const unsigned short *wStreamTable);
#endif /* _RATE_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\rate.c ===
/*******************************************************************************
*                        Voxware Proprietary Material                          *
*                        Copyright 1996, Voxware, Inc                          *
*                            All Rights Reserved                               *
*                                                                              *
*                       DISTRIBUTION PROHIBITED without                        *
*                      written authorization from Voxware                      *
*******************************************************************************/

/*******************************************************************************
* Filename:       rate.c
*                                                                              
* Purpose:        all bit manipulations for the rate change
*                                                                              
* Functions:
*                                                                              
* Author/Date:    Ilan Berci 97/09/23
*
*******************************************************************************
* Modifications:
*
* Comments:
*
* Concerns:
*
* $Header:   /export/phobos/pvcs/r_and_d/archives/scaleable/utils/rate.c_v   1.6   05 Jun 1998 17:59:24   bobd  $
******************************************************************************/
#include <stdlib.h>
#include <assert.h>

#include "rate.h"

#include "xvocver.h"

const unsigned short wDefaultTable[]={SC_BYTES_ADDITIONAL_3K,SC_BYTES_ADDITIONAL_6K,0};
/* ************************************************************************* */
/*                                                                           */
/* FUNCTION: isSingleStream()                                                */
/* PURPOSE : determines if the stream is a single instance                   */
/*                                                                           */
/*                                                                           */
/* ************************************************************************* */
unsigned char isSingleStream(unsigned long dwStream)
{
   if(!dwStream)  /* if there is no instance than leave */
      return 0;

   while(!(dwStream&0x01))
      dwStream>>=1;  /* find first bit in stream */

   if(dwStream>>=1)
      return 0;     /* not a valid stream */
   else 
      return 1;      /* single instance */
}

/* ************************************************************************* */
/*                                                                           */
/* FUNCTION: isValidStream()                                                 */
/* PURPOSE : determines if the stream is a valid stream                      */
/*                                                                           */
/*                                                                           */
/* ************************************************************************* */
unsigned char isValidStream(unsigned long dwStream, const unsigned short *wStreamTable)
{
   unsigned long dwMask=0;

   if(!dwStream)  /* if there is no instance than leave */
      return 0;

   if(!wStreamTable) /* switch to the default table if none was provided */
      wStreamTable=wDefaultTable;

   dwMask=~dwMask; /* get the inverse for ease of operation */
   while(*wStreamTable++) 
      dwMask<<=1;

   if(dwMask&dwStream)
      return 0; /* bit found in invalid section */

   while(dwStream&0x01)
      dwStream>>=1;

   if(dwStream)
      return 0; /* not a straight sequence */
   else 
      return 1; /* all checks a success */
}

/* ************************************************************************* */
/*                                                                           */
/* FUNCTION: bytesInStream()                                                 */
/* PURPOSE : determines the number of bytes in the stream                    */
/*                                                                           */
/*                                                                           */
/* ************************************************************************* */
unsigned short bytesInStream(unsigned long dwStream, const unsigned short *wStreamTable)
{
   int wAccumulate=0;

   if(!wStreamTable) /* switch to the default table if none was provided */
      wStreamTable=wDefaultTable;

   while(*wStreamTable) {
      if(dwStream&0x01)
         wAccumulate+=*wStreamTable;
      dwStream>>=1;
      wStreamTable++;
   }
   return (unsigned short)wAccumulate;
}


/* ************************************************************************* */
/*                                                                           */
/* FUNCTION: bytesToStream()                                                 */
/* PURPOSE : Put the number of bytes to the stream.                          */
/*                                                                           */
/*                                                                           */
/* ************************************************************************* */
unsigned long bytesToStream(unsigned short wBytes, const unsigned short *wStreamTable)
{

   unsigned long dwStream=0;
   if(!wStreamTable) /* switch to the default table if none was provided */
      wStreamTable=wDefaultTable;

   while(*wStreamTable) {
      wBytes = (unsigned short)(wBytes - *wStreamTable++);

      if((short)wBytes<0)
         break;

      dwStream<<=1;
      dwStream|=0x01;
   }

   return(dwStream);
}

/* ************************************************************************* */
/*                                                                           */
/* FUNCTION: seekForward()                                                   */
/* PURPOSE : returns the byte offset after seeking to desired frame          */
/*           returns -1 on insufficient buffer and -2 on corrupted stream    */
/*                                                                           */
/* ************************************************************************* */
short seekForward(unsigned char *pVoxBuffer,
                  unsigned short wReadByteOffset,
                  unsigned short wWriteByteOffset,
                  unsigned short wBufferSize,
                  unsigned short wNumFrames,
                  const unsigned short *wStreamTable)
{
   int            i;
   int            iCrossOver;
   unsigned short wBytesLeft;
   char           cContinue;
   assert(pVoxBuffer != NULL);

   /*---------------------------------------------------
     If wReadByteOffset equals wWriteByteOffset then
       the buffer is empty!
   ---------------------------------------------------*/
   if (wReadByteOffset==wWriteByteOffset)
           return -1;

   if (wWriteByteOffset>wReadByteOffset)
      iCrossOver = 1;
   else
      iCrossOver = 0;

   /*---------------------------------------------------
     switch to the default table if none was provided
   ---------------------------------------------------*/
   if(!wStreamTable)
      wStreamTable=wDefaultTable;

   while((wNumFrames--)>0) {
      i=0;
      do {
         /*---------------------------------------------------
           Increment wReadByteOffset by wStreamTable[i].
             We have to be careful here because 
             wReadByteOffset+wStreamTable[i] could be larger
             than the maximum unsigned short in which case
             we cannot compute the sum directly.
         ---------------------------------------------------*/
         wBytesLeft = wBufferSize - wReadByteOffset;
         if (wBytesLeft <= wStreamTable[i])
         {
            /*---------------------------------------------------
              If we will pass the write pointer as we wrap
                around then there are not enough sample in the 
                buffer.
            ---------------------------------------------------*/
            if (wWriteByteOffset>wReadByteOffset)
              return -1;

            wReadByteOffset = wStreamTable[i] - wBytesLeft;
            iCrossOver      = 1;
         } else {
            wReadByteOffset += wStreamTable[i];
         }
         i++;

         /*---------------------------------------------------
           If wReadByteOffset passses wWriteByteOffset then
             we are reading passed the end of the data in
             the buffer.  If wReadByteOffset is equal to 
             wWriteByteOffset then the buffer is empty, but 
             that's okay as long as we don't try to read 
             any further.
         ---------------------------------------------------*/
         if (iCrossOver&&(wReadByteOffset>wWriteByteOffset))
           return -1; /* not enough space in buffer to continue */

         /*---------------------------------------------------
            check for continuation bit
         ---------------------------------------------------*/
         if (wReadByteOffset)
            cContinue = (char)(pVoxBuffer[wReadByteOffset-1]&0x080);
         else
            cContinue = (char)(pVoxBuffer[wBufferSize-1]&0x080);

         /*---------------------------------------------------
            We have to be careful on these tests...the test
              for the corrupted bitstream comes first.
              If the bitstream is not corrupt, then we
              could be out of data.
         ---------------------------------------------------*/
         if((!wStreamTable[i]) && cContinue)
            return -2; /* bitstream may be corrupted */

         else if((wWriteByteOffset == wReadByteOffset) && cContinue)
            return -1; /* need more in buffer */

      } while(cContinue);
   }

   return(wReadByteOffset);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\refinec0.h ===
/*******************************************************************************
*                        Voxware Proprietary Material                          *
*                        Copyright 1996, Voxware, Inc                          *
*                            All Rights Reserved                               *
*                                                                              *
*                       DISTRIBUTION PROHIBITED without                        *
*                      written authorization from Voxware                      *
*******************************************************************************/
 
/*******************************************************************************
* $Header:   /export/phobos/pvcs/r_and_d/archives/scaleable/pea/RefineC0.h_v   1.0   06 Feb 1998 10:10:52   johnp  $
*******************************************************************************/
#ifndef _REFINEDC0_H
#define _REFINEDC0_H

unsigned short VoxRefineC0 (STACK_R float fCoarsePitchPeriod, float *fpFltPwr, 
			    float *fpPeakFrq, int iBpeaks, float *pfFltEnergy,
			    float *pfRefinedPitchPeriod, float *pfRhoRefined ); 

#endif /* _REFINEDC0_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\refine.c ===
/*******************************************************************************
*                        Voxware Proprietary Material                          *
*                        Copyright 1996, Voxware, Inc                          *
*                            All Rights Reserved                               *
*                                                                              *
*                       DISTRIBUTION PROHIBITED without                        *
*                      written authorization from Voxware                      *
*******************************************************************************/

/*******************************************************************************
* Filename:       Refine.c                                                             
*                                                                              
* Purpose:        Performs spectrum reconstruction                                                             
*                                                                              
* Functions:      VOXErr VoxPitchRefine(float *const pitch, void *PDA_mblk,
*                             const float *const SWR, const float *const SWI,
*                             const unsigned int uiNfft, short *pLL);                                                                 
*                                                                              
* Autohor/Date    Original developped by Suat Yeldener 
*                 Written by Rob Zopf  Sept. 12/95                                                                 
********************************************************************************
* Modifications:Ilan Berci/ 10/96 Removed global dependencies
*                                 Modularized code segments (Encapsulation)
*                                 Removed scope changes
*                                 Changed error code procedure
*                                 Removed useless code segments
*                                 General optimization         
*
* Modifications:Wei Wang  1/97    Rewrite all code. Change to L1 norm for pitch 
*                                 refinement. Use resampling technique to best-fit
*                                 window spectrum. -- need optimization.
*                         5/2/97: put macro FABS().
*
* Comments:                                                               
* 
* Concerns:
*
* $Header:   G:/r_and_d/archives/realtime/encode/Refine.c_v   1.1   11 Mar 1998 13:33:48   weiwang  $
*******************************************************************************/

#include  <math.h>
#include  <assert.h>
#include  <stdlib.h>

#include  "VoxMem.h"
#include  "model.h"
#include "research.h"

#include "VoxRound.h"
#include  "GetnHarm.h"

#include "SynSpec.h"

#include "Refine.h"

#include "xvocver.h"



/*******************************************************************************
* Function:       VOXErr VoxPitchRefine(float *const pitch, void *PDA_mblk,
*                         const float *const SWR, const float *const SWI,
*                         const unsigned int uiNfft)
*
* Action:
*
* Input:
*
* Output:
*
* Globals:        none
*
* Return:		  VOXErr : Voxware return code
********************************************************************************
* Implementation/Detailed Description:
*
* References:
********************************************************************************
* Modifications:Wei Wang  1/97    Rewrite all code. Change to L1 norm for pitch 
*                                 refinement. Use resampling technique to best-fit
*                                 window spectrum. -- need optimization.
*
* Comments:       use only half the window spectrum
*
* Concerns/TBD:
*******************************************************************************/
const float CRefinePitchTab1[NREFINEP01] = {-1.5F, -0.75F, 0.0F, 0.75F, 1.5F};
const float CRefinePitchTab2[NREFINEP02] = {-0.5F, -0.25F, 0.25F, 0.5F};


unsigned short VoxPitchRefine_TIME(float *const pitch, const float *const SWR, const float *const SWI,
		      float *pPower, const unsigned int uiWinLen, float *BandError)
{
  float *pSWR = (float *)SWR;
  float *pSWI = (float *)SWI;
  int iSpecInd1, iSpecInd2;
  float minErr, totalErr;
  int i;
  float fBasePitch;
  float fTryPitch;
  float fRefinePitch;


  if (*pitch < (float)MIN_REFINE_PITCH) *pitch = (float)MIN_REFINE_PITCH;


  /*************************************************************
    Find the errors from 0.75 resolution 
    The spectrum error ranged from 50Hz to 3700 Hz
    ************************************************************/
  fBasePitch = *pitch;
  iSpecInd1 = SPEC_START;  iSpecInd2 = SPEC_END;
  i = 0;
  minErr = MAXCON;    
  fRefinePitch = fBasePitch;
  while (i < NREFINEP01) {
    fTryPitch = *pitch + CRefinePitchTab1[i];

    if (fTryPitch >= MIN_REFINE_PITCH)
      totalErr = CalcCmpxSpecErr(fTryPitch, pSWR, pSWI, uiWinLen, iSpecInd1, iSpecInd2);
    else
      totalErr = MAXCON;

    if (minErr > totalErr) {
      minErr = totalErr;
      fRefinePitch = fTryPitch;
    }
    i++;
  } 


  /*************************************************************
    second run: test from  0.25 resultion 
    ************************************************************/
  i = 0;
  fBasePitch = fRefinePitch;
  while (i < NREFINEP02) {
    fTryPitch = fBasePitch + CRefinePitchTab2[i];

    if (fTryPitch >= MIN_REFINE_PITCH)
      totalErr = CalcCmpxSpecErr(fTryPitch, pSWR, pSWI, uiWinLen, iSpecInd1, iSpecInd2);
    else
      totalErr = MAXCON;

    if (minErr > totalErr) {
      minErr = totalErr;
      fRefinePitch = fTryPitch;
    }
    i++;
  } 


  /**** make sure the number of harmonics won't go beyond 90 ****/
  /**** the maximum pitch after the refinement is 180+1.5+0.5 ****/
  /**** and the corresponding number of harmonics should be 
        (floor)(182.0*255.0/512.0) ****/
  if(fRefinePitch > (float)(MAX_PITCH+2))
     fRefinePitch = (float)(MAX_PITCH+2);

  /*************************************************************
    calculate the harmonics error and energy 
    ************************************************************/
  CalcBandErr(fRefinePitch, pSWR, pSWI, pPower, uiWinLen, BandError);


  *pitch = fRefinePitch;

  return 0;
  
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\sc36test.c ===
#include <stdlib.h>

extern int STCmain(int,char**);

int main(int argc, char** argv)
{
	/**********************/
	/*** Scalable Codes ***/

	/* assign shared arguments */
	argc = 4;

	/*** SCX ***/
	argv[1] = "-iSCX";
	argv[2] = "sample_m.raw";		/* need to reassign both input and output files for scalable codecs */
	argv[3] = "sample_m_c_SCX.raw";
	STCmain(argc,argv);

	return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\research.h ===
/*******************************************************************************
*                        Voxware Proprietary Material                          *
*                        Copyright 1996, Voxware, Inc                          *
*                            All Rights Reserved                               *
*                                                                              *
*                       DISTRIBUTION PROHIBITED without                        *
*                      written authorization from Voxware                      *
*******************************************************************************/

/*******************************************************************************
* Filename:       research.h                                                           
*                                                                              
* Purpose:        File to handle research (temporary) compile switches.
*                                                                              
* Author/Date:    Rob Zopf  02/17/97                                                       
********************************************************************************
*                                                                      
*******************************************************************************/
#ifndef RESEARCH_H
#define RESEARCH_H

/***** The following 3 precompiler definitions are for pitch range checking. If the model code
 and quantization can support pitch range from 10 to 180, then we should switch all the 
 definition to 0s ****/
#define USE_DOUBLE_PITCH            0  /**** use double pitch residue amplitude calculation when pitch < 16 ****/

#define LOG_DOMAIN_INTERPOLATION 0

#define RESID_FLAT_SYN 0

#define UV_PITCH 64 /* hz */

#define USE_MULTIPLE_PITCH_FOR_UV   1

#define USE_MEASURED_PHASE 0

#define ROB_NEW  1

/* Change quantization of energy. Those definition will move to model.h 
   when it's finalized. */
#define ScaleEngUp         1.6027F /* (1.6027F) factors for reusing the old quantization table */
#define ScaleEngDown       0.623947F  /*   (0.623947F) */


/* Change residue amplitude calculation. */

#define NEW_QUAN_PITCH     1      /* 0: old pitch quantizer.
				     1: new pitch quantizer from 50Hz to 1000Hz  */

#define NOT_QUAN_AMP       0   /* 1: not quantize it . 0: quantize it */

#define NOT_QUAN_ENG       0   /* 1: not quantize it ,  0: quantize it */
#define NEW_GAINCB_5Bit    1

#define NOT_QUAN_LSF       0

#define NOT_QUAN_PITCH     0

#define NOT_QUAN_PV        0


#define COMPLEX_VOICING      1

#endif /* RESEARCH_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\residamp.h ===
/*******************************************************************************
*                        Voxware Proprietary Material                          *
*                        Copyright 1996, Voxware, Inc                          *
*                            All Rights Reserved                               *
*                                                                              *
*                       DISTRIBUTION PROHIBITED without                        *
*                      written authorization from Voxware                      *
*******************************************************************************/

/*******************************************************************************
* Filename:       ResidAmp.h                                                         
*                                                                              
* Purpose:        Compute the harmonic amplitudes of the excitation                                                             
*                                                                              
* Author/Date:    Original developped 1995
*                 Merged by Rob Zopf, Sept. 12/95   
*                 2/9/96: modified by Wei Wang for new structures                                                          
********************************************************************************
* $Header:   /export/phobos/pvcs/r_and_d/archives/realtime/encode/ResidAmp.h_v   1.0   26 Jan 1998 10:54:56   johnp  $                                                                     
*******************************************************************************/


#ifndef RESIDAMP_H
#define RESIDAMP_H

#define FFT_RES_ORDER             8
#define NFFT_RES                  (1<<FFT_RES_ORDER)    /* use 256 points FFT for inverse LPC spectrum */
#define F0_UV                     ((float)NFFT/(float)PITCH_UV)
#define F0_UV_RES                 ((float)NFFT_RES/(float)PITCH_UV)

#define FIXED_POINT_INDEX_RES      1
#define RES_SHIFT                  22


unsigned short VoxResidueAmp(STACK_R void *hEncMemBlk, float *BarkWtAmp);


#endif /* RESIDAMP_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\rsmsvq.h ===
/******************************************************************************
*                        Voxware Proprietary Material
*                        Copyright 1996, Voxware, Inc
*                            All Rights Reserved
*
*                       DISTRIBUTION PROHIBITED without
*                      written authorization from Voxware
******************************************************************************/
 
/******************************************************************************
* Filename:    RSMSVq.h
*
* Purpose:  quantize / unquantize vector using the split 2 Stage rotation and 
*           scaling VQ.
*
* Functions: RS2StageVQ2Enc and RS2StageVQ2Dec
*
* Author/Date: Original written by Xiaoqin Sun inside MSVqPred.c, 1997
*              Organize and Clean up code by Wei Wang, Feb. 4, 1998
*******************************************************************************
*
* Modifications: 
*
* Comments: The MSVQ uses two stage VQ. Each stage has two saparate codebooks 
*           for inner cells and outer cells.  Before searching second code books
*           residual vectors are rotated and scaled by multiplying a pretrained 
*           rotate-scaleer matrix. Each time, first stage codebook has two 
*           possible outputs (two-survivors) as candidates to be second codebook
*           entries to find the best ultimate output vector. 
*
* Concerns: Hard-wired only for dimension equal to 2
*
* $Header:   /export/phobos/pvcs/r_and_d/archives/scaleable/quan/RSMSVq.h_v   1.1   26 Feb 1998 13:48:22   bobd  $
*
******************************************************************************/

#ifndef _RSMSVQ_H_
#define _RSMSVQ_H_

/******************************************************************************
*
* Function: RS2StageVQ2Enc
*
* Action: code vector using Rotation-Scaling 2 Stage VQ  
*
* Input:  piIndices -- pointer to the quantization indices
*         pfData -- input coefficients (or vector)
*         iNumCand -- number of M-Best candidates
*         iStage1Size -- size of the stage I codebook
*         pfStage1CB -- stage I codebook
*         pfRotScaleCB -- rotation-scaling codebook
*         iStage2Size -- size of the stage II codebook
*         pfStage2InCellCB -- stage II inner cell codebook
*         pfStage2OutCellCB -- stage II outer cell codebook
*         iNumOfOutCell -- number of outer cell in the stage I codebook
*         piIndexOfStage2OutCell -- the index for the outer cell in stage 
*                                     I codebook
*
* Output: piIndices -- quantization indices
*         pfData -- quantized coefficients 
*
* Globals:   none
*
* Return:    none
*******************************************************************************/
void RS2StageVQ2Enc( STACK_R
                     int         *piIndices,
                     float       *pfData,
                     int          iNumCand,
                     int          iStage1Size,
                     const float *pfStage1CB,
                     const float *pfRotScaleCB,
                     int          iStage2Size,
                     const float *pfStage2InCellCB,
                     const float *pfStage2OutCellCB,
                     int          iNumOfOutCell,
                     const int   *piIndexOfStage2OutCell
                   );

/******************************************************************************
*
* Function: RS2StageVQ2Dec
*
* Action: decode vector using Rotation-Scaling 2 Stage VQ  
*
* Input:  piIndices -- the quantization indices
*         pfData -- pointer to the output coefficients (or vector)
*         iStage1Size -- entries in stage 1 codebook
*         pfStage1CB -- stage I codebook
*         pfRotScaleCB -- rotation-scaling codebook
*         iStage2Size -- entries in stage II codebooks
*         pfStage2InCellCB -- stage II inner cell codebook
*         pfStage2OutCellCB -- stage II outer cell codebook
*         iNumOfOutCell -- number of outer cell in the stage I codebook
*         piIndexOfStage2OutCell -- the index for the outer cell in stage 
*                                      I codebook
*
* Output:   pfData -- quantized coefficients 
*
* Globals:   none
*
* Return:    none
*******************************************************************************/
void RS2StageVQ2Dec( STACK_R
                     const int   *piIndices,
                     float       *pfData,
                     int          iStage1Size,
                     const float *pfStage1CB,
                     const float *pfRotScaleCB,
                     int          iStage2Size,
                     const float *pfStage2InCellCB,
                     const float *pfStage2OutCellCB,
                     int          iNumOfOutCell,
                     const int   *piIndexOfStage2OutCell
                   );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\resid28.h ===
/*******************************************************************************
*                        Voxware Proprietary Material                          *
*                        Copyright 1996, Voxware, Inc                          *
*                            All Rights Reserved                               *
*                                                                              *
*                       DISTRIBUTION PROHIBITED without                        *
*                      written authorization from Voxware                      *
*******************************************************************************/

/*******************************************************************************
* Filename:       Resid28.h                                                         
*                                                                              
* Purpose:        Compute the harmonic amplitudes of the excitation 
*                                                                              
* Functions:                                                              
*                                                                              
* Author/Date:   
********************************************************************************
* Modifications
*
* Comments:                                                                    
* 
* Concerns:
*
*******************************************************************************/
#ifndef RESID28_H
#define RESID28_H

unsigned short VoxCalcResidRT28(STACK_R void *hEncMemBlk, void *pvQuanMemBlk);

#endif /* RESID29_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\scalevec.c ===
/*******************************************************************************
*                        Voxware Proprietary Material                          *
*                        Copyright 1996, Voxware, Inc                          *
*                            All Rights Reserved                               *
*                                                                              *
*                       DISTRIBUTION PROHIBITED without                        *
*                      written authorization from Voxware                      *
*******************************************************************************/

/*******************************************************************************
* Filename:       ScaleVec.c
*                                                                              
* Purpose:        Multiply a vector by a scalar.
*                                                                              
* Functions:      ScaleVector() 
*                        
* Author/Date:    Bob Dunn 2/24/98
********************************************************************************
* $Header:   /export/phobos/pvcs/pvcsproj/voxlib.prj/ScaleVec.c_v   1.2   25 Mar 1998 14:31:18   weiwang  $
*******************************************************************************/
#include <stdlib.h>
#include <assert.h>

#include "vLibVec.h"

#include "xvocver.h"

/******************************************************************************
*
* Function:  ScaleVector()
*
* Action:    Multiply a vector by a scalar.
*
* Input:     float *pfIn      -> the vector to be scaled
*            int    iLength   -> the length of the vector
*            float  fScalar   -> the desired scale factor
*
* Output:    float *pfOut     -> the scaled vector
*
* Globals:   none
*
* Return:    void
*******************************************************************************
*
* Modifications:
*
* Comments:  In place and out of place operation are supported.
*
* Concerns/TBD:
******************************************************************************/
void ScaleVector( float *pfIn, 
                  int    iLength, 
                  float  fScalar, 
                  float *pfOut 
                )
{
  /*------------------------------------------------------
    Test for bad input.
  ------------------------------------------------------*/
  assert( pfIn != NULL );
  assert( pfOut != NULL );
  assert( iLength >= 0 );

  /*------------------------------------------------------
    Scale the vector.
  ------------------------------------------------------*/
  while ((iLength--)>0)
    *pfOut++ = *pfIn++ * fScalar;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\resid29.h ===
/*******************************************************************************
*                        Voxware Proprietary Material                          *
*                        Copyright 1996, Voxware, Inc                          *
*                            All Rights Reserved                               *
*                                                                              *
*                       DISTRIBUTION PROHIBITED without                        *
*                      written authorization from Voxware                      *
*******************************************************************************/
 
/*******************************************************************************
* Filename:       Resid29.h                                                         
*                                                                              
* Purpose:        Compute the harmonic amplitudes of the excitation 
*                                                                              
* Functions:                                                              
*                                                                              
* Author/Date:   
********************************************************************************
* Modifications
*
* Comments:                                                                    
* 
* Concerns:
*
*******************************************************************************/
 
#ifndef RESID29_H
#define RESID29_H

unsigned short VoxCalcResidRT29(STACK_R void *hEncMemBlk);

#endif /* RESID29_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\rsmsvq.c ===
/******************************************************************************
*                        Voxware Proprietary Material
*                        Copyright 1996, Voxware, Inc
*                            All Rights Reserved
*
*                       DISTRIBUTION PROHIBITED without
*                      written authorization from Voxware
******************************************************************************/
 
/******************************************************************************
* Filename:    RSMSVq.c
*
* Purpose:  quantize / unquantize vector using the split 2 Stage rotation and 
*           scaling VQ.
*
* Functions: RS2StageVQ2Enc and RS2StageVQ2Dec
*
* Author/Date: Original written by Xiaoqin Sun inside MSVqPred.c, 1997
*              Organize and Clean up code by Wei Wang, Feb. 4, 1998
*******************************************************************************
*
* Modifications: 
*
* Comments: The MSVQ uses two stage VQ. Each stage has two saparate codebooks 
*           for inner cells and outer cells.  Before searching second code books
*           residual vectors are rotated and scaled by multiplying a pretrained 
*           rotate-scaleer matrix. Each time, first stage codebook has two 
*           possible outputs (two-survivors) as candidates to be second codebook
*           entries to find the best ultimate output vector. 
*
* Concerns: Hard-wired only for dimension equal to 2
*
* $Header:   /export/phobos/pvcs/r_and_d/archives/scaleable/quan/RSMSVq.c_v   1.4   08 Apr 1998 11:03:04   weiwang  $
*
******************************************************************************/
#include <stdlib.h>
#include <assert.h>
#include "VoxMem.h"
#include "vLibQuan.h"
#include "RSMSVq.h"

#include "xvocver.h"

#define MAX_NUMCAND   2
#undef FLT_MAX
#define FLT_MAX       3.40282E+38F
#define VQ2_DIMENSION 2

#ifndef DECODE_ONLY
static void VQ2mbest(STACK_R const float *pfData, const float *pfCB, 
                     int iCBSize, int *piMBestCand,  int iMBest);

static void RotScaleVQ2(const float *pfIn, const float *pfRSMatrix,
                        int iIndex, float *pfOut);

static float CompDistVQ2(const float *pfIn, const float *pfRef);
#endif

static void DeRotScaleVQ2(const float *pfIn, const float *pfRSMatrix,
                          int iIndex, float *pfOut);

static int SelectOutCellCB(const int *piIndexOfOutCell,
                           int iNumOfOutCell, 
                           int iIndex);

#ifndef DECODE_ONLY
/******************************************************************************
*
* Function: RS2StageVQ2Enc
*
* Action: code vector using Rotation-Scaling 2 Stage VQ  
*
* Input:  piIndices -- pointer to the quantization indices
*         pfData -- input coefficients (or vector)
*         iNumCand -- number of M-Best candidates
*         iStage1Size -- size of the stage I codebook
*         pfStage1CB -- stage I codebook
*         pfRotScaleCB -- rotation-scaling codebook
*         iStage2Size -- size of the stage II codebook
*         pfStage2InCellCB -- stage II inner cell codebook
*         pfStage2OutCellCB -- stage II outer cell codebook
*         iNumOfOutCell -- number of outer cell in the stage I codebook
*         piIndexOfStage2OutCell -- the index for the outer cell in stage 
*                                     I codebook
*
* Output: piIndices -- quantization indices
*         pfData -- quantized coefficients 
*
* Globals:   none
*
* Return:    none
*******************************************************************************
*
* Implementation/Detailed Description: 
*
* References:
*******************************************************************************
*
* Modifications:
*
* Comments:  
*
* Concerns/TBD: only for 2-dimensional VQ
******************************************************************************/

void RS2StageVQ2Enc( STACK_R 
                     int         *piIndices, 
                     float       *pfData, 
                     int          iNumCand,
                     int          iStage1Size, 
                     const float *pfStage1CB,
                     const float *pfRotScaleCB, 
                     int          iStage2Size,
                     const float *pfStage2InCellCB, 
                     const float *pfStage2OutCellCB,
                     int          iNumOfOutCell, 
                     const int   *piIndexOfStage2OutCell
                   )
{
  int i;
  int iBestCand;
  int iIndex;
  float fDis;
  float fMinDis;
  const float *pfStage2CB;
STACK_INIT
  int piMBestCand[MAX_NUMCAND];
  float pfStage1Out[VQ2_DIMENSION];
  float pfRes[VQ2_DIMENSION];
  float pfStage2In[VQ2_DIMENSION];
  float pfQuanVec[VQ2_DIMENSION];
STACK_INIT_END

  STACK_ATTACH(int *, piMBestCand)
  STACK_ATTACH(float *, pfStage1Out)
  STACK_ATTACH(float *, pfRes)
  STACK_ATTACH(float *, pfStage2In)
  STACK_ATTACH(float *, pfQuanVec)

STACK_START
  
  assert(iNumCand <= MAX_NUMCAND);
  assert((piIndices != NULL) && (pfData != NULL));
  assert((pfStage1CB != NULL) && (pfRotScaleCB != NULL));
  assert((pfStage2InCellCB != NULL) && (pfStage2OutCellCB != NULL));
  assert(piIndexOfStage2OutCell != NULL);

  /*--------------------------------------------------
    initializethe  minimum distortion.
    --------------------------------------------------*/
  fMinDis = FLT_MAX;

  /*--------------------------------------------------
    Find the M-Best candidates
    --------------------------------------------------*/
  VQ2mbest(STACK_S pfData, pfStage1CB, iStage1Size, piMBestCand, iNumCand);


  /*--------------------------------------------------
    Check each candidates for the next stage 
    --------------------------------------------------*/
   for(i=0; i<iNumCand; i++)
     {
       iBestCand = piMBestCand[i];

       /*--------------------------------------------------
         Find the quantized vector from stage I VQ
         --------------------------------------------------*/
       Dim2VectorLUT(iBestCand, pfStage1CB, iStage1Size, pfStage1Out);

       /*--------------------------------------------------
         Find the residual and do rotation-scaling to 
         normalize the residual vector.
         --------------------------------------------------*/
       pfRes[0] = pfData[0] - pfStage1Out[0];
       pfRes[1] = pfData[1] - pfStage1Out[1];

       RotScaleVQ2(pfRes, pfRotScaleCB, iBestCand, pfStage2In);

       /*--------------------------------------------------
        Initialize the codebook for stage II -- from
        inner cell or outer cell
        --------------------------------------------------*/
       if (SelectOutCellCB(piIndexOfStage2OutCell, iNumOfOutCell, 
                           iBestCand) == 1)
          pfStage2CB = pfStage2OutCellCB;
       else
          pfStage2CB = pfStage2InCellCB;


       /*--------------------------------------------------
        Quantize the residual using stage II codebook.
        --------------------------------------------------*/
       iIndex = Dim2VectorQuantize(pfStage2In, pfStage2CB, iStage2Size);

       /*--------------------------------------------------
        Now, get the quantized stage II vector.
        --------------------------------------------------*/
       Dim2VectorLUT(iIndex, pfStage2CB, iStage2Size, pfStage2In);

       /*--------------------------------------------------
         undo rotation and scaling 
        --------------------------------------------------*/
       DeRotScaleVQ2(pfStage2In, pfRotScaleCB, iBestCand, pfRes);

       /*--------------------------------------------------
        Get the fully quantized vector by adding the
        residual vector.
        --------------------------------------------------*/
       pfStage1Out[0] += pfRes[0];
       pfStage1Out[1] += pfRes[1];

       /*--------------------------------------------------
        Compute the distortion
        --------------------------------------------------*/
       fDis = CompDistVQ2(pfData, pfStage1Out);

       /*--------------------------------------------------
         Find the minimum distation
        --------------------------------------------------*/
       if (fDis < fMinDis) 
         {
           fMinDis = fDis;
           piIndices[0] = iBestCand;
           piIndices[1] = iIndex;
           pfQuanVec[0] = pfStage1Out[0];
           pfQuanVec[1] = pfStage1Out[1];
         }
     } 

   /*--------------------------------------------------
     Replace pfData with pfQuanVec
     --------------------------------------------------*/
   pfData[0] = pfQuanVec[0];
   pfData[1] = pfQuanVec[1];
   
STACK_END
}
#endif

/******************************************************************************
*
* Function: RS2StageVQ2Dec
*
* Action: decode vector using Rotation-Scaling 2 Stage VQ  
*
* Input:  piIndices -- the quantization indices
*         pfData -- pointer to the output coefficients (or vector)
*         iStage1Size -- entries in stage 1 codebook
*         pfStage1CB -- stage I codebook
*         pfRotScaleCB -- rotation-scaling codebook
*         iStage2Size -- entries in stage II codebooks
*         pfStage2InCellCB -- stage II inner cell codebook
*         pfStage2OutCellCB -- stage II outer cell codebook
*         iNumOfOutCell -- number of outer cell in the stage I codebook
*         piIndexOfStage2OutCell -- the index for the outer cell in stage 
*                                     I codebook
*
* Output:   pfData -- quantized coefficients 
*
* Globals:   none
*
* Return:    none
*******************************************************************************
*
* Implementation/Detailed Description: 
*
* References:
*******************************************************************************
*
* Modifications:
*
* Comments:  
*
* Concerns/TBD: only for 2-dimensional VQ
******************************************************************************/

void RS2StageVQ2Dec( STACK_R 
                     const int   *piIndices, 
                     float       *pfData, 
                     int          iStage1Size,
                     const float *pfStage1CB,
                     const float *pfRotScaleCB,
                     int          iStage2Size,
                     const float *pfStage2InCellCB, 
                     const float *pfStage2OutCellCB,
                     int          iNumOfOutCell, 
                     const int   *piIndexOfStage2OutCell
                   )
{
  const float *pfStage2CB;
STACK_INIT
  float pfStage2In[VQ2_DIMENSION];
  float pfRes[VQ2_DIMENSION];
STACK_INIT_END

  STACK_ATTACH(float *, pfStage2In)  
  STACK_ATTACH(float *, pfRes)

STACK_START

  assert((piIndices != NULL) && (pfData != NULL));
  assert((pfStage1CB != NULL) && (pfRotScaleCB != NULL));
  assert((pfStage2InCellCB != NULL) && (pfStage2OutCellCB != NULL));
  assert(piIndexOfStage2OutCell != NULL);
 
  /*--------------------------------------------------
    Decode the Stage I vector
    --------------------------------------------------*/
  Dim2VectorLUT(piIndices[0], pfStage1CB, iStage1Size, pfData);

  /*--------------------------------------------------
    Find the stage II codebook
    --------------------------------------------------*/
  if (SelectOutCellCB(piIndexOfStage2OutCell, iNumOfOutCell,
                      piIndices[0]) == 1)
    pfStage2CB = pfStage2OutCellCB;
  else
    pfStage2CB = pfStage2InCellCB;

  /*--------------------------------------------------
    Decode the stage II vector
    --------------------------------------------------*/
  Dim2VectorLUT(piIndices[1], pfStage2CB, iStage2Size, pfStage2In);

  /*--------------------------------------------------
    undo rotation and scaling 
    --------------------------------------------------*/
  DeRotScaleVQ2(pfStage2In, pfRotScaleCB, piIndices[0], pfRes);

  /*--------------------------------------------------
    Add two stage vectors together
    --------------------------------------------------*/
  pfData[0] += pfRes[0];
  pfData[1] += pfRes[1];

STACK_END
}

#ifndef DECODE_ONLY
/******************************************************************************
*
* Function: VQ2mbest
*
* Action: Find the M-Best indices 
*
* Input:  pfData -- input vector
*         pfCB -- codebook
*         iCBSize -- codebook size
*         piMBestCand -- pointer to the indices for the M-Best candidates
*         iMBest -- number of best candidates
*
* Output:   piMBestCand -- indices for the M-Best candidates
*
* Globals:   none
*
* Return:    none
*******************************************************************************/

static void VQ2mbest( STACK_R 
                      const float *pfData, 
                      const float *pfCB, 
                      int    iCBSize, 
                      int    *piMBestCand, 
                      int    iMBest
                    )
{
  int i, j;
  float fDis;

STACK_INIT
  float pfMinDis[MAX_NUMCAND];
STACK_INIT_END

  STACK_ATTACH (float *, pfMinDis)

STACK_START

  assert(iMBest <= MAX_NUMCAND);
  assert((pfData != NULL) && (pfCB != NULL));
  assert(piMBestCand != NULL);

  /*--------------------------------------------------
    Initialize piMBestCand and pfMinDis 
    --------------------------------------------------*/
  for(i = 0; i < iMBest; i++) 
    {
      piMBestCand[i] = 0;
      pfMinDis[i] = FLT_MAX;
    }

  /*--------------------------------------------------
    Search each entry of the codebook, and find the
    M-Best candidates 
    --------------------------------------------------*/
  for (i = 0; i < iCBSize; i++)
    {
      /*--------------------------------------------------
        Compute the distance between the input vector and
        each code-vector.
        --------------------------------------------------*/
      fDis = CompDistVQ2(pfData, pfCB);
      pfCB += 2;
      
      /*--------------------------------------------------
        If the error for this entry is less than the worst
        retained candidate so far, keep it. 
        Note that the error list is maintained in order 
        of best (min error) to worst.
        --------------------------------------------------*/
      if (fDis < pfMinDis[iMBest-1])
        { 
          for(j=iMBest-1; ((j>0)&&(fDis<=pfMinDis[j-1])); j--)
            {
              pfMinDis[j] = pfMinDis[j-1];
              piMBestCand[j] =piMBestCand[j-1];
            }
             
          pfMinDis[j] = fDis;
          piMBestCand[j] = i;
        }
    } 

STACK_END
}


/******************************************************************************
*
* Function: RotScaleVQ2
*
* Action: Rotate and scale an input vector
*
* Input:  pfIn -- input vector
*         pfRSMatrix -- rotation and scaling matrix
*         iIndex -- index for the rotation-scaling vector entry
*         pfOut -- the pointer to the output vector
*
* Output: pfOut -- rotated and scaled vector
*
* Globals:   none
*
* Return:    none
*******************************************************************************/

static void RotScaleVQ2( const float *pfIn, 
                         const float *pfRSMatrix,
                         int    iIndex, 
                         float  *pfOut
                       )
{
  const float *pfRSVec = &(pfRSMatrix[iIndex<<1]);

  assert((pfIn != NULL) && (pfRSMatrix != NULL) && (pfOut != NULL));

  pfOut[0]=  pfRSVec[0] * pfIn[0] + pfRSVec[1] * pfIn[1];
  pfOut[1]= -pfRSVec[1] * pfIn[0] + pfRSVec[0] * pfIn[1];
}    
#endif

/******************************************************************************
*
* Function: DeRotScaleVQ2()
*
* Action: undo rotation and scaling
*
* Input:  pfIn -- input vector
*         pfRSMatrix -- rotation and scaling matrix
*         iIndex -- index for the rotation-scaling vector entry
*         pfOut -- the pointer to the output vector
*
* Output: pfOut -- output vector
*
* Globals:   none
*
* Return:    none
*******************************************************************************/

static void DeRotScaleVQ2( const float *pfIn, 
                           const float *pfRSMatrix,
                           int    iIndex, 
                           float  *pfOut
                         )
{
  float fScale;
  const float *pfRSVec = &(pfRSMatrix[iIndex<<1]);

  assert((pfIn != NULL) && (pfRSMatrix != NULL) && (pfOut != NULL));

  fScale = pfRSVec[0]*pfRSVec[0] + pfRSVec[1]*pfRSVec[1];
  fScale = 1.0F / fScale;
    
  pfOut[0] = fScale * (pfIn[0]*pfRSVec[0] - pfIn[1]*pfRSVec[1]);
  pfOut[1] = fScale * (pfIn[1]*pfRSVec[0] + pfIn[0]*pfRSVec[1]);
}


/******************************************************************************
*
* Function: SelectOutCellCB
*
* Action: find out whether the code-vector is an outer cell
*
* Input:  piIndexOfOutCell -- indices for the outer cell
*         iNumOfOutCell -- number of outer cells
*         iIndex -- the input index for an unknown cell (or code-vector)
*
* Output: none
*
* Globals:   none
*
* Return:    1: outer cell
*            0: inner cell
*       
*******************************************************************************/

static int SelectOutCellCB( const int *piIndexOfOutCell,
                            int  iNumOfOutCell, 
                            int  iIndex
                          )
{
  int flag = 0;
  int i;

  assert(piIndexOfOutCell != NULL);

  for(i=0; i<iNumOfOutCell; i++)
    {
      if (piIndexOfOutCell[i] == iIndex)
        {
          flag = 1;
          break;
        }
    }

  return flag;
}

#ifndef DECODE_ONLY
/******************************************************************************
*
* Function: CompDistVQ2
*
* Action: compute the distortion between 2-dimensional vectors
*
* Input:  pfIn -- input vector
*         pfRef -- reference vector
*
* Output: none
*
* Globals:   none
*
* Return:    distortion between pfIn and pfRef
*       
*******************************************************************************/
     
static float CompDistVQ2(const float *pfIn, const float *pfRef)
{
  float fErr;
  float fDis;

  assert((pfIn != NULL) && (pfRef != NULL));

  fErr = pfIn[0] - pfRef[0];
  fDis = fErr*fErr;

  fErr = pfIn[1] - pfRef[1];
  fDis += fErr*fErr;

  return fDis;
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\selepeak.h ===
/*******************************************************************************
*                        Voxware Proprietary Material                          *
*                        Copyright 1997, Voxware, Inc                          *
*                            All Rights Reserved                               *
*                                                                              *
*                       DISTRIBUTION PROHIBITED without                        *
*                      written authorization from Voxware                      *
******************************************************************************/

/*******************************************************************************
* Filename:       SelePeak.h
*                                                                              
* Purpose:        Choose "good" peaks for frequency-domain pitch estimator.
*                                                                              
* Functions:      SelectPeaks()
*
* Author/Date:    
*
********************************************************************************
* Modifications:
*                                                                              
* Comments:                                                                    
* 
* Concerns:
*
* $Header:   /export/phobos/pvcs/r_and_d/archives/scaleable/pea/SelePeak.h_v   1.1   02 Apr 1998 14:47:02   weiwang  $
******************************************************************************/

#ifndef _SELE_PEAK_H_
#define _SELE_PEAK_H_

/******************************************************************************
* Function:  SelectPeaks()
*
* Action:    Select peaks from the power spectrum and eliminate small peaks
*            due to background-noise.
*
* Input:     pfPower    -- input power spectrum. 
*            iBaseBand  -- the length of input power spectrum .
*            piPeakFreq -- the address of the output peak indecies.
*
* Output:    piPeakFreq -- the output peak indecies.
*
* Globals:   none
*
* Return:    none
*******************************************************************************
*
* Implementation/Detailed Description:
*
*******************************************************************************
*
* Modifications:
*
* Comments:  
*
* Concerns/TBD:
*
******************************************************************************/

void SelectPeaks( STACK_R 
                  const float *pfPower, 
                  int          iBaseBand, 
                  int         *piPeakFreq, 
                  float        fMaxPower
                );

#endif /* _SELE_PEAK_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\setamps.c ===
/******************************************************************************
*                        Voxware Proprietary Material                         *
*                        Copyright 1996, Voxware, Inc                         *
*                            All Rights Reserved                              *
*                                                                             *
*                       DISTRIBUTION PROHIBITED without                       *
*                      written authorization from Voxware                     *
******************************************************************************/
 
/******************************************************************************
* Filename:       SetAmps.c
*
* Purpose:        Interpolate the amplitude and phase envelopes at the
*                 sine-wave harmonics. Apply KL amplitude scale factor to 
*                 the unvoiced harmonics.  Also, increase the number of 
*                 unvoiced harmonics by adding sub-harmonics.
*
* Functions:      SetAmpAndPhase()
*                 AddSubHarmonics()
*
* Author/Date:    Original developed by Bob McAulay and Bob Dunn 1/97
*******************************************************************************
* Modifications: Set pfEnv[] and pfPhase[] at PI as holding previous values
*                rather than 0. And reduce complexity. Wei Wang, 4/98
*
* Comments:
*
* Concerns: Requires the length of the envelopes to be 65!  The 65th sample
*             is accessed, but multiplied by zero insetad of putting an
*             if statement inside the loop.
*
* $Header:   /export/phobos/pvcs/r_and_d/archives/scaleable/decode/SetAmps.c_v   1.7   10 Apr 1998 11:50:56   weiwang  $
******************************************************************************/
#include <stdlib.h>
#include <assert.h>
#include <math.h>

#include "vLibMath.h"

#include "codec.h"
#include "warp.h"
#include "SetAmps.h"

#include "xvocver.h"

/*-----------------------------------------------------------
  To convert frequency to down-sampled scale
-----------------------------------------------------------*/
#define  WARP_FREQ_SCALE    (1.0F/(float)(1<<CSENVDWNSMP))

/*******************************************************************************
*
* Function:  SetAmpAndPhase()
*
* Action:    Set the log amplitude and minimum-phase phase of the 
*              harmonics.
*
* Input:     float  fNoiseScale   -> scale factor for unvoiced harmonics
*                                      (log base 2 value to be added)
*            float  fPitchDFT     -> pitch in DFT samples
*            int    iHarmonics    -> number of harmonics to generate
*            int    iVoicHarm     -> number of harmonics which are voiced
*            float *pfEnv         -> current envelope (warped, log 2 magnitude)
*            float *pfEnv_1       -> previous envelope (warped, log 2 magnitude)
*            float *pfPhase       -> current unwrapped minimum-phase envelope
*            float *pfPhase_1     -> previous unwrapped minimum-phase envelope
*            float  fInterpFactor -> envelope interpolation factor
*
* Output:    float *pfLogAmps     -> harmonic amplitudes (log base 2)
*            float *pfMinFaz      -> minimum-phase harmonic phases
*
* Globals:   none
*
* Return:    void
********************************************************************************
*
* Modifications:  pfEnv[], pfPhase[] at PI must be set to hold the previous
*                 values. Then if fWarpedFreq is between [CSENV_NFFT_2-1,
*                 CSENV_NFFT_2), the interpolated envelope and phase should 
*                 take the value at CSENV_NFFT_2-1. This should be better than
*                 setting pfEnv[] and pfPhase[] at PI to be 0 since no extra
*                 if-statement is required. W.W, 4/98 
*
* Comments:  IMPORTANT NOTE: The code is currently written such that
*                              pfEnv[], pfEnv_1[], pfPhase[], pfPhase_1[]
*                              must have a valid numeric value at PI.
*                              This value is multiplied by zero, but it
*                              must exist.  This problem could be avoided
*                              by placing an if statement inside the loop,
*                              but this would increase code size and 
*                              operate more slowly.
*
* Concerns/TBD:
*******************************************************************************/

void SetAmpAndPhase ( float  fNoiseScale,
                      float  fPitchDFT,
                      float *pfLogAmps,
                      float *pfMinFaz,
                      int    iHarmonics,
                      int    iVoicHarm,
                      float *pfEnv,
                      float *pfEnv_1,
                      float *pfPhase,
                      float *pfPhase_1,
                      float  fInterpFactor
                     )
{
   int   n;
   int   iIndex;
   float fWarpedFreq;
   float fFreqInterp;
   float fFreq;
   float fEnv, fEnv_1;
   float fPhase, fPhase_1;

   assert((pfLogAmps != NULL) && (pfMinFaz != NULL));
   assert((pfEnv != NULL) && (pfEnv_1 != NULL));
   assert((pfPhase != NULL) && (pfPhase_1 != NULL));

   fFreq = fPitchDFT;

   /*-------------------------------------------------------------------
     The points at PI must be set to avoid
     if statements within a for loop in SetAmpAndPhase().
   -------------------------------------------------------------------*/
   pfEnv[CSENV_NFFT_2]   = pfEnv[CSENV_NFFT_2-1];
   pfPhase[CSENV_NFFT_2]   = pfPhase[CSENV_NFFT_2-1];

   for (n = 0; n < iHarmonics; n++) {

      /*------------------------------------------------------------------
        Compute warped frequency on 64 point scale
      ------------------------------------------------------------------*/
      fWarpedFreq = CalcWarpedFreq(fFreq)*WARP_FREQ_SCALE;

      fFreq += fPitchDFT;

      /*------------------------------------------------------------------
        Confine frequency to range of 0.0 <= fWarpedFreq <= fLastEnvelopePoint
          WARNING: This will actually read from the envelopes
                   0<=i<=(fLastEnvelopePoint+1) so be sure the envelopes 
                   are (fLastEnvelopePoint+2) points 
                   long! (One alternative is to put an if statment 
                   in the loop, but this would be slow)
      ------------------------------------------------------------------*/
      assert(fWarpedFreq >= 0.0F);
      iIndex = VoxFLOORpos( fWarpedFreq );

      assert(iIndex < CSENV_NFFT_2);
      fFreqInterp = fWarpedFreq - (float) iIndex;

      /*------------------------------------------------------------------
        Interpolate Log amplitude envelopes, first in frequency, 
          then in time.
      ------------------------------------------------------------------*/
      fEnv_1 = VoxINTERP( pfEnv_1[iIndex], pfEnv_1[iIndex+1], fFreqInterp );
      fEnv = VoxINTERP( pfEnv[iIndex], pfEnv[iIndex+1], fFreqInterp);
      pfLogAmps[n] = VoxINTERP( fEnv_1, fEnv, fInterpFactor);

      /*------------------------------------------------------------------
        Interpolate unwrapped phase envelopes, first in frequency, 
          then in time.
      ------------------------------------------------------------------*/
      fPhase_1 = VoxINTERP(pfPhase_1[iIndex], pfPhase_1[iIndex+1], fFreqInterp);
      fPhase = VoxINTERP(pfPhase[iIndex], pfPhase[iIndex+1], fFreqInterp);
      pfMinFaz[n] = VoxINTERP( fPhase_1, fPhase, fInterpFactor );
   }

   /*------------------------------------------------------------------
     Rescale the unvoiced harmonics to account for the analysis window 
       energy and the synthesis pitch.
   ------------------------------------------------------------------*/
   for (n=iVoicHarm; n<iHarmonics; n++)
      pfLogAmps[n] += fNoiseScale;

}

/*******************************************************************************
*
* Function:  AddSubHarmonics()
*
* Action:    This routine adds sub-harmonics in the unvoiced region.
*              Since we will use a harmonic synthesizer, 
*              voiced sub-harmonics are also added but their
*              magnitudes are set to zero.
*
* Input:     float *pfLogAmps     -> harmonics amplitudes (log base 2)
*            float *pfMinFaz      -> harmonics phases
*            int    iHarmonics    -> total number of (input) harmonics
*            int    iSubHarmonics -> total number of (output) harmonics
*                                      plus sub-harmonics
*            int    iRatio        -> the ratio: iSubHarmonics/iHarmonics
*            int    iVoicHarm     -> number of (input) voiced harmonics
*
*
* Output:    float *pfLogAmps     -> harmonics amplitudes (log base 2)
*            float *pfMinFaz      -> harmonics phases
*
* Globals:   none
*
* Return:    void
********************************************************************************
*
* Modifications:
*
* Comments:
*
* Concerns/TBD:
*******************************************************************************/

void AddSubHarmonics ( float *pfLogAmps,
                       float *pfMinFaz,
                       int    iHarmonics,
                       int    iSubHarmonics,
                       int    iRatio,
                       int    iVoicHarm
                     )
{
 
   int   i, j, k;

   assert(pfLogAmps!=NULL);
   assert(pfMinFaz != NULL);

   k = iSubHarmonics-1;
   /* unvoiced band */
   for (i = iHarmonics-1; i>=iVoicHarm; i--)
     {
       for (j = 0; j < iRatio; j++, k--)
         {
           pfLogAmps[k] = pfLogAmps[i];
           pfMinFaz[k] = pfMinFaz[i];
         }
     }
   
   /* voiced band */
   for (; i >= 0; i--)
     {
       pfLogAmps[k] = pfLogAmps[i];
       pfMinFaz[k] = pfMinFaz[i];
       k--;
       for (j = 1; j < iRatio; j++, k--) 
         {
           pfLogAmps[k] = 0.0F;
           pfMinFaz[k] = 0.0F;
         }
     }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\setamps.h ===
/******************************************************************************
*                        Voxware Proprietary Material                         *
*                        Copyright 1996, Voxware, Inc                         *
*                            All Rights Reserved                              *
*                                                                             *
*                       DISTRIBUTION PROHIBITED without                       *
*                      written authorization from Voxware                     *
******************************************************************************/
 
/******************************************************************************
* Filename:       SetAmps.h
*
* Purpose:        Interpolate the amplitude and phase envelopes at the
*                 sine-wave harmonics. Apply KL amplitude scale factor to 
*                 the unvoiced harmonics.  Also, increase the number of 
*                 unvoiced harmonics by adding sub-harmonics.
*
* Functions:      SetAmpAndPhase()
*                 AddSubHarmonics()
*
* Author/Date:    Original developed by Bob McAulay and Bob Dunn 1/97
*******************************************************************************
* Modifications:
*
* Comments:
*
* Concerns: Requires the length of the envelopes to be 65!  The 65th sample
*             is accessed, but multiplied by zero insetad of putting an
*             if statement inside the loop.
*
* $Header:   /export/phobos/pvcs/r_and_d/archives/scaleable/decode/SetAmps.h_v   1.0   06 Feb 1998 09:38:34   johnp  $
******************************************************************************/
#ifndef SETAMPS_H
#define SETAMPS_H

/*******************************************************************************
*
* Function:  SetAmpAndPhase()
*
* Action:    Set the log amplitude and minimum-phase phase of the 
*              harmonics.
*
* Input:     float  fNoiseScale   -> scale factor for unvoiced harmonics
*                                      (log base 2 value to be added)
*            float  fPitchDFT     -> pitch in DFT samples
*            int    iHarmonics    -> number of harmonics to generate
*            int    iVoicHarm     -> number of harmonics which are voiced
*            float *pfEnv         -> current envelope (warped, log 2 magnitude)
*            float *pfEnv_1       -> previous envelope (warped, log 2 magnitude)
*            float *pfPhase       -> current unwrapped minimum-phase envelope
*            float *pfPhase_1     -> previous unwrapped minimum-phase envelope
*            float  fInterpFactor -> envelope interpolation factor
*
* Output:    float *pfLogAmps     -> harmonic amplitudes (log base 2)
*            float *pfMinFaz      -> minimum-phase harmonic phases
*
* Globals:   none
*
* Return:    void
********************************************************************************
*
* Modifications:
*
* Comments:  IMPORTANT NOTE: The code is currently written such that
*                              pfEnv[], pfEnv_1[], pfPhase[], pfPhase_1[]
*                              must have a valid numeric value at PI.
*                              This value is multiplied by zero, but it
*                              must exist.  This problem could be avoided
*                              by placing an if statement inside the loop,
*                              but this would increase code size and 
*                              operate more slowly.
*
* Concerns/TBD:
*******************************************************************************/

void SetAmpAndPhase ( float  fNoiseScale,
                      float  fPitchDFT,
                      float *pfLogAmps,
                      float *pfMinFaz,
                      int    iHarmonics,
                      int    iVoicHarm,
                      float *pfEnv,
                      float *pfEnv_1,
                      float *pfPhase,
                      float *pfPhase_1,
                      float  fInterpFactor
                     );

/*******************************************************************************
*
* Function:  AddSubHarmonics()
*
* Action:    This routine adds sub-harmonics in the unvoiced region.
*              Since we will use a harmonic synthesizer, 
*              voiced sub-harmonics are also added but their
*              magnitudes are set to zero.
*
* Input:     float *pfLogAmps     -> harmonics amplitudes (log base 2)
*            float *pfMinFaz      -> harmonics phases
*            int    iHarmonics    -> total number of (input) harmonics
*            int    iSubHarmonics -> total number of (output) harmonics
*                                      plus sub-harmonics
*            int    iRatio        -> the ratio: iSubHarmonics/iHarmonics
*            int    iVoicHarm     -> number of (input) voiced harmonics
*
*
* Output:    float *pfLogAmps     -> harmonics amplitudes (log base 2)
*            float *pfMinFaz      -> harmonics phases
*
* Globals:   none
*
* Return:    void
********************************************************************************
*
* Modifications:
*
* Comments:
*
* Concerns/TBD:
*******************************************************************************/

void AddSubHarmonics ( float *pfLogAmps,
                       float *pfMinFaz,
                       int    iHarmonics,
                       int    iSubHarmonics,
                       int    iRatio,
                       int    iVoicHarm
                     );

#endif /* SETAMPS_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\seevoc.c ===
/*******************************************************************************
*                        Voxware Proprietary Material                          *
*                        Copyright 1996, Voxware, Inc                          *
*                            All Rights Reserved                               *
*                                                                              *
*                       DISTRIBUTION PROHIBITED without                        *
*                      written authorization from Voxware                      *
*******************************************************************************/
 
/******************************************************************************
*
* Filename:      Seevoc.c
*
* Purpose:
*
* Functions:
*
* Author/Date:   Bob McAulay
*
*******************************************************************************
*
* Modifications:
*                - Reorganized Bob Dunn (12/31/96)
*                - Modified VoxSeevocPeaksFast() so that there will always
*                    be peaks returned.  Bob Dunn (7/6/98)
*
* Comments:
*
* Concerns:
*
* $Header:   /export/phobos/pvcs/r_and_d/archives/scaleable/encode/Seevoc.c_v   1.6   20 Jan 1999 17:47:56   weiwang  $
******************************************************************************/
#include <stdlib.h>
#include <math.h>
#include <assert.h>
#include <limits.h>
#include <string.h>

#include "vLibMath.h"

#include "VoxMem.h"
#include "codec.h"

#include "Seevoc.h"

#include "xvocver.h"

static int VoxSeevocPeaksFast(float *pfMagSq, float *pfPwrIn, 
			      float *pfFrqIn, int iInCount, 
			      float fPitchDFT, float *pfPwrOut, 
			      float *pfFrqOut);



/******************************************************************************
*
* Function:    VoxSeevocFlattop()
*
* Action:      Compute the flat-top SeeVoc envelope from the measured
*                and then compute the spline envelope.
*
* Input: 
*
* Output:
*
* Globals:     none
*
* Return:      none
*******************************************************************************
*
* Implementation/Detailed Description:
*
* References:
*******************************************************************************
*
* Modifications:
*
* Comments:
*
*   The inputs peaks are measured as squared magnitude.
*     The peaks are then converted to log-base-2, hence
*     the seevoc envelope is also log-base-2.  For missing peaks
*     we fill in with samples of the STFT magnitude-squared.
*
* Concerns/TBD:
******************************************************************************/

void VoxSeevocFlattop( STACK_R  
		       float *pfMagSq, 
		       float *pfPwrIn, 
		       float *pfFrqIn, 
		       int iInCount, 
		       float *pfLogSeeEnv,
		       float fPitchDFT
		     )
{
  int   i, j, jlo, jhi;
  int   iSeePeakCount;
  float ampjm1, frqjm1, frqj;
  float ftmp;

  STACK_INIT
    float pfSeePwr[MAXHARM];
    float pfSeeFrq[NFFT_2];
    STACK_INIT_END
    STACK_ATTACH(float *, pfSeePwr)
    STACK_ATTACH(float *, pfSeeFrq)

   STACK_START

   memset(pfSeePwr, 0, MAXHARM*sizeof(float));
   memset(pfSeeFrq, 0, MAXHARM*sizeof(float));

   /*----------------------------------------------
     If the pitch is too high we will not get 
       enough Seevoc peaks.  The pitch estimator
       currently (7/6/98) limits the pitch to 1000 
       Hz so this should not be a problem.
   ----------------------------------------------*/
   assert( fPitchDFT < (1500.0F*HZ2DFT) );

   /*----------------------------------------------
     Select the largest peak in each pitch adaptive frequency band.
   ----------------------------------------------*/
   iSeePeakCount = VoxSeevocPeaksFast(pfMagSq, pfPwrIn, pfFrqIn, 
				      iInCount, fPitchDFT,
				      pfSeePwr, pfSeeFrq);

   /*----------------------------------------------
     There will always be Seevoc peaks!  
   ----------------------------------------------*/
   assert( iSeePeakCount > 0 );


   /*----------------------------------------------
     Compute the flat-top envelope
   ----------------------------------------------*/
   i = 0;
   jhi = 0;
   ampjm1 = fLog2(pfSeePwr[0]) + DC_SLOPE;
   ampjm1 = fInvLog2(ampjm1);
   frqjm1 = 0.0F;
   for (j = 0; j < iSeePeakCount; j++)
   {
      frqj = pfSeeFrq[j];
      jlo = jhi;
      ftmp=0.5F*(frqjm1 + frqj);
      VoxROUND2pos(ftmp, jhi);
      for (i = jlo; i < jhi; i++)
         pfLogSeeEnv[i] = ampjm1;

      ampjm1 = pfSeePwr[j];
      frqjm1 = frqj;
   }

   jhi += VoxFLOORpos(fPitchDFT);
   if (jhi > NFFT_2)
      jhi = NFFT_2;

   for (j = i; j < jhi; j++)
       pfLogSeeEnv[j] = ampjm1;   /** log_seeamp[iSeePeakCount-1] **/


   /*----------------------------------------------
     Extrapolate last peak to the folding frequency
   ----------------------------------------------*/
   for (j = jhi; j < NFFT_2; j++)
       pfLogSeeEnv[j] = ALPHA_SEEVOC*pfLogSeeEnv[j-1];
   
   
   STACK_END
}
 

/******************************************************************************
*
* Function:    VoxSeevocPeaksFast()
*
* Action:     
*
* Input: 
*
* Output:
*
* Globals:     none
*
* Return:      number of peaks
*******************************************************************************
*
* Implementation/Detailed Description:
*
* References:
*******************************************************************************
*
* Modifications:
*
* Comments:
*
* Concerns/TBD:
******************************************************************************/
static int VoxSeevocPeaksFast( float *pfMagSq,
                                float *pfPwrIn,
                                float *pfFrqIn,
                                int iInCount,
                                float fPitchDFT,
                                float *pfPwrOut,
                                float *pfFrqOut
                              )
{
   int   j;
   int   iOutCount;
   int   iPeakIndex;
   float fStepSize;
   float fFreqLow;
   float fFreqHigh;
   float fMaxPwr;
   float ftmp;


   /*-------------------------------------------
     Initialize some things
   -------------------------------------------*/
   iOutCount  = 0;
   iPeakIndex = 0;
   fStepSize  = 0.5F*fPitchDFT;
   fFreqLow   = fStepSize;
   fFreqHigh  = fFreqLow+fPitchDFT;


   /*-------------------------------------------
     Skip peaks that are out of the harmonic band.
       Be careful here, the test of the right
       hand side of the expression must be done 
       first to avoid an index out of range!
   -------------------------------------------*/
   while ( (pfFrqIn[iPeakIndex]<fFreqLow) && (iPeakIndex<iInCount) )
      iPeakIndex ++;


   /*-------------------------------------------
     Now find the largest peak in each pitch
       adaptive band.
   -------------------------------------------*/
   while ( (fFreqLow<((float)NFFT_2-fStepSize)) && (iOutCount<MAXHARM) )
   {
      fMaxPwr = 0.0F;

     /*-------------------------------------------
       If (iPeakIndex<iInCount) then search for
         a peak in the pitch bin.  Otherwise
         don't search and just use the spectral
         magnitude at the middle of the bin.
     -------------------------------------------*/
      if (iPeakIndex<iInCount)
      {
         j = iPeakIndex;

         /*-------------------------------------------
             Be careful here, the test of the right
             hand side of the expression must be done
             first to avoid an index out of range!
         -------------------------------------------*/
         while ((pfFrqIn[j]<fFreqHigh) && (j<iInCount))
         {
            if (fMaxPwr < pfPwrIn[j])
            {
               fMaxPwr    = pfPwrIn[j];
               iPeakIndex = j;
            }
            j ++;
         }
      }


     /*-------------------------------------------
       If no peak was found use STFT magnitude at
       the mid-point of the pitch bin
     -------------------------------------------*/
      if (fMaxPwr > 0.0F)
      {
         pfPwrOut[iOutCount] = fMaxPwr;
         pfFrqOut[iOutCount] = pfFrqIn[iPeakIndex];
      }
      else
      {
         ftmp=0.5F*(fFreqLow+fFreqHigh);
         VoxROUND2pos(ftmp, j);
         pfPwrOut[iOutCount] = pfMagSq[j] + 1.E-6F;
         pfFrqOut[iOutCount] = (float) j;
      }


     /*-------------------------------------------
       Prepare limits for the next iteration.
     -------------------------------------------*/
      fFreqLow  = pfFrqOut[iOutCount] + fStepSize;
      fFreqHigh = fFreqLow+fPitchDFT;
      if (fFreqHigh > (float) NFFT_2)
         fFreqHigh = (float) NFFT_2;

      iOutCount ++;


     /*-------------------------------------------
       Skip peaks that are out of the harmonic band.
         Be careful here, the test of the right
         hand side of the expression must be done 
         first to avoid an index out of range!
     -------------------------------------------*/
      while ( (pfFrqIn[iPeakIndex]<fFreqLow) && (iPeakIndex<iInCount) )
         iPeakIndex ++;
   }

   return iOutCount;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\seevoc.h ===
/*******************************************************************************
*                        Voxware Proprietary Material                          *
*                        Copyright 1996, Voxware, Inc                          *
*                            All Rights Reserved                               *
*                                                                              *
*                       DISTRIBUTION PROHIBITED without                        *
*                      written authorization from Voxware                      *
*******************************************************************************/
 
/******************************************************************************
*
* Filename:      Seevoc.h
*
* Purpose:
*
* Functions:
*
* Author/Date:   Bob McAulay
*
*******************************************************************************
*
* Modifications:
*                - Reorganized Bob Dunn (12/31/96)
*                - Modified VoxSeevocPeaksFast() so that there will always
*                    be peaks returned.  Bob Dunn (7/6/98)
*
* Comments:
*
* Concerns:
*
* $Header:   /export/phobos/pvcs/r_and_d/archives/scaleable/encode/Seevoc.h_v   1.1   20 Jan 1999 15:30:16   weiwang  $
******************************************************************************/
#ifndef SEEVOC_H
#define SEEVOC_H

#define NO_PEAK  -1        /* impossible index to represent no peak selected */
#define ALPHA_SEEVOC  0.999F   /** extrapolation decay rate **/
#define DC_SLOPE     -0.050F   /** -log-base_2(.707)...DC level is -3dB down from 1st peak...was -0.500 **/
 
/******************************************************************************
*
* Function:    VoxSeevocFlattop()
*
* Action:      Compute the flat-top SeeVoc envelope from the measured
*                and then compute the spline envelope.
*
* Input: 
*
* Output:
*
* Globals:     none
*
* Return:      none
*******************************************************************************
*
* Implementation/Detailed Description:
*
* References:
*******************************************************************************
*
* Modifications:
*
* Comments:
*
*   The inputs peaks are measured as squared magnitude.
*     The peaks are then converted to log-base-2, hence
*     the seevoc envelope is also log-base-2.  For missing peaks
*     we fill in with samples of the STFT magnitude-squared.
*
* Concerns/TBD:
******************************************************************************/

void VoxSeevocFlattop( STACK_R  
		       float *pfMagSq, 
		       float *pfPwrIn, 
		       float *pfFrqIn, 
		       int iInCount, 
		       float *pfLogSeeEnv,
		       float fPitchDFT
		     );
#endif /* SEEVOC_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\setup.c ===
/*******************************************************************************
*                        Voxware Proprietary Material                          *
*                        Copyright 1996, Voxware, Inc                          *
*                            All Rights Reserved                               *
*                                                                              *
*                       DISTRIBUTION PROHIBITED without                        *
*                      written authorization from Voxware                      *
*******************************************************************************/

/*******************************************************************************
* Filename:       Setup.c
*                                                                              
* Purpose:        Prepare all frame parameters for the current frame or subframe
*                                                                              
* Functions:      VOXErr VoxSetup(void *pvDecMemBlk)
*                                                                              
* Author/Date:    Rob Zopf     03/01/96
********************************************************************************
* Modifications:Ilan Berci/ 10/96 Removed global dependencies
*                                 Modularized code segments (Encapsulation)
*                                 Removed scope changes
*                                 Changed error code procedure
*                                 Removed useless code segments
*                                 General optimization
*                                                                              
* Comments:                                                                    
* 
* Concerns:
*
* $Header:   /export/phobos/pvcs/r_and_d/archives/realtime/decode/Setup.c_v   1.2   02 Mar 1998 18:18:14   weiwang  $
*******************************************************************************/
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <math.h>
#include <assert.h>

#include "model.h"
#include "VoxMem.h"

#include "vLibSgPr.h"  /* SpecIntLn() */

#include "research.h"
#include "param.h"
#include "GetnHarm.h"
#include "Setup.h"

#include "xvocver.h"

static void
InterpolateLsfs(float *Lsf, float *prevLsf, float interpFactor, float *interpLsf);


/*******************************************************************************
* Function:       VOXErr VoxSetup(void *pvDecMemBlk)
*
* Action	: The basic idea involves the desire to output frame buffers of
*                180 samples, no matter what the warp factor is, and also to minimize
*                the amount of RAM necessary.
*
*                1) For warp=1, things are unchanged.
*                2) For warp<1, the frame is synthesized and may be buffered later until
*                   a full frame worth of data (180 samples) is obtained.
*                3) For warp>1, the frame is divided into equal length(L) subframes 
*                   such that L <=180 samples.
*                   
*                   - in each new subframe, all frame parameters (Amps, Lsf's, pitch, pv)
*                     are interpolated using the previous and current frames.
*                   - we have an unpack flag to set when we are on the last subframe 
*                     of the current frame.  This signals the need to unpack a new set of
*                     frame parameters before Decode is called again.
*                   - the new subframe lengths, overlaps, window lengths, etc. are calculated.
*                   - a minimum overlap length is used for small frames.
*
*                   - the interpolation factor (M/N) is calculated as follows
*
*				|                                      |
*				|              |           |           |
*				|              |           |           |
*			    prev. frame               subframe      cur. frame
*
*                              <--------   M  ------------>
*				<---------------------- N ------------->
*
* Input:          myPrevFrameParam_mblk 	- the previous frame parameters
*                 myParam_mblk		- the current frame parameters
*
* Output:         mySubFrameParam_mblk	- the new interpolated subframe parameters
*
* Globals:        none
*
* Return:		  VOXErr : Voxware return code
********************************************************************************
* Implementation/Detailed Description:
*
* References:
********************************************************************************
* Modifications:
*
* Comments:
*
* Concerns/TBD:
*******************************************************************************/
unsigned short VoxSetup(STACK_R void *pvParam_mblk, void *pvSubFrameParam_mblk, 
		void *pvPrevFrameParam_mblk, float Warp, unsigned char *unpackFLAG)
{
   PARAM         *Param_mblk=(PARAM *)pvParam_mblk;
   SubFrameParam *SubFrameParam_mblk=(SubFrameParam *)pvSubFrameParam_mblk;
   PrevFrameParam *PrevFrameParam_mblk=(PrevFrameParam *)pvPrevFrameParam_mblk;

   short          nHarm;

STACK_INIT
   float          Spec_sub_1[MAXHARM];
   float          Spec_sub[MAXHARM];
STACK_INIT_END

   int            i;
   float          interpFactor;

STACK_ATTACH (float *, Spec_sub_1)
STACK_ATTACH (float *, Spec_sub)

STACK_START

 /*---------------------------------------------
   Check if the codec is at a new frame ...
   ---------------------------------------------*/
   if (SubFrameParam_mblk->WarpFrame == 0)
   {
    /*----------------------------------------------
      Set the total number of Warp frames for this
      frame of encoded data ...
      ----------------------------------------------*/
      if (Warp < 1.0)
         SubFrameParam_mblk->totalWarpFrame = 1;
      else
         SubFrameParam_mblk->totalWarpFrame = (short) ceil(Warp);
      SubFrameParam_mblk->WarpFrame = SubFrameParam_mblk->totalWarpFrame;

    /*-----------------------------------------------
      - Set the synthesis frame length and number of
      subframes for this set of warp frames.
      - Make the number of subframes per time no more
      than during normal operation to prevent the
      complexity from increasing.
      - Make the frame length a multiple of the 
      eventual subframe length so that things work 
      out nicely in the decoder.
      -----------------------------------------------*/

      assert(Warp>0.0F);
      SubFrameParam_mblk->frameLEN = (short)(FRAME_LEN*Warp/SubFrameParam_mblk->totalWarpFrame);
      SubFrameParam_mblk->nSubs = (short) floor((SubFrameParam_mblk->frameLEN/ ((float)MAXSUBFRAMELEN)));
      SubFrameParam_mblk->frameLEN = (short) (SubFrameParam_mblk->nSubs*
                                     floor(SubFrameParam_mblk->frameLEN/((float)SubFrameParam_mblk->nSubs)));
   }

 /*------------------------------------------------
   Set the interpolation factor for this warp based
   on the Pv of the previous and current codec
   frames ...

   - if Pv is in transition from 0 to nonzero or
     visa-versa, don't interpolate the parameters.
   ------------------------------------------------*/
   if (((PrevFrameParam_mblk->Pv==0.0)&&(Param_mblk->Pv>0.0))||
       ((PrevFrameParam_mblk->Pv>0.0)&&(Param_mblk->Pv==0.0)))
   {
      if ((SubFrameParam_mblk->totalWarpFrame-SubFrameParam_mblk->WarpFrame)< (SubFrameParam_mblk->totalWarpFrame>>1))
      {
         interpFactor = 0.0F;
      }
      else
      {
         interpFactor = 1.0F;
      }
   }
   else
   {
      interpFactor = (SubFrameParam_mblk->totalWarpFrame-SubFrameParam_mblk->WarpFrame+1)
                     /((float)SubFrameParam_mblk->totalWarpFrame);
   } 


 /*-----------------------------------------------------
   Set the subframe memory structure to correct values.
   Interpolate from the original (param) values ...
   Do not interpolate Pv.
   -----------------------------------------------------*/
   SubFrameParam_mblk->Pitch = PrevFrameParam_mblk->Pitch + interpFactor*(Param_mblk->Pitch-PrevFrameParam_mblk->Pitch);

   nHarm = getnHarm(SubFrameParam_mblk->Pitch);
   if (nHarm > MAXHARM)
      nHarm = MAXHARM;

   SpecIntLn(PrevFrameParam_mblk->Pitch, SubFrameParam_mblk->Pitch, 
             (const int) nHarm, PrevFrameParam_mblk->Amp, Spec_sub_1, 
             (const unsigned int) MAXHARM);
   SpecIntLn(Param_mblk->Pitch, SubFrameParam_mblk->Pitch, (const int) nHarm, 
             Param_mblk->Amp, Spec_sub,  (const unsigned int) MAXHARM);

   for (i=0; i< nHarm; i++)
      SubFrameParam_mblk->Amp[i] = Spec_sub_1[i] + interpFactor*(Spec_sub[i]-Spec_sub_1[i]);
   for (i=nHarm; i< MAXHARM; i++)
      SubFrameParam_mblk->Amp[i] = 0.0F;

   InterpolateLsfs(Param_mblk->Lsf, PrevFrameParam_mblk->Lsf, interpFactor, SubFrameParam_mblk->Lsf);

   if (interpFactor < 0.5)
      SubFrameParam_mblk->Pv = PrevFrameParam_mblk->Pv;
   else
      SubFrameParam_mblk->Pv = Param_mblk->Pv;


 /*-------------------------------------------------------
   Decrement the warp frame, and check to see if unpacking
   is necessary next time around ...
   -------------------------------------------------------*/
   SubFrameParam_mblk->WarpFrame--;
   if (SubFrameParam_mblk->WarpFrame==0)
      *unpackFLAG = 1;
   else
      *unpackFLAG = 0;

 /*-------------------------------------------------------
   Update the previous frame parameters if we are finished
   with the current frame's data ...
   -------------------------------------------------------*/
   if (SubFrameParam_mblk->WarpFrame==0)
   {
      memcpy(PrevFrameParam_mblk->Amp, Param_mblk->Amp, sizeof(float)*MAXHARM);
      memcpy(PrevFrameParam_mblk->Lsf, Param_mblk->Lsf, sizeof(float)*LPC_ORDER);
      PrevFrameParam_mblk->Pv = Param_mblk->Pv;
      PrevFrameParam_mblk->Pitch = Param_mblk->Pitch;
      PrevFrameParam_mblk->Energy = Param_mblk->Energy;
   }

STACK_END

   return 0;
}

void VoxUpdateSubframe(void *pvSubFrameParam_mblk)
{

   SubFrameParam *SubFrameParam_mblk=(SubFrameParam *)pvSubFrameParam_mblk;

   memcpy(SubFrameParam_mblk->Amp_1, SubFrameParam_mblk->Amp, sizeof(float)*MAXHARM);
   memcpy(SubFrameParam_mblk->Lsf_1, SubFrameParam_mblk->Lsf, sizeof(float)*LPC_ORDER);
   SubFrameParam_mblk->Pv_1 = SubFrameParam_mblk->Pv;
   SubFrameParam_mblk->Pitch_1 = SubFrameParam_mblk->Pitch;
   SubFrameParam_mblk->Energy_1 = SubFrameParam_mblk->Energy;

}


/*******************************************************************************
* Function:       static void InterpolateLsfs(float *Lsf, float *prevLsf, float 
*                                             interpFactor, float *interpLsf)
*
* Action:
*
* Input:          Lsf		- pointer to the current lsf's
*		            prevLsf		- pointer to the previous lsf's
*		            interpFactor	- subframe interpolation factor (M/N)
*				|                                      |
*				|              |           |           |
*				|              |           |           |
*			    prev. frame               subframe      cur. frame
*
*                              <--------   M  ------------>
*				<---------------------- N ------------->
*
* Output:         interpLsf		- the subframe interpolated stable lsf's
*
* Globals:        none
*
* Return:		   VOXErr : Voxware return code
********************************************************************************
* Implementation/Detailed Description:
*
* References:
********************************************************************************
* Modifications:
*
* Comments:
*
* Concerns/TBD:
*******************************************************************************/
static void InterpolateLsfs(float *Lsf, float *prevLsf, float interpFactor, float *interpLsf)
{
   int i;
   
   for (i=0; i<LPC_ORDER; i++)
      interpLsf[i] = prevLsf[i] + (Lsf[i]-prevLsf[i])*interpFactor;
   for (i=1; i<LPC_ORDER; i++)
      if (interpLsf[i]<(interpLsf[i-1]+LSP_SEPERATION_HZ))
            interpLsf[i] = (float)(interpLsf[i-1]+LSP_SEPERATION_HZ);
   if (interpLsf[LPC_ORDER-1] > 3999.0F)
      interpLsf[LPC_ORDER-1] = 3999.0F;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\selepeak.c ===
/*******************************************************************************
*                        Voxware Proprietary Material                          *
*                        Copyright 1996, Voxware, Inc                          *
*                            All Rights Reserved                               *
*                                                                              *
*                       DISTRIBUTION PROHIBITED without                        *
*                      written authorization from Voxware                      *
******************************************************************************/

/*******************************************************************************
* Filename:       SelePeak.c
*                                                                              
* Purpose:        Choose "good" peaks for frequency-domain pitch estimator.
*                                                                              
* Functions:      SelectPeaks()
*
* Author/Date:    
*
********************************************************************************
* Modifications:
*                                                                              
* Comments:                                                                    
* 
* Concerns:
*
* $Header:   /export/phobos/pvcs/r_and_d/archives/scaleable/pea/SelePeak.c_v   1.3   02 Apr 1998 14:47:00   weiwang  $
******************************************************************************/
/**** system include files ****/
#include <stdlib.h>
#include <math.h>
#include <assert.h>
#include <string.h>
#include <limits.h>

/**** Vox Lib include files ****/
#include "vLibTran.h"
#include "vLibSpch.h"
#include "vLibVec.h"
#include "vLibMath.h"

/**** Codec related include files ****/
#include "VoxMem.h"
#include "LDPDAdef.h"
#include "SelePeak.h"

#include "xvocver.h"


/**** local definitions ****/
#define MAX_LPC_MASKING_ORDER   7 
#define MASKING_ATTENUATION     0.2F 
#define LPC_MASKING_ORDER       5 
#define EXPANSION_FACTOR        0.98F

#define MAX_PEAK_THRESHOLD    6.5536e-4F  

#define DFFT_ORDER  6
#define DFFT        (1<<DFFT_ORDER)
#define DFFT_2      (DFFT>>1)
#define INV_DFFT_2  (1.0F/(float)(DFFT_2))

#define  N_SHIFT  15
#define  CONSTSCALE     (float)(1<<N_SHIFT)
#define  ROUND_OFFSET   (int)(1<<(N_SHIFT-1))

/* fix-point implementation of round(fScale*i) */
/* !!!iscale has to be pre-calculated. */
#define ConvertIndex(iScale, i)   ((iScale*i+ROUND_OFFSET)>>N_SHIFT) 


/**** private functions ****/
static 
void CalcRSbyPower( STACK_R const float *pfPower, int iBaseBand, 
                    float *pfRs, int iLPCorder );

static 
void CalcMaskEnvelope( STACK_R const float *pfAlpc, int iLPCorder, 
                       float *pfMaskEnv, int iNBand );



/******************************************************************************
* Function:  SelectPeaks()
*
* Action:    Select peaks from the power spectrum and eliminate small peaks
*            due to background-noise.
*
* Input:     pfPower    -- input power spectrum. 
*            iBaseBand  -- the length of input power spectrum .
*            piPeakFreq -- the address of the output peak indecies.
*
* Output:    piPeakFreq -- the output peak indecies.
*
* Globals:   none
*
* Return:    none
*******************************************************************************
*
* Implementation/Detailed Description:
*
*******************************************************************************
*
* Modifications:
*
* Comments:  
*
* Concerns/TBD:
*
******************************************************************************/

void SelectPeaks( STACK_R 
                  const float *pfPower, 
                  int         iBaseBand, 
                  int         *piPeakFreq, 
                  float       fMaxPower
                )
{

  /***** local varibles ******/
  int   i,k;
  int   iIndex;
  int   iNPeaks;
  float fGain;
  float fPowerThrd;
  int   iLPCorder;

  /***** STACK memory ******/
STACK_INIT
  float pfAlpc[MAX_LPC_MASKING_ORDER];
STACK_INIT_END 

  STACK_ATTACH(float *, pfAlpc)
STACK_START

  assert(pfPower != NULL);
  assert(piPeakFreq != NULL);

  /*----------------------------------------------------------------------
    (1) Pick the peaks regularly from the power spectrum.
    ----------------------------------------------------------------------*/
  PeakPick( pfPower, 0, EXTEND_CUT_LC+1, MAX_NPEAKS,
            piPeakFreq, &iNPeaks);

  /*----------------------------------------------------------------------
    (2) Compute LPC coefficients.
    ----------------------------------------------------------------------*/

  /***  Find the lpc order. ***/
  iLPCorder = (int)ceil((float)LPC_MASKING_ORDER*(float)iBaseBand/
                       (float)EXTEND_CUT_LC);
  if (iLPCorder > MAX_LPC_MASKING_ORDER)
    iLPCorder = MAX_LPC_MASKING_ORDER;

  /*** Compute RS and LPC ***/
  {
STACK_INIT 
  float pfRs[MAX_LPC_MASKING_ORDER+1];
  float pfPARCOR[MAX_LPC_MASKING_ORDER];
STACK_INIT_END

   STACK_ATTACH(float *, pfRs)
   STACK_ATTACH(float *, pfPARCOR)

STACK_START
  /*
   * Compute autocorrelation coefficients from power spectrum.
   * And the autocorrelation coefficients are the inverse FFT of power spectrum.
   */
  CalcRSbyPower(STACK_S pfPower, iBaseBand, pfRs, iLPCorder);


  /***  Calculate the LPC coefficients. ***/
  pfRs[0] *= 1.000001F;
  VoxDurbin(pfRs, iLPCorder, pfAlpc, pfPARCOR, &fGain);
  BandExpand(pfAlpc, pfAlpc, iLPCorder, EXPANSION_FACTOR);
STACK_END
  }

  /*----------------------------------------------------------------------
   (3) Get masking envelope and apply it to eliminate small peaks.
   ----------------------------------------------------------------------*/
  {
STACK_INIT
  float pfMaskEnv[EXTEND_CUT_LC+1];
STACK_INIT_END

  STACK_ATTACH(float *, pfMaskEnv)

STACK_START
  /*** Compute the Masking Envelope from the inverse all-pole filter. ***/
  CalcMaskEnvelope(STACK_S pfAlpc, iLPCorder, pfMaskEnv, iBaseBand);

  /*** Scale the residue energy.***/
  fGain *= MASKING_ATTENUATION;

  /*** Reject the peaks below the LPC masking envelope and the global
    threshold. ***/
  fPowerThrd = fMaxPower * MAX_PEAK_THRESHOLD;
  k = 0;
  for (i = 0; i < iNPeaks; i++) 
  {
    iIndex = piPeakFreq[i];

    if ((iIndex<iBaseBand) && ((pfPower[iIndex]*pfMaskEnv[iIndex]) >= fGain)
          && (pfPower[iIndex] > fPowerThrd))
      {
        piPeakFreq[k] = piPeakFreq[i];
        k++;
      }
  }

  piPeakFreq[k] = SHRT_MAX;   /* a big number for ending */
STACK_END
  }

STACK_END
}


/******************************************************************************
* Function:  CalcRSbyPower
*
* Action:    compute autocorrelation coefficients from power spectrum.
*
* Input:     pfPower    -- input power spectrum
*            iNBand     -- the length of input power spectrum
*            pfRs       -- address for the output autocorrelation coefficients
*            iLPCorder  -- LPC order
*
* Output:    pfRs       -- autocorrelation coefficients
*
* Globals:   none
*
* Return:    none
*******************************************************************************
*
* Implementation/Detailed Description:
*
*******************************************************************************
*
* Modifications:
*
* Comments:  
*
* Concerns/TBD:
*
******************************************************************************/

static 
void CalcRSbyPower( STACK_R 
                    const float *pfPower, 
                    int         iNBand, 
                    float       *pfRs,
                    int         iLPCorder
                  )
{
  int   iScale, i, j;
  float fScale;
  float ftmp;

STACK_INIT
  float pfMaskPower[DFFT+2];
STACK_INIT_END

STACK_ATTACH(float *, pfMaskPower)

STACK_START

  assert(pfPower != NULL);
  assert(pfRs != NULL);

  /*----------------------------------------------------------------------
    (1) Rescale the power spectrum of "DFFT" size. 
    Use fix-point index.
    ----------------------------------------------------------------------*/
  fScale = (float)iNBand/(float)DFFT_2;
  ftmp = fScale*CONSTSCALE;
  VoxROUND2(ftmp, iScale);

  j = 0;
  pfMaskPower[j++] = 0.0F;
  pfMaskPower[j++] = 0.0F;

  for (i = 1; i < DFFT_2; i++)
  {
    pfMaskPower[j++] = pfPower[ConvertIndex(iScale, i)];
    pfMaskPower[j++] = 0.0F;
  }
  pfMaskPower[j++] = 0.0F;
  pfMaskPower[j++] = 0.0F;

  /*----------------------------------------------------------------------
    (2) Do inverse FFT 
    ----------------------------------------------------------------------*/
  VoxRealInverseFft(pfMaskPower, DFFT_ORDER, IFFT_SCALE_FLAG);

  /*----------------------------------------------------------------------
    (3) copy to RS array.
    ----------------------------------------------------------------------*/
  memcpy(pfRs, pfMaskPower, (iLPCorder+1)*sizeof(float));

STACK_END
}


/******************************************************************************
* Function:  CalcMaskEnvelope()
*
* Action:    calculate masking envelope.
*
* Input:     pfAlpc     -- LPC coefficients
*            iLPCorder  -- LPC order
*            pfMaskEnv  -- address for the output masking envelope
*            iNBand     -- length for masking envelope
*
* Output:    pfMaskEnv  -- masking envelope
*
* Globals:   none
*
* Return:    none
*******************************************************************************
*
* Implementation/Detailed Description:
*
*******************************************************************************
*
* Modifications:
*
* Comments:  
*
* Concerns/TBD:
*
******************************************************************************/

static 
void CalcMaskEnvelope( STACK_R 
                       const float *pfAlpc, 
                       int         iLPCorder, 
                       float       *pfMaskEnv, 
                       int         iNBand
                     )
{
  int i, j;
  int iScale;
  float ftmp;
  float fScale;

STACK_INIT  
  float pfMaskPower[DFFT+2];
STACK_INIT_END

STACK_ATTACH(float *, pfMaskPower)

STACK_START

  assert(pfAlpc != NULL);
  assert(pfMaskEnv != NULL);

  /*----------------------------------------------------------------------
    (1) Compute the inverse all-pole envelope.
    ----------------------------------------------------------------------*/
  memcpy(pfMaskPower, pfAlpc, (iLPCorder+1)*sizeof(float));

  i = iLPCorder+1;
  memset(&(pfMaskPower[i]), 0, (DFFT+2-i)*sizeof(float));

  VoxRealFft(pfMaskPower, DFFT_ORDER);
  
  /*----------------------------------------------------------------------
    (2) compute the power spectrum of the all-pole envelope.
    And rescale it to [0, iNBand].
    ----------------------------------------------------------------------*/
  fScale = (float)DFFT_2/(float)iNBand;
  ftmp = fScale * CONSTSCALE;
  VoxROUND2(ftmp,iScale);

  for (i = 0; i < (iNBand-1); i++) /*for interval from [0 iNBand-2]*/
  {
    j = 2*ConvertIndex(iScale, i);
    pfMaskEnv[i] = pfMaskPower[j]*pfMaskPower[j];
    j++;
    pfMaskEnv[i] += pfMaskPower[j]*pfMaskPower[j];
  }

  j = 2*ConvertIndex(iScale, i);
  if (j >= DFFT)
    pfMaskEnv[i] = pfMaskEnv[i-1];
  else
  {
    pfMaskEnv[i] = pfMaskPower[j]*pfMaskPower[j];
    j++;
    pfMaskEnv[i] += pfMaskPower[j]*pfMaskPower[j];
  }

STACK_END
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\setup.h ===
/*******************************************************************************
*                        Voxware Proprietary Material                          *
*                        Copyright 1996, Voxware, Inc                          *
*                            All Rights Reserved                               *
*                                                                              *
*                       DISTRIBUTION PROHIBITED without                        *
*                      written authorization from Voxware                      *
*******************************************************************************/

/*******************************************************************************
* Filename:       Setup.h                                                              
*                                                                              
* Purpose:        Prepare all frame parameters for the current frame or subframe                                                             
*                                                                              
* Author/Date:    Rob Zopf   03/01/96                                                           
********************************************************************************
* $Header:   /export/phobos/pvcs/r_and_d/archives/realtime/decode/Setup.h_v   1.0   26 Jan 1998 10:52:10   johnp  $                                                                     
*******************************************************************************/
#ifndef SETUP_H
#define SETUP_H

unsigned short VoxSetup(STACK_R void *pvParam_mblk, void *pvSubFrameParam_mblk, void *pvPrevFrameParam_mblk, 
                float Warp, unsigned char *unpackFLAG);

void VoxUpdateSubframe(void *pvSubFrameParam_mblk);

#endif /* SETUP_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\sintab.h ===
/*******************************************************************************
*                        Voxware Proprietary Material                          *
*                        Copyright 1996, Voxware Inc.                          *
*                        All Rights Reserved                                   *
*                                                                              *
*                        DISTRIBUTION PROHIBITED without                       *
*                        written authorization from Voxware.                   *
*******************************************************************************/

/*******************************************************************************
*
* Filename: SinTab.h
*
* Purpose:  table for RealFFT.c
*
* Author/Date:   Bob Dunn
*
* $Header:   /export/phobos/pvcs/pvcsproj/voxlib.prj/sintab.h_v   1.1   26 Feb 1998 17:00:40   weiwang  $
*******************************************************************************/
#ifndef SINTAB_H
#define SINTAB_H
0.0000000e+00F,
1.2271538e-02F,
2.4541229e-02F,
3.6807223e-02F,
4.9067674e-02F,
6.1320736e-02F,
7.3564564e-02F,
8.5797312e-02F,
9.8017140e-02F,
1.1022221e-01F,
1.2241068e-01F,
1.3458071e-01F,
1.4673047e-01F,
1.5885814e-01F,
1.7096189e-01F,
1.8303989e-01F,
1.9509032e-01F,
2.0711138e-01F,
2.1910124e-01F,
2.3105811e-01F,
2.4298018e-01F,
2.5486566e-01F,
2.6671276e-01F,
2.7851969e-01F,
2.9028468e-01F,
3.0200595e-01F,
3.1368174e-01F,
3.2531029e-01F,
3.3688985e-01F,
3.4841868e-01F,
3.5989504e-01F,
3.7131719e-01F,
3.8268343e-01F,
3.9399204e-01F,
4.0524131e-01F,
4.1642956e-01F,
4.2755509e-01F,
4.3861624e-01F,
4.4961133e-01F,
4.6053871e-01F,
4.7139674e-01F,
4.8218377e-01F,
4.9289819e-01F,
5.0353838e-01F,
5.1410274e-01F,
5.2458968e-01F,
5.3499762e-01F,
5.4532499e-01F,
5.5557023e-01F,
5.6573181e-01F,
5.7580819e-01F,
5.8579786e-01F,
5.9569930e-01F,
6.0551104e-01F,
6.1523159e-01F,
6.2485949e-01F,
6.3439328e-01F,
6.4383154e-01F,
6.5317284e-01F,
6.6241578e-01F,
6.7155895e-01F,
6.8060100e-01F,
6.8954054e-01F,
6.9837625e-01F,
7.0710678e-01F,
7.1573083e-01F,
7.2424708e-01F,
7.3265427e-01F,
7.4095113e-01F,
7.4913639e-01F,
7.5720885e-01F,
7.6516727e-01F,
7.7301045e-01F,
7.8073723e-01F,
7.8834643e-01F,
7.9583690e-01F,
8.0320753e-01F,
8.1045720e-01F,
8.1758481e-01F,
8.2458930e-01F,
8.3146961e-01F,
8.3822471e-01F,
8.4485357e-01F,
8.5135519e-01F,
8.5772861e-01F,
8.6397286e-01F,
8.7008699e-01F,
8.7607009e-01F,
8.8192126e-01F,
8.8763962e-01F,
8.9322430e-01F,
8.9867447e-01F,
9.0398929e-01F,
9.0916798e-01F,
9.1420976e-01F,
9.1911385e-01F,
9.2387953e-01F,
9.2850608e-01F,
9.3299280e-01F,
9.3733901e-01F,
9.4154407e-01F,
9.4560733e-01F,
9.4952818e-01F,
9.5330604e-01F,
9.5694034e-01F,
9.6043052e-01F,
9.6377607e-01F,
9.6697647e-01F,
9.7003125e-01F,
9.7293995e-01F,
9.7570213e-01F,
9.7831737e-01F,
9.8078528e-01F,
9.8310549e-01F,
9.8527764e-01F,
9.8730142e-01F,
9.8917651e-01F,
9.9090264e-01F,
9.9247953e-01F,
9.9390697e-01F,
9.9518473e-01F,
9.9631261e-01F,
9.9729046e-01F,
9.9811811e-01F,
9.9879546e-01F,
9.9932238e-01F,
9.9969882e-01F,
9.9992470e-01F,
1.0000000e+00F,
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\spcbm.c ===
/*******************************************************************************
*                        Voxware Proprietary Material                          *
*                        Copyright 1996, Voxware Inc.                          *
*                        All Rights Reserved                                   *
*                                                                              *
*                        DISTRIBUTION PROHIBITED without                       *
*                        written authorization from Voxware.                   *
*******************************************************************************/

/*******************************************************************************
*
* File:         SpCBM.c
*
* Purpose:      circular buffer manager routines
*
* Functions:
*
* Author/Date:  Wei Wang
*******************************************************************************
* Modifications:
*
* Comments:
*
* Concerns:
*
* $Header:   /export/phobos/pvcs/pvcsproj/voxlib.prj/SpCBM.c_v   1.10   06 Mar 1998 16:57:48   weiwang  $
******************************************************************************/
#include <stdlib.h>
#include <assert.h>
#include <math.h>
#include <string.h>

#include "vLibMacr.h"
#include "vLibSnd.h"

#include "xvocver.h"

/* Private function */
static int CalcCircBufPosition(int n, int j, int M);

/* typedef for circular buffer */
typedef struct tagSP_CIRC_BUF
{
   int    iLength;
   int    iIndex;
   float  *pfData;
} SP_CIRC_BUF;

/*******************************************************************************
* 
* Function: InitSpCBM()
*
* Action: initialize a structure containing circular buffer,its total 
*         length & index.
*
* Input:  pvCircMblk  - A structure containing circular buffer,its total 
*                       length & index.
*         iLength  - Length of the structur
*
* Output: pvCircMblk  - The initialised structure 
*
* return: 0: succeed, 1: failed
*
******************************************************************************
* Modifications:
*
* Comments:
*
* Concerns/TBD:
*
******************************************************************************/
unsigned short InitSpCBM(int iLength, void **pvCircMblk)
{
  SP_CIRC_BUF *pCirc_Mblk;
  unsigned short iRetFlag = 0;

  pCirc_Mblk = (SP_CIRC_BUF *)calloc(1,sizeof(SP_CIRC_BUF));
  *pvCircMblk = pCirc_Mblk;
  if(pCirc_Mblk == NULL)
     iRetFlag = 1;

  if (iRetFlag == 0)
    {
      pCirc_Mblk->iLength = iLength;
      pCirc_Mblk->iIndex  = 0;

      pCirc_Mblk->pfData = (float *)calloc(iLength,sizeof(float)); 
      if(pCirc_Mblk->pfData == NULL) 
        {
          SafeFree(pvCircMblk);
          iRetFlag = 1;
        }
    }

  return iRetFlag;
}

/*******************************************************************************
* 
* Function: FreeSpCBM()
*
* Action: free speech circular buffer structure
*
* Input:  pvCircMblk  --  circular buffer structure
*
* Output: pvCircMblk  -- NULL pointer
*
* return: none
*
******************************************************************************
* Modifications:
*
* Comments:
*
* Concerns/TBD:
*
******************************************************************************/

void FreeSpCBM(void **pvCircMblk)
{
  assert(pvCircMblk != NULL);

  if(*pvCircMblk)
    {
      SafeFree(((SP_CIRC_BUF *)*pvCircMblk)->pfData);
      SafeFree(*pvCircMblk);
   }
}


/*******************************************************************************
* 
* Function: PutFrameSpCBM()
*
* Action: put a frame of speech to a circular buffer 
*
* Input:  pvCircMblk  --  A structure containing circular buffer,its total 
*                         length & index.
*         iOffset     --  the relative distance from the start position for 
*                         putting speech to the circular buffer index.
*                         (in most case just set it to 0)
*         iInLength   -- Number of input data
*         pfInBuff    -- Input data
*
* Output: pvCircMblk  -- update structure pointer
*
* return: none
*
******************************************************************************
* Modifications:
*
* Comments:
*
* Concerns/TBD:
*
******************************************************************************/
void PutFrameSpCBM( void  *pvCircMblk,  int iOffset,
                    int   iInLength,    const float *pfInBuff )
{
   float        *pfSpCircBuf = ((SP_CIRC_BUF *)pvCircMblk)->pfData;
   int           iTotalLength = ((SP_CIRC_BUF *)pvCircMblk)->iLength;
   int           iIndex = ((SP_CIRC_BUF *)pvCircMblk)->iIndex;
   int           iStartPosition;
   int           iRemainLength;

   assert((pfInBuff != NULL) && (pvCircMblk != NULL));

   /*----------------------------------------------------
      Calculate the start position in circular
        buffer to copy data from inBuff
   ----------------------------------------------------*/
   iStartPosition = CalcCircBufPosition(iOffset, iIndex, iTotalLength);

   /*----------------------------------------------------
     remain length in circular buffer from the starting
       copying position to th end of the circular buffer
   ----------------------------------------------------*/
   iRemainLength = iTotalLength - iStartPosition;

   /*----------------------------------------------------
     Point to the start position in circular buffer
   ----------------------------------------------------*/
   if (iRemainLength >= iInLength)
   {
      /*----------------------------------------------------
        the remain length in circular is suffucient
          for copying data from InBuff
      ----------------------------------------------------*/
     memcpy(&(pfSpCircBuf[iStartPosition]), pfInBuff, iInLength*sizeof(float));
   }
  else {
      /*----------------------------------------------------
        the remain length in circular is shorter than
          the length to be copied from InBuff
      ----------------------------------------------------*/

      /*----------------------------------------------------
         fill up the remain length in circular buffer
      ----------------------------------------------------*/
     memcpy(&(pfSpCircBuf[iStartPosition]), pfInBuff,
            iRemainLength*sizeof(float));
    
      /*----------------------------------------------------
         fill up from the beginning of the circular buffer
      ----------------------------------------------------*/
     memcpy(pfSpCircBuf, &(pfInBuff[iRemainLength]), 
            (iInLength-iRemainLength)*sizeof(float));
   }

   /* update the Index -- independant with iOffset */
   iIndex = CalcCircBufPosition(iInLength, iIndex, iTotalLength);
   ((SP_CIRC_BUF *)pvCircMblk)->iIndex = iIndex;
}


/*******************************************************************************
* 
* Function: GetFrameSpCBM()
*
* Action: extract speech from a circular buffer 
*
* Input:  pvCircMblk  --  a structure containing circular buffer,its total 
*                         length & index.
*         iDelay      --  the relative distance from the middle position of the
*                         extracting speech to the current circular buffer 
*                         index.
*         iOutLength  --  number of output data
*         pfOutBuff   --  pointer to the output speech
*
* Output: pfOutBuff -- output speech
*
* return: none
*
******************************************************************************
* Modifications:
*
* Comments:
*
* Concerns/TBD:
*
******************************************************************************/

void GetFrameSpCBM( void *pvCircMblk, int iDelay, int  iOutLength,
                    float *pfOutBuff)
{
   float        *pfSpCircBuf = ((SP_CIRC_BUF *)pvCircMblk)->pfData;
   int          iTotalLength = ((SP_CIRC_BUF *)pvCircMblk)->iLength;
   int          iIndex = ((SP_CIRC_BUF *)pvCircMblk)->iIndex;
   int          iStartPosition;
   int          iRemainLength;

   assert(pvCircMblk != NULL && pfOutBuff != NULL);

   /*----------------------------------------------------
      get the starting pointer of the frame
      Calculate the starting position for extracting
      data, which should be half window 
      length + position of window center
   ----------------------------------------------------*/
   iDelay += ((iOutLength+1)>>1);

   /*----------------------------------------------------
     locate the starting position in curcular buffer
   ----------------------------------------------------*/
   iStartPosition = CalcCircBufPosition(-iDelay, iIndex, iTotalLength);
  
   /*----------------------------------------------------
     remain length in curcilar buffer
   ----------------------------------------------------*/
   iRemainLength = iTotalLength - iStartPosition;

   if (iRemainLength >= iOutLength)
   {
      /*----------------------------------------------------
        the remain length in circular is suffucient
          for copying data into OutBuff
      ----------------------------------------------------*/
      memcpy(pfOutBuff, &(pfSpCircBuf[iStartPosition]), 
             iOutLength*sizeof(float));

   } else {
      /*----------------------------------------------------
        the remain length in circular is shorter than
          the length to be copied into OutBuff

         fill up the remain length in circular buffer
      ----------------------------------------------------*/
      memcpy(pfOutBuff, &(pfSpCircBuf[iStartPosition]), 
             iRemainLength*sizeof(float));

      /*----------------------------------------------------
         fill up from the beginning of the circular buffer
      ----------------------------------------------------*/
      memcpy(&(pfOutBuff[iRemainLength]), pfSpCircBuf, 
             (iOutLength-iRemainLength)*sizeof(float));
   }

}



/*******************************************************************************
* 
* Function: CalcCircBufPosition()
*
* Action:   Calculate the position in circular buffer 
*
* Input:    iPosition -- start position relative to the circular buffer index
*           iIndex    -- circular buffer index
*           iLength   -- total length of circular buffer
*
* Output: none
*
* return: the position at the circular buffer
*
******************************************************************************
* Modifications:
*
* Comments:
*
* Concerns/TBD:
*
******************************************************************************/

static int CalcCircBufPosition(int iPosition, int iIndex, int iLength)
{
   return ((iLength+(iIndex+iPosition%iLength))%iLength);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\sqlawpks.c ===
/*******************************************************************************
*                        Voxware Proprietary Material                          *
*                        Copyright 1996, Voxware, Inc                          *
*                            All Rights Reserved                               *
*                                                                              *
*                       DISTRIBUTION PROHIBITED without                        *
*                      written authorization from Voxware                      *
*******************************************************************************/

/*******************************************************************************
* Filename:       SqLawPks.c                        
*                                                                              
* Purpose:        This module computes the sine-wave amplitudes and frequencies
*                 for the sine-wave representation of the square-law output
*                                                                              
* Functions:      VoxSquareLawPeaks()
*
* Author/Date:    Bob McAulay   1/97
********************************************************************************
* Modifications:
*                                                                              
* Comments:                                                                    
* 
* Concerns:
*
* $Header:   /export/phobos/pvcs/r_and_d/archives/scaleable/pea/SqLawPks.c_v   1.1   11 Apr 1998 15:18:30   bobd  $
*******************************************************************************/

#include <stdlib.h>
#include <math.h>
#include <assert.h>

#include "vLibMath.h"
#include "codec.h"
#include "SqLawPks.h"

#include "xvocver.h"

/*------------------------------------------------------------
  Set the maximum number of difference frequencies
------------------------------------------------------------*/
#define MAX_SPAN  2
 
/*------------------------------------------------------------
    Eliminate square-law peaks below this threshold.
------------------------------------------------------------*/
#define MIN_NU_THRESHOLD    0.05F

/*------------------------------------------------------------
  Do not eliminate low level peaks unless there are at least
   MIN_NU_PEAKCOUNT new peaks.
------------------------------------------------------------*/
#define MIN_NU_PEAKCOUNT    10
 

/******************************************************************************
*
* Function:  VoxSquareLawPeaks()
*
* Action:    This module computes the sine-wave amplitudes and frequencies
*              for the sine-wave representation of the square-law output
*
* Input:     float *pfFltAmp       -> peak amplitudes
*            float *pfPkFrq        -> peak frequencies (in DFT pts)
*            int    iBasePeakCount -> number of peaks
*            float  fLoBandEdge    -> maximum difference frequency (in DFT pts)
*
* Output:    float *pfNuAmp        -> new peak amplitudes
*            float *pfNuFrq        -> new peak frequencies (in DFT pts)
*            int   *piNuPeaks      -> number of new peaks
*
* Globals:   none
*
* Return:    none
*******************************************************************************
*
* Implementation/Detailed Description:
*
* References:
*******************************************************************************
*
* Modifications:
*
* Comments:
*
* Concerns/TBD:
******************************************************************************/
void VoxSquareLawPeaks ( float *pfFltAmp,
                         float *pfPkFrq,
                         int    iBasePeakCount,
                         float  fLoBandEdge,
                         float *pfNuAmp,
                         float *pfNuFrq,
                         int   *piNuPeaks
                       )
{

   int   j, k;
   int   iPks;
   int   iNuPeakCount;


   /*-----------------------------------------------------------
     Compute the square-law peaks.
   -----------------------------------------------------------*/
   iNuPeakCount = 0;

   /*-----------------------------------------------------------
     Include the original peaks.
   -----------------------------------------------------------*/
   iPks = VoxMIN( iBasePeakCount, MAXHARM );
   for (k = 0; k < iPks; k++)
   {
      pfNuAmp[iNuPeakCount] = pfFltAmp[k];
      pfNuFrq[iNuPeakCount] = pfPkFrq[k];
      iNuPeakCount ++;
   }

   /*-----------------------------------------------------------
     Compute peaks from the first difference.
   -----------------------------------------------------------*/
   iPks = VoxMIN( iBasePeakCount-1, MAXHARM-iNuPeakCount );
   for (k = 0; k < iPks; k++)
   {
      pfNuAmp[iNuPeakCount] = pfFltAmp[k+1] * pfFltAmp[k];
      pfNuFrq[iNuPeakCount] = pfPkFrq[k+1]  - pfPkFrq[k];   
      iNuPeakCount ++;
   }

   /*-----------------------------------------------------------
     Compute peaks from the second difference.
   -----------------------------------------------------------*/
   iPks = VoxMIN( iBasePeakCount-2, MAXHARM-iNuPeakCount );
   for (k = 0; k < iPks; k++)
   {
      pfNuAmp[iNuPeakCount] = pfFltAmp[k+2] * pfFltAmp[k];
      pfNuFrq[iNuPeakCount] = pfPkFrq[k+2]  - pfPkFrq[k];   
      iNuPeakCount ++;
   }

   *piNuPeaks = iNuPeakCount;

   /*-----------------------------------------------------------
     Delete low-level peaks if there are enough of them.
   -----------------------------------------------------------*/
   if (iNuPeakCount >= MIN_NU_PEAKCOUNT)
   {
      j = 0;
      for (k = 0; k < iNuPeakCount; k++)
      {
         if (pfNuAmp[k] > MIN_NU_THRESHOLD)
         {
            pfNuAmp[j] = pfNuAmp[k];
            pfNuFrq[j] = pfNuFrq[k];
            j ++;
         }
      }
      *piNuPeaks = j;
   }

} /*VoxSquareLawPeaks()*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\sqlawpks.h ===
/*******************************************************************************
*                        Voxware Proprietary Material                          *
*                        Copyright 1996, Voxware, Inc                          *
*                            All Rights Reserved                               *
*                                                                              *
*                       DISTRIBUTION PROHIBITED without                        *
*                      written authorization from Voxware                      *
*******************************************************************************/
 
/*******************************************************************************
* $Header:   /export/phobos/pvcs/r_and_d/archives/scaleable/pea/SqLawPks.h_v   1.1   11 Apr 1998 15:18:36   bobd  $
*******************************************************************************/
#ifndef _SQUARELAWPEAKS_H
#define _SQUARELAWPEAKS_H

/******************************************************************************
*
* Function:  VoxSquareLawPeaks()
*
* Action:    This module computes the sine-wave amplitudes and frequencies
*              for the sine-wave representation of the square-law output
*
* Input:     float *pfFltAmp       -> peak amplitudes
*            float *pfPkFrq        -> peak frequencies (in DFT pts)
*            int    iBasePeakCount -> number of peaks
*            float  fLoBandEdge    -> maximum difference frequency (in DFT pts)
*
* Output:    float *pfNuAmp        -> new peak amplitudes
*            float *pfNuFrq        -> new peak frequencies (in DFT pts)
*            int   *piNuPeaks      -> number of new peaks
*
* Globals:   none
*
* Return:    none
*******************************************************************************
*
* Implementation/Detailed Description:
*
* References:
*******************************************************************************
*
* Modifications:
*
* Comments:
*
* Concerns/TBD:
******************************************************************************/
void VoxSquareLawPeaks ( float *pfFltAmp,
                         float *pfPkFrq,
                         int    iBasePeakCount,
                         float  fLoBandEdge,
                         float *pfNuAmp,
                         float *pfNuFrq,
                         int   *piNuPeaks
                       );

#define SQUARE_LAW_BIAS     0.99F    /* to weight the 1st order harmonics...was .99 */

#define MAX_SPAN  2  /** difference frequencies no more that 1 apart **/

#define MAX_NU_THRESHOLD    0.50F     /* eliminates low-level square-law peaks...was .500 */
#define MIN_NU_THRESHOLD    0.05F     /* eliminates low-level square-law peaks...was .05 */
#define MIN_NU_PEAKCOUNT    10        /*  delete peaks if there are enough */

#endif  /*_SQUARELAWPEAKS_H*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\stftfaze.h ===
#ifndef _STFTPHASE_H
#define _STFTPHASE_H

/*----------------------------------------------------------------------------
* $Header:   /export/phobos/pvcs/r_and_d/archives/scaleable/encode/STFTfaze.h_v   1.0   06 Feb 1998 10:06:50   johnp  $
----------------------------------------------------------------------------*/

unsigned short VoxSTFTPhase ( float *pfSWR,
                              float *pfSWI,
                              int   iVEVphases,
                              float *pfVEVphase,
                              float fPitchDFT,
                              short WinShift
                            );
unsigned short VoxCodePhase ( float fPhase,
                      int   iNlevels,
                      float *pfPhase_q
                    );

#endif /* _STFTPHASE_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\stftfaze.c ===
/*----------------------------------------------------------------------
* NAME:		STFTPhase.c
* PURPOSE:	Subroutine of "EncSTC.c" to compute the STFT 
*               phases at the harmonics.
* CREATED: 8-Apr-97 rjm                         VOXWARE INC
* LATEST REVISION: 26-mar-97 rjm
*-----------------------------------------------------------------------
* Copyright 1997 VOXWARE INC
* This software is not for release and should neither be copied
* nor distributed without explicit permission of$VOXWARE INC
------------------------------------------------------------------------
* $Header:   /export/phobos/pvcs/r_and_d/archives/scaleable/encode/STFTfaze.c_v   1.3   07 Jul 1998 17:50:26   bobd  $
----------------------------------------------------------------------*/
#include <math.h>
#include <assert.h>

#include "vLibMath.h"

#include "codec.h"
#include "STFTfaze.h"

#include "xvocver.h"


/**********************************************************************/

unsigned short VoxSTFTPhase ( float *pfSWR,
                              float *pfSWI,
                              int   iVEVphases,
                              float *pfVEVphase,
                              float fPitchDFT,
                              short iWinShift
                            )
{
   int   i, iNpeaks, iBasePeaks, iIndex;
   float fFreq, fSTFTphase;
   float ftmp;

   float fPhaseShift, fDeltaPhase;
   int   iMhat;

 /*** Push down quantized STFT phases from previous 10ms frame ***/

   for (i = 0; i < iVEVphases; i++)
   {
      pfVEVphase[i]   = 0.0F;
   }



 /*** Compute the number of harmonics in [0,PI) ***/
 
   iNpeaks = (int)(NFFT_2/fPitchDFT);
   ftmp=iNpeaks*fPitchDFT;
   VoxROUND2pos(ftmp, iIndex);
   if (iIndex >= NFFT_2)
         iNpeaks --;
 
   if (iNpeaks > MAXHARM)
         iNpeaks = MAXHARM;
 
 

 /*** Establish the number of phases to be coded ***/

   iBasePeaks = iNpeaks;
   if (iBasePeaks > iVEVphases)
       iBasePeaks = iVEVphases;

   /**** compute the phase shift. If the center shift to the left, iWinShift < 0, 
     then the phase should have a negative compensation. If iWinShift > 0,
     phase have a positive compensation. ****/ 
   fPhaseShift = (float)iWinShift * fPitchDFT * TWOPIONFFT;
   fDeltaPhase = 0.0F;

 /*** Compute the sine-wave phases as harmonic samples of the STFT phase ***/

   fFreq = 0.0F;
   for (i = 0; i < iBasePeaks; i++)
   {
      fFreq += fPitchDFT;
      VoxROUND2pos(fFreq, iIndex);
      fSTFTphase = VoxATAN2(pfSWI[iIndex], pfSWR[iIndex]);

      fDeltaPhase += fPhaseShift;
      fSTFTphase += fDeltaPhase;

      /*----------------------------------------------------------
        This code computes fSTFTphase modulo 2 pi. 

          ##### The argorithm is theoretically correct, but
                it is not robust to finite precision arithmetic.
                We need a better way to do this.
      ----------------------------------------------------------*/
      ftmp = fSTFTphase*INVTWOPI;
      VoxROUND2(ftmp, iMhat);

      fSTFTphase -= (float)iMhat * TWOPI;
      if (fSTFTphase < 0.0F)
          fSTFTphase += TWOPI;

      assert((fSTFTphase>=0) && (fSTFTphase<=TWOPI));

      pfVEVphase[i] = fSTFTphase;
   }

 return 0;


} /*VoxSTFTPhase*/


/**********************************************************************/


unsigned short VoxCodePhase ( float fPhase,
                              int   iNlevels,
                              float *pfPhase_q
                            )
{
   int   iIndex;
   float fArg, fArg_q;


 /*** 0 <= Phase <= TWOPI ***/
   fArg = iNlevels*fPhase*INVTWOPI;

   iIndex = (int)fArg;  /** 0 <= iIndex <= (iNlevels-1) **/

   fArg_q = 0.5F + (float)iIndex;

   *pfPhase_q =  TWOPI*fArg_q/iNlevels;

   return 0;
}

/**********************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\sq.c ===
/*******************************************************************************
*                        Voxware Proprietary Material                          *
*                        Copyright 1996, Voxware, Inc                          *
*                            All Rights Reserved                               *
*                                                                              *
*                       DISTRIBUTION PROHIBITED without                        *
*                      written authorization from Voxware                      *
*******************************************************************************/
/*******************************************************************************
* Filename:  SQ.c
*
* Purpose:   Scalar quantization
*
* Date:
* Author:
*
* $Header:   /export/phobos/pvcs/pvcsproj/voxlib.prj/sq.c_v   1.9   08 Apr 1998 17:47:36   weiwang  $
*******************************************************************************/
#include <stdlib.h>
#include <assert.h>

#include "vLibQuan.h"

#include "xvocver.h"

/*******************************************************************************
* Function:  ScalarQuant()
*
* Action:    Find index into codebook of the value closest to the
*              input variable.
*
* Input:     fValue:------- Input variable
*            pfCodeBook:--- Codebook valiables
*            iLength:------ Number of valiable in the codebook
*
* Output:    none
*
* Return:    index--------- Index to codebook
********************************************************************************
*
* Modifications:
*
* Comments:
*
* Concerns/TBD:
*******************************************************************************/
int ScalarQuant( float         fValue, 
                 const float  *pfCodeBook, 
                 int           iLength 
               )
{
   int   i;
   int   iIndex;
   float fMinErr;
   float fErr;

   assert( pfCodeBook != NULL);
   assert( iLength > 0);

   iIndex   = 0;
   fMinErr  = fValue-pfCodeBook[0];
   fMinErr *= fMinErr;

   for (i=1;i<iLength;i++)
   {
      fErr  = fValue-pfCodeBook[i];
      fErr *= fErr;
      if (fErr < fMinErr)
      {
         fMinErr = fErr;
         iIndex = i;
      }
   }

   return( iIndex );
}

/*******************************************************************************
* Function:  ScalarLUT
*
* Action:    Dequantisation.  Return the peoper valiable according to the 
*              index of the codebook
*
* Input:     pfCodeBook:------ Codebook valiables
*            iLength:--------- Number of valiable in the codebook   
*            index------------ Index to codebook
*
* Output:    none
*
* Return:    pfCodeBook[index]----chosen variable in the codebook
*******************************************************************************/
float ScalarLUT( const float *pfCodeBook, 
                 int          iLength, 
                 int          iIndex
               )
{
   assert( pfCodeBook != NULL);
   assert( iLength>0 );
   assert( iIndex<iLength );
   assert( iIndex>=0);

   if (iIndex >= iLength)
      iIndex = 0;
   return (pfCodeBook[iIndex]);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\specint.c ===
/*******************************************************************************
*                        Voxware Proprietary Material                          *
*                        Copyright 1996, Voxware, Inc                          *
*                            All Rights Reserved                               *
*                                                                              *
*                       DISTRIBUTION PROHIBITED without                        *
*                      written authorization from Voxware                      *
*******************************************************************************/

/******************************************************************************
*                        Voxware Proprietary Material
*                        Copyright 1997, Voxware, Inc
*                            All Rights Reserved
*
*                       DISTRIBUTION PROHIBITED without
*                      written authorization from Voxware
******************************************************************************/

/******************************************************************************
*
* Filename:    SpecInt.c
*
* Purpose:    Interpolate the harmonics from one pitch to another.
*
* Functions: SpecIntLn()
*
* Author/Date: Rob Zopf, 12/04/96
*
*******************************************************************************
*
* Modifications:
*
* Comments: 
*
* Concerns: 
*
* $Header:   /export/phobos/pvcs/pvcsproj/voxlib.prj/specint.c_v   1.12   07 Apr 1998 18:12:18   weiwang  $
******************************************************************************/
#include <string.h> 
#include <assert.h>
#include "vLibMath.h"
#include "vLibSgPr.h"

#include "xvocver.h"

#define H_QFACTOR     24                      /* Q24 */
#define HMASK         ((((long)1)<<H_QFACTOR)-1)
#define H_Q2P         (((unsigned long)1)<<H_QFACTOR)
#define INVHQ2P       (1.0F/H_Q2P)

/*******************************************************************************
* Function: SpecIntLn()
*
* Action: Interpolate the harmonic spectrum from one pitch to another using
*         linear interpolation.
*
* Input:  fPitch          - the original pitch lag (time-domain)
*         fPitchInt       - the pitch lag to interpolate the spectrum to.
*         iIntHarms       - the number of harmonics corresponding to fPitchInt
*         pfAmp           - pointer to the original harmonics
*         pfAmpInt        - pointer to a vector to put the interpolated spectrum
*         iMaxHarm        - maximum number of harmonics in fpAmpInt
*
* Output: pfAmpInt        - the interpolated harmonics
*
* Return:  None.
*
* Modifications:
*
* Comments: The pfAmp vector is zero padded up to iMaxHarm for unused 
*             harmonics.
*
*******************************************************************************/
void SpecIntLn( float           fPitch, 
                float           fPitchInt,  
                int             iIntHarms, 
                const float     *pfAmp,  
                float           *pfAmpInt,  
                unsigned int    iMaxHarm
              )
{
   int           i, harmsDone;
   float         interp;
   int harmNum;
   unsigned long harmFactor, totalFactor;
   
   /* error checking */
   assert(iIntHarms <= (int)iMaxHarm);
   assert(pfAmp != NULL);
   assert(pfAmpInt != NULL);
   assert(fPitchInt > 0.0F && fPitch > 0.0F);

   /* if iPitch==iPitchint Harmfactor==1 & interp==0.0  harmNum-1 == i 
      there is no need to do interpolation. "for" loops are doing nothing. 
      maximum value of harmNum could go up to MAXHARM which may cause 
      pfAmpInt index out of boundary
   */
   if(fPitch != fPitchInt) {
      harmFactor=(unsigned long)VoxFLOORposLong((float)H_Q2P *(fPitch/fPitchInt));
      totalFactor   = harmFactor;
      harmsDone     = 0;
      while (totalFactor <= H_Q2P)          
      {
         pfAmpInt[harmsDone] = totalFactor*INVHQ2P*pfAmp[0];
         harmsDone          ++; 
         totalFactor        += harmFactor;  
      }
      for (i=harmsDone; i<iIntHarms; i++)
      {
         harmNum      = (int)(totalFactor>>H_QFACTOR);
         interp       = (totalFactor&HMASK)*INVHQ2P;
         pfAmpInt[i]  = pfAmp[harmNum-1] +
                        (pfAmp[harmNum]-pfAmp[harmNum-1])*interp;
         totalFactor += harmFactor;
      }
   }
   else 
     memcpy(pfAmpInt, pfAmp, sizeof(float)*(iIntHarms));

   memset(pfAmpInt+iIntHarms, 0, sizeof(float)*(iMaxHarm-iIntHarms));
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\stftpks.h ===
/*******************************************************************************
*                        Voxware Proprietary Material                          *
*                        Copyright 1996, Voxware, Inc                          *
*                            All Rights Reserved                               *
*                                                                              *
*                       DISTRIBUTION PROHIBITED without                        *
*                      written authorization from Voxware                      *
*******************************************************************************/
 
/*******************************************************************************
* Filename:     STFTpks.h
*
* Purpose:      Compute the STFT magnitude-squared envelope from the
*               real and imaginary parts of the FFT of the windowed
*               speech. Then pick the peaks and use the amplitudes and
*               frequencies as the basis for the sinusoidal analysis/
*               synthesis system. RJM has added quadratic interpolation
*               to produce sine-wave frequencies having factional DFT
*               values. Can't say that its important but it feels good
*               particularly for low-pitched speakers
*
* Functions:    VoxSTFTpeaks()
*
* Author/Date:  Bob McAulay     11/96
********************************************************************************
* Modifications:
*
* Comments:
*
* Concerns:
*
* $Header:   /export/phobos/pvcs/r_and_d/archives/scaleable/encode/STFTpks.h_v   1.2   11 Apr 1998 15:19:02   bobd  $
*******************************************************************************/
#ifndef STFTPEAKS_H
#define STFTPEAKS_H


void VoxSTFTpeaks ( STACK_R
                    float *pfSWR,
                    float *pfSWI,
                    float *pfMagSq,
                    float *pfPkPwr,
                    float *pfPkFrq,
                    int   *piPeakCount
                  );

#endif /* STFTPEAKS_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\sumcos.h ===
/******************************************************************************
*                        Voxware Proprietary Material
*                        Copyright 1996, Voxware, Inc
*                            All Rights Reserved
*
*                       DISTRIBUTION PROHIBITED without
*                      written authorization from Voxware
******************************************************************************/

/******************************************************************************
* Filename:      SumCos.h
* Purpose:
* Functions:
* Author/Date:
*******************************************************************************
*
* Modifications:  Bob Dunn 3/27/97 added sum of cosines synthesis and
*                    FHT synthesis
*
* Comments:
*
* Concerns:       FHT and sum of cosines make the assumption that the  
*                    frequencies to be synthesized are harmoniclly related
*
* $Header:   /export/phobos/pvcs/r_and_d/archives/scaleable/decode/SumCos.h_v   1.0   16 Apr 1998 13:24:24   bobd  $
*
******************************************************************************/
#ifndef SUMCOS_H
#define SUMCOS_H

void SumCos( float  fPitchDFT, 
             float *pfAmps, 
             float *pfPhase, 
             int    iHarm, 
             int    iSynSubFrameLength, 
             float *pfOutputBuffer
           );

#endif /* SUMCOS_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\sumsyn.c ===
/*******************************************************************************
*                        Voxware Proprietary Material                          *
*                        Copyright 1996, Voxware, Inc                          *
*                            All Rights Reserved                               *
*                                                                              *
*                       DISTRIBUTION PROHIBITED without                        *
*                      written authorization from Voxware                      *
*******************************************************************************/

/*******************************************************************************
* Filename:       SumSyn.c
*                                                                              
* Purpose:        Sine-wave synthesis of harmonic amplitudes with a sum of 
*                   sinusoids.
*
* Functions:  SumSyn()
*
*                                                                              
* Author/Date:    Rob Zopf   12/05/96
********************************************************************************
* Modifications:
*
*                                                                              
* Comments:                                                                    
* 
* Concerns:        
*
* $Header:   /export/phobos/pvcs/r_and_d/archives/realtime/decode/SumSyn.c_v   1.2   02 Mar 1998 18:18:14   weiwang  $
*******************************************************************************/

#include <stdlib.h>
#include <math.h>
#include <string.h>
#include <limits.h>
#include <assert.h>

#include "VoxMem.h"
#include "vLibVec.h" /* OlAdd() */
#include "model.h"

#include "SumSyn.h"

#include "xvocver.h"

void HarmonicSum (float *A,                 /* harmonic amplitudes            */
                  float *phi_o,             /* input phases (0-2PI)           */
                  float  w,                 /* current  fundamental (0-2PI)   */
                  short  startHarm,         /* first harm to synthesize(0..)  */
                  short  endHarm,           /* last harm (not including)      */
                  float *OutBuf,            /* output buffer                  */
                  short  L                  /* length of output buffer        */
                 );

typedef struct tagSumSynBlk {
   float BasePhase;
   float prevPhase[MAXHARM];
   float Mw_1;
   float Amp_1[MAXHARM];
   unsigned short nHarm_1;
} SumSynBlk;


/*******************************************************************************
* Function:       SumSyn()
*
* Action:         Sine-wave synthesis of harmonic amplitudes with a sum of 
*                   sinusoids
*
* Input:
*
* Output:
*
* Globals:        none
*
* Return:		   VOXErr : Voxware return code
********************************************************************************
* Implementation/Detailed Description:
*
* References:
********************************************************************************
* Modifications:
*
* Comments:
*
* Concerns/TBD:
*******************************************************************************/
void SumSyn( STACK_R 
             void  *pvSumSynBlk, 
             float *Amp, 
             float  Pitch, 
             float  Pitch_1, 
             float *Phase, 
             float  multPitch, 
             short  pitch_mult, 
             short  nHarm, 
             short  vHarm, 
             short  frameLen, 
             float  interpFactor, 
             float *outSpeech
           )
{

   SumSynBlk *pSumSynBlk=(SumSynBlk *)pvSumSynBlk;
   STACK_INIT
   float  fSynBuf[MAXSYNLEN];  /* scratch */
   float  pfPrevSyn[MAXSYNLEN];  /* scratch */
   STACK_INIT_END
   STACK_ATTACH(float*,fSynBuf)
   STACK_ATTACH(float*,pfPrevSyn)
   short olLEN;
   short synLEN;
   float w, w_1;
   float Mw;
   float BaseStep;
   int i;
   STACK_START

   olLEN = (short)(interpFactor * frameLen);
   synLEN   = olLEN + ((frameLen-olLEN)>>1);
   w = (float)(D_PI/Pitch);
   w_1 = (float)(D_PI/Pitch_1);
   Mw = (float)(D_PI/multPitch);

   /*------------------------------------------------------------------------------------
      Synthesize the previous section of speech ...
     ------------------------------------------------------------------------------------*/
   HarmonicSum (pSumSynBlk->Amp_1, pSumSynBlk->prevPhase, pSumSynBlk->Mw_1, 0, 
      pSumSynBlk->nHarm_1, pfPrevSyn, synLEN );
     
   /*------------------------------------------------------------
      Set up the phases 
     ------------------------------------------------------------*/
   pSumSynBlk->BasePhase += (w+w_1)*0.5F*frameLen;
   pSumSynBlk->BasePhase  = (float)fmod(pSumSynBlk->BasePhase, D_PI);

   BaseStep = (float)(fmod((pSumSynBlk->BasePhase-synLEN*w), D_PI));
   BaseStep /=(float)pitch_mult;

   for (i=0;i<vHarm;i++)
   {
      Phase[i] = BaseStep*(i+1);
   }

   HarmonicSum (Amp, Phase, Mw, 0, nHarm, fSynBuf, synLEN );

   for (i=0; i<nHarm; i++)
      pSumSynBlk->prevPhase[i] = Phase[i] + Mw*synLEN*(i+1);

 /*----------------------------------------------------
     Do overlap-add of buffers ...
   ----------------------------------------------------*/
   OlAdd(pfPrevSyn, fSynBuf, (const int)olLEN, (const int)frameLen, outSpeech);

   memcpy(pSumSynBlk->Amp_1, Amp, sizeof(float)*MAXHARM);
   pSumSynBlk->nHarm_1 = nHarm;
   pSumSynBlk->Mw_1 = Mw;
   STACK_END
}

unsigned short InitSumSyn(void **hSumSynBlk)
{
   SumSynBlk *pSumSynBlk;

   if(VOX_MEM_INIT(pSumSynBlk=*hSumSynBlk,1,sizeof(SumSynBlk)))
      return 1;
   memset(pSumSynBlk->prevPhase,0,MAXHARM);
   memset(pSumSynBlk->Amp_1,0,MAXHARM);
   pSumSynBlk->BasePhase=0.0F;
   pSumSynBlk->Mw_1=0.0F;
   pSumSynBlk->nHarm_1=0;

   return 0;
}

unsigned short FreeSumSyn(void **hSumSynBlk)
{
   VOX_MEM_FREE(*hSumSynBlk);

   return 0;
}

void HarmonicSum (float *A,                 /* harmonic amplitudes            */
                  float *phi_o,             /* input phases (0-2PI)           */
                  float  w,                 /* current  fundamental (0-2PI)   */
                  short  startHarm,         /* first harm to synthesize(0..)  */
                  short  endHarm,           /* last harm (not including)      */
                  float *OutBuf,            /* output buffer                  */
                  short  L                  /* length of output buffer        */
                 )
{
   register int i;                          /* loop var                       */
   register int m;                          /* loop var                       */
   float        theta_t;                    /* theta(t)                       */
   float        dP;                         /* theta increment                */
   float        Am;                         /* mth amplitude                  */

   memset(OutBuf, 0, sizeof(float)*L);      /* set output buffer to 0         */
   dP     = startHarm*w;                    /* init. delta phase              */
   
   for (m=startHarm; m<endHarm; m++)        /* loop over selected harmonics   */
   {
      theta_t = phi_o[m];                   /* init. theta                    */
      dP     += w;                          /* inc. delta theta               */
      Am      = A[m];                       /* init. A(m)                     */

      for (i=0; i<L; i++)                   /* loop over all samples          */
      {
         OutBuf[i]  += (float)(Am*sin(theta_t));   /* harmonic sum            */
         theta_t    += dP;                         /* increment theta_t       */
      }                                            /* end for(i)              */
   }                                               /* end for(m)              */
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\subfmsyn.c ===
/******************************************************************************
*                        Voxware Proprietary Material                         *
*                        Copyright 1998, Voxware, Inc                         *
*                            All Rights Reserved                              *
*                                                                             *
*                       DISTRIBUTION PROHIBITED without                       *
*                      written authorization from Voxware                     *
******************************************************************************/

/******************************************************************************
* Filename:       SubFmSyn.c
*                                                                              
* Purpose:        synthesis speech of each sub-frame
*                                                                              
* Functions:      SubFrameSynth()
*                                                                              
* Author/Date:    Original developed by Bob McAulay and Bob Dunn 1/97
*******************************************************************************
* Modifications: Moved out from DecSC.c by Wei Wang, 4/98
*                Remove frameEnergy calculation to VciPlsSC.c.
*                                         
* Comments:                                                                    
* 
* Concerns:
*
* $Header:   /export/phobos/pvcs/r_and_d/archives/scaleable/decode/SubFmSyn.c_v   1.7   30 Apr 1998 17:28:06   bobd  $
******************************************************************************/


#include <stdlib.h>
#include <math.h>
#include <assert.h>
#include <string.h>

#include "vLibTran.h"
#include "vLibVec.h"
#include "vLibMath.h"
#include "VoxMem.h"

#include "paramSC.h"
#include "codec.h"
#include "quansc36.h"
#include "SWSynth.h"
#include "rate.h"
#include "AskToEnv.h"
#include "PostFilt.h"
#include "HFRegen.h"
#include "OutBufSC.h"
#include "DecPriSC.h"
#include "SubFmSyn.h"

#include "xvocver.h"
 
#define PV_SWITCH_THRESH 0.125F
#define INTERP_FACTOR_SMALL  0.25F
#define INTERP_FACTOR_MED    0.75F

static void OffsetMeasuresPhases(float *pfVEVphase, 
                                 float *pfCumPhaseOffset,
                                 int iWarpSamples, 
                                 float fPitchPeriod,
                                 float *pfVEVphaseSyn,
                                 int iRepeatSamples);

 
/*******************************************************************************
*
* Function:  SubFrameSynth()
*
* Action:   synthesis the speech of each sub-frame.
*
* Input:    hDecMemBlk -- decoder structure
*           hParamMblk -- parameter structure
*           pfSpeechBuf -- output speech buffer
*           pfEnv -- envelope spectrum
*           pfPhase -- minimum phases of current frame
*           piSynSamples -- pointer to the number of output speech samples
*
* Output:   pfSpeechBuf -- output speech
*           piSynSamples -- number of output speech samples
*
* Globals:   none
*
* Return:    none
********************************************************************************
*
* Modifications:
*
* Comments:
*
* Concerns/TBD:
*******************************************************************************/

void SubFrameSynth( STACK_R 
                    void           *hDecMemBlk, 
                    void           *hSubParamMblk,
                    float          *pfSpeechBuf,
                    float          *pfEnv,
                    float          *pfPhase,
                    int            *piSynSamples
                  )
{
   DEC_MEM_BLK *pDecMemBlk = (DEC_MEM_BLK *)hDecMemBlk;
   SUBFRAME_PARAM_SC *pSubParamMblk = (SUBFRAME_PARAM_SC *)hSubParamMblk;

   int     iSubFrame;
   int     iUpdatePhaseOffsetFlag = 0;
   int     iRepeatSamples;
   int     iSCRateSyn = pDecMemBlk->iSCRate_1;
   int     OffsetFlag = 0;
   int     iOffsetSamples;
   float  *pfSynSpeech;
   float   fInterpFactor;
   float   fPitchPeriod_1;
   float   fOffsetPitchPeriod;
   float   fFrameTime;

   SUBFRAME_PARAM_SC *pSubParamSyn;
   int     *piCountSyn;

STACK_INIT
   float pfVEVphaseSyn[SC6_PHASES];
STACK_INIT_END

   STACK_ATTACH(float *, pfVEVphaseSyn)

   STACK_START

   pfSynSpeech = pfSpeechBuf;

   /*-------------------------------------------------------------------------
     fFrameTime is the time (in samples) corresponding to the parameters
       in pParamMblk after the time scale has been warped.  Time has been
       normalized so the parameters in pParamMblk_1 are located at time
       sample 0.  (The mid-frame parameters in pParamMblk are at time
       0.5*fFrameTime).
   -------------------------------------------------------------------------*/
   fFrameTime = pDecMemBlk->fActualWarp * FRAME_LENGTH_SC;

   /*-------------------------------------------------------------------
   | Synthesize up to two subframes of speech.
   --------------------------------------------------------------------*/
   for (iSubFrame = 2; iSubFrame > 0; iSubFrame--) {
      /*-------------------------------------------------------------------
      | If the location of the center of the current synthesis frame
      |   is between pParamMblk_1 and pParamMblk (between 0 and fFrameTime)
      |   then synthesize the frame.  When warping is not used, 
      |   fSynTimeOffset is equal to fFrameTime/2 for the first subframe,
      |   and it is equal to fFrameTime for the second subframe.
      -------------------------------------------------------------------*/
      iUpdatePhaseOffsetFlag = 0;
      if (pDecMemBlk->fSynTimeOffset<=fFrameTime)
      {
         /*-------------------------------------------------------------------
         | Set the interpolation factor.  When warping is not used, 
         |   fInterpFactor is 0.5 for the first subframe, and 1.0 
         |   for the second sub-frame.
         -------------------------------------------------------------------*/
         fInterpFactor = pDecMemBlk->fSynTimeOffset/fFrameTime;
         iRepeatSamples = 0;
   
         /*-------------------------------------------------------------------
         | Set the parameters for a 10ms sub-frame
         -------------------------------------------------------------------*/
         if (fInterpFactor < INTERP_FACTOR_SMALL)
         {  
            /*----------------------------------------------------------------
            | Use parameters from previous frame (previous 20 ms analysis)
            ----------------------------------------------------------------*/
           pSubParamSyn =  &(pDecMemBlk->PrevSubParam);
           fPitchPeriod_1 = pDecMemBlk->Pitch_1_mid;
           piCountSyn = &(pDecMemBlk->piFrameCount[0]);
           if (pDecMemBlk->iFramesRepeated)
               iRepeatSamples = (pDecMemBlk->iFramesRepeated-1)*FRAME_LENGTH_SC;
         } 
         else {
           if (fInterpFactor < INTERP_FACTOR_MED)
           {
              /*----------------------------------------------------------------
              | Use parameters from mid-frame frame (current 10 ms analysis)
              ----------------------------------------------------------------*/
              pSubParamSyn = &(pSubParamMblk[PARAM_MIDFRAME]);
              fPitchPeriod_1 = pDecMemBlk->PrevSubParam.Pitch;           
              piCountSyn = &(pDecMemBlk->piFrameCount[1]);
           } else { 
             /*----------------------------------------------------------------
             | Use parameters from outer frame (current 20 ms analysis)
             ----------------------------------------------------------------*/
             pSubParamSyn = &(pSubParamMblk[PARAM_ENDFRAME]);
             fPitchPeriod_1 = pSubParamMblk[PARAM_MIDFRAME].Pitch;
             piCountSyn = &(pDecMemBlk->piFrameCount[2]);
           }

           OffsetFlag     = pDecMemBlk->iSetOffsetFlag;
           iRepeatSamples = pDecMemBlk->iFramesRepeated*FRAME_LENGTH_SC;
         } 

         /*----------------------------------------------------------------
         | Count points to the counter for the number of times the 
         |   current sub-frame parameters have been synthesized. iCount_1 
         |   is the number of times the previous sub-frame parameters 
         |   were synthesized.  
         |
         | Increment the count.
         ----------------------------------------------------------------*/
         piCountSyn[1] ++;
         fOffsetPitchPeriod = pSubParamSyn->Pitch;

         /*----------------------------------------------------------------
         | If the count is more than 1 (i.e. the sub-frame parameters have 
         |   been used before) then the linear phase offset must be INCREASED
         |   by an amount corresponding to HALF_FRAME_LENGTH_SC samples. The 
         |   pitch period for this is the pitch period of the current sub-frame.
         |   NOTE: The sub-frame can be repeated as many times as 
         |   desired since the phase offset is cumulative.
         ----------------------------------------------------------------*/
         if (piCountSyn[1] > 1)  
            iOffsetSamples = HALF_FRAME_LENGTH_SC;
         /*----------------------------------------------------------------
         | If the count is 1 (i.e. the first time these sub-frame parameters 
         |   are used) but iCount_1 is zero (i.e. the previous sub-frame 
         |   parameters were skipped) then the linear phase offset must be 
         |   DECREASED by an amount corresponding to HALF_FRAME_LENGTH_SC 
         |   samples. The pitch period for this is the pitch period of the 
         |   sub-frame that was skipped.
         |   NOTE: This assumes that a maximum of 1 consecutive sub-frame 
         |   will be skipped.  If more than 1 consecutive sub-frame is
         |   skipped, the phase offset will not be accounted for.
         ----------------------------------------------------------------*/
         else if ((piCountSyn[0]==0) && (piCountSyn[1]==1))
         {
            iOffsetSamples = -HALF_FRAME_LENGTH_SC;
            fOffsetPitchPeriod = fPitchPeriod_1;
         }
         /*----------------------------------------------------------------
         | Count is 1 (i.e. the first time these sub-frame parameters
         |   are used) and iCount_1 is not zero (i.e. the previous sub-frame
         |   parameters were not skipped) so there is no need to change
         |   the phase offset.
         ----------------------------------------------------------------*/
         else
            iOffsetSamples = 0;

         /*--------------------------------------------------------------------
         | Possibly update the phase offset in VoxHFRegeneration(). This is
         |   done when entire frames have been skipped, or when frames have
         |   been repeated.  In either of these cases the measured phases
         |   have a discontinuity in their embeded linear phases.
         --------------------------------------------------------------------*/
         if (OffsetFlag > 0) 
         {
            iUpdatePhaseOffsetFlag = 1;
            pDecMemBlk->iSetOffsetFlag = 0;
         }
     
         /*--------------------------------------------------------------------
         | Set the voicing-depdendent bit rate for the synthesizer
         --------------------------------------------------------------------*/
         if ((pDecMemBlk->iSCTargetRate==SC_RATE_6K) && 
             (iSCRateSyn==SC_RATE_3K) &&
             (pSubParamSyn->Pv>PV_SWITCH_THRESH))
            iSCRateSyn = SC_RATE_3K;
         else 
            iSCRateSyn = pDecMemBlk->iSCTargetRate;
      
         /*--------------------------------------------------------------------
         | Add a linear phase offset to the measured phases to account for
         |   time warping.  (If iOffsetSamples==0 there is no additional
         |   linear phase offset added)
         --------------------------------------------------------------------*/
         if (pDecMemBlk->iSCTargetRate==SC_RATE_6K)
            OffsetMeasuresPhases( pSubParamSyn->pfVEVphase,
                                  &(pDecMemBlk->fPhaseOffset), 
                                  iOffsetSamples, fOffsetPitchPeriod, 
                                  pfVEVphaseSyn,
                                  iRepeatSamples);

         /*--------------------------------------------------------------------
         | Synthesize 10 ms of Speech
         --------------------------------------------------------------------*/
         VoxSWSynth(STACK_S pDecMemBlk->hHFRegenMblk,
                    iSCRateSyn, pfSynSpeech, pfVEVphaseSyn,
                    pDecMemBlk->pWaveform_1, 
                    pSubParamSyn->Pitch, pSubParamSyn->Pv,
                    pfEnv, pDecMemBlk->pfEnv_1, 
                    pfPhase, pDecMemBlk->pfPhase_1, 
                    fInterpFactor, iUpdatePhaseOffsetFlag,
                    &(pDecMemBlk->lUVPhaseRandSeed));
      
         /*--------------------------------------------------------------------
         | increment speech pointer, time offset, and sample count
         --------------------------------------------------------------------*/
         pfSynSpeech                += HALF_FRAME_LENGTH_SC;
         *piSynSamples              += HALF_FRAME_LENGTH_SC;
         pDecMemBlk->fSynTimeOffset += HALF_FRAME_LENGTH_SC;
 
         /*--------------------------------------------------------------------
         | save synthesis rate flag
         --------------------------------------------------------------------*/
         pDecMemBlk->iSCRate_1 = iSCRateSyn;
      }
   }


   /*--------------------------------------------------------------------
     If (fSynTimeOffset>fFrameTime) then set the flag for a new frame
       next time
   --------------------------------------------------------------------*/
   if (pDecMemBlk->fSynTimeOffset>fFrameTime)
   {
      pDecMemBlk->iNewFrame  = 1;

      /*----------------------------------------------------------------------
        Advance the time reference. (i.e. pParamMblk becomes pParamMblk_1
          so the current value of fFrameTime is moved to 0)
      ----------------------------------------------------------------------*/
      pDecMemBlk->fSynTimeOffset -= fFrameTime;
   }

  STACK_END
}


/*******************************************************************************
*
* Function:  OffsetMeasuresPhases()
*
*******************************************************************************/

static void  OffsetMeasuresPhases( float *pfVEVphase, 
                                   float *pfCumPhaseOffset,
                                   int iWarpSamples,
                                   float fPitchPeriod,
                                   float *pfVEVphaseSyn,
                                   int iRepeatSamples
                                 )
{
   int   i;
   float fPhi;
   float fPhaseOffset;
   float fRatio;
 
   fRatio = TWOPI/fPitchPeriod;
   *pfCumPhaseOffset += ((float)iWarpSamples)*fRatio;

   fPhaseOffset = *pfCumPhaseOffset + ((float)iRepeatSamples)*fRatio;

   fPhi = 0.0F;
   for (i=SC6_PHASES; i > 0; i--)
   {
      fPhi += fPhaseOffset;
      *pfVEVphaseSyn++ = *pfVEVphase++ + fPhi;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\sumsyn.h ===
/*******************************************************************************
*                        Voxware Proprietary Material                          *
*                        Copyright 1996, Voxware, Inc                          *
*                            All Rights Reserved                               *
*                                                                              *
*                       DISTRIBUTION PROHIBITED without                        *
*                      written authorization from Voxware                      *
*******************************************************************************/
#ifndef SUMSYN_H
#define SUMSYN_H

void SumSyn(STACK_R void *pvSumSynBlk, float *Amp, float Pitch, float Pitch_1, float *Phase, 
            float multPitch, short pitch_mult, short nHarm, short vHarm, short frameLen, 
            float interpFactor, float *outSpeech);

unsigned short InitSumSyn(void **hSumSynBlk);

unsigned short FreeSumSyn(void **hSumSynBlk);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\stftpks.c ===
/*******************************************************************************
*                        Voxware Proprietary Material                          *
*                        Copyright 1996, Voxware, Inc                          *
*                            All Rights Reserved                               *
*                                                                              *
*                       DISTRIBUTION PROHIBITED without                        *
*                      written authorization from Voxware                      *
******************************************************************************/

/*******************************************************************************
* Filename:     STFTpks.c                        
*                                                                              
* Purpose:      Compute the STFT magnitude-squared envelope from the
*               real and imaginary parts of the FFT of the windowed
*               speech. Then pick the peaks and use the amplitudes and
*               frequencies as the basis for the sinusoidal analysis/
*               synthesis system. RJM has added quadratic interpolation
*               to produce sine-wave frequencies having factional DFT
*               values. Can't say that its important but it feels good
*               particularly for low-pitched speakers
*                                                                              
* Functions:    VoxSTFTpeaks()
*                                                                              
* Author/Date:  Bob McAulay     11/96
********************************************************************************
* Modifications:
*                                                                              
* Comments:                                                                    
* 
* Concerns:
*
* $Header:   /export/phobos/pvcs/r_and_d/archives/scaleable/encode/STFTpks.c_v   1.5   11 Apr 1998 15:18:58   bobd  $
*******************************************************************************/
#include <assert.h>
#include <math.h>

#include "VoxMem.h"
#include "codec.h"
#include "vLibSpch.h"
#include "vLibMath.h"
#include "vLibVec.h"

#include "STFTpks.h"

#include "xvocver.h"

/*------------------------------------------------------------
  If there are fewer than MIN_PEAKS peaks, the arbitrarily 
   sample the spectrum with a pitch of DEFAULT_PITCH.
------------------------------------------------------------*/
#define MIN_PEAKS     3
#define DEFAULT_PITCH 7
#define DEFAULT_PEAKS 36

/******************************************************************************
*
* Function:  VoxSTFTpeaks()
*
* Action:    Compute the sine-wave amplitudes and frequencies.
*
* Input:     float *pfSWR       --> real part of the spectrum
*            float *pfSWI       --> imaginary part of the spectrum
*
* Output:    float *pfMagSq     --> power spectrum (magnitude squared)
*            float *pfPkPwr     --> peaks of the power spectrum
*            float *pfPkFrq     --> frequencies (in DFT samples) of the peaks 
*                                     of the power spectrum
*            int   *piPeakCount --> number of peaks
*
* Globals:
*
* Return: 
*******************************************************************************
*
* Implementation/Detailed Description:
*
* References:
*******************************************************************************
*
* Modifications:
*
* Comments:
*
* Concerns/TBD:
******************************************************************************/
void VoxSTFTpeaks ( STACK_R
                    float *pfSWR, 
                    float *pfSWI, 
                    float *pfMagSq, 
                    float *pfPkPwr,
                    float *pfPkFrq, 
                    int   *piPeakCount
                  )
{
   int   i, n;
   int   iFreq;
   float fDeltaFreq;
   float fPitch;
   float fFreq;

STACK_INIT
   int   iPeakFreqs[MAXHARM];
STACK_INIT_END

   STACK_ATTACH(int *, iPeakFreqs)

   /*-------------------------------------------------------
     Compute magintude squared of the STFT
   -------------------------------------------------------*/
   MagSq( pfSWR, pfSWI, NFFT_2, pfMagSq);

   STACK_START

   /*-------------------------------------------------------
     Find the locations of the peaks
   -------------------------------------------------------*/
   PeakPick( pfMagSq, 0, NFFT_2, MAXHARM, iPeakFreqs, piPeakCount );

   /*-------------------------------------------------------
     Do quadratic interpolation to improve the peak 
      locations and magnitudes.
   -------------------------------------------------------*/
   for (i=0; i<*piPeakCount; i++)
   {
     n = iPeakFreqs[i];

     fDeltaFreq = QuadraticPeak( pfMagSq[n-1], pfMagSq[n], pfMagSq[n+1], 
                                 &(pfPkPwr[i]));
     pfPkFrq[i] = n + fDeltaFreq;
 
   }      

   STACK_END

   /*----------------------------------------------------------------
     If there are not enough peaks, then arbitrarily sample the 
       pfMagSq[] using a pitch of DEFAULT_PITCH.
   ----------------------------------------------------------------*/
   if (*piPeakCount <= MIN_PEAKS)
   {
      fPitch = (float) DEFAULT_PITCH;
      fFreq = fPitch;
      iFreq = DEFAULT_PITCH;
      for (n=0; n<DEFAULT_PEAKS; n++)
      {
         pfPkFrq[n] = fFreq;
         fFreq += fPitch;
         pfPkPwr[n] = pfMagSq[iFreq];
         iFreq += DEFAULT_PITCH;
      }
      *piPeakCount = DEFAULT_PEAKS;
   }

} /*VoxSTFTpeaks()*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\subfmsyn.h ===
/******************************************************************************
*                        Voxware Proprietary Material                         *
*                        Copyright 1998, Voxware, Inc                         *
*                            All Rights Reserved                              *
*                                                                             *
*                       DISTRIBUTION PROHIBITED without                       *
*                      written authorization from Voxware                     *
******************************************************************************/

/******************************************************************************
* Filename:       SubFmSyn.h
*                                                                              
* Purpose:        synthesis speech of each sub-frame
*                                                                              
* Functions:      SubFrameSynth()
*                                                                              
* Author/Date:    Original developed by Bob McAulay and Bob Dunn 1/97
*******************************************************************************
* Modifications: Moved out from DecSC.c by Wei Wang, 4/98
*                                                                              
* Comments:                                                                    
* 
* Concerns:
*
* $Header:   /export/phobos/pvcs/r_and_d/archives/scaleable/decode/SubFmSyn.h_v   1.1   13 Apr 1998 16:17:08   weiwang  $
******************************************************************************/

#ifndef _SUBFMSYN_H_
#define _SUBFMSYN_H_

/*******************************************************************************
*
* Function:  SubFrameSynth()
*
* Action:   synthesis the speech of each sub-frame.
*
* Input:    pDecMemBlk -- decoder structure
*           pParamMblk -- parameter structure
*           pfSpeechBuf -- output speech buffer
*           pfEnv -- envelope spectrum
*           pfPhase -- minimum phases of current frame
*           piSynSamples -- pointer to the number of output speech samples
*
* Output:   pfSpeechBuf -- output speech
*           piSynSamples -- number of output speech samples
*
* Globals:   none
*
* Return:    none
********************************************************************************
*
* Modifications:
*
* Comments:
*
* Concerns/TBD:
*******************************************************************************/

void SubFrameSynth( STACK_R 
                    void           *hDecMemBlk, 
                    void           *hSubParamMblk,
                    float          *pfSpeechBuf,
                    float          *pfEnv,
                    float          *pfPhase,
                    int            *piSynSamples
                  );
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\svqphase.c ===
/******************************************************************************
*                        Voxware Proprietary Material
*                        Copyright 1996, Voxware, Inc
*                            All Rights Reserved
*
*                       DISTRIBUTION PROHIBITED without
*                      written authorization from Voxware
******************************************************************************/
 
/******************************************************************************
*
* Filename:        SVqPhase.c
*
* Purpose:         Pairwise vector quantization of the 10ms and 20ms phases.
*                  The 10ms and 20ms pitches are use to predict the 20ms phase
*                  from the 10ms phase. The measured 20ms phase and the
*                  predicted 20ms phase then form a pair that are
*                  vector-quantized. 
*
* Functions:     VoxSVQEncPhase, VoxSVQDecPhase, VoxEncPhasePrediction,
*                VoxDecPhasePrediction
*
* Author/Date:     Bob Dunn 4/18/97 and Bob McAulay 4/30/97
*
*******************************************************************************
*
* Modifications:   With Phase prediction to increase correlation
*                  Hard wired for a sub-vector length of 2 for speed
*
* Comments:    
*
* Concerns:
*
* $Header:   /export/phobos/pvcs/r_and_d/archives/scaleable/quan/SVqPhase.c_v   1.8   13 Apr 1998 16:17:54   weiwang  $
******************************************************************************/
#include <stdlib.h>
#include <assert.h>
#include <math.h>

#include "vLibQuan.h"
#include "vLibMath.h"

#include "codec.h"
#include "quansc36.h"

#include "SVqPhase.h"

#include "xvocver.h"


/*--------------------------------------------------
  Definitions for phase quantization 
  --------------------------------------------------*/
#define PHASE0_LEVELS  32                 /* linear quantizer if phase error is small enough */
#define PHASE0_ERR_THRD   0.217237F       /* threshold of phase error */
#define PHASE0_FACTOR  (32.0F/TWOPI)      /* step for linear quantizer */
#define INV_PHASE0_FACTOR (TWOPI/32.0F)   /* inverse step for linear quantizer */
#define PHASE0_FLOOR      0.1927F         /* floor for end-frame phase */

/*--------------------------------------------
  Assign appropriate coding tables
  --------------------------------------------*/
/* VQ codebook size */
#define PHASE_VQ_SIZE     (((1<<BITS_PHASE_PAIR_SC6)-PHASE0_LEVELS)>>1)

static const float fPhaseCodeBookTable[PHASE_VQ_SIZE*2] = {
#include "PhaseCB.h"
};

/* SQ size + VQ size without sign bit */
#define PHASE_CODEBOOK_SIZE  (1<<(BITS_PHASE_PAIR_SC6-1)) 
static const int sPhaseCOVIndex[PHASE_CODEBOOK_SIZE] = {
#include "PhaseInd.h"
};


#ifndef DECODE_ONLY
/******************************************************************************
*
* Function:  VoxSVQEncPhase
*
* Action:    Use this module to VQ pairwise predictive phase coding.
*
* Input:  pfPhaseErr --  phase errors
*         pfPhase    --  end-frame phases
*         piIndices -- pointer to the output indices
*
* Output: piIndices -- output quantization indices
*
* Globals:   none
*
* Return:    none
*******************************************************************************
*
* Implementation/Detailed Description: 
*        If predictive error is smaller than PHASE0_ERR_THRD, quantize the 20ms
*     phase using linear quantizer. Otherwise, do 2-dimensional VQ of the phase
*     pair. 
*
* References:
*******************************************************************************
*
* Modifications:
*
* Comments:  
*
* Concerns/TBD:
******************************************************************************/

void VoxSVQEncPhase(float *pfPhase_Err, float *pfPhase, int *piIndices)
{
  int   i, j;
  int   iSignBit, iIndex;
  float pfVector[2];

  assert((pfPhase != NULL) && (pfPhase_Err != NULL) && (piIndices != NULL));

  for (i=0; i<SC6_PHASES; i++)
    {
      /*--------------------------------------------
        Get the sign bit and set the phase error 
        larger than 0.
        --------------------------------------------*/
      if (pfPhase_Err[i] < 0.0F)
        {
          pfPhase_Err[i] = -pfPhase_Err[i];
          iSignBit = 1;
        }
      else 
        iSignBit = 0;

      /*--------------------------------------------
        Test for a 10ms phase near zero.
        If phase error is small enough, use
        linear quantizer.
        --------------------------------------------*/
      if (pfPhase_Err[i] < PHASE0_ERR_THRD)
        {
          /*----------------------------------------
            Do linear quantization 
            ----------------------------------------*/
          iIndex = VoxFLOOR((pfPhase[i]-PHASE0_FLOOR)
                            *PHASE0_FACTOR+0.5F);
          if (iIndex < 0)
            iIndex += PHASE0_LEVELS;

          assert(iIndex < PHASE0_LEVELS);

          /*----------------------------------------
            Extract the sign bit.
            ----------------------------------------*/
          iSignBit = iIndex & 1;
          iIndex = iIndex >> 1;
        }
      else
        /*--------------------------------------------------
          Do vector quantization if phase error is above the
          threshold.
          --------------------------------------------------*/
        {
         /*--------------------------------------------
           Create the vector pair for Dim2VectorQuantize()
           --------------------------------------------*/
         pfVector[0] = pfPhase_Err[i];
         pfVector[1] = pfPhase[i];

         /*--------------------------------------------
           Encode subvector using fast search
           --------------------------------------------*/
         iIndex = Dim2VectorQuantize(pfVector, fPhaseCodeBookTable, 
                                     PHASE_VQ_SIZE);
          
         /*--------------------------------------------------
           Normalize the index by considering SQ level without
           sign bits.
           --------------------------------------------------*/
         iIndex += (PHASE0_LEVELS>>1);
        }

      /*--------------------------------------------------
        Now search for the channel optimized index 
        --------------------------------------------------*/
      j = 0;
      while(iIndex != sPhaseCOVIndex[j])
        j++;
      iIndex = j;

      /*--------------------------------------------------
        Combine quantization index and the sign bits
        --------------------------------------------------*/
      piIndices[i] = iIndex + (iSignBit<<(BITS_PHASE_PAIR_SC6-1));

      assert(piIndices[i] < (1<<BITS_PHASE_PAIR_SC6));
   }
}
#endif

/******************************************************************************
*
* Function:  VoxSVQDecPhase
*
* Action:    Use this module to decode the phase pair
*
* Input:  piIndices -- quantization indices
*         pfPhase_Err -- pointers to predictive phase errors
*         pfPhase     -- pointer to the end-frame phases
*
* Output: pfPhase_Err -- predictive phase errors
*         pfPhase     -- the end-frame phases
*
* Globals:   none
*
* Return:    none
*******************************************************************************
*
* Implementation/Detailed Description: 
*
* References:
*******************************************************************************
*
* Modifications:
*
* Comments:  
*
* Concerns/TBD:
******************************************************************************/

void VoxSVQDecPhase(const int *piIndices, float *pfPhase_Err, float *pfPhase)
{
  int   i, iIndex, iSignBit;
  float pfVector[2];

  assert((piIndices != NULL) && (pfPhase != NULL) && (pfPhase_Err != NULL));

  for (i=0; i<SC6_PHASES; i++)
    {
      /*--------------------------------------------------
        Get the sign bit and index
        --------------------------------------------------*/
      iSignBit = piIndices[i]>>(BITS_PHASE_PAIR_SC6-1);
      iIndex = piIndices[i] & (PHASE_CODEBOOK_SIZE-1);

      /*--------------------------------------------------
        Map the channel optimized index to regular index 
        --------------------------------------------------*/
      iIndex = sPhaseCOVIndex[iIndex];

      /*--------------------------------------------
        Test for a 10ms phase near zero.
        The first 16 code entries are for the phase errors
        equal to 0. Phases are linearly quantized.
        --------------------------------------------*/
      if (iIndex < (PHASE0_LEVELS>>1))
        {
          /*----------------------------------------
            Combine the sign bit
            ----------------------------------------*/
          iIndex = (iIndex<<1) + iSignBit;

         /*----------------------------------------
           Decode the phase pair
           ----------------------------------------*/
          pfPhase_Err[i] = 0.0F;
          pfPhase[i] = (float)iIndex*INV_PHASE0_FACTOR + PHASE0_FLOOR;
          if (pfPhase[i] > TWOPI)
            pfPhase[i] -= TWOPI;
        }
      else
        /*--------------------------------------------------
          Decode phase pair using VQ.
          --------------------------------------------------*/
        {
          /*--------------------------------------------
            Set pointer to decoded sub vector
            --------------------------------------------*/
          iIndex -= (PHASE0_LEVELS>>1);

          Dim2VectorLUT(iIndex, fPhaseCodeBookTable, PHASE_VQ_SIZE, pfVector);
          if (iSignBit == 1)
            pfPhase_Err[i] = -pfVector[0];
          else
            pfPhase_Err[i] = pfVector[0];

          pfPhase[i] = pfVector[1];
        }
    }
}

/******************************************************************************
*
* Function:  VoxEncPhasePrediction
*
* Action:    Predict the 10ms phases and output the predictive error
*
* Input:  fPitch_Mid -- middle-frame pitch
*         fPitch     -- end-frame pitch
*         pfPhaseMid -- middle-frame phases
*         pfPhase    -- end-frame phases
*
* Output: pfPhaseMid -- predictive phase errors
*         pfPhase    -- end-frame phases
*
* Globals:   none
*
* Return:    none
*******************************************************************************
*
* Implementation/Detailed Description: 
*
* References:
*******************************************************************************
*
* Modifications:
*
* Comments:  
*
* Concerns/TBD:
******************************************************************************/

void VoxEncPhasePrediction (float fPitch_Mid, float fPitch, 
                            float *pfPhaseMid, float *pfPhase)
{
   int  i, iMhat;
   float fPitchDFT[2];
   float fDeltaPhase, fPhaseShift;
   float fTemp;

   assert(pfPhase != NULL);
   assert(pfPhaseMid != NULL);

   /*--------------------------------------------------
     Compute pitch in DFT domain 
     --------------------------------------------------*/
   fPitchDFT[0] = (float)NFFT/fPitch_Mid;
   fPitchDFT[1] = (float)NFFT/fPitch;

   /*--------------------------------------------------
     Compute delta-phase and initialize phase-shift
     --------------------------------------------------*/
   fDeltaPhase = (fPitchDFT[0]+fPitchDFT[1])*
                 (0.5F*(float)HALF_FRAME_LENGTH_SC*TWOPIONFFT);
   fPhaseShift = fDeltaPhase;

   for (i = 0; i < SC6_PHASES; i++) {
     /*--------------------------------------------------
       Compute the predictive error for the middle frame 
       phase.
       --------------------------------------------------*/
      pfPhaseMid[i] = pfPhase[i] - fPhaseShift - pfPhaseMid[i];

      /*--------------------------------------------------
        Normalize the phase error so that it's between -Pi
        to Pi
        --------------------------------------------------*/
      fTemp = pfPhaseMid[i]*INVTWOPI;
      VoxROUND2( fTemp, iMhat );
      pfPhaseMid[i] -= iMhat*TWOPI;

      /*--------------------------------------------------
        Update the phase shift 
        --------------------------------------------------*/
      fPhaseShift += fDeltaPhase;
   }

}

/******************************************************************************
*
* Function: VoxDecPhasePrediction
*
* Action:  Estimate the 10ms phases from 20ms phases and 10ms predictive errors.
*
* Input:  fPitchMid -- middle-frame pitch
*         fPitch    -- end-frame pitch
*         pfPhaseMid -- predictive phase errors
*         pfPhase -- end-frame phases
*
* Output: pfPhaseMid -- middle-frame phases
*         pfPhase    -- end-frame phases
*
* Globals:   none
*
* Return:    none
*******************************************************************************
*
* Implementation/Detailed Description: 
*
* References:
*******************************************************************************
*
* Modifications:
*
* Comments:  
*
* Concerns/TBD:
******************************************************************************/

void VoxDecPhasePrediction(float fPitchMid, float fPitch, 
                           float *pfPhaseMid, float *pfPhase)
{
   int i;

   VoxEncPhasePrediction(fPitchMid, fPitch, pfPhaseMid, pfPhase);

   /*--------------------------------------------------
     Normalize the mid-frame phase between 0 to 2*Pi
    --------------------------------------------------*/
   for (i = 0; i < SC6_PHASES; i++)
     {
        while(pfPhaseMid[i] < 0.0F)
           pfPhaseMid[i] += TWOPI;
     }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\synspec.h ===
#ifndef _SYNSPEC_H_
#define _SYNSPEC_H_

#define BIT_SHIFT         22
#define DOWN_SHIFT        6
#define REFINE_SHIFT      (BIT_SHIFT-DOWN_SHIFT)
#define FIX_SCALE         ((long)((long)1<<BIT_SHIFT))
#define FIX_05            ((long)((long)1<<(BIT_SHIFT-1)))
#define FIX_05_REFINE     ((long)((long)1<<(REFINE_SHIFT-1)))


#define REFINE_SPEC_SCALE   32                

#define SPEC_RESAMP_BASE   ((float)REFINE_SPEC_SCALE/(float)(FRAME_SIZE1-1))

#define MIN_REFINE_PITCH     8


#define NREFINEP01        5       /* number of pitch candidates for pitch refinement */
#define NREFINEP02        4       /* number of pitch candidates for pitch refinement */

#define SPEC_START        3       /* 50 Hz */
#define SPEC_END          64 	  /* was 236 (3.7kHz)  however now 64 (1kHz) for Low complexity*/

#define MAXCON            3.402823466E+38F

#define MINCON         1.0e-6F    /* minimum constant */

#define INV_NFFT          (1.0F/(float)NFFT)

#define MAX_BANDWDTH      20

#define SEEVOC_PEAK_ON

float CalcCmpxSpecErr(float fPitch, float *pSWR, float *pSWI, 
		      int uiWinLen, int iStartDFT, int iEndDFT);

int CalcBandErr(float fPitch, float *pSWR, float *pSWI,
		float *pPower, int uiWinLen, float *pBandErr);

int VoxSynSpecSeeVoc(float *pSWR, float *pSWI, float *pPower, int *iSeeVocFreq,
		     float pitch, float *pBandErr, int uiWinLen);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\swsynth.c ===
/******************************************************************************
*                        Voxware Proprietary Material                         *
*                        Copyright 1996, Voxware, Inc                         *
*                            All Rights Reserved                              *
*                                                                             *
*                       DISTRIBUTION PROHIBITED without                       *
*                      written authorization from Voxware                     *
******************************************************************************/

/******************************************************************************
* Filename:       SWSynth.c
*                                                                              
* Purpose:        Sine-wave synthesis for one frame of data.
*                                                                              
* Functions:      VoxSWSynth()
*
* Author/Date:    Original developed by Bob McAulay and Bob Dunn 1/97
*******************************************************************************
* Modifications:                                                               
*                                                                              
* Comments:                                                                    
* 
* Concerns:
*
* $Header:   /export/phobos/pvcs/r_and_d/archives/scaleable/decode/SWSynth.c_v   1.7   13 Apr 1998 18:26:20   weiwang  $
******************************************************************************/
#include <stdlib.h>
#include <math.h>
#include <assert.h>

#include "vLibMath.h"

#include "VoxMem.h"
#include "codec.h"
#include "rate.h"
#include "KLPitch.h"
#include "SetAmps.h"
#include "HFRegen.h"
#include "ExPhase.h"
#include "Jitter.h"
#include "UVPhase.h"
#include "OverAdd.h"
#include "SWSynth.h"

#include "xvocver.h"

/*******************************************************************************
*
* Function:  VoxSWSynth()
*
* Action:    Synthesize 10 ms of speech from parameters.
*
* Input:  void   *hHFRegenMblk           -> memory block for HFRegen
*         int     iSCRateSyn             -> current synthesis rate
*         int     iSynSubFrameLength     -> number of samples to synthesize
*         float  *pfVEVphase             -> measured phases
*         float  *pfWaveform_1           -> previous synthesized waveform
*         float   fSynPitch              -> pitch for synthesis
*         float   fPv                    -> voicing probability for synthesis
*         float  *pfEnv                  -> magnitude envelope
*         float  *pfEnv_1                -> previous magnitude envelope
*         float  *pfPhase                -> phase envelope
*         float  *pfPhase_1              -> previous phase envelope
*         float   fInterpFactor          -> envelope interpolation factor
*         int     iUpdatePhaseOffsetFlag -> flag for HFRegen
*         long    *plUVPhaseRandSeed     -> address for random seed for 
*                                            unvoiced phases
*
* Output: float  *pfSynSpeech            -> output speech
*
* Globals:   none
*
* Return:    void
********************************************************************************
*
* Modifications:
*
* Comments:      
*
* Concerns/TBD:
*******************************************************************************/
void VoxSWSynth(STACK_R 
                void   *hHFRegenMblk,
                int     iSCRateSyn,
                float  *pfSynSpeech,
                float  *pfVEVphase,
                float  *pfWaveform_1,
                float   fSynPitch,
                float   fPv,
                float  *pfEnv,
                float  *pfEnv_1,
                float  *pfPhase,
                float  *pfPhase_1,
                float   fInterpFactor, 
                int     iUpdatePhaseOffsetFlag,
                long   *plUVPhaseRandSeed
               )
{
   int i;
   int iIndex;
   int iHarmonics;     /* number of sine waves                                */
   int iSubHarmonics;  /* number of sine waves including sub-harmonics        */
   int iRatio;         /* ratio of iSubHarmonics to iHarmonics                */
   int iBasePeaks;     /* number of peaks with measured phases                */
   int iVoicHarm;      /* number of voiced sine waves                         */
   int iVoicSubHarm;   /* number of voiced sine waves including sub-harmonics */

   float fFHT_F0;       /* F0 to use in FHT synthesis                    */
   float fVoicingCutoff;  /* the frequency cutoff for voicing                 */
   float fBasebandCutoff; /* the frequency cutoff for measured phases         */
   float fFinalCutoff;    /* the frequency cutoff for randomizing phases      */
   float fNoiseScale;     /* scale factor for unvoiced harmonics              */
   float fOnsetPhase;     /* the onset phase                                  */
   float fBeta;           /* the beta factor                                  */
   float fTemp;
   float fDFT_F0;

STACK_INIT
   float pfMinPhase[MAXHARM];
   float pfAmp[MAXHARM];
STACK_INIT_END

   STACK_ATTACH(float *, pfMinPhase)
   STACK_ATTACH(float *, pfAmp)
  
   STACK_START

   assert(hHFRegenMblk != NULL && pfSynSpeech != NULL);
   assert(pfVEVphase != NULL && pfWaveform_1 != NULL);
   assert(pfEnv != NULL && pfEnv_1 != NULL);
   assert(pfPhase != NULL && pfPhase_1 != NULL);
   assert(plUVPhaseRandSeed != NULL);

   fDFT_F0 = (float)NFFT/fSynPitch;
 
   /*--------------------------------------------------------------------
     Determine the number of harmonics
   --------------------------------------------------------------------*/
   iHarmonics = VoxFLOORpos(0.5F*fSynPitch);

   fTemp = fDFT_F0*(float)iHarmonics;
   VoxROUND2pos( fTemp, iIndex );
 
   if (iIndex >= NFFT_2)
         iHarmonics --;
 
   iHarmonics = VoxMIN( iHarmonics, MAXHARM );

   /*--------------------------------------------------------------------
     Determine the voicing cutoff and the number of baseband peaks
   --------------------------------------------------------------------*/
   fVoicingCutoff=fPv*(float)NFFT_2;
   if (iSCRateSyn==SC_RATE_3K)
   {
      iBasePeaks = 0;
      fFinalCutoff = fVoicingCutoff;
   } else {
      iBasePeaks = VoxMIN( SC6_PHASES, iHarmonics );
      fBasebandCutoff = ((float)iBasePeaks+0.5F)*fDFT_F0;
      fFinalCutoff = VoxMAX( fBasebandCutoff, fVoicingCutoff );
   }
 
   /*--------------------------------------------------------------------
     Determin iRatio and number of harmonics
   --------------------------------------------------------------------*/
   iRatio = (fVoicingCutoff<NFFT_2) ? (MAXHARM/iHarmonics) : 1;

   iSubHarmonics = iHarmonics*iRatio;

   fFHT_F0 = fDFT_F0/(float)iRatio;
 
   iVoicHarm = VoxFLOORpos( fFinalCutoff*INV_NFFT*fSynPitch);

   iVoicSubHarm = iVoicHarm*iRatio;


   /*--------------------------------------------------------------------
     Compute the Karhunen-Loeve scale factor to account for the analysis 
       window energy and the synthesis pitch for unvoiced harmonics
   --------------------------------------------------------------------*/
   fNoiseScale = fSetKLFactor( fSynPitch, fFHT_F0);

   /*--------------------------------------------------------------------
     Generate samples of the amplitude and phase envelopes at the
       pitch harmonics by interpolating in both time and frequency.
   --------------------------------------------------------------------*/
   SetAmpAndPhase ( fNoiseScale, fDFT_F0, pfAmp, pfMinPhase, 
                    iHarmonics, iVoicHarm, pfEnv, pfEnv_1, pfPhase, 
                    pfPhase_1, fInterpFactor);

   /*--------------------------------------------------------------------
     Estimate the rate-dependent excitation phase parameters
   --------------------------------------------------------------------*/
   VoxHFRegeneration(STACK_S hHFRegenMblk, pfVEVphase, 
                     fDFT_F0, pfAmp, pfMinPhase, iHarmonics,
                     &fOnsetPhase, &fBeta, iSCRateSyn, 
                     HALF_FRAME_LENGTH_SC, iUpdatePhaseOffsetFlag);

   /*--------------------------------------------------------------------
     Add the linear phase to the minimum phase and the residual phase
   --------------------------------------------------------------------*/
   ExcitationPhase(fOnsetPhase, fBeta, pfVEVphase,
                   pfMinPhase, iHarmonics, iBasePeaks );

   /*--------------------------------------------------------------------
     Add glottal pulse jitter to the uncoded odd harmonics 
   --------------------------------------------------------------------*/
   PhaseJitter( fSynPitch, pfMinPhase, iBasePeaks, iHarmonics );


   /*--------------------------------------------------------------------
     Convert log_base_2 amplitudes to linear
   --------------------------------------------------------------------*/
   for(i = 0; i < iHarmonics; i++)
      pfAmp[i] = fInvLog2(pfAmp[i]);

   /*--------------------------------------------------------------------
     Increase the number of unvoiced harmonics by adding sub-harmonics.
       This is done now rather the previously in SetAmps() to save on the
       maximum number of fInvLog2()'s required.  The maximum number of
       pitch harmonics is 80 because the minimum pitch is 50 Hz.  The
       maximum number of synthesis harmonics is 100, so we can save
       20 fInvLog2()'s from the peak complexity by increasing the
       number of harmonics after taking fInvLog2().
   --------------------------------------------------------------------*/
   AddSubHarmonics ( pfAmp, pfMinPhase, iHarmonics, iSubHarmonics, 
                     iRatio, iVoicHarm);
 
   /*--------------------------------------------------------------------
     For uncoded phases add on the random phase above cutoff
   --------------------------------------------------------------------*/
   UnvoicedPhase( pfMinPhase, iSubHarmonics, iVoicSubHarm, plUVPhaseRandSeed);

   /*--------------------------------------------------------------------
     Compute the sine-wave parameters and perform sine-wave
     synthesis using FHT and overlap-add
   --------------------------------------------------------------------*/
   FHTOverlapAdd (STACK_S pfAmp, fFHT_F0, pfMinPhase, iSubHarmonics, 
                  HALF_FRAME_LENGTH_SC, pfSynSpeech, pfWaveform_1);

   STACK_END
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\swsynth.h ===
/******************************************************************************
*                        Voxware Proprietary Material                         *
*                        Copyright 1996, Voxware, Inc                         *
*                            All Rights Reserved                              *
*                                                                             *
*                       DISTRIBUTION PROHIBITED without                       *
*                      written authorization from Voxware                     *
******************************************************************************/

/******************************************************************************
* Filename:       SWSynth.h
*                                                                              
* Purpose:        Sine-wave synthesis for one frame of data.
*                                                                              
* Functions:      VoxSWSynth()
*
* Author/Date:    Original developed by Bob McAulay and Bob Dunn 1/97
*******************************************************************************
* Modifications:                                                               
*                                                                              
* Comments:                                                                    
* 
* Concerns:
*
* $Header:   /export/phobos/pvcs/r_and_d/archives/scaleable/decode/SWSynth.h_v   1.2   13 Apr 1998 16:17:06   weiwang  $
******************************************************************************/

/*******************************************************************************
*
* Function:  VoxSWSynth()
*
* Action:    Synthesize 10 ms of speech from parameters.
*
* Input:  void   *hHFRegenMblk       -> memory block for HFRegen
*         int     iSCRateSyn         -> current synthesis rate
*         int     iSynSubFrameLength -> number of samples to synthesize
*         float  *pfVEVphase         -> measured phases
*         float  *pfWaveform_1       -> previous synthesized waveform
*         float   fSynPitch          -> pitch for synthesis
*         float   fPv                -> voicing probability for synthesis
*         float  *pfEnv              -> magnitude envelope
*         float  *pfEnv_1            -> previous magnitude envelope
*         float  *pfPhase            -> phase envelope
*         float  *pfPhase_1          -> previous phase envelope
*         float   fInterpFactor      -> envelope interpolation factor
*         int     iUpdatePhaseOffsetFlag -> flag for HFRegen
*         long    *plUVPhaseRandSeed -> address for random seed for unvoiced phases
*
* Output: float  *pfSynSpeech        -> output speech
*
* Globals:   none
*
* Return:    void
********************************************************************************
*
* Modifications:
*
* Comments:      
*
* Concerns/TBD:
*******************************************************************************/
#ifndef SWSYNTH_H
#define SWSYNTH_H

void VoxSWSynth(STACK_R 
                void   *hHFRegenMblk,
                int     iSCRateSyn,
                float  *pfSynSpeech,
                float  *pfVEVphase,
                float  *pfWaveform_1,
                float   fSynPitch,
                float   fPv,
                float  *pfEnv,
                float  *pfEnv_1,
                float  *pfPhase,
                float  *pfPhase_1,
                float   fInterpFactor, 
                int     iUpdatePhaseOffsetFlag,
                long   *plUVPhaseRandSeed
               );

#endif /* SWSYNTH_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\symwinsp.c ===
/*****************************************************************************
*                        Voxware Proprietary Material                       *
*                        Copyright 1996, Voxware Inc.                       *
*                        All Rights Reserved                                *
*                                                                           *
*                        DISTRIBUTION PROHIBITED without                    *
*                        written authorization from Voxware.                *
*****************************************************************************/
/*******************************************************************************
*
* File:  SymWinSp.c
*
* Purpose: Considering the symmetricity of window, the signal is windowed by 
*          only the half size of window coefficients.
*
* Author: Wei Wang
*
* Date:  Oct. 07, 1996
*
* $Header:   /export/phobos/pvcs/pvcsproj/voxlib.prj/SymWinSp.c_v   1.7   02 Mar 1998 17:41:02   weiwang  $
*
******************************************************************************
* Modifications:
*
* Comments: In-place operation is supported
*
* Concerns:
*
******************************************************************************/
#include <assert.h>
#include <stdlib.h>
#include "vLibSgPr.h"

#include "xvocver.h"

/*******************************************************************************
* 
* Function: SymWindowSignal()
*
* Action: considering the symmetricity of window, the signal is windowed by 
*         only the half size of window coefficients.
*
* Input:  pIn:    input signal.
*         pWin:   window data (only left half size == ((length+1)>>1)).
*         length: data length.
*
* Output: pOut:   output signal.
*
* Return: None.
*******************************************************************************
* Modifications:
*
* Comments: In-place operation is supported.
*
* Concerns/TBD:
******************************************************************************/
void SymWindowSignal(const float *pIn, const float *pWin, float *pOut,
                      int length)
{
   int half_length = length >> 1;
   float *pIn2, *pOut2;

   assert((pIn != NULL) && (pWin != NULL) && (pOut != NULL));
  
   /** window the signal in both sides **/
   pIn2 = (float *) &(pIn[length-1]);
   pOut2 = &(pOut[length-1]);
   while ( (half_length --) > 0 ) 
     {
        *pOut++ = *pIn++ * *pWin;
        *pOut2-- = *pIn2-- * *pWin++;
     }

   /* considing the length is odd number */
   if (length & 1)
      *pOut = *pIn * *pWin;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\sws.h ===
/*******************************************************************************
*                        Voxware Proprietary Material                          *
*                        Copyright 1996, Voxware, Inc                          *
*                            All Rights Reserved                               *
*                                                                              *
*                       DISTRIBUTION PROHIBITED without                        *
*                      written authorization from Voxware                      *
*******************************************************************************/

/*******************************************************************************
* Filename:       Sws.h
*                                                                              
* Purpose:        Sine-wave synthesis of harmonic amplitudes
*                                                                              
* Functions:      
*
*                                                                              
* Author/Date:    Rob Zopf   12/05/96
********************************************************************************
* Modifications:
*
*                                                                              
* Comments:                                                                    
* 
* Concerns:        
*
* $Header:   /export/phobos/pvcs/r_and_d/archives/realtime/decode/Sws.h_v   1.1   16 Feb 1998 12:22:50   bobd  $
*******************************************************************************/
#ifndef SWS_H
#define SWS_H

void VoxSws  (
          STACK_R
          void   *pSWS_mblk,
          float  *Amps,
          float  *Amps_1,
          float   Pitch,
          float   Pitch_1,
          float   Pv,
          float   Pv_1,
          short   frameLEN,
          short   nSubs,
          float  *outspeech
          );

unsigned short VoxInitSws(void **hSws);

unsigned short VoxFreeSws(void **hSws);

#endif /* SWS_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\svqphase.h ===
/******************************************************************************
*                        Voxware Proprietary Material
*                        Copyright 1996, Voxware, Inc
*                            All Rights Reserved
*
*                       DISTRIBUTION PROHIBITED without
*                      written authorization from Voxware
******************************************************************************/
 
/******************************************************************************
*
* Filename:        SVqPhase.c
*
* Purpose:         Pairwise vector quantization of the 10ms and 20ms phases.
*                  The 10ms and 20ms pitches are use to predict the 20ms phase
*                  from the 10ms phase. The measured 20ms phase and the
*                  predicted 20ms phase then form a pair that are
*                  vector-quantized. 
*
* Functions:     VoxSVQEncPhase, VoxSVQDecPhase, VoxEncPhasePrediction,
*                VoxDecPhasePrediction
*
* Author/Date:     Bob Dunn 4/18/97 and Bob McAulay 4/30/97
*
*******************************************************************************
*
* Modifications:   With Phase prediction to increase correlation
*                  Hard wired for a sub-vector length of 2 for speed
*
* Comments:    
*
* Concerns:
*
* $Header:   /export/phobos/pvcs/r_and_d/archives/scaleable/quan/SVqPhase.h_v   1.3   13 Apr 1998 16:17:56   weiwang  $
*
******************************************************************************/
#ifndef SVQPHASE_H
#define SVQPHASE_H


/******************************************************************************
*
* Function:  VoxSVQEncPhase
*
* Action:    Use this module to VQ pairwise predictive phase coding.
*
* Input:  pfPhaseErr --  phase errors
*         pfPhase    --  end-frame phases
*         piIndices -- pointer to the output indices
*
* Output: piIndices -- output quantization indices
*
* Globals:   none
*
* Return:    none
*******************************************************************************/
void VoxSVQEncPhase(float *pfPhase_Err, float *pfPhase, int *piIndices);


/******************************************************************************
*
* Function:  VoxSVQDecPhase
*
* Action:    Use this module to decode the phase pair
*
* Input:  piIndices -- quantization indices
*         pfPhase_Err -- pointers to predictive phase errors
*         pfPhase     -- pointer to the end-frame phases
*
* Output: pfPhase_Err -- predictive phase errors
*         pfPhase     -- the end-frame phases
*
* Globals:   none
*
* Return:    none
*******************************************************************************/
void VoxSVQDecPhase(const int *piIndices, float *pfPhase_Err, float *pfPhase);


/******************************************************************************
*
* Function:  VoxEncPhasePrediction
*
* Action:    Predict the 10ms phases and output the predictive error
*
* Input:  fPitch_Mid -- middle-frame pitch
*         fPitch     -- end-frame pitch
*         pfPhaseMid -- middle-frame phases
*         pfPhase    -- end-frame phases
*
* Output: pfPhaseMid -- predictive phase errors
*         pfPhase    -- end-frame phases
*
* Globals:   none
*
* Return:    none
*******************************************************************************/
void VoxEncPhasePrediction (float fPitch_Mid, float fPitch, 
                            float *pfPhaseMid, float *pfPhase);


/******************************************************************************
*
* Function: VoxDecPhasePrediction
*
* Action:  Estimate the 10ms phases from 20ms phases and 10ms predictive errors.
*
* Input:  fPitchMid -- middle-frame pitch
*         fPitch    -- end-frame pitch
*         pfPhaseMid -- predictive phase errors
*         pfPhase -- end-frame phases
*
* Output: pfPhaseMid -- middle-frame phases
*         pfPhase    -- end-frame phases
*
* Globals:   none
*
* Return:    none
*******************************************************************************/
void VoxDecPhasePrediction(float fPitchMid, float fPitch, 
                           float *pfPhaseMid, float *pfPhase);

#endif /* SVQPHASE_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\sws.c ===
/*******************************************************************************
*                        Voxware Proprietary Material                          *
*                        Copyright 1996, Voxware, Inc                          *
*                            All Rights Reserved                               *
*                                                                              *
*                       DISTRIBUTION PROHIBITED without                        *
*                      written authorization from Voxware                      *
*******************************************************************************/

/*******************************************************************************
* Filename:       Sws.c
*
* Purpose:        Sine-wave synthesis of harmonic amplitudes
*                                                                              
* Functions:      
*
*
* Author/Date:    Rob Zopf   12/05/96
********************************************************************************
* Modifications:
*
*                                                                              
* Comments:                                                                    
* 
* Concerns:        
*
* $Header:   /export/phobos/pvcs/r_and_d/archives/realtime/decode/Sws.c_v   1.4   20 Apr 1998 14:40:18   weiwang  $
*******************************************************************************/

#include <stdlib.h>
#include <math.h>
#include <string.h>
#include <limits.h>
#include <assert.h>

#include "VoxMem.h"
#include "model.h"
#include "research.h"

#include "vLibMath.h"   /* nuRand()    */
#include "vLibSgPr.h"   /* SpecIntLn() */
#include "vLibVec.h"    /* L2Scale()   */
#include "vLibFilt.h"   /* PP_NUM_SAMPLES */

#include "HarmSynF.h"
#include "GetnHarm.h"
#include "SumSyn.h"
#include "trig.h"

#include "Sws.h"

#include "xvocver.h"

#define UV_SUPPRESSION_FACTOR 0.5F /* 0.5F */

typedef struct tagSWS {
   float           PitchCycle[EXP_SIZE+PP_NUM_SAMPLES];/* scratch memory */
   float           fResampRate;
   float           fNormPhase;
   float           fVoicePhase;
   void*           pvSumSynBlk;
   long            lNrSeed;               /* seed for random number generator */
} SWS;

/*******************************************************************************
* Function:  Sws()
*
* Action:    Sine-wave synthesis of harmonic amplitudes for both voiced and 
*            unvoiced portions of the spectrum in a single step.
*
* Input:     Amps          - the current frame harmonic amplitudes
*            Amps_1        - the previous frame harmonic amplitudes
*            Pitch         - the current frame pitch lag (time-domain)
*            Pitch_1       - the previous frame pitch lag (time-domain)
*            Pv            - the current frame voicing probability
*            Pv_1          - the previous frame voicing probability
*            frameLEN      - the current frame length
*            nSubs         - the number of sumbframes for the current frame
*            outspeech     - pointer to a vector of length frameLEN for 
*                              synthesis
*
* Output: 
*            outspeech     - the synthesized speech         
*
*
* Globals:        none
*
* Return:
********************************************************************************
* Implementation/Detailed Description:
*
* References:
********************************************************************************
* Modifications:
*
* Comments:
*
* Concerns/TBD:
*******************************************************************************/
void VoxSws  (
          STACK_R
          void   *pSWS_mblk,
          float  *Amps,
          float  *Amps_1,
          float   Pitch,
          float   Pitch_1,
          float   Pv,
          float   Pv_1,
          short   frameLEN,
          short   nSubs,
          float  *outspeech
          ) 
{
   short     subframeLEN, overlap; 
   short     pitch_mult, subnHarm, subvHarm;
   int       sub,i,j;
   float     interp, subPv, subPitch;
   float     multPitch, subPitch_1, uv_energy_desired;
   SWS *SWS_mblk= (SWS *)pSWS_mblk;
   short     tempvHarm;

   STACK_INIT
   float     Spec_sub[MAXHARM];
   int       inPhase[MAXHARM];
   STACK_INIT_END

   STACK_ATTACH(float*,Spec_sub)
   STACK_ATTACH(int*,inPhase)

   STACK_START

   subframeLEN  = (short) (frameLEN/nSubs);
   overlap      = (short)(OVERLAPFACTOR*subframeLEN);
   subPitch_1   = Pitch_1;

   if ((overlap&1) == 1)
      overlap--;

   for (sub=0; sub < nSubs; sub++)
   {
      {
         STACK_INIT
         float     Spec_sub_1[MAXHARM];
         STACK_INIT_END
         STACK_ATTACH(float*,Spec_sub_1)

         STACK_START

         if ((Pv > 0.0) && (Pv_1 > 0.0))
         {
            interp = ((float)(sub+1))/((float)nSubs);
         }
         else
         {
            interp = (sub < (nSubs>>1))?0.0F:1.0F;
         }
       /*---------------------------------
          Don't interpolate Pv
         ---------------------------------*/
         subPv = (sub < (nSubs>>1))?Pv_1:Pv;

       /*----------------------------------------------
         Calculate the pitch for this subframe ...
         ----------------------------------------------*/
         if (fabs((Pitch-Pitch_1)/Pitch) < PITCH_RANGE_FOR_INTERP)
            subPitch  = Pitch_1 + interp*(Pitch-Pitch_1);
         else
            subPitch = (sub < (nSubs>>1))?Pitch_1:Pitch;
         
         if (subPitch > MAX_PITCH)
            subPitch = (float)MAX_PITCH;
         if (subPitch < MIN_PITCH)
            subPitch = (float)MIN_PITCH;

       /*-----------------------------------------------
         Calculate the highest multiple of the pitch that
         is still less than or equal to MAX_PITCH
         -----------------------------------------------*/
         pitch_mult = (short)(((float)MAX_PITCH_MULT)/subPitch);
         if (pitch_mult==0)
            pitch_mult=1;

         multPitch  = subPitch*((float)pitch_mult);

       /*---------------------------------------------------
         Calcuate the number of harmonics for multPitch, and
         the number of voiced harmonics.  The true number
         of voiced harmonics will be the largest even value
         less than or equal to the value calculated divided
         by pitch_mult (since this is what we multiplied the
         true voiced pitch by.
         ---------------------------------------------------*/
         tempvHarm = getvHarm(subPitch, subPv);
         subvHarm  = pitch_mult*tempvHarm;
         subnHarm  = getnHarm(multPitch);

         if (subnHarm > MAXHARM)
            subnHarm=MAXHARM;
         if (subvHarm > MAXHARM)
            subvHarm=MAXHARM;

         for (i=0; i < subvHarm; i++)
            inPhase[i] = 0;

       /*----------------------------------------------------
          Patent Breaking Magical 7 ...
         ----------------------------------------------------*/
         if (tempvHarm > 0)
            inPhase[(((tempvHarm>>1)+1)*pitch_mult)-1] = 7; 

       /*-----------------------------------------------
         Calculate the harmonic amplitudes at the 
         current subframe pitch value...
         -----------------------------------------------*/
         SpecIntLn(Pitch_1, multPitch, (const int) subnHarm, Amps_1, 
                   Spec_sub_1, (const unsigned int) MAXHARM);
         SpecIntLn(Pitch, multPitch, (const int) subnHarm, Amps, 
                   Spec_sub, (const unsigned int) MAXHARM);

         for (i=0; i < subnHarm; i++)
            Spec_sub[i] = Spec_sub_1[i] + 
            interp*(Spec_sub[i]-Spec_sub_1[i]);

         STACK_END
      }

    /*-----------------------------------------------
      Set the unwanted harmonics to zero ...
      -----------------------------------------------*/
      for (i=0; i < pitch_mult-1; i++)
      {
         for (j=i; j < subvHarm; j+=pitch_mult)
         {
            Spec_sub[j] = 0.0F;
         }
      }

    /*-----------------------------------------------
      Calculate the desired unvoiced energy ...
      -----------------------------------------------*/
      uv_energy_desired = 0.0F;
      for (i=subvHarm+pitch_mult-1; i < subnHarm; i+=pitch_mult)
      {
         uv_energy_desired += (Spec_sub[i])*(Spec_sub[i]);
      }
    /*------------------------------------------------
      Rescale the unvoiced energy ...
      ------------------------------------------------*/
      L2Scale(&(Spec_sub[subvHarm]), (int) (subnHarm-subvHarm), 
              uv_energy_desired*UV_SUPPRESSION_FACTOR);

    /*------------------------------------------------
      Randomize the unvoiced phase ...
      ------------------------------------------------*/
      for (i=subvHarm; i < subnHarm; i++)
      {
         inPhase[i] = (int)((NuRand(&(SWS_mblk->lNrSeed)))&(TRIG_SIZE-1));
      }

#if USE_FHT_SYN==1
      HarmSynFHTFloat(STACK_S Spec_sub, inPhase, multPitch, subPitch, 
         subPitch_1, &SWS_mblk->fNormPhase, &SWS_mblk->fVoicePhase,
         &SWS_mblk->fResampRate, subnHarm, SWS_mblk->PitchCycle, 
         &(outspeech[sub*subframeLEN]), subframeLEN, (short)(overlap));
#else
{
   float Phase[MAXHARM];

   for (i=0; i<subnHarm; i++)
      Phase[i] = ((float)inPhase[i])*D_PI*( 1.0/(TRIG_SIZE) );

      SumSyn(STACK_S SWS_mblk->pvSumSynBlk, Spec_sub, subPitch, subPitch_1, 
         Phase, multPitch, pitch_mult, subnHarm, subvHarm, subframeLEN, 
         (float)OVERLAPFACTOR, &(outspeech[sub*subframeLEN]));
}
#endif

      subPitch_1 = subPitch;
   }
   STACK_END

}

unsigned short VoxInitSws(void **hSws) 
{
   SWS *pSws;
   int i;

   if (VOX_MEM_INIT(pSws=*hSws, 1, sizeof(SWS))) 
      return 1;

   if(InitSumSyn(&pSws->pvSumSynBlk))
      return 1;

   /* initializing static variables */
   for (i=0; i < EXP_SIZE+PP_NUM_SAMPLES; i++) 
      pSws->PitchCycle[i] = 0.0F;

   pSws->fResampRate = 0.0F;
   pSws->fNormPhase  = 0.0F;
   pSws->fVoicePhase = 0.0F;

   pSws->lNrSeed = 1L;  /* initial seed for random number generator */

   return 0;
}

unsigned short VoxFreeSws(void **hSws)
{
   FreeSumSyn(&(((SWS *)(*hSws))->pvSumSynBlk));

   VOX_MEM_FREE(*hSws);

   return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\synspec.c ===
/*******************************************************************************
*                        Voxware Proprietary Material                          *
*                        Copyright 1996, Voxware, Inc                          *
*                            All Rights Reserved                               *
*                                                                              *
*                       DISTRIBUTION PROHIBITED without                        *
*                      written authorization from Voxware                      *
*******************************************************************************/

/*******************************************************************************
* Filename:       SynSpec.c
*
* Purpose:        Generate synthetic spectrum using SEEVOC peaks.
*                                                                   
* Functions: 
*
* Author/Date:
********************************************************************************
* Modifications:
*
* Comments:                                                                    
*
* Concerns:
*
* $Header:   G:/r_and_d/archives/realtime/encode/SynSpec.c_v   1.1   11 Mar 1998 13:33:52   weiwang  $
*******************************************************************************/
#include <assert.h>
#include <math.h>
#include "VoxMem.h"
#include "model.h"
#include "vLibMath.h"
#include "GetnHarm.h"
#include "SynSpec.h"

#include "xvocver.h"


/* spectrum window for pitch refinement -- center part (1024) of 16k point FFT of
   kaiser(221, 6) */
const float pWinR221[] =
{
#include "w576RT29.h"
};

const int iSpecTableLen = sizeof(pWinR221)/sizeof(float);

#define FABS(a)     (((float)a>0.0F)?(float)a:(float)-a)



/*
 * Function: calculate the error between the original spectrum and
 *           the synthetic spectrum.
 */
float CalcCmpxSpecErr(float fPitch, float *pSWR, float *pSWI, 
		      int uiWinLen, int iStartDFT, int iEndDFT)
{
  float F0, fBandWdth;
  int iHarmStart, iHarmEnd;
  float fTotalErr;
  int iLeftBound, iRightBound;
  float fAmpReal, fAmpImag;
  float fWin;
  int WinIndex;
  int i;
  int iHarm;
  float invF0;
  int iHarmF0;
  float *pWinSpecTab = (float *)pWinR221;
  long Fix_F0, Fix_fBandWdth;
  long Fix_fHarmF0;
  register float ftmp1, ftmp2;
  float ftmp;
  int iResampFactor;


  /*************************************************************
    calculate the resampling factor for synthesis spectrum 
	 ************************************************************/
  ftmp = SPEC_RESAMP_BASE*(float)(uiWinLen-1);
  VoxROUND2pos(ftmp, iResampFactor);

  /* adjust the resample factor */
  if (fPitch < (MIN_REFINE_PITCH+1))
    iResampFactor --;

  /* check the pitch range and reset ResampFactor */
  if (((float)iResampFactor * (float)NFFT_2) > (fPitch * (float)iSpecTableLen)) 
    iResampFactor = REFINE_SPEC_SCALE;


  /*************************************************************
    fundamental frequency in DFT domain 
    ************************************************************/
  F0 = (float)NFFT/fPitch;
  fBandWdth = F0 * 0.5F;

  ftmp = FIX_SCALE*F0;
  VoxROUND2posLong(ftmp, Fix_F0);
  ftmp = FIX_SCALE*fBandWdth;
  VoxROUND2posLong(ftmp, Fix_fBandWdth);

  /*************************************************************
    calculate the index of first harmonic and last harmonic 
    ************************************************************/
  assert(iStartDFT >= 0);
  assert(iEndDFT < NFFT_2);
  assert(iStartDFT < iEndDFT);
  invF0 = fPitch * INV_NFFT;
  ftmp = iStartDFT*invF0;
  VoxROUND2pos(ftmp, iHarmStart);

  ftmp = iEndDFT*invF0;
  VoxROUND2pos(ftmp, iHarmEnd);

  if (((iHarmEnd*Fix_F0+FIX_05)>>BIT_SHIFT) >= NFFT_2)
    iHarmEnd --;

  
  /*************************************************************
    Synthesis the spectrum and measure the errors between
    synthetic spectrum and original spectrum 
    ************************************************************/
  fTotalErr = MINCON;

  Fix_fHarmF0 = (long)(iHarmStart-1)*Fix_F0;
  iLeftBound = (int)((Fix_fHarmF0 + Fix_fBandWdth + FIX_05)>>BIT_SHIFT);


  if (iLeftBound < iStartDFT)
    iLeftBound = iStartDFT;


  for (iHarm = iHarmStart; iHarm <= iHarmEnd; iHarm++) {
    /* the center frequency of iHarm-th harmonic */
    Fix_fHarmF0 += Fix_F0;
    iRightBound = (int)((Fix_fHarmF0+Fix_fBandWdth+FIX_05)>>BIT_SHIFT);


    if (iRightBound > iEndDFT)
      iRightBound = iEndDFT;

    /* find the center amplitude */
    iHarmF0 = (int)((Fix_fHarmF0+FIX_05)>>BIT_SHIFT);

    assert(iHarmF0 < NFFT_2);

    fAmpReal = pSWR[iHarmF0];
    fAmpImag = pSWI[iHarmF0];

    /* synthesis the left part of one harmonic spectrum */
    WinIndex = -iResampFactor*iLeftBound;
    WinIndex+=(int)(((long)iResampFactor*((long)Fix_fHarmF0>>DOWN_SHIFT)
		     -(long)FIX_05_REFINE)>>REFINE_SHIFT);

    i = iLeftBound;
    while(WinIndex >= 0) {
      assert(WinIndex < iSpecTableLen && WinIndex >= 0);
      fWin = pWinSpecTab[WinIndex];
      ftmp1 = pSWR[i] - fAmpReal*fWin;
      ftmp2 = pSWI[i] - fAmpImag*fWin;
      fTotalErr += (float)FABS(ftmp1)+(float)FABS(ftmp2);
      i++;
      WinIndex -= iResampFactor;
    }

    /* synthesis the right part of one harmonic spectrum */
    WinIndex = -WinIndex;
    while (i < iRightBound) {
      assert(WinIndex < iSpecTableLen && WinIndex >= 0);
      fWin = pWinSpecTab[WinIndex];
      ftmp1 = pSWR[i] - fAmpReal*fWin;
      ftmp2 = pSWI[i] - fAmpImag*fWin;
      fTotalErr += (float)FABS(ftmp1)+(float)FABS(ftmp2);
      i++;
      WinIndex += iResampFactor;
    }

    /* save the rightBound as the leftBound for the next harmonic */
    iLeftBound = iRightBound;
  }

  return fTotalErr;
}


/*
 * Function: calculate the error between the original spectrum and
 *           the synthetic spectrum.
 */

int CalcBandErr(float fPitch, float *pSWR, float *pSWI,
		float *pPower, int uiWinLen, float *pBandErr)
{
  float F0, fBandWdth;
  int NHarm;
  int iLeftBound, iRightBound;
  float fAmpReal, fAmpImag;
  float fTotalErr, fTotalEng;
  int WinIndex;
  float fWin;
  int i;
  float fTmpSW, fTmpErr;
  int iHarm;
  int iHarmF0;
  float *pWinSpecTab = (float *)pWinR221;
  long Fix_F0, Fix_fBandWdth;
  long Fix_fHarmF0;
  float ftmp;
  int iResampFactor;


  /*************************************************************
    calculate the resampling factor for synthesis spectrum 
	 ************************************************************/
  ftmp = SPEC_RESAMP_BASE*(float)(uiWinLen-1);
  VoxROUND2pos(ftmp, iResampFactor);

  /* adjust the resample factor */
  if (fPitch < (MIN_REFINE_PITCH+1))
    iResampFactor --;

  /* check the pitch range and reset ResampFactor */
  if (((float)iResampFactor * (float)NFFT_2) > (fPitch * (float)iSpecTableLen)) 
    iResampFactor = REFINE_SPEC_SCALE;


  /*************************************************************
    fundamental frequency in DFT domain 
    ************************************************************/
  F0 = (float)NFFT/fPitch;
  fBandWdth = F0 * 0.5F;

  ftmp = FIX_SCALE*F0;
  VoxROUND2posLong(ftmp, Fix_F0);

  ftmp = FIX_SCALE*fBandWdth;
  VoxROUND2posLong(ftmp, Fix_fBandWdth);


  /*************************************************************
    calculate number of harmonics.
    ************************************************************/
  NHarm = getnHarm(fPitch);  

  /* make sure that number of harmonics won't out of range */
  if (NHarm > MAXHARM)    NHarm = MAXHARM;
  
  /*************************************************************
    Synthesis the spectrum and measure the errors between
    synthetic spectrum and original spectrum 
    ************************************************************/
  Fix_fHarmF0 = 0;

  iLeftBound = (int)((Fix_fHarmF0+Fix_fBandWdth+FIX_05)>>BIT_SHIFT);

  for (iHarm = 0; iHarm < NHarm; iHarm++) {
    /* the center frequency of iHarm-th harmonic */
    Fix_fHarmF0 += Fix_F0;         
    iRightBound = (int)((Fix_fHarmF0+Fix_fBandWdth+FIX_05)>>BIT_SHIFT);

    if (iRightBound >= NFFT_2)
      iRightBound = NFFT_2-1;

    /* find the center amplitude */
    iHarmF0 = (int)((Fix_fHarmF0+FIX_05)>>BIT_SHIFT);
    assert(iHarmF0 < NFFT_2);

    fAmpReal = pSWR[iHarmF0];
    fAmpImag = pSWI[iHarmF0];

    fTotalErr = MINCON;
    fTotalEng = MINCON;

    /* synthesis the left part of one harmonic spectrum */
    WinIndex = -iResampFactor*iLeftBound;
    WinIndex+=(int)(((long)iResampFactor*((long)Fix_fHarmF0>>DOWN_SHIFT)
		     -(long)FIX_05_REFINE)>>REFINE_SHIFT);
    i = iLeftBound;
    while(WinIndex >= 0) {
      assert(WinIndex < iSpecTableLen && WinIndex >= 0); 
      fWin = pWinSpecTab[WinIndex];

      fTmpSW = pSWR[i];
      fTmpErr = fTmpSW - fAmpReal*fWin;

      fTotalErr += fTmpErr*fTmpErr;

      fTmpSW = pSWI[i];
      fTmpErr = fTmpSW - fAmpImag*fWin;
      fTotalErr += fTmpErr*fTmpErr;
      fTotalEng += pPower[i];

      i++;
      WinIndex -= iResampFactor;
    }

    /* synthesis the right part of one harmonic spectrum */
    WinIndex = -WinIndex;
    while (i < iRightBound) {
      assert(WinIndex < iSpecTableLen && WinIndex >= 0); 
      fWin = pWinSpecTab[WinIndex];

      fWin = pWinSpecTab[WinIndex];
      fTmpSW = pSWR[i];
      fTmpErr = fTmpSW - fAmpReal*fWin;

      fTotalErr += fTmpErr*fTmpErr;
 
      fTmpSW = pSWI[i];
      fTmpErr = fTmpSW - fAmpImag*fWin;
      fTotalErr += fTmpErr*fTmpErr;
      fTotalEng += pPower[i];


      i++;
      WinIndex += iResampFactor;
    }

    /* save the rightBound as the leftBound for the next harmonic */
    iLeftBound = iRightBound;

    *pBandErr++ = fTotalErr/fTotalEng;
  }

  return NHarm;
}

int VoxSynSpecSeeVoc(float *pSWR, float *pSWI, float *pPower, int *iSeeVocFreq,
		     float fPitch, float *pBandErr, int uiWinLen)
{
  float F0, fBandWdth;
  int NHarm;
  int iLeftBound, iRightBound;
  float fAmpReal, fAmpImag;
  float fTotalErr, fTotalEng;
  int WinIndex;
  float fWin;
  int i;
  float fTmpSW, fTmpErr;
  int iHarm;
  int iHarmF0;
  int ResampFactor;
  float fHarmF0;
  int Ind_SV;
  int lastSVPeak;
  float ftmp;

  /*************************************************************
    calculate the resampling factor for synthesis spectrum 
	 ************************************************************/
  ftmp =  SPEC_RESAMP_BASE*(float)(uiWinLen-1);
  VoxROUND2pos(ftmp, ResampFactor);

  /* adjust the resample factor */
  if (fPitch < (MIN_REFINE_PITCH+1))
    ResampFactor --;

  /* check the pitch range and reset ResampFactor */
  if (((float)ResampFactor * (float)NFFT_2) > (fPitch * (float)iSpecTableLen)) 
    ResampFactor = REFINE_SPEC_SCALE;

  /*************************************************************
    fundamental frequency in DFT domain 
    ************************************************************/
  F0 = (float)NFFT/fPitch;
  fBandWdth = F0 * 0.5F;

  if (fBandWdth > (float)MAX_BANDWDTH)
    fBandWdth = (float)MAX_BANDWDTH;


  /*************************************************************
    calculate number of harmonics.
    ************************************************************/
  NHarm = getnHarm(fPitch);  

  /* make sure that number of harmonics won't out of range */
  if (NHarm > MAXHARM)    NHarm = MAXHARM;
  
  /*************************************************************
    Synthesis the spectrum and measure the errors between
    synthetic spectrum and original spectrum 
    ************************************************************/
  fHarmF0 = 0.0F;

  Ind_SV = 0;
  lastSVPeak = iSeeVocFreq[0];
  for (iHarm = 0; iHarm < NHarm; iHarm++) {
    /* the center frequency of iHarm-th harmonic */
	 fHarmF0 += F0;
	 ftmp = fHarmF0-fBandWdth;
	 VoxROUND2pos(ftmp, iLeftBound);
	 ftmp = fHarmF0 + fBandWdth;
	 VoxROUND2pos(ftmp, iRightBound);

    if (iRightBound >= NFFT_2)
      iRightBound = NFFT_2-1;

#ifdef SEEVOC_PEAK_ON

    while (fHarmF0 > iSeeVocFreq[Ind_SV]) {
      lastSVPeak = iSeeVocFreq[Ind_SV];
      Ind_SV++;
    }

    /* find the shortest distance of seevoc peaks */
    if ((iSeeVocFreq[Ind_SV]+lastSVPeak) > (fHarmF0+fHarmF0))
      iHarmF0 = lastSVPeak;
    else
      iHarmF0 = iSeeVocFreq[Ind_SV];

#else
	 /* find the center amplitude */
	 VoxROUND2pos(fHarmF0, iHarmF0);
#endif
    assert(iHarmF0 < NFFT_2);

    fAmpReal = pSWR[iHarmF0];
    fAmpImag = pSWI[iHarmF0];

    fTotalErr = MINCON;
    fTotalEng = MINCON;

	 /* synthesis the left part of one harmonic spectrum */
	 ftmp = ResampFactor * (fHarmF0-iLeftBound);
	 VoxROUND2pos(ftmp, WinIndex);
	 i = iLeftBound;
    while(WinIndex >= 0) {
      assert(WinIndex < iSpecTableLen && WinIndex >= 0); 
      fWin = pWinR221[WinIndex];

      fTmpSW = pSWR[i];
      fTmpErr = fTmpSW - fAmpReal*fWin;

      fTotalErr += fTmpErr*fTmpErr;

      fTmpSW = pSWI[i];
      fTmpErr = fTmpSW - fAmpImag*fWin;
      fTotalErr += fTmpErr*fTmpErr;
      fTotalEng += pPower[i];

      i++;
      WinIndex -= ResampFactor;
    }

    /* synthesis the right part of one harmonic spectrum */
    WinIndex = -WinIndex;
    while (i < iRightBound) {
      assert(WinIndex < iSpecTableLen && WinIndex >= 0); 
      fWin = pWinR221[WinIndex];

      fWin = pWinR221[WinIndex];
      fTmpSW = pSWR[i];
      fTmpErr = fTmpSW - fAmpReal*fWin;

      fTotalErr += fTmpErr*fTmpErr;

      fTmpSW = pSWI[i];
      fTmpErr = fTmpSW - fAmpImag*fWin;
      fTotalErr += fTmpErr*fTmpErr;
      fTotalEng += pPower[i];

      i++;
      WinIndex += ResampFactor;
    }

    *pBandErr++ = fTotalErr/fTotalEng;
  }

  return NHarm;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\testrt.c ===
/******************************************************************************
 *                                                                            *
 *                      Voxware Proprietary Material                          *
 *                      Copyright 1996, Voxware, Inc.                         *
 *                           All Rights Resrved                               *
 *                                                                            *
 *                     DISTRIBUTION PROHIBITED without                        *
 *                   written authorization from Voxware                       *
 *                                                                            *
 ******************************************************************************/

/******************************************************************************
 *                                                                            *
 * FILENAME:  testRT.c                                                        *
 * PURPOSE:   To demonstrate the use of the Voxware RT29 (+RT24), BC29 codec. *
 *                                                                            *
 * AUTHOR:    Epiphany Vera, Ilan Berci                                       *
 *                                                                            *
 * $Header:   P:/r_and_d/archives/realtime/testcode/testRT.c_v   1.11   23 Jul 1998 10:00:08   weiwang  $
 *****************************************************************************/

/** ************************************************************************ **/
/**                              Standard headers                            **/
/** ************************************************************************ **/
/* This section defines name changes and standard header files needed for the */
/* DSP Research Quick Start (QS) library. If compiling the code to run on a   */
/* DSP Research board that uses the QS library, then compile with the _QS     */
/* option turned on.                                                          */

/** ************************************************************************ **/
/**                              Standard headers                            **/
/** ************************************************************************ **/
#include <stdio.h>
#include <stdlib.h>
#include <stddef.h>
#include <string.h>
#include <math.h> 
#include <assert.h>
#include <ctype.h>

/* For every codec that you would like to include in the executable, */
#include "metatest.h"

/** ************************************************************************ **/
/**                    Voxware Core Interface Headers                        **/
/** ************************************************************************ **/
#include "vci.h" 
#include "vciError.h"
#include "vciPlus.h"
#if(RT24==1)      
#include "vciRT24.h"
#endif
#if(RT28==1) 
#include "vciRT28.h"
#endif
#if(RT29==1)      
#include "vciRT29.h"
#endif
#if(VR12==1) 
#include "vciVR12.h"
#include "vciPVR12.h"
#endif
#if(VR15==1) 
#include "vciVR15.h"
#include "vciPVR15.h"
#endif

#if(VFII==1) 
#include "vciVFII.h"
#endif

#if(RT24==1||RT24LD==1||RT28==1||RT29==1||RT29LD==1)
#include "vciPlsRT.h"    /* Voxware Core Interface Extension Manager Warping  */
#endif
#if(RT29==1)      
#include "PsQuan29.h"    /* Model Pseudo Quantization */
#endif

/** ************************************************************************ **/
/**                             Windows Specific                             **/
/** ************************************************************************ **/

#ifdef WIN32
#include "NspTimer.h"
#endif

/** ************************************************************************ **/
/**                            Macintosh Specific                            **/
/** ************************************************************************ **/

#define VOXWARE_MAC 0

#if (VOXWARE_MAC==1)
#include <console.h>
#endif

/** ************************************************************************ **/
/**                              Global Defines                              **/
/** ************************************************************************ **/

#ifdef WIN32
#define TIMER_NO   1
#define TEST_TIMES 5
#define MAX_FRAME_NO 6000
#endif

#define RATE8K 8000.0F

enum {VOICE_FONTS=0x02, PRINT=0x04, NUMBERS=0x08, WARP=0x10,
      BYTE_SWAP=0x20, DECODE=0x40, ENCODE=0x80, BENCH_MARK=0x100};

FILE *InFile, *OutFile, *VoxFileIn=NULL, *VoxFileOut=NULL; /* PCM files for both input and output. */

typedef struct tagCodecFuncPtrBlk {
   VCI_RETCODE (*pVciEncode)(void *hCodecMemBlk, VCI_CODEC_IO_BLOCK *hvciEncodeIOBlk);
   VCI_RETCODE (*pVciDecode)(void *hCodecMemBlk, VCI_CODEC_IO_BLOCK *hvciDecodeIOBlk);

   VCI_RETCODE (*pVciInitEncode)(void **hCodecMemBlk);
   VCI_RETCODE (*pVciInitDecode)(void **hCodecMemBlk);
                                                      
   VCI_RETCODE (*pVciFreeEncode)(void **hCodecMemBlk);
   VCI_RETCODE (*pVciFreeDecode)(void **hCodecMemBlk);

   VCI_RETCODE (*pVciSetWarpFactor)(void *hCodecMemBlk, float wWarpFactor);
   VCI_RETCODE (*pVciDecodeNeedsInput)(void *hCodecMemBlk, unsigned char *pUnPack);

   unsigned int numOfBits;
   unsigned int numOfBytes;
   unsigned int frameLen;
} CodecFuncPtrBlk; 

#ifdef WIN32
static float ENCODER_TIMER[MAX_FRAME_NO];
static float DECODER_TIMER[MAX_FRAME_NO];
#endif

/** ************************************************************************ **/
/**                           Private Funtion Defs                           **/
/** ************************************************************************ **/
void InitInOutDevices(int argc, char **argv, FILE **InFile, FILE **OutFile, unsigned int echo);
static unsigned short 
   CommandLineParse(int argc, char **argv, int* pNumOfFrames, CodecFuncPtrBlk* pCodecFuncPtrBlk);
static float setWarp(void);
void byteSwap(short *sound_buffer, unsigned int bufferSize);
static int bufToFile(unsigned char *pBuf, FILE *pFile, int bits, short last);
static int fileToCBuf(VCI_CODEC_IO_BLOCK *hvciIOBlk, FILE *pFile, int bytes);


/** ************************************************************************ **/
/**                              MAIN FUNCTION                               **/
/** ************************************************************************ **/

void RTmain(int argc, char** argv)  /* MSVC arg1: input.pcm  arg2: output.pcm */
{
   short done=0;                      /* Exit flag.                           */
   int frame=0;                      /* Frame counter.                       */
   void *hCodecMemblk1;               /* Handle to encoder instance of codec. */
   void *hCodecMemblk2;               /* Handle to decoder instance of codec. */
   unsigned short wCommandLineParse;  /* Parse the options from the com. line */
   int NumOfFrames=0;
   unsigned char wNeedsInputFlag=0;
   CodecFuncPtrBlk codecFuncPtrBlk;

   int currentBit = 0;
   double averageBitE = 0.0;
   int minBitE = 1000, maxBitE = 0;
   double averageBitD = 0.0;
   int minBitD = 1000, maxBitD = 0;
   int maxReadByte;
   int lastReadByteOffset = 0, lastReadBitOffset = 0;
#ifdef WIN32
    int EncoderPeakIndex=0, DecoderPeakIndex=0;
    float DecoderPeak=0.0, EncoderPeak=0.0;
    float DecoderAverage=0.0, EncoderAverage=0.0;
    float tempClock=0.0;
    unsigned int uiTestCount=0;
    int i;
#endif


   VCI_RETCODE wVciRetcode = VCI_NO_ERROR;

   VCI_CODEC_IO_BLOCK hvciEncodeIOBlk;    /* Encoder interface structure.     */
   VCI_CODEC_IO_BLOCK hvciDecodeIOBlk;    /* Decoder interface structure.     */


#if VFII == 1
   void *pFontChunkMemBlk = NULL;
   short FontSlection     = 10;
#endif

#if (VOXWARE_MAC==1)
/*     argc = ccommand(&argv);*/

#endif

#ifdef WIN32
   do {
#endif
      /* Parse the rest of the command line */
      wCommandLineParse=CommandLineParse(argc, argv, &NumOfFrames, 
                                         &codecFuncPtrBlk);

      maxReadByte = codecFuncPtrBlk.numOfBits/8;
      if (8*maxReadByte < (int)codecFuncPtrBlk.numOfBits)
	maxReadByte ++;

      hvciEncodeIOBlk.wVoxBufferSize = (short)(maxReadByte + 2);
      hvciDecodeIOBlk.wVoxBufferSize = hvciEncodeIOBlk.wVoxBufferSize;

      done=0;
      frame=0;

      /* Initialize an instance of the codec as an encoder. */
      if(ENCODE&wCommandLineParse) {  
         if(!(hvciEncodeIOBlk.pPCMBuffer
            =calloc(codecFuncPtrBlk.frameLen,sizeof(short)))) 
         {
            printf("\nFailed to allocated memory! .. exiting");
            exit(1);
         }
         if(!(hvciEncodeIOBlk.pVoxBuffer=calloc(hvciEncodeIOBlk.wVoxBufferSize,
                                        sizeof(unsigned char)))) 
         {
            printf("\nFailed to allocated memory! .. exiting");
            exit(1);
         }
         if(PRINT&wCommandLineParse)
            printf("\n\nInitializing: Encoder.\n");
         if(codecFuncPtrBlk.pVciInitEncode(&hCodecMemblk1)) 
          {
            printf ("Memory Allocation error.\n");
            printf ("Failed to intitialize memory for encoder instance. \n");
            exit(1);
          }
         hvciEncodeIOBlk.wVoxBufferReadByteOffset  = 0;
         hvciEncodeIOBlk.chVoxBufferReadBitOffset  = 0;
         hvciEncodeIOBlk.wVoxBufferWriteByteOffset = 0;
         hvciEncodeIOBlk.chVoxBufferWriteBitOffset = 0;
      }
      
      /* Initialize an instance of the codec as a decoder. */
      if(DECODE&wCommandLineParse) {
         if(!(hvciDecodeIOBlk.pPCMBuffer=calloc(codecFuncPtrBlk.frameLen,sizeof(short))))
         {
            printf("\nFailed to allocated memory! .. exiting");
            exit(1);
         }
         if(!(hvciDecodeIOBlk.pVoxBuffer=calloc(hvciDecodeIOBlk.wVoxBufferSize, 
                                                sizeof(unsigned char)))) 
         {
            printf("\nFailed to allocated memory! .. exiting");
            exit(1);
         }
         if(PRINT&wCommandLineParse)
             printf("Initializing: Decoder.\n");
         if(codecFuncPtrBlk.pVciInitDecode(&hCodecMemblk2)) {
            printf ("Memory Allocation error.\n");
            printf ("Failed to intitialize memory for decoder instance. \n");
            codecFuncPtrBlk.pVciFreeEncode(&hCodecMemblk1); /* woops! time to free encoder and leave! */
            exit(1);
         }

         hvciDecodeIOBlk.wVoxBufferReadByteOffset = 0;
         hvciDecodeIOBlk.chVoxBufferReadBitOffset = 0;
         hvciDecodeIOBlk.wVoxBufferWriteByteOffset = 0;
         hvciDecodeIOBlk.chVoxBufferWriteBitOffset = 0;
      }

#if (VFII==1)
      if(VOICE_FONTS&wCommandLineParse) {
        if(vciEnableVoiceFontsVFII(hCodecMemblk1))  {
           printf("Failed to initialize memory for vciEnableVoiceFontsVFII routine. \n");
           exit(1);
         }
         if(vciEnableVoiceFontsVFII(hCodecMemblk2)) {
           printf ("Failed to intitialize memory for voice font instance. \n");
           exit(1);
         } 
         if(vciGetVoiceFontChunkVFII(FontSlection ,&pFontChunkMemBlk)) {
           printf ("Failed to intitialize memory for voice font chunk. \n");
           exit(1);
         } 
         if(vciSetVoiceFontVFII(hCodecMemblk1,pFontChunkMemBlk)) {
           printf ("Failed to set voice font for encode. \n");
           exit(1);
         } 
         if(vciSetVoiceFontVFII(hCodecMemblk2,pFontChunkMemBlk)) {
           printf ("Failed to set voice font for decode. \n");
           exit(1);
         } 
       }
#endif /* (VFII==1) */
     
      /** ****************************************************************** **/
      /**                       Encode-Decode Loop                           **/
      /** ****************************************************************** **/
      /* This loop reads input from some input device, compresses it, passes  */
      /* the output bit-stream to the decoder, the decoder decodes it and     */
      /* writes its PCM output to the output device.                          */

      if(PRINT&wCommandLineParse && ENCODE&wCommandLineParse)  
	printf(" Encoding ... \n");

      if(PRINT&wCommandLineParse && DECODE&wCommandLineParse)  
	printf(" Decoding ... \n");

      while(!done&&(frame<NumOfFrames||NumOfFrames==0)) {
         if(NUMBERS&wCommandLineParse && PRINT&wCommandLineParse)
            printf("\nframe: %d : ",frame);

         if(ENCODE&wCommandLineParse) {
            /* This implementation uses the VoxBuffer as a simple/linear      */
            /* buffer. Thus after reading the encoder output, we have to      */
            /* reset the write offsets for the encoder VoxBuffer to zero.     */
            /* This way the encoder always writes from the beginning of the   */
            /* buffer.                                                        */
            hvciEncodeIOBlk.wVoxBufferWriteByteOffset = 0;
            hvciEncodeIOBlk.chVoxBufferWriteBitOffset = 0;

            /* Get a frame of speech speech for compressing                   */
            if(NUMBERS&wCommandLineParse && PRINT&wCommandLineParse)
               printf(" Reading ...");

            memset(hvciEncodeIOBlk.pPCMBuffer, 0, 
                   sizeof(short)*codecFuncPtrBlk.frameLen);
            if(fread(hvciEncodeIOBlk.pPCMBuffer, sizeof(short), 
               codecFuncPtrBlk.frameLen, InFile)!= codecFuncPtrBlk.frameLen)
               done=1;

            if(BYTE_SWAP&wCommandLineParse)
               byteSwap(hvciEncodeIOBlk.pPCMBuffer, codecFuncPtrBlk.frameLen);

	    /* clean Vox buffer */
	    memset(hvciEncodeIOBlk.pVoxBuffer, 0, hvciEncodeIOBlk.wVoxBufferSize
		   *sizeof(unsigned char));

            /** ************************************************************ **/
            /**                            Encode                            **/
            /** ************************************************************ **/
            if((NUMBERS&wCommandLineParse) && (PRINT&wCommandLineParse))
               printf(" Encoding ...");

               if(BENCH_MARK&wCommandLineParse) {
               /*** start TIMER for ENCODE**/
#ifdef WIN32
                tstTimerStart(TIMER_NO);
#endif
            }
               wVciRetcode = codecFuncPtrBlk.pVciEncode(hCodecMemblk1, &hvciEncodeIOBlk);

               if(BENCH_MARK&wCommandLineParse) {
            /*** stop TIMER for ENCODE ***/
#ifdef WIN32
                tstTimerStop(TIMER_NO);
                 tempClock = tstTimerSec(TIMER_NO);

                   if((tempClock < ENCODER_TIMER[frame] || uiTestCount==0)&&frame<MAX_FRAME_NO)
                        ENCODER_TIMER[frame] = tempClock;
#endif
            }

            if(wVciRetcode) {
               printf("\nEncoder error : %d", wVciRetcode);
               printf("\nIoBlk:");
               printf("\n   Read bit offset: %d", 
                      hvciEncodeIOBlk.chVoxBufferReadBitOffset);
               exit(1);
            }

            currentBit = (int)(hvciEncodeIOBlk.wVoxBufferWriteByteOffset)*8
	                 + (int)hvciEncodeIOBlk.chVoxBufferWriteBitOffset; 
            if (currentBit < minBitE)
               minBitE = currentBit;
            if (currentBit > maxBitE)
               maxBitE = currentBit;
            averageBitE += (double)currentBit;

            if (NUMBERS&wCommandLineParse && PRINT&wCommandLineParse)
               printf("Current Bit = %d\n", currentBit);

            if(VoxFileOut) {
               if(bufToFile(hvciEncodeIOBlk.pVoxBuffer, VoxFileOut, currentBit, done)) 
                  done=1;
	    }
         }

         if(DECODE&wCommandLineParse) {
            if(VoxFileIn) {
               if(fileToCBuf(&hvciDecodeIOBlk, VoxFileIn, maxReadByte))  
                  done=1;
            } else {
               memcpy(hvciDecodeIOBlk.pVoxBuffer, hvciEncodeIOBlk.pVoxBuffer, 
                  hvciDecodeIOBlk.wVoxBufferSize);

	       /* In this example, the decoder VoxBuffer is also used as a simple/linear */
	       /* buffer. Thus the decoder must always read from the beggining of the    */
	       /* buffer.                                                                */
	       hvciDecodeIOBlk.wVoxBufferReadByteOffset  = 0;
	       hvciDecodeIOBlk.chVoxBufferReadBitOffset  = 0;

               hvciDecodeIOBlk.chVoxBufferWriteBitOffset=hvciEncodeIOBlk.chVoxBufferWriteBitOffset;
               hvciDecodeIOBlk.wVoxBufferWriteByteOffset=hvciEncodeIOBlk.wVoxBufferWriteByteOffset;
            }

            /** ************************************************************ **/
            /**                            Decode                            **/
            /** ************************************************************ **/
            if(WARP&wCommandLineParse)
               codecFuncPtrBlk.pVciSetWarpFactor(hCodecMemblk2, setWarp());
            else
               codecFuncPtrBlk.pVciSetWarpFactor(hCodecMemblk2, 1.0F);

            do {
 	       if(NUMBERS&wCommandLineParse && PRINT&wCommandLineParse)
                   printf(" Decoding ...");

               if(BENCH_MARK&wCommandLineParse) {
               /** start TIMER for DECODER **/
#ifdef WIN32
                  tstTimerStart(TIMER_NO);
#endif
               }
               wVciRetcode = codecFuncPtrBlk.pVciDecode(hCodecMemblk2, &hvciDecodeIOBlk);

               if(BENCH_MARK&wCommandLineParse) {
                  /** stop TIMER for DECODER **/
#ifdef WIN32
                  tstTimerStop(TIMER_NO);
                  tempClock = tstTimerSec(TIMER_NO);

                  if((tempClock < DECODER_TIMER[frame] || uiTestCount==0)&&frame<MAX_FRAME_NO)
                    DECODER_TIMER[frame] = tempClock;
#endif
               }

               if(wVciRetcode) {
                  printf("\nDecoder error : %d", wVciRetcode);
                  exit(1);
               }

               /* If warping is turned off, the decoder always outputs 180    */
               /* samples, where 180 is the number of samples per frame. If   */
               /* warping is less than 1.0, i.e. during speedup, the number   */
               /* of output samples is variable and is sometimes zero.        */
               if(hvciDecodeIOBlk.wSamplesInPCMBuffer) { 
                  /* If the number of samples is non-zero, write to output.   */
                  if(NUMBERS&wCommandLineParse && PRINT&wCommandLineParse)
		     printf(" Writing ");
                  if(BYTE_SWAP&wCommandLineParse)
                     byteSwap(hvciDecodeIOBlk.pPCMBuffer, codecFuncPtrBlk.frameLen);
                  fwrite(hvciDecodeIOBlk.pPCMBuffer, sizeof(short), 
                         hvciDecodeIOBlk.wSamplesInPCMBuffer, OutFile);
               }
               codecFuncPtrBlk.pVciDecodeNeedsInput(hCodecMemblk2,&wNeedsInputFlag);
            }while(!wNeedsInputFlag); 
            /* If warping is greater than 1.0, i.e. during slow-down, there   */
            /* are cases whereby the decoder does not need to take input in   */
            /* order to give output. The while loop above makes sure that all */
            /* the output the decoder has is read before the decoder is given */
            /* more input.                                                    */

	    /* write out the frame bits */
            currentBit = (int)(hvciDecodeIOBlk.wVoxBufferReadByteOffset)*8
                  + (int)hvciDecodeIOBlk.chVoxBufferReadBitOffset 
                  - (int)(lastReadByteOffset*8) - (int)lastReadBitOffset;

            if (currentBit < 0)
                currentBit += (hvciDecodeIOBlk.wVoxBufferSize*8);
		
            if (currentBit < minBitD)
                minBitD = currentBit;
            if (currentBit > maxBitD)
                maxBitD = currentBit;
            averageBitD += (double)currentBit;

            if (NUMBERS&wCommandLineParse && PRINT&wCommandLineParse) {
               printf("Current Bit = %d\n", currentBit);
            }

            if (VoxFileIn) {
	      lastReadByteOffset = hvciDecodeIOBlk.wVoxBufferReadByteOffset;
      	      lastReadBitOffset = hvciDecodeIOBlk.chVoxBufferReadBitOffset;
	    }


         } /* end of 'if (DECODE&wCommandLineParse) '*/
         frame++; 
      } /* while(!done) */

       /* VoiceFonts */
#if (VFII==1)
       if(VOICE_FONTS&wCommandLineParse) {
       vciDisableVoiceFontsVFII(hCodecMemblk1);
       vciDisableVoiceFontsVFII(hCodecMemblk2);
       vciFreeVoiceFontChunkVFII(pFontChunkMemBlk);
       }
#endif /* (VFII==1) */
     
      if(ENCODE&wCommandLineParse) {
	if(PRINT&wCommandLineParse) {
            printf("\nFreeing Encoder ");

	    averageBitE /= (double)frame;

     	    printf("\naverage bps = %.2f\nminimum bps = %.2f\nmaximum bps = %.2f\n", 
		 averageBitE*RATE8K/(float)codecFuncPtrBlk.frameLen, 
		 (float)minBitE*RATE8K/(float)codecFuncPtrBlk.frameLen, 
		 (float)maxBitE*RATE8K/(float)codecFuncPtrBlk.frameLen);
	}

         codecFuncPtrBlk.pVciFreeEncode(&hCodecMemblk1); 
         free(hvciEncodeIOBlk.pPCMBuffer);
         free(hvciEncodeIOBlk.pVoxBuffer);
      }
  
      if(DECODE&wCommandLineParse) {
	if(PRINT&wCommandLineParse) {
          printf("\nFreeing Decoder ");

          averageBitD /= (double)frame;

	  printf("\naverage bps = %.2f\nminimum bps = %.2f\nmaximum bps = %.2f\n", 
		 averageBitD*RATE8K/(float)codecFuncPtrBlk.frameLen,
		 (float)minBitD*RATE8K/(float)codecFuncPtrBlk.frameLen,
		 (float)maxBitD*RATE8K/(float)codecFuncPtrBlk.frameLen);
	}

         codecFuncPtrBlk.pVciFreeDecode(&hCodecMemblk2);
         free(hvciDecodeIOBlk.pPCMBuffer);
         free(hvciDecodeIOBlk.pVoxBuffer);
      }

      if(InFile)
         fclose(InFile);
      if(OutFile)
         fclose(OutFile);

      if(VoxFileIn)
         fclose(VoxFileIn);
      if(VoxFileOut)
         fclose(VoxFileOut);

#ifdef WIN32
   } while(!(!(BENCH_MARK&wCommandLineParse) || (++uiTestCount>=TEST_TIMES)));
#endif

#ifdef WIN32
   if(BENCH_MARK&wCommandLineParse) {
        frame=(frame>MAX_FRAME_NO)?MAX_FRAME_NO:frame;
        for(i=1;i<frame;i++) {
            if(ENCODER_TIMER[i]>EncoderPeak)
            {
                EncoderPeak = ENCODER_TIMER[i];
                EncoderPeakIndex = i;
            }
            if(DECODER_TIMER[i]>DecoderPeak)
            {
                DecoderPeak = DECODER_TIMER[i];
                DecoderPeakIndex = i;
            }

          EncoderAverage += ENCODER_TIMER[i];
          DecoderAverage += DECODER_TIMER[i];
        }

        EncoderAverage/= ((frame)*(float)codecFuncPtrBlk.frameLen/RATE8K);
        DecoderAverage/= ((frame)*(float)codecFuncPtrBlk.frameLen/RATE8K);
        EncoderPeak /=(float)codecFuncPtrBlk.frameLen/RATE8K;
        DecoderPeak /=(float)codecFuncPtrBlk.frameLen/RATE8K;
  
        printf("\n\nEncodeAverage CPU time: %.1f", EncoderAverage*100);
        printf("\nEncodePeak    CPU time: %.1f", EncoderPeak*100);
        printf("\nEncoder Peak Index %d", EncoderPeakIndex);

        printf("\n\nDecodeAverage CPU time: %.1f", DecoderAverage*100);
        printf("\nDecodePeak    CPU time: %.1f", DecoderPeak*100);
        printf("\nDecoder Peak Index %d\n", DecoderPeakIndex);
    }
   printf("\n");
#else
   printf("Finished!\n");
#endif

  return;
}


/** ************************************************************************ **/
/**                                                                          **/
/** FUNCTION: CommandLineParse()                                             **/
/** PURPOSE : Parses the command line                                        **/
/**                                                                          **/
/** ************************************************************************ **/
static unsigned short CommandLineParse(int argc, char **argv, int* pNumOfFrames, 
                                       CodecFuncPtrBlk* pCodecFuncPtrBlk)
{
   unsigned short i=0; 
   unsigned short wComLineParse=0;
   unsigned char wordSet;
   char *pParse;
   char *pVoxFileName=NULL;
   char *pCodecType="";
   unsigned char fileCount=0, codecSet=0;
   VCI_CODEC_INFO_BLOCK vciInfoBlk;

   while(++i<argc)
   {
      pParse=argv[i];
      if(*pParse!='-')
         continue;
      wordSet=0;
      while(*++pParse&&!wordSet)
      {
         switch(*pParse) 
         {
            case 'C':
            case 'c':
               if(!(*++pParse)) {
                  i++;
                  pParse=argv[i];
               }
               pCodecType=pParse;
               wordSet=1;
               break;

            case 'I':
            case 'i':
               wComLineParse|=ENCODE;
               if(!(*++pParse)) {
                  i++;
                  pParse=argv[i];
               }
               if(!(InFile = fopen(pParse, "rb"))) {
                  printf("Cannot open %s\n", pParse);
                  exit(1);
               } else 
                  fileCount++;
               wordSet=1;
               break;

            case 'O':
            case 'o':
               wComLineParse|=DECODE;
               if(!(*++pParse)) {
                  i++;
                  pParse=argv[i];
               }
               if(!(OutFile = fopen(pParse, "wb"))) {
                  printf("Cannot open %s\n", pParse);
                  exit(1);
               } else
                  fileCount++;
               wordSet=1;
               break;

            case 'V':
            case 'v':
               if(!(*++pParse)) {
                  i++;
                  pParse=argv[i];
               }
               pVoxFileName=pParse;
               fileCount++;
               wordSet=1;
               break;

            case 'F':
            case 'f':
               wComLineParse|=VOICE_FONTS;                       
               break;

            case 'P':
            case 'p':
               wComLineParse|=PRINT;
               break;

            case 'N':
            case 'n':
               wComLineParse|=NUMBERS;
               break;

            case 'W':
            case 'w':
               wComLineParse|=WARP;
               break;

            case 'B':
            case 'b':
               wComLineParse|=BYTE_SWAP;
               break;


            case 'T':
            case 't':
               wComLineParse|=BENCH_MARK;
               break;

            case 'H':
            case 'h':

               printf("\nUsage: %s <-iInfile> [-vVoxfile] <-oOutfile> [-Options]\n", argv[0]);
               printf("       %s <-vVoxfile> <-oOutfile> [-Options]\n", argv[0]);
               printf("       %s <-iInfile> <-vVoxfile> [-Options]\n\n",argv[0]);
               printf("Options:\n");

               printf("        -c      codec type (RT29/RT24/RT28/RT29LD/RT24LD/VR12/VR15) \n");
               printf("        -i      precedes input file (raw) \n");
               printf("        -o      precedes output file (raw) \n");
               printf("        -v      precedes raw vox file    \n\n");
               printf("        -f      voice fonts  \n");
               printf("        -#      number of frames to run \n");
               printf("        -p      print out codec operations \n");
               printf("        -n      print out frame numbers \n");
               printf("        -b      byte swap the data\n");
               printf("        -w      turn on the warping test \n");
               printf("        -t      bench mark test \n");

               if(InFile) 
                  fclose(InFile);
               if(OutFile)
                  fclose(OutFile);
               exit(1);
               break;

            default:
               if(isdigit(*pParse)) {
                  *pNumOfFrames=atoi(pParse);
                  wordSet=1;
               }
               else {
                  printf("\nUnrecognized command line argument: %c",*pParse);
                  printf("\nType -h for help\n");
                  exit(1);
               }
         }
      }
   }
   if(fileCount<2) {
      printf("\nNot enough files in command line");
      printf("\nRun program with -h for help");
      exit(1);
   }

   if(pVoxFileName)
   {
      if(ENCODE&wComLineParse) {
         if(!(VoxFileOut= fopen(pVoxFileName, "wb"))) {
            printf("Cannot open %s\n", pVoxFileName);
            exit(1);
         }
      }
      if(DECODE&wComLineParse) {
	if (VoxFileOut == NULL) {
	  /* Cannot read vox file for variable codec! */
         if(!(VoxFileIn = fopen(pVoxFileName, "rb+"))) {
            printf("Cannot open %s\n", pVoxFileName);
            exit(1);
         }
	}
      }
   }
#if(RT24==1) 
   if(!strcmp(pCodecType,"RT24")) {
      pCodecFuncPtrBlk->pVciDecode    = vciDecodeRT24;
      pCodecFuncPtrBlk->pVciEncode    = vciEncodeRT24;
      pCodecFuncPtrBlk->pVciInitEncode= vciInitEncodeRT24;
      pCodecFuncPtrBlk->pVciInitDecode= vciInitDecodeRT24;
      pCodecFuncPtrBlk->pVciFreeEncode= vciFreeEncodeRT24; 
      pCodecFuncPtrBlk->pVciFreeDecode= vciFreeDecodeRT24;
      vciGetInfoRT24(&vciInfoBlk);
      pCodecFuncPtrBlk->numOfBits     = (int)vciInfoBlk.dwMaxPacketBits;
      pCodecFuncPtrBlk->frameLen      = vciInfoBlk.wNumSamplesPerFrame;
      pCodecFuncPtrBlk->pVciSetWarpFactor=vciSetWarpFactorRT;
      pCodecFuncPtrBlk->pVciDecodeNeedsInput=vciDecodeNeedsInputRT;
      codecSet=1;
   }
#endif
#if(RT28==1)
   if(!strcmp(pCodecType,"RT28")) {
      pCodecFuncPtrBlk->pVciDecode    = vciDecodeRT28;
      pCodecFuncPtrBlk->pVciEncode    = vciEncodeRT28;
      pCodecFuncPtrBlk->pVciInitEncode= vciInitEncodeRT28;
      pCodecFuncPtrBlk->pVciInitDecode= vciInitDecodeRT28;
      pCodecFuncPtrBlk->pVciFreeEncode= vciFreeEncodeRT28;
      pCodecFuncPtrBlk->pVciFreeDecode= vciFreeDecodeRT28;
      vciGetInfoRT28(&vciInfoBlk);
      pCodecFuncPtrBlk->numOfBits     = (int)vciInfoBlk.dwMaxPacketBits;
      pCodecFuncPtrBlk->frameLen      = vciInfoBlk.wNumSamplesPerFrame;
      pCodecFuncPtrBlk->pVciSetWarpFactor=vciSetWarpFactorRT;
      pCodecFuncPtrBlk->pVciDecodeNeedsInput=vciDecodeNeedsInputRT;
      codecSet=1;
   }
#endif
#if(VR12==1)
   if(!strcmp(pCodecType,"VR12")) {
      pCodecFuncPtrBlk->pVciDecode    = vciDecodeVR12;
      pCodecFuncPtrBlk->pVciEncode    = vciEncodeVR12;
      pCodecFuncPtrBlk->pVciInitEncode= vciInitEncodeVR12;
      pCodecFuncPtrBlk->pVciInitDecode= vciInitDecodeVR12;
      pCodecFuncPtrBlk->pVciFreeEncode= vciFreeEncodeVR12;
      pCodecFuncPtrBlk->pVciFreeDecode= vciFreeDecodeVR12;
      vciGetInfoVR12(&vciInfoBlk);
        pCodecFuncPtrBlk->numOfBits     = (int)vciInfoBlk.dwMaxPacketBits;
      pCodecFuncPtrBlk->frameLen      = vciInfoBlk.wNumSamplesPerFrame;
      pCodecFuncPtrBlk->pVciSetWarpFactor=vciSetWarpFactorVR12;
      pCodecFuncPtrBlk->pVciDecodeNeedsInput=vciDecodeNeedsInputVR12;
      codecSet=1;
   }
#endif
#if(VR15==1)
   if(!strcmp(pCodecType,"VR15")) {
      pCodecFuncPtrBlk->pVciDecode    = vciDecodeVR15;
      pCodecFuncPtrBlk->pVciEncode    = vciEncodeVR15;
      pCodecFuncPtrBlk->pVciInitEncode= vciInitEncodeVR15;
      pCodecFuncPtrBlk->pVciInitDecode= vciInitDecodeVR15;
      pCodecFuncPtrBlk->pVciFreeEncode= vciFreeEncodeVR15;
      pCodecFuncPtrBlk->pVciFreeDecode= vciFreeDecodeVR15;
      vciGetInfoVR15(&vciInfoBlk);
        pCodecFuncPtrBlk->numOfBits     = (int)vciInfoBlk.dwMaxPacketBits;
      pCodecFuncPtrBlk->frameLen      = vciInfoBlk.wNumSamplesPerFrame;
      pCodecFuncPtrBlk->pVciSetWarpFactor=vciSetWarpFactorVR15;
      pCodecFuncPtrBlk->pVciDecodeNeedsInput=vciDecodeNeedsInputVR15;
      codecSet=1;
   }
#endif
#if(RT29==1) /* default codec is the RT29 */
   if(!codecSet) { 
      pCodecFuncPtrBlk->pVciDecode    = vciDecodeRT29;
      pCodecFuncPtrBlk->pVciEncode    = vciEncodeRT29;
      pCodecFuncPtrBlk->pVciInitEncode= vciInitEncodeRT29;
      pCodecFuncPtrBlk->pVciInitDecode= vciInitDecodeRT29;
      pCodecFuncPtrBlk->pVciFreeEncode= vciFreeEncodeRT29; 
      pCodecFuncPtrBlk->pVciFreeDecode= vciFreeDecodeRT29;
      vciGetInfoRT29(&vciInfoBlk);
      pCodecFuncPtrBlk->numOfBits     = (int)vciInfoBlk.dwMaxPacketBits;
      pCodecFuncPtrBlk->frameLen      = vciInfoBlk.wNumSamplesPerFrame;
      pCodecFuncPtrBlk->pVciSetWarpFactor=vciSetWarpFactorRT;
      pCodecFuncPtrBlk->pVciDecodeNeedsInput=vciDecodeNeedsInputRT;
      codecSet=1;
   }
#endif
   pCodecFuncPtrBlk->numOfBytes=pCodecFuncPtrBlk->numOfBits/8;
   if(pCodecFuncPtrBlk->numOfBits%8)
      pCodecFuncPtrBlk->numOfBytes++;

   if(!codecSet) {
      printf("\nCodec type not specified and RT29 (Default is not available)\n");
      exit(1);
   }
   return wComLineParse;
}

float setWarp(void)
{
   static float step = 0.0F;
   float warp=1.0F;
   float temp;
   float inc;

   temp = (float)(2.0*sin(step));
   if (temp > 1.5)
      inc = 0.007F;
   else if (temp > 0.5)
      inc = 0.005F;
   else if (temp > -0.5)
      inc = 0.001F;
   else if (temp > -1.5)
      inc = 0.002F;
   else
      inc = 0.007F;

   step+=inc;
   if (temp < 0.0F)
   {
      temp = -(temp-1.0F);
      temp = 1.0F/temp;
   }
   else
      temp+=1.0F;

   return(warp*=temp);
}

void byteSwap(short *sound_buffer, unsigned int bufferSize)
{
    unsigned int i;
    
    unsigned short thisSample;

    for(i = 0; i < bufferSize; i++)
    {
        thisSample = sound_buffer[i];
        thisSample = (((thisSample)>>8)|((thisSample)<<8));
        sound_buffer[i] = thisSample;

    }
}



static int bufToFile(unsigned char *pBuf, FILE *pFile, int bits, short last)
{ 
   static unsigned char wordToWrite  = 0;
   static int  bitsLeftOver = 0;
   int writeFail=0;

   for(bits+=bitsLeftOver;bits>8;bits-=8,pBuf++) {
      wordToWrite|=(*pBuf<<bitsLeftOver)&0xFF;
      if(!fwrite(&wordToWrite,sizeof(unsigned char),1,pFile)) {
         writeFail=1;
         break;
      }
      wordToWrite= (unsigned char)((*pBuf>>(8-bitsLeftOver))&0xFF);
   }

   if (bits > bitsLeftOver)
     wordToWrite|=(*pBuf<<bitsLeftOver)&0xFF;

   bitsLeftOver=bits;
   wordToWrite= (unsigned char) ((wordToWrite<<(8-bitsLeftOver))>>(8-bitsLeftOver));

   if (last == 1 && bitsLeftOver > 0) {
     if(!fwrite(&wordToWrite,sizeof(unsigned char),1,pFile))
       writeFail=1;
   }
   return writeFail;
}


/* file to circular buffer */
static int fileToCBuf(VCI_CODEC_IO_BLOCK *hvciIOBlk, FILE *pFile, int bytes)
{
   int endOfFile=0;
   int leftOverByte;
   unsigned char wordToRead;

   /* write bit offset should be always 0 */
   hvciIOBlk->chVoxBufferWriteBitOffset = 0; 

   /* find out how many bytes leftOver */
   if (hvciIOBlk->wVoxBufferWriteByteOffset >= hvciIOBlk->wVoxBufferReadByteOffset)
     leftOverByte = hvciIOBlk->wVoxBufferWriteByteOffset - hvciIOBlk->wVoxBufferReadByteOffset;
   else
     leftOverByte = hvciIOBlk->wVoxBufferWriteByteOffset + hvciIOBlk->wVoxBufferSize
       - hvciIOBlk->wVoxBufferReadByteOffset;

   if (hvciIOBlk->chVoxBufferReadBitOffset > 0)
     leftOverByte --;
   
   /* reset the bytes for reading */
   bytes -= leftOverByte;
   if (bytes >= hvciIOBlk->wVoxBufferSize)
     bytes = hvciIOBlk->wVoxBufferSize - 1;

   for (; bytes > 0; bytes--) {
      if(!fread(&wordToRead,sizeof(unsigned char), 1, pFile)) {
         endOfFile=1;
         break;
      }

      hvciIOBlk->pVoxBuffer[hvciIOBlk->wVoxBufferWriteByteOffset] = wordToRead;
      
      /* increase the index */
      hvciIOBlk->wVoxBufferWriteByteOffset 
         = (unsigned char)((hvciIOBlk->wVoxBufferWriteByteOffset+1)
	% hvciIOBlk->wVoxBufferSize);
   }

   return endOfFile;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\trackpth.h ===
#ifndef _TRACKPTH_H_
#define _TRACKPTH_H_

/***********************************************************************
 *
 * Filename:  trackPth.h
 *
 * Purpose:  tracking the pitch based on one future frame and one or two
 *           previous frames. And make the decision.
 *           
 * Reference:  (1) ITU-T Draft G.723, p.13.
 *             (2) Inmarsat-M Voce Coding System Description, p15-17.
 *
 * Author:     Wei Wang
 *
 * Date:       Oct. 08, 1996
 *
 * $Header:   /export/phobos/pvcs/r_and_d/archives/realtime/pda/trackPth.h_v   1.2   12 May 1998 12:55:16   weiwang  $
 ***********************************************************************/

/*************************************************************
 * Fucntion:   trackPitch()
 *
 * Action:    do forward and backward pitch tracking using 
 *            biased cost function.
 *
 * Input:     myPDATrack_mblk:  pointer for pitch tracking.
 *
 * Output:    pitch value of frame 0.
 *************************************************************/

short VoxTrackPitch(STACK_R float *costs1, CorrPDA_mblk *myCorrPDA_mblk);



#endif /* end of #ifndef _TRACKPTH_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\teststc.c ===
/******************************************************************************
*                        Voxware Proprietary Material
*                        Copyright 1996, Voxware, Inc
*                            All Rights Reserved
*
*                       DISTRIBUTION PROHIBITED without
*                      written authorization from Voxware
******************************************************************************/

/******************************************************************************
*
* Filename:       TestSTC.c
*
* Purpose:        Test program for scalable codecs
*
* Functions:      main()
*
* Author/Date:    Bob
*
*******************************************************************************
*
* Modifications:
*
* Comments:
*
* Concerns:
*
* $Header:   /export/phobos/pvcs/r_and_d/archives/scaleable/testcode/TestSTC.c_v   1.4   18 May 1998 10:37:42   weiwang  $
*
******************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <math.h>
#include <assert.h>
 
#include "VoxMem.h"
#include "vci.h"

#include "zargs.h"

#include "vciSC6.h"
#include "vciSC3.h"
#include "vciPlus.h"
#include "vciPlsSC.h"

#include "codec.h"

#define VCI_VAD 0

#if(VCI_VAD==1)
#include "vciVad.h"
FILE *vadFile=NULL, *agcFile=NULL;

static void setVadAgc(void *hCodecMemBlk1);
static void getVadAgc(void *hCodecMemBlk1, unsigned short framelen);
#endif

static void resetArgTable(void);
static float setWarp(void);

#define ALIGNMENT_SAMPLES    ENC_DELAY_SIZE 
#define MAX_FRAME_LENGTH 160

#ifdef WIN32
#include "NspTimer.h"
#endif

#ifdef SPARCSTATION
#include "sys/time.h"
#endif

#if (defined(WIN32)==1 || defined(SPARCSTATION)==1)
#define TIMER_NO   1
#define TEST_TIMES 1
#define MAX_FRAME_NO 4000
static double ENCODER_TIMER[MAX_FRAME_NO];
static double DECODER_TIMER[MAX_FRAME_NO];
#endif

#define SC_RATE_3K 0x01
#define SC_RATE_6K 0x03
/*--------------------------------------------------------------
  VOX_BUFFER_SIZE should be at least 15 for 6.0 kBits and
    at least  8 for 3.2 kBits
--------------------------------------------------------------*/
#define VOX_BUFFER_SIZE  20


static int  iWriteParams=0;
static FILE *pFWPFile;

int   iPrnFrmNum = 0;     /* print each frame number during processing       */
int   iFirstFrame = 0;    /* first frame to process                          */
int   iSCX = 0;           /* flag to switch between 3 and 6 kBits            */
int   iSC6 = 0;           /* flag to run at 6 kBits                          */
int   iParamCopy = 0;     /* flag to call ParamCopy() for uncoded parameters */
char  *cWPFileName = "";  /* output file for writing parameters into         */
char  *cVoxFile  ="";     /* vox file for half duplex                        */
int   iEncode=0;          /* half duplex mode, encode                        */
int   iDecode=0;          /* half duplex mode, decode                        */
float fWarp = 1.0F;       /* time scale warping factor                       */
int   fWarpTest = 0;      /* puts the warp on a sin wave a la RT             */
int   iAlign = 0;         /* time align the output and input                 */
int   iVad =0;            /* switch to turn Vad/Agc on/off                   */

int STCmain(int argc, char** argv)
{
   int  iFrameCount=0;
   FILE    *fp=NULL, *fp2=NULL;
   void    *pMemBlkE, *pMemBlkD;
   int      iTotalSamples,iTableSize;
   int      iContFlag=0;
   unsigned long iToggle=SC_RATE_3K,iToggle2=SC_RATE_3K;
   unsigned short wBitRate;
   int     i;
   VCI_RETCODE wError;
   unsigned char wNeedsInputFlag=0;
#if (defined(SPARCSTATION) == 1)
   struct timeval tp0, tp1, tpNull;
#endif
#if (defined(WIN32)==1 || defined(SPARCSTATION)==1)
   double tempClock=0.0;
   unsigned int uiTestCount=0;
   double DecoderPeak=0.0, EncoderPeak=0.0;
   double DecoderAverage=0.0, EncoderAverage=0.0;
   int EncoderPeakIndex=0, DecoderPeakIndex=0;
#else
   clock_t cTime;
   float   fSeconds,fPercent;
#endif
   int        iAlignmentSamples = 0;
   short int *psPCM=NULL;
   int        iSamples;

   VCI_CODEC_IO_BLOCK hvciEncodeIOBlk;     /* Encoder interface structure.     */
   VCI_CODEC_IO_BLOCK hvciDecodeIOBlk;     /* Decoder interface structure.     */

   static ARG argtab[]= {
      {"iSCX", BOOLEAN, &iSCX, "switch between  3 and 6 kbits"},
      {"iSC6", BOOLEAN, &iSC6, "run at 6 kbits"},
      {"iParamCopy", BOOLEAN, &iParamCopy, "call ParamCopy()"},
      {"iPrnFrmNum", BOOLEAN, &iPrnFrmNum, "print frame numbers"},
      {"iFirstFrame", INT, &iFirstFrame, "first frame to process"},
      {"cWPFileName", STRING, (int *)&cWPFileName, "parameter output file"},
      {"iEncode", BOOLEAN, &iEncode, "half duplex (encode)"},
      {"iDecode", BOOLEAN, &iDecode, "half duplex (decode)"}, 
      {"cVoxFile", STRING, (int *)&cVoxFile, "vox file"},
      {"fWarp", FLOAT, (int *)&fWarp, "time warping factor"},
      {"fWarpTest", BOOLEAN, &fWarpTest, "warp test"},
      {"iAlign", BOOLEAN, &iAlign, "time align the output and input"},
      {"iVad", BOOLEAN, &iVad, "Vad/Agc test"}
   };
   
   /* we need to reset each argument value in case we call the STCmain again */
   resetArgTable();

   /* Get the command-line arguments */
   iTableSize=sizeof(argtab)/sizeof(ARG);
   argc = zargs(argc, argv, argtab, iTableSize);
 
   if (iAlign) 
      iAlignmentSamples = ALIGNMENT_SAMPLES;

   (iSC6)?printf("\nRunning SC6 "):printf("\nRunning SC3 ");

   if (iParamCopy) printf("(calling ParamCopy())");

   if(iEncode) {
      if(iDecode) {
         printf("Half Duplex!!!! Get it... like duhhhh");
         exit(1);
      } 
      printf("(Encode->Vox)\n");

      if (argc <= 2) {
         fprintf(stderr, "Usage: %s <Input Speech File> <Output Raw Vox File>\n\n",
                 argv[0]);
         fprintf(stderr, "example: %s INPUT.pcm OUTPUT.vox \n", argv[0]);
         exit(1);
      }

   }
   else if(iDecode) {
      printf("(Vox->Decode)\n");

      if (argc <= 2) {
         fprintf(stderr, "Usage: %s <Input Raw Vox File> <Output Speech File>\n\n",
                 argv[0]);
         fprintf(stderr, "example: %s INPUT.vox OUTPUT.out \n", argv[0]);
         exit(1);
      }


   } else { /* Full duplex */
      printf("(Full Duplex)\n");
      if (argc <= 2) {
         fprintf(stderr, "Usage: %s <Input Speech File> <Output Speech File>\n\n",
                 argv[0]);
         fprintf(stderr, "example: %s INPUT.pcm OUTPUT.out \n", argv[0]);
         exit(1);
      }
   }

   /*** Specify the input speech file ***/
   if ((fp = fopen(argv[1], "rb")) == NULL) {
      fprintf(stderr, "\nCannot open %s\n", argv[1]);
      exit(1);
   } else  
      printf("\nInput File:  \"%s\"\n", argv[1]); 

   /*** Specify the output speech file ***/
   if ((fp2 = fopen(argv[2], "wb")) == NULL) {
      fprintf(stderr, "\nCannot create %s\n", argv[2]);
      exit(1);
   } else 
      printf("Output File: \"%s\"\n", argv[2]); 

   if(!iDecode) {
      if(!(hvciEncodeIOBlk.pPCMBuffer=calloc(FRAME_LENGTH_SC,sizeof(short)))) {
         printf("\nFailed to allocated memory! .. exiting");
         exit(1);
      }

      if(!(hvciEncodeIOBlk.pVoxBuffer=calloc(VOX_BUFFER_SIZE,sizeof(unsigned char)))) {
         printf("\nFailed to allocated memory! .. exiting");
         exit(1);
      }

      hvciEncodeIOBlk.wVoxBufferSize = VOX_BUFFER_SIZE;
      hvciEncodeIOBlk.wVoxBufferReadByteOffset = 0;
      hvciEncodeIOBlk.chVoxBufferReadBitOffset = 0;
      hvciEncodeIOBlk.wVoxBufferWriteByteOffset = 0;
      hvciEncodeIOBlk.chVoxBufferWriteBitOffset = 0;

   }
   if(!iEncode) {
      if(!(hvciDecodeIOBlk.pPCMBuffer=calloc(FRAME_LENGTH_SC,sizeof(short)))) {
         printf("\nFailed to allocated memory! .. exiting");
         exit(1);
      }

      if(!(hvciDecodeIOBlk.pVoxBuffer=calloc(VOX_BUFFER_SIZE,sizeof(unsigned char)))) {
         printf("\nFailed to allocated memory! .. exiting");
         exit(1);
      }

      hvciDecodeIOBlk.wVoxBufferSize = VOX_BUFFER_SIZE;
      hvciDecodeIOBlk.wVoxBufferReadByteOffset = 0;
      hvciDecodeIOBlk.chVoxBufferReadBitOffset = 0;
      hvciDecodeIOBlk.wVoxBufferWriteByteOffset = 0;
      hvciDecodeIOBlk.chVoxBufferWriteBitOffset = 0;
   }

   /* Initialize all neccesary structures */
   if (iSC6 || iSCX) {
      if(!iDecode)
         if(vciInitEncodeSC6(&pMemBlkE)) {
            printf("\nFailed in Encoder 6 initialization! ... exiting");
            exit(1);
         }
      if(!iEncode)
         if(vciInitDecodeSC6(&pMemBlkD)) {
            printf("\nFailed in Decoder 6 initialization! ... exiting");
            exit(1);
         }
   } else {
      if(!iDecode) 
         if(vciInitEncodeSC3(&pMemBlkE)) {
            printf("\nFailed in Encoder 3 initialization! ... exiting");
            exit(1);
         }
      if(!iEncode)
         if(vciInitDecodeSC3(&pMemBlkD)) {
            printf("\nFailed in Decoder 3 initialization! ... exiting");
            exit(1);
         }
   }

#if VCI_VAD==1
   if(!iDecode&&iVad) {
      if (!(vadFile = fopen("vad.out", "wb"))) {
         printf("Cannot open vad.out\n");
         exit(1);
      }
      if (!(agcFile = fopen("agc.out", "wb"))) {
         printf("Cannot open agc.out\n");
         exit(1);
      }
      if(vciEnableVAD(pMemBlkE)) {
         printf("Memory Allocation error for Vad/Agc \n");
         exit(1); 
      }
      if(vciEnableAGC(pMemBlkE)) {
         printf("Memory Allocation error for Vad/Agc \n");
         exit(1);
      }
   }  
#endif

   if (cWPFileName[0]!='\0') {
      iWriteParams = 1;
      pFWPFile = fopen( cWPFileName, "w" );
      if (!pFWPFile) {
         printf("ERROR: could not open file: \'%s\'\n",cWPFileName);
         exit(0);
      }
   }

   if (!iEncode) {
      vciSetWarpFactorSC(pMemBlkD, fWarp);
      vciGetWarpFactorSC(pMemBlkD, &fWarp);
      printf("Warp set to %.3f\n",fWarp);
   }

   iTotalSamples = 0;

#if (defined(WIN32) == 0 && defined(SPARCSTATION) == 0)
   cTime = clock();
#else
   do {

   fseek(fp,0,0); /* resetting for bench mark */
#endif


   if(iFirstFrame) 
      fseek(fp,iFirstFrame*(FRAME_LENGTH_SC),0);
   iFrameCount=iFirstFrame;

   /* Processing loop */
   do  {
      iTotalSamples += FRAME_LENGTH_SC;
     
         if (iSCX) {
            if ((iFrameCount>=0)&&!(iFrameCount%20)) {
               iToggle=(iToggle==SC_RATE_3K)?SC_RATE_3K|SC_RATE_6K:SC_RATE_3K;
               vciSetEncoderRateSC(pMemBlkE, iToggle);
               vciGetEncoderRateSC(pMemBlkE, &iToggle2);
               vciCalculateBitRateSC(pMemBlkE, iToggle, &wBitRate);
               assert(iToggle==iToggle2);
               vciCalculateRateSC(pMemBlkE, wBitRate, &iToggle2);
               assert(iToggle==iToggle2);
               printf("\nRate now set at %d", wBitRate);
            }
         }

         if (iPrnFrmNum)
            printf("\nFrame: %d",iFrameCount);

         if(!iDecode) {
#if(VCI_VAD==1)
            if(iVad)
               setVadAgc(pMemBlkE);
#endif

            iContFlag=fread(hvciEncodeIOBlk.pPCMBuffer, sizeof(short),FRAME_LENGTH_SC, fp);
            if(iContFlag<FRAME_LENGTH_SC) {
               for(i=iContFlag;i<(FRAME_LENGTH_SC);i++)
                  hvciEncodeIOBlk.pPCMBuffer[i]=(short)0;
               iContFlag=0;
            }

            /*--------------------------------------------
              clear bit stream and reset offsets to zero
            --------------------------------------------*/
            hvciEncodeIOBlk.wVoxBufferWriteByteOffset = 0;
            hvciEncodeIOBlk.chVoxBufferWriteBitOffset = 0;

            /*--------------------------------------------
              Encode the speech
            --------------------------------------------*/
#ifdef WIN32
            tstTimerStart(TIMER_NO);
#elif (defined(SPARCSTATION) == 1)
            gettimeofday(&tp0, &tpNull);
#endif
            wError=(unsigned short)((iSC6||iSCX)?vciEncodeSC6(pMemBlkE, &hvciEncodeIOBlk):
               vciEncodeSC3(pMemBlkE, &hvciEncodeIOBlk));
#ifdef WIN32
            tstTimerStop(TIMER_NO);
            tempClock = tstTimerSec(TIMER_NO);
#elif (defined(SPARCSTATION)== 1)
            gettimeofday(&tp1, &tpNull);
            tempClock = (tp1.tv_sec-tp0.tv_sec) + (tp1.tv_usec-tp0.tv_usec)*1.0e-6F;
#endif

#if (defined(WIN32) == 1 || defined(SPARCSTATION) == 1)
            if(iFrameCount<MAX_FRAME_NO)
               if(tempClock < ENCODER_TIMER[iFrameCount] || uiTestCount==0)
                  ENCODER_TIMER[iFrameCount] = tempClock;
#endif

            if(wError) {
               printf("\nError %d in Encoder... exiting", wError);
               exit(1);
            }
#if(VCI_VAD==1)
            if(iVad)
               getVadAgc(pMemBlkE, (unsigned short)FRAME_LENGTH_SC);
#endif
         }

         if(iEncode) {
           /* write out the frame boundary */
           fwrite(hvciEncodeIOBlk.pVoxBuffer, sizeof(unsigned char), 
              hvciEncodeIOBlk.wVoxBufferWriteByteOffset, fp2); 
          }
         else if(iDecode) {
            /* seek back the frame boundary */
            fseek(fp, hvciDecodeIOBlk.wVoxBufferReadByteOffset
              -hvciDecodeIOBlk.wVoxBufferWriteByteOffset,SEEK_CUR); 
            /* read the data */
            iContFlag=(fread(hvciDecodeIOBlk.pVoxBuffer,sizeof(unsigned char), 
               hvciDecodeIOBlk.wVoxBufferSize-1, fp)==
               (unsigned int)(hvciDecodeIOBlk.wVoxBufferSize-1))?1:0;

            /* set the write byt offset */
            hvciDecodeIOBlk.wVoxBufferWriteByteOffset = 
            (unsigned short)((hvciDecodeIOBlk.wVoxBufferSize-1) % hvciDecodeIOBlk.wVoxBufferSize);
         }
         else { /* Full Duplex */
         /*--------------------------------------------
           Copy bit stream for decoder.

           NOTE: A bitstream must ALWAYS be passed
                   to the decoder, even when using
                   ParamCopy() to transfer the parameters.
                   Without a bitstream the VCI
                   cannot tell which decoder to 
                   invoke!
         --------------------------------------------*/

            for (i=0; i<hvciEncodeIOBlk.wVoxBufferSize; i++)
               hvciDecodeIOBlk.pVoxBuffer[i] = hvciEncodeIOBlk.pVoxBuffer[i];
         /*--------------------------------------------
              copy unquantized parameters
         --------------------------------------------*/

         /*--------------------------------------------------
           copy the write flags 
           --------------------------------------------------*/
          hvciDecodeIOBlk.wVoxBufferWriteByteOffset = hvciEncodeIOBlk.wVoxBufferWriteByteOffset;
          hvciDecodeIOBlk.chVoxBufferWriteBitOffset = hvciEncodeIOBlk.chVoxBufferWriteBitOffset;
         }

         if(!iEncode) {
            /*--------------------------------------------
              copy bit stream and reset offsets to zero
            --------------------------------------------*/
            hvciDecodeIOBlk.wVoxBufferReadByteOffset = 0;
            hvciDecodeIOBlk.chVoxBufferReadBitOffset = 0;

            if(fWarpTest)
               vciSetWarpFactorSC(pMemBlkD, setWarp());

            do {
               /*--------------------------------------------
                 Decode the speech
               --------------------------------------------*/
#ifdef WIN32
               tstTimerStart(TIMER_NO);
#elif (defined(SPARCSTATION) == 1)
               gettimeofday(&tp0, &tpNull);
#endif
               wError=(unsigned short)((iSC6||iSCX)?vciDecodeSC6(pMemBlkD, &hvciDecodeIOBlk):
                  vciDecodeSC3(pMemBlkD, &hvciDecodeIOBlk));
#ifdef WIN32
            tstTimerStop(TIMER_NO);
            tempClock = tstTimerSec(TIMER_NO);
#elif (defined(SPARCSTATION)== 1)
            gettimeofday(&tp1, &tpNull);
            tempClock = (tp1.tv_sec-tp0.tv_sec) + (tp1.tv_usec-tp0.tv_usec)*1.0e-6F;
#endif

#if (defined(WIN32) == 1 || defined(SPARCSTATION) == 1)
               if(iFrameCount<MAX_FRAME_NO)
                  if(tempClock < DECODER_TIMER[iFrameCount] || uiTestCount==0)
                     DECODER_TIMER[iFrameCount] = tempClock; 
#endif
               if(wError) {
                  printf("\nError %d in Decoder... exiting", wError);
                  exit(1);
               }
               /*--------------------------------------------
                 write decoded speech to a file
               --------------------------------------------*/
               if (hvciDecodeIOBlk.wSamplesInPCMBuffer) {
                  /*------------------------------------------------------
                    possibly time align the output by skipping the
                      first 146 output samples.....
                  ------------------------------------------------------*/
                  if (iAlignmentSamples) {
                     if (iAlignmentSamples>=hvciDecodeIOBlk.wSamplesInPCMBuffer) {   
                        iSamples = 0;
                        iAlignmentSamples-=hvciDecodeIOBlk.wSamplesInPCMBuffer;
                     } else {
                        iSamples = hvciDecodeIOBlk.wSamplesInPCMBuffer -
                                   iAlignmentSamples;
                        psPCM = hvciDecodeIOBlk.pPCMBuffer + iAlignmentSamples;
                        iAlignmentSamples = 0;
                     }
                  } else {
                     psPCM = hvciDecodeIOBlk.pPCMBuffer;
                     iSamples = hvciDecodeIOBlk.wSamplesInPCMBuffer;
                  }

                  /*----------------------------------------------------
                    Write the output speech to disk
                  ----------------------------------------------------*/
                  if (iSamples)
                     fwrite((char*)psPCM, sizeof(short), iSamples, fp2);
               }
   
               vciDecodeNeedsInputSC(pMemBlkD,&wNeedsInputFlag);
            } while (!wNeedsInputFlag);
         }
         iFrameCount++;

#if 0
        if (iFrameCount > MAX_FRAME_NO) break;
#endif

   } while (iContFlag);

    printf ("Job Completed... \n");

#if (defined(WIN32) == 0 && defined(SPARCSTATION) == 0)
   cTime = clock() - cTime;
   fSeconds = (float)cTime/(float)CLOCKS_PER_SEC;
   fPercent = fSeconds/(float)iTotalSamples*8000.0F*100.0F;

   printf("\nElapsed Time: %.3f seconds (%.1f%% of real time)\n",
          fSeconds, fPercent);
   /*printf("Clock resolution is %e seconds\n",1.0F/(float)CLOCKS_PER_SEC);*/
#else
   } while(++uiTestCount<TEST_TIMES);
   iFrameCount=(iFrameCount>MAX_FRAME_NO)?MAX_FRAME_NO:iFrameCount;
   for(i=0;i<iFrameCount;i++) {
      if(ENCODER_TIMER[i]>EncoderPeak) {
         EncoderPeak = ENCODER_TIMER[i];
         EncoderPeakIndex = i;
      }
      if(DECODER_TIMER[i]>DecoderPeak) {
         DecoderPeak = DECODER_TIMER[i];
         DecoderPeakIndex = i;
      }
      EncoderAverage += ENCODER_TIMER[i];
      DecoderAverage += DECODER_TIMER[i];
   }
   
   EncoderAverage/= (iFrameCount*0.02);
   DecoderAverage/= (iFrameCount*0.02);
   EncoderPeak /=(0.02);
   DecoderPeak /=(0.02);
  
   if(!iDecode) {
      printf("\n\nEncodeAverage CPU time: %.1f", EncoderAverage*100);
      printf("\nEncodePeak    CPU time: %.1f", EncoderPeak*100);
      printf("\nEncoder Peak Index %d", EncoderPeakIndex);
   }

   if(!iEncode) {
      printf("\n\nDecodeAverage CPU time: %.1f", DecoderAverage*100);
      printf("\nDecodePeak    CPU time: %.1f", DecoderPeak*100);
      printf("\nDecoder Peak Index %d\n", DecoderPeakIndex);
   }
#endif
#if VCI_VAD==1
      if(iVad) {
         printf("\nFreeing: Vad/Agc. \n");
         vciDisableAGC(pMemBlkE);
         vciDisableVAD(pMemBlkE);

         if(vadFile)
            fclose(vadFile);
         if(agcFile)
            fclose(agcFile);
      }
#endif

   if (iSC6 || iSCX) {
      if(!iDecode)
         vciFreeEncodeSC6(&pMemBlkE);
      if(!iEncode)
         vciFreeDecodeSC6(&pMemBlkD);
   } else  {
      if(!iDecode)
         vciFreeEncodeSC3(&pMemBlkE);
      if(!iEncode)
         vciFreeDecodeSC3(&pMemBlkD);
   }

   if(!iDecode) {
      free(hvciEncodeIOBlk.pPCMBuffer);
      free(hvciEncodeIOBlk.pVoxBuffer);
   }

   if(!iEncode) {
      free(hvciDecodeIOBlk.pPCMBuffer);
      free(hvciDecodeIOBlk.pVoxBuffer);
   }

   fclose(fp);
   fclose(fp2);

   return(0);
} /* main() */

static void resetArgTable(void)
{
   iPrnFrmNum = 0;     /* print each frame number during processing       */
   iFirstFrame = 0;    /* first frame to process                          */
   iSCX = 0;           /* flag to switch between 3 and 6 kBits            */
   iSC6 = 0;           /* flag to run at 6 kBits                          */
   iParamCopy = 0;     /* flag to call ParamCopy() for uncoded parameters */
   cWPFileName = "";  /* output file for writing parameters into         */
   cVoxFile  ="";     /* vox file for half duplex                        */
   iEncode=0;          /* half duplex mode, encode                        */
   iDecode=0;          /* half duplex mode, decode                        */
   fWarp = 1.0F;       /* time scale warping factor                       */
   fWarpTest = 0;      /* puts the warp on a sin wave a la RT             */
   iAlign = 0;         /* time align the output and input                 */
   iVad =0;            /* switch to turn Vad/Agc on/off                   */
}

static float setWarp(void)
{
   static float step = 0.0F;
   float warp=1.0F;
   float temp;
   float inc;

   temp = (float)(2.0*sin(step));
   if (temp > 1.5)
      inc = 0.007F;
   else if (temp > 0.5)
      inc = 0.005F;
   else if (temp > -0.5)
      inc = 0.001F;
   else if (temp > -1.5)
      inc = 0.002F;
   else
      inc = 0.007F;

   step+=inc;
   if (temp < 0.0F) {
      temp = -(temp-1.0F);
      temp = 1.0F/temp;
   }
   else
      temp+=1.0F;

   return(warp*=temp);
}

#if VCI_VAD==1
static void setVadAgc(void *hCodecMemBlk1)
{
  unsigned short wSilenceThresh = 450;     /* 450ms (5 packets) */
  unsigned short wEnergyTrigLevel = 150;   /* energy level is 150 */
  short wTargetGain = 180;   /* set target gain to 180 */
  
  /* set silence threshold */
  vciSetVADSilenceThresh(hCodecMemBlk1, wSilenceThresh);

  /* set user triggle level */
  vciSetVADEnergyTrigLevel(hCodecMemBlk1, wEnergyTrigLevel);

  /* set AGC control value to 0 */
  vciSetAGCControlValue(hCodecMemBlk1, 0);

  /* set AGC target gain */
  vciSetAGCTargetGain(hCodecMemBlk1, wTargetGain);
}

static void getVadAgc(void *hCodecMemBlk1, unsigned short framelen)
{
  unsigned short VadValue;
  short AGCcontrolValue;
  short outBuf[MAX_FRAME_LENGTH];
  int i;

  /* get VAD */
  vciGetVADVoiceActivity(hCodecMemBlk1, &VadValue);
  
  /* get AGC control value */
  vciGetAGCControlValue(hCodecMemBlk1, &AGCcontrolValue);

  /* write to the buffer */
  for (i = 0; i < framelen; i++)
    outBuf[i] = VadValue;
  fwrite(outBuf, sizeof(short), framelen, vadFile);

  for (i = 0; i < framelen; i++)
    outBuf[i] = AGCcontrolValue;
  fwrite(outBuf, sizeof(short), framelen, agcFile);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\trackpth.c ===
/***********************************************************************
 *
 * Filename:  trackPth.c
 *
 * Purpose:  tracking the pitch based on one future frame and one or two
 *           previous frames. And make the decision.
 *           
 * Reference:  (1) ITU-T Draft G.723, p.13.
 *             (2) Inmarsat-M Voce Coding System Description, p15-17.
 *
 * Author:     Wei Wang
 *
 * Date:       Oct. 08, 1996
 *
 * Modification: modified for decimated signal. When pitch is too small,
 *               the cost values of double pitch and triple pitch are checked.
 *               If they are too small, the second pitch candidate has to be 
 *               selected.  1/21/97, Wei Wang.
 * 
 * $Header:   /export/phobos/pvcs/r_and_d/archives/realtime/pda/trackPth.c_v   1.6   12 May 1998 12:55:16   weiwang  $
 ***********************************************************************/
#include <stdlib.h>
#include <string.h>
#include <assert.h>

#include "vLibVec.h" /* FindMaxValueFlt() */

#include "VoxMem.h"

#include "CorrPDA.h"
#include "PitchDef.h"

#include "trackPth.h"

#include "xvocver.h"

static void LookForward(STACK_R float *pcost1, CorrPDA_mblk *myCorrPDA_mblk, 
                        float *pcost_f, short *pp0_f, short *tooSmall_flag);

static void LookBackward(CorrPDA_mblk *myCorrPDA_mblk, float *pcost_b, short *pp0_b);


/*************************************************************
 * Fucntion:   trackPitch()
 *
 * Action:    do forward and backward pitch tracking using 
 *            biased cost function.
 *
 * Input:     myPDATrack_mblk:  pointer for pitch tracking.
 *
 * Output:    pitch value of frame 0.
 *************************************************************/

short VoxTrackPitch(STACK_R float *costs1, CorrPDA_mblk *myCorrPDA_mblk)
{
  float cost_f, cost_b;
  short p0_f, p0_b;
  short pitch;
  short tooSmall_flag = 0;

  /*--------------------------------------------------
    forward tracking :
    --------------------------------------------------*/
  LookForward(STACK_S costs1, myCorrPDA_mblk, &cost_f, &p0_f, &tooSmall_flag);


  /*-------------------------------------------------- 
    backward tracking :
    find the maximum costs while tracking.
    --------------------------------------------------*/
  LookBackward(myCorrPDA_mblk, &cost_b, &p0_b);

  if (tooSmall_flag == 1) {
    /* need check p0_b to see if pitch candidate is not reliable */
    if (p0_b <= LPITCH_MIN_CONF && cost_b < 0.5F) {
      cost_b = INIT_COST;
    }
  }

  /*-----------------------------------------------------------------
    make the decision to choose from backward pitch or forward pitch.
    -----------------------------------------------------------------*/
  if (((p0_b>p0_f)&&(cost_f<=BIAS_FORWARD*cost_b))
      ||((p0_b <= p0_f) && ( (cost_b >= (BIAS_BACKWARD * cost_f)))))
    pitch = p0_b;
  else 
    pitch = p0_f;


  /*------------------------------------------------------------
    Save the tracking information.
    ------------------------------------------------------------*/
  myCorrPDA_mblk->pitch_2 = myCorrPDA_mblk->pitch_1;
  myCorrPDA_mblk->pitch_1 = pitch;

  myCorrPDA_mblk->cost_2 = myCorrPDA_mblk->cost_1;
  myCorrPDA_mblk->cost_1 = myCorrPDA_mblk->costs0[pitch-LPITCH_MIN];

  memcpy(myCorrPDA_mblk->costs0, costs1, PITCH_CAND*sizeof(float));


  return pitch;
}





/*--------------------------------------------------
  forward tracking :
  --------------------------------------------------*/
static void LookForward(STACK_R float *pcost1, CorrPDA_mblk *myCorrPDA_mblk, 
                        float *pcost_f, short *pp0_f, short *tooSmall_flag)
{
  STACK_INIT
  float pforward_costs[3*PITCH_CAND];
  STACK_INIT_END
  STACK_ATTACH(float*,pforward_costs)
  float *pcost0 = myCorrPDA_mblk->costs0;
  int *dLagStart = myCorrPDA_mblk->dInterLagStart;
  int *dLagLength = myCorrPDA_mblk->dInterLagLength;
  float cost_f;
  int p0_f;
  int jlag;
  float forcosts;

  float tmpmaxcost;
  int tmpmaxlag = -1;
  float tmpcost2, tmpcost3;

  STACK_START

  /*--------------------------------------------------
    calculate the forward cost function.
    --------------------------------------------------*/
  {
    int k, length, kend=0;
    float tmpmaxcost1;
    int tmpmaxlag1;

    cost_f = INIT_COST;
    for (jlag = 0; jlag < PITCH_CAND; jlag++) {
      k = *dLagStart++;
      length = k+ *dLagLength-kend;
      if(tmpmaxlag < k) {
	FindMaxValueFlt(&(pcost1[k]), *dLagLength, &tmpmaxlag, &tmpmaxcost);
	tmpmaxlag += k;
      }
      else if(length) {
	assert(kend < PITCH_CAND);
	tmpmaxcost1 = pcost1[kend];
	tmpmaxlag1 = kend;
	if(length == 2) {
	  assert( kend+1 < PITCH_CAND);
	  if(tmpmaxcost1 < pcost1[kend+1]) {
	    tmpmaxcost1 = pcost1[kend+1];
	    tmpmaxlag1 ++;
	  }
	}
	if(tmpmaxcost1>tmpmaxcost) {
	  tmpmaxlag = tmpmaxlag1;
	  tmpmaxcost = tmpmaxcost1;
	}
      }
      kend = k + *dLagLength++;
      forcosts = 0.5F * (tmpmaxcost + *pcost0++);
      if (forcosts > cost_f) {
	cost_f = forcosts;
	p0_f = jlag;
      }
      pforward_costs[jlag] = forcosts;
    }
  }

  p0_f += LPITCH_MIN;


  /*--------------------------------------------------
    To prevent pick too small pitch as the candidates,
    If p0_f is [PITCH_MIN:PITCH_MIN+1], we have to check
    the costs of 2*p0_f and 3*p0_f. If all of them are 
    very large, then we keep this candidates. Otherwise,
    we have to find the largest cost from 3*p0_f+1:
    PITCH_MAX.
    --------------------------------------------------*/
  if (p0_f <= LPITCH_MIN_CONF) {
    jlag = 2*p0_f-LPITCH_MIN;
    tmpcost2 = pforward_costs[jlag];
    jlag += p0_f;
    tmpcost3 = pforward_costs[jlag];
    if ((tmpcost2 < 0.5F*cost_f) || (tmpcost3 < 0.5F*cost_f)) {
      /* we have to find the new forward tracking candidates */
      jlag++;
      FindMaxValueFlt(&(pforward_costs[jlag]), (PITCH_CAND-jlag),
		      &tmpmaxlag, &cost_f);
      p0_f = tmpmaxlag + jlag + LPITCH_MIN;

      *tooSmall_flag = 1;
    }
  }
  
  *pp0_f = (short) p0_f;
  *pcost_f = cost_f;
  STACK_END
}


/*-------------------------------------------------- 
  backward tracking :
  --------------------------------------------------*/
static void LookBackward(CorrPDA_mblk *myCorrPDA_mblk, float *pcost_b, short *pp0_b)
{
  float *pcost0 = myCorrPDA_mblk->costs0;
  short lag_1, lag_2;
  int *dLagStart = myCorrPDA_mblk->dInterLagStart;
  int *dLagLength = myCorrPDA_mblk->dInterLagLength;
  float tmpcost;
  float tmpmaxcost;
  int tmpmaxlag;
  float cost_b;
  short p0_b;
  short k;

  /*--------------------------------------------------
    find out the backward candidate.
    --------------------------------------------------*/
  lag_1 = (short)(myCorrPDA_mblk->pitch_1 - LPITCH_MIN);
  k = (short) dLagStart[lag_1];
  FindMaxValueFlt(&(pcost0[k]), dLagLength[lag_1], &tmpmaxlag, &tmpmaxcost);

  p0_b = (short)(tmpmaxlag + k + LPITCH_MIN);
  cost_b = (tmpmaxcost + myCorrPDA_mblk->cost_1) * 0.5F; 

  
  /*--------------------------------------------------
    lookback to see if the previous previous frame is under
    tracking.
    --------------------------------------------------*/
  lag_2 = (short)(myCorrPDA_mblk->pitch_2 - LPITCH_MIN);
  k = (short) dLagStart[lag_2];

  if (lag_1>=k && lag_1< (k+dLagLength[lag_2])) {
    tmpcost = (float)(myCorrPDA_mblk->cost_2*0.25F + myCorrPDA_mblk->cost_1*0.35F
      + tmpmaxcost*0.4F);
    if (tmpcost > cost_b)
      cost_b = tmpcost;
  } /* end of "if (lag_1 ... " */

  *pcost_b = cost_b;
  *pp0_b = p0_b;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\trig.h ===
/*******************************************************************************
*                        Voxware Proprietary Material                          *
*                        Copyright 1996, Voxware, Inc                          *
*                            All Rights Reserved                               *
*                                                                              *
*                       DISTRIBUTION PROHIBITED without                        *
*                      written authorization from Voxware                      *
*******************************************************************************/

/*******************************************************************************
* Filename:     trig.h                                                                
*                                                                              
* Purpose:      Provide a global pointer to a sin and a cos table. 
*                                                                              
*                                                                
*                                                                              
* Author/Date:  Rob Zopf                                                               
********************************************************************************
* Modifications:
*                                                
* Comments:                                                                    
* 
* Concerns:
*
* 
*******************************************************************************/
#ifndef TRIG_H
#define TRIG_H

#define LOG2_TRIG_SIZE      8
#define TRIG_SIZE           (1<<LOG2_TRIG_SIZE)


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\trgtbl8.h ===
0.0000000000F,
   0.0245412285F,
   0.0490676743F,
   0.0735645636F,
   0.0980171403F,
   0.1224106752F,
   0.1467304745F,
   0.1709618888F,
   0.1950903220F,
   0.2191012402F,
   0.2429801799F,
   0.2667127575F,
   0.2902846773F,
   0.3136817404F,
   0.3368898534F,
   0.3598950365F,
   0.3826834324F,
   0.4052413140F,
   0.4275550934F,
   0.4496113297F,
   0.4713967368F,
   0.4928981922F,
   0.5141027442F,
   0.5349976199F,
   0.5555702330F,
   0.5758081914F,
   0.5956993045F,
   0.6152315906F,
   0.6343932842F,
   0.6531728430F,
   0.6715589548F,
   0.6895405447F,
   0.7071067812F,
   0.7242470830F,
   0.7409511254F,
   0.7572088465F,
   0.7730104534F,
   0.7883464276F,
   0.8032075315F,
   0.8175848132F,
   0.8314696123F,
   0.8448535652F,
   0.8577286100F,
   0.8700869911F,
   0.8819212643F,
   0.8932243012F,
   0.9039892931F,
   0.9142097557F,
   0.9238795325F,
   0.9329927988F,
   0.9415440652F,
   0.9495281806F,
   0.9569403357F,
   0.9637760658F,
   0.9700312532F,
   0.9757021300F,
   0.9807852804F,
   0.9852776424F,
   0.9891765100F,
   0.9924795346F,
   0.9951847267F,
   0.9972904567F,
   0.9987954562F,
   0.9996988187F,
   1.0000000000F,
   0.9996988187F,
   0.9987954562F,
   0.9972904567F,
   0.9951847267F,
   0.9924795346F,
   0.9891765100F,
   0.9852776424F,
   0.9807852804F,
   0.9757021300F,
   0.9700312532F,
   0.9637760658F,
   0.9569403357F,
   0.9495281806F,
   0.9415440652F,
   0.9329927988F,
   0.9238795325F,
   0.9142097557F,
   0.9039892931F,
   0.8932243012F,
   0.8819212643F,
   0.8700869911F,
   0.8577286100F,
   0.8448535652F,
   0.8314696123F,
   0.8175848132F,
   0.8032075315F,
   0.7883464276F,
   0.7730104534F,
   0.7572088465F,
   0.7409511254F,
   0.7242470830F,
   0.7071067812F,
   0.6895405447F,
   0.6715589548F,
   0.6531728430F,
   0.6343932842F,
   0.6152315906F,
   0.5956993045F,
   0.5758081914F,
   0.5555702330F,
   0.5349976199F,
   0.5141027442F,
   0.4928981922F,
   0.4713967368F,
   0.4496113297F,
   0.4275550934F,
   0.4052413140F,
   0.3826834324F,
   0.3598950365F,
   0.3368898534F,
   0.3136817404F,
   0.2902846773F,
   0.2667127575F,
   0.2429801799F,
   0.2191012402F,
   0.1950903220F,
   0.1709618888F,
   0.1467304745F,
   0.1224106752F,
   0.0980171403F,
   0.0735645636F,
   0.0490676743F,
   0.0245412285F,
   0.0000000000F,
   -0.0245412285F,
   -0.0490676743F,
   -0.0735645636F,
   -0.0980171403F,
   -0.1224106752F,
   -0.1467304745F,
   -0.1709618888F,
   -0.1950903220F,
   -0.2191012402F,
   -0.2429801799F,
   -0.2667127575F,
   -0.2902846773F,
   -0.3136817404F,
   -0.3368898534F,
   -0.3598950365F,
   -0.3826834324F,
   -0.4052413140F,
   -0.4275550934F,
   -0.4496113297F,
   -0.4713967368F,
   -0.4928981922F,
   -0.5141027442F,
   -0.5349976199F,
   -0.5555702330F,
   -0.5758081914F,
   -0.5956993045F,
   -0.6152315906F,
   -0.6343932842F,
   -0.6531728430F,
   -0.6715589548F,
   -0.6895405447F,
   -0.7071067812F,
   -0.7242470830F,
   -0.7409511254F,
   -0.7572088465F,
   -0.7730104534F,
   -0.7883464276F,
   -0.8032075315F,
   -0.8175848132F,
   -0.8314696123F,
   -0.8448535652F,
   -0.8577286100F,
   -0.8700869911F,
   -0.8819212643F,
   -0.8932243012F,
   -0.9039892931F,
   -0.9142097557F,
   -0.9238795325F,
   -0.9329927988F,
   -0.9415440652F,
   -0.9495281806F,
   -0.9569403357F,
   -0.9637760658F,
   -0.9700312532F,
   -0.9757021300F,
   -0.9807852804F,
   -0.9852776424F,
   -0.9891765100F,
   -0.9924795346F,
   -0.9951847267F,
   -0.9972904567F,
   -0.9987954562F,
   -0.9996988187F,
   -1.0000000000F,
   -0.9996988187F,
   -0.9987954562F,
   -0.9972904567F,
   -0.9951847267F,
   -0.9924795346F,
   -0.9891765100F,
   -0.9852776424F,
   -0.9807852804F,
   -0.9757021300F,
   -0.9700312532F,
   -0.9637760658F,
   -0.9569403357F,
   -0.9495281806F,
   -0.9415440652F,
   -0.9329927988F,
   -0.9238795325F,
   -0.9142097557F,
   -0.9039892931F,
   -0.8932243012F,
   -0.8819212643F,
   -0.8700869911F,
   -0.8577286100F,
   -0.8448535652F,
   -0.8314696123F,
   -0.8175848132F,
   -0.8032075315F,
   -0.7883464276F,
   -0.7730104534F,
   -0.7572088465F,
   -0.7409511254F,
   -0.7242470830F,
   -0.7071067812F,
   -0.6895405447F,
   -0.6715589548F,
   -0.6531728430F,
   -0.6343932842F,
   -0.6152315906F,
   -0.5956993045F,
   -0.5758081914F,
   -0.5555702330F,
   -0.5349976199F,
   -0.5141027442F,
   -0.4928981922F,
   -0.4713967368F,
   -0.4496113297F,
   -0.4275550934F,
   -0.4052413140F,
   -0.3826834324F,
   -0.3598950365F,
   -0.3368898534F,
   -0.3136817404F,
   -0.2902846773F,
   -0.2667127575F,
   -0.2429801799F,
   -0.2191012402F,
   -0.1950903220F,
   -0.1709618888F,
   -0.1467304745F,
   -0.1224106752F,
   -0.0980171403F,
   -0.0735645636F,
   -0.0490676743F,
   -0.0245412285F,
   -0.0000000000F,
   0.0245412285F,
   0.0490676743F,
   0.0735645636F,
   0.0980171403F,
   0.1224106752F,
   0.1467304745F,
   0.1709618888F,
   0.1950903220F,
   0.2191012402F,
   0.2429801799F,
   0.2667127575F,
   0.2902846773F,
   0.3136817404F,
   0.3368898534F,
   0.3598950365F,
   0.3826834324F,
   0.4052413140F,
   0.4275550934F,
   0.4496113297F,
   0.4713967368F,
   0.4928981922F,
   0.5141027442F,
   0.5349976199F,
   0.5555702330F,
   0.5758081914F,
   0.5956993045F,
   0.6152315906F,
   0.6343932842F,
   0.6531728430F,
   0.6715589548F,
   0.6895405447F,
   0.7071067812F,
   0.7242470830F,
   0.7409511254F,
   0.7572088465F,
   0.7730104534F,
   0.7883464276F,
   0.8032075315F,
   0.8175848132F,
   0.8314696123F,
   0.8448535652F,
   0.8577286100F,
   0.8700869911F,
   0.8819212643F,
   0.8932243012F,
   0.9039892931F,
   0.9142097557F,
   0.9238795325F,
   0.9329927988F,
   0.9415440652F,
   0.9495281806F,
   0.9569403357F,
   0.9637760658F,
   0.9700312532F,
   0.9757021300F,
   0.9807852804F,
   0.9852776424F,
   0.9891765100F,
   0.9924795346F,
   0.9951847267F,
   0.9972904567F,
   0.9987954562F,
   0.9996988187F,
   1.0000000000F,
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\trig.c ===
/*******************************************************************************
*                        Voxware Proprietary Material                          *
*                        Copyright 1996, Voxware, Inc                          *
*                            All Rights Reserved                               *
*                                                                              *
*                       DISTRIBUTION PROHIBITED without                        *
*                      written authorization from Voxware                      *
*******************************************************************************/

/*******************************************************************************
* Filename:     trig.c                                                                
*                                                                              
* Purpose:      Provide a global pointer to a sin and a cos table. 
*                                                                              
*                                                                
*                                                                              
* Author/Date:  Rob Zopf                                                               
********************************************************************************
* Modifications:
*                                                
* Comments:                                                                    
* 
* Concerns:
*
* 
*******************************************************************************/
#include "trig.h"

#include "xvocver.h"

const float trigTBL[] = 
{
#include "trigtbl.h"
};
 
const float *sinTBL = trigTBL;
const float *cosTBL = trigTBL + TRIG_SIZE/4;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\trgtblsc.h ===
0.0000000000F,
   0.0061358846F,
   0.0122715383F,
   0.0184067299F,
   0.0245412285F,
   0.0306748032F,
   0.0368072229F,
   0.0429382569F,
   0.0490676743F,
   0.0551952443F,
   0.0613207363F,
   0.0674439196F,
   0.0735645636F,
   0.0796824380F,
   0.0857973123F,
   0.0919089565F,
   0.0980171403F,
   0.1041216339F,
   0.1102222073F,
   0.1163186309F,
   0.1224106752F,
   0.1284981108F,
   0.1345807085F,
   0.1406582393F,
   0.1467304745F,
   0.1527971853F,
   0.1588581433F,
   0.1649131205F,
   0.1709618888F,
   0.1770042204F,
   0.1830398880F,
   0.1890686641F,
   0.1950903220F,
   0.2011046348F,
   0.2071113762F,
   0.2131103199F,
   0.2191012402F,
   0.2250839114F,
   0.2310581083F,
   0.2370236060F,
   0.2429801799F,
   0.2489276057F,
   0.2548656596F,
   0.2607941179F,
   0.2667127575F,
   0.2726213554F,
   0.2785196894F,
   0.2844075372F,
   0.2902846773F,
   0.2961508882F,
   0.3020059493F,
   0.3078496400F,
   0.3136817404F,
   0.3195020308F,
   0.3253102922F,
   0.3311063058F,
   0.3368898534F,
   0.3426607173F,
   0.3484186802F,
   0.3541635254F,
   0.3598950365F,
   0.3656129978F,
   0.3713171940F,
   0.3770074102F,
   0.3826834324F,
   0.3883450467F,
   0.3939920401F,
   0.3996241998F,
   0.4052413140F,
   0.4108431711F,
   0.4164295601F,
   0.4220002708F,
   0.4275550934F,
   0.4330938189F,
   0.4386162385F,
   0.4441221446F,
   0.4496113297F,
   0.4550835871F,
   0.4605387110F,
   0.4659764958F,
   0.4713967368F,
   0.4767992301F,
   0.4821837721F,
   0.4875501601F,
   0.4928981922F,
   0.4982276670F,
   0.5035383837F,
   0.5088301425F,
   0.5141027442F,
   0.5193559902F,
   0.5245896827F,
   0.5298036247F,
   0.5349976199F,
   0.5401714727F,
   0.5453249884F,
   0.5504579729F,
   0.5555702330F,
   0.5606615762F,
   0.5657318108F,
   0.5707807459F,
   0.5758081914F,
   0.5808139581F,
   0.5857978575F,
   0.5907597019F,
   0.5956993045F,
   0.6006164794F,
   0.6055110414F,
   0.6103828063F,
   0.6152315906F,
   0.6200572118F,
   0.6248594881F,
   0.6296382389F,
   0.6343932842F,
   0.6391244449F,
   0.6438315429F,
   0.6485144010F,
   0.6531728430F,
   0.6578066933F,
   0.6624157776F,
   0.6669999223F,
   0.6715589548F,
   0.6760927036F,
   0.6806009978F,
   0.6850836678F,
   0.6895405447F,
   0.6939714609F,
   0.6983762494F,
   0.7027547445F,
   0.7071067812F,
   0.7114321957F,
   0.7157308253F,
   0.7200025080F,
   0.7242470830F,
   0.7284643904F,
   0.7326542717F,
   0.7368165689F,
   0.7409511254F,
   0.7450577854F,
   0.7491363945F,
   0.7531867990F,
   0.7572088465F,
   0.7612023855F,
   0.7651672656F,
   0.7691033376F,
   0.7730104534F,
   0.7768884657F,
   0.7807372286F,
   0.7845565972F,
   0.7883464276F,
   0.7921065773F,
   0.7958369046F,
   0.7995372691F,
   0.8032075315F,
   0.8068475535F,
   0.8104571983F,
   0.8140363297F,
   0.8175848132F,
   0.8211025150F,
   0.8245893028F,
   0.8280450453F,
   0.8314696123F,
   0.8348628750F,
   0.8382247056F,
   0.8415549774F,
   0.8448535652F,
   0.8481203448F,
   0.8513551931F,
   0.8545579884F,
   0.8577286100F,
   0.8608669386F,
   0.8639728561F,
   0.8670462455F,
   0.8700869911F,
   0.8730949784F,
   0.8760700942F,
   0.8790122264F,
   0.8819212643F,
   0.8847970984F,
   0.8876396204F,
   0.8904487232F,
   0.8932243012F,
   0.8959662498F,
   0.8986744657F,
   0.9013488470F,
   0.9039892931F,
   0.9065957045F,
   0.9091679831F,
   0.9117060320F,
   0.9142097557F,
   0.9166790599F,
   0.9191138517F,
   0.9215140393F,
   0.9238795325F,
   0.9262102421F,
   0.9285060805F,
   0.9307669611F,
   0.9329927988F,
   0.9351835099F,
   0.9373390119F,
   0.9394592236F,
   0.9415440652F,
   0.9435934582F,
   0.9456073254F,
   0.9475855910F,
   0.9495281806F,
   0.9514350210F,
   0.9533060404F,
   0.9551411683F,
   0.9569403357F,
   0.9587034749F,
   0.9604305194F,
   0.9621214043F,
   0.9637760658F,
   0.9653944417F,
   0.9669764710F,
   0.9685220943F,
   0.9700312532F,
   0.9715038910F,
   0.9729399522F,
   0.9743393828F,
   0.9757021300F,
   0.9770281427F,
   0.9783173707F,
   0.9795697657F,
   0.9807852804F,
   0.9819638691F,
   0.9831054874F,
   0.9842100924F,
   0.9852776424F,
   0.9863080972F,
   0.9873014182F,
   0.9882575677F,
   0.9891765100F,
   0.9900582103F,
   0.9909026354F,
   0.9917097537F,
   0.9924795346F,
   0.9932119492F,
   0.9939069700F,
   0.9945645707F,
   0.9951847267F,
   0.9957674145F,
   0.9963126122F,
   0.9968202993F,
   0.9972904567F,
   0.9977230666F,
   0.9981181129F,
   0.9984755806F,
   0.9987954562F,
   0.9990777278F,
   0.9993223846F,
   0.9995294175F,
   0.9996988187F,
   0.9998305818F,
   0.9999247018F,
   0.9999811753F,
   1.0000000000F,
   0.9999811753F,
   0.9999247018F,
   0.9998305818F,
   0.9996988187F,
   0.9995294175F,
   0.9993223846F,
   0.9990777278F,
   0.9987954562F,
   0.9984755806F,
   0.9981181129F,
   0.9977230666F,
   0.9972904567F,
   0.9968202993F,
   0.9963126122F,
   0.9957674145F,
   0.9951847267F,
   0.9945645707F,
   0.9939069700F,
   0.9932119492F,
   0.9924795346F,
   0.9917097537F,
   0.9909026354F,
   0.9900582103F,
   0.9891765100F,
   0.9882575677F,
   0.9873014182F,
   0.9863080972F,
   0.9852776424F,
   0.9842100924F,
   0.9831054874F,
   0.9819638691F,
   0.9807852804F,
   0.9795697657F,
   0.9783173707F,
   0.9770281427F,
   0.9757021300F,
   0.9743393828F,
   0.9729399522F,
   0.9715038910F,
   0.9700312532F,
   0.9685220943F,
   0.9669764710F,
   0.9653944417F,
   0.9637760658F,
   0.9621214043F,
   0.9604305194F,
   0.9587034749F,
   0.9569403357F,
   0.9551411683F,
   0.9533060404F,
   0.9514350210F,
   0.9495281806F,
   0.9475855910F,
   0.9456073254F,
   0.9435934582F,
   0.9415440652F,
   0.9394592236F,
   0.9373390119F,
   0.9351835099F,
   0.9329927988F,
   0.9307669611F,
   0.9285060805F,
   0.9262102421F,
   0.9238795325F,
   0.9215140393F,
   0.9191138517F,
   0.9166790599F,
   0.9142097557F,
   0.9117060320F,
   0.9091679831F,
   0.9065957045F,
   0.9039892931F,
   0.9013488470F,
   0.8986744657F,
   0.8959662498F,
   0.8932243012F,
   0.8904487232F,
   0.8876396204F,
   0.8847970984F,
   0.8819212643F,
   0.8790122264F,
   0.8760700942F,
   0.8730949784F,
   0.8700869911F,
   0.8670462455F,
   0.8639728561F,
   0.8608669386F,
   0.8577286100F,
   0.8545579884F,
   0.8513551931F,
   0.8481203448F,
   0.8448535652F,
   0.8415549774F,
   0.8382247056F,
   0.8348628750F,
   0.8314696123F,
   0.8280450453F,
   0.8245893028F,
   0.8211025150F,
   0.8175848132F,
   0.8140363297F,
   0.8104571983F,
   0.8068475535F,
   0.8032075315F,
   0.7995372691F,
   0.7958369046F,
   0.7921065773F,
   0.7883464276F,
   0.7845565972F,
   0.7807372286F,
   0.7768884657F,
   0.7730104534F,
   0.7691033376F,
   0.7651672656F,
   0.7612023855F,
   0.7572088465F,
   0.7531867990F,
   0.7491363945F,
   0.7450577854F,
   0.7409511254F,
   0.7368165689F,
   0.7326542717F,
   0.7284643904F,
   0.7242470830F,
   0.7200025080F,
   0.7157308253F,
   0.7114321957F,
   0.7071067812F,
   0.7027547445F,
   0.6983762494F,
   0.6939714609F,
   0.6895405447F,
   0.6850836678F,
   0.6806009978F,
   0.6760927036F,
   0.6715589548F,
   0.6669999223F,
   0.6624157776F,
   0.6578066933F,
   0.6531728430F,
   0.6485144010F,
   0.6438315429F,
   0.6391244449F,
   0.6343932842F,
   0.6296382389F,
   0.6248594881F,
   0.6200572118F,
   0.6152315906F,
   0.6103828063F,
   0.6055110414F,
   0.6006164794F,
   0.5956993045F,
   0.5907597019F,
   0.5857978575F,
   0.5808139581F,
   0.5758081914F,
   0.5707807459F,
   0.5657318108F,
   0.5606615762F,
   0.5555702330F,
   0.5504579729F,
   0.5453249884F,
   0.5401714727F,
   0.5349976199F,
   0.5298036247F,
   0.5245896827F,
   0.5193559902F,
   0.5141027442F,
   0.5088301425F,
   0.5035383837F,
   0.4982276670F,
   0.4928981922F,
   0.4875501601F,
   0.4821837721F,
   0.4767992301F,
   0.4713967368F,
   0.4659764958F,
   0.4605387110F,
   0.4550835871F,
   0.4496113297F,
   0.4441221446F,
   0.4386162385F,
   0.4330938189F,
   0.4275550934F,
   0.4220002708F,
   0.4164295601F,
   0.4108431711F,
   0.4052413140F,
   0.3996241998F,
   0.3939920401F,
   0.3883450467F,
   0.3826834324F,
   0.3770074102F,
   0.3713171940F,
   0.3656129978F,
   0.3598950365F,
   0.3541635254F,
   0.3484186802F,
   0.3426607173F,
   0.3368898534F,
   0.3311063058F,
   0.3253102922F,
   0.3195020308F,
   0.3136817404F,
   0.3078496400F,
   0.3020059493F,
   0.2961508882F,
   0.2902846773F,
   0.2844075372F,
   0.2785196894F,
   0.2726213554F,
   0.2667127575F,
   0.2607941179F,
   0.2548656596F,
   0.2489276057F,
   0.2429801799F,
   0.2370236060F,
   0.2310581083F,
   0.2250839114F,
   0.2191012402F,
   0.2131103199F,
   0.2071113762F,
   0.2011046348F,
   0.1950903220F,
   0.1890686641F,
   0.1830398880F,
   0.1770042204F,
   0.1709618888F,
   0.1649131205F,
   0.1588581433F,
   0.1527971853F,
   0.1467304745F,
   0.1406582393F,
   0.1345807085F,
   0.1284981108F,
   0.1224106752F,
   0.1163186309F,
   0.1102222073F,
   0.1041216339F,
   0.0980171403F,
   0.0919089565F,
   0.0857973123F,
   0.0796824380F,
   0.0735645636F,
   0.0674439196F,
   0.0613207363F,
   0.0551952443F,
   0.0490676743F,
   0.0429382569F,
   0.0368072229F,
   0.0306748032F,
   0.0245412285F,
   0.0184067299F,
   0.0122715383F,
   0.0061358846F,
   0.0000000000F,
   -0.0061358846F,
   -0.0122715383F,
   -0.0184067299F,
   -0.0245412285F,
   -0.0306748032F,
   -0.0368072229F,
   -0.0429382569F,
   -0.0490676743F,
   -0.0551952443F,
   -0.0613207363F,
   -0.0674439196F,
   -0.0735645636F,
   -0.0796824380F,
   -0.0857973123F,
   -0.0919089565F,
   -0.0980171403F,
   -0.1041216339F,
   -0.1102222073F,
   -0.1163186309F,
   -0.1224106752F,
   -0.1284981108F,
   -0.1345807085F,
   -0.1406582393F,
   -0.1467304745F,
   -0.1527971853F,
   -0.1588581433F,
   -0.1649131205F,
   -0.1709618888F,
   -0.1770042204F,
   -0.1830398880F,
   -0.1890686641F,
   -0.1950903220F,
   -0.2011046348F,
   -0.2071113762F,
   -0.2131103199F,
   -0.2191012402F,
   -0.2250839114F,
   -0.2310581083F,
   -0.2370236060F,
   -0.2429801799F,
   -0.2489276057F,
   -0.2548656596F,
   -0.2607941179F,
   -0.2667127575F,
   -0.2726213554F,
   -0.2785196894F,
   -0.2844075372F,
   -0.2902846773F,
   -0.2961508882F,
   -0.3020059493F,
   -0.3078496400F,
   -0.3136817404F,
   -0.3195020308F,
   -0.3253102922F,
   -0.3311063058F,
   -0.3368898534F,
   -0.3426607173F,
   -0.3484186802F,
   -0.3541635254F,
   -0.3598950365F,
   -0.3656129978F,
   -0.3713171940F,
   -0.3770074102F,
   -0.3826834324F,
   -0.3883450467F,
   -0.3939920401F,
   -0.3996241998F,
   -0.4052413140F,
   -0.4108431711F,
   -0.4164295601F,
   -0.4220002708F,
   -0.4275550934F,
   -0.4330938189F,
   -0.4386162385F,
   -0.4441221446F,
   -0.4496113297F,
   -0.4550835871F,
   -0.4605387110F,
   -0.4659764958F,
   -0.4713967368F,
   -0.4767992301F,
   -0.4821837721F,
   -0.4875501601F,
   -0.4928981922F,
   -0.4982276670F,
   -0.5035383837F,
   -0.5088301425F,
   -0.5141027442F,
   -0.5193559902F,
   -0.5245896827F,
   -0.5298036247F,
   -0.5349976199F,
   -0.5401714727F,
   -0.5453249884F,
   -0.5504579729F,
   -0.5555702330F,
   -0.5606615762F,
   -0.5657318108F,
   -0.5707807459F,
   -0.5758081914F,
   -0.5808139581F,
   -0.5857978575F,
   -0.5907597019F,
   -0.5956993045F,
   -0.6006164794F,
   -0.6055110414F,
   -0.6103828063F,
   -0.6152315906F,
   -0.6200572118F,
   -0.6248594881F,
   -0.6296382389F,
   -0.6343932842F,
   -0.6391244449F,
   -0.6438315429F,
   -0.6485144010F,
   -0.6531728430F,
   -0.6578066933F,
   -0.6624157776F,
   -0.6669999223F,
   -0.6715589548F,
   -0.6760927036F,
   -0.6806009978F,
   -0.6850836678F,
   -0.6895405447F,
   -0.6939714609F,
   -0.6983762494F,
   -0.7027547445F,
   -0.7071067812F,
   -0.7114321957F,
   -0.7157308253F,
   -0.7200025080F,
   -0.7242470830F,
   -0.7284643904F,
   -0.7326542717F,
   -0.7368165689F,
   -0.7409511254F,
   -0.7450577854F,
   -0.7491363945F,
   -0.7531867990F,
   -0.7572088465F,
   -0.7612023855F,
   -0.7651672656F,
   -0.7691033376F,
   -0.7730104534F,
   -0.7768884657F,
   -0.7807372286F,
   -0.7845565972F,
   -0.7883464276F,
   -0.7921065773F,
   -0.7958369046F,
   -0.7995372691F,
   -0.8032075315F,
   -0.8068475535F,
   -0.8104571983F,
   -0.8140363297F,
   -0.8175848132F,
   -0.8211025150F,
   -0.8245893028F,
   -0.8280450453F,
   -0.8314696123F,
   -0.8348628750F,
   -0.8382247056F,
   -0.8415549774F,
   -0.8448535652F,
   -0.8481203448F,
   -0.8513551931F,
   -0.8545579884F,
   -0.8577286100F,
   -0.8608669386F,
   -0.8639728561F,
   -0.8670462455F,
   -0.8700869911F,
   -0.8730949784F,
   -0.8760700942F,
   -0.8790122264F,
   -0.8819212643F,
   -0.8847970984F,
   -0.8876396204F,
   -0.8904487232F,
   -0.8932243012F,
   -0.8959662498F,
   -0.8986744657F,
   -0.9013488470F,
   -0.9039892931F,
   -0.9065957045F,
   -0.9091679831F,
   -0.9117060320F,
   -0.9142097557F,
   -0.9166790599F,
   -0.9191138517F,
   -0.9215140393F,
   -0.9238795325F,
   -0.9262102421F,
   -0.9285060805F,
   -0.9307669611F,
   -0.9329927988F,
   -0.9351835099F,
   -0.9373390119F,
   -0.9394592236F,
   -0.9415440652F,
   -0.9435934582F,
   -0.9456073254F,
   -0.9475855910F,
   -0.9495281806F,
   -0.9514350210F,
   -0.9533060404F,
   -0.9551411683F,
   -0.9569403357F,
   -0.9587034749F,
   -0.9604305194F,
   -0.9621214043F,
   -0.9637760658F,
   -0.9653944417F,
   -0.9669764710F,
   -0.9685220943F,
   -0.9700312532F,
   -0.9715038910F,
   -0.9729399522F,
   -0.9743393828F,
   -0.9757021300F,
   -0.9770281427F,
   -0.9783173707F,
   -0.9795697657F,
   -0.9807852804F,
   -0.9819638691F,
   -0.9831054874F,
   -0.9842100924F,
   -0.9852776424F,
   -0.9863080972F,
   -0.9873014182F,
   -0.9882575677F,
   -0.9891765100F,
   -0.9900582103F,
   -0.9909026354F,
   -0.9917097537F,
   -0.9924795346F,
   -0.9932119492F,
   -0.9939069700F,
   -0.9945645707F,
   -0.9951847267F,
   -0.9957674145F,
   -0.9963126122F,
   -0.9968202993F,
   -0.9972904567F,
   -0.9977230666F,
   -0.9981181129F,
   -0.9984755806F,
   -0.9987954562F,
   -0.9990777278F,
   -0.9993223846F,
   -0.9995294175F,
   -0.9996988187F,
   -0.9998305818F,
   -0.9999247018F,
   -0.9999811753F,
   -1.0000000000F,
   -0.9999811753F,
   -0.9999247018F,
   -0.9998305818F,
   -0.9996988187F,
   -0.9995294175F,
   -0.9993223846F,
   -0.9990777278F,
   -0.9987954562F,
   -0.9984755806F,
   -0.9981181129F,
   -0.9977230666F,
   -0.9972904567F,
   -0.9968202993F,
   -0.9963126122F,
   -0.9957674145F,
   -0.9951847267F,
   -0.9945645707F,
   -0.9939069700F,
   -0.9932119492F,
   -0.9924795346F,
   -0.9917097537F,
   -0.9909026354F,
   -0.9900582103F,
   -0.9891765100F,
   -0.9882575677F,
   -0.9873014182F,
   -0.9863080972F,
   -0.9852776424F,
   -0.9842100924F,
   -0.9831054874F,
   -0.9819638691F,
   -0.9807852804F,
   -0.9795697657F,
   -0.9783173707F,
   -0.9770281427F,
   -0.9757021300F,
   -0.9743393828F,
   -0.9729399522F,
   -0.9715038910F,
   -0.9700312532F,
   -0.9685220943F,
   -0.9669764710F,
   -0.9653944417F,
   -0.9637760658F,
   -0.9621214043F,
   -0.9604305194F,
   -0.9587034749F,
   -0.9569403357F,
   -0.9551411683F,
   -0.9533060404F,
   -0.9514350210F,
   -0.9495281806F,
   -0.9475855910F,
   -0.9456073254F,
   -0.9435934582F,
   -0.9415440652F,
   -0.9394592236F,
   -0.9373390119F,
   -0.9351835099F,
   -0.9329927988F,
   -0.9307669611F,
   -0.9285060805F,
   -0.9262102421F,
   -0.9238795325F,
   -0.9215140393F,
   -0.9191138517F,
   -0.9166790599F,
   -0.9142097557F,
   -0.9117060320F,
   -0.9091679831F,
   -0.9065957045F,
   -0.9039892931F,
   -0.9013488470F,
   -0.8986744657F,
   -0.8959662498F,
   -0.8932243012F,
   -0.8904487232F,
   -0.8876396204F,
   -0.8847970984F,
   -0.8819212643F,
   -0.8790122264F,
   -0.8760700942F,
   -0.8730949784F,
   -0.8700869911F,
   -0.8670462455F,
   -0.8639728561F,
   -0.8608669386F,
   -0.8577286100F,
   -0.8545579884F,
   -0.8513551931F,
   -0.8481203448F,
   -0.8448535652F,
   -0.8415549774F,
   -0.8382247056F,
   -0.8348628750F,
   -0.8314696123F,
   -0.8280450453F,
   -0.8245893028F,
   -0.8211025150F,
   -0.8175848132F,
   -0.8140363297F,
   -0.8104571983F,
   -0.8068475535F,
   -0.8032075315F,
   -0.7995372691F,
   -0.7958369046F,
   -0.7921065773F,
   -0.7883464276F,
   -0.7845565972F,
   -0.7807372286F,
   -0.7768884657F,
   -0.7730104534F,
   -0.7691033376F,
   -0.7651672656F,
   -0.7612023855F,
   -0.7572088465F,
   -0.7531867990F,
   -0.7491363945F,
   -0.7450577854F,
   -0.7409511254F,
   -0.7368165689F,
   -0.7326542717F,
   -0.7284643904F,
   -0.7242470830F,
   -0.7200025080F,
   -0.7157308253F,
   -0.7114321957F,
   -0.7071067812F,
   -0.7027547445F,
   -0.6983762494F,
   -0.6939714609F,
   -0.6895405447F,
   -0.6850836678F,
   -0.6806009978F,
   -0.6760927036F,
   -0.6715589548F,
   -0.6669999223F,
   -0.6624157776F,
   -0.6578066933F,
   -0.6531728430F,
   -0.6485144010F,
   -0.6438315429F,
   -0.6391244449F,
   -0.6343932842F,
   -0.6296382389F,
   -0.6248594881F,
   -0.6200572118F,
   -0.6152315906F,
   -0.6103828063F,
   -0.6055110414F,
   -0.6006164794F,
   -0.5956993045F,
   -0.5907597019F,
   -0.5857978575F,
   -0.5808139581F,
   -0.5758081914F,
   -0.5707807459F,
   -0.5657318108F,
   -0.5606615762F,
   -0.5555702330F,
   -0.5504579729F,
   -0.5453249884F,
   -0.5401714727F,
   -0.5349976199F,
   -0.5298036247F,
   -0.5245896827F,
   -0.5193559902F,
   -0.5141027442F,
   -0.5088301425F,
   -0.5035383837F,
   -0.4982276670F,
   -0.4928981922F,
   -0.4875501601F,
   -0.4821837721F,
   -0.4767992301F,
   -0.4713967368F,
   -0.4659764958F,
   -0.4605387110F,
   -0.4550835871F,
   -0.4496113297F,
   -0.4441221446F,
   -0.4386162385F,
   -0.4330938189F,
   -0.4275550934F,
   -0.4220002708F,
   -0.4164295601F,
   -0.4108431711F,
   -0.4052413140F,
   -0.3996241998F,
   -0.3939920401F,
   -0.3883450467F,
   -0.3826834324F,
   -0.3770074102F,
   -0.3713171940F,
   -0.3656129978F,
   -0.3598950365F,
   -0.3541635254F,
   -0.3484186802F,
   -0.3426607173F,
   -0.3368898534F,
   -0.3311063058F,
   -0.3253102922F,
   -0.3195020308F,
   -0.3136817404F,
   -0.3078496400F,
   -0.3020059493F,
   -0.2961508882F,
   -0.2902846773F,
   -0.2844075372F,
   -0.2785196894F,
   -0.2726213554F,
   -0.2667127575F,
   -0.2607941179F,
   -0.2548656596F,
   -0.2489276057F,
   -0.2429801799F,
   -0.2370236060F,
   -0.2310581083F,
   -0.2250839114F,
   -0.2191012402F,
   -0.2131103199F,
   -0.2071113762F,
   -0.2011046348F,
   -0.1950903220F,
   -0.1890686641F,
   -0.1830398880F,
   -0.1770042204F,
   -0.1709618888F,
   -0.1649131205F,
   -0.1588581433F,
   -0.1527971853F,
   -0.1467304745F,
   -0.1406582393F,
   -0.1345807085F,
   -0.1284981108F,
   -0.1224106752F,
   -0.1163186309F,
   -0.1102222073F,
   -0.1041216339F,
   -0.0980171403F,
   -0.0919089565F,
   -0.0857973123F,
   -0.0796824380F,
   -0.0735645636F,
   -0.0674439196F,
   -0.0613207363F,
   -0.0551952443F,
   -0.0490676743F,
   -0.0429382569F,
   -0.0368072229F,
   -0.0306748032F,
   -0.0245412285F,
   -0.0184067299F,
   -0.0122715383F,
   -0.0061358846F,
   -0.0000000000F,
   0.0061358846F,
   0.0122715383F,
   0.0184067299F,
   0.0245412285F,
   0.0306748032F,
   0.0368072229F,
   0.0429382569F,
   0.0490676743F,
   0.0551952443F,
   0.0613207363F,
   0.0674439196F,
   0.0735645636F,
   0.0796824380F,
   0.0857973123F,
   0.0919089565F,
   0.0980171403F,
   0.1041216339F,
   0.1102222073F,
   0.1163186309F,
   0.1224106752F,
   0.1284981108F,
   0.1345807085F,
   0.1406582393F,
   0.1467304745F,
   0.1527971853F,
   0.1588581433F,
   0.1649131205F,
   0.1709618888F,
   0.1770042204F,
   0.1830398880F,
   0.1890686641F,
   0.1950903220F,
   0.2011046348F,
   0.2071113762F,
   0.2131103199F,
   0.2191012402F,
   0.2250839114F,
   0.2310581083F,
   0.2370236060F,
   0.2429801799F,
   0.2489276057F,
   0.2548656596F,
   0.2607941179F,
   0.2667127575F,
   0.2726213554F,
   0.2785196894F,
   0.2844075372F,
   0.2902846773F,
   0.2961508882F,
   0.3020059493F,
   0.3078496400F,
   0.3136817404F,
   0.3195020308F,
   0.3253102922F,
   0.3311063058F,
   0.3368898534F,
   0.3426607173F,
   0.3484186802F,
   0.3541635254F,
   0.3598950365F,
   0.3656129978F,
   0.3713171940F,
   0.3770074102F,
   0.3826834324F,
   0.3883450467F,
   0.3939920401F,
   0.3996241998F,
   0.4052413140F,
   0.4108431711F,
   0.4164295601F,
   0.4220002708F,
   0.4275550934F,
   0.4330938189F,
   0.4386162385F,
   0.4441221446F,
   0.4496113297F,
   0.4550835871F,
   0.4605387110F,
   0.4659764958F,
   0.4713967368F,
   0.4767992301F,
   0.4821837721F,
   0.4875501601F,
   0.4928981922F,
   0.4982276670F,
   0.5035383837F,
   0.5088301425F,
   0.5141027442F,
   0.5193559902F,
   0.5245896827F,
   0.5298036247F,
   0.5349976199F,
   0.5401714727F,
   0.5453249884F,
   0.5504579729F,
   0.5555702330F,
   0.5606615762F,
   0.5657318108F,
   0.5707807459F,
   0.5758081914F,
   0.5808139581F,
   0.5857978575F,
   0.5907597019F,
   0.5956993045F,
   0.6006164794F,
   0.6055110414F,
   0.6103828063F,
   0.6152315906F,
   0.6200572118F,
   0.6248594881F,
   0.6296382389F,
   0.6343932842F,
   0.6391244449F,
   0.6438315429F,
   0.6485144010F,
   0.6531728430F,
   0.6578066933F,
   0.6624157776F,
   0.6669999223F,
   0.6715589548F,
   0.6760927036F,
   0.6806009978F,
   0.6850836678F,
   0.6895405447F,
   0.6939714609F,
   0.6983762494F,
   0.7027547445F,
   0.7071067812F,
   0.7114321957F,
   0.7157308253F,
   0.7200025080F,
   0.7242470830F,
   0.7284643904F,
   0.7326542717F,
   0.7368165689F,
   0.7409511254F,
   0.7450577854F,
   0.7491363945F,
   0.7531867990F,
   0.7572088465F,
   0.7612023855F,
   0.7651672656F,
   0.7691033376F,
   0.7730104534F,
   0.7768884657F,
   0.7807372286F,
   0.7845565972F,
   0.7883464276F,
   0.7921065773F,
   0.7958369046F,
   0.7995372691F,
   0.8032075315F,
   0.8068475535F,
   0.8104571983F,
   0.8140363297F,
   0.8175848132F,
   0.8211025150F,
   0.8245893028F,
   0.8280450453F,
   0.8314696123F,
   0.8348628750F,
   0.8382247056F,
   0.8415549774F,
   0.8448535652F,
   0.8481203448F,
   0.8513551931F,
   0.8545579884F,
   0.8577286100F,
   0.8608669386F,
   0.8639728561F,
   0.8670462455F,
   0.8700869911F,
   0.8730949784F,
   0.8760700942F,
   0.8790122264F,
   0.8819212643F,
   0.8847970984F,
   0.8876396204F,
   0.8904487232F,
   0.8932243012F,
   0.8959662498F,
   0.8986744657F,
   0.9013488470F,
   0.9039892931F,
   0.9065957045F,
   0.9091679831F,
   0.9117060320F,
   0.9142097557F,
   0.9166790599F,
   0.9191138517F,
   0.9215140393F,
   0.9238795325F,
   0.9262102421F,
   0.9285060805F,
   0.9307669611F,
   0.9329927988F,
   0.9351835099F,
   0.9373390119F,
   0.9394592236F,
   0.9415440652F,
   0.9435934582F,
   0.9456073254F,
   0.9475855910F,
   0.9495281806F,
   0.9514350210F,
   0.9533060404F,
   0.9551411683F,
   0.9569403357F,
   0.9587034749F,
   0.9604305194F,
   0.9621214043F,
   0.9637760658F,
   0.9653944417F,
   0.9669764710F,
   0.9685220943F,
   0.9700312532F,
   0.9715038910F,
   0.9729399522F,
   0.9743393828F,
   0.9757021300F,
   0.9770281427F,
   0.9783173707F,
   0.9795697657F,
   0.9807852804F,
   0.9819638691F,
   0.9831054874F,
   0.9842100924F,
   0.9852776424F,
   0.9863080972F,
   0.9873014182F,
   0.9882575677F,
   0.9891765100F,
   0.9900582103F,
   0.9909026354F,
   0.9917097537F,
   0.9924795346F,
   0.9932119492F,
   0.9939069700F,
   0.9945645707F,
   0.9951847267F,
   0.9957674145F,
   0.9963126122F,
   0.9968202993F,
   0.9972904567F,
   0.9977230666F,
   0.9981181129F,
   0.9984755806F,
   0.9987954562F,
   0.9990777278F,
   0.9993223846F,
   0.9995294175F,
   0.9996988187F,
   0.9998305818F,
   0.9999247018F,
   0.9999811753F,
   1.0000000000F,
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\trigsc.h ===
/******************************************************************************
*                        Voxware Proprietary Material                         *
*                        Copyright 1996, Voxware, Inc                         *
*                            All Rights Reserved                              *
*                                                                             *
*                       DISTRIBUTION PROHIBITED without                       *
*                      written authorization from Voxware                     *
******************************************************************************/

/******************************************************************************
* Filename:     trig.h
*
* Purpose:      Provide a global pointer to a sin and a cos table. 
*
*
*
* Author/Date:  Rob Zopf
*******************************************************************************
* Modifications:
*                                                
* Comments:                                                                    
* 
* Concerns:
*
* $Header:   /export/phobos/pvcs/r_and_d/archives/scaleable/utils/trigSC.h_v   1.1   14 Apr 1998 15:33:18   weiwang  $
*
******************************************************************************/
#ifndef TRIG_SC_H
#define TRIG_SC_H

#define LOG2_TRIG_SIZE      8
#define TRIG_SIZE           (1<<LOG2_TRIG_SIZE)
#define TRIG_MASK           (TRIG_SIZE-1)

#endif /* TRIG_SC_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\trigsc.c ===
/******************************************************************************
*                        Voxware Proprietary Material                         *
*                        Copyright 1996, Voxware, Inc                         *
*                            All Rights Reserved                              *
*                                                                             *
*                       DISTRIBUTION PROHIBITED without                       *
*                      written authorization from Voxware                     *
******************************************************************************/

/******************************************************************************
* Filename:     trig.c
*                                                              
* Purpose:      Provide a global pointer to a sin and a cos table.
*                                                                          
*                                                                   
* Author/Date:  Rob Zopf        
*******************************************************************************
* Modifications:
*                                                
* Comments: The table MUST include the value at 2 PI!                                                                   
* 
* Concerns:
*
* $Header:   /export/phobos/pvcs/r_and_d/archives/scaleable/utils/trigSC.c_v   1.3   16 Apr 1998 13:28:18   bobd  $
* 
******************************************************************************/
#include "codec.h"
#include "trigSC.h"

#include "xvocver.h"

/*-------------------------------------------------------
  WARNING!! In OverAdd.c it is assumed that the trig
   tables range from zero to and including 2 PI!
   This save computation in computing phase indices
   that are modulo 2 PI.  Be sure the table includes 
   the value at 2 PI.
-------------------------------------------------------*/

#if (LOG2_TRIG_SIZE==10)
const float trigTBL_32[] = 
{
#include "trgTblSC.h"
};
#endif

#if (LOG2_TRIG_SIZE==8)
const float trigTBL_32[] = 
{
#include "trgTbl8.h"
};
#endif

const float *sinTBL_32 = trigTBL_32;
const float *cosTBL_32 = trigTBL_32 + TRIG_SIZE/4;

const float fRadiansToIndex = (float)TRIG_SIZE/TWOPI;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\uvphase.c ===
/******************************************************************************
*                        Voxware Proprietary Material                         *
*                        Copyright 1996, Voxware, Inc                         *
*                            All Rights Reserved                              *
*                                                                             *
*                       DISTRIBUTION PROHIBITED without                       *
*                      written authorization from Voxware                     *
******************************************************************************/

/******************************************************************************
* Filename:       UVPhase.c
*
* Purpose:        Add random phase to unvoiced harmonics.
*
* Functions:      UnvoicedPhase()
*
* Author/Date:    Bob Dunn 12/18/97
*******************************************************************************
* Modifications:
*
* Comments:
*
* Concerns:
*
* $Header:   /export/phobos/pvcs/r_and_d/archives/scaleable/decode/UVPhase.c_v   1.3   16 Mar 1998 15:16:16   weiwang  $
******************************************************************************/
#include <stdlib.h>
#include <assert.h>
#include "vLibMath.h"

#include "codec.h"
#include "UVPhase.h"

#include "xvocver.h"

/*---------------------------------------------------------------
  Scale factor to generate uniform random number on [0,TWOPI]
---------------------------------------------------------------*/
static const float fPhaseScale = NURAND_SCALE*TWOPI;

/*******************************************************************************
*
* Function:  UnvoicedPhase()
*
* Action:    Add random phase to unvoiced harmonics.
*
* Input:     float *pfPhase     -> harmonic phases
*            int    iHarmonics  -> total number of harmonics
*            int    iVoicHarm   -> number of voiced harmonics
*            long  *plRandSeed --> address to the random seed
*
* Output:    float *pfPhase     -> harmonic phases
*
* Globals:   none
*
* Return:    void
********************************************************************************
*
* Modifications:
*
* Comments:
*
* Concerns/TBD:
*******************************************************************************/

void UnvoicedPhase( float *pfPhase,
                    int    iHarmonics,
                    int    iVoicHarm,
                    long  *plRandSeed
                  )
{
   int   i;

   assert(pfPhase != NULL && plRandSeed != NULL);

   /*---------------------------------------------------------------
     Add a random phase above the cutoff for noise-like synthesis
   ---------------------------------------------------------------*/
   for (i=iVoicHarm; i<iHarmonics; i++) {
      pfPhase[i] = fPhaseScale*(float)NuRand(plRandSeed);
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\uvphase.h ===
/******************************************************************************
*                        Voxware Proprietary Material                         *
*                        Copyright 1996, Voxware, Inc                         *
*                            All Rights Reserved                              *
*                                                                             *
*                       DISTRIBUTION PROHIBITED without                       *
*                      written authorization from Voxware                     *
******************************************************************************/

/******************************************************************************
* Filename:       UVPhase.h
*
* Purpose:        Add random phase to unvoiced harmonics.
*
* Functions:      UnvoicedPhase()
*
* Author/Date:    Bob Dunn 12/18/97
*******************************************************************************
* Modifications:
*
* Comments:
*
* Concerns:
*
* $Header:   /export/phobos/pvcs/r_and_d/archives/scaleable/decode/UVPhase.h_v   1.1   18 Feb 1998 16:55:06   weiwang  $
******************************************************************************/
#ifndef UVPHASE_H
#define UVPHASE_H

/*******************************************************************************
*
* Function:  UnvoicedPhase()
*
* Action:    Add random phase to unvoiced harmonics.
*
* Input:     float *pfPhase     -> harmonic phases
*            int    iHarmonics  -> total number of harmonics
*            int    iVoicHarm   -> number of voiced harmonics
*            long  *plRandSeed --> address to the random seed
*
* Output:    float *pfPhase     -> harmonic phases
*
* Globals:   none
*
* Return:    void
********************************************************************************
*
* Modifications:
*
* Comments:
*
* Concerns/TBD:
*******************************************************************************/

void UnvoicedPhase( float *pfPhase,
                    int    iHarmonics,
                    int    iVoicHarm,
                    long  *plRandSeed
                  );

#endif /* UVPHASE_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\vad.h ===
/*******************************************************************************
*                        Voxware Proprietary Material                          *
*                        Copyright 1996, Voxware, Inc                          *
*                            All Rights Reserved                               *
*                                                                              *
*                       DISTRIBUTION PROHIBITED without                        *
*                      written authorization from Voxware                      *
*******************************************************************************/

/*******************************************************************************
* Filename:       VAD.h                                                             
*                                                                              
* Purpose:        Implementation of QCELP's proposed standard.  This procedure
*		          uses their method for estimating the background noise and
*		          their formula for calculating the silence threshold.                                                            
*                                                                              
* Author/Date:    Rob Zopf 
*                 1/7/95 Modified and Rewritten for the CODEC and TeleVox by Wei Wang                                                           
********************************************************************************
* $Header:   /export/phobos/pvcs/r_and_d/archives/realtime/encode/VAD.h_v   1.0   26 Jan 1998 10:55:00   johnp  $                                                                     
*******************************************************************************/
#ifndef VAD_H
#define VAD_H

#define LOW_THRESH_LIM        160000.0F
#define HIGH_THRESH_LIM      5059644.0F

#define HIGH_ESTIMATE         500000.0F

#define INIT_NOISE_LEVEL   HIGH_THRESH_LIM
#define INIT_NOISE_THRSH   1.563645e+07F  /**** by calculation ****/

#define SILENCE        0
#define VOICED         1

#define MTH_MIN(a, b)   (((float)a<=(float)b)?(float)a:(float)b)
#define MTH_MAX(a, b)   (((float)a>=(float)b)?(float)a:(float)b)

/* voice activity detection structure */
typedef struct
{
  float threshold;
  float estimate;
  float meanVoiceEng;
  short count;
  short medianZ[3];

  float frameEng;
  float maxEng;
  short medianZ2[3];
  unsigned short HangOverCount;
} VAD;


unsigned short VoxInitVad(void **fcp);

unsigned short VoxVoiceClass(void *fcp, float frame_E, float Pv,
                                 unsigned short *pVclass);

#endif /* VAD_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\trigtbl.h ===
0.0000000000F,
0.0245412285F,
0.0490676743F,
0.0735645636F,
0.0980171403F,
0.1224106752F,
0.1467304745F,
0.1709618888F,
0.1950903220F,
0.2191012402F,
0.2429801799F,
0.2667127575F,
0.2902846773F,
0.3136817404F,
0.3368898534F,
0.3598950365F,
0.3826834324F,
0.4052413140F,
0.4275550934F,
0.4496113297F,
0.4713967368F,
0.4928981922F,
0.5141027442F,
0.5349976199F,
0.5555702330F,
0.5758081914F,
0.5956993045F,
0.6152315906F,
0.6343932842F,
0.6531728430F,
0.6715589548F,
0.6895405447F,
0.7071067812F,
0.7242470830F,
0.7409511254F,
0.7572088465F,
0.7730104534F,
0.7883464276F,
0.8032075315F,
0.8175848132F,
0.8314696123F,
0.8448535652F,
0.8577286100F,
0.8700869911F,
0.8819212643F,
0.8932243012F,
0.9039892931F,
0.9142097557F,
0.9238795325F,
0.9329927988F,
0.9415440652F,
0.9495281806F,
0.9569403357F,
0.9637760658F,
0.9700312532F,
0.9757021300F,
0.9807852804F,
0.9852776424F,
0.9891765100F,
0.9924795346F,
0.9951847267F,
0.9972904567F,
0.9987954562F,
0.9996988187F,
1.0000000000F,
0.9996988187F,
0.9987954562F,
0.9972904567F,
0.9951847267F,
0.9924795346F,
0.9891765100F,
0.9852776424F,
0.9807852804F,
0.9757021300F,
0.9700312532F,
0.9637760658F,
0.9569403357F,
0.9495281806F,
0.9415440652F,
0.9329927988F,
0.9238795325F,
0.9142097557F,
0.9039892931F,
0.8932243012F,
0.8819212643F,
0.8700869911F,
0.8577286100F,
0.8448535652F,
0.8314696123F,
0.8175848132F,
0.8032075315F,
0.7883464276F,
0.7730104534F,
0.7572088465F,
0.7409511254F,
0.7242470830F,
0.7071067812F,
0.6895405447F,
0.6715589548F,
0.6531728430F,
0.6343932842F,
0.6152315906F,
0.5956993045F,
0.5758081914F,
0.5555702330F,
0.5349976199F,
0.5141027442F,
0.4928981922F,
0.4713967368F,
0.4496113297F,
0.4275550934F,
0.4052413140F,
0.3826834324F,
0.3598950365F,
0.3368898534F,
0.3136817404F,
0.2902846773F,
0.2667127575F,
0.2429801799F,
0.2191012402F,
0.1950903220F,
0.1709618888F,
0.1467304745F,
0.1224106752F,
0.0980171403F,
0.0735645636F,
0.0490676743F,
0.0245412285F,
0.0000000000F,
-0.0245412285F,
-0.0490676743F,
-0.0735645636F,
-0.0980171403F,
-0.1224106752F,
-0.1467304745F,
-0.1709618888F,
-0.1950903220F,
-0.2191012402F,
-0.2429801799F,
-0.2667127575F,
-0.2902846773F,
-0.3136817404F,
-0.3368898534F,
-0.3598950365F,
-0.3826834324F,
-0.4052413140F,
-0.4275550934F,
-0.4496113297F,
-0.4713967368F,
-0.4928981922F,
-0.5141027442F,
-0.5349976199F,
-0.5555702330F,
-0.5758081914F,
-0.5956993045F,
-0.6152315906F,
-0.6343932842F,
-0.6531728430F,
-0.6715589548F,
-0.6895405447F,
-0.7071067812F,
-0.7242470830F,
-0.7409511254F,
-0.7572088465F,
-0.7730104534F,
-0.7883464276F,
-0.8032075315F,
-0.8175848132F,
-0.8314696123F,
-0.8448535652F,
-0.8577286100F,
-0.8700869911F,
-0.8819212643F,
-0.8932243012F,
-0.9039892931F,
-0.9142097557F,
-0.9238795325F,
-0.9329927988F,
-0.9415440652F,
-0.9495281806F,
-0.9569403357F,
-0.9637760658F,
-0.9700312532F,
-0.9757021300F,
-0.9807852804F,
-0.9852776424F,
-0.9891765100F,
-0.9924795346F,
-0.9951847267F,
-0.9972904567F,
-0.9987954562F,
-0.9996988187F,
-1.0000000000F,
-0.9996988187F,
-0.9987954562F,
-0.9972904567F,
-0.9951847267F,
-0.9924795346F,
-0.9891765100F,
-0.9852776424F,
-0.9807852804F,
-0.9757021300F,
-0.9700312532F,
-0.9637760658F,
-0.9569403357F,
-0.9495281806F,
-0.9415440652F,
-0.9329927988F,
-0.9238795325F,
-0.9142097557F,
-0.9039892931F,
-0.8932243012F,
-0.8819212643F,
-0.8700869911F,
-0.8577286100F,
-0.8448535652F,
-0.8314696123F,
-0.8175848132F,
-0.8032075315F,
-0.7883464276F,
-0.7730104534F,
-0.7572088465F,
-0.7409511254F,
-0.7242470830F,
-0.7071067812F,
-0.6895405447F,
-0.6715589548F,
-0.6531728430F,
-0.6343932842F,
-0.6152315906F,
-0.5956993045F,
-0.5758081914F,
-0.5555702330F,
-0.5349976199F,
-0.5141027442F,
-0.4928981922F,
-0.4713967368F,
-0.4496113297F,
-0.4275550934F,
-0.4052413140F,
-0.3826834324F,
-0.3598950365F,
-0.3368898534F,
-0.3136817404F,
-0.2902846773F,
-0.2667127575F,
-0.2429801799F,
-0.2191012402F,
-0.1950903220F,
-0.1709618888F,
-0.1467304745F,
-0.1224106752F,
-0.0980171403F,
-0.0735645636F,
-0.0490676743F,
-0.0245412285F,
-0.0000000000F,
0.0245412285F,
0.0490676743F,
0.0735645636F,
0.0980171403F,
0.1224106752F,
0.1467304745F,
0.1709618888F,
0.1950903220F,
0.2191012402F,
0.2429801799F,
0.2667127575F,
0.2902846773F,
0.3136817404F,
0.3368898534F,
0.3598950365F,
0.3826834324F,
0.4052413140F,
0.4275550934F,
0.4496113297F,
0.4713967368F,
0.4928981922F,
0.5141027442F,
0.5349976199F,
0.5555702330F,
0.5758081914F,
0.5956993045F,
0.6152315906F,
0.6343932842F,
0.6531728430F,
0.6715589548F,
0.6895405447F,
0.7071067812F,
0.7242470830F,
0.7409511254F,
0.7572088465F,
0.7730104534F,
0.7883464276F,
0.8032075315F,
0.8175848132F,
0.8314696123F,
0.8448535652F,
0.8577286100F,
0.8700869911F,
0.8819212643F,
0.8932243012F,
0.9039892931F,
0.9142097557F,
0.9238795325F,
0.9329927988F,
0.9415440652F,
0.9495281806F,
0.9569403357F,
0.9637760658F,
0.9700312532F,
0.9757021300F,
0.9807852804F,
0.9852776424F,
0.9891765100F,
0.9924795346F,
0.9951847267F,
0.9972904567F,
0.9987954562F,
0.9996988187F,
1.0000000000F
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\vad2.c ===
/*******************************************************************************
*                        Voxware Proprietary Material                          *
*                        Copyright 1998, Voxware, Inc                          *
*                            All Rights Reserved                               *
*                                                                              *
*                       DISTRIBUTION PROHIBITED without                        *
*                      written authorization from Voxware                      *
*******************************************************************************/

/*******************************************************************************
* Filename:          VAD.c                                                         
*                                                                              
* Purpose:           Voice Activity Detector                                                          
*                                                                              
* Functions:         VAD(), initVAD(), freeVAD()                                                          
*                                                                              
* Author/Date:       Rob Zopf/10/09/98 - Code based on JGA                                                          
********************************************************************************
* Modifications:
*                   
* Comments:                                                                      
* 
* Concerns:
*
* 
*******************************************************************************/
#define WRITE_OUT  0
#if (WRITE_OUT==1)
#include <stdio.h>
#endif

#include <stdlib.h>
#include <math.h>
#include <assert.h>
#include "vLibMath.h"
#include "VoxMem.h"
#include "VAD2.h"

#include "xvocver.h"

/******************************************************************************
                P R I V A T E   V A D   M E M   B L O C K 
 =============================================================================*/
typedef struct
{
   float dBFrameEnergy;       /* Future frame energy in dB                    */
   short SkippedFrames;       /* Used to skip the first few frames from VAD   */
   float NominalVoiced;       /* Voiced Energy Estimate in dB                 */
   float NominalBckGrnd;      /* Background Energy Estimate in dB             */
   short VADHangoverSoFar;    /* Running Hangover Frame Total                 */
   short VBHangoverSoFar;     /* Running Voiced Background Hangover Total     */
   short PrevVAD;             /* Last VAD Decision                            */
   float sbnr;                /* signal-to-backgroundnoise-ratio              */

} VAD_MemBlk;

/******************************************************************************/


/******************************************************************************
                         V A D   # D E F I N E S 
 =============================================================================*/
#define FRAME_RATE      (1.0F/0.0225F)
                                 /* Frames per Second (needed for decay rates */

#define MAX_PITCH_CORR  (1.0F)   /* can use to tune thresholds if input
                                    correlation is funny                      */

#define VOICED_TH       (MAX_PITCH_CORR*0.7F)
                                 /* frame is assumed to be voiced if corr at  */
                                 /* the pitch lag is greater than this        */

#define BCKGRND_TH      (MAX_PITCH_CORR*0.5F)
                                 /* frame is assumed to be background noise   */
                                 /* or unvoiced if the correlation is less    */

#define VOICED_DEC      (5.0F/FRAME_RATE)
                                 /* Decrement the nominal voiced frame energy */
                                 /* estimate my this much each voiced frame   */

#define BCKGRND_INC     (44.4444F/FRAME_RATE)
                                 /* Increment the nominal background noise    */
                                 /* estimate each frame by this amount        */

#define SKIP_FRAMES     4        /* Skip these frames to avoid setting BckGrnd*/
                                 /* estimate to zero at the start of the file */

#define VAD_TH          0.25F    /* VAD Threshold (will be multiplied by the  */
                                 /* difference between the voiced and bckgrnd */
                                 /* energy estimates                          */

#define VAD_ON_TRIGGER  0.05F

#define VAD_OFF_TRIGGER 0.05F

#define SILENCE_TH      10.0F    /* lower than this in dB is silence for sure */

#define MIN_SNR_TH      15.0F    /* Maintain at least this SNR estimate       */

#define INIT_VOICED_ESTIMATE  70.0F 
                                 /* dB initial setting                        */

#define INIT_BCKGRND_ESTIMATE 50.0F
                                 /* dB initial setting                        */

#define VOICED_BCKGRND_THRES  10.0F
                                 /* dB                                        */

#define VOICED_CORR_THRES     (MAX_PITCH_CORR*0.513F)
                                 /* correlation threshold to determine if     */
                                 /* background noise is background speech     */

#define VOICED_BCKGRND_HANGOVER 4
                                 /* hangover frames for voiced background flag*/

#define SBNR_UPDATE_RATE      0.85F

#define MAX_HANGOVER          40
#define SBNR_AT_MAX           15.0F

#define MIN_HANGOVER          10
#define SBNR_AT_MIN           35.0F

#define SLOPE                 ((MIN_HANGOVER-MAX_HANGOVER)/((float)(SBNR_AT_MIN-SBNR_AT_MAX)))
#define INTERCEPT             (MAX_HANGOVER-(SLOPE*SBNR_AT_MAX))

#define SBNR2HANGOVER         0.666F

/******************************************************************************/


/*******************************************************************************
* Function: VoiceActivity()
*
* Action: Perform Voice Activity Detection
*
* Input: *hVADMemBlk       - the VAD memory block 
*        FutureFrameEnergy - the energy of the next frame (the VAD uses a 
*                            one frame lookahead to avoid misclassifying onsets)
*        PitchCorr         - the normalized autocorrelation at the pitch lag 
*                            for the current frame.
*
* Output:
*        *VAD              - the activity flag : active speech =  ACTIVE_SPEECH
*                                                background    = !ACTIVE_SPEECH
*        *BckgrndSpeech    - a flag that signals the presence of possible 
*                            speech in the background noise.  This flag could
*                            be used to set Pv to zero, or be used to control
*                            the mode of a variable rate codec.
*                                                bckgrnd speech=  ACTIVE_SPEECH
*                                                non-speech    = !ACTIVE_SPEECH 
*
* Globals:      none
*
* Return:	none
********************************************************************************
* Implementation/Detailed Description:
*
* References:
********************************************************************************
* Modifications:
*
* Comments:
*
* Concerns/TBD:
*******************************************************************************/

void VoiceActivity(void *hVADMemBlk, float FutureFrameEnergy, float PitchCorr, short *VAD,
         short *BckgrndSpeech)
{
   VAD_MemBlk *VADMemBlk;
   float       dBFutureFrameEnergy;
   float       dBCurrentFrameEnergy;
   float       VADThreshold;
   float       sbnr;                   /* signal-to-background-noise ratio    */
   short       FrameVAD;               /* Instantaneous VAD decision for frame*/

   /*------------------------------------------------
     Initialize Variables
     ------------------------------------------------*/
   VADMemBlk                = (VAD_MemBlk *)hVADMemBlk;
   dBCurrentFrameEnergy     = VADMemBlk->dBFrameEnergy;
   dBFutureFrameEnergy      = 10.0F*(float)log10(FutureFrameEnergy); /* try use RL later */
   VADMemBlk->dBFrameEnergy = dBFutureFrameEnergy;

   /*------------------------------------------------
      Update Nominal Voiced Energy Estimate.  
      ===============================================
      
      The energy estimate is only updated when the 
      pitch correlation is greater than a threshold
      indicating that the frame is most likely voiced.

      The estimate is first decreased slightly, and 
      then compared to the current frame energy to 
      see which is greater.
     ------------------------------------------------*/
   if (PitchCorr > VOICED_TH)
   {
      VADMemBlk->NominalVoiced -= VOICED_DEC;
      if (dBCurrentFrameEnergy > VADMemBlk->NominalVoiced)
         VADMemBlk->NominalVoiced = dBCurrentFrameEnergy;
   }
   /*------------------------------------------------
      Update Nominal Background Noise Energy Estimate.  
      ===============================================
      
      The energy estimate is only updated when the 
      pitch correlation is less than a threshold
      indicating that the frame is most likely 
      background noise or unvoiced.

      The estimate is first increased slightly, and 
      then compared to the current frame energy to 
      see which is less.

      Skip the first few frames for file robustness
      and initial lookahead energy.
     ------------------------------------------------*/
   if (VADMemBlk->SkippedFrames > SKIP_FRAMES)
   {
      if (PitchCorr < BCKGRND_TH)
      {
         VADMemBlk->NominalBckGrnd += BCKGRND_INC;
         if ((dBCurrentFrameEnergy < VADMemBlk->NominalBckGrnd)&&
            (dBCurrentFrameEnergy > SILENCE_TH))
         {
            VADMemBlk->NominalBckGrnd = dBCurrentFrameEnergy;
         }
      }
   }

   /*-------------------------------------------------
      Estimate the signal-to-background-noise energy
      ratio.
   ---------------------------------------------------*/
   sbnr = VADMemBlk->sbnr*SBNR_UPDATE_RATE + 
         (VADMemBlk->NominalVoiced - VADMemBlk->NominalBckGrnd)*
         (1.0F-SBNR_UPDATE_RATE);


   /*-------------------------------------------------
      Calculate the VAD Energy Threshold in dB 
      based on the estimated nominal voiced energy 
      level and the estimated nominal background noise
      energy level.
   ---------------------------------------------------*/
   if (VADMemBlk->PrevVAD==ACTIVE_SPEECH)
      VADThreshold = (sbnr*(VAD_TH-VAD_ON_TRIGGER)) + VADMemBlk->NominalBckGrnd;
   else
      VADThreshold = (sbnr*(VAD_TH+VAD_OFF_TRIGGER))+ VADMemBlk->NominalBckGrnd;


   /*-------------------------------------------------
      Maintain a Minimum SNR for VAD operation
   ---------------------------------------------------*/
   if (VADMemBlk->SkippedFrames > SKIP_FRAMES)
   {
      if (sbnr < MIN_SNR_TH)
      {
         VADMemBlk->NominalBckGrnd = VADMemBlk->NominalVoiced - MIN_SNR_TH;
      }
   }


   /*--------------------------------------------------
      Make VAD decision on current frame based on 
      frame energy for current frame and future frame.
   ----------------------------------------------------*/
   if ((dBCurrentFrameEnergy > VADThreshold)||(dBFutureFrameEnergy > VADThreshold))
   {
      FrameVAD = ACTIVE_SPEECH;
   }
   else
   {
      FrameVAD = !ACTIVE_SPEECH;
   }

   *VAD = FrameVAD;
   if (FrameVAD!=ACTIVE_SPEECH)
   {
      if (VADMemBlk->PrevVAD==ACTIVE_SPEECH)
      {
      /*---------------------------------------------------
         Set the hangover for this frame based on the 
         estimated signal-to-background-noise energy ratio.
         Use a simple 1st order equation to map lower sbnr
         with a greater hangover.
      -----------------------------------------------------*/
         if (sbnr <= SBNR_AT_MAX)
            VADMemBlk->VADHangoverSoFar = MAX_HANGOVER;
         else if (sbnr >= SBNR_AT_MIN)
            VADMemBlk->VADHangoverSoFar = MIN_HANGOVER;
         else
            VADMemBlk->VADHangoverSoFar = (short)(SLOPE*sbnr+INTERCEPT);      
      }
      VADMemBlk->VADHangoverSoFar--;
      if (VADMemBlk->VADHangoverSoFar > 0)
         *VAD = ACTIVE_SPEECH;
      else
         VADMemBlk->VADHangoverSoFar = 0;
   }    

   /*------------------------------------------------------
      Background Speech Signal Flag Logic

      The Background Speech Flag can be used by the codec 
      to improve synthesis of harmonic like background noise.  
      This could include babble or interfering talker.  Here,
      we just basically look at the correlation and if it
      is high, make the assumption that the background 
      noise is some sort of voiced speech, which would 
      sound better if synthesized with a non-zero Pv.

      This really should be part of Pv and should not be
      here.
   ---------------------------------------------------------*/
   *BckgrndSpeech = FrameVAD;
    if ((sbnr > VOICED_BCKGRND_THRES)&&(PitchCorr > VOICED_CORR_THRES))
      *BckgrndSpeech = ACTIVE_SPEECH;

   /* Some hangover for the decision */
   if (*BckgrndSpeech == ACTIVE_SPEECH)
   {
      VADMemBlk->VBHangoverSoFar = 0;
   }
   else
   {
      if (VADMemBlk->VBHangoverSoFar <= VOICED_BCKGRND_HANGOVER)
      {
         *BckgrndSpeech = ACTIVE_SPEECH;
      }

      VADMemBlk->VBHangoverSoFar++;
      if (VADMemBlk->VBHangoverSoFar > VOICED_BCKGRND_HANGOVER+1)
      {
         VADMemBlk->VBHangoverSoFar = VOICED_BCKGRND_HANGOVER+1;
      }
   }

   VADMemBlk->SkippedFrames++;
   if (VADMemBlk->SkippedFrames > SKIP_FRAMES)
   {
      VADMemBlk->SkippedFrames = SKIP_FRAMES+1;
   }

   VADMemBlk->PrevVAD = FrameVAD;
   VADMemBlk->sbnr    = sbnr;

#if (WRITE_OUT==1)
{
static FILE *f1, *f2;
static int init=0;
short tempbuf[180];
int i;

   if (init==0)
   {
      init=1;
      f1 = fopen("VOICED_NEW.out", "w");
      f2 = fopen("VAD_NEW.out", "w");
   }
   for (i=0;i<180;i++)
      tempbuf[i] = *BckgrndSpeech;

   fwrite(tempbuf, sizeof(short), 180, f1);

   for (i=0;i<180;i++)
      tempbuf[i] = *VAD;

   fwrite(tempbuf, sizeof(short), 180, f2);

}

#endif

}


/*******************************************************************************
* Function: initVAD()
*
* Action: initialize the VAD memory block
*
* Input: **hVADMemBlk -  handle to the memory block
*
* Output: *hVADMemBlk -  pointer to the allocated and initialized memory
*
* Globals:        none
*
* Return:	unsigned short : 0 = successful memory allocation
*                                1 = failed memory allocation
*               
********************************************************************************
* Implementation/Detailed Description:
*
* References:
********************************************************************************
* Modifications:
*
* Comments:
*
* Concerns/TBD:
*******************************************************************************/
unsigned short initVAD(void **hVADMemBlk)
{
   VAD_MemBlk  *VADMemBlk;

   if (VOX_MEM_INIT(VADMemBlk = *hVADMemBlk, 1, sizeof(VAD_MemBlk)) != 0)
   {
      return 1;
   }
   VADMemBlk->NominalVoiced    = INIT_VOICED_ESTIMATE;
   VADMemBlk->NominalBckGrnd   = INIT_BCKGRND_ESTIMATE;
   VADMemBlk->dBFrameEnergy    = INIT_BCKGRND_ESTIMATE;
   VADMemBlk->SkippedFrames    = 0;
   VADMemBlk->VBHangoverSoFar  = 0;
   VADMemBlk->VADHangoverSoFar = 0;
   VADMemBlk->PrevVAD          = ACTIVE_SPEECH;
   VADMemBlk->sbnr             = INIT_VOICED_ESTIMATE-INIT_BCKGRND_ESTIMATE;

   return 0;
}

/*******************************************************************************
* Function: freeVAD()
*
* Action: free the allocated memory used by the VAD
*
* Input: **hVADMemBlk - handle to the VAD memory
*
* Output:
*
* Globals:      none
*
* Return:	void
********************************************************************************
* Implementation/Detailed Description:
*
* References:
********************************************************************************
* Modifications:
*
* Comments:
*
* Concerns/TBD:
*******************************************************************************/
void freeVAD(void **hVADMemBlk)
{
   VOX_MEM_FREE(*hVADMemBlk);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\vad2.h ===
/*******************************************************************************
*                        Voxware Proprietary Material                          *
*                        Copyright 1996, Voxware, Inc                          *
*                            All Rights Reserved                               *
*                                                                              *
*                       DISTRIBUTION PROHIBITED without                        *
*                      written authorization from Voxware                      *
*******************************************************************************/

/*******************************************************************************
* Filename:          VAD.h                                                        
*                                                                              
* Purpose:           Voice Activity Detector                                                          
*                                                                              
* Functions:         VAD(), initVAD(), freeVAD()                                                          
*                                                                              
* Author/Date:       Rob Zopf/10/09/98 - Code based on JGA                                                          
********************************************************************************
* Modifications:
*                   
* Comments:                                                                      
* 
* Concerns:
*
* 
*******************************************************************************/


#define ACTIVE_SPEECH  1


/*******************************************************************************
* Function: VoiceActivity()
*
* Action: Perform Voice Activity Detection
*
* Input: *hVADMemBlk       - the VAD memory block 
*        FutureFrameEnergy - the energy of the next frame (the VAD uses a 
*                            one frame lookahead to avoid misclassifying onsets)
*        PitchCorr         - the normalized autocorrelation at the pitch lag 
*                            for the current frame.
*
* Output:
*        *VAD              - the activity flag : active speech =  ACTIVE_SPEECH
*                                                background    = !ACTIVE_SPEECH
*        *BckgrndSpeech    - a flag that signals the presence of possible 
*                            speech in the background noise.  This flag could
*                            be used to set Pv to zero, or be used to control
*                            the mode of a variable rate codec.
*                                                bckgrnd speech=  ACTIVE_SPEECH
*                                                non-speech    = !ACTIVE_SPEECH 
*
* Globals:      none
*
* Return:	none
********************************************************************************
* Implementation/Detailed Description:
*
* References:
********************************************************************************
* Modifications:
*
* Comments:
*
* Concerns/TBD:
*******************************************************************************/

void VoiceActivity(void *hVADMemBlk, float FutureFrameEnergy, float PitchCorr, short *VAD,
         short *BckgrndSpeech);

/*******************************************************************************
* Function: initVAD()
*
* Action:
*
* Input:
*
* Output:
*
* Globals:        none
*
* Return:		  VOXErr : Voxware return code
********************************************************************************
* Implementation/Detailed Description:
*
* References:
********************************************************************************
* Modifications:
*
* Comments:
*
* Concerns/TBD:
*******************************************************************************/
unsigned short initVAD(void **hVADMemBlk);


/*******************************************************************************
* Function: freeVAD()
*
* Action:
*
* Input:
*
* Output:
*
* Globals:        none
*
* Return:		  VOXErr : Voxware return code
********************************************************************************
* Implementation/Detailed Description:
*
* References:
********************************************************************************
* Modifications:
*
* Comments:
*
* Concerns/TBD:
*******************************************************************************/
void freeVAD(void **hVADMemBlk);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\vcierror.h ===
/******************************************************************************
*                        Voxware Proprietary Material
*                        Copyright 1996, Voxware, Inc
*                            All Rights Reserved
*
*                       DISTRIBUTION PROHIBITED without
*                      written authorization from Voxware
******************************************************************************/

/******************************************************************************
* Filename:        vciError.h
*
* Purpose:     Defines the Voxware Core Interface (VCI) error values
*
* Author/Date: Ilan Berci, Sept. 25, 1996
*******************************************************************************
*
* Modifications:
*
* Comments:
*
* Concerns:
*
* $Header:   P:/r_and_d/archives/common/vci/vciError.h_v   1.4   28 Aug 1998 10:36:10   johnp  $
******************************************************************************/

#ifndef _VCI_ERROR_H_
#define _VCI_ERROR_H_

#ifndef _VCI_RETCODE_
#define _VCI_RETCODE_
typedef unsigned short VCI_RETCODE; /* Voxware Core Interface error type.     */
                                    /* This variable is also defined in vci.h */
#endif  /** #ifndef _VCI_RETCODE_ **/

#define VCI_NO_ERROR                      0
#define VCI_FAILED_MEM_ALLOC           6000
#define VCI_NOT_VCI_HANDLE             6100
#define VCI_INCOMPATIBLE_HANDLE        6105
#define VCI_NOT_ENC_HANDLE             6110
#define VCI_NOT_DEC_HANDLE             6115
#define VCI_NULL_IO_BLOCK              6120
#define VCI_NULL_PCM_BUFFER            6125
#define VCI_NULL_VOX_BUFFER            6130
#define VCI_INVALID_R_BIT_OFFSET       6135
#define VCI_INVALID_W_BIT_OFFSET       6140
#define VCI_INVALID_R_BYTE_OFFSET      6145
#define VCI_INVALID_W_BYTE_OFFSET      6150
#define VCI_INSUFFICIENT_VOX_DATA      6155
#define VCI_NULL_INFO_BLOCK            6160
#define VCI_ARG_OUT_OF_RANGE           6165
#define VCI_NULL_ARG                   6170
#define VCI_NO_EXTENSION_SUPPORT       6175
#define VCI_WRONG_PITCH_MODE           6180
#define VCI_CODEC_NOT_SUPPORTED        6500 
#define VCI_CODEC_OUT_OF_DATE          6501 
#define VCI_EXT_OUT_OF_DATE            6502
#define VCI_EXTENSION_NOT_ENABLED      6503 
#define VCI_BITSTREAM_CORRUPTED        6185
#define VCI_BITSTREAM_NOT_SUPPORTED    6186
#define VCI_BITSTREAM_INSUFFICIENT     6187
#define VCI_BITSTREAM_FULL             6189
#define VCI_RATE_SET_TO_MAX            6190
#define VCI_RATE_INVALID               6191
#define VCI_DYNAMIC_ARG_NOT_FOUND      6200
#define VCI_PLUS_NOT_INITIALIZED       6210

#define VCI_IO_BLK_PARAM_CHECK(a) \
   if(!a) \
      return VCI_NULL_ARG; \
   if(!a->pVoxBuffer) \
      return VCI_NULL_VOX_BUFFER; \
   if(!(a->pPCMBuffer)) \
      return VCI_NULL_PCM_BUFFER; \
   if(a->wVoxBufferReadByteOffset>=a->wVoxBufferSize) \
      return VCI_INVALID_R_BYTE_OFFSET; \
   if(a->wVoxBufferWriteByteOffset>=a->wVoxBufferSize) \
      return VCI_INVALID_W_BYTE_OFFSET; \
   if(a->chVoxBufferReadBitOffset>7) \
      return VCI_INVALID_R_BIT_OFFSET; \
   if(a->chVoxBufferWriteBitOffset>7) \
      return VCI_INVALID_W_BIT_OFFSET; 

#define VCI_EXTRACT_IO_BLK_PARAM_CHECK(a) \
   if(!a) \
      return VCI_NULL_ARG; \
   if(!a->pVoxBuffer) \
      return VCI_NULL_VOX_BUFFER; \
   if(a->wVoxBufferReadByteOffset>=a->wVoxBufferSize) \
      return VCI_INVALID_R_BYTE_OFFSET; \
   if(a->wVoxBufferWriteByteOffset>=a->wVoxBufferSize) \
      return VCI_INVALID_W_BYTE_OFFSET; \
   if(a->chVoxBufferReadBitOffset>7) \
      return VCI_INVALID_R_BIT_OFFSET; \
   if(a->chVoxBufferWriteBitOffset>7) \
      return VCI_INVALID_W_BIT_OFFSET; 

#define VCI_IO_BLK_PARAM_CHECK_ENC(a) \
   if(!a) \
      return VCI_NULL_ARG; \
   if(!a->pPCMBuffer) \
      return VCI_NULL_PCM_BUFFER; \
   if(!a->pVoxBuffer) \
      return VCI_NULL_VOX_BUFFER; \
   if(a->wVoxBufferWriteByteOffset>=a->wVoxBufferSize) \
      return VCI_INVALID_W_BYTE_OFFSET; \
   if(a->chVoxBufferWriteBitOffset>7) \
      return VCI_INVALID_W_BIT_OFFSET; 

#define VCI_IO_BLK_PARAM_CHECK_DEC(a) \
   if(!a) \
      return VCI_NULL_ARG; \
   if(!a->pPCMBuffer) \
      return VCI_NULL_PCM_BUFFER; \
   if(!a->pVoxBuffer) \
      return VCI_NULL_VOX_BUFFER; \
   if(a->wVoxBufferReadByteOffset>=a->wVoxBufferSize) \
      return VCI_INVALID_R_BYTE_OFFSET; \
   if(a->chVoxBufferReadBitOffset>7) \
      return VCI_INVALID_R_BIT_OFFSET;

#define VCI_SIL_IO_BLK_PARAM_CHECK_DEC(a) \
   if(!a) \
      return VCI_NULL_ARG; \
   if(!a->pPCMBuffer) \
      return VCI_NULL_PCM_BUFFER;

#endif /** #ifndef _VCI_ERROR_H_ **/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\vciplssc.c ===
/******************************************************************************
*                        Voxware Proprietary Material
*                        Copyright 1996, Voxware, Inc
*                            All Rights Reserved
*
*                       DISTRIBUTION PROHIBITED without
*                      written authorization from Voxware
******************************************************************************/

/******************************************************************************
* Filename:        vciPlsSC.c  
*
* Purpose:     Additional VCI functions specific to the SC codecs      
*
* Functions:   vciSetFramesSkippedSC, ...etc
*
* Author/Date: John Puterbaugh, Ilan Berci & Epiphany Vera    97/05/20
*******************************************************************************
*
* Modifications:
*
* Comments:
*
* Concerns:
*
* $Header:   P:/r_and_d/archives/scaleable/vci/vciPlsSC.c_v   1.17   02 Sep 1998 08:39:38   xiaoqins  $
******************************************************************************/
#include <stdlib.h>
#include <assert.h>
#include <string.h>
#include <math.h> /* log10( ) */

#include "vci.h"
#include "vciError.h"
#include "vciPriv.h"
#include "VoxMem.h"
#include "codec.h"
#include "rate.h"
#include "DecPlsSC.h"
#include "paramSC.h"
#include "DecPriSC.h"

#ifndef DECODE_ONLY
#include "EncSC.h"
#endif

#include "FadeSC.h"

#include "vciPlus.h"
#include "vciPlsSC.h"

#include "xvocver.h"

#define MIN_WARP 0.5F
#define MAX_WARP 5.0F
#define DB2LEVEL_VALUE  28.3333333333F 

/* ************************************************************************* */
/*                                                                           */
/* FUNCTION: vciSetFramesSkippedSC()                                         */
/* PURPOSE : Tell the decoder that frames have been skipped/lost             */
/*                                                                           */
/* ************************************************************************* */
VCI_RETCODE vciSetFramesSkippedSC(void *pDecodeMemBlk, int iFramesSkipped)
{
   VCI_CODEC_BLOCK *vciCodecMblk=NULL;
   
   if(!VCI_BLOCK_CHECK(pDecodeMemBlk))
      return VCI_NOT_VCI_HANDLE;

   if(!VCI_IS_DECODE(pDecodeMemBlk))
      return VCI_NOT_DEC_HANDLE;
      
   vciCodecMblk = (VCI_CODEC_BLOCK *)pDecodeMemBlk;

   voxSetFrameSkippedSC(vciCodecMblk->hCodecMblk, iFramesSkipped);

   return VCI_NO_ERROR;
}

/* ************************************************************************* */
/*                                                                           */
/* FUNCTION: vciSetRepeatFrameFlagSC()                                       */
/* PURPOSE : Tell the decoder that the frame is a repeat.                    */
/*                                                                           */
/* ************************************************************************* */
VCI_RETCODE vciSetRepeatFrameFlagSC(void *pDecodeMemBlk)
{
   VCI_CODEC_BLOCK *vciCodecMblk;
 
   if(!VCI_BLOCK_CHECK(pDecodeMemBlk))
      return VCI_NOT_VCI_HANDLE;

   if(!VCI_IS_DECODE(pDecodeMemBlk))
      return VCI_NOT_DEC_HANDLE;

   vciCodecMblk = (VCI_CODEC_BLOCK *)pDecodeMemBlk;

   voxSetRepeatFrameSC(vciCodecMblk->hCodecMblk, 1);
 
   return VCI_NO_ERROR;
}

/* ************************************************************************* */
/*                                                                           */
/* FUNCTION: vciSetWarpFactorSC()                                            */
/* PURPOSE : Sets the warp factor for the decoder.                           */
/*                                                                           */
/* ************************************************************************* */
VCI_RETCODE vciSetWarpFactorSC(void *pDecodeMemBlk, float wWarpFactor)
{
   VCI_CODEC_BLOCK *vciCodecMblk = NULL;

   if(!VCI_BLOCK_CHECK(pDecodeMemBlk))
      return VCI_NOT_VCI_HANDLE;

   if(!VCI_IS_DECODE(pDecodeMemBlk))
      return VCI_NOT_DEC_HANDLE;

   vciCodecMblk = (VCI_CODEC_BLOCK *)pDecodeMemBlk;

   /* First make sure that the handle passed is the correct one. */
   if (vciCodecMblk->dwVciChunkID != SANITY_CHECK) 
      return VCI_NOT_VCI_HANDLE;
   if (vciCodecMblk->chEncOrDec   != DECODE_ID)    
      return VCI_NOT_DEC_HANDLE;

   if(wWarpFactor<MIN_WARP||wWarpFactor>MAX_WARP)
      return VCI_ARG_OUT_OF_RANGE;

   voxSetWarpFactorSC(vciCodecMblk->hCodecMblk, wWarpFactor);

   return VCI_NO_ERROR;
}


/* ************************************************************************* */
/*                                                                           */
/* FUNCTION: vciGetWarpFactor()                                              */
/* PURPOSE : Retrieves the warp factor setting in the  decoder.              */
/*                                                                           */
/* ************************************************************************* */
VCI_RETCODE vciGetWarpFactorSC(void *pDecodeMemBlk, float *pwWarpFactor)
{
   VCI_CODEC_BLOCK *vciCodecMblk = NULL;

   /* First make sure that the handle passed is the correct one. */
   if(!VCI_BLOCK_CHECK(pDecodeMemBlk))
      return VCI_NOT_VCI_HANDLE;

   if(!VCI_IS_DECODE(pDecodeMemBlk))
      return VCI_NOT_DEC_HANDLE;

   vciCodecMblk = (VCI_CODEC_BLOCK *)pDecodeMemBlk;

   assert(pwWarpFactor != NULL);
   *pwWarpFactor = voxGetWarpFactorSC(vciCodecMblk->hCodecMblk);

  return VCI_NO_ERROR;
}

/* ************************************************************************* */
/*                                                                           */
/* FUNCTION: vciDecodeNeedsInput()                                           */
/* PURPOSE : Checks whether the decoder needs input or not.                  */
/*                                                                           */
/* ************************************************************************* */
VCI_RETCODE vciDecodeNeedsInputSC(void *pDecodeMemBlk, unsigned char *pUnPack)
{
   VCI_CODEC_BLOCK *vciCodecMblk = NULL;

   /* First make sure that the handle passed is the correct one. */
   if(!VCI_BLOCK_CHECK(pDecodeMemBlk))
      return VCI_NOT_VCI_HANDLE;

   if(!VCI_IS_DECODE(pDecodeMemBlk))
      return VCI_NOT_DEC_HANDLE;

   vciCodecMblk = (VCI_CODEC_BLOCK *)pDecodeMemBlk;
   assert(pUnPack!= NULL);

   *pUnPack=voxGetDecReqDataFlagSC(vciCodecMblk->hCodecMblk);

   return VCI_NO_ERROR;
}

/* ************************************************************************* */
/*                                                                           */
/* FUNCTION: vciGetEnergyLevelSC()                                           */
/* PURPOSE : Gets the energy level.                                          */
/*                                                                           */
/* ************************************************************************* */
VCI_RETCODE vciGetEnergyLevelSC(void *pCodecMemBlk, short *pwEnergyLevel)
{
   VCI_CODEC_BLOCK *vciCodecMblk = NULL;
   VCI_CODEC_IO_BLOCK *vciCodecIOBlk = NULL;
   float fFrameEnergy = 0.0F ;
   float fSample;
   int i;

   assert(pwEnergyLevel!=NULL);

   /* First make sure that the handle passed is the correct one. */
   if(!VCI_BLOCK_CHECK(pCodecMemBlk))
      return VCI_NOT_VCI_HANDLE;
   vciCodecMblk = (VCI_CODEC_BLOCK *)pCodecMemBlk;

   /* vciCodeIOBlk must be attached to vciCodeMblk */
   vciCodecIOBlk = (VCI_CODEC_IO_BLOCK *)(vciCodecMblk->pVciCodecIOBlock);
   VCI_IO_BLK_PARAM_CHECK(vciCodecIOBlk);

#ifndef DECODE_ONLY
   if(VCI_IS_ENCODE(pCodecMemBlk)) {
     fFrameEnergy = ((ENC_MEM_BLK *)(vciCodecMblk->hCodecMblk))->frameEnergy;
   }
#endif

   if(VCI_IS_DECODE(pCodecMemBlk)) {
     /* compute frame_energy from PCMBuffer */
     if (vciCodecIOBlk->wSamplesInPCMBuffer > 0) {
       for (i = 0; i < vciCodecIOBlk->wSamplesInPCMBuffer; i++) {
	 fSample = (float)vciCodecIOBlk->pPCMBuffer[i];
	 fFrameEnergy += fSample * fSample;
       }

       fFrameEnergy /= (float)vciCodecIOBlk->wSamplesInPCMBuffer;
     }
   }

   *pwEnergyLevel=(short)(log10(fFrameEnergy+1.0)* DB2LEVEL_VALUE);
  
  return VCI_NO_ERROR;
}

/* ************************************************************************* */
/*                                                                           */
/* FUNCTION: vciSetInjectSilenceFlagSC()                                     */
/* PURPOSE : Perform fade-in/fade-out and background noise injection during  */
/*           packet loss.                                                    */
/*                                                                           */
/* ************************************************************************* */
VCI_RETCODE vciSetInjectSilenceFlagSC(void *pDecodeMemBlk)
{
   DEC_MEM_BLK *pDecMemBlk = NULL;

   /* First make sure that the handle passed is the correct one. */
   if(!VCI_BLOCK_CHECK(pDecodeMemBlk))
      return VCI_NOT_VCI_HANDLE;

   if(!VCI_IS_DECODE(pDecodeMemBlk))
      return VCI_NOT_DEC_HANDLE;

   pDecMemBlk = (DEC_MEM_BLK *)((VCI_CODEC_BLOCK *)pDecodeMemBlk)->hCodecMblk;
   SetCurrentFrameStateSC(pDecMemBlk->pFadeIOMemBlk, SILENCE);

   return VCI_NO_ERROR;
}

/* ************************************************************************* */
/*                                                                           */
/* FUNCTION: vciNumFramesInBufferSC()                                        */
/* PURPOSE : Counts the number of frames in the Vox buffer of the given      */
/*           codec I/O block.                                                */
/*                                                                           */
/* ************************************************************************* */
VCI_RETCODE vciNumFramesInBufferSC(const void *pVciCodecMemBlk,
                                   const VCI_CODEC_IO_BLOCK *pvciCodecIOBlk,
                                   unsigned short *pwNumFrames,
                                   unsigned short *pwByteOffset,
                                   unsigned char  *pchBitOffset)
{
   short wSeekReturn, wSeekInitial;
   unsigned short wNumFrames=0;
   const VCI_CODEC_BLOCK *vciCodecMblk = NULL;
   const unsigned short *pStreamTable = NULL;
   unsigned short wByteOffset;

    /* Do parameter checking on IO block. */
   VCI_IO_BLK_PARAM_CHECK(pvciCodecIOBlk);

   /* First make sure that the handle passed is the correct one. */
   if(!VCI_BLOCK_CHECK(pVciCodecMemBlk))
      return VCI_NOT_VCI_HANDLE;

   vciCodecMblk = (VCI_CODEC_BLOCK *)pVciCodecMemBlk;

   if(vciCodecMblk->pVciPlusMethodStruct)
      if(vciCodecMblk->pVciPlusMethodStruct->wStreamTable)
         pStreamTable = vciCodecMblk->pVciPlusMethodStruct->wStreamTable;

   assert(pwNumFrames!= NULL);

   wByteOffset = wSeekReturn=pvciCodecIOBlk->wVoxBufferReadByteOffset;

   while(wSeekReturn != pvciCodecIOBlk->wVoxBufferWriteByteOffset) {

      wSeekInitial = wSeekReturn;
      wSeekReturn = seekForward(pvciCodecIOBlk->pVoxBuffer,
                  wSeekInitial,
                  pvciCodecIOBlk->wVoxBufferWriteByteOffset,
                  pvciCodecIOBlk->wVoxBufferSize,
                  1, pStreamTable);

      if(wSeekReturn < 0)
        break;
      else
        wByteOffset = wSeekReturn;

      wNumFrames++;
   } 

   *pwByteOffset=wByteOffset;
   *pwNumFrames=wNumFrames;
   *pchBitOffset=0;

   return VCI_NO_ERROR;
}

/* ************************************************************************* */
/*                                                                           */
/* FUNCTION: vciSeekForwardSC()                                              */
/* PURPOSE : Seeks to a given frame offset.                                  */
/*                                                                           */
/* ************************************************************************* */
VCI_RETCODE vciSeekForwardSC(const void *pVciCodecMemBlk,
                             const VCI_CODEC_IO_BLOCK *pvciCodecIOBlk,
                             unsigned short wNumFrames,
                             unsigned short *pwReadOffset,
                             unsigned char  *pchBitOffset)
{
   short wSeek; 
   const VCI_CODEC_BLOCK *vciCodecMblk = NULL;
   const unsigned short *pStreamTable = NULL;

   VCI_IO_BLK_PARAM_CHECK(pvciCodecIOBlk);

   /* First make sure that the handle passed is the correct one. */
   if(!VCI_BLOCK_CHECK(pVciCodecMemBlk))
      return VCI_NOT_VCI_HANDLE;

   vciCodecMblk = (VCI_CODEC_BLOCK *)pVciCodecMemBlk; 

   if(vciCodecMblk->pVciPlusMethodStruct)
      if(vciCodecMblk->pVciPlusMethodStruct->wStreamTable)
         pStreamTable = vciCodecMblk->pVciPlusMethodStruct->wStreamTable;

   wSeek=seekForward(pvciCodecIOBlk->pVoxBuffer,
                  pvciCodecIOBlk->wVoxBufferReadByteOffset,
                  pvciCodecIOBlk->wVoxBufferWriteByteOffset,
                  pvciCodecIOBlk->wVoxBufferSize,
                  wNumFrames, 
                  pStreamTable);

   if(wSeek==-1)
      return VCI_INSUFFICIENT_VOX_DATA;
   else if(wSeek==-2)
      return VCI_BITSTREAM_CORRUPTED;
   else {
      *pwReadOffset=(unsigned short)wSeek;
      *pchBitOffset=0;
   }

   return VCI_NO_ERROR;

}

/* ************************************************************************* */
/*                                                                           */
/* FUNCTION: vciExtractFromBitStreamSC()                                     */
/* PURPOSE : Extracts the specified embedded streams from the Vox Buffer of  */
/*           the codec I/O block                                             */
/*                                                                           */
/* ************************************************************************* */
VCI_RETCODE vciExtractFromBitStreamSC(const void *pVciCodecMemBlk,
                                      const VCI_CODEC_IO_BLOCK *pvciInputIOBlk,
                                      VCI_CODEC_IO_BLOCK *pvciOutputIOBlk,
                                      unsigned long dwBitField)
{
   const VCI_CODEC_BLOCK *vciCodecMblk = NULL;
   unsigned short wReadByteOffset, wReadIncrementer, wBytesToExtract, wSkipOverBytes;
   unsigned long dwSkipBitField=0x0, dwCopyBitField=dwBitField;
   short wSeekActual, wSeekProjected, wSeekToSkip;
   const unsigned short *pStreamTable = NULL;

   VCI_EXTRACT_IO_BLK_PARAM_CHECK(pvciInputIOBlk);
   VCI_EXTRACT_IO_BLK_PARAM_CHECK(pvciOutputIOBlk);

   /* First make sure that the handle passed is the correct one. */
   if(!VCI_BLOCK_CHECK(pVciCodecMemBlk))
      return VCI_NOT_VCI_HANDLE;

   vciCodecMblk = (VCI_CODEC_BLOCK *)pVciCodecMemBlk; 

   if(vciCodecMblk->pVciPlusMethodStruct)
      if(vciCodecMblk->pVciPlusMethodStruct->wStreamTable)
         pStreamTable = vciCodecMblk->pVciPlusMethodStruct->wStreamTable;

   wReadByteOffset=pvciInputIOBlk->wVoxBufferReadByteOffset;
   pvciOutputIOBlk->wVoxBufferWriteByteOffset = pvciOutputIOBlk->wVoxBufferReadByteOffset;

   if(isValidStream(dwBitField, pStreamTable)) {
      wBytesToExtract = bytesInStream(dwBitField, pStreamTable);
      wSkipOverBytes  = 0;
   } else {
      if(!isSingleStream(dwBitField))
         return VCI_BITSTREAM_NOT_SUPPORTED;

      while(!(dwCopyBitField&0x01)) {
         dwCopyBitField>>=1;
         dwSkipBitField<<=1;
         dwSkipBitField+=1;
      }
      wBytesToExtract = bytesInStream(dwBitField, pStreamTable);
      wSkipOverBytes  = bytesInStream(dwSkipBitField, pStreamTable);
   }

   wSeekActual = pvciInputIOBlk->wVoxBufferReadByteOffset;
   while(wReadByteOffset != pvciInputIOBlk->wVoxBufferWriteByteOffset) {

      wReadIncrementer = wSeekActual;

      wSeekToSkip = (short)(wReadIncrementer+wSkipOverBytes);
      if(wSeekToSkip >= pvciInputIOBlk->wVoxBufferSize)
         wSeekToSkip = (short)(wSeekToSkip - pvciInputIOBlk->wVoxBufferSize);

      wSeekProjected  = (short)(wSeekToSkip+wBytesToExtract);
      if(wSeekProjected >= pvciInputIOBlk->wVoxBufferSize)
         wSeekProjected = (short)(wSeekProjected - pvciInputIOBlk->wVoxBufferSize);

      wSeekActual=seekForward(pvciInputIOBlk->pVoxBuffer, wReadByteOffset,
         pvciInputIOBlk->wVoxBufferWriteByteOffset,
         pvciInputIOBlk->wVoxBufferSize, 1, pStreamTable);

      if(wSeekActual<0)
         return VCI_BITSTREAM_CORRUPTED;
      else 
         wReadByteOffset=(unsigned short)wSeekActual;

      while((wReadIncrementer!=wSeekToSkip)&&(wReadIncrementer!=wReadByteOffset)) {

         /*-----------------------------------------------------
           This line was:

              pvciInputIOBlk->pVoxBuffer[wReadIncrementer++];

           but that seems unnecessary and produces a warning.
         -----------------------------------------------------*/
         wReadIncrementer++;

         if(wReadIncrementer >= pvciInputIOBlk->wVoxBufferSize)
            wReadIncrementer= (unsigned short)(wReadIncrementer-pvciInputIOBlk->wVoxBufferSize);

      } 

      while((wReadIncrementer!=wSeekProjected)&&(wReadIncrementer!=wReadByteOffset)) {
         pvciOutputIOBlk->pVoxBuffer[pvciOutputIOBlk->wVoxBufferWriteByteOffset++]=
            pvciInputIOBlk->pVoxBuffer[wReadIncrementer++];

         if(pvciOutputIOBlk->wVoxBufferWriteByteOffset >= pvciOutputIOBlk->wVoxBufferSize)
            pvciOutputIOBlk->wVoxBufferWriteByteOffset = 
            (unsigned short)(pvciOutputIOBlk->wVoxBufferWriteByteOffset - 
                    pvciOutputIOBlk->wVoxBufferSize);

         if(wReadIncrementer >= pvciInputIOBlk->wVoxBufferSize)
            wReadIncrementer = (unsigned short)(wReadIncrementer-pvciInputIOBlk->wVoxBufferSize);

         if(pvciOutputIOBlk->wVoxBufferWriteByteOffset==
            pvciOutputIOBlk->wVoxBufferReadByteOffset) 
            return VCI_BITSTREAM_INSUFFICIENT;
      }

      /* set the continuation bit to false */
      if(pvciOutputIOBlk->wVoxBufferWriteByteOffset)
         pvciOutputIOBlk->pVoxBuffer[pvciOutputIOBlk->wVoxBufferWriteByteOffset-1] &= 0x07F;
      else
         pvciOutputIOBlk->pVoxBuffer[pvciOutputIOBlk->wVoxBufferSize-1] &= 0x07F;
   }
   return VCI_NO_ERROR;
}
/* ************************************************************************* */
/*                                                                           */
/* FUNCTION: vciCombineBitStreamSC()                                         */
/* PURPOSE : Combines the specified emnedded streams from the Vox Buffer of  */
/*           the codec I/O block pointed to be pvciInputIOBlk and writes the */
/*           new stream to that pointed to be pcviOutputIOBlk.               */
/* ************************************************************************* */
VCI_RETCODE vciCombineBitStreamSC(const void *pVciCodecMemBlk,
                                  const VCI_CODEC_IO_BLOCK *pvciInputAIOBlk,
                                  const VCI_CODEC_IO_BLOCK *pvciInputBIOBlk,
                                  VCI_CODEC_IO_BLOCK *pvciOutputIOBlk,
                                  unsigned long  ScCodecA,
                                  unsigned long  ScCodecB)
{
   const VCI_CODEC_BLOCK *vciCodecMblk = NULL;
   unsigned short wBytesA, wBytesB, wBytesOut, wNumOfFrames, i, j;
   short wNumOfBytesInBuffer;
   unsigned short wReadA, wReadB;
   const VCI_CODEC_IO_BLOCK *pCodecIOTempBlk;
   unsigned long ScCodecTemp;
   const unsigned short *pStreamTable = NULL;

   /* First make sure that the handle passed is the correct one. */
   if(!VCI_BLOCK_CHECK(pVciCodecMemBlk))
      return VCI_NOT_VCI_HANDLE;

   vciCodecMblk = (VCI_CODEC_BLOCK *)pVciCodecMemBlk; 

   VCI_EXTRACT_IO_BLK_PARAM_CHECK(pvciInputAIOBlk);
   VCI_EXTRACT_IO_BLK_PARAM_CHECK(pvciInputBIOBlk);
   VCI_EXTRACT_IO_BLK_PARAM_CHECK(pvciOutputIOBlk);

   if(vciCodecMblk->pVciPlusMethodStruct)
      if(vciCodecMblk->pVciPlusMethodStruct->wStreamTable)
         pStreamTable = vciCodecMblk->pVciPlusMethodStruct->wStreamTable;

   
   if(ScCodecA&ScCodecB)
      return VCI_BITSTREAM_NOT_SUPPORTED;

   if(!isValidStream((ScCodecA|ScCodecB), pStreamTable))
      return VCI_BITSTREAM_NOT_SUPPORTED;

   /* maybe we have to do a variable shuffle */
   if(!(ScCodecA&0x01)) {
      ScCodecTemp = ScCodecA;
      ScCodecA    = ScCodecB;
      ScCodecB    = ScCodecTemp;

      pCodecIOTempBlk = pvciInputAIOBlk;
      pvciInputAIOBlk = pvciInputBIOBlk;
      pvciInputBIOBlk = pCodecIOTempBlk;
   }

   wBytesA=bytesInStream(ScCodecA, pStreamTable);
   wBytesB=bytesInStream(ScCodecB, pStreamTable);
   wBytesOut=(unsigned short)(wBytesA+wBytesB);

   /* the following block etablishes the number of itterations that we'll have to do */
   wNumOfBytesInBuffer=
      (short)(pvciInputAIOBlk->wVoxBufferWriteByteOffset
              -pvciInputAIOBlk->wVoxBufferReadByteOffset);

   if(wNumOfBytesInBuffer<=0)
      wNumOfBytesInBuffer=(short)(wNumOfBytesInBuffer + pvciInputAIOBlk->wVoxBufferSize);

   if(wNumOfBytesInBuffer%wBytesA) /* shouldn't have any left over bits */
      return VCI_BITSTREAM_CORRUPTED;

   wNumOfFrames=(unsigned short)(wNumOfBytesInBuffer/wBytesA);

   /* checking B buffer */
   wNumOfBytesInBuffer=
      (short)(pvciInputBIOBlk->wVoxBufferWriteByteOffset
             -pvciInputBIOBlk->wVoxBufferReadByteOffset);

   if(wNumOfBytesInBuffer<=0)
      wNumOfBytesInBuffer=(short)(wNumOfBytesInBuffer+pvciInputBIOBlk->wVoxBufferSize);

   if(wNumOfBytesInBuffer%wBytesB) /* shouldn't have any left over bytes */
      return VCI_BITSTREAM_CORRUPTED;

   if(wNumOfFrames!=wNumOfBytesInBuffer/wBytesB)
      return VCI_BITSTREAM_INSUFFICIENT; /* Num of frames doesn't match with A */

   /* lastly checking C buffer */
   wNumOfBytesInBuffer=
      (short)(pvciOutputIOBlk->wVoxBufferWriteByteOffset
              -pvciOutputIOBlk->wVoxBufferReadByteOffset);

   if(wNumOfBytesInBuffer<=0)
      wNumOfBytesInBuffer=(short)(wNumOfBytesInBuffer+pvciOutputIOBlk->wVoxBufferSize);

   if(wNumOfBytesInBuffer/wBytesOut<wNumOfFrames)
      return VCI_BITSTREAM_INSUFFICIENT;
   else if(wNumOfBytesInBuffer/wBytesOut==wNumOfFrames)
      if(!(wNumOfBytesInBuffer%wBytesOut)) /* need at least one extra byte!! */
         return VCI_BITSTREAM_INSUFFICIENT;
  
   wReadA=pvciInputAIOBlk->wVoxBufferReadByteOffset;
   wReadB=pvciInputBIOBlk->wVoxBufferReadByteOffset;

   for(i=0;i<wNumOfFrames;i++) {
      for(j=0;j<wBytesA;j++) {
         pvciOutputIOBlk->pVoxBuffer[pvciOutputIOBlk->wVoxBufferWriteByteOffset++]=
            pvciInputAIOBlk->pVoxBuffer[wReadA++];

         if(pvciOutputIOBlk->wVoxBufferWriteByteOffset>=pvciOutputIOBlk->wVoxBufferSize)
            pvciOutputIOBlk->wVoxBufferWriteByteOffset=
                (unsigned short)(pvciOutputIOBlk->wVoxBufferWriteByteOffset-
                                 pvciOutputIOBlk->wVoxBufferSize);

         if(wReadA>=pvciInputAIOBlk->wVoxBufferSize)
            wReadA=(unsigned short)(wReadA-pvciInputAIOBlk->wVoxBufferSize);
      }
      /* set the continuation bit */
      if(pvciOutputIOBlk->wVoxBufferWriteByteOffset)
         pvciOutputIOBlk->pVoxBuffer[pvciOutputIOBlk->wVoxBufferWriteByteOffset-1]|=0x080;
      else
         pvciOutputIOBlk->pVoxBuffer[pvciOutputIOBlk->wVoxBufferSize-1]|=0x080;

      for(j=0;j<wBytesB;j++) {
         pvciOutputIOBlk->pVoxBuffer[pvciOutputIOBlk->wVoxBufferWriteByteOffset++]=
            pvciInputBIOBlk->pVoxBuffer[wReadB++];

         if(pvciOutputIOBlk->wVoxBufferWriteByteOffset>=pvciOutputIOBlk->wVoxBufferSize)
            pvciOutputIOBlk->wVoxBufferWriteByteOffset=
               (unsigned short)(pvciOutputIOBlk->wVoxBufferWriteByteOffset-
                                pvciOutputIOBlk->wVoxBufferSize);

         if(wReadB>=pvciInputBIOBlk->wVoxBufferSize)
            wReadB=(unsigned short)(wReadB-pvciInputBIOBlk->wVoxBufferSize);
      }
   }
   return VCI_NO_ERROR;
}

/* ************************************************************************* */
/*                                                                           */
/* FUNCTION: vciGetRatesInFrameSC()                                          */
/* PURPOSE : Returns the highest rate codec that is present in the           */
/*           bit-stream for the frame ponted to by the read offset pointer.  */
/*                                                                           */
/* ************************************************************************* */
VCI_RETCODE vciGetRatesInFrameSC(const void *pVciCodecMemBlk,
                                 const VCI_CODEC_IO_BLOCK *pvciCodecIOBlk,
                                 unsigned long *ScCodec)  
{
   short wSeekReturn, wSeekInitial, wBytesSeeked;
   unsigned long dwAccumulated=0;
   const VCI_CODEC_BLOCK *vciCodecMblk = NULL;
   const unsigned short *pStreamTable = NULL;

   /* First make sure that the handle passed is the correct one. */
   if(!VCI_BLOCK_CHECK(pVciCodecMemBlk))
      return VCI_NOT_VCI_HANDLE;

    /* Do parameter checking on IO block. */
   VCI_IO_BLK_PARAM_CHECK(pvciCodecIOBlk);

   vciCodecMblk = (VCI_CODEC_BLOCK *)pVciCodecMemBlk; 

   if(vciCodecMblk->pVciPlusMethodStruct)
      if(vciCodecMblk->pVciPlusMethodStruct->wStreamTable)
         pStreamTable = vciCodecMblk->pVciPlusMethodStruct->wStreamTable;

   wSeekReturn=pvciCodecIOBlk->wVoxBufferReadByteOffset;

   while(wSeekReturn != pvciCodecIOBlk->wVoxBufferWriteByteOffset) {

      wSeekInitial = wSeekReturn;
      
      wSeekReturn = seekForward(pvciCodecIOBlk->pVoxBuffer,
                  wSeekInitial,
                  pvciCodecIOBlk->wVoxBufferWriteByteOffset,
                  pvciCodecIOBlk->wVoxBufferSize,
                  1, pStreamTable);

      if(wSeekReturn < 0)
         return VCI_BITSTREAM_CORRUPTED;

      wBytesSeeked = (short)(wSeekReturn - wSeekInitial);

      if(wBytesSeeked < 0) 
         wBytesSeeked = (short)(wBytesSeeked + pvciCodecIOBlk->wVoxBufferSize);

      dwAccumulated|=bytesToStream(wBytesSeeked, pStreamTable);
   } 

   *ScCodec=dwAccumulated;

   return VCI_NO_ERROR;
}

#ifndef DECODE_ONLY
/* ************************************************************************* */
/*                                                                           */
/* FUNCTION: vciSetEncoderRateSC()                                           */
/* PURPOSE : Switches the encoder rate on the fly (depends upon              */
/*           initialization)                                                 */
/*                                                                           */
/* NOTE    : looking for a rate or a valid stream!                           */
/* ************************************************************************* */
VCI_RETCODE vciSetEncoderRateSC(const void *pEncodeMemBlk, unsigned long wBitField)  
{
   VCI_CODEC_BLOCK *vciCodecMblk = NULL;
   unsigned long wTemp=wBitField;
   unsigned long wMask=~wTemp;
   const unsigned short *pStreamTable = NULL;

   /* First make sure that the handle passed is the correct one. */
   if(!VCI_BLOCK_CHECK(pEncodeMemBlk))
      return VCI_NOT_VCI_HANDLE;

   if(!VCI_IS_ENCODE(pEncodeMemBlk))
      return VCI_NOT_ENC_HANDLE;

   vciCodecMblk = (VCI_CODEC_BLOCK *)pEncodeMemBlk;

   if(vciCodecMblk->pVciPlusMethodStruct)
      if(vciCodecMblk->pVciPlusMethodStruct->wStreamTable)
         pStreamTable = vciCodecMblk->pVciPlusMethodStruct->wStreamTable;

   if(!isValidStream(wBitField, pStreamTable))
      return VCI_BITSTREAM_NOT_SUPPORTED;

   /* adjusting rate to assure that it's a single rate */
   while(wTemp>>=1) {
      wMask=(wMask>>1)|0x8000;
      wBitField&=wMask;
   }

   if (wBitField == 0)
     return VCI_RATE_INVALID;

   if(voxSetEncodeRate(vciCodecMblk->hCodecMblk, wBitField)!=wBitField)
      return VCI_RATE_INVALID;
   else
      return VCI_NO_ERROR;
}

/* ************************************************************************* */
/*                                                                           */
/* FUNCTION: vciGetEncoderRateSC()                                           */
/* PURPOSE : Returns the current encoder rate being used                     */
/*                                                                           */
/* ************************************************************************* */
VCI_RETCODE vciGetEncoderRateSC(const void *pEncodeMemBlk, 
                                unsigned long *wBitField) 
{
   VCI_CODEC_BLOCK *vciCodecMblk = NULL;
   unsigned short wTemp;

   /* First make sure that the handle passed is the correct one. */
   if(!VCI_BLOCK_CHECK(pEncodeMemBlk))
      return VCI_NOT_VCI_HANDLE;

   if(!VCI_IS_ENCODE(pEncodeMemBlk))
      return VCI_NOT_ENC_HANDLE;

   assert(wBitField != NULL);

   vciCodecMblk = (VCI_CODEC_BLOCK *)pEncodeMemBlk;
   *wBitField=wTemp=(unsigned short)voxGetEncodeRate(vciCodecMblk->hCodecMblk);

   /* adjust rate so that it becomes a valid bit field */
   do
      *wBitField|=(wTemp>>=1);
   while (wTemp);

   return VCI_NO_ERROR;
}
#endif

/* ************************************************************************* */
/*                                                                           */
/* FUNCTION: vciGetValideRateSC()                                            */
/* PURPOSE : Returns the current either encoder rate or decoder rate         */
/*           being used                                                      */
/*                                                                           */
/* ************************************************************************* */
VCI_RETCODE vciGetValidRatesSC(const void *pCodecMemBlk, 
                               unsigned long *wBitField)
{
   VCI_CODEC_BLOCK *vciCodecMblk = NULL;

   if(!VCI_BLOCK_CHECK(pCodecMemBlk))
      return VCI_NOT_VCI_HANDLE;

   assert(wBitField != NULL);
   vciCodecMblk = (VCI_CODEC_BLOCK *)pCodecMemBlk;

   switch(vciCodecMblk->chEncOrDec) {
#ifndef DECODE_ONLY
      case ENCODE_ID:
         *wBitField=voxGetEncodeInitRate(vciCodecMblk->hCodecMblk);
         break;
#endif

      case DECODE_ID:
         *wBitField=voxGetDecodeInitRateSC(vciCodecMblk->hCodecMblk);
         break;

      default:
         *wBitField=0;
         assert(0);
         return VCI_INCOMPATIBLE_HANDLE;
   }
   return VCI_NO_ERROR;
}


/* ************************************************************************* */
/*                                                                           */
/* FUNCTION: vciCalculateBitRate()                                           */
/* PURPOSE : Returns the bitrate calculated from the rate stream passed in   */
/*                                                                           */
/* ************************************************************************* */
VCI_RETCODE vciCalculateBitRateSC(const void *pCodecMemBlk, unsigned long wBitField, 
                                  unsigned short *pwBitRate)
{
   short wBytesInStream=0;
   VCI_CODEC_BLOCK *vciCodecMblk = NULL;
   const unsigned short *pStreamTable = NULL;

   if(!VCI_BLOCK_CHECK(pCodecMemBlk))
      return VCI_NOT_VCI_HANDLE;

   vciCodecMblk = (VCI_CODEC_BLOCK *)pCodecMemBlk;

   if(vciCodecMblk->pVciPlusMethodStruct)
      if(vciCodecMblk->pVciPlusMethodStruct->wStreamTable)
         pStreamTable = vciCodecMblk->pVciPlusMethodStruct->wStreamTable;

   if((wBytesInStream=bytesInStream(wBitField, pStreamTable))==-1)
      return VCI_BITSTREAM_CORRUPTED;

   *pwBitRate=(unsigned short)((float)RATE8K*(float)(wBytesInStream*8)/(float)FRAME_LENGTH_SC);

   return VCI_NO_ERROR;
}

/* ************************************************************************* */
/*                                                                           */
/* FUNCTION: vciCalculateBitField()                                          */
/* PURPOSE : Returns the bitrate calculated from the rate stream passed in   */
/*                                                                           */
/* ************************************************************************* */
VCI_RETCODE vciCalculateRateSC(const void *pCodecMemBlk, unsigned short wBitRate, 
                                   unsigned long *wBitField)
{
   VCI_CODEC_BLOCK *vciCodecMblk = NULL;
   float rateBytes=(float)wBitRate*((float)FRAME_LENGTH_SC/((float)RATE8K*8));
   const unsigned short *pStreamTable = NULL;

   if(!VCI_BLOCK_CHECK(pCodecMemBlk))
      return VCI_NOT_VCI_HANDLE;

   vciCodecMblk = (VCI_CODEC_BLOCK *)pCodecMemBlk;   

   if(vciCodecMblk->pVciPlusMethodStruct)
      if(vciCodecMblk->pVciPlusMethodStruct->wStreamTable)
         pStreamTable = vciCodecMblk->pVciPlusMethodStruct->wStreamTable;

   *wBitField = bytesToStream((unsigned short)rateBytes, pStreamTable);

   return VCI_NO_ERROR;
}


/* ************************************************************************* */
/*                                                                           */
/* FUNCTION: vciPlusInitSC()                                                 */
/* PURPOSE : Initialize pVciPlusMethodStruct with all the plus functions     */
/*                                                                           */
/* ************************************************************************* */
VCI_RETCODE vciPlusInitSC(const void *pCodecMemBlk)
{
   VCI_CODEC_BLOCK *vciCodecMblk = NULL;

   if(!VCI_BLOCK_CHECK(pCodecMemBlk))
      return VCI_NOT_VCI_HANDLE;

   vciCodecMblk = (VCI_CODEC_BLOCK *)pCodecMemBlk;

   if(VOX_MEM_INIT(vciCodecMblk->pVciPlusMethodStruct,1,sizeof(VCI_PLUS_METHOD_STRUCT)))
      return VCI_FAILED_MEM_ALLOC;

   vciCodecMblk->pVciPlusMethodStruct->pfVciDecodeNeedsInput=vciDecodeNeedsInputSC;
   vciCodecMblk->pVciPlusMethodStruct->pfVciSetWarpFactor=vciSetWarpFactorSC;
   vciCodecMblk->pVciPlusMethodStruct->pfVciGetWarpFactor=vciGetWarpFactorSC;

   vciCodecMblk->pVciPlusMethodStruct->pfVciSetInjectSilenceFlag=vciSetInjectSilenceFlagSC;

   vciCodecMblk->pVciPlusMethodStruct->pfVciGetEnergy=vciGetEnergyLevelSC;   
  
   vciCodecMblk->pVciPlusMethodStruct->pfVciNumFramesInBuffer=vciNumFramesInBufferSC;
   vciCodecMblk->pVciPlusMethodStruct->pfVciSeekForward=vciSeekForwardSC;

   vciCodecMblk->pVciPlusMethodStruct->pfVciSetFramesSkipped=vciSetFramesSkippedSC;
   vciCodecMblk->pVciPlusMethodStruct->pfVciSetRepeatFrameFlag=vciSetRepeatFrameFlagSC;


   vciCodecMblk->pVciPlusMethodStruct->pfVciExtractFromBitStream=vciExtractFromBitStreamSC;

   vciCodecMblk->pVciPlusMethodStruct->pfVciCombineBitStream=vciCombineBitStreamSC;

   vciCodecMblk->pVciPlusMethodStruct->pfVciGetRatesInFrame=vciGetRatesInFrameSC;

#ifndef DECODE_ONLY
   vciCodecMblk->pVciPlusMethodStruct->pfVciSetEncoderRate=vciSetEncoderRateSC;
   vciCodecMblk->pVciPlusMethodStruct->pfVciGetEncoderRate=vciGetEncoderRateSC; 
#endif

   vciCodecMblk->pVciPlusMethodStruct->pfVciGetValidRates=vciGetValidRatesSC;

   vciCodecMblk->pVciPlusMethodStruct->pfVciCalculateBitRate=vciCalculateBitRateSC;
   vciCodecMblk->pVciPlusMethodStruct->pfVciCalculateRateSC=vciCalculateRateSC;

   vciCodecMblk->pVciPlusMethodStruct->wStreamTable = NULL;

   return VCI_NO_ERROR;
}


/* ************************************************************************* */
/*                                                                           */
/* FUNCTION: vciPlusFreeSC()                                                 */
/* PURPOSE : Free pVciPlusMethodStruct                                       */
/*                                                                           */
/* ************************************************************************* */
VCI_RETCODE vciPlusFreeSC(const void *pCodecMemBlk)
{

   if(!VCI_BLOCK_CHECK(pCodecMemBlk))
      return VCI_NOT_VCI_HANDLE;

   VOX_MEM_FREE(((VCI_CODEC_BLOCK *)pCodecMemBlk)->pVciPlusMethodStruct);

   return VCI_NO_ERROR;
}

/* ************************************************************************** */
/*                                                                            */
/* FUNCTION: vciGetPlusInfoSC()                                               */
/* PURPOSE : Fills in the VCI plus info blk                                   */
/*                                                                            */
/* ************************************************************************** */
VCI_RETCODE vciGetPlusInfoSC(VCI_PLUS_INFO_BLOCK *pVciPlusInfoBlk)
{
   pVciPlusInfoBlk->wPlusFlags=VCI_CODEC_HAS_WARPING; 
   pVciPlusInfoBlk->wPlusFlags|=VCI_CODEC_HAS_SILENCE_INJECTION;
   pVciPlusInfoBlk->wPlusFlags|=VCI_CODEC_HAS_GET_ENERGY;
   pVciPlusInfoBlk->wPlusFlags|=VCI_CODEC_HAS_FRAME_TRAVERSAL;
   pVciPlusInfoBlk->wPlusFlags|=VCI_PRIME_FLUSH;
   pVciPlusInfoBlk->wPlusFlags|=VCI_STREAM_MANIPULATION;
   pVciPlusInfoBlk->wPlusFlags|=VCI_CODEC_IS_SCALEABLE;
   pVciPlusInfoBlk->dwMinWarp=MIN_WARP;
   pVciPlusInfoBlk->dwMaxWarp=MAX_WARP;

   return VCI_NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\vciplus.h ===
/******************************************************************************
*                        Voxware Proprietary Material
*                        Copyright 1996, Voxware, Inc
*                            All Rights Reserved
*
*                       DISTRIBUTION PROHIBITED without
*                      written authorization from Voxware
******************************************************************************/

/******************************************************************************
* Filename:        vciPlus.h
*
* Purpose:     Definitions and structures for VCI Plus
*
* Author/Date: John Puterbaugh, Ilan Berci & Epiphany Vera
*******************************************************************************
*
* Modifications:
*
* Comments:
*
* Concerns:
*
* $Header:   /export/phobos/pvcs/r_and_d/archives/realtime/vci/vciPlus.h_v   1.1   13 Feb 1998 10:42:38   weiwang  $
******************************************************************************/
#ifndef VCIPLUS_H
#define VCIPLUS_H


#ifdef __cplusplus
extern "C"
{
#endif

#ifndef __COMPATIBILITY_FUNCTION
#define __COMPATIBILITY_FUNCTION

#define COMPATIBILITY_VFONT   (1)
#define COMPATIBILITY_VAD_AGC (1<<1)
#define COMPATIBILITY_PLUS    (1<<2) /* only needed for backward compatibility */

typedef unsigned short (COMPATIBILITY_FUNCTION)(unsigned short VemPlugin,unsigned long *pVemCodID);
#endif /* __COMPATIBILITY_FUNCTION */

#define VCI_CODEC_HAS_WARPING             (1)
#define VCI_CODEC_HAS_SILENCE_INJECTION   (1 << 1) 
#define VCI_CODEC_HAS_PITCH_SHIFT         (1 << 2) /* not supported anymore */   
#define VCI_CODEC_HAS_GET_ENERGY          (1 << 3)
#define VCI_CODEC_HAS_FRAME_TRAVERSAL     (1 << 4)
#define VCI_PRIME_FLUSH                   (1 << 5)
#define VCI_CODEC_IS_SCALEABLE            (1 << 6)
#define VCI_STREAM_MANIPULATION           (1 << 7)

typedef struct tagVCI_PLUS_INFO_BLOCK {
   unsigned short wPlusFlags;
   float dwMinWarp; 
   float dwMaxWarp;

} VCI_PLUS_INFO_BLOCK;

#ifdef __cplusplus
}
#endif

#endif /* VCIPLUS_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\vciplssc.h ===
/******************************************************************************
*                        Voxware Proprietary Material
*                        Copyright 1996, Voxware, Inc
*                            All Rights Reserved
*
*                       DISTRIBUTION PROHIBITED without
*                      written authorization from Voxware
******************************************************************************/

/******************************************************************************
* Filename:        vciPlsSC.h
*
* Purpose:     Additional VCI functions specific to the SC codecs      
*
* Functions:   vciSetFramesSkippedSC, ...etc
*
* Author/Date: John Puterbaugh, Ilan Berci & Epiphany Vera    97/05/20
*******************************************************************************
*
* Modifications:
*
* Comments:
*
* Concerns:
*
* $Header:   /export/phobos/pvcs/r_and_d/archives/scaleable/vci/vciPlsSC.h_v   1.2   16 Mar 1998 17:13:06   weiwang  $
******************************************************************************/
#ifndef _VCIPLSSC
#define _VCIPLSSC

#ifdef __cplusplus
extern "C"
{
#endif

/* ************************************************************************* */
/*                                                                           */
/* FUNCTION: vciSetFramesSkippedSC()                                         */
/* PURPOSE : Tell the decoder that frames have been skipped/lost             */
/*                                                                           */
/* ************************************************************************* */
VCI_RETCODE vciSetFramesSkippedSC(void *pDecodeMemBlk, int iFramesSkipped);

/* ************************************************************************* */
/*                                                                           */
/* FUNCTION: vciSetRepeatFrameFlagSC()                                       */
/* PURPOSE : Tell the decoder that the frame is a repeat.                    */
/*                                                                           */
/* ************************************************************************* */
VCI_RETCODE vciSetRepeatFrameFlagSC(void *pDecodeMemBlk);

/* ************************************************************************* */
/*                                                                           */
/* FUNCTION: vciSetWarpFactorSC()                                            */
/* PURPOSE : Sets the warp factor for the decoder.                           */
/*                                                                           */
/* ************************************************************************* */
VCI_RETCODE vciSetWarpFactorSC(void *pDecodeMemBlk, float wWarpFactor);

/* ************************************************************************* */
/*                                                                           */
/* FUNCTION: vciGetWarpFactor()                                              */
/* PURPOSE : Retrieves the warp factor setting in the  decoder.              */
/*                                                                           */
/* ************************************************************************* */
VCI_RETCODE vciGetWarpFactorSC(void *pDecodeMemBlk, float *pwWarpFactor);

/* ************************************************************************* */
/*                                                                           */
/* FUNCTION: vciDecodeNeedsInput()                                           */
/* PURPOSE : Checks whether the decoder needs input or not.                  */
/*                                                                           */
/* ************************************************************************* */
VCI_RETCODE vciDecodeNeedsInputSC(void *pDecodeMemBlk, unsigned char *pUnPack);

/* ************************************************************************* */
/*                                                                           */
/* FUNCTION: vciGetEnergyLevelSC()                                           */
/* PURPOSE : Gets the energy level.                                          */
/*                                                                           */
/* ************************************************************************* */
VCI_RETCODE vciGetEnergyLevelSC(void *pDecodeMemBlk, short *pwEnergyLevel);

/* ************************************************************************* */
/*                                                                           */
/* FUNCTION: vciSetInjectSilenceFlagSC()                                     */
/* PURPOSE : Perform fade-in/fade-out and background noise injection during  */
/*           packet loss.                                                    */
/*                                                                           */
/* ************************************************************************* */
VCI_RETCODE vciSetInjectSilenceFlagSC(void *pDecodeMemBlk);

/* ************************************************************************* */
/*                                                                           */
/* FUNCTION: vciNumFramesInBuffer()                                          */
/* PURPOSE : Counts the number of frames in the Vox buffer of the given      */
/*           codec I/O block.                                                */
/*                                                                           */
/* ************************************************************************* */
VCI_RETCODE vciNumFramesInBufferSC(const void *pVciCodecMemBlk,
                                   const VCI_CODEC_IO_BLOCK *pvciCodecIOBlk,
                                   unsigned short *pwNumFrames,
                                   unsigned short *pwByteOffset,
                                   unsigned char  *pchBitOffset);

/* ************************************************************************* */
/*                                                                           */
/* FUNCTION: vciSeekForwardSC()                                              */
/* PURPOSE : Seeks to a given frame offset.                                  */
/*                                                                           */
/* ************************************************************************* */
VCI_RETCODE vciSeekForwardSC(const void *pVciCodecMemBlk,
                             const VCI_CODEC_IO_BLOCK *pvciCodecIOBlk,
                             unsigned short wNumFrames,
                             unsigned short *pwReadOffset,
                             unsigned char  *pchBitOffset);

/* ************************************************************************* */
/*                                                                           */
/* FUNCTION: vciExtractFromBitStreamSC()                                     */
/* PURPOSE : Extracts the specified embedded streams from the Vox Buffer of  */
/*           the codec I/O block                                             */
/*                                                                           */
/* ************************************************************************* */
VCI_RETCODE vciExtractFromBitStreamSC(const void *pVciCodecMemBlk,
                                      const VCI_CODEC_IO_BLOCK *pvciInputIOBlk,
                                      VCI_CODEC_IO_BLOCK  *pvciOutputIOBlk,
                                      unsigned long dwBitField);

/* ************************************************************************* */
/*                                                                           */
/* FUNCTION: vciCombineBitStreamSC()                                         */
/* PURPOSE : Combines the specified emnedded streams from the Vox Buffer of  */
/*           the codec I/O block pointed to be pvciInputIOBlk and writes the */
/*           new stream to that pointed to be pcviOutputIOBlk.               */
/* ************************************************************************* */
VCI_RETCODE vciCombineBitStreamSC(const void *pVciCodecMemBlk,
                                  const VCI_CODEC_IO_BLOCK *pvciInputAIOBlk,
                                  const VCI_CODEC_IO_BLOCK *pvciInputBIOBlk,
                                  VCI_CODEC_IO_BLOCK *pvciOutputIOBlk,
                                  unsigned long  ScCodecA,
                                  unsigned long  ScCodecB);

/* ************************************************************************* */
/*                                                                           */
/* FUNCTION: vciGetRatesInFrameSC()                                          */
/* PURPOSE : Returns the highest rate codec that is present in the           */
/*           bit-stream for the frame ponted to by the read offset pointer.  */
/*                                                                           */
/* ************************************************************************* */
VCI_RETCODE vciGetRatesInFrameSC(const void *pVciCodecMemBlk,
                                 const VCI_CODEC_IO_BLOCK *pvciCodecIOBlk,
                                 unsigned long *ScCodec);

/* ************************************************************************* */
/*                                                                           */
/* FUNCTION: vciSetEncoderRateSC()                                           */
/* PURPOSE : Switches the encoder rate on the fly (depends upon              */
/*           initialization)                                                 */
/*                                                                           */
/* NOTE    : looking for a rate or a valid stream!                           */
/* ************************************************************************* */
VCI_RETCODE vciSetEncoderRateSC(const void *pEncodeMemBlk, unsigned long wRate);

/* ************************************************************************* */
/*                                                                           */
/* FUNCTION: vciGetEncoderRateSC()                                           */
/* PURPOSE : Returns the current encoder rate being used                     */
/*                                                                           */
/* ************************************************************************* */
VCI_RETCODE vciGetEncoderRateSC(const void *pEncodeMemBlk, unsigned long *wRate); 

/* ************************************************************************* */
/*                                                                           */
/* FUNCTION: vciGetValideRateSC()                                            */
/* PURPOSE : Returns the current either encoder rate or decoder rate         */
/*           being used                                                      */
/*                                                                           */
/* ************************************************************************* */
VCI_RETCODE vciGetValidRatesSC(const void *pCodecMemBlk, unsigned long *wRate);


/* ************************************************************************* */
/*                                                                           */
/* FUNCTION: vciCalculateBitRate()                                           */
/* PURPOSE : Returns the bitrate calculated from the rate stream passed in   */
/*                                                                           */
/* ************************************************************************* */
VCI_RETCODE vciCalculateRateSC(const void *pCodecMemBlk, unsigned short wBitRate, 
                                   unsigned long *wRate);

/* ************************************************************************* */
/*                                                                           */
/* FUNCTION: vciCalculateBitField()                                          */
/* PURPOSE : Returns the bitrate calculated from the rate stream passed in   */
/*                                                                           */
/* ************************************************************************* */
VCI_RETCODE vciCalculateBitRateSC(const void *pCodecMemBlk, unsigned long wRate, 
                                  unsigned short *pwBitRate);

/* ************************************************************************* */
/*                                                                           */
/* FUNCTION: vciPlusInitSC()                                                 */
/* PURPOSE : Initialize pVciPlusMethodStruct with all the plus functions     */
/*                                                                           */
/* ************************************************************************* */
VCI_RETCODE vciPlusInitSC(const void *pCodecMemBlk);

/* ************************************************************************* */
/*                                                                           */
/* FUNCTION: vciPlusFreeSC()                                                 */
/* PURPOSE : Free pVciPlusMethodStruct                                       */
/*                                                                           */
/* ************************************************************************* */
VCI_RETCODE vciPlusFreeSC(const void *pCodecMemBlk);

/* ************************************************************************** */
/*                                                                            */
/* FUNCTION: vciGetPlusInfoSC()                                               */
/* PURPOSE : Fills in the VCI plus info blk                                   */
/*                                                                            */
/* ************************************************************************** */
VCI_RETCODE vciGetPlusInfoSC(VCI_PLUS_INFO_BLOCK *pVciPlusInfoBlk);

#ifdef __cplusplus
}
#endif

#endif /* _VCIPLSSC */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\vci.h ===
/******************************************************************************
*                        Voxware Proprietary Material
*                        Copyright 1996, Voxware, Inc
*                            All Rights Reserved
*
*                       DISTRIBUTION PROHIBITED without
*                      written authorization from Voxware
******************************************************************************/

/******************************************************************************
* Filename:        vci.h
*
* Purpose:   Defines the interface data structures needed for the Voxware
*            Core Interface (VCI).
*
* Structure: VCI_CODEC_IO_BLOCK, VCI_CODEC_INFO_BLOCK
*
* Author/Date:     Ilan Berci, Epiphany Vera
*******************************************************************************
*
* Modifications:
*
* Comments:
*
* Concerns:
*
* $Header:   /export/phobos/pvcs/r_and_d/archives/realtime/vci/vci.h_v   1.1   13 Feb 1998 10:42:36   weiwang  $
******************************************************************************/

#ifndef _VCI_H_
#define _VCI_H_

/* Donavan's VCI switch */
#define VCI_SEGMENTED_MODEL_SWITCH 0

#ifdef __cplusplus
extern "C"
{
#endif

#ifndef _VCI_RETCODE_
#define _VCI_RETCODE_
typedef unsigned short VCI_RETCODE; /* Voxware Core Interface error type.    */
                                    /* This variable is also defined in      */
                                    /* vciError.h.                           */
#endif  /** #ifndef _VCI_RETCODE_ **/


/* ************************************************************************* */
/*                                 VCI Defines                               */
/* ************************************************************************* */
#define VCI_VERSION 4

/* ************************************************************************* */
/*                                                                           */
/* STRUCTURE: VCI_CODEC_CONTROL_BLOCK                                        */
/* PURPOSE :  Used for I/O between the codec and the calling program.        */
/*                                                                           */
/*                                                                           */
/* ************************************************************************* */
typedef struct 
{
  /* PCM Data buffer variables                                               */
                                  /* Buffer of signed 16 bit PCM samples.    */
  signed short   *pPCMBuffer;               
                                  /* Number of samples in PCMBuffer          */
  unsigned short wSamplesInPCMBuffer;

  /* Compressed bit-stream buffer variables                                  */
                                  /* Buffer of compressed bit-stream data    */
  unsigned char  *pVoxBuffer;     
                                  /* Size of VoxBuffer in bytes              */
  unsigned short wVoxBufferSize;
                                  /* Diagram of the VoxBuffer. The "D" repr- */
                                  /* esents byte with at least 1 bit of data */
                                  /* _______________________________________
                                    |                  DDDDDDDDDDDDDD       |
                                    |__________________^____________^_______|
                                    ^                  ^            ^       ^
                                    |<-ReadByteOffset->|            |       |
                                    |                               |       |
                                    |<------WriteByteOffset-------->|       |
                                    |                               |       |
                                    |<-------------BufferSize-------------->|
                                    |
                                    |<---Begining of buffer (i.e. pVoxBuffer)
                                                                             */
                                  /* The offset in bytes, from the beginning */
                                  /* of the buffer, of the first byte to     */
                                  /* start reading from.                     */
  unsigned short wVoxBufferReadByteOffset;
                                  /* The offset in bits, from the most sign- */
                                  /* ificant bit, to start reading from.     */
  unsigned char  chVoxBufferReadBitOffset;
                                  /* The offset in bytes, from the beginning */
                                  /* of the buffer, of the first byte to     */
                                  /* start writing to.                       */
  unsigned short wVoxBufferWriteByteOffset;
                                  /* The offset in bits, from the most sign- */
                                  /* ificant bit, to start writing to.       */
  unsigned char  chVoxBufferWriteBitOffset;
   
} VCI_CODEC_IO_BLOCK;



/* ************************************************************************* */
/*                                                                           */
/* STRUCTURE: VCI_CODEC_INFO_BLOCK                                           */
/* PURPOSE :  Used for getting information about the codec.                  */
/*                                                                           */
/*                                                                           */
/* ************************************************************************* */
 typedef struct
 {
   /* VCI Codec API information.              */
   unsigned short wVCIVersion;
   
   /* Variables for codec identification.     */
   char           sCodecVersion[32];  
   unsigned long  dwCodecClassID;      
   unsigned long  dwCodecID;
   
   /* PCM Data formats.                       */
   unsigned short wSamplingRate;   
   unsigned short wNumBitsPerSample;
   unsigned short wNumSamplesPerFrame;
   
   /* Multi-channel support.                  */
   unsigned short wNumChannels;
   unsigned short wInterleaveBlockSize;
   
   /* Bitstream information.                  */
   unsigned long dwBitRate;
   unsigned long dwMinPacketBits;
   unsigned long dwAvgPacketBits;
   unsigned long dwMaxPacketBits;
      
   /* Prime Flush Information   */
   unsigned short wNumPrimeFlushFrames;
   unsigned short wNumPrimeFlushSamples;
 } VCI_CODEC_INFO_BLOCK;

#ifdef __cplusplus
}
#endif /* __cplusplus */

#endif /** #ifndef _VCI_H_ **/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\vciplsrt.h ===
/******************************************************************************
 *                                                                            *
 *		                  Voxware Proprietary Material                          *
 *		                  Copyright 1996, Voxware, Inc.                         *
 *		                       All Rights Resrved                               *
 *                                                                            *
 *		                 DISTRIBUTION PROHIBITED without                        *
 *		               written authorization from Voxware                       *
 *                                                                            *
 ******************************************************************************/

/******************************************************************************
 *                                                                            *
 * FILENAME:  vciPlsRT.h                                                      *
 * PURPOSE:   Defines the interface functions for vciPlsRT.c.                 *
 *                                                                            *
 *****************************************************************************/

/******************************************************************************
 *                                                                            *
 *                          DETAILED REVISION HISTORY                         *
 *                                                                            *
 * (March 17, '97)                                                            *
 *    Created                                                                 *
 *                                                                            *
 *****************************************************************************/

#ifndef VCIPLSRT_H
#define VCIPLSRT_H

#ifdef __cplusplus
extern "C"
{
#endif

VCI_RETCODE vciDecodeNeedsInputRT(void *hCodecMemBlk, unsigned char *pUnPack);
VCI_RETCODE vciSetWarpFactorRT(void *hCodecMemBlk, float wWarpFactor);
VCI_RETCODE vciGetWarpFactorRT(void *hCodecMemBlk, float *pwWarpFactor);

VCI_RETCODE vciSetInjectSilenceFlagRT(void *hCodecMemBlk);

VCI_RETCODE vciGetEnergyRT(void *hCodecMemBlk, short *pwEnergyLevel);   
  
VCI_RETCODE vciNumFramesInBufferRT(const void *hCodecMemBlk, 
                                 const VCI_CODEC_IO_BLOCK *hvciCodecIOBlk,
                                 unsigned short *pwNumFrames,
                                 unsigned short *pwByteOffset,
                                 unsigned char  *pchBitOffset);
VCI_RETCODE vciSeekForwardRT(const void *hCodecMemBlk, 
                           const VCI_CODEC_IO_BLOCK *hvciCodecIOBlk,
                           unsigned short      wNumFrames,
                           unsigned short *pwByteOffset,
                           unsigned char  *pchBitOffset);

VCI_RETCODE vciGetPlusInfoRT(VCI_PLUS_INFO_BLOCK *pVciPlusInfoBlk);

/* needed for all extensions that call out to vci(plus) calls */
VCI_RETCODE vciPlusInit(const void *pCodecMemBlk);
VCI_RETCODE vciPlusFree(const void *pCodecMemBlk);

#ifdef __cplusplus
}
#endif /* __cplusplus */
                     
#endif /* VCIPLSRT_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\vciqotrt.h ===
/******************************************************************************
 *                                                                            *
 *                      Voxware Proprietary Material                          *
 *                      Copyright 1996, Voxware, Inc.                         *
 *                           All Rights Resrved                               *
 *                                                                            *
 *                     DISTRIBUTION PROHIBITED without                        *
 *                   written authorization from Voxware                       *
 *                                                                            *
 *****************************************************************************/

/******************************************************************************
 *                                                                            *
 * FILENAME:  vciQoT.h                                                        *
 * PURPOSE:   QoT structures                                                  *
 * AUTHOR:    Robert Zopf 08/18/97                                            *
 *                                                                            *
 * $Header:   /export/phobos/pvcs/r_and_d/archives/realtime/vci/vciQoTRT.h_v   1.0   26 Jan 1998 11:21:10   johnp  $
 *
 *****************************************************************************/
#ifndef _VCI_QOT_RT
#define _VCI_QOT_RT
/*---------------------------------------------------------------------------
                    P U B L I C   S T R U C T U R E S 
  ---------------------------------------------------------------------------*/
#ifdef __cplusplus
extern "C"
{
#endif

VCI_RETCODE vciQoTLookSetupRT(
                  void  *hDecodeMemBlk,
                  short *wLookaheadCount,
                  short *wLookbackCount );

VCI_RETCODE vciQoTDecodeRT(
                  void *pDecodeMemBlk,
                  VCI_CODEC_IO_BLOCK *pvciCodecIOBlk,
                  void *pvciQoTMemBlk,
                  short  wLookaheadCount,
                  short  wLookbackCount,
                  QoTFrame *lpaFrames );

VCI_RETCODE vciInitQoTRT(void **hQoTMemBlk, void *pvCodecMemBlk);
VCI_RETCODE vciFreeQoTRT(void **hQoTMemBlk);
 
#ifdef __cplusplus
}
#endif /* __cplusplus */

#endif /* _VCI_QOT_RT */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\vcipvr12.h ===
/******************************************************************************
 *                                                                            *
 *		                  Voxware Proprietary Material                          *
 *		                  Copyright 1996, Voxware, Inc.                         *
 *		                       All Rights Resrved                               *
 *                                                                            *
 *		                 DISTRIBUTION PROHIBITED without                        *
 *		               written authorization from Voxware                       *
 *                                                                            *
 ******************************************************************************/

/******************************************************************************
 *                                                                            *
 * FILENAME:  vciPVR12.h                                                      *
 * PURPOSE:   Defines the interface functions for vciPlsRT.c.                 *
 *                                                                            *
 *****************************************************************************/

/******************************************************************************
 *                                                                            *
 *                          DETAILED REVISION HISTORY                         *
 *                                                                            *
 * (March 17, '97)                                                            *
 *    Created                                                                 *
 *                                                                            *
 *****************************************************************************/

#ifndef VCIPVR12_H
#define VCIPVR12_H

#ifdef __cplusplus
extern "C"
{
#endif

VCI_RETCODE vciDecodeNeedsInputVR12(void *hCodecMemBlk, 
                                    unsigned char *pUnPack);
VCI_RETCODE vciSetWarpFactorVR12(void *hCodecMemBlk, float wWarpFactor);
VCI_RETCODE vciGetWarpFactorVR12(void *hCodecMemBlk, float *pwWarpFactor);

VCI_RETCODE vciSetInjectSilenceFlagVR12(void *hCodecMemBlk);

VCI_RETCODE vciGetEnergyVR12(void *hCodecMemBlk, short *pwEnergyLevel);   
  
VCI_RETCODE vciNumFramesInBufferVR12(const void *hCodecMemBlk, 
                                 const VCI_CODEC_IO_BLOCK *hvciCodecIOBlk,
                                 unsigned short *pwNumFrames,
                                 unsigned short *pwByteOffset,
                                 unsigned char  *pchBitOffset);
VCI_RETCODE vciSeekForwardVR12(const void *hCodecMemBlk, 
                           const VCI_CODEC_IO_BLOCK *hvciCodecIOBlk,
                           unsigned short      wNumFrames,
                           unsigned short *pwByteOffset,
                           unsigned char  *pchBitOffset);

VCI_RETCODE vciGetPlusInfoVR12(VCI_PLUS_INFO_BLOCK *pVciPlusInfoBlk);

/* needed for all extensions that call out to vci(plus) calls */
VCI_RETCODE vciPlusInitVR12(const void *pCodecMemBlk);
VCI_RETCODE vciPlusFreeVR12(const void *pCodecMemBlk);

#ifdef __cplusplus
}
#endif /* __cplusplus */
                     
#endif /* VCIPVR15_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\vcirt24.h ===
/******************************************************************************
 *                                                                            *
 *		                  Voxware Proprietary Material                        *
 *		                  Copyright 1996, Voxware, Inc.                       *
 *		                       All Rights Resrved                             *
 *                                                                            *
 *		                 DISTRIBUTION PROHIBITED without                      *
 *		               written authorization from Voxware                     *
 *                                                                            *
 ******************************************************************************/

/******************************************************************************
 *                                                                            *
 * FILENAME:  vciRT24.h                                                       *
 * PURPOSE:   Defines the interface functions and defines for vciRT24.c.      *
 *                                                                            *
 *****************************************************************************/

/******************************************************************************
 *                                                                            *
 *                          DETAILED REVISION HISTORY                         *
 *                                                                            *
 * (Sept 25, '96)                                                             *
 *    Created                                                                 *
 *                                                                            *
 *****************************************************************************/

#ifndef VCIRT24_H
#define VCIRT24_H
 
#ifdef __cpluplus
extern "C"
{
#endif
                                                         
VCI_RETCODE vciGetInfoRT24(VCI_CODEC_INFO_BLOCK *pvciCodecInfoBlk);

VCI_RETCODE vciDecodeRT24(void *hCodecMemBlk, 
                          VCI_CODEC_IO_BLOCK *hvciDecodeIOBlk);
VCI_RETCODE vciEncodeRT24(void *hCodecMemBlk, 
                          VCI_CODEC_IO_BLOCK *hvciEncodeIOBlk);

VCI_RETCODE vciInitEncodeRT24(void **hCodecMemBlk);
VCI_RETCODE vciInitDecodeRT24(void **hCodecMemBlk); 
                                                      
VCI_RETCODE vciFreeEncodeRT24(void **hCodecMemBlk);                                                       
VCI_RETCODE vciFreeDecodeRT24(void **hCodecMemBlk);  

VCI_RETCODE vciGetExtCompatibilityRT24(void **ppvExtCompat);


#define MAX_FRAME_LENGTH_24    180
#define PACKET_BITS_RT24    54  /* The number of bits in a bit-stream packet  */
#define PACKET_BYTE_RT24     7  /* The minimum bytes required to store one    */
                                /* bit-stream packet.                         */

#ifdef __cplusplus
}
#endif /* __cplusplus */

#endif /* VCIRT24_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\vciqotsc.h ===
/******************************************************************************
*                        Voxware Proprietary Material
*                        Copyright 1996, Voxware, Inc
*                            All Rights Reserved
*
*                       DISTRIBUTION PROHIBITED without
*                      written authorization from Voxware
******************************************************************************/

/******************************************************************************
* Filename:        vciQoTSC.h
*
* Purpose:         provide QoT (quanlity of transmission) for SC codec
*
* Functions:   
*
* Author/Date:     Rob Zopf
*******************************************************************************
*
* Modifications: cleaned up structure and code by Wei Wang, 02/98
*
* Comments:
*
* Concerns:
*
* $Header:   /export/phobos/pvcs/r_and_d/archives/scaleable/vci/vciQoTSC.h_v   1.2   16 Mar 1998 17:20:16   weiwang  $
******************************************************************************/

#ifndef _VCI_QOT_SC
#define _VCI_QOT_SC

#ifdef __cplusplus
extern "C"
{
#endif


/******************************************************************************
*
* Function:  vciQoTDecodeSC()
*
* Action:    Decodes one frame of speech under QoT using SC codec.
*
* Input:   pDecodeMemBlk   - a pointer to the codec's private data storage 
*                             returned from the codec initialization process.
*          pvciCodecIOBlk  - a pointer to the standard codec I/O structure which 
*                            is used to describe the output buffer where the 
*                            decoded frame is to be written.
*          pvciQoTMemBlk  - a pointer to the QoT's private data storage.
*          wLookaheadCount - the number of frame s"ahead" of this frame in time 
*                            for which look-ahead infromation is available.
*
*          wLookbackCount  - the number of frames "back" in time for which 
*                            look-back information is present.
*
*          lpaFrames       - a pointer to an array of structures describing the 
*                            frames for which frame information is available.
*                            This array starts with the frame n-wLookbackCount
*                            and continues until frame n+wLookaheadCount for a 
*                            total of wLookbackCount+wLookaheadCount+1 frames.
*                            The current frame (n) would be at 
*                            lpaFrames[wLookbackCount].
*
* Output:  pvciCodecIOBlk  - an updated I/O block containing synthesized speech
*                            in PCM format, with the number of samples present
*                            indicated by wSamplesInPCMBuffer.
*          pDecodeMemBlk -   updated codec structure
*          pvciQoTMemBlk -   updated QoT structure
*
* Globals:   none
*
* Return:    VCI error code
*******************************************************************************/


VCI_RETCODE vciQoTDecodeSC(void               *pDecodeMemBlk, 
                           VCI_CODEC_IO_BLOCK *pvciCodecIOBlk,
                           void               *pvciQoTMemBlk, 
                           short              wLookaheadCount,
                           short              wLookbackCount, 
                           const QoTFrame     *lpaFrames);

/******************************************************************************
* Function:  vciQoTLookSetup() 
*
* Action:    Set up the optimal number of look-ahead and look-back frames
*
* Input:    hDecodeMemBlk - handle to the Decoder Memory block
*
* Output:    wLookaheadCount - the recommended number of look-ahead frames
*            wLookbackCount  - the recommended number of look-back frames
*
* Globals:    none
*
* Return:     VCI_RETCODE : VCI return code
*******************************************************************************/


VCI_RETCODE vciQoTLookSetupSC(void  *hDecodeMemBlk, 
                              short *wLookaheadCount,
                              short *wLookbackCount );


/******************************************************************************
* Function:  vciInitQoTSC()
*
* Action:    initialize the QoT structure
*
* Input:    hQoTMemBlk -- pointer to the structure be intialized
*           pvCodecMemBlk -- codec memory structure with initialized pVciMethodStruct.
*
* Output:    hQoTMemBlk -- the initialized QoT structure
*
* Globals:    none
*
* Return:     VCI_RETCODE : VCI return code
*******************************************************************************/

VCI_RETCODE vciInitQoTSC(void **hQoTMemBlk, 
                         void *pvCodecMemBlk);


/******************************************************************************
* Function:  vciFreeQoTSC()
*
* Action:    free the memory of the QoT structure
*
* Input:    hQoTMemBlk -- pointer to the structure 
*
* Output:    hQoTMemBlk -- the memory freed QoT structure
*
* Globals:    none
*
* Return:     VCI_RETCODE : VCI return code
*******************************************************************************/

VCI_RETCODE vciFreeQoTSC(void **hQoTMemBlk);
 
#ifdef __cplusplus
}
#endif /* __cplusplus */

#endif /* _VCI_QOT_SC */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\vciqot.h ===
/******************************************************************************
*                        Voxware Proprietary Material
*                        Copyright 1996, Voxware, Inc
*                            All Rights Reserved
*
*                       DISTRIBUTION PROHIBITED without
*                      written authorization from Voxware
******************************************************************************/

/******************************************************************************
* Filename:        vciQoT.h
*
* Purpose:         public structure for VCI QOT
*
* Functions:       
*
* Author/Date:     Robert Zopf 08/18/97
*******************************************************************************
*
* Modifications: 
*
* Comments:
*
* Concerns:
*
* $Header:   /export/phobos/pvcs/r_and_d/archives/realtime/vci/vciQoT.h_v   1.1   13 Feb 1998 10:42:40   weiwang  $
******************************************************************************/
#ifndef VCI_QOT
#define VCI_QOT
/*---------------------------------------------------------------------------
                    P U B L I C   S T R U C T U R E S 
  ---------------------------------------------------------------------------*/
#ifdef __cplusplus
extern "C"
{
#endif

/* This structure dwscribes a single frame. */
typedef struct
{
   /* TRUE if the frame is present */
   int                      bFrameIsPresent;
  
   /* If the frame is present, these identify
    * the start of the frame.  Otherwise, they
    * are unused.
    */
   unsigned char            *pchFrameFirstByte;

  /* indicate the bit offset of the first byte */
   unsigned char             chBitOffset;
} QoTFrame;

 
#ifdef __cplusplus
}
#endif /* __cplusplus */

#endif /* VCI_QOT */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\vcipvr15.h ===
/******************************************************************************
 *                                                                            *
 *		                  Voxware Proprietary Material                          *
 *		                  Copyright 1996, Voxware, Inc.                         *
 *		                       All Rights Resrved                               *
 *                                                                            *
 *		                 DISTRIBUTION PROHIBITED without                        *
 *		               written authorization from Voxware                       *
 *                                                                            *
 ******************************************************************************/

/******************************************************************************
 *                                                                            *
 * FILENAME:  vciPVR15.h                                                      *
 * PURPOSE:   Defines the interface functions for vciPlsRT.c.                 *
 *                                                                            *
 *****************************************************************************/

/******************************************************************************
 *                                                                            *
 *                          DETAILED REVISION HISTORY                         *
 *                                                                            *
 * (March 17, '97)                                                            *
 *    Created                                                                 *
 *                                                                            *
 *****************************************************************************/

#ifndef VCIPVR15_H
#define VCIPVR15_H

#ifdef __cplusplus
extern "C"
{
#endif

VCI_RETCODE vciDecodeNeedsInputVR15(void *hCodecMemBlk, 
                                    unsigned char *pUnPack);
VCI_RETCODE vciSetWarpFactorVR15(void *hCodecMemBlk, float wWarpFactor);
VCI_RETCODE vciGetWarpFactorVR15(void *hCodecMemBlk, float *pwWarpFactor);

VCI_RETCODE vciSetInjectSilenceFlagVR15(void *hCodecMemBlk);

VCI_RETCODE vciGetEnergyVR15(void *hCodecMemBlk, short *pwEnergyLevel);   
  
VCI_RETCODE vciNumFramesInBufferVR15(const void *hCodecMemBlk, 
                                 const VCI_CODEC_IO_BLOCK *hvciCodecIOBlk,
                                 unsigned short *pwNumFrames,
                                 unsigned short *pwByteOffset,
                                 unsigned char  *pchBitOffset);
VCI_RETCODE vciSeekForwardVR15(const void       *hCodecMemBlk, 
                           const VCI_CODEC_IO_BLOCK *hvciCodecIOBlk,
                           unsigned short      wNumFrames,
                           unsigned short *pwByteOffset,
                           unsigned char  *pchBitOffset);

VCI_RETCODE vciGetPlusInfoVR15(VCI_PLUS_INFO_BLOCK *pVciPlusInfoBlk);

/* needed for all extensions that call out to vci(plus) calls */
VCI_RETCODE vciPlusInitVR15(const void *pCodecMemBlk);
VCI_RETCODE vciPlusFreeVR15(const void *pCodecMemBlk);

#ifdef __cplusplus
}
#endif /* __cplusplus */
                     
#endif /* VCIPVR15_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\vcipriv.h ===
/******************************************************************************
*                        Voxware Proprietary Material
*                        Copyright 1996, Voxware, Inc
*                            All Rights Reserved
*
*                       DISTRIBUTION PROHIBITED without
*                      written authorization from Voxware
******************************************************************************/

/******************************************************************************
* Filename:         vciPriv.h 
*
* Purpose:     Defines the interface data structures and constants that are
*              private to the Voxware Core Interface (VCI). 

* Author/Date: John Puterbaugh, Ilan Berci & Epiphany Vera  (Nov 25, '96)
*******************************************************************************
*
* Modifications:
*
* Comments:
*
* Concerns:
*
* $Header:   /export/phobos/pvcs/r_and_d/archives/common/vci/vciPriv.h_v   1.5   22 Jun 1998 14:29:28   weiwang  $
******************************************************************************/
#ifndef VCIPRIV_H
#define VCIPRIV_H

#ifndef _VCI_RETCODE_
#define _VCI_RETCODE_
typedef unsigned short VCI_RETCODE; /* Voxware Core Interface error type.    */
                                    /* This variable is also defined in      */
                                    /* vciError.h.                           */
#endif  /** #ifndef _VCI_RETCODE_ **/


/* ************************************************************************** */
/*                                                                            */
/* STRUCTURE: VCI_PLUS_METHOD_STRUCT                                          */
/* PURPOSE :  definies the basic functions for VCI                            */
/*                                                                            */
/* ************************************************************************** */
typedef struct tagVCI_METHOD_STRUCT {

   VCI_RETCODE (*pfVciGetInfo)(VCI_CODEC_INFO_BLOCK *pvciCodecInfoBlk);

   VCI_RETCODE (*pfVciEncode)(void *hCodecMemBlk, VCI_CODEC_IO_BLOCK *hvciEncodeIOBlk);
   VCI_RETCODE (*pfVciDecode)(void *hCodecMemBlk, VCI_CODEC_IO_BLOCK *hvciDecodeIOBlk);

   VCI_RETCODE (*pfVciInitEncode)(void **hCodecMemBlk);
   VCI_RETCODE (*pfVciInitDecode)(void **hCodecMemBlk); 
                                                      
   VCI_RETCODE (*pfVciFreeEncode)(void **hCodecMemBlk);                                                       
   VCI_RETCODE (*pfVciFreeDecode)(void **hCodecMemBlk);  

} VCI_METHOD_STRUCT;


/* ************************************************************************** */
/*                                                                            */
/* STRUCTURE: VCI_PLUS_METHOD_STRUCT                                          */
/* PURPOSE :  definies the plus functionalities for VCI                       */
/*                                                                            */
/* ************************************************************************** */
typedef struct tagVCI_PLUS_METHOD_STRUCT {
   VCI_RETCODE (*pfVciDecodeNeedsInput)(void *hCodecMemBlk, unsigned char *pUnPack);
   VCI_RETCODE (*pfVciSetWarpFactor)(void *hCodecMemBlk, float wWarpFactor);
   VCI_RETCODE (*pfVciGetWarpFactor)(void *hCodecMemBlk, float *pwWarpFactor);

   VCI_RETCODE (*pfVciSetInjectSilenceFlag)(void *hCodecMemBlk);

   VCI_RETCODE (*pfVciGetEnergy)(void *hCodecMemBlk, short *pwEnergyLevel);   
  
   VCI_RETCODE (*pfVciNumFramesInBuffer)(const void     *hCodecMemBlk, 
                                    const VCI_CODEC_IO_BLOCK  *hvciCodecIOBlk,
                                    unsigned short      *pwNumFrames,
                                    unsigned short      *pwByteOffset,
                                    unsigned char       *pchBitOffset);
   VCI_RETCODE (*pfVciSeekForward)(const void     *hCodecMemBlk, 
                              const VCI_CODEC_IO_BLOCK  *hvciCodecIOBlk,
                              unsigned short      wNumFrames,
                              unsigned short      *pwByteOffset,
                              unsigned char       *pchBitOffset);

   VCI_RETCODE (*pfVciSetFramesSkipped)(void *pDecodeMemBlk, int iFramesSkipped);
   VCI_RETCODE (*pfVciSetRepeatFrameFlag)(void *pDecodeMemBlk);


   VCI_RETCODE (*pfVciExtractFromBitStream)(const void * pVciCodecBlk,
                                         const VCI_CODEC_IO_BLOCK  *pvciInputIOBlk,
                                         VCI_CODEC_IO_BLOCK  *pvciOutputIOBlk,
                                         unsigned long      ScCodec);

   VCI_RETCODE (*pfVciCombineBitStream)(const void * pVciCodecBlk,
                                     const VCI_CODEC_IO_BLOCK *pvciInputAIOBlk,
                                     const VCI_CODEC_IO_BLOCK *pvciInputBIOBlk,
                                     VCI_CODEC_IO_BLOCK *pvciOutputIOBlk,
                                     unsigned long  ScCodecA,
                                     unsigned long  ScCodecB);

   VCI_RETCODE (*pfVciGetRatesInFrame)(const void *pVciCodecBlk,
                                     const VCI_CODEC_IO_BLOCK  *pvciCodecIOBlk,
                                     unsigned long   *ScCodec);

   VCI_RETCODE (*pfVciSetEncoderRate)(const void *pEncodeMemBlk, unsigned long wBitField);
   VCI_RETCODE (*pfVciGetEncoderRate)(const void *pEncodeMemBlk, unsigned long *wBitField); 

   VCI_RETCODE (*pfVciGetValidRates)(const void *pCodecMemBlk, unsigned long *wBitField);

   VCI_RETCODE (*pfVciCalculateBitRate)(const void *pCodecMemBlk, unsigned long wBitField, 
                                        unsigned short *wBitRate);
   VCI_RETCODE (*pfVciCalculateRateSC)(const void *pCodecMemBlk, unsigned short wBitRate, 
                                        unsigned long *wBitField);

   unsigned short *wStreamTable;

} VCI_PLUS_METHOD_STRUCT;



/* ************************************************************************** */
/*                                                                            */
/* STRUCTURE: VCI_CODEC_BLOCK                                                 */
/* PURPOSE :  This a wrapper put around the codec's encode or decode by VCI   */
/*            It is used by VCI to identify the memory block.                 */
/*                                                                            */
/* ************************************************************************** */
typedef struct tagVciCodecBlock
{
/* Warning Warning Warning Warning Warning Warning Warning Warning Warning */
/* DO NOT MOVE THE FIRST ELEMENT OF THIS SRUCT!!!!!!!!                     */
/* Warning Warning Warning Warning Warning Warning Warning Warning Warning */
   unsigned long  dwVciChunkID;  /* Number used to identify a VCI memory   */
                                    /* block.                                 */
   unsigned long  dwCodecClassID;   /* Codec class ID                         */   
   unsigned long  dwCodecID;        /* Specific ID                            */

   unsigned char  chEncOrDec;       /* Identifies wether the memory block po- */
                                    /* inted to by hCodecMblk is an encode or */
                                    /* decode memory block.                   */
   void           *hCodecMblk;      /* Points to an encode or decode memory   */
                                    /* block.                                 */
   void           *pQuanMemBlk;     /* Points to a Quantize memory block      */
   void           *pvemMemBlk;      /* Points to the extension manager memory */

   void           *pVciCodecIOBlock;/* Attached VCI Codec IO Block            */
   void           *pScratchBlk;     /* Points to Scratch Memory block         */

   VCI_METHOD_STRUCT *pVciMethodStruct; /* needed for extensions that call VCI*/
   VCI_PLUS_METHOD_STRUCT *pVciPlusMethodStruct; /* as bove for vci plus funcs*/

} VCI_CODEC_BLOCK;

/* ************************************************************************** */
/*                              hCodecMblk TYPES                              */
/* ************************************************************************** */
/* Defines the types of codec memory blocks. These are the values that are    */
/* assigned to chEncOrDec.                                                    */
#define ENCODE_ID   0xA
#define DECODE_ID   0xB

#ifndef SANITY_CHECK
#define SANITY_CHECK 0xFACE
#endif

#define VCI_BLOCK_CHECK(ptr)    (ptr&&(((VCI_CODEC_BLOCK*)ptr)->dwVciChunkID==SANITY_CHECK))
#define VCI_GET_VEM_HANDLE(ptr) (((VCI_CODEC_BLOCK*)ptr)->pvemMemBlk)

#define VCI_IS_ENCODE(ptr)      (((VCI_CODEC_BLOCK*)ptr)->chEncOrDec==ENCODE_ID)
#define VCI_IS_DECODE(ptr)      (((VCI_CODEC_BLOCK*)ptr)->chEncOrDec==DECODE_ID)

#define VCI_GET_CLASS_ID(ptr)   (((VCI_CODEC_BLOCK*)ptr)->dwCodecClassID)
#define VCI_GET_CODEC_ID(ptr)   (((VCI_CODEC_BLOCK*)ptr)->dwCodecID)

/* functions for initializing the method struct */
unsigned short vciInitMethodStruct(VCI_METHOD_STRUCT **hVciMethodStruct);
unsigned short vciFreeMethodStruct(VCI_METHOD_STRUCT **hVciMethodStruct);

#endif /* VCIPRIV_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\vcisc3.c ===
/******************************************************************************
*                        Voxware Proprietary Material
*                        Copyright 1996, Voxware, Inc
*                            All Rights Reserved
*
*                       DISTRIBUTION PROHIBITED without
*                      written authorization from Voxware
******************************************************************************/

/******************************************************************************
* Filename:    vciSC3.c
*
* Purpose:     Defines the interface functions for the Voxware SC Quality codec
*
* Functions:   vciGetInfoSC3, vciEncodeSC3, vciDecodeSC3, 
*              vciInitEncodeSC3, vciInitDecodeSC3, vciFreeEncodeSC3,
*              vciFreeDecodeSC3, vciGetExtCompatibilitySC3
*
* Author/Date: Ilan Berci, Epiphany Vera 97/05/19
*******************************************************************************
*
* Modifications:
*
* Comments:
*
* Concerns:
*
* $Header:   P:/r_and_d/archives/scaleable/vci/vciSC3.c_v   1.26   12 Oct 1998 10:23:50   johnp  $
******************************************************************************/

/** *********************************************************************** **/
/**                             Standard headers                            **/
/** *********************************************************************** **/
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <assert.h>

/** *********************************************************************** **/
/**                              Vci Headers                                **/
/** *********************************************************************** **/
#include "vci.h"
#include "vciError.h"
#include "vciPriv.h"
#include "vciPlus.h"
#include "vciPlsSC.h"

/** *********************************************************************** **/
/**                              Codec Headers                              **/
/** *********************************************************************** **/
#include "vLibPack.h"
#include "vem2Prm.h"
#include "VoxMem.h"
#include "vem2.h"
#include "codec.h"
#include "quansc36.h"
#include "DecSC.h"
#include "DecPlsSC.h"

#ifndef DECODE_ONLY
#include "EncSC.h"
#endif

#include "Coder.h"
#include "CodeStr.h"
#include "PackSC.h"
#include "vCodecID.h"
#include "FadeSC.h"
#include "rate.h"
#include "paramSC.h"
#include "vciSC3.h"
#include "DecPriSC.h"

#include "xvocver.h"

/** ************************************************************************ **/
/**                     Voxware Core Interface PreDefines                    **/
/** ************************************************************************ **/

#define MAX_STACK_WORD_SC3_ENC        2000
#define MAX_STACK_WORD_SC3_DEC        900

#define VEM_COMPATIBILITY_VFONT       20
#define VEM_COMPATIBILITY_VAD_AGC     20
#define VEM_COMPATIBILITY_PLUS        20
#define VEM_COMPATIBILITY_DEFAULT     0

#define SC_CODEC_VERSION              "SC.01.08.00"


/** ************************************************************************ **/
/**                            Private Prototypes                            **/
/** ************************************************************************ **/

static unsigned  short SC3CompatibilityFunc(unsigned short VemPlugin, 
                                            unsigned long *pVemCodID);

static unsigned short initMethodStruct(VCI_METHOD_STRUCT **hVciMethodStruct);
static unsigned short freeMethodStruct(VCI_METHOD_STRUCT **hVciMethodStruct);

                                     
/******************************************************************************
*
* Function:  vciGetInfoSC3()        
*
* Action:    Fill up information block for SC3
*
* Input:    pvciCodecInfoBlk -- pointer to the info. block
*
* Output:   pvciCodecInfoBlk -- filled up info. block
*
* Globals:   none
*
* Return:    VCI error code
*******************************************************************************
*
* Implementation/Detailed Description:
*
* References:
*******************************************************************************
*
* Modifications:
*
* Comments:  
*
* Concerns/TBD:
******************************************************************************/

VCI_RETCODE vciGetInfoSC3(VCI_CODEC_INFO_BLOCK *pvciCodecInfoBlk)
{

   pvciCodecInfoBlk->wVCIVersion               = (unsigned short) VCI_VERSION;
   
   /* Variables for codec identification.     */
   strcpy(pvciCodecInfoBlk->sCodecVersion,       SC_CODEC_VERSION);
   pvciCodecInfoBlk->dwCodecClassID            = (unsigned long)VOXWARE_CODEC_SC_8K_3;      
   pvciCodecInfoBlk->dwCodecID                 = (unsigned long)VOXWARE_CODEC_ID_SC_8K_3_GENERIC;
   
   /* PCM Data formats.                       */
   pvciCodecInfoBlk->wSamplingRate             = (unsigned short)RATE8K;   
   pvciCodecInfoBlk->wNumBitsPerSample         = 16; 
   pvciCodecInfoBlk->wNumSamplesPerFrame       = (unsigned short)FRAME_LENGTH_SC;

   /* Bitstream information.                  */
   pvciCodecInfoBlk->dwBitRate                 = (unsigned long)(TOTAL_BITS_SC3*
                                                    (float)RATE8K/(float)FRAME_LENGTH_SC);
   pvciCodecInfoBlk->dwMinPacketBits           = (unsigned short) TOTAL_BITS_SC3;
   pvciCodecInfoBlk->dwAvgPacketBits           = (unsigned short) TOTAL_BITS_SC3;
   pvciCodecInfoBlk->dwMaxPacketBits           = (unsigned short) TOTAL_BITS_SC3;

   /* Prime Flush Information */
   /* encoder delay + decoder delay == ENC_DELAY_SIZE (145 == 80 + 65) */
   pvciCodecInfoBlk->wNumPrimeFlushFrames      = (unsigned short)ceil((float)ENC_DELAY_SIZE
                                                 /(float)FRAME_LENGTH_SC);
   pvciCodecInfoBlk->wNumPrimeFlushSamples     = 
              (unsigned short)(pvciCodecInfoBlk->wNumPrimeFlushFrames*FRAME_LENGTH_SC
                               -ENC_DELAY_SIZE);
   
   /* Multi-channel support.                  */
   pvciCodecInfoBlk->wNumChannels              = 1;
   pvciCodecInfoBlk->wInterleaveBlockSize      = 1;
   
   return(VCI_NO_ERROR);
}
/*===========================================================================*/


#ifndef DECODE_ONLY
/******************************************************************************
*
* Function:  vciEncodeSC3()     
*
* Action:    Encodes one frame of speech using SC3.
*
* Input:    pEncodeMemBlk -- encoder structure
*           pvciCodecIOBlk -- codec I/O structure
*
* Output:   pEncodeMemBlk -- updated strcture
*           pvciCodecIOBlk -- updated strcture
*
* Globals:   none
*
* Return:    VCI error code
*******************************************************************************
*
* Implementation/Detailed Description:
*
* References:
*******************************************************************************
*
* Modifications:
*
* Comments:  
*
* Concerns/TBD:
******************************************************************************/

VCI_RETCODE vciEncodeSC3(void *pEncodeMemBlk, 
                         VCI_CODEC_IO_BLOCK *pvciCodecIOBlk)
{
   VCI_CODEC_BLOCK *vciCodecMblk = NULL;
   PARAM_SC    ParamMblk;  /* scratch memory */
   STACK_DECLARE

   /* check the validity of the VCI IO blk */
   VCI_IO_BLK_PARAM_CHECK(pvciCodecIOBlk);

   if(!VCI_BLOCK_CHECK(pEncodeMemBlk))
      return VCI_NOT_VCI_HANDLE;

   if(!VCI_IS_ENCODE(pEncodeMemBlk))
      return VCI_NOT_ENC_HANDLE;

   vciCodecMblk = (VCI_CODEC_BLOCK *)pEncodeMemBlk;
   STACK_ASSIGN(vciCodecMblk->pScratchBlk)
   vciCodecMblk->pVciCodecIOBlock=pvciCodecIOBlk;

   /* check to make sure that codec was initialized at 3 or higher */
   if(!(voxGetEncodeInitRate(vciCodecMblk->hCodecMblk)&SC_RATE_3K))
      return VCI_CODEC_NOT_SUPPORTED; 

   VoxEncodeSC(STACK_S pvciCodecIOBlk->pPCMBuffer, vciCodecMblk->hCodecMblk,
               (void *)&ParamMblk);

   /* combine quantization and pack together to save memory */
   {
     int QuanIndex[TOTAL_SC3_QUAN_INDICES];
 
     VoxQuantSC3(STACK_S QuanIndex, vciCodecMblk->hCodecMblk,
                 (void *)&ParamMblk);

     VoxPackSC3(QuanIndex, pvciCodecIOBlk->pVoxBuffer, 
                &(pvciCodecIOBlk->wVoxBufferWriteByteOffset),
                &(pvciCodecIOBlk->chVoxBufferWriteBitOffset), 
                pvciCodecIOBlk->wVoxBufferSize,
                (unsigned short) END_OF_FRAME);
   }

   return(VCI_NO_ERROR);
}
/*===========================================================================*/
#endif

/******************************************************************************
*
* Function:  vciDecodeSC3()
*
* Action:    Decodes one frame of speech using SC3.
*
* Input:    pDecodeMemBlk -- decoder structure
*           pvciCodecIOBlk -- codec I/O structure
*
* Output:   pDecodeMemBlk -- updated strcture
*           pvciCodecIOBlk -- updated strcture
*
* Globals:   none
*
* Return:    VCI error code
*******************************************************************************
*
* Implementation/Detailed Description:
*
* References:
*******************************************************************************
*
* Modifications:
*
* Comments:  
*
* Concerns/TBD:
******************************************************************************/

VCI_RETCODE vciDecodeSC3(void *pDecodeMemBlk, 
                         VCI_CODEC_IO_BLOCK *pvciCodecIOBlk)
{
   VCI_CODEC_BLOCK *vciCodecMblk = NULL;
   DEC_MEM_BLK     *pDecMemBlk;
   PARAM_SC        ParamMblk; 
   unsigned short  sLongerFrameFlag;
   short wSeek;
   STACK_DECLARE
   VCI_RETCODE VoxErrRet = VCI_NO_ERROR;
   unsigned short sByteOffset;
   unsigned char cBitOffset;
   unsigned char cDecReqDataFlagSC;

   /*----------------------------------------------------
     sanity check and decode check
   ----------------------------------------------------*/
   if(!VCI_BLOCK_CHECK(pDecodeMemBlk))
      return VCI_NOT_VCI_HANDLE;

   if(!VCI_IS_DECODE(pDecodeMemBlk))     
      return VCI_NOT_DEC_HANDLE;
   
   /*----------------------------------------------------
     set some pointers and assign the VoxStack
   ----------------------------------------------------*/
   vciCodecMblk = (VCI_CODEC_BLOCK *)pDecodeMemBlk;

   pDecMemBlk = (DEC_MEM_BLK *)(vciCodecMblk->hCodecMblk);

   STACK_ASSIGN(vciCodecMblk->pScratchBlk);
   vciCodecMblk->pVciCodecIOBlock=pvciCodecIOBlk;

   /*----------------------------------------------------
     check the validity of the VCI IO Block.
   ----------------------------------------------------*/
   
   if (SILENCE != GetCurrentFrameStateSC(pDecMemBlk->pFadeIOMemBlk))
   {
	   VCI_IO_BLK_PARAM_CHECK(pvciCodecIOBlk);

	  /*----------------------------------------------------
		 If the decoder needs a new frame to decode then
		   get the new frame from pvciCodecIOBlk->pVoxBuffer
		   and put it in vciCodecMblk->pbSaveVoxBuffer.
	   ----------------------------------------------------*/
	   if (voxGetDecReqDataFlagSC((void *)pDecMemBlk))
		{

		/*------------------------------------------------------------
		  Check whether there are sufficient Vox data.
		  ------------------------------------------------------------*/
		  VoxErrRet = vciSeekForwardSC(pDecodeMemBlk, pvciCodecIOBlk,
									   1, &sByteOffset, &cBitOffset);

		  if (VoxErrRet != VCI_NO_ERROR)
			 return VoxErrRet;

		/*------------------------------------------------------------
		  No further test is needed at this point because the error
			condition has already been tested and there is a frame
			of data available in the circular buffer.
		  ------------------------------------------------------------*/
		  copyCBuf2LBuf(pvciCodecIOBlk->pVoxBuffer, 
						&(pvciCodecIOBlk->wVoxBufferReadByteOffset),
						&(pvciCodecIOBlk->chVoxBufferReadBitOffset), 
						pvciCodecIOBlk->wVoxBufferSize, 
						TOTAL_BITS_SC3, pDecMemBlk->pbSaveVoxBuffer);
		}

	   /*---------------------------------------------------------
		 Unpack and unquantize the frame in 
		   vciCodecMblk->pbSaveVoxBuffer.
	   ---------------------------------------------------------*/
	   {
		 int QuanIndex[TOTAL_SC3_QUAN_INDICES];
		 sByteOffset = 0;
		 cBitOffset = 0;
	   /*---------------------------------------------------------
		 This unpacking location is a momentary hack, must be changed 
		 to support time scaling ####
		 ---------------------------------------------------------*/
		 VoxUnPackSC3(QuanIndex,
					  pDecMemBlk->pbSaveVoxBuffer,
					  &sByteOffset,
					  &cBitOffset,
					  TOTAL_BYTES_SC3,
					  &sLongerFrameFlag);

		 VoxUnQuantSC3(STACK_S QuanIndex, (void *)pDecMemBlk, &ParamMblk);
	   }

	   /*---------------------------------------------------------
		 if sLongerFrameFlag==LONGER_FRAME then this is a 
		 SC_RATE_6K bitstream and we need to increment the byte
		 pointer in the circular buffer by ADDITIONAL_BYTES_SC6
		 ---------------------------------------------------------*/
	   if (voxGetDecReqDataFlagSC((void *)pDecMemBlk) 
		   && (sLongerFrameFlag==LONGER_FRAME))
		 {
		   wSeek=seekForward(pvciCodecIOBlk->pVoxBuffer,
							 pvciCodecIOBlk->wVoxBufferReadByteOffset,
							 pvciCodecIOBlk->wVoxBufferWriteByteOffset,
							 pvciCodecIOBlk->wVoxBufferSize,
							 1, NULL);

		   if(wSeek==-2) 
			  return VCI_BITSTREAM_CORRUPTED;

		   pvciCodecIOBlk->wVoxBufferReadByteOffset=(unsigned short)wSeek;
		 }
   }
   else
   {
	   VCI_SIL_IO_BLK_PARAM_CHECK_DEC(pvciCodecIOBlk);
   }

   /*----------------------------------------------------
     Set the decoder rate, it is always 3
   ----------------------------------------------------*/
   if(voxSetDecodeSC((void *)pDecMemBlk, SC_RATE_3K))
     return VCI_CODEC_NOT_SUPPORTED;
   
   /*---------------------------------------------------------
     Call the fade routine to modify parameters if there
       has benn a fade.
   ---------------------------------------------------------*/
   VoxFadeSC(pDecMemBlk->pFadeIOMemBlk, &ParamMblk);

   /*---------------------------------------------------------
     Decode the parameters.
   ---------------------------------------------------------*/
   VoxDecodeSC(STACK_S (void *)pDecMemBlk, &ParamMblk, pvciCodecIOBlk->pPCMBuffer, 
               &(pvciCodecIOBlk->wSamplesInPCMBuffer) );
 
   /*---------------------------------------------------------
     Update the fade block for the case when the decoder
       is not yet finished with the current frame.
   ---------------------------------------------------------*/
   cDecReqDataFlagSC = voxGetDecReqDataFlagSC((void *)pDecMemBlk);
   UpdateFadeStateSC( pDecMemBlk->pFadeIOMemBlk, cDecReqDataFlagSC );

   return(VCI_NO_ERROR);
}
/*===========================================================================*/


#ifndef DECODE_ONLY
/******************************************************************************
*
* Function:  vciInitEncodeSC3()
*
* Action:    To allocate memory for a Codec Memory Block and to initialize
*            it as an encoder.  
*
* Input:    hEncodeMemBlk -- the pointer to the encoder structure
*
* Output:   hEncodeMemBlk -- memory allocated and initialized encoder structure
*
* Globals:   none
*
* Return:    VCI error code
*******************************************************************************
*
* Implementation/Detailed Description:
*
* References:
*******************************************************************************
*
* Modifications:
*
* Comments:  
*
* Concerns/TBD:
******************************************************************************/

VCI_RETCODE vciInitEncodeSC3(void **hEncodeMemBlk)
{
   VCI_CODEC_BLOCK *vciCodecMblk=NULL;
   STACK_DECLARE

   if(!hEncodeMemBlk)
      return VCI_NULL_ARG;

   if(VOX_MEM_INIT(vciCodecMblk=*hEncodeMemBlk,1,sizeof(VCI_CODEC_BLOCK))) 
     return VCI_FAILED_MEM_ALLOC;

   vciCodecMblk->chEncOrDec = ENCODE_ID;  
   vciCodecMblk->dwVciChunkID = SANITY_CHECK;
   vciCodecMblk->dwCodecClassID = VOXWARE_CODEC_SC_8K_3;
   vciCodecMblk->dwCodecID = VOXWARE_CODEC_ID_SC_8K_3_GENERIC;

   if(STACK_SET(vciCodecMblk->pScratchBlk,(MAX_STACK_WORD_SC3_ENC*sizeof(int)))) {
      vciFreeEncodeSC3(hEncodeMemBlk);
      return VCI_FAILED_MEM_ALLOC;
   }

   if(!(vciCodecMblk->pvemMemBlk=vemInit())) {
#if VEM_DEFINED == 1
      vciFreeEncodeSC3(hEncodeMemBlk);
      return VCI_FAILED_MEM_ALLOC; 
#endif
   } else {
      vemRegisterConstShort(GET_VEM_MEMORY_HANDLE(vciCodecMblk), 
                            (short)FRAME_LENGTH_SC, "frame length");
      vemRegisterConstShort(GET_VEM_MEMORY_HANDLE(vciCodecMblk), 
                            (short)RATE8K, "rate");
   }

   if(VoxInitEncodeSC3(&vciCodecMblk->hCodecMblk, vciCodecMblk->pvemMemBlk)) {
      vciFreeEncodeSC3(hEncodeMemBlk);
      return VCI_FAILED_MEM_ALLOC;
   }

   if(initMethodStruct(&vciCodecMblk->pVciMethodStruct))
      return VCI_FAILED_MEM_ALLOC;

   return VCI_NO_ERROR;
}
/*===========================================================================*/
#endif


/******************************************************************************
*
* Function:  vciInitDecodeSC3()
*
* Action:    To allocate memory for a Codec Memory Block and to initialize
*            it as a decoder.
*
* Input:    hDecodeMemBlk -- the pointer to the decoder structure
*
* Output:   hDecodeMemBlk -- allocated  and initilized structure
*
* Globals:   none
*
* Return:    VCI error code
*******************************************************************************
*
* Implementation/Detailed Description:
*
* References:
*******************************************************************************
*
* Modifications:
*
* Comments:  
*
* Concerns/TBD:
******************************************************************************/

VCI_RETCODE vciInitDecodeSC3(void **hDecodeMemBlk)
{
   VCI_CODEC_BLOCK *vciCodecMblk=NULL;
   DEC_MEM_BLK *pDecMemBlk;

   STACK_DECLARE

   if(!hDecodeMemBlk)
      return VCI_NULL_ARG;

   if(VOX_MEM_INIT(vciCodecMblk=*hDecodeMemBlk,1,sizeof(VCI_CODEC_BLOCK))) 
      return VCI_FAILED_MEM_ALLOC;

   vciCodecMblk->chEncOrDec = DECODE_ID;
   vciCodecMblk->dwVciChunkID = SANITY_CHECK;

   if(STACK_SET(vciCodecMblk->pScratchBlk,MAX_STACK_WORD_SC3_DEC*sizeof(int))) {
      vciFreeDecodeSC3(hDecodeMemBlk);
      return VCI_FAILED_MEM_ALLOC;
   } 

   if(!(vciCodecMblk->pvemMemBlk=vemInit())) {
#if VEM_DEFINED == 1
      vciFreeDecodeSC3(hDecodeMemBlk);
      return VCI_FAILED_MEM_ALLOC;
#endif
   }

   if(VoxInitDecodeSC3(&vciCodecMblk->hCodecMblk)) {
      vciFreeDecodeSC3(hDecodeMemBlk);
      return VCI_FAILED_MEM_ALLOC;
   } 

   pDecMemBlk = (DEC_MEM_BLK *)(vciCodecMblk->hCodecMblk);

   if(VoxinitFadeSC(&pDecMemBlk->pFadeIOMemBlk)) {
      vciFreeDecodeSC3(hDecodeMemBlk);
      return VCI_FAILED_MEM_ALLOC;
   }

   if (VOX_MEM_INIT(pDecMemBlk->pbSaveVoxBuffer, 
                    TOTAL_BYTES_SC3,
                    sizeof(unsigned char *)))
     return VCI_FAILED_MEM_ALLOC;

   if(initMethodStruct(&vciCodecMblk->pVciMethodStruct))
      return VCI_FAILED_MEM_ALLOC;

   return VCI_NO_ERROR;
}
/*===========================================================================*/


#ifndef DECODE_ONLY
/******************************************************************************
*
* Function:  vciFreeEncodeSC3()
*
* Action:    Frees memory assigned to the encoder.
*
* Input:    hEncodeMemBlk -- the pointer to the encoder structure
*
* Output:   hEncodeMemBlk -- freed memory 
*
* Globals:   none
*
* Return:    VCI error code
*******************************************************************************
*
* Implementation/Detailed Description:
*
* References:
*******************************************************************************
*
* Modifications:
*
* Comments:  
*
* Concerns/TBD:
******************************************************************************/

VCI_RETCODE vciFreeEncodeSC3(void **hEncodeMemBlk)
{  
   VCI_CODEC_BLOCK *vciCodecMblk = NULL;

   /* First make sure that the handle passed is the correct one. */
   if(!hEncodeMemBlk)
      return VCI_NULL_ARG;

   if(!VCI_BLOCK_CHECK(*hEncodeMemBlk))
      return VCI_NOT_VCI_HANDLE;

   if(!VCI_IS_ENCODE(*hEncodeMemBlk))
      return VCI_NOT_DEC_HANDLE;

   vciCodecMblk = (VCI_CODEC_BLOCK *)*hEncodeMemBlk;
   
   vciCodecMblk->dwVciChunkID=0;

   VoxFreeEncodeSC3(&vciCodecMblk->hCodecMblk);

   vemFree(vciCodecMblk->pvemMemBlk);

   freeMethodStruct(&vciCodecMblk->pVciMethodStruct);

   STACK_UNSET(vciCodecMblk->pScratchBlk)

   VOX_MEM_FREE(vciCodecMblk);

   return VCI_NO_ERROR;
}
/*===========================================================================*/
#endif

/******************************************************************************
*
* Function:  vciFreeDecodeSC3()
*
* Action:    Frees memory assigned to the decoder.
*
* Input:    hDecodeMemBlk -- the pointer to the decoder structure
*
* Output:   hDecodeMemBlk -- freed memory 
*
* Globals:   none
*
* Return:    VCI error code
*******************************************************************************
*
* Implementation/Detailed Description:
*
* References:
*******************************************************************************
*
* Modifications:
*
* Comments:  
*
* Concerns/TBD:
******************************************************************************/

VCI_RETCODE vciFreeDecodeSC3(void **hDecodeMemBlk)
{
   VCI_CODEC_BLOCK *vciCodecMblk = NULL;
   DEC_MEM_BLK *pDecMemBlk;

   /* First make sure that the handle passed is the correct one. */
   if(!hDecodeMemBlk)
      return VCI_NULL_ARG;

   /* First make sure that the handle passed is the correct one. */
   if(!VCI_BLOCK_CHECK(*hDecodeMemBlk))
      return VCI_NOT_VCI_HANDLE;

   if(!VCI_IS_DECODE(*hDecodeMemBlk))
      return VCI_NOT_DEC_HANDLE;
   
   vciCodecMblk = (VCI_CODEC_BLOCK *)*hDecodeMemBlk;
   pDecMemBlk = (DEC_MEM_BLK *)(vciCodecMblk->hCodecMblk);

   vciCodecMblk->dwVciChunkID=0;

   VoxfreeFadeSC(&pDecMemBlk->pFadeIOMemBlk);

   VOX_MEM_FREE(pDecMemBlk->pbSaveVoxBuffer);

   VoxFreeDecodeSC3(&vciCodecMblk->hCodecMblk);

   vemFree(vciCodecMblk->pvemMemBlk);

   freeMethodStruct(&vciCodecMblk->pVciMethodStruct);

   STACK_UNSET(vciCodecMblk->pScratchBlk)

   VOX_MEM_FREE(vciCodecMblk);

  return VCI_NO_ERROR;
}

/*===========================================================================*/


/******************************************************************************
*
* Function:  vciGetExtCompatibilitySC3()  
*
* Action:    Returns compatibility function 
*
* Input:    pCompatFunc -- the function pointer to the compatibility function
*
* Output:   pCompatFunc -- the compatibility function
*
* Globals:   none
*
* Return:    VCI return error
*******************************************************************************
*
* Implementation/Detailed Description:
*
* References:
*******************************************************************************
*
* Modifications:
*
* Comments:  
*
* Concerns/TBD:
******************************************************************************/

VCI_RETCODE vciGetExtCompatibilitySC3(void **pCompatFunc)
{
   *((COMPATIBILITY_FUNCTION **)pCompatFunc)=&SC3CompatibilityFunc;

   return VCI_NO_ERROR;
}


/******************************************************************************
*
* Function:  SC3CompatibilityFunc()
*
* Action:    Get the compatiliby ID
*
* Input:    VemPlugin -- the VEM-plug-in-ID
*           pVemCodID -- the pointer to the current codec ID
*
* Output:   pVemCodID -- the current codec ID
*
* Globals:   none
*
* Return:    vem-compatibility-ID 
*******************************************************************************
*
* Implementation/Detailed Description:
*
* References:
*******************************************************************************
*
* Modifications:
*
* Comments:  
*
* Concerns/TBD:
******************************************************************************/

static unsigned  short SC3CompatibilityFunc(unsigned short VemPlugin, 
                                            unsigned long *pVemCodID) 
{
   unsigned short vem_compatibility_ID;

   *pVemCodID=(unsigned long)VOXWARE_CODEC_SC_8K_3;
   
   switch(VemPlugin) {
      case COMPATIBILITY_VFONT:
        vem_compatibility_ID = (unsigned short)VEM_COMPATIBILITY_VFONT;
        break;

      case COMPATIBILITY_VAD_AGC:
        vem_compatibility_ID = (unsigned short)VEM_COMPATIBILITY_VAD_AGC;
        break;

      case COMPATIBILITY_PLUS: 
        vem_compatibility_ID = (unsigned short)VEM_COMPATIBILITY_PLUS;
        break;

      default:
        vem_compatibility_ID = (unsigned short)VEM_COMPATIBILITY_DEFAULT;
   }

   return vem_compatibility_ID;
}



/******************************************************************************
*
* Function:  initMethodStruct()
*
* Action:    initialization of the VCI method structure
*
* Input:    hVciMethodStruct -- the pointer to the VCI method structure
*
* Output:   hVciMethodStruct -- the memory allocated and initialized 
*                               VCI method structure
*
* Globals:   none
*
* Return:    0: no error , 1: memory allocation error
*******************************************************************************
*
* Implementation/Detailed Description:
*
* References:
*******************************************************************************
*
* Modifications:
*
* Comments:  
*
* Concerns/TBD:
******************************************************************************/

static unsigned short initMethodStruct(VCI_METHOD_STRUCT **hVciMethodStruct)
{
   if(VOX_MEM_INIT(*hVciMethodStruct,1,sizeof(VCI_METHOD_STRUCT)))
      return 1;

   (*hVciMethodStruct)->pfVciGetInfo=vciGetInfoSC3;

#ifndef DECODE_ONLY
   (*hVciMethodStruct)->pfVciEncode=vciEncodeSC3;
   (*hVciMethodStruct)->pfVciInitEncode=vciInitEncodeSC3;
   (*hVciMethodStruct)->pfVciFreeEncode=vciFreeEncodeSC3;
#endif

   (*hVciMethodStruct)->pfVciDecode=vciDecodeSC3;
   (*hVciMethodStruct)->pfVciInitDecode=vciInitDecodeSC3; 
   (*hVciMethodStruct)->pfVciFreeDecode=vciFreeDecodeSC3;

   return 0;
}

/******************************************************************************
*
* Function:  freeMethodStruct()
*
* Action:    free the memory for the VCI method structure
*
* Input:    hVciMethodStruct -- the pointer to the VCI method structure
*
* Output:   hVciMethodStruct -- memory freed structure
*
* Globals:   none
*
* Return:    0: no error
*******************************************************************************
*
* Implementation/Detailed Description:
*
* References:
*******************************************************************************
*
* Modifications:
*
* Comments:  
*
* Concerns/TBD:
******************************************************************************/

static unsigned short freeMethodStruct(VCI_METHOD_STRUCT **hVciMethodStruct)
{
   if(hVciMethodStruct)
      VOX_MEM_FREE(*hVciMethodStruct);

   return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\vcipvr12.c ===
/******************************************************************************
 *                                                                            *
 *		                  Voxware Proprietary Material                          *
 *		                  Copyright 1996, Voxware, Inc.                         *
 *		                       All Rights Resrved                               *
 *                                                                            *
 *		                 DISTRIBUTION PROHIBITED without                        *
 *		               written authorization from Voxware                       *
 *                                                                            *
 ******************************************************************************/

/******************************************************************************
 *                                                                            *
 * FILENAME:  vciPVR12.c                                                      *
 * PURPOSE:   Functions for the RT version of the VCI Plus Codec Extension.   *
 * AURTHORS:  John Puterbaugh, Ilan Berci & Epiphany Vera                     *
 *                                                                            *
 *****************************************************************************/

/******************************************************************************
 *                                                                            *
 *                          DETAILED REVISION HISTORY                         *
 *                                                                            *
 * (March 17, '97)                                                            *
 *    Created                                                                 *
 *                                                                            *
 *****************************************************************************/

#include <stdlib.h>
#include <math.h>
#include <assert.h>

#include "vci.h"
#include "vciPriv.h"
#include "vciError.h"
#include "vCodecID.h"

#include "VoxMem.h"
#include "vmEngLev.h"
#include "vemFrm12.h"
#include "DecodeRT.h"
#include "EncodeRT.h"
#include "param.h"
#include "FadeIO.h"
#include "Quan12.h"

#include "vciPlus.h"
#include "vciPVR12.h"

#include "xvocver.h"

#define MIN_WARP 0.2F
#define MAX_WARP 5.0F
#define DB2LEVEL_VALUE          28.3333333333F       /***** (255.0/9.0) *****/

/* ************************************************************************** */
/*                                                                            */
/* FUNCTION: vciSetWarpFactorVR12()                                           */
/* PURPOSE : Sets the warp factor for the decoder.                            */
/*                                                                            */
/* ************************************************************************** */
VCI_RETCODE vciSetWarpFactorVR12(void *hCodecMemBlk, float wWarpFactor)
{
   VCI_CODEC_BLOCK *vciCodecMblk = NULL;

   if(!VCI_BLOCK_CHECK(hCodecMemBlk))
      return VCI_NOT_VCI_HANDLE;

   if(!VCI_IS_DECODE(hCodecMemBlk))
      return VCI_NOT_DEC_HANDLE;

   vciCodecMblk = (VCI_CODEC_BLOCK *)hCodecMemBlk;

   if(wWarpFactor<MIN_WARP||wWarpFactor>MAX_WARP)
      return VCI_ARG_OUT_OF_RANGE;

   (((DEC_MEM_BLK*)vciCodecMblk->hCodecMblk)->fWarpedLengthFactor)=wWarpFactor;

  return VCI_NO_ERROR;
}
/*============================================================================*/



/* ************************************************************************** */
/*                                                                            */
/* FUNCTION: vciGetWarpFactorVR12()                                           */
/* PURPOSE : Retrieves the warp factor setting in the  decoder.               */
/*                                                                            */
/* ************************************************************************** */
VCI_RETCODE   vciGetWarpFactorVR12(void *hCodecMemBlk, float *pwWarpFactor)
{
   VCI_CODEC_BLOCK *vciCodecMblk = NULL;

   if(!VCI_BLOCK_CHECK(hCodecMemBlk))
      return VCI_NOT_VCI_HANDLE;

   if(!VCI_IS_DECODE(hCodecMemBlk))
      return VCI_NOT_DEC_HANDLE;

   if(!pwWarpFactor)
      return VCI_NULL_ARG;

   vciCodecMblk = (VCI_CODEC_BLOCK *)hCodecMemBlk;

   *pwWarpFactor=(((DEC_MEM_BLK*)vciCodecMblk->hCodecMblk)->fWarpedLengthFactor);
   
   return VCI_NO_ERROR;
}

/* ************************************************************************** */
/*                                                                            */
/* FUNCTION: vciDecodeNeedsInputVR12()                                        */
/* PURPOSE : Checks whether the decoder needs input or not.                   */
/*                                                                            */
/* ************************************************************************** */
VCI_RETCODE vciDecodeNeedsInputVR12(void *hCodecMemBlk, 
                                    unsigned char *pUnPack)
{
   VCI_CODEC_BLOCK *vciCodecMblk = NULL;

   if(!VCI_BLOCK_CHECK(hCodecMemBlk))
      return VCI_NOT_VCI_HANDLE;

   if(!VCI_IS_DECODE(hCodecMemBlk))
      return VCI_NOT_DEC_HANDLE;

   if(!pUnPack)
      return VCI_NULL_ARG;

   vciCodecMblk = (VCI_CODEC_BLOCK *)hCodecMemBlk;

   *pUnPack=((DEC_MEM_BLK*)vciCodecMblk->hCodecMblk)->unpackFLAG;

   return VCI_NO_ERROR;
}

/* ************************************************************************** */
/*                                                                            */
/* FUNCTION: vciGetEnergyVR12()                                               */
/* PURPOSE : Gets the frame energy                                            */
/*                                                                            */
/*  From energy to dB then map dB from 0 to 255                               */
/*  we map the maximum 90 dB to 255                                           */
/*  so level = 255/90*(10*log10(energy))                                      */
/* ************************************************************************** */
VCI_RETCODE vciGetEnergyVR12(void *hCodecMemBlk, short *pwEnergyLevel)
{
   VCI_CODEC_BLOCK *vciCodecMblk = NULL;
   float energy;
   *pwEnergyLevel=-1;

   if(!VCI_BLOCK_CHECK(hCodecMemBlk))
      return VCI_NOT_VCI_HANDLE;

   if(!pwEnergyLevel)
      return VCI_NULL_ARG;

   vciCodecMblk = (VCI_CODEC_BLOCK *)hCodecMemBlk;

   if (vciCodecMblk->chEncOrDec   == ENCODE_ID) {
      energy=*(((ENC_MEM_BLK*)(vciCodecMblk->hCodecMblk))->dwLpc);
      *pwEnergyLevel=(short)(log10(energy+1.0)* DB2LEVEL_VALUE);
   } else  /* hack from the old days ..GA */
      *pwEnergyLevel=(short)(((QUAN_12*)(vciCodecMblk->pQuanMemBlk))->Energy_INDEX);

   return VCI_NO_ERROR;
}

/* ************************************************************************** */
/*                                                                            */
/* FUNCTION: vciSetInjectSilenceFlagVR12()                                    */
/* PURPOSE : Perform fade-in/fade-out and background noise injection during   */
/*           packet loss.                                                     */
/*                                                                            */
/* ************************************************************************** */
VCI_RETCODE vciSetInjectSilenceFlagVR12(void *hCodecMemBlk)
{
   DEC_MEM_BLK *DecMemBlk = NULL;

   if(!VCI_BLOCK_CHECK(hCodecMemBlk))
      return VCI_NOT_VCI_HANDLE;

   if(!VCI_IS_DECODE(hCodecMemBlk))
      return VCI_NOT_DEC_HANDLE;

   DecMemBlk = (DEC_MEM_BLK *)((VCI_CODEC_BLOCK *)hCodecMemBlk)->hCodecMblk;

   ((FadeIOstruct*)(DecMemBlk->pFadeIOMemBlk))->CurrentFrameState=0;

   return VCI_NO_ERROR;
}

/* ************************************************************************** */
/*                                                                            */
/* FUNCTION: vciNumFramesInBufferVR12()                                       */
/* PURPOSE : Counts the number of frames in the Vox buffer of the given codec */
/*           I/O block.                                                       */
/*                                                                            */
/* ************************************************************************** */
VCI_RETCODE vciNumFramesInBufferVR12(const void  *hCodecMemBlk, 
                                 const VCI_CODEC_IO_BLOCK *hvciCodecIOBlk,
                                 unsigned short *pwNumFrames,
                                 unsigned short *pwByteOffset,
                                 unsigned char  *pchBitOffset)
{
	unsigned short  BitsInFrame;

   if(!VCI_BLOCK_CHECK(hCodecMemBlk))
      return VCI_NOT_VCI_HANDLE;

   /* Do parameter checking on IO block. */
   VCI_IO_BLK_PARAM_CHECK(hvciCodecIOBlk);

   if(!pwNumFrames)
      return VCI_NULL_ARG;

   if(!pwByteOffset)
      return VCI_NULL_ARG;

   if(!pchBitOffset)
      return VCI_NULL_ARG;

   framesInBufferVR12(hvciCodecIOBlk, pwNumFrames);
         seekForwardVR12(hvciCodecIOBlk->wVoxBufferReadByteOffset, 
            hvciCodecIOBlk->chVoxBufferReadBitOffset, 
            hvciCodecIOBlk->wVoxBufferSize, 
            hvciCodecIOBlk->pVoxBuffer,
            *pwNumFrames, 
            pwByteOffset, 
            pchBitOffset, 
            &BitsInFrame);
       
   return VCI_NO_ERROR;
}




/* ************************************************************************** */
/*                                                                            */
/* FUNCTION: vciSeekForwardVR12()                                             */
/* PURPOSE : Seeks to a given frame offset.                                   */
/*                                                                            */
/* ************************************************************************** */
VCI_RETCODE vciSeekForwardVR12(const void  *hCodecMemBlk, 
                           const VCI_CODEC_IO_BLOCK *hvciCodecIOBlk,
                           unsigned short  wNumFrames,
                           unsigned short *pwByteOffset,
                           unsigned char  *pchBitOffset)
{
	unsigned short  BitsInFrame;
   unsigned short  TempFrames;

   if(!VCI_BLOCK_CHECK(hCodecMemBlk))
      return VCI_NOT_VCI_HANDLE;

   /* Do parameter checking on IO block. */
   VCI_IO_BLK_PARAM_CHECK(hvciCodecIOBlk);

   if(!pwByteOffset)
      return VCI_NULL_ARG;

   if(!pchBitOffset)
      return VCI_NULL_ARG;

	framesInBufferVR12(hvciCodecIOBlk, &TempFrames);
   if (TempFrames < wNumFrames)
      return VCI_INSUFFICIENT_VOX_DATA;

   seekForwardVR12(hvciCodecIOBlk->wVoxBufferReadByteOffset, 
      hvciCodecIOBlk->chVoxBufferReadBitOffset, 
      hvciCodecIOBlk->wVoxBufferSize, 
      hvciCodecIOBlk->pVoxBuffer,
      wNumFrames, 
      pwByteOffset, 
      pchBitOffset, 
      &BitsInFrame);

   /* An else would be required here to deal with variable rate codecs.       */
   return VCI_NO_ERROR;
}

/* ************************************************************************** */
/*                                                                            */
/* FUNCTION: vciGetPlusInfoVR12()                                               */
/* PURPOSE : Fills in the VCI plus info blk                                   */
/*                                                                            */
/* ************************************************************************** */
VCI_RETCODE vciGetPlusInfoVR12(VCI_PLUS_INFO_BLOCK *pVciPlusInfoBlk)
{

   if(!pVciPlusInfoBlk)
      return VCI_NULL_ARG;

   pVciPlusInfoBlk->wPlusFlags=VCI_CODEC_HAS_WARPING; 
   pVciPlusInfoBlk->wPlusFlags|=VCI_CODEC_HAS_SILENCE_INJECTION;
   pVciPlusInfoBlk->wPlusFlags|=VCI_CODEC_HAS_GET_ENERGY;
   pVciPlusInfoBlk->wPlusFlags|=VCI_CODEC_HAS_FRAME_TRAVERSAL;
   pVciPlusInfoBlk->wPlusFlags|=VCI_PRIME_FLUSH;

   pVciPlusInfoBlk->dwMinWarp=MIN_WARP;
   pVciPlusInfoBlk->dwMaxWarp=MAX_WARP;

   return VCI_NO_ERROR;
}

VCI_RETCODE vciPlusInitVR12(const void *pCodecMemBlk)
{
   VCI_CODEC_BLOCK *vciCodecMblk = NULL;

   if(!VCI_BLOCK_CHECK(pCodecMemBlk))
      return VCI_NOT_VCI_HANDLE;

   vciCodecMblk = (VCI_CODEC_BLOCK *)pCodecMemBlk;

   if(VOX_MEM_INIT(vciCodecMblk->pVciPlusMethodStruct,1,sizeof(VCI_PLUS_METHOD_STRUCT)))
      return VCI_FAILED_MEM_ALLOC;

   vciCodecMblk->pVciPlusMethodStruct->pfVciDecodeNeedsInput=vciDecodeNeedsInputVR12;
   vciCodecMblk->pVciPlusMethodStruct->pfVciSetWarpFactor=vciSetWarpFactorVR12;
   vciCodecMblk->pVciPlusMethodStruct->pfVciGetWarpFactor=vciGetWarpFactorVR12;

   vciCodecMblk->pVciPlusMethodStruct->pfVciSetInjectSilenceFlag=vciSetInjectSilenceFlagVR12;

   vciCodecMblk->pVciPlusMethodStruct->pfVciGetEnergy=vciGetEnergyVR12;   
  
   vciCodecMblk->pVciPlusMethodStruct->pfVciNumFramesInBuffer=vciNumFramesInBufferVR12;
   vciCodecMblk->pVciPlusMethodStruct->pfVciSeekForward=vciSeekForwardVR12;

   return VCI_NO_ERROR;
}

VCI_RETCODE vciPlusFreeVR12(const void *pCodecMemBlk)
{
   if(!VCI_BLOCK_CHECK(pCodecMemBlk))
      return VCI_NOT_VCI_HANDLE;

   VOX_MEM_FREE(((VCI_CODEC_BLOCK *)pCodecMemBlk)->pVciPlusMethodStruct);

   return VCI_NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\vcisc6.h ===
/******************************************************************************
*                        Voxware Proprietary Material
*                        Copyright 1996, Voxware, Inc
*                            All Rights Reserved
*
*                       DISTRIBUTION PROHIBITED without
*                      written authorization from Voxware
******************************************************************************/

/******************************************************************************
* Filename:        vciSC6.h
*
* Purpose:         Defines the interface functions for the Voxware SC Quality codec
*
* Functions:   vciGetInfoSC6, vciEncodeSC6, vciDecodeSC6, 
*              vciInitEncodeSC6, vciInitDecodeSC3, vciFreeEncodeSC6,
*              vciFreeDecodeSC6, vciGetExtCompatibilitySC6
*
* Author/Date:     Ilan Berci, Epiphany Vera 97/05/19
*******************************************************************************
*
* Modifications:
*
* Comments:
*
* Concerns:
*
* $Header:   /export/phobos/pvcs/r_and_d/archives/scaleable/vci/vciSC6.h_v   1.2   16 Mar 1998 17:26:42   weiwang  $
******************************************************************************/
#ifndef _VCISC6
#define _VCISC6

#ifdef __cplusplus
extern "C"
{
#endif

#ifndef _VCI_RETCODE_
#define _VCI_RETCODE_
typedef unsigned short VCI_RETCODE; /* Voxware Core Interface error type.     */
                                    /* This variable is also defined in vci.h */
#endif  /* _VCI_RETCODE_ */

/******************************************************************************
*
* Function:  vciGetInfoSC6() 
*
* Action:    Fill up information block for SC6
*
* Input:    pvciCodecInfoBlk -- pointer to the info. block
*
* Output:   pvciCodecInfoBlk -- filled up info. block
*
* Globals:   none
*
* Return:    VCI error code
*******************************************************************************/

VCI_RETCODE vciGetInfoSC6(VCI_CODEC_INFO_BLOCK *pvciCodecInfoBlk);

/******************************************************************************
*
* Function:  vciEncodeSC6()     
*
* Action:    Encodes one frame of speech using SC6
*
* Input:    pEncodeMemBlk -- encoder structure
*           pvciCodecIOBlk -- codec I/O structure
*
* Output:   pEncodeMemBlk -- updated strcture
*           pvciCodecIOBlk -- updated strcture
*
* Globals:   none
*
* Return:    VCI error code
*******************************************************************************/

VCI_RETCODE vciEncodeSC6(void *pEncodeMemBlk, 
                         VCI_CODEC_IO_BLOCK *pvciCodecIOBlk);


/******************************************************************************
*
* Function:  vciDecodeSC6()
*
* Action:    Decodes one frame of speech using SC6
*
* Input:    pDecodeMemBlk -- decoder structure
*           pvciCodecIOBlk -- codec I/O structure
*
* Output:   pDecodeMemBlk -- updated strcture
*           pvciCodecIOBlk -- updated strcture
*
* Globals:   none
*
* Return:    VCI error code
*******************************************************************************/

VCI_RETCODE vciDecodeSC6(void *pDecodeMemBlk, 
                         VCI_CODEC_IO_BLOCK *pvciCodecIOBlk);


/******************************************************************************
*
* Function:  vciInitEncodeSC6()
*
* Action:    To allocate memory for a Codec Memory Block and to initialize
*            it as an encoder.  
*
* Input:    hEncodeMemBlk -- the pointer to the encoder structure
*
* Output:   hEncodeMemBlk -- memory allocated and initialized encoder structure
*
* Globals:   none
*
* Return:    VCI error code
*******************************************************************************/

VCI_RETCODE vciInitEncodeSC6(void **hEncodeMemBlk);

                                     
/******************************************************************************
*
* Function:  vciInitDecodeSC6()
*
* Action:    To allocate memory for a Codec Memory Block and to initialize
*            it as a decoder.
*
* Input:    hDecodeMemBlk -- the pointer to the decoder structure
*
* Output:   hDecodeMemBlk -- allocated  and initilized structure
*
* Globals:   none
*
* Return:    VCI error code
*******************************************************************************/

VCI_RETCODE vciInitDecodeSC6(void **hDecodeMemBlk);

/******************************************************************************
*
* Function:  vciFreeEncodeSC6()
*
* Action:    Frees memory assigned to the encoder.
*
* Input:    hEncodeMemBlk -- the pointer to the encoder structure
*
* Output:   hEncodeMemBlk -- freed memory 
*
* Globals:   none
*
* Return:    VCI error code
*******************************************************************************/

VCI_RETCODE vciFreeEncodeSC6(void **hEncodeMemBlk);

/******************************************************************************
*
* Function:  vciFreeDecodeSC6()
*
* Action:    Frees memory assigned to the decoder.
*
* Input:    hDecodeMemBlk -- the pointer to the decoder structure
*
* Output:   hDecodeMemBlk -- freed memory 
*
* Globals:   none
*
* Return:    VCI error code
*******************************************************************************/

VCI_RETCODE vciFreeDecodeSC6(void **hDecodeMemBlk);

/******************************************************************************
*
* Function:  vciGetExtCompatibilitySC6()  
*
* Action:    Returns compatibility function 
*
* Input:    pCompatFunc -- the function pointer to the compatibility function
*
* Output:   pCompatFunc -- the compatibility function
*
* Globals:   none
*
* Return:    VCI return error
*******************************************************************************/
VCI_RETCODE vciGetExtCompatibilitySC6(void **pCompatFunc);

#ifdef __cplusplus
}
#endif


#endif /* _VCISC6 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\vcirt29.h ===
/******************************************************************************
 *                                                                            *
 *		                  Voxware Proprietary Material                        *
 *		                  Copyright 1996, Voxware, Inc.                       *
 *		                       All Rights Resrved                             *
 *                                                                            *
 *		                 DISTRIBUTION PROHIBITED without                      *
 *		               written authorization from Voxware                     *
 *                                                                            *
 ******************************************************************************/

/******************************************************************************
 *                                                                            *
 * FILENAME:  vciRT29.h                                                       *
 * PURPOSE:   Defines the interface functions and defines for vciRT29.c.      *
 *                                                                            *
 *****************************************************************************/

/******************************************************************************
 *                                                                            *
 *                          DETAILED REVISION HISTORY                         *
 *                                                                            *
 * (Sept 25, '96)                                                             *
 *    Created                                                                 *
 *                                                                            *
 *****************************************************************************/


#ifndef VCIRT29_H
#define VCIRT29_H
 
#ifdef __cplusplus
extern "C"
{
#endif
                                                         
VCI_RETCODE vciGetInfoRT29(VCI_CODEC_INFO_BLOCK *pvciCodecInfoBlk);

VCI_RETCODE vciDecodeRT29(void*hCodecMemBlk, 
                          VCI_CODEC_IO_BLOCK *hvciDecodeIOBlk);
VCI_RETCODE vciEncodeRT29(void *hCodecMemBlk, 
                          VCI_CODEC_IO_BLOCK *hvciEncodeIOBlk);

VCI_RETCODE vciInitEncodeRT29(void **hCodecMemBlk);
VCI_RETCODE vciInitDecodeRT29(void **hCodecMemBlk); 
                                                      
VCI_RETCODE vciFreeEncodeRT29(void **hCodecMemBlk);                                                       
VCI_RETCODE vciFreeDecodeRT29(void **hCodecMemBlk);  

VCI_RETCODE vciGetExtCompatibilityRT29(void **ppvExtCompat);

#ifdef __cplusplus
}
#endif /* __cplusplus */

#endif /* VCIRT29_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\vcisc6.c ===
/******************************************************************************
*                        Voxware Proprietary Material
*                        Copyright 1996, Voxware, Inc
*                            All Rights Reserved
*
*                       DISTRIBUTION PROHIBITED without
*                      written authorization from Voxware
******************************************************************************/

/******************************************************************************
* Filename:    vciSC6.c
*
* Purpose:     Defines the interface functions for the Voxware SC Quality codec
*
* Functions:   vciGetInfoSC6, vciEncodeSC6, vciDecodeSC6, 
*              vciInitEncodeSC6, vciInitDecodeSC3, vciFreeEncodeSC6,
*              vciFreeDecodeSC6, vciGetExtCompatibilitySC6
*
* Author/Date: Ilan Berci, Epiphany Vera 97/05/19
*******************************************************************************
*
* Modifications:
*
* Comments:
*
* Concerns:
*
* $Header:   P:/r_and_d/archives/scaleable/vci/vciSC6.c_v   1.31   12 Oct 1998 10:23:52   johnp  $
******************************************************************************/

/** *********************************************************************** **/
/**                             Standard headers                            **/
/** *********************************************************************** **/
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <assert.h>

/** *********************************************************************** **/
/**                              Vci Headers                                **/
/** *********************************************************************** **/
#include "vci.h"
#include "vciError.h"
#include "vciPriv.h"
#include "vciPlus.h"
#include "VoxMem.h"
#include "vem2.h"
#include "vem2Prm.h"
#include "vciPlsSC.h"

/** *********************************************************************** **/
/**                              Codec Headers                              **/
/** *********************************************************************** **/
#include "vLibPack.h"
#include "codec.h"

#include "DecSC.h"
#include "DecPlsSC.h"

#ifndef DECODE_ONLY
#include "EncSC.h"
#endif

#include "Coder.h"
#include "CodeStr.h"
#include "PackSC.h"
#include "vCodecID.h"
#include "quansc36.h"
#include "FadeSC.h"
#include "rate.h"
#include "paramSC.h"
#include "vciSC3.h"
#include "vciSC6.h"
#include "DecPriSC.h"

#include "xvocver.h"

/** ************************************************************************ **/
/**                     Voxware Core Interface PreDefines                    **/
/** ************************************************************************ **/

#define MAX_STACK_WORD_SC6_ENC       2000
#define MAX_STACK_WORD_SC6_DEC        900

#define VEM_COMPATIBILITY_VFONT       20
#define VEM_COMPATIBILITY_VAD_AGC     20
#define VEM_COMPATIBILITY_PLUS        20
#define VEM_COMPATIBILITY_DEFAULT     0

#define SC_CODEC_VERSION              "SC.01.08.00"


/** ************************************************************************ **/
/**                            Private Prototypes                            **/
/** ************************************************************************ **/

static unsigned  short SC6CompatibilityFunc(unsigned short VemPlugin, 
                                            unsigned long *pVemCodID) ;
static unsigned short initMethodStruct(VCI_METHOD_STRUCT **hVciMethodStruct);
static unsigned short freeMethodStruct(VCI_METHOD_STRUCT **hVciMethodStruct);

/******************************************************************************
*
* Function:  vciGetInfoSC6() 
*
* Action:    Fill up information block for SC6
*
* Input:    pvciCodecInfoBlk -- pointer to the info. block
*
* Output:   pvciCodecInfoBlk -- filled up info. block
*
* Globals:   none
*
* Return:    VCI error code
*******************************************************************************
*
* Implementation/Detailed Description:
*
* References:
*******************************************************************************
*
* Modifications:
*
* Comments:  
*
* Concerns/TBD:
******************************************************************************/

VCI_RETCODE vciGetInfoSC6(VCI_CODEC_INFO_BLOCK *pvciCodecInfoBlk)
{

   pvciCodecInfoBlk->wVCIVersion               = (unsigned short) VCI_VERSION;
   
   /* Variables for codec identification.     */
   strcpy(pvciCodecInfoBlk->sCodecVersion,       SC_CODEC_VERSION);
   pvciCodecInfoBlk->dwCodecClassID            = (unsigned long)VOXWARE_CODEC_SC_8K_6;      
   /* generic codec is SC3 */
   pvciCodecInfoBlk->dwCodecID                 = (unsigned long)VOXWARE_CODEC_ID_SC_8K_3_GENERIC;  
   
   /* PCM Data formats.                       */
   pvciCodecInfoBlk->wSamplingRate             = (unsigned short)RATE8K;   
   pvciCodecInfoBlk->wNumBitsPerSample         = 16; 
   pvciCodecInfoBlk->wNumSamplesPerFrame       = (unsigned short)FRAME_LENGTH_SC;

   pvciCodecInfoBlk->dwBitRate                 = (unsigned long)((TOTAL_BITS_SC3+
                                                    ADDITIONAL_BITS_SC6)*
                                                    (float)RATE8K/(float)FRAME_LENGTH_SC);

   /* Prime Flush Information */
   /* encoder delay + decoder delay == ENC_DELAY_SIZE (145 == 80 + 65) */
   pvciCodecInfoBlk->wNumPrimeFlushFrames      = (unsigned short)ceil((float)ENC_DELAY_SIZE
                                                  /(float)FRAME_LENGTH_SC);
   pvciCodecInfoBlk->wNumPrimeFlushSamples     = 
              (unsigned short)(pvciCodecInfoBlk->wNumPrimeFlushFrames*FRAME_LENGTH_SC
                              -ENC_DELAY_SIZE);
   
   /* Bitstream information (for fix rate codec). */
   pvciCodecInfoBlk->dwMinPacketBits           = (unsigned short) (TOTAL_BITS_SC3+
                                                    ADDITIONAL_BITS_SC6);
   pvciCodecInfoBlk->dwAvgPacketBits           = pvciCodecInfoBlk->dwMinPacketBits;
   pvciCodecInfoBlk->dwMaxPacketBits           = pvciCodecInfoBlk->dwMinPacketBits;
   
   /* Multi-channel support.                  */
   pvciCodecInfoBlk->wNumChannels              = 1;
   pvciCodecInfoBlk->wInterleaveBlockSize      = 1;

   return(VCI_NO_ERROR);
}
/*===========================================================================*/


#ifndef DECODE_ONLY
/******************************************************************************
*
* Function:  vciEncodeSC6()     
*
* Action:    Encodes one frame of speech using SC6
*
* Input:    pEncodeMemBlk -- encoder structure
*           pvciCodecIOBlk -- codec I/O structure
*
* Output:   pEncodeMemBlk -- updated strcture
*           pvciCodecIOBlk -- updated strcture
*
* Globals:   none
*
* Return:    VCI error code
*******************************************************************************
*
* Implementation/Detailed Description:
*
* References:
*******************************************************************************
*
* Modifications:
*
* Comments:  
*
* Concerns/TBD:
******************************************************************************/

VCI_RETCODE vciEncodeSC6( void               *pEncodeMemBlk, 
                          VCI_CODEC_IO_BLOCK *pvciCodecIOBlk
                        )
{
   VCI_CODEC_BLOCK *vciCodecMblk = NULL;
   PARAM_SC ParamMblk; /* scratch memory */
   STACK_DECLARE
   
   /* check the validity of the VCI IO blk */
   VCI_IO_BLK_PARAM_CHECK(pvciCodecIOBlk);

   if(!VCI_BLOCK_CHECK(pEncodeMemBlk))
      return VCI_NOT_VCI_HANDLE;

   if(!VCI_IS_ENCODE(pEncodeMemBlk))     
      return VCI_NOT_ENC_HANDLE;

   vciCodecMblk = (VCI_CODEC_BLOCK *)pEncodeMemBlk;
   STACK_ASSIGN(vciCodecMblk->pScratchBlk)
   vciCodecMblk->pVciCodecIOBlock=pvciCodecIOBlk;

   /* check to make sure that codec was initialized at 6 or higher */
   if(!(voxGetEncodeInitRate(vciCodecMblk->hCodecMblk)&SC_RATE_6K))
      return VCI_CODEC_NOT_SUPPORTED; 

   /*--------------------------------------------------------------------
     Encode speech at SC_RATE_6K
   --------------------------------------------------------------------*/
   VoxEncodeSC(STACK_S pvciCodecIOBlk->pPCMBuffer, vciCodecMblk->hCodecMblk,
               (void *)&ParamMblk);

   {
     int QuanSC3Index[TOTAL_SC3_QUAN_INDICES];
     int QuanSC6Index[EXTRA_SC6_QUAN_INDICES];

     /*--------------------------------------------------------------------
      Quantize 3k parameters and then quantize 6k parameters
     --------------------------------------------------------------------*/
     VoxQuantSC3(STACK_S QuanSC3Index, vciCodecMblk->hCodecMblk,
                 (void *)&ParamMblk);

     if(voxGetEncodeRate(vciCodecMblk->hCodecMblk)!=SC_RATE_3K)
        VoxQuantSC6(QuanSC6Index, (void *)&ParamMblk);

     /*--------------------------------------------------------------------
       Pack 3k parameters and then pack 6k parameters
     --------------------------------------------------------------------*/
     if(voxGetEncodeRate(vciCodecMblk->hCodecMblk)==SC_RATE_3K) {
        VoxPackSC3(QuanSC3Index,
                   pvciCodecIOBlk->pVoxBuffer,
                   &(pvciCodecIOBlk->wVoxBufferWriteByteOffset),
                   &(pvciCodecIOBlk->chVoxBufferWriteBitOffset),
                   pvciCodecIOBlk->wVoxBufferSize,
                   (unsigned short) END_OF_FRAME);

     } else {
        VoxPackSC3(QuanSC3Index,
                   pvciCodecIOBlk->pVoxBuffer,
                   &(pvciCodecIOBlk->wVoxBufferWriteByteOffset),
                   &(pvciCodecIOBlk->chVoxBufferWriteBitOffset),
                   pvciCodecIOBlk->wVoxBufferSize,
                   (unsigned short) LONGER_FRAME);

        VoxPackSC6(QuanSC6Index,
                   pvciCodecIOBlk->pVoxBuffer,
                   &(pvciCodecIOBlk->wVoxBufferWriteByteOffset),
                   &(pvciCodecIOBlk->chVoxBufferWriteBitOffset),
                   pvciCodecIOBlk->wVoxBufferSize,
                   (unsigned short) END_OF_FRAME);
     }
   }

   return(VCI_NO_ERROR);
}
/*===========================================================================*/
#endif


/******************************************************************************
*
* Function:  vciDecodeSC6()
*
* Action:    Decodes one frame of speech using SC6
*
* Input:    pDecodeMemBlk -- decoder structure
*           pvciCodecIOBlk -- codec I/O structure
*
* Output:   pDecodeMemBlk -- updated strcture
*           pvciCodecIOBlk -- updated strcture
*
* Globals:   none
*
* Return:    VCI error code
*******************************************************************************
*
* Implementation/Detailed Description:
*
* References:
*******************************************************************************
*
* Modifications:
*
* Comments:  
*
* Concerns/TBD:
******************************************************************************/

VCI_RETCODE vciDecodeSC6( void               *pDecodeMemBlk, 
                          VCI_CODEC_IO_BLOCK *pvciCodecIOBlk
                        )
{
   VCI_CODEC_BLOCK *vciCodecMblk = NULL;
   DEC_MEM_BLK     *pDecMemBlk;
   PARAM_SC        ParamMblk;
   STACK_DECLARE
   unsigned short  sLongerFrameFlag;
   VCI_RETCODE VoxErrRet = VCI_NO_ERROR;
   unsigned short sByteOffset=0;
   unsigned char  cBitOffset=0;
   unsigned char cDecReqDataFlagSC;

   /*----------------------------------------------------
     sanity check and decode check
   ----------------------------------------------------*/
   if(!VCI_BLOCK_CHECK(pDecodeMemBlk))
      return VCI_NOT_VCI_HANDLE;

   if(!VCI_IS_DECODE(pDecodeMemBlk))     
      return VCI_NOT_DEC_HANDLE;
    
   /*----------------------------------------------------
     set some pointers and assign the VoxStack
   ----------------------------------------------------*/
   vciCodecMblk = (VCI_CODEC_BLOCK *)pDecodeMemBlk;
   STACK_ASSIGN(vciCodecMblk->pScratchBlk);

   pDecMemBlk= (DEC_MEM_BLK *)vciCodecMblk->hCodecMblk;

   vciCodecMblk->pVciCodecIOBlock=pvciCodecIOBlk;

   /*----------------------------------------------------
     check the validity of the VCI IO Block.
   ----------------------------------------------------*/
   if (SILENCE != GetCurrentFrameStateSC(pDecMemBlk->pFadeIOMemBlk))
   {
	   VCI_IO_BLK_PARAM_CHECK(pvciCodecIOBlk);

		/*----------------------------------------------------
			 If the decoder needs a new frame to decode then
			   get the new frame from pvciCodecIOBlk->pVoxBuffer
			   and put it in vciCodecMblk->pbSaveVoxBuffer.
		   ----------------------------------------------------*/
		   if (voxGetDecReqDataFlagSC((void *)pDecMemBlk))
		   {
			/*------------------------------------------------------------
			  Check whether there are sufficient Vox data. If there is not,
				return an error.  In the code below we will assume there
				is enough data.
			  ------------------------------------------------------------*/
			  VoxErrRet = vciSeekForwardSC(pDecodeMemBlk, pvciCodecIOBlk,
										   1, &sByteOffset, &cBitOffset);

			  if (VoxErrRet != VCI_NO_ERROR)
				 return VoxErrRet;
		   }

		   /*------------------------------------------------------------
			 Unpack and unquantize the frame.  QuanMemBlk is declared
			   only in this local region to save memory.
		   ------------------------------------------------------------*/
		   {
			 int QuanSC3Index[TOTAL_SC3_QUAN_INDICES];
			 int QuanSC6Index[EXTRA_SC6_QUAN_INDICES];
			 sByteOffset = 0;
			 cBitOffset = 0;

			 /*---------------------------------------------------------
			   Copy the SC3 bits from the circular buffer to the 
				 linear buffer.
			 ---------------------------------------------------------*/
			 if (voxGetDecR