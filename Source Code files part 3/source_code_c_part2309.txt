maining = 0;
    }

    //
    // If we're to skip over bytes from a descriptor that crosses a sector
    // boundary, then do that adjustment here.
    //

    LocalCurrentBuffer -= DirectoryMapping->CacheBytesRemaining;
    LocalCacheBytesRemaining += DirectoryMapping->CacheBytesRemaining;

    //
    // Return the results back to the caller.
    //

    DirectoryMapping->CurrentBuffer = LocalCurrentBuffer;
    DirectoryMapping->CacheBytesRemaining = LocalCacheBytesRemaining;

    return STATUS_SUCCESS;
}

VOID
UdfxCopyPartialDirectoryBuffer(
    IN OUT PUDF_DIRECTORY_MAPPING DirectoryMapping,
    OUT PVOID Destination,
    IN PVOID Source,
    IN SIZE_T Length
    )
/*++

Routine Description:

    This routine is a wrapper for RtlCopyMemory that asserts that the arguments
    are valid cache pointers in a debug build and reduces the code bloat in a
    retail build caused by RtlCopyMemory inlining.

Arguments:

    DirectoryMapping - Specifies a structure that describes the current sector
        mapping and how to map the next sector.

    Destination - Specifies the destination of the move.

    Source - Specifies the memory to be copied.

    Length - Specifies the number of bytes to be copied.

Return Value:

    Status of operation.

--*/
{
    ASSERT((PUCHAR)Source >= (PUCHAR)DirectoryMapping->CacheBuffer);
    ASSERT((PUCHAR)Source < (PUCHAR)DirectoryMapping->CacheBuffer +
        UDF_CD_SECTOR_SIZE);
    ASSERT((PUCHAR)Source + Length <= (PUCHAR)DirectoryMapping->CacheBuffer +
        UDF_CD_SECTOR_SIZE);
    ASSERT(Length <= UDF_CD_SECTOR_SIZE);

    RtlCopyMemory(Destination, Source, Length);
}

NTSTATUS
UdfxLookupElementNameInDirectory(
    IN PUDF_VOLUME_EXTENSION VolumeExtension,
    IN PIRP Irp,
    IN PUDF_FCB DirectoryFcb,
    IN POBJECT_STRING ElementName,
    OUT PLONGAD ElementIcb
    )
/*++

Routine Description:

    This routine looks up the supplied file name in the supplied directory
    file control block.

Arguments:

    VolumeExtension - Specifies the extension that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

    DirectoryFcb - Specifies the file control block that describes where to
        read the directory stream from.

    ElementName - Specifies the name to search for in the directory.

    ElementIcb - Specifies the buffer to receive the extent of the found file.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    ULONG ExpectedFileID8BitLength;
    UDF_DIRECTORY_MAPPING DirectoryMapping;
    union {
        NSR_FID FileIdentifierDescriptor;
        UCHAR FileID[256];
    } Stack;
    ULONG PartialStackBufferBytes;
    PNSR_FID FileIdentifierDescriptor;
    ULONG FileIdentifierDescriptorLength;
    ULONG FileIDLength;
    ULONG FileIDStartingOffset;
    PUCHAR FileID;

    ASSERT(UdfxIsFlagSet(DirectoryFcb->Flags, UDF_FCB_DIRECTORY));

    //
    // Compute the expected lengths for a file identifier that will match the
    // supplied file name that we're searching for.  We only care about 8-bit
    // encodings.
    //

    ExpectedFileID8BitLength = sizeof(UCHAR) + ElementName->Length / sizeof(OCHAR);

    //
    // Initialize the directory mapping structure.
    //

    DirectoryMapping.VolumeExtension = VolumeExtension;
    DirectoryMapping.Irp = Irp;
    DirectoryMapping.DirectoryFcb = DirectoryFcb;
    DirectoryMapping.LogicalSectorNumber = DirectoryFcb->AllocationSectorStart;
    DirectoryMapping.FileBytesRemaining = DirectoryFcb->FileSize.LowPart;
    DirectoryMapping.CacheBytesRemaining = 0;
    DirectoryMapping.CacheBuffer = NULL;
    DirectoryMapping.CurrentBuffer = NULL;

    //
    // Process the directory stream.
    //

    for (;;) {

        //
        // If we're out of bytes in the current cache buffer, then map in the
        // next sector.
        //

        if ((LONG)DirectoryMapping.CacheBytesRemaining <= 0) {

            status = UdfxMapNextDirectorySector(&DirectoryMapping);

            if (!NT_SUCCESS(status)) {
                break;
            }
        }

        //
        // If the current cache buffer doesn't have enough bytes to contain a
        // full descriptor, then we'll have to buffer the descriptor on the
        // stack and carefully cross sector boundaries.
        //

        if (DirectoryMapping.CacheBytesRemaining < ISONsrFidConstantSize) {

            //
            // If the bytes from this cache buffer and what remains in the file
            // won't be enough to contain a full descriptor, then bail out now.
            //

            if (DirectoryMapping.CacheBytesRemaining +
                DirectoryMapping.FileBytesRemaining < ISONsrFidConstantSize) {
                status = STATUS_OBJECT_NAME_NOT_FOUND;
                break;
            }

            //
            // Copy the first part of the descriptor to the stack.
            //

            PartialStackBufferBytes = DirectoryMapping.CacheBytesRemaining;

            UdfxCopyPartialDirectoryBuffer(&DirectoryMapping,
                &Stack.FileIdentifierDescriptor, DirectoryMapping.CurrentBuffer,
                PartialStackBufferBytes);

            //
            // Map in the next sector.  Note that on return, the CurrentBuffer
            // CurrentBuffer and CacheBytesRemaining fields have been adjusted
            // adjusted to point back in memory as if the previous sector was
            // virtually mapped in order to make the below math easier.
            //

            status = UdfxMapNextDirectorySector(&DirectoryMapping);

            if (!NT_SUCCESS(status)) {
                break;
            }

            //
            // Copy the last part of the descriptor to the stack.
            //

            UdfxCopyPartialDirectoryBuffer(&DirectoryMapping,
                (PUCHAR)&Stack.FileIdentifierDescriptor + PartialStackBufferBytes,
                DirectoryMapping.CurrentBuffer + PartialStackBufferBytes,
                ISONsrFidConstantSize - PartialStackBufferBytes);

            FileIdentifierDescriptor = &Stack.FileIdentifierDescriptor;

        } else {

            //
            // There's enough bytes in the current buffer to contain at least
            // the header, so point directly into the cache buffer.
            //

            FileIdentifierDescriptor = (PNSR_FID)DirectoryMapping.CurrentBuffer;
        }

        //
        // Validate that the descriptor header looks valid and that its size
        // doesn't exceed a sector as specified by UDF or the number of
        // remaining bytes in the directory stream.  We can't use
        // UdfxVerifyDescriptor here because we don't have a contiguous
        // descriptor in memory.
        //

        FileIdentifierDescriptorLength = ISONsrFidSize(FileIdentifierDescriptor);

        if ((FileIdentifierDescriptor->Destag.Version != DESTAG_VER_CURRENT) ||
            (FileIdentifierDescriptor->Destag.Ident != DESTAG_ID_NSR_FID) ||
            (FileIdentifierDescriptorLength > UDF_CD_SECTOR_SIZE) ||
            (FileIdentifierDescriptorLength > DirectoryMapping.FileBytesRemaining +
                (ULONG)DirectoryMapping.CacheBytesRemaining)) {
            UdfxDbgPrint(("UDFX: file identifier descriptor doesn't verify\n"));
            status = STATUS_DISK_CORRUPT_ERROR;
            break;
        }

        FileIDLength = FileIdentifierDescriptor->FileIDLen;

        //
        // Only bother checking the file identifier descriptor if the file
        // identifier length matches the length of the element name we're
        // looking for.
        //

        if (FileIDLength == ExpectedFileID8BitLength) {

            //
            // Fill in the output buffer now since we'll shortly lose access to
            // the file identifier descriptor.
            //

            *ElementIcb = FileIdentifierDescriptor->Icb;

            //
            // Compute the byte offset of the file identifier.
            //

            FileIDStartingOffset = ISONsrFidConstantSize +
                FileIdentifierDescriptor->ImpUseLen;

            //
            // The below code can cause the current sector buffer to become
            // invalid, so we can no longer safely touch the
            // FileIdentifierDescriptor.
            //

            FileIdentifierDescriptor = NULL;

            //
            // If the current cache buffer doesn't have enough bytes to contain
            // the string, then we'll have to buffer the string on the stack and
            // carefully cross sector boundaries.
            //

            if (DirectoryMapping.CacheBytesRemaining < FileIDStartingOffset +
                FileIDLength) {

                //
                // Check if any of the string is inside the current cache
                // buffer.
                //

                if (DirectoryMapping.CacheBytesRemaining > FileIDStartingOffset) {

                    //
                    // Copy the first part of the string to the stack.
                    //

                    PartialStackBufferBytes =
                        DirectoryMapping.CacheBytesRemaining - FileIDStartingOffset;

                    UdfxCopyPartialDirectoryBuffer(&DirectoryMapping,
                        &Stack.FileID, DirectoryMapping.CurrentBuffer +
                        FileIDStartingOffset, PartialStackBufferBytes);

                } else {

                    PartialStackBufferBytes = 0;
                }

                //
                // Map in the next sector.  Note that on return, the
                // CurrentBuffer and CacheBytesRemaining fields have been
                // adjusted to point back in memory as if the previous sector
                // was virtually mapped in order to make the below math easier.
                //

                status = UdfxMapNextDirectorySector(&DirectoryMapping);

                if (!NT_SUCCESS(status)) {
                    break;
                }

                //
                // Copy the last part of the string to the stack.
                //

                UdfxCopyPartialDirectoryBuffer(&DirectoryMapping,
                    Stack.FileID + PartialStackBufferBytes,
                    DirectoryMapping.CurrentBuffer + FileIDStartingOffset +
                    PartialStackBufferBytes, FileIDLength -
                    PartialStackBufferBytes);

                FileID = Stack.FileID;

            } else {

                //
                // There's enough bytes in the current buffer to contain all of
                // the string, so point directly into the cache.
                //

                FileID = DirectoryMapping.CurrentBuffer + FileIDStartingOffset;
            }

            if (UdfxEqualOSTACS0StringAndObjectString(FileID, FileIDLength,
                ElementName)) {
                status = STATUS_SUCCESS;
                break;
            }
        }

        //
        // Advance to the next descriptor.
        //

        DirectoryMapping.CacheBytesRemaining -= FileIdentifierDescriptorLength;
        DirectoryMapping.CurrentBuffer += FileIdentifierDescriptorLength;
    }

    if (DirectoryMapping.CacheBuffer != NULL) {
        FscUnmapBuffer(DirectoryMapping.CacheBuffer);
    }

    return status;
}

NTSTATUS
UdfxFsdCreate(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is called by the I/O manager to handle IRP_MJ_CREATE requests.

Arguments:

    DeviceObject - Specifies the device object that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    PUDF_VOLUME_EXTENSION VolumeExtension;
    PIO_STACK_LOCATION IrpSp;
    ACCESS_MASK DesiredAccess;
    ULONG CreateOptions;
    PFILE_OBJECT FileObject;
    OBJECT_STRING RemainingName;
    PFILE_OBJECT RelatedFileObject;
    ULONG CreateDisposition;
    PUDF_FCB CurrentFcb;
    SHARE_ACCESS ShareAccess;
    BOOLEAN TrailingBackslash;
    BOOLEAN CreateFcbCalled;
    OBJECT_STRING ElementName;
    PUDF_FCB FoundOrNewFcb;
    LONGAD ElementIcb;

    VolumeExtension = (PUDF_VOLUME_EXTENSION)DeviceObject->DeviceExtension;
    IrpSp = IoGetCurrentIrpStackLocation(Irp);
    DesiredAccess = IrpSp->Parameters.Create.DesiredAccess;
    CreateOptions = IrpSp->Parameters.Create.Options;
    FileObject = IrpSp->FileObject;
    RemainingName = *IrpSp->Parameters.Create.RemainingName;
    RelatedFileObject = FileObject->RelatedFileObject;

    //
    // Synchronize access to the file control block lists by acquiring the
    // global mutex.
    //

    UdfxAcquireGlobalMutexExclusive();

    //
    // Check if the volume has been dismounted.
    //

    if (VolumeExtension->Dismounted) {
        status = STATUS_VOLUME_DISMOUNTED;
        goto CleanupAndExit;
    }

    //
    // Don't allow the target directory to be opened.  This is only used by the
    // I/O manager when it wants to rename a file across a directory on the same
    // volume.
    //

    if (UdfxIsFlagSet(IrpSp->Flags, SL_OPEN_TARGET_DIRECTORY)) {
        status = STATUS_ACCESS_DENIED;
        goto CleanupAndExit;
    }

    //
    // Check the desired access mask to make sure that no write rights are being
    // requested.
    //

    if (UdfxIsFlagSet(DesiredAccess, FILE_WRITE_ATTRIBUTES | FILE_WRITE_DATA |
        FILE_WRITE_EA | FILE_ADD_FILE | FILE_ADD_SUBDIRECTORY |
        FILE_APPEND_DATA | FILE_DELETE_CHILD | DELETE | WRITE_DAC)) {
        status = STATUS_ACCESS_DENIED;
        goto CleanupAndExit;
    }

    //
    // Don't allow a file to be opened based on its file ID.
    //

    if (UdfxIsFlagSet(CreateOptions, FILE_OPEN_BY_FILE_ID)) {
        status = STATUS_NOT_IMPLEMENTED;
        goto CleanupAndExit;
    }

    //
    // Verify that the create disposition is for open access only.
    //

    CreateDisposition = (CreateOptions >> 24) & 0xFF;

    if ((CreateDisposition != FILE_OPEN) && (CreateDisposition != FILE_OPEN_IF)) {
        status = STATUS_ACCESS_DENIED;
        goto CleanupAndExit;
    }

    //
    // Determine whether we parse the file name from the root of the volume or
    // from a subdirectory by looking at RelatedFileObject.
    //

    if (RelatedFileObject != NULL) {

        //
        // Grab the file control block out of the related file object.
        //

        CurrentFcb = (PUDF_FCB)RelatedFileObject->FsContext;

        //
        // Verify that the related file object is really a directory object.
        // Note that the file control block could be NULL if the file object was
        // opened as a result of a direct device open in the I/O manager.
        //

        if ((CurrentFcb == NULL) ||
            UdfxIsFlagClear(CurrentFcb->Flags, UDF_FCB_DIRECTORY)) {
            status = STATUS_INVALID_PARAMETER;
            goto CleanupAndExit;
        }

        //
        // Check if we're supposed to open the related directory.
        //

        if (RemainingName.Length == 0) {
            CurrentFcb->ReferenceCount++;
            status = STATUS_SUCCESS;
            goto OpenStartDirectoryFcb;
        }

        //
        // Verify that this is not an absolute path.
        //

        if (RemainingName.Buffer[0] == OBJ_NAME_PATH_SEPARATOR) {
            status = STATUS_OBJECT_NAME_INVALID;
            goto CleanupAndExit;
        }

    } else {

        //
        // Check if we're supposed to open the physical volume.
        //

        if (RemainingName.Length == 0) {

            CurrentFcb = VolumeExtension->VolumeFcb;

            //
            // The caller shouldn't be expecting to see a directory file.
            //

            if (UdfxIsFlagSet(CreateOptions, FILE_DIRECTORY_FILE)) {
                status = STATUS_NOT_A_DIRECTORY;
                goto CleanupAndExit;
            }

            //
            // Physical volume access is always non-cached.  Mark the file
            // object as non-cached so that the I/O manager enforces alignment
            // requirements.
            //

            FileObject->Flags |= FO_NO_INTERMEDIATE_BUFFERING;

            CurrentFcb->ReferenceCount++;
            goto InitializeFileObject;
        }

        //
        // Start searching relative to the root directory.
        //

        CurrentFcb = VolumeExtension->RootDirectoryFcb;

        //
        // Verify that this is an absolute path.
        //

        if (RemainingName.Buffer[0] != OBJ_NAME_PATH_SEPARATOR) {
            status = STATUS_OBJECT_NAME_INVALID;
            goto CleanupAndExit;
        }

        //
        // Check if we're supposed to open the root directory.
        //

        if (RemainingName.Length == sizeof(OCHAR)) {
            CurrentFcb->ReferenceCount++;
            status = STATUS_SUCCESS;
            goto OpenStartDirectoryFcb;
        }
    }

    //
    // Check if the file name ends in a backslash.  If so, strip it off and set
    // a flag so that we can later verify that the target file is a directory.
    //
    // We've already checked for an empty file name or a file name that consists
    // of a single backslash above, so we know that before and after this check
    // that the remaining name will still have some characters in it.
    //

    ASSERT(RemainingName.Length > 0);

    if (RemainingName.Buffer[(RemainingName.Length / sizeof(OCHAR)) - 1] ==
        OBJ_NAME_PATH_SEPARATOR) {
        RemainingName.Length -= sizeof(OCHAR);
        TrailingBackslash = TRUE;
    } else {
        TrailingBackslash = FALSE;
    }

    ASSERT(RemainingName.Length > 0);

    //
    // Process the file name.  At this point, we're only walking the open file
    // control block list.
    //

    for (;;) {

        //
        // Pull off the next element of the file name.
        //

        ObDissectName(RemainingName, &ElementName, &RemainingName);

        //
        // Verify that there aren't multiple backslashes in the name.
        //

        if ((RemainingName.Length != 0) && (RemainingName.Buffer[0] ==
            OBJ_NAME_PATH_SEPARATOR)) {
            status = STATUS_OBJECT_NAME_INVALID;
            break;
        }

        //
        // Check if a file control block already exists for this file name.
        //

        if (!UdfxFindOpenChildFcb(CurrentFcb, &ElementName, &FoundOrNewFcb)) {
            break;
        }

        CurrentFcb = FoundOrNewFcb;

        //
        // If we have consumed the entire name, then the file is already open.
        // Bump up the reference count and skip past the on-disk search loop.
        //

        if (RemainingName.Length == 0) {
            CurrentFcb->ReferenceCount++;
            status = STATUS_SUCCESS;
            goto OpenCurrentFcb;
        }
    }

    //
    // Continue processing the file name.  At this point, we're searching
    // directory streams for the requested file.
    //

    CreateFcbCalled = FALSE;

    do {

        //
        // On the first iteration of the loop, we've already dissected the name
        // we're looking for so don't dissect another piece of the name.
        //

        if (CreateFcbCalled) {

            //
            // Pull off the next element of the file name.
            //

            ObDissectName(RemainingName, &ElementName, &RemainingName);

            //
            // Verify that there aren't multiple backslashes in the name.
            //

            if ((RemainingName.Length != 0) && (RemainingName.Buffer[0] ==
                OBJ_NAME_PATH_SEPARATOR)) {
                status = STATUS_OBJECT_NAME_INVALID;
                break;
            }
        }

        //
        // Lookup the element in the directory.
        //

        status = UdfxLookupElementNameInDirectory(VolumeExtension, Irp,
            CurrentFcb, &ElementName, &ElementIcb);

        if (!NT_SUCCESS(status)) {

            //
            // If we failed to find the element and there's more of a path name
            // to process, then convert the error from "file not found" to
            // "path not found".
            //

            if ((status == STATUS_OBJECT_NAME_NOT_FOUND) &&
                (RemainingName.Length != 0)) {
                status = STATUS_OBJECT_PATH_NOT_FOUND;
            }

            break;
        }

        //
        // Create a file control block for the file we found.
        //

        status = UdfxCreateFcbFromFileEntry(VolumeExtension, Irp, &ElementIcb,
            CurrentFcb, &ElementName, &FoundOrNewFcb);

        if (!NT_SUCCESS(status)) {
            break;
        }

        //
        // If this is the second or greater iteration of this loop, then we want
        // to release the reference to the parent directory from FatxCreateFcb.
        // The parent directory already has a reference count of one from when
        // we created that file control block.
        //

        if (CreateFcbCalled) {
            ASSERT(CurrentFcb->ReferenceCount >= 2);
            CurrentFcb->ReferenceCount--;
        }

        CreateFcbCalled = TRUE;
        CurrentFcb = FoundOrNewFcb;

        //
        // If there's still more of a path name to process, then the file that
        // we found had better be a directory.
        //

        if ((RemainingName.Length != 0) &&
            UdfxIsFlagClear(CurrentFcb->Flags, UDF_FCB_DIRECTORY)) {
            status = STATUS_OBJECT_PATH_NOT_FOUND;
            break;
        }

    } while (RemainingName.Length != 0);

    //
    // If we failed to open the file, then before bailing out, we may need to
    // dereference the current file control block.  If we haven't created any
    // file control blocks, then there's no file control blocks to clean up.
    //

    if (!NT_SUCCESS(status)) {

        if (CreateFcbCalled) {
            UdfxDereferenceFcb(CurrentFcb);
        }

        goto CleanupAndExit;
    }

    //
    // If the caller is expecting to open only a file or directory file, then
    // verify that the file type matches.
    //

OpenCurrentFcb:
    if (UdfxIsFlagSet(CurrentFcb->Flags, UDF_FCB_DIRECTORY)) {

OpenStartDirectoryFcb:
        if (UdfxIsFlagSet(CreateOptions, FILE_NON_DIRECTORY_FILE)) {
            status = STATUS_FILE_IS_A_DIRECTORY;
        }

    } else {

        if (TrailingBackslash ||
            UdfxIsFlagSet(CreateOptions, FILE_DIRECTORY_FILE)) {
            status = STATUS_NOT_A_DIRECTORY;
        }
    }

    //
    // If the resulting file looks acceptable, then fill out the file object
    // and return success.
    //

    if (NT_SUCCESS(status)) {

InitializeFileObject:
        //
        // We don't care about sharing modes for this file system.
        //

        IoSetShareAccess(DesiredAccess, 0, FileObject, &ShareAccess);

        //
        // Fill in the file object with the file control block that we
        // created.
        //

        FileObject->FsContext = CurrentFcb;
        FileObject->FsContext2 = NULL;

        VolumeExtension->FileObjectCount++;

        //
        // Indicate to the caller that we opened the file as opposed to
        // creating or overwriting the file.
        //

        Irp->IoStatus.Information = FILE_OPENED;

        status = STATUS_SUCCESS;
        goto CleanupAndExit;
    }

    //
    // If we reach this point, then we're going to be failing the call so
    // cleanup any file control block we're still holding on to.
    //

    UdfxDereferenceFcb(CurrentFcb);

CleanupAndExit:
    UdfxReleaseGlobalMutex();

    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\udfx\driver.c ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    driver.c

Abstract:

    This module implements routines that apply to the driver object including
    initialization and IRP dispatch routines.

--*/

#include "udfx.h"

//
// Driver object for the UDF file system.
//
DECLSPEC_RDATA DRIVER_OBJECT UdfxDriverObject = {
    NULL,                               // DriverStartIo
    NULL,                               // DriverDeleteDevice
    UdfxDismountVolume,                 // DriverDismountVolume
    {
        UdfxFsdCreate,                  // IRP_MJ_CREATE
        UdfxFsdClose,                   // IRP_MJ_CLOSE
        UdfxFsdRead,                    // IRP_MJ_READ
        IoInvalidDeviceRequest,         // IRP_MJ_WRITE
        UdfxFsdQueryInformation,        // IRP_MJ_QUERY_INFORMATION
        UdfxFsdSetInformation,          // IRP_MJ_SET_INFORMATION
        IoInvalidDeviceRequest,         // IRP_MJ_FLUSH_BUFFERS
        UdfxFsdQueryVolumeInformation,  // IRP_MJ_QUERY_VOLUME_INFORMATION
        UdfxFsdDirectoryControl,        // IRP_MJ_DIRECTORY_CONTROL
        UdfxFsdFileSystemControl,       // IRP_MJ_FILE_SYSTEM_CONTROL
        UdfxFsdDeviceControl,           // IRP_MJ_DEVICE_CONTROL
        IoInvalidDeviceRequest,         // IRP_MJ_INTERNAL_DEVICE_CONTROL
        IoInvalidDeviceRequest,         // IRP_MJ_SHUTDOWN
        IoInvalidDeviceRequest,         // IRP_MJ_CLEANUP
    }
};

//
// All file system access is guarded by this single global lock.
//
INITIALIZED_CRITICAL_SECTION(UdfxGlobalMutex);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\udfx\dirctrl.c ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    dirctrl.c

Abstract:

    This module implements routines related to handling
    IRP_MJ_DIRECTORY_CONTROL.

--*/

#include "udfx.h"

NTSTATUS
UdfxReadNextFileIdentifierDescriptor(
    IN PUDF_VOLUME_EXTENSION VolumeExtension,
    IN PIRP Irp,
    IN PUDF_FCB DirectoryFcb,
    IN PDIRECTORY_ENUM_CONTEXT DirectoryEnumContext,
    OUT PNSR_FID *ReturnedFileIdentifierDescriptor
    )
/*++

Routine Description:

    This routine returns the file identifier descriptor located at the
    Directory.QueryOffset of the supplied file control block.

Arguments:

    VolumeExtension - Specifies the extension that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

    DirectoryFcb - Specifies the file control block that describes where to
        read the directory stream from.

    DirectoryEnumContext - Specifies the directory enumeration context.

    ReturnedFileIdentifierDescriptor - Specifies the buffer to receive the pool
        allocated file identifier descriptor.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    PVOID CacheBuffer;
    PNSR_FID PoolFileIdentifierDescriptor;
    ULONG FileBytesRemaining;
    ULONG LogicalSectorNumber;
    ULONG CacheBufferOffset;
    ULONG CacheBytesRemaining;
    NSR_FID StackFileIdentifierDescriptor;
    PNSR_FID FileIdentifierDescriptor;
    ULONG FileIdentifierDescriptorLength;

    ASSERT(UdfxIsFlagSet(DirectoryFcb->Flags, UDF_FCB_DIRECTORY));

    *ReturnedFileIdentifierDescriptor = NULL;

    CacheBuffer = NULL;
    PoolFileIdentifierDescriptor = NULL;

    //
    // If there aren't enough bytes left in the directory stream to contain a
    // full descriptor, then stop enumerating files.
    //

    FileBytesRemaining = DirectoryFcb->FileSize.LowPart -
        DirectoryEnumContext->QueryOffset;

    if (FileBytesRemaining < ISONsrFidConstantSize) {
        status = STATUS_END_OF_FILE;
        goto CleanupAndExit;
    }

    //
    // Compute the logical sector number of the current query offset.
    //

    LogicalSectorNumber = DirectoryFcb->AllocationSectorStart +
        (DirectoryEnumContext->QueryOffset >> UDF_CD_SECTOR_SHIFT);

    //
    // Map the directory sector into the cache.
    //

    status = UdfxMapLogicalSector(VolumeExtension, Irp, LogicalSectorNumber,
        &CacheBuffer);

    if (!NT_SUCCESS(status)) {
        goto CleanupAndExit;
    }

    //
    // Compute the current offset into the cache and the number of bytes
    // remaining in this mapping.
    //

    CacheBufferOffset = (DirectoryEnumContext->QueryOffset & UDF_CD_SECTOR_MASK);

    if (UdfxIsFlagSet(DirectoryFcb->Flags, UDF_FCB_EMBEDDED_DATA)) {
        CacheBufferOffset += DirectoryFcb->EmbeddedDataOffset;
    }

    CacheBytesRemaining = UDF_CD_SECTOR_SIZE - CacheBufferOffset;

    //
    // Check if there are enough bytes in the cache buffer to contain a full
    // header.
    //

    if (CacheBytesRemaining < ISONsrFidConstantSize) {

        //
        // Copy the first part of the descriptor to the stack.
        //

        RtlCopyMemory(&StackFileIdentifierDescriptor, (PUCHAR)CacheBuffer +
            CacheBufferOffset, CacheBytesRemaining);

        //
        // Unmap this directory sector.
        //

        FscUnmapBuffer(CacheBuffer);
        CacheBuffer = NULL;

        //
        // Advance to the next directory sector.
        //

        LogicalSectorNumber++;

        //
        // Map the directory sector into the cache.
        //

        status = UdfxMapLogicalSector(VolumeExtension, Irp, LogicalSectorNumber,
            &CacheBuffer);

        if (!NT_SUCCESS(status)) {
            goto CleanupAndExit;
        }

        //
        // Copy the last part of the descriptor to the stack.  We've already
        // validated that the stream has at least enough bytes to contain a
        // header, so this copy is safe.
        //

        RtlCopyMemory((PUCHAR)&StackFileIdentifierDescriptor +
            CacheBytesRemaining, CacheBuffer, ISONsrFidConstantSize -
            CacheBytesRemaining);

        FileIdentifierDescriptor = &StackFileIdentifierDescriptor;

    } else {

        //
        // There's enough bytes in the current buffer to contain at least the
        // header, so point directly into the cache buffer.
        //

        FileIdentifierDescriptor = (PNSR_FID)((PUCHAR)CacheBuffer +
            CacheBufferOffset);
    }

    //
    // Validate that the descriptor header looks valid and that its size
    // doesn't exceed a sector as specified by UDF or the number of
    // remaining bytes in the directory stream.  We can't use
    // UdfxVerifyDescriptor here because we don't have a contiguous
    // descriptor in memory.
    //

    FileIdentifierDescriptorLength = ISONsrFidSize(FileIdentifierDescriptor);

    if ((FileIdentifierDescriptor->Destag.Version != DESTAG_VER_CURRENT) ||
        (FileIdentifierDescriptor->Destag.Ident != DESTAG_ID_NSR_FID) ||
        (FileIdentifierDescriptorLength > UDF_CD_SECTOR_SIZE) ||
        (FileIdentifierDescriptorLength > FileBytesRemaining)) {
        status = STATUS_DISK_CORRUPT_ERROR;
        goto CleanupAndExit;
    }

    //
    // Allocate a buffer to receive the file identifier descriptor.
    //

    PoolFileIdentifierDescriptor = (PNSR_FID)ExAllocatePoolWithTag(
        FileIdentifierDescriptorLength, 'iFxU');

    if (PoolFileIdentifierDescriptor == NULL) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto CleanupAndExit;
    }

    //
    // Carefully copy the full file identifier descriptor to the pool block.
    //

    if (FileIdentifierDescriptor == &StackFileIdentifierDescriptor) {

        ASSERT(UdfxIsFlagClear(DirectoryFcb->Flags, UDF_FCB_EMBEDDED_DATA));

        //
        // The descriptor's header crossed a sector boundary.  Copy the first
        // part of the descriptor from the stack copy of the header and then
        // copy the rest from the current cache buffer.
        //

        RtlCopyMemory(PoolFileIdentifierDescriptor, &StackFileIdentifierDescriptor,
            CacheBytesRemaining);

        RtlCopyMemory((PUCHAR)PoolFileIdentifierDescriptor + CacheBytesRemaining,
            CacheBuffer, FileIdentifierDescriptorLength - CacheBytesRemaining);

    } else if (CacheBytesRemaining < FileIdentifierDescriptorLength) {

        ASSERT(UdfxIsFlagClear(DirectoryFcb->Flags, UDF_FCB_EMBEDDED_DATA));

        //
        // Part of the descriptor crosses a sector boundary, so we'll need to
        // copy as much as we can from the current cache buffer and then map in
        // the next sector.
        //

        //
        // Copy the first part of the descriptor to the pool block.
        //

        RtlCopyMemory(PoolFileIdentifierDescriptor, FileIdentifierDescriptor,
            CacheBytesRemaining);

        //
        // Unmap this directory sector.
        //

        FscUnmapBuffer(CacheBuffer);
        CacheBuffer = NULL;

        //
        // Advance to the next directory sector.
        //

        LogicalSectorNumber++;

        //
        // Map the directory sector into the cache.
        //

        status = UdfxMapLogicalSector(VolumeExtension, Irp, LogicalSectorNumber,
            &CacheBuffer);

        if (!NT_SUCCESS(status)) {
            goto CleanupAndExit;
        }

        //
        // Copy the last part of the descriptor to the pool block.
        //

        RtlCopyMemory((PUCHAR)PoolFileIdentifierDescriptor + CacheBytesRemaining,
            CacheBuffer, FileIdentifierDescriptorLength - CacheBytesRemaining);

    } else {

        //
        // The entire descriptor resides in one sector.  Copy it from the
        // current cache buffer.
        //

        RtlCopyMemory(PoolFileIdentifierDescriptor, FileIdentifierDescriptor,
            FileIdentifierDescriptorLength);
    }

    *ReturnedFileIdentifierDescriptor = PoolFileIdentifierDescriptor;
    PoolFileIdentifierDescriptor = NULL;

    status = STATUS_SUCCESS;

CleanupAndExit:
    if (PoolFileIdentifierDescriptor != NULL) {
        ExFreePool(PoolFileIdentifierDescriptor);
    }

    if (CacheBuffer != NULL) {
        FscUnmapBuffer(CacheBuffer);
    }

    return status;
}

NTSTATUS
UdfxFindNextFileIdentifierDescriptor(
    IN PUDF_VOLUME_EXTENSION VolumeExtension,
    IN PIRP Irp,
    IN PUDF_FCB DirectoryFcb,
    IN PDIRECTORY_ENUM_CONTEXT DirectoryEnumContext,
    OUT PNSR_FID *ReturnedFileIdentifierDescriptor,
    OUT POBJECT_STRING FileName
    )
/*++

Routine Description:

    This routine finds the next file identifier descriptor that matches the
    query template specification.

Arguments:

    VolumeExtension - Specifies the extension that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

    DirectoryFcb - Specifies the file control block that describes where to
        read the directory stream from.

    DirectoryEnumContext - Specifies the directory enumeration context.

    ReturnedFileIdentifierDescriptor - Specifies the buffer to receive the pool
        allocated file identifier descriptor.

    FileName - Specifies the buffer to receive the pool allocated matching file
        name.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    PNSR_FID FileIdentifierDescriptor;

    //
    // Process the directory stream until we find a match or run out of
    // file identifier descriptors.
    //

    for (;;) {

        //
        // Read in the next file identifier descriptor.
        //

        status = UdfxReadNextFileIdentifierDescriptor(VolumeExtension, Irp,
            DirectoryFcb, DirectoryEnumContext, &FileIdentifierDescriptor);

        if (!NT_SUCCESS(status)) {
            break;
        }

        //
        // Check if the file identifier descriptor has a name.  This filters out
        // the special directory entry that would map to "..".  We don't bother
        // faking this special name or the "." directory entry.
        //

        if (FileIdentifierDescriptor->FileIDLen != 0) {

            //
            // Convert the string to a Unicode string.
            //

            status = UdfxOSTACS0StringToObjectString(
                (PUCHAR)FileIdentifierDescriptor + ISONsrFidConstantSize +
                FileIdentifierDescriptor->ImpUseLen,
                FileIdentifierDescriptor->FileIDLen, FileName);

            if (!NT_SUCCESS(status)) {
                break;
            }

            //
            // If there's no template file name, then this is an automatic
            // match.  Otherwise, check if the file name matches the template
            // file name criteria.
            //

            if ((DirectoryEnumContext->TemplateFileName.Buffer == NULL) ||
                IoIsNameInExpression(&DirectoryEnumContext->TemplateFileName, FileName)) {
                *ReturnedFileIdentifierDescriptor = FileIdentifierDescriptor;
                return STATUS_SUCCESS;
            }

            ExFreePool(FileName->Buffer);
        }

        //
        // Advance to the offset of the next file identifier descriptor.
        //

        DirectoryEnumContext->QueryOffset += ISONsrFidSize(FileIdentifierDescriptor);

        //
        // Free the memory of the current file identifier descriptor.
        //

        ExFreePool(FileIdentifierDescriptor);
        FileIdentifierDescriptor = NULL;
    }

    if (FileIdentifierDescriptor != NULL) {
        ExFreePool(FileIdentifierDescriptor);
    }

    return status;
}

NTSTATUS
UdfxFsdDirectoryControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is called by the I/O manager to handle IRP_MJ_DIRECTORY_CONTROL
    requests.

Arguments:

    DeviceObject - Specifies the device object that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    PUDF_VOLUME_EXTENSION VolumeExtension;
    PIO_STACK_LOCATION IrpSp;
    PFILE_OBJECT FileObject;
    PUDF_FCB DirectoryFcb;
    PDIRECTORY_ENUM_CONTEXT DirectoryEnumContext;
    ULONG FileInformationClass;
    SIZE_T FileInformationBaseLength;
    BOOLEAN InitialQuery;
    POBJECT_STRING TemplateFileName;
    PNSR_FID FileIdentifierDescriptor;
    OBJECT_STRING FileName;
    PFILE_DIRECTORY_INFORMATION DirectoryInformation;
    PUDF_FCB InformationFcb;
    ULONG FileNameBytesToCopy;
    ULONG OutputBytesRemaining;

    VolumeExtension = (PUDF_VOLUME_EXTENSION)DeviceObject->DeviceExtension;
    IrpSp = IoGetCurrentIrpStackLocation(Irp);
    FileObject = IrpSp->FileObject;
    DirectoryFcb = (PUDF_FCB)FileObject->FsContext;

    //
    // Synchronize the creation and access of the directory context control
    // block by acquiring the global mutex.
    //

    UdfxAcquireGlobalMutexExclusive();

    //
    // Ensure that the file object is for a directory.
    //

    if (UdfxIsFlagClear(DirectoryFcb->Flags, UDF_FCB_DIRECTORY)) {
        status = STATUS_INVALID_PARAMETER;
        goto CleanupAndExit;
    }

    //
    // Verify that this is a supported information class.
    //

    FileInformationClass = IrpSp->Parameters.QueryDirectory.FileInformationClass;

    switch (FileInformationClass) {

        case FileDirectoryInformation:
            FileInformationBaseLength = FIELD_OFFSET(FILE_DIRECTORY_INFORMATION,
                FileName[0]);
            break;

        case FileNamesInformation:
            FileInformationBaseLength = FIELD_OFFSET(FILE_NAMES_INFORMATION,
                FileName[0]);
            break;

        default:
            status = STATUS_INVALID_INFO_CLASS;
            goto CleanupAndExit;
    }

    //
    // The query cannot be started relative to a starting index.
    //

    if (UdfxIsFlagSet(IrpSp->Flags, SL_INDEX_SPECIFIED)) {
        status = STATUS_NOT_IMPLEMENTED;
        goto CleanupAndExit;
    }

    //
    // If this is the first query for this directory, then prepare the template
    // file name.
    //

    DirectoryEnumContext = (PDIRECTORY_ENUM_CONTEXT)FileObject->FsContext2;

    if (DirectoryEnumContext == NULL) {

        TemplateFileName = IrpSp->Parameters.QueryDirectory.FileName;

        status = IoCreateDirectoryEnumContext(TemplateFileName,
            &DirectoryEnumContext);

        if (!NT_SUCCESS(status)) {
            goto CleanupAndExit;
        }

        //
        // Connect the directory enumeration context to the file object.
        //

        FileObject->FsContext2 = DirectoryEnumContext;

        InitialQuery = TRUE;

    } else {

        InitialQuery = FALSE;
    }

    //
    // If we're to restart the directory scan, then reset the current index to
    // zero.
    //

    if (UdfxIsFlagSet(IrpSp->Flags, SL_RESTART_SCAN)) {
        DirectoryEnumContext->QueryOffset = 0;
    }

    //
    // Find the next file identifier descriptor that matches our query criteria.
    //
    // On return, Directory.QueryOffset still points at the matching identifier.
    // It's only updated after we're about to successfully return so that no
    // entries are lost in the event of an invalid parameter or pool allocation
    // failure.
    //

    status = UdfxFindNextFileIdentifierDescriptor(VolumeExtension, Irp,
        DirectoryFcb, DirectoryEnumContext, &FileIdentifierDescriptor, &FileName);

    if (NT_SUCCESS(status)) {

        //
        // The I/O manager has already checked that the user's buffer has enough
        // space to contain at least the header.
        //

        ASSERT(IrpSp->Parameters.QueryDirectory.Length >= FileInformationBaseLength);

        //
        // Zero out the header.
        //

        DirectoryInformation = (PFILE_DIRECTORY_INFORMATION)Irp->UserBuffer;
        RtlZeroMemory(DirectoryInformation, FileInformationBaseLength);

        //
        // For FileDirectoryInformation and FileNamesInformation, the
        // FileNameLength field is immediately before the FileName buffer.
        //

        *((PULONG)((PUCHAR)DirectoryInformation + FileInformationBaseLength -
            sizeof(ULONG))) = FileName.Length;

        //
        // If this is a FileDirectoryInformation request, then fill in more
        // information.  We have to go to dig into the file entry descriptor
        // to get the information we need, so we'll construct a file control
        // block to get the attributes.
        //

        if (FileInformationClass == FileDirectoryInformation) {

            status = UdfxCreateFcbFromFileEntry(VolumeExtension, Irp,
                &FileIdentifierDescriptor->Icb, NULL, NULL, &InformationFcb);

            if (NT_SUCCESS(status)) {

                DirectoryInformation->EndOfFile =
                DirectoryInformation->AllocationSize =
                    InformationFcb->FileSize;

                DirectoryInformation->CreationTime =
                DirectoryInformation->LastAccessTime =
                DirectoryInformation->LastWriteTime =
                DirectoryInformation->ChangeTime =
                    UdfxUdfTimestampToTime(&InformationFcb->ModifyTime);

                if (UdfxIsFlagSet(InformationFcb->Flags, UDF_FCB_DIRECTORY)) {
                    DirectoryInformation->FileAttributes =
                        FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_DIRECTORY;
                } else {
                    DirectoryInformation->FileAttributes =
                        FILE_ATTRIBUTE_READONLY;
                }

                UdfxDereferenceFcb(InformationFcb);
            }
        }

        //
        // If nothing has gone wrong yet, then copy the file name to the user's
        // buffer.
        //

        if (NT_SUCCESS(status)) {

            OutputBytesRemaining =
                ALIGN_DOWN(IrpSp->Parameters.QueryDirectory.Length -
                FileInformationBaseLength, sizeof(OCHAR));
            FileNameBytesToCopy = FileName.Length;

            if (FileNameBytesToCopy > OutputBytesRemaining) {
                FileNameBytesToCopy = OutputBytesRemaining;
                status = STATUS_BUFFER_OVERFLOW;
            } else {
                status = STATUS_SUCCESS;
            }

            RtlCopyMemory((PUCHAR)DirectoryInformation + FileInformationBaseLength,
                FileName.Buffer, FileNameBytesToCopy);

            //
            // Fill in the number of bytes that we wrote to the user's buffer.
            //

            Irp->IoStatus.Information = FileInformationBaseLength +
                FileNameBytesToCopy;

            //
            // Check that we didn't overflow the user's buffer.  The I/O manager
            // does the initial check to make sure there's enough space for the
            // static structure for a given information class, but we might
            // overflow the buffer when copying in the variable length file
            // name.
            //

            ASSERT(Irp->IoStatus.Information <=
                IrpSp->Parameters.QueryDirectory.Length);

            //
            // Update the query offset.
            //

            DirectoryEnumContext->QueryOffset += ISONsrFidSize(FileIdentifierDescriptor);
        }

        ExFreePool(FileName.Buffer);
        ExFreePool(FileIdentifierDescriptor);

    } else if (status == STATUS_END_OF_FILE) {

        //
        // If we hit the end of the directory stream, then return an appropriate
        // status code depending on whether this was the first pass through this
        // routine for this handle or not.
        //

        status = InitialQuery ? STATUS_NO_SUCH_FILE : STATUS_NO_MORE_FILES;
    }

CleanupAndExit:
    UdfxReleaseGlobalMutex();

    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\udfx\fileinfo.c ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    fileinfo.c

Abstract:

    This module implements routines related to handling
    IRP_MJ_QUERY_INFORMATION and IRP_MJ_SET_INFORMATION.

--*/

#include "udfx.h"

VOID
UdfxQueryNetworkOpenInformation(
    IN PFILE_OBJECT FileObject,
    OUT PFILE_NETWORK_OPEN_INFORMATION NetworkOpenInformation
    )
/*++

Routine Description:

    This routine fills the information structure with attributes about the
    supplied file object.

Arguments:

    FileObject - Specifies the file object to obtain the information from.

    NetworkOpenInformation - Specifies the buffer to receive the file
        information.

Return Value:

    None.

--*/
{
    PUDF_FCB Fcb;

    Fcb = (PUDF_FCB)FileObject->FsContext;

    NetworkOpenInformation->CreationTime =
    NetworkOpenInformation->LastAccessTime =
    NetworkOpenInformation->LastWriteTime =
    NetworkOpenInformation->ChangeTime =
        UdfxUdfTimestampToTime(&Fcb->ModifyTime);

    if (UdfxIsFlagSet(Fcb->Flags, UDF_FCB_DIRECTORY)) {

        NetworkOpenInformation->FileAttributes = FILE_ATTRIBUTE_READONLY |
            FILE_ATTRIBUTE_DIRECTORY;
        NetworkOpenInformation->AllocationSize.QuadPart = 0;
        NetworkOpenInformation->EndOfFile.QuadPart = 0;

    } else {

        NetworkOpenInformation->FileAttributes = FILE_ATTRIBUTE_READONLY;
        NetworkOpenInformation->AllocationSize = Fcb->FileSize;
        NetworkOpenInformation->EndOfFile = Fcb->FileSize;
    }
}

NTSTATUS
UdfxFsdQueryInformation(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is called by the I/O manager to handle IRP_MJ_QUERY_INFORMATION
    requests.

Arguments:

    DeviceObject - Specifies the device object that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    PUDF_VOLUME_EXTENSION VolumeExtension;
    PIO_STACK_LOCATION IrpSp;
    PFILE_OBJECT FileObject;
    PUDF_FCB Fcb;
    ULONG BytesWritten;
    PFILE_INTERNAL_INFORMATION InternalInformation;
    PFILE_POSITION_INFORMATION PositionInformation;

    VolumeExtension = (PUDF_VOLUME_EXTENSION)DeviceObject->DeviceExtension;
    IrpSp = IoGetCurrentIrpStackLocation(Irp);
    FileObject = IrpSp->FileObject;
    Fcb = (PUDF_FCB)FileObject->FsContext;

    //
    // For volume file control blocks, the only thing that can be queried is the
    // current file position.
    //

    if (UdfxIsFlagSet(Fcb->Flags, UDF_FCB_VOLUME) &&
        (IrpSp->Parameters.SetFile.FileInformationClass != FilePositionInformation)) {
        status = STATUS_INVALID_PARAMETER;
        goto CleanupAndExit;
    }

    //
    // Clear the output buffer.
    //

    RtlZeroMemory(Irp->UserBuffer, IrpSp->Parameters.QueryFile.Length);

    //
    // Dispatch the information class function.
    //

    status = STATUS_SUCCESS;

    switch (IrpSp->Parameters.QueryFile.FileInformationClass) {

        case FileInternalInformation:
            InternalInformation = (PFILE_INTERNAL_INFORMATION)Irp->UserBuffer;
            InternalInformation->IndexNumber.HighPart = PtrToUlong(VolumeExtension);
            InternalInformation->IndexNumber.LowPart = PtrToUlong(Fcb);
            BytesWritten = sizeof(FILE_INTERNAL_INFORMATION);
            break;

        case FilePositionInformation:
            PositionInformation = (PFILE_POSITION_INFORMATION)Irp->UserBuffer;
            PositionInformation->CurrentByteOffset = FileObject->CurrentByteOffset;
            BytesWritten = sizeof(FILE_POSITION_INFORMATION);
            break;

        case FileNetworkOpenInformation:
            UdfxQueryNetworkOpenInformation(FileObject,
                (PFILE_NETWORK_OPEN_INFORMATION)Irp->UserBuffer);
            BytesWritten = sizeof(FILE_NETWORK_OPEN_INFORMATION);
            break;

        default:
            BytesWritten = 0;
            status = STATUS_INVALID_PARAMETER;
            break;
    }

    //
    // Fill in the number of bytes that we wrote to the user's buffer.
    //

    Irp->IoStatus.Information = BytesWritten;

    //
    // Check that we didn't overflow the user's buffer.  The I/O manager does
    // the initial check to make sure there's enough space for the static
    // structure for a given information class, but we might overflow the buffer
    // when copying in the variable length file name.
    //

    ASSERT(Irp->IoStatus.Information <= IrpSp->Parameters.QueryFile.Length);

CleanupAndExit:
    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return status;
}

NTSTATUS
UdfxFsdSetInformation(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is called by the I/O manager to handle IRP_MJ_SET_INFORMATION
    requests.

Arguments:

    DeviceObject - Specifies the device object that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    PIO_STACK_LOCATION IrpSp;
    PFILE_OBJECT FileObject;
    PFILE_POSITION_INFORMATION PositionInformation;

    IrpSp = IoGetCurrentIrpStackLocation(Irp);
    FileObject = IrpSp->FileObject;

    //
    // The only thing that can be set is the current file position.
    //

    if (IrpSp->Parameters.SetFile.FileInformationClass != FilePositionInformation) {
        status = STATUS_INVALID_PARAMETER;
        goto CleanupAndExit;
    }

    PositionInformation = (PFILE_POSITION_INFORMATION)Irp->UserBuffer;

    //
    // If the file was opened without intermediate buffering, then the byte
    // offset must be sector aligned.
    //
    // Note that we don't use UDF_SECTOR_CD_MASK here so that the generated code
    // ends up being identical to RawxFsdSetInformation.  The linker will take
    // care of collapsing the two functions.
    //

    if (UdfxIsFlagSet(FileObject->Flags, FO_NO_INTERMEDIATE_BUFFERING) &&
        (PositionInformation->CurrentByteOffset.LowPart &
        (DeviceObject->SectorSize - 1)) != 0) {
        status = STATUS_INVALID_PARAMETER;
        goto CleanupAndExit;
    }

    //
    // Update the current file position.
    //

    FileObject->CurrentByteOffset = PositionInformation->CurrentByteOffset;
    status = STATUS_SUCCESS;

CleanupAndExit:
    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\udfx\fcbsup.c ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    fcbsup.c

Abstract:

    This module implements routines which provide support for file control
    blocks.

--*/

#include "udfx.h"

NTSTATUS
UdfxCreateFcbFromFileEntry(
    IN PUDF_VOLUME_EXTENSION VolumeExtension,
    IN PIRP Irp,
    IN PLONGAD IcbExtent,
    IN PUDF_FCB ParentFcb OPTIONAL,
    IN POBJECT_STRING FileName OPTIONAL,
    OUT PUDF_FCB *ReturnedFcb
    )
/*++

Routine Description:

    This routine reads the file entry descriptor at the supplied extent and
    constructs a file control block that represents the file.

Arguments:

    VolumeExtension - Specifies the volume to read the file entry descriptor
        from.

    Irp - Specifies an IRP that can be used for cache I/O.

    IcbExtent - Specifies the extent of the file entry descriptor.

    ParentFcb - Specifies the parent directory that contains the supplied file.

    FileName - Specifies the name of the file.

    ReturnedFcb - Specifies the buffer to receive the created file control
        block.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    SIZE_T FcbSize;
    PUDF_FCB Fcb;
    PICBFILE IcbFile;
    ULONG AllocationDescriptorType;
    PLONGAD LongExtent;
    PSHORTAD ShortExtent;

    *ReturnedFcb = NULL;

    Fcb = NULL;
    IcbFile = NULL;

    //
    // Verify that the extent specifies the single supported partition.
    //

    if (IcbExtent->Start.Partition != 0) {
        status = STATUS_DISK_CORRUPT_ERROR;
        goto CleanupAndExit;
    }

    //
    // Compute the size of the file control block.
    //

    FcbSize = sizeof(UDF_FCB) + ((FileName != NULL) ? FileName->Length : 0);

    //
    // Allocate and initialize the file control block.
    //

    Fcb = ExAllocatePoolWithTag(FcbSize, 'cFxU');

    if (Fcb == NULL) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto CleanupAndExit;
    }

    RtlZeroMemory(Fcb, FcbSize);

    InitializeListHead(&Fcb->ChildFcbList);

    //
    // Copy the file name into the file control block.
    //

    if (FileName != NULL) {
        RtlCopyMemory(Fcb->FileName, FileName->Buffer, FileName->Length);
        Fcb->FileNameLength = (UCHAR)FileName->Length;
    }

    //
    // Map the file descriptor into the cache.
    //

    status = UdfxMapLogicalSector(VolumeExtension, Irp, IcbExtent->Start.Lbn,
        (PVOID*)&IcbFile);

    if (!NT_SUCCESS(status)) {
        goto CleanupAndExit;
    }

    //
    // Verify that this is a file descriptor.
    //

    if (!UdfxVerifyDescriptor(&IcbFile->Destag, UDF_CD_SECTOR_SIZE,
        DESTAG_ID_NSR_FILE, IcbExtent->Start.Lbn)) {

        UdfxDbgPrint(("UDFX: file descriptor doesn't verify\n"));
        status = STATUS_DISK_CORRUPT_ERROR;
        goto CleanupAndExit;
    }

    //
    // Verify that the size of the file descriptor's variable fields doesn't
    // exceed the size of a sector.  Avoid overflow problems by checking each
    // field individually as well.
    //

    if ((IcbFile->EALength > UDF_CD_SECTOR_SIZE) ||
        (IcbFile->AllocLength > UDF_CD_SECTOR_SIZE) ||
        ((FIELD_OFFSET(ICBFILE, EAs) + IcbFile->EALength + IcbFile->AllocLength) >
            UDF_CD_SECTOR_SIZE)) {
        UdfxDbgPrint(("UDFX: file descriptor has too large of variant structures\n"));
        status = STATUS_DISK_CORRUPT_ERROR;
        goto CleanupAndExit;
    }

    //
    // Verify that this is a file type that we can support and mark the file
    // control block accordingly.
    //

    if (IcbFile->Icbtag.FileType == ICBTAG_FILE_T_DIRECTORY) {
        Fcb->Flags |= UDF_FCB_DIRECTORY;
    } else if (IcbFile->Icbtag.FileType != ICBTAG_FILE_T_FILE) {
        UdfxDbgPrint(("UDFX: file descriptor has unsupported file type\n"));
        status = STATUS_DISK_CORRUPT_ERROR;
        goto CleanupAndExit;
    }

    //
    // Copy the file size to the file control block and verify that the length
    // is limited to 32-bits.  We only support a single allocation extent and
    // that's limited to a single ULONG.
    //

    Fcb->FileSize.QuadPart = IcbFile->InfoLength;

    if (Fcb->FileSize.HighPart != 0) {
        UdfxDbgPrint(("UDFX: file descriptor has too large of file size\n"));
        status = STATUS_DISK_CORRUPT_ERROR;
        goto CleanupAndExit;
    }

    //
    // Copy the modify timestamp to the file control block.  We don't bother
    // storing any of the other timestamps that are part of the file control
    // block or stored as extended attributes.
    //

    Fcb->ModifyTime = IcbFile->ModifyTime;

    //
    // Verify that the strategy type is direct mode.
    //

    if (IcbFile->Icbtag.StratType != ICBTAG_STRAT_DIRECT) {
        UdfxDbgPrint(("UDFX: file descriptor has unsupported ICB strategy\n"));
        status = STATUS_DISK_CORRUPT_ERROR;
        goto CleanupAndExit;
    }

    //
    // Verify that we know how to process the allocation descriptor encoding.
    //

    AllocationDescriptorType = (IcbFile->Icbtag.Flags & ICBTAG_F_ALLOC_MASK);

    if ((Fcb->FileSize.LowPart == 0) && (IcbFile->AllocLength == 0)) {

        //
        // If this is a zero length file, then there may not be any allocation
        // descriptors for the file.
        //

        ASSERT(Fcb->AllocationSectorStart == 0);
        ASSERT(Fcb->EmbeddedDataOffset == 0);

    } else if (AllocationDescriptorType == ICBTAG_F_ALLOC_IMMEDIATE) {

        //
        // The size of the file should match the length of the allocation data.
        //

        if (Fcb->FileSize.LowPart != IcbFile->AllocLength) {
            UdfxDbgPrint(("UDFX: file descriptor has invalid allocation length\n"));
            status = STATUS_DISK_CORRUPT_ERROR;
            goto CleanupAndExit;
        }

        Fcb->Flags |= UDF_FCB_EMBEDDED_DATA;
        Fcb->AllocationSectorStart = IcbExtent->Start.Lbn;
        Fcb->EmbeddedDataOffset = (USHORT)
            (FIELD_OFFSET(ICBFILE, EAs) + IcbFile->EALength);

    } else if (AllocationDescriptorType == ICBTAG_F_ALLOC_LONG) {

        if (IcbFile->AllocLength != sizeof(LONGAD)) {
            UdfxDbgPrint(("UDFX: file descriptor has invalid allocation length\n"));
            status = STATUS_DISK_CORRUPT_ERROR;
            goto CleanupAndExit;
        }

        LongExtent = (PLONGAD)((PUCHAR)IcbFile + FIELD_OFFSET(ICBFILE, EAs) +
            IcbFile->EALength);

        //
        // Verify that the extent specifies the single supported partition.
        //

        if (LongExtent->Start.Partition != 0) {
            status = STATUS_DISK_CORRUPT_ERROR;
            goto CleanupAndExit;
        }

        //
        // The size of the file should match the length of the extent.
        //

        if (Fcb->FileSize.LowPart != LongExtent->Length.Length) {
            UdfxDbgPrint(("UDFX: file descriptor has invalid extent length\n"));
            status = STATUS_DISK_CORRUPT_ERROR;
            goto CleanupAndExit;
        }

        Fcb->AllocationSectorStart = LongExtent->Start.Lbn;
        ASSERT(Fcb->EmbeddedDataOffset == 0);

    } else if (AllocationDescriptorType == ICBTAG_F_ALLOC_SHORT) {

        if (IcbFile->AllocLength != sizeof(SHORTAD)) {
            UdfxDbgPrint(("UDFX: file descriptor has invalid allocation length\n"));
            status = STATUS_DISK_CORRUPT_ERROR;
            goto CleanupAndExit;
        }

        ShortExtent = (PSHORTAD)((PUCHAR)IcbFile + FIELD_OFFSET(ICBFILE, EAs) +
            IcbFile->EALength);

        //
        // The size of the file should match the length of the extent.
        //

        if (Fcb->FileSize.LowPart != ShortExtent->Length.Length) {
            UdfxDbgPrint(("UDFX: file descriptor has invalid extent length\n"));
            status = STATUS_DISK_CORRUPT_ERROR;
            goto CleanupAndExit;
        }

        Fcb->AllocationSectorStart = ShortExtent->Start;
        ASSERT(Fcb->EmbeddedDataOffset == 0);

    } else {

        UdfxDbgPrint(("UDFX: file descriptor has unsupported allocation type\n"));
        status = STATUS_DISK_CORRUPT_ERROR;
        goto CleanupAndExit;
    }

    //
    // A file control block starts with the single reference for the caller.
    //

    Fcb->ReferenceCount = 1;

    //
    // Increment the reference count for the parent file control block and
    // attach it to this file control block.
    //

    if (ParentFcb != NULL) {
        ParentFcb->ReferenceCount++;
        Fcb->ParentFcb = ParentFcb;
        InsertHeadList(&ParentFcb->ChildFcbList, &Fcb->SiblingFcbLink);
    }

    //
    // The file control block is successfully filled in.  Return the results to
    // the caller.
    //

    *ReturnedFcb = Fcb;
    Fcb = NULL;
    status = STATUS_SUCCESS;

CleanupAndExit:
    if (IcbFile != NULL) {
        FscUnmapBuffer(IcbFile);
    }

    if (Fcb != NULL) {
        ExFreePool(Fcb);
    }

    return status;
}

BOOLEAN
UdfxFindOpenChildFcb(
    IN PUDF_FCB DirectoryFcb,
    IN POBJECT_STRING FileName,
    OUT PUDF_FCB *ReturnedFcb
    )
/*++

Routine Description:

    This routine searches the child file control block for the supplied
    directory for a file that has the supplied file name.

Arguments:

    DirectoryFcb - Specifies the file control block of the directory to search.

    FileName - Specifies the name to search for in the directory.

    ReturnedFcb - Specifies the buffer to receive the found file control block.

Return Value:

    Returns TRUE if the file control block was found, else FALSE.

--*/
{
    PLIST_ENTRY NextFcbLink;
    PUDF_FCB Fcb;
    OBJECT_STRING FcbFileName;

    //
    // Walk through the file control blocks actively in use by the volume and
    // find a match.
    //

    NextFcbLink = DirectoryFcb->ChildFcbList.Flink;

    while (NextFcbLink != &DirectoryFcb->ChildFcbList) {

        Fcb = CONTAINING_RECORD(NextFcbLink, UDF_FCB, SiblingFcbLink);

        FcbFileName.Length = Fcb->FileNameLength;
        FcbFileName.Buffer = Fcb->FileName;

        if ((FcbFileName.Length == FileName->Length) &&
            RtlEqualObjectString(&FcbFileName, FileName, TRUE)) {
            *ReturnedFcb = Fcb;
            return TRUE;
        }

        NextFcbLink = Fcb->SiblingFcbLink.Flink;
    }

    *ReturnedFcb = NULL;
    return FALSE;
}

VOID
UdfxDereferenceFcb(
    IN PUDF_FCB Fcb
    )
/*++

Routine Description:

    This routine decrements the reference count on the supplied file control
    block.  If the reference count reaches zero, then the file control block is
    deleted.

Arguments:

    Fcb - Specifies the file control block to dereference.

Return Value:

    None.

--*/
{
    PUDF_FCB ParentFcb;

    ASSERT(Fcb->ReferenceCount > 0);

    do {

        //
        // Decrement the reference count and bail out if there are still
        // outstanding references to the file control block.
        //

        if (--Fcb->ReferenceCount != 0) {
            return;
        }

        //
        // Verify that the child file control block list is empty if this is a
        // directory.
        //

        if (UdfxIsFlagSet(Fcb->Flags, UDF_FCB_DIRECTORY)) {
            ASSERT(IsListEmpty(&Fcb->ChildFcbList));
        }

        //
        // Save off the parent file control block so that we can dereference it
        // in a bit.
        //

        ParentFcb = Fcb->ParentFcb;

        //
        // Remove this file control block from the list of siblings.
        //

        if (ParentFcb != NULL) {
            RemoveEntryList(&Fcb->SiblingFcbLink);
        }

        //
        // Free the file control block.
        //

        ExFreePool(Fcb);

        //
        // Switch to the parent file control block and restart the loop to
        // dereference this object.
        //

        Fcb = ParentFcb;

    } while (Fcb != NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\udfx\mountvol.c ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    mountvol.c

Abstract:

    This module implements routines related to the mounting of a UDF volume.

--*/

#include "udfx.h"

//
// Define a lookup table to map from VSD identifier string to its corresponding
// VSD identifier enumeration.
//

#include <pshpack1.h>

typedef struct _VSD_IDENT_LOOKUP_TABLE {
    UCHAR Ident[VSD_LENGTH_IDENT];
    UCHAR IdentEnum;
} VSD_IDENT_LOOKUP_TABLE, *PVSD_IDENT_LOOKUP_TABLE;

#include <poppack.h>

// C4295: array is too small to include a terminating null character
#pragma warning(disable:4295)

const VSD_IDENT_LOOKUP_TABLE UdfxVsdIdentLookupTable[] = {
    VSD_IDENT_BEA01, VsdIdentBEA01,
    VSD_IDENT_TEA01, VsdIdentTEA01,
    VSD_IDENT_CDROM, VsdIdentCDROM,
    VSD_IDENT_CD001, VsdIdentCD001,
    VSD_IDENT_NSR01, VsdIdentNSR01,
    VSD_IDENT_NSR02, VsdIdentNSR02,
    VSD_IDENT_CDW01, VsdIdentCDW01,
    VSD_IDENT_CDW02, VsdIdentCDW02,
    VSD_IDENT_BOOT2, VsdIdentBOOT2
};

#pragma warning(default:4295)

//
// Entity identifier for a ECMA-167 standard partition.
//
const UCHAR UdfxNSR02Regid[REGID_LENGTH_IDENT] = NSR_PART_CONTID_NSR02;

//
// Entity identifier for a UDF standard volume.
//
const UCHAR UdfxOSTAUdfRegid[REGID_LENGTH_IDENT] = "*OSTA UDF Compliant";

//
// Character set specification for a UDF partition.
//
const CHARSPEC UdfxCS0Identifier = {
    CHARSPEC_T_CS0, "OSTA Compressed Unicode"
};

NTSTATUS
UdfxCreateVolumeDevice(
    IN PDEVICE_OBJECT TargetDeviceObject,
    IN PDISK_GEOMETRY DiskGeometry,
    OUT PDEVICE_OBJECT *ReturnedVolumeDeviceObject
    )
/*++

Routine Description:

    This routine creates an instance of a volume device object.

Arguments:

    TargetDeviceObject - Specifies the device object that the volume object
        sends I/O requests to.

    DiskGeometry - Specifies the disk geometry of the target device.

    ReturnedVolumeDeviceObject - Specifies the buffer to receive the created
        device object.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    PDEVICE_OBJECT VolumeDeviceObject;
    PUDF_VOLUME_EXTENSION VolumeExtension;
    PUDF_FCB VolumeFcb;

    //
    // Create the volume's device object.
    //

    status = IoCreateDevice(&UdfxDriverObject, sizeof(UDF_VOLUME_EXTENSION),
        NULL, FILE_DEVICE_CD_ROM_FILE_SYSTEM, FALSE, &VolumeDeviceObject);

    if (!NT_SUCCESS(status)) {
        return status;
    }

    //
    // Increase the volume's IRP stack size for requests that we pass down to
    // the target device object.
    //

    VolumeDeviceObject->StackSize = (UCHAR)(VolumeDeviceObject->StackSize +
        TargetDeviceObject->StackSize);

    //
    // Ensure that the alignment for this device matches the requirements of the
    // target device.
    //

    if (VolumeDeviceObject->AlignmentRequirement < TargetDeviceObject->AlignmentRequirement) {
        VolumeDeviceObject->AlignmentRequirement = TargetDeviceObject->AlignmentRequirement;
    }

    //
    // If the target device object supports scatter gather I/O, then indicate
    // that we can as well.
    //

    if (UdfxIsFlagSet(TargetDeviceObject->Flags, DO_SCATTER_GATHER_IO)) {
        VolumeDeviceObject->Flags |= DO_SCATTER_GATHER_IO;
    }

    //
    // Set the size of a sector for this device.
    //

    VolumeDeviceObject->SectorSize = UDF_CD_SECTOR_SIZE;

    //
    // Increment the reference count on the target device object since we'll be
    // holding a pointer to it.
    //

    ObReferenceObject(TargetDeviceObject);

    //
    // Initialize the volume's device extension data.
    //

    VolumeExtension = (PUDF_VOLUME_EXTENSION)VolumeDeviceObject->DeviceExtension;

    VolumeExtension->TargetDeviceObject = TargetDeviceObject;
    VolumeExtension->SectorSize = UDF_CD_SECTOR_SIZE;
    VolumeExtension->PhysicalSectorCount = DiskGeometry->Cylinders.LowPart;

    //
    // Allocate the file control block for the physical volume.
    //

    VolumeFcb = ExAllocatePoolWithTag(sizeof(UDF_FCB), 'cVxU');

    if (VolumeFcb == NULL) {
        UdfxDeleteVolumeDevice(VolumeDeviceObject);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    VolumeExtension->VolumeFcb = VolumeFcb;
    VolumeExtension->RootDirectoryFcb = NULL;

    //
    // Initialize the file control block for the physical volume.
    //

    RtlZeroMemory(VolumeFcb, sizeof(UDF_FCB));

    VolumeFcb->Flags = UDF_FCB_VOLUME;
    VolumeFcb->ReferenceCount = 1;

    InitializeListHead(&VolumeFcb->SiblingFcbLink);

    //
    // The device has finished initializing and is ready to accept requests.
    //

    VolumeDeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

    //
    // Return the device object to the caller.
    //

    *ReturnedVolumeDeviceObject = VolumeDeviceObject;

    return STATUS_SUCCESS;
}

VOID
UdfxDeleteVolumeDevice(
    IN PDEVICE_OBJECT VolumeDeviceObject
    )
/*++

Routine Description:

    This routine deletes an instance of a volume device object.

Arguments:

    VolumeDeviceObject - Specifies the volume device object to delete.

Return Value:

    Status of operation.

--*/
{
    PUDF_VOLUME_EXTENSION VolumeExtension;

    VolumeExtension = (PUDF_VOLUME_EXTENSION)VolumeDeviceObject->DeviceExtension;

    //
    // There shouldn't be any open files for this volume.
    //

    ASSERT(VolumeExtension->FileObjectCount == 0);

    //
    // Delete any file control blocks created by the volume.
    //

    if (VolumeExtension->VolumeFcb != NULL) {
        UdfxDereferenceFcb(VolumeExtension->VolumeFcb);
    }

    if (VolumeExtension->RootDirectoryFcb != NULL) {
        UdfxDereferenceFcb(VolumeExtension->RootDirectoryFcb);
    }

    //
    // Invalidate any file system cache buffers for this device.
    //

    FscInvalidateDevice(&VolumeExtension->CacheExtension);

    //
    // Release the reference on the target device object.
    //

    if (VolumeExtension->TargetDeviceObject != NULL) {
        ObDereferenceObject(VolumeExtension->TargetDeviceObject);
    }

    //
    // Delete the device object.
    //

    IoDeleteDevice(VolumeDeviceObject);
}

NTSTATUS
UdfxReadPhysicalSector(
    IN PUDF_VOLUME_EXTENSION VolumeExtension,
    IN ULONG PhysicalSectorNumber,
    OUT PVOID Buffer
    )
/*++

Routine Description:

    This routine reads from the supplied device object a single physical sector.

Arguments:

    VolumeExtension - Specifies the volume extension to read from.

    PhysicalSectorNumber - Specifies the physical sector number to read.

    Buffer - Specifies the buffer to read the data into.

Return Value:

    Status of operation.

--*/
{
    LARGE_INTEGER ByteOffset;

    //
    // Verify that the physical sector resides inside the disk.
    //

    if (PhysicalSectorNumber >= VolumeExtension->PhysicalSectorCount) {
        return STATUS_DISK_CORRUPT_ERROR;
    }

    //
    // Read the physical sector.
    //

    ByteOffset.QuadPart = (ULONGLONG)PhysicalSectorNumber << UDF_CD_SECTOR_SHIFT;

    return IoSynchronousFsdRequest(IRP_MJ_READ, VolumeExtension->TargetDeviceObject,
        Buffer, UDF_CD_SECTOR_SIZE, &ByteOffset);
}

NTSTATUS
UdfxRecognizeVolume(
    IN PUDF_VOLUME_EXTENSION VolumeExtension
    )
/*++

Routine Description:

    This routine checks if a UDF volume is in the specified device.

    Refer to ISO 13346 section 2/8.

Arguments:

    VolumeExtension - Specifies the extension for the volume to mount.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    PVSD_GENERIC VolumeStructureDescriptor;
    ULONG PhysicalSectorNumber;
    ULONG LookupIndex;
    VSD_IDENT VsdIdent;
    BOOLEAN FoundBEA;

    //
    // Allocate a buffer to read the descriptors into.  The buffer size must be
    // aligned to the size of a CD-ROM sector.
    //

    VolumeStructureDescriptor = (PVSD_GENERIC)ExAllocatePoolWithTag(UDF_CD_SECTOR_SIZE,
        'sVxU');

    if (VolumeStructureDescriptor == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // The volume recognition area begins at VRA_BOUNDARY_LOCATION rounded up to
    // the next sector.
    //

    PhysicalSectorNumber = UDF_CD_SECTOR_ALIGN_UP(VRA_BOUNDARY_LOCATION) >>
        UDF_CD_SECTOR_SHIFT;

    //
    // Process the volume structure descriptors.
    //

    status = STATUS_UNRECOGNIZED_VOLUME;
    FoundBEA = FALSE;

    for (;;) {

        //
        // Verify that the physical sector is in the bounds of the disk.
        //

        if (PhysicalSectorNumber >= VolumeExtension->PhysicalSectorCount) {
            status = STATUS_UNRECOGNIZED_VOLUME;
            break;
        }

        //
        // Read the next volume structure descriptor.
        //

        status = UdfxReadPhysicalSector(VolumeExtension, PhysicalSectorNumber,
            VolumeStructureDescriptor);

        if (!NT_SUCCESS(status)) {
            break;
        }

        //
        // Set up the error code for an invalid UDF volume.
        //

        status = STATUS_UNRECOGNIZED_VOLUME;

        //
        // Map the VSD identifier string to its VSD identifier enumeration.  If
        // we find an unrecognized identifier, then this can't be a UDF volume
        // that we support.
        //

        VsdIdent = VsdIdentBad;

        for (LookupIndex = 0; LookupIndex <
            ARRAY_ELEMENTS(UdfxVsdIdentLookupTable); LookupIndex++) {

            if (RtlEqualMemory(VolumeStructureDescriptor->Ident,
                UdfxVsdIdentLookupTable[LookupIndex].Ident, VSD_LENGTH_IDENT)) {
                VsdIdent = UdfxVsdIdentLookupTable[LookupIndex].IdentEnum;
                break;
            }
        }

        if (VsdIdent == VsdIdentBad) {
            UdfxDbgPrint(("UDFX: unknown VSD identifier\n"));
            break;
        }

        //
        // Process the VSD type based on the VSD identifier.
        //

        if (VolumeStructureDescriptor->Type == 0) {

            if (VsdIdent == VsdIdentBEA01) {

                //
                // Beginning Extended Area descriptor.  There should be one and
                // only one of these descriptors.
                //

                if (FoundBEA) {
                    UdfxDbgPrint(("UDFX: found multiple BEA01 descriptors\n"));
                    break;
                }

                if (VolumeStructureDescriptor->Version != 1) {
                    UdfxDbgPrint(("UDFX: found BEA01 descriptor with unknown version\n"));
                    break;
                }

                FoundBEA = TRUE;

            } else if (VsdIdent == VsdIdentNSR02) {

                //
                // NSR02 descriptor.  There should be one of these descriptors
                // following the BEA01 descriptor.
                //

                if (FoundBEA) {

                    if (VolumeStructureDescriptor->Version != 1) {
                        UdfxDbgPrint(("UDFX: found NSR02 descriptor with unknown version\n"));
                        break;
                    }

                    status = STATUS_SUCCESS;
                    break;

                } else {

                    UdfxDbgPrint(("UDFX: found NSR02 descriptor without BEA01 descriptor\n"));
                    break;
                }

            } else if (VsdIdent == VsdIdentTEA01) {

                //
                // Terminating Extended Area descriptor.  This marks the end of
                // the descriptors that could mark a UDF volume.
                //

                break;
            }

        } else if ((VolumeStructureDescriptor->Type < 3) ||
            (VolumeStructureDescriptor->Type == 255)) {

            if (FoundBEA) {
                UdfxDbgPrint(("UDFX: found unexpected descriptors after BEA01\n"));
                break;
            }

            if ((VsdIdent != VsdIdentCDROM) && (VsdIdent != VsdIdentCD001)) {
                UdfxDbgPrint(("UDFX: unknown VSD type\n"));
                break;
            }

        } else {

            UdfxDbgPrint(("UDFX: unknown VSD type\n"));
            break;
        }

        //
        // Advance to the next sector.
        //

        PhysicalSectorNumber++;
    }

    ExFreePool(VolumeStructureDescriptor);

    return status;
}

NTSTATUS
UdfxProcessAnchorVolumeDescriptor(
    IN PUDF_VOLUME_EXTENSION VolumeExtension,
    OUT PEXTENTAD MainVolumeDescriptorSequenceExtent
    )
/*++

Routine Description:

    This routine finds the anchor volume descriptor from the supplied device.

    Refer to ISO 13346 section 3/8.4.

Arguments:

    VolumeExtension - Specifies the extension for the volume to mount.

    MainVolumeDescriptorSequenceExtent - Specifies the location to receive the
        main volume descriptor sequence extent from the anchor (3/10.2.2).

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    PNSR_ANCHOR AnchorVolumeDescriptor;

    //
    // Allocate a buffer to read the descriptors into.  The buffer size must be
    // aligned to the size of a CD-ROM sector.
    //

    AnchorVolumeDescriptor = (PNSR_ANCHOR)ExAllocatePoolWithTag(UDF_CD_SECTOR_SIZE,
        'vAxU');

    if (AnchorVolumeDescriptor == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Read the anchor volume descriptor from its typical location.
    //

    status = UdfxReadPhysicalSector(VolumeExtension, ANCHOR_SECTOR,
        AnchorVolumeDescriptor);

    if (NT_SUCCESS(status)) {

        if (UdfxVerifyDescriptor(&AnchorVolumeDescriptor->Destag,
            sizeof(NSR_ANCHOR), DESTAG_ID_NSR_ANCHOR, ANCHOR_SECTOR)) {

            //
            // Return the interesting fields from the descriptor back to the
            // caller.
            //

            *MainVolumeDescriptorSequenceExtent = AnchorVolumeDescriptor->Main;

            status = STATUS_SUCCESS;

        } else {

            UdfxDbgPrint(("UDFX: anchor volume descriptor not valid\n"));
            status = STATUS_DISK_CORRUPT_ERROR;
        }
    }

    ExFreePool(AnchorVolumeDescriptor);

    return status;
}

BOOLEAN
UdfxProcessPrimaryVolumeDescriptor(
    IN PNSR_PVD PrimaryVolumeDescriptor
    )
/*++

Routine Description:

    This routine validates and pulls out any interesting information from the
    supplied primary volume descriptor.

    Refer to ISO 13346 section 3/10.1.

Arguments:

    PrimaryVolumeDescriptor - Specifies the descriptor to process.

Return Value:

    Returns TRUE if the descriptor is valid, else FALSE.

--*/
{
    //
    // Verify that the volume is a single volume set.  Note that we ignore
    // VolSetSeqMax because some DVDs are authored incorrectly (Snow White).
    //

    if (PrimaryVolumeDescriptor->VolSetSeq > 1) {
        UdfxDbgPrint(("UDFX: invalid primary volume descriptor (line %d)\n", __LINE__));
        return FALSE;
    }

    //
    // Verify that the volume is using only the CS0 character set.
    //

    if ((PrimaryVolumeDescriptor->CharSetList != (1 << CHARSPEC_T_CS0)) ||
        (PrimaryVolumeDescriptor->CharSetListMax != (1 << CHARSPEC_T_CS0))) {
        UdfxDbgPrint(("UDFX: invalid primary volume descriptor (line %d)\n", __LINE__));
        return FALSE;
    }

    //
    // Verify that the volume is using the UDF domain character set.
    //

    if (!RtlEqualMemory(&PrimaryVolumeDescriptor->CharsetDesc,
            &UdfxCS0Identifier, sizeof(CHARSPEC)) ||
        !RtlEqualMemory(&PrimaryVolumeDescriptor->CharsetExplan,
            &UdfxCS0Identifier, sizeof(CHARSPEC))) {
        UdfxDbgPrint(("UDFX: invalid primary volume descriptor (line %d)\n", __LINE__));
        return FALSE;
    }

    return TRUE;
}

BOOLEAN
UdfxProcessPartitionDescriptor(
    IN PNSR_PART PartitionDescriptor,
    IN PUDF_VOLUME_EXTENSION VolumeExtension,
    OUT PUSHORT PartitionNumber
    )
/*++

Routine Description:

    This routine validates and pulls out any interesting information from the
    supplied partition descriptor.

    Refer to ISO 13346 section 3/10.5.

Arguments:

    PartitionDescriptor - Specifies the descriptor to process.

    VolumeExtension - Specifies the extension for the volume to mount.

    PartitionNumber - Specifies the buffer to receive the expected partition
        number.

Return Value:

    Returns TRUE if the descriptor is valid, else FALSE.

--*/
{
    //
    // Verify that the partition's content identifier is valid.
    //

    if (!RtlEqualMemory(&PartitionDescriptor->ContentsID.Identifier,
        &UdfxNSR02Regid, REGID_LENGTH_IDENT)) {
        UdfxDbgPrint(("UDFX: invalid partition descriptor (line %d)\n", __LINE__));
        return FALSE;
    }

    //
    // The descriptor appears to be valid.  Return any interesting information
    // in the volume extension and to the caller.
    //

    VolumeExtension->PartitionSectorStart = PartitionDescriptor->Start;
    VolumeExtension->PartitionSectorCount = PartitionDescriptor->Length;

    VolumeExtension->PartitionLength.QuadPart =
    VolumeExtension->VolumeFcb->FileSize.QuadPart =
        ((ULONGLONG)VolumeExtension->PartitionSectorStart +
        VolumeExtension->PartitionSectorCount) << UDF_CD_SECTOR_SHIFT;

    *PartitionNumber = PartitionDescriptor->Number;

    return TRUE;
}

BOOLEAN
UdfxProcessLogicalVolumeDescriptor(
    IN PNSR_LVOL LogicalVolumeDescriptor,
    IN PLONGAD FileSetDescriptorExtent,
    IN PUSHORT PartitionNumber
    )
/*++

Routine Description:

    This routine validates and pulls out any interesting information from the
    supplied logical volume descriptor.

    Refer to ISO 13346 section 3/10.6.

Arguments:

    LogicalVolumeDescriptor - Specifies the descriptor to process.

    FileSetDescriptorExtent - Specifies the buffer to receive the extents of the
        file set descriptor for the volume.

    PartitionNumber - Specifies the buffer to receive the expected partition
        number.

Return Value:

    Returns TRUE if the descriptor is valid, else FALSE.

--*/
{
    USHORT UdfVersion;
    PPARTMAP_PHYSICAL PartitionMap;

    //
    // Verify that the descriptor's size doesn't exceed the size of a sector
    // and that the volume's block size is equal to the device's sector size.
    //

    if ((ISONsrLvolSize(LogicalVolumeDescriptor) > UDF_CD_SECTOR_SIZE) ||
        (LogicalVolumeDescriptor->BlockSize != UDF_CD_SECTOR_SIZE)) {
        UdfxDbgPrint(("UDFX: invalid logical volume descriptor (line %d)\n", __LINE__));
        return FALSE;
    }

    //
    // Verify that the volume is using the UDF domain.
    //

    if (!RtlEqualMemory(&LogicalVolumeDescriptor->DomainID.Identifier,
        &UdfxOSTAUdfRegid, REGID_LENGTH_IDENT)) {
        UdfxDbgPrint(("UDFX: invalid logical volume descriptor (line %d)\n", __LINE__));
        return FALSE;
    }

    //
    // Verify that this is a supported UDF version.
    //

    UdfVersion = *((PUSHORT)&LogicalVolumeDescriptor->DomainID.Suffix[0]);

    if ((UdfVersion < UDF_VERSION_MINIMUM) || (UdfVersion > UDF_VERSION_MAXIMUM)) {
        UdfxDbgPrint(("UDFX: unsupported UDF version %04x\n", UdfVersion));
        return FALSE;
    }

    //
    // Verify that the volume is using the UDF domain character set.
    //

    if (!RtlEqualMemory(&LogicalVolumeDescriptor->Charset, &UdfxCS0Identifier,
        sizeof(CHARSPEC))) {
        UdfxDbgPrint(("UDFX: invalid logical volume descriptor (line %d)\n", __LINE__));
        return FALSE;
    }

    //
    // Only allow one partition in the logical volume (level 1 medium
    // interchange).
    //

    if ((LogicalVolumeDescriptor->MapTableCount > 1) ||
        (LogicalVolumeDescriptor->MapTableLength < sizeof(PARTMAP_PHYSICAL))) {
        UdfxDbgPrint(("UDFX: invalid logical volume descriptor (line %d)\n", __LINE__));
        return FALSE;
    }

    //
    // Verify that this is a physical partition type of the expected size and
    // that this is a single volume set.
    //

    PartitionMap = (PPARTMAP_PHYSICAL)LogicalVolumeDescriptor->MapTable;

    if ((PartitionMap->Type != PARTMAP_TYPE_PHYSICAL) ||
        (PartitionMap->Length != sizeof(PARTMAP_PHYSICAL)) ||
        (PartitionMap->VolSetSeq > 1)) {
        UdfxDbgPrint(("UDFX: invalid partition map descriptor (line %d)\n", __LINE__));
        return FALSE;
    }

    //
    // The descriptor appears to be valid.  Return any interesting information
    // back to the caller.
    //

    *FileSetDescriptorExtent = LogicalVolumeDescriptor->FSD;
    *PartitionNumber = PartitionMap->Partition;

    return TRUE;
}

NTSTATUS
UdfxProcessVolumeDescriptorSequence(
    IN PUDF_VOLUME_EXTENSION VolumeExtension,
    IN PEXTENTAD VolumeDescriptorSequenceExtent,
    OUT PLONGAD FileSetDescriptorExtent
    )
/*++

Routine Description:

    This routine processes the volume data structures bounded by the supplied
    volume descriptor sequence extents.

Arguments:

    VolumeExtension - Specifies the extension for the volume to mount.

    VolumeDescriptorSequenceExtent - Specifies the extents of the volume
        descriptor sequence area.

    FileSetDescriptorExtent - Specifies the buffer to receive the extents of the
        file set descriptor for the volume.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    PNSR_VD_GENERIC VolumeDataStructure;
    BOOLEAN SeenPrimaryVolumeDescriptor;
    ULONG PrevailingPVDVolDescSeqNum;
    BOOLEAN SeenPartitionDescriptor;
    ULONG PrevailingPartitionVolDescSeqNum;
    BOOLEAN SeenLogicalVolumeDescriptor;
    ULONG PrevailingLVOLVolDescSeqNum;
    USHORT PartitionNumber;
    USHORT ExpectedPartitionNumber;
    ULONG LogicalSectorNumber;
    ULONG EndingLogicalSectorNumber;
    PNSR_PVD PrimaryVolumeDescriptor;
    PNSR_LVOL LogicalVolumeDescriptor;
    PNSR_PART PartitionDescriptor;

    //
    // Verify that the extent is correctly formed (3/7.1).
    //

    if ((VolumeDescriptorSequenceExtent->Len == 0) ||
        !UdfxIsSectorAligned(VolumeDescriptorSequenceExtent->Len)) {
        return STATUS_DISK_CORRUPT_ERROR;
    }

    //
    // Allocate a buffer to read the descriptors into.  The buffer size must be
    // aligned to the size of a CD-ROM sector.
    //

    VolumeDataStructure = (PNSR_VD_GENERIC)ExAllocatePoolWithTag(UDF_CD_SECTOR_SIZE,
        'dVxU');

    if (VolumeDataStructure == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Reset the state variables before we begin processing the descriptors.
    //

    SeenPrimaryVolumeDescriptor = FALSE;
    PrevailingPVDVolDescSeqNum = 0;
    SeenPartitionDescriptor = FALSE;
    PrevailingPartitionVolDescSeqNum = 0;
    SeenLogicalVolumeDescriptor = FALSE;
    PrevailingLVOLVolDescSeqNum = 0;
    PartitionNumber = 0;
    ExpectedPartitionNumber = 0;

    //
    // The volume descriptor sequence area starts at the sector given in the
    // supplied extent structure.
    //

    status = STATUS_UNRECOGNIZED_VOLUME;
    LogicalSectorNumber = VolumeDescriptorSequenceExtent->Lsn;
    EndingLogicalSectorNumber = LogicalSectorNumber +
        (VolumeDescriptorSequenceExtent->Len >> UDF_CD_SECTOR_SHIFT);

    //
    // Process the volume data structures.
    //

    while (LogicalSectorNumber < EndingLogicalSectorNumber) {

        //
        // Read the next volume data structure.
        //

        status = UdfxReadPhysicalSector(VolumeExtension, LogicalSectorNumber,
            VolumeDataStructure);

        if (!NT_SUCCESS(status)) {
            break;
        }

        //
        // Set up the error code for an invalid UDF volume.
        //

        status = STATUS_UNRECOGNIZED_VOLUME;

        //
        // Verify that this is a valid volume data structure.
        //

        if (!UdfxVerifyDescriptor(&VolumeDataStructure->Destag,
            sizeof(NSR_VD_GENERIC), VolumeDataStructure->Destag.Ident,
            LogicalSectorNumber)) {
            UdfxDbgPrint(("UDFX: invalid descriptor (line %d)\n", __LINE__));
            break;
        }

        //
        // Process the volume data structure.
        //

        if (VolumeDataStructure->Destag.Ident == DESTAG_ID_NSR_PVD) {

            //
            // If we find a primary volume descriptor, then process it if it's
            // the prevailing descriptor.
            //

            PrimaryVolumeDescriptor = (PNSR_PVD)VolumeDataStructure;

            if (PrimaryVolumeDescriptor->VolDescSeqNum >=
                PrevailingPVDVolDescSeqNum) {

                SeenPrimaryVolumeDescriptor =
                    UdfxProcessPrimaryVolumeDescriptor(PrimaryVolumeDescriptor);

                PrevailingPVDVolDescSeqNum =
                    PrimaryVolumeDescriptor->VolDescSeqNum;
            }

        } else if (VolumeDataStructure->Destag.Ident == DESTAG_ID_NSR_PART) {

            //
            // If we find a partition descriptor, then process it if it's the
            // prevailing descriptor.
            //

            PartitionDescriptor = (PNSR_PART)VolumeDataStructure;

            if (PartitionDescriptor->VolDescSeqNum >=
                PrevailingPartitionVolDescSeqNum) {

                SeenPartitionDescriptor =
                    UdfxProcessPartitionDescriptor(PartitionDescriptor,
                    VolumeExtension, &PartitionNumber);

                PrevailingPartitionVolDescSeqNum =
                    PartitionDescriptor->VolDescSeqNum;
            }

        } else if (VolumeDataStructure->Destag.Ident == DESTAG_ID_NSR_LVOL) {

            //
            // If we find a logical volume descriptor, then process it if it's
            // the prevailing descriptor.
            //

            LogicalVolumeDescriptor = (PNSR_LVOL)VolumeDataStructure;

            if (LogicalVolumeDescriptor->VolDescSeqNum >=
                PrevailingLVOLVolDescSeqNum) {

                SeenLogicalVolumeDescriptor =
                    UdfxProcessLogicalVolumeDescriptor(LogicalVolumeDescriptor,
                    FileSetDescriptorExtent, &ExpectedPartitionNumber);

                PrevailingLVOLVolDescSeqNum =
                    LogicalVolumeDescriptor->VolDescSeqNum;
            }

        } else if (VolumeDataStructure->Destag.Ident == DESTAG_ID_NSR_TERM) {

            //
            // If we find the terminating descriptor, then we're at the end of
            // the data structures we care about.
            //
            // Refer to ISO 13346 section 3/10.9.
            //

            if (SeenPrimaryVolumeDescriptor && SeenLogicalVolumeDescriptor &&
                SeenPartitionDescriptor &&
                (PartitionNumber == ExpectedPartitionNumber)) {
                status = STATUS_SUCCESS;
            }

            break;
        }

        //
        // Advance to the next sector.
        //

        LogicalSectorNumber++;
    }

    ExFreePool(VolumeDataStructure);

    return status;
}

NTSTATUS
UdfxProcessFileSetDescriptor(
    IN PUDF_VOLUME_EXTENSION VolumeExtension,
    IN PLONGAD FileSetDescriptorExtent,
    OUT PLONGAD IcbRoot
    )
/*++

Routine Description:

    This routine processes the file set descriptor.  The search for the
    prevailing descriptor begins at the supplied extent.

    Refer to ISO 13346 section 4/14.1.

Arguments:

    VolumeDeviceObject - Specifies the volume device object that's being
        mounted.

    FileSetDescriptorExtent - Specifies the extent of the file set descriptor.

    IcbRoot - Specifies the buffer to receive the extent of the root directory
        ICB.

Return Value:

    Returns TRUE if the descriptor is valid, else FALSE.

--*/
{
    NTSTATUS status;
    PNSR_VD_GENERIC VolumeDataStructure;
    BOOLEAN SeenFileSetDescriptor;
    ULONG PrevailingFSDFileSet;
    ULONG LogicalSectorNumber;
    ULONG EndingLogicalSectorNumber;
    PNSR_FSD FileSetDescriptor;

    //
    // Verify that the extent is correctly formed (4/14.1);
    //

    if ((FileSetDescriptorExtent->Length.Length == 0) ||
        (FileSetDescriptorExtent->Length.Type != NSRLENGTH_TYPE_RECORDED) ||
        !UdfxIsSectorAligned(FileSetDescriptorExtent->Length.Length)) {
        return STATUS_DISK_CORRUPT_ERROR;
    }

    //
    // Allocate a buffer to read the descriptors into.  The buffer size must be
    // aligned to the size of a CD-ROM sector.
    //

    VolumeDataStructure = (PNSR_VD_GENERIC)ExAllocatePoolWithTag(UDF_CD_SECTOR_SIZE,
        'dVxU');

    if (VolumeDataStructure == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Reset the state variables before we begin processing the descriptors.
    //

    SeenFileSetDescriptor = FALSE;
    PrevailingFSDFileSet = 0;

    //
    // The first file set descriptor starts at the sector given in the
    // supplied extent structure.
    //

    status = STATUS_DISK_CORRUPT_ERROR;
    LogicalSectorNumber = FileSetDescriptorExtent->Start.Lbn;
    EndingLogicalSectorNumber = LogicalSectorNumber +
        (FileSetDescriptorExtent->Length.Length >> UDF_CD_SECTOR_SHIFT);

    //
    // Process the volume data structures.
    //

    while (LogicalSectorNumber < EndingLogicalSectorNumber) {

        //
        // Verify that the logical sector resides inside the physical partition.
        //

        if (LogicalSectorNumber >= VolumeExtension->PartitionSectorCount) {
            break;
        }

        //
        // Read the next volume data structure.
        //

        status = UdfxReadPhysicalSector(VolumeExtension,
            VolumeExtension->PartitionSectorStart + LogicalSectorNumber,
            VolumeDataStructure);

        if (!NT_SUCCESS(status)) {
            break;
        }

        //
        // Set up the error code for a corrupt UDF volume.
        //

        status = STATUS_DISK_CORRUPT_ERROR;

        //
        // Verify that this is a valid volume data structure.
        //

        if (!UdfxVerifyDescriptor(&VolumeDataStructure->Destag,
            sizeof(NSR_VD_GENERIC), VolumeDataStructure->Destag.Ident,
            LogicalSectorNumber)) {
            UdfxDbgPrint(("UDFX: invalid descriptor (line %d)\n", __LINE__));
            break;
        }

        //
        // Process the volume data structure.
        //

        if (VolumeDataStructure->Destag.Ident == DESTAG_ID_NSR_FSD) {

            //
            // If we find a file set descriptor, then process it if it's the
            // prevailing descriptor.
            //

            FileSetDescriptor = (PNSR_FSD)VolumeDataStructure;

            if (FileSetDescriptor->FileSet >= PrevailingFSDFileSet) {

                *IcbRoot = FileSetDescriptor->IcbRoot;

                PrevailingFSDFileSet = FileSetDescriptor->FileSet;
                SeenFileSetDescriptor = TRUE;

                if (FileSetDescriptor->NextExtent.Length.Length != 0) {

                    //
                    // The next extent is not zero, so verify that the extent is
                    // valid and restart the loop at the new extent.
                    //

                    if ((FileSetDescriptor->NextExtent.Length.Type != NSRLENGTH_TYPE_RECORDED) ||
                        !UdfxIsSectorAligned(FileSetDescriptor->NextExtent.Length.Length)) {
                        break;
                    }

                    LogicalSectorNumber = FileSetDescriptor->NextExtent.Start.Lbn;
                    EndingLogicalSectorNumber = LogicalSectorNumber +
                        (FileSetDescriptor->NextExtent.Length.Length >>
                        UDF_CD_SECTOR_SHIFT);

                    continue;
                }
            }

        } else if (VolumeDataStructure->Destag.Ident == DESTAG_ID_NSR_TERM) {

            //
            // If we find the terminating descriptor, then we're at the end of
            // the data structures we care about.
            //
            // Refer to ISO 13346 section 4/14.2.
            //

            if (SeenFileSetDescriptor) {
                status = STATUS_SUCCESS;
            }

            break;

        } else {

            //
            // An invalid descriptor was found.  Terminate the loop since we
            // have no idea what we're in the middle of now.
            //

            break;
        }

        //
        // Advance to the next sector.
        //

        LogicalSectorNumber++;
    }

    ExFreePool(VolumeDataStructure);

    return status;
}

NTSTATUS
UdfxMountVolume(
    IN PDEVICE_OBJECT TargetDeviceObject
    )
/*++

Routine Description:

    This routine is called by the I/O manager to attempt to mount this file
    system.

Arguments:

    TargetDeviceObject - Specifies the device object to attempt to mount.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    PIRP Irp;
    PDEVICE_OBJECT VolumeDeviceObject;
    PUDF_VOLUME_EXTENSION VolumeExtension;
    DISK_GEOMETRY DiskGeometry;
    EXTENTAD MainVolumeDescriptorSequenceExtent;
    LONGAD FileSetDescriptorExtent;
    LONGAD IcbRoot;

    Irp = NULL;
    VolumeDeviceObject = NULL;

    UdfxAcquireGlobalMutexExclusive();

    //
    // Get the drive geometry from the device.
    //

    status = IoSynchronousDeviceIoControlRequest(IOCTL_CDROM_GET_DRIVE_GEOMETRY,
        TargetDeviceObject, NULL, 0, &DiskGeometry, sizeof(DISK_GEOMETRY), NULL,
        FALSE);

    if (!NT_SUCCESS(status)) {
        goto CleanupAndExit;
    }

    ASSERT(DiskGeometry.Cylinders.HighPart == 0);
    ASSERT(DiskGeometry.TracksPerCylinder == 1);
    ASSERT(DiskGeometry.SectorsPerTrack == 1);
    ASSERT(DiskGeometry.BytesPerSector == UDF_CD_SECTOR_SIZE);

    //
    // Create an I/O request packet in order to submit requests to the target
    // device.
    //

    Irp = IoAllocateIrp(TargetDeviceObject->StackSize);

    if (Irp == NULL) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto CleanupAndExit;
    }

    //
    // Create the volume's device object.
    //

    status = UdfxCreateVolumeDevice(TargetDeviceObject, &DiskGeometry,
        &VolumeDeviceObject);

    if (!NT_SUCCESS(status)) {
        goto CleanupAndExit;
    }

    VolumeExtension = (PUDF_VOLUME_EXTENSION)VolumeDeviceObject->DeviceExtension;

    //
    // See if we can recognize a UDF volume in the device.
    //

    status = UdfxRecognizeVolume(VolumeExtension);

    if (!NT_SUCCESS(status)) {
        goto CleanupAndExit;
    }

    //
    // Process the anchor volume descriptor for the volume.
    //

    status = UdfxProcessAnchorVolumeDescriptor(VolumeExtension,
        &MainVolumeDescriptorSequenceExtent);

    if (!NT_SUCCESS(status)) {
        goto CleanupAndExit;
    }

    //
    // Process the volume data structures for the volume.
    //

    status = UdfxProcessVolumeDescriptorSequence(VolumeExtension,
        &MainVolumeDescriptorSequenceExtent, &FileSetDescriptorExtent);

    if (!NT_SUCCESS(status)) {
        goto CleanupAndExit;
    }

    //
    // Process the file set descriptor for the volume.
    //

    status = UdfxProcessFileSetDescriptor(VolumeExtension,
        &FileSetDescriptorExtent, &IcbRoot);

    if (!NT_SUCCESS(status)) {
        goto CleanupAndExit;
    }

    //
    // Create the file control block for the root directory.
    //

    status = UdfxCreateFcbFromFileEntry(VolumeExtension, Irp, &IcbRoot, NULL,
        NULL, &VolumeExtension->RootDirectoryFcb);

    if (!NT_SUCCESS(status)) {
        goto CleanupAndExit;
    }

    VolumeExtension->RootDirectoryFcb->Flags |= UDF_FCB_ROOT_DIRECTORY;

    //
    // Connect the volume device object to the target device object and return
    // success.
    //

    TargetDeviceObject->MountedOrSelfDevice = VolumeDeviceObject;
    VolumeDeviceObject = NULL;

    status = STATUS_SUCCESS;

CleanupAndExit:
    if (VolumeDeviceObject != NULL) {
        UdfxDeleteVolumeDevice(VolumeDeviceObject);
    }

    if (Irp != NULL) {
        IoFreeIrp(Irp);
    }

    UdfxReleaseGlobalMutex();

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\udfx\iso13346.h ===
/***    ISO13346.H - ISO 13346 File System Disk Format
 *
 *      Microsoft Confidential
 *      Copyright (C) Microsoft Corporation 1996-2001
 *      All Rights Reserved
 *
 *      This file defines the ISO 13346 Data Structures.
 *
 *      The UDF file system uses these data structures to interpret the
 *      media's contents.
 *
 */

//
//  All 13346 structures are aligned on natural boundaries even though it will
//  not be obvious to the compiler.  Disable compiler smarts for the duration
//  of the ISO definitions.
//
//  As an example, the LONGAD definition is {ULONG {ULONG USHORT} UCHAR[6]} and
//  normal packing will pad out the internal NSRLBA, nevermind that the UCHAR
//  reserved field is doing exactly that.
//

#pragma pack(1)

/***    ISO 13346 Part 1: General
 *
 *
 */

/***    charspec - Character Set Specification (1/7.2.1)
 *
 */

typedef struct  CHARSPEC {
    UCHAR       Type;                   // Character Set Type (CHARSPEC_T_...)
    UCHAR       Info[63];               // Character Set Information
} CHARSPEC, *PCHARSPEC;

//  CHARSPEC_T_... - Values for charspec_Type Character Set Types (1/7.2.1.1)

#define CHARSPEC_T_CS0  0               // By Agreement
#define CHARSPEC_T_CS1  1               // Unicode (according to ISO 2022)
#define CHARSPEC_T_CS2  2               // 38 Glyphs
#define CHARSPEC_T_CS3  3               // 65 Glyphs
#define CHARSPEC_T_CS4  4               // 95 Glyphs
#define CHARSPEC_T_CS5  5               // 191 Glyphs
#define CHARSPEC_T_CS6  6               // Unicode or ISO 2022
#define CHARSPEC_T_CS7  7               // Unicode or ISO 2022
#define CHARSPEC_T_CS8  8               // 53 Glyphs

/***    timestamp - Timestamp Structure (1/7.3)
 *
 */

typedef struct  TIMESTAMP {
    SHORT       Zone:12;                // Time Zone (+-1440 minutes from CUT)
    USHORT      Type:4;                 // Timestamp Type (TIMESTAMP_T_...)
    USHORT      Year;                   // Year (1..9999)
    UCHAR       Month;                  // Month (1..12)
    UCHAR       Day;                    // Day (1..31)
    UCHAR       Hour;                   // Hour (0..23)
    UCHAR       Minute;                 // Minute (0..59)
    UCHAR       Second;                 // Second (0..59)
    UCHAR       CentiSecond;            // Centiseconds (0..99)
    UCHAR       Usec100;                // Hundreds of microseconds (0..99)
    UCHAR       Usec;                   // microseconds (0..99)
} TIMESTAMP, *PTIMESTAMP;

//  TIMESTAMP_T_... - Values for timestamp_Type (1/7.3.1)

#define TIMESTAMP_T_CUT         0       // Coordinated Universal Time
#define TIMESTAMP_T_LOCAL       1       // Local Time
#define TIMESTAMP_T_AGREEMENT   2       // Time format by agreement

//  TIMESTAMP_Z_... Values for timestamp_Zone

#define TIMESTAMP_Z_MIN         (-1440) // Minimum timezone offset (minutes)
#define TIMESTAMP_Z_MAX         ( 1440) // Maximum timezone offset (minutes)
#define TIMESTAMP_Z_NONE        (-2047) // No timezone in timestamp_Zone


/****   regid - Entity Identifier (1/7.4)
 *
 */

typedef struct  REGID {
    UCHAR       Flags;                  // Flags (REGID_F_...)
    UCHAR       Identifier[23];         // Identifier
    UCHAR       Suffix[8];              // Identifier Suffix
} REGID, *PREGID;

//  REGID_F_... - Definitions for regid_Flags bits

#define REGID_F_DIRTY           (0x01)  // Information Modified
#define REGID_F_PROTECTED       (0x02)  // Changes Locked Out

//  REGID_LENGTH_... - regid field lengths

#define REGID_LENGTH_IDENT      23      // Length of regid_Identifier (bytes)
#define REGID_LENGTH_SUFFIX     8       // Length of regid_Suffix (bytes)

//  REGID_ID_... - Values for regid_Identifier[0]

#define REGID_ID_ISO13346       (0x2B)  // regid_Identifier within ISO 13346
#define REGID_ID_NOTREGISTERED  (0x2D)  // regid_Identifier is not registered


/***    Various Structures from Parts 3 and 4 moved here for compilation.
 *
 */


/***    extentad - Extent Address Descriptor (3/7.1)
 *
 */

typedef struct  EXTENTAD {
    ULONG       Len;                    // Extent Length in Bytes
    ULONG       Lsn;                    // Extent Logical Sector Number
} EXTENTAD, *PEXTENTAD;


/***    nsr_lba - Logical Block Address (4/7.1) (lb_addr)
 *
 */

typedef struct  NSRLBA {
    ULONG       Lbn;                    // Logical Block Number
    USHORT      Partition;              // Partition Reference Number
} NSRLBA, *PNSRLBA;


/***    nsr_length - Format of a NSR allocation descriptor length field (4/14.14.1.1)
 *
 *          This is hands-down one of the most stupid things in 13346
 */

typedef struct NSRLENGTH {
    ULONG       Length:30;
    ULONG       Type:2;
} NSRLENGTH, *PNSRLENGTH;

#define NSRLENGTH_TYPE_RECORDED         0
#define NSRLENGTH_TYPE_UNRECORDED       1
#define NSRLENGTH_TYPE_UNALLOCATED      2
#define NSRLENGTH_TYPE_CONTINUATION     3


/***    Short Allocation Descriptor (4/14.14.1)
 *
 *      Note that a SHORTAD precisely overlaps a LONGAD.  Use this by defining
 *      a generic allocation descriptor structure.
 */

typedef struct  SHORTAD {
    NSRLENGTH   Length;                 // Extent Length
    ULONG       Start;                  // Extent Logical Block Number
} SHORTAD, *PSHORTAD;

typedef SHORTAD AD_GENERIC, *PAD_GENERIC;


/***    Long Allocation Descriptor (4/14.14.2)
 *
 */

typedef struct  LONGAD {
    NSRLENGTH   Length;                 // Extent Length
    NSRLBA      Start;                  // Extent Location
    UCHAR       ImpUse[6];              // Implementation Use
} LONGAD, *PLONGAD;


/***    Extended Allocation Descriptor (4/14.14.3)
 *
 */

typedef struct  EXTAD {
    NSRLENGTH   ExtentLen;              // Extent Length
    NSRLENGTH   RecordedLen;            // Recorded Length
    ULONG       InfoLen;                // Information Length
    NSRLBA      Start;                  // Extent Location
    UCHAR       ImpUse[2];              // Implementation Use
} EXTAD, *PEXTAD;

/***    ISO 13346 Part 2: Volume and Boot Block Recognition
 *
 *
 */


/***    vsd_generic - Generic Volume Structure Descriptor (2/9.1)
 *
 */

typedef struct  VSD_GENERIC {
    UCHAR       Type;                   // Structure Type
    UCHAR       Ident[5];               // Standard Identifier
    UCHAR       Version;                // Standard Version
    UCHAR       Data[2041];             // Structure Data
} VSD_GENERIC, *PVSD_GENERIC;

//  VSD_LENGTH_... - vsd field lengths

#define VSD_LENGTH_IDENT        5       // Length of regid_Identifier (bytes)

//  VSD_IDENT_... - Values for vsd_generic_Ident

#define VSD_IDENT_BEA01     "BEA01"     // Begin Extended Area
#define VSD_IDENT_TEA01     "TEA01"     // Terminate Extended Area
#define VSD_IDENT_CDROM     "CDROM"     // High Sierra Group (pre-ISO 9660)
#define VSD_IDENT_CD001     "CD001"     // ISO 9660
#define VSD_IDENT_CDW01     "CDW01"     // ECMA 168
#define VSD_IDENT_CDW02     "CDW02"     // ISO 13490
#define VSD_IDENT_NSR01     "NSR01"     // ECMA 167
#define VSD_IDENT_NSR02     "NSR02"     // ISO 13346
#define VSD_IDENT_BOOT2     "BOOT2"     // Boot Descriptor

typedef enum _VSD_IDENT {
    VsdIdentBad = 0,
    VsdIdentBEA01,
    VsdIdentTEA01,
    VsdIdentCDROM,
    VsdIdentCD001,
    VsdIdentCDW01,
    VsdIdentCDW02,
    VsdIdentNSR01,
    VsdIdentNSR02,
    VsdIdentBOOT2
} VSD_IDENT, *PVSD_IDENT;

/***    vsd_bea01 - Begin Extended Area Descriptor (2/9.2)
 *
 */

typedef struct  VSD_BEA01 {
    UCHAR       Type;                   // Structure Type
    UCHAR       Ident[5];               // Standard Identifier ('BEA01')
    UCHAR       Version;                // Standard Version
    UCHAR       Data[2041];             // Structure Data
} VSD_BEA01, *PVSD_BEA01;


/***    vsd_tea01 - Terminate Extended Area Descriptor (2/9.3)
 *
 */

typedef struct  VSD_TEA01 {
    UCHAR       Type;                   // Structure Type
    UCHAR       Ident[5];               // Standard Identifier ('TEA01')
    UCHAR       Version;                // Standard Version
    UCHAR       Data[2041];             // Structure Data
} VSD_TEA01, *PVSD_TEA01;


/***    vsd_boot2 - Boot Descriptor (2/9.4)
 *
 */

typedef struct  VSD_BOOT2 {
    UCHAR       Type;                   // Structure Type
    UCHAR       Ident[5];               // Standard Identifier ('BOOT2')
    UCHAR       Version;                // Standard Version
    UCHAR       Res8;                   // Reserved Zero
    REGID       Architecture;           // Architecture Type
    REGID       BootIdent;              // Boot Identifier
    ULONG       BootExt;                // Boot Extent Start
    ULONG       BootExtLen;             // Boot Extent Length
    ULONG       LoadAddr[2];            // Load Address
    ULONG       StartAddr[2];           // Start Address
    TIMESTAMP   Timestamp;              // Creation Time
    USHORT      Flags;                  // Flags (VSD_BOOT2_F_...)
    UCHAR       Res110[32];             // Reserved Zeros
    UCHAR       BootUse[1906];          // Boot Use
} VSD_BOOT2, *PVSD_BOOT2;

//  VSD_BOOT2_F_... - Definitions for vsd_boot2_Flags bits

#define VSD_BOOT2_F_ERASE   (0x0001)    // Ignore previous similar BOOT2 vsds

//
//  Aligning this byte offset to a sector boundary by rounding up will
//  yield the starting offset of the Volume Recognition Area (2/8.3)
//

#define VRA_BOUNDARY_LOCATION (32767 + 1)

/***    ISO 13346 Part 3: Volume Structure
 *
 *
 */

/***    destag - Descriptor Tag (3/7.1 and 4/7.2)
 *
 *      destag_Checksum = Byte sum of bytes 0-3 and 5-15 of destag.
 *
 *      destag_CRC = CRC (X**16 + X**12 + X**5 + 1)
 *
 */

typedef struct  DESTAG {
    USHORT      Ident;                  // Tag Identifier
    USHORT      Version;                // Descriptor Version
    UCHAR       Checksum;               // Tag Checksum
    UCHAR       Res5;                   // Reserved
    USHORT      Serial;                 // Tag Serial Number
    USHORT      CRC;                    // Descriptor CRC
    USHORT      CRCLen;                 // Descriptor CRC Length
    ULONG       Lbn;                    // Tag Location (Logical Block Number)
} DESTAG, *PDESTAG;

//  DESTAG_ID_... - Values for destag_Ident
//  Descriptor Tag Values from NSR Part 3 (3/7.2.1)

#define DESTAG_ID_NOTSPEC           0   // Format Not Specified
#define DESTAG_ID_NSR_PVD           1   // (3/10.1) Primary Volume Descriptor
#define DESTAG_ID_NSR_ANCHOR        2   // (3/10.2) Anchor Volume Desc Pointer
#define DESTAG_ID_NSR_VDP           3   // (3/10.3) Volume Descriptor Pointer
#define DESTAG_ID_NSR_IMPUSE        4   // (3/10.4) Implementation Use Vol Desc
#define DESTAG_ID_NSR_PART          5   // (3/10.5) Partition Descriptor
#define DESTAG_ID_NSR_LVOL          6   // (3/10.6) Logical Volume Descriptor
#define DESTAG_ID_NSR_UASD          7   // (3/10.8) Unallocated Space Desc
#define DESTAG_ID_NSR_TERM          8   // (3/10.9) Terminating Descriptor
#define DESTAG_ID_NSR_LVINTEG       9   // (3/10.10) Logical Vol Integrity Desc

#define DESTAG_ID_MINIMUM_PART3     1   // The lowest legal DESTAG in Part 3
#define DESTAG_ID_MAXIMUM_PART3     9   // The highest legal DESTAG in Part 3

//  DESTAG_ID_... - Values for destag_Ident, continued...
//  Descriptor Tag Values from NSR Part 4 (4/7.2.1)

#define DESTAG_ID_NSR_FSD           256 // (4/14.1) File Set Descriptor
#define DESTAG_ID_NSR_FID           257 // (4/14.4) File Identifier Descriptor
#define DESTAG_ID_NSR_ALLOC         258 // (4/14.5) Allocation Extent Desc
#define DESTAG_ID_NSR_ICBIND        259 // (4/14.7) ICB Indirect Entry
#define DESTAG_ID_NSR_ICBTRM        260 // (4/14.8) ICB Terminal Entry
#define DESTAG_ID_NSR_FILE          261 // (4/14.9) File Entry
#define DESTAG_ID_NSR_EA            262 // (4/14.10) Extended Attribute Header
#define DESTAG_ID_NSR_UASE          263 // (4/14.11) Unallocated Space Entry
#define DESTAG_ID_NSR_SBP           264 // (4/14.12) Space Bitmap Descriptor
#define DESTAG_ID_NSR_PINTEG        265 // (4/14.13) Partition Integrity

#define DESTAG_ID_MINIMUM_PART4     256 // The lowest legal DESTAG in Part 4
#define DESTAG_ID_MAXIMUM_PART4     265 // The highest legal DESTAG in Part 4

//  DESTAG_VER_... - Values for destag_Version (3/7.2.2)

#define DESTAG_VER_CURRENT          2   // Current Descriptor Tag Version

//  DESTAG_SERIAL_... - Values for destag_Serial (3/7.2.5)

#define DESTAG_SERIAL_NONE          0   // No Serial Number specified


/***    Anchor Points (3/8.4.2.1)
 *
 */

#define ANCHOR_SECTOR   256


/***    vsd_nsr02 - NSR02 Volume Structure Descriptor (3/9.1)
 *
 */

typedef struct  VSD_NSR02 {
    UCHAR       Type;                   // Structure Type
    UCHAR       Ident[5];               // Standard Identifier ('NSR02')
    UCHAR       Version;                // Standard Version
    UCHAR       Res7;                   // Reserved 0 Byte
    UCHAR       Data[2040];             // Structure Data
} VSD_NSR02, *PVSD_NSR02;


//  Values for vsd_nsr02_Type

#define VSD_NSR02_TYPE_0        0       // Reserved 0

//  Values for vsd_nsr02_Version

#define VSD_NSR02_VER           1       // Standard Version 1


/***    nsr_vd_generic - Generic Volume Descriptor of 512 bytes
 *
 */

typedef struct  NSR_VD_GENERIC {
    DESTAG      Destag;                 // Descriptor Tag
    ULONG       Sequence;               // Volume Descriptor Sequence Number
    UCHAR       Data20[492];            // Descriptor Data
} NSR_VD_GENERIC, *PNSR_VD_GENERIC;


/***    nsr_pvd - NSR Primary Volume Descriptor (3/10.1)
 *
 *      nsr_pvd_destag.destag_Ident = DESTAG_ID_NSR_PVD
 *
 */

typedef struct  NSR_PVD {
    DESTAG      Destag;                 // Descriptor Tag (NSR_PVD)
    ULONG       VolDescSeqNum;          // Volume Descriptor Sequence Number
    ULONG       Number;                 // Primary Volume Descriptor Number
    UCHAR       VolumeID[32];           // Volume Identifier
    USHORT      VolSetSeq;              // Volume Set Sequence Number
    USHORT      VolSetSeqMax;           // Maximum Volume Set Sequence Number
    USHORT      Level;                  // Interchange Level
    USHORT      LevelMax;               // Maximum Interchange Level
    ULONG       CharSetList;            // Character Set List (See 1/7.2.11)
    ULONG       CharSetListMax;         // Maximum Character Set List
    UCHAR       VolSetID[128];          // Volume Set Identifier
    CHARSPEC    CharsetDesc;            // Descriptor Character Set
    CHARSPEC    CharsetExplan;          // Explanatory Character Set
    EXTENTAD    Abstract;               // Volume Abstract Location
    EXTENTAD    Copyright;              // Volume Copyright Notice Location
    REGID       Application;            // Application Identifier
    TIMESTAMP   RecordTime;             // Recording Time
    REGID       ImpUseID;               // Implementation Identifier
    UCHAR       ImpUse[64];             // Implementation Use
    ULONG       Predecessor;            // Predecessor Vol Desc Seq Location
    USHORT      Flags;                  // Flags
    UCHAR       Res490[22];             // Reserved Zeros
} NSR_PVD, *PNSR_PVD;

//  NSRPVD_F_... - Definitions for nsr_pvd_Flags

#define NSRPVD_F_COMMON_VOLID   (0x0001)// Volume ID is common across Vol Set


/***    nsr_anchor - Anchor Volume Descriptor Pointer (3/10.2)
 *
 *      nsr_anchor_destag.destag_Ident = DESTAG_ID_NSR_ANCHOR
 *
 */

typedef struct  NSR_ANCHOR {
    DESTAG      Destag;                 // Descriptor Tag (NSR_ANCHOR)
    EXTENTAD    Main;                   // Main Vol Desc Sequence Location
    EXTENTAD    Reserve;                // Reserve Vol Desc Sequence Location
    UCHAR       Res32[480];             // Reserved Zeros
} NSR_ANCHOR, *PNSR_ANCHOR;


/***    nsr_vdp - Volume Descriptor Pointer (3/10.3)
 *
 *      nsr_vdp_destag.destag_Ident = DESTAG_ID_NSR_VDP
 *
 */

typedef struct  NSR_VDP {
    DESTAG      Destag;                 // Descriptor Tag (NSR_VDP)
    ULONG       VolDescSeqNum;          // Vol Desc Sequence Number
    EXTENTAD    Next;                   // Next Vol Desc Sequence Location
    UCHAR       Res28[484];             // Reserved Zeros
} NSR_VDP, *PNSR_VDP;


/***    nsr_impuse - Implementation Use Volume Descriptor (3/10.4)
 *
 *      nsr_impuse_destag.destag_Ident = DESTAG_ID_NSR_IMPUSE
 *
 */

typedef struct  NSR_IMPUSE {
    DESTAG      Destag;                 // Descriptor Tag (NSR_IMPUSE)
    ULONG       VolDescSeqNum;          // Vol Desc Sequence Number
    REGID       ImpUseID;               // Implementation Identifier
    UCHAR       ImpUse[460];            // Implementation Use
} NSR_IMPUSE, *PNSR_IMPUSE;


/***    nsr_part - Partition Descriptor (3/10.5)
 *
 *      nsr_part_destag.destag_Ident = DESTAG_ID_NSR_PART
 *
 */

typedef struct  NSR_PART {
    DESTAG      Destag;                 // Descriptor Tag (NSR_PART)
    ULONG       VolDescSeqNum;          // Vol Desc Sequence Number
    USHORT      Flags;                  // Partition Flags (NSR_PART_F_...)
    USHORT      Number;                 // Partition Number
    REGID       ContentsID;             // Partition Contents ID
    UCHAR       ContentsUse[128];       // Partition Contents Use
    ULONG       AccessType;             // Access Type
    ULONG       Start;                  // Partition Starting Location
    ULONG       Length;                 // Partition Length (sector count)
    REGID       ImpUseID;               // Implementation Identifier
    UCHAR       ImpUse[128];            // Implementation Use
    UCHAR       Res356[156];            // Reserved Zeros
} NSR_PART, *PNSR_PART;


//  NSR_PART_F_... - Definitions for nsr_part_Flags

#define NSR_PART_F_ALLOCATION   (0x0001)    // Volume Space Allocated

//  Values for nsr_part_ContentsID.regid_Identifier

#define NSR_PART_CONTID_FDC01   "+FDC01"    // ISO 9293-1987
#define NSR_PART_CONTID_CD001   "+CD001"    // ISO 9660
#define NSR_PART_CONTID_CDW01   "+CDW01"    // ECMA 168
#define NSR_PART_CONTID_CDW02   "+CDW02"    // ISO 13490
#define NSR_PART_CONTID_NSR01   "+NSR01"    // ECMA 167
#define NSR_PART_CONTID_NSR02   "+NSR02"    // ISO 13346

typedef enum NSR_PART_CONTID {
    NsrPartContIdBad = 0,
    NsrPartContIdFDC01,
    NsrPartContIdCD001,
    NsrPartContIdCDW01,
    NsrPartContIdCDW02,
    NsrPartContIdNSR01,
    NsrPartContIdNSR02
} NSR_PART_CONTID, *PNSR_PART_CONTID;

//  Values for nsr_part_AccessType

#define NSR_PART_ACCESS_NOSPEC  0       // Partition Access Unspecified
#define NSR_PART_ACCESS_RO      1       // Read Only Access
#define NSR_PART_ACCESS_WO      2       // Write-Once Access
#define NSR_PART_ACCESS_RW_PRE  3       // Read/Write with preparation
#define NSR_PART_ACCESS_RW_OVER 4       // Read/Write, fully overwritable


/***    nsr_lvol - Logical Volume Descriptor (3/10.6)
 *
 *      nsr_lvol_destag.destag_Ident = DESTAG_ID_NSR_LVOL
 *
 *      The Logical Volume Contents Use field is specified here as a
 *      File Set Descriptor Sequence (FSD) address.  See (4/3.1).
 *
 */

typedef struct  NSR_LVOL {
    DESTAG      Destag;                 // Descriptor Tag (NSR_LVOL)
    ULONG       VolDescSeqNum;          // Vol Desc Sequence Number
    CHARSPEC    Charset;                // Descriptor Character Set
    UCHAR       VolumeID[128];          // Logical Volume ID
    ULONG       BlockSize;              // Logical Block Size (in bytes)
    REGID       DomainID;               // Domain Identifier
    LONGAD      FSD;                    // Logical Volume Contents Use
    ULONG       MapTableLength;         // Map Table Length (bytes)
    ULONG       MapTableCount;          // Map Table Partition Maps Count
    REGID       ImpUseID;               // Implementaion Identifier
    UCHAR       ImpUse[128];            // Implementation Use
    EXTENTAD    Integrity;              // Integrity Sequence Extent
    UCHAR       MapTable[0];            // Partition Map Table (variant!)

//  The true length of this structure may vary!

} NSR_LVOL, *PNSR_LVOL;

#define ISONsrLvolConstantSize (FIELD_OFFSET( NSR_LVOL, MapTable ))
#define ISONsrLvolSize( L ) (ALIGN_UP( ISONsrLvolConstantSize + (L)->MapTableLength, sizeof(ULONGLONG) ))

/***    partmap_generic - Generic Partition Map (3/10.7.1)
 *
 */

typedef struct  PARTMAP_GENERIC {
    UCHAR       Type;                   // Partition Map Type
    UCHAR       Length;                 // Partition Map Length
    UCHAR       Map[0];                 // Partion Mapping (variant!)

//  The true length of this structure may vary!

} PARTMAP_GENERIC, *PPARTMAP_GENERIC;

//  Values for partmap_g_Type

#define PARTMAP_TYPE_NOTSPEC        0   // Partition Map Format Not Specified
#define PARTMAP_TYPE_PHYSICAL       1   // Partition Map in Volume Set (Type 1)
#define PARTMAP_TYPE_PROXY          2   // Partition Map by identifier (Type 2)


/***    partmap_physical - Normal (Type 1) Partition Map (3/10.7.2)
 *
 *      A Normal Partion Map specifies a partition number on a volume
 *      within the same volume set.
 *
 */

typedef struct  PARTMAP_PHYSICAL {
    UCHAR       Type;                   // Partition Map Type = 1
    UCHAR       Length;                 // Partition Map Length = 6
    USHORT      VolSetSeq;              // Partition Volume Set Sequence Number
    USHORT      Partition;              // Partition Number
} PARTMAP_PHYSICAL, *PPARTMAP_PHYSICAL;


/***    partmap_proxy - Proxy (Type 2) Partition Map (3/10.7.3)
 *
 *      A Proxy Partition Map is commonly not interchangeable.
 *
 */

typedef struct  PARTMAP_PROXY {
    UCHAR       Type;                   // Partition Map Type = 2
    UCHAR       Length;                 // Partition Map Length = 64
    UCHAR       PartID[62];             // Partition Identifier (Proxy)
} PARTMAP_PROXY, *PPARTMAP_PROXY;


/***    nsr_uasd - Unallocated Space Descriptor (3/10.8)
 *
 *      nsr_uasd_destag.destag_Ident = DESTAG_ID_NSR_UASD
 *
 *      The true length of nsr_uasd_Extents is (nsr_uasd_ExtentCount * 8), and
 *      the last logical sector of nsr_uasd_Extents is zero padded.
 *
 */

typedef struct  NSR_UASD {
    DESTAG      Destag;                 // Descriptor Tag (NSR_UASD)
    ULONG       VolDescSeqNum;          // Vol Desc Sequence Number
    ULONG       ExtentCount;            // Number of Allocation Descriptors
    EXTENTAD    Extents[0];             // Allocation Descriptors (variant!)

//  The true length of this structure may vary!
//  The true length of nsr_uasd_Extents is (nsr_uasd_ExtentCount * 8) bytes.
//  The last logical sector of nsr_uasd_Extents is zero padded.

} NSR_UASD, *PNSR_UASD;


/***    nsr_term - Terminating Descriptor (3/10.9 and 4/14.2)
 *
 *      nsr_term_destag.destag_Ident = DESTAG_ID_NSR_TERM
 *
 */

typedef struct  NSR_TERM {
    DESTAG      Destag;                 // Descriptor Tag (NSR_TERM)
    UCHAR       Res16[496];             // Reserved Zeros
} NSR_TERM, *PNSR_TERM;


/***    nsr_lvhd - Logical Volume Header Descriptor (4/14.15)
 *
 *      This descriptor is found in the Logical Volume Content Use
 *      field of a Logical Volume Integrity Descriptor.
 *
 *      This definition is moved to here to avoid forward reference.
 */

typedef struct  NSR_LVHD {
    ULONG       UniqueID[2];            // Unique ID
    UCHAR       Res8[24];               // Reserved Zeros
} NSR_LVHD, *PNSR_LVHD;


/***    nsr_integ - Logical Volume Integrity Descriptor (3/10.10)
 *
 *      nsr_integ_destag.destag_Ident = DESTAG_ID_NSR_LVINTEG
 *
 *      WARNING: WARNING: WARNING: nsr_integ is a multi-variant structure!
 *
 *      The starting address of nsr_integ_Size is not acurrate.
 *      Compensate for this nsr_integ_Size problem by adding the value of
 *      (nsr_integ_PartitionCount-1) to the ULONG ARRAY INDEX.
 *
 *      The starting address of nsr_integ_ImpUse[0] is not accurate.
 *      Compensate for this nsr_integ_ImpUse problem by adding the value of
 *      ((nsr_integ_PartitionCount-1)<<3) to the UCHAR ARRAY INDEX.
 *
 *      This descriptor is padded with zero bytes to the end of the last
 *      logical sector it occupies.
 *
 *      The Logical Volume Contents Use field is specified here as a
 *      Logical Volume Header Descriptor.  See (4/3.1) second last point.
 */

typedef struct  NSR_INTEG {
    DESTAG      Destag;                 // Descriptor Tag (NSR_LVINTEG)
    TIMESTAMP   Time;                   // Recording Date
    ULONG       Type;                   // Integrity Type (INTEG_T_...)
    EXTENTAD    Next;                   // Next Integrity Extent
    NSR_LVHD    LVHD;                   // Logical Volume Contents Use
    ULONG       PartitionCount;         // Number of Partitions
    ULONG       ImpUseLength;           // Length of Implementation Use
    ULONG       Free[1];                // Free Space Table

//  nsr_integ_Free has a variant length = (4*nsr_integ_PartitionCount)

    ULONG       Size[1];                // Size Table

//  nsr_integ_Size has a variant starting offset due to nsr_integ_Free
//  nsr_integ_Size has a variant length = (4*nsr_integ_PartitionCount)

    UCHAR       ImpUse[0];              // Implementation Use

//  nsr_integ_ImpUse has a variant starting offset due to nsr_integ_Free and
//  nsr_integ_Size.
//  nsr_integ_ImpUse has a variant length = (nsr_integ_ImpUseLength)

} NSR_INTEG, *PNSR_INTEG;

// Values for nsr_integ_Type

#define NSR_INTEG_T_OPEN        0           // Open Integrity Descriptor
#define NSR_INTEG_T_CLOSE       1           // Close Integrity Descriptor


/***    ISO 13346 Part 4: File Structure
 *
 *      See DESTAG structure in Part 3 for definitions found in (4/7.2).
 *
 */


/***    nsr_fsd - File Set Descriptor (4/14.1)
 *
 *      nsr_fsd_destag.destag_Ident = DESTAG_ID_NSR_FSD
 */

typedef struct  NSR_FSD {
    DESTAG      Destag;                     // Descriptor Tag (NSR_LVOL)
    TIMESTAMP   Time;                       // Recording Time
    USHORT      Level;                      // Interchange Level
    USHORT      LevelMax;                   // Maximum Interchange Level
    ULONG       CharSetList;                // Character Set List (See 1/7.2.11)
    ULONG       CharSetListMax;             // Maximum Character Set List
    ULONG       FileSet;                    // File Set Number
    ULONG       FileSetDesc;                // File Set Descriptor Number
    CHARSPEC    CharspecVolID;              // Volume ID Character Set
    UCHAR       VolID[128];                 // Volume ID
    CHARSPEC    CharspecFileSet;            // File Set Character Set
    UCHAR       FileSetID[32];              // File Set ID
    UCHAR       Copyright[32];              // Copyright File Name
    UCHAR       Abstract[32];               // Abstract File Name
    LONGAD      IcbRoot;                    // Root Directory ICB Address
    REGID       DomainID;                   // Domain Identifier
    LONGAD      NextExtent;                 // Next FSD Extent
    UCHAR       Res464[48];                 // Reserved Zeros
} NSR_FSD, *PNSR_FSD;


/***    nsr_part_h - Partition Header Descriptor (4/14.3)
 *
 *      No Descriptor Tag.
 *
 *      This descriptor is found in the nsr_part_ContentsUse field of
 *      an NSR02 Partition Descriptor.  See NSR_PART_CONTID_NSR02.
 *
 */

typedef struct  NSR_PART_H {
    SHORTAD     UASTable;                   // Unallocated Space Table
    SHORTAD     UASBitmap;                  // Unallocated Space Bitmap
    SHORTAD     IntegTable;                 // Integrity Table
    SHORTAD     FreedTable;                 // Freed Space Table
    SHORTAD     FreedBitmap;                // Freed Space Bitmap
    UCHAR       Res40[88];                  // Reserved Zeros
} NSR_PART_H, *PNSR_PART_H;


/***    nsr_fid - File Identifier Descriptor (4/14.4)
 *
 *      nsr_fid_destag.destag_Ident = DESTAG_ID_NSR_FID
 *
 *      WARNING: WARNING: WARNING: nsr_fid is a multi-variant structure!
 *
 *      The starting address of nsr_fid_FileID is not acurrate.
 *      Compensate for this nsr_fid_FileID problem by adding the value of
 *      (nsr_fid_ImpUseLen-1) to the UCHAR ARRAY INDEX.
 *
 *      The starting address of nsr_fid_Padding is not acurrate.
 *      Compensate for this nsr_fid_Padding problem by adding the value of
 *      (nsr_fid_ImpUseLen+nsr_fid_FileIDLen-2) to the UCHAR ARRAY INDEX.
 *
 *      The true total size of nsr_fid_s is
 *          ((38 + nsr_fid_FileIDLen + nsr_fid_ImpUseLen) + 3) & ~3)
 *
 */

typedef struct  NSR_FID {
    DESTAG      Destag;                     // Descriptor Tag (NSR_FID)
    USHORT      Version;                    // File Version Number
    UCHAR       Flags;                      // File Flags (NSR_FID_F_...)
    UCHAR       FileIDLen;                  // File ID Length
    LONGAD      Icb;                        // ICB (long) Address
    USHORT      ImpUseLen;                  // Implementation Use Length

    UCHAR       ImpUse[1];                  // Implementation Use Area

//  nsr_fid_ImpUse has a variant length = nsr_fid_ImpUseLen

    UCHAR       FileID[1];                  // File Identifier

//  nsr_fid_FileID has a variant starting offset due to nsr_fid_ImpUse
//  nsr_fid_FileID has a variant length = nsr_fid_FileIDLen

    UCHAR       Padding[1];                 // Padding

//  nsr_fid_Paddinghas a variant starting offset due to nsr_fid_ImpUse and
//  nsr_fid_FileID
//  nsr_fid_Padding has a variant length. Round up to the next ULONG boundary.

} NSR_FID, *PNSR_FID;

#define ISONsrFidConstantSize (ULONG)(FIELD_OFFSET( NSR_FID, ImpUse ))
#define ISONsrFidSize( F ) (ALIGN_UP( ISONsrFidConstantSize + (F)->FileIDLen + (F)->ImpUseLen, sizeof(ULONG) ))

//  NSR_FID_F_... - Definitions for nsr_fid_Flags (Characteristics, 4/14.4.3)

#define NSR_FID_F_HIDDEN        (0x01)  // Hidden Bit
#define NSR_FID_F_DIRECTORY     (0x02)  // Directory Bit
#define NSR_FID_F_DELETED       (0x04)  // Deleted Bit
#define NSR_FID_F_PARENT        (0x08)  // Parent Directory Bit

#define NSR_FID_OFFSET_FILEID   38      // Field Offset of nsr_fid_FileID[];


/***    nsr_alloc - Allocation Extent Descriptor (4/14.5)
 *
 *      nsr_alloc_destag.destag_Ident = DESTAG_ID_NSR_ALLOC
 *
 *      This descriptor is immediately followed by AllocLen bytes
 *      of allocation descriptors, which is not part of this
 *      descriptor (so CRC calculation doesn't include it).
 *
 */

typedef struct  NSR_ALLOC {
    DESTAG      Destag;                 // Descriptor Tag (NSR_ALLOC)
    ULONG       Prev;                   // Previous Allocation Descriptor
    ULONG       AllocLen;               // Length of Allocation Descriptors
} NSR_ALLOC, *PNSR_ALLOC;


/***    icbtag - Information Control Block Tag (4/14.6)
 *
 *      An ICBTAG is commonly preceeded by a Descriptor Tag (DESTAG).
 *
 */

typedef struct  ICBTAG {
    ULONG       PriorDirectCount;// Prior Direct Entry Count
    USHORT      StratType;       // Strategy Type (ICBTAG_STRAT_...)
    USHORT      StratParm;       // Strategy Parameter (2 bytes)
    USHORT      MaxEntries;      // Maximum Number of Entries in ICB
    UCHAR       Res10;           // Reserved Zero
    UCHAR       FileType;        // File Type (ICBTAG_FILE_T_...)
    NSRLBA      IcbParent;       // Parent ICB Location
    USHORT      Flags;           // ICB Flags (ICBTAG_F_...)
} ICBTAG, *PICBTAG;


//  ICBTAG_STRAT_T_... - ICB Strategy Types

#define ICBTAG_STRAT_NOTSPEC    0       // ICB Strategy Not Specified
#define ICBTAG_STRAT_TREE       1       // Strategy 1 (4/A.2) (Plain Tree)
#define ICBTAG_STRAT_MASTER     2       // Strategy 2 (4/A.3) (Master ICB)
#define ICBTAG_STRAT_BAL_TREE   3       // Strategy 3 (4/A.4) (Balanced Tree)
#define ICBTAG_STRAT_DIRECT     4       // Strategy 4 (4/A.5) (One Direct)

//  ICBTAG_FILE_T_... - Values for icbtag_FileType

#define ICBTAG_FILE_T_NOTSPEC    0      // Not Specified
#define ICBTAG_FILE_T_UASE       1      // Unallocated Space Entry
#define ICBTAG_FILE_T_PINTEG     2      // Partition Integrity Entry
#define ICBTAG_FILE_T_INDIRECT   3      // Indirect Entry
#define ICBTAG_FILE_T_DIRECTORY  4      // Directory
#define ICBTAG_FILE_T_FILE       5      // Ordinary File
#define ICBTAG_FILE_T_BLOCK_DEV  6      // Block Special Device
#define ICBTAG_FILE_T_CHAR_DEV   7      // Character Special Device
#define ICBTAG_FILE_T_XA         8      // Extended Attributes
#define ICBTAG_FILE_T_FIFO       9      // FIFO file
#define ICBTAG_FILE_T_C_ISSOCK  10      // Socket
#define ICBTAG_FILE_T_TERMINAL  11      // Terminal Entry
#define ICBTAG_FILE_T_PATHLINK  12      // Symbolic Link with a pathname

//  ICBTAG_F_... - Values for icbtag_Flags

#define ICBTAG_F_ALLOC_MASK     (0x0007)// Mask for Allocation Descriptor Info
#define ICBTAG_F_ALLOC_SHORT          0 // Short Allocation Descriptors Used
#define ICBTAG_F_ALLOC_LONG           1 // Long Allocation Descriptors Used
#define ICBTAG_F_ALLOC_EXTENDED       2 // Extended Allocation Descriptors Used
#define ICBTAG_F_ALLOC_IMMEDIATE      3 // File Data Recorded Immediately

#define ISOAllocationDescriptorSize(T) ( (T) == ICBTAG_F_ALLOC_SHORT ? sizeof(SHORTAD) : \
                                         (T) == ICBTAG_F_ALLOC_LONG ? sizeof(LONGAD) :   \
                                         sizeof(EXTAD) )

#define ICBTAG_F_SORTED         (0x0008)// Directory is Sorted (4/8.6.1)
#define ICBTAG_F_NO_RELOCATE    (0x0010)// Data is not relocateable
#define ICBTAG_F_ARCHIVE        (0x0020)// Archive Bit
#define ICBTAG_F_SETUID         (0x0040)// S_ISUID Bit
#define ICBTAG_F_SETGID         (0x0080)// S_ISGID Bit
#define ICBTAG_F_STICKY         (0x0100)// C_ISVTX Bit
#define ICBTAG_F_CONTIGUOUS     (0x0200)// File Data is Contiguous
#define ICBTAG_F_SYSTEM         (0x0400)// System Bit
#define ICBTAG_F_TRANSFORMED    (0x0800)// Data Transformed
#define ICBTAG_F_MULTIVERSIONS  (0x1000)// Multi-version Files in Directory


/***    icbind - Indirect ICB Entry (4/14.7)
 *
 */

typedef struct  ICBIND {
    DESTAG      Destag;                 // Descriptor Tag (ID_NSR_ICBIND)
    ICBTAG      Icbtag;                 // ICB Tag (ICBTAG_FILE_T_INDIRECT)
    LONGAD      Icb;                    // ICB Address
} ICBIND, *PICBIND;


/***    icbtrm - Terminal ICB Entry (4/14.8)
 *
 */

typedef struct  ICBTRM {
    DESTAG      Destag;                 // Descriptor Tag (ID_NSR_ICBTRM)
    ICBTAG      Icbtag;                 // ICB Tag (ICBTAG_FILE_T_TERMINAL)
} ICBTRM, *PICBTRM;


/***    icbfile - File ICB Entry (4/14.9)
 *
 *      WARNING: WARNING: WARNING: icbfile is a multi-variant structure!
 *
 *      The starting address of icbfile_Allocs is not acurrate.
 *      Compensate for this icbfile_Allocs problem by adding the value of
 *      (icbfile_XALength-1) to the UCHAR ARRAY INDEX.
 *
 *      icbfile_XALength is a multiple of 4.
 *
 */

typedef struct  ICBFILE {
    DESTAG      Destag;                 // Descriptor Tag (ID_NSR_FILE)
    ICBTAG      Icbtag;                 // ICB Tag (ICBTAG_FILE_T_FILE)
    ULONG       UID;                    // User ID of file's owner
    ULONG       GID;                    // Group ID of file's owner
    ULONG       Permissions;            // File Permissions
    USHORT      LinkCount;              // File hard-link count
    UCHAR       RecordFormat;           // Record Format
    UCHAR       RecordDisplay;          // Record Display Attributes
    ULONG       RecordLength;           // Record Length
    ULONGLONG   InfoLength;             // Information Length (file size)
    ULONGLONG   BlocksRecorded;         // Logical Blocks Recorded
    TIMESTAMP   AccessTime;             // Last-Accessed Time
    TIMESTAMP   ModifyTime;             // Last-Modification Time
    TIMESTAMP   AttributeTime;          // Last-Attribute-Change Time
    ULONG       Checkpoint;             // File Checkpoint
    LONGAD      IcbEA;                  // Extended Attribute ICB
    REGID       ImpUseID;               // Implementation Use Identifier
    ULONGLONG   UniqueID;               // Unique ID
    ULONG       EALength;               // Length of Extended Attributes
    ULONG       AllocLength;            // Length of Allocation Descriptors
    UCHAR       EAs[1];                 // Extended Attributes

//  icbfile_EAs has a variant length = icbfile_EALength

    UCHAR       Allocs[0];              // Allocation Descriptors.

//  icbfile_Allocs has a variant starting offset due to icbfile_EAs.
//  icbfile_Allocs has a variant length = icbfile_AllocLen.

} ICBFILE, *PICBFILE;


//  Definitions for icbfile_Permissions (4/14.9.6)

#define ICBFILE_PERM_OTH_X  (0x00000001)    // Other: Execute OK
#define ICBFILE_PERM_OTH_W  (0x00000002)    // Other: Write OK
#define ICBFILE_PERM_OTH_R  (0x00000004)    // Other: Read OK
#define ICBFILE_PERM_OTH_A  (0x00000008)    // Other: Set Attributes OK
#define ICBFILE_PERM_OTH_D  (0x00000010)    // Other: Delete OK
#define ICBFILE_PERM_GRP_X  (0x00000020)    // Group: Execute OK
#define ICBFILE_PERM_GRP_W  (0x00000040)    // Group: Write OK
#define ICBFILE_PERM_GRP_R  (0x00000080)    // Group: Read OK
#define ICBFILE_PERM_GRP_A  (0x00000100)    // Group: Set Attributes OK
#define ICBFILE_PERM_GRP_D  (0x00000200)    // Group: Delete OK
#define ICBFILE_PERM_OWN_X  (0x00000400)    // Owner: Execute OK
#define ICBFILE_PERM_OWN_W  (0x00000800)    // Owner: Write OK
#define ICBFILE_PERM_OWN_R  (0x00001000)    // Owner: Read OK
#define ICBFILE_PERM_OWN_A  (0x00002000)    // Owner: Set Attributes OK
#define ICBFILE_PERM_OWN_D  (0x00004000)    // Owner: Delete OK

//  (4/14.9.7) Record Format
//      Skipped

//  (4/14.9.8) Record Display Attributes
//      Skipped


/***    nsr_eah - Extended Attributes Header Descriptor (4/14.10.1)
 *
 */

typedef struct  NSR_EAH {
    DESTAG      Destag;                 // Descriptor Tag (ID_NSR_XA)
    ULONG       EAImp;                  // Implementation Attributes Location
    ULONG       EAApp;                  // Application Attributes Location
} NSR_EAH, *PNSR_EAH;


/***    nsr_ea_g - Generic Extended Attributes Format (4/14.10.2)
 *
 */

typedef struct  NSR_EA_GENERIC {
    ULONG       EAType;                 // Extended Attribute Type
    UCHAR       EASubType;              // Extended Attribute Sub Type
    UCHAR       Res5[3];                // Reserved Zeros
    ULONG       EALength;               // Extended Attribute Length
    UCHAR       EAData[0];              // Extended Attribute Data (variant!)

} NSR_EA_GENERIC, *PNSR_EA_GENERIC;

//
//  Extended Attribute Types (14.4.10)
//

#define EA_TYPE_CHARSET     1
#define EA_TYPE_ALTPERM     3
#define EA_TYPE_FILETIMES   5
#define EA_TYPE_INFOTIMES   6
#define EA_TYPE_DEVICESPEC  12
#define EA_TYPE_IMPUSE      2048
#define EA_TYPE_APPUSE      65536

#define EA_SUBTYPE_BASE     1


//  (4/14.10.3) Character Set Information Extended Attribute Format
//      Skipped

//  (4/14.10.4) Alternate Permissions Extended Attribute Format
//      Skipped

//  (4/14.10.5) File Times Extended Attribute Format

typedef struct  NSR_EA_FILETIMES {
    ULONG       EAType;                 // Extended Attribute Type
    UCHAR       EASubType;              // Extended Attribute Sub Type
    UCHAR       Res5[3];                // Reserved Zeros
    ULONG       EALength;               // Extended Attribute Length
    ULONG       DataLength;             // EAData Length
    ULONG       Existence;              // Specifies which times are recorded
    TIMESTAMP   Stamps[0];              // Timestamps (variant!)

} NSR_EA_FILETIMES, *PNSR_EA_FILETIMES;


//  Definitions for nsr_ea_filetimes_Existence (4/14.10.5.6)

#define EA_FILETIMES_E_CREATION     (0x00000001)
#define EA_FILETIMES_E_DELETION     (0x00000004)
#define EA_FILETIMES_E_EFFECTIVE    (0x00000008)
#define EA_FILETIMES_E_LASTBACKUP   (0x00000020)


//  (4/14.10.6) Information Times Extended Attribute Format
//
//  Exactly the same as an NSR_EA_FILETIMES

//  Definitions for nsr_ea_infotimes_Existence (4/14.10.6.6)

#define EA_INFOTIMES_E_CREATION     (0x00000001)
#define EA_INFOTIMES_E_MODIFICATION (0x00000002)
#define EA_INFOTIMES_E_EXPIRATION   (0x00000004)
#define EA_INFOTIMES_E_EFFECTIVE    (0x00000008)


//  (4/14.10.7) Device Specification Extended Attribute Format
//      Skipped

//  (4/14.10.8) Implementation Use Extended Attribute Format
//      Skipped

//  (4/14.10.9) Application Use Extended Attribute Format
//      Skipped


/***    icbuase - Unallocated Space Entry (4/14.11)
 *
 *      icbuase_destag.destag_Ident = DESTAG_ID_NSR_UASE
 *      icbuase_icbtag.icbtag_FileType = ICBTAG_FILE_T_UASE
 *
 */

typedef struct  ICBUASE {
    DESTAG      Destag;                 // Descriptor Tag (ID_NSR_ICBUASE)
    ICBTAG      Icbtag;                 // ICB Tag (ICBTAG_FILE_T_UASE)
    ULONG       AllocLen;               // Allocation Descriptors Length
    UCHAR       Allocs[0];              // Allocation Descriptors (variant!)

//  The true length of this structure may vary!
//  icbuase_Allocs has a variant length = icbuase_AllocLen;

} ICBUASE, *PICBUASE;


/***    nsr_sbd - Space Bitmap Descriptor (4/14.12)
 *
 *      nsr_sbd_destag.destag_Ident = DESTAG_ID_NSR_SBD
 *
 */

typedef struct  NSR_SBD {
    DESTAG      Destag;                 // Descriptor Tag (DESTAG_ID_NSR_SBD)
    ULONG       BitCount;               // Number of bits in Space Bitmap
    ULONG       ByteCount;              // Number of bytes in Space Bitmap
    UCHAR       Bits[0];                // Space Bitmap (variant!)

//  The true length of this structure may vary!
//  nsr_sbd_Bits has a variant length = nsr_sbd_ByteCount;

} NSR_SBD, *PNSR_SBD;


/***    icbpinteg - Partition Integrity ICB Entry (4/14.13)
 *
 */

typedef struct  ICBPINTEG {
    DESTAG      Destag;                 // Descriptor Tag (ID_NSR_PINTEG)
    ICBTAG      Icbtag;                 // ICB Tag (ICBTAG_FILE_T_PINTEG)
    TIMESTAMP   Recording;              // Recording Time
    UCHAR       IntegType;              // Integrity Type (ICBPINTEG_T_...)
    UCHAR       Res49[175];             // Reserved Zeros
    REGID       ImpUseID;               // Implemetation Use Identifier
    UCHAR       ImpUse[256];            // Implemetation Use Area
} ICBPINTEG, *PICBPINTEG;

//  ICBPINTEG_T_... - Values for icbpinteg_IntegType

#define ICBPINTEG_T_OPEN        0       // Open Partition Integrity Entry
#define ICBPINTEG_T_CLOSE       1       // Close Partition Integrity Entry
#define ICBPINTEG_T_STABLE      2       // Stable Partition Integrity Entry


/***    (4/14.14.1) Short Allocation Descriptor
 ***    (4/14.14.2) Long Allocation Descriptor
 ***    (4/14.14.3) Extended Allocation Descriptor
 *
 *      See SHORTAD, LONGAD, EXTAD, already defined above.
 *
 */


/***    nsr_lvhd - Logical Volume Header Descriptor (4/14.15)
 *
 *      The definition is moved to before Logical Volume Integrity
 *      Descriptor.
 *
 */


/***    nsr_path - Path Component (4/14.16)
 *
 */

typedef struct  NSR_PATH {
    UCHAR       Type;                   // Path Component Type (NSR_PATH_T_...)
    UCHAR       CompLen;                // Path Component Length
    UCHAR       CompVer;                // Path Component Version
    UCHAR       Comp[0];                // Path Component Identifier (variant!)

//  nsr_path_Comp has a variant length = nsr_path_CompLen

} NSR_PATH, *PNSR_PATH;

//  NSR_PATH_T_... - Values for nsr_path_Type

#define NSR_PATH_T_RESERVED     0       // Reserved Value
#define NSR_PATH_T_OTHER_ROOT   1       // Another root directory, by agreement
#define NSR_PATH_T_ROOTDIR      2       // Root Directory ('\')
#define NSR_PATH_T_PARENTDIR    3       // Parent Directory ('..')
#define NSR_PATH_T_CURDIR       4       // Current Directory ('.')
#define NSR_PATH_T_FILE         5       // File


/***    ISO 13346 Part 5: Record Structure
 *
 *      Skipped
 *
 */

//
//  Restore the standard structure packing.
//

#pragma pack()
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\udfx\fsctrl.c ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    fsctrl.c

Abstract:

    This module implements routines related to handling
    IRP_MJ_FILE_SYSTEM_CONTROL.

--*/

#include "udfx.h"

NTSTATUS
UdfxDismountVolume(
    IN PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

    This routine is indirectly called by the I/O manager to handle
    FSCTL_DISMOUNT_VOLUME requests.

Arguments:

    DeviceObject - Specifies the device object that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    PUDF_VOLUME_EXTENSION VolumeExtension;
    KIRQL OldIrql;

    UdfxAcquireGlobalMutexExclusive();

    VolumeExtension = (PUDF_VOLUME_EXTENSION)DeviceObject->DeviceExtension;

    //
    // Check if the volume is already marked for dismount.  If not, mark it for
    // dismount.
    //

    if (VolumeExtension->Dismounted) {
        status = STATUS_VOLUME_DISMOUNTED;
        goto CleanupAndExit;
    }

    VolumeExtension->Dismounted = TRUE;

    //
    // Synchronize access to the MountedOrSelfDevice with the I/O manager by
    // raising to DISPATCH_LEVEL.
    //
    // Clear out the target device object's MountedOrSelfDevice field.  That
    // will cause future accesses to the target device object to mount a new
    // file system device object.
    //

    OldIrql = KeRaiseIrqlToDpcLevel();

    VolumeExtension->TargetDeviceObject->MountedOrSelfDevice = NULL;

    KeLowerIrql(OldIrql);

    //
    // Delete the volume device if the file object count is zero.
    //

    if (VolumeExtension->FileObjectCount == 0) {
        UdfxDeleteVolumeDevice(DeviceObject);
    } else if (VolumeExtension->FileObjectCount > 1) {
        UdfxDbgPrint(("UDFX: dismounting volume %p with %d open file handles\n",
            VolumeExtension, VolumeExtension->FileObjectCount));
    }

    status = STATUS_SUCCESS;

CleanupAndExit:
    UdfxReleaseGlobalMutex();

    return status;
}

NTSTATUS
UdfxFsdFileSystemControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is called by the I/O manager to handle
    IRP_MJ_FILE_SYSTEM_CONTROL requests.

Arguments:

    DeviceObject - Specifies the device object that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    PIO_STACK_LOCATION IrpSp;

    IrpSp = IoGetCurrentIrpStackLocation(Irp);

    switch (IrpSp->Parameters.FileSystemControl.FsControlCode) {

        case FSCTL_DISMOUNT_VOLUME:
            //
            // Note that we call indirect through our driver object so that the
            // generated code ends up being identical between GDFX/RAWX/UDFX.
            //

            status = DeviceObject->DriverObject->DriverDismountVolume(DeviceObject);
            break;

        default:
            status = STATUS_INVALID_DEVICE_REQUEST;
            break;
    }

    Irp->IoStatus.Status = status;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\udfx\read.c ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    read.c

Abstract:

    This module implements routines related to handling IRP_MJ_READ.

--*/

#include "udfx.h"

NTSTATUS
UdfxNonCachedReadCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:

    This routine is called to process the completion of a non-cached file read.

Arguments:

    DeviceObject - Specifies the device object that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

    Context - Specifies the context that was supplied to IoSetCompletionRoutine.

Return Value:

    Status of operation.

--*/
{
    PIO_STACK_LOCATION IrpSp;
    PFILE_OBJECT FileObject;
    ULONG ReadLength;

    //
    // This completion routine is set to be called only on IRP success.
    //

    ASSERT(NT_SUCCESS(Irp->IoStatus.Status));

    IrpSp = IoGetCurrentIrpStackLocation(Irp);
    FileObject = IrpSp->FileObject;
    ReadLength = IrpSp->Parameters.Read.Length;

    //
    // Assert that the device handled as many bytes as we programmed it to.
    //

    ASSERT(Irp->IoStatus.Information == UDF_CD_SECTOR_ALIGN_UP(ReadLength));

    //
    // Propagate the pending flag up the IRP stack.
    //

    if (Irp->PendingReturned) {
        IoMarkIrpPending(Irp);
    }

    //
    // Fix the number of bytes read to the number that we computed inside
    // UdfxFsdRead.  This number may be less than the actual number of bytes
    // read from the device if we're at the end of file.
    //

    Irp->IoStatus.Information = ReadLength;

    //
    // If the file is open for synchronous I/O, then we need to update the
    // current file position.
    //

    if (UdfxIsFlagSet(FileObject->Flags, FO_SYNCHRONOUS_IO)) {
        FileObject->CurrentByteOffset.QuadPart =
            IrpSp->Parameters.Read.ByteOffset.QuadPart + ReadLength;
    }

    return STATUS_SUCCESS;
}

NTSTATUS
UdfxFsdRead(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is called by the I/O manager to handle IRP_MJ_READ requests.

Arguments:

    DeviceObject - Specifies the device object that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    PUDF_VOLUME_EXTENSION VolumeExtension;
    PIO_STACK_LOCATION IrpSp;
    PIO_STACK_LOCATION NextIrpSp;
    PFILE_OBJECT FileObject;
    PUDF_FCB Fcb;
    ULONG ReadLength;
    BOOLEAN NonCachedEndOfFileTransfer;
    ULONGLONG FileBytesRemaining;
    ULONGLONG PhysicalByteOffset;

    VolumeExtension = (PUDF_VOLUME_EXTENSION)DeviceObject->DeviceExtension;
    IrpSp = IoGetCurrentIrpStackLocation(Irp);
    NextIrpSp = IoGetNextIrpStackLocation(Irp);
    FileObject = IrpSp->FileObject;
    Fcb = (PUDF_FCB)FileObject->FsContext;
    ReadLength = IrpSp->Parameters.Read.Length;
    NonCachedEndOfFileTransfer = FALSE;

    //
    // Check if the volume has been dismounted.
    //

    if (VolumeExtension->Dismounted) {
        status = STATUS_VOLUME_DISMOUNTED;
        goto CleanupAndExit;
    }

    //
    // Ensure that the file object is not for a directory.
    //

    if (UdfxIsFlagSet(Fcb->Flags, UDF_FCB_DIRECTORY)) {
        status = STATUS_INVALID_DEVICE_REQUEST;
        goto CleanupAndExit;
    }

    //
    // Disable support for reading from files with data embedded in the file
    // identifier descriptor.
    //

    if (UdfxIsFlagSet(Fcb->Flags, UDF_FCB_EMBEDDED_DATA)) {
        status = STATUS_ACCESS_DENIED;
        goto CleanupAndExit;
    }

    //
    // If this is a zero length request, then we can complete the IRP now.
    //

    if (ReadLength == 0) {
        Irp->IoStatus.Information = 0;
        status = STATUS_SUCCESS;
        goto CleanupAndExit;
    }

    //
    // Check if the starting offset is beyond the end of file.
    //

    if ((ULONGLONG)IrpSp->Parameters.Read.ByteOffset.QuadPart >=
        (ULONGLONG)Fcb->FileSize.QuadPart) {
        status = STATUS_END_OF_FILE;
        goto CleanupAndExit;
    }

    //
    // If the number of bytes to read is greater than the number of bytes
    // remaining in the file, then truncate the number of bytes we'll actually
    // read.
    //

    FileBytesRemaining = (ULONGLONG)Fcb->FileSize.QuadPart -
        (ULONGLONG)IrpSp->Parameters.Read.ByteOffset.QuadPart;

    if ((ULONGLONG)ReadLength >= FileBytesRemaining) {

        if (UdfxIsFlagClear(Fcb->Flags, UDF_FCB_VOLUME)) {

            //
            // If the user's buffer is large enough to hold the logical read
            // length rounded up to a sector boundary, then set a flag so that
            // the below code will potentially read this part of the file as
            // non cached.
            //

            if (ReadLength >= (UDF_CD_SECTOR_ALIGN_UP(Fcb->FileSize.LowPart) -
                IrpSp->Parameters.Read.ByteOffset.LowPart)) {
                NonCachedEndOfFileTransfer = TRUE;
            }
        }

        ReadLength = (ULONG)FileBytesRemaining;
    }

    ASSERT(ReadLength > 0);

    //
    // Check if we're supposed to bypass the file system cache.
    //
    // If this is a physical volume file control block, also bypass the cache.
    // This was the behavior of the old file systems and it also let's us avoid
    // having to deal with the volume case in the cached path.
    //

    if (UdfxIsFlagSet(Irp->Flags, IRP_NOCACHE) ||
        UdfxIsFlagSet(Fcb->Flags, UDF_FCB_VOLUME)) {

        IoCopyCurrentIrpStackLocationToNext(Irp);

        //
        // Lock the user's buffer into memory if necessary.
        //

        IoLockUserBuffer(Irp, IrpSp->Parameters.Read.Length);

        //
        // The file is contiguous on disk, so we can pass this IRP down to the
        // target device after adjusting the starting byte offset assuming this
        // isn't a volume file control block.
        //

        if (UdfxIsFlagClear(Fcb->Flags, UDF_FCB_VOLUME)) {
            NextIrpSp->Parameters.Read.ByteOffset.QuadPart +=
                ((ULONGLONG)(VolumeExtension->PartitionSectorStart +
                Fcb->AllocationSectorStart) << UDF_CD_SECTOR_SHIFT);
        }

        //
        // Limit the number of bytes physically read to the end of the file or
        // volume.
        //

        NextIrpSp->Parameters.Read.Length = UDF_CD_SECTOR_ALIGN_UP(ReadLength);

        //
        // If the actual number of bytes we're to read is less than the number
        // of bytes we'll read from the physical device, then set a completion
        // routine to fix IO_STATUS_BLOCK.Information to be the actual number
        // of bytes.  We'll store the actual number of bytes back in the IRP so
        // that we don't have to calculate it again.
        //
        // If this is a synchronous I/O operation, then set a completion routine
        // so that we can update the current file position.
        //
        // We don't have to do either of the above if the IRP completes with an
        // error.
        //

        if ((IrpSp->Parameters.Read.Length != ReadLength) ||
            UdfxIsFlagSet(FileObject->Flags, FO_SYNCHRONOUS_IO)) {

            IrpSp->Parameters.Read.Length = ReadLength;

            IoSetCompletionRoutine(Irp, UdfxNonCachedReadCompletion, NULL, TRUE,
                FALSE, FALSE);
        }

        //
        // Call down to the target device.
        //

        return IoCallDriver(VolumeExtension->TargetDeviceObject, Irp);
    }

    //
    // Scatter/gather operations are always non-cached.
    //

    ASSERT(UdfxIsFlagClear(Irp->Flags, IRP_SCATTER_GATHER_OPERATION));

    //
    // Otherwise, handle reading the data using the file cache.
    //

    PhysicalByteOffset = IrpSp->Parameters.Read.ByteOffset.QuadPart +
        ((ULONGLONG)(VolumeExtension->PartitionSectorStart +
        Fcb->AllocationSectorStart) << UDF_CD_SECTOR_SHIFT);

    status = FscCachedRead(&VolumeExtension->CacheExtension, Irp,
        PhysicalByteOffset, ReadLength, NonCachedEndOfFileTransfer);

CleanupAndExit:
    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\udfx\udfsup.c ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    udfsup.c

Abstract:

    This module implements UDF file system utility routines.

--*/

#include "udfx.h"

BOOLEAN
UdfxVerifyDescriptor(
    IN PDESTAG Descriptor,
    IN ULONG DescriptorSize,
    IN USHORT Ident,
    IN ULONG LogicalSectorNumber
    )
/*++

Routine Description:

    This routine checks if the supplied descriptor tag is structurally correct.

    Refer to ISO 13346 section 3/7.2.

Arguments:

    Descriptor - Specifies the descriptor tag to verify.

    DescriptorSize - Specifies the size in bytes of the descriptor.

    Ident - Specifies the expected identifier of the tag.

    LogicalSectorNumber - Specifies the expected sector number of the tag.

Return Value:

    Returns TRUE if the descriptor is structurally correct, else FALSE.

--*/
{
    if ((Descriptor->Version == DESTAG_VER_CURRENT) &&
        (Descriptor->Ident == Ident) &&
        (Descriptor->Lbn == LogicalSectorNumber)) {
        return TRUE;
    } else {
        return FALSE;
    }
}

BOOLEAN
UdfxEqualOSTACS0StringAndObjectString(
    IN PUCHAR OSTACS0String,
    IN SIZE_T OSTACS0StringLength,
    IN POBJECT_STRING ObjectString
    )
/*++

Routine Description:

    This routine does a case insensitive comparision of a OSTA CS0 string to an
    object manager string.

Arguments:

    OSTACS0String - Specifies the OSTA CS0 string to compare.

    OSTACS0StringLength - Specifies the length of the OSTA CS0 string.

    ObjectString - Specifies the object manager string to compare.

Return Value:

    Returns TRUE if the strings are equal, else FALSE.

--*/
{
    POSTR ObjectBuffer;
    OCHAR c1;
    OCHAR c2;

    //
    // The first byte of an OSTA Compressed Unicode string is the compression
    // format, which is either going to be 8-bits per character or 16-bits per
    // character.  All other values are reserved and we'll treat as a failed
    // compare.
    //

    if (*OSTACS0String != 8) {
        return FALSE;
    }

    //
    // Advance past the compression code.
    //

    OSTACS0String++;
    OSTACS0StringLength--;

    //
    // Check if the lengths of the strings match.
    //

    if (ObjectString->Length != OSTACS0StringLength * sizeof(OCHAR)) {
        return FALSE;
    }

    ObjectBuffer = ObjectString->Buffer;

    while (OSTACS0StringLength) {

        c1 = *ObjectBuffer++;
        c2 = (OCHAR)*OSTACS0String++;

        if ((c1 != c2) && (RtlUpperChar(c1) != RtlUpperChar(c2))) {
            return FALSE;
        }

        OSTACS0StringLength -= sizeof(CHAR);
    }

    return TRUE;
}

NTSTATUS
UdfxOSTACS0StringToObjectString(
    IN PUCHAR OSTACS0String,
    IN SIZE_T OSTACS0StringLength,
    OUT POBJECT_STRING ObjectString
    )
/*++

Routine Description:

    This routine converts a OSTA CS0 string to an object manager string.

Arguments:

    OSTACS0String - Specifies the source string to convert.

    OSTACS0StringLength - Specifies the length of the source string.

    ObjectString - Specifies the buffer to receive the converted object manager
        string.

Return Value:

    Status of operation.

--*/
{
    POSTR ObjectBuffer;

    ObjectString->Buffer = NULL;

    if (OSTACS0StringLength != 0) {

        //
        // The first byte of an OSTA Compressed Unicode string is the compression
        // format, which is either going to be 8-bits per character or 16-bits
        // per character.
        //

        if (*OSTACS0String == 8) {

            //
            // Advance past the compression code.
            //

            OSTACS0String++;
            OSTACS0StringLength--;

            //
            // Allocate a buffer to receive the object manager string.
            //

            ObjectBuffer = ExAllocatePoolWithTag(OSTACS0StringLength *
                sizeof(OCHAR), 'gSxU');

            if (ObjectBuffer == NULL) {
                return STATUS_INSUFFICIENT_RESOURCES;
            }

            ObjectString->Buffer = ObjectBuffer;
            ObjectString->Length = (USHORT)(OSTACS0StringLength * sizeof(OCHAR));
            ObjectString->MaximumLength = ObjectString->Length;

            //
            // Fill in the output buffer.
            //

            RtlCopyMemory(ObjectBuffer, OSTACS0String, OSTACS0StringLength);

            return STATUS_SUCCESS;
        }
    }

    return STATUS_INVALID_PARAMETER;
}

LARGE_INTEGER
UdfxUdfTimestampToTime(
    IN PTIMESTAMP UdfTimestamp
    )
/*++

Routine Description:

    This routine converts a UDF timestamp to a NT system time.

Arguments:

    UdfTimestamp - Specifies the timestamp to convert to NT system time.

Return Value:

    Conversion to NT system time.

--*/
{
    LARGE_INTEGER SystemTime;
    TIME_FIELDS TimeField;

    TimeField.Year = UdfTimestamp->Year;
    TimeField.Month = UdfTimestamp->Month;
    TimeField.Day = UdfTimestamp->Day;
    TimeField.Hour = UdfTimestamp->Hour;
    TimeField.Minute = UdfTimestamp->Minute;
    TimeField.Second = UdfTimestamp->Second;
    TimeField.Milliseconds = 0;

    //
    // Validate the timestamp is valid and convert it to a system time.
    //

    if ((UdfTimestamp->Type <= TIMESTAMP_T_LOCAL) &&
        ((UdfTimestamp->Zone >= TIMESTAMP_Z_MIN && UdfTimestamp->Zone <= TIMESTAMP_Z_MAX) ||
            (UdfTimestamp->Zone == TIMESTAMP_Z_NONE)) &&
        RtlTimeFieldsToTime(&TimeField, &SystemTime)) {

        //
        // If necessary, convert to coordinated universal time.
        //

        if ((UdfTimestamp->Type == TIMESTAMP_T_LOCAL) &&
            (UdfTimestamp->Zone != TIMESTAMP_Z_NONE)) {
            SystemTime.QuadPart -= (ULONGLONG)UdfTimestamp->Zone * 60 * 10 * 1000 * 1000;
        }

    } else {

        SystemTime.QuadPart = 0;
    }

    return SystemTime;
}

NTSTATUS
UdfxMapLogicalSector(
    IN PUDF_VOLUME_EXTENSION VolumeExtension,
    IN PIRP Irp,
    IN ULONG LogicalSectorNumber,
    OUT PVOID *CacheBuffer
    )
/*++

Routine Description:

    This routine maps the supplied logical sector number into the file system
    cache.

Arguments:

    VolumeExtension - Specifies the extension that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

    LogicalSectorNumber - Specifies the number of the logical sector to map into
        the cache.

    CacheBuffer - Specifies the buffer to receive the address of the mapped
        cache buffer.

Return Value:

    Status of operation.

--*/
{
    ULONGLONG ByteOffset;

    //
    // Verify that the logical sector resides inside the physical partition.
    //

    if (LogicalSectorNumber >= VolumeExtension->PartitionSectorCount) {
        return STATUS_DISK_CORRUPT_ERROR;
    }

    //
    // Convert the logical sector to the disk offset.
    //

    ByteOffset = ((ULONGLONG)VolumeExtension->PartitionSectorStart +
        LogicalSectorNumber) << UDF_CD_SECTOR_SHIFT;

    //
    // Map the directory sector into the cache.
    //

    return FscMapBuffer(&VolumeExtension->CacheExtension, Irp, ByteOffset,
        FALSE, CacheBuffer);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\udfx\udfx.h ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    udfx.h

Abstract:

    This module contains the private data structures and procedure prototypes
    for the UDF file system driver.

--*/

#ifndef _UDFX_
#define _UDFX_

#include <ntos.h>
#include <ntddcdrm.h>
#include <ntdddisk.h>
#include "iso13346.h"

#include <pshpack4.h>

//
// DBG sensitive DbgPrint wrapper.
//

#if DBG
#define UdfxDbgPrint(x)                         DbgPrint x
#else
#define UdfxDbgPrint(x)
#endif

//
// Bit flag macros.
//

#define UdfxIsFlagSet(flagset, flag)            (((flagset) & (flag)) != 0)
#define UdfxIsFlagClear(flagset, flag)          (((flagset) & (flag)) == 0)

//
// Returns the number of elements in the supplied array.
//

#define ARRAY_ELEMENTS(array)                                                 \
    (sizeof((array)) / sizeof((array)[0]))

//
// Define the recognized version numbers of the UDF specification.
//

#define UDF_VERSION_100                         0x0100
#define UDF_VERSION_101                         0x0101
#define UDF_VERSION_102                         0x0102
#define UDF_VERSION_150                         0x0150

#define UDF_VERSION_MINIMUM                     UDF_VERSION_100
#define UDF_VERSION_MAXIMUM                     UDF_VERSION_150

//
// Define the static drive geometry for a CD-ROM device supported by this file
// system.
//

#define UDF_CD_SECTOR_SHIFT                     11
#define UDF_CD_SECTOR_SIZE                      (1 << UDF_CD_SECTOR_SHIFT)
#define UDF_CD_SECTOR_MASK                      (UDF_CD_SECTOR_SIZE - 1)

//
// Define a macro to align the supplied number of bytes down or up to the next
// sector boundary.
//

#define UDF_CD_SECTOR_ALIGN_DOWN(cb) \
    (((SIZE_T)(cb) & (~UDF_CD_SECTOR_MASK))
#define UDF_CD_SECTOR_ALIGN_UP(cb) \
    (((SIZE_T)(cb) + UDF_CD_SECTOR_SIZE - 1) & (~UDF_CD_SECTOR_MASK))

//
// Define a macro to check if a length is sector aligned.
//

#define UdfxIsSectorAligned(value) \
    ((LOGICAL)(((ULONG)(value) & UDF_CD_SECTOR_MASK) == 0))

//
// Define file control block flags.
//

#define UDF_FCB_VOLUME                          0x01
#define UDF_FCB_DIRECTORY                       0x02
#define UDF_FCB_ROOT_DIRECTORY                  0x04
#define UDF_FCB_EMBEDDED_DATA                   0x08

//
// File control block.
//

typedef struct _UDF_FCB {
    UCHAR Flags;
    UCHAR FileNameLength;
    USHORT EmbeddedDataOffset;
    ULONG AllocationSectorStart;
    LARGE_INTEGER FileSize;
    TIMESTAMP ModifyTime;
    ULONG ReferenceCount;
    struct _UDF_FCB *ParentFcb;
    LIST_ENTRY SiblingFcbLink;
    LIST_ENTRY ChildFcbList;
    OCHAR FileName[0];
} UDF_FCB, *PUDF_FCB;

//
// Volume device extension data.
//

typedef struct _UDF_VOLUME_EXTENSION {
    union {
        FSCACHE_EXTENSION CacheExtension;
        FSCACHE_EXTENSION;
    };
    PUDF_FCB VolumeFcb;
    PUDF_FCB RootDirectoryFcb;
    ULONG PhysicalSectorCount;
    ULONG PartitionSectorStart;
    ULONG PartitionSectorCount;
    ULONG FileObjectCount;
    BOOLEAN Dismounted;
} UDF_VOLUME_EXTENSION, *PUDF_VOLUME_EXTENSION;

//
// File system dismount routine.
//

NTSTATUS
UdfxDismountVolume(
    IN PDEVICE_OBJECT DeviceObject
    );

//
// IRP dispatch routines.
//

NTSTATUS
UdfxFsdClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
UdfxFsdCreate(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
UdfxFsdDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
UdfxFsdDirectoryControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
UdfxFsdFileSystemControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
UdfxFsdQueryInformation(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
UdfxFsdQueryVolumeInformation(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
UdfxFsdRead(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
UdfxFsdSetInformation(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

//
// Cache support routines.
//

NTSTATUS
UdfxMapLogicalSector(
    IN PUDF_VOLUME_EXTENSION VolumeExtension,
    IN PIRP Irp,
    IN ULONG LogicalSectorNumber,
    OUT PVOID *CacheBuffer
    );

//
// File control block support routines.
//

NTSTATUS
UdfxCreateFcbFromFileEntry(
    IN PUDF_VOLUME_EXTENSION VolumeExtension,
    IN PIRP Irp,
    IN PLONGAD IcbExtent,
    IN PUDF_FCB ParentFcb OPTIONAL,
    IN POBJECT_STRING FileName OPTIONAL,
    OUT PUDF_FCB *ReturnedFcb
    );

BOOLEAN
UdfxFindOpenChildFcb(
    IN PUDF_FCB DirectoryFcb,
    IN POBJECT_STRING FileName,
    OUT PUDF_FCB *ReturnedFcb
    );

VOID
UdfxDereferenceFcb(
    IN PUDF_FCB Fcb
    );

//
// Synchronization routines.
//

#define UdfxAcquireGlobalMutexExclusive() \
    RtlEnterCriticalSectionAndRegion(&UdfxGlobalMutex)

#define UdfxReleaseGlobalMutex() \
    RtlLeaveCriticalSectionAndRegion(&UdfxGlobalMutex)

//
// Miscellaneous routines.
//

BOOLEAN
UdfxVerifyDescriptor(
    IN PDESTAG Descriptor,
    IN ULONG DescriptorSize,
    IN USHORT Ident,
    IN ULONG LogicalSectorNumber
    );

BOOLEAN
UdfxEqualOSTACS0StringAndObjectString(
    IN PUCHAR OSTACS0String,
    IN SIZE_T OSTACS0StringLength,
    IN POBJECT_STRING ObjectString
    );

NTSTATUS
UdfxOSTACS0StringToObjectString(
    IN PUCHAR OSTACS0String,
    IN SIZE_T OSTACS0StringLength,
    OUT POBJECT_STRING ObjectString
    );

LARGE_INTEGER
UdfxUdfTimestampToTime(
    IN PTIMESTAMP UdfTimestamp
    );

VOID
UdfxDeleteVolumeDevice(
    IN PDEVICE_OBJECT VolumeDeviceObject
    );

//
// External symbols.
//

extern DRIVER_OBJECT UdfxDriverObject;
extern RTL_CRITICAL_SECTION UdfxGlobalMutex;

#include <poppack.h>

#endif  // UDFX
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\udfx\volinfo.c ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    volinfo.c

Abstract:

    This module implements routines related to handling
    IRP_MJ_QUERY_VOLUME_INFORMATION.

--*/

#include "udfx.h"

NTSTATUS
UdfxFsdQueryVolumeInformation(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is called by the I/O manager to handle
    IRP_MJ_QUERY_VOLUME_INFORMATION requests.

Arguments:

    DeviceObject - Specifies the device object that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    PUDF_VOLUME_EXTENSION VolumeExtension;
    PIO_STACK_LOCATION IrpSp;
    ULONG BytesWritten;
    PFILE_FS_SIZE_INFORMATION SizeInformation;
    PFILE_FS_DEVICE_INFORMATION DeviceInformation;
    PFILE_FS_ATTRIBUTE_INFORMATION AttributeInformation;

    VolumeExtension = (PUDF_VOLUME_EXTENSION)DeviceObject->DeviceExtension;
    IrpSp = IoGetCurrentIrpStackLocation(Irp);

    //
    // Clear the output buffer.
    //

    RtlZeroMemory(Irp->UserBuffer, IrpSp->Parameters.QueryVolume.Length);

    //
    // Dispatch the information class function.
    //

    status = STATUS_SUCCESS;

    switch (IrpSp->Parameters.QueryVolume.FsInformationClass) {

        case FileFsVolumeInformation:
            NOTHING;
            BytesWritten = FIELD_OFFSET(FILE_FS_VOLUME_INFORMATION, VolumeLabel);
            break;

        case FileFsSizeInformation:
            SizeInformation = (PFILE_FS_SIZE_INFORMATION)Irp->UserBuffer;
            SizeInformation->TotalAllocationUnits.QuadPart =
                VolumeExtension->PartitionLength.QuadPart >> UDF_CD_SECTOR_SHIFT;
            SizeInformation->SectorsPerAllocationUnit = 1;
            SizeInformation->BytesPerSector = UDF_CD_SECTOR_SIZE;
            BytesWritten = sizeof(FILE_FS_SIZE_INFORMATION);
            break;

        case FileFsDeviceInformation:
            DeviceInformation = (PFILE_FS_DEVICE_INFORMATION)Irp->UserBuffer;
            DeviceInformation->DeviceType =
                VolumeExtension->TargetDeviceObject->DeviceType;
            DeviceInformation->Characteristics = 0;
            BytesWritten = sizeof(FILE_FS_DEVICE_INFORMATION);
            break;

        case FileFsAttributeInformation:
            AttributeInformation =
                (PFILE_FS_ATTRIBUTE_INFORMATION)Irp->UserBuffer;
            AttributeInformation->FileSystemAttributes = 0;
            AttributeInformation->MaximumComponentNameLength = 255;
            AttributeInformation->FileSystemNameLength = sizeof(OCHAR) * 4;

            if (IrpSp->Parameters.QueryVolume.Length <
                FIELD_OFFSET(FILE_FS_ATTRIBUTE_INFORMATION, FileSystemName) +
                sizeof(OCHAR) * 4) {
                BytesWritten = FIELD_OFFSET(FILE_FS_ATTRIBUTE_INFORMATION,
                    FileSystemName);
                status = STATUS_BUFFER_OVERFLOW;
            } else {
                RtlCopyMemory(AttributeInformation->FileSystemName, OTEXT("UDFX"),
                    sizeof(OCHAR) * 4);
                BytesWritten = FIELD_OFFSET(FILE_FS_ATTRIBUTE_INFORMATION,
                    FileSystemName) + sizeof(OCHAR) * 4;
            }
            break;

        default:
            BytesWritten = 0;
            status = STATUS_INVALID_PARAMETER;
            break;
    }

    //
    // Fill in the number of bytes that we wrote to the user's buffer.
    //

    Irp->IoStatus.Information = BytesWritten;

    //
    // Check that we didn't overflow the user's buffer.  The I/O manager does
    // the initial check to make sure there's enough space for the static
    // structure for a given information class, but we might overflow the buffer
    // when copying in the variable length file name.
    //

    ASSERT(Irp->IoStatus.Information <= IrpSp->Parameters.QueryVolume.Length);

    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\inc\minix.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    minix.h

Abstract:

    Contains declarations for minix    

--*/


typedef struct _MINIX_MODE_INFO
{
    LONG Width; 
    LONG Height; 
    LONG BitDepth;
    ULONG PushBase;
    ULONG PushLimit;
    ULONG NotificationBase;    
    ULONG NotificationLimit;
    ULONG HostMemoryBase;
    ULONG HostMemoryLimit;
    
    PVOID DevFlatDma;          // Filled by SetVideoMode 
    PVOID VidMemAddress;       // Filled by SetVideoMode
    PVOID NvBase;              // Filled by SetVideoMode

} MINIX_MODE_INFO, *PMINIX_MODE_INFO;




//
// Major function codes used for the to access functions in the dispatch table
// of the minix driver object. Since this is not a real driver, the dispatch 
// function is used to pass alternate functions
//

#define IRP_MJ_MINIX_CREATE                0x00    // PMINIX_CREATE
#define IRP_MJ_MINIX_SETVIDEOMODE          0x01    // PMINIX_SETVIDEOMODE
#define IRP_MJ_MINIX_ALLOCCONTEXTDMA       0x02    // PMINIX_ALLOCCONTEXTDMA


typedef
LONG
(*PMINIX_CREATE) (
    VOID
    );

typedef
LONG
(*PMINIX_SETVIDEOMODE) (
    IN OUT PMINIX_MODE_INFO ModeInfo
    );

typedef
LONG
(*PMINIX_ALLOCCONTEXTDMA)(
    IN ULONG Dma,
    IN ULONG Class,
    IN ULONG Flags,
    IN PVOID Base,
    IN ULONG Limit
        );



LONG
MxInitSystem(
    IN PVOID Argument1
    );
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\minix\agpuma.c ===
/*++

Copyright (c) 1990-2000  Microsoft Corporation

Module Name:

    agpuma.c

Abstract:

    This module maps all physical memory into the AGP address space.  It is
    used by the XBOX to simulate UMA.

--*/

// Nasty path, but there are only two files that need to make kernel calls.
#include <ntos.h>
#include <pci.h>
#include <ntddvdeo.h>
#include <ntagp.h>
#include <stdio.h>

#if defined(DBG)

    #define RIP(msg)            \
        {                       \
            DbgPrint msg;     \
            DbgPrint("\n");   \
            _asm { int 3 };     \
        }

#else

    #define RIP(msg) {}

#endif

//
// Conversions from APSIZE encoding to MB
//

#define AP_SIZE_4MB     0x3F
#define AP_SIZE_8MB     0x3E
#define AP_SIZE_16MB    0x3C
#define AP_SIZE_32MB    0x38
#define AP_SIZE_64MB    0x30
#define AP_SIZE_128MB   0x20
#define AP_SIZE_256MB   0x00

//
// Define the location of the GART aperture control registers
//

#define HOST_BUS                0
#define HOST_SLOT               0

//
// Define the location of the video card
//

#define CARD_BUS                1
#define CARD_SLOT               0

//
// Defines what mode we're using.  If the hardware doesn't support this then
// we'll RIP.
//

#define AGP_APERTURE_SIZE       AP_SIZE_64MB
#define AGP_APERTURE_BYTES      (64*1024*1024)
#define AGP_APERTURE_BASE       0xF8000000

//
// Offsets for host the registers we need to poke directly.
//

#define APBASE_OFFSET   0x10            // Aperture Base Address
#define APSIZE_OFFSET   0xB4            // Aperture Size Register
#define AGPCTRL_OFFSET  0xB0            // AGP Control Register
#define ATTBASE_OFFSET  0xB8            // Aperture Translation Table Base
#define RDCR_OFFSET     0x51            // RDRAM Control register
#define AGPBCTRL_OFFSET 0xE8            // AGP buffer control register
//
// Define the layout of the hardware registers
//

typedef struct _AGPCTRL 
{
    ULONG FourXOverride:1;              // forces AGP 2x mode
    ULONG FastWriteEnable:1;            // enables fast writes
    ULONG Reserved1:5;
    ULONG EnableGART:1;                 // enables the GART
    ULONG Reserved2:24;
} AGPCTRL;

typedef struct _RDCR
{
    UCHAR Reserved1:1;
    UCHAR ApertureEnable:1;             // enable AGP aperture
    UCHAR Reserved2:4;
    UCHAR PBS:1;
    UCHAR Reserved3:1;
} RDCR;

//
// GART entry structure
//

typedef struct _GART_PTE 
{
    ULONG Valid     :  1;
    ULONG Reserved  : 11;
    ULONG Page      : 20;
} GART_PTE, *PGART_PTE;

//
// Simple wrappers to make reading/writing host register values
// a little easier.
//

#define ReadHostRegister(_buf_, _offset_, _size_)           \
                                                            \
    ReadDeviceData(HOST_BUS,                                \
                   HOST_SLOT,                               \
                   (_buf_),                                 \
                   (_offset_),                              \
                   (_size_));                       

#define WriteHostRegister(_buf_, _offset_, _size_)          \
                                                            \
    WriteDeviceData(HOST_BUS,                               \
                    HOST_SLOT,                              \
                    (_buf_),                                \
                    (_offset_),                             \
                    (_size_));                      

//============================================================================
// AGP Code
//============================================================================

//----------------------------------------------------------------------------
// Read data from a PCI device.
//
static ULONG ReadDeviceData(
    ULONG Bus,
    ULONG Slot,
    PVOID Buffer,
    ULONG Offset,
    ULONG Length
    )
{
    ULONG Transferred;

    Transferred = HalGetBusDataByOffset(PCIConfiguration,
                                        Bus,
                                        Slot,
                                        Buffer,
                                        Offset,
                                        Length);

    return (Transferred == Length);
}

//----------------------------------------------------------------------------
// Write data to a PCI device.
//
static void WriteDeviceData(
    ULONG Bus,
    ULONG Slot,
    PVOID Buffer,
    ULONG Offset,
    ULONG Length
    )
{
    ULONG Transferred;

    Transferred = HalSetBusDataByOffset(PCIConfiguration,
                                        Bus,
                                        Slot,
                                        Buffer,
                                        Offset,
                                        Length);

    ASSERT(Transferred == Length);
}

//----------------------------------------------------------------------------
// Walk an AGP device's configuration space to find a specific capability.
//
static UCHAR ReadAgpCapability(
    ULONG Bus,
    ULONG Slot,
    PCI_AGP_CAPABILITY *Capability
    )
{
    PCI_COMMON_CONFIG Header;
    UCHAR CapabilityOffset;

    //
    // Read the PCI common header to get the capabilities pointer
    //

    ReadDeviceData(Bus, Slot, &Header, 0, sizeof(PCI_COMMON_CONFIG));

    //
    // Check the Status register to see if this device supports capability lists.
    // If not, it is not an AGP-compliant device.
    //

    if ((Header.Status & PCI_STATUS_CAPABILITIES_LIST) == 0) 
    {
        RIP(("FindAgpCapability - Device does not support Capabilities list, not an AGP device"));
        return 0;
    }

    //
    // The device supports capability lists, find the AGP capabilities.
    //

    if ((Header.HeaderType & (~PCI_MULTIFUNCTION)) == PCI_BRIDGE_TYPE) 
    {
        CapabilityOffset = Header.u.type1.CapabilitiesPtr;
    } 
    else 
    {
        ASSERT((Header.HeaderType & (~PCI_MULTIFUNCTION)) == PCI_DEVICE_TYPE);
        CapabilityOffset = Header.u.type0.CapabilitiesPtr;
    }

    while (CapabilityOffset != 0) 
    {
        //
        // Read the Capability at this offset
        //

        ReadDeviceData(Bus, Slot, Capability, CapabilityOffset, sizeof(PCI_AGP_CAPABILITY));

        // Find it?
        if (Capability->Header.CapabilityID == PCI_CAPABILITY_ID_AGP) 
        {
            break;
        } 
        else 
        {
            CapabilityOffset = Capability->Header.Next;
        }
    }

    if (CapabilityOffset == 0) 
    {
        // No AGP capability was found
        RIP(("FindAgpCapability - Device does not have an AGP Capability entry, not an AGP device"));
        return 0;
    }

    return CapabilityOffset;
}

//----------------------------------------------------------------------------
// Write a capability to a device.
//
static void WriteAgpCapability(
    ULONG Bus,
    ULONG Slot,
    UCHAR CapabilityOffset,
    PCI_AGP_CAPABILITY *Capability
    )
{
    // Write the new information.
    WriteDeviceData(Bus, 
                    Slot, 
                    Capability, 
                    CapabilityOffset, 
                    sizeof(PCI_AGP_CAPABILITY));
}

//----------------------------------------------------------------------------
// Set up the hardware to talk to each other.
//
static void SetupAgp()
{
    AGPCTRL agpctrl;

    PCI_AGP_CAPABILITY HostCap;
    PCI_AGP_CAPABILITY CardCap;    

    UCHAR HostCapOffset;
    UCHAR CardCapOffset;

    ULONG DataRate;
    
    //
    // Initialize the host to support fast writes.
    //

    ReadHostRegister(&agpctrl, AGPCTRL_OFFSET, sizeof(agpctrl));

    agpctrl.FastWriteEnable = 1;

    WriteHostRegister(&agpctrl, AGPCTRL_OFFSET, sizeof(agpctrl));

    //
    // Get the capabilities of both the host and the card.
    //

    HostCapOffset = ReadAgpCapability(HOST_BUS, HOST_SLOT, &HostCap);
    CardCapOffset = ReadAgpCapability(CARD_BUS, CARD_SLOT, &CardCap);

    //
    // Check the data rate.
    //

    DataRate = HostCap.AGPStatus.Rate & CardCap.AGPStatus.Rate;

    if (!(DataRate & PCI_AGP_RATE_4X))
    {
        RIP(("SetupAgp   - Mainboard/graphic card does not support 4x AGP."));
    }

    // 
    // The current graphics card does not support sideband addressing.  Note if 
    // this changes.
    //
    if (HostCap.AGPStatus.SideBandAddressing & CardCap.AGPStatus.SideBandAddressing)
    {
        RIP(("SetupAgp   - Sideband addressing is now available."));
    }

    // 
    // Note if fast writes go away.
    //

    if (!(HostCap.AGPStatus.FastWrite & CardCap.AGPStatus.FastWrite))
    {
        RIP(("SetupAgp   - Fast write are not available."));
    }

    //
    // Enable the host first.
    //

    HostCap.AGPCommand.Rate = PCI_AGP_RATE_4X;
    HostCap.AGPCommand.AGPEnable = 1;
    HostCap.AGPCommand.SBAEnable = 0;
    HostCap.AGPCommand.FastWriteEnable = 1;
    HostCap.AGPCommand.FourGBEnable = 0;  

    WriteAgpCapability(HOST_BUS, HOST_SLOT, HostCapOffset, &HostCap);

    //
    // Now enable the card
    //

    CardCap.AGPCommand.Rate = PCI_AGP_RATE_4X;
    CardCap.AGPCommand.AGPEnable = 1;
    CardCap.AGPCommand.SBAEnable = 0;
    CardCap.AGPCommand.FastWriteEnable = 1;
    CardCap.AGPCommand.FourGBEnable = 0;  
    CardCap.AGPCommand.RequestQueueDepth = HostCap.AGPStatus.RequestQueueDepthMaximum;

    WriteAgpCapability(CARD_BUS, CARD_SLOT, CardCapOffset, &CardCap);
}

//============================================================================
// GART code
//============================================================================

//----------------------------------------------------------------------------
// Initialize and enable the GART
//
static BOOLEAN SetupGART()
{
    ULONG GartLength;
    GART_PTE *Gart;
    ULONG_PTR GartPhysical;
    AGPCTRL agpctrl;
    RDCR rdcr;
    ULONG i;

#if DBG

    ULONG ApBase;
    UCHAR ApSize;

    //
    // Verity the current APBASE and APSIZE settings
    //

    ReadHostRegister(&ApBase, APBASE_OFFSET, sizeof(ApBase));
    ReadHostRegister(&ApSize, APSIZE_OFFSET, sizeof(ApSize));

    if (ApSize != AGP_APERTURE_SIZE)
    {
        RIP(("SetupGART - Bad aperture size."));
    }

    if ((ApBase & PCI_ADDRESS_MEMORY_ADDRESS_MASK) != AGP_APERTURE_BASE)
    {
        RIP(("SetupGART - Bad Aperature base."));
    }

#endif DBG

    //
    // Try and get a chunk of contiguous memory big enough to map the
    // entire aperture.
    //

    GartLength = BYTES_TO_PAGES(AGP_APERTURE_BYTES) * sizeof(GART_PTE);

    Gart = MmAllocateContiguousMemorySpecifyCache(GartLength, 0, MAXULONG_PTR, 0, MmNonCached);

    if (Gart == NULL) 
    {
        RIP(("SetupGART - MmAllocateContiguousMemory failed\n"));
        return FALSE;
    }

    //
    // We successfully allocated a contiguous chunk of memory.
    // It should be page aligned already.
    //

    ASSERT(((ULONG_PTR)Gart & (PAGE_SIZE - 1)) == 0);

    //
    // Get the physical address.
    //

    GartPhysical = MmGetPhysicalAddress(Gart);

    //
    // Initialize all the PTEs
    //

    for (i = 0; i < GartLength/sizeof(GART_PTE); i++) 
    {
        Gart[i].Valid = 1;
        Gart[i].Page  = i;
    }

    //
    // Update the configuration
    //

    WriteHostRegister(&GartPhysical, ATTBASE_OFFSET, sizeof(GartPhysical));

    // 
    // Enable the gart apeture.
    //

    ReadHostRegister(&agpctrl, AGPCTRL_OFFSET, sizeof(agpctrl));
    agpctrl.EnableGART = 1;
    WriteHostRegister(&agpctrl, AGPCTRL_OFFSET, sizeof(agpctrl));

    ReadHostRegister(&rdcr, RDCR_OFFSET, sizeof(RDCR));
    rdcr.ApertureEnable = 1;
    WriteHostRegister(&rdcr, RDCR_OFFSET, sizeof(RDCR));

    return TRUE;
}

//============================================================================
// Main entrypoint
//============================================================================

//----------------------------------------------------------------------------
// Entrypoint for AGP initializes.  Sets up all AGP stuff for both the host
// and the card.
//
BOOLEAN AgpUmaEnable()
{
    SetupAgp();

    if (!SetupGART())
    {
        return FALSE; 
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\minix\drvx.c ===
/*++

Copyright (c) 1989-2000  Microsoft Corporation

Module Name:

    drvx.c

Abstract:

    This module contains the code to initialize the video hardware

--*/

#include "minixp.h"
#include <nvntioctl.h>
#include "nv32.h"
#include "nvddobj.h"
#include <nvos.h>

//
// Sends an IOCTL to the miniport by calling MxDeviceIoControl.  To use this macro
// your shoud have these 'status' and 'BytesReturned' locals defined and CleanupAndExit label
//

#define IOCTL_CMD(Code, InBuf, InLen, OutBuf, OutLen) { \
            status = MxDeviceIoControl(Code, InBuf, InLen, OutBuf, OutLen, &BytesReturned); \
            if (!NT_SUCCESS(status)) goto CleanupAndExit; }

//
// Helper macro to check status of the return call
//
#define CHECKSTATUS(x) { status = (x); if (!NT_SUCCESS(status)) goto CleanupAndExit; }
  

extern PMINIX_DRIVER_EXTENSION MxDriverExtension;



typedef struct _VIDEOMODEDEF
{
    USHORT  Mode;
    USHORT  Width;
    USHORT  Height;
    UCHAR   Depth;
    UCHAR   Refresh;

} VIDEOMODEDEF, *PVIDEOMODEDEF;


VIDEOMODEDEF g_VideoModeDef[] =
{
#define DEF_VIDEOMODE(Mode, Width, Height, Depth, Refresh) {Mode, Width, Height, Depth, Refresh},
#include "modes.h"
#undef DEF_VIDOEMODE
};






BOOLEAN
NVStartIO(
    PVOID HwDeviceExtension,
    PVIDEO_REQUEST_PACKET RequestPacket
    );



VOID
pVideoPortMapToNtStatus(
    IN PSTATUS_BLOCK StatusBlock
    );


//
// Nvidia object ids
//

#define DD_DEVICE_OBJECT_HANDLE                     (0x00002002)
#define DD_FRAME_BUFFER_OBJECT_HANDLE               (0x000C0006)

#define DD_CONTEXT_DMA_IN_MEMORY_VIDEO_MEM          (0x00001022)

//
// Nvidia alloc context dma flags
//
#define ALLOC_CTX_DMA_FLAGS_ACCESS_RD_WR                    0x00000000
#define ALLOC_CTX_DMA_FLAGS_ACCESS_READ_ONLY                0x00000001
#define ALLOC_CTX_DMA_FLAGS_ACCESS_WRITE_ONLY               0x00000002

#define ALLOC_CTX_DMA_FLAGS_CONTIGUOUS_PHYSICALITY          0x00000000
#define ALLOC_CTX_DMA_FLAGS_NONCONTIGUOUS_PHYSICALITY       0x00000010

#define ALLOC_CTX_DMA_FLAGS_LOCKED_ALWAYS                   0x00000000
#define ALLOC_CTX_DMA_FLAGS_LOCKED_IN_TRANSIT               0x00000100

#define ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED              0x00000000
#define ALLOC_CTX_DMA_FLAGS_COHERENCY_CACHED                0x00001000

#define ALLOC_CTX_DMA_FLAGS_LOCKED_CACHED                   ALLOC_CTX_DMA_FLAGS_LOCKED_ALWAYS + ALLOC_CTX_DMA_FLAGS_COHERENCY_CACHED



NTSTATUS
MxDeviceIoControl(
    IN ULONG IoControlCode,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    OUT PULONG BytesReturned
    )

/*++

Routine Description:

    This routine builds an vrp and calls miniport start io function directly.

Arguments:

Return Value:

    Status of the operation

--*/

{
    NTSTATUS status;
    KEVENT event;
    STATUS_BLOCK StatusBlock;
    PHW_DEVICE_EXTENSION HwDeviceExtension;
    PVIDEO_DEVICE_EXTENSION VideoDeviceExtension;
    VIDEO_REQUEST_PACKET vrp;


    //
    // we only support METHOD_BUFFERED
    //

    if ((IoControlCode & 3) != METHOD_BUFFERED) {
        return STATUS_UNSUCCESSFUL;
    }


    HwDeviceExtension = &(MxDriverExtension->HwExtension);
    VideoDeviceExtension = &(MxDriverExtension->VideoExtension);

    KeInitializeEvent(&event, SynchronizationEvent, FALSE);


    //
    // Initialize the vrp
    //
    RtlZeroMemory(&StatusBlock, sizeof(STATUS_BLOCK));

    vrp.IoControlCode = IoControlCode;
    vrp.StatusBlock = &StatusBlock;
    vrp.InputBuffer = InputBuffer;
    vrp.InputBufferLength = InputBufferLength;
    vrp.OutputBuffer = OutputBuffer;
    vrp.OutputBufferLength = OutputBufferLength;

    //
    // Call the start io routine directly
    //

    ACQUIRE_DEVICE_LOCK(VideoDeviceExtension);

    VideoDeviceExtension->HwStartIO(HwDeviceExtension, &vrp);

    RELEASE_DEVICE_LOCK(VideoDeviceExtension);

    if (StatusBlock.Status != NO_ERROR) {
        pVideoPortMapToNtStatus(&StatusBlock);
    }

    status = StatusBlock.Status;

    //
    // If the call is synchronous, the IO is always completed
    // and the Status is the same as the Iosb.Status.
    //

    if (status == STATUS_PENDING) {

        KeWaitForSingleObject(&event, UserRequest, KernelMode, TRUE, NULL);
    }

    *BytesReturned = StatusBlock.Information;


    return status;
}



VOID
pVideoPortMapToNtStatus(
    IN PSTATUS_BLOCK StatusBlock
    )

/*++

Routine Description:

    This function maps a Win32 error code to an NT error code, making sure
    the inverse translation will map back to the original status code.

Arguments:

    StatusBlock - Pointer to the status block

Return Value:

    None.

--*/

{
    PNTSTATUS status = &StatusBlock->Status;

    switch (*status) {

    case ERROR_INVALID_FUNCTION:
        *status = STATUS_NOT_IMPLEMENTED;
        break;

    case ERROR_NOT_ENOUGH_MEMORY:
        *status = STATUS_INSUFFICIENT_RESOURCES;
        break;

    case ERROR_INVALID_PARAMETER:
        *status = STATUS_INVALID_PARAMETER;
        break;

    case ERROR_INSUFFICIENT_BUFFER:
        *status = STATUS_BUFFER_TOO_SMALL;

        //
        // Make sure we zero out the information block if we get an
        // insufficient buffer.
        //

        StatusBlock->Information = 0;
        break;

    case ERROR_MORE_DATA:
        *status = STATUS_BUFFER_OVERFLOW;
        break;

    case ERROR_DEV_NOT_EXIST:
        *status = STATUS_DEVICE_DOES_NOT_EXIST;
        break;

    case ERROR_IO_PENDING:
        ASSERT(FALSE);
        // Fall through.

    case NO_ERROR:
        *status = STATUS_SUCCESS;
        break;

    default:

        ASSERT(FALSE);

        *status = STATUS_UNSUCCESSFUL;

        break;

    }

    return;

} 



NTSTATUS
NvAllocRoot(
    ULONG hClass,
    ULONG *phClient
    )
{
    NVOS01_PARAMETERS parms;
    PVOID pParms;

    ULONG BytesReturned;
    NTSTATUS status;

    parms.hClass = hClass;
    pParms = &parms;


    IOCTL_CMD((ULONG)IOCTL_NV01_ALLOC_ROOT,
        (&pParms),
        sizeof(PVOID),
        (&parms),
        (ULONG)sizeof(NVOS01_PARAMETERS));

    *phClient = (ULONG)parms.hObjectNew;

    status = (parms.status == 0 ? STATUS_SUCCESS : STATUS_UNSUCCESSFUL);

CleanupAndExit:

    return status;

}


NTSTATUS
NvAllocDevice(
    ULONG hClient,
    ULONG hDevice,
    ULONG hClass,
    PUCHAR szName
    )
{
    NVOS06_PARAMETERS parms;
    PVOID pParms;

    ULONG BytesReturned;
    NTSTATUS status;

    parms.hObjectParent     = (NvV32)hClient;
    parms.hObjectNew        = (NvV32)hDevice;
    parms.hClass            = (NvV32)hClass;

#ifdef NV20MINIX
    parms.szName            = (NvP64)szName;
#else
    parms.szName            = (NvV32)szName;
#endif
    
    pParms = &parms;

    IOCTL_CMD((ULONG)IOCTL_NV01_ALLOC_DEVICE,
        (&pParms),
        sizeof(PVOID),
        (&parms),
        sizeof(NVOS06_PARAMETERS));

    status = (parms.status == 0 ? STATUS_SUCCESS : STATUS_UNSUCCESSFUL);

CleanupAndExit:

    return status;
}


NTSTATUS
NvAllocContextDma(
    ULONG hClient,
    ULONG hDma,
    ULONG hClass,
    ULONG flags,
    PVOID base,
    ULONG limit
    )
{
    NVOS03_PARAMETERS parms;
    PVOID pParms;

    ULONG BytesReturned;
    NTSTATUS status;

    parms.hObjectParent     = (NvV32)hClient;
    parms.hObjectNew        = (NvV32)hDma;
    parms.hClass            = (NvV32)hClass;
    parms.flags             = (NvV32)flags;
#ifdef NV20MINIX
    parms.pBase             = (NvP64)base;
    parms.limit             = (NvU64)limit;
#else    
    parms.pBase.selector    = 0x00000000;
    parms.pBase.offset      = (NvU32)base;
    parms.limit.high        = 0x00000000;
    parms.limit.low         = (NvU32)limit;
#endif

    pParms = &parms;

    IOCTL_CMD((ULONG)IOCTL_NV01_ALLOC_CONTEXT_DMA,
        (&pParms),
        sizeof(PVOID),
        (&parms),
        sizeof(NVOS03_PARAMETERS));

    status = (parms.status == 0 ? STATUS_SUCCESS : STATUS_UNSUCCESSFUL);

CleanupAndExit:

    return status;
}


NTSTATUS
NvAllocObject(
    ULONG hClient,
    ULONG hChannel,
    ULONG hObject,
    ULONG hClass
    )
{
    NVOS05_PARAMETERS parms;
    PVOID pParms;

    ULONG BytesReturned;
    NTSTATUS status;


    // set input parameters
    parms.hRoot             = (NvV32)hClient;
    parms.hObjectParent     = (NvV32)hChannel;
    parms.hObjectNew        = (NvV32)hObject;
    parms.hClass            = (NvV32)hClass;
    pParms = &parms;

    IOCTL_CMD((ULONG)IOCTL_NV01_ALLOC_OBJECT,
        (&pParms),
        sizeof(PVOID),
        (&parms),
        sizeof(NVOS05_PARAMETERS));

    status = (parms.status == 0 ? STATUS_SUCCESS : STATUS_UNSUCCESSFUL);

CleanupAndExit:

    return status;
}


NTSTATUS
NvAllocEvent(
    ULONG hClient,
    ULONG hParent,
    ULONG hObject,
    ULONG hClass,
    ULONG index,
    ULONG hEvent
    )
{
    NVOS10_PARAMETERS parms;
    PVOID pParms;

    ULONG BytesReturned;
    NTSTATUS status;

    // set input parameters
    parms.hRoot             = (NvV32)hClient;
    parms.hObjectParent     = (NvV32)hParent;
    parms.hObjectNew        = (NvV32)hObject;
    parms.hClass            = (NvV32)hClass;
    parms.index             = (NvV32)index;

#ifdef NV20MINIX
    parms.hEvent            = (NvU64)hEvent;
#else
    parms.hEvent.low        = (NvV32)hEvent;
    parms.hEvent.high       = (NvV32)0;
#endif

    pParms = &parms;

    IOCTL_CMD((ULONG)IOCTL_NV01_ALLOC_EVENT,
        (&pParms),
        sizeof(PVOID),
        (&parms),
        sizeof(NVOS10_PARAMETERS));

    status = (parms.status == 0 ? STATUS_SUCCESS : STATUS_UNSUCCESSFUL);

CleanupAndExit:

    return status;
}


NTSTATUS
NvFree(
    ULONG hClient,
    ULONG hParent,
    ULONG hObject
    )
{
    NVOS00_PARAMETERS parms;
    PVOID pParms;

    ULONG BytesReturned;
    NTSTATUS status;

    parms.hRoot             = (NvV32)hClient;
    parms.hObjectParent     = (NvV32)hParent;
    parms.hObjectOld        = (NvV32)hObject;
    pParms = &parms;

    IOCTL_CMD((ULONG)IOCTL_NV01_FREE,
        (&pParms),
        sizeof(PVOID),
        (&parms),
        sizeof(NVOS00_PARAMETERS));

    status = (parms.status == 0 ? STATUS_SUCCESS : STATUS_UNSUCCESSFUL);

CleanupAndExit:

    return status;
}


NTSTATUS
NvAllocMemory(
    ULONG hClient,
    ULONG hParent,
    ULONG hMemory,
    ULONG hClass,
    ULONG flags,
    PVOID *ppAddress,
    ULONG *pLimit
    )
{
    NVOS02_PARAMETERS parms;
    PVOID pParms;

    ULONG BytesReturned;
    NTSTATUS status;


    // set input parameters
    parms.hRoot             = (NvV32)hClient;
    parms.hObjectParent     = (NvV32)hParent;
    parms.hObjectNew        = (NvV32)hMemory;
    parms.hClass            = (NvV32)hClass;
    parms.flags             = (NvV32)flags;

#ifdef NV20MINIX
    parms.pMemory           = (NvP64)*ppAddress;
    parms.pLimit            = (NvU64)*pLimit;
#else
    parms.pMemory.selector  = 0x00000000;
    parms.pMemory.offset    = (NvU32)*ppAddress;
    parms.pLimit.high       = 0x00000000;
    parms.pLimit.low        = (NvU32)*pLimit;
#endif

    pParms = &parms;

    IOCTL_CMD((ULONG)IOCTL_NV01_ALLOC_MEMORY,
        (&pParms),
        sizeof(PVOID),
        (&parms),
        sizeof(NVOS02_PARAMETERS));

#ifdef NV20MINIX
    *ppAddress = (PVOID)((ULONG)parms.pMemory);
    *pLimit = (ULONG)parms.pLimit;
#else
    *ppAddress = (PVOID)parms.pMemory.offset;
    *pLimit = (ULONG)parms.pLimit.low;
#endif

    status = (parms.status == 0 ? STATUS_SUCCESS : STATUS_UNSUCCESSFUL);

CleanupAndExit:

    return status;
}



ULONG 
NvAllocChannelDma(
    ULONG hClient,
    ULONG hDevice,
    ULONG hChannel,
    ULONG hClass,
    ULONG hErrorCtx,
    ULONG hDataCtx,
    ULONG offset,
    PVOID *ppChannel
    )
{
    NVOS07_PARAMETERS parms;
    PVOID pParms;
    
    ULONG BytesReturned;
    NTSTATUS status;

    parms.hRoot             = (NvV32)hClient;
    parms.hObjectParent     = (NvV32)hDevice;
    parms.hObjectNew        = (NvV32)hChannel;
    parms.hClass            = (NvV32)hClass;
    parms.hObjectError      = (NvV32)hErrorCtx;
    parms.hObjectBuffer     = (NvV32)hDataCtx;
    parms.offset            = (NvU32)offset;
    pParms = &parms;

    IOCTL_CMD((ULONG)IOCTL_NV03_ALLOC_CHANNEL_DMA,
        (&pParms),
        sizeof(PVOID),
        (&parms),
        sizeof(NVOS07_PARAMETERS));

#ifdef NV20MINIX
    *ppChannel = (PVOID)((ULONG)parms.pControl);
#else
    *ppChannel = (PVOID)parms.pControl.offset;
#endif

    status = (parms.status == 0 ? STATUS_SUCCESS : STATUS_UNSUCCESSFUL);

CleanupAndExit:

    return status;
}





LONG
MxAllocContextDma(
    IN ULONG Dma,
    IN ULONG Class,
    IN ULONG Flags,
    IN PVOID Base,
    IN ULONG Limit
    )
{
    return NvAllocContextDma(MxDriverExtension->Client, Dma, Class, Flags, Base, Limit);
}





NTSTATUS
MxCreateObjects(
    VOID
    )
{

    NTSTATUS status;

    //
    // Create objects
    //

#if defined(NV20MINIX) && defined(KELVIN)

    CHECKSTATUS(NvAllocObject(MxDriverExtension->Client,
                           NV_DD_DEV_DMA,
                           D3D_KELVIN_PRIMITIVE,
                           NV20_KELVIN_PRIMITIVE));

#else

    CHECKSTATUS(NvAllocObject(MxDriverExtension->Client, 
                           NV_DD_DEV_DMA, 
                           D3D_CELSIUS_PRIMITIVE, 
                           NV10_CELSIUS_PRIMITIVE));

    CHECKSTATUS(NvAllocObject(MxDriverExtension->Client, 
                           NV_DD_DEV_DMA,
                           D3D_RENDER_SOLID_RECTANGLE, 
                           NV4_RENDER_SOLID_RECTANGLE));

#endif

    CHECKSTATUS(NvAllocObject(MxDriverExtension->Client, 
                           NV_DD_DEV_DMA,
                           NV_DD_SURFACES_2D, 
                           NV10_CONTEXT_SURFACES_2D));

    CHECKSTATUS(NvAllocObject(MxDriverExtension->Client, 
                           NV_DD_DEV_DMA,
                           NV_DD_VIDEO_LUT_CURSOR_DAC, 
                           NV05_VIDEO_LUT_CURSOR_DAC));

CleanupAndExit:

    return status;
}



NTSTATUS
MxAllocContextDmas(
    IN PMINIX_MODE_INFO ModeInfo,
    IN PVOID VidMemAddress,
    IN ULONG VidMemLength
    )
{

    NTSTATUS status;

    CHECKSTATUS(NvAllocContextDma(MxDriverExtension->Client, 
                                  DD_CONTEXT_DMA_IN_MEMORY_VIDEO_MEM,
                                  NV01_CONTEXT_DMA, 
                                  NVOS03_FLAGS_ACCESS_READ_WRITE, 
                                  VidMemAddress, 
                                  VidMemLength));


    CHECKSTATUS(NvAllocContextDma(MxDriverExtension->Client, 
                                  NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY,
                                  NV01_CONTEXT_DMA, 
                                  (ALLOC_CTX_DMA_FLAGS_ACCESS_RD_WR |
                                     ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED),
                                  VidMemAddress, 
                                  VidMemLength));


    CHECKSTATUS(NvAllocContextDma(MxDriverExtension->Client, 
                               NV_DD_DMA_CONTEXT_DMA_FROM_VIDEO_MEMORY,
                               NV01_CONTEXT_DMA, 
                               (ALLOC_CTX_DMA_FLAGS_ACCESS_READ_ONLY |
                                  ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED),
                               VidMemAddress, 
                               VidMemLength));

    
    CHECKSTATUS(NvAllocContextDma(MxDriverExtension->Client, 
                                  NV_DD_DMA_CONTEXT_DMA_TO_VIDEO_MEMORY,
                                  NV01_CONTEXT_DMA, 
                                  (ALLOC_CTX_DMA_FLAGS_ACCESS_WRITE_ONLY |
                                      ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED),
                                  VidMemAddress, 
                                  VidMemLength));

    //
    // Create DMA contexts for notifications
    //
    
    CHECKSTATUS(NvAllocContextDma(MxDriverExtension->Client, 
                                  NV_DD_DMA_PUSHER_SYNC_NOTIFIER_CONTEXT_DMA_TO_MEMORY,
                                  NV01_CONTEXT_DMA, 
                                  ALLOC_CTX_DMA_FLAGS_ACCESS_WRITE_ONLY,
                                  (PVOID)ModeInfo->NotificationBase,
                                  (2 * sizeof(NvNotification) - 1)) );


    //
    // Create DMA context for host memory
    //
    CHECKSTATUS(NvAllocContextDma(MxDriverExtension->Client, 
                                  D3D_CONTEXT_DMA_HOST_MEMORY, 
                                  NV01_CONTEXT_DMA,
                                  (ALLOC_CTX_DMA_FLAGS_ACCESS_READ_ONLY | 
                                      ALLOC_CTX_DMA_FLAGS_LOCKED_CACHED),
                                  (PVOID)ModeInfo->HostMemoryBase, 
                                  ModeInfo->HostMemoryLimit));


    //
    // Allocate context DMA for the push buffer
    //

#if defined(NV20MINIX) && defined(KELVIN)

    CHECKSTATUS(NvAllocContextDma(MxDriverExtension->Client, 
                                  NV_DD_DMA_PUSHER_CONTEXT_DMA_FROM_MEMORY, 
                                  NV01_CONTEXT_DMA,
                                  (ALLOC_CTX_DMA_FLAGS_ACCESS_READ_ONLY | 
                                      ALLOC_CTX_DMA_FLAGS_LOCKED_CACHED),
                                  (PVOID)ModeInfo->HostMemoryBase, 
                                  ModeInfo->HostMemoryLimit));

#else !KELVIN

    CHECKSTATUS(NvAllocContextDma(MxDriverExtension->Client, 
                                  NV_DD_DMA_PUSHER_CONTEXT_DMA_FROM_MEMORY, 
                                  NV01_CONTEXT_DMA,
                                  (ALLOC_CTX_DMA_FLAGS_ACCESS_READ_ONLY | 
                                      ALLOC_CTX_DMA_FLAGS_LOCKED_CACHED),
                                  (PVOID)ModeInfo->PushBase, 
                                  ModeInfo->PushLimit));

#endif !KELVIN

CleanupAndExit:

    return status;
}




LONG
MxSetVideoMode(
    IN OUT PMINIX_MODE_INFO ModeInfo
    )
{
    ULONG BytesReturned;
    NTSTATUS status;

    ULONG Device;
    ULONG DeviceReference;

    VIDEO_PUBLIC_ACCESS_RANGES VideoAccessRange[16];
    
    VIDEO_MEMORY VideoMemory;
    VIDEO_MEMORY_INFORMATION VideoMemoryInfo;

    union
    {
        ULONG osName;
        CHAR devName[128];
    } NameBuffer;


    ULONG Mode;
    ULONG ModeIndex;
    PVIDEOMODEDEF ModeDef;

    BOOLEAN HwVidOvl;

    VIDEO_MODE_INFORMATION VideoModeInfo;
    TV_CURSOR_ADJUST_INFO CursorAdjustInfo;

    PVOID VidMemAddress;
    PVOID Temp;
    ULONG VidMemLength;
    ULONG VidMemHandle;

    BOOLEAN FullInit;


    Device = DD_DEVICE_OBJECT_HANDLE;
    VidMemAddress = 0;

    //
    // Determine if we need to do full initialization
    //
    FullInit = (BOOLEAN)(ModeInfo->PushBase != 0);



    if (FullInit) {
        
        // 
        // Enable P6 write combining when mapping the video memory
        //
        IOCTL_CMD(IOCTL_VIDEO_ENABLE_WRITE_COMBINING,
            NULL,
            0,
            NULL,
            0);
    
        // 
        // Get the device reference from the miniport to the device class
        //
        IOCTL_CMD(IOCTL_VIDEO_GET_DEVICE_REF,
            NULL,
            0,
            &DeviceReference,
            sizeof(ULONG));
    
    
        //
        // Get virtual addresses for the memory ranges
        //
        IOCTL_CMD(IOCTL_VIDEO_QUERY_PUBLIC_ACCESS_RANGES,
            NULL,                     
            0,
            VideoAccessRange,         
            sizeof(VideoAccessRange));


        //
        // Get the linear memory address range for the video memory
        //
        VideoMemory.RequestedVirtualAddress = NULL;
    
        IOCTL_CMD(IOCTL_VIDEO_MAP_VIDEO_MEMORY,
            &VideoMemory,      
            sizeof(VIDEO_MEMORY),
            &VideoMemoryInfo,  
            sizeof(VideoMemoryInfo));

        VidMemAddress = VideoMemoryInfo.FrameBufferBase;

        // 
        // Register the client 
        //
        CHECKSTATUS(NvAllocRoot(NV01_ROOT, &(MxDriverExtension->Client)));
    
        //
        // Allocate the device
        //
        NameBuffer.osName = DeviceReference;
    
        CHECKSTATUS(NvAllocDevice(MxDriverExtension->Client, Device, NV03_DEVICE_XX, NameBuffer.devName));
    }

    //
    // Set the video mode
    //
    status = STATUS_INVALID_PARAMETER; 

    ModeDef = &g_VideoModeDef[0];
    for (ModeIndex = 0; ModeIndex < (sizeof(g_VideoModeDef) / sizeof(g_VideoModeDef[0])); 
         ModeIndex++) {
        
        if (ModeInfo->Width == ModeDef->Width && 
            ModeInfo->Height == ModeDef->Height &&
            ModeInfo->BitDepth == ModeDef->Depth) {
            
            Mode = ModeDef->Mode;
            status = STATUS_SUCCESS;
            break;
        }

        ModeDef++;
    }

    if (!NT_SUCCESS(status)) {
        goto CleanupAndExit;            
    }


    IOCTL_CMD(IOCTL_VIDEO_SET_CURRENT_MODE,
        &Mode,  
        sizeof(ULONG),
        &HwVidOvl,
        sizeof(BOOLEAN));


    //
    // Get video mode information
    //
    IOCTL_CMD(IOCTL_VIDEO_QUERY_CURRENT_MODE,
        NULL,
        0,
        &VideoModeInfo,
        sizeof(VideoModeInfo));


    //
    // Get cursor adjust information
    //
    IOCTL_CMD(IOCTL_VIDEO_GET_TV_CURSOR_ADJUST_INFO,
        NULL,
        0,
        &CursorAdjustInfo,
        sizeof(CursorAdjustInfo));


    if (FullInit) {
        
        //
        // Get the size for video memory from RM
        //
        Temp = (PVOID)1;  // NO_MAPPING
        VidMemHandle = DD_FRAME_BUFFER_OBJECT_HANDLE;
        CHECKSTATUS(NvAllocMemory(MxDriverExtension->Client, Device, VidMemHandle, NV01_MEMORY_LOCAL_USER, 0,
                                  &Temp, &VidMemLength));
    
        
        //
        // Return the video memory address
        //
        ModeInfo->VidMemAddress = VidMemAddress;
    
        //
        // Return the base address of the hardware.
        //
        ModeInfo->NvBase = VideoAccessRange[0].VirtualAddress;

        // BUGBUG: testcode: clear memory
        memset((PVOID)((unsigned char*)VidMemAddress), 0xFF, VidMemLength);
        // end test code

    
        //
        // Allocate DMA contexts to video memory. 
        //
        
        CHECKSTATUS(MxAllocContextDmas(ModeInfo, VidMemAddress, VidMemLength));

        //
        // Allocate channel DMA for the push buffer
        //

#if defined(NV20MINIX) && defined(KELVIN)

        CHECKSTATUS(NvAllocChannelDma(MxDriverExtension->Client,
                                      Device,
                                      NV_DD_DEV_DMA,
                                      NV20_CHANNEL_DMA,
                                      0,
                                      NV_DD_DMA_PUSHER_CONTEXT_DMA_FROM_MEMORY,
                                      0,
                                      (PVOID*)&(ModeInfo->DevFlatDma)));
#else
    
        CHECKSTATUS(NvAllocChannelDma(MxDriverExtension->Client, 
                                      Device, 
                                      NV_DD_DEV_DMA,
                                      NV10_CHANNEL_DMA, 
                                      0, 
                                      NV_DD_DMA_PUSHER_CONTEXT_DMA_FROM_MEMORY, 
                                      0,
                                      (PVOID*)&(ModeInfo->DevFlatDma)));
#endif

        //
        // Create objects
        //
    
        CHECKSTATUS(MxCreateObjects());
    }

 
    status = STATUS_SUCCESS;

CleanupAndExit:

    return (LONG)status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\inc\video.h ===
/*++

Copyright (c) 1991-1999 Microsoft Corporation

Module Name:

    video.h

Abstract:

    Contains all structure and routine definitions common to the video port
    driver and the video miniport drivers.

Notes:

Revision History:

--*/

#ifndef __VIDEO_H__
#define __VIDEO_H__

#include <videoagp.h>

//
// Define port driver status code.
// The values for these are the Win32 error codes
//

typedef LONG VP_STATUS;
typedef VP_STATUS *PVP_STATUS;

//
// Defines for registry information and synchronization.
//

typedef enum VIDEO_SYNCHRONIZE_PRIORITY {
    VpLowPriority,
    VpMediumPriority,
    VpHighPriority
} VIDEO_SYNCHRONIZE_PRIORITY, *PVIDEO_SYNCHRONIZE_PRIORITY;

//
//  Opaque pointer type for miniport to be used to type PEVENTs received from
//  display driver.
//

typedef struct _VIDEO_PORT_EVENT * PEVENT;

//
// Type of information requested with GetDeviceData
//

typedef enum _VIDEO_DEVICE_DATA_TYPE {
    VpMachineData,
    VpCmosData,
    VpBusData,
    VpControllerData,
    VpMonitorData
} VIDEO_DEVICE_DATA_TYPE, *PVIDEO_DEVICE_DATA_TYPE;

//
// Data returned with VpControllerData
//

typedef struct _VIDEO_HARDWARE_CONFIGURATION_DATA {
    INTERFACE_TYPE InterfaceType;
    ULONG BusNumber;
    USHORT Version;
    USHORT Revision;
    USHORT Irql;
    USHORT Vector;
    ULONG ControlBase;
    ULONG ControlSize;
    ULONG CursorBase;
    ULONG CursorSize;
    ULONG FrameBase;
    ULONG FrameSize;
} VIDEO_HARDWARE_CONFIGURATION_DATA, *PVIDEO_HARDWARE_CONFIGURATION_DATA;

//
// Define structure used to call the BIOS int 10 function
//

typedef struct _VIDEO_X86_BIOS_ARGUMENTS {
    ULONG Eax;
    ULONG Ebx;
    ULONG Ecx;
    ULONG Edx;
    ULONG Esi;
    ULONG Edi;
    ULONG Ebp;
} VIDEO_X86_BIOS_ARGUMENTS, *PVIDEO_X86_BIOS_ARGUMENTS;

#define SIZE_OF_NT4_VIDEO_PORT_CONFIG_INFO           0x42
#define SIZE_OF_NT4_VIDEO_HW_INITIALIZATION_DATA     0x28
 
//
// Debugging statements. This will remove all the debug information from the
// "free" version.
//

#if DBG
#define VideoDebugPrint(arg) VideoPortDebugPrint arg
#else
#define VideoDebugPrint(arg)
#endif

//
// Allows us to remove lots of unused code.
//

#ifndef _NTOSDEF_

#define ALLOC_PRAGMA 1
#define VIDEOPORT_API __declspec(dllimport)

#if DBG
#define PAGED_CODE() \
    if (VideoPortGetCurrentIrql() > 1 /*APC_LEVEL*/) { \
        VideoPortDebugPrint(0, "Video: Pageable code called at IRQL %d\n", VideoPortGetCurrentIrql() ); \
        ASSERT(FALSE); \
        }

#else
#define PAGED_CODE()
#endif

ULONG
DriverEntry(
    PVOID Context1
    );

#else
#define VIDEOPORT_API
#endif


#ifndef _NTOS_

//
// These are the various function prototypes of the routines that are
// provided by the kernel driver to hook out access to io ports.
//

typedef
VP_STATUS
(*PDRIVER_IO_PORT_UCHAR ) (
    ULONG_PTR Context,
    ULONG Port,
    UCHAR AccessMode,
    PUCHAR Data
    );

typedef
VP_STATUS
(*PDRIVER_IO_PORT_UCHAR_STRING ) (
    ULONG_PTR Context,
    ULONG Port,
    UCHAR AccessMode,
    PUCHAR Data,
    ULONG DataLength
    );

typedef
VP_STATUS
(*PDRIVER_IO_PORT_USHORT ) (
    ULONG_PTR Context,
    ULONG Port,
    UCHAR AccessMode,
    PUSHORT Data
    );

typedef
VP_STATUS
(*PDRIVER_IO_PORT_USHORT_STRING ) (
    ULONG_PTR Context,
    ULONG Port,
    UCHAR AccessMode,
    PUSHORT Data,
    ULONG DataLength // number of words
    );

typedef
VP_STATUS
(*PDRIVER_IO_PORT_ULONG ) (
    ULONG_PTR Context,
    ULONG Port,
    UCHAR AccessMode,
    PULONG Data
    );

typedef
VP_STATUS
(*PDRIVER_IO_PORT_ULONG_STRING ) (
    ULONG_PTR Context,
    ULONG Port,
    UCHAR AccessMode,
    PULONG Data,
    ULONG DataLength  // number of dwords
    );

#endif // _NTOS_


//
// Definition of the request packet sent from the port driver to the
// miniport driver. It reflects the parameters passed from the
// DeviceIOControl call made by the windows display driver.
// 
// N.B. The definition of the STATUS_BLOCK must be the same as the
//      the definition of IO_STATUS_BLOCK defined in ntioapi.h.
//

typedef struct _STATUS_BLOCK {

    //
    // Contains the status code of the operation.
    // This value in one of the Win32 error codes that are defined for use
    // in the video miniport drivers.
    //

    union {
       VP_STATUS Status;
       PVOID Pointer;
    };

    //
    // Information returned to the callee.
    // The meaning of the information varies from function to function. It
    // is generally used to return the minimum size for the input buffer if
    // the function takes an input buffer, or the amount of data transfered
    // back to the caller if the operation returns output.
    //

    ULONG_PTR Information;

} STATUS_BLOCK, *PSTATUS_BLOCK;

typedef struct _VIDEO_REQUEST_PACKET {

    //
    // The IO control code passed to the DeviceIoControl function by the
    // caller.
    //

    ULONG IoControlCode;

    //
    // Pointer to a status block provided by the caller. This should be
    // filled out by the callee with the appropriate information.
    //

    PSTATUS_BLOCK StatusBlock;

    //
    // Pointer to an input buffer which contains the information passed in
    // by the caller.
    //

    PVOID InputBuffer;

    //
    // Size of the input buffer
    //

    ULONG InputBufferLength;

    //
    // Pointer to an output buffer into which the data returned to the caller
    // should be stored.
    //

    PVOID OutputBuffer;

    //
    // Length of the output buffer. This buffer can not be grown by the
    // callee.
    //

    ULONG OutputBufferLength;

} VIDEO_REQUEST_PACKET, *PVIDEO_REQUEST_PACKET;

//
//  typedef for scattergather array available via GET_VIDEO_SCATTERGATHER().
//

typedef struct __VRB_SG {
    __int64   PhysicalAddress;
    ULONG     Length;
    } VRB_SG, *PVRB_SG;

//
// Opaque type for dma handle
//

typedef struct __DMA_PARAMETERS * PDMA;

//
//  The following macro returns in Address the 32 bit physical address of
//  the VirtualAddress lying within the InputBuffer passed into EngDevIo
//

#define GET_VIDEO_PHYSICAL_ADDRESS(scatterList, VirtualAddress, InputBuffer, pLength, Address)    \
                                                                                           \
        do {                                                                               \
            ULONG_PTR          byteOffset;                                                  \
                                                                                           \
            byteOffset = (PCHAR) VirtualAddress - (PCHAR)InputBuffer;                \
                                                                                           \
            while (byteOffset >= scatterList->Length) {                                    \
                                                                                           \
                byteOffset -= scatterList->Length;                                         \
                scatterList++;                                                             \
            }                                                                              \
                                                                                           \
            *pLength = scatterList->Length - byteOffset;                                   \
                                                                                           \
            Address = (ULONG_PTR) (scatterList->PhysicalAddress + byteOffset);                  \
                                                                                           \
        } while (0)


#define GET_VIDEO_SCATTERGATHER(ppDma)   (**(PVRB_SG **)ppDma)

#define VIDEO_RANGE_PASSIVE_DECODE   0x1
#define VIDEO_RANGE_10_BIT_DECODE    0x2


//
// The following structure is used to define access ranges. The ranges are
// used to indicate which ports and memory adresses are being used by the
// card.
//

typedef struct _VIDEO_ACCESS_RANGE {

    //
    // Indicates the starting memory address or port number of the range.
    // This values should be stored before being transformed by
    // VideoPortGetDeviceBase() which returns the logical address that must
    // be used by the miniport driver when referencing physical addresses.
    //

    PHYSICAL_ADDRESS RangeStart;

    //
    // Indicates the length in bytes, or number of ports in the range. This
    // value should indicate the range actually decoded by the adapter. For
    // example, if the adapter uses 7 registers but responds to eight, the
    // RangeLength should be set to 8.

    ULONG RangeLength;

    //
    // Indicates if the range is in IO space (TRUE) or in memory space (FALSE).
    //

    UCHAR RangeInIoSpace;

    //
    // Indicates if the range should be visible by the Windows display driver.
    // This is done so that a Windows display driver can access certain
    // video ports directly. This will only be allowed if the caller has the
    // required privileges (is a trusted subsystem) to access the range.
    //
    // Synchronization of access to ports or memory in the range must be
    // done explicitly by the miniport driver and the user mode process so
    // that they both don't try to program the device simultaneously.
    //
    // Non visible ranges should include video memory, ROM addresses, etc.
    // which are not required to program the device for output purposes.
    //
    //

    UCHAR RangeVisible;

    //
    // This field determines if the range can be shared with another device.
    // The rule should be applied as follow.
    //
    // - If the range of memory or IO ports should be "owned" by this driver,
    //   and that any other driver trying to access this range may cause
    //   a problem, FALSE should be returned.
    //
    // - If the range can be shared with another co-operating device driver,
    //   then the share field should be set to TRUE.
    //
    // As a guideline, the VGA miniport driver will claim all of its resources
    // as shareable so that it can be used as a VGA compatible device with
    // any other driver (such as an S3 or XGA.
    //
    // Super VGA miniport drivers that implement all the VGA functionality
    // (declared in the Registry as VGACOMPATIBLE=1) should claim the range
    // as non-shareable since they don't want the VGA to run at the same time.
    //
    // Miniports for cards such as an S3 or XGA that have an XGA on the board
    // but do not implement the VGA functionality will run with the VGA
    // miniport loaded and should therefore claim all the resources shared
    // with the VGA as shareable.
    //
    // Miniports for cards that work with a pass-through and that can be
    // connected to any VGA/SVGA card should not be using any VGA ports or
    // memory ranges ! ... but if they do they should not claim those
    // resources since they will cause a conflict in the system because the
    // SVGA cards will have claimed them as non-shareable ...
    //

    UCHAR RangeShareable;

    //
    // Indicates that the range is decoded by the hardware, but that the
    // driver will never access this port.
    //

    UCHAR RangePassive;

} VIDEO_ACCESS_RANGE, *PVIDEO_ACCESS_RANGE;



typedef
PVOID
(*PVIDEO_PORT_GET_PROC_ADDRESS)(
    IN PVOID HwDeviceExtension,
    IN PUCHAR FunctionName
    );

//
// This structure contains the specific configuration information about the
// device. The information is initialized by the port driver and it should
// be completed by the miniport driver.
// The information is used to setup the device, as weel as providing
// information to the port driver so it can perform some of the requests on
// behalf of the miniport driver.
//

typedef struct _VIDEO_PORT_CONFIG_INFO {

    //
    // Specifies the length of the PVIDEO_PORT_CONFIG_INFO structure as
    // returned by sizeof(). Since this structure may grow in later
    // releases, the miniport driver should check that the length of the
    // structure is greater than or equal to the length it expects (since
    // it is guaranteed that defined fields will not change).
    //
    // This field is always initialized by the port driver.
    //

    ULONG Length;

    //
    // Specifies which IO bus is tp be scanned. This field is used as a
    // parameter to some VideoPortXXX calls.
    //
    // This field is always initialized by the port driver.
    //

    ULONG SystemIoBusNumber;

    //
    // Specifies the type of bus being scanned. This field is equal to the
    // value being passed into VideoPortInitialize in the
    // VIDEO_HW_INITIALIZATION_DATA structure.
    //
    // This field is always initialized by the port driver.
    //

    INTERFACE_TYPE AdapterInterfaceType;

    //
    // Specifies the bus interrupt request level. This level corresponds to
    // the IRQL on ISA and MCA buses.
    // This value is only used if the device supports interrupts, which is
    // determined by the presence of an interrupt service routine in the
    // VIDEO_HW_INITIALIZATION_DATA structure.
    //
    // The preset default value for this field is zero. Otherwise, it is the
    // value found in the device configuration information.
    //

    ULONG BusInterruptLevel;

    //
    // Specifies the bus vector returned by the adapter. This is used for
    // systems which have IO buses that use interrupt vectors. For ISA, MCA
    // and EISA buses, this field is unused.
    //
    // The preset default value for this field is zero.
    //

    ULONG BusInterruptVector;

    //
    // Specifies whether this adapter uses latched or edge-triggered type
    // interrupts.
    //
    // This field is always initialized by the port driver.
    //

    KINTERRUPT_MODE InterruptMode;

    //
    // Specifies the number of emulator access entries that the adapter
    // uses.  It indicates the number of array elements in the following field.
    //
    // This field can be reinitialized with the number of entries in the
    // EmulatorAccessEntries structure if the structure is statically
    // defined in the miniport driver. The EmulatorAccessEntries fields
    // should also be updated.
    //

    ULONG NumEmulatorAccessEntries;

    //
    // Supplies a pointer to an array of EMULATOR_ACCESS_ENTRY structures.
    // The number of elements in the array is indicated by the
    // NumEmulatorAccessEntries field. The driver should fill out each entry
    // for the adapter.
    //
    // The uninitialized value for the structure is NULL.
    // EmulatorAccessEntries will be NULL if NumEmulatorAccessEntries is
    // zero.
    //
    // A poiner to an array of emulator access entries can be passed back
    // if such a structure is defined statically in the miniport driver. The
    // NumEmulatorAccessEntries field should also be updated.
    //

    PVOID EmulatorAccessEntries;

    //
    // This is a context values that is passed with each call to the
    // emulator/validator functions defined in the EmulatorAccessEntries
    // defined above.
    // This parameter should in general be a pointer to the miniports
    // device extension or other such storage location.
    //
    // This pointer will allow the miniport to save some state temporarily
    // to allow for the batching of IO requests.
    //

    ULONG_PTR EmulatorAccessEntriesContext;

    //
    // Physical address of the video memory that must be mapped into a VDM's
    // address space for proper BIOS support
    //

    PHYSICAL_ADDRESS VdmPhysicalVideoMemoryAddress;

    //
    // Length of the video memory that must be mapped into a VDM's addres
    // space for proper BIOS support.
    //

    ULONG VdmPhysicalVideoMemoryLength;

    //
    // Determines the minimum size required to store the hardware state
    // information returned by IOCTL_VIDEO_SAVE_HARDWARE_STATE.
    //
    // The uninitialized value for this field is zero.
    //
    // If the field is left to zero, SAVE_HARDWARE_STATE will return an
    // ERROR_INVALID_FUNCTION status code.
    //

    ULONG HardwareStateSize;

    //
    // New for version 3.5
    //

    //
    // Optional DMA channel, if required by the device.
    // 0 for the Channel and Port indicates DMA is not used by the device.
    //

    ULONG DmaChannel;

    //
    // Optional DMA channel, if required by the device.
    // 0 for the Channel and Port indicates DMA is not used by the device.
    //

    ULONG DmaPort;

    //
    // Set to 1 if the DMA channel can be shared with another device.
    // Set to 0 if the DMA channel must be owned exclusively by the driver.
    //

    UCHAR DmaShareable;

    //
    // Set to 1 if the interrupt can be shared with another device.
    // Set to 0 if the interrupt must be owned exclusively by the driver.
    //

    UCHAR InterruptShareable;

    //
    //  Start new dma stuff
    //

    //
    // Set to TRUE if the DMA device is a busmaster, FALSE otherwise.
    //

    BOOLEAN Master;

    //
    // Set to number of bits wide. Consistent with DEVICE_DESCRIPTION.
    // See ntioapi.h
    //

    DMA_WIDTH   DmaWidth;

    //
    // Set to speed so miniport can set DEVICE_DESCRIPTION field.
    // See ntioapi.h
    //

    DMA_SPEED   DmaSpeed;

    //
    // Set to TRUE if the DMA device requires mapped buffers. Also
    // a DEVICE_DESCRIPTION  field.
    //

    BOOLEAN bMapBuffers;

    //
    // Set to TRUE if the DMA device requires physical addresses.
    //

    BOOLEAN NeedPhysicalAddresses;

    //
    // Set to TRUE if the DMA device supports demand mode, FALSE otherwise.
    // Also DEVICE_DESCRIPTION support.
    //

    BOOLEAN DemandMode;

    //
    // Set to max transfer length the DMA device supports.
    //

    ULONG   MaximumTransferLength;

    //
    // Set to max number of Physical breaks the DMA device supports.
    //

    ULONG   NumberOfPhysicalBreaks;

    //
    // Set to TRUE if the DMA device supports scatter gather, FALSE otherwise.
    //

    BOOLEAN ScatterGather;

    //
    // Maximal Length in PVRB_SG returned measured in bytes. If the device
    // has no maximum size, zero should be entered.
    //

    ULONG   MaximumScatterGatherChunkSize;

    //
    // Allow for 4.0/5.0 compatibilty
    //

    PVIDEO_PORT_GET_PROC_ADDRESS VideoPortGetProcAddress;

    //
    // Provide a pointer to the device's registry path
    //

    PWSTR DriverRegistryPath;

    //
    // Indicates to a driver the amount of physical memory in the system
    //

    ULONGLONG SystemMemorySize;

} VIDEO_PORT_CONFIG_INFO, *PVIDEO_PORT_CONFIG_INFO;


//
// Video Adapter Dependent Routines.
//

typedef
VP_STATUS
(*PVIDEO_HW_FIND_ADAPTER) (
    PVOID HwDeviceExtension,
    PVOID HwContext,
    PWSTR ArgumentString,
    PVIDEO_PORT_CONFIG_INFO ConfigInfo,
    PUCHAR Again
    );

typedef
BOOLEAN
(*PVIDEO_HW_INITIALIZE) (
    PVOID HwDeviceExtension
    );

typedef
BOOLEAN
(*PVIDEO_HW_INTERRUPT) (
    PVOID HwDeviceExtension
    );

typedef
VOID
(*PVIDEO_HW_LEGACYRESOURCES) (
    IN ULONG VendorId,
    IN ULONG DeviceId,
    IN OUT PVIDEO_ACCESS_RANGE *LegacyResourceList,
    IN OUT PULONG LegacyResourceCount
    );

//
// type to be returned by HwStartDma().
//

typedef enum _HW_DMA_RETURN {
    DmaAsyncReturn,
    DmaSyncReturn
    } HW_DMA_RETURN, *PHW_DMA_RETURN;


typedef
HW_DMA_RETURN
(*PVIDEO_HW_START_DMA) (
    PVOID                   HwDeviceExtension,
    PDMA                    pDma
    );

//
//  Flags to be passed into VideoPortLockPages() or VideoPortDoDma().
//

//
//  The flag VideoPortUnlockAfterDma tells the video port to unlock the pages
//  after the miniport signals that the dma is complete via the
//  pDmaCompletionEvent in HwStartDma. Failure to set this event at
//  dma completion may cause the memory to be unlocked at randon times.
//  This flag is best used when one wants to do one dma transfer which
//  occurs infrequently. It allows locking, dmaing and unlocking to be performed
//  in the context of 1 IOCTL.
//

//
//  The flag VideoPortKeepPagesLocked tells the video port to leave the pages
//  locked if possible.
//

//
//  The flag VideoPortDmaInitOnly tells the Video Port to lock the pages, but don't
//  call HwStartDma. Not applicable to VideoPortDoDma().
//


typedef enum {
    VideoPortUnlockAfterDma = 1,
    VideoPortKeepPagesLocked,
    VideoPortDmaInitOnly
    }   DMA_FLAGS;

//
// DMA Event flags
//

typedef ULONG DMA_EVENT_FLAGS;

#define SET_USER_EVENT    0x01
#define SET_DISPLAY_EVENT 0x02

//
// Child Enumeration structure passed in to the PVIDEO_HW_GET_CHILD_DESCRIPTOR
// function.
//
// All these parameters are input parameters and must not be modified by the
// callee
//
// Size - Size of the structure.  It can be used by the calle for versioning.
//
// ChildDescriptorSize - Size of the pChildDescriptor buffer passed in as the
//     third parameter to PVIDEO_HW_GET_CHILD_DESCRIPTOR.
//
// ChildIndex - Index of the device to be enumerated.  This field should be
//     used to enumerate devices not enumerated by ACPI or other operating
//     system components.  If this field is set to 0 it indicates the ACPIHwId
//     field.
//
// ACPIHwId - ID returned by the ACPI BIOS that represent the device being
//     queried.  The ACPIHwId returned by the firmware must match the HwIds
//     returned by the driver.  The System BIOS manufacturer and the graphics
//     IHV must synchronize these IDs.
//
// ChildHwDeviceExtension - Pointer to a device extension specific to this
//     child device.  This field will only be filled in if the miniport driver
//     filled the ChildHwDeviceExtensionSize to be non-NULL.
//

typedef struct _VIDEO_CHILD_ENUM_INFO {
    ULONG Size;
    ULONG ChildDescriptorSize;
    ULONG ChildIndex;
    ULONG ACPIHwId;
    PVOID ChildHwDeviceExtension;
} VIDEO_CHILD_ENUM_INFO, *PVIDEO_CHILD_ENUM_INFO;

//
//  VIDEO_CHILD_TYPE enum:
//
//  'Monitor' identifies a device which may have a DDC2 compliant EDID data
//  structure. If the video miniport detects such a device, it is to extract
//  the edid from the monitor and put that in the paged buffer provided by
//  videoprt.sys in the callback to PVIDEO_HW_GET_CHILD_DESCRIPTOR and return
//  this type in the the OUT PVIDEO_CHILD_TYPE parameter of that call. This
//  EDID, if available, will be written to the registry. If the EDID is not
//  available, nothing should be put in the buffer.
//
//  'NonPrimaryChip' identifies another VGA chip on the video board which
//  is not the primary VGA chip. This type is to be used if and only if the
//  miniport detects more than one VGA chip on the board. Such an identifier
//  will cause the videoprt to create another DEVICE_EXTENSION and associated
//  HW_DEVICE_EXTENSION to be associated with the chip so identified.
//
//  'Other' identifies some other video device attached to the video card. If
//  the miniport detects such a device, it is to put a wide char string
//  (WSTR) into the paged buffer provided by the videoprt.sys which is the
//  PNP hardware identifier of the device. This string will be used to create
//  a value of that name in the registry.
//

typedef enum {
    Monitor = 1,
    NonPrimaryChip,
    VideoChip,
    Other
} VIDEO_CHILD_TYPE, *PVIDEO_CHILD_TYPE;

//
//  define a constant that represents the display adapter self query.
//

#define DISPLAY_ADAPTER_HW_ID           0xFFFFFFFF

typedef struct _VIDEO_CHILD_STATE {
    ULONG   Id;
    ULONG   State;
} VIDEO_CHILD_STATE, *PVIDEO_CHILD_STATE;
    
typedef struct _VIDEO_CHILD_STATE_CONFIGURATION {
    ULONG             Count;
    VIDEO_CHILD_STATE ChildStateArray[ANYSIZE_ARRAY];
} VIDEO_CHILD_STATE_CONFIGURATION, *PVIDEO_CHILD_STATE_CONFIGURATION;

//
//  The following routine should return TRUE if successful. It should:
//      1)  put the type of the child device in VideoChildType.
//      2)  put the information from the device in Buffer. This
//          buffer is of size 256 bytes. If the type returned in
//          PVideoChildType is Monitor, this buffer must contain the
//          EDID of the monitor if readable. If the type returned in
//          PVideoChildType is Other, a wide character string representing
//          the PNP Device Id must be put in the buffer. This string will
//          be used to create a key for the device if the buffer contains
//          an EDID. Otherwise, it is used to obtain a PNP ID for the
//          device.
//      3)  Put a miniport determined HANDLE in HwId. This value will be
//          passed back to the miniport for Power management operations,
//          as well as other operations. This allows the miniport to define
//          the contract between the system and the miniport which defines a
//          particular device.
//
//  It should  only return FALSE if there are no devices attached to that
//  display adapter connector.
//

typedef
ULONG
(*PVIDEO_HW_GET_CHILD_DESCRIPTOR) (
    IN  PVOID                   HwDeviceExtension,
    IN  PVIDEO_CHILD_ENUM_INFO  ChildEnumInfo,
    OUT PVIDEO_CHILD_TYPE       VideoChildType,
    OUT PUCHAR                  pChildDescriptor,
    OUT PULONG                  UId,
    OUT PULONG                  pUnused
    );


//
// This routine is used to set the power on the graphics devices.
// These include all the Children enumerated by GET_CHILD_DESCRIPTOR callback
// as well as the graphics adapter itself.
//
// The HwDevice extension represent the adapter instance of the device.
//
// The HwId parameter is the unique ID as returned by the enumeration routine.
// The miniport will only be called to set the power on the devices it
// enumerated, as well as the graphics adapter itself.  A HwId of 0xFFFFFFFF
// will be passed in to identify the graphics adapter itself.
// The miniport driver should never turn off the power to the graphics adapter
// unless specifically request to.
//
// The VideoPowerControl is the level to which the device shold be set.
// The videoport driver will manage these states.
//

typedef
VP_STATUS
(*PVIDEO_HW_POWER_SET) (
    PVOID                   HwDeviceExtension,
    ULONG                   HwId,
    PVIDEO_POWER_MANAGEMENT VideoPowerControl
    );

//
// This routine simply returns whether or not the device can support the
// requested state.
//
// See HW_POWER_SET for a description of the parameters.
//

typedef
VP_STATUS
(*PVIDEO_HW_POWER_GET) (
    PVOID                   HwDeviceExtension,
    ULONG                   HwId,
    PVIDEO_POWER_MANAGEMENT VideoPowerControl
    );

//
// This structure should match the QueryInterface struct defined
// in io.h.
//

typedef struct _INTERFACE {
    USHORT Size;
    USHORT Version;
    PVOID Context;
    PINTERFACE_REFERENCE InterfaceReference;
    PINTERFACE_DEREFERENCE InterfaceDereference;
    // interface specific entries go here
} INTERFACE, *PINTERFACE;

typedef struct _QUERY_INTERFACE {
    CONST GUID *InterfaceType;
    USHORT Size;
    USHORT Version;
    PINTERFACE Interface;
    PVOID InterfaceSpecificData;
} QUERY_INTERFACE, *PQUERY_INTERFACE;

typedef
VP_STATUS
(*PVIDEO_HW_QUERY_INTERFACE) (
    PVOID HwDeviceExtension,
    PQUERY_INTERFACE QueryInterface
    );

typedef
VP_STATUS
(*PVIDEO_HW_CHILD_CALLBACK) (
    PVOID HwDeviceExtension,
    PVOID ChildDeviceExtension
    );

//
// Entry point for all IOCTL calls made to the miniport driver.
//

typedef
BOOLEAN
(*PVIDEO_HW_START_IO) (
    PVOID HwDeviceExtension,
    PVIDEO_REQUEST_PACKET RequestPacket
    );

//
// The return value determines if the mode was completely programmed (TRUE)
// or if an int10 should be done by the HAL to complete the modeset (FALSE).
//

typedef
BOOLEAN
(*PVIDEO_HW_RESET_HW) (
    PVOID HwDeviceExtension,
    ULONG Columns,
    ULONG Rows
    );

//
// Timer routine called every second.
//

typedef
VOID
(*PVIDEO_HW_TIMER) (
    PVOID HwDeviceExtension
    );


//
// Structure passed by the miniport entry point to the video port
// initialization routine.
//

typedef struct _VIDEO_HW_INITIALIZATION_DATA {

    //
    // Supplies the size of the structure in bytes as determined by sizeof().
    //

    ULONG HwInitDataSize;

    //
    // Indicates the bus type the adapter works with, such as Eisa, Isa, MCA.
    //

    INTERFACE_TYPE AdapterInterfaceType;

    //
    // Supplies a pointer to the miniport driver's find adapter routine.
    //

    PVIDEO_HW_FIND_ADAPTER HwFindAdapter;

    //
    // Supplies a pointer to the miniport driver's initialization routine.
    //

    PVIDEO_HW_INITIALIZE HwInitialize;

    //
    // Supplies a pointer to the miniport driver's interrupt service routine.
    //

    PVIDEO_HW_INTERRUPT HwInterrupt;

    //
    // Supplies a pointer to the miniport driver's start io routine.
    //

    PVIDEO_HW_START_IO HwStartIO;

    //
    // Supplies the size in bytes required for the miniport driver's private
    // device extension. This storage is used by the miniport driver to hold
    // per-adapter information. A pointer to this storage is provided with
    // every call made to the miniport driver. This data storage is
    // initialized to zero by the port driver.
    //

    ULONG HwDeviceExtensionSize;

    //
    // Supplies the number with which device numbering should be started.
    // The device numbering is used to determine which \DeviceX entry under
    // the \Parameters section in the registry should be used for parameters
    // to the miniport driver.
    // The number is *automatically* incremented when the miniport is called
    // back in it's FindAdapter routine due to an appropriate _Again_
    // parameter.
    //

    ULONG StartingDeviceNumber;


    //
    // New for version 3.5
    //

    //
    // Supplies a pointer to the miniport driver's HwResetHw routine.
    //
    // This function is called when the machine needs to bugchecks (go back
    // to the blue screen).
    //
    // This function should reset the video adapter to a character mode,
    // or at least to a state from which an int 10 can reset the card to
    // a character mode.
    //
    // This routine CAN NOT call int10.
    // It can only call Read\Write Port\Register functions from the port driver.
    //
    // The function must also be completely in non-paged pool since the IO\MM
    // subsystems may have crashed.
    //

    PVIDEO_HW_RESET_HW HwResetHw;

    //
    // Pointer to a timer routine to be called every second.
    //

    PVIDEO_HW_TIMER HwTimer;

    //
    //  Start of 5.0 stuff.
    //

    //
    //  Supplies a pointer to the miniport driver's start dma routine. This routine must
    //  return a HW_DMA_RETURN consistent with it's return behavior.
    //

    PVIDEO_HW_START_DMA HwStartDma;

    //
    //  HW dependent Power management routines.
    //

    PVIDEO_HW_POWER_SET HwSetPowerState;
    PVIDEO_HW_POWER_GET HwGetPowerState;

    //
    // Supplies a pointer to a miniport driver routine which can be called to
    // enumerate devices physically attached to the graphics adapter.
    //

    PVIDEO_HW_GET_CHILD_DESCRIPTOR HwGetVideoChildDescriptor;

    //
    // Supplies a pointer to a miniport driver routine which can be called to
    // query external programming interfaces supported in the miniport
    // driver.
    //

    PVIDEO_HW_QUERY_INTERFACE HwQueryInterface;

    //
    // Size of the device extension associated with the display output device.
    // This should only be set (to the approrpiate size) if the miniport driver
    // needs to manage the monitor configuration data separately from the
    // adapter board configuration (example - multiple output graphics devices).
    //

    ULONG HwChildDeviceExtensionSize;

    //
    // Allows the device to report legacy resources that should be
    // associated with the Plug and Play device.
    //

    PVIDEO_ACCESS_RANGE HwLegacyResourceList;

    //
    // Number of elements in the legacy resource list.
    //

    ULONG HwLegacyResourceCount;

    //
    // Call this routine to allow a driver to specify it's
    // legacy resources based on its device/vendor id.
    //

    PVIDEO_HW_LEGACYRESOURCES HwGetLegacyResources;

    //
    // Can HwGetVideoChildDescriptor be called before HwInitialize?
    //

    BOOLEAN AllowEarlyEnumeration;

} VIDEO_HW_INITIALIZATION_DATA, *PVIDEO_HW_INITIALIZATION_DATA;

//
// DDC help routines.
//

typedef
VOID
(*PVIDEO_WRITE_CLOCK_LINE)(
    PVOID HwDeviceExtension,
    UCHAR Data
    );

typedef
VOID
(*PVIDEO_WRITE_DATA_LINE)(
    PVOID HwDeviceExtension,
    UCHAR Data
    );

typedef
BOOLEAN
(*PVIDEO_READ_CLOCK_LINE)(
    PVOID HwDeviceExtension
    );

typedef
BOOLEAN
(*PVIDEO_READ_DATA_LINE)(
    PVOID HwDeviceExtension
    );

typedef
VOID
(*PVIDEO_WAIT_VSYNC_ACTIVE)(
    PVOID HwDeviceExtension
    );

//
// Data structures used I2C and DDC helper functions.
//

typedef struct _I2C_FNC_TABLE
{
    ULONG                    Size;
    PVIDEO_WRITE_CLOCK_LINE  WriteClockLine;
    PVIDEO_WRITE_DATA_LINE   WriteDataLine;
    PVIDEO_READ_CLOCK_LINE   ReadClockLine;
    PVIDEO_READ_DATA_LINE    ReadDataLine;
    PVIDEO_WAIT_VSYNC_ACTIVE WaitVsync;
    PVOID                    Reserved;
} I2C_FNC_TABLE, *PI2C_FNC_TABLE;

typedef struct _I2C_CALLBACKS
{
    PVIDEO_WRITE_CLOCK_LINE WriteClockLine;
    PVIDEO_WRITE_DATA_LINE  WriteDataLine;
    PVIDEO_READ_CLOCK_LINE  ReadClockLine;
    PVIDEO_READ_DATA_LINE   ReadDataLine;
} I2C_CALLBACKS, *PI2C_CALLBACKS;

typedef struct _DDC_CONTROL
{
    ULONG         Size;
    I2C_CALLBACKS I2CCallbacks;
    UCHAR         EdidSegment;
} DDC_CONTROL, *PDDC_CONTROL;

//
// Types of services exported by the VideoPortQueryServices().
//

typedef enum
{
    VideoPortServicesAGP = 1,
    VideoPortServicesI2C
} VIDEO_PORT_SERVICES;

//
// AGP services interface.
//

typedef struct _VIDEO_PORT_AGP_INTERFACE
{
    USHORT                 Size;
    USHORT                 Version;
    PVOID                  Context;
    PINTERFACE_REFERENCE   InterfaceReference;
    PINTERFACE_DEREFERENCE InterfaceDereference;
    PAGP_RESERVE_PHYSICAL  AgpReservePhysical;
    PAGP_RELEASE_PHYSICAL  AgpReleasePhysical;
    PAGP_COMMIT_PHYSICAL   AgpCommitPhysical;
    PAGP_FREE_PHYSICAL     AgpFreePhysical;
    PAGP_RESERVE_VIRTUAL   AgpReserveVirtual;
    PAGP_RELEASE_VIRTUAL   AgpReleaseVirtual;
    PAGP_COMMIT_VIRTUAL    AgpCommitVirtual;
    PAGP_FREE_VIRTUAL      AgpFreeVirtual;
    ULONGLONG              AgpAllocationLimit;
} VIDEO_PORT_AGP_INTERFACE, *PVIDEO_PORT_AGP_INTERFACE;

//
// I2C helper routines exported via VideoPortQueryServices().
//

typedef
BOOLEAN
(*PI2C_START)(
    IN PVOID HwDeviceExtension,
    IN PI2C_CALLBACKS I2CCallbacks
    );

typedef
BOOLEAN
(*PI2C_STOP)(
    IN PVOID HwDeviceExtension,
    IN PI2C_CALLBACKS I2CCallbacks
    );

typedef
BOOLEAN
(*PI2C_WRITE)(
    IN PVOID HwDeviceExtension,
    IN PI2C_CALLBACKS I2CCallbacks,
    IN PUCHAR Buffer,
    IN ULONG Length
    );

typedef
BOOLEAN
(*PI2C_READ)(
    IN PVOID HwDeviceExtension,
    IN PI2C_CALLBACKS I2CCallbacks,
    OUT PUCHAR Buffer,
    IN ULONG Length
    );

//
// I2C services interface.
//

typedef struct _VIDEO_PORT_I2C_INTERFACE
{
    USHORT                 Size;
    USHORT                 Version;
    PVOID                  Context;
    PINTERFACE_REFERENCE   InterfaceReference;
    PINTERFACE_DEREFERENCE InterfaceDereference;
    PI2C_START             I2CStart;
    PI2C_STOP              I2CStop;
    PI2C_WRITE             I2CWrite;
    PI2C_READ              I2CRead;
} VIDEO_PORT_I2C_INTERFACE, *PVIDEO_PORT_I2C_INTERFACE;

//
// Flags that can be passed to VideoPortGetDeviceBase or VideoPortMapMemory.
//

#define VIDEO_MEMORY_SPACE_MEMORY    0x00  // Should not be set by display driver
#define VIDEO_MEMORY_SPACE_IO        0x01  // Should not be set by display driver
#define VIDEO_MEMORY_SPACE_USER_MODE 0x02  // Memory pointer for application use
#define VIDEO_MEMORY_SPACE_DENSE     0x04  // Mapped dense, linearly (ALPHA)
#define VIDEO_MEMORY_SPACE_P6CACHE   0x08  // P6 MTRR caching (kernel and user)

//
// Define status codes returned by HwGetVideoChildDescriptor()
// miniport enumaration routine.
//
// Note: For backword compatibility reasons these values match
// existing WINERROR codes.
//

//
// Call again (ACPI and non-ACPI devices will be enumerated).
//

#define VIDEO_ENUM_MORE_DEVICES     ERROR_CONTINUE

//
// Stop enumeration.
//

#define VIDEO_ENUM_NO_MORE_DEVICES  ERROR_NO_MORE_DEVICES

//
// Call again, device could not be enumerated.
//

#define VIDEO_ENUM_INVALID_DEVICE   ERROR_INVALID_NAME

//
// Define the bits in VgaStatus.
//

#define DEVICE_VGA_ENABLED          1

//
// Port driver routines called by miniport driver and callbacks.
//

VIDEOPORT_API
VP_STATUS
VideoPortAllocateBuffer(
    IN PVOID HwDeviceExtension,
    IN ULONG Size,
    OUT PVOID *Buffer
    );

VIDEOPORT_API
VOID
VideoPortAcquireDeviceLock(
    IN PVOID HwDeviceExtension
    );

VIDEOPORT_API
ULONG
VideoPortCompareMemory(
    PVOID Source1,
    PVOID Source2,
    ULONG Length
    );

VIDEOPORT_API
BOOLEAN
VideoPortDDCMonitorHelper(
    IN PVOID HwDeviceExtension,
    IN PVOID DDCControl,
    IN OUT PUCHAR EdidBuffer,
    IN ULONG EdidBufferSize
    );

VIDEOPORT_API
VOID
VideoPortDebugPrint(
    ULONG DebugPrintLevel,
    PCHAR DebugMessage,
    ...
    );

VIDEOPORT_API
VP_STATUS
VideoPortDisableInterrupt(
    PVOID HwDeviceExtension
    );

VIDEOPORT_API
VP_STATUS
VideoPortEnableInterrupt(
    PVOID HwDeviceExtension
    );

VIDEOPORT_API
VP_STATUS
VideoPortEnumerateChildren(
    IN PVOID HwDeviceExtension,
    IN PVOID Reserved
    );

VIDEOPORT_API
VOID
VideoPortFreeDeviceBase(
    PVOID HwDeviceExtension,
    PVOID MappedAddress
    );

typedef
VP_STATUS
(*PMINIPORT_QUERY_DEVICE_ROUTINE)(
    PVOID HwDeviceExtension,
    PVOID Context,
    VIDEO_DEVICE_DATA_TYPE DeviceDataType,
    PVOID Identifier,
    ULONG IdentiferLength,
    PVOID ConfigurationData,
    ULONG ConfigurationDataLength,
    PVOID ComponentInformation,
    ULONG ComponentInformationLength
    );

VIDEOPORT_API
VP_STATUS
VideoPortGetAccessRanges(
    PVOID HwDeviceExtension,
    ULONG NumRequestedResources,
    PIO_RESOURCE_DESCRIPTOR RequestedResources OPTIONAL,
    ULONG NumAccessRanges,
    PVIDEO_ACCESS_RANGE AccessRanges,
    PVOID VendorId,
    PVOID DeviceId,
    PULONG Slot
    );

VIDEOPORT_API
PVOID
VideoPortGetAssociatedDeviceExtension(
    IN PVOID DeviceObject
    );

VIDEOPORT_API
ULONG
VideoPortGetBusData(
    PVOID HwDeviceExtension,
    BUS_DATA_TYPE BusDataType,
    ULONG SlotNumber,
    PVOID Buffer,
    ULONG Offset,
    ULONG Length
    );

VIDEOPORT_API
UCHAR
VideoPortGetCurrentIrql();

VIDEOPORT_API
PVOID
VideoPortGetDeviceBase(
    PVOID HwDeviceExtension,
    PHYSICAL_ADDRESS IoAddress,
    ULONG NumberOfUchars,
    UCHAR InIoSpace
    );

VIDEOPORT_API
VP_STATUS
VideoPortGetDeviceData(
    PVOID HwDeviceExtension,
    VIDEO_DEVICE_DATA_TYPE DeviceDataType,
    PMINIPORT_QUERY_DEVICE_ROUTINE CallbackRoutine,
    PVOID Context
    );

typedef
VP_STATUS
(*PMINIPORT_GET_REGISTRY_ROUTINE)(
    PVOID HwDeviceExtension,
    PVOID Context,
    PWSTR ValueName,
    PVOID ValueData,
    ULONG ValueLength
    );

VIDEOPORT_API
VP_STATUS
VideoPortGetRegistryParameters(
    PVOID HwDeviceExtension,
    PWSTR ParameterName,
    UCHAR IsParameterFileName,
    PMINIPORT_GET_REGISTRY_ROUTINE GetRegistryRoutine,
    PVOID Context
    );

VIDEOPORT_API
PVOID
VideoPortGetRomImage(
    IN PVOID HwDeviceExtension,
    IN PVOID Unused1,
    IN ULONG Unused2,
    IN ULONG Length
    );

VIDEOPORT_API
VP_STATUS
VideoPortGetVgaStatus(
    PVOID HwDeviceExtension,
    OUT PULONG VgaStatus
    );

VIDEOPORT_API
LONG
FASTCALL
VideoPortInterlockedDecrement(
    IN PLONG Addend
    );

VIDEOPORT_API
LONG
FASTCALL
VideoPortInterlockedIncrement(
    IN PLONG Addend
    );

VIDEOPORT_API
LONG
FASTCALL
VideoPortInterlockedExchange(
    IN OUT PLONG Target,
    IN LONG Value
    );

VIDEOPORT_API
ULONG
VideoPortInitialize(
    PVOID Argument1,
    PVOID Argument2,
    PVIDEO_HW_INITIALIZATION_DATA HwInitializationData,
    PVOID HwContext
    );

VIDEOPORT_API
VP_STATUS
VideoPortInt10(
    PVOID HwDeviceExtension,
    PVIDEO_X86_BIOS_ARGUMENTS BiosArguments
    );

VIDEOPORT_API
VOID
VideoPortLogError(
    PVOID HwDeviceExtension,
    PVIDEO_REQUEST_PACKET Vrp OPTIONAL,
    VP_STATUS ErrorCode,
    ULONG UniqueId
    );

VIDEOPORT_API
VP_STATUS
VideoPortMapMemory(
    PVOID HwDeviceExtension,
    PHYSICAL_ADDRESS PhysicalAddress,
    PULONG Length,
    PULONG InIoSpace,
    PVOID *VirtualAddress
    );

VIDEOPORT_API
VOID
VideoPortMoveMemory(
    PVOID Destination,
    PVOID Source,
    ULONG Length
    );

VIDEOPORT_API
VP_STATUS
VideoPortQueryServices(
    IN PVOID HwDeviceExtension,
    IN VIDEO_PORT_SERVICES ServicesType,
    IN OUT PINTERFACE Interface
    );

typedef
VOID
(*PMINIPORT_DPC_ROUTINE)(
    IN PVOID HwDeviceExtension,
    IN PVOID Context
    );

VIDEOPORT_API
BOOLEAN
VideoPortQueueDpc(
    IN PVOID HwDeviceExtension,
    IN PMINIPORT_DPC_ROUTINE CallbackRoutine,
    IN PVOID Context
    );

VIDEOPORT_API
UCHAR
VideoPortReadPortUchar(
    PUCHAR Port
    );

VIDEOPORT_API
USHORT
VideoPortReadPortUshort(
    PUSHORT Port
    );

VIDEOPORT_API
ULONG
VideoPortReadPortUlong(
    PULONG Port
    );

VIDEOPORT_API
VOID
VideoPortReadPortBufferUchar(
    PUCHAR Port,
    PUCHAR Buffer,
    ULONG Count
    );

VIDEOPORT_API
VOID
VideoPortReadPortBufferUshort(
    PUSHORT Port,
    PUSHORT Buffer,
    ULONG Count
    );

VIDEOPORT_API
VOID
VideoPortReadPortBufferUlong(
    PULONG Port,
    PULONG Buffer,
    ULONG Count
    );

VIDEOPORT_API
UCHAR
VideoPortReadRegisterUchar(
    PUCHAR Register
    );

VIDEOPORT_API
USHORT
VideoPortReadRegisterUshort(
    PUSHORT Register
    );

VIDEOPORT_API
ULONG
VideoPortReadRegisterUlong(
    PULONG Register
    );

VIDEOPORT_API
VOID
VideoPortReadRegisterBufferUchar(
    PUCHAR Register,
    PUCHAR Buffer,
    ULONG Count
    );

VIDEOPORT_API
VOID
VideoPortReadRegisterBufferUshort(
    PUSHORT Register,
    PUSHORT Buffer,
    ULONG Count
    );

VIDEOPORT_API
VOID
VideoPortReadRegisterBufferUlong(
    PULONG Register,
    PULONG Buffer,
    ULONG Count
    );

VIDEOPORT_API
VOID
VideoPortReleaseBuffer(
  IN PVOID HwDeviceExtension,
  IN PVOID Buffer
  );

VIDEOPORT_API
VOID
VideoPortReleaseDeviceLock(
    IN PVOID HwDeviceExtension
    );

VIDEOPORT_API
BOOLEAN
VideoPortScanRom(
    PVOID HwDeviceExtension,
    PUCHAR RomBase,
    ULONG RomLength,
    PUCHAR String
    );

VIDEOPORT_API
ULONG
VideoPortSetBusData(
    PVOID HwDeviceExtension,
    BUS_DATA_TYPE BusDataType,
    ULONG SlotNumber,
    PVOID Buffer,
    ULONG Offset,
    ULONG Length
    );

VIDEOPORT_API
VP_STATUS
VideoPortSetRegistryParameters(
    PVOID HwDeviceExtension,
    PWSTR ValueName,
    PVOID ValueData,
    ULONG ValueLength
    );

VIDEOPORT_API
VP_STATUS
VideoPortSetTrappedEmulatorPorts(
    PVOID HwDeviceExtension,
    ULONG NumAccessRanges,
    PVIDEO_ACCESS_RANGE AccessRange
    );

VIDEOPORT_API
VOID
VideoPortStallExecution(
    ULONG Microseconds
    );

VIDEOPORT_API
VOID
VideoPortStartTimer(
    PVOID HwDeviceExtension
    );

VIDEOPORT_API
VOID
VideoPortStopTimer(
    PVOID HwDeviceExtension
    );

typedef
BOOLEAN
(*PMINIPORT_SYNCHRONIZE_ROUTINE)(
    PVOID Context
    );

BOOLEAN
VIDEOPORT_API
VideoPortSynchronizeExecution(
    PVOID HwDeviceExtension,
    VIDEO_SYNCHRONIZE_PRIORITY Priority,
    PMINIPORT_SYNCHRONIZE_ROUTINE synchronizeRoutine,
    PVOID Context
    );

VIDEOPORT_API
VP_STATUS
VideoPortUnmapMemory(
    PVOID HwDeviceExtension,
    PVOID VirtualAddress,
    HANDLE ProcessHandle
    );

VIDEOPORT_API
VP_STATUS
VideoPortVerifyAccessRanges(
    PVOID HwDeviceExtension,
    ULONG NumAccessRanges,
    PVIDEO_ACCESS_RANGE AccessRanges
    );

VIDEOPORT_API
VOID
VideoPortWritePortUchar(
    PUCHAR Port,
    UCHAR Value
    );

VIDEOPORT_API
VOID
VideoPortWritePortUshort(
    PUSHORT Port,
    USHORT Value
    );

VIDEOPORT_API
VOID
VideoPortWritePortUlong(
    PULONG Port,
    ULONG Value
    );

VIDEOPORT_API
VOID
VideoPortWritePortBufferUchar(
    PUCHAR Port,
    PUCHAR Buffer,
    ULONG Count
    );

VIDEOPORT_API
VOID
VideoPortWritePortBufferUshort(
    PUSHORT Port,
    PUSHORT Buffer,
    ULONG Count
    );

VIDEOPORT_API
VOID
VideoPortWritePortBufferUlong(
    PULONG Port,
    PULONG Buffer,
    ULONG Count
    );

VIDEOPORT_API
VOID
VideoPortWriteRegisterUchar(
    PUCHAR Register,
    UCHAR Value
    );

VIDEOPORT_API
VOID
VideoPortWriteRegisterUshort(
    PUSHORT Register,
    USHORT Value
    );

VIDEOPORT_API
VOID
VideoPortWriteRegisterUlong(
    PULONG Register,
    ULONG Value
    );

VIDEOPORT_API
VOID
VideoPortWriteRegisterBufferUchar(
    PUCHAR Register,
    PUCHAR Buffer,
    ULONG Count
    );

VIDEOPORT_API
VOID
VideoPortWriteRegisterBufferUshort(
    PUSHORT Register,
    PUSHORT Buffer,
    ULONG Count
    );

VIDEOPORT_API
VOID
VideoPortWriteRegisterBufferUlong(
    PULONG Register,
    PULONG Buffer,
    ULONG Count
    );

VIDEOPORT_API
VOID
VideoPortZeroDeviceMemory(
    PVOID Destination,
    ULONG Length
    );

VIDEOPORT_API
VOID
VideoPortZeroMemory(
    PVOID Destination,
    ULONG Length
    );

//
// DMA support.
// TODO: Move to the separate module -- will be obsolete.
//

VIDEOPORT_API
PVOID
VideoPortAllocateContiguousMemory(
    IN  PVOID            HwDeviceExtension,
    IN  ULONG            NumberOfBytes,
    IN  PHYSICAL_ADDRESS HighestAcceptableAddress
    );

VIDEOPORT_API
PVOID
VideoPortGetCommonBuffer(
    IN  PVOID                       HwDeviceExtension,
    IN  ULONG                       DesiredLength,
    IN  ULONG                       Alignment,
    OUT PPHYSICAL_ADDRESS           LogicalAddress,
    OUT PULONG                      pActualLength,
    IN  BOOLEAN                     CacheEnabled
    );

VIDEOPORT_API
VOID
VideoPortFreeCommonBuffer(
    IN  PVOID            HwDeviceExtension,
    IN  ULONG            Length,
    IN  PVOID            VirtualAddress,
    IN  PHYSICAL_ADDRESS LogicalAddress,
    IN  BOOLEAN          CacheEnabled
    );

VIDEOPORT_API
PDMA
VideoPortDoDma(
    IN      PVOID                   HwDeviceExtension,
    IN      PDMA                    pDma,
    IN      DMA_FLAGS               DmaFlags
    );

VIDEOPORT_API
BOOLEAN
VideoPortLockPages(
    IN      PVOID                   HwDeviceExtension,
    IN OUT  PVIDEO_REQUEST_PACKET   pVrp,
    IN      PEVENT                  pUEvent,
    IN      PEVENT                  pDisplayEvent,
    IN      DMA_FLAGS               DmaFlags
    );

VIDEOPORT_API
BOOLEAN
VideoPortUnlockPages(
    PVOID   hwDeviceExtension,
    PDMA    pDma
    );

VIDEOPORT_API
BOOLEAN
VideoPortSignalDmaComplete(
    IN  PVOID               HwDeviceExtension,
    IN  PDMA                pDmaHandle
    );

VIDEOPORT_API
BOOLEAN
VideoPortCompleteDma(
    IN  PVOID           HwDeviceExtension,
    IN  PDMA            pDmaHandle,
    IN  DMA_EVENT_FLAGS CompletionFlags
    );

VIDEOPORT_API
PVOID
VideoPortGetMdl(
    IN  PVOID   HwDeviceExtension,
    IN  PDMA    pDma
    );

VIDEOPORT_API
PVOID
VideoPortGetDmaContext(
    IN  PVOID   HwDeviceExtension,
    IN  PDMA    pDma
    );

VIDEOPORT_API
VOID
VideoPortSetDmaContext(
    IN  PVOID   HwDeviceExtension,
    OUT PDMA    pDma,
    IN  PVOID   InstanceContext
    );

VIDEOPORT_API
ULONG
VideoPortGetBytesUsed(
    IN  PVOID   HwDeviceExtension,
    IN  PDMA    pDma
    );

VIDEOPORT_API
VOID
VideoPortSetBytesUsed(
    IN      PVOID   HwDeviceExtension,
    IN OUT  PDMA    pDma,
    IN      ULONG   BytesUsed
    );

VIDEOPORT_API
PDMA
VideoPortAssociateEventsWithDmaHandle(
    IN      PVOID                   HwDeviceExtension,
    IN OUT  PVIDEO_REQUEST_PACKET   pVrp,
    IN      PVOID                   MappedUserEvent,
    IN      PVOID                   DisplayDriverEvent
    );

VIDEOPORT_API
PDMA
VideoPortMapDmaMemory(
    IN      PVOID                   HwDeviceExtension,
    IN      PVIDEO_REQUEST_PACKET   pVrp,
    IN      PHYSICAL_ADDRESS        BoardAddress,
    IN      PULONG                  Length,
    IN      PULONG                  InIoSpace,
    IN      PVOID                   MappedUserEvent,
    IN      PVOID                   DisplayDriverEvent,
    IN OUT  PVOID                 * VirtualAddress
    );

VIDEOPORT_API
BOOLEAN
VideoPortUnmapDmaMemory(
    PVOID               HwDeviceExtension,
    PVOID               VirtualAddress,
    HANDLE              ProcessHandle,
    PDMA                BoardMemoryHandle
    );

//
// TODO: End of move block.
//

#endif // ifndef __VIDEO_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\minix\minixp.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    minixp.h

Abstract:

    This module contains the private data structures and procedure prototypes
    for the minix port driver.

--*/

#ifndef _MINIXP_
#define _MINIXP_

// Define ourselves as an NV20 to make life easy when including Nvidia
// header files:

#define NVARCH 0x20


#include <ntos.h>
#include <videoprt.h>
#include <pci.h>
#include <ntddvdeo.h>
#include <video.h>
#include <dderror.h>
#include <v86emul.h>   // needed by nv.h
#include <nv.h>
#include <minix.h>


BOOLEAN AgpUmaEnable();


typedef struct _MINIX_DRIVER_EXTENSION {

    VIDEO_DEVICE_EXTENSION VideoExtension;
    HW_DEVICE_EXTENSION HwExtension;

    ULONG Client;


} MINIX_DRIVER_EXTENSION, *PMINIX_DRIVER_EXTENSION;



LONG
MxCreatePort(
    VOID
    );


 
#endif  // _MINIXP_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\minix\initx.c ===
/*++

Copyright (c) 1989-2000  Microsoft Corporation

Module Name:

    initx.c

Abstract:

    This module contains the code to initialize the video hardware

--*/


#include "minixp.h"


//
// Global variable to hold driver extension
//

PMINIX_DRIVER_EXTENSION MxDriverExtension;


//
// Local functions
//

BOOLEAN
MxPortInterrupt(
    IN PKINTERRUPT InterruptObject,
    IN PVOID ServiceContext
    );

VOID
MxDpcDispatcher(
    IN PKDPC Dpc,
    IN PVOID HwDeviceExtension,
    IN PVOID DpcRoutine,
    IN PVOID Context
    );


//
// Functions defined else where
//

VP_STATUS
NVFindAdapter(
    PVOID HwDeviceExtension,
    PVOID HwContext,
    PWSTR ArgumentString,
    PVIDEO_PORT_CONFIG_INFO ConfigInfo,
    PUCHAR Again
    );

BOOLEAN
NVInitialize(
    PVOID HwDeviceExtension
    );

BOOLEAN
NVStartIO(
    PVOID HwDeviceExtension,
    PVIDEO_REQUEST_PACKET RequestPacket
    );

BOOLEAN
NVInterrupt(
    PVOID HwDeviceExtension
    );

BOOL    
RmInitRm(
    VOID
    );


LONG
MxSetVideoMode(
    IN PMINIX_MODE_INFO ModeInfo
    );


LONG
MxAllocContextDma(
    IN ULONG Dma,
    IN ULONG Class,
    IN ULONG Flags,
    IN PVOID Base,
    IN ULONG Limit
    );




VOID
MxDpcDispatcher(
    IN PKDPC Dpc,
    IN PVOID HwDeviceExtension,
    IN PVOID DpcRoutine,
    IN PVOID Context
    )

/*++

Routine Description:

    This routine handles DPCs and forwards them to the miniport callback
    routine.

Arguments:

    Dpc - The DPC which is executing.

    HwDeviceExtension - The HwDeviceExtension for the device which scheduled
        the DPC.

    DpcRoutine - The callback in the miniport which needs to be called.

    Context - The miniport supplied context.

Returns:

    None.

--*/

{
    ((PMINIPORT_DPC_ROUTINE)(ULONG_PTR)DpcRoutine)(HwDeviceExtension, Context);
}



BOOLEAN
MxPortInterrupt(
    IN PKINTERRUPT InterruptObject,
    IN PVOID ServiceContext
    )
{
    BOOLEAN Handled;
    PVIDEO_DEVICE_EXTENSION VideoDeviceExtension;
    PHW_DEVICE_EXTENSION HwDeviceExtension;

    VideoDeviceExtension = &(MxDriverExtension->VideoExtension);
    HwDeviceExtension = &(MxDriverExtension->HwExtension);

    if (VideoDeviceExtension->InterruptsEnabled) {
        Handled = VideoDeviceExtension->HwInterrupt(HwDeviceExtension);
    } else {
        Handled = FALSE;
    }

    return Handled;
}





LONG
MxInitSystem(
    IN PVOID Argument1
    )
/*++

Routine Description:

    This routine initializes the I/O system.

Arguments:

    Argument1 - Supplies a pointer to the driver object

Return Value:

    Status of the operation

--*/
{
    NTSTATUS status;
    SYSTEM_BASIC_INFORMATION BasicInformation;
    PCI_SLOT_NUMBER SlotNumber;
    PCI_COMMON_CONFIG Configuration;
    VP_STATUS vpstatus;
    VIDEO_PORT_CONFIG_INFO ConfigInfo;
    UCHAR Again;
    ULONG InterruptVector;
    KIRQL InterruptIrql;
    PVIDEO_DEVICE_EXTENSION VideoDeviceExtension;
    PHW_DEVICE_EXTENSION HwDeviceExtension;
    PDRIVER_OBJECT DriverObject;

    DriverObject = (PDRIVER_OBJECT)Argument1;

    //
    // Initialize the Driver Object 
    //
    
    DriverObject->MajorFunction[IRP_MJ_MINIX_CREATE] = (PDRIVER_DISPATCH)MxCreatePort;
    DriverObject->MajorFunction[IRP_MJ_MINIX_SETVIDEOMODE] = (PDRIVER_DISPATCH)MxSetVideoMode;
    DriverObject->MajorFunction[IRP_MJ_MINIX_ALLOCCONTEXTDMA] = (PDRIVER_DISPATCH)MxAllocContextDma;

    MxDriverExtension = ExAllocatePoolWithTag(NonPagedPool, sizeof(MINIX_DRIVER_EXTENSION), 'rDxM');

    if (MxDriverExtension == NULL) {
        return (LONG)STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(MxDriverExtension, sizeof(MINIX_DRIVER_EXTENSION));

    VideoDeviceExtension = &(MxDriverExtension->VideoExtension);
    HwDeviceExtension = &(MxDriverExtension->HwExtension);
    
    //
    // Figure out how much physical memory is in the system.
    //

    status = NtQuerySystemInformation(SystemBasicInformation, &BasicInformation,
        sizeof(SYSTEM_BASIC_INFORMATION), NULL);

    if (!NT_SUCCESS(status)) {
        return (LONG)status;
    }

    //
    // Read the PCI configuration data for the adapter attached to the AGP440 bus.
    //

    SlotNumber.u.AsULONG = 0;
    SlotNumber.u.bits.DeviceNumber = AGP440_TARGET_DEVICE_NUMBER;
    SlotNumber.u.bits.FunctionNumber = AGP440_TARGET_FUNCTION_NUMBER;

    if (HalGetBusData(PCIConfiguration, 1, SlotNumber.u.AsULONG, &Configuration,
        sizeof(PCI_COMMON_CONFIG)) != sizeof(PCI_COMMON_CONFIG)) {
        return (LONG)STATUS_DEVICE_DOES_NOT_EXIST;
    }

    //
    // Verify that this looks something like an NVidia display controller and
    // that the configuration is in the state that we expect.
    //

    ASSERT(Configuration.BaseClass == PCI_CLASS_DISPLAY_CTLR);
    ASSERT(Configuration.VendorID == 0x10DE);
    ASSERT(VideoIsFlagSet(Configuration.Command, PCI_ENABLE_IO_SPACE));
    ASSERT(VideoIsFlagSet(Configuration.Command, PCI_ENABLE_BUS_MASTER));

    //
    // Initialize the video device extension.
    //

    VideoDeviceExtension->HwFindAdapter = NVFindAdapter;
    VideoDeviceExtension->HwInitialize = NVInitialize;
    VideoDeviceExtension->HwInterrupt = NVInterrupt;
    VideoDeviceExtension->HwStartIO = NVStartIO;

    RtlCopyMemory(VideoDeviceExtension->BaseAddresses, Configuration.u.type0.BaseAddresses,
        sizeof(ULONG) * PCI_TYPE0_ADDRESSES);

    KeInitializeDpc(&VideoDeviceExtension->Dpc, MxDpcDispatcher, HwDeviceExtension);  

    KeInitializeMutex(&VideoDeviceExtension->SyncMutex, 0);

    if (!AgpUmaEnable()) {
        return (LONG)STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Invoke the miniport's HwFindAdapter routine.
    //

    RtlZeroMemory(&ConfigInfo, sizeof(VIDEO_PORT_CONFIG_INFO));

    ConfigInfo.Length = sizeof(VIDEO_PORT_CONFIG_INFO);
    ConfigInfo.BusInterruptLevel = 0xFF;
    ConfigInfo.BusInterruptVector = 0xFF;
    ConfigInfo.SystemMemorySize = (ULONGLONG)BasicInformation.NumberOfPhysicalPages << PAGE_SHIFT;

    vpstatus = VideoDeviceExtension->HwFindAdapter(HwDeviceExtension, NULL,
        NULL, &ConfigInfo, &Again);

    if (vpstatus != NO_ERROR) {
        return (LONG)STATUS_DEVICE_DOES_NOT_EXIST;
    }

    //
    // Connect to the device's interrupt.
    //

    VideoDeviceExtension->InterruptsEnabled = TRUE;

    InterruptVector = HalGetInterruptVector(PCIBus, 0,
        Configuration.u.type0.InterruptLine, Configuration.u.type0.InterruptLine,
        &InterruptIrql);

    status = IoConnectInterrupt(&(VideoDeviceExtension->InterruptObject),
        MxPortInterrupt, VideoDeviceExtension, InterruptVector,
        InterruptIrql, InterruptIrql, LevelSensitive, TRUE);

    if (!NT_SUCCESS(status)) {
        return (LONG)status;
    }
                         
    //
    // Initialize resource manager
    //
    if (!RmInitRm()) {
        return (LONG)STATUS_UNSUCCESSFUL;
    }


    return (LONG)STATUS_SUCCESS;
}



LONG
MxCreatePort(
    VOID
    )
{
    PVIDEO_DEVICE_EXTENSION VideoDeviceExtension;
    PHW_DEVICE_EXTENSION HwDeviceExtension;

    VideoDeviceExtension = &(MxDriverExtension->VideoExtension);
    HwDeviceExtension = &(MxDriverExtension->HwExtension);

    if (VideoDeviceExtension->DeviceOpened) {
        // 
        // Calling this function more than once has no effect
        //
        return (LONG)STATUS_SUCCESS;
    }

    //
    // Invoke the miniport's HwInitialize routine.
    //

    if (!VideoDeviceExtension->HwInitialize(HwDeviceExtension)) {
        return (LONG)STATUS_UNSUCCESSFUL;
    }

    VideoDeviceExtension->DeviceOpened = TRUE;
    
    return (LONG)STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\minix\nvddobj.h ===
;/*
;***************************************************************************
;                                                                           *
;   Copyright (C) 1995, 1998 NVidia Corporation. All Rights Reserved.       *
;                                                                           *
;***************************************************************************
;*/


#if defined NV10 || defined NV4
#define NV_IN_PROGRESS          0x8000
#else   /* !(NV10 || NV4) */
#define NV_IN_PROGRESS          0xFF
#endif  /* !(NV10 || NV4) */

#define NV_DD_COMMON_DMA_BUFFER_SIZE    32768
// win9x driver does not use these values anymore
#define NV_DD_DMA_PUSH_BUFFER_SIZE      (2*1024*1024)
#define NV_DD_DMA_PUSH_BUFFER_SIZE_LRG  (4*1024*1024)

#define NV_VIDEO_NOTIFIER_BUFFER_SIZE   32 * sizeof(NvNotification)

#define NV_STATUS_DONE_OK          0

#if defined NV10 || defined NV4

#define videoColorKey                  NVFF6_TYPEDEF
#define videoScaler                    NVFF7_TYPEDEF
#define videoFromMemory                NVFF8_TYPEDEF
#define videoColormap                  NVFF9_TYPEDEF
#define videoSink                      NVFFA_TYPEDEF
#define patchcordVideo                 NVFFB_TYPEDEF
#define contextDmaInMemory             NVFFC_TYPEDEF
#define contextDmaToMemory             NVFFD_TYPEDEF
#define contextDmaFromMemory           NVFFE_TYPEDEF

#undef  NVFF8_SET_CONTEXT_DMA_NOTIFIES
#define NVFF8_SET_CONTEXT_DMA_NOTIFIES                   (0x00000180)
#undef  NVFF8_SET_VIDEO_OUTPUT
#define NVFF8_SET_VIDEO_OUTPUT                           (0x00000200)
#undef  NVFF8_IMAGE_SCAN_OFFSET
#define NVFF8_IMAGE_SCAN_OFFSET                          (0x00000300)
#undef  NVFF9_SET_VIDEO_OUTPUT
#define NVFF9_SET_VIDEO_OUTPUT                           (0x00000200)
#undef  NVFFA_SET_VIDEO_INPUT
#define NVFFA_SET_VIDEO_INPUT                            (0x00000200)
#undef  NVFFF_SET_CONTEXT_DMA_NOTIFIES
#define NVFFF_SET_CONTEXT_DMA_NOTIFIES                   (0x00000180)
#undef  NVFFF_CREATE_OFFSET
#define NVFFF_CREATE_OFFSET                              (0x00000300)
#undef  NVFFF_DESTROY_OFFSET
#define NVFFF_DESTROY_OFFSET                             (0x00000304)

                                        // default object on this sub-channel
#define NV_DD_ROP                  0    // NV_DD_CONTEXT_ROP - NV03_CONTEXT_ROP (0x043)
#define NV_DD_SURFACES             1    // NV_DD_SURFACES_2D - NV4/10_CONTEXT_SURFACES_2D (0x042/0x062)
#define NV_DD_ROP_RECT_AND_TEXT    2    // NV_DD_ROP_GDI_RECT_AND_TEXT - NV4_GDI_RECTANGLE_TEXT (0x04a)
#define NV_DD_BLIT                 3    // NV_DD_IMAGE_BLIT  - NV4_IMAGE_BLIT (0x05f)
#define NV_DD_IMAGE                4    // NV_DD_IMAGE_FROM_CPU - NV4_IMAGE_FROM_CPU (0x061)
#define NV_DD_STRETCH              5    // NV_DD_STRETCHED_IMAGE_FROM_CPU/or one of many NV_DD_SCALED_IMAGE_FROM_MEMORY - NV04/05_STRETCHED/SCALED_IMAGE_FROM_CPU/MEMORY (0x066/0x076)
#define NV_DD_CELSIUS              6    // D3D_CELSIUS_PRIMITIVE - NV10_CELSIUS_PRIMITIVE (0x056)
#ifdef WINNT    // Remove this when DX7 port is complete
#define NV_DD_TRANSCOLOR           6
#endif // WINNT
#define NV_DD_SPARE                7

/* Default cached objects in Windows 95 Direct Draw patch */
#define dDrawRop                       subchannel[NV_DD_ROP].nv3ContextRop
#define dDrawSurfaces                  subchannel[NV_DD_SURFACES].nv4ContextSurfaces2D
#define dDrawRopRectAndText            subchannel[NV_DD_ROP_RECT_AND_TEXT].nv4GdiRectangleText
#define dDrawBlit                      subchannel[NV_DD_BLIT].nv1ImageBlit
#define dDrawImageFromCpu              subchannel[NV_DD_IMAGE].nv1ImageFromCpu
#define dDrawStretch                   subchannel[NV_DD_STRETCH]
#define dDrawTransColor                subchannel[NV_DD_TRANSCOLOR].nv4ContextColorKey
#define dDrawSpare                     subchannel[NV_DD_SPARE]

#define dDrawSubchannelOffset(I)       (I * 0x00002000)

#define dVideoControlHdr               subchannel[0]
#define dVideoControl                  subchannel[0].Nv10VideoLutCursorDac
#define dVideoOverlayHdr               subchannel[1]
#define dVideoOverlay                  subchannel[1].Nv10VideoOverlay
#define dVideoDVDSubPictureHdr         subchannel[2]
#define dVideoDVDSubPicture            subchannel[2].Nv10DvdSubpicture
#define dVideoImageBlitHdr             subchannel[3]
#define dVideoImageBlit                subchannel[3].Nv04ImageBlit
#define dVideoSurface2DHdr             subchannel[4]
#define dVideoSurface2D                subchannel[4].Nv10ContextSurfaces2d


#define NV_DMA_PUSHER_JUMP             0x20000000

/* DMA pusher offsets */
#define SET_ROP_OFFSET                                          NV043_SET_ROP5
#define SURFACES_2D_SET_COLOR_FORMAT_OFFSET                     NV042_SET_COLOR_FORMAT
#define SURFACES_2D_PITCH_OFFSET                                NV042_SET_PITCH
#define SURFACES_2D_DEST_OFFSET                                 NV042_SET_OFFSET_DESTIN
#define IMAGE_BLACK_RECTANGLE_POINT_OFFSET                      NV019_SET_POINT
#define RECT_AND_TEXT_NO_OPERATION_OFFSET                       NV04A_NO_OPERATION
#define RECT_AND_TEXT_NOTIFY_OFFSET                             NV04A_NOTIFY
#define RECT_AND_TEXT_COLOR1A_OFFSET                            NV04A_COLOR1_A
#define RECT_AND_TEXT_CLIPPOINT0B_OFFSET                        NV04A_CLIP_POINT0_B
#define RECT_AND_TEXT_CLIPPEDRECT_POINT0_OFFSET                 NV04A_CLIPPED_RECTANGLE(0)
#define BLIT_POINT_IN_OFFSET                                    NV05F_CONTROL_POINT_IN
#define IMAGE_FROM_CPU_POINT_OFFSET                             NV061_POINT
#define IMAGE_FROM_CPU_COLOR_OFFSET                             NV061_COLOR(0)
#define STRETCHED_IMAGE_SIZE_IN_OFFSET                          NV076_SIZE_IN
#define STRETCHED_IMAGE_COLOR_OFFSET                            NV076_COLOR(0)
#define SCALED_IMAGE_NOTIFY_OFFSET                              NV077_NOTIFY
#define SCALED_IMAGE_CONTEXT_DMA_IMAGE_OFFSET                   NV077_SET_CONTEXT_DMA_IMAGE
#define SCALED_IMAGE_SET_COLOR_FORMAT                           NV077_SET_COLOR_FORMAT
#define SCALED_IMAGE_CLIPPOINT_OFFSET                           NV077_CLIP_POINT
#define SCALED_IMAGE_DELTADUDX_OFFSET                           NV077_DELTA_DU_DX
#define SCALED_IMAGE_IMAGE_OUT_POINT_OFFSET                     NV077_IMAGE_OUT_POINT
#define SCALED_IMAGE_IMAGE_IN_SIZE_OFFSET                       NV077_IMAGE_IN_SIZE
#define SCALED_IMAGE_IMAGE_IN_POINT_OFFSET                      NV077_IMAGE_IN
#define SET_TRANSCOLOR_OFFSET                                   NV057_SET_COLOR
#define MEM_TO_MEM_FORMAT_BUFFER_IN_OFFSET                      NV039_SET_CONTEXT_DMA_BUFFER_IN
#define MEM_TO_MEM_FORMAT_BUFFER_OUT_OFFSET                     NV039_SET_CONTEXT_DMA_BUFFER_OUT
#define MEM_TO_MEM_FORMAT_OFFSET_IN_OFFSET                      NV039_OFFSET_IN
#define BETA4_SET_BETA_FACTOR_OFFSET                            NV072_SET_BETA_FACTOR
#define VIDEO_FROM_MEM_OFFSET_OFFSET                            NVFF8_IMAGE_SCAN_OFFSET
#define CONTEXT_DMA_FROM_MEM_NOTIFY_OFFSET                      NVFFE_NOTIFY
#define CONTEXT_DMA_FROM_MEM_SET_DMA_SPECIFIER_OFFSET           NVFFE_SET_DMA_SPECIFIER
#define CONTEXT_DMA_FROM_MEM_SET_DMA_SPECIFIER_LIMIT_OFFSET     NVFFE_SET_DMA_SPECIFIER_LIMIT


#else   /* !(NV10 || NV4) */

#define NV_DD_ROP                      0
#define NV_DD_IMAGE_IN_MEMORY          1
#define NV_DD_ROP_RECT_AND_TEXT        2
#define NV_DD_BLIT                     3
#define NV_DD_IMAGE                    4
#define NV_DD_STRETCH                  5
#define NV_DD_TRANSCOLOR               6
#define NV_DD_SPARE                    7

/* Default cached objects in Windows 95 Direct Draw patch */
#define dDrawRop                       subchannel[NV_DD_ROP].rop5Solid
#define dDrawImageInMemory             subchannel[NV_DD_IMAGE_IN_MEMORY].imageInMemory
#define dDrawRopRectAndText            subchannel[NV_DD_ROP_RECT_AND_TEXT].winRectAndTextFromCpu
#define dDrawBlit                      subchannel[NV_DD_BLIT].imageBlit
#define dDrawImageFromCpu              subchannel[NV_DD_IMAGE].imageFromCpu
#define dDrawStretch                   subchannel[NV_DD_STRETCH]
#define dDrawTransColor                subchannel[NV_DD_TRANSCOLOR].imageSolid
#define dDrawSpare                     subchannel[NV_DD_SPARE]

#endif  /* !(NV10 || NV4) */
/*
      7 subchannels contain the default cached objects.  These objects
are expected to be loaded at all times except when one or more of them gets
temporarily replaced for an unusual rendering operation.  If a default cached
object does get temporarily replaced, it is expected to be restored immediately
after completion of the rendering operation which caused it's replacement.
There is a spare subchannel in the Direct Draw patch which is lazy evaluated
similarly to the one used in the display driver.

        In the Windows 95 Direct Draw patch description below outlined objects are
those expected to be cached in the 8 subchannels.  Objects with corners
marked only are objects which temporarily replace cached objects or which are
loaded into the eighth subchannel when used.  All other objects are created,
patched together, then never loaded again until the patch is destroyed.  Most of
those objects are in the interior of the patch and are referenced by row for
clear identification.  Patchcord object names are derived from the object
where their output originates (their source).




/* Windows 95 Double Buffered Direct Draw ROP3 Patch */


/*

   Objects

   Context DMA  Context DMA
    To Memory    To Memory
          . |    | . .-------. .               . .         . .---------------.
           MemToMem  |  Rop  |   Image Pattern      Image    |  Image Solid  |
            Format   | Solid |  (Alpha Enabled)     Black    |(Alpha Enabled)|
          '        ' '-------' '               '  Rectangle  '---------------'
                           |        |            '         '         |
                          P|I       |              |                 |
                           |  .-----'     .--------'    .------------'
                           | P|I         P|I           P|I
 .               .         |  |           |             |
    (Sync) Rect     P      |  |           |             |       P
     And Text     ------------------------------------------------->.
 '               '  I      |  |           |             |       I   |
                           |  |           |             |           |
                          P|IP|I         P|I           P|I          |
 .---------------.         V  V           |             V           |
 |   Rop Rect    |  P   Image Rop  P      V     P     Image     P   |
 |   And Text    |----->   And   ------------------>Color Key------>|       1
 '---------------'  I   ^          I      |     I               I   |
                       P|I |  |           |             |           |
                        | P|IP|I         P|I           P|I          |
.----------------.         V  V           V             V           |
| Image From CPU |  P   Image Rop  P    Image   P     Image     P   |
|(Alpha Disabled)|----->   And   ----->Stencil----->Color Key------>|       2
'----------------'  I   ^          I            I               I   |
                       P|I |  |           |             |           |
                        | P|IP|I         P|I           P|I          |
.                .         V  V           V             V           |
  Image From CPU    P   Image Rop  P    Image   P     Image     P   |
 (Alt Pxl Depth)  ----->   And   ----->Stencil----->Color Key------>|       3
'                '  I   ^          I            I               I   |
 CtxDmaFromSysMem      P|I |  |           |             |           |
    |                   | P|IP|I         P|I           P|I          |
.---|------------.         V  V           |             V           |
|  Scaled RGB    |  P   Image Rop  P      V     P     Image     P   |
|ImageFromSysMem |----->   And   ------------------>Color Key------>|       4
|(Alpna Disabled)|  I   ^          I      |     I               I   |
'----------------'     P|I |  |           |             |           |
 CtxDmaFromVidMem       | P|IP|I         P|I           P|I          |
.          |     .         V  V           |             V           |
   Scaled RGB       P   Image Rop  P      V     P     Image     P   |
 ImageFromVidMem  ----->   And   ------------------>Color Key------>|       5
 (Alpna Disabled)   I   ^          I      |     I               I   |
'                '     P|I |  |           |             |           |
    |                   | P|IP|I         P|I           P|I          |
.   |            .      |  |  |           |             |           |
   Scaled UYVY      P   |  V  V    P      V     P       V       P   |
 ImageFromSysMem  ------------------------------------------------->|       6
 (Alpna Disabled)   I   ^  |  |    I      |     I       |       I   |
'                '     P|I |  |           |             |           |
           |            | P|IP|I         P|I           P|I          |
.          |     .         |  |           |             |           |
   Scaled UYVY      P   |  V  V    P      V     P       V       P   |
 ImageFromVidMem  ------------------------------------------------->|       7
 (Alpna Disabled)   I   ^  |  |    I      |     I       |       I   |
'                '     P|I |  |           |             |           |
    |                   | P|IP|I         P|I           P|I          |
.   |            .      |  |  |           |             |           |
   Scaled YUYV      P   |  V  V    P      V     P       V       P   |
 ImageFromSysMem  ------------------------------------------------->|       8
 (Alpna Disabled)   I   ^  |  |    I      |     I       |       I   |
'                '     P|I |  |           |             |           |
           |            | P|IP|I         P|I           P|I          |
.          |     .         |  |           |             |           |
   Scaled YUYV      P   |  V  V    P      V     P       V       P   |
 ImageFromVidMem  ------------------------------------------------->|       9
 (Alpna Disabled)   I   ^  |  |    I      |     I       |       I   |
'                '     P|I |  |           |             |           |
 CtxDmaFromSysMem       | P|IP|I         P|I           P|I          |
.       |        .      |  |  |           |             |           |
    Floating 0      P   |  V  V    P      V     P       V       P   |
   Scaled UYVY    ------------------------------------------------->|       A
 ImageFromSysMem    I   ^  |  |    I      |     I       |       I   |
'                '     P|I |  |           |             |           |
 CtxDmaFromSysMem       | P|IP|I         P|I           P|I          |
.       |        .         |  |           |             |           |
    Floating 1      P   |  V  V    P      V     P       V       P   |
   Scaled UYVY    ------------------------------------------------->|       B
 ImageFromSysMem    I   ^  |  |    I      |     I       |       I   |
'                '     P|I |  |           |             |           |
 CtxDmaFromSysMem       | P|IP|I         P|I           P|I          |
.       |        .      |  |  |           |             |           |
    Floating 0      P   |  V  V    P      V     P       V       P   |
   Scaled YUYV    ------------------------------------------------->|       C
 ImageFromSysMem    I   ^  |  |    I      |     I       |       I   |
'                '     P|I |  |           |             |           |
 CtxDmaFromSysMem       | P|IP|I         P|I           P|I          |
.       |        .         |  |           |             |           |
    Floating 1      P   |  V  V    P      V     P       V       P   |
   Scaled YUYV    ------------------------------------------------->|       D
 ImageFromSysMem    I   ^  |  |    I      |     I       |       I   |
'                '     P|I |  |           |             |           |
 CtxDmaFromSysMem       | P|IP|I         P|I           P|I          |
.       |        .      |  |  |           |             |           |
    Floating 0      P   |  V  V    P      V     P       V       P   |
   Scaled Y420    ------------------------------------------------->|       AA
 ImageFromSysMem    I   ^  |  |    I      |     I       |       I   |
'                '     P|I |  |           |             |           |
 CtxDmaFromSysMem       | P|IP|I         P|I           P|I          |
.       |        .         |  |           |             |           |
    Floating 1      P   |  V  V    P      V     P       V       P   |
   Scaled Y420    ------------------------------------------------->|       BB
 ImageFromSysMem    I   ^  |  |    I      |     I       |       I   |
'                '     P|I |  |           |             |           |
                        | P|IP|I         P|I           P|I          |
.                .         V  V           |             |           |
  Stretched UV      P   Image Rop  P      V     P       V       P   |
      Image       ----->   And   ---------------------------------->|       CC
 (Alpna Disabled)   I   ^          I      |     I       |       I   |
'                '     P|I |  |           |             |           |
                        | P|IP|I         P|I           P|I          |
.                .         V  V           |             V           |
    Stretched       P   Image Rop  P      V     P     Image     P   |
      Image       ----->   And   ------------------>Color Key------>|       DD
 (Alpna Disabled)   I   ^          I      |     I       |       I   |
'                '     P|I |  |           |             |           |
                        | P|IP|I         P|I           P|I          |
.----------------.         V  V           V             V           |
|   Image Blit   |  P   Image Rop  P    Image   P     Image     P   |
|(Alpha Disabled)|----->   And   ----->Stencil----->Color Key------>|       E
'------------^---'  I   ^          I            I               I   |
            P|I        P|I                                          |
             |          |                                           |
             |          |                                           |
             |          '------------------------------------.      |
             |                                               |      |
             |                                               |      |
             |                                              P|I    P|I
             |                                               |      |
            P|I                                              |      |
             |                                               |      |
             |                                               |      V
 .             .               .           .              .-------------.
     Source     --------------- Context DMA --------------| Destination |  P
  ImageInMemory                  InMemory                 |ImageInMemory|<----.
 '             '               '           '              '-------------'  I  |
                                  |    |                                      |
                                  |    '-------------------------.            |
                                  |                              |            |
 .              .          P      |                 P     .                .  |
  Render Solid   ----------------------------------------> Destination Zeta   |
  Zeta Rectangle           I      |                 I       ImageInMemory     |
 '              '                 |                       '                '  |
                                  |                                           |
                                  '------------------------------.            |
                                                                 |            |
                                                          .                .  |
 .             .      P                               P    Destination Zeta   |
   Render D3D   ----------------------------------------->  BufferInMemory    |
  Triangle Zeta       Z         P   Image    P        Z   '      ^         '  |
 '             '------------------>Stencil----------------------------------->| F
                                I            I                   |            |
                                                                P|Z           |
 .             .      P                               P          |            |
   Render D3D   -------------------------------------------------'            |
  Triangle Zeta       Z         P   Image    P        Z                       |
   From Video   ------------------>Stencil----------------------------------->' FF
     Memory                     I            I
 '             '

                            .                 .
  Floating Format               Y, U, V, UV
  Context DMA From --------- System Memory To  ---------------.
   System Memory             Vid Memory Format                |
                            '                 '               |
                                                       Context DMA To
                                                        Video Memory
                            .                 .               |
                                Y, U, V, UV                   |
         .------------------  Video Memory To  ---------------'
         |                   Vid Memory Format
 .                .         '                 '
  Context DMA From
    Video Memory
 ,                ,               .          .
       |    |                       Primary
       |    '--------------------- Video From ------Flip Primary Notifier
       |                             Memory         Context DMA To Memory
       |                          '          '
       |                            |      |
       |                            |      |
       |                           P|V    P|V
       |                            |      |
       |                            |      |   P   .            .
  .          .                      V      V//<---- Shared Video
     YUV422     P   .      .    P  .         . V      Colormap
   Video From -----> Video  ------>   Video        '            '
     Memory     V    Scaler     V   Color Key
  '          '      '      '       '         '
        |                               |
        |                               |
  Flip Overlay Notifier                P|V
  Context DMA To Memory                 |
                                        V
                                   .         .
                                      Video
                                      Sink
                                   '         '

*/


/* Video channel shared Display Driver and DDraw Object IDs */

#define NV_VIDEO_NOTIFIER_CONTEXT_DMA_TO_MEMORY                 0x00008000
#define NV_VIDEO_LUT_CURSOR_DAC_NOTIFIER_CONTEXT_DMA_TO_MEMORY  0x00008004
#define NV_VIDEO_OVERLAY_NOTIFIER_CONTEXT_DMA_TO_MEMORY         0x00008008
#define NV_VIDEO_CONTEXT_DMA_IN_MEMORY                          0x00008010
#define NV_VIDEO_LUT_CURSOR_DAC                                 0x00008020
#define NV_VIDEO_OVERLAY                                        0x00008030
#define NV_VIDEO_DVD_SUBPICTURE                                 0x00008040
#define NV_VIDEO_SURFACES_2D_A8R8G8B8                           0x00008050
#define NV_VIDEO_CONTEXT_BETA4                                  0x00008060
#define NV_VIDEO_SRCCOPY_PREMULT_A8R8G8B8_IMAGE_BLIT            0x00008070

/* Windows 9X Direct Draw Object IDs */


#define NV_DD_PIO_CONTEXT_DMA_FROM_SYSTEM_MEMORY                0xDD001000
#define NV_DD_DMA_CONTEXT_DMA_FROM_SYSTEM_MEMORY                0xDD001000
#define NV_DD_PIO_FLOATING_FORMAT_CONTEXT_DMA_FROM_SYSTEM_MEMORY 0xDD001001
#define NV_DD_DMA_FLOATING_FORMAT_CONTEXT_DMA_FROM_SYSTEM_MEMORY 0xDD001001
#define NV_DD_PIO_CONTEXT_DMA_FROM_VIDEO_MEMORY                 0xDD001002
#define NV_DD_DMA_CONTEXT_DMA_FROM_VIDEO_MEMORY                 0xDD001002
#define NV_DD_PIO_FLOATING0_UYVY_CONTEXT_DMA_FROM_SYSTEM_MEMORY 0xDD001003
#define NV_DD_DMA_FLOATING0_UYVY_CONTEXT_DMA_FROM_SYSTEM_MEMORY 0xDD001003
#define NV_DD_PIO_FLOATING1_UYVY_CONTEXT_DMA_FROM_SYSTEM_MEMORY 0xDD001004
#define NV_DD_DMA_FLOATING1_UYVY_CONTEXT_DMA_FROM_SYSTEM_MEMORY 0xDD001004
#define NV_DD_PIO_FLOATING0_YUYV_CONTEXT_DMA_FROM_SYSTEM_MEMORY 0xDD001005
#define NV_DD_DMA_FLOATING0_YUYV_CONTEXT_DMA_FROM_SYSTEM_MEMORY 0xDD001005
#define NV_DD_PIO_FLOATING1_YUYV_CONTEXT_DMA_FROM_SYSTEM_MEMORY 0xDD001006
#define NV_DD_DMA_FLOATING1_YUYV_CONTEXT_DMA_FROM_SYSTEM_MEMORY 0xDD001006
#define NV_DD_PIO_FLOATING_CONTEXT_DMA_IN_OVERLAY_SHADOW        0xDD001007
#define NV_DD_DMA_FLOATING_CONTEXT_DMA_IN_OVERLAY_SHADOW        0xDD001007
#define NV_DD_DMA_TEXTURE_CONTEXT_DMA_FROM_SYSTEM_MEMORY        0xDD001009
#define NV_DD_DMA_FLOATING_TEXTURE_CONTEXT_DMA_FROM_SYSTEM_MEMORY 0xDD00100A
#define NV_DD_DMA_TRIANGLE_CONTEXT_DMA_FROM_SYSTEM_MEMORY       0xDD00100B
#define NV_DD_PIO_CONTEXT_DMA_IN_VIDEO_MEMORY                   0xDD001010
#define NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY                   0xDD001010
#define NV_DD_PIO_COMBINER_EVENT_NOTIFIER                       0xDD001014
#define NV_DD_DMA_COMBINER_EVENT_NOTIFIER                       0xDD001014
#define NV_DD_PIO_TO_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY         0xDD001015
#define NV_DD_DMA_TO_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY         0xDD001015
#define NV_DD_PIO_FLIP_PRIMARY_NOTIFIER_CONTEXT_DMA_TO_MEMORY   0xDD001016
#define NV_DD_DMA_FLIP_PRIMARY_NOTIFIER_CONTEXT_DMA_TO_MEMORY   0xDD001016
#define NV_DD_PIO_FLIP_OVERLAY_NOTIFIER_CONTEXT_DMA_TO_MEMORY   0xDD001017
#define NV_DD_DMA_FLIP_OVERLAY_NOTIFIER_CONTEXT_DMA_TO_MEMORY   0xDD001017
#define NV_DD_PIO_FLIP_OVERLAY_NOTIFIER_CONTEXT_DMA_TO_MEMORY_0 0xDD001017
#define NV_DD_PIO_CONTEXT_DMA_TO_SYSTEM_MEMORY                  0xDD001018
#define NV_DD_DMA_CONTEXT_DMA_TO_SYSTEM_MEMORY                  0xDD001018
#define NV_DD_PIO_FROM_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY       0xDD001019
#define NV_DD_DMA_FROM_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY       0xDD001019
#define NV_DD_DMA_PUSHER_SYNC_NOTIFIER_CONTEXT_DMA_TO_MEMORY    0xDD00101A
#define NV_DD_PIO_BUFFER_NOTIFIER_CONTEXT_DMA_TO_MEMORY         0xDD00101B
#define NV_DD_DMA_BUFFER_NOTIFIER_CONTEXT_DMA_TO_MEMORY         0xDD00101B
#define NV_DD_PIO_CONTEXT_DMA_TO_VIDEO_MEMORY                   0xDD00101C
#define NV_DD_DMA_CONTEXT_DMA_TO_VIDEO_MEMORY                   0xDD00101C
#define NV_DD_PIO_SYNC_NOTIFIER_CONTEXT_DMA_TO_MEMORY           0xDD00101D
#define NV_DD_DMA_SYNC_NOTIFIER_CONTEXT_DMA_TO_MEMORY           0xDD00101D
#define NV_DD_PIO_FLIP_OVERLAY_NOTIFIER_CONTEXT_DMA_TO_MEMORY_1 0xDD00101E
#define NV_DD_PIO_COLOUR_CONTROL_EVENT_NOTIFIER                 0xDD00101F
#define NV_DD_DMA_COLOUR_CONTROL_EVENT_NOTIFIER                 0xDD00101F


#define NV_DD_VIDEO_MEMORY_TO_SYSTEM_MEMORY_FORMAT              0xDD001020
#define NV_DD_CONTEXT_ROP                                       0xDD001030
#define NV_DD_ROP5_SOLID                                        0xDD001030
#define NV_DD_P_I_ROP5_SOLID                                    0xDD001031
#define NV_DD_BETA_SOLID                                        0xDD001040
#define NV_DD_P_B_BETA_SOLID                                    0xDD001041
#define NV_DD_CONTEXT_PATTERN                                   0xDD001050
#define NV_DD_IMAGE_PATTERN                                     0xDD001050
#define NV_DD_P_I_IMAGE_PATTERN                                 0xDD001051
#define NV_DD_IMAGE_BLACK_RECTANGLE                             0xDD001060
#define NV_DD_P_I_IMAGE_BLACK_RECTANGLE                         0xDD001061
#define NV_DD_CONTEXT_COLOR_KEY                                 0xDD001070
#define NV_DD_COLOR_KEY_IMAGE_SOLID                             0xDD001070
#define NV_DD_P_I_COLOR_KEY_IMAGE_SOLID                         0xDD001071
#define NV_DD_CONTEXT_BETA4                                     0xDD001080

#define NV_DD_ROP_GDI_RECT_AND_TEXT                             0xDD001100
#define NV_DD_P_I_ROP_GDI_RECT_AND_TEXT                         0xDD001101
#define NV_DD_ABLEND_RECT_AND_TEXT                              0xDD001108
#define NV_DD_PUSHER_SYNC_RECT_AND_TEXT_FROM_CPU                0xDD00110A
#define NV_DD_P_I_PUSHER_SYNC_RECT_AND_TEXT_FROM_CPU            0xDD00110B
#define NV_DD_IMAGE_FROM_CPU                                    0xDD001200
#define NV_DD_P_I_IMAGE_FROM_CPU                                0xDD001201
#define NV_DD_SRCCOPY_IMAGE_FROM_CPU                            0xDD001208
#define NV_DD_IMAGE_BLEND_FROM_CPU                              0xDD001300
#define NV_DD_P_I_IMAGE_BLEND_FROM_CPU                          0xDD001301
#define NV_DD_ABLEND_NOSRCALPHA_IMAGE_FROM_CPU                  0xDD001308
#define NV_DD_ABLEND_IMAGE_FROM_CPU                             0xDD001309
#define NV_DD_STRETCHED_IMAGE_FROM_CPU                          0xDD001400
#define NV_DD_P_I_STRETCHED_IMAGE_FROM_CPU                      0xDD001401
#define NV_DD_SRCCOPY_STRETCHED_IMAGE_FROM_CPU                  0xDD001408
#define NV_DD_ABLEND_NOSRCALPHA_STRETCHED_IMAGE_FROM_CPU        0xDD001409
#define NV_DD_ABLEND_STRETCHED_IMAGE_FROM_CPU                   0xDD00140A
#define NV_DD_SCALED_RGB_IMAGE_FROM_SYSTEM_MEMORY               0xDD001500
#define NV_DD_P_I_SCALED_RGB_IMAGE_FROM_SYSTEM_MEMORY           0xDD001501
#define NV_DD_SRCCOPY_SCALED_RGB_IMAGE_FROM_SYSTEM_MEMORY       0xDD001508
#define NV_DD_ABLEND_NOSRCALPHA_SCALED_RGB_IMAGE_FROM_SYSTEM_MEMORY 0xDD001509
#define NV_DD_ABLEND_SCALED_RGB_IMAGE_FROM_SYSTEM_MEMORY        0xDD00150A
#define NV_DD_SCALED_RGB_IMAGE_FROM_VIDEO_MEMORY                0xDD001510
#define NV_DD_P_I_SCALED_RGB_IMAGE_FROM_VIDEO_MEMORY            0xDD001511
#define NV_DD_SRCCOPY_SCALED_RGB_IMAGE_FROM_VIDEO_MEMORY        0xDD001518
#define NV_DD_ABLEND_NOSRCALPHA_SCALED_RGB_IMAGE_FROM_VIDEO_MEMORY 0xDD001519
#define NV_DD_ABLEND_SCALED_RGB_IMAGE_FROM_VIDEO_MEMORY         0xDD00151A
#define NV_DD_SCALED_UYVY_IMAGE_FROM_SYSTEM_MEMORY              0xDD001520
#define NV_DD_P_I_SCALED_UYVY_IMAGE_FROM_SYSTEM_MEMORY          0xDD001521
#define NV_DD_SCALED_UYVY_IMAGE_FROM_VIDEO_MEMORY               0xDD001530
#define NV_DD_P_I_SCALED_UYVY_IMAGE_FROM_VIDEO_MEMORY           0xDD001531
#define NV_DD_SCALED_YUYV_IMAGE_FROM_SYSTEM_MEMORY              0xDD001540
#define NV_DD_P_I_SCALED_YUYV_IMAGE_FROM_SYSTEM_MEMORY          0xDD001541
#define NV_DD_SCALED_YUYV_IMAGE_FROM_VIDEO_MEMORY               0xDD001550
#define NV_DD_P_I_SCALED_YUYV_IMAGE_FROM_VIDEO_MEMORY           0xDD001551
#define NV_DD_FLOATING0_SCALED_UYVY_IMAGE_FROM_SYSTEM_MEMORY    0xDD001560
#define NV_DD_P_I_FLOATING0_SCALED_UYVY_IMAGE_FROM_SYSTEM_MEMORY 0xDD001561
#define NV_DD_FLOATING1_SCALED_UYVY_IMAGE_FROM_SYSTEM_MEMORY    0xDD001570
#define NV_DD_P_I_FLOATING1_SCALED_UYVY_IMAGE_FROM_SYSTEM_MEMORY 0xDD001571
#define NV_DD_FLOATING0_SCALED_YUYV_IMAGE_FROM_SYSTEM_MEMORY    0xDD001580
#define NV_DD_P_I_FLOATING0_SCALED_YUYV_IMAGE_FROM_SYSTEM_MEMORY 0xDD001581
#define NV_DD_FLOATING1_SCALED_YUYV_IMAGE_FROM_SYSTEM_MEMORY    0xDD001590
#define NV_DD_P_I_FLOATING1_SCALED_YUYV_IMAGE_FROM_SYSTEM_MEMORY 0xDD001591
#define NV_DD_GENERIC_SCALED_IMAGE                              0xDD0015A0
#define NV_DD_STRETCHED_UV_IMAGE_FROM_CPU                       0xDD001600
#define NV_DD_P_I_STRETCHED_UV_IMAGE_FROM_CPU                   0xDD001601
#define NV_DD_DVD_SUBPICTURE                                    0xDD001700

#define NV_DD_IMAGE_BLIT                                        0xDD001800
#define NV_DD_P_I_IMAGE_BLIT                                    0xDD001801
#define NV_DD_SRCCOPY_IMAGE_BLIT                                0xDD001808
#define NV_DD_SRCCOPY_PREMULT_A8R8G8B8_IMAGE_BLIT               0xDD00180A
#define NV_DD_ALT_IMAGE_FROM_CPU                                0xDD001900
#define NV_DD_P_I_ALT_IMAGE_FROM_CPU                            0xDD001901
#define NV_DD_RENDER_SOLID_ZETA_RECTANGLE                       0xDD001A00
#define NV_DD_P_I_RENDER_SOLID_ZETA_RECTANGLE                   0xDD001A01

#define NV_D3D_RENDER_TRIANGLE_ZETA                             0xDD001B00
#define NV_D3D_P_I_RENDER_TRIANGLE_ZETA                         0xDD001B01
#define NV_D3D_P_Z_RENDER_TRIANGLE_ZETA                         0xDD001B02
#define NV_D3D_RENDER_TRIANGLE_ZETA_FROM_VIDEO_MEMORY           0xDD001B03
#define NV_D3D_P_I_RENDER_TRIANGLE_ZETA_FROM_VIDEO_MEMORY       0xDD001B04
#define NV_D3D_P_Z_RENDER_TRIANGLE_ZETA_FROM_VIDEO_MEMORY       0xDD001B05
#define NV_D3D_FLOATING_RENDER_TRIANGLE_ZETA                    0xDD001B06
#define NV_D3D_FLOATING_P_I_RENDER_TRIANGLE_ZETA                0xDD001B07
#define NV_D3D_FLOATING_P_Z_RENDER_TRIANGLE_ZETA                0xDD001B08

// floating dma contexts for DVD acceleration
#define NV_DD_PIO_FLOATING_CONTEXT_DMA_IN_SYSTEM_S2V            0xDD001C00
#define NV_DD_DMA_FLOATING_CONTEXT_DMA_IN_SYSTEM_S2V            0xDD001C00
#define NV_DD_PIO_FLOATING_CONTEXT_DMA_IN_SYSTEM_S2V0           0xDD001C00
#define NV_DD_DMA_FLOATING_CONTEXT_DMA_IN_SYSTEM_S2V0           0xDD001C00
#define NV_DD_PIO_FLOATING_CONTEXT_DMA_IN_SYSTEM_S2V1           0xDD001C01
#define NV_DD_DMA_FLOATING_CONTEXT_DMA_IN_SYSTEM_S2V1           0xDD001C01
#define NV_DD_PIO_FLOATING_CONTEXT_DMA_IN_SYSTEM_S2V2           0xDD001C02
#define NV_DD_DMA_FLOATING_CONTEXT_DMA_IN_SYSTEM_S2V2           0xDD001C02
#define NV_DD_PIO_FLOATING_CONTEXT_DMA_IN_SYSTEM_S2V3           0xDD001C03
#define NV_DD_DMA_FLOATING_CONTEXT_DMA_IN_SYSTEM_S2V3           0xDD001C03
#define NV_DD_PIO_FLOATING_CONTEXT_DMA_IN_SYSTEM_S2V4           0xDD001C04
#define NV_DD_DMA_FLOATING_CONTEXT_DMA_IN_SYSTEM_S2V4           0xDD001C04
#define NV_DD_PIO_FLOATING_CONTEXT_DMA_IN_SYSTEM_S2V5           0xDD001C05
#define NV_DD_DMA_FLOATING_CONTEXT_DMA_IN_SYSTEM_S2V5           0xDD001C05
#define NV_DD_PIO_FLOATING_CONTEXT_DMA_IN_SYSTEM_S2V6           0xDD001C06
#define NV_DD_DMA_FLOATING_CONTEXT_DMA_IN_SYSTEM_S2V6           0xDD001C06
#define NV_DD_PIO_FLOATING_CONTEXT_DMA_IN_SYSTEM_S2V7           0xDD001C07
#define NV_DD_DMA_FLOATING_CONTEXT_DMA_IN_SYSTEM_S2V7           0xDD001C07
#define NV_DD_PIO_FLOATING_CONTEXT_DMA_IN_SYSTEM_S2V8           0xDD001C08
#define NV_DD_DMA_FLOATING_CONTEXT_DMA_IN_SYSTEM_S2V8           0xDD001C08
#define NV_DD_PIO_FLOATING_CONTEXT_DMA_IN_SYSTEM_S2V9           0xDD001C09
#define NV_DD_DMA_FLOATING_CONTEXT_DMA_IN_SYSTEM_S2V9           0xDD001C09
#define NV_DD_PIO_FLOATING_CONTEXT_DMA_IN_SYSTEM_S2VA           0xDD001C0A
#define NV_DD_DMA_FLOATING_CONTEXT_DMA_IN_SYSTEM_S2VA           0xDD001C0A
#define NV_DD_PIO_FLOATING_CONTEXT_DMA_IN_SYSTEM_S2VB           0xDD001C0B
#define NV_DD_DMA_FLOATING_CONTEXT_DMA_IN_SYSTEM_S2VB           0xDD001C0B
#define NV_DD_PIO_FLOATING_CONTEXT_DMA_IN_SYSTEM_S2VC           0xDD001C0C
#define NV_DD_DMA_FLOATING_CONTEXT_DMA_IN_SYSTEM_S2VC           0xDD001C0C
#define NV_DD_PIO_FLOATING_CONTEXT_DMA_IN_SYSTEM_S2VD           0xDD001C0D
#define NV_DD_DMA_FLOATING_CONTEXT_DMA_IN_SYSTEM_S2VD           0xDD001C0D
#define NV_DD_PIO_FLOATING_CONTEXT_DMA_IN_SYSTEM_S2VE           0xDD001C0E
#define NV_DD_DMA_FLOATING_CONTEXT_DMA_IN_SYSTEM_S2VE           0xDD001C0E
#define NV_DD_PIO_FLOATING_CONTEXT_DMA_IN_SYSTEM_S2VF           0xDD001C0F
#define NV_DD_DMA_FLOATING_CONTEXT_DMA_IN_SYSTEM_S2VF           0xDD001C0F

#define NV_DD_DMA_FLOATING_MC_IDCT0_CONTEXT_DMA_FROM_MEMORY     0xDD001D00
#define NV_DD_DMA_FLOATING_MC_IDCT1_CONTEXT_DMA_FROM_MEMORY     0xDD001D01
#define NV_DD_DMA_FLOATING_MC_IDCT2_CONTEXT_DMA_FROM_MEMORY     0xDD001D02
#define NV_DD_DMA_FLOATING_MC_IDCT3_CONTEXT_DMA_FROM_MEMORY     0xDD001D03


/* Patch interior */

#define NV_DD_IMAGE_ROP_AND_1                                   0xDD002110
#define NV_DD_P_I_IMAGE_ROP_AND_1                               0xDD002111
#define NV_DD_IMAGE_COLOR_KEY_1                                 0xDD002130
#define NV_DD_P_I_IMAGE_COLOR_KEY_1                             0xDD002131

#define NV_DD_IMAGE_ROP_AND_2                                   0xDD002210
#define NV_DD_P_I_IMAGE_ROP_AND_2                               0xDD002211
#define NV_DD_IMAGE_STENCIL_2                                   0xDD002220
#define NV_DD_P_I_IMAGE_STENCIL_2                               0xDD002221
#define NV_DD_IMAGE_COLOR_KEY_2                                 0xDD002230
#define NV_DD_P_I_IMAGE_COLOR_KEY_2                             0xDD002231

#define NV_DD_IMAGE_ROP_AND_3                                   0xDD002310
#define NV_DD_P_I_IMAGE_ROP_AND_3                               0xDD002311
#define NV_DD_IMAGE_STENCIL_3                                   0xDD002320
#define NV_DD_P_I_IMAGE_STENCIL_3                               0xDD002321
#define NV_DD_IMAGE_COLOR_KEY_3                                 0xDD002330
#define NV_DD_P_I_IMAGE_COLOR_KEY_3                             0xDD002331

#define NV_DD_IMAGE_ROP_AND_4                                   0xDD002410
#define NV_DD_P_I_IMAGE_ROP_AND_4                               0xDD002411
#define NV_DD_IMAGE_COLOR_KEY_4                                 0xDD002430
#define NV_DD_P_I_IMAGE_COLOR_KEY_4                             0xDD002431

#define NV_DD_IMAGE_ROP_AND_5                                   0xDD002510
#define NV_DD_P_I_IMAGE_ROP_AND_5                               0xDD002511
#define NV_DD_IMAGE_COLOR_KEY_5                                 0xDD002530
#define NV_DD_P_I_IMAGE_COLOR_KEY_5                             0xDD002531

#define NV_DD_IMAGE_ROP_AND_C                                   0xDD002C10
#define NV_DD_P_I_IMAGE_ROP_AND_C                               0xDD002C11

#define NV_DD_IMAGE_ROP_AND_D                                   0xDD002D10
#define NV_DD_P_I_IMAGE_ROP_AND_D                               0xDD002D11
#define NV_DD_IMAGE_COLOR_KEY_D                                 0xDD002D30
#define NV_DD_P_I_IMAGE_COLOR_KEY_D                             0xDD002D31

#define NV_DD_IMAGE_ROP_AND_E                                   0xDD002E10
#define NV_DD_P_I_IMAGE_ROP_AND_E                               0xDD002E11
#define NV_DD_IMAGE_STENCIL_E                                   0xDD002E20
#define NV_DD_P_I_IMAGE_STENCIL_E                               0xDD002E21
#define NV_DD_IMAGE_COLOR_KEY_E                                 0xDD002E30
#define NV_DD_P_I_IMAGE_COLOR_KEY_E                             0xDD002E31

#define NV_DD_IMAGE_STENCIL_F                                   0xDD002F20
#define NV_DD_P_I_IMAGE_STENCIL_F                               0xDD002F21

#define NV_DD_IMAGE_STENCIL_F3                                  0xDD002F30
#define NV_DD_P_I_IMAGE_STENCIL_F3                              0xDD002F31

#define NV_DD_IMAGE_STENCIL_FF                                  0xDD002FF0
#define NV_DD_P_I_IMAGE_STENCIL_FF                              0xDD002FF1


/* Patch back end */

#define NV_DD_SURFACES_2D                                       0xDD003F00
#define NV_DD_DST_IMAGE_IN_MEMORY                               0xDD003F00
#define NV_DD_P_I_DST_IMAGE_IN_MEMORY                           0xDD003F01
#define NV_DD_SURFACES_2D_A8R8G8B8                              0xDD003F02
#define NV_DD_SURFACES_3D                                       0xDD003F03
#define NV_DD_SURFACES_SWIZZLED                                 0xDD003F04
#define NV_DD_SRC_IMAGE_IN_MEMORY                               0xDD003F10
#define NV_DD_P_I_SRC_IMAGE_IN_MEMORY                           0xDD003F11
#define NV_DD_ZETA_IMAGE_IN_MEMORY                              0xDD003F20
#define NV_D3D_ZETA_BUFFER_IN_MEMORY                            0xDD003F30
#define NV_D3D_P_Z_ZETA_BUFFER_IN_MEMORY                        0xDD003F31

#define NV_DD_PRIMARY_VIDEO_FROM_MEMORY                         0xDD003F80
#define NV_DD_P_V_PRIMARY_VIDEO_FROM_MEMORY                     0xDD003F81
#define NV_DD_YUV422_VIDEO_FROM_MEMORY                          0xDD003F90
#define NV_DD_P_V_YUV422_VIDEO_FROM_MEMORY                      0xDD003F91
#define NV_DD_VIDEO_SCALER                                      0xDD003FA0
#define NV_DD_P_V_VIDEO_SCALER                                  0xDD003FA1
#define NV_DD_VIDEO_COLOR_KEY                                   0xDD003FB0
#define NV_DD_P_V_VIDEO_COLOR_KEY                               0xDD003FB1
#define NV_DD_SHARED_VIDEO_COLORMAP                             0xDD003FC0
#define NV_DD_P_V_SHARED_VIDEO_COLORMAP                         0xDD003FC1

#define NV_DD_SYSTEM_MEMORY_Y_TO_VIDEO_MEMORY_FORMAT            0xDD003FD0
#define NV_DD_SYSTEM_MEMORY_U_TO_VIDEO_MEMORY_FORMAT            0xDD003FD1
#define NV_DD_SYSTEM_MEMORY_V_TO_VIDEO_MEMORY_FORMAT            0xDD003FD2
#define NV_DD_SYSTEM_MEMORY_UV_TO_VIDEO_MEMORY_FORMAT           0xDD003FD3
#define NV_DD_VIDEO_MEMORY_Y_TO_VIDEO_MEMORY_FORMAT             0xDD003FE0
#define NV_DD_VIDEO_MEMORY_U_TO_VIDEO_MEMORY_FORMAT             0xDD003FE1
#define NV_DD_VIDEO_MEMORY_V_TO_VIDEO_MEMORY_FORMAT             0xDD003FE2
#define NV_DD_VIDEO_MEMORY_UV_TO_VIDEO_MEMORY_FORMAT            0xDD003FE3
#define NV_DD_VIDEO_MEMORY_TO_OVERLAY_SHADOW_FORMAT             0xDD003FE4
#define NV_DD_OVERLAY_SHADOW_TO_VIDEO_MEMORY_FORMAT             0xDD003FE5
#define NV_DD_DMABLT_TO_VID                                     0xDD003FE6
#define NV_DD_VIDEO_SINK                                        0xDD003FF0

#define NV_DD_COMMON_DMA_BUFFER                                 0xDD004000
#define NV_DD_PIO_CONTEXT_ERROR_TO_MEMORY                       0xDD004010
#define NV_DD_DEV_PIO                                           0xDD004020

#define NV_DD_DMA_PUSHER_CONTEXT_DMA_FROM_MEMORY                0xDD005000
#define NV_DD_DMA_CONTEXT_ERROR_TO_MEMORY                       0xDD005010
#define NV_DD_DEV_DMA                                           0xDD005020

#define NV_DD_DEV_VIDEO                                         0xDD006020

#define NV_DD_DEV_VPE                                           0xDD007020

#define NV_DD_VIDEO_LUT_CURSOR_DAC                              0xDD008000

#define NV_DD_GLOBALDATA_MEMORY                                 0xDD008020
#define NV_DD_GLOBALDATA_MEMORY_NVDD32_CONTEXT                  0xDD008021
#define NV_DD_IPM                                               0xDD008022
#define NV_DD_CONTEXTDMA_MEMORY                                 0xDD008030

#define NV_DD_INDEXED_IMAGE_FROM_CPU                            0xDD00A000

#ifdef WINNT
// Pushbuf ID needed for Win2k RM AGP allocator.
#define NV_DD_AGP_PUSHBUF                                       0xDD00A001
#endif // WINNT

// VPP objects
#define NV_DD_SWIZZLE_BLIT                                      0xDD00B000
#define NV_DD_DMA_OVERLAY                                       0xDD00B010
#define NV_DD_V2V_FORMAT_Y                                      0xDD00B020
#define NV_DD_ALPHA_BLIT                                        0xDD00B030

// Events
#define NV_DD_EVENT_IDLE_SYNC                                   0xDD00C000
#define NV_DD_EVENT_CONVERT_SYNC                                0xDD00C001
#define NV_DD_EVENT_DVD_SUBPICTURE                              0xDD00C002
#define NV_DD_EVENT_ALPHA_BLIT_SYNC                             0xDD00C003
#define NV_DD_EVENT_VIDEO_TO_SYSTEM_SYNC                        0xDD00C004
#define NV_DD_EVENT_SYSTEM_TO_VIDEO_SYNC                        0xDD00C005
#define NV_DD_EVENT_COMBINER_SYNC                               0xDD00C006
#define NV_DD_EVENT_DMABLT_TO_VID                               0xDD00C007
#define NV_DD_EVENT_OVL_FLIP1                                   0xDD00C008
#define NV_DD_EVENT_OVL_FLIP2                                   0xDD00C009
#define NV_DD_EVENT_DFILTER_SYNC                                0xDD00C00A

// Floating context DMA's for system surfaces (reserve a block of 512 for now)
#define MAX_FLOATING_CONTEXT_DMA                                0x200
#define MASK_FLOATING_CONTEXT_DMA_ID                            0xFFFFF001
#define FLOATING_CONTEXT_DMA_ID                                 0xDD00D001
#define NV_DD_FLOATING_CONTEXT_DMA_BASE                         0xDD00D001
#define NV_DD_FLOATING_CONTEXT_DMA_0                            0xDD00D001
#define NV_DD_FLOATING_CONTEXT_DMA_7FF                          0xDD00DFFF


// D3D objects

// naming convention:
// D3Dxxxyy
// where xxx = object class number
//        yy = enumerator, in case we have more than one object of type xxx

// DMA contexts.

#ifdef WINNT  // Still needed by old DX6 Win2k driver!!
#define D3D_CONTEXT_LINEAR_TEXTURE_FROM_MEMORY                  0xD3D00201
#define D3D_CONTEXT_SWIZZLED_TEXTURE_FROM_MEMORY                0xD3D00202
#endif // Still needed by old DX6 win2k driver

#define D3D_CONTEXT_xxx_unused_xxx                              0xD3D00201
#define D3D_CONTEXT_DMA_HOST_MEMORY                             0xD3D00202  // pci or agp context (growable for surfaces)

// Surface contexts.
#define D3D_CONTEXT_SURFACE_SWIZZLED                            0xD3D05201
#define D3D_CONTEXT_SURFACES_ARGB_ZS                            0xD3D05301

// D3D 2D rendering objects.
#define D3D_RENDER_SOLID_RECTANGLE                              0xD3D05E01  // Currently used for Z and Buffer Clears
#define D3D_RENDER_SOLID_RECTANGLE_2                            0xD3D05E02  // pseudo texblit notifiers
#define D3D_SCALED_IMAGE_FROM_MEMORY                            0xD3D07701  // Used for swizzling textures.

// D3D Triangle objects.
#define D3D_DX5_TEXTURED_TRIANGLE                               0xD3D05401  // DX5 class triangle renderer.
#define D3D_DX6_MULTI_TEXTURE_TRIANGLE                          0xD3D05501  // Multi Texture/Stencil triangle renderer.

// Celcius primitive
#define D3D_CELSIUS_PRIMITIVE                                   0xD3D05601

// Kelvin primitive
#define D3D_KELVIN_PRIMITIVE                                    0xD3D09701

// IPM allocator
#define IPM_MEMORY_OBJECT_LO                                    0x10000000  // low
#define IPM_MEMORY_OBJECT_HI                                    0x1fffffff  // high
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\minix\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

MAJORCOMP=ntos
MINORCOMP=minix

TARGETPATH=$(BASEDIR)\public\sdk\lib
TARGETTYPE=LIBRARY

         
MSC_WARNING_LEVEL=/W4 /WX


SOURCES= initx.c \
         drvx.c \
         agpuma.c
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\common\inc\CompileControl.h ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-2000 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/
#ifndef _COMPILE_CONTROL_H_
#define _COMPILE_CONTROL_H_

// Activate this block to get an idea of what #defs are set if it isn't clear
#if 0
#if defined(_WIN32)
#pragma message("Got _WIN32")
#endif
#if defined(WIN32)
#pragma message("Got WIN32")
#endif
#if defined(WINNT)
#pragma message("Got WINNT")
#else
#pragma message("No WINNT")
#endif
#if defined(_WIN32_WINNT)
#pragma message("Got WIN32 NT version")
#endif
#if (_WIN32_WINNT < 0x0500)
#pragma message("NT VER <500")
#else
#pragma message("NT VER >=500")
#endif
#endif

// Use this to for all windows-NT-based systems (NT4,Win2k,WinXP...)
#ifdef WINNT
#define IS_WINNT (IS_WINNT4 || IS_WINNT5)
#endif
		
#if (defined(WINNT) && (_WIN32_WINNT < 0x0500))
#define IS_WINNT4 1
#else
#undef IS_WINNT4
#endif

#if (defined(WINNT) && (_WIN32_WINNT >= 0x0500))
#define IS_WINNT5 1
#else
#undef IS_WINNT5
#endif

#if (defined (WIN32) && !defined(WINNT))
#define IS_WIN9X 1
#else
#undef IS_WIN9X
#endif

#if 0
#if (IS_WIN9X)
#pragma message("Compiling for OS = WIN9X")
#elif IS_WINNT4
#pragma message("Compiling for OS = WINNT4")
#elif IS_WINNT5
#pragma message("Compiling for OS = WINNT5")
#else
#error Unrecognized OS!
#endif
#endif

#if !(IS_WIN9X || IS_WINNT4 || IS_WINNT5)
#error Unrecognized OS!
#endif

#define IS_WIN98 ^^^ // Use IS_WIN9X
#define IS_WIN95 ^^^ // Use IS_WIN9X
#define IS_WINME ^^^ // Use IS_WIN9X

#endif _COMPILE_CONTROL_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\common\inc\elsaesc.h ===
//*****************************Module*Header******************************
//
// Module Name: elsaesc.h
//
// This file conatins all declarations for the ELSA Escape interface
// used by all tools and applications to access graphic driver data.
//
// FNicklisch 09/14/2000: 
//
// This part of code was taken from the code bought from ELSA. Parts of 
// it is used to get the workstation tools, application and features up
// and running. It is implemented on a temporary base and will be replaced
// by a NVIDIA propritary interface as soon as possible.
// Don't care about the code not necessariliy used.
//
// Copyright (c) 1998-2000, ELSA AG, Aachen (Germany)
// Copyright (c) 2000 NVidia Corporation. All Rights Reserved.
//
#ifndef __ELSAESC
#define __ELSAESC

/*
** $Header$
**
** MODULE:   ELSAESC.H
**
** AUTHOR:   Fred Nicklisch
**           Copyright (c) 1991-99 ELSA AG, Aachen (Germany)
**
** PROJECT:  ELSA Graphics Software
**
** PURPOSE:  define Escape interface between Windows 95/NT display driver
**           and tools
**
** DESCR:    All ELSA drivers will provide a escape interface to allow
**           user-applications (tools) to configure the display driver and
**           retrieve information. The application has to use ExtEscape.
**           The implementation depends on one single esc entry and
**           multiple subescapes.
**
**           WARNING: We only allow the basic types
**                    LONG, DWORD and char in all in and out structures!
**                    Don't use Tabs (blanks instead)
**                    Don't use german "Umlaute"
**
** NOTES:    01.12.97 FNicklis: First Release, basic functionality
**           02.12.97 MSuhre  : Added support for Monitor-Key,
**                              changed CHAR to char
**           03.12.97 SKuklik : Added support for DUO Boards
**           03.12.97 SKuklik : Added support for DUO Boards
**           04.12.97 FNicklis: struct packing and basic types
**           04.12.97 MSuhre  : #pragma pack (push/pop,..)
**                              push and pop are not valid for MS-C 1.52
**           06.03.98 tu      : Query and set value for string and dword added
**           06.03.98 FNicklis: Fixed "query and set value" to make it compilable
**           08.03.98 FNicklis: defined ET_SET_VALUE_RET
**           12.03.98 tu      : Added query and set value ID's for WinNT:
**                                HardwareInformation 0x20000500-0x200005ff
**                                Desktop coordinates 0x20000600-0x200006ff
**                                Some Basic/system values 0x20000002-0x20000004
**                              Added dwFlags to ET_VALUE_STRING and ET_VALUE_DWORD;
**                              Added return flags convention
**           12.03.98 THorn   : New grouping of the items in this file,
**                              no compiler relevant change.
**           13.03.98 tu      : Added value ID ET_VALUE_DW_ICDINTERFACE_SIZEOFBUFFER
**           13.04.98 db      : replaced dwAlign member of ET_QUERY with dwBoard
**                              Somehow we have to know for what board we want to read or write
**           13.04.98 db      : number of dma buffers is not number of subbuffers (used the same ID)
**           12.05.98 THorn   : SUBESC_ET_WINMAN_DDC_EDID_GET added.
**           09.06.98 tu      : Transfer ESCAPE calls from EDDESC.H (SUBESC_ET_EDD_xxx)
**           08.07.98 tu      : Added value ID ET_VALUE_DW_OPENGL_DISABLETEXTUREPATCHING (0x20000320)
**           14.08.98 FNicklis: Added value IDs ET_VALUE_DW_xx for NT driver
**           16.09.98 THorn   : SUBESC_ET_WINMAN2_... added.
**           25.09.98 tu      : added ET_VALUE_ERROR (0x80000000)
**                              added #pragma warning( disable:4201 ) at struct tagET_VERSION
**           30.09.98 FNicklis: Added version stamp and capabilities to ET_VERSION retrieved with
**                              SUBESC_ET_QUERY_VERSION_INFO
**           21.10.98 FNicklis: Extension to ET_VALUE_xx-interface (ET_VALUE_BLOCKED)
**           23.10.98 FNicklis: NT doesn't know FAR and somtimes doesn't know DWORD
**           25.10.98 FNicklis: Modified ET_VALUE_xx-interface to get reserved bits for OS internals
**           12.11.98 js:       ET_VALUE_DW_OPENGL_SUPPORTPRODESIGNER for OpenGL.SupportProDesigner added
**           21.11.98 FNicklis: ET_VALUE_DW_OPENGL_DMAMAXCOUNT, ET_VALUE_DW_OPENGL_DMAMINPUSHCOUNT added
**           25.11.98 MPietsch: ET_VALUE_DW_OPENGL_PIXELTUBE added
**                    FNicklis: Added some informational stuff regarding version stamp and version checking
**           02.12.98 FNicklis: New ET_VALUE_TYPE_DWORD_DEFAULT, ...
**           29.01.99 FNicklis: Registry Key-IDs 0x2000032A-0x2000032E
**           29.01.99 SKuklik:  Registry Key-IDs 0x20000069-0x2000006c, 0x20000097, 0x20000129, 0x20000208, 0x20000405 - 406, 0x20000601 - 602
**           03.02.99 CSkopins: Escape-Codes fuer Video-In/-Out hinzugefuegt.
**           11.02.99 SKuklik : Registry Key-ID  0x2000012B (ICDInterface.PFD_SWAP_EXCHANGE)
**           12.02.99 FNicklis: SUBESC_ET_QUERY_ICDCLIENTINFO
**           13.04.99 CSchalle: ET_VALUE_SZ_HARDWAREINFORMATION_BIOSSTRING
**           14.04.99 CSchalle: added ET_VALUE_DW_OPENGL_ALIGNED_SURFACES
**           22.04.99 CSchalle: added ET_VALUE_DW_OPENGL_FRAMEBUFFER_DMA
**           11.05.99 JS:       added ET_SUBESC_ET_xxx_VALUE_BINARY, ET_VALUE_BIN_GDI_GAMMARAMP
**                              added SUBESC_ET_EDD_xETGAMMARAMP
**           19.05.99 FNicklis: ET_VALUE_DW_OPENGL_AUTODESKEXTENSIONS fixed
**           28.06.99 HHornig : added RES_ESC_ELSA_TOOL call for generic drivers
**           30.06.99 FNicklis: added SUBESC_ET_MULTIBOARDSETUP for internal Display driver vs multiboard driver calls
**           25.08.99 CSkopins: added Capability flags for STEREO and OVERCLOCKING
**           22.09.99 HHornig : added ET_EDD_GETCOLORCAPSLIMITS
**           28.09.99 TU:       added SUBESC_ET_QUERY_TEMPERATURE for temperature and fan status
**           29.09.99 FNicklis: added SUBESC_ET_DPMS and sample code
**           18.10.99 CSkopins: added SUBESC_RMAPI_CONFIGSETGET for ERAZOR X TV-Out
**           20.10.99 CSchalle: added ET_VALUE_BIN_OEM_MODELIST
**           10.02.00 FNicklis: added ET_VALUE_DW_DMA_7DUMMYREADS, ET_VALUE_DW_DMA_DUMMYREADUC, ET_VALUE_DW_DMA_FORCEIOFLUSH
**           10.03.00 HHornig : added SUBESC_GET_OUTPUT_DEVICE_INFO / SUBESC_SET_OUTPUT_DEVICE
**           23.05.00 BSchwall: added ET_VALUE_DW_OPENGL_UNIGRAPHICS_TEXTURE_FIX
*/

// ********************************************************
// ********************************************************
// Basic defines
// -------------

// We need a common alignment for all structures:
// save current packing and switch to 8 byte (64bit)
#ifdef WIN32
#pragma pack (push, fixed_forELSAESC)
#endif
#pragma pack(8)

#define ET_MAX_PATH   260 // MAX_PATH is not available in all environments!
#define ET_MAX_STRING 260


#define ESC_ELSA_TOOLS 0xE15A // Escape for ELSA Tools
// HHORNIG : 28.6.99
// if we build generic drivers some tools are allowed to pop up
// to detect this the tool should use this call combined with
// a special code that is only used for this tool
#define RES_ESC_ELSA_TOOLS 0xE15B // restricted Escape for ELSA Tools

// FNicklis 23.10.98: Need it sometimes ;-)
#ifndef DWORD
typedef unsigned long DWORD;
#endif

// FNicklis 23.10.98: Under NT we don't have FAR and NEAR
#ifndef FAR
#define FAR
#endif

#ifdef NTMINIPORT
// FNicklis 29.01.1999: don't know HWND in NT miniport
#ifndef HWND
#define HWND PVOID
#endif
#endif// NTMINIPORT

// Subescapes: 0x00000000 - 0x0fffffffbasic sub escapes
//             0x10000000 - 0x1fffffff to be defined by Win95
//             0x20000000 - 0x2fffffff to be defined by NT (NTeam)
//             0x30000000 - 0xffffffff unused
// Naming: SUBESC_ET_xxxx, read: Sub escape for ELSA tools
//
// Note: Queries should use the same in structure ET_QUERY but different
//       query subescapes SUBESC_ET_QUERY_yyyy

// ********************************************************
// Sub escapes, common for Windows 95 and Windows NT:
#define SUBESC_ET_QUERY_VERSION_INFO        0x00000000

#define SUBESC_ET_QUERY_VALUE_STRING        0x00000010
#define SUBESC_ET_QUERY_VALUE_DWORD         0x00000011
#define SUBESC_ET_QUERY_VALUE_BINARY        0x00000012

#define SUBESC_ET_SET_VALUE_STRING          0x00000018
#define SUBESC_ET_SET_VALUE_DWORD           0x00000019
#define SUBESC_ET_SET_VALUE_BINARY          0x00000020

// 0x30-0x4F reserved for WINman
#define SUBESC_ET_WINMAN_DATA_GET           0x00000030
#define SUBESC_ET_WINMAN_DATA_SET           0x00000031
#define SUBESC_ET_WINMAN_DDC_EDID_GET       0x00000032
#define SUBESC_ET_WINMAN2_DATA_GET          0x00000035
#define SUBESC_ET_WINMAN2_DATA_SET          0x00000036
#define SUBESC_ET_WINMAN2_DDC_EDID_GET      0x00000037

// 0x50-0x6F reserved for elsa directdraw caps
#define SUBESC_ET_EDD_GETCAPS               0x00000050
#define SUBESC_ET_EDD_GETFEATURES           0x00000051
#define SUBESC_ET_EDD_SETFEATURES           0x00000052
#define SUBESC_ET_EDD_GETVIDMEMINFO         0x00000053
#define SUBESC_ET_EDD_GETCOLORADJUSTMENT    0x00000054
#define SUBESC_ET_EDD_SETCOLORADJUSTMENT    0x00000055
#define SUBESC_ET_EDD_SETGAMMARAMP          0x00000056
#define SUBESC_ET_EDD_GETGAMMARAMP          0x00000057
#define SUBESC_ET_EDD_GETCOLORCAPSLIMITS    0x00000058

// 0x100-0x11F reserved for Video-In / -Out Escapes
//
#define SUBESC_ET_VIDEO_DMACOPYSM           0x00000100
#define SUBESC_ET_VIDEO_OUTCONTROL          0x00000110
#define SUBESC_ET_RMAPI_CONFIGSETGET        0x0000011F

// 0x200-0x21F reserved for all tools to decide if they are
//             allowed to pop up, only to be used in combination
//             with a resctricted call RES_ESC_ELSA_TOOL
//
#define SUBESC_STEREO_TOOL                  0x00000200

// 0x300-0x3FF reserved for hardware status and control
//
#define SUBESC_ET_QUERY_TEMPERATURE         0x00000300

#define SUBESC_ET_GET_OUTPUT_DEVICE_INFO    0x00000310
#define SUBESC_ET_SET_OUTPUT_DEVICE         0x00000311


// ********************************************************
// Windows 95 sub escapes:

#define SUBESC_ET_QUERY_MONITORKEY_REGPATH  0x10000000
#define SUBESC_ET_QUERY_D3DSETTINGS_REGPATH 0x10000001

// ********************************************************
// Windows NT sub escapes:

#define SUBESC_ET_QUERY_OPENGLICD_REGPATH   0x20000000
#define SUBESC_ET_DUO_ESC_GETPANELINFO      0x20000002  //Returns Information on our Panel/PanelCaps
#define SUBESC_ET_DUO_ESC_SETPANELINFO      0x20000004  //Sets Panel Information
#define SUBESC_ET_POWERLIB_START            0x20000008  //Tells driver that one powerlib has started
#define SUBESC_ET_POWERLIB_EXIT             0x20000009  //Tells driver that one powerlib will end

// 0x10-0x2F reserved for driver internal escapes
#define SUBESC_ET_GETREGISTER               0x20000010  // direct hw access
#define SUBESC_ET_SETREGISTER               0x20000011
#define SUBESC_ET_MODIFYREGISTER            0x20000012
#define SUBESC_ET_SCROLL                    0x20000013
#define SUBESC_ET_GFXOPTIONQUERY            0x20000014

#define SUBESC_ET_NOTIFYDRIVER              0x20000015  // special support for video capture driver
#define SUBESC_ET_SAA                       0x20000016
#define SUBESC_ET_DDSURFOVERRIDE            0x20000017

#define SUBESC_ET_MULTIBOARDSETUP           0x20000018 // FNicklis: setup singleboard client with information from multiboard wrapper.
                                                       // IO structures ET_MULTIBOARDSETUP_IN and ET_MULTIBOARDSETUP_OUT are defined in driver code!
#define SUBESC_ET_DPMS                      0x20000019 // FNicklis: set DPMS power save mode; uses ET_DPMS_IN and ET_DPMS_OUT

// 0x30- ... Common driver Escapes
#define SUBESC_ET_SETWINDOW_STEREOMODE      0x20000030 // set the stereo mode of an OpenGL window
#define SUBESC_ET_QUERY_ICDCLIENTINFO       0x20000031 // receive information about OpenGL-Clients


// ********************************************************
// ********************************************************
// In structure (Tool -> driver):
// Input Query structure, common part of all subescape input structures
// --------------------------------------------------------------------
typedef struct tagET_QUERY
{
  DWORD dwSize;    // Length of this structure, sizeof(ET_QUERY)
  DWORD dwSubEsc;  // has to be (SUBESC_ET_QUERY_VERSION_INFO, SUBESC_ET_QUERY_OPENGLICD_REGPATH, ...)
  DWORD dwOutSize; // size of output data structure (if there is such data)
  DWORD dwBoard;   // for registry issues we need to know for what board we have to read/write @@db 130498
                   // Calls that affect all boards use ET_ALL_BOARDS to initialize dwBoard
                   // 0 -> board 0, 1 -> board 1, ET_ALL_BOARDS -> all boards
} ET_QUERY;

#define ET_ALL_BOARDS 0xFFFFFFFF   // FNicklis, 11.03.99 reserved key for all boards

// driver get's PVOIDs but needs a fast access to members
#define ET_QUERY_GET_SUBESC(pv)    (((ET_QUERY*)pv)->dwSubEsc)
#define ET_QUERY_GET_BOARD(pv)     (((ET_QUERY*)pv)->dwBoard)

// ********************************************************
// ********************************************************
// Version info and some other data from driver
// --------------------------------------------

#define MAX_ET_VERSION 64

#define ET_VER_RELEASE_DRIVER    0x0
#define ET_VER_WHQL_DRIVER       0x1 // Release driver for WHQL
#define ET_VER_BETA_DRIVER       0x2 // Beta driver neither release nor WHQL

// Out structure (Driver -> Tool):
// Version information used in ET_VERSION_INFO, retrieved by SUBESC_ET_QUERY_VERSION_INFO

#ifdef WIN32
#pragma warning( disable:4201 ) // nonstandard extension used : nameless struct/union
#endif

// Usage of ET_VERSION_STAMP:
//
// Allowes to check which bits of the capabilities fields are defined.
// You may only test the bits defined in the version matching the version
// stamp.
//
// NOTE: The version stamp is only valid for the ET_VERSION structure!
//   Don't validate other structures with this!
//
// NOTE: A tool may only test the capabilities defined for the version
//   matching the version stamp.
//
// NOTE: Newer versions must support the capabilites of older versions!
//
// NOTE: A tool must check for an equal version stamp as older drivers
//   didn't touch the reserved flags, and leaved them initialized!
//   It isn't allowed to do a greater equal test on the verstion stamp!
//
// example:
/*
// FNicklis 25.11.98 15:30:15: example program
BOOL bIsCVBoard(
  IN const ET_VERSION_INFO *pVersionInfo)  // pointer to version info (read outside)
{
  const ET_VERSION *pVersion;
  BOOL              bRet     = FALSE; // default is no CV board

  assert(NULL!=pVersionInfo);

  pVersion = &(pVersionInfo->Version);

  // as it is a union it must be the same!
  assert(pVersion->dwNTVersionStamp ==pVersion->dwW95VersionStamp);
  assert(pVersion->dwW95Capabilities==pVersion->dwNTCapabilities);

  //Not allowed! if ( pVersion->dwNTVersionStamp>ET_VERSION_STAMP10 )

  // ET_VERSION_STAMP10 was the first version that supported
  // this extenstion

  if ( ET_VERSION_STAMP10==pVersion->dwNTVersionStamp )
  {
    // it's a version 1.0, supported by our app

    // we may test 1.0 features: ET_VERSION_CAPS_CV_PRODUCT and ET_VERSION_CAPS_2D_BOARD_ONLY
    if ( pVersion->dwNTCapabilities & ET_VERSION_CAPS_CV_PRODUCT )
    {
      bRet = TRUE;
    }
  }
  else
  {
    // error, interface not valid
    // older board -> fallback
    // unknown board -> exit

    // .... add code here
  }

  return (bRet);
}
*/
// History:
// ???????? uninitialized and any other value than defined VERSION_STAMPS are
//          invalid and don't support the interface!
// 00000010: First version 1.0 valid and testableET_VERSION_CAPS_xx:
//     xx_CV_PRODUKT
//     xx_2D_BOARD
#define ET_VERSION_STAMP10 0x00000010         // FNicklis 30.09.1998 first version

// please don't use ET_VERSION_STAMP any longer!
#define ET_VERSION_STAMP  ET_VERSION_STAMP10  // Current version stamp is highest available, but better is
                                              // to use the stamp you know you support!
// capabilities
// defined in 1.0:
//                      CH == !CV product
#define ET_VERSION_CAPS_CV_PRODUCT     0x01 // The board is a CV product (GLoria, Synergy, ...)
                                            // GLoria Settings, POWERlib, ... must run
//                      3D == !2D
#define ET_VERSION_CAPS_2D_BOARD_ONLY  0x02 // The board has only 2D and no hardware 3D capabilities (Trio, S3 986,..)

//
#define ET_VERSION_CAPS_DIRECT3DSTEREO 0x04 // Driver supports REVELATOR type Stereo for Direct3D
#define ET_VERSION_CAPS_OPENGLSTEREO   0x08 // Driver supports REVELTAOR type Stereo for OpenGL
#define ET_VERSION_CAPS_OVERCLOCKING   0x10 // Driver supports overclocking
#define ET_VERSION_CAPS_TEMPERATURE    0x20 // Driver supports temperature control

// ... to be continued


// used with SUBESC_ET_QUERY_VERSION_INFO
typedef struct tagET_VERSION
{
  DWORD dwFlags;                     // Flags to define WHQL, BETA, ... driver
  DWORD dwAlign1;                    // needed to align on 8 byte boundaries

  // NT and Win95 version data is different, so use a union to match all
  union
  {
    struct // Windows 95 version information
    {
      DWORD dwW95Major;        //
      DWORD dwW95Minor;        //
      DWORD dwW95BuildMajor;   //
      DWORD dwW95BuildMinor;   //
      DWORD dwW95BuildPrivate; //
      DWORD dwW95Reserved1;    // unused
      DWORD dwW95Capabilities; // bitfield containing capabilities (ET_VERSION_CAPS_xx)
      DWORD dwW95VersionStamp; // == ET_VERSION_STAMP (read comment above!) Has to be verified before reading dwW95Capabilities!
    };
    struct // Windows NT version information
    {           // e.g 5.12.00.345
      DWORD dwNTMajor;      //   5
      DWORD dwNTMinor;      //  12
      DWORD dwNTBuildMajor; //  00
      DWORD dwNTBuildMinor; // 345
      DWORD dwNTReserved0;
      DWORD dwNTReserved1;
      DWORD dwNTCapabilities; // bitfield containing capabilities (ET_VERSION_CAPS_xx)
      DWORD dwNTVersionStamp; // == ET_VERSION_STAMP (read comment above!). Has to be verified before reading dwNTCapabilities!
    };
  };

  char  szVersion[MAX_ET_VERSION]; // Version string (ANSI/ASCCI)

} ET_VERSION;

#ifdef WIN32
#pragma warning( default:4201 ) // nonstandard extension used : nameless struct/union
#endif

// Out structure (Driver -> Tool):
// Structure to retrieve driver version and registry data
typedef struct tagET_VERSION_INFO
{
  DWORD dwSize;    // Length of this structure, sizeof(ET_VERSION_INFO)

  // Driver version information (system dependent!)
  ET_VERSION Version;

  // Complete path to drivers registry (be sure it is defined long enough!)
  char  szRegDriverKey[ET_MAX_PATH]; // e.g. NT:    "\Registry\Machine\System\CurrentControlSet\Services\EGLXLM"
                                 // e.g. Win95: "\Registry\Machine\System\CurrentControlSet\Services\Class\Display\0000"

} ET_VERSION_INFO;


// Out structure (Driver -> Tool):
// Structure to retrieve complete path to key where the monitor is defined
typedef struct tagET_MONITORKEY_REGPATH
{
  DWORD dwSize;    // Length of this structure, sizeof(ET_MONITORKEY_REGPATH)

  // Complete path to Key where the ICD is defined
  char  szRegMonitorKey[ET_MAX_PATH];  // e.g. Win95: "\Registry\Machine\System\CurrentControlSet\Services\Class\Monitor\0000"

} ET_MONITORKEY_REGPATH;


// Out structure (Driver -> Tool):
// Structure to retrieve complete path to key where D3DSettings store its settings
typedef struct tagET_D3DSETTINGS_REGPATH
{
  DWORD dwSize;    // Length of this structure, sizeof(ET_D3DSETTINGS_REGPATH)

  // Complete path to Key where the ICD is defined
  char  szRegD3DSettingsKey[ET_MAX_PATH];  // e.g. Win95: "\Registry\Machine\Software\ELSA\Erazor"

} ET_D3DSETTINGS_REGPATH;


// Out structure (Driver -> Tool):
// Structure to retrieve complete path to Key where the ICD is defined
typedef struct tagET_OPENGLICD_REGPATH
{
  DWORD dwSize;    // Length of this structure, sizeof(ET_OPENGLICD_REGPATH)

  // Complete path to Key where the ICD is defined
  char  szRegICDKey[ET_MAX_PATH];  // e.g. NT: "\Registry\Machine\Software\Microsoft\WindowsNT\OpenGLDrivers\ELSA EGLXLM driver"
  char  szRegICDName[ET_MAX_PATH]; // e.g. NT: "EOGLXL"

} ET_OPENGLICD_REGPATH;




// ET_EDD_GETVIDMEMINFO
// get surface counts
typedef struct tagET_EDD_GETVIDMEMINFODATA
{
  DWORD   dwSize;
  DWORD   dwPrimaryCount;
  DWORD   dwOffscreenCount;
  DWORD   dwOverlayCount;
} ET_EDD_GETVIDMEMINFODATA, FAR* LPET_EDD_GETVIDMEMINFODATA;


#define ET_COLOR_CAPS_CONTRAST    0x01    // driver supports contrast settings and limitations are valid
#define ET_COLOR_CAPS_BRIGHTNESS  0x02    // driver supports brightness settings and limitations are valid
#define ET_COLOR_CAPS_SATURATION  0x04    // driver supports saturation settings and limitations are valid
#define ET_COLOR_CAPS_HUE         0x08    // driver supports hue settings and limitations are valid

// ET_EDD_GETCOLORCAPSLIMITS
// get capability of contrast, brightness saturation and hue
// and their limits. The limits are only valid if the capability
// is set.
typedef struct tagET_EDD_GETCOLORCAPSLIMITS
{
  DWORD   dwSize;
  DWORD   dwColorCaps;
  long    lContrastMin;
  long    lContrastMax;
  long    lBrightnessMin;
  long    lBrightnessMax;
  long    lSaturationMin;
  long    lSaturationMax;
  long    lHueMin;
  long    lHueMax;
  long    reserved[20];     // some spare left for future
} ET_EDD_GETCOLORCAPSLIMITS, FAR* LPET_EDD_GETCOLORCAPSLIMITS;


// ET_EDD_SETCOLORADJUSTMENT
// set contrast, brightness saturation and hue
// values for each item is 0..9999
typedef struct tagET_EDD_SETCOLORADJUSTMENTDATA
{
  ET_QUERY hdr;				// size and subescape SUBESC_ET_EDD_SETCOLORADJUSTMENT
  long   dwContrast;
  long   dwBrightness;
  long   dwSaturation;
  long   dwHue;
} ET_EDD_SETCOLORADJUSTMENTDATA, FAR* LPET_EDD_SETCOLORADJUSTMENTDATA;


// ET_EDD_GETCOLORADJUSTMENT
// get contrast, brightness saturation and hue
// values for each item is 0..9999
typedef struct tagET_EDD_GETCOLORADJUSTMENTDATA
{
  DWORD   dwSize;
  long    dwContrast;
  long    dwBrightness;
  long    dwSaturation;
  long    dwHue;
  DWORD   dwYUVOverlayVisibleCount;
} ET_EDD_GETCOLORADJUSTMENTDATA, FAR* LPET_EDD_GETCOLORADJUSTMENTDATA;


// ET_EDD_SETFEATURES  set ELSA DirectDraw features
typedef struct tagET_EDD_SETFEATURESDATA
{
  ET_QUERY hdr;				// size and subescape SUBESC_ET_EDD_SETFEATURES
  DWORD   dwEddCaps0;
  DWORD   dwEddCaps1;
} ET_EDD_SETFEATURESDATA, FAR* LPET_EDD_SETFEATURESDATA;


// ET_EDD_GETFEATURES get ELSA DirectDraw features
typedef struct tagET_EDD_GETFEATURESDATA
{
  DWORD   dwSize;
  DWORD   dwEddCaps0;
  DWORD   dwEddCaps1;
} ET_EDD_GETFEATURESDATA, FAR* LPET_EDD_GETFEATURESDATA;


// ET_EDD_GETCAPS
//   retrieves capabilitie of ELSA DirectDraw features
//   capabilities depends on hardware, resolution and pixel depth
typedef struct tagET_EDD_GETCAPSDATA
{
  DWORD   dwSize;
  DWORD   dwEddCaps0;
  DWORD   dwEddCaps1;
} ET_EDD_GETCAPSDATA, FAR* LPET_EDD_GETCAPSDATA;

// ET_GAMMA_SET
//   _TEMPORARY_ set a gamma table.
//   This escape immediately sets the gamma table to the device. The table
//   is not stored permanently by the device. Means, after reboot, the
//   original 1:1 (or what ever else) table is reloaded by hardware.
//   To store the table, use the ELSA Subescape:
//      SUBESC_ET_SET_VALUE_BINARY::ET_VALUE_BIN_GDI_GAMMARAMP
//
//   Information about the success of the SET call is provided
//   via a ET_SET_VALUE_RET structure
//   If the hardware generally supports gamma ramps, but not in the current
//   mode (256 colors), the flags field in the output structure contains
//   ET_VALUE_BLOCKED.

typedef struct tagET_EDD_SETGAMMARAMP
{
  ET_QUERY hdr;       // size and subescape SUBESC_ET_EDD_SETGAMMARAMP
  WORD     red[256];
  WORD     green[256];
  WORD     blue[256];
} ET_EDD_SETGAMMARAMP, FAR* LPET_EDD_SETGAMMARAMP, * PET_EDD_SETGAMMARAMP;

typedef struct tagET_EDD_GETGAMMARAMP
{
  DWORD   dwSize;
  DWORD   dwResult;		// ET_VALUE_OK if succeeded and ET_VALUE_BLOCKED if Gamma not supported yet
  WORD    red[256];
  WORD    green[256];
  WORD    blue[256];
} ET_EDD_GETGAMMARAMP, FAR* LPET_EDD_GETGAMMARAMP, * PET_EDD_GETGAMMARAMP;

// ET_VIDEO_DMACOPYSM
//   copies video memory to system memory by DMA
typedef struct tagET_VIDEO_DMACOPYSMDATA
{
  ET_QUERY  hdr;

  DWORD     dwDstSel;       // Selector of destination memory (16Bit) / NULL (32Bit)
  DWORD     dwDstOfs;       // Offset of destination memory (16Bit) / Linear Address (32Bit)
  DWORD     dwDstStride;    //

  DWORD     dwSrcSel;       // Selector of source video memory (16Bit) / NULL (32Bit)
                            // The base of the selector points to the start of the video memory
  DWORD     dwSrcOfs;       // Offset of source video memory (16Bit) / Linear Address (32Bit)
                            // This is the offset relative to the beginning of video memory
  DWORD     dwSrcStride;    //

  DWORD     dwWidthBytes;   // Amount of bytes to transfer in one line (must be aligned to 4)
  DWORD     dwHeight;       // Anount of lines to transfer
} ET_VIDEO_DMACOPYSMDATA, FAR* LPET_VIDEO_DMACOPYSMDATA;

// ET_VIDEO_OUTCONTROL
//   controls video-out
typedef struct tagET_VIDEO_OUTCONTROL
{
  ET_QUERY  hdr;

  DWORD     dwEnable;
  DWORD     dwControl;
  DWORD     dwParam1;
  DWORD     dwParam2;
} ET_VIDEO_OUTCONTROL, FAR* LPET_VIDEO_OUTCONTROL, * PET_VIDEO_OUTCONTROL;

// ET_RMAPI_CONFIGSETGET
//   allows escape access to stateConfigGet [...] routines.
typedef struct tagET_RMAPI_CONFIGSETGET
{
  ET_QUERY  hdr;
  DWORD     dwSetGetCommand;
  DWORD     dwIndex;
  DWORD     dwlpParamStruct;
  DWORD     dwParamSize;
  DWORD     dwValue;
  DWORD     dwParam0;
  DWORD     dwParam1;
  DWORD     dwParam2;
} ET_RMAPI_CONFIGSETGET, FAR* LPET_RMAPI_CONFIGSETGET, * PET_RMAPI_CONFIGSETGET;

// Constants for ELSA DirectDraw features:
//
// dwEddCaps0:
#define EDDCAPS_DITHER              0x00000001
#define EDDCAPS_FILTERX             0x00000002
#define EDDCAPS_FILTERY             0x00000004
#define EDDCAPS_FILTERX_LIN02420    0x00000008
#define EDDCAPS_FILTERX_BILINEAR    0x00000010
#define EDDCAPS_FILTERX_LIN12221    0x00000020
#define EDDCAPS_OFFSCREENINHIBIT    0x00000040
#define EDDCAPS_OFFSCREENLINEAR     0x00000080
#define EDDCAPS_COLORADJUSTYUV_CB   0x00000100
#define EDDCAPS_COLORADJUSTYUV_HS   0x00000200
#define EDDCAPS_FILTERXY_BILINEAR   0x00000400
#define EDDCAPS_DITHER_ALWAYS_ON    0x00000800
#define EDDCAPS_ENABLE_332_TEXTURE  0x00001000

// 3D-Features
#define EDDCAPS_INHIBIT_ZBUFFER     0x00010000
#define EDDCAPS_INHIBIT_PERSCORRECT 0x00020000
#define EDDCAPS_INHIBIT_TEXTURE     0x00040000
#define EDDCAPS_INHIBIT_FOG         0x00080000
#define EDDCAPS_INHIBIT_FILTER      0x00100000
#define EDDCAPS_INHIBIT_ALPHA       0x00200000
// ViRGE/DX has a fast bilinear algorithm
#define EDDCAPS_FASTBILINEAR        0x00400000
// emuliere Colorkey for a Texture using texture alpha blending
#define EDDCAPS_EMULATE_TEX_CKEY    0x00800000
#define EDDCAPS_SIMULATE_MIPMAP     0x01000000

// Commands
#define EDDCMD_ALLOCFILTERYBUF      0x80000001

// Bedeutung der einzelnen Bits in dwEddCaps0 beim Aufruf von
// EDDESC_SETFEATURES:
//
// Achtung: Ein Bit darf nur gesetzt werden, wenn das entsprechende Bit
//          vorher bei einem Aufruf von EDD_GETCAPS als gueltig gemeldet
//          wurde.
//
// EDDCAPS_DITHER  : 1=Dithering ein. 0=Dithering aus.
//
// EDDCAPS_FILTERX : 1=Schalte einen Filter ein. Ggf. kann mit anderen
//                   Konstanten eine spezieller Filter definiert werden.
//                   Wird kein spezieller Filter ausgewaehlt (obwohl
//                   es moeglich waere) so sucht der Treiber einen adequaten
//                   Filter aus.
//                   0=Alle Filter aus.
//
// EDDCAPS_FILTERX_xxxxx : Schalte diesen speziellen Filter ein, wenn auch
//                         EDDCAPS_FILTERX gesetzt ist.
//
// EDDCAPS_OFFSCREENLINEAR: Weist den DirectDraw-Treiber an, linearen
//                          Offscreen falls moeglich (!) zu benutzen, um z.B.
//                          eine bessere Speicherausnutzung zu erreichen, oder
//                          die Erzeugung von Offscreen-Surfaces zu ermoeglichen,
//                          deren Breite (in Bytes) groesser ist als die Breite
//                          des Primary-Surface.
//                          Wenn dieses Bit beim Zuruecklesen gesetzt ist,
//                          ist der Offscreen tatsaechlich linear, ansonsten
//                          nicht.
//
//
// EDDCAPS_COLORADJUSTYUV_CB : 0=Kontrast/Helligkeit-Werte ohne Wirkung
//                             1=Kontrast/Helligkeit wird gemaess der per
//                               EDDESC_SETCOLORADJUSTMENT gewaehlten Werte
//                               eingestellt.
//
// EDDCAPS_COLORADJUSTYUV_HS : 0=Phase/Saettigungs-Werte ohne Wirkung
//                             1=Phase/Saettigung wird gemaess der per
//                               EDDESC_SETCOLORADJUSTMENT gewaehlten Werte
//                               eingestellt.

// Bedeutung der einzelnen Bits in dwEddCaps0 beim Aufruf von EDDESC_GETCAPS:
// -------------------------------------------------------------------------
//
// EDDCAPS_DITHER  : Der Treiber beherrscht Dithering zur Verbesserung der
//                   Bildqualitaet.
//
// EDDCAPS_FILTERX : Der Treiber beherrscht eine allgemeine Methode zum
//                   Filtern in X-Richtung. Ueber andere Bits
//                   EDDCAPS_FILTERX_xxxxx KANN der Treiber angeben, welche
//                   speziellen Filterfaehigkeiten er kennt.
//
// EDDCAPS_FILTERY : Der Treiber beherrscht eine allgemeine Methode zum
//                   Filtern in Y-Richtung.
//
// EDDCAPS_FILTERX_LIN02420
// EDDCAPS_FILTERX_BILINEAR
// EDDCAPS_FILTERX_LIN12221 : Der Treiber beherrscht diesen Filter in X-
//                            Richtung. Wenn diese Bit gesetzt ist, wird
//                            auch EDDCAPS_FILTERX gesetzt.
//
// EDDCAPS_OFFSCREENINHIBIT : Der Treiber bietet die Moeglichkeit, die
//                            Erzeugung von Offscreen-Surfaces zu
//                            unterbinden.
//
// EDDCAPS_OFFSCREENLINEAR : Der Treiber bietet die Moeglichkeit, lineare
//                           Offscreenverwaltung zu erwuenschen.
//                           Diesen Wunsch kann der Treiber erfuellen, er
//                           muss es aber nicht.
//
// EDDCAPS_COLORADJUSTYUV_CB : Der Treiber bietet die Moeglichkeit Kontrast
//                             und Helligkeit eines YUV-Videos einzustellen.
//
// EDDCAPS_COLORADJUSTYUV_HS : Der Treiber bietet die Moeglichkeit "Hue" und
//                             Saettigung eines YUV-Videos einzustellen.





// ********************************************************
// ********************************************************
// New *_VALUE_* Interface to replace registry accesses for driver data by escapes
// -------------------------------------------------------------------------------

// In structure (Tool -> driver):
// Input Structure to set a registry string
// Output Structure ET_SET_VALUE_RET
typedef struct tagET_SET_VALUE_STRING
{
  ET_QUERY hdr;   // size and subescape SUBESC_ET_SET_VALUE_STRING
                  // dwSize parameter of ET_QUERY holds length of this structure
                  //    i.e. hdr.dwSize >= sizeof(ET_SET_VALUE_STRING)
                  //   ET_MAX_STRING is the minimal length of the string!

  DWORD dwID;     // ID of string to set (ET_VALUE_SZ_...)
  char  szValue[ET_MAX_STRING];

} ET_SET_VALUE_STRING, *PET_SET_VALUE_STRING;

// In structure (Tool -> driver):
// Input Structure to set a registry DWORD
// Output Structure ET_SET_VALUE_RET
typedef struct tagET_SET_VALUE_DWORD
{
  ET_QUERY hdr;     // size and subescape SUBESC_ET_SET_VALUE_DWORD

  DWORD    dwID;    // ID of dword to set (ET_VALUE_DW_...)
  DWORD    dwValue; // value to set

} ET_SET_VALUE_DWORD, *PET_SET_VALUE_DWORD;

// In structure (Tool -> driver):
// Input Structure to set binary data to registry
// Output Structure ET_SET_VALUE_RET
typedef struct tagET_SET_VALUE_BINARY
{
  ET_QUERY hdr;       // size and subescape SUBESC_ET_SET_VALUE_DWORD

  DWORD    dwID;      // ID of dword to set (ET_VALUE_DW_...)
  char     ajData[1]; // array of binary data
  // The true size of this array can be re-calculated from hdr.dwSize

} ET_SET_VALUE_BINARY, *PET_SET_VALUE_BINARY;
// Size of the structure without the data array
#define ET_SET_VALUE_BINARY_HDR_SIZE (sizeof(ET_SET_VALUE_BINARY)-sizeof(DWORD))

// use in struct ET_QUERY_VALUE.dwType
#define ET_VALUE_TYPE_DWORD           0x00  // subesc SUBESC_ET_QUERY_VALUE_DWORD
#define ET_VALUE_TYPE_STRING          0x01  // subesc SUBESC_ET_VALUE_TYPE_STRING
#define ET_VALUE_TYPE_BINARY          0x02  // subesc SUBESC_ET_VALUE_TYPE_BINARY

// Query defaults: Same as ET_VALUE_TYPE_xx but driver allways returns the values default.
// If an ESC-error is returned, the driver doesn't support the default query!
#define ET_VALUE_DEFAULT_FLAG         0x80
#define ET_VALUE_TYPE_DEFAULT_DWORD   (ET_VALUE_DEFAULT_FLAG|ET_VALUE_TYPE_DWORD)   // subesc SUBESC_ET_QUERY_VALUE_DWORD
#define ET_VALUE_TYPE_DEFAULT_STRING  (ET_VALUE_DEFAULT_FLAG|ET_VALUE_TYPE_STRING)  // subesc SUBESC_ET_VALUE_TYPE_STRING

// In structure (Tool -> driver):
// Input Structure to query a registry DWORD
// Output data is returned in ET_VALUE_STRING or ET_VALUE_DWORD
typedef struct tagET_QUERY_VALUE
{
  ET_QUERY hdr;    // size and subescapes SUBESC_ET_QUERY_VALUE_STRING or SUBESC_ET_QUERY_VALUE_DWORD
                   // if outsize for strings > sizeof(ET_VALUE_STRING) the buffer can take longer than the
                   // default strings! Only check if the out buffer is to small to fit the data. The bigger
                   // the better!

  DWORD dwID;      // ID of dword to query (ET_VALUE_DW_..., ET_VALUE_SZ_...)
  DWORD dwType;    // This identifies what kind of data is requested (type of output structure) (ET_VALUE_TYPE_DWORD,...)
                   // Allways assign this value and be sure to set all necessary bits too!
} ET_QUERY_VALUE, *PET_QUERY_VALUE;


// Out structure (Driver -> Tool):
// Output Structure used to return a string from the driver in subesc SUBESC_ET_QUERY_VALUE_STRING
// used by input structure ET_QUERY_VALUE and dwType ET_VALUE_TYPE_STRING
typedef struct tagET_VALUE_STRING
{
  DWORD dwSize;    // Length of this structure (should be the same as ET_QUERY_VALUE's outbuffer size)
  DWORD dwID;      // identifier of string to query (additional and as alignment) (ET_VALUE_SZ_...)
                   // should be the same as in the calling ET_QUERY_VALUE
  DWORD dwFlags;   // return value, ET_VALUE_OK=value set and all is OK, others as ET_SET_VALUE_REBOOT are
                   // error codes or additional information flags
  char  szValue[ET_MAX_STRING]; // zero terminated ASCII/ANSI string (no UNICODE!)

} ET_VALUE_STRING, *PET_VALUE_STRING;


// Out structure (Driver -> Tool):
// Structure used to return a DWORD from the driver in subesc SUBESC_ET_QUERY_VALUE_DWORD
// used by input structure ET_QUERY_VALUE and dwType ET_VALUE_TYPE_DWORD
typedef struct tagET_VALUE_DWORD
{
  DWORD dwSize;    // Length of this structure, sizeof(ET_VALUE_DWORD)
                   // (should be the same as ET_QUERY_VALUE's outbuffer size)

  DWORD dwID;      // identifier of queried dword to query (additional and as alignment) (ET_VALUE_DW_...)
                   // should be the same as in the calling ET_QUERY_VALUE
  DWORD dwFlags;   // return value, ET_VALUE_OK=value set and all is OK, others as ET_SET_VALUE_REBOOT are
                   // error codes or additional information flags
  DWORD dwValue;   // return value

} ET_VALUE_DWORD, *PET_VALUE_DWORD;

// Out structure (Driver -> Tool):
// Structure used to return binary data from the driver in subesc
// SUBESC_ET_QUERY_VALUE_BINARY used by input structure ET_QUERY_VALUE
// and dwType ET_VALUE_TYPE_BINARY
typedef struct tagET_VALUE_BINARY
{
  DWORD dwSize;    // Length of this structure, at least ET_QUERY_VALUE_BINARY_HDR_SIZE
                   // (should be the same as ET_QUERY_VALUE's outbuffer size)
  DWORD dwID;      // identifier of binary to query (additional and as alignment) (ET_VALUE_DW_...)
                   // should be the same as in the calling ET_QUERY_VALUE
  DWORD dwFlags;   // return value,
                   // ET_VALUE_OK=value set and all is OK,
                   // ET_VALUE_ERROR_SIZE=structure is too short for all the data,
                   //                     see dwSizeData for the required size
                   // others are error codes or additional information flags
  DWORD dwSizeData; // size of binary data, especially the required size, when
                    // dwFlags return ET_VALUE_ERROR_SIZE

  char  ajData[1]; // dwSizeData bytes of data

} ET_VALUE_BINARY, *PET_VALUE_BINARY;
// Size of the structure without the data array
#define ET_QUERY_VALUE_BINARY_HDR_SIZE (sizeof(ET_VALUE_BINARY)-sizeof(DWORD))


// Flags used in ET_SET_VALUE_RET or ET_VALUE_XXX as return values
//   bit 31 (higest bit) == 0: function was successfull and additional information for values != 0
//   bit 31 (higest bit) == 1: error
#define IsError(Value)      ((Value & 0x80000000)!=0)
#define IsOK(Value)         ((Value & 0x80000000)==0)


//  ET_VALUE_xx return codes used in dwFlags are 32 bit values layed out as follows:

//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1              Bit No
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-----------------------------------------------------------+
//  |0 r|                                       Bitfield            | success
//  +---+-----------------------------------------------------------+
//  |1 r|                                       ErrorCode           | error
//  +---+-----------------------------------------------------------+
//  r = reserved
//                            bitfield
#define ET_VALUE_OK         0x00000000 // Value function is successfull
#define ET_VALUE_REBOOT     0x00000001 // a reboot is necessary to acivate after value set
#define ET_VALUE_DEFAULT    0x00000002 // Value function had problems and returned defaults
#define ET_VALUE_BLOCKED    0x00000004 // Value is blocked by running application and not set in driver! (e.g. ask user to close application)

//                          Bit   Code
#define ET_VALUE_ERROR		  0x80000000 // application reserved value for ESCAPE failed (not used in driver!)
#define ET_VALUE_UNKNOWN    0x80000001 // Value to get/set is unknown or not supported (e.g. grey button)
#define ET_VALUE_ERROR_SIZE 0x80000002 // returnbuffer is smaller than the value to get

// Out structure (Driver -> Tool):
// structure passed back to caller
typedef struct tagET_SET_VALUE_RET
{
  DWORD dwSize;    // Length of this structure, sizeof(ET_SET_VALUE_RET)

  DWORD dwID;      // identifier of set value (additional and as alignment) (ET_VALUE_DW_...)

  DWORD dwFlags;   // return value, ET_VALUE_OK=value set and all is OK, others as ET_SET_VALUE_REBOOT are
                   // error codes or additional information flags

  DWORD dwAlign;   // unused
} ET_SET_VALUE_RET, *PET_SET_VALUE_RET;


// ********************************************************
// query/set values identifier:
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1              Bit No
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +-------+-------+-----------------------------------------------+
//  |o o o o|r r r r|                                          code |
//  +-------+-------+-----------------------------------------------+
//
//  o = bitfield defining OS dependencies
//    0       = no specific OS
//    0x1     = Win9x
//    0x2     = Win NT
//    0x4,0x8 = unused
//  r = bitfield reserved for driver internal stuff.
//    This field must be 0 in all IDs-codes called via ExtEscape!
//
//    Use this code to check Esc-IDs validity:
//
//    DrvEscape (...)
//    {
//      // check if the caller gives us a valid dwID,
//      // All reserved bits have to be 0!
//      ASSERT( 0==(pEtValue->dwID & ET_VALUE_OS_RESERVED) ); // check the tool which called!
//      ...
//    }
//
//  code = number of identifer, no bitfield.
//    valid range: 0x000000 - 0xffffff (3 Byte)
//    New ID code increments by one.
//
//  Resulting ranges:
//    0x00000000 - 0x00ffffff basic values, common to all operating systems
//    0x10000000 - 0x10ffffff to be defined by Win95
//    0x20000000 - 0x20ffffff to be defined by NT (NTeam)
//    0x40000000 - 0x40ffffff unused
//    0x80000000 - 0x80ffffff unused
// Naming: ET_VALUE_DW_xxxx, read: ELSA tools value dword
//         ET_VALUE_SZ_xxxx, read: ELSA tools value zero terminated string (single byte char)
//

#define ET_VALUE_OS_WIN9x                                   0x10000000 // Bit defining IDs known by Windows 9x driver
#define ET_VALUE_OS_WINNT                                   0x20000000 // Bit defining IDs known by Windows NT driver
#define ET_VALUE_OS_unused0                                 0x40000000 //
#define ET_VALUE_OS_unused1                                 0x80000000 //

#define ET_VALUE_OS_RESERVED                                0x0F000000 // Bits that are reserved for the driver internaly

// Windows 9x
//
#define ET_VALUE_DW_D3DOGL_MCLK                             ( ET_VALUE_OS_WIN9x | 0x00CA0001 )
#define ET_VALUE_DW_D3DOGL_NVCLK                            ( ET_VALUE_OS_WIN9x | 0x00CA0002 )
#define ET_VALUE_DW_D3DOGL_OVERCLOCK_ENABLE                 ( ET_VALUE_OS_WIN9x | 0x00CA0003 )
#define ET_VALUE_DW_D3DOGL_OVERCLOCK_CRASHSTATUS            ( ET_VALUE_OS_WIN9x | 0x00CA0004 )
#define ET_VALUE_DW_D3DOGL_DEFAULT_MCLK                     ( ET_VALUE_OS_WIN9x | 0x00CA0005 )
#define ET_VALUE_DW_D3DOGL_DEFAULT_NVCLK                    ( ET_VALUE_OS_WIN9x | 0x00CA0006 )

// Windows NT
//
// Basic/system 0x20000000-0x200000ff
//#define ET_VALUE_SZ_IMAGEPATH                               0x20000000
//#define ET_VALUE_SZ_INSTALLEDDISPLAYDRIVERS                 0x20000001

#define ET_VALUE_DW_GDI_DESKTOPONMAXIMIZE                   0x20000050 // DesktopOnMaximize
#define ET_VALUE_DW_GDI_ENABLEDEVICEBITMAPS                 0x20000051 // EnableDeviceBitmaps
#define ET_VALUE_DW_GDI_ENABLEPCIDISCONNECT                 0x20000052 // PCIDisconnect
#define ET_VALUE_DW_GDI_EXPORTONLYDOUBLEBUFFERMODES         0x20000053 // ExportOnlyDoubleBufferModes
#define ET_VALUE_DW_GDI_NTEAMPRIVATEKEY                     0x20000054
#define ET_VALUE_DW_GDI_P6ENABLEUSWC                        0x20000055 // DRV_PPRO_ENABLE_WCB
#define ET_VALUE_DW_GDI_REVERSESCREENORDER                  0x20000056 // ReverseScreenOrder
#define ET_VALUE_DW_GDI_USEGETACCESSRANGES                  0x20000057 // UseGetAccessRanges
#define ET_VALUE_DW_GDI_USELCDPANEL                         0x20000058 // UseLCDPanel
#define ET_VALUE_DW_GDI_VERTICALSCREENORDER                 0x20000059 // VerticalScreenOrder
#define ET_VALUE_DW_GDI_WAITFORFIFOS                        0x2000005a // EngineSynchronization
#define ET_VALUE_DW_GDI_DEVICEORIGINX                       0x2000005b
#define ET_VALUE_DW_GDI_DEVICEORIGINY                       0x2000005c
#define ET_VALUE_DW_GDI_DEVICESIZEX                         0x2000005d
#define ET_VALUE_DW_GDI_DEVICESIZEY                         0x2000005e
#define ET_VALUE_DW_GDI_VISUALORIGINX                       0x2000005f
#define ET_VALUE_DW_GDI_VISUALORIGINY                       0x20000060
#define ET_VALUE_DW_GDI_VISUALSIZEX                         0x20000061
#define ET_VALUE_DW_GDI_VISUALSIZEY                         0x20000062
#define ET_VALUE_DW_GDI_DELLXXL                             0x20000063 // DELLXXL
#define ET_VALUE_DW_GDI_PERMEDIACLOCKSPEED                  0x20000064 // PermediaClockSpeed
#define ET_VALUE_DW_GDI_GLINTCLOCKSPEED                     0x20000065 // GlintClockSpeed
#define ET_VALUE_DW_GDI_GLINTGAMMACLOCKSPEED                0x20000066 // GlintGammaClockSpeed
#define ET_VALUE_DW_GDI_GLINTDELTACLOCKSPEED                0x20000067 // GlintDeltaClockSpeed
#define ET_VALUE_DW_GDI_HWLINES                             0x20000068 // TNT: interface to enable nonconformant but faster lines
#define ET_VALUE_DW_GDI_FIFOEXTRA_P2                        0x20000069 // GDI.FifoExtra
#define ET_VALUE_DW_GDI_FIFOEXTRA                           0x2000006a // GDI.FifoExtra
#define ET_VALUE_DW_GDI_FIFOUSAGE                           0x2000006b // GDI.FifoUsage
#define ET_VALUE_DW_GDI_EXPORTMULTIBOARDMODES               0x2000006c // ExportMultiboardModes
#define ET_VALUE_DW_GDI_SURFACESONBANKBOUNDARIES            0x2000006d // boolean
#define ET_VALUE_DW_GDI_DMABUFFERSIZE                       0x2000006e // ulong ( > 8kB)
#define ET_VALUE_DW_GDI_DMAPADDING                          0x2000006f // ulong (ET_VALUE_DW_GDI_DMAPADDING < ET_VALUE_DW_GDI_DMABUFFERSIZE)
#define ET_VALUE_DW_GDI_BOARD_PATTERN                       0x20000070 // binary: defines boards used for the mode (00 01 02,...)
#define ET_VALUE_DW_GDI_AGP_DMA                             0x20000071 // bool: 1=use AGP for display driver DMA, 0=don't use AGP
#define ET_VALUE_DW_GDI_FRAMEBUFFER_DMA                     0x20000072 // bool: 1=use framebuffer DMA for display driver

#define ET_VALUE_DW_MAP_FRAMEBUFFER                         0x20000090 // Map.FrameBuffer
#define ET_VALUE_DW_MAP_GLINTMMIO                           0x20000091 // Map.GLintMmio
#define ET_VALUE_DW_MAP_DELTAMMIO                           0x20000092 // Map.DeltaMmio
#define ET_VALUE_DW_MAP_LOCALBUFFER                         0x20000093 // Map.LocalBuffer

#define ET_VALUE_DW_PPRO_ENABLEWCB                          0x20000095 // PPro.EnableWCB
#define ET_VALUE_DW_ALPHA_MIATA                             0x20000096 // Alpha.Miata
#define ET_VALUE_DW_PRINTANDCHECKRENDERSTATE                0x20000097 //

#define ET_VALUE_BIN_GDI_GAMMARAMP                          0x200000A0 // Gammatable in the same format as in GDI::SetGammaRamp
#define ET_VALUE_BIN_OEM_MODELIST                           0x200000A1 // mode list override string: "bpp#1 width#1 height#1 refresh1#1 refresh2#1... 0 bpp#2 width#2 height#2 refresh1#2 refresh2#2... 0";

// ICDInterface.* 0x20000100-0x200001ff
#define ET_VALUE_DW_ICDINTERFACE_DISABLE                    0x20000100 // ICDInterface.Disable
//#define ET_VALUE_DW_ICDINTERFACE_DOUBLEBUFFER               0x20000101
//#define ET_VALUE_DW_ICDINTERFACE_MAXDOUBLEBUFFER            0x20000102
#define ET_VALUE_DW_ICDINTERFACE_NUMBEROFDISPLAYBUFFERS     0x20000101 // ICDInterface.NumberOfDisplayBuffers
#define ET_VALUE_DW_ICDINTERFACE_MAXNUMBEROFDISPLAYBUFFERS  0x20000102 // ICDInterface.MaxNumberOfDisplayBuffers
#define ET_VALUE_DW_ICDINTERFACE_SUPPORTSINGLEBUFFEREDGDI   0x20000103 // ICDInterface.SupportSingleBufferedGDI
#define ET_VALUE_DW_ICDINTERFACE_SUPPORTDOUBLEBUFFEREDGDI   0x20000104 // ICDInterface.SupportDoubleBufferedGDI
#define ET_VALUE_DW_ICDINTERFACE_EXPORTALPHA                0x20000105 // ICDInterface.ExportAlpha
#define ET_VALUE_DW_ICDINTERFACE_SUPPORTOVERLAYPLANES       0x20000106 // ICDInterface.SupportOverlayPlanes
#define ET_VALUE_DW_ICDINTERFACE_VBLANKWAIT                 0x20000107 // ICDInterface.VBlankWait
#define ET_VALUE_DW_ICDINTERFACE_PAGEFLIPPING               0x20000108 // ICDInterface.PageFlipping
#define ET_VALUE_DW_ICDINTERFACE_LBWIDTH                    0x20000109 // ICDInterface.LBWidth
#define ET_VALUE_DW_ICDINTERFACE_SIZEOFBUFFER               0x2000010A // ICDInterface.SizeOfBuffer

#define ET_VALUE_DW_ICDINTERFACE_DUALTXLBMOVES              0x2000010B // ICDInterface.DualTXLBMoves
#define ET_VALUE_DW_ICDINTERFACE_EXTENDEDPAGEFLIP           0x2000010C // ICDInterface.ExtendedPageFlip
#define ET_VALUE_DW_ICDINTERFACE_FNSENDDATATST              0x2000010D // ICDInterface.FNSendDataTst
#define ET_VALUE_DW_ICDINTERFACE_FULLSCNTOPBORDER           0x2000010E // DoubleBuffer.FullScnTopBorder
#define ET_VALUE_DW_ICDINTERFACE_LBSIZE                     0x2000010F // ICDInterface.LBSize
#define ET_VALUE_DW_ICDINTERFACE_P2ENABLEBYPASSDMA          0x20000110 // ICDInterface.P2EnableBypassDma
#define ET_VALUE_DW_ICDINTERFACE_P2ENABLEBYPASSPATCH        0x20000111 // ICDInterface.P2EnableBypassPatch
#define ET_VALUE_DW_ICDINTERFACE_PAGEFLIPFORCESYNC          0x20000112 // ICDInterface.PageFlipForceSync
#define ET_VALUE_DW_ICDINTERFACE_TEXTURESIZE                0x20000113 // ICDInterface.MaxTextureSize
#define ET_VALUE_DW_ICDINTERFACE_USESOFTWAREWRITEMASK       0x20000114 // ICDInterface.UseSoftwareWriteMask
#define ET_VALUE_DW_ICDINTERFACE_USESINGLETX                0x20000115 // ICDInterface.UseSingleTX

#define ET_VALUE_DW_ICDINTERFACE_EXPORTCOLORINDEX           0x20000116
#define ET_VALUE_DW_ICDINTERFACE_OPENGLICDNAME              0x20000117
#define ET_VALUE_DW_ICDINTERFACE_OPENGLICDELSAOGLNAME       0x20000118
#define ET_VALUE_DW_ICDINTERFACE_PFDREDUCTION               0x20000119 // ICDInterface.PFDReduction
#define ET_VALUE_DW_ICDINTERFACE_STEREOFORCEBUFFERS         0x2000011A // ICDInterface.StereoForceBuffers
#define ET_VALUE_DW_ICDINTERFACE_STEREOLEFTEYETOP           0x2000011B // ICDInterface.StereoLeftEyeTop
#define ET_VALUE_DW_ICDINTERFACE_STEREOSUPPORT              0x2000011C // ICDInterface.StereoSupport
#define ET_VALUE_DW_ICDINTERFACE_TEXTURESMARTCACHE          0x2000011D // ICDInterface.TextureSmartCache
#define ET_VALUE_DW_ICDINTERFACE_TEXTURETRANSIENTONLY       0x2000011E // ICDInterface.TextureTransientOnly

#define ET_VALUE_DW_ICDINTERFACE_MAXTEXTURESIZE             0x2000011F // ICDInterface.MaxTextureSize
#define ET_VALUE_DW_ICDINTERFACE_PFD_TYPE_COLORINDEX        0x20000120 // ICDInterface.PFD_TYPE_COLORINDEX
#define ET_VALUE_DW_ICDINTERFACE_LBPATCHED                  0x20000121 // ICDInterface.LBPatched
#define ET_VALUE_DW_ICDINTERFACE_DUALGLINTWINDOWMOVES       0x20000122 // ICDInterface.DualGlintWindowMoves
#define ET_VALUE_DW_ICDINTERFACE_FORCEGDIBROADCASTINGINOGLVIEWS 0x20000123 // ICDInterface.ForceGdiBroadCastingInOglViews
#define ET_VALUE_DW_ICDINTERFACE_PFD_STEREO                 0x20000124 // ICDInterface.PFD_STEREO
#define ET_VALUE_DW_ICDINTERFACE_PFD_SWAP_LAYER_BUFFERS     0x20000125 // ICDInterface.PFD_SWAP_LAYER_BUFFERS
#define ET_VALUE_DW_ICDINTERFACE_PFD_SUPPORT_GDI            0x20000126 // ICDInterface.PFD_SUPPORT_GDI

#define ET_VALUE_DW_ICDINTERFACE_FORCE_STENCIL              0x20000127 // ICDInterface.ForceStencil
#define ET_VALUE_DW_ICDINTERFACE_FORCE_MORETHAN16BITZ       0x20000128 // 0=default, else force to this value!
#define ET_VALUE_DW_ICDINTERFACE_TEXTURE_REDUCE_FACTOR      0x20000129 // ICDInterface.TextureReduceFactor
#define ET_VALUE_DW_ICDINTERFACE_PFD_SWAP_COPY              0x2000012A // ICDInterface.PFD_SWAP_COPY
#define ET_VALUE_DW_ICDINTERFACE_PFD_SWAP_EXCHANGE          0x2000012B // ICDInterface.PFD_SWAP_EXCHANGE

// GLintDMA.* 0x20000200-0x2000024f
#define ET_VALUE_DW_GLINTDMA_NUMBEROFBUFFERS                0x20000200 // GLintDMA.NumberOfBuffers
#define ET_VALUE_DW_GLINTDMA_NUMBEROFSUBBUFFERS             0x20000201 // GLintDMA.NumberOfSubBuffers
#define ET_VALUE_DW_GLINTDMA_SIZEOFBUFFERS                  0x20000202 // GLintDMA.SizeOfBuffer
#define ET_VALUE_DW_GLINTDMA_CACHEDBUFFERS                  0x20000203 // GLintDMA.CachedBuffers

#define ET_VALUE_DW_GLINTDMA_USEAGP                         0x20000204 // GLintDMA.UseAGP
#define ET_VALUE_DW_GLINTDMA_SUPPORTAGPONBX                 0x20000205 // GLintDMA.SupportAGPonBX

#define ET_VALUE_DW_AGP_ENABLE                              ET_VALUE_DW_GLINTDMA_USEAGP // AGP.Enable:  0, 1
#define ET_VALUE_DW_AGP_RATE                                0x20000206                  // AGP.Rate:    1, 2, 4
#define ET_VALUE_DW_AGP_SIDEBANDADDRESSING                  0x20000207                  // AGP.SBA:     0, 1
#define ET_VALUE_DW_AGP_REQUEST_DEPTH                       0x20000208                  // AGP.RQDepth: 1...255
#define ET_VALUE_DW_AGP_FAST_WRITES                         0x20000209                  // AGP.FW:      0, 1

#define ET_VALUE_DW_DMAWAITFORPOLL                          0x2000020A // DMAWaitForPoll

#define ET_VALUE_DW_AGP_CACHING                             0x2000020B // 0=No, 1=Yes (as used in AgpReservePhysical)
#define ET_VALUE_DW_AGP_MSWORKAROUND                        0x2000020C // 0=No, 1=Yes (to enable workaround for bug in MS W2K videoport.sys AGP mapping)

#define ET_VALUE_DW_DMA_7DUMMYREADS                         0x2000020D // 0=No, 1=Yes (7 dummy reads in dma buffer to flush writecombined caches)
#define ET_VALUE_DW_DMA_DUMMYREADUC                         0x2000020E // 0=No, 1=Yes (Perform a dummy read to the UC system memory but not WC to flush writecombined caches)

#define ET_VALUE_DW_DMA_FORCEIOFLUSH                        0x2000020F // 0=No, 1=Yes (Perform inp and outp to flush io buffers)

// GLintIRQ.* 0x20000250-0x200002ff
#define ET_VALUE_DW_GLINTIRQ_ENABLE                         0x20000250 // GLintIRQ.Enable

// OpenGL.* 0x20000300-0x200003ff
#define ET_VALUE_DW_OPENGL_USEHIQUALITYTEXTURE              0x20000300
#define ET_VALUE_DW_OPENGL_UNIXCONFORM                      0x20000301
#define ET_VALUE_DW_OPENGL_DOUBLEWRITE                      0x20000302
#define ET_VALUE_DW_OPENGL_DISABLEFASTCLEAR                 0x20000303 // OpenGL.DisableFastClear
#define ET_VALUE_DW_OPENGL_DISABLEMIPMAPS                   0x20000304
#define ET_VALUE_DW_OPENGL_TEXTURECOMPRESSION               0x20000305
#define ET_VALUE_DW_OPENGL_ENABLEP2ANTIALIAS                0x20000306
#define ET_VALUE_DW_OPENGL_SUPPORTOPENGLVERSION11           0x20000307
#define ET_VALUE_DW_OPENGL_FORCETRUECOLOR16BIT              0x20000308 // OpenGL.ForceTrueColorTexturesTo16bit
#define ET_VALUE_DW_OPENGL_SUPPORTSOFTIMAGE                 0x20000309 // OpenGL.SupportSoftimage
#define ET_VALUE_DW_OPENGL_SUPPORTSOFTIMAGE_351             0x2000030A // OpenGL.SupportSoftimage351

#define ET_VALUE_DW_OPENGL_DRAWLINEENDS                     0x2000030B
#define ET_VALUE_DW_OPENGL_ENABLEFIFOACCESS                 0x2000030C
#define ET_VALUE_DW_OPENGL_DISABLEDELTA                     0x2000030D
#define ET_VALUE_DW_OPENGL_MXDISABLEMIPMAPS                 0x2000030E
#define ET_VALUE_DW_OPENGL_FORCENNTEXFILTER                 0x2000030F
#define ET_VALUE_DW_OPENGL_DISABLEDMAFLUSHES                0x20000310
#define ET_VALUE_DW_OPENGL_DISABLEGXCULL                    0x20000311
#define ET_VALUE_DW_OPENGL_INVERTGXCFORMAT                  0x20000312
#define ET_VALUE_DW_OPENGL_PERSPECTIVECORRECTION            0x20000313
#define ET_VALUE_DW_OPENGL_REALLOCBLOCKSIZE                 0x20000314
#define ET_VALUE_DW_OPENGL_DISABLEDLISTTEXTURES             0x20000315
#define ET_VALUE_DW_OPENGL_DELTANODRAW                      0x20000316
#define ET_VALUE_DW_OPENGL_ENABLEBYPASSPATCH                0x20000317
#define ET_VALUE_DW_OPENGL_ENABLEBYPASSDMA                  0x20000318
#define ET_VALUE_DW_OPENGL_FORCENESTEDDMA                   0x20000319
#define ET_VALUE_DW_OPENGL_DISABLETRIANGLEPACKET            0x2000031A
#define ET_VALUE_DW_OPENGL_PRESERVETRUECOLORTEXTURES        0x2000031B // OpenGL.PreserveTrueColorTextures
#define ET_VALUE_DW_OPENGL_DUALTXPRO                        0x2000031C
#define ET_VALUE_DW_OPENGL_VERTEXCOOPTMAX                   0x2000031D
#define ET_VALUE_DW_OPENGL_NVVVOPTIMIZATION                 0x2000031E
#define ET_VALUE_DW_OPENGL_MIPMAPCONTROL                    0x2000031F
#define ET_VALUE_DW_OPENGL_DISABLETEXTUREPATCHING           0x20000320 // OpenGL.DisableTexturePatching

#define ET_VALUE_DW_OPENGL_USEGIDCLIPPING                   0x20000321 // OpenGL.UseGidClipping
#define ET_VALUE_DW_OPENGL_PLACEMIPMAPSINALTERNATEBANKS     0x20000322 // OpenGL.PlaceMipMapsInAlternateBanks
#define ET_VALUE_DW_OPENGL_DISABLETEXTUREMANAGERLRU         0x20000323 // OpenGL.DisableTextureManagerLRU
#define ET_VALUE_DW_OPENGL_SUPPORTPRODESIGNER               0x20000324 // OpenGL.SupportProDesigner

#define ET_VALUE_DW_OPENGL_DMAMAXCOUNT                      0x20000325 // TNT: OpenGL.DMAMaxCount (size of DMA buffer)
#define ET_VALUE_DW_OPENGL_DMAMINPUSHCOUNT                  0x20000326 // TNT: OpenGL.DMAMinPushCount (fill grade of buffer to force flush)
#define ET_VALUE_DW_OPENGL_MAXTEXTURESIZE                   0x20000327
#define ET_VALUE_DW_OPENGL_MINVIDMEMTEXWIDTH                0x20000328
#define ET_VALUE_DW_OPENGL_MAXTEXHEAPSIZE                   0x20000329
#define ET_VALUE_DW_OPENGL_LIGHTINGANALYSIS                 0x2000032A  // BITFIELD
#define ET_VALUE_DW_OPENGL_LIGHTPICKINGOVERRIDE             0x2000032B  // BITFIELD
#define ET_VALUE_DW_OPENGL_STATISTICS                       0x2000032C  // BITFIELD
#define ET_VALUE_DW_OPENGL_BENCHING                         0x2000032D  // OpenGL.Benching
#define ET_VALUE_DW_OPENGL_USEKATMAI                        0x2000032E // BOOLEAN
#define ET_VALUE_DW_OPENGL_VERTEXCACHESIZE                  0x2000032F // DWORD
#define ET_VALUE_DW_OPENGL_PIXELTUBE                        0x20000330 // DWORD

// OpenGL AGP settings
#define ET_VALUE_DW_OPENGL_AGP_DMA                          0x20000331  // OpenGL.AGP.DMA
#define ET_VALUE_DW_OPENGL_AGP_TEXTURES                     0x20000332  // OpenGL.AGP.Textures
#define ET_VALUE_DW_OPENGL_FORCE_AGP_TEXTURES               0x20000333  // OpenGL.ForceAGPTextures

#define ET_VALUE_DW_OPENGL_FORCE_CLIPPING                   0x20000334  // OpenGL.ForceClipping
#define ET_VALUE_DW_OPENGL_ERRORLOG                         0x20000335  // OpenGL.ErrorLog
#define ET_VALUE_DW_OPENGL_DUMPLOG                          0x20000336  // OpenGL.DumpLog
#define ET_VALUE_DW_OPENGL_MCAD_MODE                        0x20000337  // OpenGL.MCAD
#define ET_VALUE_DW_OPENGL_SUPPORT_P2_CI4TEXTURES           0x20000338  // OpenGL.SupportP2CI4Textures
#define ET_VALUE_DW_OPENGL_FORCE_SINGLEBUFFERED             0x20000339  // BOOLEAN
#define ET_VALUE_DW_OPENGL_ALIGNED_SURFACES                 0x2000033A  // ULONG
#define ET_VALUE_DW_OPENGL_FRAMEBUFFER_DMA                  0x2000033B  // OpenGL.FramebufferDMA
#define ET_VALUE_DW_OPENGL_AUTODESKEXTENSIONS               0x2000033C  // Bitfield enabling Autocad 2000 opengl extensions
#define ET_VALUE_DW_OPENGL_USESENDDATAESCAPE                0x2000033D  // ULONG (0:ICD accesses HW, 1:automatic (ICD or Escape), 2: ICD uses Escape to fire DMA), FNicklis 07.05.1999
#define ET_VALUE_DW_OPENGL_DISABLE_STENCIL                  0x2000033E  // BOOLEAN (0: default, export stencil, 1: remove stencil formats), FNicklis 11.06.199
#define ET_VALUE_DW_OPENGL_DISABLE_ALPHA                    0x2000033F  // BOOLEAN (0: default, export alpha,   1: remove alpha formats), FNicklis 11.06.199
#define ET_VALUE_DW_OPENGL_PREFER_AGP_TEXTURES              0x20000340  // BOOL ('OpenGL.PreferAGPTextures, 0=default)
#define ET_VALUE_DW_OPENGL_DMAMINPUSHCOUNT_SENDDATA         0x20000341  // TNT: OpenGL.DMAMinPushCountSendData (fill grade of buffer to force flush)
#define ET_VALUE_DW_OPENGL_MULTIBOARD                       0x20000342  // BOOLEAN (1:default, allow OpenGL; 0:OpenGl not in mulitboard) OpenGL.MultiBoard
#define ET_VALUE_DW_OPENGL_UNIGRAPHICS_TEXTURE_FIX          0x20000343  // Enable bug fix for Unigraphics 15, 16 (border color for texture)
#define ET_VALUE_DW_ICDINTERFACE_STEREOWAITCONCEPT          0x20000344  // ULONG  (0:default do not wait 1:allways use DPCs 2:do wait until VBlank occured
#define ET_VALUE_DW_ICDINTERFACE_STEREOWAITLINESBEFORE      0x20000345  // ULONG  ( default: 2 ) amount of rasterlines before VBlank until to loop and wait for VBlank 
#define ET_VALUE_DW_ICDINTERFACE_STEREOWAITLINESAFTER       0x20000346  // ULONG  ( default: 1 ) amount of rasterlines after VBlank when to trigger stereo glasses + offsets 

                                                          //0x20000347  ...

// Heidi/Kinetix.* 0x20000400-0x200004ff
#define ET_VALUE_DW_HEIDI_USEEXCLUSIVE                      0x20000400
#define ET_VALUE_DW_HEIDI_USELINEARTEXTUREFILTER            0x20000401
#define ET_VALUE_DW_KTX_BUFFERREGIONS                       0x20000402 // e.g. KTX.BufferRegions
#define ET_VALUE_DW_KTX_SWAPHINTS                           0x20000403 // e.g. KTX.SwapHints
#define ET_VALUE_DW_KTX_ELSABUFFERREGIONS                   0x20000404 // e.g. KTX.ElsaBufferRegions
#define ET_VALUE_DW_KTX_BUFFER_REGIONS_FULL                 0x20000405 // e.g. KTX.BufferRegionsFull
#define ET_VALUE_DW_KTX_BUFFER_REGIONS_FIX                  0x20000406 // e.g. KTX.BufferRegionsFix

// HardwareInformation.* 0x20000500-0x200005ff
#define ET_VALUE_SZ_HARDWAREINFORMATION_ADAPTERSTRING       0x20000500
#define ET_VALUE_SZ_HARDWAREINFORMATION_CHIPTYPE            0x20000501
#define ET_VALUE_SZ_HARDWAREINFORMATION_DACTYPE             0x20000502
#define ET_VALUE_DW_HARDWAREINFORMATION_MEMORYSIZE          0x20000503
#define ET_VALUE_SZ_BOARDNAME                               0x20000504
#define ET_VALUE_SZ_DESCRIPTION                             0x20000505
#define ET_VALUE_SZ_SERNUM                                  0x20000506
#define ET_VALUE_SZ_HARDWAREINFORMATION_BIOSSTRING          0x20000507

// DDraw ids    0x20000600-0x200006ff
#define ET_VALUE_DW_DDRAWMULTIBOARDPRIMARY                  0x20000600 // DirectDraw.MultiboardPrimary
#define ET_VALUE_DW_DDRAWENABLEVIDEOIO                      0x20000601 // EnableVideoIO
#define ET_VALUE_DW_DDRAWMULTIBOARDHW_ENABLE                0x20000602 // DirectDraw.MultiboardEnabled
#define ET_VALUE_DW_DDRAWSUPPORT_OVERLAYSHRINK              0x20000603 // DirectDraw.SupportOverlayshrink

// LCD Panel    0x20000700-0x200007ff
#define ET_VALUE_DW_LCDPANELBORDERLEFTRIGHT                 0x20000700 // DUO.PanningBorderLeftRight
#define ET_VALUE_DW_LCDPANELBORDERTOPBOTTOM                 0x20000701 // DUO.PanningBorderTopBottom
#define ET_VALUE_DW_LCDPANELSTEPLEFTRIGHT                   0x20000702 // DUO.PanningStepLeftRight
#define ET_VALUE_DW_LCDPANELSTEPTOPBOTTOM                   0x20000703 // DUO.PanningStepTopBottom
#define ET_VALUE_DW_LCDPANELPANSTARTXRES                    0x20000704 // DUO.PanningStartXResolution
#define ET_VALUE_DW_LCDPANELSTRETCHXRES                     0x20000705 // DUO.LcdExpand
#define ET_VALUE_DW_LCDPANELSINGLEMODE                      0x20000706 // DUO.SingleControllerMode
#define ET_VALUE_DW_LCDPANELENABLECRT                       0x20000707 // DUO.CrtEnable
#define ET_VALUE_DW_LCDPANELENABLELCD                       0x20000708 // DUO.LcdEnable
#define ET_VALUE_DW_LCDPANELENABLETV                        0x20000709 // DUO.TvEnable
#define ET_VALUE_DW_LCDPANELTRUECOLORDITHER                 0x2000070A // DUO.LcdTruecolorDither
#define ET_VALUE_DW_LCDPANELTVFLICKERFILTER                 0x2000070B // DUO.TvFlickerFilter

// ********************************************************
// ********************************************************
// NV10 / NV 15 boards
// -----------------------------
// #define SUBESC_ET_GET_OUTPUT_DEVICE_INFO    0x00000310
// #define SUBESC_ET_SET_OUTPUT_DEVICE         0x00000311

#define PANEL_RESOLUTION_STRETCHED	0x0001
#define PANEL_RESOLUTION_CENTERED	0x0002
#define PANEL_RESOLUTION_NATIVE	0x0004

#define DEVICE_TYPE_INVALID   0x0000
#define DEVICE_TYPE_CRT       0x0001
#define DEVICE_TYPE_LCD       0x0002
#define DEVICE_TYPE_TV        0x0004

typedef struct tagET_COMMON_OUTPUT_DEVICE_INFO
{
  DWORD   dwDeviceType;         // holds the type of the device (CRT/LCD/TV)
  DWORD   dwDeviceConnected;    // is this device connected to graphics board
  DWORD   dwDeviceOn;           // is the device switched on
  DWORD   dwHorSize;            // horizontal size of the device in pixel
  DWORD   dwVertSize;           // vertical size of the device in pixel
  DWORD   dwDisplayMode;        // display mode of device ( stretched, native, centered )
  DWORD   dwSupportedDisplayModes;   // supported display modes of device ( stretched, native, centered )
}ET_COMMON_OUTPUT_DEVICE_INFO, *PET_COMMON_OUTPUT_DEVICE_INFO;

typedef struct tagET_OUTPUT_DEVICE_INFO
{
  DWORD   dwSize;                   // size of structure
  DWORD   dwDevicesSupported;       // bitfield containing type of supported devices
  DWORD   dwSimultaniousDevices;      // bitfield containing type of devices supported at the same time
  ET_COMMON_OUTPUT_DEVICE_INFO  crt;  // information on the CRT
  ET_COMMON_OUTPUT_DEVICE_INFO  lcd;  // information on the LCD
  ET_COMMON_OUTPUT_DEVICE_INFO  tv;   // information on the tv set
  DWORD   dwNumAdditionalDevices;   // number of additional ET_COMMON_OUTPUT_DEVICE_INFO structures needed
  ET_COMMON_OUTPUT_DEVICE_INFO  *pAdditionalInformation;
} ET_OUTPUT_DEVICE_INFO, *PET_OUTPUT_DEVICE_INFO;

// Structure to set output device
typedef struct tagET_SET_OUTPUT_DEVICE
{
  ET_QUERY                    hdr;

  DWORD                       dwParam1;             //1 saves to registry, 0 for testing
  ET_OUTPUT_DEVICE_INFO       deviceInfo;
} ET_SET_OUTPUT_DEVICE, *PET_SET_OUTPUT_DEVICE;

//Structure to retrieve complete information on the output devices
typedef struct tagET_GET_OUTPUT_DEVICE_INFO
{
  DWORD                       dwSize;
  ET_OUTPUT_DEVICE_INFO       deviceInfo;
} ET_GET_OUTPUT_DEVICE_INFO,*PET_GET_OUTPUT_DEVICE_INFO;


// ********************************************************
// ********************************************************
// LCD panel with WINNER 1000DUO
// -----------------------------

// Common information on actual PANEL settings (used in Get and Set info)
typedef struct tagET_COMMON_PANEL_INFO
{
  LONG        lPanStepLR;           //Panning stepsize right/left panning
  LONG        lPanStepTB;           //Panning stepsize up/down panning
  LONG        lPanBorderLR;         //Area where panning begins before cursor hits panel end left/right
  LONG        lPanBorderTB;         //Area where panning begins before cursor hits panel end top/bottom
  LONG        lPanStartResX;        //We start panning if our Resolution exceeds this value
  LONG        lStretchEndXRes;      //Bitfield to describe the resolutions at which we want to stretch/expand
  DWORD       dwEnablePanel;        //We enable the LCD
  DWORD       dwEnableCrt;          //We enable the CRT
  DWORD       dwEnableTV;           //We enable the TV
  DWORD       dwPanelSingleMode;    //One Controller for both displays
  LONG        lTVFlickerFilter;     //1(disabled),2 or 3 line Flickerfilter
  DWORD       dwLCDTrueColorDither; //True Color dithering or reducing to 18bit
} ET_COMMON_PANEL_INFO, *PET_COMMON_PANEL_INFO;


// In structure (Tool -> driver):
// Structure to set the new Panel settings
typedef struct tagET_SET_PANEL_INFO
{
  ET_QUERY              hdr;

  DWORD                 dwParam1;             //1 saves to registry, 0 for testing
  ET_COMMON_PANEL_INFO  CommonPanelInfo;
} ET_SET_PANEL_INFO, *PET_SET_PANEL_INFO;


// Out structure (Driver -> Tool):
//Structure to retrieve complete information on the actual Panel
typedef struct tagET_GET_PANEL_INFO
{
  DWORD                 dwSize;

  DWORD                 dwPanelSupport;       //Does the Board support a LCD Panel
  LONG                  lXResPanel;           //X-Res of our Panel
  LONG                  lYResPanel;           //Y-Res of our Panel

  ET_COMMON_PANEL_INFO  CommonPanelInfo;

} ET_GET_PANEL_INFO, *PET_GET_PANEL_INFO;

// ********************************************************
// ********************************************************
//NEW: SK 13011999
//Interface for Maxtreme to enable/disable stereo for a given window

//In structure (Tool -> driver )
//Structure to set the Stereomode of a oglwindow. (for Maxtreme)
typedef struct tagET_SET_WINDOW_STEREOMODE
{
  ET_QUERY  hdr;

  PVOID     hwnd;   //Windowhandle // ELSA-FNicklis 27.04.00: not all of our code knows a HWND
  DWORD     dwMode; //STEREOMODE_ENABLE or STEREOMODE_DISABLE
} ET_SET_WINDOW_STEREOMODE, *PET_SET_WINDOW_STEREOMODE;

#define STEREOMODE_DISABLE  0x00000000
#define STEREOMODE_ENABLE   0x00000001

// ********************************************************


//
// NT direct hw access support - development only
//

// SUBESC_ET_GETREGISTER
typedef struct tagET_GETREG
{
  DWORD dwSize;
  DWORD dwRegister;
  DWORD dwValue;
  DWORD dwFlags;
}ET_GETREG, *PET_GETREG, FAR *LPET_GETREG;

// SUBESC_ET_SETREGISTER
typedef struct tagET_SETREG
{
  ET_QUERY hdr;     // size and subescape SUBESC_ET_SETREGISTER
  DWORD dwRegister;
  DWORD dwValue;
  DWORD dwFlags;
}ET_SETREG, *PET_SETREG, FAR *LPET_SETREG;

// SUBESC_ET_MODIFYREGISTER
typedef struct tagET_MODIFYREG
{
  ET_QUERY hdr;     // size and subescape SUBESC_ET_MODIFYREGISTER
  DWORD dwRegister;
  DWORD dwValue;
  DWORD dwFlags;
  DWORD dwMask; // (all bits to modify set to 1)
}ET_MODIFYREG, *PET_MODIFYREG, FAR *LPET_MODIFYREG;

//
// dwFlags values
//
#define MMIO_ACCESS             0x00 << 16  // default: mmio, sync + vblankwait
#define PIO_ACCESS              0x01 << 16
#define NO_SYNC                 0x02 << 16
#define NO_VBLANKWAIT           0x04 << 16
#define NO_FIFOWAIT             0x08 << 16

#define ACCESS_DWORD 0x01 << 0
#define ACCESS_WORD  0x02 << 0
#define ACCESS_BYTE  0x04 << 0



// SUBESC_ET_NOTIFYDRIVER
typedef struct tagET_NOTIFYDRIVER
{
  ET_QUERY hdr;     // size and subescape SUBESC_ET_NOTIFYDRIVER
  DWORD dwNotification;
}ET_NOTIFYDRIVER, *PET_NOTIFYDRIVER, FAR *LPET_NOTIFYDRIVER;

// notifications: video capture driver to display driver
#define EDDESC_VIO2DRVNOTIFY_TVOUTON   0x01
#define EDDESC_VIO2DRVNOTIFY_TVOUTOFF  0x02



// SUBESC_ET_SCROLL
// scrolling into offscreen (debug purposes)
typedef struct tagET_SCROLL_DATA
{
  ET_QUERY hdr;     // size and subescape SUBESC_ET_SCROLL
  LONG  cyLines;            // # of lines vertical panning
}ET_SCROLL_DATA, FAR *LPET_SCROLL_DATA;



// SUBESC_ET_GFXOPTIONQUERY
// GfxOptionQuery support
typedef struct tagET_GFXOPTIONQUERY
{
  ET_QUERY hdr;     // size and subescape SUBESC_ET_GFXOPTIONQUERY
  DWORD dwGfxOption;        // in/out parameter
}ET_GFXOPTIONQUERY_DATA, FAR *LPET_GFXOPTIONQUERY_DATA;

// SUBESC_ET_SAA
// video in/out related stuff, used by Windows NT video capture driver for hw access
typedef struct tagET_SAA_DATA
{
  ET_QUERY hdr;     // size and subescape SUBESC_ET_SAA
  DWORD dwSAACommand;       // = defines below
  DWORD dwData;
  DWORD dwRegister;
  DWORD dwReturn;
}ET_SAA_DATA, FAR *LPET_SAA_DATA;

#define I2COPEN                   1000
#define I2CCLOSE                  1001

#define CHECKSAA7111              1
#define WRITESAA7111              2
#define READSAA7111               3

#define CHECKSAA7125              101
#define WRITESAA7125              102
#define READSAA7125               103

// ********************************************************
// code for SUBESC_ET_QUERY_ICDCLIENTINFO:
// 12.02.1999 FNicklis

// input structure app -> driver
typedef struct tagET_QUERY_ICDCLIENTINFO_IN
{
  ET_QUERY hdr;  // size and subescape ET_QUERY_ICDCLIENTINFO
} ET_QUERY_ICDCLIENTINFO_IN;

typedef struct tagET_ICDCLIENTINFO
{
  DWORD  dwClientID;     // 1 per window
  DWORD  dwContextCount; // n per window > 0; 0==invalid
  DWORD  dwProcessID;    // 0==invalid/unused/unkown
  HANDLE hWnd;           // window handle
  LONG   lPixelFormat;   // used pixelformat number
} ET_ICDCLIENTINFO;

// output structure driver -> app
typedef struct tagET_QUERY_ICDCLIENTINFO_OUT
{
  DWORD  dwSize;          // Length of this out buffer
  DWORD  dwTotalClients;  // Total count of running OpenGL clients
  DWORD  dwReturnClients; // Count of information units returned to app

  ET_ICDCLIENTINFO aClientInfo[1]; // array of 1, ...
} ET_QUERY_ICDCLIENTINFO_OUT;


// ********************************************************
// code for SUBESC_ET_QUERY_TEMPERATURE:
// 28.09.1999 Thorsten Schumann

// bits used as caps and as status
#define ET_TEMPERATURE_FANSLOW     0x00000001   // fan slow or stop
#define ET_TEMPERATURE_FANSHORTVCC 0x00000002   // fan short VCC (only on boot phase available)
#define ET_TEMPERATURE_OVERTEMP    0x00000004   // over temperature
#define ET_TEMPERATURE_VALUE       0x00000008   // for future release, not yet used
                                                //    entry dwTemperatureValue is used

// output structure driver -> app
typedef struct tagET_QUERY_TEMPERATURE
{
  DWORD  dwSize;              // Length of this out buffer
  DWORD  dwTemperatureCaps;    // caps of valid record entries / hardware caps
  DWORD  dwTemperatureStatus; // status of flags
  DWORD  dwTemperatureValue;  // for future release, not yet used
  DWORD  dwReserved1;
  DWORD  dwReserved2;
} ET_QUERY_TEMPERATURE, FAR *LPET_QUERY_TEMPERATURE;


// ********************************************************
// begin of code for SUBESC_ET_DPMS:
//
// Set or query DPMS power save mode. Send ET_DPMS_IN structure
// with wanted DPMS mode to driver and always receive selected
// mode. If Escape fails, the DPMS mode was not set!
//
// FNicklis 29.09.1999: added SUBESC_ET_DPMS and sample code
//
// Sample code to set powersave mode:
//   taken from PowerSaver.scr Screen saver
//
  /*
//
// bSetDPMSMode
//
// enables ELSAESC-ET_DPMS power save mode via Escape call to driver.
//
// return: TRUE  - mode set successfully
//         FALSE - failed to set powersave mode
//
// FNicklis 29.09.1999: New
//
static BOOL bSetDPMSMode(
  IN ET_DPMS_MODE lMode)      // Power save mode to set
{
  BOOL        bRet=FALSE;     // pessimistic
  LONG        lResult;        // return value of extescape
  ET_DPMS_IN  etPowersaveIn;  // App -> Driver
  ET_DPMS_OUT etPowersaveOut; // Driver -> App
  HDC         hDC;            // Desktops HDC (to reach the display driver)

  ZeroMemory(&etPowersaveIn, sizeof(etPowersaveIn));

  etPowersaveIn.hdr.dwSize    = sizeof(etPowersaveIn);
  etPowersaveIn.hdr.dwSubEsc  = SUBESC_ET_DPMS;
  etPowersaveIn.hdr.dwOutSize = sizeof(etPowersaveOut);
  etPowersaveIn.hdr.dwBoard   = 0;
  etPowersaveIn.lMode         = lMode;

  hDC = GetDC(0);

  lResult = ExtEscape(hDC,
    ESC_ELSA_TOOLS,
    sizeof(etPowersaveIn),
    (PVOID)&etPowersaveIn,
    sizeof(etPowersaveOut),
    (PVOID)&etPowersaveOut);

  if (lResult>0)
  {
    assert(sizeof(etPowersaveOut)==etPowersaveOut.dwSize);
    assert((lMode==ET_DPMS_QUERY) || (etPowersaveIn.lMode==etPowersaveOut.lMode));
    bRet=TRUE;
  }
  else
  {
    // error: failed for call SUBESC_ET_DPMS");
  }

  return(bRet);
}
  */

// defines for DPMS-Power save modes
typedef enum tagET_DPMS_MODE
{
  ET_DPMS_ON,      // in/out: default mode, turn on monitor
                // Powersave modes:
  ET_DPMS_STANDBY, // in/out:
  ET_DPMS_SUSPEND, // in/out:
  ET_DPMS_OFF,     // in/out:

  ET_DPMS_QUERY    // in: return current mode in ET_DPMS_OUT. Only used in ET_DPMS_IN.ulMode!
} ET_DPMS_MODE;

// input structure app -> driver
typedef struct tagET_DPMS_IN
{
  ET_QUERY     hdr;    // size and subescape ET_DPMS_IN
  ET_DPMS_MODE lMode;  // type of mode to set or query
} ET_DPMS_IN;

// output structure driver -> app
typedef struct tagET_DPMS_OUT
{
  DWORD        dwSize; // Length of this out buffer
  ET_DPMS_MODE lMode;  // return current mode which is POWERSAVE_DISABLE or POWERSAVE_ENABLE
} ET_DPMS_OUT;

// end of code for SUBESC_ET_DPMS:
// ********************************************************

#ifdef WIN32
#pragma pack (pop, fixed_forELSAESC)
#else
#pragma pack ()
#endif

#endif //__ELSAESC
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\common\inc\eewinma2.h ===
//*****************************Module*Header******************************
//
// Module Name: eewinman2.h
//
// WINman display propterty page interface version 2
// for board detection, mode set,...
//
// FNicklisch 09/14/2000: 
//
// This part of code was taken from the code bought from ELSA. Parts of 
// it is used to get the workstation tools, application and features up
// and running. It is implemented on a temporary base and will be replaced
// by a NVIDIA propritary interface as soon as possible.
// Don't care about the code not necessariliy used.
//
// Copyright (c) 1998-2000, ELSA AG, Aachen (Germany)
// Copyright (c) 2000 NVidia Corporation. All Rights Reserved.
//
#ifndef _EeWINma2_h_
#define _EeWINma2_h_


/*
** $Header$
**
** MODULE:   EeWINma2.h
**
** AUTHOR:   Torsten Horn, Copyright (c) 1999 ELSA AG, Aachen (Germany)
**
** PROJECT:  ELSA Graphics Software
**
** PURPOSE:  ELSA Escape Windows driver functions for WINman
**
** NOTES:    1998-10-01 THorn: First release.
**           1999-05-04 THorn: Only comment extended/modified.
**           1999-08-03 THorn: New WINMAN_MOD_DFP and comments extended.
**           1999-08-18 THorn: New WINMAN_TIM_... flags.
**           1999-11-12 THorn: ET_WINMAN2_DDC_EDID_GET extended for EDID2.
*/


/*-----------------------------------------------------------------
  For the principle architecture of this kind of ELSA escape functions see 
  the header elsa\ElsaEsc.h (which must be included before this header).

  This header EeWINma2.h defines the escape functions:
    SUBESC_ET_WINMAN2_DATA_GET
    SUBESC_ET_WINMAN2_DATA_SET
    SUBESC_ET_WINMAN2_DDC_EDID_GET
  
  Simplyfied example for getting data from the driver (in case of 16 boards):
    ET_QUERY.dwSubEsc  = SUBESC_ET_WINMAN2_DATA_GET;
    ET_QUERY.dwSize    = sizeof(ET_QUERY);
    ET_QUERY.dwOutSize = sizeof(ET_WINMAN2_DATA_GET) +
                         sizeof(ET_WINMAN2_DATA_BRD_R) * 15;  // when 16 boards
    ExtEscape( hDC, ESC_ELSA_TOOLS,
               ET_QUERY.dwSize,    (LPCSTR)&ET_QUERY,
               ET_QUERY.dwOutSize,  (LPSTR)&ET_WINMAN2_DATA_GET );

  Simplyfied example for setting data to the driver (in case of 16 boards):
    ET_WINMAN2_DATA_SET.hdr.dwSubEsc  = SUBESC_ET_WINMAN2_DATA_SET;
    ET_WINMAN2_DATA_SET.hdr.dwSize    = sizeof(ET_WINMAN2_DATA_SET);
    ET_WINMAN2_DATA_SET.hdr.dwOutSize = sizeof(ET_WINMAN2_DATA_GET) +
                                        sizeof(ET_WINMAN2_DATA_BRD_R) * 15;
    ExtEscape( hDC, ESC_ELSA_TOOLS,
               ET_WINMAN2_DATA_SET.hdr.dwSize,    (LPCSTR)&ET_WINMAN2_DATA_SET,
               ET_WINMAN2_DATA_SET.hdr.dwOutSize,  (LPSTR)&ET_WINMAN2_DATA_GET );

  dwOutSize (in ET_QUERY and ET_WINMAN2_DATA_SET.hdr) must match
    sizeof(ET_WINMAN2_DATA_GET) + sizeof(ET_WINMAN2_DATA_BRD_R) * n;
  where n usually is equal to
    ET_WINMAN2_DATA_GET.dwNumBoardsInstalled - 1
  but n may be less eg. with WINMAN_SET_CHECK, see below.

  The first call usually is a SUBESC_ET_WINMAN2_DATA_GET with a return 
  structure size (dwOutSize) fitting for only one board. If
    ExtEscape() > 0  &&
    lResult == WINMAN_RESULT_ERROR_SIZE  &&
    dwNumBoardsInstalled > 1,
  then the next SUBESC_ET_WINMAN2_DATA_GET call has the correct 
  structure size in dwOutSize for getting the data of all boards.

  SUBESC_ET_WINMAN2_DATA_SET may be called for less than all boards 
  (especially with WINMAN_SET_CHECK). In this case the return structure 
  size (dwOutSize) may fit to this reduced number of boards (what should 
  not produce an error code).
  SUBESC_ET_WINMAN2_DATA_SET must always return either with 
  WINMAN_RESULT_ERROR or with valid and complete data in ET_WINMAN2_DATA_GET.

  You must carefully distinguish between the different return values:
    ExtEscape() must return:
      - zero if the escape function or the subescape is not implemented,
      - less than zero if an error in the escape interface occures (may 
        be ET_QUERY.dwSize is too small),
      - greater than zero if the escape interface is successful, even 
        when another error occures. Other error codes (for problems with 
        the data) are returned in lResult.
    ET_WINMAN2_DATA_GET.lResult must return the fitting WINMAN_RESULT_...
      When the size of the output structure was too small for all needed 
      boards, you must return WINMAN_RESULT_ERROR_SIZE.
      When all data send to the driver are ok, but eg. only the pixel 
      clock (may be of only one board) is too high, you either must return 
      WINMAN_RESULT_ERROR, or better would be, you would return 
      WINMAN_RESULT_MODIFIED and reduce the pixel clock to the max. allowed 
      value.
      With WINMAN_RESULT_ERROR the returned ET_WINMAN2_DATA_GET structure 
      may have invalid data. With WINMAN_RESULT_OK or WINMAN_RESULT_MODIFIED 
      the returned ET_WINMAN2_DATA_GET data must be o.k. and complete for 
      both kind of calls (SUBESC_ET_WINMAN2_DATA_GET and 
      SUBESC_ET_WINMAN2_DATA_SET).
    ET_WINMAN2_DATA_BRD_RW.dwFlags has flags for each board.
      With WINMAN_BRD_MODIFIED you can decide, for which board the data 
      were modified.
    ET_WINMAN2_DATA_GET.dwDrvModFlags returns with the WINMAN_MOD_... flag 
      bits some modification possibilities/capabilities (common for all 
      boards).

  -----------------------------------------------------------------*/


/* #include <elsa\ElsaEsc.h> */


/* Defines for driver result value in lResult
   (used eg. in ET_WINMAN2_DATA_GET and ET_WINMAN2_DDC_EDID_GET). */
#define WINMAN_RESULT_OK          0  /* o.k., no modification */
#define WINMAN_RESULT_ERROR      -1  /* error (returned data invalid) */
#define WINMAN_RESULT_ERROR_SIZE -2  /* error: dwOutSize wrong, 
                                        see comment to dwOutSize in header.
                                        Only the following members of 
                                        ET_WINMAN2_DATA_GET are guaranted to 
                                        be valid: dwSize, lResult, 
                                        dwNumBoardsInstalled, dwNumBoardsActive;
                                        other returned data may be invalid */
#define WINMAN_RESULT_MODIFIED    1  /* data modified;
                                        all data are ok, but only eg. the 
                                        pixel clock was too high; pixel 
                                        clock is reduced to max. allowed 
                                        value */

/* Defines for modification possibilities/capabilities flags in dwDrvModFlags
   (used in ET_WINMAN2_DATA_GET). */
#define WINMAN_MOD_BPP            1  /* bpp changable */
#define WINMAN_MOD_HZ             2  /* new Hz values definable */
#define WINMAN_MOD_TIM            4  /* complete timing definable */
#define WINMAN_MOD_PAN_HOR        8  /* horizontal panning possible */
#define WINMAN_MOD_PAN_VER       16  /* vertical panning possible */
#define WINMAN_MOD_MULTI_HOR     32  /* multiscreen hor. possible */
#define WINMAN_MOD_MULTI_VER     64  /* multiscreen ver. possible */
#define WINMAN_MOD_MULTI_H_V    128  /* multiscreen hor.+ver. both */
#define WINMAN_MOD_RES          256  /* new resolution values definable */
#define WINMAN_MOD_DFP          512  /* DFP Digital Flat Panel (different 
                                        resolutions with one fix timing) */

/* Defines for some board flags in dwFlags
   (used in ET_WINMAN2_DATA_BRD_RW). */
#define WINMAN_BRD_MODIFIED       1  /* data of this board modified */

/* Defines for some timing flags (sync polarity, interlace) in dwTimFlags
   (used in ET_WINMAN2_DATA_BRD_RW). */
#define WINMAN_TIM_HSYNC_POS      8  /* same as GFX_HSYNC_POS */
#define WINMAN_TIM_VSYNC_POS      4  /* same as GFX_VSYNC_POS */
#define WINMAN_TIM_ILC            1  /* same as GFX_ILC */
#define WINMAN_TIM_FIXED_TIMING  16  /* same as GFX_FIXED_TIMING */

/* Defines for action in dwCheckAddRemove
   (used in ET_WINMAN2_DATA_SET). */
#define WINMAN_SET_CHECK          1  /* check (may be modify) this mode */
#define WINMAN_SET_ADD            2  /* add this mode to allowed modes */
#define WINMAN_SET_REMOVE         3  /* remove this mode */
/* The following two are not used till now (for future use): */
#define WINMAN_SET_DO_TEST        4  /* switch only for test screen */
#define WINMAN_SET_DO_PERM        5  /* switch graphics mode permanent */


/* Read/write data of each board
   (used in ET_WINMAN2_DATA_GET and ..._DATA_SET). */
typedef struct tagET_WINMAN2_DATA_BRD_RW
{
  /* These values must always be valid: */
  DWORD dwPanOriginX;            /* panning x-origin */
  DWORD dwPanOriginY;            /* panning y-origin */
  DWORD dwVisOriginX;            /* visible x-origin */
  DWORD dwVisOriginY;            /* visible y-origin */
  DWORD dwPanSizeX;              /* panning x-size */
  DWORD dwPanSizeY;              /* panning y-size */
  DWORD dwVisSizeX;              /* visible x-size */
  DWORD dwVisSizeY;              /* visible y-size */
  DWORD dwBpp;                   /* bpp */
  DWORD dwColorsNum;             /* num. of colors */
  DWORD dwHz;                    /* Hz refresh rate */
  /* These values must be zero if not used: */
  DWORD dwFlags;                 /* flag bits, eg. WINMAN_BRD_MODIFIED */
  DWORD dwTimPixFreq;            /* pixel clock frequency in Hz */
  DWORD dwTimHTot;               /* horizontal total number of pixels */
  DWORD dwTimHFp;                /* horizontal frontporch in pixels */
  DWORD dwTimHSw;                /* horizontal sync width in pixels */
  DWORD dwTimHBp;                /* horizontal backporch in pixels */
  DWORD dwTimVTot;               /* vertical total number of lines */
  DWORD dwTimVFp;                /* vertical frontporch in lines */
  DWORD dwTimVSw;                /* vertical sync width in lines */
  DWORD dwTimVBp;                /* vertical backporch in lines */
  DWORD dwTimFlags;              /* tim. flag bits: WINMAN_TIM_... */
  DWORD dwReserved1;             /* == 0 (reserved) */
  DWORD dwReserved2;             /* == 0 (reserved) */
} ET_WINMAN2_DATA_BRD_RW, *PET_WINMAN2_DATA_BRD_RW;


/* Read-only data of each board
   (used in ET_WINMAN2_DATA_GET). */
typedef struct tagET_WINMAN2_DATA_BRD_R
{
  /* Board data used in ET_WINMAN2_DATA_GET and ..._DATA_SET: */
  ET_WINMAN2_DATA_BRD_RW rw;     /* read/write data */
  /* These values must be zero if not used: */
  DWORD dwPixFreqMax08;          /* max. possible pixel clock (in Hz) at  8bpp */
  DWORD dwPixFreqMax16;          /* max. possible pixel clock (in Hz) at 16bpp */
  DWORD dwPixFreqMax24;          /* max. possible pixel clock (in Hz) at 24bpp */
  DWORD dwPixFreqMax32;          /* max. possible pixel clock (in Hz) at 32bpp */
  DWORD dwMemSizePan;            /* RAM usable for visible and virtual screen */
  DWORD dwMemSizeAll;            /* size of all RAM (e.g. VRAM + DRAM) */
  DWORD dwReserved1;             /* == 0 (reserved) */
  DWORD dwReserved2;             /* == 0 (reserved) */
  char  sBoardname[40];          /* board name */
  char  sSerNum[24];             /* serial number */
} ET_WINMAN2_DATA_BRD_R, *PET_WINMAN2_DATA_BRD_R;


/* Data WINman gets from the Windows driver. */
typedef struct tagET_WINMAN2_DATA_GET
{
  DWORD dwSize;                  /* sizeof this struct with correct num of brd */
  LONG  lResult;                 /* WINMAN_RESULT_OK, ...ERROR..., ...MODIFIED */
  DWORD dwDrvModFlags;           /* driver modify flags WINMAN_MOD_... */
  DWORD dwReserved;              /* == 0 (reserved) */
  DWORD dwNumBoardsInstalled;    /* number of all installed boards */
  DWORD dwNumBoardsActive;       /* number of active used boards */
  /* The following struct as often as dwNumBoardsActive: */
  ET_WINMAN2_DATA_BRD_R brd[1];  /* data of all boards */
} ET_WINMAN2_DATA_GET, *PET_WINMAN2_DATA_GET;


/* Data WINman writes to the Windows driver. */
typedef struct tagET_WINMAN2_DATA_SET
{
  ET_QUERY hdr;
  DWORD dwCheckAddRemove;        /* WINMAN_SET_CHECK, ..._ADD, ..._DO_... */
  DWORD dwReserved1;             /* == 0 (reserved) */
  DWORD dwReserved2;             /* == 0 (reserved) */
  DWORD dwSizeX;                 /* x-size of desktop (over all monitors) */
  DWORD dwSizeY;                 /* y-size of desktop (over all monitors) */
  DWORD dwNumBoardsActive;       /* number of active used boards */
  /* The following struct as often as dwNumBoardsActive: */
  ET_WINMAN2_DATA_BRD_RW brd[1]; /* data of all boards */
} ET_WINMAN2_DATA_SET, *PET_WINMAN2_DATA_SET;


/*-----------------------------------------------------------------
  SUBESC_ET_WINMAN2_DDC_EDID_GET
  
  Example (m=0 for EDID1 and m=1 for EDID2):
    ET_QUERY.dwSubEsc  = SUBESC_ET_WINMAN2_DDC_EDID_GET;
    ET_QUERY.dwSize    = sizeof(ET_QUERY);
    ET_QUERY.dwOutSize = sizeof(ET_WINMAN2_DDC_EDID_GET) + m*128;
    ET_QUERY.dwBoard   = n;
    ExtEscape( hDC, ESC_ELSA_TOOLS,
               sizeof(  ET_QUERY ),
               (LPCSTR)&ET_QUERY,
               sizeof(  ET_WINMAN2_DDC_EDID_GET ) + m*128,
               (LPSTR) &ET_WINMAN2_DDC_EDID_GET );
  -----------------------------------------------------------------*/


/* DDC EDID structure WINman gets from the Windows driver.
   This structure  is for EDID 1.x with 128 bytes 
   of data as well as for EDID 2.x with 256 bytes.
   When WINman querries with wrong ET_QUERY.dwOutSize value, 
   the driver has to return WINMAN_RESULT_ERROR_SIZE. 
   Then WINman must try with another ET_QUERY.dwOutSize. */
typedef struct tagET_WINMAN2_DDC_EDID_GET
{
  DWORD dwSize;                   /* sizeof(ET_WINMAN2_DDC_EDID_GET)+m*128 */
  LONG  lResult;                  /* WINMAN_RESULT_OK, WINMAN_RESULT_ERROR... */
  unsigned char ddcEdid[128][1];  /* VESA DDC EDID structure */
} ET_WINMAN2_DDC_EDID_GET, *PET_WINMAN2_DDC_EDID_GET;


#endif  // #ifndef _EeWINma2_h_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\minix\modes.h ===
/*++

Copyright (c) 1989-2000  Microsoft Corporation

Module Name:

    modes.h

Abstract:

    This module contains the available video modes

--*/



//                Mode  Width  Height Depth Refresh
    DEF_VIDEOMODE(0x9F, 640  , 480  , 32  , 60)
    DEF_VIDEOMODE(0xA6, 800  , 600  , 32  , 60)
    DEF_VIDEOMODE(0xAD, 1024 , 768  , 32  , 60)
    DEF_VIDEOMODE(0x46, 320  , 240  , 16  , 60)
    DEF_VIDEOMODE(0x4A, 400  , 300  , 16  , 60)
    DEF_VIDEOMODE(0x4E, 480  , 360  , 16  , 60)
    DEF_VIDEOMODE(0x52, 512  , 384  , 16  , 60)
    DEF_VIDEOMODE(0x5C, 640  , 480  , 16  , 60)
    DEF_VIDEOMODE(0x63, 800  , 600  , 16  , 60)
    DEF_VIDEOMODE(0x6A, 1024 , 768  , 16  , 60)
    DEF_VIDEOMODE(0x71, 1152 , 864  , 16  , 60)
    DEF_VIDEOMODE(0x78, 1280 , 1024 , 16  , 60)
    DEF_VIDEOMODE(0x7E, 1920 , 1080 , 16  , 60)
    DEF_VIDEOMODE(0x81, 1920 , 1200 , 16  , 60)
    DEF_VIDEOMODE(0x82, 1600 , 1200 , 16  , 60)
    DEF_VIDEOMODE(0x89, 320  , 240  , 32  , 60)
    DEF_VIDEOMODE(0x8D, 400  , 300  , 32  , 60)
    DEF_VIDEOMODE(0x91, 480  , 360  , 32  , 60)
    DEF_VIDEOMODE(0x95, 512  , 384  , 32  , 60)
    DEF_VIDEOMODE(0xB4, 1152 , 864  , 32  , 60)
    DEF_VIDEOMODE(0xBB, 1280 , 1024 , 32  , 60)
    DEF_VIDEOMODE(0xC1, 1920 , 1080 , 32  , 60)
    DEF_VIDEOMODE(0xC4, 1920 , 1200 , 32  , 60)
    DEF_VIDEOMODE(0xC5, 1600 , 1200 , 32  , 60)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\common\inc\nvBldVer.h ===
#ifndef _NVBLDVER_H_
#define _NVBLDVER_H_

#define NV_BUILD_BRANCH_VERSION "nvr10-61"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\common\inc\nvCapture.h ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/

//////////////////////////////////////////////////////////////////////////////
// schema history
// 1. original version
// 2. adds CAPTURE_OBJECT_FREE, ANNOTATION, CAPTURE_CONFIG settings
// 3. adds CAPTURE_SYNC3 and obsoletes CAPTURE_SYNC
// 4. adds CAPTURE_LOCK
// 5. adds CAPTURE_FLIP_CHAIN
//////////////////////////////////////////////////////////////////////////////

#ifndef _nvCapture_h
#define _nvCapture_h

#ifdef __cplusplus
extern "C"
{
#endif
#pragma pack(push,1)

//////////////////////////////////////////////////////////////////////////////
// constants
//
#define CAPTURE_JMP_COMMAND             0x20ffffff
#define CAPTURE_EXT_SIGNATURE           0x420352ec

#define CAPTURE_CTXDMA_TYPE_PCI         0x49435920
#define CAPTURE_CTXDMA_TYPE_AGP         0x50474120
#define CAPTURE_CTXDMA_TYPE_VID         0x44495620

#define CAPTURE_SURFACE_TYPE_NORMAL     0x4d524f4e  // 'NORM'  surface goes into normal space (tiled)
#define CAPTURE_SURFACE_TYPE_ZETA       0x4154455a  // 'ZETA'  surface goes into zeta space (tiled)
#define CAPTURE_SURFACE_TYPE_TEXTURE    0x54584554  // 'TEXT'  surface goes into texture space

#define CAPTURE_SURFACE_KIND_TARGET     0x54475254  // 'TRGT'  surface will be used as a render target
#define CAPTURE_SURFACE_KIND_ZETA       0x4154455a  // 'ZETA'  surface will be used as a z buffer
#define CAPTURE_SURFACE_KIND_TEXTURE    0x54584554  // 'TEXT'  surface will be used as a texture
#define CAPTURE_SURFACE_KIND_VERTEX     0x54524556  // 'VERT'  surface will be used as a vertex buffer
#define CAPTURE_SURFACE_KIND_PUSHER     0x48535550  // 'PUSH'  surface will be used as a push buffer
#define CAPTURE_SURFACE_KIND_UNKNOWN    0x4e4b4e55  // 'UNKN'  surface will be used as a push buffer
#define CAPTURE_SURFACE_KIND_COMMAND    0x4d4d4f43  // 'COMM'  surface will be used as a command buffer
#define CAPTURE_SURFACE_KIND_PALETTE    0x434c4150  // 'PALE'  surface will be used as a palette

#define CAPTURE_SURFACE_FORMAT_Y8                0
#define CAPTURE_SURFACE_FORMAT_AY8               1
#define CAPTURE_SURFACE_FORMAT_A1R5G5B5          2
#define CAPTURE_SURFACE_FORMAT_X1R5G5B5          3
#define CAPTURE_SURFACE_FORMAT_A4R4G4B4          4
#define CAPTURE_SURFACE_FORMAT_R5G6B5            5
#define CAPTURE_SURFACE_FORMAT_A8R8G8B8          6
#define CAPTURE_SURFACE_FORMAT_unknown1          7
#define CAPTURE_SURFACE_FORMAT_X8R8G8B8          8
#define CAPTURE_SURFACE_FORMAT_I8_A1R5G5B5       9
#define CAPTURE_SURFACE_FORMAT_I8_R5G6B5        10
#define CAPTURE_SURFACE_FORMAT_I8_A4R4G4B4      11
#define CAPTURE_SURFACE_FORMAT_I8_A8R8G8B8      12
#define CAPTURE_SURFACE_FORMAT_DXT1_A1R5G5B5    13
#define CAPTURE_SURFACE_FORMAT_DXT23_A8R8G8B8   14
#define CAPTURE_SURFACE_FORMAT_DXT45_A8R8G8B8   15
#define CAPTURE_SURFACE_FORMAT_IMAGE_A1R5G5B5   16
#define CAPTURE_SURFACE_FORMAT_IMAGE_R5G6B5     17
#define CAPTURE_SURFACE_FORMAT_IMAGE_A8R8G8B8   18
#define CAPTURE_SURFACE_FORMAT_IMAGE_Y8         19
#define CAPTURE_SURFACE_FORMAT_IMAGE_SY8        20
#define CAPTURE_SURFACE_FORMAT_IMAGE_X7SY9      21
#define CAPTURE_SURFACE_FORMAT_IMAGE_R8B8       22
#define CAPTURE_SURFACE_FORMAT_IMAGE_G8B8       23
#define CAPTURE_SURFACE_FORMAT_IMAGE_SG8SB8     24
#define CAPTURE_SURFACE_FORMAT_unknown2         25
#define CAPTURE_SURFACE_FORMAT_unknown3         26
#define CAPTURE_SURFACE_FORMAT_unknown4         27

#define CAPTURE_LOCK_TYPE_LOCK                   1
#define CAPTURE_LOCK_TYPE_UNLOCK                 2

#define CAPTURE_ANNOTATION_ALLOC4X               0

#define CAPTURE_SYNC_SPECIAL            0xffffffff
#define CAPTURE_SYNC_WAIT_ZEROCOMMANDS  0x00000001  // wait for command buffer to empty (put==get)
#define CAPTURE_SYNC_WAIT_CHIPIDLE      0x00000002  // wait fot call engines to go idle
#define CAPTURE_SYNC_WAIT_CHANNELS      0x00000003  // wait for other channels to complete

#define CAPTURE_SYNC3_TYPE_ZEROCOMMANDS 0x00000001  // wait for command buffer to empty (put==get)
#define CAPTURE_SYNC3_TYPE_CHIPIDLE     0x00000002  // wait fot call engines to go idle
#define CAPTURE_SYNC3_TYPE_CHANNELS     0x00000003  // wait for other channels to complete
#define CAPTURE_SYNC3_TYPE_NOTIFIER     0x00000004  // wait for a notifier
#define CAPTURE_SYNC3_TYPE_REFCOUNT     0x00000005  // wait for a refcount
#define CAPTURE_SYNC3_TYPE_SEMAPHORE    0x00000006  // wait for a semaphore

#define CAPTURE_SCHEMA_1                0x00000001
#define CAPTURE_SCHEMA_2                0x00000002
#define CAPTURE_SCHEMA_3                0x00000003
#define CAPTURE_SCHEMA_4                0x00000004
#define CAPTURE_SCHEMA_5                0x00000005

#define CAPTURE_CURRENT_SCHEMA          CAPTURE_SCHEMA_5

//
// INFORMATION
//
#define CAPTURE_XID_INFORMATION             0x4f464e49  // 'INFO'
typedef struct {
    DWORD dwJmpCommand;             // CAPTURE_JMP_COMMAND
    DWORD dwExtensionSignature;     // CAPTURE_EXT_SIGNATURE
    DWORD dwExtensionID;            // CAPTURE_XID_INFORMATION
    DWORD dwSchema;                 // file version (CAPTURE_CURRENT_SCHEMA)
    char  szInformation[256];       // creation info
} CAPTURE_INFORMATION;

//
// CTXDMA_CREATE
//
#define CAPTURE_XID_CTXDMA_CREATE           0x52435843  // 'CXCR'
typedef struct {
    DWORD dwJmpCommand;             // CAPTURE_JMP_COMMAND
    DWORD dwExtensionSignature;     // CAPTURE_EXT_SIGNATURE
    DWORD dwExtensionID;            // CAPTURE_XID_CTXDMA_CREATE
    DWORD dwHandle;                 // you figure it out, Tex
    DWORD dwType;                   // CAPTURE_CTXDMA_TYPE_xxx
    DWORD dwSize;                   // [bytes]
    DWORD dwBaseAddress;            // application base address
} CAPTURE_CTXDMA_CREATE;

//
// SURFACE_ALLOC
//
#define CAPTURE_XID_SURFACE_ALLOC           0x41465253  // 'SRFA'
typedef struct {
    DWORD dwJmpCommand;             // CAPTURE_JMP_COMMAND
    DWORD dwExtensionSignature;     // CAPTURE_EXT_SIGNATURE
    DWORD dwExtensionID;            // CAPTURE_XID_SURFACE_ALLOC
    DWORD dwCtxDMAHandle;           // you figure it out, Tex
    DWORD dwOffset;                 // offset in CTXDMA
    DWORD dwSize;                   // size of surface (in bytes)
    DWORD dwAlignment;              // alignment (if known, 0 - let interpreter infer from CTXDMA)
    DWORD dwType;                   // CAPTURE_SURFACE_TYPE_xxx
    DWORD dwKind;                   // usage hint - CAPTURE_SURFACE_KIND_xxx
    DWORD dwSurfaceType;            // CAPTURE_SURFACE_FORMAT_xxx
    DWORD dwIntendedPitch;          // pitch we think we will apply on this surface
    DWORD dwIntendedHeight;         // height we think we will apply on this surface
} CAPTURE_SURFACE_ALLOC;

//
// SURFACE_FREE
//
#define CAPTURE_XID_SURFACE_FREE            0x46465253  // 'SRFF'
typedef struct {
    DWORD dwJmpCommand;             // CAPTURE_JMP_COMMAND
    DWORD dwExtensionSignature;     // CAPTURE_EXT_SIGNATURE
    DWORD dwExtensionID;            // CAPTURE_XID_SURFACE_FREE
    DWORD dwCtxDMAHandle;           // you figure it out, Tex
    DWORD dwOffset;                 // offset in CTXDMA
} CAPTURE_SURFACE_FREE;

//
// MEMORY_WRITE
//
#define CAPTURE_XID_MEMORY_WRITE            0x574d454d  // 'MEMW'
typedef struct {
    DWORD dwJmpCommand;             // CAPTURE_JMP_COMMAND
    DWORD dwExtensionSignature;     // CAPTURE_EXT_SIGNATURE
    DWORD dwExtensionID;            // CAPTURE_XID_MEMORY_WRITE
    DWORD dwCtxDMAHandle;           // you figure it out, Tex
    DWORD dwOffset;                 // offset in CTXDMA
    DWORD dwSize;                   // number of bytes (multiple of 4)
    // [ data goes here ]
} CAPTURE_MEMORY_WRITE;

//
// SYNC - obsoleted in schema 3
//
#define CAPTURE_XID_SYNC                    0x434e5953  // 'SYNC'
typedef struct {
    DWORD dwJmpCommand;             // CAPTURE_JMP_COMMAND
    DWORD dwExtensionSignature;     // CAPTURE_EXT_SIGNATURE
    DWORD dwExtensionID;            // CAPTURE_XID_SYNC
    DWORD dwCtxDMAHandle;           //                  [ if special, undefined                              ]
    DWORD dwOffset;                 // offset in CTXDMA [ special case when dwOffset == CAPTURE_SYNC_SPECIAL ]
    DWORD dwValue;                  // value to match   [ if special, one of CAPTURE_SYNC_WAIT_xxx           ]
} CAPTURE_SYNC;

//
// SYNC3
//
#define CAPTURE_XID_SYNC3                   0x334e5953  // 'SYN3'
typedef struct {
    DWORD dwJmpCommand;             // CAPTURE_JMP_COMMAND
    DWORD dwExtensionSignature;     // CAPTURE_EXT_SIGNATURE
    DWORD dwExtensionID;            // CAPTURE_XID_SYNC3
    DWORD dwType;                   // CAPTURE_SYNC3_TYPE_xxx
    DWORD dwCtxDMAHandle;           // valid for type semaphore, else irrelevant
    DWORD dwOffset;                 // offset in CTXDMA, valid for type semaphore, else irrelevant
    DWORD dwValue;                  // value to match
} CAPTURE_SYNC3;

//
// OBJECT_CREATE
//
#define CAPTURE_XID_OBJECT_CREATE           0x5243424f  // 'OBCR'
typedef struct {
    DWORD dwJmpCommand;             // CAPTURE_JMP_COMMAND
    DWORD dwExtensionSignature;     // CAPTURE_EXT_SIGNATURE
    DWORD dwExtensionID;            // CAPTURE_XID_OBJECT_CREATE
    DWORD dwClassID;                // actual class this handle maps to
    DWORD dwHandle;                 // handle of the class
} CAPTURE_OBJECT_CREATE;

//
// OBJECT_FREE
//
#define CAPTURE_XID_OBJECT_FREE             0x5246424f  // 'OBFR'
typedef struct {
    DWORD dwJmpCommand;             // CAPTURE_JMP_COMMAND
    DWORD dwExtensionSignature;     // CAPTURE_EXT_SIGNATURE
    DWORD dwExtensionID;            // CAPTURE_XID_OBJECT_FREE
    DWORD dwHandle;                 // you figure it out, Tex
} CAPTURE_OBJECT_FREE;

//
// SCENE
//
#define CAPTURE_XID_SCENE                   0x454e4353  // 'SCNE'
typedef struct {
    DWORD dwJmpCommand;             // CAPTURE_JMP_COMMAND
    DWORD dwExtensionSignature;     // CAPTURE_EXT_SIGNATURE
    DWORD dwExtensionID;            // CAPTURE_XID_SCENE
} CAPTURE_SCENE;

//
// LOCK / UNLOCK
//
#define CAPTURE_XID_LOCK                    0x4b434f4c  // 'LOCK'
typedef struct {
    DWORD dwJmpCommand;             // CAPTURE_JMP_COMMAND
    DWORD dwExtensionSignature;     // CAPTURE_EXT_SIGNATURE
    DWORD dwExtensionID;            // CAPTURE_XID_LOCK
    DWORD dwType;                   // CAPTURE_LOCK_TYPE_xxx
    DWORD dwCtxDMAHandle;
    DWORD dwOffset;
} CAPTURE_LOCK;

//
// FLIP_CHAIN
//
#define CAPTURE_XID_FLIP_CHAIN              0x4e484346  // 'FCHN'
typedef struct {
    DWORD dwJmpCommand;             // CAPTURE_JMP_COMMAND
    DWORD dwExtensionSignature;     // CAPTURE_EXT_SIGNATURE
    DWORD dwExtensionID;            // CAPTURE_XID_FLIP_CHAIN
    DWORD dwCount;                  // number of surfaces in chain. addresses follow.
    // [ data here ]
} CAPTURE_FLIP_CHAIN;

//
// ANNOTATION
//
#define CAPTURE_XID_ANNOTATION              0x4f4e4e41  // 'ANNO'
typedef struct {
    DWORD dwJmpCommand;             // CAPTURE_JMP_COMMAND
    DWORD dwExtensionSignature;     // CAPTURE_EXT_SIGNATURE
    DWORD dwExtensionID;            // CAPTURE_XID_ANNOTATION
    DWORD dwValue;                  // CAPTURE_ANNOTATION_xxx
} CAPTURE_ANNOTATION;


//////////////////////////////////////////////////////////////////////////////
// procedures
//
int captureStartup   (char *szBasePath, char *szBaseFilename, DWORD dwBaseFilenum);
int captureShutdown  (void);
int captureSetParams (char *szBasePath, char *szBaseFilename, DWORD dwBaseFilenum);
int captureLog       (void *pBuffer, unsigned uCount);
int captureFileInc   (void);

int capturePlayStartup   (char *szBasePath, char *szBaseFilename, DWORD dwBaseFilenum);
int capturePlayShutdown  (void);
int capturePlaySetParams (char *szBasePath, char *szBaseFilename, DWORD dwBaseFilenum);
int capturePlay          (void *pRenderTarget, DWORD dwPitch, DWORD dwWidth, DWORD dwHeight);
int capturePlayFileInc   (void);

#pragma pack(pop)
#ifdef __cplusplus
}
#endif

#endif // _nvPM_h
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\common\inc\nvBlit.h ===
/*
 * (C) Copyright NVIDIA Corporation Inc., 1996,1997,1998. All rights reserved.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: nvBlit.h                                                          *
*    Definition file for:                                                   *
*       Blt832.c, Blt1632.c and Blt3232                                     *
*    Suggested new name for combined file:                                  *
*       nvBlit.c                                                            *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Paul van der Kouwe 06/16/99 - created.                              *
*                                                                           *
\***************************************************************************/

#ifndef _NVBLIT_H_
#define _NVBLIT_H_

#ifdef __cplusplus
extern "C" {
#endif

// workspace allocation flags
#define BLTWS_UNINITIALIZED     0x0
#define BLTWS_VIDEO             0x1
#define BLTWS_AGP               0x2
#define BLTWS_SYSTEM            0x4
#define BLTWS_PREFERRED_VIDEO   0x10
#define BLTWS_PREFERRED_AGP     0x20
#define BLTWS_PREFERRED_SYSTEM  0x40
#define BLTWS_REQUIRED_VIDEO    0x100
#define BLTWS_REQUIRED_AGP      0x200
#define BLTWS_REQUIRED_SYSTEM   0x400

// other defines (lore)
#define NV4_BLT_READ_AHEAD_BUFFER_SIZE  4096
#define NV10_BLT_READ_AHEAD_BUFFER_SIZE 8192

// abbreviated surface info
typedef struct tagSurfInfo {
    LPDDRAWI_DDRAWSURFACE_LCL pLcl;
    LPDDRAWI_DDRAWSURFACE_GBL pGbl;
    CNvObject *pObj;
    DWORD     dwFourCC;
    BOOL      bUseSwizzle;
    BOOL      bIsLocked;
    DWORD     dwCaps;
    DWORD     dwContextDma;
    FLATPTR   fpVidMem;
    DWORD     dwOffset;
    DWORD     dwPitch;
    DWORD     dwWidth;
    DWORD     dwHeight;
    DWORD     dwSubRectX;
    DWORD     dwSubRectY;
    DWORD     dwSubRectWidth;
    DWORD     dwSubRectHeight;
    BOOL      isPotentialFault;
    DWORD     dwBytesPerPixel;
    BOOL      bDefaultBlitChanged;
} SURFINFO, *LPSURFINFO;

// exports
DWORD __stdcall GetBltStatus32(LPDDHAL_GETBLTSTATUSDATA lpGetBltStatus);
DWORD __stdcall Blit32(LPDDHAL_BLTDATA pbd);

// utility functions
void  __stdcall bltInit(void);
DWORD __stdcall bltEarlyErrorCheck(LPDDHAL_BLTDATA pbd, LPSURFINFO pSrc, LPSURFINFO pDst);
DWORD __stdcall bltUpdateClip(GLOBALDATA *pDriverData);
DWORD __stdcall bltDestroyAllContextDMAs(LPDDRAWI_DIRECTDRAW_GBL lpDD);
DWORD __stdcall bltCreateContextDMA(LPDDHAL_BLTDATA pbd, LPSURFINFO pSurf);
DWORD __stdcall bltControlTraffic(LPSURFINFO pSrc, LPSURFINFO pDst);
DWORD __stdcall bltAllocWorkSpace(LPDDHAL_BLTDATA pbd, LPSURFINFO pSurf, DWORD dwFlags, LPDDRAWI_DIRECTDRAW_GBL lpDD);
DWORD __stdcall bltSetSurfaces2D(LPSURFINFO pSrc, LPSURFINFO pDst);
DWORD __stdcall bltSetBltState(LPDDHAL_BLTDATA pbd, LPSURFINFO src, LPSURFINFO dst);

// blt functions
DWORD __stdcall bltPotentialFaultHandler(LPDDHAL_BLTDATA pbd, LPSURFINFO pSrc, LPSURFINFO pDst);
DWORD __stdcall bltTexture(LPDDHAL_BLTDATA pbd, LPSURFINFO pSrc, LPSURFINFO pDst, BOOL bStretch);
DWORD __stdcall ScaleZFillDepth(LPDDHAL_BLTDATA pbd, LPSURFINFO pDst);
DWORD __stdcall bltColourFill(LPDDHAL_BLTDATA pbd, LPSURFINFO pDst, DWORD dwFillColour);
DWORD __stdcall blt4CCto4CC(LPDDHAL_BLTDATA pbd, LPSURFINFO pSrc, LPSURFINFO pDst);
DWORD __stdcall bltSimpleCopy(LPDDHAL_BLTDATA pbd, LPSURFINFO pSrc, LPSURFINFO pDst);
DWORD __stdcall bltSlowVtoSBlt(LPDDHAL_BLTDATA pbd, LPSURFINFO pSrc, LPSURFINFO pDst);
DWORD __stdcall bltSlowStoVBlt(LPDDHAL_BLTDATA pbd, LPSURFINFO pSrc, LPSURFINFO pDst);
DWORD __stdcall bltSimpleVtoVBlt(LPDDHAL_BLTDATA pbd, LPSURFINFO pSrc, LPSURFINFO pDst);
DWORD __stdcall blt8bppStrBlt(LPDDHAL_BLTDATA pbd, LPSURFINFO pSrc, LPSURFINFO pDst);
DWORD __stdcall bltStrBlt(LPDDHAL_BLTDATA pbd, LPSURFINFO pSrc, LPSURFINFO pDst, BOOL bFilter);

// internal use blit functions
DWORD __stdcall bltWriteDword(DWORD dwOffset, DWORD dwIndex, DWORD dwData);
DWORD __stdcall bltFillBlock(GLOBALDATA *pDriverData, DWORD dwColour, DWORD dwOffset, DWORD dwPitch, DWORD dwWidth, DWORD dwHeight, DWORD dwBytesPerPel);

// old fallback blt code
DWORD __stdcall Blt8bpp32  (LPDDHAL_BLTDATA pbd);
DWORD __stdcall Blt16bpp32 (LPDDHAL_BLTDATA pbd);
DWORD __stdcall Blt32bpp32 (LPDDHAL_BLTDATA pbd);

#ifdef __cplusplus
}
#endif // __cplusplus

#endif // _NVBLIT_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\common\inc\nvcom.h ===
#ifndef __NV_COM_H
#define __NV_COM_H

#include "nvOverlay.h"

// XXX Having to define this here sucks.  This is in mtexport.h but
// mtexport.h needs NVstate stuff :(   -paul
#ifndef WQ_MAX_THREAD
#define WQ_MAX_THREAD 2
#endif

typedef struct  __GLNVtagInfoRec {
    unsigned int  type;
    void          *address;
} __GLNVtagInfo;    

// Basic element of the pushbuffer
typedef union __GLNVdataRec {
    NvF32 f;
    NvS32 i;
    NvU32 u;
} __GLNVdata;

// Structure declarations to keep gcc happy
struct __GLNVstateRec;
struct __GLdrawablePrivateRec;

// Flags passed into the display driver when allocating or requesting
// info regarding the unified buffers.

enum  {
    SBD_BACK_1_OFFSET = 0,
    SBD_BACK_1_PITCH,
    SBD_BACK_2_OFFSET,
    SBD_BACK_2_PITCH,
    SBD_DEPTH_OFFSET,
    SBD_DEPTH_PITCH,
    SBD_FRONT_MAIN_OFFSET,
    SBD_FRONT_MAIN_PITCH,
    SBD_BACK_1_MAIN_OFFSET,
    SBD_BACK_1_MAIN_PITCH,
    SBD_FRONT_OVERLAY_OFFSET,
    SBD_FRONT_OVERLAY_PITCH,
    SBD_BACK_1_OVERLAY_OFFSET,
    SBD_BACK_1_OVERLAY_PITCH,
    // ogl api stereo buffers below
    SBD_FRONT_RIGHT_OFFSET,
    SBD_FRONT_RIGHT_PITCH,
    SBD_BACK_1_RIGHT_OFFSET,
    SBD_BACK_1_RIGHT_PITCH,
    SBD_BACK_2_RIGHT_OFFSET,
    SBD_BACK_2_RIGHT_PITCH,
    SBD_DEPTH_RIGHT_OFFSET,
    SBD_DEPTH_RIGHT_PITCH,
    SBD_FRONT_MAIN_RIGHT_OFFSET,
    SBD_FRONT_MAIN_RIGHT_PITCH,
    SBD_BACK_1_MAIN_RIGHT_OFFSET,
    SBD_BACK_1_MAIN_RIGHT_PITCH,
    SBD_FRONT_OVERLAY_RIGHT_OFFSET,
    SBD_FRONT_OVERLAY_RIGHT_PITCH,
    SBD_BACK_1_OVERLAY_RIGHT_OFFSET,
    SBD_BACK_1_OVERLAY_RIGHT_PITCH
};

typedef struct __GLNVsbdFlagsRec {
    int windowFlipping;  // Enable window flipping
    int overlaySupport;  // Allocate overlay buffers
    int surfaceInfoType;
    int depthCompressed;
} __GLNVsbdFlags;


typedef struct __GLNVpaletteDataRec {
  void         *windowHandle;
  unsigned int  entries[ICD_PALETTE_ENTRIES];
  unsigned int  crTransparent;
} __GLNVpaletteData;

typedef struct __GLMergeBlitDataRec
{
    NvU32 PrimaryFrontOffset; // offset of primary buffer (where DAC is working)
    NvU32 PrimaryFrontPitch ;
    NvU32 ScratchOffset     ; // offset of scratch buffer for mergeblit
    NvU32 ScratchPitch      ;

    NvU32 MainFrontOffset   ; // offset of main front plane (where overlay app has its main)
    NvU32 MainFrontPitch    ;
    NvU32 MainBackOffset    ; // offset of main back plane (where overlay app has its main)
    NvU32 MainBackPitch     ;

    NvU32 OverlayFrontOffset; // offset of overlay front plane (where overlay app has its overlay)
    NvU32 OverlayFrontPitch ;
    NvU32 OverlayBackOffset ; // offset of overlay back plane (where overlay app has its overlay)
    NvU32 OverlayBackPitch  ;

    int   colordepth        ; // 16 or 32, color depth of above buffers (UBB)

    NvU32 colorref          ; // colorkey for transparent color

    unsigned int   dwAction ; // NV_OVERLAY_xxx

    __GLregionRect *prclClip; // pointer to list of clip rects
    unsigned int    cClip;    // count of valid rects inside prclClip

    __GLregionRect rclUser  ; // single user clip rect 
} __GLMergeBlitData;

typedef struct __GLNVcmdInfoRec {

    struct __GLNVstateRec *state;

    // Channel information for syncing in NTx display driver
    NvU32        maskOtherChannels;
    unsigned int ourChannelId;
    void         *ntOther;      // PDEV pointer 
    void         *ntDrawable;   // clientDrawableInfo pointer 
    void         *ntClientInfo; // clientInfo pointer 

    // Number of hardware window clipping rectangles available.
    // Should be 8 for NV10GL and 1 for NV10 geForce.
    int numHWClipRects;

    // TRUE if rendering to the back buffer
    unsigned int backBufferIsEnabled;

    // Client size view of windowChangedCount at time of kickoff; this is
    // compared with the latest count inside the display driver.  If they
    // are out of sync and flushBetween2D is TRUE then fail the kick off
    // in the display driver.
    int windowChangedCount;
    int flushedBetween2D;

    unsigned char isClipped;
    unsigned char usingCopyBuf;
    int syncGdi;

    int nvDebugLevel;
    int nvDebugOptions;
    int nvDebugMask;
    int nvControlOptions;

    // Core Clip rectangle computed by wgl in screen coordinates
    __GLregionRect coreClipRect;

    int temp0;
    int temp1;
    int temp2;
    int temp3;
    int temp4;
} __GLNVcmdInfo;

//
// NV10 flush information structure
//
typedef struct __GLNVflushInfoRec {
    // flush type, client handle and window handle
//    ULONG        type;
    ULONG        hClient;

    // clip and mode switch info
    ULONG        localModeSwitchCount;

    __GLNVcmdInfo *cmdInfo;
    
    // Tells Display driver that scissor has changed.
    ULONG wndClipRectChanged;
    
    // Clip Changed Count 
    ULONG clipChangedCount;

    // return status from flush command
    unsigned int retStatus;   // status of flush in display driver
} __GLNVflushInfo;

typedef struct __GLNVswapInfoRec {
    ULONG        hClient;

    // window info
    __GLNVcmdInfo *cmdInfo;

    // clip and mode switch info
    ULONG        clipChangedCount;
    ULONG        localModeSwitchCount;
    PVOID        drawable;

    // SwapHintRect info
    unsigned int        numSwapHintRects;
    __GLregionRect*     pSwapHintRects;

    // return status
    ULONG        retStatus;
} __GLNVswapInfo;

// ***********************************************************************
// Command interface for OpenGL operations which must be performed inside
// the display driver (or mutexed, depending on the OS)
enum {
    NVOP_STATUS_ERROR,
    NVOP_STATUS_SUCCESS,
    NVOP_STATUS_NEED_UPDATE,
    NVOP_STATUS_UNKNOWN_OP
};

typedef enum {
    NVOP_CLEAR,
    NVOP_SWAP,
} __GLNVopcode;

typedef struct __GLNVclearCmdRec {
    GLbitfield mask;                        // buffers to clear
    __GLregionRect rect;                    // user clear rect
    GLint drawBufferMask;                   // mask of active buffers
    /* Color buffer */
    struct {
        GLfloat r, g, b, a;
    } clearColor;                           // clear color
    GLboolean rMask;                        // color buffer red mask
    GLboolean gMask;                        // color buffer green mask
    GLboolean bMask;                        // color buffer blue mask
    GLboolean aMask;                        // color buffer alpha mask
    /* Depth buffer */
    GLfloat clearDepth;                     // clear depth
    /* Stencil buffer */
    GLuint clearStencil;                    // clear stencil
    GLuint stencilMask;                     // stencil mask
} __GLNVclearCmd;

typedef struct __GLNVoperationRec {
    __GLNVopcode opCode;
    __GLNVcmdInfo *cmdInfo;
    struct __GLNVstateRec *state;             // can this be removed?
    struct __GLdrawablePrivateRec *dp;
    struct {
        GLint numRects;
        __GLregionRect *rects;
    } clip;
    union {
        __GLNVclearCmd clear;
    } u;
    GLint retStatus;
} __GLNVoperation;

// ***********************************************************************


// probably needs to be removed to better place
// bits used in __glNVOverlayMergeFastLock - dwAction
#define NV_OVERLAY_MERGE_BLIT        0x00000001 // do front overlay + front main -> scratch -> primary
#define NV_OVERLAY_UPDATE_OVERLAY    0x00000010 // overlay back -> overlay front (prior to merge)
#define NV_OVERLAY_UPDATE_MAIN       0x00000020 // main back -> overlay front (prior to merge)
#define NV_OVERLAY_USE_CLIPRECT      0x00000100 // only do mergeblit on given rect (else entire window)
#define NV_OVERLAY_DEFERRED          0x00001000 // defer merge blit (do update later)
#define NV_OVERLAY_RUN_IN_DD         0x00002000 // do mergeblit in display driver
#define NV_OVERLAY_NO_OVERLAY_PLANE  0x00010000 // there is no overlay plane, front main -> primary (will overwrite NV_OVERLAY_MERGE_BLIT)


//
// Derived from __GLNVswapInfo to support overlay merge blit through DD.
// Used with the ESC_NV_OPENGL_OVERLAY_MERGEBLIT escape 
// in __glNVOverlayMergeFastLock.
//
typedef struct __GLNVoverlayMergeBlitInfoRec {
    unsigned int hClient;
    
    // window info
    __GLNVcmdInfo *cmdInfo;

    // clip and mode switch info
    unsigned int localModeSwitchCount;

    // return status
    unsigned int retStatus;

    unsigned int dwAction; // NV_OVERLAY_xxx

    int          x;        // bounding rectangle if NV_OVERLAY_USE_CLIPRECT is set 
    int          y;
    int          width;
    int          height;

    // SwapHintRect info
    unsigned int numSwapHintRects;
    void *       pSwapHintRects;

} __GLNVoverlayMergeBlitInfo;

//
// These routines live in the shared lib and are called from both the ICD
// and from the display driver side of OGL escape calls.  -paul
//

// nvsharedpushbuf.c
extern void STDCALL __glNVMakeJumpSpaceInPushBuffer(__GLNVcmdInfo *cmdInfo);
extern GLboolean STDCALL __glNVSetupAndKickoff(__GLNVcmdInfo *cmdInfo,
                                          unsigned int numInclusiveRects,__GLregionRect *inclusiveRects,
                                          unsigned int numExclusiveRects,__GLregionRect *exclusiveRects,
                                          unsigned char failOnClipChange);
extern void STDCALL __glNVCopyPseudoKickoff(__GLNVcmdInfo *cmdInfo, int forceRealBuf);

// nvsharedutils.c
extern void STDCALL __glNVInitSharedFnPtrs(__GLNVcmdInfo *cmdInfo);
extern void STDCALL __glNVDoRegistryHacks(unsigned int hwGfxCaps,
                                          unsigned int *flippingControl,
                                          unsigned int *doUnifiedBuffers,
                                          unsigned int *doWindowFlipping,
                                          unsigned int *applicationKey,
                                          unsigned int *appSupportBits,
                                          unsigned int *overlaySupport,
                                          unsigned int *apiStereoSupport,
                                          unsigned int *apiStereoMode);
extern void STDCALL __glNVLoadRegistryDefaults(unsigned int hwGfxCaps,
                                               unsigned int *doUnifiedBuffers,
                                               unsigned int *doWindowFlipping,
                                               unsigned int *flippingControl,
                                               unsigned int *applicationKey,
                                               unsigned int *appSupportBits,
                                               unsigned int *overlaySupport,
                                               unsigned int *apiStereoSupport,
                                               unsigned int *apiStereoMode);

extern void STDCALL __glNVUpdateStereoBuffers(struct __GLdrawablePrivateRec *dp);

// nvsharedswap.c
extern GLboolean STDCALL __glNVWasFlipped(__GLNVcmdInfo *cmdInfo);
extern GLboolean STDCALL __glNVSetupSwap(__GLNVcmdInfo *cmdInfo, void *drawable,
                                         unsigned int numRects, __GLregionRect *rects,
                                         int screenWidth, int screenHeight);
extern int STDCALL __glNVIsVerticalInterlacedApiStereo(void *drawable);
extern GLboolean STDCALL __glNV4SetupSwap(__GLNVcmdInfo *cmdInfo, void *drawable,
                                          unsigned int numRects, __GLregionRect *rects,
                                          int screenWidth, int screenHeight);
extern GLboolean STDCALL __glNVPrepareStereoSwap(void *drawable,
                                                 int stereoBroadcastingNeeded);
extern GLboolean STDCALL __glNVSetupMergeBlit(__GLNVcmdInfo *cmdInfo, 
                                              struct __GLMergeBlitDataRec *pMergeBlitData);

// nv4sharedpushbuf.c
extern void STDCALL __glNV4SetupAndKickoff(__GLNVcmdInfo *cmdInfo,
                                           unsigned int numRects,
                                           __GLregionRect *rects);

// nvsharedclear.c
extern void STDCALL __glNVSetupClear(__GLNVoperation *op);

// oglexpor.c in DD
extern void CDECLCALL __glNVFlushInternal(__GLNVcmdInfo *cmdInfo, unsigned char forceRealBuf);
extern void CDECLCALL __glNV4FlushInternal(__GLNVcmdInfo *cmdInfo);

#endif  // __NV_COM_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\common\inc\nvDMAC.h ===
// (C) Copyright NVIDIA Corporation Inc., 1996,1998. All rights reserved.

/********************************* Direct 3D *******************************\
*                                                                           *
* Module: NVDMAC.H                                                          *
*   Define various macros used to interact with the hardware                *
*   Please put other more general D3D macros in nvd3dmac or elsewhere!      *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Charles Inman (chasi)       1/26/98 - Created                       *
*                                                                           *
\***************************************************************************/

#ifndef _NV4DMAC_H_
#define _NV4DMAC_H_

#ifdef __cplusplus
extern "C" {
#endif

// NV Reference Manual register access definitions.
#define BIT(b)                  (1<<(b))
#define DEVICE_BASE(d)          (0?d)
#define DEVICE_EXTENT(d)        (1?d)
#define DRF_SHIFT(drf)          ((0?drf) % 32)
#define DRF_MASK(drf)           (0xFFFFFFFF>>(31-((1?drf) % 32)+((0?drf) % 32)))
#define DRF_DEF(d,r,f,c)        ((NV ## d ## r ## f ## c)<<DRF_SHIFT(NV ## d ## r ## f))
#define DRF_NUM(d,r,f,n)        (((n)&DRF_MASK(NV ## d ## r ## f))<<DRF_SHIFT(NV ## d ## r ## f))
#define DRF_VAL(d,r,f,v)        (((v)>>DRF_SHIFT(NV ## d ## r ## f))&DRF_MASK(NV ## d ## r ## f))
#define REG_WR_DRF_NUM(d,r,f,n) REG_WR32(NV ## d ## r, DRF_NUM(d,r,f,n))
#define REG_WR_DRF_DEF(d,r,f,c) REG_WR32(NV ## d ## r, DRF_DEF(d,r,f,c))
#define FLD_WR_DRF_NUM(d,r,f,n) REG_WR32(NV##d##r,(REG_RD32(NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_NUM(d,r,f,n))
#define FLD_WR_DRF_DEF(d,r,f,c) REG_WR32(NV##d##r,(REG_RD32(NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_DEF(d,r,f,c))
#define REG_RD_DRF(d,r,f)       (((REG_RD32(NV ## d ## r))>>DRF_SHIFT(NV ## d ## r ## f))&DRF_MASK(NV ## d ## r ## f))

//-------------------------------------------------------------------------
//                 GENERIC DMA PUSH BUFFER OPERATIONS
//-------------------------------------------------------------------------

#define sizeSetObject                       2
#define nvglSetObject(ch, obj)                                              \
{                                                                           \
    nvPushData (0, (0x00040000 | ((ch) << 13)));                            \
    nvPushData (1, obj);                                                    \
    nvPusherAdjust (sizeSetObject);                                         \
}

#define sizeSetStartMethod                  1
#define nvglSetStartMethod(index, ch, method, methodcount)                  \
{                                                                           \
    nvPushData (index, ((((methodcount) << 2) << 16) | ((ch) << 13) | (method))); \
}

#define sizeSetData                         1
#define nvglSetData(index, data)                                            \
{                                                                           \
    nvPushData (index, (data));                                             \
}

#define nvglAdjust(size)                                                    \
{                                                                           \
    nvPusherAdjust (size);                                                  \
}

#define sizeDmaJump         1
#define nvglDmaJump(offset)                                                 \
{                                                                           \
    nvPushData (0, (0x20000000 | (offset)));                                \
    nvPusherAdjust (sizeDmaJump);                                           \
}

//-------------------------------------------------------------------------
//                              NV 002
//                   NV01_CONTEXT_DMA_FROM_MEMORY
//-------------------------------------------------------------------------

#define sizeSetDmaFromMemoryMthdCnt                 3
#define sizeSetDmaFromMemory                        4
#define nvglSetDmaFromMemory(ch, base, selector, limit)                     \
{                                                                           \
    nvPushData (0, (((sizeSetDmaFromMemoryMthdCnt << 2) << 16) | ((ch) << 13) | 0x300)); \
    nvPushData (1, (base));                                                 \
    nvPushData (2, (selector));                                             \
    nvPushData (3, (limit));                                                \
    nvPusherAdjust (sizeSetDmaFromMemory);                                  \
}

#define sizeSetDmaFromMemoryContextNotifyMthdCnt    1
#define sizeSetDmaFromMemoryContextNotify           2
#define nvglSetDmaFromMemoryContextNotify(ch, ctxdmanotify)                 \
{                                                                           \
    nvPushData (0, (((sizeSetDmaFromMemoryContextNotifyMthdCnt << 2) << 16) | ((ch) << 13) | 0x180)); \
    nvPushData (1, (ctxdmanotify));                                         \
    nvPusherAdjust (sizeSetDmaFromMemoryContextNotify);                     \
}

#define sizeSetDmaFromMemoryNotify                  7
#define nvglSetDmaFromMemoryNotify(ch, base, selector, limit, notify)       \
{                                                                           \
    nvPushData (0, (((2 << 2) << 16) | ((ch) << 13) | 0x300));              \
    nvPushData (1, (base));                                                 \
    nvPushData (2, (selector));                                             \
    nvPushData (3, (((1 << 2) << 16) | ((ch) << 13) | 0x104));              \
    nvPushData (4, (notify));                                               \
    nvPushData (5, (((1 << 2) << 16) | ((ch) << 13) | 0x308));              \
    nvPushData (6, (limit));                                                \
    nvPusherAdjust (sizeSetDmaFromMemoryNotify);                            \
}

//-------------------------------------------------------------------------
//                              NV 003
//                    NV01_CONTEXT_DMA_TO_MEMORY
//-------------------------------------------------------------------------

#define sizeSetDmaToMemoryMthdCnt                 3
#define sizeSetDmaToMemory                        4
#define nvglSetDmaToMemory(ch, base, selector, limit)                       \
{                                                                           \
    nvPushData (0, (((sizeSetDmaToMemoryMthdCnt << 2) << 16) | ((ch) << 13) | 0x300)); \
    nvPushData (1, (base));                                                 \
    nvPushData (2, (selector));                                             \
    nvPushData (3, (limit));                                                \
    nvPusherAdjust (sizeSetDmaToMemory);                                    \
}

#define sizeSetDmaToMemoryContextNotifyMthdCnt    1
#define sizeSetDmaToMemoryContextNotify           2
#define nvglSetDmaToMemoryContextNotify(ch, ctxdmanotify)                   \
{                                                                           \
    nvPushData (0, (((sizeSetDmaToMemoryContextNotifyMthdCnt << 2) << 16) | ((ch) << 13) | 0x180)); \
    nvPushData (1, (ctxdmanotify));                                         \
    nvPusherAdjust (sizeSetDmaToMemoryContextNotify);                       \
}

#define sizeSetDmaToMemoryNotify                  7
#define nvglSetDmaToMemoryNotify(ch, base, selector, limit, notify)         \
{                                                                           \
    nvPushData (0, (((2 << 2) << 16) | ((ch) << 13) | 0x300));              \
    nvPushData (1, (base));                                                 \
    nvPushData (2, (selector));                                             \
    nvPushData (3, (((1 << 2) << 16) | ((ch) << 13) | 0x104));              \
    nvPushData (4, (notify));                                               \
    nvPushData (5, (((1 << 2) << 16) | ((ch) << 13) | 0x308));              \
    nvPushData (6, (limit));                                                \
    nvPusherAdjust (sizeSetDmaToMemoryNotify);                              \
}

//-------------------------------------------------------------------------
//                              NV 019
//                    NV01_CONTEXT_CLIP_RECTANGLE
//-------------------------------------------------------------------------

#define sizeSetClipMthdCnt                          2
#define sizeSetClip                                 3
#define nvglSetClip(ch, x, y, w, h)                                         \
{                                                                           \
    nvPushData (0, (((sizeSetClipMthdCnt << 2) << 16) | ((ch) << 13) | NV019_SET_POINT)); \
    nvPushData (1, ((DWORD)y << 16) | (DWORD)x);                            \
    nvPushData (2, ((DWORD)h << 16) | (DWORD)w);                            \
    nvPusherAdjust (sizeSetClip);                                           \
}

//-------------------------------------------------------------------------
//                              NV 042
//                     NV04_CONTEXT_SURFACES_2D
//-------------------------------------------------------------------------

#define sizeSet2DSurfacesNoOpMthdCnt    1
#define sizeSet2DSurfacesNoOp           2
#define nvglSet2DSurfacesNoOp(ch)                                           \
{                                                                           \
    nvPushData (0, (((sizeSet2DSurfacesNoOpMthdCnt << 2) << 16) | ((ch) << 13) | NV042_NO_OPERATION)); \
    nvPushData (1, 0);                                                      \
    nvPusherAdjust (sizeSet2DSurfacesNoOp);                                 \
}

#define sizeSet2DSurfacesContextsMthdCnt            2
#define sizeSet2DSurfacesContexts                   3
#define nvglSet2DSurfacesContexts(ch, ctxsrc, ctxdest)                      \
{                                                                           \
    nvPushData (0, (((sizeSet2DSurfacesContextsMthdCnt << 2) << 16) | ((ch) << 13) | NV042_SET_CONTEXT_DMA_IMAGE_SOURCE)); \
    nvPushData (1, (ctxsrc));                                               \
    nvPushData (2, (ctxdest));                                              \
    nvPusherAdjust (sizeSet2DSurfacesContexts);                             \
}

#define sizeSet2DSurfacesColorFormatMthdCnt         1
#define sizeSet2DSurfacesColorFormat                2
#define nvglSet2DSurfacesColorFormat(ch, format)                            \
{                                                                           \
    if (pDriverData->bltData.dwLastColourFormat != format) {                \
        nvPushData (0, (((sizeSet2DSurfacesColorFormatMthdCnt << 2) << 16) | ((ch) << 13) | NV042_SET_COLOR_FORMAT)); \
        nvPushData (1, (format));                                           \
        nvPusherAdjust (sizeSet2DSurfacesColorFormat);                      \
        pDriverData->bltData.dwLastColourFormat = format;                   \
    }                                                                       \
}

#define sizeSet2DSurfacesPitchMthdCnt               1
#define sizeSet2DSurfacesPitch                      2
#define nvglSet2DSurfacesPitch(ch, srcpitch, dstpitch)                      \
{                                                                           \
DWORD dwCombinedPitch = ((((dstpitch) & 0x0000FFFF) << 16) | ((srcpitch) & 0x0000FFFF));   \
    if (pDriverData->bltData.dwLastCombinedPitch != dwCombinedPitch) {      \
        nvPushData (0, (((sizeSet2DSurfacesPitchMthdCnt << 2) << 16) | ((ch) << 13) | NV042_SET_PITCH)); \
        nvPushData (1, dwCombinedPitch);                                    \
        nvPusherAdjust (sizeSet2DSurfacesPitch);                            \
        pDriverData->bltData.dwLastCombinedPitch = dwCombinedPitch;         \
    }                                                                       \
}

#define sizeSet2DSurfacesDestinationMthdCnt         1
#define sizeSet2DSurfacesDestination                2
#define nvglSet2DSurfacesDestination(ch, offset)                            \
{                                                                           \
    if (pDriverData->bltData.dwLastDstOffset != offset) {                   \
        nvPushData (0, (((sizeSet2DSurfacesDestinationMthdCnt << 2) << 16) | ((ch) << 13) | NV042_SET_OFFSET_DESTIN)); \
        nvPushData (1, (offset));                                           \
        nvPusherAdjust (sizeSet2DSurfacesDestination);                      \
        pDriverData->bltData.dwLastDstOffset = offset;                      \
    }                                                                       \
}

//-------------------------------------------------------------------------
//                              NV 043
//                         NV03_CONTEXT_ROP
//-------------------------------------------------------------------------

#define sizeSetRop5MthdCnt                          1
#define sizeSetRop5                                 2
#define nvglSetRop5(ch, rop5)                                               \
{                                                                           \
    if (pDriverData->bltData.dwLastRop != rop5) {                           \
        nvPushData (0, (((sizeSetRop5MthdCnt << 2) << 16) | ((ch) << 13) | NV043_SET_ROP5)); \
        nvPushData (1, (rop5));                                             \
        nvPusherAdjust (sizeSetRop5);                                       \
        pDriverData->bltData.dwLastRop = rop5;                              \
    }                                                                       \
}

//-------------------------------------------------------------------------
//                              NV 044
//                       NV04_CONTEXT_PATTERN
//-------------------------------------------------------------------------

// 0x00000304
#define sizeSetNv4ContextPatternMonochromeFormatMthdCnt  1
#define sizeSetNv4ContextPatternMonochromeFormat         2
#define nvglSetNv4ContextPatternMonochromeFormat(ch, format)                \
{                                                                           \
    nvPushData (0, (((sizeSetNv4ContextPatternMonochromeFormatMthdCnt << 2) << 16) | ((ch) << 13) | NV044_SET_MONOCHROME_FORMAT)); \
    nvPushData (1, (format));                                               \
    nvPusherAdjust (sizeSetNv4ContextPatternMonochromeFormat);              \
}
// 0x00000308
#define sizeSetNv4ContextPatternMonochromeShapeMthdCnt  1
#define sizeSetNv4ContextPatternMonochromeShape         2
#define nvglSetNv4ContextPatternMonochromeShape(ch, shape)                  \
{                                                                           \
    nvPushData (0, (((sizeSetNv4ContextPatternMonochromeShapeMthdCnt << 2) << 16) | ((ch) << 13) | NV044_SET_MONOCHROME_SHAPE)); \
    nvPushData (1, (shape));                                                \
    nvPusherAdjust (sizeSetNv4ContextPatternMonochromeShape);               \
}
// 0x0000030c
#define sizeSetNv4ContextPatternPatternSelectMthdCnt  1
#define sizeSetNv4ContextPatternPatternSelect         2
#define nvglSetNv4ContextPatternPatternSelect(ch, select)                   \
{                                                                           \
    nvPushData (0, (((sizeSetNv4ContextPatternPatternSelectMthdCnt << 2) << 16) | ((ch) << 13) | NV044_SET_PATTERN_SELECT)); \
    nvPushData (1, (select));                                               \
    nvPusherAdjust (sizeSetNv4ContextPatternPatternSelect);                 \
}
// 0x00000310
#define sizeSetNv4ContextPatternMonochromeColorsMthdCnt  2
#define sizeSetNv4ContextPatternMonochromeColors         3
#define nvglSetNv4ContextPatternMonochromeColors(ch, c0, c1)                \
{                                                                           \
    nvPushData (0, (((sizeSetNv4ContextPatternMonochromeColorsMthdCnt << 2) << 16) | ((ch) << 13) | NV044_SET_MONOCHORME_COLOR0)); \
    nvPushData (1, (c0));                                                   \
    nvPushData (2, (c1));                                                   \
    nvPusherAdjust (sizeSetNv4ContextPatternMonochromeColors);              \
}
// 0x00000318
#define sizeSetNv4ContextPatternMonochromePatternsMthdCnt  2
#define sizeSetNv4ContextPatternMonochromePatterns         3
#define nvglSetNv4ContextPatternMonochromePatterns(ch, pattern0, pattern1)  \
{                                                                           \
    nvPushData (0, (((sizeSetNv4ContextPatternMonochromePatternsMthdCnt << 2) << 16) | ((ch) << 13) | NV044_SET_MONOCHORME_PATTERN0)); \
    nvPushData (1, (pattern0));                                             \
    nvPushData (2, (pattern1));                                             \
    nvPusherAdjust (sizeSetNv4ContextPatternMonochromePatterns);            \
}

//-------------------------------------------------------------------------
//                              NV 04A
//                     NV04_GDI_RECTANGLE_TEXT
//-------------------------------------------------------------------------

//0x00000300
#define sizeDrawRopRectAndTextSetColorFormatMthdCnt 1
#define sizeDrawRopRectAndTextSetColorFormat        2
#define nvglDrawRopRectAndTextSetColorFormat(ch, format)                    \
{                                                                           \
    nvPushData (0, (((sizeDrawRopRectAndTextSetColorFormatMthdCnt << 2) << 16) | ((ch) << 13) | NV04A_SET_COLOR_FORMAT)); \
    nvPushData (1, (format));                                               \
    nvPusherAdjust (sizeDrawRopRectAndTextSetColorFormat);                  \
}

//0x0000018C
#define sizeDrawRopRectAndTextSetROPMthdCnt 1
#define sizeDrawRopRectAndTextSetROP        2
#define nvglDrawRopRectAndTextSetROP(ch, rop)                               \
{                                                                           \
    nvPushData (0, (((sizeDrawRopRectAndTextSetROPMthdCnt << 2) << 16) | ((ch) << 13) | NV04A_SET_CONTEXT_ROP)); \
    nvPushData (1, (rop));                                                  \
    nvPusherAdjust (sizeDrawRopRectAndTextSetROP);                          \
}

//0x00000188
#define sizeDrawPatternRectAndTextSetPatternMthdCnt 1
#define sizeDrawPatternRectAndTextSetPattern        2
#define nvglDrawPatternRectAndTextSetPattern(ch, pattern)                   \
{                                                                           \
    nvPushData (0, (((sizeDrawPatternRectAndTextSetPatternMthdCnt << 2) << 16) | ((ch) << 13) | NV04A_SET_CONTEXT_PATTERN)); \
    nvPushData (1, (pattern));                                              \
    nvPusherAdjust (sizeDrawPatternRectAndTextSetPattern);                  \
}

//0x00000198
#define sizeDrawRopRectAndTextSetSurfaceMthdCnt 1
#define sizeDrawRopRectAndTextSetSurface        2
#define nvglDrawRopRectAndTextSetSurface(ch, surface)                       \
{                                                                           \
    nvPushData (0, (((sizeDrawRopRectAndTextSetSurfaceMthdCnt << 2) << 16) | ((ch) << 13) | NV04A_SET_CONTEXT_SURFACE)); \
    nvPushData (1, (surface));                                              \
    nvPusherAdjust (sizeDrawRopRectAndTextSetSurface);                      \
}

//0x000002FC
#define sizeDrawRopRectAndTextSetOperatioonMthdCnt 1
#define sizeDrawRopRectAndTextSetOperation         2
#define nvglDrawRopRectAndTextSetOperation(ch, operation)                   \
{                                                                           \
    nvPushData (0, (((sizeDrawRopRectAndTextSetOperatioonMthdCnt << 2) << 16) | ((ch) << 13) | NV04A_SET_OPERATION)); \
    nvPushData (1, (operation));                                            \
    nvPusherAdjust (sizeDrawRopRectAndTextSetOperation);                    \
}

#define sizeDrawRopRectAndTextColor1AMthdCnt        1
#define sizeDrawRopRectAndTextColor1A               2
#define nvglDrawRopRectAndTextColor1A(ch, color)                            \
{                                                                           \
    nvPushData (0, (((sizeDrawRopRectAndTextColor1AMthdCnt << 2) << 16) | ((ch) << 13) | NV04A_COLOR1_A)); \
    nvPushData (1, (color));                                                \
    nvPusherAdjust (sizeDrawRopRectAndTextColor1A);                         \
}

#define sizeDrawRopRectAndTextPointSizeMthdCnt      2
#define sizeDrawRopRectAndTextPointSize             3
#define nvglDrawRopRectAndTextPointSize(ch, x, y, width, height)            \
{                                                                           \
    nvPushData (0, (((sizeDrawRopRectAndTextPointSizeMthdCnt << 2) << 16) | ((ch) << 13) | NV04A_UNCLIPPED_RECTANGLE_POINT(0))); \
    nvPushData (1, ((((x) & 0x0000FFFF) << 16) | ((y) & 0x0000FFFF)));      \
    nvPushData (2, ((((width) & 0x0000FFFF) << 16) | ((height) & 0x0000FFFF))); \
    nvPusherAdjust (sizeDrawRopRectAndTextPointSize);                       \
}

//-------------------------------------------------------------------------
//                              NV 052
//                   NV04_CONTEXT_SURFACE_SWIZZLED
//-------------------------------------------------------------------------

#define sizeSetSwizzledSurfaceContextImageMthdCnt   1
#define sizeSetSwizzledSurfaceContextImage          2
#define nvglSetSwizzledSurfaceContextImage(ch, ctxdmaimage)                 \
{                                                                           \
    nvPushData (0, (((sizeSetSwizzledSurfaceContextImageMthdCnt << 2) << 16) | ((ch) << 13) | NV052_SET_CONTEXT_DMA_IMAGE)); \
    nvPushData (1, (ctxdmaimage));                                          \
    nvPusherAdjust (sizeSetSwizzledSurfaceContextImage);                    \
}

#define sizeSetSwizzledSurfaceMthdCnt        2
#define sizeSetSwizzledSurface               3
#define nvglSetSwizzledSurface(ch, format, offset)                          \
{                                                                           \
    nvPushData (0, (((sizeSetSwizzledSurfaceMthdCnt << 2) << 16) | ((ch) << 13) | NV052_SET_FORMAT)); \
    nvPushData (1, (format));                                               \
    nvPushData (2, (offset));                                               \
    nvPusherAdjust (sizeSetSwizzledSurface);                                \
}

//-------------------------------------------------------------------------
//                              NV 053
//                     NV04_CONTEXT_SURFACES_3D
//-------------------------------------------------------------------------

#define sizeSetRenderTargetContextsMthdCnt  2
#define sizeSetRenderTargetContexts         3
#define nvglSetRenderTargetContexts(ch, ctxdmacolor, ctxdmazeta)            \
{                                                                           \
    nvPushData (0, (((sizeSetRenderTargetContextsMthdCnt << 2) << 16) | ((ch) << 13) | NV053_SET_CONTEXT_DMA_COLOR)); \
    nvPushData (1, (ctxdmacolor));                                          \
    nvPushData (2, (ctxdmazeta));                                           \
    nvPusherAdjust (sizeSetRenderTargetContexts);                           \
}

#define sizeSetRenderTarget                 8
#define nvglSetRenderTarget(ch, cliphorizontal, clipvertical, format,       \
                            pitch, coloroffset, zetaoffset)                 \
{                                                                           \
    nvPushData (0, (((3 << 2) << 16) | ((ch) << 13) | NV053_SET_CLIP_HORIZONTAL)); \
    nvPushData (1, (cliphorizontal));                                       \
    nvPushData (2, (clipvertical));                                         \
    nvPushData (3, (format));                                               \
    nvPushData (4, (((3 << 2) << 16) | ((ch) << 13) | NV053_SET_PITCH));    \
    nvPushData (5, (pitch));                                                \
    nvPushData (6, (coloroffset));                                          \
    nvPushData (7, (zetaoffset));                                           \
    nvPusherAdjust (sizeSetRenderTarget);                                   \
}

#define sizeSetRenderTarget2MthdCnt         5
#define sizeSetRenderTarget2                6
#define nvglSetRenderTarget2(ch, format, clipsize, pitch,                   \
                             coloroffset, zetaoffset)                       \
{                                                                           \
    nvPushData (0, (((sizeSetRenderTarget2MthdCnt << 2) << 16) | ((ch) << 13) | NV053_SET_FORMAT)); \
    nvPushData (1, (format));                                               \
    nvPushData (2, (clipsize));                                             \
    nvPushData (3, (pitch));                                                \
    nvPushData (4, (coloroffset));                                          \
    nvPushData (5, (zetaoffset));                                           \
    nvPusherAdjust (sizeSetRenderTarget2);                                  \
}

#define sizeSetRenderTargetViewportMthdCnt  2
#define sizeSetRenderTargetViewport         3
#define nvglSetRenderTargetViewport(ch, cliphorizontal, clipvertical)       \
{                                                                           \
    nvPushData (0, (((sizeSetRenderTargetViewportMthdCnt << 2) << 16) | ((ch) << 13) | NV053_SET_CLIP_HORIZONTAL)); \
    nvPushData (1, (cliphorizontal));                                       \
    nvPushData (2, (clipvertical));                                         \
    nvPusherAdjust (sizeSetRenderTargetViewport);                           \
}

//-------------------------------------------------------------------------
//                              NV 054
//                     NV04_DX5_TEXTURED_TRIANGLE
//-------------------------------------------------------------------------

#define sizeSetDx5TriangleContextsMthdCnt   2
#define sizeSetDx5TriangleContexts          3
#define nvglSetDx5TriangleContexts(ch, ctxa, ctxb)                          \
{                                                                           \
    nvPushData (0, (((sizeSetDx5TriangleContextsMthdCnt << 2) << 16) | ((ch) << 13) | NV054_SET_CONTEXT_DMA_A)); \
    nvPushData (1, (ctxa));                                                 \
    nvPushData (2, (ctxb));                                                 \
    nvPusherAdjust (sizeSetDx5TriangleContexts);                            \
}

#define sizeSetDx5TriangleSurfaceMthdCnt    1
#define sizeSetDx5TriangleSurface           2
#define nvglSetDx5TriangleSurface(ch, ctxs)                                 \
{                                                                           \
    nvPushData (0, (((sizeSetDx5TriangleSurfaceMthdCnt << 2) << 16) | ((ch) << 13) | NV054_SET_CONTEXT_SURFACES)); \
    nvPushData (1, (ctxs));                                                 \
    nvPusherAdjust (sizeSetDx5TriangleSurface);                             \
}

#define sizeDx5TriangleStateMthdCnt         7
#define sizeDx5TriangleState                8
#define nvglDx5TriangleState(ch, ckey, offset, format, filter,              \
                             blend, control, fogcolor)                      \
{                                                                           \
    nvPushData (0, (((sizeDx5TriangleStateMthdCnt << 2) << 16) | ((ch) << 13) | NV054_COLOR_KEY)); \
    nvPushData (1, (ckey));                                                 \
    nvPushData (2, (offset));                                               \
    nvPushData (3, (format));                                               \
    nvPushData (4, (filter));                                               \
    nvPushData (5, (blend));                                                \
    nvPushData (6, (control));                                              \
    nvPushData (7, (fogcolor));                                             \
    nvPusherAdjust (sizeDx5TriangleState);                                  \
}

#define sizeDx5TriangleDrawPrimitiveMthdCnt 1
#define sizeDx5TriangleDrawPrimitive        2
#define nvglDx5TriangleDrawPrimitive(ch, alias, vertices)                   \
{                                                                           \
    nvPushData (0, (((sizeDx5TriangleDrawPrimitiveMthdCnt << 2) << 16) | ((ch) << 13) | NV054_DRAW_PRIMITIVE((alias)))); \
    nvPushData (1, (vertices));                                             \
    nvPusherAdjust (sizeDx5TriangleDrawPrimitive);                          \
}

#define sizeDx5TriangleNotify               4
#define nvglDx5TriangleNotify(ch)                                           \
{                                                                           \
    nvPushData (0, (((1 << 2) << 16) | ((ch) << 13) | NV054_NOTIFY));       \
    nvPushData (1, NV054_NOTIFY_WRITE_ONLY);                                \
    nvPushData (2, (((1 << 2) << 16) | ((ch) << 13) | NV054_NO_OPERATION)); \
    nvPushData (3, 0x00000000);                                             \
    nvPusherAdjust (sizeDx5TriangleNotify);                                 \
}

//-------------------------------------------------------------------------
//                              NV 055
//                   NV04_DX6_MULTI_TEXTURE_TRIANGLE
//-------------------------------------------------------------------------

#define sizeSetDx6TriangleContextsMthdCnt   2
#define sizeSetDx6TriangleContexts          3
#define nvglSetDx6TriangleContexts(ch, ctxa, ctxb)                          \
{                                                                           \
    nvPushData (0, (((sizeSetDx6TriangleContextsMthdCnt << 2) << 16) | ((ch) << 13) | NV055_SET_CONTEXT_DMA_A)); \
    nvPushData (1, (ctxa));                                                 \
    nvPushData (2, (ctxb));                                                 \
    nvPusherAdjust (sizeSetDx6TriangleContexts);                            \
}

#define sizeSetDx6TriangleSurfaceMthdCnt    1
#define sizeSetDx6TriangleSurface           2
#define nvglSetDx6TriangleSurface(ch, ctxs)                                 \
{                                                                           \
    nvPushData (0, (((sizeSetDx6TriangleSurfaceMthdCnt << 2) << 16) | ((ch) << 13) | NV055_SET_CONTEXT_SURFACES)); \
    nvPushData (1, (ctxs));                                                 \
    nvPusherAdjust (sizeSetDx6TriangleSurface);                             \
}

#define sizeDx6TriangleOffsetMthdCnt        1
#define sizeDx6TriangleOffset               2
#define nvglDx6TriangleOffset(ch, offset, buffer)                           \
{                                                                           \
    nvPushData (0, (((sizeDx6TriangleOffsetMthdCnt << 2) << 16) | ((ch) << 13) | NV055_OFFSET(buffer))); \
    nvPushData (1, (offset));                                               \
    nvPusherAdjust (sizeDx6TriangleOffset);                                 \
}

#define sizeDx6TriangleFormatMthdCnt        1
#define sizeDx6TriangleFormat               2
#define nvglDx6TriangleFormat(ch, format, buffer)                           \
{                                                                           \
    nvPushData (0, (((sizeDx6TriangleFormatMthdCnt << 2) << 16) | ((ch) << 13) | NV055_FORMAT(buffer))); \
    nvPushData (1, (format));                                               \
    nvPusherAdjust (sizeDx6TriangleFormat);                                 \
}

#define sizeDx6TriangleFilterMthdCnt        1
#define sizeDx6TriangleFilter               2
#define nvglDx6TriangleFilter(ch, filter, buffer)                           \
{                                                                           \
    nvPushData (0, (((sizeDx6TriangleFilterMthdCnt << 2) << 16) | ((ch) << 13) | NV055_FILTER(buffer))); \
    nvPushData (1, (filter));                                               \
    nvPusherAdjust (sizeDx6TriangleFilter);                                 \
}

#define sizeDx6TriangleStageState           12
#define nvglDx6TriangleStageState(ch, c0alpha, c0color, c1alpha, c1color,   \
                                  factor, blend,                            \
                                  control0, control1, control2,             \
                                  fogcolor)                                 \
{                                                                           \
    nvPushData (0, (((2 << 2) << 16) | ((ch) << 13) | NV055_COMBINE_0_ALPHA)); \
    nvPushData (1, (c0alpha));                                              \
    nvPushData (2, (c0color));                                              \
    nvPushData (3, (((8 << 2) << 16) | ((ch) << 13) | NV055_COMBINE_1_ALPHA)); \
    nvPushData (4, (c1alpha));                                              \
    nvPushData (5, (c1color));                                              \
    nvPushData (6, (factor));                                               \
    nvPushData (7, (blend));                                                \
    nvPushData (8, (control0));                                             \
    nvPushData (9, (control1));                                             \
    nvPushData (10, (control2));                                            \
    nvPushData (11, (fogcolor));                                            \
    nvPusherAdjust (sizeDx6TriangleStageState);                             \
}

#define sizeDX6TriangleState    (((sizeDx6TriangleOffset + sizeDx6TriangleFormat + sizeDx6TriangleFilter) * 2) + sizeDx6TriangleStageState)

#define sizeDx6TriangleTLVertexMthdCnt      10
#define sizeDx6TriangleTLVertex1            11
#define nvglDx6TriangleTLVertex(ch, alias, vd)                              \
{                                                                           \
    nvPushData (0, (((sizeDx6TriangleTLVertexMthdCnt << 2) << 16) | ((ch) << 13) | NV055_TLMTVERTEX((alias)))); \
    nvPushData (1, *(U032 *)&(vd.sx));                                      \
    nvPushData (2, *(U032 *)&(vd.sy));                                      \
    nvPushData (3, *(U032 *)&(vd.sz));                                      \
    nvPushData (4, *(U032 *)&(vd.rhw));                                     \
    nvPushData (5, (vd.color));                                             \
    nvPushData (6, (vd.specular));                                          \
    nvPushData (7, *(U032 *)&(vd.tu));                                      \
    nvPushData (8, *(U032 *)&(vd.tv));                                      \
    nvPushData (9, 0);                                                      \
    nvPushData (10, 0);                                                     \
    nvPusherAdjust (sizeDx6TriangleTLVertex1);                              \
    dbgDisplayVertexData(FALSE, (DWORD *)&(vd.sx));                         \
}

#define sizeDx6TriangleDrawPrimitiveMthdCnt 1
#define sizeDx6TriangleDrawPrimitive        2
#define nvglDx6TriangleDrawPrimitive(ch, alias, vertices)                   \
{                                                                           \
    nvPushData (0, (((sizeDx6TriangleDrawPrimitiveMthdCnt << 2) << 16) | ((ch) << 13) | NV055_DRAW_PRIMITIVE((alias)))); \
    nvPushData (1, (vertices));                                             \
    nvPusherAdjust (sizeDx6TriangleDrawPrimitive);                          \
}

//-------------------------------------------------------------------------
//                              NV 056
//                      NV10_CELSIUS_PRIMITIVE
//-------------------------------------------------------------------------
#if (NVARCH >= 0x010)
#define NV056_SET_VERTEX_FORMAT_SHADOW      NV056_SET_INVERSE_MODEL_VIEW_MATRIX1(15)

// 0x00000100
#define sizeSetNv10CelsiusNoOpMthdCnt    1
#define sizeSetNv10CelsiusNoOp           2
#define nvglSetNv10CelsiusNoOp(ch)                                          \
{                                                                           \
    nvPushData (0, (((sizeSetNv10CelsiusNoOpMthdCnt << 2) << 16) | ((ch) << 13) | NV056_NO_OPERATION)); \
    nvPushData (1, 0);                                                      \
    nvPusherAdjust (sizeSetNv10CelsiusNoOp);                                \
}
// 0x00000104
#define sizeSetNv10CelsiusNotifyMthdCnt    1
#define sizeSetNv10CelsiusNotify           2
#define nvglSetNv10CelsiusNotify(ch, type)                                  \
{                                                                           \
    nvPushData (0, (((sizeSetNv10CelsiusNotifyMthdCnt << 2) << 16) | ((ch) << 13) | NV056_NOTIFY)); \
    nvPushData (1, (type));                                                 \
    nvPusherAdjust (sizeSetNv10CelsiusNotify);                              \
}
// 0x00000180
#define sizeSetNv10CelsiusContextDMAsMthdCnt    7
#define sizeSetNv10CelsiusContextDMAs           8
#define nvglSetNv10CelsiusContextDMAs(ch, notifies, dmaa, dmab, vertex, state, color, zeta) \
{                                                                           \
    nvPushData (0, (((sizeSetNv10CelsiusContextDMAsMthdCnt << 2) << 16) | ((ch) << 13) | NV056_SET_CONTEXT_DMA_NOTIFIES)); \
    nvPushData (1, (notifies));                                             \
    nvPushData (2, (dmaa));                                                 \
    nvPushData (3, (dmab));                                                 \
    nvPushData (4, (vertex));                                               \
    nvPushData (5, (state));                                                \
    nvPushData (6, (color));                                                \
    nvPushData (7, (zeta));                                                 \
    nvPusherAdjust (sizeSetNv10CelsiusContextDMAs);                         \
}
// 0x00000180
#define sizeSetNv10CelsiusNotifierContextDMAMthdCnt    1
#define sizeSetNv10CelsiusNotifierContextDMA           2
#define nvglSetNv10CelsiusNotifierContextDMA(ch, notifies)                  \
{                                                                           \
    nvPushData (0, (((sizeSetNv10CelsiusNotifierContextDMAMthdCnt << 2) << 16) | ((ch) << 13) | NV056_SET_CONTEXT_DMA_NOTIFIES)); \
    nvPushData (1, (notifies));                                             \
    nvPusherAdjust (sizeSetNv10CelsiusNotifierContextDMA);                  \
}
// 0x00000184
#define sizeSetNv10CelsiusTextureAndVertexContextDMAsMthdCnt    3
#define sizeSetNv10CelsiusTextureAndVertexContextDMAs           4
#define nvglSetNv10CelsiusTextureAndVertexContextDMAs(ch, dmaa, dmab, vertex) \
{                                                                           \
    nvPushData (0, (((sizeSetNv10CelsiusTextureAndVertexContextDMAsMthdCnt << 2) << 16) | ((ch) << 13) | NV056_SET_CONTEXT_DMA_A)); \
    nvPushData (1, (dmaa));                                                 \
    nvPushData (2, (dmab));                                                 \
    nvPushData (3, (vertex));                                               \
    nvPusherAdjust (sizeSetNv10CelsiusTextureAndVertexContextDMAs);         \
}
// 0x0000072c
#define sizeSetNv10CelsiusEyeDirectionMthdCnt                   3
#define sizeSetNv10CelsiusEyeDirection                          4
#define nvglSetNv10CelsiusEyeDirection(ch, x, y, z)                         \
{                                                                           \
    float x1 = x, y1 = y, z1 = z;                                           \
    nvPushData (0, (((sizeSetNv10CelsiusEyeDirectionMthdCnt << 2) << 16) | ((ch) << 13) | NV056_SET_EYE_DIRECTION_SW(0))); \
    nvPushData (1, *(DWORD*)&x1);                                           \
    nvPushData (2, *(DWORD*)&y1);                                           \
    nvPushData (3, *(DWORD*)&z1);                                           \
    nvPusherAdjust (sizeSetNv10CelsiusEyeDirection);                        \
}
// 0x00000cf0
#define sizeSetNv10CelsiusInvalidateVertexCacheMthdCnt    1
#define sizeSetNv10CelsiusInvalidateVertexCache           2
#define nvglSetNv10CelsiusInvalidateVertexCache(ch)                         \
{                                                                           \
    nvPushData (0, (((sizeSetNv10CelsiusInvalidateVertexCacheMthdCnt << 2) << 16) | ((ch) << 13) | NV056_INVALIDATE_VERTEX_CACHE_FILE)); \
    nvPushData (1, 0);                                                      \
    nvPusherAdjust (sizeSetNv10CelsiusInvalidateVertexCache);               \
}
// 0x00000dfc
#define sizeSetNv10CelsiusBeginEndMthdCnt    1
#define sizeSetNv10CelsiusBeginEnd           2
#define nvglSetNv10CelsiusBeginEnd(ch, op)                                  \
{                                                                           \
    nvPushData (0, (((sizeSetNv10CelsiusBeginEndMthdCnt << 2) << 16) | ((ch) << 13) | NV056_SET_BEGIN_END)); \
    nvPushData (1, (op));                                                   \
    nvPusherAdjust (sizeSetNv10CelsiusBeginEnd);                            \
}
// 0x000010fc
#define sizeSetNv10CelsiusBeginEnd2MthdCnt    1
#define sizeSetNv10CelsiusBeginEnd2           2
#define nvglSetNv10CelsiusBeginEnd2(ch, op)                                  \
{                                                                           \
    nvPushData (0, (((sizeSetNv10CelsiusBeginEnd2MthdCnt << 2) << 16) | ((ch) << 13) | NV056_SET_BEGIN_END2)); \
    nvPushData (1, (op));                                                   \
    nvPusherAdjust (sizeSetNv10CelsiusBeginEnd2);                            \
}
// 0x000013fc
#define sizeSetNv10CelsiusBeginEnd3MthdCnt    1
#define sizeSetNv10CelsiusBeginEnd3           2
#define nvglSetNv10CelsiusBeginEnd3(ch, op)                                 \
{                                                                           \
    nvPushData (0, (((sizeSetNv10CelsiusBeginEnd3MthdCnt << 2) << 16) | ((ch) << 13) | NV056_SET_BEGIN_END3)); \
    nvPushData (1, (op));                                                   \
    nvPusherAdjust (sizeSetNv10CelsiusBeginEnd3);                           \
}
// 0x000017fc
#define sizeSetNv10CelsiusBeginEnd4MthdCnt    1
#define sizeSetNv10CelsiusBeginEnd4           2
#define nvglSetNv10CelsiusBeginEnd4(ch, op)                                 \
{                                                                           \
    nvPushData (0, (((sizeSetNv10CelsiusBeginEnd4MthdCnt << 2) << 16) | ((ch) << 13) | NV056_SET_BEGIN_END4)); \
    nvPushData (1, (op));                                                   \
    nvPusherAdjust (sizeSetNv10CelsiusBeginEnd4);                           \
}
// 0x00001400
#define sizeSetNv10CelsiusDrawArraysMthdCnt    1
#define sizeSetNv10CelsiusDrawArrays           2
#define nvglSetNv10CelsiusDrawArrays(ch, data)                              \
{                                                                           \
    nvPushData (0, (((sizeSetNv10CelsiusDrawArraysMthdCnt << 2) << 16) | ((ch) << 13) | NV056_DRAW_ARRAYS(0))); \
    nvPushData (1, (data));                                                 \
    nvPusherAdjust (sizeSetNv10CelsiusDrawArrays);                          \
}
#endif  // NVARCH >= 0x010

//-------------------------------------------------------------------------
//                              NV 097
//                       NV20_KELVIN_PRIMITIVE
//-------------------------------------------------------------------------
#if (NVARCH >= 0x020)
// 0x00000100
#define sizeSetNv20KelvinNoOpMthdCnt    1
#define sizeSetNv20KelvinNoOp           2
#define nvglSetNv20KelvinNoOp(ch)                                           \
{                                                                           \
    nvPushData (0, (((sizeSetNv20KelvinNoOpMthdCnt << 2) << 16) | ((ch) << 13) | NV097_NO_OPERATION)); \
    nvPushData (1, 0);                                                      \
    nvPusherAdjust (sizeSetNv20KelvinNoOp);                                 \
}
// 0x00000104
#define sizeSetNv20KelvinNotifyMthdCnt    1
#define sizeSetNv20KelvinNotify           2
#define nvglSetNv20KelvinNotify(ch, type)                                   \
{                                                                           \
    nvPushData (0, (((sizeSetNv20KelvinNotifyMthdCnt << 2) << 16) | ((ch) << 13) | NV097_NOTIFY)); \
    nvPushData (1, (type));                                                 \
    nvPusherAdjust (sizeSetNv20KelvinNotify);                               \
}
// 0x00000180
#define sizeSetNv20KelvinNotifierContextDMAMthdCnt    1
#define sizeSetNv20KelvinNotifierContextDMA           2
#define nvglSetNv20KelvinNotifierContextDMA(ch, notifies)                   \
{                                                                           \
    nvPushData (0, (((sizeSetNv20KelvinNotifierContextDMAMthdCnt << 2) << 16) | ((ch) << 13) | NV097_SET_CONTEXT_DMA_NOTIFIES)); \
    nvPushData (1, (notifies));                                             \
    nvPusherAdjust (sizeSetNv20KelvinNotifierContextDMA);                   \
}
// 0x00000180
#define sizeSetNv20KelvinContextDMAsMthdCnt1    3
#define sizeSetNv20KelvinContextDMAs1           4
#define sizeSetNv20KelvinContextDMAsMthdCnt2    7
#define sizeSetNv20KelvinContextDMAs2           8
#define nvglSetNv20KelvinContextDMAs(ch, notifies, dmaa, dmab, state, color, zeta, vertexa, vertexb, semaphore, report) \
{                                                                           \
    nvPushData (0, (((sizeSetNv20KelvinContextDMAsMthdCnt1 << 2) << 16) | ((ch) << 13) | NV097_SET_CONTEXT_DMA_NOTIFIES)); \
    nvPushData (1, (notifies));                                             \
    nvPushData (2, (dmaa));                                                 \
    nvPushData (3, (dmab));                                                 \
    nvPusherAdjust (sizeSetNv20KelvinContextDMAs1);                         \
    nvPushData (0, (((sizeSetNv20KelvinContextDMAsMthdCnt2 << 2) << 16) | ((ch) << 13) | NV097_SET_CONTEXT_DMA_STATE)); \
    nvPushData (1, (state));                                                \
    nvPushData (2, (color));                                                \
    nvPushData (3, (zeta));                                                 \
    nvPushData (4, (vertexa));                                              \
    nvPushData (5, (vertexb));                                              \
    nvPushData (6, (semaphore));                                            \
    nvPushData (7, (report));                                               \
    nvPusherAdjust (sizeSetNv20KelvinContextDMAs2);                         \
}
// 0x00000184
#define sizeSetNv20KelvinTextureContextDMAsMthdCnt    2
#define sizeSetNv20KelvinTextureContextDMAs           3
#define nvglSetNv20KelvinTextureContextDMAs(ch, dmaa, dmab)                 \
{                                                                           \
    nvPushData (0, (((sizeSetNv20KelvinTextureContextDMAsMthdCnt << 2) << 16) | ((ch) << 13) | NV097_SET_CONTEXT_DMA_A)); \
    nvPushData (1, (dmaa));                                                 \
    nvPushData (2, (dmab));                                                 \
    nvPusherAdjust (sizeSetNv20KelvinTextureContextDMAs);                   \
}
// 0x0000019c
#define sizeSetNv20KelvinVertexContextDMAsMthdCnt    2
#define sizeSetNv20KelvinVertexContextDMAs           3
#define nvglSetNv20KelvinVertexContextDMAs(ch, vertexa, vertexb)            \
{                                                                           \
    nvPushData (0, (((sizeSetNv20KelvinVertexContextDMAsMthdCnt << 2) << 16) | ((ch) << 13) | NV097_SET_CONTEXT_DMA_VERTEX_A)); \
    nvPushData (1, (vertexa));                                              \
    nvPushData (2, (vertexb));                                              \
    nvPusherAdjust (sizeSetNv20KelvinVertexContextDMAs);                    \
}
// 0x00001710
#define sizeSetNv20KelvinInvalidateVertexCacheMthdCnt    1
#define sizeSetNv20KelvinInvalidateVertexCache           2
#define nvglSetNv20KelvinInvalidateVertexCache(ch)                          \
{                                                                           \
    nvPushData (0, (((sizeSetNv20KelvinInvalidateVertexCacheMthdCnt << 2) << 16) | ((ch) << 13) | NV097_INVALIDATE_VERTEX_CACHE_FILE)); \
    nvPushData (1, 0);                                                      \
    nvPusherAdjust (sizeSetNv20KelvinInvalidateVertexCache);                \
}
// 0x000017fc
#define sizeSetNv20KelvinBeginEndMthdCnt    1
#define sizeSetNv20KelvinBeginEnd           2
#define nvglSetNv20KelvinBeginEnd(ch, op)                                   \
{                                                                           \
    nvPushData (0, (((sizeSetNv20KelvinBeginEndMthdCnt << 2) << 16) | ((ch) << 13) | NV097_SET_BEGIN_END)); \
    nvPushData (1, (op));                                                   \
    nvPusherAdjust (sizeSetNv20KelvinBeginEnd);                             \
}
// 0x00001810
#define sizeSetNv20KelvinDrawArraysMthdCnt    1
#define sizeSetNv20KelvinDrawArrays           2
#define nvglSetNv20KelvinDrawArrays(ch, data)                               \
{                                                                           \
    nvPushData (0, (((sizeSetNv20KelvinDrawArraysMthdCnt << 2) << 16) | ((ch) << 13) | NONINC_METHOD(NV097_DRAW_ARRAYS))); \
    nvPushData (1, (data));                                                 \
    nvPusherAdjust (sizeSetNv20KelvinDrawArrays);                           \
}

#endif // (NVARCH >= 0x020)

//-------------------------------------------------------------------------
//                              NV 05E
//                    NV04_RENDER_SOLID_RECTANGLE
//-------------------------------------------------------------------------

// 0x00000100
#define sizeSetNv4SolidRectangleNoOpMthdCnt    1
#define sizeSetNv4SolidRectangleNoOp           2
#define nvglSetNv4SolidRectangleNoOp(ch)                                    \
{                                                                           \
    nvPushData (0, (((sizeSetNv4SolidRectangleNoOpMthdCnt << 2) << 16) | ((ch) << 13) | NV05E_NO_OPERATION)); \
    nvPushData (1, 0);                                                      \
    nvPusherAdjust (sizeSetNv4SolidRectangleNoOp);                          \
}
// 0x00000184
#define sizeSetNv4SolidRectangleClipRectangleMthdCnt  1
#define sizeSetNv4SolidRectangleClipRectangle         2
#define nvglSetNv4SolidRectangleClipRectangle(ch, rect)                     \
{                                                                           \
    nvPushData (0, (((sizeSetNv4SolidRectangleClipRectangleMthdCnt << 2) << 16) | ((ch) << 13) | NV05E_SET_CONTEXT_CLIP_RECTANGLE)); \
    nvPushData (1, (rect));                                                 \
    nvPusherAdjust (sizeSetNv4SolidRectangleClipRectangle);                 \
}
// 0x00000188
#define sizeSetNv4SolidRectanglePatternMthdCnt  1
#define sizeSetNv4SolidRectanglePattern         2
#define nvglSetNv4SolidRectanglePattern(ch, pattern)                        \
{                                                                           \
    nvPushData (0, (((sizeSetNv4SolidRectanglePatternMthdCnt << 2) << 16) | ((ch) << 13) | NV05E_SET_CONTEXT_PATTERN)); \
    nvPushData (1, (pattern));                                              \
    nvPusherAdjust (sizeSetNv4SolidRectanglePattern);                       \
}
// 0x0000018c
#define sizeSetNv4SolidRectangleRopMthdCnt  1
#define sizeSetNv4SolidRectangleRop         2
#define nvglSetNv4SolidRectangleRop(ch, rop)                                \
{                                                                           \
    nvPushData (0, (((sizeSetNv4SolidRectangleRopMthdCnt << 2) << 16) | ((ch) << 13) | NV05E_SET_CONTEXT_ROP)); \
    nvPushData (1, (rop));                                                  \
    nvPusherAdjust (sizeSetNv4SolidRectangleRop);                           \
}
// 0x00000198
#define sizeSetNv4SolidRectangleSurfaceMthdCnt  1
#define sizeSetNv4SolidRectangleSurface         2
#define nvglSetNv4SolidRectangleSurface(ch, surface)                        \
{                                                                           \
    nvPushData (0, (((sizeSetNv4SolidRectangleSurfaceMthdCnt << 2) << 16) | ((ch) << 13) | NV05E_SET_CONTEXT_SURFACE)); \
    nvPushData (1, (surface));                                              \
    nvPusherAdjust (sizeSetNv4SolidRectangleSurface);                       \
}
// 0x000002fc
#define sizeSetNv4SolidRectangleOperationMthdCnt    1
#define sizeSetNv4SolidRectangleOperation           2
#define nvglSetNv4SolidRectangleOperation(ch, op)                           \
{                                                                           \
    nvPushData (0, (((sizeSetNv4SolidRectangleOperationMthdCnt << 2) << 16) | ((ch) << 13) | NV05E_SET_OPERATION)); \
    nvPushData (1, (op));                                                   \
    nvPusherAdjust (sizeSetNv4SolidRectangleOperation);                     \
}
// 0x00000300
#define sizeSetNv4SolidRectangleColorFormatMthdCnt  1
#define sizeSetNv4SolidRectangleColorFormat         2
#define nvglSetNv4SolidRectangleColorFormat(ch, cfmt)                       \
{                                                                           \
    nvPushData (0, (((sizeSetNv4SolidRectangleColorFormatMthdCnt << 2) << 16) | ((ch) << 13) | NV05E_SET_COLOR_FORMAT)); \
    nvPushData (1, (cfmt));                                                 \
    nvPusherAdjust (sizeSetNv4SolidRectangleColorFormat);                   \
}
// 0x00000304
#define sizeNv4SolidRectangleColorMthdCnt           1
#define sizeNv4SolidRectangleColor                  2
#define nvglNv4SolidRectangleColor(ch, color)                               \
{                                                                           \
    nvPushData (0, (((sizeNv4SolidRectangleColorMthdCnt << 2) << 16) | ((ch) << 13) | NV05E_COLOR)); \
    nvPushData (1, (color));                                                \
    nvPusherAdjust (sizeNv4SolidRectangleColor);                            \
}
// 0x00000400
#define sizeNv4SolidRectanglePointSizeMthdCnt       2
#define sizeNv4SolidRectanglePointSize              3
#define nvglNv4SolidRectanglePointSize(ch, x, y, width, height)             \
{                                                                           \
    nvPushData (0, (((sizeNv4SolidRectanglePointSizeMthdCnt << 2) << 16) | ((ch) << 13) | NV05E_RECTANGLE(0))); \
    nvPushData (1, ((((y) & 0x0000FFFF) << 16) | ((x) & 0x0000FFFF)));      \
    nvPushData (2, ((((height) & 0x0000FFFF) << 16) | ((width) & 0x0000FFFF))); \
    nvPusherAdjust (sizeNv4SolidRectanglePointSize);                        \
}

//-------------------------------------------------------------------------
//                              NV 05F
//                         NV04_IMAGE_BLIT
//-------------------------------------------------------------------------

// 0x00000188
#define sizeSetNv4ImageBlitClipRectangleMthdCnt     1
#define sizeSetNv4ImageBlitClipRectangle            2
#define nvglSetNv4ImageBlitClipRectangle(ch, rect)                          \
{                                                                           \
    nvPushData (0, (((sizeSetNv4ImageBlitClipRectangleMthdCnt << 2) << 16) | ((ch) << 13) | NV05F_SET_CONTEXT_CLIP_RECTANGLE)); \
    nvPushData (1, (rect));                                                 \
    nvPusherAdjust (sizeSetNv4ImageBlitClipRectangle);                      \
}
// 0x0000018c
#define sizeSetNv4ImageBlitContextPatternMthdCnt     1
#define sizeSetNv4ImageBlitContextPattern            2
#define nvglSetNv4ImageBlitContextPattern(ch, pattern)                      \
{                                                                           \
    nvPushData (0, (((sizeSetNv4ImageBlitContextPatternMthdCnt << 2) << 16) | ((ch) << 13) | NV05F_SET_CONTEXT_PATTERN)); \
    nvPushData (1, (pattern));                                              \
    nvPusherAdjust (sizeSetNv4ImageBlitContextPattern);                     \
}
// 0x00000190
#define sizeSetNv4ImageBlitContextRopMthdCnt     1
#define sizeSetNv4ImageBlitContextRop            2
#define nvglSetNv4ImageBlitContextRop(ch, rop)                              \
{                                                                           \
    nvPushData (0, (((sizeSetNv4ImageBlitContextRopMthdCnt << 2) << 16) | ((ch) << 13) | NV05F_SET_CONTEXT_ROP)); \
    nvPushData (1, (rop));                                                  \
    nvPusherAdjust (sizeSetNv4ImageBlitContextRop);                         \
}
// 0x0000019c
#define sizeSetNv4ImageBlitContextSurfacesMthdCnt     1
#define sizeSetNv4ImageBlitContextSurfaces            2
#define nvglSetNv4ImageBlitContextSurfaces(ch, surface)                     \
{                                                                           \
    nvPushData (0, (((sizeSetNv4ImageBlitContextSurfacesMthdCnt << 2) << 16) | ((ch) << 13) | NV05F_SET_CONTEXT_SURFACES)); \
    nvPushData (1, (surface));                                              \
    nvPusherAdjust (sizeSetNv4ImageBlitContextSurfaces);                    \
}
// 0x000002fc
#define sizeSetNv4ImageBlitOperationMthdCnt     1
#define sizeSetNv4ImageBlitOperation            2
#define nvglSetNv4ImageBlitOperation(ch, op)                                \
{                                                                           \
    nvPushData (0, (((sizeSetNv4ImageBlitOperationMthdCnt << 2) << 16) | ((ch) << 13) | NV05F_SET_OPERATION)); \
    nvPushData (1, (op));                                                   \
    nvPusherAdjust (sizeSetNv4ImageBlitOperation);                          \
}
// 0x00000300
#define sizeSetNv4ImageBlitControlPointsMthdCnt     2
#define sizeSetNv4ImageBlitControlPoints            3
#define nvglSetNv4ImageBlitControlPoints(ch, xin, yin, xout, yout)          \
{                                                                           \
    nvPushData (0, (((sizeSetNv4ImageBlitControlPointsMthdCnt << 2) << 16) | ((ch) << 13) | NV05F_CONTROL_POINT_IN)); \
    nvPushData (1, (((xin)  & 0xffff) | ((yin)  << 16)));                   \
    nvPushData (2, (((xout) & 0xffff) | ((yout) << 16)));                   \
    nvPusherAdjust (sizeSetNv4ImageBlitControlPoints);                      \
}
// 0x00000308
#define sizeSetNv4ImageBlitSizeMthdCnt     1
#define sizeSetNv4ImageBlitSize            2
#define nvglSetNv4ImageBlitSize(ch, width, height)                          \
{                                                                           \
    nvPushData (0, (((sizeSetNv4ImageBlitSizeMthdCnt << 2) << 16) | ((ch) << 13) | NV05F_SIZE)); \
    nvPushData (1, (((width)  & 0xffff) | ((height)  << 16)));              \
    nvPusherAdjust (sizeSetNv4ImageBlitSize);                               \
}

//-------------------------------------------------------------------------
//                              NV 060
//                    NV04_INDEXED_IMAGE_FROM_CPU
//-------------------------------------------------------------------------

#define sizeSetIndexedImageDmaNotifiesMthdCnt           1
#define sizeSetIndexedImageDmaNotifies                  2
#define nvglSetIndexedImageDmaNotifies(ch, ctxdmanotify)                    \
{                                                                           \
    nvPushData (0, (((sizeSetIndexedImageDmaNotifiesMthdCnt << 2) << 16) | ((ch) << 13) | NV060_SET_CONTEXT_DMA_NOTIFIES)); \
    nvPushData (1, (ctxdmanotify));                                         \
    nvPusherAdjust (sizeSetIndexedImageDmaNotifies);                        \
}

#define sizeSetIndexedImageContextDmaLUTMthdCnt           1
#define sizeSetIndexedImageContextDmaLUT                  2
#define nvglSetIndexedImageContextDmaLUT(ch, handle)                        \
{                                                                           \
    nvPushData (0, (((sizeSetIndexedImageContextDmaLUTMthdCnt << 2) << 16) | ((ch) << 13) | NV060_SET_CONTEXT_DMA_LUT)); \
    nvPushData (1, (handle));                                               \
    nvPusherAdjust (sizeSetIndexedImageContextDmaLUT);                      \
}

#define sizeSetIndexedImageContextSurfaceMthdCnt        1
#define sizeSetIndexedImageContextSurface               2
#define nvglSetIndexedImageContextSurface(ch, surface)                      \
{                                                                           \
    nvPushData (0, (((sizeSetIndexedImageContextSurfaceMthdCnt << 2) << 16) | ((ch) << 13) | NV060_SET_CONTEXT_SURFACE)); \
    nvPushData (1, (surface));                                              \
    nvPusherAdjust (sizeSetIndexedImageContextSurface);                     \
}

#define sizeSetIndexedImageOperationMthdCnt     1
#define sizeSetIndexedImageOperation            2
#define nvglSetIndexedImageOperation(ch, operation)                         \
{                                                                           \
    nvPushData (0, (((sizeSetIndexedImageOperationMthdCnt << 2) << 16) | ((ch) << 13) | NV060_SET_OPERATION)); \
    nvPushData (1, (operation));                                            \
    nvPusherAdjust (sizeSetIndexedImageOperation);                          \
}

#define sizeSetIndexedImageColorFormatMthdCnt   1
#define sizeSetIndexedImageColorFormat          2
#define nvglSetIndexedImageColorFormat(ch, colorformat)                     \
{                                                                           \
    nvPushData (0, (((sizeSetIndexedImageColorFormatMthdCnt << 2) << 16) | ((ch) << 13) | NV060_SET_COLOR_FORMAT)); \
    nvPushData (1, (colorformat));                                          \
    nvPusherAdjust (sizeSetIndexedImageColorFormat);                        \
}

#define sizeSetIndexedImageIndexFormatMthdCnt   1
#define sizeSetIndexedImageIndexFormat          2
#define nvglSetIndexedImageIndexFormat(ch, indexformat)                     \
{                                                                           \
    nvPushData (0, (((sizeSetIndexedImageIndexFormatMthdCnt << 2) << 16) | ((ch) << 13) | NV060_INDEX_FORMAT)); \
    nvPushData (1, (indexformat));                                          \
    nvPusherAdjust (sizeSetIndexedImageIndexFormat);                        \
}

#define sizeSetIndexedImageLUTOffsetMthdCnt     1
#define sizeSetIndexedImageLUTOffset            2
#define nvglSetIndexedImageLUTOffset(ch, offset)                            \
{                                                                           \
    nvPushData (0, (((sizeSetIndexedImageLUTOffsetMthdCnt << 2) << 16) | ((ch) << 13) | NV060_LUT_OFFSET)); \
    nvPushData (1, (offset));                                               \
    nvPusherAdjust (sizeSetIndexedImageLUTOffset);                          \
}

//-------------------------------------------------------------------------
//                              NV 077
//                   NV04_SCALED_IMAGE_FROM_MEMORY
//-------------------------------------------------------------------------

#define sizeSetScaledImageContextNotifiesMthdCnt    1
#define sizeSetScaledImageContextNotifies           2
#define nvglSetScaledImageContextNotifies(ch, ctxdmanotify)                 \
{                                                                           \
    nvPushData (0, (((sizeSetScaledImageContextNotifiesMthdCnt << 2) << 16) | ((ch) << 13) | NV077_SET_CONTEXT_DMA_NOTIFIES)); \
    nvPushData (1, (ctxdmanotify));                                         \
    nvPusherAdjust (sizeSetScaledImageContextNotifies);                     \
}

#define sizeSetScaledImageContextImageMthdCnt       1
#define sizeSetScaledImageContextImage              2
#define nvglSetScaledImageContextImage(ch, ctxdmaimage)                     \
{                                                                           \
    nvPushData (0, (((sizeSetScaledImageContextImageMthdCnt << 2) << 16) | ((ch) << 13) | NV077_SET_CONTEXT_DMA_IMAGE)); \
    nvPushData (1, (ctxdmaimage));                                          \
    nvPusherAdjust (sizeSetScaledImageContextImage);                        \
}

#define sizeSetScaledImageContextSurfaceMthdCnt     1
#define sizeSetScaledImageContextSurface            2
#define nvglSetScaledImageContextSurface(ch, ctxdmasurface)                 \
{                                                                           \
    nvPushData (0, (((sizeSetScaledImageContextSurfaceMthdCnt << 2) << 16) | ((ch) << 13) | NV077_SET_CONTEXT_SURFACE)); \
    nvPushData (1, (ctxdmasurface));                                        \
    nvPusherAdjust (sizeSetScaledImageContextSurface);                      \
}

#define sizeSetScaledImageFormatMthdCnt             1
#define sizeSetScaledImageFormat                    2
#define nvglSetScaledImageFormat(ch, format)                                \
{                                                                           \
    nvPushData (0, (((sizeSetScaledImageFormatMthdCnt << 2) << 16) | ((ch) << 13) | NV077_SET_COLOR_FORMAT)); \
    nvPushData (1, (format));                                               \
    nvPusherAdjust (sizeSetScaledImageFormat);                              \
}

#define sizeSetScaledImageOperationMthdCnt          1
#define sizeSetScaledImageOperation                 2
#define nvglSetScaledImageOperation(ch, operation)                          \
{                                                                           \
    nvPushData (0, (((sizeSetScaledImageOperationMthdCnt << 2) << 16) | ((ch) << 13) | NV077_SET_OPERATION)); \
    nvPushData (1, (operation));                                            \
    nvPusherAdjust (sizeSetScaledImageOperation);                           \
}

#define sizeScaledImageClipMthdCnt                  2
#define sizeScaledImageClip                         3
#define nvglScaledImageClip(ch, x, y, width, height)                        \
{                                                                           \
    nvPushData (0, (((sizeScaledImageClipMthdCnt << 2) << 16) | ((ch) << 13) | NV077_CLIP_POINT)); \
    nvPushData (1, ((((y) & 0x0000FFFF) << 16) | ((x) & 0x0000FFFF)));      \
    nvPushData (2, ((((height) & 0x0000FFFF) << 16) | ((width) & 0x0000FFFF))); \
    nvPusherAdjust (sizeScaledImageClip);                                   \
}

#define sizeScaledImageOutMthdCnt                   2
#define sizeScaledImageOut                          3
#define nvglScaledImageOut(ch, x, y, width, height)                         \
{                                                                           \
    nvPushData (0, (((sizeScaledImageOutMthdCnt << 2) << 16) | ((ch) << 13) | NV077_IMAGE_OUT_POINT)); \
    nvPushData (1, ((((y) & 0x0000FFFF) << 16) | ((x) & 0x0000FFFF)));      \
    nvPushData (2, ((((height) & 0x0000FFFF) << 16) | ((width) & 0x0000FFFF))); \
    nvPusherAdjust (sizeScaledImageOut);                                    \
}

#define sizeScaledImageDeltaDuDxDvDyMthdCnt         2
#define sizeScaledImageDeltaDuDxDvDy                3
#define nvglScaledImageDeltaDuDxDvDy(ch, dudx, dvdy)                        \
{                                                                           \
    nvPushData (0, (((sizeScaledImageDeltaDuDxDvDyMthdCnt << 2) << 16) | ((ch) << 13) | NV077_DELTA_DU_DX)); \
    nvPushData (1, (dudx));                                                 \
    nvPushData (2, (dvdy));                                                 \
    nvPusherAdjust (sizeScaledImageDeltaDuDxDvDy);                          \
}

#define sizeScaledImageInSizeMthdCnt                1
#define sizeScaledImageInSize                       2
#define nvglScaledImageInSize(ch, width, height)                            \
{                                                                           \
    nvPushData (0, (((sizeScaledImageInSizeMthdCnt << 2) << 16) | ((ch) << 13) | NV077_IMAGE_IN_SIZE)); \
    nvPushData (1, ((((height) & 0x0000FFFF) << 16) | ((width) & 0x0000FFFF))); \
    nvPusherAdjust (sizeScaledImageInSize);                                 \
}

#define sizeScaledImageInFormatMthdCnt              1
#define sizeScaledImageInFormat                     2
#define nvglScaledImageInFormat(ch, format)                                 \
{                                                                           \
    nvPushData (0, (((sizeScaledImageInFormatMthdCnt << 2) << 16) | ((ch) << 13) | NV077_IMAGE_IN_FORMAT)); \
    nvPushData (1, (format));                                               \
    nvPusherAdjust (sizeScaledImageInFormat);                               \
}

#define sizeScaledImageInOffsetMthdCnt              1
#define sizeScaledImageInOffset                     2
#define nvglScaledImageInOffset(ch, offset)                                 \
{                                                                           \
    nvPushData (0, (((sizeScaledImageInOffsetMthdCnt << 2) << 16) | ((ch) << 13) | NV077_IMAGE_IN_OFFSET)); \
    nvPushData (1, (offset));                                               \
    nvPusherAdjust (sizeScaledImageInOffset);                               \
}

#define sizeScaledImageInPointMthdCnt               1
#define sizeScaledImageInPoint                      2
#define nvglScaledImageInPoint(ch, x, y)                                    \
{                                                                           \
    nvPushData (0, (((sizeScaledImageInPointMthdCnt << 2) << 16) | ((ch) << 13) | NV077_IMAGE_IN)); \
    nvPushData (1, ((((y) & 0x0000FFFF) << 16) | ((x) & 0x0000FFFF))); \
    nvPusherAdjust (sizeScaledImageInPoint); \
}

#define sizeScaledImageNotify                       4
#define nvglScaledImageNotify(ch)                                           \
{                                                                           \
    nvPushData (0, (((1 << 2) << 16) | ((ch) << 13) | NV077_NOTIFY));       \
    nvPushData (1, NV077_NOTIFY_WRITE_ONLY);                                \
    nvPushData (2, (((1 << 2) << 16) | ((ch) << 13) | NV077_NO_OPERATION)); \
    nvPushData (3, 0);                                                      \
    nvPusherAdjust (sizeScaledImageNotify);                                 \
}

//-------------------------------------------------------------------------
//                              NV 07C
//                     NV15_VIDEO_LUT_CURSOR_DAC
//-------------------------------------------------------------------------

// 0x00000300
#define sizeSetNv15VideoLUTCursorDACImageDataMthdCnt   2
#define sizeSetNv15VideoLUTCursorDACImageData          3
#define nvglSetNv15VideoLUTCursorDACImageData(ch, index, offset, format)    \
{                                                                           \
    nvPushData (0, (((sizeSetNv15VideoLUTCursorDACImageDataMthdCnt << 2) << 16) | ((ch) << 13) | NV07C_SET_IMAGE_OFFSET(index))); \
    nvPushData (1, offset);                                                 \
    nvPushData (2, format);                                                 \
    nvPusherAdjust (sizeSetNv15VideoLUTCursorDACImageData);                 \
}

//-------------------------------------------------------------------------
//                              NV 096
//                      NV15_CELSIUS_PRIMITIVE
//-------------------------------------------------------------------------

// 0x00000120
#define sizeSetNv15CelsiusSyncSetRWMMthdCnt        3
#define sizeSetNv15CelsiusSyncSetRWM               4
#define nvglSetNv15CelsiusSyncSetRWM(ch, read, write, modulo)               \
{                                                                           \
    nvPushData (0, (((sizeSetNv15CelsiusSyncSetRWMMthdCnt << 2) << 16) | ((ch) << 13) | NV096_SYNC_SET_READ)); \
    nvPushData (1, (read));                                                 \
    nvPushData (2, (write));                                                \
    nvPushData (3, (modulo));                                               \
    nvPusherAdjust (sizeSetNv15CelsiusSyncSetRWM);                          \
}
// 0x0000012c
#define sizeSetNv15CelsiusSyncIncWriteMthdCnt      1
#define sizeSetNv15CelsiusSyncIncWrite             2
#define nvglSetNv15CelsiusSyncIncWrite(ch)                                  \
{                                                                           \
    nvPushData (0, (((sizeSetNv15CelsiusSyncIncWriteMthdCnt << 2) << 16) | ((ch) << 13) | NV096_SYNC_INCREMENT_WRITE)); \
    nvPushData (1, 0);                                                      \
    nvPusherAdjust (sizeSetNv15CelsiusSyncIncWrite);                        \
}
// 0x00000130
#define sizeSetNv15CelsiusSyncStallMthdCnt         1
#define sizeSetNv15CelsiusSyncStall                2
#define nvglSetNv15CelsiusSyncStall(ch)                                     \
{                                                                           \
    nvPushData (0, (((sizeSetNv15CelsiusSyncStallMthdCnt << 2) << 16) | ((ch) << 13) | NV096_SYNC_STALL)); \
    nvPushData (1, 0);                                                      \
    nvPusherAdjust (sizeSetNv15CelsiusSyncStall);                           \
}

#ifdef __cplusplus
}
#endif // __cplusplus

#endif // _NV4DMAC_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\common\inc\nvdbg.h ===
// **************************************************************************
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// ********************************* NV Common ******************************
//
//  Module: nvDbg.h
//      Shared debugging routines for printing, tracing, etc.
//
// **************************************************************************
//
//  History:
//      Matt Lavoie             18Nov00         extracted from d3d
//      Craig Duttweiler        21Nov00         major rehash
//
// **************************************************************************

#ifndef _NVDBG_H_
#define _NVDBG_H_

#ifdef __cplusplus
extern "C" {
#endif

#include "NvTypes.h"

//-------------------------------------------------------------------------
// GLOBAL VARIABLES
//-------------------------------------------------------------------------

#ifdef DEBUG

    extern  int       dbgTrace;   // function call tracing
    extern  NvU32     dbgLevel;   // DPF printing control
    extern  NvU32     dbgLog;     // log DPFs to a file (TRUE/FALSE)
    #define NVDBG_TRACE_EXIT 0x10000000  // prints '.' on function exit

#else

    #define dbgTrace  0
    #define dbgLevel  0
    #define dbgLog    0

#endif

//-------------------------------------------------------------------------
// DEFINTIONS
//-------------------------------------------------------------------------

// printing defaults

#define DPF_START_STR  "NV: "
#define DPF_END_STR    "\r\n"
#define DPF_LOG_FILE   "\\nv.log"

// tracing defaults

#define NV_TRACE_MAX_COLS  76
#define NV_TRACE_MAX_DEPTH 20
#define NV_TRACE_START_STR "TRACE: "

//-------------------------------------------------------------------------
// PROTOTYPES
//-------------------------------------------------------------------------

// debug printing

void __cdecl PF (char *szFormat, ...);      // Available in Debug and Non-Debug Builds

#ifdef DEBUG

    void __cdecl DPF             (char *szFormat, ...);
    void __cdecl DPF_PLAIN       (char *szFormat, ...);
    void __cdecl DPF_LEVEL       (NvU32 dwLevel, char * szFormat, ...);
    void __cdecl DPF_LEVEL_PLAIN (NvU32 dwLevel, char * szFormat, ...);

#else  // !DEBUG

    #define DPF                  1 ? (void)0 : (void)
    #define DPF_PLAIN            1 ? (void)0 : (void)
    #define DPF_LEVEL            1 ? (void)0 : (void)
    #define DPF_LEVEL_PLAIN      1 ? (void)0 : (void)

#endif  // !DEBUG

// tracing

#ifdef DEBUG

    void __cdecl dbgTracePush       (char *szFormat, ...);
    void __cdecl dbgTracePop        (void);
    void __cdecl dbgResetTraceLevel (void);

#elif INSTRUMENT_ALL_CALLS

    void __cdecl dbgTracePush       (char *szFormat, ...);
    void __cdecl dbgTracePop        (void);
    #define      dbgResetTraceLevel()

#else  // !DEBUG && !INSTRUMENT_ALL_CALLS

    #define      dbgTracePush       1 ? (void)0 : (void)
    #define      dbgTracePop()
    #define      dbgResetTraceLevel()

#endif  // !DEBUG && !INSTRUMENT_ALL_CALLS

#ifdef HAVE_NV_FILE_FACILITY
void __cdecl createDPFLog();
void __cdecl closeDPFLog();
#endif


//---------------------------------------------------------------------------
// ERROR HANDLING
//---------------------------------------------------------------------------

#ifdef DEBUG

    int _nvAssertReport(const char *pszExpr, const char *pszFile, const int nLine);

    // The do-while is there so that an nvAssert w/o a semi will not compile
    #define nvAssert(expr)                                                      \
    do {                                                                        \
        if (!(expr) && (_nvAssertReport(#expr, __FILE__, __LINE__)))    \
            _asm int 3                                                          \
    } while(0)

#else  // !DEBUG

    #define nvAssert(expr) ((void)0)

#endif  // !DEBUG

// override normal assert
#undef  assert
#define assert nvAssert

//---------------------------------------------------------------------------

#ifdef DEBUG

    #define dbgError(string)                                                    \
    {                                                                           \
        DPF (string);                                                           \
        _asm int 3                                                              \
    }

#else  // !DEBUG

    #define dbgError(a)

#endif  // !DEBUG

#ifdef __cplusplus
}
#endif // __cplusplus

#endif // _NVDBG_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\common\inc\nvEscDef.h ===
/*
 * nvEscDef.h
 *
 * Provides definitions for nVidia ExtEscape calls into display driver.
 *
 * Copyright (c) 1998, Nvidia Corporation.  All rights reserved.
 * Portions Copyright (c) 1996, 1997, Silicon Graphics Inc.
 *
 * THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
 * NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
 * IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
 */

#ifndef NV_ESC_DEF_INCLUDED
#define NV_ESC_DEF_INCLUDED


////////////////////////////////////////////////////////////////////////
// nVidia private escapes

////////////////////////////////////////////////////////////////////////
// Bit to distinguish between 32 and 64 bit process
// (Make them the same for now until implementation is complete).

#define NV_ESC_64_BASE                  0x0000
#define NV_ESC_32_BASE                  0x0000

#if defined(_WIN64)
#define NV_ESC_BASE                     NV_ESC_64_BASE
#else
#define NV_ESC_BASE                     NV_ESC_32_BASE
#endif

////////////////////////////////////////////////////////////////////////
// Escapes destined for the Resource Manager

#ifdef UNIX
#define NV_ESC_RM_BASE                  0x0000
#else
#define NV_ESC_RM_BASE                  0x7000
#endif

#define NV_ESC_RM_OPEN                  (NV_ESC_RM_BASE + 0x20)
#define NV_ESC_RM_CLOSE                 (NV_ESC_RM_BASE + 0x21)
#define NV_ESC_RM_ALLOC_ROOT            (NV_ESC_RM_BASE + 0x22)
#define NV_ESC_RM_ALLOC_DEVICE          (NV_ESC_RM_BASE + 0x23)
#define NV_ESC_RM_ALLOC_CONTEXT_DMA     (NV_ESC_RM_BASE + 0x24)
#define NV_ESC_RM_ALLOC_CHANNEL_PIO     (NV_ESC_RM_BASE + 0x25)
#define NV_ESC_RM_ALLOC_CHANNEL_DMA     (NV_ESC_RM_BASE + 0x26)
#define NV_ESC_RM_ALLOC_MEMORY          (NV_ESC_RM_BASE + 0x27)
#define NV_ESC_RM_ALLOC_OBJECT          (NV_ESC_RM_BASE + 0x28)
#define NV_ESC_RM_FREE                  (NV_ESC_RM_BASE + 0x29)
#define NV_ESC_RM_DMA_PUSH_INFO         (NV_ESC_RM_BASE + 0x2A)
#define NV_ESC_RM_ALLOC                 (NV_ESC_RM_BASE + 0x2B)
#define NV_ESC_RM_CONFIG_VERSION        (NV_ESC_RM_BASE + 0x31)
#define NV_ESC_RM_CONFIG_GET            (NV_ESC_RM_BASE + 0x32)
#define NV_ESC_RM_CONFIG_SET            (NV_ESC_RM_BASE + 0x33)
#define NV_ESC_RM_CONFIG_UPDATE         (NV_ESC_RM_BASE + 0x34)
#define NV_ESC_RM_ARCH_HEAP             (NV_ESC_RM_BASE + 0x35)
#define NV_ESC_RM_DEBUG_CONTROL         (NV_ESC_RM_BASE + 0x36)
#define NV_ESC_RM_CONFIG_GET_EX         (NV_ESC_RM_BASE + 0x37)
#define NV_ESC_RM_CONFIG_SET_EX         (NV_ESC_RM_BASE + 0x38)
#define NV_ESC_RM_I2C_ACCESS            (NV_ESC_RM_BASE + 0x39)
#define NV_ESC_RM_POWER_MANAGEMENT      (NV_ESC_RM_BASE + 0x3A)
#define NV_ESC_RM_INTERRUPT             (NV_ESC_RM_BASE + 0x3B)
#define NV_ESC_RM_OS_CONFIG_GET         (NV_ESC_RM_BASE + 0x3C)
#define NV_ESC_RM_OS_CONFIG_SET         (NV_ESC_RM_BASE + 0x3D)
#define NV_ESC_RM_OS_CONFIG_GET_EX      (NV_ESC_RM_BASE + 0x3E)
#define NV_ESC_RM_OS_CONFIG_SET_EX      (NV_ESC_RM_BASE + 0x3F)
#define NV_ESC_RM_NVWATCH               (NV_ESC_RM_BASE + 0x40)
#define NV_ESC_RM_ALLOC_EVENT           (NV_ESC_RM_BASE + 0x44)

#ifdef UNIX
#define NV_ESC_RM_AGP_INIT              (NV_ESC_RM_BASE + 0x45)
#define NV_ESC_RM_AGP_TEARDOWN          (NV_ESC_RM_BASE + 0x46)
#define NV_ESC_RM_IO_FLUSH              (NV_ESC_RM_BASE + 0x47)
#endif
#define NV_ESC_RM_SWAP_EXT              (NV_ESC_RM_BASE + 0x49)

////////////////////////////////////////////////////////////////////////
// Nvidia OpenGL client information.

#define WNDOBJ_SETUP                            4354

#define ESC_NV_OPENGL_DMA_PUSH_GO               0x7001

#define ESC_NV_OPENGL_ESCAPE                      0x7101 // nVidia OpenGL escape
#define ESC_NV_OPENGL_DESTROY_DRAWABLE            0x0002 // destroy drawable client information
#define ESC_NV_OPENGL_START_STATE_CLIENT_TRACKING 0x0003  // start tracking of state->hClient
#define ESC_NV_OPENGL_STOP_STATE_CLIENT_TRACKING  0x0004 // stop tracking of state->hClient
#define ESC_NV_OPENGL_DMA_PUSH_GO_CMD             0x0005 // NV3 DMA push go command
#define ESC_NV_OPENGL_MEM_TO_SCREEN_SRCCOPY       0x0006 // memory to screen copy
#define ESC_NV_OPENGL_SCREEN_TO_SCREEN_SRCCOPY    0x0007 // screen to screen copy
#define ESC_NV_OPENGL_SUPPORT_ENABLED             0x0008 // OpenGL ICD enabled or NOT!
#define ESC_NV_OPENGL_ALLOC_SHARED_MEMORY         0x0009 // create shared memory area
#define ESC_NV_OPENGL_FREE_SHARED_MEMORY          0x000A // free shared memory area
#define ESC_NV_OPENGL_GET_DISPLAY_PITCH           0x000B // return pitch of display
#define ESC_NV4_OPENGL_SWAP_BUFFERS               0x000C // NV4 swap buffers...
#define ESC_NV4_OPENGL_FLUSH                      0x000D // NV4 flush...
#define ESC_NV_OPENGL_PURGE_DEVICE_BITMAP         0x000E // purge GDI device bitmaps...
#define ESC_NV_OPENGL_FLUSH                       0x000F // NV10 and up style flush...
#define ESC_NV_OPENGL_SWAP_BUFFERS                0x0010 // NV10 and up style swap buffers...
#define ESC_NV_OPENGL_CPUBLIT                     0x0011 // Generic CPU blit. Currently used for buffer region Ext.
#define ESC_NV_OPENGL_INIT_STATE                  0x0012 // Initialize HW state from the display driver side
#define ESC_NV_OPENGL_ALLOC_UNIFIED_SURFACES      0x0021 // alloc single back/depth in GDI display driver
#define ESC_NV_OPENGL_FREE_UNIFIED_SURFACES       0x0022 // free single back/depth in GDI display driver
#define ESC_NV_OPENGL_GET_SURFACE_INFO            0x0023 // get offset for single back
#define ESC_NV_OPENGL_DID_STATUS_CHANGE           0x0029 // clip list status call
#define ESC_NV_OPENGL_GET_CLIP_LIST_COUNT         0x002A // return count of rectangles in clip list
#define ESC_NV_OPENGL_GET_CLIP_LIST               0x002B // return list of rectangles for window clip
#define ESC_NV_OPENGL_SUPPORT                     0x002C // return TRUE if OpenGL supported...
#define ESC_NV_OPENGL_REGISTER_RM_CLIENT          0x002D // register RM client with display driver
#define ESC_NV_OPENGL_UNREGISTER_RM_CLIENT        0x002E // unregister RM client with display driver
#define ESC_NV_OPENGL_SET_DAC_BASE                0x002F // set the display base offset
#define ESC_NV_OPENGL_SYNC_CHANNEL                0x0030 // wait for FIFO and graphics engine to be !busy
#define ESC_NV_OPENGL_SET_LAYER_PALETTE           0x0031 // Overlay specific: set palette entries in the DD
#define ESC_NV_OPENGL_GET_LAYER_PALETTE           0x0032 // Overlay specific: get palette entries from the DD
#define ESC_NV_OPENGL_OVERLAY_MERGEBLIT           0x0033 // Overlay specific: do the merge blit fm+fo->scratch->primary
#define ESC_NV_OPENGL_PFD_CHECK                   0x0034 // Retrieve some caps from the driver
#define ESC_NV_OPENGL_COMMAND                     0x0035 // Command interface for e.g. locked clears
#define ESC_NV_OPENGL_SHARED_LIBRARY_SIZES        0x0036 // check __GLNVstate and __GLdrawablePrivate sizes
#define ESC_NV_OPENGL_NT4_GET_NUMBER_OF_MONITORS  0x0037 // multimon escape for NT4 
#define ESC_NV_OPENGL_NT4_GET_DEVICE_HANDLE       0x0038 // multimon escape for NT4
#define ESC_NV_OPENGL_NT4_GET_DEVICE_RECT         0x0039 // multimon escape for NT4
#define ESC_NV_OPENGL_NT4_GDI_LOCK                0x0040 // multimon escape for NT4

#define ESC_NV_CONVERT_RING3_TO_RING0             0x7200

#undef ESC_NV_OPENGL_MEM_TO_SCREEN_SRCCOPY // uses a separate escape...
#define ESC_NV_OPENGL_MEM_TO_SCREEN_SRCCOPY     0x7102


#define ESC_NV_QUERYSET_REGISTRY_KEY              0x7103
#define NV_QUERY_REGISTRY_KEY                     0x0001
#define NV_SET_REGISTRY_KEY                       0x0002
#define NV_QUERY_REGISTRY_BINARY_KEY              0x0004


#define ESC_NV_MAP_USER                 0x9000
#define ESC_NV_UNMAP_USER               0x9001

#ifndef NV_SIGNATURE
// This value also is defined in driver.h of display driver
#define NV_SIGNATURE 0x11223344
#endif

#define ESC_NV_QUERY_PCI_SLOT                   0x7105
#define ESC_NV_QUERY_HEAD_REFRESH_RATE          0x7106

#ifndef NV_ESC_PRIMARY_INFO
#define NV_ESC_PRIMARY_INFO 0x7104
typedef struct _NV_PRIMARY_INFO
{
    ULONG  ulNVSignature;   // IN
    ULONG  ulNumDevices;    // IN
    ULONG  ulHeadNum;       // IN
    ULONG  ulReturnCode;    // IN
    ULONG  ulWidth;         // OUT from display driver
    ULONG  ulHeight;        // OUT from display driver
    ULONG  ulDepth;         // OUT from display driver
    ULONG  ulPitch;         // OUT from display driver
    ULONG  ulPrimaryOffset; // OUT from display driver
    ULONG  ulNumDACs;       // OUT from display driver (NT only)
    ULONG  ulNumActiveDACs; // OUT from display driver
    ULONG  ulActiveDACs;    // OUT from display driver (NT only)
    ULONG *ulPanningPtr;    // OUT from display driver (9x only)
    ULONG *ulFullscreenPtr; // OUT from display driver (9x only)
} NV_PRIMARY_INFO;
#endif

#ifdef _WIN32 // rest of this file only needed for win32 interfaces

/* The defines for the escapes */
#define	OPENGL_CMD              4352
#define	OPENGL_GETINFO          4353

// Input structure for OPENGL_CMD ExtEscape.

typedef struct _OPENGLCMD
{
    ULONG    ulSubEsc;
    ULONG    fl;
    struct _WNDOBJ   *pwo;
    struct _XLATEOBJ *pxo;
} OPENGLCMD, *POPENGLCMD;

// Flags for OPENGL_CMD ExtEscape.

#define OGLCMD_NEEDWNDOBJ       0x01
#define OGLCMD_NEEDXLATEOBJ     0x02


#define NV_ESC_IS_64BIT_CLIENT   'SIX4'
#define NV_ESC_IS_32BIT_CLIENT   '3TWO'

#if defined(_WIN64)
#define NV_ESC_CLIENT_MODEL NV_ESC_IS_64BIT_CLIENT
#else
#define NV_ESC_CLIENT_MODEL NV_ESC_IS_32BIT_CLIENT
#endif

typedef struct _NV_OPENGL_COMMAND
{
    union                            // offset == 0 
    {
        OPENGLCMD openGLCmd;         // header needed for MS OpenGL escape call                                     
        ULONG     spaceUnifier[8];   // used to make sure the next element is aligned 
                                     // to 4x8bytes in 64 bit and 32 bit environment
    };
                                     // offset == 32
    ULONG       NVClientModel;       // can have only two values NV_ESC_IS_32BIT_CLIENT or NV_ESC_IS_64BIT_CLIENT 
                                     // to make sure it's used in a reliant way
                                     // Note: We can't or NV_ESC_64_BASE onto the escape cmd 
                                     // as long as we use the OPENGL_CMD escape 
                                     // To make life a bit easier the flag has an offset 
                                     // of 32bytes for both 64 and 32 bit Windows (guaranteed by spaceUnifier)
    ULONG       NVSignature;         // offset == 36
    ULONG       command;             // Handle to resource manager client used in NvFree
    ULONG       numDevices;          // Number of devices in the system
    union                            // offset == 48 (must be 8 byte aligned for 64bit Windows)
    { 
        HWND        hWnd;            // Window handle
        __int64     hWndSpaceUnifier;// used to make sure the next element has equal offsets on 
                                     // 64 and 32 bit Windows
    };                                     
    union                            // offset == 56 (must be 8 byte aligned for 64bit Windows)
    { 
        HDC         hDC;             // GDI device context handle
        __int64     hDCSpaceUnifier; // used to make sure the next element has equal offsets on 
                                     // 64 and 32 bit Windows
    };
    ULONG       hClient;             // Handle to resource manager client
    ULONG       processHandle;       // Process handle from client associated with globalData
    union                            // offset == 72 (must be 8 byte aligned for 64bit Windows)
    { 
        PVOID       globalData;      // Pointer to global shared data for destroy
        __int64     gDSpaceUnifier;  // used to make sure the next element has equal offsets on 
                                     // 64 and 32 bit Windows
    };
    union                            // offset == 80 (must be 8 byte aligned for 64bit Windows)
    { 
        PVOID       other;           // Pointer to whatever
        __int64     otherSpaceUnifier;// used to make sure the next element has equal offsets on 
                                     // 64 and 32 bit Windows
    };
    ULONG       devID;               // DevID of current device for NT4 multimon 
    ULONG       useOpenGLCmdEscape;  // use OPENGL_CMD escape if non zero (flush on front buffer 
                                     // rendering, clear, swap buffers)
    LONG        devOriginLeft;       // left origin of device: needed for multimon to identify device  (W2K)
    LONG        devOriginTop;        // top  origin of device: needed for multimon to identify device  (W2K)

} NV_OPENGL_COMMAND;



typedef struct _NV_OPENGL_CLIP_LIST_DATA
{
    int  clipChangedCount;
    int  rgnDataSize;
    void *rgnData;
    void *rect;
} NV_OPENGL_CLIP_LIST_DATA;

typedef struct _NV_OPENGL_GLOBAL_DATA
{
    ULONG oglMutex;
    ULONG oglModeSwitch;
    ULONG oglPFifoAddress;
    ULONG oglSystemMutex;
} NV_OPENGL_GLOBAL_DATA;

typedef struct _NV_WNDOBJ_SETUP
{
    ULONG       NVSignature;
    HWND        hWnd;       /* Handle to window */
    HDC         hDC;        /* handle to GDI device context */
    ULONG       numDevices; /* Number of devices in the system */
    PIXELFORMATDESCRIPTOR pfd;
    ULONG       devID;      // DevID of current device for NT4 multimon 
} NV_WNDOBJ_SETUP;

#define NV_CLIP_MUTEX_WAIT_IN_SECONDS       10 // 10 milliseconds
#define NV_WINDOW_CLIP_FULLYVISIBLE         0x0001
#define NV_WINDOW_CLIP_OCCLUDED             0x0002
#define NV_WINDOW_CLIP_SINGLERECTANGLE      0x0004
#define NV_WINDOW_CLIP_COMPLEX              0x0008
#define NV_WINDOW_CLIP_FULLSCREEN           0x0010
#define MAX_OGL_CLIP_RECTS                  250
#define MAX_OGL_CLIENTS                     512

// The following structure lives in shared memory between the display driver
// and OpenGL.  Put shared items in the front to ensure that data items line
// up between a 64 bit display driver and a 32 bit OpenGL client.
// In addition, only the first page (4096 bytes on most systems) is shared.
                                        // 
typedef struct _NV_OPENGL_DRAWABLE_INFO
{
                                        // BEGIN SHARED AREA

    ULONG       clipChangedCount;       // Number of times clip has changed since client registered
    ULONG       clipFlags;              // Clip status for last clip
    ULONG       numClipRects;           // Number of clip rectangles

    ULONG       flipChangedCount;       // Number of times flip has changed 
    int         bFlipping;              // TRUE=client is flipping; FALSE=client is blitting

    ULONG       ulSwapDoneByClient;     // set if the ICD takes care of the swap
                                        // END SHARED AREA

    ULONG       oglMutexPtr;            // Handle to resource manager client used in NvFree
    PVOID       oglGlobalPagePtr;       // Pointer to shared memory
    ULONG       mutexLock;              // Lock on this data structure
    PVOID       pClientInfoMdl;         // MDL for lock down pages
    PVOID       userVirtualAddress;     // user virtual address for clientInfo
    ULONG       hClient;                // handle to resource manager
    HANDLE      hWnd;                   // Handle to window tracked in DrvClipChanged
    HANDLE      hDC;                    // Handle to GDI device context
    LONG        iPixelFormat;           // pixel format associated with this client
    RECT        rect;                   // rectangle of window on screen
    RECTL       windowRect[MAX_OGL_CLIP_RECTS];
                                        // Clip region for client window
    PVOID       origClientDrawableInfoPtr; 
                                        // Original Ptr remembered to free memory

    RECTL       *cachedClipRectList;    // Cache the clip list so that we do not have to merge it
    ULONG       cachedNumClipRects;     // Number of rectangles.
    ULONG       cachedClipListSize;     // Currently allocated size of the clip list.
    BOOL        cachedClipListDirty;    // Flag to determine whether to recompute clip list.
    RECTL       *cachedExclusiveRectList;    // Cache the clip list so that we do not have to merge it
    ULONG       cachedNumExclusiveRects;     // Number of rectangles.
    RECTL       *copyWindowRect;           // Actual clip rectangle pointer used everywhere in NV4+ driver
    ULONG       sizeCopyWindowRectList;    // Size of clip rectangle pointer above.

    ULONG       bOrigClipList;            // TRUE means the original clip list is cached in this structure
    RECTL       *origWindowRectList;      // cache of the original unclipped rectangle list for this window

    ULONG       cxScreen, cyScreen;     // width and height of display
    ULONG       cxcyChanged;

    //
    // The following flag is used when UBB is ON, window flipping is OFF and there are no OGL windows
    // occluding the window this drawable structure references.  This is an optimization for window
    // clipping created for 3D Studio Max.  When 3D Studio Max is in No redraw on expose mode, an expose
    // event will not cause a re-render of the scene.  Compaq workstation did not like this and complained
    // that the image is wrong in comparison to other CAD graphics products.  Since the 3D pixels are 
    // clipped to a GDI window that is occluding our OGL window, it is possible to render those pixels
    // with UBB on without causing scribble.  But for this to work, the occluding window must NOT be a
    // OGL window and window flipping must be off.
    //
    // This flag is computed as part of the DrvClipChanged function.
    //
    ULONG       ubbWindowClipFlag;      // TRUE means use window bounds for clip; otherwise use copyWindowRect list
    ULONG       refCount;               // mainplane+overlay track the same window!, so we need a refCount, to securely destroy the drawable
    int         overlayMember;
    } NV_OPENGL_DRAWABLE_INFO;

typedef struct _NV_OPENGL_CONTEXT_INFO
    {
    HWND        hWnd;                   // Window/drawable associated with context
    HDC         hDC;                    // GDI device context
    ULONG       hClient;                // Handle to resource manager client
    } NV_OPENGL_CONTEXT_INFO;

// WARNING! This structure is shared with NT display driver in driver.h
#define OGL_ERROR_NO_ERROR             0x0000
#define OGL_ERROR_MODE_SWITCH          0x0001
#define OGL_ERROR_CLIENT_NOT_FOUND     0x0002
#define OGL_ERROR_CLIP_MUTEX_TIMEOUT   0x0003
#define OGL_ERROR_CLIP_LIST_BAD        0x0004
#define OGL_ERROR_LOAD_BUFFER_INFO     0x0005
#define OGL_ERROR_SIMPLE_TO_COMPLEX    0x0006
#define OGL_ERROR_COMPLEX_TO_SIMPLE    0x0007
#define OGL_ERROR_REALLOC_FAILURE      0x0008
#define OGL_ERROR_NO_SWAP              0x0009
#define OGL_ERROR_WINDOW_CHANGED_COUNT 0x000A
#define OGL_ERROR_SURFACE_INVALID      0x000B

#define OGL_ERROR_CLIP_CHANGE_NOTIFY   0x000C


#define NV_BLIT_MEM_TO_SCR 1
#define NV_BLIT_SCR_TO_MEM 2
typedef struct {
    ULONG       blitType;
    ULONG       useClipList;
    PVOID       pSrcBase; 
    ULONG       dwSrcByteWidth; 
    ULONG       dwSrcElementSize;
    ULONG       dstOffset; // offset in frame buffer
    PVOID       pDstBase; 
    ULONG       dwDstByteWidth; 
    ULONG       dwDstElementSize;
    ULONG       dwSrcLeft; 
    ULONG       dwSrcTop;
    ULONG       dwDstLeft; 
    ULONG       dwDstTop;
    ULONG       dwWidth; 
    ULONG       dwHeight;
    ULONG       retStatus;
} __GLNvCpuBltData;

typedef struct {
    ULONG       type;
    PCHAR       keyName;
    PVOID       keyVal;
    ULONG       keyValSize;
    ULONG       keyValMaxSize;
    ULONG       retStatus;
    ULONG       devID;               // DevID of current device for NT4 multimon 
} *__PNVRegKeyInfo, __NVRegKeyInfo;


// Desktop Manager private escapes
#define ESC_NV_DESKMGR_ZOOMBLIT         0x7107

#define NVDM_ESC_BLIT_VIDMEM            0x00000000
#define NVDM_ESC_BLIT_SYSMEM            0x00000001
#define NVDM_ESC_BLIT_SMOOTH            0x00000002

typedef struct {
    ULONG flags;
    int scale;
    union {
        RECTL srcRect;
        struct {
            ULONG format;
            int stride;
            PVOID bits;
        } srcMem;
    };
    RECTL dstRect;
    int clips;
    RECTL clipRects[1];
} __NVDMEscapeParams;


// ESC_NV_WKS_APP_SUPPORT - BEGIN
//
// Workstation application support escape
//
// The ESC_NV_WKS_APP_SUPPORT escape supports a couple of sub escapes through
// a common interface!
//
// WARNING:
//   Never change the escape number ESC_NV_WKS_APP_SUPPORT! 
//   This will break QuadroView, MaxTreme, PowerDraft and all other workstation apps!
//
// NOTES: 
// - all ExtEscape in-structures need to use NV_WKS_HEAD_IN at top of the structure
// - all out structures need to use NV_WKS_HEAD_OUT at top of the structure
// - all in and out structures must be initialized with 0 to clear unused members
// - changes to the interface structures must be downwards compatible
// - never change the size of a existing structure or the arrangement of the members
// - always check the exact strucure size and fail if not the same
// - if lResult returns an error only the NV_WKS_HEAD_OUT struct is valid and the 
//   members of the structure are used to specify the error (see error description)
#define ESC_NV_WKS_APP_SUPPORT          0x7108

//
// supported subescapes
//
                                          // 0x0000 unused
#define SUBESC_WKS_GET_CAPS                  0x0001 // uses NV_WKS_GET_CAPS_IN as in and NV_WKS_GET_CAPS_OUT as out structure 
#define SUBESC_WKS_WINDOW_STEREOMODE         0x0002 // uses NV_WKS_WINDOW_STEREOMODE_IN as in, and NULL as NV_WKS_WINDOW_STEREOMODE_OUT as out structure
//      add new subescapes here:             0x0003


//
// Common in and out header structures that must be used by all in and out structures
//

// must be used by all in structures
typedef struct _NV_WKS_HEAD_IN
{
    ULONG ulInSize;     // Length of entire in structure, e.g. sizeof(NV_WKS_GET_CAPS_IN)
    ULONG ulSubEsc;     // has to be (SUBESC_WKS_GET_CAPS, ...)
    ULONG ulOutSize;    // size of entire output data structure or 0 ()
    ULONG ulVersion;    // initialize with NV_WKS_VERSION; Version of ESC_NV_WKS_APP_SUPPORT interface
                        
    ULONG ulBoard;      // Calls that affect all boards use NV_WKS_ALLBOARDS to initialize dwBoard
                        // 0 -> board 0, 1 -> board 1, ET_ALL_BOARDS -> all boards (broadcast)  

    // reserved members are not allowed to be used!
    ULONG ulReserved0;
    ULONG ulReserved1;  // reserved for future extensions
    ULONG ulReserved2;
} NV_WKS_HEAD_IN;

// must be used by all out structures
typedef struct _NV_WKS_HEAD_OUT
{
    ULONG ulSize;       // Length of entire out structure, e.g. sizeof(NV_WKS_GET_CAPS_OUT)
                        // Should be same as NV_WKS_HEAD_IN.ulOutSize!
                        // NOTE: In error case used perhaps other meaning (see error description)!
    ULONG ulVersion;    // initialize with NV_WKS_VERSION; Version of ESC_NV_WKS_APP_SUPPORT interface
    LONG  lResult;      // If escapes succeeds ulResult contains more status information

    // reserved members are not allowed to be used!
    ULONG ulReserved0;  // reserved for future extensions
} NV_WKS_HEAD_OUT;

//
// defines for header variables
//
// NV_WKS_HEAD_IN.ulVersion, NV_WKS_HEAD_OUT.ulVersion
#define NV_WKS_VERSION                          1          // intial version

// NV_WKS_HEAD_IN.ulBoard
#define NV_WKS_ALLBOARDS                        0xFFFFFFFF // broadcast to all boards, 

// return values for NV_WKS_HEAD_OUT.lResult

// Success values lResult > 0
#define NV_WKS_RESULT_SUCCESS                      1 // wks escape succeeded

#define NV_WKS_RESULT_NOT_ALLOWED                  0 // unused valued, HEAD_OUT isn't valid at all!

// Error values lResult < 0
#define NV_WKS_RESULT_ERROR                       -1 // any unspecified error
#define NV_WKS_RESULT_ERROR_SUBESC_NOT_SUPPORTED  -2 // unsupported subescape
#define NV_WKS_RESULT_ERROR_INSIZE                -3 // input buffer has wrong size, expected size in NV_WKS_HEAD_OUT.ulSize
#define NV_WKS_RESULT_ERROR_OUTSIZE               -4 // output buffer has wrong size, expected size in NV_WKS_HEAD_OUT.ulSize
#define NV_WKS_RESULT_ERROR_INTERFACE             -5 // inconsisty in usage of interface, values in HEAD_IN do not match cjIn, cjOut, ...
#define NV_WKS_RESULT_ERROR_PARAMETER             -6 // interface correct, but a parameter is wrong and the escape couldn't be handled

// define that c
#define NV_WKS_INIT_HEAD_IN(pHdr, subEsc, sizeIn, sizeOut, board)   \
    ((NV_WKS_HEAD_IN *)(pHdr))->ulSubEsc  = subEsc;                 \
    ((NV_WKS_HEAD_IN *)(pHdr))->ulInSize  = sizeIn;                 \
    ((NV_WKS_HEAD_IN *)(pHdr))->ulOutSize = sizeOut;                \
    ((NV_WKS_HEAD_IN *)(pHdr))->ulVersion = NV_WKS_VERSION;         \
    ((NV_WKS_HEAD_IN *)(pHdr))->ulBoard   = board;


//
// SUBESC_WKS_GET_CAPS 
//
// Query workstation graphics capabilities.
//
// Example code can be found in .\drivers\display\winnt4\displays\nv_disp\wksappsupport.c
//
// input structure
typedef struct _NV_WKS_GET_CAPS_IN
{
    NV_WKS_HEAD_IN hdr;
} NV_WKS_GET_CAPS_IN;

// output structure
typedef struct _NV_WKS_GET_CAPS_OUT
{
    NV_WKS_HEAD_OUT hdr;

    ULONG flGraphicsCaps; // NV_WKS_GRAPHICS_CAPS_*, nearly same as NvRmConfigGet(NV_CFG_GRAPHICS_CAPS)
    ULONG ulMaxClipRects; // number of supported clip rects
    ULONG flWksCaps;      // NV_WKS_CAPS_*, workstation capabilities

    // reserved members are not allowed to be used!
    ULONG ulReserved0;    // reserved for future extensions
} NV_WKS_GET_CAPS_OUT;

// defines used in NV_WKS_GET_CAPS_OUT.flGraphicsCaps
#define NV_WKS_GRAPHICS_CAPS_AA_LINES           0x00000001 //NOTE: != NV_CFG_GRAPHICS_CAPS_AA_LINES
#define NV_WKS_GRAPHICS_CAPS_AA_POLYS           0x00000002
#define NV_WKS_GRAPHICS_CAPS_AKILL_USERCLIP     0x00000004
#define NV_WKS_GRAPHICS_CAPS_LOGIC_OPS          0x00000008
#define NV_WKS_GRAPHICS_CAPS_NV15_ALINES        0x00000010
#define NV_WKS_GRAPHICS_CAPS_2SIDED_LIGHTING    0x00000020
#define NV_WKS_GRAPHICS_CAPS_QUADRO_GENERIC     0x00000040
#define NV_WKS_GRAPHICS_CAPS_UBB                0x00000080

// defines used in NV_WKS_GET_CAPS_OUT.flWksCaps
#define NV_WKS_CAPS_WORKSTATION_BOARD           0x00000001
#define NV_WKS_CAPS_STERO_CAPABLE               0x00000010
#define NV_WKS_CAPS_OVERLAY_CAPABLE             0x00000020


//
// SUBESC_WKS_WINDOW_STEREOMODE
//
// Interface for workstation apps to enable/disable stereo toggle and 
// double pumping for a given window wiht a stereo-pfd
//
// Example code can be found in .\drivers\display\winnt4\displays\nv_disp\wksappsupport.c
//
// input structure
typedef struct _NV_WKS_WINDOW_STEREOMODE_IN
{
    NV_WKS_HEAD_IN hdr;

    PVOID          hwnd;   // handle of window to modify/query. If NULL current driver status is returned
    ULONG          ulMode; // NV_WKS_WINDOW_STEREOMODE_QUERY, NV_WKS_WINDOW_STEREOMODE_ENABLE, NV_WKS_WINDOW_STEREOMODE_DISABLE
} NV_WKS_WINDOW_STEREOMODE_IN;

// output structure
typedef struct _NV_WKS_WINDOW_STEREOMODE_OUT
{
    NV_WKS_HEAD_OUT hdr;

    PVOID           hwnd;   // handle of window queried, or NULL if not specified.
    ULONG           ulMode; // NV_WKS_WINDOW_STEREOMODE_ENABLED, NV_WKS_WINDOW_STEREOMODE_DISABLED, ...
} NV_WKS_WINDOW_STEREOMODE_OUT;

// IN.ulMode
#define NV_WKS_WINDOW_STEREOMODE_DISABLE           0 // disable stereo mode for IN.hwnd (must be valid stereo window)
#define NV_WKS_WINDOW_STEREOMODE_ENABLE            1 // enable stereo mode for IN.hwnd (must be valid stereo window)
#define NV_WKS_WINDOW_STEREOMODE_QUERY             2 // query status of IN.hwnd or system if IN.hwnd==NULL

// OUT.ulMode
#define NV_WKS_WINDOW_STEREOMODE_UNUSED            0 // value not set by driver, ignore value
#define NV_WKS_WINDOW_STEREOMODE_DISABLED          1 // stereo is disabled for OUT.hwnd
#define NV_WKS_WINDOW_STEREOMODE_ENABLED           3 // stereo is enabled for OUT.hwnd
#define NV_WKS_WINDOW_STEREOMODE_INVALID_HWND      4 // couldn't find hwnd in client list
#define NV_WKS_WINDOW_STEREOMODE_NO_STEREO_HWND    5 // hwnd isn't a stero window
#define NV_WKS_WINDOW_STEREOMODE_NO_STEREO         6 // currently no stereo active


// ESC_NV_WKS_APP_SUPPORT - END

#endif // _WIN32

#endif // NV_ESC_DEF_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\common\inc\nvescdef32.h ===
/*
 * nvEscDef32.h
 *
 * Provides definitions for 32 bit views for nVidia ExtEscape strucures into
 * the 64 bit display driver.  Eventually we'll have a single source file.
 *
 * Copyright (c) 2000, Nvidia Corporation.  All rights reserved.
 * Portions Copyright (c) 1996, 1997, Silicon Graphics Inc.
 *
 * THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
 * NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
 * IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
 */

#ifndef NV_ESC_DEF32_INCLUDED
#define NV_ESC_DEF32_INCLUDED

typedef struct _NV_PRIMARY_INFO32
{
    ULONG          ulNVSignature;    // IN
    ULONG          ulNumDevices;     // IN
    ULONG          ulHeadNum;        // IN
    ULONG          ulReturnCode;     // IN
    ULONG          ulWidth;          // OUT from display driver
    ULONG          ulHeight;         // OUT from display driver
    ULONG          ulDepth;          // OUT from display driver
    ULONG          ulPitch;          // OUT from display driver
    ULONG          ulPrimaryOffset;  // OUT from display driver
    ULONG          ulNumDACs;        // OUT from display driver (NT only)
    ULONG          ulNumActiveDACs;  // OUT from display driver
    ULONG          ulActiveDACs;     // OUT from display driver (NT only)
    ULONG * __ptr32 ulPanningPtr;    // OUT from display driver (9x only)
    ULONG * __ptr32 ulFullscreenPtr; // OUT from display driver (9x only)
} NV_PRIMARY_INFO32;

typedef struct _NV_OPENGL_COMMAND32
{
    ULONG          NVSignature;
    ULONG          command;           // Handle to resource manager client used in NvFree
    ULONG          numDevices;        // Number of devices in the system
    VOID * __ptr32 hWnd;              // Window handle
    VOID * __ptr32 hDC;               // GDI device context handle
    ULONG          hClient;           // Handle to resource manager client
    ULONG          processHandle;     // Process handle from client associated with globalData
    VOID * __ptr32 globalData;        // Pointer to global shared data for destroy
    VOID * __ptr32 other;             // Pointer to whatever
} NV_OPENGL_COMMAND32;

typedef struct _NV_OPENGL_CLIP_LIST_DATA32
{
    int            clipChangedCount;
    int            rgnDataSize;
    void * __ptr32 rgnData;
    void * __ptr32 rect;
} NV_OPENGL_CLIP_LIST_DATA32;

typedef struct _NV_WNDOBJ_SETUP32
{
    ULONG          NVSignature;
    VOID * __ptr32 hWnd;                // Handle to window
    VOID * __ptr32 hDC;                 // handle to GDI device context
    ULONG          numDevices;          // Number of devices in the system
    PIXELFORMATDESCRIPTOR pfd;
} NV_WNDOBJ_SETUP32;

typedef struct {
    ULONG          type;
    CHAR * __ptr32 keyName;
    VOID * __ptr32 keyVal;
    ULONG          keyValSize;
    ULONG          keyValMaxSize;
    ULONG          retStatus;
} *__PNVRegKeyInfo32, __NVRegKeyInfo32;

#endif // NV_ESC_DEF32_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\common\inc\nvfilenames.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1995, 1999 NVidia Corporation. All Rights Reserved.
 *
 *  File:       files.h
 *  Content:    Contains defines for the various binary filenames
 *
 ***************************************************************************/

/*NV3 binaries*/
#define NV3_DDRAW_BINARY		"NV3DD32.DLL"
#define NV3_DISPLAY_BINARY		"NV3DISP.DRV"
#define NV3_OPENGL_BINARY		"NV3OGL.DLL"
#define NV3_MINIVDD_BINARY		"NV3.VXD"
#define NV3_MINIVDD2_BINARY		"NV3MINI2.VXD"
#define NV3_RM_32_BINARY		"NV3API.DLL"
#define NV3_RM_16_BINARY		"NV3SYS.DLL"
#define NV3_RM_KERNEL_BINARY		"NV3RM.VXD"
#define NV3_QUICK_TWEAK_BINARY		"NV3QTWK.DLL"
#define NV3_TWEAK_BINARY		"NV3TWEAK.DLL"
#define NV3_TWEAK_HELP_BINARY		"NV3TWEAK.HLP"

/*NV4 binaries*/
#define NV4_DDRAW_BINARY		"NVDD32.DLL"
#define NV4_DISPLAY_BINARY		"NVDISP.DRV"
#define NV4_MODESET_BINARY		"NVMODE.DLL"
#define NV4_OPENGL_BINARY		"NVOPENGL.DLL"
#define NV4_MINIVDD_BINARY		"NVMINI.VXD"
#define NV4_MINIVDD2_BINARY		"NVMINI2.VXD"
#define NV4_RM_32_BINARY		"NVARCH32.DLL"
#define NV4_RM_16_BINARY		"NVARCH16.DLL"
#define NV4_RM_KERNEL_BINARY		"NVCORE.VXD"
#define NV4_QUICK_TWEAK_BINARY		"NVQTWK.DLL"
#define NV4_STERCP_BINARY           "NVSTERCP.DLL"
#define NV4_TWEAK_BINARY		    "NVCPL.DLL"
#define NV4_TWEAK_SVC_BINARY        "NVSVC.EXE"
#define NV4_DESK_MGR_BINARY         "NVDESK32.DLL"
#define NV4_DESK_MGR_UI_BINARY      "NVDMCPL.DLL"
#define NV4_FSVM_BINARY		        "NVFSVM.EXE"
#define NV4_TWEAK_HELP_BINARY		"NVCPL.HLP"
#define NV4_INSTALL_LIB_BINARY      "NVINST32.DLL"
#define NV4_ARABIC_RESOURCE_BINARY	"NVRSAR.DLL"
#define NV4_ARABIC_HELP_BINARY		"NVCPAR.HLP"
#define NV4_CZECH_RESOURCE_BINARY	"NVRSCS.DLL"
#define NV4_CZECH_HELP_BINARY		"NVCPCS.HLP"
#define NV4_DANISH_RESOURCE_BINARY	"NVRSDA.DLL"
#define NV4_DANISH_HELP_BINARY		"NVCPDA.HLP"
#define NV4_GERMAN_RESOURCE_BINARY	"NVRSDE.DLL"
#define NV4_GERMAN_HELP_BINARY		"NVCPDE.HLP"
#define NV4_UKENGLISH_RESOURCE_BINARY	"NVRSENG.DLL"
#define NV4_UKENGLISH_HELP_BINARY	"NVCPENG.HLP"
#define NV4_SPANISH_RESOURCE_BINARY	"NVRSES.DLL"
#define NV4_SPANISH_HELP_BINARY		"NVCPES.HLP"
#define NV4_MSPANISH_RESOURCE_BINARY	"NVRSESM.DLL"
#define NV4_MSPANISH_HELP_BINARY	"NVCPESM.HLP"
#define NV4_LASPANISH_RESOURCE_BINARY	"NVRSES.DLL"
#define NV4_LASPANISH_HELP_BINARY	"NVCPES.HLP"
#define NV4_FINNISH_RESOURCE_BINARY	"NVRSFI.DLL"
#define NV4_FINNISH_HELP_BINARY		"NVCPFI.HLP"
#define NV4_FRENCH_RESOURCE_BINARY	"NVRSFR.DLL"
#define NV4_FRENCH_HELP_BINARY		"NVCPFR.HLP"
#define NV4_CAFRENCH_RESOURCE_BINARY	"NVRSFR.DLL"
#define NV4_CAFRENCH_HELP_BINARY	"NVCPFR.HLP"
#define NV4_GREEK_RESOURCE_BINARY	"NVRSEL.DLL"
#define NV4_GREEK_HELP_BINARY	"NVCPEL.HLP"
#define NV4_HEBREW_RESOURCE_BINARY	"NVRSHE.DLL"
#define NV4_HEBREW_HELP_BINARY	"NVCPHE.HLP"
#define NV4_HUNGARIAN_RESOURCE_BINARY	"NVRSHU.DLL"
#define NV4_HUNGARIAN_HELP_BINARY	"NVCPHU.HLP"
#define NV4_ITALIAN_RESOURCE_BINARY	"NVRSIT.DLL"
#define NV4_ITALIAN_HELP_BINARY		"NVCPIT.HLP"
#define NV4_JAPANESE_RESOURCE_BINARY	"NVRSJA.DLL"
#define NV4_JAPANESE_HELP_BINARY	"NVCPJA.HLP"
#define NV4_KOREAN_RESOURCE_BINARY	"NVRSKO.DLL"
#define NV4_KOREAN_HELP_BINARY		"NVCPKO.HLP"
#define NV4_DUTCH_RESOURCE_BINARY	"NVRSNL.DLL"
#define NV4_DUTCH_HELP_BINARY		"NVCPNL.HLP"
#define NV4_NORWEGIAN_RESOURCE_BINARY	"NVRSNO.DLL"
#define NV4_NORWEGIAN_HELP_BINARY	"NVCPNO.HLP"
#define NV4_POLISH_RESOURCE_BINARY	"NVRSPL.DLL"
#define NV4_POLISH_HELP_BINARY	"NVCPPL.HLP"
#define NV4_PORTUGUESE_RESOURCE_BINARY	"NVRSPT.DLL"
#define NV4_PORTUGUESE_HELP_BINARY	"NVCPPT.HLP"
#define NV4_BPORTUGUESE_RESOURCE_BINARY	"NVRSPTB.DLL"
#define NV4_BPORTUGUESE_HELP_BINARY	"NVCPPTB.HLP"
#define NV4_RUSSIAN_RESOURCE_BINARY	"NVRSRU.DLL"
#define NV4_RUSSIAN_HELP_BINARY		"NVCPRU.HLP"
#define NV4_SLOVAK_RESOURCE_BINARY	"NVRSSK.DLL"
#define NV4_SLOVAK_HELP_BINARY		"NVCPSK.HLP"
#define NV4_SLOVENIAN_RESOURCE_BINARY	"NVRSSL.DLL"
#define NV4_SLOVENIAN_HELP_BINARY		"NVCPSL.HLP"
#define NV4_SWEDISH_RESOURCE_BINARY	"NVRSSV.DLL"
#define NV4_SWEDISH_HELP_BINARY		"NVCPSV.HLP"
#define NV4_THAI_RESOURCE_BINARY	"NVRSTH.DLL"
#define NV4_THAI_HELP_BINARY		"NVCPTH.HLP"
#define NV4_TURKISH_RESOURCE_BINARY	"NVRSTR.DLL"
#define NV4_TURKISH_HELP_BINARY		"NVCPTR.HLP"
#define NV4_SIMCHINESE_RESOURCE_BINARY	"NVRSZHC.DLL"
#define NV4_SIMCHINESE_HELP_BINARY	"NVCPZHC.HLP"
#define NV4_TRDCHINESE_RESOURCE_BINARY	"NVRSZHT.DLL"
#define NV4_TRDCHINESE_HELP_BINARY	"NVCPZHT.HLP"

/*NV4 NT4 binaries*/
#define NV4_DISPLAY_BINARY_NT4		"NV4_DISP.DLL"
#define NV4_OPENGL_BINARY_NT4		"NVOGLNT.DLL"
#define NV4_MINIVDD_BINARY_NT4		"NV4_MINI.SYS"
#define NV4_QUICK_TWEAK_BINARY_NT4   NV4_QUICK_TWEAK_BINARY
#define NV4_TWEAK_BINARY_NT4         NV4_TWEAK_BINARY
#define NV4_TWEAK_HELP_BINARY_NT4    NV4_TWEAK_HELP_BINARY
#define NV4_DESK_MGR_BINARY_NT4      NV4_DESK_MGR_BINARY
#define NV4_TWEAK_SVC_BINARY_NT4     "NVSVC32.EXE"

/* Workstation Application binaries */
#define NV4_POWERDRAFT_BINARY		"NVDS15.DLL"
#define NV4_MAXTREME_BINARY			"MAXtreme.drv"
#define NV4_QUADROVIEW_BINARY		"QUADROVIEW.EXE"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\common\inc\nvFourCC.h ===
// **************************************************************************
//
//       Copyright 1993-2000 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// **************************************************************************
//  Content:    FOURCC codes used in the nVidia drivers
//
//  Note that this file is meant to be used across ALL operating systems.
//  Do not create any dependency on non-nVidia code.
//
// **************************************************************************
#ifndef _NVFOURCC_H_
#define _NVFOURCC_H_

#include "nvTypes.h"

/* MMIO macros */
#ifndef mmioFOURCC
#define mmioFOURCC( ch0, ch1, ch2, ch3 )                                \
                ( (NvU32)(NvU8)(ch0) | ( (NvU32)(NvU8)(ch1) << 8 ) |    \
                ( (NvU32)(NvU8)(ch2) << 16 ) | ( (NvU32)(NvU8)(ch3) << 24 ) )
#endif // mmioFOURCC

/* FOURCC video formats we support */
#ifndef FOURCC_UYVY
#define FOURCC_UYVY                        mmioFOURCC('U','Y','V','Y')
#endif
#ifndef FOURCC_YUY2
#define FOURCC_YUY2                        mmioFOURCC('Y','U','Y','2')
#endif
#ifndef FOURCC_UYNV
#define FOURCC_UYNV                        mmioFOURCC('U','Y','N','V')
#endif
#ifndef FOURCC_YUNV
#define FOURCC_YUNV                        mmioFOURCC('Y','U','N','V')
#endif
#ifndef FOURCC_YV12
#define FOURCC_YV12                        mmioFOURCC('Y','V','1','2')
#endif
#ifndef FOURCC_NVDS
#define FOURCC_NVDS                        mmioFOURCC('N','V','D','S')
#endif
#ifndef FOURCC_NVMC
#define FOURCC_NVMC                        mmioFOURCC('N','V','M','C')
#endif
#ifndef FOURCC_NV12
#define FOURCC_NV12                        mmioFOURCC('N','V','1','2')
#endif
#ifndef FOURCC_NVID
#define FOURCC_NVID                        mmioFOURCC('N','V','I','D')
#endif
#ifndef FOURCC_NVSP
#define FOURCC_NVSP                        mmioFOURCC('N','V','S','P')
#endif
#ifndef FOURCC_420i
#define FOURCC_420i                        mmioFOURCC('4','2','0','i')
#endif
#ifndef FOURCC_IF09
#define FOURCC_IF09                        mmioFOURCC('I','F','0','9')
#endif
#ifndef FOURCC_YVU9
#define FOURCC_YVU9                        mmioFOURCC('Y','V','U','9')
#endif
#ifndef FOURCC_IV32
#define FOURCC_IV32                        mmioFOURCC('I','V','3','2')
#endif
#ifndef FOURCC_IV31
#define FOURCC_IV31                        mmioFOURCC('I','V','3','1')
#endif
#ifndef FOURCC_RAW8
#define FOURCC_RAW8                        mmioFOURCC('R','A','W','8')
#endif
#ifndef FOURCC_RGB0
#define FOURCC_RGB0                        0 // ?? @mjl@
#endif
#ifndef FOURCC_UBAD
#define FOURCC_UBAD                        mmioFOURCC('U','B','A','D')
#endif

/* FOURCC formats we support for 3d textures */
#ifndef FOURCC_NVT0
#define FOURCC_NVT0                        mmioFOURCC('N','V','T','0')
#endif
#ifndef FOURCC_NVT1
#define FOURCC_NVT1                        mmioFOURCC('N','V','T','1')
#endif
#ifndef FOURCC_NVT2
#define FOURCC_NVT2                        mmioFOURCC('N','V','T','2')
#endif
#ifndef FOURCC_NVT3
#define FOURCC_NVT3                        mmioFOURCC('N','V','T','3')
#endif
#ifndef FOURCC_NVT4
#define FOURCC_NVT4                        mmioFOURCC('N','V','T','4')
#endif
#ifndef FOURCC_NVT5
#define FOURCC_NVT5                        mmioFOURCC('N','V','T','5')
#endif
#ifndef FOURCC_NVT6
#define FOURCC_NVT6                        mmioFOURCC('N','V','T','6')
#endif
#ifndef FOURCC_NVT7
#define FOURCC_NVT7                        mmioFOURCC('N','V','T','7')
#endif
#ifndef FOURCC_NVT8
#define FOURCC_NVT8                        mmioFOURCC('N','V','T','8')
#endif
#ifndef FOURCC_NVT9
#define FOURCC_NVT9                        mmioFOURCC('N','V','T','9')
#endif
#ifndef FOURCC_NVTx
#define FOURCC_NVTx                        mmioFOURCC('N','V','T', 0)
#endif
#ifndef FOURCC_NVT_MASK
#define FOURCC_NVT_MASK                    mmioFOURCC(0xff, 0xff, 0xff, 0)
#endif
#ifndef FOURCC_NVS0
#define FOURCC_NVS0                        mmioFOURCC('N','V','S','0')
#endif
#ifndef FOURCC_NVS1
#define FOURCC_NVS1                        mmioFOURCC('N','V','S','1')
#endif
#ifndef FOURCC_NVS2
#define FOURCC_NVS2                        mmioFOURCC('N','V','S','2')
#endif
#ifndef FOURCC_NVS3
#define FOURCC_NVS3                        mmioFOURCC('N','V','S','3')
#endif
#ifndef FOURCC_NVS4
#define FOURCC_NVS4                        mmioFOURCC('N','V','S','4')
#endif
#ifndef FOURCC_NVS5
#define FOURCC_NVS5                        mmioFOURCC('N','V','S','5')
#endif
#ifndef FOURCC_NVS6
#define FOURCC_NVS6                        mmioFOURCC('N','V','S','6')
#endif
#ifndef FOURCC_NVS7
#define FOURCC_NVS7                        mmioFOURCC('N','V','S','7')
#endif
#ifndef FOURCC_NVS8
#define FOURCC_NVS8                        mmioFOURCC('N','V','S','8')
#endif
#ifndef FOURCC_NVS9
#define FOURCC_NVS9                        mmioFOURCC('N','V','S','9')
#endif
#ifndef FOURCC_NVSx
#define FOURCC_NVSx                        mmioFOURCC('N','V','S', 0)
#endif
#ifndef FOURCC_NVS_MASK
#define FOURCC_NVS_MASK                    mmioFOURCC(0xff, 0xff, 0xff, 0)
#endif
#ifndef FOURCC_NVHU
#define FOURCC_NVHU                        mmioFOURCC('N','V','H','U')
#endif
#ifndef FOURCC_NVHS
#define FOURCC_NVHS                        mmioFOURCC('N','V','H','S')
#endif
#ifndef FOURCC_DXT1
#define FOURCC_DXT1                        mmioFOURCC('D','X','T','1') // Compressed Texture
#endif
#ifndef FOURCC_DXT2
#define FOURCC_DXT2                        mmioFOURCC('D','X','T','2')
#endif
#ifndef FOURCC_DXT3
#define FOURCC_DXT3                        mmioFOURCC('D','X','T','3')
#endif
#ifndef FOURCC_DXT4
#define FOURCC_DXT4                        mmioFOURCC('D','X','T','4')
#endif
#ifndef FOURCC_DXT5
#define FOURCC_DXT5                        mmioFOURCC('D','X','T','5')
#endif


// Note!! The number below is UNRELATED to the number of fourcc's defined above.  
// This is the number that will be USED by the driver. This should be redone! @mjl@

/* total number of fourcc formats we support */
#define NV_MAX_FOURCC_REGULAR (10 + 12)     // 10 ddraw/video, 12 texture

#ifdef DXT_SUPPORT
#define NV_MAX_FOURCC_COMPRESSED 5          // 5 compressed texture
#else
#define NV_MAX_FOURCC_COMPRESSED 0
#endif

#define NV_MAX_FOURCC                       (NV_MAX_FOURCC_REGULAR+NV_MAX_FOURCC_COMPRESSED)

#endif // _NVFOURCC_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\common\inc\nvMultiMon.h ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/
#ifndef _nvMultiMon_h
#define _nvMultiMon_h

//
// This file contains constants shared between the display and miniport drivers for NT40 and Win2K.
// These are used for the MultiMon modes for NV11 dual head cards.
// This file also contains the TwinView definitions (previously in win9x\inc\escape.h) used by Win9x driver and 
// the NT40/Win2K drivers.
//

#ifdef __cplusplus
extern "C"
{
#endif

// Uncomment this line to enable the Win2K hot key driver code  for laptops
#define ENABLE_WIN2K_HOTKEY_CODE

// maximum number of heads this driver supports
#define NV_MAX_HEADS   2

// Some special bitmask definitions for the new head API of resman.
#define BITMASK_CRT0    0x1
#define BITMASK_CRT1    0x2
#define BITMASK_DFP0    0x10000
#define BITMASK_TV0     0x100
#define BITMASK_INVALID_DEVICE 0x0
#define BITMASK_ALL_CRT 0xff
#define BITMASK_ALL_TV 0xff00
#define BITMASK_ALL_DFP 0xff0000

    
//
// The table entries were taken from the GTF table in the miniport in vesadata.c
// Returns true if the resolution specified by (modeWidth, modeHeight) is a horizontally doubled resolution.
//
#define HORIZONTAL_MODE(modeWidth, modeHeight) \
        (\
            (modeWidth == 2048 * 2 && modeHeight == 1536 * 1) ||\
            (modeWidth == 1920 * 2 && modeHeight == 1440 * 1) ||\
            (modeWidth == 1920 * 2 && modeHeight == 1200 * 1) ||\
            (modeWidth == 1920 * 2 && modeHeight == 1080 * 1) ||\
            (modeWidth == 1856 * 2 && modeHeight == 1392 * 1) ||\
            (modeWidth == 1800 * 2 && modeHeight == 1440 * 1) ||\
            (modeWidth == 1792 * 2 && modeHeight == 1344 * 1) ||\
            (modeWidth == 1600 * 2 && modeHeight == 1200 * 1) ||\
            (modeWidth == 1600 * 2 && modeHeight == 1024 * 1) ||\
            (modeWidth == 1600 * 2 && modeHeight == 1000 * 1) ||\
            (modeWidth == 1600 * 2 && modeHeight == 900 * 1) ||\
            (modeWidth == 1600 * 2 && modeHeight == 880 * 1) ||\
            (modeWidth == 1400 * 2 && modeHeight == 1050 * 1) ||\
            (modeWidth == 1360 * 2 && modeHeight == 768 * 1) ||\
            (modeWidth == 1280 * 2 && modeHeight == 1024 * 1) ||\
            (modeWidth == 1280 * 2 && modeHeight == 960 * 1) ||\
            (modeWidth == 1280 * 2 && modeHeight == 800 * 1) ||\
            (modeWidth == 1280 * 2 && modeHeight == 768 * 1) ||\
            (modeWidth == 1152 * 2 && modeHeight == 864 * 1) ||\
            (modeWidth == 1024 * 2 && modeHeight == 768 * 1) ||\
            (modeWidth == 960 * 2 && modeHeight == 720 * 1) ||\
            (modeWidth == 864 * 2 && modeHeight == 480 * 1) ||\
            (modeWidth == 856 * 2 && modeHeight == 480 * 1) ||\
            (modeWidth == 852 * 2 && modeHeight == 480 * 1) ||\
            (modeWidth == 848 * 2 && modeHeight == 480 * 1) ||\
            (modeWidth == 800 * 2 && modeHeight == 600 * 1) ||\
            (modeWidth == 720 * 2 && modeHeight == 480 * 1) ||\
            (modeWidth == 640 * 2 && modeHeight == 480 * 1) ||\
            (modeWidth == 640 * 2 && modeHeight == 400 * 1) ||\
            (modeWidth == 512 * 2 && modeHeight == 384 * 1) ||\
            (modeWidth == 480 * 2 && modeHeight == 360 * 1) ||\
            (modeWidth == 400 * 2 && modeHeight == 300 * 1) ||\
            (modeWidth == 320 * 2 && modeHeight == 240 * 1) ||\
            (modeWidth == 320 * 2 && modeHeight == 200 * 1)\
        )

//
// The table entries were taken from the GTF table in the miniport in vesata.c
// Returns true if the resolution specified by (modeWidth, modeHeight) is a vertically doubled resolution.
//
#define VERTICAL_MODE(modeWidth, modeHeight) \
        (\
            (modeWidth == 2048 * 1 && modeHeight == 1536 * 2) ||\
            (modeWidth == 1920 * 1 && modeHeight == 1440 * 2) ||\
            (modeWidth == 1920 * 1 && modeHeight == 1200 * 2) ||\
            (modeWidth == 1920 * 1 && modeHeight == 1080 * 2) ||\
            (modeWidth == 1856 * 1 && modeHeight == 1392 * 2) ||\
            (modeWidth == 1800 * 1 && modeHeight == 1440 * 2) ||\
            (modeWidth == 1792 * 1 && modeHeight == 1344 * 2) ||\
            (modeWidth == 1600 * 1 && modeHeight == 1200 * 2) ||\
            (modeWidth == 1600 * 1 && modeHeight == 1024 * 2) ||\
            (modeWidth == 1600 * 1 && modeHeight == 1000 * 2) ||\
            (modeWidth == 1600 * 1 && modeHeight == 900 * 2) ||\
            (modeWidth == 1600 * 1 && modeHeight == 880 * 2) ||\
            (modeWidth == 1400 * 1 && modeHeight == 1050 * 2) ||\
            (modeWidth == 1360 * 1 && modeHeight == 768 * 2) ||\
            (modeWidth == 1280 * 1 && modeHeight == 1024 * 2) ||\
            (modeWidth == 1280 * 1 && modeHeight == 960 * 2) ||\
            (modeWidth == 1280 * 1 && modeHeight == 800 * 2) ||\
            (modeWidth == 1280 * 1 && modeHeight == 768 * 2) ||\
            (modeWidth == 1152 * 1 && modeHeight == 864 * 2) ||\
            (modeWidth == 1024 * 1 && modeHeight == 768 * 2) ||\
            (modeWidth == 960 * 1 && modeHeight == 720 * 2) ||\
            (modeWidth == 864 * 1 && modeHeight == 480 * 2) ||\
            (modeWidth == 856 * 1 && modeHeight == 480 * 2) ||\
            (modeWidth == 852 * 1 && modeHeight == 480 * 2) ||\
            (modeWidth == 848 * 1 && modeHeight == 480 * 2) ||\
            (modeWidth == 800 * 1 && modeHeight == 600 * 2) ||\
            (modeWidth == 720 * 1 && modeHeight == 480 * 2) ||\
            (modeWidth == 640 * 1 && modeHeight == 480 * 2) ||\
            (modeWidth == 640 * 1 && modeHeight == 400 * 2) ||\
            (modeWidth == 512 * 1 && modeHeight == 384 * 2) ||\
            (modeWidth == 480 * 1 && modeHeight == 360 * 2) ||\
            (modeWidth == 400 * 1 && modeHeight == 300 * 2) ||\
            (modeWidth == 320 * 1 && modeHeight == 240 * 2) ||\
            (modeWidth == 320 * 1 && modeHeight == 200 * 2)\
        )

//
// Returns TRUE if the mode is a dual screen multi mon mode. It can beeither horizontal or vertical.
//
#define MULTIMON_MODE(modeWidth, modeHeight)\
        (HORIZONTAL_MODE(modeWidth, modeHeight) || VERTICAL_MODE(modeWidth, modeHeight))

//
// Fills in a nvRECTL structure (which is the same structure as RECTL).
//
#define SET_RECT(nvRECTLPtr, leftVal, topVal, rightVal, bottomVal)\
{\
    (nvRECTLPtr)->left = (leftVal);\
    (nvRECTLPtr)->top =  (topVal);\
    (nvRECTLPtr)->right =  (rightVal);\
    (nvRECTLPtr)->bottom =  (bottomVal);\
}



//******************************************************************************
// Bitmask flag for support desktop
// NOTE: These definitions must match those in the NV miniport's 'NV.h'!
//******************************************************************************
//
// 31            24 23           16                               0
// .-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-.
// |  Secondary        Primary             Master Flag             |
// `-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-'
//
// Master Flag            : bit 0 - bit 15
// Primary Display Flag   : bit 16 - bit 23
// Secondary Display Flag : bit 24 - bit 31
//
//******************************************************************************
#define NV_VIRTUAL_DESKTOP_1        0x00010000
#define NV_VIRTUAL_DESKTOP_2        0x01000000

// NV_SPANNING_MODE is virtual desktop (cxScreen, cyScreen) enabled.
// ie, ppdev->ulMode to mode table resolution does not match to (cxScreen, cyScreen)
// additional information for set mode is passed from IOCTL_VIDEO_SET_DESKTOP_INFO_MODE
// to miniport driver.

#define NV_TWO_DACS                 0x01
#define NV_CLONE_DESKTOP            0x02
#define NV_SPANNING_MODE            0x04
#define NV_ENABLE_CLASS_SET_MODE    0x08

#define NV_ENABLE_VIRTUAL_DESKTOP   (NV_VIRTUAL_DESKTOP_1 | NV_VIRTUAL_DESKTOP_2)
//
// Values for the ppdev->ulDACStatus[NV_NO_DACS]
//
#define DAC_STATUS_ON_BOARD      1   // The DAC is onboard.
#define DAC_STATUS_CONNECTED    2   // The DAC is connected to a device (CRT/DFP/TV).
#define DAC_STATUS_ACTIVE       4   // The DAC is active. For example, in spanning mode and clone mode, both dacs are active.
                                    // In normal mode, only one head is active.
//
// Registry key "PanScanSelection"
// absent or 0: pan-scan in only secondary monitor of clone mode.
// 1: Enable pan-scan in all modes.
// 2: Disable pan-scan in all modes. 
//
#define PAN_SCAN_SELECTION_CLONE_SECONDARY_ONLY 0
#define PAN_SCAN_SELECTION_ENABLE_ALL           1
#define PAN_SCAN_SELECTION_DISABLE_ALL          2

//
// A private named event between the control panel and miniport on Win2K.
//
#define NVCPL_EVENT_HOTKEY "NVCplHotKeyEvent"
#define NVCPL_EVENT_HOTKEY_DRIVER "\\BaseNamedObjects\\"NVCPL_EVENT_HOTKEY


//
// Actions to be performed on named events for Win2K/NT4.0
//
#define EVENT_ACTION_CREATE 1
#define EVENT_ACTION_SIGNAL 2
#define EVENT_ACTION_CLEAR  3


//*****************************************************************************
//
// NV11 TwiNView definitions for controlling dual CRTC functionality
// (previously in Win9x\inc\escape.h).
//
typedef struct  _nvRECTL
{
    long    left;
    long    top;
    long    right;
    long    bottom;
}   nvRECTL;
#define NV_NO_DACS  2

//
// The device scan bit flags. Used in Win2K/NT4.0 only.
// These are used for the "ulHeadDeviceOptions" field in the GET_DEVICE_SCAN_DATA escape call.
//
#define HEAD_DEVICE_OPTION_CRT 0x1
#define HEAD_DEVICE_OPTION_DFP 0x2
#define HEAD_DEVICE_OPTION_TV  0x4

//
// This indicates that nothing is connected on this head
//
#define INVALID_DEVICE_TYPE 0x9999

// - Added escapes for the control panel to Get the deviceOptions matrix and to initiate the device scan. And
// - to set the timing mode override.
// - This is for TwinView for Win2K/NT4.0 only.
#define NV_ESC_GET_DEVICE_SCAN_DATA                 0x6992
#define NV_ESC_INDUCE_DEVICE_SCAN                   0x6993

typedef struct _GET_DEVICE_SCAN_DATA_TYPE {
    unsigned long ulNumberDacsOnBoard;
    unsigned long ulNumberDacsConnected;
    unsigned long ulNumberDacsActive;
    unsigned long ulHeadDeviceOptions[NV_NO_DACS];
} GET_DEVICE_SCAN_DATA_TYPE;


// escape for control panel to get the desired deviceMask after the NVSVC is signalled for a device change.
#define NV_ESC_GET_DEVICE_MASK                   0x6994
typedef struct _GET_DEVICE_MASK_DATA_TYPE {
    unsigned long ulDeviceMask;
} GET_DEVICE_MASK_DATA_TYPE;

//
// Support for the hardware icons (such as the battery status for Gateway/Quantas). Used in Win2K/NT4.0 and Win9X/WinME.
// NV_ESC_DISPLAY_ICON: Displays the requested icon as a hardware cursor after caching current cursor.
// NV_ESC_HIDE_ICON: Removes the displayed Icon and restores the desktop cursor to the cached cursor.
//
typedef struct _DISPLAY_ICON_DATA_TYPE {
    unsigned long ulStartX;
    unsigned long ulStartY; // The position of upper left corner of the icon
    unsigned long ulWidth;
    unsigned long ulHeight; // dimensions of the icon bitmap
    void * pvBitmap;        // Bitmap pointer for the 32BPP, ARGB icon
    unsigned long ulFlag;   // For future usage
} DISPLAY_ICON_DATA_TYPE;
#define NV_ESC_DISPLAY_ICON                 0x6996
#define NV_ESC_HIDE_ICON                    0x6997

// DrvEscape function call to disable HW cursor with *(ULONG *)pvIn != FALSE
// if *(ULONG *)pvIn == FALSE, the HW cursor will be re-enabled.
#define NV_ESC_DISABLE_HW_CURSOR            0x6998

//
// DrvEscape() call for the NVSVC to report its current status to the display driver.
//
#define NV_ESC_SET_NVSVC_STATUS            0x6999
//
// The possible NVSVC_STATUS values. At bootup time, display driver will assume a STOPPED status till
// NVSVC makes this call.
//
#define NVSVC_STATUS_STOPPED    0
#define NVSVC_STATUS_STARTED    1
#define NVSVC_STATUS_PAUSED     2

// escape call for the control panel to query the saved settings.
// The input is the QUERY_SAVE_SETTINGS structure and the output is the NVTWINVIEWDATA structure for the
// requested device combo. The caller must have preallocated the memory for the output structure which is
// sizeof(NVTWINVIEWDATA). The display driver saves the settings for standard/clone and span modes. 
// WinXP DualView is not saved since it is all handled directly by the OS and the OS panel.
#define NV_ESC_QUERY_SAVE_SETTINGS            0x7010
// Number of entries in the save settings table. The display driver saves the TwinViewInfo for each
// device and for each device combo in clone and span modes. Currently the devices are CRT0, LCD, TV and CRT1. 
#define NUM_ENTRIES_SAVE_SETTINGS 28
// Input to the query to get the saved settings. Caller should fill up all fields.
typedef struct _QUERY_SAVE_SETTINGS
{
    unsigned long ulState;
    unsigned long ulOrientation;
    unsigned long ulDeviceMask[NV_NO_DACS];
    unsigned long ulDeviceDisplay[NV_NO_DACS]; // Per requirments for example, LCD+CRT is treated 
                                               // as the same combo as CRT+LCD.
} QUERY_SAVE_SETTINGS;
// Input is a fully constructed NVTWINVIEWDATA structure. This structure will be saved in the correct slot
// in the registry "SaveSettings" table for the State+device combo of the NVTWINVIEWDATA structure. 
// No sanity check or validation will be done on
// this input structure. There is no output structure for this escape call.
#define NV_ESC_FORCE_SAVE_SETTINGS  0x7011



// use these values for the "dwFlag" member of NVTWINVIEWDATA
#define NVTWINVIEW_FLAG_GET                      0
#define NVTWINVIEW_FLAG_SET                      1
// use these values for the "dwAction" member of NVTWINVIEWDATA
#define NVTWINVIEW_ACTION_SETGET_STATE           1
#define NVTWINVIEW_ACTION_SETGET_DEVICE_TYPE     2
#define NVTWINVIEW_ACTION_SETGET_VIRTUALDESKTOP  3
#define NVTWINVIEW_ACTION_SETGET_FREEZE_ORIGIN   4
#define NVTWINVIEW_ACTION_SETGET_PRIMARY_CRTC    5
#define NVTWINVIEW_ACTION_SETGET_VIRTUAL_MODE    6
#define NVTWINVIEW_ACTION_SETGET_PHYSICAL_MODE   7

// The following actions are applicable only for NT40 and Win2K. Win9X can ignore this.
#define NVTWINVIEW_ACTION_SETGET_PHYSICAL_VIRTUAL_MODELIST   8
#define NVTWINVIEW_ACTION_SETGET_GDI_MODELIST    9
#define NVTWINVIEW_ACTION_SETGET_PHYSICAL_VIRTUAL_MODE     11

#define NVTWINVIEW_ACTION_VALIDATE_VIRTUAL_MODE  20
#define NVTWINVIEW_ACTION_VALIDATE_PHYSICAL_MODE 21
#define NVTWINVIEW_ACTION_SETGET_TIMING_OVERRIDE 22

// returns the last used TV format in the dwTVFormat member of NVTWINVIEW_DEVICE_TYPE_DATA
#define NVTWINVIEW_ACTION_GET_LAST_TV_FORMAT     23

// These escapes are to support DVD ZOOM under Win9X. (and maybe NT?)
#define NVTWINVIEW_ACTION_LOCK_HWCRTC                       30
#define NVTWINVIEW_ACTION_UNLOCK_HWCRTC                     31
#define NVTWINVIEW_ACTION_SETGET_PHYSICAL_MODE_IMMEDIATE    32

// The following is for Win9X. Win2K/NT4.0 can ignore this.
#define NVTWINVIEW_ACTION_MAP_LOG_TO_PHYS_HEAD   40

#define NVTWINVIEW_ACTION_SETGET_CLONE_GAMMA    41
#define NVTWINVIEW_ACTION_ROTATE_CLONE_DEVICES  42
#define NVTWINVIEW_ACTION_BEGIN_DISPLAY_CHANGE  43
#define NVTWINVIEW_ACTION_END_DISPLAY_CHANGE    44
#define NVTWINVIEW_ACTION_GET_LARGEST_EDID_MODE 45

#ifndef WINNT
// This escape allows changing the display device configration
// all in one escape. The caller can specify STANDARD or CLONE
// state and all the display devices necessary for the state specified.
// Note that this sub-escape only uses the dwFlag and dwAction fields
// from NVTWINVIEWDATA. All other data pertinent to this call are
// in the structure _NVTWINVIEW_DISPLAY_CONFIG below.
//
// On a NVTWINVIEW_FLAG_SET, the structure fields should be as follows:
// dwActiveDevices should contain a 1 bit for each display they want to
//   turn on.
//   Bit 0 -- the primary display
//   Bit 1 -- first clone display
//   etc....
//   (Hopefully this is forward looking to the day when we have N heads).
//   Note that with two heads, as we have at the time of this writing,
//   dwState will either equal 1 for STANDARD mode or 3 for CLONE mode.
//
// dwDeviceMask should contain a 1 bit for each device the caller wants
// to be used.
//   Bits 7:0 indicate CRTs:  Bit 0  = CRT0,  Bit 1  = CRT1, etc...
//   Bits 15:8 indiate TVs:   Bit 8  = TV0,   Bit 9  = TV1,  etc...
//   Bits 23:16 indiate DFPs: Bit 16 = DFP0,  Bit 17 = DFP1, etc...
//   Bits 31:24 are not used.
//
// dwPrimaryDeviceMask should contain a 1 bit in the bit position to
//   indicate which device should be the primary.  The bit defintions
//   are the same as for dwDeviceMask.  Note that only 1 bit should be
//   set in this mask and that the same bit in dwDeviceMask must also
//   be a 1.
//
// dwPhysicalModeFlags should contain a 1 in the same bit positions
//   as the dwDeviceMask for every device that the caller is specifying
//   a new physical mode for. Note that you should never have a 1 in
//   any bit position where dwDeviceMask has a 0.
//   Bits 31:24 are not used.
//
// PhysModes[]  If bit position N of dwPhysicalModeFlags has a 1 in it,
//   then PhysModes[N] is the physical mode to use for that device. Note
//   that the pixel depth is not settable here -- it is determined by the
//   desktop (the virtual mode.) There are two special "physical modes."
//
//   If dwXRes = 0, then the xres and yres for the physical mode will be
//   set to the largest resolution the display device is capable of that
//   does not exceed the desktop resolution.
//
//   If dwXRes = -1, then the xres and yres for the physical mode will be
//   set to the same resolution that the display device had the last time
//   that it was used.
//
// dwSetModesNow   If this is non-0, then the display driver will remap
//   all the display devices and set all the modes within the context of
//   this escape call. If this variable is 0, the display driver just saves
//   the desired state change and expects the caller to issue a
//   ChangeDisplaySettingsEx() in order to get the new state banged into
//   the hardware.
//
// -----------------------------------------------------------------------
// On a NVTWINVIEW_FLAG_GET, the caller fills in the
//   dwPhysicalModeFlags field as described a little ways below. The
//   display driver fills in the following fields on return.
//
// dwActiveDevices will contain a 1 bit for each display that is on
//   Bit 0 -- the primary display
//   Bit 1 -- first clone display
//   etc....
//
// dwDeviceMask will contain a 1 bit for each device in use
//   Bits 7:0 indicate CRTs:  Bit 0  = CRT0,  Bit 1  = CRT1, etc...
//   Bits 15:8 indiate TVs:   Bit 8  = TV0,   Bit 9  = TV1,  etc...
//   Bits 23:16 indiate DFPs: Bit 16 = DFP0,  Bit 17 = DFP1, etc...
//   Bits 31:24 are not used.
//
// dwPrimaryDeviceMask will contain a 1 bit in the bit position to
//   indicate which device is the primary.  The bit defintions
//   are the same as for dwDeviceMask.
//
// PhysModes[]  If bit position N of dwDeviceMask has a 1 in it,
//   then PhysModes[N] is the physical mode either currently set
//   on that device or the maximum physical mode settable on that
//   device depending upon how the caller set the dwPhysicalModeFlags.
//
//  dwPhysicalModeFlags is set by the CALLER. If bit N is a 1,
//   then the driver fills in PhysModes[N] with the CURRENT physical
//   mode on the display device. If bit N is a 0, then the driver
//   fills in PhysModes[N] with the maximal physical mode on the
//   display device.

typedef struct  _PHYSICAL_MODE
{
    unsigned long   dwXRes;
    unsigned long   dwYRes;
    unsigned long   dwRefreshRate;
}   PHYSICAL_MODE;

#define NVTWINVIEW_ACTION_SETGET_DISPLAY_CONFIG 50
typedef struct  _NVTWINVIEW_DISPLAY_CONFIG
{
    unsigned long   dwActiveDevices;
    unsigned long   dwDeviceMask;
    unsigned long   dwPrimaryDeviceMask;
    unsigned long   dwPhysicalModeFlags;
    PHYSICAL_MODE   PhysModes[24];
    unsigned long   dwSetModesNow;
}   NVTWINVIEW_DISPLAY_CONFIG;
#endif

// use these values for the "dwState" member of NVTWINVIEWDATA
#define NVTWINVIEW_STATE_NORMAL                 0
#define NVTWINVIEW_STATE_MULTIMON               1 // to be deleted
#define NVTWINVIEW_STATE_DUALVIEW               1
#define NVTWINVIEW_STATE_CLONE                  2
#define NVTWINVIEW_STATE_SPAN                   3

// When the NVTWINVIEW_ACTION_SETGET_STATE escape is issued,
// a return of the following values in dwSuccess of NVTINWVIEWDATA
// indicates what is needed to make the state change happen.
#define NVTWINVIEW_STATE_CHANGE_FAILED          0
#define NVTWINVIEW_STATE_CHANGE_DONE            1
#define NVTWINVIEW_STATE_CHANGE_NEEDS_REBOOT    2

// use these values for the "dwAutoPan" member of NVTWINVIEW_AUTOPAN_DATA
#define NVTWINVIEW_VIRTUALDESKTOP_OFF           0
#define NVTWINVIEW_VIRTUALDESKTOP_ON            1

// use these values for the "dwState" member of NVTWINVIEWDATA
#define NVTWINVIEW_STATE_AUTO                   0
#define NVTWINVIEW_STATE_DMT                    1
#define NVTWINVIEW_STATE_GTF                    2

// use these values for the "ulTimingOverRide" field of NVTWINVIEW_DEVICE_TYPE_DATA. Used only in Win2K and NT4.0
#define TIMING_OVERRIDE_AUTO                    0
#define TIMING_OVERRIDE_DMT                     1
#define TIMING_OVERRIDE_GTF                     2

typedef struct {
unsigned long dwDeviceMask;        // A unique bitmask in a 32 bit Dword identifying
                                    // this specific output device. (as defined in NVCM.H)

   unsigned long dwDeviceType;      // Monitor, DFP, TV (as defined in NVCM.H)
   unsigned long dwTVFormat;        // Format for TV    (as defined in NVCM.H)
   unsigned long dwXRes;            // Horizontal resolution of secondary device in clone mode (in pixels). Used only by Win9X.
   unsigned long dwYRes;            // Vertical resolution of secondary device in clone mode (in Pixels). Used only by Win9X.
   unsigned long dwBpp;             // For Win9X: color depth of secondary device in clone mode (in Bits per pixel)
                                    // For Win2K/NT40: color depth of this head. The color depths of both heads will be the same.
   unsigned long dwRefresh;         // For Win9X: refresh rate of secondary device in clone mode (actual rate in Hz or 1 for "optimal" or 0 for "default")
                                    // For Win2K/NT40: refresh rate of this head (actual rate in Hz or 1 for "optimal" or 0 for "default"), the
                                    // refresh rates can be different for each head.

   // The following fields are applicable only for NT40 and Win2K. Win9X can ignore this.
   unsigned long dwNumPhysModes;    // The number of physical modes supported by the device. This list is obtained after
                                    // an intersection of EDID and the registry modes. If the device has no EDID, then this
                                    // list simply equals the registry modelist.
   unsigned long dwNumVirtualModes; // The number of virtual modes supported by the device. This list is obtained after
                                    // an intersection of registry modes and the board frame buffer size. 
   nvRECTL    PhysicalRectl;        // Physical coordinates of the device.
   nvRECTL    VirtualRectl;         // Virtual coordinates of the device.
   unsigned long dwEnableDDC; 
   unsigned long dwEnablePanScan;   // Enables the virtual desktop to let the physical resolution
                                    // to be less than the virtual resolution.
   unsigned long dwFreezePanScan;   // Freeze the pan-scan
   unsigned long dwFreezeOriginX;   // The user specified upper left corner for freezing the pan-scan.
   unsigned long dwFreezeOriginY;   // The user specified upper left corner for freezing the pan-scan.
   unsigned long dwTimingOverRide;  // GTF or DMT preference by the user.


} NVTWINVIEW_DEVICE_TYPE_DATA;

typedef struct {
   unsigned long dwVirtualDesktop;  // Virtual Desktop On/Off (clone mode only)
   unsigned long dwPad;
}  NVTWINVIEW_VIRTUALDESKTOP_DATA;

typedef struct {
   unsigned long dwFreezeOrigin;    // Freeze Origin On/Off (clone mode only)
   unsigned long dwOriginX;         // freeze mode x origin (clone mode only)
   unsigned long dwOriginY;         // freeze mode y origin (clone mode only)
}  NVTWINVIEW_FREEZE_ORIGIN_DATA;

typedef struct {
   unsigned long pHWCrtcCX;
   unsigned long pGNLogdevCX;
   unsigned long dwLogicalCrtcIndex;
   unsigned long dwPad;
}  NVTWINVIEW_LOCK_UNLOCK_HWCRTC_DATA;

typedef struct {
   unsigned long pHWCrtcCX;
   unsigned long pGNLogdevCX;
   unsigned long dwLogicalCrtcIndex;
   unsigned long dwPad;
}  NVTWINVIEW_SETGET_PHYSICAL_MODE_IMMEDIATE;




// The mode_entry structure is copied from miniport\nv_mini\nv.h. Anychanges in one file should be reflected
// in the other.
struct Mode_Entry
   {
   unsigned short  ValidMode;
   unsigned short  Width;
   unsigned short  Height;
   unsigned short  Depth;
   unsigned short  RefreshRate;
#ifndef WINNT
   unsigned short  wPad;
   unsigned long   dwPad;
#endif
   };
typedef struct Mode_Entry *PMODE_ENTRY, MODE_ENTRY;

// Toshiba wants to keep the same desktop on hotkey switches.
typedef MODE_ENTRY TOSHIBA_HOTKEY_MODE;

// This is per head information
typedef struct {
   MODE_ENTRY * PhysModeEntries;         // Pointer to alloced memory for the physical mode list.
   unsigned long dwNumPhysModeEntries;   // The number of mode entries in the alloced memory for the physical mode list.
   MODE_ENTRY * VirtualModeEntries;         // Pointer to alloced memory for the physical mode list.
   unsigned long dwNumVirtualModeEntries;   // The number of mode entries in the alloced memory for the physical mode list.

   unsigned long dwDeviceMask;  // Return the modelist info for this deviceMask

   unsigned long dwDeviceType;  // Return the modelist info for this deviceType on this head
   unsigned long dwTVFormat;    // Return the modelist info for this TV format on this head
}  NVTWINVIEW_MODELIST_DATA;

// Values for the dwOrientation field
#define HORIZONTAL_ORIENTATION  1
#define VERTICAL_ORIENTATION    2


typedef struct {
   unsigned long dwFlag;            // flag indicating GET or SET
   unsigned long dwAction;          // indicates action to be performed
   unsigned long dwState;           // normal, multi-mon, clone
   unsigned long dwCrtc;            // indicates CRT number for which action is performed. Used only by Win9X.
                                    // The actions apply to all the heads in Win2K and NT40.
   unsigned long dwSuccess;         // indicates success of call. Driver should return non-zero in this member
                                    // if the escape is successfully handled, or zero for failure
   nvRECTL    DeskTopRectl;           // The overall desktop rectangle. The (left,top) is always (0, 0).
                                    // Applicable only for Win2K and NT40. Win9X can ignore it.
   unsigned long dwBoard;           // The board number in a multi-adapter system.
                                    // Applicable only for NT40. Win9X and Win2K can ignore it.
   unsigned long dwOrientation;     // Horizontal or vertical. For multi-mon mode only.
                                    // Applicable only for NT4.0 and Win2K. Win9x can ignore this.
   unsigned long dwDeviceDisplay[NV_NO_DACS]; // Dynamically switch device; ulDeviceDisplay[0] will be primary; head 0 or head 1
                                    // Applicable only for NT4.0 and Win2K. Win9x can ignore this.

   unsigned long dwAllDeviceMask;  // Bitmask for all the output device connectors in the board. NT4.0/Win2K only.
   unsigned long dwConnectedDeviceMask;  // Bitmask for all the output device connectors in the board. NT4.0/Win2K only.
                                    


   union {
       NVTWINVIEW_DEVICE_TYPE_DATA nvtwdevdata[NV_NO_DACS]; // use with action NVTWINVIEW_ACTION_SETGET_DEVICE_TYPE and NVTWINVIEW_ACTION_SETGET_STATE (if
                                    // dwState == NVTWINVIEW_STATE_CLONE)

       NVTWINVIEW_VIRTUALDESKTOP_DATA    nvtwvirtualdesktopdata;  // use with action NVTWINVIEW_ACTION_SETGET_VIRTUALDESKTOP

       NVTWINVIEW_FREEZE_ORIGIN_DATA nvtwfreezedata; // use with action NVTWINVIEW_ACTION_SETGET_FREEZE_ORIGIN
                                      // Note: union is ignored for  and NVTWINVIEW_ACTION_SETGET_PRIMARY_CRTC and
                                      // NVTWINVIEW_ACTION_SETGET_STATE (if dwState != NVTWINVIEW_STATE_CLONE)

       NVTWINVIEW_MODELIST_DATA   nvtwModeListData[NV_NO_DACS]; // Applicable only for Win2K and NT40. Win9X can ignore it.
                                                    // Use with actions NVTWINVIEW_ACTION_SETGET_PHYS_MODELIST and
                                                    // NVTWINVIEW_ACTION_SETGET_GDI_MODELIST.
#ifndef WINNT
        NVTWINVIEW_DISPLAY_CONFIG  nvtwDisplayConfig;
        unsigned long adwGammaTable[256];
#endif
   } NVTWINVIEWUNION;

   NVTWINVIEW_LOCK_UNLOCK_HWCRTC_DATA nvtwLockUnlockHwcrtc;
   NVTWINVIEW_SETGET_PHYSICAL_MODE_IMMEDIATE nvtwPhysicalModeImmediate;
} NVTWINVIEWDATA;


#ifdef __cplusplus
}
#endif

#endif // _nvPM_h
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\common\inc\nvioctl.h ===
#ifndef _nvioctl_h_
#define _nvioctl_h_

/*
** Copyright 1991-1999, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** $Header$
*/

#include <sys/ioctl.h>

/*
** IOCTLs defines and structures common between the kernel and the GL
*/

/* ---  first the defines --- */
#define IOCTL_NV_OPENGL                         1

#define IOCTL_NV_OPENGL_GET_SINGLE_BACK_1       1
#define IOCTL_NV_OPENGL_GET_SINGLE_DEPTH        2
#define IOCTL_NV_OPENGL_FREE_SINGLE_BACK_DEPTH  3

/* --- now the structure definitions --- */

typedef struct NvOpenGLCommandRec {
    int 	command;
    void *      ret;
} NvOpenGLCommand;

#endif /* _nvioctl_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\common\inc\nvOverlay.h ===
#ifndef __gl_nvOverlay_h_
#define __gl_nvOverlay_h_

/*
 * Copyright (c) 2000, Nvidia Corporation.  All rights reserved.
 * Portions Copyright (c) 1996, 1997, Silicon Graphics Inc.
 */

// RBiermann: add global definitions for OpenGL Overlay Planes here:

// the number of palette entries
#define ICD_PALETTE_ENTRIES 256

// layer palette transparent index
#define ICD_PALETTE_TRANSPARENT_INDEX 0

// the transparent color is black
#define ICD_PALETTE_TRANSPARENT_COLOR 0

#endif  /* __gl_nvOverlay_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\common\inc\nvPixelFmt.h ===
#ifndef __gl_nvPixelFmt_h_
#define __gl_nvPixelFmt_h_

/*
 * Copyright (c) 1997, Nvidia Corporation.  All rights reserved.
 * Portions Copyright (c) 1996, 1997, Silicon Graphics Inc.
 */

#if defined(WIN32)
/* Remember, this file is used by non-Win32 OpenGL drivers, too. */

int STDCALL __wglNVDescribePixelFormat(int bpp, int iLayerPlane, int iPixelFormat,
                                       unsigned int nBytes,
                                       PIXELFORMATDESCRIPTOR *ppfd,
                                       LAYERPLANEDESCRIPTOR *plpd,
                                       int flags,
                                       int showExtended);

#define NUM_PIXELFORMATS_16 6
#define NUM_PIXELFORMATS_16_OVERLAY 10
#define NUM_PIXELFORMATS_16_STEREO  8
#define NUM_NV20_PIXELFORMATS_16 6
#define NUM_PIXELFORMATS_32 10
#define NUM_PIXELFORMATS_32_OVERLAY 16
#define NUM_PIXELFORMATS_32_STEREO  12
#define NUM_NV11_PIXELFORMATS_32 15

extern PIXELFORMATDESCRIPTOR *NV4PixelFormats16[NUM_PIXELFORMATS_16];
extern PIXELFORMATDESCRIPTOR *NV4PixelFormats16Stereo[NUM_PIXELFORMATS_16_STEREO];
extern PIXELFORMATDESCRIPTOR *NV20PixelFormats16[NUM_NV20_PIXELFORMATS_16];
extern PIXELFORMATDESCRIPTOR *NV4PixelFormats32[NUM_PIXELFORMATS_32];
extern PIXELFORMATDESCRIPTOR *NV4PixelFormats32Overlay[NUM_PIXELFORMATS_32_OVERLAY];
extern PIXELFORMATDESCRIPTOR *NV4PixelFormats32Stereo[NUM_PIXELFORMATS_32_STEREO];
extern PIXELFORMATDESCRIPTOR *NV11PixelFormats32[NUM_NV11_PIXELFORMATS_32];

#endif /* defined(WIN32) */

#define NV_PFD_SUPPORTS_COLOR32_DEPTH16    0x00000001 /* nv11 */
#define NV_PFD_SUPPORTS_COLOR16_DEPTH32    0x00000002 /* nv20 */
#define NV_PFD_SUPPORTS_OVERLAYS           0x00000004
#define NV_PFD_SUPPORTS_SWAPCOPYONLY       0x00000008
#define NV_PFD_SUPPORTS_SWAP_LAYER_BUFFERS 0x00000010
#define NV_PFD_SUPPORTS_STEREO             0x00000020
#define NV_PFD_SUPPORTS_PBUFFERS           0x00000040
#define NV_PFD_SUPPORTS_MULTISAMPLE        0x00000080

// ---------- Internal Nvidia Pixel Format structure ---------------------

// bits for flags1
#define NVPF_DRAW_TO_WINDOW       0x00000001
#define NVPF_DRAW_TO_BITMAP       0x00000002
#define NVPF_DRAW_TO_PBUFFER      0x00000004
#define NVPF_NEED_PALETTE         0x00000008
#define NVPF_NEED_SYSTEM_PALETTE  0x00000010
#define NVPF_SWAP_LAYER_BUFFERS   0x00000020
#define NVPF_SUPPORT_GDI          0x00000040
#define NVPF_SUPPORT_OPENGL       0x00000080
#define NVPF_DOUBLE_BUFFER        0x00000100
#define NVPF_STEREO               0x00000200
#define NVPF_SHARE_DEPTH          0x00000400
#define NVPF_SHARE_STENCIL        0x00000800
#define NVPF_SHARE_ACCUM          0x00001000
#define NVPF_TRANSPARENCY         0x00002000

typedef enum {
	NVPF_SWAP_UNDEFINED,
    NVPF_SWAP_COPY,
    NVPF_SWAP_EXCHANGE
} __GLNVswapMethod;

typedef enum {
    NVPF_PIXEL_RGBA,
    NVPF_PIXEL_COLOR_INDEX
} __GLNVpixelType;

typedef struct __GLNVpixelFormatRec {
    NvU32            flags1;
    __GLNVswapMethod swapMethod;
    __GLNVpixelType  pixelType;
    unsigned int     numOverlays;
    unsigned int     numUnderlays;
    unsigned int     colorBits;
    unsigned int     redBits;
    unsigned int     redShift;
    unsigned int     greenBits;
    unsigned int     greenShift;
    unsigned int     blueBits;
    unsigned int     blueShift;
    unsigned int     alphaBits;
    unsigned int     alphaShift;
    unsigned int     accumBits;
    unsigned int     accumRedBits;
    unsigned int     accumGreenBits;
    unsigned int     accumBlueBits;
    unsigned int     accumAlphaBits;
    unsigned int     depthBits;
    unsigned int     stencilBits;
    unsigned int     auxBuffers;
    unsigned int     transparentRed;
    unsigned int     transparentGreen;
    unsigned int     transparentBlue;
    unsigned int     transparentAlpha;
    unsigned int     transparentIndex;
    unsigned int     maxPbufferPixels;
    unsigned int     maxPbufferWidth;
    unsigned int     maxPbufferHeight;
    unsigned int     sampleBuffers;
    unsigned int     samples;
} __GLNVpixelFormat;

#endif  /* __gl_nvPixelFmt_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\common\inc\nvOverlaySurf.h ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-2000 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/

#ifndef _NVOVERLAYSURF_H_
#define _NVOVERLAYSURF_H_

#define NVDBG_LEVEL_OVERLAY_INFO 0x80000000

#ifdef DEBUG

#define NV_DBG_SHOW_FOURCC()                                                    \
    char fourCCStr[5];                                                          \
    fourCCStr[0] = (char)pSurf->lpGbl->ddpfSurface.dwFourCC & 0xFF;             \
    fourCCStr[1] = (char)(pSurf->lpGbl->ddpfSurface.dwFourCC >> 8) & 0xFF;      \
    fourCCStr[2] = (char)(pSurf->lpGbl->ddpfSurface.dwFourCC >> 16) & 0xFF;     \
    fourCCStr[3] = (char)(pSurf->lpGbl->ddpfSurface.dwFourCC >> 24) & 0xFF;     \
    fourCCStr[4] = 0;                                                           \
    DPF_LEVEL (NVDBG_LEVEL_OVERLAY_INFO, "FOURCC %s allocation: size=%u bytes", \
               &fourCCStr, dwBlockSize );

#else // NOT DEBUG

#define NV_DBG_SHOW_FOURCC()

#endif // DEBUG

// external functions

extern DWORD VppCreateFourCCSurface(Vpp_t *pVpp, LPDDRAWI_DDRAWSURFACE_LCL pSurf, LPDDRAWI_DIRECTDRAW_GBL pDDGbl, DWORD dwExtraSize, DWORD dwExtraNumSurfaces, DWORD dwBlockHeight);
extern void VppCalcExtraSurfaceSpace(Vpp_t *pVpp, LPDDRAWI_DDRAWSURFACE_LCL pDDSLcl, NvU32 displayHeight, NvU32 dwRequestedSurfaces, NvU32 *dwExtraSize, NvU32 *dwExtraNumSurfaces, NvU32 *dwBlockHeight);
#endif // _DDSURF4CC_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\common\inc\nvPatchInterface.h ===
//**************************************************************************
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// **************************************************************************
//
//  Module: nvPatchInterface.h
//        nvPatchInterface specification to allow for shared ogl/d3d access
//
//  History:
//        Daniel Rohrer    (drohrer)      23Jun00      created
//
// **************************************************************************

// using generic C structs for shared library compatability with OGL.

#ifndef __NV_PATCH_INTERFACE_H
#define __NV_PATCH_INTERFACE_H

#include "nvUniversal.h"
#if !defined(IS_OPENGL)
    #define FASTCALL _fastcall
#else
    #include "os.h"
#endif

// FD mutual exclusion 
#define FD_SEMAPHORE_HANDLE                                     0xDDFD0000
#define FD_SEMAPHORE_206E_CONTEXT_DMA                           0xDDFD0001
#define FD_SEMAPHORE_097_CONTEXT_DMA                            0xDDFD0002
//          ... 1-32 should be considered used here for our channels ... 
//#define FD_SEMAPHORE_CONTEXT_DMA                              0xDDFD0020

/*
** Standard polymorphic data types that are not present in older header files.
*/
#if defined(_WIN32) && (_MSC_VER < 1300)

typedef int            intptr_t;
typedef unsigned int   uintptr_t;

#endif

/*****************************************************************************/
// Eval memory allocation. Avoid seperate malloc for each section of memory.
// allocate a big chunk with EV_ALLOC_INIT
// and dole it out efficiently with EV_ALLOC
// free it with EV_FREE
// Only one DECL per routine.
// Use EV_ALLOC_INIT/EV_FREE to alloc/free within a routine.

// To alloc something that will persist to parallel or higher routines,
// use EV_ALLOC_INIT_WITH_CACHE with a NV_PATCH_ALLOC_CACHE
// The higher level routines must free with EV_FREE_CACHE

// Use EV_ALLOC_RESET to use memory chunk allocated by higher level routine.
//
// Use EV_ROUND if necessary to ensure allocations have pointer sized
// granularity to avoid address exceptions on the IA64.

// used by cached-alloc algorithm to avoid allocs on each imm mode call
// Each call to EV_ALLOC_INIT_WITH_CACHE can specify a cache to use.
// The coder must be careful that a cache is not used twice at a time.
#if !defined(IS_OPENGL)
typedef struct {
        void *pBaseCache;
        int bytesAllocCache;
        int countFreeCheck;     // count times past a potential free point
        int inUse;              // for debug check
        void *contextCache;     // for debug check
} NV_PATCH_ALLOC_CACHE;
#define MAX_EV_CACHE                        10

#else
// for OpenGL, these are defined in eval.h
#endif

typedef struct {
        void *context;
        void *pBase;
        void *pAvail;
        void *pAllocatedBase;
        int bytesAlloc;
        int bytesUsed;
        NV_PATCH_ALLOC_CACHE *pCache; // ptr to higher level cache structure
} NV_PATCH_ALLOC_CONTROL;

#define EV_ALLOC_BYTE_ALIGN              0x10
#define EV_CACHE_INFO_SCRATCH               0
#define EV_CACHE_QUADINFO_ETC               1
#define EV_CACHE_9FDMATRICES                2
#define EV_CACHE_AUTO_NORMAL_SETUP          3
#define EV_CACHE_UV_SETUP                   4
#define EV_CACHE_TRI_WEIGHTS                5
#define EV_CACHE_RETESS0                    6
#define EV_CACHE_RETESS1                    7
#define EV_CACHE_DRAW_SW                    8
#define EV_CACHE_SWATHING                   9
// if you add more after '9', you must change MAX_EV_CACHE


#define EV_ALLOC_DECL() NV_PATCH_ALLOC_CONTROL evMemory = {NULL, 0}

#define EV_ALLOC_INIT_WITH_CACHE(CONTEXT, TBYTES, errorLabel, PCACHE) \
        if (evAllocInitWithCache(info, CONTEXT, &evMemory, TBYTES, PCACHE)) { \
evAllocError: \
            nvAssert(("EV_ALLOC_INIT FAILURE",0)); \
            info->retVal |= NV_PATCH_EVAL_ERR_OUT_OF_MEMORY; \
            goto errorLabel; \
        } \

#define EV_ALLOC_INIT_WITH_CACHE2(CONTEXT, TBYTES, errorLabel, PCACHE) \
        if (evAllocInitWithCache(info, CONTEXT, &evMemory, TBYTES, PCACHE)) { \
            nvAssert(("EV_ALLOC_INIT FAILURE",0)); \
            info->retVal |= NV_PATCH_EVAL_ERR_OUT_OF_MEMORY; \
            goto errorLabel; \
        } \

#define EV_ALLOC_INIT(CONTEXT, TBYTES, errorLabel) \
        EV_ALLOC_INIT_WITH_CACHE(CONTEXT, TBYTES, errorLabel, NULL)

#if defined(IS_OPENGL)
#define EV_ALLOC(VAR, CONTEXT, BYTES) {                             \
        int __nBytes;                                               \
        nvAssert(CONTEXT == evMemory.context);                      \
        nvAssert(!((BYTES) & (EV_ALLOC_BYTE_ALIGN - 1)));           \
        evMemory.bytesUsed += (__nBytes = (BYTES));                 \
        nvAssert(evMemory.bytesUsed <= evMemory.bytesAlloc);        \
        if (evMemory.bytesUsed <= evMemory.bytesAlloc) {            \
            *(void **)(&(VAR)) = evMemory.pAvail;                   \
            evMemory.pAvail = (char *)evMemory.pAvail + __nBytes;   \
            nvAssert(!((uintptr_t)evMemory.pAvail & ((sizeof(void *) - 1)))); \
        } else {                                                    \
            VAR = NULL;                                             \
        }                                                           \
        if (!VAR) goto evAllocError;                                \
    }
#else
#define EV_ALLOC(VAR, CONTEXT, BYTES) {                             \
        int __nBytes;                                               \
        nvAssert(!((BYTES) & (EV_ALLOC_BYTE_ALIGN - 1)));           \
        evMemory.bytesUsed += (__nBytes = (BYTES));                 \
        nvAssert(evMemory.bytesUsed <= evMemory.bytesAlloc);        \
        if (evMemory.bytesUsed <= evMemory.bytesAlloc) {            \
            *(void **)(&(VAR)) = evMemory.pAvail;                   \
            evMemory.pAvail = (char *)evMemory.pAvail + __nBytes;   \
            nvAssert(!((uintptr_t)evMemory.pAvail & ((sizeof(void *) - 1)))); \
        } else {                                                    \
            VAR = NULL;                                             \
        }                                                           \
        if (!VAR) goto evAllocError;                                \
    }
#endif

#define EV_ALLOC_FULL(CONTEXT) \
        /* expect equal if pre-calc was accurate */ \
        nvAssert(evMemory.bytesUsed == evMemory.bytesAlloc);

#define EV_FREE(VAR, CONTEXT) { \
        nvAssert(CONTEXT == evMemory.context); \
        if (evMemory.pBase && (VAR)) { \
            if (!evMemory.pCache) { \
                info->callbacks->free(CONTEXT, evMemory.pAllocatedBase); \
            } else { \
                evMemory.pCache->inUse = 0; \
            } \
            evMemory.pBase = NULL; \
            evMemory.pAllocatedBase = NULL; \
        } \
        VAR = NULL; \
    }

#define EV_FREE_CACHE(PCACHE, CONTEXT) { \
        if ((PCACHE)->pBaseCache) { \
            info->callbacks->free((PCACHE)->CONTEXT, (PCACHE)->pBaseCache); \
            (PCACHE)->pBaseCache = NULL; \
        } \
        (PCACHE)->inUse = 0; \
    } \

//#define EV_ROUND(BYTES) \
//    (((BYTES) + (sizeof(void *) - 1)) & ~(sizeof(void *) - 1))

//force 16 byte alignment...
#define EV_ROUND(BYTES) \
    (((BYTES) + (EV_ALLOC_BYTE_ALIGN - 1)) & ~(EV_ALLOC_BYTE_ALIGN - 1))

/*****************************************************************************/
#define NV_PATCH_ATTRIB_POSITION            0
#define NV_PATCH_ATTRIB_VERTEX_WEIGHT       1
#define NV_PATCH_ATTRIB_NORMAL              2
#define NV_PATCH_ATTRIB_COLOR               3
#define NV_PATCH_ATTRIB_SECONDARY_COLOR     4
#define NV_PATCH_ATTRIB_FOG_COORD           5
#define NV_PATCH_ATTRIB_UNUSED0             6
#define NV_PATCH_ATTRIB_UNUSED1             7
#define NV_PATCH_ATTRIB_TEXCOORD0           8
#define NV_PATCH_ATTRIB_TEXCOORD1           9
#define NV_PATCH_ATTRIB_TEXCOORD2           10
#define NV_PATCH_ATTRIB_TEXCOORD3           11
#define NV_PATCH_ATTRIB_TEXCOORD4           12
#define NV_PATCH_ATTRIB_TEXCOORD5           13
#define NV_PATCH_ATTRIB_TEXCOORD6           14
#define NV_PATCH_ATTRIB_TEXCOORD7           15

// Some of the ATTR bit names are used so much, and are so long, 
// they were making line lengths in excess of 140 characters.
// Rather than split the lines, these names have abbreviations
#define ATTR_V  NV_PATCH_ATTRIB_POSITION
#define ATTR_N  NV_PATCH_ATTRIB_NORMAL

//return codes for EvalPatch
#define NV_PATCH_EVAL_OK                 0x1
#define NV_PATCH_EVAL_ERR_OUT_OF_MEMORY  0x10
#define NV_PATCH_EVAL_ERR_NOT_HANDLED    0x20

// D3D, OGL, and Kelvin all use 16 separate vertex attributes.
#define NV_PATCH_NUMBER_OF_ATTRIBS      16

// D3D supports up to 5, OGL supports up to 8, and Kelvin supports up to 16.
// Note that when computing normal patches, an 8th-order nonrational patch
// becomes a 14th-order rational patch, and an 8th-order rational patch
// exceeds the Kelvin limit easily.
#define NV_PATCH_MAX_ORDER              16
#define NV_PATCH_MAX_RETESS             (1+NV_PATCH_MAX_ORDER)

// The maximum size of a swatch is determined by the size of the vertex
// file.   Henry says this is the magic number.  16 might work better, but
// it's not clear.
#define NV_PATCH_KELVIN_SWATCH_SIZE     17


#define NV_PATCH_MAX_TOTAL_STEP 1000    // total steps allowed
#define NV_PATCH_MAX_SWATCH_STEP 40     // max steps within a sub-patch

// When drawing stitch in SW modes, the buffer is this many vertices.
//  +1 because n steps means (n+1) vertices
//  +2 because may need to share 2 vertices between groups of n steps
#define NV_PATCH_MAX_SW_VERTICES (NV_PATCH_MAX_SWATCH_STEP+1+2)

#define EV_AS_INT(x)     (*((int *) &(x)))

typedef float NV_PATCH_CURVE_COEFFS[NV_PATCH_MAX_ORDER][4];
typedef double NV_PATCH_CURVE_COEFFS_D[NV_PATCH_MAX_ORDER][4];

// Matrix structure for matrix math
typedef struct {
    int rows, columns;
    int pad[2];
    NV_PATCH_CURVE_COEFFS data[NV_PATCH_MAX_ORDER];     // [row][col][xyzw]
} FDMatrix;

typedef struct {
    int rows, columns;
    int pad[2];
    NV_PATCH_CURVE_COEFFS_D data[NV_PATCH_MAX_ORDER];   // [row][col][xyzw]
} FDMatrixd;
#define FDMATRIX_HEADER_SIZE    4*sizeof(int)

// For swathing, an array of ptrs to FDMatrices is used to
// find a pointer to a particular FDMatrix given an attribute number
typedef FDMatrix *FDMatrixAttrSet[NV_PATCH_NUMBER_OF_ATTRIBS];

// Evaluated vertex attributes
typedef struct {
   float vertexAttribs[NV_PATCH_MAX_SW_VERTICES][NV_PATCH_NUMBER_OF_ATTRIBS][4];
} NV_PATCH_EVAL_OUTPUT;


// This is given to beginPrimitive to indicate what type of primitive to draw.
typedef enum {
    NV_PATCH_PRIMITIVE_TSTRIP = 1,
    NV_PATCH_PRIMITIVE_TFAN   = 2,
} NV_PATCH_PRIMITIVE_TYPE;

// Information for forward differencing one curve
typedef struct {
    int order;
    int pad[3];
    NV_PATCH_CURVE_COEFFS coeffs;
} NV_PATCH_CURVE_INFO;
#define PATCH_CURVE_HEADER_SIZE     4*sizeof(int)

// For swathing, an array of ptrs to NV_PATCH_CURVE_INFOs is used to
// find a pointer to a particular guard curve given an attribute number
typedef NV_PATCH_CURVE_INFO *FDCurveAttrSet[NV_PATCH_NUMBER_OF_ATTRIBS];

// Enumerant for what basis the patch is defined on
typedef enum {
    NV_PATCH_BASIS_BEZIER      = 0,
    NV_PATCH_BASIS_BSPLINE     = 1,
    NV_PATCH_BASIS_CATMULL_ROM = 2,
} NV_PATCH_BASIS_TYPE;

// Enumerant for the format of the control points
typedef enum {
    NV_PATCH_VERTEX_FORMAT_FLOAT_1 = 0, // Expand to (value,   0.0,   0.0, 1.0)
    NV_PATCH_VERTEX_FORMAT_FLOAT_2 = 1, // Expand to (value, value,   0.0, 1.0);
    NV_PATCH_VERTEX_FORMAT_FLOAT_3 = 2, // Expand to (value, value, value, 1.0);
    NV_PATCH_VERTEX_FORMAT_FLOAT_4 = 3, // No expansion required
    NV_PATCH_VERTEX_FORMAT_D3DCOLOR= 4, // Unpack bytes and remap to [0,1.0]
    NV_PATCH_VERTEX_FORMAT_UBYTE   = 5, // Unpack bytes and remap to [0,1.0]
    NV_PATCH_VERTEX_FORMAT_SHORT_2 = 5, // 2D signed short expanded to (value, value, 0., 1.)
    NV_PATCH_VERTEX_FORMAT_SHORT_4 = 7  // 4D signed short
} NV_PATCH_VERTEX_FORMAT_TYPE;

// Dirty flags for each map
#define NV_PATCH_DIRTY_NONE             0x00000000
#define NV_PATCH_DIRTY_CONTROL_POINTS   0x00000001
#define NV_PATCH_DIRTY_TESSELLATION     0x00000002

// Enumerant for the type of backend
typedef enum {
    NV_PATCH_BACKEND_IMMEDIATE = 1, // call immediately into a NV_PATCH_BACKEND
    NV_PATCH_BACKEND_CELSIUS   = 2, // write a Celsius pushbuffer
    NV_PATCH_BACKEND_KELVIN    = 3, // write a Kelvin pushbuffer
    NV_PATCH_BACKEND_DP2       = 4, // write a DP2 command stream
} NV_PATCH_BACKEND_TYPE;

// Guard information for a single subquad within a fractional tesselation
typedef struct {                                //     |              |
    NV_PATCH_CURVE_INFO *guardU0;               //     |              |center
    NV_PATCH_CURVE_INFO *guardV0;               // Vmid*---UCenter----*-----
    NV_PATCH_CURVE_INFO *guardUCenter;          //     |              |
    NV_PATCH_CURVE_INFO *guardVCenter;          //     |    _         |
    float *uMid;                                //     |   _/|      VCenter
    float *vMid;                                //    V0 _/           |
    float *center;                              //     |/             |
} NV_PATCH_FRAC_GUARD_INFO;                     //     +------U0------*------
                                                //                  Umid

// Guard information for a single attribute for a fractionally tesselated
// tensor product patch
typedef struct {                            //                    u1Mid
    NV_PATCH_CURVE_INFO guardU00;           //       *------U01---->*<-----U11-----*
    NV_PATCH_CURVE_INFO guardU01;           //       |\_            |            _/|
    NV_PATCH_CURVE_INFO guardU10;           //       |  \_          |          _/  |
    NV_PATCH_CURVE_INFO guardU11;           //      V01  _\| 01    VC1    11 |/_  V11
    NV_PATCH_CURVE_INFO guardV00;           //       |              |              |
    NV_PATCH_CURVE_INFO guardV01;           //       v              vcenter        v
    NV_PATCH_CURVE_INFO guardV10;           //  v0Mid*------UC0---->*<-----UC1-----* v1Mid
    NV_PATCH_CURVE_INFO guardV11;           //       ^              ^              ^
    NV_PATCH_CURVE_INFO guardUCenter0;      //       |    _         |         _    |
    NV_PATCH_CURVE_INFO guardUCenter1;      //      V00  _/|  00   VC0    10 |\_  V10
    NV_PATCH_CURVE_INFO guardVCenter0;      //       | _/           |           \_ |
    NV_PATCH_CURVE_INFO guardVCenter1;      //       |/             |             \|
    float u0Mid[4], v0Mid[4], u1Mid[4];     //       *------U00---->*<-----U10-----*
    float v1Mid[4], center[4];              //                    u0Mid
} NV_PATCH_FRAC_QUAD_GUARD_INFO;


// Guard information for a single attribute for a fractionally tesselated
// triangular patch
typedef struct {                            //                +                -
    NV_PATCH_CURVE_INFO guard[3][2];        //               / \               -
    NV_PATCH_CURVE_INFO guardCenter[3];     //              /   \              -
    float mid[3][4];                        //             /     \             -
    float center[4];                        //           g20     g11           -
} NV_PATCH_FRAC_TRI_GUARD_INFO;             //           /         \           -
                                            //          /           \          -
                                            //    mid? +             + mid?    -
                                            //        / \_         _/ \        -
                                            //       /    gc?    gc?   \       -
                                            //      /       \_ _/       \      -
                                            //    g21         + center  g10    -
                                            //    /           |           \    -
                                            //   /           gc?           \   -
                                            //  /             |             \  -
                                            // +------g00-----+------g01-----+ -
                                            //               mid?



// Illustration of quadInfo information.
// Used by all patch styles at the low level swathing and drawing routines
// This is a connonical view assuming that uDir=1 and vDir=1
// The U coordinates are reversed if uDir=0
// The V coordinates are reversed if vDir=0
// Also, pUInner and pVInner may be on the other side of the quad.
//
//     c01                     c11
//      *--------pU1------------*
//      |                    __/|
//      |                   /   |
//      +-----pUInner-------+   |
//      |                   |   |
//      |                   |   |
//      |                   |   |
//     pV0             pVInner pV1
//      |                   |   |
//      |                   |   |
//      |                   |   |
//      |                   |   |
//      |                   |   |
//      +--------pU0--------+---*
//     c00                 pVB c10



// This fake picture of quadInfo below shows transitions on all sides.
// This can never happen, but serves to illustrate the meaning of the
// stitchUBegin/End and stitchVBegin/End values.
// These may be slightly counterintuitive, but that depends on who you are.
// The thing to note is that the regions specified by quadInfo->stitchU* 
// are between curves specified with V. U regions and V curves mix.
// Again, like above, the coordinates of U and V may be reversed if
// the u/vDir is flipped.

//                                 __ quadInfo->stitchVEnd
//                                /
//               c01             /       c11
//                *--------pU1--/---------*  <-- ppGuardSetUEnd at top of regular grid
//                |\__         o       __/|
//                |   \               /   |
// quadInfo->     |   +-pUInnerT------+   |  <-- ppGuardSetUEnd is here if top stitch, quadInfo->pSwatchUEnd for "top" of swatch
//   stitchUBegin---o |               |   |
//                |   pVInnerL        | o---- quadInfo->stitchUEnd
//                |   |               |   |
//               pV0  |        pVInnerR  pV1
//                |   |               |   |
//                |   |               |   |
//                |   +-pUInnerB------+   |  <-- ppGuardSetUBegin is here if bot stitch, quadInfo->pSwatchUBegin for "bot" of swatch
//                | __/         o     \__ |
//                |/             \       \|
//                +--------pU0----\-------*  <-- ppGuardSetUBegin at bot of regular grid
//               c00               \     c10
//                                  \
//                                   -- quadInfo->stitchVBegin

// Following statements use U, but analogously apply equally to V
// ppGuardSetUBegin/UEnd are for the boundaries of the regular grid.
// ppGuardSetUBegin/UEnd may be either pU0, pUInnerL, pUInnerR, or pU1
// see "BEGIN SIMILAR CODE" in nvpatchutil.c
// Some cases are not so obvious, like when the height of the quad
// is only one segment, and there's a top stitch, then
// both ppGuardSetUBegin and UEnd are set to pU0.
// If height is 1, and bot stitch, then both are set to pU1.
// This simplifies other code which must pick off values at the edges of the regular grid.
// Also, ppStitchUInner may be either pU0 or pU1 in degenerate cases.

//
typedef struct {
    // corners of the original control points
    float corners[2][2][4]; // [v][u][xyzw]
} NV_PATCH_CORNER_INFO;

// Common information for any quad drawn by the lower level swathing and drawing code.
// This is for INT/FRAC and QUAD/TRI patches.
typedef struct {
    int nu0, nu1, nv0, nv1;                     // actual number of segments along each edge
    int uMaxSegs, vMaxSegs, uMinSegs, vMinSegs; // MIN and MAX comparing nu0:nu1 and nv0:nv1
    int needUInner, needVInner;                 // set if U/V Inner guards required

    // flags for transitions required.
    // Names refer to original LRTB, not flipped versions or anything
    // HW must render INT and FRAC stitches in order TOP/RIGHT/BOTTOM/LEFT
    int stitchTop, stitchRight, stitchBottom, stitchLeft;

    // These begin/end's mean in the direction of U (L/R) and V (B/T)
    // note: you may find these names confusing, since they don't correspond
    // to U0, U1. In other words, stitchVBegin means U0/UInner create a stitch
    // (in the canonical view).
    // But, we decided to leave things well enough alone.
    int stitchUBegin, stitchUEnd, stitchVBegin, stitchVEnd;

    int u0Dir, v0Dir, u1Dir, v1Dir; // '1' means normal direction (For u this is L-->R, for v this is B-->T)
    int oldu0Dir, oldv0Dir, oldu1Dir, oldv1Dir;

    // MaxDir are directions of regular grid
    int uMaxDir, vMaxDir;
    int olduMaxDir, oldvMaxDir;

    float du0, du1, dv0, dv1, duMax, dvMax; // small step size along edges, and for regular grid

    FDCurveAttrSet pU0;
    FDCurveAttrSet pU1;
    FDCurveAttrSet pV0;
    FDCurveAttrSet pV1;
    FDCurveAttrSet pUInner;
    FDCurveAttrSet pVInner;

    NV_PATCH_CORNER_INFO cornAttr[NV_PATCH_NUMBER_OF_ATTRIBS];      // general guard info
    float *pCorners[NV_PATCH_NUMBER_OF_ATTRIBS][2][2];

    // ptrs to set of edge curves for a given swatch
    FDCurveAttrSet *pSwatchUBegin, *pSwatchUEnd;
    FDCurveAttrSet *pSwatchVBegin, *pSwatchVEnd;

    FDCurveAttrSet *pCurvesTop, *pCurvesBot;
    NV_PATCH_EVAL_OUTPUT *pOut1, *pOut2;

    // CACHED DATA
    // the driver should allocate memory for these data members BEFORE
    // calling into the shared code.  Shared code should not be responsible
    // for the life time of these data members.
    FDMatrix *m00[NV_PATCH_NUMBER_OF_ATTRIBS], *m01[NV_PATCH_NUMBER_OF_ATTRIBS],
             *m10[NV_PATCH_NUMBER_OF_ATTRIBS], *m11[NV_PATCH_NUMBER_OF_ATTRIBS];    //[attribute]  (sub-patch index = 0 for bezier types)

    //we should probably union these....
    NV_PATCH_FRAC_QUAD_GUARD_INFO *guardQF[NV_PATCH_NUMBER_OF_ATTRIBS];             //[attribute]  (sub-patch index = 0 bezier types)
    NV_PATCH_FRAC_TRI_GUARD_INFO  *guardTF[NV_PATCH_NUMBER_OF_ATTRIBS];
} NV_PATCH_QUAD_INFO;

// for quadInfo->setGridCorner
#define NV_PATCH_SET_GRID_CORNER00      0x1
#define NV_PATCH_SET_GRID_CORNER10      0x2
#define NV_PATCH_SET_GRID_CORNER01      0x4
#define NV_PATCH_SET_GRID_CORNER11      0x8
#define NV_PATCH_SET_GRID_CORNER_ALL    0xf

// Information for one map within the current patch
typedef struct {
    unsigned int uorder, vorder;
    float *rawData;
    int stride;         // OGL: stride == typesize*sizeof(float)
    int pitch;          // OGL: pitch == uorder, number of coords
    int ufStride;       // u stride in floats (i.e. 4 floats is 4, not 16)
    int vfStride;       // v stride in floats
    NV_PATCH_VERTEX_FORMAT_TYPE maptype;
    NV_PATCH_VERTEX_FORMAT_TYPE Originaltype;
    unsigned int dirtyFlags;          // Currently ignored
} NV_PATCH_MAP_INFO;

// Declaration of an immediate-mode-style backend
typedef struct {    
    void (*InitBackend)(void *info);
    void (*DestroyBackend)(void *info);
    void (*beginPrimitive)(void *info, NV_PATCH_PRIMITIVE_TYPE primType);
    void (*endPrimitive)(void *info);
    void (*sendVertex)(void *info, NV_PATCH_EVAL_OUTPUT *pData, int index);
    void (*setFrontFace)(void *info, int reversed);
    void (*beginPatch)(void *info);
    void (*endPatch)(void *info);
} NV_PATCH_BACKEND;

// These are the callbacks that the shared code needs access to.  It is NOT SAFE
// to call C standard library or Windows API functions from the shared code!
typedef struct {
    void *(*malloc)(void *context, size_t bytes);
    void (*free)(void *context, void *ptr);
    void (*memcpy)(void *dst, const void *src, size_t bytes);
    void (*flushOutput)(void *context, unsigned int bytesWritten);
} NV_PATCH_DRIVER_CALLBACKS;

#if defined(IS_OPENGL)
  #define __NV_MALLOC(TAG, SIZE)        __GL_MALLOC(TAG, SIZE)
  #define __NV_FREE(TAG, ADDR)          __GL_FREE(TAG, ADDR)
  #define __NV_MEMCPY(DST, SRC, BYTES)  __GL_MEMCOPY(DST, SRC, BYTES)
#else
  #define __NV_MALLOC(TAG, SIZE)        info->callbacks->malloc(TAG, SIZE)
  #define __NV_FREE(TAG, ADDR)          info->callbacks->free(TAG, ADDR)
  #define __NV_MEMCPY(DST, SRC, BYTES)  info->callbacks->memcpy(DST, SRC, BYTES)
#endif

/*****************************************************************************/

// ***** bits for info->swatchFlags
#define NV_PATCH_SWATCH                 0x00000001      // set when swathing
#define NV_PATCH_SWATCH_FLIPUV          0x00000002      // for tri frac

#define NV_PATCH_SWATCH_FIRST_ROW       0x00000100
#define NV_PATCH_SWATCH_LAST_ROW        0x00000200
#define NV_PATCH_SWATCH_FIRST_COL       0x00000400
#define NV_PATCH_SWATCH_LAST_COL        0x00000800

#define NV_PATCH_SWATCH_SAVE_FIRST_ROW  0x00001000
#define NV_PATCH_SWATCH_SAVE_LAST_ROW   0x00002000
#define NV_PATCH_SWATCH_SAVE_FIRST_COL  0x00004000
#define NV_PATCH_SWATCH_SAVE_LAST_COL   0x00008000

#define NV_PATCH_HAS_NORMAL             0x00010000      // indicates to emit normal guard curves
#define NV_PATCH_NO_REGULAR_GRID        0x00020000      // indicates there is no regular grid -- only transitions

// ***** bits for info->flags
#define NV_PATCH_FLAG_TYPE_MASK         0x00000001
#define NV_PATCH_FLAG_TYPE_TRIANGULAR   0x00000001
#define NV_PATCH_FLAG_TYPE_PATCH        0x00000000

#define NV_PATCH_FLAG_TESS_MASK         0x00000002
#define NV_PATCH_FLAG_TESS_FRACTIONAL   0x00000002
#define NV_PATCH_FLAG_TESS_INTEGER      0x00000000

#define NV_PATCH_FLAG_AUTO_MASK         0x0000000C
#define NV_PATCH_FLAG_AUTO_NORMAL       0x00000004
#define NV_PATCH_FLAG_AUTO_UV           0x00000008
#define NV_PATCH_FLAG_AUTO_NONE         0x00000000

#define NV_PATCH_FLAG_CACHE_MASK        0x00000010
#define NV_PATCH_FLAG_DO_NOT_CACHE      0x00000010
#define NV_PATCH_FLAG_SOME_DIRTY_TESS   0x00000100

#define NV_PATCH_FLAG_TRANSPOSE         0x00001000
#define NV_PATCH_FLAG_FLIPPED_U         0x00002000
#define NV_PATCH_FLAG_FLIPPED_V         0x00004000

// bits for transition flag 
#define FIRST_ROW 0x1   //first row transition
#define LAST_ROW  0x2   //last row transition
#define FIRST_COL 0x4   //first column transition
#define LAST_COL  0x8   //last column transition
#define USE_ITE   0x10  //send an inner transition endpoint

// Information about the current patch
typedef struct {
    // Bitmask of which attributes to evaluate (bits 0..15)
    unsigned int evalEnables;   // as specified to the HW interface
    unsigned int swEnables;     // as presented by the SW interface
    // currently, all attributes handled in the shared code are processed
    // and passed to the back-end without any remapping.
    // For D3D, this is totally handeled in higher level code.
    // So, for D3D, all indices in the shared code are HW indices.
    // For OpenGL, when calling the immediate mode interface, the imm mode
    // calls remap from SW to HW indices.
    // For OpenGL, when calling the Kelvin HW, the remap occurs in
    // __glNVEvalMaps as info is copied from the 'gc' to 'info'

    int nAttr;              // number of active attrs
    int maxAttr;            // max attributes required for malloc's
    int firstAttr;          // first attribute found -- used in memcopies
    unsigned int maxOrder;  // max order of all enabled attributes
    int maxSwatch;          // set according to HW or SW swathing
    int nSwatchU, nSwatchV; // swatches in patch, including Begin/End stitch
    int fracSwatchU, fracSwatchV; // swatches not counting inner frac stitches

    int swatchFlags;        // control during swathing using NV_PATCH_SWATCH_*
    int usingHW;            // set if using Kelvin HW
    int cpuType;            // as provided by the RM
    unsigned long counter;  // temporary storage for the current semphore count

    // Evaluation flags
    unsigned int flags;     // NV_PATCH_FLAG_*
    int flipT;              // set if (flags & NV_PATCH_FLAG_FLAG_TRANSPOSE)
    int flipU;              // set if (flags & NV_PATCH_FLAG_FLIPPED_U)
    int flipV;              // set if (flags & NV_PATCH_FLAG_FLIPPED_V)
    int flipUV;             // for stitches
    int flipTUV;            // combine transpose and both flips

    //MOVE TO QUADINFO ---------------->
    unsigned char* cachedPB;        // cached push buffer
    unsigned long  cachedPBSize;    // cached push buffer size
    unsigned long  cachedPBCounter; // hit count
    //<-------------------------

    // CW/CCW reversal for FRAC layered on INT
    int reverse;

    // Description of tesselation factors
    union {
        struct { float nu0, nu1, nv0, nv1; } tensor;
        struct { float n1, n2, n3;         } tri;
    } tess, originaltess;

    // The basis for the patch
    NV_PATCH_BASIS_TYPE basis;

    // Source and destination of AUTO_NORMAL calculations
    int srcNormal, dstNormal;
    int rational;
    float startu, endu, startv, endv;
    // Destination of AUTO_UV calculations
    int srcUV[8], dstUV[8]; //can have up to 8 sets??

    // Information for each map
    NV_PATCH_MAP_INFO maps[NV_PATCH_NUMBER_OF_ATTRIBS];

    // What type of backend we are writing to or calling to
    NV_PATCH_BACKEND_TYPE backendType;

    // Function pointers for shared code to call into
    NV_PATCH_BACKEND *backend;
    NV_PATCH_DRIVER_CALLBACKS *callbacks;

    // Output buffer (pushbuffer, DP2 stream, ...)
    //MAY BE DEPRECATED?????
    unsigned char *buffer;
    unsigned int bufferLength; // in bytes
    int vertexSize;            // expected # of dwords to output per vertex

    // Opaque context pointer
    void *context;

    // for cache-able info
    NV_PATCH_ALLOC_CACHE *pCache[MAX_EV_CACHE];
    unsigned int retVal;    // for deeply nested alloc errors

    float *normalPatch;     // for NV_PATCH_FLAG_AUTO_NORMAL
    float *UVPatch;         // for NV_PATCH_FLAG_AUTO_UV

    // These point to the guard corners of the regular grid. They are in this
    // top-level structure to be used by all patch types.
    // Instead of fancy attribute arrays, they are simply enumerated for
    // the two attributes which require guard corners: vertex, normal
    // Think of drawing the regular grid from lower-left to upper-right.
    // These names match that orientation so the regular grid routine doesn't
    // need to worry about various orientation flipping and swatching cases.
    // Perhaps LL and LR are not needed for HW, but they're set up for now.
    // Generally these points are the corners of the regular grid,
    // except for LL and LR on the bottom row with a bottom stitch.
    // In this case, they correspond to the swatch corners, and must be stepped
    // up if you want the regular grid.
    //  UL=[0][1]   UR=[1][1]
    //  LL=[0][0]   LR=[0][1]
    float *pSwatchCorner[NV_PATCH_NUMBER_OF_ATTRIBS][2][2]; // [v][u]

    // These are available storage for the corners of the regular grid on
    // the outside of all swatches.
    // Whereas, pSwatchCornerVertex and pSwatchCornerNormal will be
    // correct per sub-patch, these need only be fully valid
    // after all swatches are done
    // Here, the indices are "absolute" because the stitch code was written
    // to draw stitches on the Left, Right, Bot, Top, not relative to the
    // regular grid.
    float gridCorner[NV_PATCH_NUMBER_OF_ATTRIBS][2][2][4]; // [v][u][xyzw]
    int setGridCorner;  // mask indicating which gridCorner to assign

    // 'fracCorner' is for the additional corners created by the 
    // top and right frac stitches. Only used by SW. For HW, HW does it.
    // fracCorner[i][0][0] is the same as gridCorner[i][0][0]
    float fracCorner[NV_PATCH_NUMBER_OF_ATTRIBS][2][2][4]; // [v][u][xyzw]

    // SCRATCH SPACE
    // alloced once with the structure to prevent LOTS of malloc/free's later.
    // IMPORTANT! USE THE MACROs BEGIN/END_USING_TEMP_MATRIX() to help
    // catch cases where nested routines use the same temp
    NV_PATCH_CURVE_INFO tempCurve;
    FDMatrix tempMatrix;
    FDMatrix tempMatrix_m0;    
    FDMatrix tempMatrix_m1;
    FDMatrix tempMatrix_m2;
    FDMatrix reparam;                        // used for Tri INT and FRAC
    FDMatrix *reduceTri[NV_PATCH_MAX_ORDER]; // see ReparameterizeTriPatch()

    #define BEGIN_USING_TEMP_MATRIX(MATRIX)     \
        nvAssert(!(MATRIX).rows);               \
        nvAssert(!(MATRIX).columns);            \

    #define END_USING_TEMP_MATRIX(MATRIX)       \
        nvAssert(((MATRIX).rows = 0, 1));       \
        nvAssert(((MATRIX).columns = 0, 1));    \

    int bytesGuardCurve;        // bytes in truncated NV_PATCH_CURVE_INFO
    int bytesGuardCurveAllAttr; // bytes for one curve set (one curve for each active attribute)

    NV_PATCH_QUAD_INFO *quadInfo;   // alloc'd by callers

    // temp storage allocated in DrawIntPatch() and used by lower routines
    void *pScratchBase; // ptr to group of all scratch stuff for free

    // temp FD matrix for reg grid, small steps in V and U
    FDMatrix *ppMatrixSetSS0[NV_PATCH_NUMBER_OF_ATTRIBS];

    // temp* curves are for boundary curves in regular grid
    NV_PATCH_CURVE_INFO *tempVBegin[NV_PATCH_NUMBER_OF_ATTRIBS];
    NV_PATCH_CURVE_INFO *tempVEnd[NV_PATCH_NUMBER_OF_ATTRIBS];

    // guard sets. Now only for FRAC. Later for more.
    FDCurveAttrSet guardSetUInnerFrac;  // for non-swathing
    FDCurveAttrSet guardSetVInnerFrac;  // for non-swathing
    FDCurveAttrSet *ppGuardSetUInnerFrac1[1];   // for non-swathing
    FDCurveAttrSet *ppGuardSetVInnerFrac1[1];   // for non-swathing
    FDCurveAttrSet **ppGuardSetUInnerFrac;
    FDCurveAttrSet **ppGuardSetVInnerFrac;
} NV_PATCH_INFO;

/*****************************************************************************/
// forward declarations
int nvAllocInfoScratch(NV_PATCH_INFO *info);
int nvAllocFDMatricesEtc(NV_PATCH_INFO *info);
unsigned int nvEvalPatchSetup(NV_PATCH_INFO *info);
unsigned int nvEvalPatch(NV_PATCH_INFO *info);
unsigned int nvEvalPatchCleanup(NV_PATCH_INFO *info);

unsigned int DrawKelvinIntPatchGrid(NV_PATCH_INFO *info, NV_PATCH_QUAD_INFO *quadInfo, FDMatrix **matrices);
void SendGuardCurve(unsigned long curvetype, NV_PATCH_INFO *info, NV_PATCH_QUAD_INFO *quadInfo, unsigned long flags);
void ComputeKelvinHOSControlWords(NV_PATCH_INFO *info, NV_PATCH_QUAD_INFO *quadInfo, long flags);
void CopyCurve(NV_PATCH_INFO *info, NV_PATCH_CURVE_INFO *dst, NV_PATCH_CURVE_INFO *src);

void OffsetFDMatrix(NV_PATCH_INFO *info, FDMatrix *m, int a, int b);
void OffsetCurve(NV_PATCH_INFO *info, NV_PATCH_CURVE_INFO *curve, int n);
void ExtractUCurve(NV_PATCH_INFO *info, NV_PATCH_CURVE_INFO *dst, const FDMatrix *m);
void ExtractVCurve(NV_PATCH_INFO *info, NV_PATCH_CURVE_INFO *dst, const FDMatrix *m);
void RetessellateFDCurve(NV_PATCH_INFO *info, float stepOld, float stepNew,
                                NV_PATCH_CURVE_INFO *curve, int reversedirection);
void RetessellateFDMatrix(NV_PATCH_INFO *info, float stepOldU, float stepOldV,
                             float stepNewU, float stepNewV, FDMatrix *matrix);

int evAllocInitWithCache(NV_PATCH_INFO *info, void *context, 
                            NV_PATCH_ALLOC_CONTROL *pevMemory,
                            int tBytes, NV_PATCH_ALLOC_CACHE *pCache);

extern const int attrHwToSw[NV_PATCH_NUMBER_OF_ATTRIBS];
extern const int attrSwToHw[NV_PATCH_NUMBER_OF_ATTRIBS];

//#define HOS_DEBUG
#if !defined(IS_OPENGL)
    //d3d defs
    #define VIEW_AS_DWORD(f) (*(DWORD *)(&(f)))
    #define HOS_KELVIN_CHANNEL                  NV_DD_KELVIN

    #define HOS_CREATE_AND_ASSIGN_PUSHBUF_LOCALS() \
            extern int fakeFunc(int ii)         // make declaration instead of <null> so macro may be called with ";"

    #ifdef HOS_DEBUG                            //for debug builds output debug info rather than actual pushbuffer methods
        #define HOS_PUSH(index, method)         { getDC()->nvPusher.push(index, method); \
                                                  DPF_LEVEL(NVDBG_LEVEL_HOS_INFO,"HOS: 0x%08x", (method)); } 
  
        #define HOS_PUSHF(index, method)        { getDC()->nvPusher.push(index, method); \
                                                  DPF_LEVEL(NVDBG_LEVEL_HOS_INFO,"HOS: %f", (*(float *)(&(method)))); }   
    
        #define HOS_PUSH_ADJUST(num_dwords)     getDC()->nvPusher.adjust(num_dwords)
        #define HOS_NOTE(a)                     DPF_LEVEL(NVDBG_LEVEL_HOS_INFO,"HOS: %s",a)                    
        #define HOS_FLUSH()                     //getDC()->nvPusher.flush(TRUE,CPushBuffer::FLUSH_HEAVY_POLLING)       
    #else
        #define HOS_PUSH(index, method)         getDC()->nvPusher.push(index, method)
        #define HOS_PUSHF(index, method)        HOS_PUSH(index,method)      //remap to same push method.
        #define HOS_PUSH_ADJUST(num_dwords)     getDC()->nvPusher.adjust(num_dwords)
        #define HOS_NOTE(a)                     //DPF_LEVEL(NVDBG_LEVEL_HOS_INFO,"HOS: %s",a)
        #define HOS_FLUSH()                     //getDC()->nvPusher.flush(TRUE,CPushBuffer::FLUSH_HEAVY_POLLING)
    #endif

#else   // !defined(IS_OPENGL)
    //OGL defs
    #define VIEW_AS_DWORD(f) (*(NvU32 *)(&(f)))
    #define HOS_KELVIN_CHANNEL NV_SC_3D         // define kelvin channel for OGL
    #define MAX_CHECK_PUSH_WORDS    100

    static NV_INLINE int dbgPushCheckCount(int nWritten, int *count)
    {
        int ii;

        for (ii = 0;  ii < nWritten;  ii++) {
            if (ii >= MAX_CHECK_PUSH_WORDS) {
                break;
            }
            assert(count[ii] == 1);
        }
        for (ii = 0;  ii < MAX_CHECK_PUSH_WORDS;  ii++) {
            count[ii] = 0;
        }
        return 0;
    }

    #define HOS_CREATE_AND_ASSIGN_PUSHBUF_LOCALS() \
            NV_TRACE_CODE( \
                int dbgPushCount[MAX_CHECK_PUSH_WORDS]; \
                int dbgPushFoo = nvDebugLevel >= 2 ? \
                                    dbgPushCheckCount(0, dbgPushCount) : 0; \
                const int setupForMT = MT_PENDING; \
            ) \
            __GLNVcontext *hwcx = NV_GET_HWCX(info->context); \
            __GLNVstate *state = NV_GET_HWSTATE(info->context) \
            /* NV_CREATE_AND_ASSIGN_PUSHBUF_LOCALS() */ \

    #define HOS_PUSH(index, data) \
            /* nvCurrent[index].u = data; */ \
            hwcx->u.pushBuf.current[index].u = data; \
            NV_TRACE_CODE( \
                assert((index) >= 0); \
                if ((index) < MAX_CHECK_PUSH_WORDS) { \
                    dbgPushCount[index]++; \
                } \
            ); \

    #define HOS_PUSHF(index, data) HOS_PUSH(index,data)

    #define HOS_PUSH_ADJUST(num_dwords) { \
            NV_CREATE_AND_ASSIGN_PUSHBUF_LOCALS(); \
            NV_TRACE_CODE( \
                if (nvDebugLevel >= 2) { \
                    dbgPushCheckCount(num_dwords, dbgPushCount); \
                } \
            ); \
            nvCurrent += (num_dwords); \
            NV_SYNC_PUSHBUF_LOCALS(); \
            NV_GET_VARIABLE_SPACE_IF_NEEDED(128); \
            nvAssert(nvCurrent < hwcx->u.pushBuf.fence); \
        }

    #define HOS_NOTE(a)

    #define HOS_FLUSH() { \
            NV_CREATE_AND_ASSIGN_PUSHBUF_LOCALS(); \
            NV_GET_SKID_SPACE_IF_NEEDED(); \
            NV_FLUSH(state); \
        }

    extern int enableUniqueCheck;
    extern int nUniqueVertices;
    void drawUniqueVertices(void);
#endif  // else !defined(IS_OPENGL)

#define HOS_PUSH4F(index, method)       { HOS_PUSHF(index+0, VIEW_AS_DWORD(method[0])); \
                                          HOS_PUSHF(index+1, VIEW_AS_DWORD(method[1])); \
                                          HOS_PUSHF(index+2, VIEW_AS_DWORD(method[2])); \
                                          HOS_PUSHF(index+3, VIEW_AS_DWORD(method[3])); }


// Assembly inner loops storage, constants, and defines
extern int bFirstTimeInit;           //global value to indicate if we've built dynamic inner loops yet or not.
typedef void (FASTCALL *PFOFSTMED)(NV_PATCH_CURVE_INFO *dst, int dir, FDMatrix *m, int a, int b);
typedef void (FASTCALL *PFOFSTM)(FDMatrix *m, int a, int b);
typedef void (FASTCALL *PFOFSC)(NV_PATCH_CURVE_INFO *curve, int n);
typedef void (FASTCALL *PFMM)(FDMatrix *dst, FDMatrix *a, FDMatrix *b);

#define MAX_PATCH_INNERLOOPS          16
#define OFFSET_FDMATRIX_ED_2x2      0
#define OFFSET_FDMATRIX_ED_4x4      1
#define OFFSET_FDMATRIX_ED_6x6      2
#define OFFSET_FDMATRIX_ED_DEF      3
#define OFFSET_FDMATRIX_2x2         4
#define OFFSET_FDMATRIX_4x4         5
#define OFFSET_FDMATRIX_6x6         6
#define OFFSET_FDMATRIX_DEF         7
#define OFFSET_CURVE_2x2            8
#define OFFSET_CURVE_4x4            9
#define OFFSET_CURVE_6x6            10
#define OFFSET_CURVE_DEF            11
#define OFFSET_MATRIX_MULT_2x2      12
#define OFFSET_MATRIX_MULT_4x4      13
#define OFFSET_MATRIX_MULT_6x6      14
#define OFFSET_MATRIX_MULT_DEF      15

typedef struct {
    //ptrs for inner loops
    void *HOSInnerLoops[MAX_PATCH_INNERLOOPS];  //function mappings

    //small FDMatrix cache to get rid of extra 
    unsigned int RetessFDtag[2][2];           //tags for a retessellation matrix cache
    FDMatrix *RetessFDCache[2];               //ptrs for retessellation matrix cache
    int RetessFDMRU;                          //MRU bit for the above cache
    
    //EV_ALLOC data structures to minimize the number of malloc/frees in shared code
    NV_PATCH_ALLOC_CACHE pCache[MAX_EV_CACHE];
    
    //callback ptrs for HOS routines
    NV_PATCH_DRIVER_CALLBACKS *callbacks;
} NV_PATCH_STATIC_DATA;


//forward declarations for functions used elsewhere
void OffsetFDMatrix_Extract_Discard(NV_PATCH_INFO *info, NV_PATCH_CURVE_INFO *dst, int dir, FDMatrix *m, int a, int b);
void nvPatchDestroyFD();
void nvPatchInitFD(NV_PATCH_INFO *info);

typedef struct{    
    //semaphore data members
    long *FDSynchCounter;
    unsigned char *baseAllocation;
    unsigned char *alignedAllocation;
    unsigned long FDContextDMA;    
    unsigned long cpuType;
    int bForceSoftware;                  //indicates we failed to set up semaphore -- force a SW fallback
    int bFirstTimeInit;    
    //inner loop data members
    void *HOSInnerLoops[MAX_PATCH_INNERLOOPS];  //function mappings
    //retessellation cache members
    unsigned int RetessFDtag[2][2];           //tags for a retessellation matrix cache
    FDMatrix *RetessFDCache[2];               //ptrs for retessellation matrix cache
    int RetessFDMRU;                          //MRU bit for the above cache

} NV_PATCH_GLOBAL_DATA;
//this should match the intiialization of the above default structure
#define DEFAULT_PATCH_GLOBAL_DATA {NULL,NULL,NULL,0,0,0,1, {NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL, \
                                                            NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL}, \
                                   {{0xFFFFFFFF,0xFFFFFFFF},{0xFFFFFFFF,0xFFFFFFFF}}, \
                                   {NULL,NULL}, 0} \

extern NV_PATCH_ALLOC_CACHE MyCache[MAX_EV_CACHE];
extern NV_PATCH_GLOBAL_DATA g_FDGlobalData;
//#define DCR_SEMAPHORE
//extern NV_PATCH_MUTEX_DATA g_FDMutexData;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\common\inc\nvPM.h ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/
#ifndef _nvPM_h
#define _nvPM_h

#ifdef __cplusplus
extern "C"
{
#endif

/*
 * constants
 */

// registry related
#define PM_REGISTRY_SUBKEY          "PerformanceMonitor"

#define PM_REG_LOGFILENAME          "logFileName"
#define PM_REG_CONNECTCOUNT         "connectCount"
#define PM_REG_PMTRIGGER            "trigger"
#define PM_REG_TRIGGERCOUNT         "triggerCount"
#define PM_REG_FLAGS                "flags"
#define PM_REG_PROGRAM_SETUP        "programSetup"
#define PM_REG_PROGRAM_START        "programStart"
#define PM_REG_PROGRAM_SAMPLE       "programSample"

#define PM_REG_PMTRIGGER_DISABLED   0                   // disabled
#define PM_REG_PMTRIGGER_ENDSCENE   1                   // emit trigger at end of frame
#define PM_REG_PMTRIGGER_1MS        2                   // emit trigger at 1ms intervals (not exact)
#define PM_REG_PMTRIGGER_RESV00     3
#define PM_REG_PMTRIGGER_CUSTOM0    4
#define PM_REG_PMTRIGGER_CUSTOM1    5
#define PM_REG_PMTRIGGER_CUSTOM2    6
#define PM_REG_PMTRIGGER_CUSTOM3    7
#define PM_REG_PMTRIGGER_MAX        7

#define PM_LOG_ID                   "events \0"
#define PM_PGM_ID                   "program\0"

#define PM_LOG_VERSION              0x00000001
#define PM_PGM_VERSION              0x00000001

#define PM_PGM_MASK_SIZE            0x0000000f
#define PM_PGM_VAL_SIZE_8               0x00000000
#define PM_PGM_VAL_SIZE_16              0x00000001
#define PM_PGM_VAL_SIZE_32              0x00000002
#define PM_PGM_VAL_SIZE_40              0x00000003
#define PM_PGM_FLAG_READ            0x80000000

#define PM_LOG_EVENT_BUFFER_SIZE    (65536 / 8)

// flags bits
#define PM_FLAGS_NO_WAIT 0x1
#define PM_FLAGS_NO_RESET 0x2
#define PM_FLAGS_IN_QUAKE3 0x4

/*
 * macros
 */
#define PM_SIGNAL(match)            if (g_dwPMTrigger == (match)) { if (!(--g_dwPMTriggerValue)) { pmSignal(); g_dwPMTriggerValue = g_dwPMTriggerCount; } }

/*
 * structures
 */
#pragma pack(push,1)

//////
// log event
typedef struct
{
    DWORD dwValueLo;
    DWORD dwValueHi;
} PM_LOG_EVENT;

// log header
typedef struct
{
    char         szID[8];
    DWORD        dwVersion;
    PM_LOG_EVENT Event[1];
} PM_LOG_HEADER;

//////
// program entry
typedef struct
{
    DWORD dwFlags;
    DWORD dwOffset;
    DWORD dwValueLo;
    DWORD dwValueHi;
} PM_PGM_ENTRY;

// program header
typedef struct
{
    char         szID[8];
    DWORD        dwVersion;
    DWORD        dwEntryCount;
    PM_PGM_ENTRY Entry[1];
} PM_PGM_HEADER;

#pragma pack(pop)

/*
 * exported globals
 */
extern DWORD g_dwPMTrigger;
extern DWORD g_dwPMTriggerCount;
extern DWORD g_dwPMTriggerValue;

/*
 * public functions
 */
#if defined(IS_OPENGL)
BOOL pmConnect    (HDC hEscapeDC,DWORD dwHWLinearBase,DWORD dwArch);    // arch: nv4 -> 0x04, nv10 -> 0x10
#else
BOOL pmConnect    (DWORD dwHeadNumber,DWORD dwHWLinearBase,DWORD dwArch);    // arch: nv4 -> 0x04, nv10 -> 0x10
#endif
BOOL pmDisconnect (void);
BOOL pmSignal     (void);

#ifdef __cplusplus
}
#endif

#endif // _nvPM_h
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\common\inc\nvregionshared.h ===
/***********************************************************

Copyright (c) 1987, 1988, 1989  X Consortium

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
X CONSORTIUM BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of the X Consortium shall not be
used in advertising or otherwise to promote the sale, use or other dealings
in this Software without prior written authorization from the X Consortium.


Copyright 1987, 1988, 1989 by
Digital Equipment Corporation, Maynard, Massachusetts.

                        All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of Digital not be
used in advertising or publicity pertaining to distribution of the
software without specific, written prior permission.

DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
SOFTWARE.

******************************************************************/
/* $XConsortium: miregion.c,v 1.60 94/04/17 20:27:49 dpw Exp $ */


#ifndef __NVREGIONSHARED_H
#define __NVREGIONSHARED_H

#if !defined(XFree86LOADER)
typedef struct _Box {
    short x1, y1, x2, y2;
} BoxRec;

typedef struct _Box *BoxPtr;
#else
# include <miscstruct.h>
#endif /* XFree86LOADER */

/* 
 *   clip region
 */

typedef struct _RegData {
    int    size;
    int    numRects;
/*  BoxRec rects[size];   in memory but not explicitly declared */
} RegDataRec, *RegDataPtr;

typedef struct _Region {
    BoxRec  extents;
    RegDataPtr  data;
} RegionRec, *RegionPtr;


#define REGION_NIL(reg) ((reg)->data && !(reg)->data->numRects)
#define REGION_NUM_RECTS(reg) ((reg)->data ? (reg)->data->numRects : 1)
#define REGION_SIZE(reg) ((reg)->data ? (reg)->data->size : 0)
#define REGION_RECTS(reg) ((reg)->data ? (BoxPtr)((reg)->data + 1) \
                           : &(reg)->extents)
#define REGION_BOXPTR(reg) ((BoxPtr)((reg)->data + 1))
#define REGION_BOX(reg,i) (&REGION_BOXPTR(reg)[i])
#define REGION_TOP(reg) REGION_BOX(reg, (reg)->data->numRects)
#define REGION_END(reg) REGION_BOX(reg, (reg)->data->numRects - 1)
#define REGION_SZOF(n) (sizeof(RegDataRec) + ((n) * sizeof(BoxRec)))

#define good(a)

extern void * NV_STDCALL oglXAlloc(size_t size);
extern void  NV_STDCALL oglXFree(void *ptr);
extern void * NV_STDCALL oglXRealloc(void *oldPtr, size_t oldSize, size_t newSize);

extern RegDataPtr  NV_STDCALL oglXAllocData(int n);
extern void  NV_STDCALL oglXFreeData(RegionPtr reg);

extern int  NV_STDCALL nvInverse(RegionPtr newReg, RegionPtr reg1, BoxPtr invRect);
extern int  NV_STDCALL nvIntersect(RegionPtr newReg, RegionPtr reg1, RegionPtr reg2);
extern void  NV_STDCALL nvOptimizeRegion(RegionPtr nvRegion);
   
#endif // __NVREGIONSHARED_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\common\inc\nvPriv.h ===
#ifndef _NVPRIV_H_
#define _NVPRIV_H_

#include "CompileControl.h"
#include "nvUtil.h"

/*==========================================================================;
 *
 *  Copyright (C) 1995, 1999 NVidia Corporation. All Rights Reserved.
 *
 *  File:       nvPriv.h
 *  Content:    header for nvPriv.cpp
 *
 ***************************************************************************/

typedef struct _MYDCICMD
{
	ULONG	dwCommand;
	ULONG	dwParam1;
	ULONG 	dwParam2;
	ULONG	dwVersion;
	ULONG	dwReserved;
} MYDCICMD;

typedef struct _MYDD32BITDRIVERDATA
{
    UCHAR   szName[260];            // 32-bit driver name
    UCHAR   szEntryPoint[64];       // entry point
    ULONG   dwContext;              // context to pass to entry point
} MYDD32BITDRIVERDATA;

#define DD_VERSION              0x00000200l
#define DDCREATEDRIVEROBJECT    10
#define DDGET32BITDRIVERNAME    11
#define DDNEWCALLBACKFNS        12
#define DDVERSIONINFO           13
#define DDDESTROYDRIVEROBJECT   99

// The nvPriv functions provide a private API within the nVidia driver.
// Since they are called outside the context of an OS API (ie the DirectDraw HAL)
// we need a way to identify the appropriate global data structures.  This array of 
// ptrs must be updated as devices are added or removed.
//
// stores a list of display adapters with the global data structures associated with each
//
#define MAX_ADAPTERS            9

typedef struct tagDISPDRVDIRECTXCOMMON DISPDRVDIRECTXCOMMON;
typedef struct _GLOBALDATA GLOBALDATA;

typedef struct
{
#if IS_WIN9X
    DISPDRVDIRECTXCOMMON *pDXShare;
    GLOBALDATA       *pDriverData;
#elif IS_WINNT5
    GLOBALDATA       *pDriverData;
#elif IS_WINNT4
    GLOBALDATA           *pDriverData;
#endif
} NV_ADAPTER_TYPE;

EXTERN_C NV_ADAPTER_TYPE g_adapterData[MAX_ADAPTERS];	// Declared in nvPriv.cpp


#ifdef WINNT
#ifndef NV_ESC_DDPRIV_DMABLIT
// lpIn = pointer to input structure to nvMoComp
// lpOut = pointer to a DWORD return code
#define NV_ESC_DDPRIV_DMABLIT               0x6E88
#endif

#ifndef NV_ESC_DDPRIV_OVERLAYCONTROL
// lpIn = pointer to input structure to nvOverlayControl
// lpOut = pointer to a DWORD return code
#define NV_ESC_DDPRIV_OVERLAYCONTROL        0x6E89
#endif
#endif // WINNT

// --------------------------------------------------------------------------
// nvOverlayControl
//      Overlay control callback
//
// Command Structure
// -----------------
// NVOCCMD_IDENTIFY
//      dwSize
//      dwDevice
//      caps.dwCaps1
//          NVOCID1_INTERVIDEO
//          NVOCID1_MEDIAMATICS
//          NVOCID1_RAVISENT
//          NVOCID1_CYBERLINK
//          NVOCID1_NEC
//          NVOCID1_MGI
//          NVOCID1_CANOPUS
//          NVOCID1_AVID
//          NVOCID1_REAL
//          NVOCID1_MADONION
//          NVOCID1_MICROSOFT
//      caps.dwCaps2
//          NVOCID2_OS_SCHEDULED
//              Set this cap if your decoder uses OS scheduling, i.e. multithreaded
//              Do not set if your decoder is self scheduled, i.e. multifibre
//          NVOCID2_CAN_HANDLE_60HZ
//              Set this cap if your decoder can handle 60 fps content on 60 Hz resolutions
//          NVOCID2_PIPELINED
//              Set this cap if your decoder is pipelined.  If you do not know, do not set this
//          NVOCID2_NEED_OVERLAY
//              Set this cap if your decoder cannot use FOURCC blits if overlay is absent
//          NVOCID2_SINGLE_MONITOR
//              Set this cap if your decoder is not multimon capable
// NVOCCMD_GETCAPS
//      dwSize
//      dwDevice
//      returns caps
//          dwCaps1
//              NVOCCAPS1_BRIGHTNESS
//              NVOCCAPS1_CONTRAST
//              NVOCCAPS1_HUE
//              NVOCCAPS1_SATURATION
//              NVOCCAPS1_SHARPNESS
//              NVOCCAPS1_GAMMA
//          dwCaps2
//              NVOCCAPS2_HQVUPSCALE
//              NVOCCAPS2_TFILTER
//              NVOCCAPS2_DFILTER
//              NVOCCAPS2_FSMIRROR
//              NVOCCAPS2_OVLZOOM
//          dwCaps3
//              NVOCCAPS3_SUBPICTURE
//              NVOCCAPS3_LATEFLIPSYNC
//              NVOCCAPS3_SPLITVPP
//              NVOCCAPS3_DELIVERYCONTROL
//              NVOCCAPS3_BLTCAPS
//          dwCaps4
//              NVOCCAPS4_SMA
//              NVOCCAPS4_IMB
//              NVOCCAPS4_DEVICEHASOVL
//              NVOCCAPS4_MULTIHEADNUM (number of display heads on this device)
//              NVOCCAPS4_MULTIHEADMODE (0 = single, 1 = span, 2 = clone)
//              NVOCCAPS4_HEAD0_TYPE (0 = CRT, 1 = NTSC, 2 = PAL, 3 = DFP, -1 = inactive)
//              NVOCCAPS4_HEAD1_TYPE (0 = CRT, 1 = NTSC, 2 = PAL, 3 = DFP, -1 = inactive)
//          dwCaps5
//              NVOCCAPS5_BLT_YUV9_2_YUV422
//              NVOCCAPS5_BLT_YUV12_2_YUV422
//              NVOCCAPS5_BLT_YC12_2_YUV422
//              NVOCCAPS5_BLT_YUV422_2_YUV422
//              NVOCCAPS5_BLT_YUV422_2_RGB8
//              NVOCCAPS5_BLT_YUV422_2_RGB15
//              NVOCCAPS5_BLT_YUV422_2_RGB16
//              NVOCCAPS5_BLT_YUV422_2_RGB32
//              NVOCCAPS5_BLT_SYUV2VYUV
//              NVOCCAPS5_BLT_VYUV2VYUV
//              NVOCCAPS5_BLT_VYUV2SYUV
//              NVOCCAPS5_BLT_SYUV2VRGB
//              NVOCCAPS5_BLT_VYUV2VRGB
//              NVOCCAPS5_BLT_VYUV2SRGB
//              NVOCCAPS5_BLT_SRGB2VRGB
//              NVOCCAPS5_BLT_VRGB2VRGB
//              NVOCCAPS5_BLT_VRGB2SRGB
//              NVOCCAPS5_BLT_2RGBTEX
// NVOCCMD_SETCOLORCONTROL
//      dwSize
//      dwDevice
//      ccData
//          dwEnable (ignored for NV10 and above, always enabled)
//              0 = disable
//              1 = enable with vertical chroma subsampling
//              2 = enable with full chroma sampling (do not use)
//          dwCCFlags
//              NVOCCC_BRIGHTNESS
//                  lBrightness (range is -256 to +255)
//              NVOCCC_CONTRAST
//                  lContrast (range is 0 to 200)
//              NVOCCC_HUE
//                  lHue (range is 0 to 360)
//              NVOCCC_SATURATION
//                  lSaturation (range is 0 to 200)
// NVOCCMD_GETCOLORCONTROL
//      dwSize
//      dwDevice
//      returns ccData
//          returns dwEnable
//              0 = disable
//              1 = enable with vertical chroma subsampling
//              2 = enable with full chroma sampling (do not use)
//          returns dwCCFlags
//              NVOCCC_BRIGHTNESS
//                  returns lBrightness
//              NVOCCC_CONTRAST
//                  returns lContrast
//              NVOCCC_HUE
//                  returns lHue
//              NVOCCC_SATURATION
//                  returns lSaturation
// NVOCCMD_SETFEATURE (enables feature)
//      dwSize
//      dwDevice
//      dwFeature1
//          NVOCF1_HQVUPSCALE (always enable if enough memory (8M))
//          NVOCF1_TFILTER (only enable in BOB mode if enough memory (16M))
//              lCoefficient[0] (recommended value = 0xA4)
//              dwCmdFlags (optional)
//                  NVOCF_TF_PRECOPY
//          NVOCF1_DFILTER (only enable in BOB mode if enough memory (16M))
//              lCoefficient[1] (recommended value = 0xA4)
//              dwCmdFlags (optional)
//                  NVOCF_DF_PRECOPY
//          NVOCF1_FSMIRROR (only enable with dual head and large memory)
//              lCoefficient[4]:
//                  bits 0-3: head number
//                            0 = disable FSVM
//                            1 = display 1
//                            2 = display 2
//                            15 = autoselect display
//                  bits 4-7: aspect ratio
//                            0 = stretch to display full screen
//                            1 = preserve aspect of source (assume square pixels)
//                            3 = force anamorphic 16:9
//                            5 = track overlay aspect
//                            9 = force TV 4:3
//                  bits 8-11: zoom quadrant
//                             0 = disable zoom
//                             1 = top left
//                             2 = top right
//                             3 = bottom left
//                             4 = bottom right
//                             5 = center
//                  bits 12-19: zoom factor, 0 = 1x, 255 = 2x
//                  bit 20: 0 = use current display size
//                          1 = let driver pick the display size
//                  bit 21: 0 = independent FS and overlay zoom
//                          1 = FS zoom tracks overlay zoom controls
//                  bit 22: 0 = disable DVD output to TV
//                          1 = enable DVD output to TV
//          NVOCF1_OVLZOOM
//              lCoefficient[5]:
//                  bits 8-11: zoom quadrant
//                             0 = disable zoom
//                             1 = top left
//                             2 = top right
//                             3 = bottom left
//                             4 = bottom right
//                             5 = center
//                  bits 12-23: zoom factor, 0 = 1x, 255 = 2x
//          NVOCF1_DELIVERYCONTROL
//              lCoefficient[6]: low 32 bits of frame period (in ns)
//              lCoefficient[7]: high 32 bits of frame period (in ns)
//              returns lCoefficient[6]: pointer to 64 bit absolute timecode 0
//                      lCoefficient[7]: pointer to 64 bit absolute timecode 1
//          NVOCF1_LATEFLIPSYNC
//      dwFeature2
//          NVOCF2_VPPMAXSURFACES
//              lCoefficient[2] = set to 0, 2, 3, 4, or 6
//              lCoefficient[3] = reserved
// NVOCCMD_RESETFEATURE (disables feature)
//      dwSize
//      dwDevice
//      dwFeature1
//          NVOCF1_HQVUPSCALE
//          NVOCF1_TFILTER
//          NVOCF1_DFILTER
//          NVOCF1_FSMIRROR
//          NVOCF1_OVLZOOM
//          NVOCF1_DELIVERYCONTROL
//          NVOCF1_LATEFLIPSYNC
// NVOCCMD_GETFEATURE
//      dwSize
//      dwDevice
//      returns dwFeature1
//          NVOCF1_HQVUPSCALE
//          NVOCF1_TFILTER
//              returns lCoefficient[0]
//          NVOCF1_DFILTER
//              returns lCoefficient[1]
//          NVOCF1_FSMIRROR
//              returns lCoefficient[4]
//          NVOCF1_OVLZOOM
//              returns lCoefficient[5]
//          NVOCF1_DELIVERYCONTROL
//              returns lCoefficient[6] low 32 bits of frame period
//                      lCoefficient[7] high 32 bits of frame period
//                      lCoefficient[8] low 32 bits of absolute timecode 0
//                      lCoefficient[9] high 32 bits of absolute timecode 0
//                      lCoefficient[10] low 32 bits of absolute timecode 1
//                      lCoefficient[11] high 32 bits of absolute timecode 1
//          NVOCF1_LATEFLIPSYNC
//      returns dwFeature2
//          NVOCF2_VPPMAXSURFACES
//              lCoefficient[2] = max VPP work surfaces
//              lCoefficient[3] = VPP work surfaces currently allocated
//

#define OVERLAYCONTROLCALLBACK "nvOverlayControl"

typedef enum { 
    NVOCERR_OK              = 0,
    NVOCERR_GENERIC_WARN    = 1,
    NVOCERR_GENERIC_FATAL   = 0x80000001,
    NVOCERR_BAD_COMMAND     = 0x80000002,
    NVOCERR_INVALID_PARMS   = 0x80000003,
    NVOCERR_ALREADY_ACTIVE  = 0x80000004,
    NVOCERR_NOT_SUPPORTED   = 5,
    NVOCERR_BAD_DEVICE      = 0x80000006
} NVOCERROR;

typedef enum {
    NVOCCMD_NOOP            = 0,
    NVOCCMD_GETCAPS         = 1,
    NVOCCMD_SETCOLORCONTROL = 2,
    NVOCCMD_GETCOLORCONTROL = 3,
    NVOCCMD_SETFEATURE      = 4,
    NVOCCMD_RESETFEATURE    = 5,
    NVOCCMD_GETFEATURE      = 6,
    NVOCCMD_IDENTIFY        = 7
} NVOCCOMMAND;

typedef struct {
    unsigned long   dwCCFlags;
    unsigned long   dwEnable;
    long            lBrightness;
    long            lContrast;
    long            lHue;
    long            lSaturation;
    long            lSharpness;
    long            lGamma;
} NVOCCCDATA, *LPNVOCCCDATA;

#define NVOCCC_BRIGHTNESS   0x1
#define NVOCCC_CONTRAST     0x2
#define NVOCCC_HUE          0x4
#define NVOCCC_SATURATION   0x8
#define NVOCCC_SHARPNESS    0x10
#define NVOCCC_GAMMA        0x20

typedef struct {
    unsigned long dwCaps1;
    unsigned long dwCaps2;
    unsigned long dwCaps3;
    unsigned long dwCaps4;
    unsigned long dwCaps5;
} NVOCCAPS, *LPNVOCCAPS;

#define NVOCCAPS1_BRIGHTNESS    0x1
#define NVOCCAPS1_CONTRAST      0x2
#define NVOCCAPS1_HUE           0x4
#define NVOCCAPS1_SATURATION    0x8
#define NVOCCAPS1_SHARPNESS     0x10
#define NVOCCAPS1_GAMMA         0x20

#define NVOCCAPS2_HQVUPSCALE    0x1
#define NVOCCAPS2_TFILTER       0x2
#define NVOCCAPS2_DFILTER       0x4
#define NVOCCAPS2_FSMIRROR      0x8
#define NVOCCAPS2_OVLZOOM       0x10

#define NVOCCAPS3_SUBPICTURE        0x1
#define NVOCCAPS3_LATEFLIPSYNC      0x2
#define NVOCCAPS3_SPLITVPP          0x4
#define NVOCCAPS3_DELIVERYCONTROL   0x8
#define NVOCCAPS3_BLTCAPS           0x80000000

#define NVOCCAPS4_IMB           0x1
#define NVOCCAPS4_SMA           0x2
#define NVOCCAPS4_DEVICEHASOVL  0x4
#define NVOCCAPS4_MULTIHEADNUM  0x000F0000
#define NVOCCAPS4_MULTIHEADMODE 0x00F00000
#define NVOCCAPS4_HEAD0_TYPE    0x0F000000
#define NVOCCAPS4_HEAD1_TYPE    0xF0000000

#define NVOCCAPS5_BLT_YUV9_2_YUV422     0x00000001
#define NVOCCAPS5_BLT_YUV12_2_YUV422    0x00000002
#define NVOCCAPS5_BLT_YC12_2_YUV422     0x00000004
#define NVOCCAPS5_BLT_YUV422_2_YUV422   0x00000008
#define NVOCCAPS5_BLT_YUV422_2_RGB8     0x00000100
#define NVOCCAPS5_BLT_YUV422_2_RGB15    0x00000200
#define NVOCCAPS5_BLT_YUV422_2_RGB16    0x00000400
#define NVOCCAPS5_BLT_YUV422_2_RGB32    0x00000800
#define NVOCCAPS5_BLT_RGB16_2_RGB32     0x00001000
#define NVOCCAPS5_BLT_RGB32_2_RGB32     0x00002000
#define NVOCCAPS5_BLT_SYUV2VYUV         0x00010000
#define NVOCCAPS5_BLT_VYUV2VYUV         0x00020000
#define NVOCCAPS5_BLT_VYUV2SYUV         0x00040000
#define NVOCCAPS5_BLT_SYUV2VRGB         0x00100000
#define NVOCCAPS5_BLT_VYUV2VRGB         0x00200000
#define NVOCCAPS5_BLT_VYUV2SRGB         0x00400000
#define NVOCCAPS5_BLT_SRGB2VRGB         0x01000000
#define NVOCCAPS5_BLT_VRGB2VRGB         0x02000000
#define NVOCCAPS5_BLT_VRGB2SRGB         0x04000000
#define NVOCCAPS5_BLT_2RGBTEX           0x80000000

#define NVOCID1_UNKNOWN                 0
#define NVOCID1_INTERVIDEO              MAKEFOURCC('I','V','I',' ')
#define NVOCID1_MEDIAMATICS             MAKEFOURCC('M','D','M','X')
#define NVOCID1_RAVISENT                MAKEFOURCC('R','V','S','T')
#define NVOCID1_CYBERLINK               MAKEFOURCC('C','Y','B','R')
#define NVOCID1_NEC                     MAKEFOURCC('N','E','C',' ')
#define NVOCID1_MGI                     MAKEFOURCC('M','G','I',' ')
#define NVOCID1_CANOPUS                 MAKEFOURCC('C','N','P','S')
#define NVOCID1_AVID                    MAKEFOURCC('A','V','I','D')
#define NVOCID1_REAL                    MAKEFOURCC('R','E','A','L')
#define NVOCID1_MADONION                MAKEFOURCC('M','A','D','O')
#define NVOCID1_MICROSOFT               MAKEFOURCC('M','S','F','T')

#define NVOCID2_OS_SCHEDULED            0x00000001
#define NVOCID2_CAN_HANDLE_60HZ         0x00000002
#define NVOCID2_PIPELINED               0x00000004
#define NVOCID2_NEED_OVERLAY            0x00000008
#define NVOCID2_SINGLE_MONITOR          0x00000010

typedef struct {
    unsigned long dwFeature1;
    unsigned long dwFeature2;
    unsigned long dwFeature3;
    unsigned long dwFeature4;
    long          lCoefficient[16];
} NVOCFEATUREDATA;

#define NVOCF1_HQVUPSCALE       0x1
#define NVOCF1_TFILTER          0x2
#define NVOCF1_LATEFLIPSYNC     0x4
#define NVOCF1_DFILTER          0x8
#define NVOCF1_FSMIRROR         0x10
#define NVOCF1_OVLZOOM          0x20
#define NVOCF1_DELIVERYCONTROL  0x40

#define NVOCF2_VPPMAXSURFACES   0x1

#define NVOCF_TF_PRECOPY   0x00000001
#define NVOCF_DF_PRECOPY   0x00000002

typedef struct {
    unsigned long dwSize;
    unsigned long dwDevice;

    // command
    NVOCCOMMAND cmd;
    unsigned long dwCmdFlags;

    // data
    union {
        NVOCCAPS        caps;
        NVOCCCDATA      ccData;
        NVOCFEATUREDATA featureData;
    };

    unsigned long dwReserved[40];
} NVOCDATATYPE, *LPNVOCDATATYPE;

typedef NVOCERROR (__stdcall *NVOVERLAYCONTROL)(LPNVOCDATATYPE data);


// --------------------------------------------------------------------------
// nvSetOverlayColorControl
//      Obsolete.  Only use with rel3 drivers
//      If lpDDCC is NULL, callback returns caps
//
//      dwDevice            always 1
//      lpDDCC->dwSize      sizeof(DDCOLORCONTROL)
//      lpDDCC->dwFlags     DDCOLOR_CONTRAST | DDCOLOR_BRIGHTNESS | DDCOLOR_HUE | DDCOLOR_SATURATION
//                          determines which members hold valid data
//      lpDDCC->lBrightness range is from -256 to +255
//      lpDDCC->lContrast   range is from 0 to 200
//      lpDDCC->lHue        range is from 0 to 360
//      lpDDCC->lSaturation range is from 0 to 200
//      lpDDCC->dwReserved1 0 = disable colour controls
//                          1 = enable with vertical chroma subsampling
//                          2 = enable with full chroma sampling
// #define SETOVERLAYCOLORCONTROLCALLBACK "nvSetOverlayColorControl"

//typedef DWORD (__stdcall *NVSETOVERLAYCOLORCONTROL)(DWORD dwDevice, LPDDCOLORCONTROL lpDDCC);


// --------------------------------------------------------------------------
// nvMoComp
//      Backdoor DMA blits and formatting for video
// 
// Command Structure
// -----------------
// NVS2VCMD_INIT
//      dwSize
//      dwDevice
//      dwIndex
//      dwHeight
//      dwSrcType
//          NVS2V_YUYV:
//              fpSrc
//          NVS2V_UYVY:
//              fpSrc
//          NVS2V_RGB16:
//              fpSrc
//          NVS2V_RGB32:
//              fpSrc
//          NVS2V_YC12
//              SrcYC12.fpY
//          NVS2V_YUV12
//              SrcYUV12.fpY (points to start of surface)
//      dwSrcPitch
//      dwDstFlags (optional)
//          NVS2VF_OFFSET
//      dwDstType (required only if using INDEXED type on BLIT)
//          NVS2V_YUYV
//              fpDst
//          NVS2V_UYVY
//              fpDst
//          NVS2V_DDSURF
//              lpDstDirectDrawSurface
// NVS2VCMD_RELEASE
//      dwSize
//      dwDevice
//      dwIndex
// NVS2VCMD_BLIT
//      dwSize
//      dwDevice
//      dwIndex
//      dwWidth
//      dwHeight
//      dwSrcFlags (optional)
//          NVS2VF_OFFSET (only use for V->S blits)
//          NVS2VF_LOCAL
//          NVS2VF_SYSTEM (default)
//      dwSrcType
//          NVS2V_YC12
//              SrcYC12.fpY
//              SrcYC12.fpC
//          NVS2V_YUV12
//              SrcYUV12.fpY
//              SrcYUV12.fpU
//              SrcYUV12.fpV
//          NVS2V_YUYV
//              fpSrc
//          NVS2V_UYVY
//              fpSrc
//          NVS2V_YV12
//              SrcYUV12.fpY
//              SrcYUV12.fpU
//              SrcYUV12.fpV
//              dwSrcYV12ChromaPitch
//      dwSrcPitch
//      dwDstFlags (optional)
//          NVS2VF_OFFSET (only use for S->V blits)
//          NVS2VF_LOCAL (default)
//          NVS2VF_SYSTEM
//      dwDstType
//          NVS2V_YUYV
//              fpDst
//          NVS2V_UYVY
//              fpDst
//          NVS2V_DDSURF
//              lpDstDirectDrawSurface
//          NVS2V_INDEXED (uses last YUY2 or UYVY state)
//              dwDstSize
//      dwDstPitch
//      bWaitForCompletion
//          dwTimeoutTime
// NVS2VCMD_QUERY_IDLE
//      dwSize
//      dwDevice
// NVS2VCMD_WAIT_FOR_IDLE
//      dwSize
//      dwDevice
//      dwTimeoutTime
// NVS2VCMD_SET_SUBPICTURE
//      dwSize
//      dwDevice
//      dwSPFlags (optional)
//          NVS2VF_OFFSET
//          NVS2VF_SP_SUBRECT
//              dwSubRectX
//              dwSubRectY
//              dwSubRectWidth
//              dwSubRectHeight
//      dwSPType
//      dwSPPitch
//      fpSP
// NVS2VCMD_VPP_START
//      dwSize
//      dwDevice
//      dwWidth
//      dwHeight
//      dwSrcType
//          NVS2V_YUYV
//              fpSrc
//          NVS2V_UYVY
//              fpSrc
//      dwSrcPitch
//      dwSrcFlags (optional)
//          NVS2VF_OFFSET
//          NVS2VF_VPP_ODD
//          NVS2VF_VPP_EVEN
//          NVS2VF_VPP_BOB
//          NVS2VF_VPP_INTERLEAVED
// NVS2VCMD_VPP_QUERY
//      dwSize
//      dwDevice
// NVS2VCMD_VPP_FLIP
//      dwSize
//      dwDevice
// NVS2VCMD_4CC_TO_VRGB
//      dwSize
//      dwIndex (0xFFFFFFFF means use video memory)
//      dwCmdFlags (optional)
//          NVS2VF_CRTC_SYNC
//              dwHead
//              dwScanline (blit will not begin until CRTC of specified head reaches this scanline)
//              dwTimeoutTime
//          NVS2VF_USE_DELIVERY_CTL
//              dwTimeoutTime
//      dwDevice
//      dwWidth
//      dwHeight
//      dwSrcFlags (optional)
//          NVS2VF_OFFSET
//          NVS2VF_LOCAL
//          NVS2VF_SYSTEM (default)
//      dwSrcType
//          NVS2V_RGB16
//              fpSrc (not required if in system memory)
//              dwSrcPixelBias (31:16 is the Y pixel bias in 12.4 fixed point, 15:0 is the X pixel bias in 12.4 fixed point)
//          NVS2V_RGB32
//              fpSrc (not required if in system memory)
//              dwSrcPixelBias (31:16 is the Y pixel bias in 12.4 fixed point, 15:0 is the X pixel bias in 12.4 fixed point)
//          NVS2V_YUYV
//              fpSrc (not required if in system memory)
//              dwSrcPixelBias (31:16 is the Y pixel bias in 12.4 fixed point, 15:0 is the X pixel bias in 12.4 fixed point)
//          NVS2V_UYVY
//              fpSrc (not required if in system memory)
//              dwSrcPixelBias (31:16 is the Y pixel bias in 12.4 fixed point, 15:0 is the X pixel bias in 12.4 fixed point)
//      dwSrcPitch
//      dwDstFlags (optional)
//          NVS2VF_OFFSET
//          NVS2VF_LOCAL (default)
//          NVS2VF_SYSTEM
//          NVS2VF_SWIZZLED
//      dwDstType
//          NVS2V_RGB16
//              DstRGB.fpRGB
//              DstRGB.dwDstWidth
//              DstRGB.dwDstHeight
//          NVS2V_RGB32
//              DstRGB.fpRGB
//              DstRGB.dwDstWidth
//              DstRGB.dwDstHeight
//      dwDstPitch
//      bWaitForCompletion
//          dwTimeoutTime
// NVS2VCMD_GET_TEXTURE_OFFSET
//      dwSize
//      dwDevice
//      fpTexture
//      returns fpTexture


#define MOCOMPCALLBACK "nvMoComp"

typedef enum {
    NVS2V_YC12      = 1,
    NVS2V_YUV12     = 2,
    NVS2V_YUYV      = 3,
    NVS2V_UYVY      = 4,
    NVS2V_DDSURF    = 5,
    NVS2V_INDEXED   = 6,
    NVS2V_YUVA16    = 7,
    NVS2V_YUVA32    = 8,
    NVS2V_YV12      = 9,
    NVS2V_RGB8      = 0x10,
    NVS2V_RGB16     = 0x11,
    NVS2V_RGB24     = 0x12,
    NVS2V_RGB32     = 0x13
} NVS2VSURFTYPE;

typedef enum {
    NVS2VCMD_NOOP               = 0,
    NVS2VCMD_INIT               = 1,
    NVS2VCMD_RELEASE            = 2,
    NVS2VCMD_BLIT               = 3,
    NVS2VCMD_QUERY_IDLE         = 4,
    NVS2VCMD_WAIT_FOR_IDLE      = 5,
    NVS2VCMD_SET_SUBPICTURE     = 6,
    NVS2VCMD_VPP_START          = 7,
    NVS2VCMD_VPP_QUERY          = 8,
    NVS2VCMD_VPP_FLIP           = 9,
    NVS2VCMD_4CC_TO_VRGB        = 0xA,
    NVS2VCMD_GET_TEXTURE_OFFSET = 0xB
} NVS2VCOMMAND;

typedef enum {
    NVS2VERR_OK             = 0,
    NVS2VERR_GENERIC_WARN   = 1,
    NVS2VERR_GENERIC_FATAL  = 0x80000001,
    NVS2VERR_BAD_COMMAND    = 0x80000002,
    NVS2VERR_INVALID_PARMS  = 0x80000003,
    NVS2VERR_INIT_FAILED    = 0x80000004,
    NVS2VERR_NO_EVENT       = 5,
    NVS2VERR_BUSY           = 6,
    NVS2VERR_TIMEOUT        = 7,
    NVS2VERR_BAD_DEVICE     = 0x80000008,
    NVS2VERR_NOT_READY      = 0x80000009, // The VPP has not been initialized
} NVS2VERROR;

#define NVS2VF_OFFSET           0x00000001
#define NVS2VF_SP_SUBRECT       0x00000002
#define NVS2VF_SP_ODD           0x00000004
#define NVS2VF_SP_EVEN          0x00000008
#define NVS2VF_VPP_ODD          0x00000010
#define NVS2VF_VPP_EVEN         0x00000020
#define NVS2VF_VPP_BOB          0x00000040
#define NVS2VF_VPP_INTERLEAVED  0x00000080
#define NVS2VF_LOCAL            0x00000100
#define NVS2VF_SYSTEM           0x00000200
#define NVS2VF_SWIZZLED         0x00000400
#define NVS2VF_CRTC_SYNC        0x00000800
#define NVS2VF_USE_DELIVERY_CTL 0x00001000

typedef struct {
    unsigned long dwSize;               // sizeof(NVS2VDATATYPE)
    
    // command data
    NVS2VCOMMAND  dwCmd;
    unsigned long dwCmdFlags;
    BOOL          bWaitForCompletion;
    unsigned long dwTimeoutTime;        // in ms
    unsigned long dwIndex;
    unsigned long dwDevice;
    unsigned long dwHead;
    unsigned long dwScanline;
    unsigned long dwReserved1[55];

    // neutral data
    unsigned long dwWidth;              // in pixels
    unsigned long dwHeight;             // in lines

    // source data
    unsigned long dwSrcFlags;
    NVS2VSURFTYPE dwSrcType;
    unsigned long dwSrcPitch;           // in bytes
    union {
        void  *fpTexture;
        void  *fpSrc;                   // used with NVS2V_YUYV or NVS2V_UYVY or NVS2V_RGB32 or NVS2V_RGB16
        void  *lpSrcDirectDrawSurface;  // used with NVS2V_DDSURF (not implemented)
        unsigned long dwSrcSize;        // used with NVS2V_INDEXED (not implemented)
        struct {
            void  *fpY;
            void  *fpC;
        } SrcYC12;                      // used with NVS2V_YC12 (Y and C must be contiguous)
        struct {
            void  *fpY;
            void  *fpU;
            void  *fpV;
        } SrcYUV12;                     // used with NVS2V_YUV12 (not implemented)
    };

    // destination data
    unsigned long dwDstFlags;
    NVS2VSURFTYPE dwDstType;
    unsigned long dwDstPitch;           // in bytes
    union {
        void  *fpDst;                   // used with NVS2V_YUYV or NVS2V_UYVY or NVS2V_RGB32 or NVS2V_RGB16
        void  *lpDstDirectDrawSurface;  // used with NVS2V_DDSURF
        unsigned long dwDstSize;        // used with NVS2V_INDEXED
        struct {
            void *fpY;
            void *fpC;
        } DstYC12;                      // used with NVS2V_YC12 (not implemented)
        struct {
            void *fpY;
            void *fpU;
            void *fpV;
        } DstYUV12;                     // used with NVS2V_YUV12 (not implemented)
        struct {
            void *fpRGB;
            unsigned long dwDstWidth;
            unsigned long dwDstHeight;
        } DstRGB;                       // used with the RGB surface types
    };

    // subpicture data
    unsigned long dwSPFlags;
    NVS2VSURFTYPE dwSPType;
    unsigned long dwSPPitch;
    unsigned long fpSP;
    unsigned long dwSubRectX;
    unsigned long dwSubRectY;
    unsigned long dwSubRectWidth;
    unsigned long dwSubRectHeight;

    // more source data
    unsigned long dwSrcYV12ChromaPitch;
    unsigned long dwSrcPixelBias;

    // pad
    unsigned long dwReserved2[40];
} NVS2VDATATYPE, *LPNVS2VDATATYPE;

typedef NVS2VERROR (__stdcall *NVMOCOMP)(LPNVS2VDATATYPE data);

#endif // _NVPRIV_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\common\inc\nvprocman.h ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-2000 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/

#ifndef __NVPROCMAN_H_
#define __NVPROCMAN_H_

#include "CompileControl.h"

#ifndef NV3
#if IS_WINNT5
#include <dx95type.h>
#include "nvntd3d.h"
#endif

#ifndef NVQTWKVER // include DDKMMINI.H only if control panel not being built
#if !IS_WINNT4
#include "ddkmmini.h"
#endif
#endif // ifndef NVQTWKVER
#endif // NV3

#define EVENTNAME_IDLE                  "NV_Idle"
#define EVENTNAME_OVL_FLIP_EVEN         "NV_OvlFlipEven"
#define EVENTNAME_OVL_FLIP_ODD          "NV_OvlFlipOdd"
#define EVENTNAME_DMA_TO_VID            "NV_DMAToVid"
#define EVENTNAME_CONVERT               "NV_Convert"
#define EVENTNAME_SUBPICTURE            "NV_SubPicture"
#define EVENTNAME_PRESCALE              "NV_PreScale"
#define EVENTNAME_COLOURCONTROL         "NV_ColourControl"
#define EVENTNAME_TFILTER               "NV_TFilter"
#define EVENTNAME_DFILTER               "NV_DFilter"
#define EVENTNAME_DISPATCH_GO           "NV_DispatchGo"
#define EVENTNAME_DISPATCH_DONE         "NV_DispatchDone"
#define EVENTNAME_FSMIRROR              "NV_FSMirror"
#define EVENTNAME_FOURCCBLT             "NV_FourCCBlt"
#define EVENTNAME_PRIMARY0_FLIP_EVEN    "NV_Primary0FlipEven"
#define EVENTNAME_PRIMARY0_FLIP_ODD     "NV_Primary0FlipOdd"
#define EVENTNAME_PRIMARY1_FLIP_EVEN    "NV_Primary1FlipEven"
#define EVENTNAME_PRIMARY1_FLIP_ODD     "NV_Primary1FlipOdd"
#define EVENTNAME_TIMER                 "NV_Timer"
#define EVENTNAME_DXEXCLUSIVEMODE       "NV_DXExclusiveMode"

#if IS_WINNT5

#define CREATE_EVENT(pHandle) EngCreateEvent(pHandle)
#define DELETE_EVENT(handle) EngDeleteEvent(handle)
#define HDRVEVENT PEVENT
#define EVENT_ERROR

#elif IS_WINNT4

// TBD - mlavoie: resolve issues with events on NT4

// VERY unsure as to whether the ddraw portion of the display can call these.
//   the miniport can so we may need to find another way -mlavoie
// Also very unsure as to whether these 2 funcs correspond to create & delete
#define CREATE_EVENT(pHandle) KeInitializeEvent(pHandle,NotificationEvent,FALSE)
#define DELETE_EVENT(handle) KeResetEvent(&(handle))
//KeWaitForSingleObject
#define HDRVEVENT NvU32
#define EVENT_ERROR

#elif IS_WIN9X

#define HDRVEVENT HANDLE
#define EVENT_ERROR {   \
    pmDeleteProcess(lpProcInfo->dwProcessID);   \
    pmAddProcess(pDriverData, GetCurrentProcessId());        }

#else
#error Unhandled OS.
#endif

// process manager structure
typedef struct tagProcessInfo {
    unsigned long dwProcessID;
    HDRVEVENT     hIdleSyncEvent0;
    HDRVEVENT     hIdleSyncEvent3;
    HDRVEVENT     hOvlFlipEvenEvent0;
    HDRVEVENT     hOvlFlipEvenEvent3;
    HDRVEVENT     hOvlFlipOddEvent0;
    HDRVEVENT     hOvlFlipOddEvent3;
    HDRVEVENT     hDMABlitToVid0;
    HDRVEVENT     hDMABlitToVid3;
    HDRVEVENT     hConvert0;
    HDRVEVENT     hConvert3;
    HDRVEVENT     hSubPicture0;
    HDRVEVENT     hSubPicture3;
    HDRVEVENT     hColourControl0;
    HDRVEVENT     hColourControl3;
    HDRVEVENT     hTFilter0;
    HDRVEVENT     hTFilter3;
    HDRVEVENT     hDFilter0;
    HDRVEVENT     hDFilter3;
    HDRVEVENT     hFSMirror0;
    HDRVEVENT     hFSMirror3;
    HDRVEVENT     hFourCCBlt0;
    HDRVEVENT     hFourCCBlt3;
    HDRVEVENT     hPrimary0FlipEven0;
    HDRVEVENT     hPrimary0FlipEven3;
    HDRVEVENT     hPrimary0FlipOdd0;
    HDRVEVENT     hPrimary0FlipOdd3;
    HDRVEVENT     hPrimary1FlipEven0;
    HDRVEVENT     hPrimary1FlipEven3;
    HDRVEVENT     hPrimary1FlipOdd0;
    HDRVEVENT     hPrimary1FlipOdd3;
    HDRVEVENT     hTimer0;
    HDRVEVENT     hTimer3;
    struct tagProcessInfo *lpNext;
} PROCESSINFO, *LPPROCESSINFO;

#ifdef __cplusplus
extern "C" {
#endif

// public
#ifndef WINNT
HANDLE        ConvertRing3EventToRing0 (HDRVEVENT hEventRing3);
BOOL          CloseRing0Handle         (HDRVEVENT hEventRing0);
#endif // WINNT
typedef struct _GLOBALDATA GLOBALDATA;
LPPROCESSINFO pmGetProcess             (GLOBALDATA *pDriverData, DWORD processID);
BOOL          pmAddProcess             (GLOBALDATA *pDriverData, DWORD processID);
BOOL          pmDeleteProcess          (DWORD processID);
void          pmDeleteAllProcesses     (GLOBALDATA *pDriverData);

HRESULT NvResetEvent(HDRVEVENT hEvent);
HRESULT NvSetEvent(HDRVEVENT hEvent);
HRESULT NvWaitEvent(HDRVEVENT hEvent, DWORD timeout);

#ifdef __cplusplus
}
#endif // __cplusplus

#endif // __NVPROCMAN_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\common\inc\nvtracecom.h ===
#ifndef __NV_TRACECOM_H
#define __NV_TRACECOM_H
// This struct is used for debug code.

typedef struct nvFunRec {
    char *uname;
    char *name;
    int class;
    int level;
    struct nvFunRec *next;
    int count;
    struct {
        int msh, lsh;
    } time;
} nvFunRec;

extern int nvDebugOptions;
extern int nvDebugMask;
extern int nvDebugLevel;
extern int nvControlOptions;

#endif // __NV_TRACECOM_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\common\inc\nvRegTool.h ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-2001 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/
#ifndef _NVREGTOOL_H_
#define _NVREGTOOL_H_

#include "nvTypes.h"

typedef void * NV_DRIVER_HANDLE;
typedef void * NV_REGISTRY_HANDLE;

#ifdef __cplusplus
class CRegTool
{
private:
#else
typedef struct CRegTool
{
#endif

#if IS_WIN9X
    NV_REGISTRY_HANDLE m_hKey;
#elif IS_WINNT
    NV_DRIVER_HANDLE m_hDriver;
#endif

#ifdef __cplusplus

public:
    NvU8 Open(NV_DRIVER_HANDLE hDriver, int logicalHeadID, char *subKeyName);
    NvU8 Read(char *keyName, NvU32 &val);
    NvU8 Read(char *keyName, NvS32 &val);
    void Close();
};
#else
} CRegTool;
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\common\inc\nvsvc_public.h ===
//
// File:         nvsvc_public.h
// Author(s):    Viet-Tam Luu
// Description:  Public exports and definitions for NVSVC clients.
// Target OS:    Windows NT, Windows 2000, Windows XP, Windows 98, Windows ME
// Platform:     IA32, IA64
//
// Copyright 2001 NVIDIA Corporation.
//

#ifndef __nvsvc_public_h__
#define __nvsvc_public_h__

#ifdef __cplusplus
extern "C" {
#endif


// Filenames of NVSVC binary under various OSes.
#define NV_SERVICE_FILE_WINNT   "nvsvc32.exe"
#define NV_SERVICE_FILE_WIN64   "nvsvc64.exe"
#define NV_SERVICE_FILE_WIN9X   "nvsvc.exe"

// Magic args to run Win9x service.
#define NV_SERVICE_ARG_W9XSTART "-runservice"
#define NV_SERVICE_ARG_W9XSTOP  "-stop"

// NVSVC service name and description strings.
#define NV_SERVICE_NAME         "NVSvc"
#define NV_SERVICE_DESC         "NVIDIA Driver Helper Service"

// Client events handled by NVSVC.
#define NVSVC_EVENT_STOP        "NVSvcStop"
#define NVSVC_EVENT_ICONBEGIN   "NVIconBeginEvent"
#define NVSVC_EVENT_ICONEND     "NVIconEndEvent"
#define NVSVC_EVENT_MODESWITCH  "NVModeSwitchEvent"
#define NVSVC_EVENT_DSWHOTKEY   "NVDisplaySwitchHotKey"
#define NVSVC_EVENT_PMM         "NVPMMEvent"

// Maximum length of any named events supported by nVidia drivers.
// This includes any prefixes to the name.
#define NVSVC_EVENT_NAME_MAX_LENGTH    256

// Event names as seen by the Win2K/NT4 drivers.
// We need to prepend a prefix to the name strings.
#define NVSVC_EVENT_ICONBEGIN_DRIVER   "\\BaseNamedObjects\\"NVSVC_EVENT_ICONBEGIN
#define NVSVC_EVENT_ICONEND_DRIVER     "\\BaseNamedObjects\\"NVSVC_EVENT_ICONEND
#define NVSVC_EVENT_MODESWITCH_DRIVER  "\\BaseNamedObjects\\"NVSVC_EVENT_MODESWITCH
#define NVSVC_EVENT_DSWHOTKEY_DRIVER   "\\BaseNamedObjects\\"NVSVC_EVENT_DSWHOTKEY

// Identifier for NVSVC's RM client.
#define NVSVC_RM_CLIENT_HANDLE  0x95510933

// Named mutex taken by first running NVSVC service (Win9x only).
#define NVSVC_MUTEX_INSTANCE    "NVSvcInstanceMutex"

#ifdef __cplusplus
}   // extern "C"
#endif

#endif	// #ifndef __nvsvc_public_h__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\common\inc\nvReg.h ===
/*
 * nvReg.h
 *
 * Registry keys and functions for the NVIDIA drivers
 *
 * Copyright (c) 1997-1999, NVIDIA Corporation.  All rights reserved.
 *
 * THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
 * NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
 * IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
 */

/* Note to OEMs:
   Please leave these strings intact.  There are utilities published on the
   net which let users edit these registry keys, and the utils expect the
   values to be in this location.  It will also allow us to occasionally post
   messages in RIVA-related web sites discussing how these values can affect
   performance and quality.  Thanks!
*/

//*****************************************************************************
// ----------------------------  NOTE  ----------------------------------------
//
// Only #define constants belong in this file.  This file is used for other
// operating systems besides Windows and should be kept clean of Windows
// specific types.
//
// ----------------------------------------------------------------------------
//*****************************************************************************


//-----------------------------------------------------------------------------
// Base
//-----------------------------------------------------------------------------

#define NV_MAX_REG_KEYNAME_LEN 256

#define NV04_REG_PRODUCT_NAME                   "RIVA TNT"
#define NV10_REG_PRODUCT_NAME                   "GeForce 256"
#define NV10GL_REG_PRODUCT_NAME                 "Quadro"

//  There are keys which are global and apply to all NVidia boards in a
//  system and those keys which are board specific. The global keys all
//  use the following path as a base:
#if defined(unix)
#define NV4_REG_GLOBAL_BASE_KEY     ""
#define NV4_REG_GLOBAL_BASE_PATH    "_NV_"
#else
#define NV4_REG_GLOBAL_BASE_KEY     HKEY_LOCAL_MACHINE
#define NV4_REG_GLOBAL_BASE_PATH    "SOFTWARE\\NVIDIA Corporation\\Global"
#endif
#define NV4_REG_MAX_STR_SIZE        256

//  For each sub-system, the following key should be tacked onto the
//  GLOBAL_BASE_PATH given above and specific registry values for that
// sub-system placed inside the resulting key.
#define NV4_REG_SUBKEY                  "NVidia"
#define NV4_REG_DISPLAY_DRIVER_SUBKEY   "Display"
#define NV4_REG_DIRECT_DRAW_SUBKEY      "DirectDraw"
#define NV4_REG_DIRECT3D_SUBKEY         "Direct3D"
#define NV4_REG_RESOURCE_MANAGER_SUBKEY "System"
#define NV4_REG_OGL_SUBKEY              "OpenGL"
#define NV4_REG_OGL_DEBUG_SUBKEY        "OpenGL\\Debug"
#define NV4_REG_CONTROL_PANEL_SUBKEY    "NVTweak"
#define NV4_REG_DESKTOP_MANAGER_SUBKEY  "NVDesk"
#define NV4_REG_MEDIA_PORT_SUBKEY       "MediaPort"
#define NV4_REG_STEREO_SUBKEY           "Stereo3D"

// For the board specific keys (also called "local" keys), the registry
// path must be run-time determined. An escape has been added to the
// display driver to return a registry path string. Each instance of the
// display driver in a multi-mon system will return a different
// registry path that is specific to the board/slot/device, etc. You
// should use this as the base path for local keys and, as with the
// global keys, tack on one of the above sub-system strings and then
// place your registry values in the resulting key. The escape to
// return the local base path is defined in
// ...drivers\common\win9x\inc\escape.h

//-----------------------------------------------------------------------------
// Display Driver
//-----------------------------------------------------------------------------

// These may be used by many labels
#define NV4_REG_DRV_TRUE                         "1"
#define NV4_REG_DRV_FALSE                        "0"

// This is for QA, so that any mode can be set.
#define NV4_REG_DRV_ALLOW_ALL_MODES             "AllowAllModes"

// This is to allow any mode up to 2048x1536 to be set as the desktop.
#define NV4_REG_DRV_ALLOW_MIGHTY_MODES          "AllowMightyModes"

// This tells what the boot device will be.
#define NV4_REG_DRV_BOOT_DEVICE_TYPE            "ForcedBootDeviceType"

// This tells us whether to use the RM or the reg for getting a
// forced boot device type.
#define NV4_REG_DRV_USE_HW_SELECTED_DEVICE      "UseHwSelectedDevice"

// This tells us whether or not to use a separate registry key for the
// clone desktop mode and the standard desktop mode.
#define NV4_REG_DRV_USE_CLONE_DESKTOP_MODE      "UseCloneDesktopMode"

// This tells us whether to restrict the desktop mode to the greatest
// EDID mode of the lesser display device.
#define NV4_REG_DRV_RESTRICT_LARGEST_MODE       "RestrictLargestMode"

// This tells us whether we should invalidate 1400x1050 as a mode when
// we are not on a 1400x1050 panel.
#define NV4_REG_DRV_1400x1050_OVERRIDE          "Override1400x1050"

// This tells us whether to send a StopImage method to the VideoLutCursorDac
// class after a modeset. This will blank the screen.                                                                 
#define NV4_REG_DRV_MODESET_STOP_IMAGE          "ModesetStopImage"

// If this key exists, it tells us the maximum allowable mode for the DFP.
#define NV4_REG_DRV_MAX_DFP_MODE                "MaxDfpMode"

// The physical device attachments are given as PhysicalDevice0,
// PhysicalDevice1, etc. This is the base string.
#define NV4_REG_DRV_PHYSICAL_DEVICE             "PhysicalDevice"

// The following reg keys are string values which always look like
// "xres,yres,bpp"  e.g. "1024,768,16"
#define NV4_REG_DRV_FORCED_DESKTOP_MODE         "ForcedDesktopMode"
#define NV4_REG_DRV_LAST_DESKTOP_MODE           "LastDesktopMode"
#define NV4_REG_DRV_LAST_CLONE_DESKTOP_MODE     "LastCloneDesktopMode"

// This keeps track of the last tv format
#define NV4_REG_DRV_LAST_TV_FORMAT              "LastTVFormat"

// These are possible values for the LastTVFormat
#define NV4_REG_DRV_NTSCM_TVFORMAT              "NTSCM"
#define NV4_REG_DRV_NTSCJ_TVFORMAT              "NTSCJ"
#define NV4_REG_DRV_PALM_TVFORMAT               "PALM"
#define NV4_REG_DRV_PALA_TVFORMAT               "PALA"
#define NV4_REG_DRV_PALN_TVFORMAT               "PALN"
#define NV4_REG_DRV_PALNC_TVFORMAT              "PALNC"

// The following reg keys are string values which always look like
// "xres,yres,bpp,refresh_rate"  e.g. "1024,768,16,75"
// These are local keys.
#define NV4_REG_DRV_LAST_CRT_MODE               "LastCRTMode"
#define NV4_REG_DRV_LAST_DFP_MODE               "LastDFPMode"
#define NV4_REG_DRV_LAST_NTSCM_MODE             "LastNTSCMMode"
#define NV4_REG_DRV_LAST_NTSCJ_MODE             "LastNTSCJMode"
#define NV4_REG_DRV_LAST_PALM_MODE              "LastPALMMode"
#define NV4_REG_DRV_LAST_PALA_MODE              "LastPALAMode"
#define NV4_REG_DRV_LAST_PALN_MODE              "LastPALNMode"
#define NV4_REG_DRV_LAST_PALNC_MODE             "LastPALNCMode"

// The following reg keys are string values which always look like
// "xres,yres,bpp,refresh_rate"  e.g. "1024,768,16,75"
// These are local keys.
#define NV4_REG_DRV_FORCED_MODE                 "ForcedMode"
#define NV4_REG_DRV_LAST_MODE                   "LastMode"

// The following registry values are used when the user requests adapter
// default refresh rate. They are all string values which look like:
// "60" or "75" etc. If the keys do not exist, the adapter default value
// is obtained in another way.
// These are local keys.
#define NV4_REG_DRV_DEFAULT_CRT_VERT_REFRESH_RATE   "DefaultCRTRefreshRate"
#define NV4_REG_DRV_DEFAULT_DFP_VERT_REFRESH_RATE   "DefaultDFPRefreshRate"

// The following registry values are used when the user requests optimal
// refresh rate. They are all string values which look like:
// "60" or "75" etc. If the keys do not exist, the optimal refresh value
// is obtained in another way.
// These are local keys.
#define NV4_REG_DRV_OPTIMAL_CRT_VERT_REFRESH_RATE   "OptimalCRTRefreshRate"
#define NV4_REG_DRV_OPTIMAL_DFP_VERT_REFRESH_RATE   "OptimalDFPRefreshRate"

// This registry value is used to override the timing standard used
// for the monitor.
#define NV4_REG_DRV_MONITOR_TIMING                  "MonitorTiming"
#define NV4_REG_DRV_MONITOR_TIMING_DMT              "DMT"
#define NV4_REG_DRV_MONITOR_TIMING_GTF              "GTF"

// This is used for the cursor alpha amount
#define NV4_REG_DRV_CURSOR_ALPHA                    "CursorAlpha"

// The following key is used to indicate that the driver should
// read the EDID and use it. It is a string value and the
// possible options are "0" and "1".
#define NV4_REG_DRV_FORCE_EDID_READ                 "ForceEdidRead"

// The following reg key ius a string value which always looks like
// "xres,yres,bpp,refresh_rate"  e.g. "1024,768,16,75"
// It is a local key. It gives the highest permissable mode when
// their is no EDID and no INF installed for the monitor.
#define NV4_REG_DRV_MONITOR_LIMIT_MODE              "NoEdidNoInfLimitMode"

// The RestrictOptimal key causes the modeset DLL to look for an
// exact Xres,Yres match with an EDID mode. If one exists, then
// that refresh rate will be the one used. If not, then other
// logic determines the refresh rate. The possible values are
// NV4_REG_DRV_TRUE or NV4_REG_DRV_FALSE
#define NV4_REG_DRV_USE_REFRESH_RATE_OF_XYRES_EDID_MODE_MATCH   "RestrictOptimal"

// These are erased by the driver at boot time.
#define POWERUPFLAGS                                "PowerUpFlags"

// These are used by the driver for dual-head support
#define NV4_REG_DRV_VIRTUALDESKTOP                  "VirtualDesktop"
#define NV4_REG_DRV_AUTOPANMODE                     "AutoPanMode"

// This key is read to indicate whether we should run single monitor,
// multimon or clone mode.
#define NV4_REG_DRV_DESKTOPSTATE                    "DesktopState"
#define NV4_REG_DRV_DESKTOP_STATE_NORMAL            "Single"
#define NV4_REG_DRV_DESKTOP_STATE_MULTI_MON         "Multi"
#define NV4_REG_DRV_DESKTOP_STATE_CLONE             "Clone"

// This key is read to determine whether or not to check for an SXGA Panel.
#define NV4_REG_DRV_CHECK_SXGA_PANEL                "CheckSXGAPanel"

// This key is read to determine whether or not to set panning for the clone device.
#define NV4_REG_DRV_PANNING_FLAG                    "CloneDevicePanningFlag"


//-----------------------------------------------------------------------------
// DirectDraw
//-----------------------------------------------------------------------------

// default is enabled, define and set to zero to disable
#define NV4_REG_VPE_ENABLE              "VPEENABLE"

// EnumDDRefresh (default = 0)
//      0 = do not enumerate refresh rates
//      1 = only enumerate refresh rates of modes above 640x480
//      2 = enumerate all refresh rates
#define NV4_REG_ENUM_REFRESH                "EnumDDRefresh"
#define   NV4_REG_ENUM_REFRESH_DISABLE      0
#define   NV4_REG_ENUM_REFRESH_ENABLEBIG    1
#define   NV4_REG_ENUM_REFRESH_ENABLEALL    2

// all the overlay settings are local

// OverlayMode (default = 0)
//      0 = always use overlay upscale
//      1 = use vertical blt upscale if sufficient resources
//      2 = use temporal filter
//      3 = this is not the first frame (gets autoset after 1 frame)
//      8-15 = temporal filter factor
#define NV4_REG_OVL_MODE                "OverlayMode"
#define   NV4_REG_OVL_MODE_VUPSCALE     0x1
#define   NV4_REG_OVL_MODE_TFILTER      0x2
#define   NV4_REG_OVL_MODE_NOTFIRST     0x4
#define   NV4_REG_OVL_MODE_TF_PRECOPY   0x8
#define   NV4_REG_OVL_MODE_LATEFLIPSYNC 0x10
#define   NV4_REG_OVL_MODE_DFILTER      0x20
#define   NV4_REG_OVL_MODE_DF_PRECOPY   0x40
#define   NV4_REG_OVL_MODE_TFACTOR      15:8
#define   NV4_REG_OVL_MODE_DFACTOR      23:16

// OverlayMode2 (default = 0)
//   bits 0-3 = Full screen mirror device number (1 based, zero means disable)
//      bit 4 = Preserve aspect in full screen mirror mode
//      bit 5 = Fix aspect ratio to 16:9, bit 4 must be set also
//      bit 6 = Track aspect ratio of overlay, bit 4 must be set also
//      bit 7 = Fix aspect ratio to 4:3, bit 4 must also be set
//      bits 8-11 = Video zoom quadrant
//                  0: zoom disabled
//                  1: top left quadrant
//                  2: top right quadrant
//                  3: bottom left quadrant
//                  4: bottom right quadrant
//                  5: center
//      bits 12-23 = Video zoom factor, 0 = 1x, 255 = 2x
//      bit 24 = Let the driver pick the full screen display mode
//      bit 25 = Track overlay zoom
//      bit 26 = Enable TV devices
#define NV4_REG_OVL_MODE2                       "OverlayMode2"
#define     NV4_REG_OVL_MODE2_FSMASK            0x007FFFFF
#define     NV4_REG_OVL_MODE2_FSDEVICEMASK      0x0000000F
#define     NV4_REG_OVL_MODE2_FSASPECTMASK      0x000000F0
#define     NV4_REG_OVL_MODE2_FSZOOMQUADMASK    0x00000F00
#define     NV4_REG_OVL_MODE2_FSZOOMFACTORMASK  0x000FF000
#define     NV4_REG_OVL_MODE2_FSDEVICE          0:3
#define     NV4_REG_OVL_MODE2_FSASPECT          0x00000010
#define     NV4_REG_OVL_MODE2_FSFIXEDANIMORPHIC 0x00000020
#define     NV4_REG_OVL_MODE2_FSTRACKOVLASPECT  0x00000040
#define     NV4_REG_OVL_MODE2_FSFIXEDTV         0x00000080
#define     NV4_REG_OVL_MODE2_FSZOOMQUAD        8:11
#define     NV4_REG_OVL_MODE2_FSZOOMFACTOR      12:23
#define     NV4_REG_OVL_MODE2_FSSETMODE         0x00100000
#define     NV4_REG_OVL_MODE2_FSTRACKOVLZOOM    0x00200000
#define     NV4_REG_OVL_MODE2_FSENABLETV        0x00400000

// OverlayMode3 (default = 0);
//   bit 0 = Allow overlay creation in clone mode and win2k span mode
//   bits 8-11 = Overlay zoom quadrant
//               0: zoom disabled
//               1: top left quadrant
//               2: top right quadrant
//               3: bottom left quadrant
//               4: bottom right quadrant
//               5: center
//   bits 12-23: Overlay zoom factor, 0 = 1x, 255 = 2x
#define NV4_REG_OVL_MODE3                                   "OverlayMode3"
#define     NV4_REG_OVL_MODE3_ALLOWOVL                      0x00000001
#define     NV4_REG_OVL_MODE3_DXVA_BACK_END_ALPHA_PREFERRED 0x00000002
#define     NV4_REG_OVL_MODE3_OVLZOOMMASK                   0x000FFF00
#define     NV4_REG_OVL_MODE3_OVLZOOMQUADMASK               0x00000F00
#define     NV4_REG_OVL_MODE3_OVLZOOMFACTORMASK             0x000FF000
#define     NV4_REG_OVL_MODE3_OVLZOOMQUAD                   8:11
#define     NV4_REG_OVL_MODE3_OVLZOOMFACTOR                 12:23

// VPPInvMask (default = 0)
//      Inverse mask for all VPP function enables.  Should exactly match
//      command flags defined in ddVPP.h
#define NV4_REG_VPP_INV_MASK                "VPPInvMask"
#define   NV4_REG_VPP_INV_MASK_ODD          0x1
#define   NV4_REG_VPP_INV_MASK_EVEN         0x2
#define   NV4_REG_VPP_INV_MASK_BOB          0x4
#define   NV4_REG_VPP_INV_MASK_INTERLEAVED  0x8
#define   NV4_REG_VPP_INV_MASK_VIDEOPORT    0x10
#define   NV4_REG_VPP_INV_MASK_WAIT         0x20
#define   NV4_REG_VPP_SAVE_STATE_DISABLE    0x40
#define   NV4_REG_VPP_RESTORE_STATE_DISABLE 0x80
#define   NV4_REG_VPP_CONVERT_DISABLE       0x100
#define   NV4_REG_VPP_SUBPICTURE_DISABLE    0x200
#define   NV4_REG_VPP_PRESCALE_DISABLE      0x400
#define   NV4_REG_VPP_COLOURCONTROL_DISABLE 0x800
#define   NV4_REG_VPP_TEMPORAL_DISABLE      0x1000
#define   NV4_REG_VPP_OPTIMIZEFLIP_DISABLE  0x2000
#define   NV4_REG_VPP_DEINTERLACE_DISABLE   0x4000
#define   NV4_REG_VPP_FSMIRROR_DISABLE      0x8000
#define   NV4_REG_VPP_DMABLIT_DISABLE       0x10000
#define   NV4_REG_VPP_MASTER_DISABLE        0x80000000

// VPPMaxSurfaces
//      Determines the maximum number of work surfaces VPP is allowed to use.
//      Legal values are:
//          6 - Full functionality and performance
//          4 - Full functionality, no superpipelining
//          3 - One stage allowed, superpipelined
//          2 - One stage allowed, no superpipelining
//          0 - VPP disabled
#define NV4_REG_VPP_MAX_SURFACES            "VPPMaxSurfaces"

// OverlayColorControlEnable (default = 0)
//      0 = disable
//      1 = enable with vertical chroma subsampling enabled (use this one)
//      2 = enable with vertical chroma subsampling disabled
// OverlayBrightness (default = 0)
// OverlayContrast (default = 100)
// OverlayHue (default = 0)
// OverlaySaturation (default = 100)
// OverlayGamma (not implemented)
// OverlaySharpness (not implemented)
#define NV4_REG_OVLCC_ENABLE            "OverlayColorControlEnable"
#define NV4_REG_OVLCC_BRIGHTNESS        "OverlayBrightness"
#define NV4_REG_OVLCC_CONTRAST          "OverlayContrast"
#define NV4_REG_OVLCC_HUE               "OverlayHue"
#define NV4_REG_OVLCC_SATURATION        "OverlaySaturation"
#define NV4_REG_OVLCC_GAMMA             "OverlayGamma"
#define NV4_REG_OVLCC_SHARPNESS         "OverlaySharpness"

#define NV4_REG_OVLCC_BRIGHTNESS_DEFAULT  0
#define NV4_REG_OVLCC_CONTRAST_DEFAULT    100
#define NV4_REG_OVLCC_HUE_DEFAULT         0
#define NV4_REG_OVLCC_SATURATION_DEFAULT  100

// VideoBusMasterMode (default = 0)
//      Determine which hacks to implement for bus mastering TV tuners (will not work on WINNT)
//      0 = No special hacks
//      1 = If no flips detected and 1 overlay surface, force into autoflip mode
//      2 = If 1 overlay surface, force autoflip
//      3 = Force autoflip
#define NV4_REG_VIDEO_BUS_MASTER_MODE   "VideoBusMasterMode"
#define   NV4_REG_VBMM_NOHACK           0
#define   NV4_REG_VBMM_DETECT           1
#define   NV4_REG_VBMM_SINGLEOVL        2
#define   NV4_REG_VBMM_FORCE            3

//-----------------------------------------------------------------------------
// Direct3D
//-----------------------------------------------------------------------------

// To add registry settings:
// 1. choose a category:
//    boolean, enumerated non-boolean, non-enumerated non-boolean, or string
// 2. add definitions as required for that category. make sure to include a definition
//    for the default value (and PLEASE ALPHABETIZE and use the same ordering for ALL
//    OF WHAT FOLLOWS!)
// 3. add a reg_entry to the definition of reg_struc in global.h
// 4. add the string to the initialization of reg_struc in global.cpp
// 5. add the default value to the initializations at the top of D3DReadRegistry()
// 6. add a routine to actually read and cache the registry value in D3DReadRegistry()

// ------------ Boolean enables / disables ------------------------------------

// Each boolean enable gets one bit in a control word.
#define D3D_REG_BIT_ALTERNATEZENABLE                    0
#define D3D_REG_BIT_ANTIALIASENABLE                     1
#define D3D_REG_BIT_ANTIALIASDYNAMICENABLE              2
#define D3D_REG_BIT_ANTIALIASFORCEENABLE                3
#define D3D_REG_BIT_ANTIALIASCONVOLUTIONFASTMODE        4
#define D3D_REG_BIT_CKCOMPATABILITYENABLE               5
#define D3D_REG_BIT_CONTROLTRAFFICENABLE                6
// unused                       7
#define D3D_REG_BIT_DIRECTMAPENABLE                     8
// unused                       9
#define D3D_REG_BIT_ENFORCESTRICTTRILINEAR              10
// unused                       11
#define D3D_REG_BIT_FLUSHAFTERBLITENABLE                12
#define D3D_REG_BIT_FOGTABLEENABLE                      13
#define D3D_REG_BIT_FORCEBLITWAITFLAGENABLE             14
#define D3D_REG_BIT_LIMITQUEUEDFBBLITSENABLE            15
// unused                       16
#define D3D_REG_BIT_LOGOENABLE                          17
#ifdef TEXFORMAT_CRD
// unused                       18
#else
#define D3D_REG_BIT_PALETTEENABLE                       18
#endif
#define D3D_REG_BIT_SQUASHWENABLE                       19
#define D3D_REG_BIT_SSYNCENABLE                         20
#ifdef TEXFORMAT_CRD
// unused                       21
#else
#define D3D_REG_BIT_TEXTURECOMPRESSIONENABLE            21
#endif
// unused                       22
#define D3D_REG_BIT_TEXTUREMANAGEMENTENABLE             23
#define D3D_REG_BIT_TILINGENABLE                        24
#define D3D_REG_BIT_ZCULLENABLE                         25
#define D3D_REG_BIT_USERMIPMAPENABLE                    26
#define D3D_REG_BIT_VIDEOTEXTUREENABLE                  27
#define D3D_REG_BIT_VS_HOS_EMULATION                    28
#define D3D_REG_BIT_WBUFFERENABLE                       29
#define D3D_REG_BIT_Z24ENABLE                           30
#define D3D_REG_BIT_ZCOMPRESSENABLE                     31

// ALTERNATEZENABLE
#define D3D_REG_ALTERNATEZENABLE_STRING                 "ALTERNATEZENABLE"
#define D3D_REG_ALTERNATEZENABLE_MASK                   (1 << D3D_REG_BIT_ALTERNATEZENABLE)
#define D3D_REG_ALTERNATEZENABLE_DISABLE                (0 << D3D_REG_BIT_ALTERNATEZENABLE)
#define D3D_REG_ALTERNATEZENABLE_ENABLE                 (1 << D3D_REG_BIT_ALTERNATEZENABLE)

// ANTIALIASENABLE
#define D3D_REG_ANTIALIASENABLE_STRING                  "ANTIALIASENABLE"
#define D3D_REG_ANTIALIASENABLE_MASK                    (1 << D3D_REG_BIT_ANTIALIASENABLE)         // Enable Anti-Aliasing support.
#define D3D_REG_ANTIALIASENABLE_DISABLE                 (0 << D3D_REG_BIT_ANTIALIASENABLE)         // Disable Anti-Aliasing support.
#define D3D_REG_ANTIALIASENABLE_ENABLE                  (1 << D3D_REG_BIT_ANTIALIASENABLE)         // Enable Anti-Aliasing support.

// ANTIALIASDYNAMICENABLE
#define D3D_REG_ANTIALIASDYNAMICENABLE_STRING           "ANTIALIASDYNAMICENABLE"
#define D3D_REG_ANTIALIASDYNAMICENABLE_MASK             (1 << D3D_REG_BIT_ANTIALIASDYNAMICENABLE)  // Enable Dynamic Anti-Aliasing support.
#define D3D_REG_ANTIALIASDYNAMICENABLE_DISABLE          (0 << D3D_REG_BIT_ANTIALIASDYNAMICENABLE)  // Disable Dynamic Anti-Aliasing support.
#define D3D_REG_ANTIALIASDYNAMICENABLE_ENABLE           (1 << D3D_REG_BIT_ANTIALIASDYNAMICENABLE)  // Enable Dynamic Anti-Aliasing support.

// ANTIALIASFORCEENABLE
#define D3D_REG_ANTIALIASFORCEENABLE_STRING             "ANTIALIASFORCEENABLE"
#define D3D_REG_ANTIALIASFORCEENABLE_MASK               (1 << D3D_REG_BIT_ANTIALIASFORCEENABLE)
#define D3D_REG_ANTIALIASFORCEENABLE_DISABLE            (0 << D3D_REG_BIT_ANTIALIASFORCEENABLE)
#define D3D_REG_ANTIALIASFORCEENABLE_ENABLE             (1 << D3D_REG_BIT_ANTIALIASFORCEENABLE)

// ANTIALIASCONVOLUTIONFASTMODE
#define D3D_REG_ANTIALIASCONVOLUTIONFASTMODE_STRING     "ANTIALIASCONVOLUTIONFASTMODE"
#define D3D_REG_ANTIALIASCONVOLUTIONFASTMODE_MASK       (1 << D3D_REG_BIT_ANTIALIASCONVOLUTIONFASTMODE)
#define D3D_REG_ANTIALIASCONVOLUTIONFASTMODE_DISABLE    (0 << D3D_REG_BIT_ANTIALIASCONVOLUTIONFASTMODE)
#define D3D_REG_ANTIALIASCONVOLUTIONFASTMODE_ENABLE     (1 << D3D_REG_BIT_ANTIALIASCONVOLUTIONFASTMODE)

// COLORKEYCOMPATIBILITYENABLE
#define D3D_REG_CKCOMPATABILITYENABLE_STRING            "COLORKEYCOMPATABILITYENABLE"
#define D3D_REG_CKCOMPATABILITYENABLE_MASK              (1 << D3D_REG_BIT_CKCOMPATABILITYENABLE)
#define D3D_REG_CKCOMPATABILITYENABLE_DISABLE           (0 << D3D_REG_BIT_CKCOMPATABILITYENABLE)
#define D3D_REG_CKCOMPATABILITYENABLE_ENABLE            (1 << D3D_REG_BIT_CKCOMPATABILITYENABLE)

// CONTROLTRAFFIC
#define D3D_REG_CONTROLTRAFFICENABLE_STRING             "CONTROLTRAFFIC"
#define D3D_REG_CONTROLTRAFFICENABLE_MASK               (1 << D3D_REG_BIT_CONTROLTRAFFICENABLE)
#define D3D_REG_CONTROLTRAFFICENABLE_DISABLE            (0 << D3D_REG_BIT_CONTROLTRAFFICENABLE)
#define D3D_REG_CONTROLTRAFFICENABLE_ENABLE             (1 << D3D_REG_BIT_CONTROLTRAFFICENABLE)

// DIRECTMAPENABLE
#define D3D_REG_DIRECTMAPENABLE_STRING                  "DIRECTMAPENABLE"
#define D3D_REG_DIRECTMAPENABLE_MASK                    (1 << D3D_REG_BIT_DIRECTMAPENABLE)
#define D3D_REG_DIRECTMAPENABLE_DISABLE                 (0 << D3D_REG_BIT_DIRECTMAPENABLE)
#define D3D_REG_DIRECTMAPENABLE_ENABLE                  (1 << D3D_REG_BIT_DIRECTMAPENABLE)

// ENFORCESTRICTTRILINEAR
#define D3D_REG_ENFORCESTRICTTRILINEAR_STRING           "ENFORCESTRICTTRILINEAR"
#define D3D_REG_ENFORCESTRICTTRILINEAR_MASK             (1 << D3D_REG_BIT_ENFORCESTRICTTRILINEAR)
#define D3D_REG_ENFORCESTRICTTRILINEAR_DISABLE          (0 << D3D_REG_BIT_ENFORCESTRICTTRILINEAR)
#define D3D_REG_ENFORCESTRICTTRILINEAR_ENABLE           (1 << D3D_REG_BIT_ENFORCESTRICTTRILINEAR)

// FLUSHAFTERBLITENABLE
#define D3D_REG_FLUSHAFTERBLITENABLE_STRING             "FLUSHAFTERBLITENABLE"
#define D3D_REG_FLUSHAFTERBLITENABLE_MASK               (1 << D3D_REG_BIT_FLUSHAFTERBLITENABLE)
#define D3D_REG_FLUSHAFTERBLITENABLE_DISABLE            (0 << D3D_REG_BIT_FLUSHAFTERBLITENABLE)
#define D3D_REG_FLUSHAFTERBLITENABLE_ENABLE             (1 << D3D_REG_BIT_FLUSHAFTERBLITENABLE)

// FOGTABLEENABLE
#define D3D_REG_FOGTABLEENABLE_STRING                   "FOGTABLEENABLE"
#define D3D_REG_FOGTABLEENABLE_MASK                     (1 << D3D_REG_BIT_FOGTABLEENABLE)       // Enable Fog Table support
#define D3D_REG_FOGTABLEENABLE_DISABLE                  (0 << D3D_REG_BIT_FOGTABLEENABLE)       // Disable Fog Table support.
#define D3D_REG_FOGTABLEENABLE_ENABLE                   (1 << D3D_REG_BIT_FOGTABLEENABLE)       // Enable Fog Table support

// FORCEBLITWAITFLAGENABLE
#define D3D_REG_FORCEBLITWAITFLAGENABLE_STRING          "FORCEBLITWAITFLAGENABLE"
#define D3D_REG_FORCEBLITWAITFLAGENABLE_MASK            (1 << D3D_REG_BIT_FORCEBLITWAITFLAGENABLE)
#define D3D_REG_FORCEBLITWAITFLAGENABLE_DISABLE         (0 << D3D_REG_BIT_FORCEBLITWAITFLAGENABLE)
#define D3D_REG_FORCEBLITWAITFLAGENABLE_ENABLE          (1 << D3D_REG_BIT_FORCEBLITWAITFLAGENABLE)

// LIMITQUEUEDFBBLITSENABLE
#define D3D_REG_LIMITQUEUEDFBBLITSENABLE_STRING         "LIMITQUEUEDFBBLITSENABLE"
#define D3D_REG_LIMITQUEUEDFBBLITSENABLE_MASK           (1 << D3D_REG_BIT_LIMITQUEUEDFBBLITSENABLE)
#define D3D_REG_LIMITQUEUEDFBBLITSENABLE_DISABLE        (0 << D3D_REG_BIT_LIMITQUEUEDFBBLITSENABLE)
#define D3D_REG_LIMITQUEUEDFBBLITSENABLE_ENABLE         (1 << D3D_REG_BIT_LIMITQUEUEDFBBLITSENABLE)

// LOGOENABLE
#define D3D_REG_LOGOENABLE_STRING                       "LOGOENABLE"
#define D3D_REG_LOGOENABLE_MASK                         (1 << D3D_REG_BIT_LOGOENABLE)            // Enable NVIDIA logo
#define D3D_REG_LOGOENABLE_DISABLE                      (0 << D3D_REG_BIT_LOGOENABLE)            // Disable NVIDIA logo
#define D3D_REG_LOGOENABLE_ENABLE                       (1 << D3D_REG_BIT_LOGOENABLE)            // Enable NVIDIA logo

#ifndef TEXFORMAT_CRD
// PALETTEENABLE
#define D3D_REG_PALETTEENABLE_STRING                    "PALETTEENABLE"
#define D3D_REG_PALETTEENABLE_MASK                      (1 << D3D_REG_BIT_PALETTEENABLE)
#define D3D_REG_PALETTEENABLE_DISABLE                   (0 << D3D_REG_BIT_PALETTEENABLE)
#define D3D_REG_PALETTEENABLE_ENABLE                    (1 << D3D_REG_BIT_PALETTEENABLE)
#endif

// SQUASHW
#define D3D_REG_SQUASHW_STRING                          "SQUASHW"
#define D3D_REG_SQUASHW_MASK                            (1 << D3D_REG_BIT_SQUASHWENABLE)
#define D3D_REG_SQUASHW_DISABLE                         (0 << D3D_REG_BIT_SQUASHWENABLE)
#define D3D_REG_SQUASHW_ENABLE                          (1 << D3D_REG_BIT_SQUASHWENABLE)

// SSYNCENABLE
// This is a major hack to work around input lag in stupid applications that
// want to use blits instead of flips to do there screen updates but then don't
// make any getblitstatus calls to see if the blit has completed before beginning
// to render the next frame.
// This is not something that you want to have enabled unless you absolutely need
// to have it enabled.
#define D3D_REG_SSYNCENABLE_STRING                      "SCENESYNCENABLE"
#define D3D_REG_SSYNCENABLE_MASK                        (1 << D3D_REG_BIT_SSYNCENABLE)
#define D3D_REG_SSYNCENABLE_DISABLE                     (0 << D3D_REG_BIT_SSYNCENABLE)
#define D3D_REG_SSYNCENABLE_ENABLE                      (1 << D3D_REG_BIT_SSYNCENABLE)

#ifndef TEXFORMAT_CRD
// TEXTURECOMPRESSIONENABLE
#define D3D_REG_TEXTURECOMPRESSIONENABLE_STRING         "TEXTURECOMPRESSIONENABLE"
#define D3D_REG_TEXTURECOMPRESSIONENABLE_MASK           (1 << D3D_REG_BIT_TEXTURECOMPRESSIONENABLE)
#define D3D_REG_TEXTURECOMPRESSIONENABLE_DISABLE        (0 << D3D_REG_BIT_TEXTURECOMPRESSIONENABLE)
#define D3D_REG_TEXTURECOMPRESSIONENABLE_ENABLE         (1 << D3D_REG_BIT_TEXTURECOMPRESSIONENABLE)
#endif

// TEXTUREMANAGEMENTENABLE
#define D3D_REG_TEXTUREMANAGEMENTENABLE_STRING          "TEXTUREMANAGEMENTENABLE"
#define D3D_REG_TEXTUREMANAGEMENTENABLE_MASK            (1 << D3D_REG_BIT_TEXTUREMANAGEMENTENABLE)
#define D3D_REG_TEXTUREMANAGEMENTENABLE_DISABLE         (0 << D3D_REG_BIT_TEXTUREMANAGEMENTENABLE)
#define D3D_REG_TEXTUREMANAGEMENTENABLE_ENABLE          (1 << D3D_REG_BIT_TEXTUREMANAGEMENTENABLE)

// TILINGENABLE
#define D3D_REG_TILINGENABLE_STRING                     "TILINGENABLE"
#define D3D_REG_TILINGENABLE_MASK                       (1 << D3D_REG_BIT_TILINGENABLE)
#define D3D_REG_TILINGENABLE_DISABLE                    (0 << D3D_REG_BIT_TILINGENABLE)
#define D3D_REG_TILINGENABLE_ENABLE                     (1 << D3D_REG_BIT_TILINGENABLE)

// ZCULLENABLE
#define D3D_REG_ZCULLENABLE_STRING                      "ZCULLENABLE"
#define D3D_REG_ZCULLENABLE_MASK                        (1 << D3D_REG_BIT_ZCULLENABLE)
#define D3D_REG_ZCULLENABLE_DISABLE                     (0 << D3D_REG_BIT_ZCULLENABLE)
#define D3D_REG_ZCULLENABLE_ENABLE                      (1 << D3D_REG_BIT_ZCULLENABLE)

// USERMIPMAPENABLE - enable User supplied mipmaps
#define D3D_REG_USERMIPMAPENABLE_STRING                 "USERMIPMAPENABLE"
#define D3D_REG_USERMIPMAPENABLE_MASK                   (1 << D3D_REG_BIT_USERMIPMAPENABLE)
#define D3D_REG_USERMIPMAPENABLE_DISABLE                (0 << D3D_REG_BIT_USERMIPMAPENABLE)
#define D3D_REG_USERMIPMAPENABLE_ENABLE                 (1 << D3D_REG_BIT_USERMIPMAPENABLE)

// VIDEOTEXTUREENABLE - enable texturing from video memory
#define D3D_REG_VIDEOTEXTUREENABLE_STRING               "VIDEOTEXTUREENABLE"
#define D3D_REG_VIDEOTEXTUREENABLE_MASK                 (1 << D3D_REG_BIT_VIDEOTEXTUREENABLE)
#define D3D_REG_VIDEOTEXTUREENABLE_DISABLE              (0 << D3D_REG_BIT_VIDEOTEXTUREENABLE)
#define D3D_REG_VIDEOTEXTUREENABLE_ENABLE               (1 << D3D_REG_BIT_VIDEOTEXTUREENABLE)

// VertexShader/Higher order surface emulation for NV10/NV15 class parts
#define D3D_REG_BIT_VS_HOS_EMULATION                    28
#define D3D_REG_VS_HOS_EMULATION_STRING                 "VS_HOS_EMULATION"
#define D3D_REG_VS_HOS_EMULATION_MASK                   (1 << D3D_REG_BIT_VS_HOS_EMULATION)
#define D3D_REG_VS_HOS_EMULATION_DISABLE                (0 << D3D_REG_BIT_VS_HOS_EMULATION)
#define D3D_REG_VS_HOS_EMULATION_ENABLE                 (1 << D3D_REG_BIT_VS_HOS_EMULATION)

// WBUFFERING
#define D3D_REG_WBUFFERENABLE_STRING                    "WENABLE"
#define D3D_REG_WBUFFERENABLE_MASK                      (1 << D3D_REG_BIT_WBUFFERENABLE)
#define D3D_REG_WBUFFERENABLE_DISABLE                   (0 << D3D_REG_BIT_WBUFFERENABLE)
#define D3D_REG_WBUFFERENABLE_ENABLE                    (1 << D3D_REG_BIT_WBUFFERENABLE)

// Z24ENABLE
#define D3D_REG_Z24ENABLE_STRING                        "Z24ENABLE"
#define D3D_REG_Z24ENABLE_MASK                          (1 << D3D_REG_BIT_Z24ENABLE)
#define D3D_REG_Z24ENABLE_DISABLE                       (0 << D3D_REG_BIT_Z24ENABLE)
#define D3D_REG_Z24ENABLE_ENABLE                        (1 << D3D_REG_BIT_Z24ENABLE)

// ZCOMPRESSENABLE
#define D3D_REG_ZCOMPRESSENABLE_STRING                  "ZCOMPRESSENABLE"
#define D3D_REG_ZCOMPRESSENABLE_MASK                    (1 << D3D_REG_BIT_ZCOMPRESSENABLE)
#define D3D_REG_ZCOMPRESSENABLE_DISABLE                 (0 << D3D_REG_BIT_ZCOMPRESSENABLE)
#define D3D_REG_ZCOMPRESSENABLE_ENABLE                  (1 << D3D_REG_BIT_ZCOMPRESSENABLE)

//// not currently in use - rel6 maybe?
// ANTIALIASENABLE
#define D3D_REG_ANTIALIASDYNAMICENABLE_STRING           "ANTIALIASDYNAMICENABLE"
#define D3D_REG_ANTIALIASDYNAMICENABLE_MASK             (1 << D3D_REG_BIT_ANTIALIASDYNAMICENABLE)         // Enable Dynamic Anti-Aliasing support.
#define D3D_REG_ANTIALIASDYNAMICENABLE_DISABLE          (0 << D3D_REG_BIT_ANTIALIASDYNAMICENABLE)         // Disable Dynamic Anti-Aliasing support.
#define D3D_REG_ANTIALIASDYNAMICENABLE_ENABLE           (1 << D3D_REG_BIT_ANTIALIASDYNAMICENABLE)         // Enable Dynamic Anti-Aliasing support.

// Default values for registry configurable driver settings.
#define D3D_REG_DEFAULT_ALTERNATEZENABLE                D3D_REG_ALTERNATEZENABLE_DISABLE
#define D3D_REG_DEFAULT_ANTIALIASENABLE                 D3D_REG_ANTIALIASENABLE_ENABLE            // enable Anti Aliasing.
#define D3D_REG_DEFAULT_ANTIALIASDYNAMICENABLE          D3D_REG_ANTIALIASDYNAMICENABLE_ENABLE     // enable dynamic Anti Aliasing.
#define D3D_REG_DEFAULT_ANTIALIASFORCEENABLE            D3D_REG_ANTIALIASFORCEENABLE_DISABLE      // Disable forced Anti Aliasing.
#define D3D_REG_DEFAULT_ANTIALIASCONVOLUTIONFASTMODE    D3D_REG_ANTIALIASCONVOLUTIONFASTMODE_DISABLE // Disable the fast mode for 5x and 9x AA by default
#define D3D_REG_DEFAULT_CKCOMPATABILITYENABLE           D3D_REG_CKCOMPATABILITYENABLE_ENABLE      // Perform application colorkey fixups.
#define D3D_REG_DEFAULT_CONTROLTRAFFICENABLE            D3D_REG_CONTROLTRAFFICENABLE_ENABLE
#define D3D_REG_DEFAULT_DIRECTMAPENABLE                 D3D_REG_DIRECTMAPENABLE_ENABLE            // Enable Direct Mapping of Texture Combiners by default.
#define D3D_REG_DEFAULT_ENFORCESTRICTTRILINEAR          D3D_REG_ENFORCESTRICTTRILINEAR_ENABLE     // Enforces multitexture-trilinear ot NOT use dithering approximation
#define D3D_REG_DEFAULT_FLUSHAFTERBLITENABLE            D3D_REG_FLUSHAFTERBLITENABLE_DISABLE      // Disable flush after blit on wait flag
#define D3D_REG_DEFAULT_FOGTABLEENABLE                  D3D_REG_FOGTABLEENABLE_ENABLE             // Enable software implemented fog table support.
#define D3D_REG_DEFAULT_FORCEBLITWAITFLAGENABLE         D3D_REG_FORCEBLITWAITFLAGENABLE_DISABLE   // Disable force the BLT_WAIT flag
#define D3D_REG_DEFAULT_LIMITQUEUEDFBBLITSENABLE        D3D_REG_LIMITQUEUEDFBBLITSENABLE_DISABLE  // Disable limiting the max number of queued FB blits
#define D3D_REG_DEFAULT_LOGOENABLE                      D3D_REG_LOGOENABLE_DISABLE
#ifndef TEXFORMAT_CRD
#define D3D_REG_DEFAULT_PALETTEENABLE                   D3D_REG_PALETTEENABLE_ENABLE              // Enable 8-bit textures (relevant only >=DX8. always disabled for <=DX7)
#endif
#define D3D_REG_DEFAULT_SQUASHW                         D3D_REG_SQUASHW_DISABLE
#define D3D_REG_DEFAULT_SSYNCENABLE                     D3D_REG_SSYNCENABLE_DISABLE               // MAJOR APP HACK should never be enbled by default!!
#ifndef TEXFORMAT_CRD
#define D3D_REG_DEFAULT_TEXTURECOMPRESSIONENABLE        D3D_REG_TEXTURECOMPRESSIONENABLE_ENABLE   // Enable Texture compression so we can 'disable' for badly behaving apps
#endif
#define D3D_REG_DEFAULT_TEXTUREMANAGEMENTENABLE         D3D_REG_TEXTUREMANAGEMENTENABLE_ENABLE    // enable driver-based texture management
#define D3D_REG_DEFAULT_TILINGENABLE                    D3D_REG_TILINGENABLE_ENABLE
#define D3D_REG_DEFAULT_ZCULLENABLE                     D3D_REG_ZCULLENABLE_ENABLE                // Enable z occlusion culling by default (applicable to nv20 ff.)
#define D3D_REG_DEFAULT_USERMIPMAPENABLE                D3D_REG_USERMIPMAPENABLE_ENABLE           // Enable use of user supplied mip maps
#define D3D_REG_DEFAULT_VIDEOTEXTUREENABLE              D3D_REG_VIDEOTEXTUREENABLE_ENABLE         // Enable texturing from video memory
#define D3D_REG_DEFAULT_WBUFFERENABLE                   D3D_REG_WBUFFERENABLE_ENABLE
#define D3D_REG_DEFAULT_Z24ENABLE                       D3D_REG_Z24ENABLE_ENABLE                  // Enable 24bit z-exports by default
#define D3D_REG_DEFAULT_ZCOMPRESSENABLE                 D3D_REG_ZCOMPRESSENABLE_ENABLE            // Enable z compression by default (applicable to nv20 ff.)

// ----------- Non-boolean settings with enumerated values ------------------

// AntiAliasQuality definitions.
#define D3D_REG_ANTIALIASQUALITY_STRING                 "ANTIALIASQUALITY"
#define D3D_REG_ANTIALIASQUALITY_MIN                    0
#define D3D_REG_ANTIALIASQUALITY_MAX                    7

//// not currently in use - rel6 maybe?
// AntiAliasDynamicFPS definitions.
#define D3D_REG_ANTIALIASDYNAMICFPS_STRING              "ANTIALIASDYNAMICFPS"
#define D3D_REG_ANTIALIASDYNAMICFPS_MIN                 10
#define D3D_REG_ANTIALIASDYNAMICFPS_MAX                 500

// CAPTURE CONFIG
#define D3D_REG_CAPTURECONFIG_STRING                    "CAPTURECONFIG"
#define D3D_REG_CAPTURECONFIG_ALLOC4X                   0x01
#define D3D_REG_CAPTURECONFIG_FORCEPCI                  0x02

// CAPTUREENABLE
#define D3D_REG_CAPTUREENABLE_STRING                    "CAPTUREENABLE"
#define D3D_REG_CAPTUREENABLE_DISABLE                   0x00
#define D3D_REG_CAPTUREENABLE_RECORD                    0x01
#define D3D_REG_CAPTUREENABLE_PLAY                      0x02

// Colorkey Reference Values range.
#define D3D_REG_CKREF_STRING                            "CKREF"
#define D3D_REG_CKREF_MIN                               0x00
#define D3D_REG_CKREF_MAX                               0x7F

// Force Anisotropic definitions.
#define D3D_REG_ANISOTROPICLEVEL_STRING                 "ANISOTROPICLEVEL"
#define D3D_REG_ANISOTROPICLEVEL_PASSIVE                0xFFFFFFFF  // do what the app wants (else force to the value specified)

// MipMapDitherEnable definitions.
#define D3D_REG_MIPMAPDITHERMODE_STRING                 "ANISOTROPIC4TAP"
#define D3D_REG_MIPMAPDITHERMODE_DISABLE                0           // Disable mipmap dithering (true trilinear)
#define D3D_REG_MIPMAPDITHERMODE_ENABLE                 1           // Enable mipmap dithering (fake trilinear)
#define D3D_REG_MIPMAPDITHERMODE_SMART                  2           // smart dithering (enabled at higher resolutions)
#define D3D_REG_MIPMAPDITHERMODE_MAX                    2

#ifdef TEXFORMAT_CRD
// surface formats exported
#define D3D_REG_SURFACEFORMATSDX7_STRING                "SURFACEFORMATSDX7"
#define D3D_REG_SURFACEFORMATSDX8_STRING                "SURFACEFORMATSDX8"
#define D3D_REG_SURFACEFORMATS_BASIC                    0x00000001
#define D3D_REG_SURFACEFORMATS_BUMPMAP                  0x00000002
#define D3D_REG_SURFACEFORMATS_DXT                      0x00000004
#define D3D_REG_SURFACEFORMATS_PALETTIZED               0x00000008
#define D3D_REG_SURFACEFORMATS_NVXN                     0x00000010
#define D3D_REG_SURFACEFORMATS_HILO                     0x00000020
#define D3D_REG_SURFACEFORMATS_ZETA                     0x00000040
#define D3D_REG_SURFACEFORMATS_MISC                     0x00000080
#endif  // TEXFORMAT_CRD

// TexelAlignment definitions.
// Bit flags (bit 0 = ZOH, bit 1 = FOH, bit 2 = Texel Origin)
#define D3D_REG_TEXELALIGNMENT_STRING                   "TEXELALIGNMENT"
#define D3D_REG_TEXELALIGNMENT_ZOH_CENTER               0x00
#define D3D_REG_TEXELALIGNMENT_ZOH_CORNER               0x01
#define D3D_REG_TEXELALIGNMENT_ZOH_MASK                 0x01
#define D3D_REG_TEXELALIGNMENT_FOH_CENTER               0x00
#define D3D_REG_TEXELALIGNMENT_FOH_CORNER               0x02
#define D3D_REG_TEXELALIGNMENT_FOH_MASK                 0x02
#define D3D_REG_TEXELALIGNMENT_TEXEL_CENTER             0x00
#define D3D_REG_TEXELALIGNMENT_TEXEL_CORNER             0x04
#define D3D_REG_TEXELALIGNMENT_TEXEL_MASK               0x04
#define D3D_REG_TEXELALIGNMENT_MAX                      0x07

// TEXTUREMANAGESTRATEGY
#define D3D_REG_TEXTUREMANAGESTRATEGY_STRING            "TEXTUREMANAGESTRATEGY"
#define D3D_REG_TEXTUREMANAGESTRATEGY_AGGRESSIVE        0x1
#define D3D_REG_TEXTUREMANAGESTRATEGY_LAZY              0x0

// ValidateZMethod definitions.
#define D3D_REG_VALIDATEZMETHOD_STRING                  "VALIDATEZMETHOD"
#define D3D_REG_VALIDATEZMETHOD_FLEXIBLE                0           // Driver will match z-buffer to rendering depth.
#define D3D_REG_VALIDATEZMETHOD_SRTRETURNNOTHANDLED     1           // Same as FLEXIBLE but returns NOTHANDLED from Set Render Target.
#define D3D_REG_VALIDATEZMETHOD_STRICT                  2           // Z-Buffer must always match rendering depth.
#define D3D_REG_VALIDATEZMETHOD_MIXED                   3           // DX6 applications = STRICT, DX5 applications = flexible
#define D3D_REG_VALIDATEZMETHOD_MAX                     3

// V-Sync modes
#define D3D_REG_VSYNCMODE_STRING                        "VSYNCMODE"
#define D3D_REG_VSYNCMODE_PASSIVE                       0           // just do what the app tells us to do
#define D3D_REG_VSYNCMODE_FORCEOFF                      1           // override app and don't vsync
#define D3D_REG_VSYNCMODE_FORCEON                       2           // override app and vsync
#define D3D_REG_VSYNCMODE_MAX                           2

// WFormat definitions.
#define D3D_REG_WFORMAT16_STRING                        "W16FORMAT"
#define D3D_REG_WFORMAT32_STRING                        "W32FORMAT"
#define D3D_REG_WFORMAT_FIXED                           0x1
#define D3D_REG_WFORMAT_FLOAT                           0x2
#define D3D_REG_WFORMAT_MIN                             0x1
#define D3D_REG_WFORMAT_MAX                             0x2

// defaults for the non-boolean enumerated values
#define D3D_REG_DEFAULT_CAPTURCONFIG                    (D3D_REG_CAPTURECONFIG_ALLOC4X | D3D_REG_CAPTURECONFIG_FORCEPCI)
#define D3D_REG_DEFAULT_CAPTURENABLE                    D3D_REG_CAPTUREENABLE_RECORD
#define D3D_REG_DEFAULT_ANISOTROPICLEVEL                D3D_REG_ANISOTROPICLEVEL_PASSIVE
#define D3D_REG_DEFAULT_MIPMAPDITHERMODE                D3D_REG_MIPMAPDITHERMODE_SMART          // use true trilinear sometimes
#ifdef TEXFORMAT_CRD
#define D3D_REG_DEFAULT_SURFACEFORMATSDX7               (D3D_REG_SURFACEFORMATS_BASIC | D3D_REG_SURFACEFORMATS_BUMPMAP    |  \
                                                         D3D_REG_SURFACEFORMATS_DXT   | D3D_REG_SURFACEFORMATS_PALETTIZED |  \
                                                         D3D_REG_SURFACEFORMATS_ZETA  | D3D_REG_SURFACEFORMATS_MISC)
#define D3D_REG_DEFAULT_SURFACEFORMATSDX8               (D3D_REG_SURFACEFORMATS_BASIC | D3D_REG_SURFACEFORMATS_BUMPMAP    |  \
                                                         D3D_REG_SURFACEFORMATS_DXT   | D3D_REG_SURFACEFORMATS_PALETTIZED |  \
                                                         D3D_REG_SURFACEFORMATS_NVXN  | D3D_REG_SURFACEFORMATS_HILO       |  \
                                                         D3D_REG_SURFACEFORMATS_ZETA  | D3D_REG_SURFACEFORMATS_MISC)
#endif  // TEXFORMAT_CRD
#define D3D_REG_DEFAULT_TEXELALIGNMENT                  (D3D_REG_TEXELALIGNMENT_ZOH_CORNER | D3D_REG_TEXELALIGNMENT_FOH_CORNER | D3D_REG_TEXELALIGNMENT_TEXEL_CENTER)
#define D3D_REG_DEFAULT_TEXTUREMANAGESTRATEGY           D3D_REG_TEXTUREMANAGESTRATEGY_AGGRESSIVE
#define D3D_REG_DEFAULT_VALIDATEZMETHOD                 D3D_REG_VALIDATEZMETHOD_FLEXIBLE        // D3D_REG_VALIDATEZMETHOD_MIXED
#define D3D_REG_DEFAULT_VSYNCMODE                       D3D_REG_VSYNCMODE_PASSIVE
#define D3D_REG_DEFAULT_W16FORMAT                       D3D_REG_WFORMAT_FIXED
#define D3D_REG_DEFAULT_W32FORMAT                       D3D_REG_WFORMAT_FLOAT

// ------- Non-boolean settings with non-enumerated values ------------------

// NOT of address of pointer to command-line string
#define D3D_REG_AACOMPATIBILITYBITS_STRING              "AACOMPATIBILITYBITS"

// Reads nvCelsiusAACompatibility.h
#define D3D_REG_AAREADCOMPATIBILITYFILE_STRING          "AAREADCOMPATIBILITYFILE"

// AntiAliasQuality definitions.
#define D3D_REG_ANTIALIASQUALITY_STRING                 "ANTIALIASQUALITY"
#define D3D_REG_ANTIALIASQUALITY_MIN                    0
#define D3D_REG_ANTIALIASQUALITY_MAX                    7

// AntiAliasDynamicFPS definitions.
#define D3D_REG_ANTIALIASDYNAMICFPS_STRING              "ANTIALIASDYNAMICFPS"
#define D3D_REG_ANTIALIASDYNAMICFPS_MIN                 10
#define D3D_REG_ANTIALIASDYNAMICFPS_MAX                 500

// AGP texture cutoff
#define D3D_REG_AGPTEXCUTOFF_STRING                     "AGPTEXCUTOFF"

// starting number for played capture files
#define D3D_REG_CAPTUREPLAYFILENUM_STRING               "CAPTUREPLAYFILENUM"

// starting number for recorded capture files
#define D3D_REG_CAPTURERECORDFILENUM_STRING             "CAPTURERECORDFILENUM"

// Colorkey Reference Values range.
#define D3D_REG_CKREF_STRING                            "CKREF"
#define D3D_REG_CKREF_MIN                               0x00
#define D3D_REG_CKREF_MAX                               0x7F

// D3D contexts
#define D3D_REG_D3DCONTEXTMAX_STRING                    "D3DCONTEXTMAX"

// D3D contexts
#define D3D_REG_D3DTEXTUREMAX_STRING                    "D3DTEXTUREMAX"

// DPF debug level
#define D3D_REG_DEBUGLEVEL_STRING                       "DEBUGLEVEL"

// LOD bias adjust
#define D3D_REG_LODBIAS_STRING                          "LODBIASADJUST"

// minimum video texture size
#define D3D_REG_MINVIDTEXSIZE_STRING                    "MINVIDEOTEXSIZE"

// size of the pci texture heap. non-zero value will override value determined by the driver
#define D3D_REG_PCITEXHEAPSIZE_STRING                   "PCITEXHEAPSIZE"

// performance strategy
#define D3D_REG_PERFSTRATEGYOR_STRING                   "PSOR"
#define D3D_REG_PERFSTRATEGYAND_STRING                  "PSAND"

// Prerender limits
#define D3D_REG_PRERENDERLIMIT_STRING                   "PRERENDERLIMIT"
#define D3D_REG_PRERENDERLIMIT_MIN                      1
#define D3D_REG_PRERENDERLIMIT_MAX                      1000

// maximum push buffer size
#define D3D_REG_PUSHBUFFERSIZEMAX_STRING                "DMAPUSHBUFFERSIZEMAX"

// WScale 16/24 definitions.
#define D3D_REG_WSCALE16_STRING                         "WSCALE16"
#define D3D_REG_WSCALE24_STRING                         "WSCALE24"
#define D3D_REG_WSCALE16_MAX                            0x00010000
#define D3D_REG_WSCALE24_MAX                            0x01000000

// positively shift z to accomodate apps that give us slightly negtive z
#define D3D_REG_ZBIAS_STRING                            "ZBIAS"

// defaults for the non-boolean, non-enumerated values
#define D3D_REG_DEFAULT_AACOMPATIBILITYBITS             0
#define D3D_REG_DEFAULT_AAREADCOMPATIBILITYFILE         0
#define D3D_REG_DEFAULT_ANTIALIASQUALITY                1
#define D3D_REG_DEFAULT_ANTIALIASDYNAMICFPS             (1000 / 30)
#define D3D_REG_DEFAULT_AGPTEXCUTOFF                    1024
#define D3D_REG_DEFAULT_CAPTUREPLAYFILENUM              0
#define D3D_REG_DEFAULT_CAPTURERECORDFILENUM            0
#define D3D_REG_DEFAULT_CKREF                           D3D_REG_CKREF_MIN
#define D3D_REG_DEFAULT_D3DCONTEXTMAX                   64                  // D3D Context heap allocation max.
#define D3D_REG_DEFAULT_D3DTEXTUREMAX                   1024                // D3D Texture heap allocation max.
#define D3D_REG_DEFAULT_DEBUGLEVEL                      0                   // no debug output
#define D3D_REG_DEFAULT_LODBIASADJUST                   0
#define D3D_REG_DEFAULT_MINVIDEOTEXSIZE                 1                   // minimum texture size to be placed in video memory.
#define D3D_REG_DEFAULT_PCITEXHEAPSIZE                  0                   // size of PCI texture heap. (0 => driver-determined value)
#define D3D_REG_DEFAULT_PRERENDERLIMIT                  3
#define D3D_REG_DEFAULT_PUSHBUFFERSIZEMAX               0x40000             // maximum push buffer size.
#define D3D_REG_DEFAULT_WSCALE16                        D3D_REG_WSCALE16_MAX
#define D3D_REG_DEFAULT_WSCALE24                        D3D_REG_WSCALE24_MAX
#define D3D_REG_DEFAULT_ZBIAS                           0.f

// ------------------------------- Strings ----------------------------------

#define D3D_REG_STRING_LENGTH                           64                  // maximum allowed string length

// push-buffer capture playback file name
#define D3D_REG_CAPTUREPLAYFILENAME_STRING              "CAPTUREPLAYFILENAME"

// push-buffer capture playback path
#define D3D_REG_CAPTUREPLAYPATH_STRING                  "CAPTUREPLAYPATH"

// push-buffer capture recording path
#define D3D_REG_CAPTURERECORDFILENAME_STRING            "CAPTURERECORDFILENAME"

// push-buffer capture recording path
#define D3D_REG_CAPTURERECORDPATH_STRING                "CAPTURERECORDPATH"

// string defaults
#define D3D_REG_DEFAULT_CAPTUREPLAYFILENAME             "capture"
#define D3D_REG_DEFAULT_CAPTUREPLAYPATH                 "c:\\"
#define D3D_REG_DEFAULT_CAPTURERECORDFILENAME           "capture"
#define D3D_REG_DEFAULT_CAPTURERECORDPATH               "c:\\"


//-----------------------------------------------------------------------------
// OpenGL
//-----------------------------------------------------------------------------

#define NV4_REG_OGL_BUFFER_FLIPPING_CONTROL             "FlippingControl"
#define   NV4_REG_OGL_BUFFER_FLIPPING_CONTROL_BLIT      0
#define   NV4_REG_OGL_BUFFER_FLIPPING_CONTROL_FLIP      1
#define   NV4_REG_OGL_BUFFER_FLIPPING_CONTROL_AUTO      2
#define   NV4_REG_OGL_BUFFER_FLIPPING_CONTROL_DEFAULT   NV4_REG_OGL_BUFFER_FLIPPING_CONTROL_AUTO

#define NV_REG_OGL_BUFFER_REGION_EXT                    "BufferRegionExt"
#define   NV_REG_OGL_BUFFER_REGION_EXT_OFF              0
#define   NV_REG_OGL_BUFFER_REGION_EXT_ON               1
#define   NV_REG_OGL_BUFFER_REGION_EXT_DEFAULT          NV_REG_OGL_BUFFER_REGION_EXT_ON

#define NV_REG_OGL_BUFFER_REGION_USE_VIDMEM             "BufferRegionUseVidMem"
#define   NV_REG_OGL_BUFFER_REGION_USE_VIDMEM_OFF       0
#define   NV_REG_OGL_BUFFER_REGION_USE_VIDMEM_ON        1
#define   NV_REG_OGL_BUFFER_REGION_USE_VIDMEM_DEFAULT   NV_REG_OGL_BUFFER_REGION_USE_VIDMEM_ON

#define NV_REG_OGL_DEBUG_RENDERER                       "Renderer"
#define   NV_REG_OGL_DEBUG_RENDERER_NVIDIA              0
#define   NV_REG_OGL_DEBUG_RENDERER_SOFTWARE            1
#define   NV_REG_OGL_DEBUG_RENDERER_MICROSOFT           2
#define   NV_REG_OGL_DEFAULT_DEBUG_RENDERER             NV_REG_OGL_DEBUG_RENDERER_NVIDIA

#define NV_REG_OGL_DEBUG_PMENABLE                       "PMEnable"
#define   NV_REG_OGL_DEBUG_PMENABLE_ENABLED             1
#define   NV_REG_OGL_DEBUG_PMENABLE_DISABLED            0
#define   NV_REG_OGL_DEFAULT_DEBUG_PMENABLE             NV_REG_OGL_DEBUG_PMENABLE_DISABLED

#define NV_REG_OGL_DEFAULT_SWAP_INTERVAL                "DefaultSwapInterval"
#define   NV_REG_OGL_DEFAULT_SWAP_INTERVAL_TEAR         0
#define   NV_REG_OGL_DEFAULT_SWAP_INTERVAL_VSYNC        1
#define   NV_REG_OGL_DEFAULT_SWAP_INTERVAL_DISABLE      0xffffffff
#define   NV_REG_OGL_DEFAULT_SWAP_INTERVAL_DEFAULT      NV_REG_OGL_DEFAULT_SWAP_INTERVAL_VSYNC

#define NV_REG_OGL_MAX_NVACCEL                          "MaxNVACCEL"
#define NV_REG_OGL_DEFAULT_MAX_NVACCEL                  0

#define NV_REG_OGL_NV15_ALINES                          "NV15Alines"
#define   NV_REG_OGL_DEFAULT_NV15_ALINES                0
#define   NV_REG_OGL_NV15_ALINES_ACTUAL                 0
#define   NV_REG_OGL_NV15_ALINES_FORCE                  1
#define   NV_REG_OGL_NV15_ALINES_DISABLE                2

#define NV_REG_OGL_CLIPPED_ALINES                       "77345d17C"
#define   NV_REG_OGL_CLIPPED_ALINES_DEFAULT             0
#define   NV_REG_OGL_CLIPPED_ALINES_ENABLE              1

#define NV_REG_OGL_VERTEX_PROGRAM                       "VertexProgram"
#define   NV_REG_OGL_VERTEX_PROGRAM_OPTIMIZE            0
#define   NV_REG_OGL_VERTEX_PROGRAM_NO_LIVEDEAD         1

#define NV_REG_OGL_VPIPE                                "Vpipe"
#define   NV_REG_OGL_VPIPE_OPTIMIZE                     0
#define   NV_REG_OGL_VPIPE_DISABLE_BATCHED_IMMEDIATE    2
#define   NV_REG_OGL_VPIPE_DISABLE_BATCHED_DLISTS       4
#define   NV_REG_OGL_VPIPE_DISABLE_CDE                  8
#define   NV_REG_OGL_VPIPE_FORCE_GENERIC_CPU            0x0400
#define   NV_REG_OGL_VPIPE_REREAD_REGISTRY_ON_CLEAR     0x8000
#define   NV_REG_OGL_VPIPE_TOGGLE_BATCHING_ON_CLEAR     0x00040000

#define NV_REG_OGL_TRIPLE_BUFFER                        "EnableTripleBuffer"
#define   NV_REG_OGL_TRIPLE_BUFFER_DISABLE              0
#define   NV_REG_OGL_TRIPLE_BUFFER_ENABLE               1
#define   NV_REG_OGL_TRIPLE_BUFFER_DEFAULT              NV_REG_OGL_TRIPLE_BUFFER_DISABLE

#define NV_REG_OGL_WINDOW_FLIPPING                      "EnableWindowFlipping"
#define   NV_REG_OGL_WINDOW_FLIPPING_ENABLE             1
#define   NV_REG_OGL_WINDOW_FLIPPING_DISABLE            0
#define   NV_REG_OGL_WINDOW_FLIPPING_DEFAULT            NV_REG_OGL_WINDOW_FLIPPING_DISABLE
#define   NV_REG_OGL_WINDOW_FLIPPING_DEFAULT_GL         NV_REG_OGL_WINDOW_FLIPPING_ENABLE

#define NV_REG_OGL_OVERLAY_SUPPORT                      "EnableOverlaySupport"
#define NV_REG_OGL_OVERLAY_SUPPORT_OFF                  0
#define NV_REG_OGL_OVERLAY_SUPPORT_ON                   1
#define NV_REG_OGL_OVERLAY_SUPPORT_DEFAULT              NV_REG_OGL_OVERLAY_SUPPORT_OFF

#define NV_REG_OGL_OVERLAY_MERGEBLIT_TIMER_MS           "OverlayMergeBlitTimerMs"
#define NV_REG_OGL_OVERLAY_MERGEBLIT_TIMER_MS_DEFAULT   40 //ms
#define NV_REG_OGL_OVERLAY_MERGEBLIT_TIMER_MS_OFF       0  //0ms => off

#define NV_REG_OGL_STEREO_SUPPORT                       "EnableStereoSupport"
#define NV_REG_OGL_STEREO_SUPPORT_OFF                   0
#define NV_REG_OGL_STEREO_SUPPORT_ON                    1
#define NV_REG_OGL_STEREO_SUPPORT_DEFAULT               NV_REG_OGL_STEREO_SUPPORT_OFF

#define NV_REG_OGL_API_STEREO_MODE                              "APIStereoMode"
#define NV_REG_OGL_API_STEREO_MODE_SHUTTER_GLASSES              0 // stereo through shutter glasses
#define NV_REG_OGL_API_STEREO_MODE_VERTICAL_INTERLACED_RIGHT_0  1 // use vertical interlace monitor, right eye on first column
#define NV_REG_OGL_API_STEREO_MODE_VERTICAL_INTERLACED_LEFT_0   2 // use vertical interlace monitor, left eye on first column
#define NV_REG_OGL_API_STEREO_MODE_TVINVIEW_LEFT_DAC0           3 // use two dacs, dac 0 will show left eye
#define NV_REG_OGL_API_STEREO_MODE_TVINVIEW_RIGHT_DAC0          4 // use two dacs, dac 0 will show right eye
#define NV_REG_OGL_API_STEREO_MODE_DEFAULT                      NV_REG_OGL_API_STEREO_MODE_SHUTTER_GLASSES

// MSchwarzer 9/28/00 these keys are used to enable bundles of bugfixes for special applications
#define NV_REG_OGL_APPLICATION_KEY                      "ApplicationKey"
#define NV_REG_OGL_APPLICATION_KEY_NONE                 0
#define NV_REG_OGL_APPLICATION_KEY_STANDARD             1
#define NV_REG_OGL_APPLICATION_KEY_SOFTIMAGE3D          2
#define NV_REG_OGL_APPLICATION_KEY_3DSMAX               3
#define NV_REG_OGL_APPLICATION_KEY_3DPAINT              4
#define NV_REG_OGL_APPLICATION_KEY_MAYA                 5
#define NV_REG_OGL_APPLICATION_KEY_LIGHTSCAPE           6
#define NV_REG_OGL_APPLICATION_KEY_DEFAULT              NV_REG_OGL_APPLICATION_KEY_NONE

#define NV_REG_OGL_FORCE_16BIT_Z                        "EnableForce16BitZ"
#define NV_REG_OGL_FORCE_16BIT_Z_DISABLE                0
#define NV_REG_OGL_FORCE_16BIT_Z_ENABLE                 1
#define NV_REG_OGL_FORCE_16BIT_Z_DEFAULT                NV_REG_OGL_FORCE_16BIT_Z_DISABLE

#define NV_REG_OGL_SINGLE_BACKDEPTH_BUFFER              "EnableSingleBackDepthBuffer"
#define NV_REG_OGL_SINGLE_BACKDEPTH_DISABLE             0
#define NV_REG_OGL_SINGLE_BACKDEPTH_ENABLE              1
#define NV_REG_OGL_SINGLE_BACKDEPTH_BUFFER_DEFAULT      NV_REG_OGL_SINGLE_BACKDEPTH_DISABLE
#define NV_REG_OGL_SINGLE_BACKDEPTH_BUFFER_DEFAULT_GL   NV_REG_OGL_SINGLE_BACKDEPTH_ENABLE

#define NV_REG_OGL_DMAPUSH_BUFSIZE_WORDS                "CmdBufSizeWords"

#define NV_REG_OGL_DMAPUSH_MIN_PUSH_COUNT               "CmdBufMinWords"

#define NV_REG_OGL_DL_STAGING_BUFFER_SIZE_WORDS         "DLStagingBufferSizeWords"
#define NV_REG_OGL_DL_STAGING_BUFFER_SIZE_WORDS_DEFAULT ((9*1024*1024)/4)

#define NV_REG_OGL_TARGET_FLUSHCOUNT                    "TargetFlushCount"

#define NV_REG_OGL_FORCE_MULTITEX                       "ForceMultiTexture"
#define NV_REG_OGL_DISABLE_MULTITEX                     0
#define NV_REG_OGL_ENABLE_MULTITEX                      1
#define NV_REG_OGL_DEFAULT_MULTITEX                     NV_REG_OGL_ENABLE_MULTITEX

#define NV_REG_OGL_MAX_FRAMES_ALLOWED                   "MaxFramesAllowed"
#define NV_OGL_DEFAULT_MAX_FRAMES_ALLOWED               2
#define NV_MAX_FRAMES_ALLOWED                           10

#define NV_REG_OGL_MAX_TEX_SIZE                         "MaxTexSize"
#define NV_OGL_DEFAULT_MAX_TEX_SIZE                     2048

#define NV_REG_OGL_PCI_TEXHEAP_SIZE                     "MaxPCITexHeapSize"
#define NV_REG_OGL_PCI_TEXHEAP_SIZE_DEFAULT             (5*1024*1024)
#define NV_REG_OGL_PCI_TEXHEAP_SIZE_MAX_NT              (16*1024*1024)

#define NV_REG_MULTI_MONITOR_ADVANCED_ENABLE            "MultiMonAdvEnable"
#define NV_OGL_DEFAULT_MULTI_MONITOR_ADVANCED_ENABLE    0

#define NV_REG_OGL_DEFAULT_LOG_ANISO                    "DefaultLogAniso"
#define NV_REG_OGL_DEFAULT_LOG_ANISO_DEFAULT            0

#define NV_REG_OGL_RENDER_QUALITY_FLAGS                 "RenderQualityFlags"
#define NV_REG_OGL_RENDER_QUALITY_FLAGS_MMDITHER        0x00000001

// XXXmjc delete this flag ASAP!
#define NV_REG_OGL_RENDER_QUALITY_FLAGS_ANISOENABLE     0x00000002

/* Default texel size */
#define NV_REG_OGL_RENDER_QUALITY_FLAGS_TEXBITS_MASK     0x0000000c
#define NV_REG_OGL_RENDER_QUALITY_FLAGS_TEXBITS_AUTO     0x00000000
#define NV_REG_OGL_RENDER_QUALITY_FLAGS_TEXBITS_16       0x00000004
#define NV_REG_OGL_RENDER_QUALITY_FLAGS_TEXBITS_32       0x00000008
#define NV_REG_OGL_RENDER_QUALITY_FLAGS_TEXBITS_RESERVED 0x0000000c

#define NV_REG_OGL_TEX_DIRECT_LOAD                      "TextureDirectLoad"
#define NV_REG_OGL_TEX_DIRECT_LOAD_DISABLE              0
#define NV_REG_OGL_TEX_DIRECT_LOAD_ALLOW                1
#define NV_REG_OGL_TEX_DIRECT_LOAD_FORCE                2
#define NV_REG_OGL_TEX_DIRECT_LOAD_AUTO                 3
#define NV_REG_OGL_TEX_DIRECT_LOAD_DEFAULT              NV_REG_OGL_TEX_DIRECT_LOAD_DISABLE

/* One Minus Depth Buffering */
#define NV_REG_OGL_RENDER_QUALITY_FLAGS_ONE_MINUS_Z     0x00000010

#define NV_REG_OGL_RENDER_QUALITY_FLAGS_DEFAULT         (0)

#define NV_REG_OGL_TEX_MEMORY_SPACE_ENABLES             "TexMemorySpaceEnables"
#define NV_REG_OGL_TEX_MEMORY_SPACE_ENABLES_NONE        0
#define NV_REG_OGL_TEX_MEMORY_SPACE_ENABLES_SYS         1
#define NV_REG_OGL_TEX_MEMORY_SPACE_ENABLES_VID         2
#define NV_REG_OGL_TEX_MEMORY_SPACE_ENABLES_VIDSYS      3
#define NV_REG_OGL_TEX_MEMORY_SPACE_ENABLES_DEFAULT     3

#define NV4_REG_OGL_PALETTED_TEX_IN_VID_MEM             "PalettedTexInVidMem"
#define NV4_REG_OGL_DEFAULT_PALETTED_TEX_IN_VID_MEM     1

#define NV4_REG_OGL_TEX_PRECACHE                        "TexturePrecache"

#define NV4_REG_OGL_TEX_STAGING_BUFFER_SIZE             "TexStagingBufferSize"
#define NV4_REG_OGL_TEX_STAGING_BUFFER_SIZE_DEFAULT     (512*1024)

#define NV4_REG_OGL_TEX_STAGING_BUFFER_MULT_SIZE        "TexStagingBufferMultSize"
#define NV4_REG_OGL_STAGING_BUFFER_MULT_SIZE_DEFAULT    (256*1024)

// XXXmjc delete this key ASAP!
#define NV_REG_OGL_FULLSCENE_ANTIALIASING               "EnableFSAA"
#define NV_REG_OGL_FULLSCENE_ANTIALIASING_ENABLED       1
#define NV_REG_OGL_FULLSCENE_ANTIALIASING_DISABLED      0
#define NV_REG_OGL_FULLSCENE_ANTIALIASING_DEFAULT       NV_REG_OGL_FULLSCENE_ANTIALIASING_DISABLED

// XXXmjc delete this key ASAP!
#define NV_REG_OGL_FSAA_QUALITY                         "FSAAQuality"
#define NV_REG_OGL_FSAA_QUALITY_15x15                   0 // 1.5x1.5
#define NV_REG_OGL_FSAA_QUALITY_2x2_LODBIAS             1
#define NV_REG_OGL_FSAA_QUALITY_2x2                     2
#define NV_REG_OGL_FSAA_QUALITY_DEFAULT                 NV_REG_OGL_FSAA_QUALITY_15x15
#define NV_REG_OGL_FSAA_QUALITY_MAXIMUM                 2 // clamp to [0,this]

/*
** The way this key works has changed dramatically between rel6 and rel7.
** There used to be one key that controlled whether FSAA was on at all,
** and another to determine the quality.  Now, there's just one key.
** NV10 has 4 levels of FSAA (none, 1.5x1.5, 2x2 LOD-bias, 2x2).  NV20
** has 3 levels of FSAA (none, 2x, 4x).  The way each setting is interpreted
** on each chip is as follows:
**
** Setting                            NV10 Meaning            NV20 Meaning
** NV_REG_OGL_FSAA_MODE_NONE          No AA                   No AA
** NV_REG_OGL_FSAA_MODE_2x            Invalid                 2x AA bilinear
** NV_REG_OGL_FSAA_MODE_2x_5t         Invalid                 2x AA quincunx
** NV_REG_OGL_FSAA_MODE_15x15         1.5x1.5 AA              Invalid
** NV_REG_OGL_FSAA_MODE_4x            2x2 AA                  4x AA bilinear
** NV_REG_OGL_FSAA_MODE_4x_9t         Invalid                 4x AA gaussian
**
** If a setting is invalid, the driver will treat it the same as no AA.
** The panel should not allow the user to set this key to an invalid value
** on the current chip, and the UI needs to be chip-dependent.
*/
#define NV_REG_OGL_FSAA_MODE                            "FSAAMode"
#define NV_REG_OGL_FSAA_MODE_NONE                       0
#define NV_REG_OGL_FSAA_MODE_2x                         1
#define NV_REG_OGL_FSAA_MODE_2x_5t                      2
#define NV_REG_OGL_FSAA_MODE_15x15                      3
#define NV_REG_OGL_FSAA_MODE_4x                         4
#define NV_REG_OGL_FSAA_MODE_4x_9t                      5
#define NV_REG_OGL_FSAA_MODE_DEFAULT                    NV_REG_OGL_FSAA_MODE_NONE
#define NV_REG_OGL_FSAA_MODE_MAXIMUM                    5 // clamp to [0,this]

#define NV_REG_OGL_S3TC_QUALITY                         "S3TCQuality"
#define NV_REG_OGL_S3TC_QUALITY_FORCE_DXT3              1
#define NV_REG_OGL_S3TC_QUALITY_DEFAULT                 0

#define NV_REG_OGL_FORCE_GENERIC_CPU                    "ForceGenericCPU"
#define NV_REG_OGL_FORCE_GENERIC_CPU_ON                 1
#define NV_REG_OGL_FORCE_GENERIC_CPU_OFF                0
#define NV_REG_OGL_FORCE_GENERIC_CPU_DEFAULT            NV_REG_OGL_FORCE_GENERIC_CPU_OFF

#define NV_REG_OGL_APP_SOFTIMAGE                        "App_SoftImage"
#define NV_REG_OGL_APP_SOFTIMAGE_DEFAULT                0
#define NV_REG_OGL_APP_SOFTIMAGE_38                     38
#define NV_REG_OGL_APP_SOFTIMAGE_39                     39

#define NV_REG_OGL_APP_SUPPORTBITS                      "App_SupportBits"
#define NV_REG_OGL_APP_SUPPORTBITS_DEFAULT              0
#define NV_REG_OGL_APP_SUPPORTBITS_SYNCGDI              0x00000001
#define NV_REG_OGL_APP_SUPPORTBITS_PROE_2000I2          0x00000002

#define NV_REG_OGL_NV20_EMULATE                         "NV20Emulate"
#define NV_REG_OGL_NV20_EMULATE_ON                      1
#define NV_REG_OGL_NV20_EMULATE_OFF                     0
#define NV_REG_OGL_NV20_EMULATE_DEFAULT                 NV_REG_OGL_FORCE_GENERIC_CPU_OFF

#define NV_REG_OGL_SERVER_SWAP_NT4                      "ServerSwapNT4"
#define NV_REG_OGL_SERVER_SWAP_NT4_DEFAULT              0

#define NV_REG_OGL_PERF_STRAT_IMM_MODE                  "094313"
#define NV_REG_OGL_PERF_STRAT_IMM_MODE_FORCE_DIRECT     0x09431392
#define NV_REG_OGL_PERF_STRAT_IMM_MODE_FORCE_BATCH      0x29313490
#define NV_REG_OGL_PERF_STRAT_IMM_MODE_FORCE_CACHE      0x13920943
#define NV_REG_OGL_PERF_STRAT_IMM_MODE_DEFAULT          0

/* OGL Capture file */
#define NV_REG_OGL_CAPTURE_ENABLE                       "CaptureEnable"
#define NV_REG_OGL_CAPTURE_ENABLE_DISABLE               0x00
#define NV_REG_OGL_CAPTURE_ENABLE_RECORD                0x01
#define NV_REG_OGL_CAPTURE_ENABLE_PLAY                  0x02
#define NV_REG_OGL_CAPTURE_ENABLE_DEFAULT               NV_REG_OGL_CAPTURE_ENABLE_RECORD

#define NV_REG_OGL_CAPTURE_RECORD_PATH                  "CaptureRecordPath"
#define NV_REG_OGL_CAPTURE_RECORD_PATH_DEFAULT          "c:\\"
#define NV_REG_OGL_CAPTURE_RECORD_FILENAME              "CaptureRecordFilename"
#define NV_REG_OGL_CAPTURE_RECORD_FILENAME_DEFAULT      "capture"

#define NV_REG_OGL_CAPTURE_PLAY_PATH                    "CapturePlayPath"
#define NV_REG_OGL_CAPTURE_PLAY_PATH_DEFAULT            "c:\\"
#define NV_REG_OGL_CAPTURE_PLAY_FILENAME                "CapturePlayFilename"
#define NV_REG_OGL_CAPTURE_PLAY_FILENAME_DEFAULT        "capture"

#define NV_REG_OGL_CAPTURE_WHEN_FLIP                    1
#define NV_REG_OGL_CAPTURE_WHEN_READPIXELS              2

#define NV_REG_OGL_CAPTURE_RECORD_WHEN                  "CaptureRecordWhen"
#define NV_REG_OGL_CAPTURE_RECORD_WHEN_DEFAULT          NV_REG_OGL_CAPTURE_WHEN_FLIP

#define NV_REG_OGL_CAPTURE_PLAY_WHEN                    "CapturePlayWhen"
#define NV_REG_OGL_CAPTURE_PLAY_WHEN_DEFAULT            NV_REG_OGL_CAPTURE_WHEN_FLIP

#define NV_REG_OGL_CAPTURE_PLAY_WHERE                   "CapturePlayWhere"
#define NV_REG_OGL_CAPTURE_PLAY_WHERE_FRONT             0
#define NV_REG_OGL_CAPTURE_PLAY_WHERE_BACK              1
#define NV_REG_OGL_CAPTURE_PLAY_WHERE_DEFAULT           NV_REG_OGL_CAPTURE_PLAY_WHERE_FRONT

// NV_REG_OGL_TEXCLAMP defines texture clamping behavior when GL_CLAMP is set.
//   EDGE means always use CLAMP_TO_EDGE.
//   USE_HW means use CLAMP if the HW supports it, otherwise CLAMP_TO_EDGE.
//   SPEC means follow the spec, even if it means software rasterization.
#define NV_REG_OGL_TEXCLAMP                             "TextureClampBehavior"
#define NV_REG_OGL_TEXCLAMP_EDGE                        0
#define NV_REG_OGL_TEXCLAMP_USE_HW                      1
#define NV_REG_OGL_TEXCLAMP_SPEC                        2
#define NV_REG_OGL_TEXCLAMP_NVALUES                     3
#define NV_REG_OGL_TEXCLAMP_DEFAULT                     NV_REG_OGL_TEXCLAMP_EDGE


//-----------------------------------------------------------------------------
// ResMan
//-----------------------------------------------------------------------------

#define NV_REG_SYS_SUPER7_COMPATIBILITY                 "Super7Compat"
#define NV_REG_OGL_DEFAULT_ALLOW_AGP_PUSH_BUF_FOR_MAC   0
#define NV_REG_OGL_DEFAULT_ALLOW_AGP_PUSH_BUF           1
#define NV_REG_OGL_DEFAULT_ALLOW_VID_PUSH_BUF           0
#define NV_REG_OGL_DISABLE_AGP_PUSH_BUF                 0
#define NV_REG_OGL_ENABLE_AGP_PUSH_BUF                  1

#define PERSISTENT_AGP_SIZE                             "PersistAGPSize"
#define NV_MAX_AGP_SIZE                                 "MaxAGPSize"
#define NV5_REG_SYS_HSYNC_FLIP                          "FlipOnHSync"
#define MAXREFRESHRATE                                  "MaxRefreshRate"
#define MAXOPTIMALREFRESHRATE                           "MaxOptimalRefreshRate"
#define OPTIMALREFRESHNOTFROMEDID                       "OptimalRefreshNotFromEDID"
#define DMTOVERRIDE                                     "DMTOVERRIDE"
#define MONITORTIMING                                   "MonitorTiming"
#define CURSORCACHE                                     "CursorCache"
#define DISPLAY_TYPE                                    "Display Type"
#define DISPLAY2_TYPE                                   "Display2 Type"
#define TV_TYPE                                         "TV Type"
#define POWERUPFLAGS                                    "PowerUpFlags"
#define TV_OUT                                          "TV Out"
#define NEWSTYLEMODESET                                 "NewStyleModeSet"
#define FLATPANELMODE                                   "FlatPanelMode"
#define RESOURCE_MANAGER_SUBKEY_ADDITION                "NVIDIA"


// Forces the push buffer to reside in a particular location.  Used by ddraw
// and OGL.  This is a local key.  Setting this will override the Super7Compat key
#define NV_REG_SYS_PB_LOCATION                          "PushBufferLocale"
#define   NV_REG_SYS_PB_LOCATION_DEFAULT                0
#define   NV_REG_SYS_PB_LOCATION_SYSTEM                 1
#define   NV_REG_SYS_PB_LOCATION_AGP                    2
#define   NV_REG_SYS_PB_LOCATION_VIDEO                  3

//-----------------------------------------------------------------------------
// Control Panel
//-----------------------------------------------------------------------------

#define NV_REG_CPL_D3D_SETTINGS_SUBKEY                   NV4_REG_DIRECT3D_SUBKEY
#define NV_REG_CPL_OGL_SETTINGS_SUBKEY                   NV4_REG_OGL_SUBKEY

#define NV_REG_CPL_COLOR_SUBKEY                          "Color"
#define NV_REG_CPL_COLOR_VALUE_CURRENT                   "Current"

#define NV_REG_CPL_COLOR_SCHEMES_SUBKEY                  "Schemes"

#define NV_REG_CPL_TV_OUT_SUBKEY                         "TVOut"

#define NV_REG_CPL_OEM_DEFAULTS_SUBKEY                   "Defaults"

#define NV_REG_CPL_DISPLAY_MODES_SUBKEY                  "DisplayModes"
#define NV_REG_CPL_DISPLAY_MODES_VALUE_MONITOR           "Analog Monitor"
#define NV_REG_CPL_DISPLAY_MODES_VALUE_DFP               "Digital Flat Panel"
#define NV_REG_CPL_DISPLAY_MODES_VALUE_TV                "TV"

#define NV_REG_CPL_OVL_SETTINGS_SUBKEY                   "Overlay"

// path to "skins" DLL provided by OEMs or IHVs
#define NV_REG_CPL_OEM_GRAPHICS_LIB                      "NvCplGfxLib"

#define NV_REG_CPL_VALUE_UNLOCK_GOODIES                  "CoolBits"
#define NV_REG_CPL_DATA_UNLOCK_GOODIES_VSYNC             0x00000001
#define NV_REG_CPL_DATA_UNLOCK_GOODIES_HWCLOCK           0x00000002

#define NV_REG_HARDWARE_SUBKEY                           "Hardware"
#define NV_REG_HARDWARE_CLOCK_ENABLE                     "Marge"    // overclocking enable
#define NV_REG_HARDWARE_CLOCK_CONTROL_USER               "Krusty"   // user defined clock speeds
#define NV_REG_HARDWARE_CLOCK_CONTROL_DEFAULT            "Bart"     // BIOS default clock speeds
#define NV_REG_HARDWARE_CLOCK_ENCRYPT_FLAGS              "Homer"    // encryption flags
#define NV_REG_HARDWARE_CLOCK_NO_WARN_DLG                "Lisa"     // turn off warning dialog
#define NV_REG_HARDWARE_CLOCK_DETECT_VALUE               "NvHardwareControl"
#define NV_REG_HARDWARE_CLOCK_DETECT_CMD_LINE            "RUNDLL32.EXE NVQTWK.DLL,NvHWCtl"
#define NV_REG_HARDWARE_CLOCK_INIT_VALUE                 "NvInitialize"
#define NV_REG_HARDWARE_CLOCK_INIT_CMD_LINE              "RUNDLL32.EXE NVQTWK.DLL,NvXTInit"

#define NV_REG_DESK_MANAGER_VALUE_NAME                   "DesktopManager"   //XXX deprecated!
#define NV_REG_DESK_MANAGER_HOTKEY_SUBKEY                "HotKeys"  //XXX deprecated!
#define NV_REG_DESK_MANAGER_APPASSOC_SUBKEY              "Apps"
#define NV_REG_DESK_MANAGER_APPASSOC_DESKTOP             "Desktop"
#define NV_REG_DESK_MANAGER_APPASSOC_MONITOR             "StartingMonitor"
#define NV_REG_DESK_MANAGER_APPASSOC_FLAGS               "Flags"
#define NV_REG_DESK_MANAGER_APPASSOC_PLACEMENT           "Placement"
#define NV_REG_DESK_MANAGER_APPASSOC_CLASS               "Class"
#define NV_REG_DESK_MANAGER_GLOBALS_SUBKEY               "Globals"
#define NV_REG_DESK_MANAGER_GLOBALS_FLAGS                "Flags"
#define NV_REG_DESK_MANAGER_GLOBALS_TLSCREEN             "TLScreen"
#define NV_REG_DESK_MANAGER_GLOBALS_HKMOVE               "HKMove"
#define NV_REG_DESK_MANAGER_GLOBALS_HKMOVEALL            "HKMoveAll"
#define NV_REG_DESK_MANAGER_GLOBALS_HKSWITCH             "HKSwitch"
#define NV_REG_DESK_MANAGER_GLOBALS_HKGATHER             "HKGather"
#define NV_REG_DESK_MANAGER_GLOBALS_HKZOOM               "HKZoom"
#define NV_REG_DESK_MANAGER_GLOBALS_HKZOOMIN             "HKZoomIn"
#define NV_REG_DESK_MANAGER_GLOBALS_HKZOOMOUT            "HKZoomOut"
#define NV_REG_DESK_MANAGER_GLOBALS_ALTTABMON            "CoolSwitchMon"
#define NV_REG_DESK_MANAGER_GLOBALS_ZOOMLEVEL            "DefaultZoomLevel"
#define NV_REG_DESK_MANAGER_GLOBALS_ZOOMREFRESH          "ZoomRefreshRate"
#define NV_REG_DESK_MANAGER_GLOBALS_ZOOMWKEYS            "ZoomWheelKeys"
#define NV_REG_DESK_MANAGER_GLOBALS_ZOOMDELAY            "ZoomSwitchDelay"
#define NV_REG_DESK_MANAGER_CPLPOS                       "PanelPos"

/////////////////////////////////////
// bit flags for the QuickTweak properties settings

#define NV_REG_CPL_GLOBAL_VALUE_QUICKTWEAK_FLAGS         "QuickTweak"

#define NV_REG_CPL_GLOBAL_DATA_QUICKTWEAK_DEFAULT        0x00010020

#define NV_REG_FLAGS_NOCONFIRM                           0x00000001
#define NV_REG_FLAGS_LBUTTON                             0x00000010
#define NV_REG_FLAGS_RBUTTON                             0x00000020
#define NV_REG_FLAGS_BOTHBUTTONS                         0x00000030
#define NV_REG_FLAGS_COOLMENUS                           0x00000100
#define NV_REG_FLAGS_QUICKTWEAK_ALWAYS                   0x00000200
#define NV_REG_FLAGS_QUICKTWEAK_HIDDEN                   0x00000400
#define NV_REG_FLAGS_SUPPORT_INDUCE                      0x00000800
#define NV_REG_FLAGS_RESTORE_VIRTUAL                     0x00001000
#define NV_REG_FLAGS_TASKBAR_LOGO                        0x00010000
#define NV_REG_FLAGS_TASKBAR_BLUE                        0x00020000
#define NV_REG_FLAGS_TASKBAR_RED                         0x00040000

#define NV_REG_FLAGS_DEFAULT                             (NV_REG_FLAGS_RBUTTON | NV_REG_FLAGS_TASKBAR_LOGO)

/////////////////////////////////////
// Flag to turn on the control panel agp/hardware page
#define NV_REG_CPL_ENABLE_HARDWARE_PAGE "NvCplEnableHardwarePage"
#define NV_REG_CPL_ENABLE_HARDWARE_PAGE_ENABLE  1
#define NV_REG_CPL_ENABLE_HARDWARE_PAGE_DISABLE 0
#define NV_REG_CPL_ENABLE_HARDWARE_PAGE_DEFAULT NV_REG_CPL_ENABLE_HARDWARE_PAGE_DISABLE

/////////////////////////////////////
// bit flags for hiding particular property pages or dialogs
#define NV_REG_CPL_HIDE_PROPPAGES          "NoPages"

#define NVCPL_HIDE_COLOR_PAGE              0x00000001
#define NVCPL_HIDE_D3D_PAGE                0x00000002
#define NVCPL_HIDE_OGL_PAGE                0x00000004
#define NVCPL_HIDE_OVERLAY_PAGE            0x00000008
#define NVCPL_HIDE_OPTIONS_PAGE            0x00000010
#define NVCPL_HIDE_TASKBAR_PAGE            NVCPL_HIDE_OPTIONS_PAGE
#define NVCPL_HIDE_OUTPUT_DEVICE_PAGE      0x00000020
#define NVCPL_HIDE_CRT_POSITIONING_DLG     0x00000040
#define NVCPL_HIDE_DFP_POSITIONING_DLG     0x00000080
#define NVCPL_HIDE_TV_POSITIONING_DLG      0x00000100
#define NVCPL_HIDE_INTERNET_OPTIONS        0x00000200
#define NVCPL_HIDE_CRT_TIMING_DLG          0x00000400
#define NVCPL_HIDE_ALL_CRT_SETTINGS        (NVCPL_HIDE_CRT_POSITIONING_DLG | NVCPL_HIDE_CRT_TIMING_DLG)
#define NVCPL_HIDE_AA_PAGE                 0x00000800
#define NVCPL_HIDE_MONITOR_SCALING_OPTION  0x00002000
#define NVCPL_HIDE_BIOS_FLASH_CAPS         0x00004000
#define NVCPL_HIDE_EXTENDED_OVERLAY_DIALOG 0x00008000
#define NVCPL_HIDE_HARDWARE_DIALOG         0x00010000
#define NVCPL_HIDE_POWERMIZER_DIALOG       0x00020000
#define NVCPL_HIDE_WATERMARK               0x00040000

#ifdef  STEREO_SUPPORT
//-----------------------------------------------------------------------------
// Registry settings for stereo support. For now are sitting in the Global section.
//-----------------------------------------------------------------------------
#define NV_REG_STEREO_ENABLED                            "StereoEnable"                //Stereo can be potentially activated.
#define NV_REG_STEREO_STEREOVIEWER                       "StereoViewer"                //Defines the name of the stereo viewer driver.
#define NV_REG_STEREO_STEREOVIEWERTYPE                   "StereoViewerType"            //Defines the stereo viewer type.
#define NV_REG_STEREO_ADJUSTENABLED                      "StereoAdjustEnable"          //Allow stereo adjustments by hot keys.
#define NV_REG_STEREO_DISABLE_TnL                        "StereoDisableTnL"            //Disables hardware T&L. Allowes to reach more stereo effect.
#define NV_REG_STEREO_SEPARATION                         "StereoSeparation"            //Pre-transformed separation (ProjectMatrix.31).
#define NV_REG_STEREO_CONVERGENCE                        "StereoConvergence"           //Pre-transformed convergence (ProjectMatrix.41).
#define NV_REG_STEREO_CONVERGENCEMULTIPLIER              "StereoConvergenceMultiplier" //Defines correlation between pre and post-transformed convergence.
#define NV_REG_STEREO_RHW2DDETECTIONMIN                  "RHW2DDetectionMin"           //RHW far limit for 2D object detection.
#define NV_REG_STEREO_RHWGREATERATSCREEN                 "RHWGreaterAtScreen"          //Objects closer than this boundary are 2D.
#define NV_REG_STEREO_RHWEQUALATSCREEN                   "RHWEqualAtScreen"            //All objects parallel to screen are 2D.
#define NV_REG_STEREO_RHWLESSATSCREEN                    "RHWLessAtScreen"             //All objects parallel to screen are 2D.
#define NV_REG_STEREO_AUTOCONVERGENCE                    "AutoConvergence"             //Automatically focus on the closest object.
#define NV_REG_STEREO_CONVERGENCEADJUSTPACE              "AutoConvergenceAdjustPace"   //Per frame Convergence adjust pace in AutoConvergence mode.
#define NV_REG_STEREO_HOTKEY_TOGGLE                      "StereoToggle"                //The hot key to toggle stereo.
#define NV_REG_STEREO_HOTKEY_VERTICALADJUST_MORE         "StereoVerticalAdjustMore"    //The hot key to increase the vertical separation.
#define NV_REG_STEREO_HOTKEY_VERTICALADJUST_LESS         "StereoVerticalAdjustLess"    //The hot key to reduce the vertical separation.
#define NV_REG_STEREO_HOTKEY_HORIZONTALADJUST_MORE       "StereoHorizontalAdjustMore"  //The hot key to increase the horizontal separation.
#define NV_REG_STEREO_HOTKEY_HORIZONTALADJUST_LESS       "StereoHorizontalAdjustLess"  //The hot key to reduce the horizontal separation.
#define NV_REG_STEREO_HOTKEY_SEPARATIONADJUST_MORE       "StereoSeparationAdjustMore"  //The hot key to increase the stereo separation.
#define NV_REG_STEREO_HOTKEY_SEPARATIONADJUST_LESS       "StereoSeparationAdjustLess"  //The hot key to increase the stereo separation.
#define NV_REG_STEREO_HOTKEY_CONVERGENCEADJUST_MORE      "StereoConvergenceAdjustMore" //The hot key to increase the convergence degree.
#define NV_REG_STEREO_HOTKEY_CONVERGENCEADJUST_LESS      "StereoConvergenceAdjustLess" //The hot key to reduce the convergence degree.
#define NV_REG_STEREO_HOTKEY_SUGGESTSETTINGS             "StereoSuggestSettings"       //The hot key to automatically set suggested stereo settings.
#define NV_REG_STEREO_HOTKEY_UNSUGGESTSETTINGS           "StereoUnsuggestSettings"     //The hot key to restore stereo settings before suggestion.
#define NV_REG_STEREO_HOTKEY_LASER_X_PLUS                "LaserAdjustXPlus"            //The hot key to increase the laser sight X position
#define NV_REG_STEREO_HOTKEY_LASER_X_MINUS               "LaserAdjustXMinus"           //The hot key to decrease the laser sight X position
#define NV_REG_STEREO_HOTKEY_LASER_Y_PLUS                "LaserAdjustYPlus"            //The hot key to increase the laser sight Y position
#define NV_REG_STEREO_HOTKEY_LASER_Y_MINUS               "LaserAdjustYMinus"           //The hot key to decrease the laser sight Y position
#define NV_REG_STEREO_FAVORSZ                            "FavorSZ"                     //Rather use SZ in stereo calculations than RHW
#define NV_REG_STEREO_LASERSIGHT                         "LaserSight"                  //Use Nvidia proprietary laser sight.
#define NV_REG_STEREO_LASERSIGHTFILE                     "LaserSightFile"              //Defines the BMP file used as a laser sight.
#define NV_REG_STEREO_LASERSIGHTENABLED                  "LaserSightEnabled"           //Masks on/off use of a laser sight.
#define NV_REG_STEREO_LASERSIGHTPROPERTY                 "LaserSightProperty"          //Laser sight min/max size and transparency.
#define NV_REG_STEREO_DEFAULTON                          "StereoDefaultOn"             //Turn stereo on when the game starts
#define NV_REG_STEREO_FRUSTUMADJUSTMODE                  "FrustumAdjustMode"           //0 - do nothing, 1 - stretch in X, 2 - clear corresponding edges for each eye.
#define NV_REG_STEREO_MONITORSIZE                        "MonitorSize"                 //The monitor diagonal for max. stereo separation calculation.
#define NV_REG_STEREO_NOORTHOSTEREO                      "NoOrthoStereo"               //Assumes that Ortho porjection is used for 2D objects (OpenGL).
#define NV_REG_STEREO_MAXVERTEXCOUNT                     "MaxVertexCount"              //Max. amount of vertices we allow in VB (for D3D SW TnL games only).
#define NV_REG_STEREO_PARTIALCLEARMODE                   "PartialClearMode"            //0 - do as requested, 1 - do full clear instad, 2 - ignore
#define NV_REG_STEREO_LASERXADJUST                       "LaserXAdjust"
#define NV_REG_STEREO_LASERYADJUST                       "LaserYAdjust"
#define NV_REG_STEREO_POPUP_ENABLED                      "PopupAgents"                  //Use Nvidia proprietary popup agents
#define NV_REG_STEREO_POPUP_SUBKEY                       "PopupAgentOptions"            //subkey under which options lies
#define NV_REG_STEREO_POPUP_STAT                         "PopupStat"                    //on/off Stereo statistics
#define NV_REG_STEREO_POPUP_FPS                          "PopupFPS"                     //on/off frame rate info popup
#define NV_REG_STEREO_POPUP_HOTKEY                       "PopupHotkey"                  //what hotkey will toggle all popups
#define NV_REG_STEREO_POPUP_FPS_HOTKEY                   "FPSHotkey"                    //what hotkey will toggle FPS popup
#define NV_REG_STEREO_POPUP_STATS_HOTKEY                 "StatHotkey"                   //what hotkey will toggle StereoStat popup
#endif  //STEREO_SUPPORT

//----------------End of file NVREG.H----(do not edit below this line or remove this line) -----
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\common\inc\nvPusher.h ===
// **************************************************************************
//
//       Copyright 1993-2000 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// **************************************************************************
//
//  Module: nvPusher.h
//      routines for creating, destroying, and interacting with a push buffer
//
// **************************************************************************
//
//  History:
//      Ben DeWaal              07Apr1999         original code
//      Craig Duttweiler        05Apr2000         cleanup, consolidation,
//                                                and C++'ification
//
// **************************************************************************

#ifndef _NVPUSHER_H
#define _NVPUSHER_H

#include "CompileControl.h"
#include "nvUniversal.h"
#include "nv32.h"
#include "nvDbg.h"

#if IS_WINNT4
typedef PDD_DIRECTDRAW_GLOBAL           LPDDRAWI_DIRECTDRAW_GBL;
#endif

typedef struct _PDEV PDEV;

#if (NVARCH < 0x04)

typedef void *CPushBuffer;   // Not avail on NV3, but let's compile go through easier

#else // (NVARCH >= 0x04)

//---------------------------------------------------------------------------

// pusher debugging switches (available in retail builds too)

//#define _PC_PRINTPUT                      // print kick-offs (slow)
//#define _PC_PRINT                         // print important pusher transactions
//#define _PC_CHECK                         // check for push buffer problems
//#define _PC_BREAK                         // break at specific class (define CHECK also)
//#define _PC_FLUSH_ON_ADJUST               // force flush on every call to nvPusherAdjust
//#define _PC_CAPTURE_METHOD_DATA           // captures method data and allows you to view it (good to check object state)
//#define _PC_CAPTURE                       // writes contents of the the push buffer to a file

// debug switch logic

// for now we enable push buffer validation for all debug builds
#if defined(DEBUG) || defined(_PC_CAPTURE_METHOD_DATA) || defined(_PC_CAPTURE)
#define _PC_CHECK
#endif

// don't allow inline functions if we have certain other debug bits enabled
#undef _NO_INLINE
#if defined(DEBUG) || defined(_PC_PRINTPUT) || defined(_PC_PRINT) || defined(_PC_CHECK) || defined(_PC_BREAK)
#define _NO_INLINE
#endif
#if defined(_PC_FLUSH_ON_ADJUST) || defined(_PC_CAPTURE_METHOD_DATA) || defined(_PC_CAPTURE)
#define _NO_INLINE
#endif

//---------------------------------------------------------------------------

// pusher constants and macros

#define NVPUSHER_MAX_METHOD_COUNT   (2048 - 1)  // maximum method count = 2 ^ 11 - 1
#define NVPUSHER_THRESHOLD_SIZE     128         // words of data always available (4 triangles)
#define NVPUSHER_MINIMUM            1024        // bytes of data for option kick-off

#define NVPUSHER_JUMP(offset)       (0x20000000 | (offset))
#define NVPUSHER_NOINC(method)      (0x40000000 | (method))
#define NVPUSHER_CALL(offset)       (0x00000002 | (offset))
#define NVPUSHER_RETURN()           (0x00020000)

//---------------------------------------------------------------------------

#ifdef _PC_CAPTURE

extern HANDLE hPusherFileBinary;
extern HANDLE hPusherFileAscii;
extern BOOL   bPusherCapture;

#define NV_PC_CAPTURE_BEGIN(filename)                                               \
{                                                                                   \
    char fullname[64];                                                              \
    nvSprintf (fullname, "%s.bin", filename);                                       \
    hPusherFileBinary = CreateFile (fullname,GENERIC_WRITE,0,0,OPEN_ALWAYS,0,0);    \
    if (hPusherFileBinary == INVALID_HANDLE_VALUE) {                                \
        DPF ("NV_PC_CAPTURE_BEGIN: Binary file open failed");                       \
        nvAssert(0);                                                                  \
    }                                                                               \
    SetFilePointer (hPusherFileBinary, 0,0, FILE_END);                              \
    nvSprintf (fullname, "%s.txt", filename);                                       \
    hPusherFileAscii = CreateFile (fullname,GENERIC_WRITE,0,0,OPEN_ALWAYS,0,0);     \
    if (hPusherFileAscii == INVALID_HANDLE_VALUE) {                                 \
        DPF ("NV_PC_CAPTURE_BEGIN: Ascii file open failed");                        \
        nvAssert(0);                                                                  \
    }                                                                               \
    SetFilePointer (hPusherFileAscii, 0,0, FILE_END);                               \
    bPusherCapture = TRUE;                                                          \
}

#define NV_PC_CAPTURE_END                                                           \
{                                                                                   \
    if (bPusherCapture) {                                                           \
        getDC()->nvPusher.flush (TRUE, CPushBuffer::FLUSH_WITH_DELAY);              \
        FlushFileBuffers (hPusherFileBinary);                                       \
        FlushFileBuffers(hPusherFileAscii);                                         \
        CloseHandle (hPusherFileBinary);                                            \
        CloseHandle (hPusherFileAscii);                                             \
        bPusherCapture = FALSE;                                                     \
    }                                                                               \
}

#endif

//---------------------------------------------------------------------------

// pusher aliases
// alias these to point to appropriate data for your particular implementation

// hw get
#ifndef _pdwHWGet
#define _pdwHWGet       ((volatile DWORD)(((Nv4ControlDma*)m_dwControlDMA)->Get))
#endif

// hw put
#ifndef _pdwHWPut
#define _pdwHWPut       ((volatile DWORD)(((Nv4ControlDma*)m_dwControlDMA)->Put))
#endif

// hw reference count
#ifndef _pdwHWRef
#define _pdwHWRef       ((volatile DWORD)(((Nv10ControlDma*)m_dwControlDMA)->Reference))
#endif

// true when HW is busy
#ifndef _pbHWBusy
#define _pbHWBusy       (*(volatile DWORD *)(pDriverData->NvBaseFlat + 0x400700))
#endif

// cache1 ownership: bits 0:4 give the channel that currently owns the cache
#ifndef _ffCache1Push1
#define _ffCache1Push1  (*(volatile DWORD *)(pDriverData->NvBaseFlat + 0x003204))
#endif

// cache1 status: bit 4 is set when the cache is empty
#ifndef _ffCache1Status
#define _ffCache1Status (*(volatile DWORD *)(pDriverData->NvBaseFlat + 0x003214))
#endif

// true if we have KNI support
#ifndef _hasKNI
#define _hasKNI         (pDriverData->nvD3DPerfData.dwCPUFeatureSet & FS_KATMAI)
#endif

// true if we have 3DNOW support
#ifndef _has3DNOW
#define _has3DNOW       (pDriverData->nvD3DPerfData.dwCPUFeatureSet & FS_3DNOW)
#endif

// true if we have SFENCE support
#ifndef _hasSFENCE
#define _hasSFENCE      (pDriverData->nvD3DPerfData.dwCPUFeatureSet & FS_SFENCE)
#endif

// Defines which classes are present on the chip and other system information
#ifndef _systemInfo
#define _systemInfo (pDriverData->nvD3DPerfData)
#endif

#ifndef _dmaPusherChannelIndex
#define _dmaPusherChannelIndex (pDriverData->dwDDDmaPusherChannelIndex)
#endif

#ifndef _dwRootHandle
#define _dwRootHandle (pDriverData->dwRootHandle)
#endif

#ifndef _nvBaseFlat
#define _nvBaseFlat ((volatile DWORD*)pDriverData->NvBaseFlat)
#endif

#ifndef _pCurrentChannelID
#define _pCurrentChannelID ((DWORD*)(pDriverData->pCurrentChannelID))
#endif

#ifndef _pDriverData
#define _pDriverData (pDriverData)
#endif

#ifndef _hDevice
#define _hDevice (NV_WIN_DEVICE)
#endif


//---------------------------------------------------------------------------

// pusher-related macros

// the if is to allow for a string of Function such as Flip(A->B), Clear(A), Blit(C), such that the Blit to C
// does not destroy the pending waitforflip on Clear(A).  We only wait on surfaces that are just becoming a
// target and not an arbitrary surface
#define nvPusherSignalWaitForFlip(fpVidMem, dwDDSFlags)          \
{                                                                \
    if (getDC()->flipPrimaryRecord.fpFlipFrom == (fpVidMem)) {   \
        getDC()->nvPusher.setSyncFlipFlag();                     \
        getDC()->nvPusher.setFlipSurface(fpVidMem);              \
        getDC()->nvPusher.setFlipSurfaceFlags(dwDDSFlags);       \
    }                                                            \
}

// i'd really rather see these eventually just be substituted, but i'll make that mess later
#define nvPushData(a,b)    getDC()->nvPusher.push(a,b)
#define nvPusherAdjust(a)  getDC()->nvPusher.adjust(a)
#define nvPusherStart(a)   getDC()->nvPusher.start(a)
#define nvPusherFlush(a)   getDC()->nvPusher.flush(a,0)     // 0 = FLUSH_WITH_DELAY

//---------------------------------------------------------------------------

struct _CPushBuffer
{
    // members
    DWORD m_dwChannel;          // handle for channel used by this push buffer
    DWORD m_dwContextDMA;       // handle for context DMA
    DWORD m_dwContextDMASize;   // size of context dma allocated for this push buffer
    DWORD m_dwControlDMA;       // controlDMA structure for this channel
    DWORD m_dwPCIHeapHandle;    // pci heap handle (if any)
    DWORD m_dwPCIHeapBase;      // pci heap base (if any)
    DWORD m_dwHeap;             // heap from which push buffer is allocated
    // bank
    DWORD m_dwBase;             // base of push buffer
    DWORD m_dwSize;             // size of push buffer
    DWORD m_dwPut;              // current put pointer
    DWORD m_dwPutLast;          // last put wrote to HW
    DWORD m_dwGet;              // cached get pointer
    DWORD m_dwThreshold;        // threshold value
    DWORD m_dwWrapCount;        // # of wrap arounds
#if (IS_WIN9X || IS_WINNT5)
    DWORD m_dwPad01[1];
#elif IS_WINNT4
    PDEV *m_ppdev;     // On NT4 systems when there is no D3D, this pointer is used to get to a valid context
#endif
    // bank
    DWORD m_dwFlipSurfaceAddr;  // what surface to wait on during getFrameStatus
    DWORD m_dwFlipSurfaceFlags; // DDS caps flags, identifying the type of surface
    DWORD m_dwFlags;            // pusher flags
    DWORD m_dwPad02[5];
};

#ifdef __cplusplus

// forward definitions

struct  _def_nv_d3d_context;
typedef _def_nv_d3d_context *PNVD3DCONTEXT;


//---------------------------------------------------------------------------


class CPushBuffer : public _CPushBuffer
{
private:

    // pusher flags
    const enum {
        PB_FLAG_VALID          = (1 << ( 0)),  // push buffer is allocated, context DMA is allocated, and channel is open
        PB_FLAG_CHANNEL_SYNC   = (1 << ( 1)),  // signal to sync other channels b4 put
        PB_FLAG_FLIP_SYNC      = (1 << ( 2))   // will wait for flip before writing put
    };

public:

    // flush modes
    const enum {
        FLUSH_WITH_DELAY       = 0,            // flush with a delays when polling    (detrimental to CPU performance)
        FLUSH_HEAVY_POLLING    = 1             // flush & poll hw as fast as possible (detrimental to HW performance)
    };

public:

#if (IS_WINNT4)
    inline void  setPdev              (PDEV *ppdev)            {   m_ppdev =  ppdev;  }
#endif

    inline DWORD getChannel           (void)            {   return (m_dwChannel);      }
    inline DWORD getContextDMA        (void)            {   return (m_dwContextDMA);   }

    inline DWORD getHeap              (void)            {   return (m_dwHeap);   }
    inline DWORD getBase              (void)            {   return (m_dwBase);   }
    inline DWORD getSize              (void)            {   return (m_dwSize);   }

    inline void  setPut               (DWORD dwPut)     {   m_dwPut = dwPut;    }
    inline DWORD getPut               (void)            {   return (m_dwPut);   }

    inline DWORD getThreshold         (void)            {   return (m_dwThreshold);   }
    inline DWORD getWrapCount         (void)            {   return (m_dwWrapCount);   }
    inline DWORD getRefCount          (void)            {   return (_pdwHWRef);       }

    inline void  setSyncFlipFlag      (void)            {   m_dwFlags |=  PB_FLAG_FLIP_SYNC;    }
    inline void  clearSyncFlipFlag    (void)            {   m_dwFlags &= ~PB_FLAG_FLIP_SYNC;    }
    inline void  setSyncChannelFlag   (void)            {   m_dwFlags |=  PB_FLAG_CHANNEL_SYNC; }
    inline void  clearSyncChannelFlag (void)            {   m_dwFlags &= ~PB_FLAG_CHANNEL_SYNC; }

    inline void  setFlipSurface       (DWORD dwAddr)    {   m_dwFlipSurfaceAddr = dwAddr;   }
    inline void  setFlipSurfaceFlags  (DWORD dwFlags)   {   m_dwFlipSurfaceFlags = dwFlags;   }

    inline BOOL  isValid              (void)            {   return ((m_dwFlags & PB_FLAG_VALID) ? TRUE : FALSE);   }
    inline void  invalidate           (void)            {   m_dwFlags &= ~PB_FLAG_VALID;   }

    // prototypes for functions in nvPusher.cpp

           BOOL  allocate             (DWORD dwChannel);
           BOOL  free                 (void);

           void  start                (BOOL bRequired);                     // kick off
           void  flush                (BOOL bWaitForHWIdle, DWORD dwMode);  // kick off & wait for idle
           void  resetPut             (void);                               // set put to base & read get
           BOOL  isIdle               (BOOL bCheckHWAlso);                  // check if idle
           void  waitForOtherChannels (void);                               // idle other channels
           void  makeSpace            (DWORD dwCount);                      // makes space for large transfers (use inc instead of adjust)

    #ifdef _NO_INLINE

           void  push                 (DWORD dwOffset, DWORD dwData);
           BOOL  adjust               (DWORD dwCount);
           void  inc                  (DWORD dwCount);

    #else  // !_NO_INLINE

    FORCE_INLINE void  push           (DWORD dwOffset, DWORD dwData)
                {
                    ((DWORD*)m_dwPut)[dwOffset] = dwData;
                };

    FORCE_INLINE BOOL  adjust         (DWORD dwCount)
                {   m_dwPut += ((dwCount) << 2);
                    if (m_dwPut >= m_dwThreshold) {
                        return getSpace();
                    }
                    return FALSE;
                }
    FORCE_INLINE void  inc            (DWORD dwCount)
                {
                    m_dwPut += ((dwCount) << 2);
                }

    #endif  // !_NO_INLINE

    inline void setObject(NvU32 subChannel,NvU32 objId)
    {
        nvAssert((subChannel >= 0) && (subChannel<=7));
        nvAssert(objId != 0);
        push(0, (subChannel << 13) | 0x40000);
        push(1, objId);
        adjust(2);
    }
private:

    // prototypes for functions in nvPusher.cpp

    inline void    setChannel         (DWORD dwChannel)                 {   m_dwChannel    = dwChannel;
                                                                            m_dwContextDMA = dwChannel+1;   }

           void    setBase            (DWORD dwBase);   // set buffer base
           void    setSize            (DWORD dwSize);   // set buffer size

           BOOL    allocateMemory     (void);
           BOOL    freeMemory         (void);
           BOOL    allocateContextDMA (void);
           BOOL    freeContextDMA     (void);
           BOOL    openChannel        (void);
           BOOL    closeChannel       (void);

           FLATPTR getfpVidMem        (void);           // FLATPTR of pusher base

    inline void    syncAndFlushWC     (void);
           void    kickOff            (void);

           BOOL    getSpace           (void);
           BOOL    calcThreshold      (void);           // read get
           void    wrapAround         (void);

    #ifdef _PC_CHECK
           BOOL    validate           (DWORD dwStart, DWORD dwEnd);
    #endif
    #ifdef _PC_CAPTURE_METHOD_DATA
           DWORD   parseMethod        (DWORD dwAddress);
           void    captureState       (DWORD dwSubChannel);
    #endif

public:

    // creation and destruction

    inline         CPushBuffer        (void)            {   memset (this, 0, sizeof(*this));  }
    inline        ~CPushBuffer        (void)            {}

    // friends

    friend void    nvCelsiusILCompile_beginEnd        (DWORD dwPrimType);
    friend DWORD   nvCelsiusILCompile_inline_prim     (PNVD3DCONTEXT pContext, DWORD dwFlags);
    friend DWORD   nvCelsiusILCompile_inline_tri_list (PNVD3DCONTEXT pContext, DWORD dwFlags);
    friend DWORD   nvCelsiusILCompile_super_tri_list  (PNVD3DCONTEXT pContext, DWORD dwFlags);
    friend DWORD   nvCelsiusILCompile_vb_prim         (PNVD3DCONTEXT pContext, DWORD dwFlags);

    //friend void    nvKelvinILCompile_beginEnd         (DWORD dwPrimType);
    friend DWORD   nvKelvinILCompile_inline_prim      (PNVD3DCONTEXT pContext, DWORD dwFlags);
    //friend DWORD   nvKelvinILCompile_inline_tri_list  (PNVD3DCONTEXT pContext, DWORD dwFlags);
    //friend DWORD   nvKelvinILCompile_super_tri_list   (PNVD3DCONTEXT pContext, DWORD dwFlags);
    friend DWORD   nvKelvinILCompile_vb_prim          (PNVD3DCONTEXT pContext, DWORD dwFlags);

};

#else  // !cplusplus

typedef struct _CPushBuffer CPushBuffer;

#endif  // !cplusplus

#endif  // (NVARCH >= 0x04)

#endif  //!_NVPUSHER_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\common\inc\nvVPP.h ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-2001 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/

/*==========================================================================;
 *
 *  File:       nvVPP.h
 *  Content:    Video Post Processing
 *
 ***************************************************************************/

#ifndef _NVVPP_H_
#define _NVVPP_H_

#include "CompileControl.h"

#include "nvTypes.h"
#include "nvProcMan.h"
#include "nvPusher.h"
#include "nvRegTool.h"
#include "nvUniversal.h"
#include "nvMultiMon.h" // Need twinview definition

// {BFD51181-16C4-11d4-8E67-00104B9D3738}
static const GUID GUID_NV_OVERLAY_INFO = { 0xbfd51181, 0x16c4, 0x11d4, { 0x8e, 0x67, 0x0, 0x10, 0x4b, 0x9d, 0x37, 0x38 } };

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

// Objects created and destroyed by the VPP code
//  Note: IID = instance ID
// TBD: lots of the code in ddraw common assumes these objects exist and interact with them
//   directly.  They should be changed to access them only through VPP routines. -@mjl@
#define NV_VPP_SWIZZLE_BLIT_IID     0xBB00B000
#define NV_VPP_OVERLAY_IID          0xBB00B010
#define NV_VPP_V2V_FORMAT_Y_IID     0xBB00B020
#define NV_VPP_ALPHA_BLIT_IID       0xBB00B030
#define NV_VPP_TIMER_IID            0xBB00B040
#define NV_VPP_V2OSH_FORMAT_IID     0xBB00B050  // Video Mem -> Overlay SHadow (OSH)
#define NV_VPP_OSH2V_FORMAT_IID     0xBB00B060
#define NV_VPP_SCALED_IMAGE1_IID    0xBB00B070
#define NV_VPP_SCALED_IMAGE2_IID    0xBB00B080
#define NV_VPP_DMABLT_TO_VID_IID    0xBB00B090
#define NV_VPP_DVD_SUBPICTURE_IID   0xBB00B0A0

#define NV_VPP_SWIZZLE_BLIT_CONTEXT_IID             0xBB00C000
#define NV_VPP_OVERLAY_CONTEXT_IID                  0xBB00C010
#define NV_VPP_V2V_FORMAT_Y_CONTEXT_IID             0xBB00C020
#define NV_VPP_ALPHA_BLIT_CONTEXT_IID               0xBB00C030
#define NV_VPP_TIMER_CONTEXT_IID                    0xBB00C040
#define NV_VPP_V2OSH_FORMAT_CONTEXT_IID             0xBB00C050
#define NV_VPP_OSH2V_FORMAT_CONTEXT_IID             0xBB00C060
#define NV_VPP_SCALED_IMAGE1_CONTEXT_IID            0xBB00C070
#define NV_VPP_SCALED_IMAGE2_CONTEXT_IID            0xBB00C080
#define NV_VPP_DMABLT_TO_VID_CONTEXT_IID            0xBB00C090
#define NV_VPP_DVD_SUBPICTURE_CONTEXT_IID           0xBB00C0A0

#define NV_VPP_CONTEXT_DMA_MEMORY_IID               0xBB00C990  // Used only on Win9x systems


#define NV_VPP_MAX_OVERLAY_SURFACES  10
#define NV_VPP_MAX_EXTRA_SURFACES    6
#define NV_VPP_MAX_EXTRA_FS_SURFACES 4


// vppVPPandFlip flags
#define VPP_ODD             NV4_REG_VPP_INV_MASK_ODD
#define VPP_EVEN            NV4_REG_VPP_INV_MASK_EVEN
#define VPP_BOB             NV4_REG_VPP_INV_MASK_BOB
#define VPP_INTERLEAVED     NV4_REG_VPP_INV_MASK_INTERLEAVED
#define VPP_VIDEOPORT       NV4_REG_VPP_INV_MASK_VIDEOPORT
#define VPP_WAIT            NV4_REG_VPP_INV_MASK_WAIT
#define VPP_SAVE_STATE      NV4_REG_VPP_SAVE_STATE_DISABLE
#define VPP_RESTORE_STATE   NV4_REG_VPP_RESTORE_STATE_DISABLE
#define VPP_CONVERT         NV4_REG_VPP_CONVERT_DISABLE
#define VPP_SUBPICTURE      NV4_REG_VPP_SUBPICTURE_DISABLE
#define VPP_PRESCALE        NV4_REG_VPP_PRESCALE_DISABLE
#define VPP_COLOURCONTROL   NV4_REG_VPP_COLOURCONTROL_DISABLE
#define VPP_TEMPORAL        NV4_REG_VPP_TEMPORAL_DISABLE
#define VPP_OPTIMIZEFLIP    NV4_REG_VPP_OPTIMIZEFLIP_DISABLE
#define VPP_DEINTERLACE     NV4_REG_VPP_DEINTERLACE_DISABLE
#define VPP_FSMIRROR        NV4_REG_VPP_FSMIRROR_DISABLE
#define VPP_DMABLIT_DISABLE NV4_REG_VPP_DMABLIT_DISABLE
#define VPP_MASTER_DISABLE  NV4_REG_VPP_MASTER_DISABLE
// TBD: why redefine these?  Note that master disable WAS being used directly anyway. - @mjl@

#define VPP_ALL             (VPP_CONVERT | VPP_SUBPICTURE | VPP_PRESCALE | VPP_COLOURCONTROL | VPP_DEINTERLACE | VPP_TEMPORAL | VPP_FSMIRROR)
#define VPP_STATIC          (VPP_CONVERT | VPP_SUBPICTURE | VPP_PRESCALE | VPP_COLOURCONTROL | VPP_FSMIRROR)
#define VPP_MOCOMP          (VPP_PRESCALE | VPP_FSMIRROR)

#define IS_OVERLAY(caps,fourcc) ((caps & DDSCAPS_OVERLAY) && (fourcc != FOURCC_NVDS) && (fourcc != FOURCC_NVMC))
#define IS_FIELD(f) ((f & (VPP_INTERLEAVED | VPP_BOB)) && (f & (VPP_ODD | VPP_EVEN)))

#ifdef ENABLE_VPP_DISPATCH_CODE
// This code is no longer used but may someday be useful.

// dispatcher commands
#define VPPDISPATCH_NOOP            0x0
#define VPPDISPATCH_DISPATCH        0x1
#define VPPDISPATCH_SETPRIORITY     0x2
#define VPPDISPATCH_RESTOREPRIORITY 0x4
#define VPPDISPATCH_EXIT            0xFFFFFFFF

// dispatcher state
#define VPPDSTATE_WAITING           0x1
#define VPPDSTATE_BUSY              0x2
#define VPPDSTATE_INITERROR         0x10000
#define VPPDSTATE_CMDERROR          0x20000
#define VPPDSTATE_TERMINATED        0x80000000

#endif

#ifdef DEBUG
    // so we know when something is drastically wrong
    #define VPP_TIMEOUT_TIME    250
    // snooping automatically enabled unless we're on NT where it doesn't work
    #ifndef WINNT
    #define VPP_SNOOP           1
    #endif
#else  // !DEBUG
    // maximum time we can spend on a frame
    #define VPP_TIMEOUT_TIME    42
    #ifdef DEVELOP
        #ifndef WINNT
        #define VPP_SNOOP       1
        #endif
    #endif  // DEVELOP
#endif  // !DEBUG

typedef struct {
  NvF32 sx;
  NvF32 sy;
  NvF32 sz;
  NvF32 rhw;
  NvV32 color;
  NvV32 specular;
  NvF32 tu0;
  NvF32 tv0;
  NvF32 tu1;
  NvF32 tv1;
} Tlmtvertex;

typedef struct Vpp_s Vpp_t;

//
// Exported functions
//
#ifdef WINNT
extern NvU8 VppConstructor(PDEV *ppdev, Vpp_t *pVpp, NV_SystemInfo_t *pSysInfo);
#else
extern NvU8 VppConstructor(GLOBALDATA *pDriverData, Vpp_t *pVpp, NV_SystemInfo_t *pSysInfo);
#endif
extern void VppDestructor(Vpp_t *pVpp);
extern NvU8 VppReadRegistry(Vpp_t *pVpp, HANDLE hDriver, NvU32 logicalHeadID);
extern void VppBltWriteDword(Vpp_t *pVpp, NvU32 dwOffset, NvU32 dwIndex, NvU32 dwData);
extern NvU8 VppIsOverlayActive(Vpp_t *pVpp);
extern NvU8 VppIsConstructed(Vpp_t *pVpp);
extern NvU8 VppGetVideoScalerBandwidthStatus(Vpp_t *pVpp, NvU16 wWidth);

extern int  VppWaitForNotification(NvNotification* pNotify, HDRVEVENT hEvent, unsigned long timeOut);
extern void VppResetNotification(NvNotification* pNotify, HDRVEVENT hEvent);

// Exported Functions
NvU8 VppEnable(
    Vpp_t           *pVpp,
    PDEV            *ppdev,
    CPushBuffer     *pPusher,
    NvU32            hChannel, 
    NvU32            hThreeDClass,
    NvU32            threeDClassSubCh,
    NvU32           *pThreeDClassLastUser,
    NvU32            hInVideoMemContextDma,
    NvU32            hFromVideoMemContextDma,
    NvU32            hToVideoMemContextDma,
    NvU32            hLutCursorDac,
    NvU32            hMiscEventNotifier,
    NvU32            hContextSurfaceSwizzled,
    NvU32            hContextBeta4,
    NvU32            hSurfaces2D,
    NvU32            surfaces2DSubCh,
    NvU32            hVideoMemUtoVideoMemFormat,    // U-conversion object
    NvU32            hVideoMemVtoVideoMemFormat,    // V-conversion object
    NvU32            hVideoMemUVtoVideoMemFormat,    // UV-conversion object
    NvU32            hDvdSubpicture,
    NvU32            hContextPattern,
    NvU32            hContextRop,
    NvU32            hContextColorKey,
    NvU32            hFloatingContextDmaInOverlayShadow,

    NvNotification  *pFlipPrimaryNotifier,  
    NvNotification  *pPusherSyncNotifier,
    NvNotification  *pUnused,

    NvU32            hContextSurfacesARGB_ZS,
    NvU32            hDX6MultiTextureTriangle,
    NvU32            hImageBlackRect,

    NvU32            ropRectTextSubCh,
    NvU32            ropSubCh,
    NvU32            spareSubCh);


NvU8 VppSetOverlayColourControl(Vpp_t *pVpp);

BOOL VppCreateOverlay(Vpp_t *pVpp);
void VppDestroyOverlay(Vpp_t *pVpp);
void VppDisable(Vpp_t *pVpp);
BOOL VppCreateFSMirror(Vpp_t *pVpp, DWORD dwWidth, DWORD dwHeight);
void VppDestroyFSMirror(Vpp_t *pVpp);
BOOL VppDoFlip(Vpp_t *pVpp,DWORD dwOffset, DWORD dwPitch, DWORD dwWidth,
                   DWORD dwHeight, DWORD dwFourCC, DWORD dwFlags);

#if (IS_WINNT5 | IS_WIN9X)
#define NV_GET_VIDEO_HEAP_FREE() (DWORD)vpp.pDriverData->VideoHeapFree

#elif (IS_WINNT4)
#define NV_GET_VIDEO_HEAP_FREE() (DWORD)vpp.pDriverData->ppdev->VideoHeapFree

#else
#error Unsupported OS.
#endif

/*
 * NV_ColorControl_t
 *    'Derived' from DDCOLORCONTROL for multi-OS compatibility
 */
#define NV_VPP_COLOR_BRIGHTNESS		0x00000001l // Field validity flags
#define NV_VPP_COLOR_CONTRAST		0x00000002l
#define NV_VPP_COLOR_HUE			0x00000004l
#define NV_VPP_COLOR_SATURATION		0x00000008l
#define NV_VPP_COLOR_SHARPNESS		0x00000010l
#define NV_VPP_COLOR_GAMMA			0x00000020l
#define NV_VPP_COLOR_COLORENABLE	0x00000040l

typedef struct {
    NvU32               dwLastFlags;
    NvU32               dwLastExec;
    NvU32               dwMarker1;
    NvU32               dwReserved1;

    LONGLONG            qwCount;    // TBD: what to do with LONGLONG? -@mjl@
    
    LONGLONG            qwInterFrameTime;
    LONGLONG            qwInterFrameAcc;
    LONGLONG            qwInterFramePeak;
    LONGLONG            qwInterFrameDelta;
    LONGLONG            qwInterFrameJitterAcc;
    LONGLONG            qwInterFrameJitterPeak;

    LONGLONG            qwIntraFrameAcc;
    LONGLONG            qwIntraFramePeak;
    LONGLONG            qwIntraFrameDelta;
    LONGLONG            qwIntraFrameJitterAcc;
    LONGLONG            qwIntraFrameJitterPeak;

    LONGLONG            qwMarker2;
    LONGLONG            qwReserved2;
} Vpp_snoop_t;


typedef struct NV_ColorControl_s
{
    NvU32 		dwSize;
    NvU32		dwFlags;
    NvS32		lBrightness;
    NvS32		lContrast;
    NvS32		lHue;
    NvS32 		lSaturation;
    NvS32		lSharpness;
    NvS32		lGamma;
    NvS32		lColorEnable;
    NvU32		dwReserved1;
} Nv_ColorControl_t;

// Experimental struct (may replace overlay corresponding vars with this as well)
typedef struct Nv_Surface_s
{
    NvU32       format; // TBD: enumerate - @mjl@
    NvU32       originX;
    NvU32       originY;
    NvU32       pitch;
    NvU32       width;
    NvU32       height;
    NvU32       offset; // General offset?  Unsure -@mjl@
} Nv_Surface_t;


typedef struct {
    NvU32               dwOpCount;
    HDRVEVENT           hLastStage;
    NvNotification     *pLastStageNotifier;
    HDRVEVENT           hLastFSStage;
    NvNotification     *pLastFSStageNotifier;
    NvU8                doLateFlipSync;
    NvU8                doFSMirror;
    NvU16               unused_01;
    NvU32               dwIndex;
    NvU32               dwSrcOffset;
    NvU32               dwSrcPitch;
    NvU32               dwWidth;
    NvU32               dwHeight;
    NvU32               dwFourCC;
    NvU32               dwFlags;
    NvU32               dwWorkSurfaces;
    NvU32               vppExec;
    NvU32               dwPrescaleFactorX;
    NvU32               dwPrescaleFactorY;
#ifdef VPP_SNOOP
    LONGLONG            qwTime1;
    LONGLONG            qwTime2;
    LONGLONG            qwDelta;
    LONGLONG            qwJitter;
#endif
} Vpp_pipeline_state_t;

// *********************************************************************
// Notesf on m_obj_a array:
//
// Note that the 2nd field is sometimes overwritten depending on the hardware.  Usually
// to conditionally 'upgrade' the class.
//
// The entries MUST remain in the order that corresponds to the indexes (see nvVPP.h)
//
// Any entries with NV_DD_ names are allocated by the main driver and NOT the vpp.  They are in
// this array to provide a consistent access point to a notifier pointer.  Since the status
// is set to VPP_OBJ_NA, the alloc/dealloc routines will ignore the object.
//  [NB: there are none like this right now - @mjl@]
//
// *********************************************************************

typedef struct {
	NvU16 status;	            // Allocated by VPP, FREED, NA or ERROR
	NvU16 classNdx;             // Index that identifies the class
	NvU32 classIID;	         	// Instance of this class
	NvU32 contextIID;	        // Instance of a DMA context used by this class
	int notifierCount;          // # of notifier slots used by <classNdx>
    NvNotification* notifier_a; // Length of array depends on the object
} VppObjectRecord_t;

#define  VPP_OBJECT_COUNT 11

// This list MUST match the one in nvVPP.cpp -- need a better way to do this...@mjl@
#define OVERLAY_NDX         0
#define SWIZZLE_NDX         1 
#define TIMER_NDX           2 
#define ALPHA_BLT_NDX       3 
#define V2V_FORMAT_NDX      4  
#define V2OSH_FORMAT_NDX    5 
#define OSH2V_FORMAT_NDX    6
#define SCALED_IMAGE1_NDX   7
#define SCALED_IMAGE2_NDX   8
#define DMABLT_TO_VID_NDX   9
#define DVDPICT_NDX        10


// Note: The 3D class object is used for "advanced" blts that are not possible
//  using the normal bltter.  Surfaces are treated as textures and texture ops
//  are applied to get the desired results.
//
// TBD: turn this into a proper class (if we can get away from C enough) - @mjl@
//
typedef struct Vpp_s
{
    NvU32            dwFlags; // General flags detailing state of the VPP object (see VPP_FLAG_*)

	NvU32            m_pContextDMABase;	// Address of a context DMA memory for VPP use

    DWORD            dwOverlayEventsAllocated;        // used to keep track of overlay event allocation

    GLOBALDATA      *pDriverData;           // Hope to eliminate this some day. -@mjl@

    PDEV            *m_ppdev;              // Hope to eliminate this some day. -@mjl@

    CPushBuffer     *pPusher;              // A cmd pusher class attached to a DMA push buffer
    NV_SystemInfo_t *pSysInfo;             // System Information
    NvU32           *pThreeDClassLastUser; // Last user of the 3d superclass (kelvin,celsius,...)

    CRegTool         regTool;              // A tool to access the system registry

    // Handles to objects created outside of the VPP
    NvU32            hImageBlackRect;
    NvU32            hContextPattern;
    NvU32            hContextRop;
    NvU32            hContextColorKey;
    NvU32            hFloatingContextDmaInOverlayShadow;
    NvU32            hVideoMemUtoVideoMemFormat;        // U-conversion object
    NvU32            hVideoMemVtoVideoMemFormat;        // V-conversion object
    NvU32            hVideoMemUVtoVideoMemFormat;       // UV-conversion object
    NvU32            hLutCursorDacBase;                 // Base object ID for DACs (1 per head)
    NvU32            hMiscEventNotifier;                // Used as the notifier in many cases
    NvU32            hContextSurfaceSwizzled;
    NvU32            hContextBeta4;
    NvU32            hSurfaces2D;
    NvU32            hChannel;
    NvU32            hThreeDClass;        // Unique object ID for the 3D object to be used
    NvU32            hInVideoMemContextDma;      // DMA context for V2V 
    NvU32            hFromVideoMemContextDma;    // DMA context for V2S
    NvU32            hToVideoMemContextDma;      // DMA context for S2V
    NvU32            hContextSurfacesARGB_ZS;
    NvU32            hDX6MultiTextureTriangle;

    // Notifiers created outside of the VPP

    NvNotification  *pFlipPrimaryNotifier;
    NvNotification  *pPusherSyncNotifier;

    // Sub-channel definitions

    NvU32            ropRectTextSubCh;
    NvU32            ropSubCh;
    NvU32            spareSubCh;          // General use subchannel (SetObject always done first)
    NvU32            surfaces2DSubCh;       // May be able to just use spare? -@mjl@
    NvU32            threeDClassSubCh;    // Subchannel that _always_ holds the 3D class object

    // TBD:hMiscEventNotifier was using NV_DD_DMA_COLOUR_CONTROL_EVENT_NOTIFIER which IS NV_DD_PIO_COLOUR_CONTROL_EVENT_NOTIFIER -@mjl@

    NvU32            dwOverlayFSNumSurfaces;
    NvU32            dwOverlayFSHead;    //what head is overlay on over is head on
    NvU32            dwOverlayFSOvlHead; // where mirror is
    NvU32            dwOverlayFSOvlHeadSaved;
    NvU32            dwOverlayFSOvlLost;

    NvU32            dwOverlayFSWidth;
    NvU32            dwOverlayFSHeight;
    NvU32            dwOverlayFSPitch;
    NvU32            dwOverlayFSFormat;
    NvU32            dwOverlayFSOffset[NV_VPP_MAX_EXTRA_FS_SURFACES];

    NvU32            dwOverlayFSIndex;
    NvU32            dwOverlayFSDeltaX;
    NvU32            dwOverlayFSDeltaY;

    // Size & offset of each of the extra surfaces used to run the VPP engine
    NvU32   extraOverlayOffset[NV_VPP_MAX_EXTRA_SURFACES];   // can be up to n "chunks" longer original surface
    NvU32   extraPitch;
    NvU32   extraNumSurfaces;
    NvU32   extraIndex; // Next 'extra' surface to be used

    NvU32   dwOverlaySurfaces;
    NvU32   dwOverlayOwner;
    NvU32   dwOverlaySurfaceLCL[NV_VPP_MAX_OVERLAY_SURFACES];
    NvU32   dwOverlaySrcWidth;
    NvU32   dwOverlaySrcHeight;
    NvU32   dwOverlayDstWidth;
    NvU32   dwOverlayDstHeight;
    NvU32   dwOverlayDeltaX;
    NvU32   dwOverlayDeltaY;

    NvU32   dwOverlaySrcX;          // overlay source starting point
    NvU32   dwOverlaySrcY;
    NvU32   dwOverlayDstX;        // overlay Dst starting point
    NvU32   dwOverlayDstY;
    NvU32   dwOverlaySrcOffset;
    NvU32   dwOverlayFormat;      // current overlay format - used so VDD knows what's up!
    NvU32   dwOverlaySrcPitch;    // current overlay pitch   - used so VDD knows what's up!
///
    NvU32   dwOverlayLastVisibleSurfaceLCL;
    NvU32   dwOverlayLastVisibleFpVidMem;
    NvU32   dwOverlayLastVisiblePitch;
    NvU32   dwOverlayLastVisiblePixelFormat;
    NvU32   dwOverlayFlipCount;
    NvU16   overlayBufferIndex;
    NvU16   overlayRelaxOwnerCheck;
    NvU32   dwOverlaySrcSize;
    NvU32   dwOverlayColorKey;

    NvU32                       dwOverlayCachedFlags;
    NvU32                       dwOverlayFSSrcWidth;
    NvU32                       dwOverlayFSSrcHeight;
    NvU32                       dwOverlayFSSrcMinX;
    NvU32                       dwOverlayFSSrcMinY;
    NVTWINVIEWDATA              dwOverlayFSTwinData;
    NvU32                       fpOverlayShadow;
    NvU32                       dwOverlayMaxDownScale;
    NvU32                       dwOverlayMaxDownScaleX;
    NvU32                       dwOverlayMaxDownScaleY;
    NvU32                       regOverlayColourControlEnable;
    NvU32                       dwOverlayByteAlignmentPad;
    NvU32                       regOverlayMode;
    NvU32                       regOverlayMode2;
    NvU32                       regOverlayMode3;
    NvU32                       regVPPInvMask;
    NvU32                       regVPPMaxSurfaces;

    NvU32                       dwDecoderIdentity;
    NvU32                       dwDecoderCaps;

    NvU32                       regRing0ColourCtlInterlockFlags;    // bit0 = 1 -> ring0 should run; bit2 = 1 ring0 in progress

    NvU32                       dwOverlayMode;            // used to tell if we're doing interleaved or what...
//    VPPDISPATCH                 vppDispatch;          No longer used.
///

    NvU32                       dwPrevFrameOffset;

    __int64                     llDeliveryPeriod;    // in ns
    __int64                     llDeliveryTime;      // in ns
    __int64                     llDeliveryStart;     // in ns

    Nv_ColorControl_t    colorCtrl;

    Nv_Surface_t         subPicture; // Dvd Subpicture

    Vpp_pipeline_state_t pipeState;

    Vpp_snoop_t          snoop;

    NvU32                dwNVOverlayFlags;

    VppObjectRecord_t    m_obj_a[VPP_OBJECT_COUNT];
} Vpp_t;

#define KELVIN_Z_SCALE24                16777215.0f  // 2^24 - 1

#define DEFAULT_KELVIN_ALPHA_OCW   (NV097_SET_COMBINER_ALPHA_OCW_OPERATION_NOSHIFT << 15) |        \
                                   (NV097_SET_COMBINER_ALPHA_OCW_MUX_ENABLE_FALSE << 14) |         \
                                   (NV097_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_C << 8) |             \
                                   (NV097_SET_COMBINER_ALPHA_OCW_AB_DST_REG_0 << 4) |              \
                                    NV097_SET_COMBINER_ALPHA_OCW_CD_DST_REG_0

#define DEFAULT_KELVIN_COLOR_OCW (NV097_SET_COMBINER_COLOR_OCW_BLUETOALPHA_AB_DISABLE << 19) |  \
                                 (NV097_SET_COMBINER_COLOR_OCW_BLUETOALPHA_CD_DISABLE << 18) |  \
                                 (NV097_SET_COMBINER_COLOR_OCW_OP_NOSHIFT << 15) |              \
                                 (NV097_SET_COMBINER_COLOR_OCW_MUX_ENABLE_FALSE << 14) |        \
                                 (NV097_SET_COMBINER_COLOR_OCW_AB_DOT_ENABLE_FALSE << 13) |     \
                                 (NV097_SET_COMBINER_COLOR_OCW_CD_DOT_ENABLE_FALSE << 12) |     \
                                 (NV097_SET_COMBINER_COLOR_OCW_SUM_DST_REG_C << 8) |            \
                                 (NV097_SET_COMBINER_COLOR_OCW_AB_DST_REG_0 << 4) |             \
                                  NV097_SET_COMBINER_COLOR_OCW_CD_DST_REG_0

#define DEFAULT_KELVIN_ALPHA_ICW   (NV097_SET_COMBINER_ALPHA_ICW_A_MAP_UNSIGNED_IDENTITY << 29) |  \
                                   (NV097_SET_COMBINER_ALPHA_ICW_A_ALPHA_TRUE << 28) |             \
                                   (NV097_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_4 << 24) |           \
                                                                                                   \
                                   (NV097_SET_COMBINER_ALPHA_ICW_B_MAP_UNSIGNED_INVERT << 21) |    \
                                   (NV097_SET_COMBINER_ALPHA_ICW_B_ALPHA_TRUE << 20) |             \
                                   (NV097_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_0 << 16) |           \
                                                                                                   \
                                   (NV097_SET_COMBINER_ALPHA_ICW_C_MAP_UNSIGNED_IDENTITY << 13) |  \
                                   (NV097_SET_COMBINER_ALPHA_ICW_C_ALPHA_TRUE << 12) |             \
                                   (NV097_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_0 << 8) |            \
                                                                                                   \
                                   (NV097_SET_COMBINER_ALPHA_ICW_D_MAP_UNSIGNED_IDENTITY << 5) |   \
                                   (NV097_SET_COMBINER_ALPHA_ICW_D_ALPHA_TRUE << 4) |              \
                                    NV097_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_0

#define DEFAULT_KELVIN_COLOR_ICW   (NV097_SET_COMBINER_COLOR_ICW_A_MAP_UNSIGNED_IDENTITY << 29) |  \
                                   (NV097_SET_COMBINER_COLOR_ICW_A_ALPHA_FALSE << 28) |            \
                                   (NV097_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_4 << 24) |           \
                                                                                                   \
                                   (NV097_SET_COMBINER_COLOR_ICW_B_MAP_UNSIGNED_INVERT << 21) |    \
                                   (NV097_SET_COMBINER_COLOR_ICW_B_ALPHA_FALSE << 20) |            \
                                   (NV097_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_0 << 16) |           \
                                                                                                   \
                                   (NV097_SET_COMBINER_COLOR_ICW_C_MAP_UNSIGNED_IDENTITY << 13) |  \
                                   (NV097_SET_COMBINER_COLOR_ICW_C_ALPHA_FALSE << 12) |            \
                                   (NV097_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_0 << 8) |            \
                                                                                                   \
                                   (NV097_SET_COMBINER_COLOR_ICW_D_MAP_UNSIGNED_IDENTITY << 5) |   \
                                   (NV097_SET_COMBINER_COLOR_ICW_D_ALPHA_FALSE << 4) |             \
                                    NV097_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_0

#define DEFAULT_FINAL_CW0   (NV056_SET_COMBINER_SPECULAR_FOG_CW0_A_INVERSE_FALSE << 29) |   \
                            (NV056_SET_COMBINER_SPECULAR_FOG_CW0_A_ALPHA_FALSE << 28) |     \
                            (NV056_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_0 << 24) |    \
                                                                                            \
                            (NV056_SET_COMBINER_SPECULAR_FOG_CW0_B_INVERSE_FALSE << 21) |   \
                            (NV056_SET_COMBINER_SPECULAR_FOG_CW0_B_ALPHA_FALSE << 20) |     \
                            (NV056_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_0 << 16) |    \
                                                                                            \
                            (NV056_SET_COMBINER_SPECULAR_FOG_CW0_C_INVERSE_FALSE << 13) |   \
                            (NV056_SET_COMBINER_SPECULAR_FOG_CW0_C_ALPHA_FALSE << 12) |     \
                            (NV056_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_0 << 8) |     \
                                                                                            \
                            (NV056_SET_COMBINER_SPECULAR_FOG_CW0_D_INVERSE_FALSE << 5) |    \
                            (NV056_SET_COMBINER_SPECULAR_FOG_CW0_D_ALPHA_FALSE << 4) |      \
                             NV056_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_C

#define DEFAULT_KELVIN_FINAL_CW0   (NV097_SET_COMBINER_SPECULAR_FOG_CW0_A_INVERSE_FALSE << 29) |   \
                                   (NV097_SET_COMBINER_SPECULAR_FOG_CW0_A_ALPHA_FALSE << 28) |     \
                                   (NV097_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_0 << 24) |    \
                                                                                                   \
                                   (NV097_SET_COMBINER_SPECULAR_FOG_CW0_B_INVERSE_FALSE << 21) |   \
                                   (NV097_SET_COMBINER_SPECULAR_FOG_CW0_B_ALPHA_FALSE << 20) |     \
                                   (NV097_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_0 << 16) |    \
                                                                                                   \
                                   (NV097_SET_COMBINER_SPECULAR_FOG_CW0_C_INVERSE_FALSE << 13) |   \
                                   (NV097_SET_COMBINER_SPECULAR_FOG_CW0_C_ALPHA_FALSE << 12) |     \
                                   (NV097_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_0 << 8) |     \
                                                                                                   \
                                   (NV097_SET_COMBINER_SPECULAR_FOG_CW0_D_INVERSE_FALSE << 5) |    \
                                   (NV097_SET_COMBINER_SPECULAR_FOG_CW0_D_ALPHA_FALSE << 4) |      \
                                    NV097_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_C

// TBD: add CELSIUS to the following - @mjl@
#define DEFAULT_FINAL_CW1   (NV056_SET_COMBINER_SPECULAR_FOG_CW1_E_INVERSE_FALSE << 29) |   \
                            (NV056_SET_COMBINER_SPECULAR_FOG_CW1_E_ALPHA_FALSE << 28) |     \
                            (NV056_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_0 << 24) |    \
                                                                                            \
                            (NV056_SET_COMBINER_SPECULAR_FOG_CW1_F_INVERSE_FALSE << 21) |   \
                            (NV056_SET_COMBINER_SPECULAR_FOG_CW1_F_ALPHA_FALSE << 20) |     \
                            (NV056_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_0 << 16) |    \
                                                                                            \
                            (NV056_SET_COMBINER_SPECULAR_FOG_CW1_G_INVERSE_FALSE << 13) |   \
                            (NV056_SET_COMBINER_SPECULAR_FOG_CW1_G_ALPHA_TRUE << 12) |      \
                            (NV056_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_C << 8) |     \
                                                                                            \
                            (NV056_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_CLAMP_TRUE << 7) | \
                            (NV056_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_ADD_INVERT_R5_FALSE << 6) | \
                             NV056_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_ADD_INVERT_R12_FALSE

#define DEFAULT_KELVIN_FINAL_CW1   (NV097_SET_COMBINER_SPECULAR_FOG_CW1_E_INVERSE_FALSE << 29) |   \
                                   (NV097_SET_COMBINER_SPECULAR_FOG_CW1_E_ALPHA_FALSE << 28) |     \
                                   (NV097_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_0 << 24) |    \
                                                                                                   \
                                   (NV097_SET_COMBINER_SPECULAR_FOG_CW1_F_INVERSE_FALSE << 21) |   \
                                   (NV097_SET_COMBINER_SPECULAR_FOG_CW1_F_ALPHA_FALSE << 20) |     \
                                   (NV097_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_0 << 16) |    \
                                                                                                   \
                                   (NV097_SET_COMBINER_SPECULAR_FOG_CW1_G_INVERSE_FALSE << 13) |   \
                                   (NV097_SET_COMBINER_SPECULAR_FOG_CW1_G_ALPHA_TRUE << 12) |      \
                                   (NV097_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_C << 8) |     \
                                                                                                   \
                                   (NV097_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_CLAMP_TRUE << 7) | \
                                   (NV097_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_ADD_INVERT_R5_FALSE << 6) | \
                                    NV097_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_ADD_INVERT_R12_FALSE

#ifdef __cplusplus
}
#endif // __cplusplus

#define NV_MAX_EXTRA_FS_SURFACES 4

// Flags for vpp.dwFlags field
#define VPP_FLAG_CONSTRUCTED    0x00000001 // VPP class has been initialized
#define VPP_FLAG_ENABLED        0x00000002 // Resources have been assigned and VPP is ready to start
#define VPP_FLAG_OVERLAY_READY  0x00000004 // VPP is ready to run the overlay
#define VPP_FLAG_MIRROR_READY   0x00000008 // VPP is ready to run the full screen mirror
#define VPP_FLAG_CELSIUS_3D     0x00000010 // VPP is using a celsius class as it's 3D object
#define VPP_FLAG_KELVIN_3D      0x00000020 // VPP is using a kelvin class as it's 3D object


// Values for the status field of the m_obj_a[] array
//
#define VPP_OBJ_NA        0	// Ignore this entry.  Object is not applicable.
#define VPP_OBJ_FREED     1 // Needs to be allocated before next use
#define VPP_OBJ_ALLOCATED 2 // Has been allocated
#define VPP_OBJ_ERROR     3 // An error occured during allocation

// dwNVOverlayFlags values
#define OVERLAY_FLAG_ON_PANEL        0x00000001

// Using polling notifiers ALWAYS on an IKOS or NT4 build
//    events do not work properly on IKOS and are not available on NT4
//
//#if 1
#if defined(IKOS) || IS_WINNT4
#undef VPP_USE_EVENT_NOTIFIERS   // use event notifiers if this is defined, else use polling
#else
#define VPP_USE_EVENT_NOTIFIERS  // Win2k, Win9x...
#endif


// Note: The following assumes that all the WRITE_ONLY and WRITE_THEN_AWAKEN values are the
//    same for all objects. (NV039, NV056...) this IS the case.
//
#ifdef VPP_USE_EVENT_NOTIFIERS
#define VPP_NOTIFY_TYPE (NV039_BUFFER_NOTIFY_WRITE_THEN_AWAKEN)
#else
#define VPP_NOTIFY_TYPE (NV039_BUFFER_NOTIFY_WRITE_ONLY)
#pragma message ("VPP will not use events.")
#endif

#endif _NVVPP_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\common\inc\nvUtil.h ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-2000 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/
 /***************************************************************************\
|*                                                                           *|
|*                       General nVidia Utilties                             *|
|*                                                                           *|
|* Includes a variety of miscelaneous but commonly useful functions & macros *|
|*                                                                           *|
|* This file is OS independent.  Use ONLY nVidia types and names.            *|
|*                                [eg. No DWORD, use NvU32]                  *|
|*                                                                           *|
 \***************************************************************************/

#ifndef _NVUTIL_H_
#define _NVUTIL_H_

#include "nvTypes.h"
#include <StdArg.h>

#ifdef __cplusplus
    #define EXTERN_C    extern "C"
#else
    #define EXTERN_C    extern
#endif

//---------------------------------------------------------------------------
//
//  Common definitions
//
//---------------------------------------------------------------------------

#ifndef ABS
#define ABS(a)  (a>0?a:-a)
#endif
#ifndef MIN
#define MIN(x,y) (((x)<(y))?(x):(y))
#endif
#ifndef MAX
#define MAX(x,y) (((x)>(y))?(x):(y))
#endif

#ifndef VOID
#define VOID            void
#endif
#ifndef TRUE
#define TRUE            ~0
#endif
#ifndef FALSE
#define FALSE           0
#endif
#ifndef NULL
#define NULL            0L
#endif

// ================================================================
// floating point bit munging
// ================================================================

// convert an FP representation into a DWORD or vice-versa
#define DWORD_FROM_FLOAT(fp) (*(NvU32 *)&(fp))
#define FLOAT_FROM_DWORD(dw) (*(float *)&(dw))

#define FP_SIGN_BIT(fp) (DWORD_FROM_FLOAT(fp)&0x80000000)
#define FP_ABS_BITS(fp) (DWORD_FROM_FLOAT(fp)&0x7FFFFFFF)
#define FP_EXP_BITS(fp) (DWORD_FROM_FLOAT(fp)&0x7F800000)
#define FP_MAN_BITS(fp) (DWORD_FROM_FLOAT(fp)&0x007FFFFF)

#define FP_EXP_VAL(fp)  (FP_EXP_BITS(fp) >> 27)
#define FP_MAN_VAL(fp)  (FP_MAN_BITS(fp) >>  0)

#define FP_ONE_BITS          0x3F800000
#define FP_INFINITY_BITS     0x7F800000
#define FP_MIN_INFINITY_BITS 0xFF800000

// ================================================================
// Fun with Powers of 2
// ================================================================

// returns the index of the least significant bit = log2(x) if x=2^n
#define ASM_LOG2(x)     __asm mov eax,[x]   __asm bsf ecx,eax   __asm mov [x],ecx
// returns the index of the most significant bit = log2(x) if x=2^n
#define ASM_LOG2_R(x)   __asm mov eax,[x]   __asm bsr ecx,eax   __asm mov [x],ecx

// ================================================================
// Our very own string utils
// ================================================================
// NV string routines necessary because the analogs don't exist under NT. ugh.

EXTERN_C int   __cdecl nvStrCmp     (char *szStr1, char *szStr2);
EXTERN_C int   __cdecl nvStrLen     (char *szStr);
EXTERN_C int   __cdecl nvStrNLen    (char *szStr, int n);
EXTERN_C void  __cdecl nvStrCpy     (char *szDst, char *szSrc);
EXTERN_C void  __cdecl nvStrNCpy    (char *szDst, char *szSrc, int n);
EXTERN_C void  __cdecl nvStrCat     (char *szStr1, char *szStr2);
EXTERN_C char* __cdecl nvStrChr     (char *szStr, NvU8 c);
EXTERN_C char* __cdecl nvStrRChr    (char *szStr, NvU8 c);
EXTERN_C void  __cdecl nvSprintfVAL (char *szDest, char *szFormat, va_list vaArgs);
EXTERN_C void  __cdecl nvSprintf    (char *szDest, char *szFormat, ...);

EXTERN_C NvU32 nvGetCurrentProcessId();
EXTERN_C void  nvQueryPerformanceCounter(__int64  *pPerformanceCount);

// This is the same as nvDelay, but takes a parameter instead of referencing a global
EXTERN_C void nvSpin(NvU32 loopCount);

#endif  // !_NVUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\common\inc\nvUniversal.h ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-2000 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/
#ifndef _NVUNIVERSAL_H_
#define _NVUNIVERSAL_H_

#include "nvtypes.h"

/*==========================================================================;
 *
 *  File:       NvUniversal.h
 *
 *  Content:    Defines, constants, macros, and miscellaneous constructs that
 *              are commonly needed across all operating system platforms.
 *
 *              If the code is specific to Windows, or Mac, or Linux it doesn't
 *              go here.
 *
 ***************************************************************************/

#ifndef NVARCH
#error NVARCH must be defined. Definition of NV3, NV4, NV10, etc. is obsolete.
ERROR! NVARCH must be defined. Definition of NV3, NV4, NV10, etc. is obsolete.
#endif

// TBD: have everyone use this from here... -mlavoie
#if 0
#if (NVARCH >= 0x04)
#define NV_IN_PROGRESS          0x8000
#else
#define NV_IN_PROGRESS          0xFF
#endif
#endif

// TBD: move device version (and other appropos stuff) into this @mjl@
typedef struct _NVD3D_PERFDATA
{
    // bank
    NvU32 dwCPUFeatureSet;
    NvU32 dwProcessorSpeed;
    NvU32 dwSystemMemory;                   // MB of system memory, rounded to the nearest 8
    NvU32 dwNVClasses;
    NvU32 dwNVClasses1;
    NvU32 dwPerformanceStrategy;
    NvU32 dwSpinLoopCount;
    NvU32 dwPad_0[1];
    // bank
    NvU32 dwRecommendedPushBufferSize;      // default pusher size in BYTES
    NvU32 dwRecommendedStageBufferSize;     // default stage buffer size in BYTES
    NvU32 dwRecommendedPCITexHeapSize;      // recommended size of PCI texture heap in BYTES
    NvU32 dwMaxTextureSize;
    NvU32 dwMaxVolumeTextureSize;
    NvU32 dwHaveVolumeTextures;             // RM tells us if we do
    NvU32 dwHaveAALines;
    NvU32 dwHaveAnisotropic;
} NV_SystemInfo_t;

//---------------------------------------------------------------------------
// perf data

// nvD3DPerfData.dwCPUFeatureSet
#define FS_MMX              0x00000001      // ) do not change - some code
#define FS_KATMAI           0x00000002      //  )          relies on the macros to match these numbers
#define FS_3DNOW            0x00000004      // )
#define FS_HALFFASTWRITE    0x00000008      // camino with agp4x and 1/2 nv fast writes
#define FS_FULLFASTWRITE    0x00000010      // camino with agp4x and 1/1 nv fast writes
#define FS_WILLAMETTE       0x00000020      //  Pentium 4 support
#define FS_ATHLON           0x00000040      // AMD Athlon
#define FS_PREFETCH         0x00000080      // supports prefetchNTA, prefetchT0, movntq
#define FS_SFENCE           0x00001000      // has sfence support
#define FS_64BIT            0x00008000      // 64-bit back end (VANTA)
#define FS_PCIBUS           0x00010000      // PCI Bus

// nvD3DPerfData.dwPerformanceStrategy
#define PS_TEXTURE_RENAME       0x00000001  // allow textures to be renamed
#define PS_TEXTURE_USEHW        0x00000002  // allow HW to swizzle (better for lower back-end bandwidth)
#define PS_TEXTURE_PREFER_AGP   0x00000004  // put textures in AGP first (expensive blt to HW)
#define PS_CONTROL_TRAFFIC_16   0x00000008  // allow CPU to control back-end bus traffic
#define PS_CONTROL_TRAFFIC_32   0x00000010  // allow CPU to control back-end bus traffic
#define PS_VB_RENAME            0x00000020  // allow vertex buffers to be renamed
#define PS_VB_PREFER_AGP        0x00000040  // put VBs in agp
#define PS_PUSH_VID             0x00000080  // put push buffer & default VB in video memory
#define PS_SUPERTRI             0x00000100  // super triangle processing
#define PS_MUSH                 0x00000200  // limit performance
#define PS_AUTOPALETTE          0x00000400  // auto-palettize 32 bit textures with 256 colours or less
#define PS_ST_XFORMCLIP         0x00000800  // super triangle - transform and clip check
#define PS_ST_MODEL             0x00001000  // super tri - model space cull
#define PS_ALT_STENCIL          0x00002000  // alternate stencil mode
#define PS_CT_11M               0x00004000  // special CT mode for NV11M

#define PS_ST_MASK              (PS_ST_XFORMCLIP | PS_ST_MODEL)

//---------------------------------------------------------------------------

// nvD3DPerfData.dwCPUFeatureSet
#define CPU_FS_MMX              0x00000001      // ) do not change - some code
#define CPU_FS_KATMAI           0x00000002      //  )          relies on the macros to match these numbers
#define CPU_FS_3DNOW            0x00000004      // )
#define CPU_FS_HALFFASTWRITE    0x00000008      // camino with agp4x and 1/2 nv fast writes
#define CPU_FS_FULLFASTWRITE    0x00000010      // camino with agp4x and 1/1 nv fast writes
#define CPU_FS_WILLAMETTE       0x00000020      //  Pentium 4 support
#define CPU_FS_ATHLON           0x00000040      // AMD Athlon
#define CPU_FS_PREFETCH         0x00000080      // supports prefetchNTA, prefetchT0, movntq
#define CPU_FS_SFENCE           0x00001000      // has sfence support
#define CPU_FS_64BIT            0x00008000      // 64-bit back end (VANTA)

// These are IDs used to identify the last module to use a given object (if more than one
// module (subsystem) is using a given object in the same channel.
//
#define MODULE_ID_NONE                 0  // No subsystem has yet used the object
#define MODULE_ID_D3D                  1
#define MODULE_ID_DDRAW                2
#define MODULE_ID_DDRAW_VPP            3

// NV_SYSTEM_INFO.dwNVClasses
// ordered from "worst" to "best" within each class
#define NVCLASS_0055_DX6TRI     0x00000001
#define NVCLASS_0095_DX6TRI     0x00000002

#define NVCLASS_0054_DX5TRI     0x00000004
#define NVCLASS_0094_DX5TRI     0x00000008

#define NVCLASS_0056_CELSIUS    0x00000010
#define NVCLASS_0096_CELSIUS    0x00000020
#define NVCLASS_1196_CELSIUS    0x00000040

#define NVCLASS_0097_KELVIN     0x00000080

#define NVCLASS_0046_DAC        0x00000100
#define NVCLASS_0049_DAC        0x00000200
#define NVCLASS_0067_DAC        0x00000400
#define NVCLASS_007C_DAC        0x00000800

#define NVCLASS_0042_CTXSURF2D  0x00001000
#define NVCLASS_0062_CTXSURF2D  0x00002000

#define NVCLASS_0060_IDXIMAGE   0x00004000
#define NVCLASS_0064_IDXIMAGE   0x00008000

#define NVCLASS_0077_SCALEDIMG  0x00010000
#define NVCLASS_0063_SCALEDIMG  0x00020000
#define NVCLASS_0089_SCALEDIMG  0x00040000

#define NVCLASS_0038_DVDPICT    0x00100000
#define NVCLASS_0088_DVDPICT    0x00200000

#define NVCLASS_007A_OVERLAY    0x00400000

#define NVCLASS_0053_CTXSURF3D  0x01000000
#define NVCLASS_0093_CTXSURF3D  0x02000000

#define NVCLASS_004A_GDIRECT    0x04000000
#define NVCLASS_005E_SOLIDRECT  0x08000000

#define NVCLASS_0052_CTXSURFSWZ 0x10000000
#define NVCLASS_009E_CTXSURFSWZ 0x20000000
#define NVCLASS_0004_TIMER      0x40000000

// class 0 collectives
#define NVCLASS_FAMILY_DXTRI    (NVCLASS_0094_DX5TRI  | NVCLASS_0054_DX5TRI  | NVCLASS_0095_DX6TRI | NVCLASS_0055_DX6TRI)
#define NVCLASS_FAMILY_CELSIUS  (NVCLASS_0056_CELSIUS | NVCLASS_0096_CELSIUS | NVCLASS_1196_CELSIUS)
#define NVCLASS_FAMILY_KELVIN   (NVCLASS_0097_KELVIN)

// NV_SYSTEM_INFO.dwNVClasses1
// ordered from "worst" to "best" within each class
#define NVCLASS1_006C_CHANNELDMA 0x00000001
#define NVCLASS1_006E_CHANNELDMA 0x00000002
#define NVCLASS1_206E_CHANNELDMA 0x00000004

// class 1 collectives
// none yet

#define SUB_CHANNEL(I) (I * 0x00002000) // Computes subchannel offset given a simple ndx 0-7

// Convert Microsoft Specific modifier (not available on all MS compilers either)
#if defined(__forceinline)
#define FORCE_INLINE __forceinline
#else
#define FORCE_INLINE inline
#endif

#endif // _NVUNIVERSAL_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\common\inc\nvVer.h ===
// nvver.h
//      Versions of NV drivers
//
// Copyright (C) Microsoft Corporation 1993.
// Portions Copyright 1993,1996 NVidia Corporation. All Rights Reserved.
//

// The following version numbers are owned by Microsoft.  We have permission
// to change the last 3 digits of each version string but no other digits
// until the next major Microsoft release.
//
// NOTE: This release must be bumped up to 4.10... (0x040A...) when starting
// to build Win98 drivers
//
//
// The following #defines are used for the driver version number. They should be
// updated for each build and they should agree with each other.
//
// Also, because NV_DRIVER_VERSION has a leading 0, it can't be used as a number
// in drivers (it'll be interpretted as octal). And since it does contain non-octal
// values drivers should use NV_DRIVER_VERSION_NUMBER instead.
//
#ifndef WIN31
#define NV_DRIVER_VERSION              1440
#endif
#define NV_DRIVER_VERSION_NUMBER       1440
#define NV_VERSION_NUMBER               4,13,01,NV_DRIVER_VERSION
#define NV_VERSION_NUMBER_NT4           4,00,1381,NV_DRIVER_VERSION
#define NV_VERSION_NUMBER_NT5           5,13,01,NV_DRIVER_VERSION
#define NV_VERSION_NUMBER_DW            (0x0413010 | NV_DRIVER_VERSION)
#define NV_VERSION_STRING              "14.40"
#define NV_VERSION_MS_STRING           "4.13.01.1440\0"
#define NV_VERSION_MS_STRING_NT4       "4.00.1381.1440\0"
#define NV_VERSION_MS_STRING_NT5       "5.13.01.1440\0"

#define NV_COMPANY_NAME_STRING_SHORT    "NVIDIA"
#define NV_COMPANY_NAME_STRING_FULL     "NVIDIA Corporation"
#define NV_COMPANY_NAME_STRING          NV_COMPANY_NAME_STRING_FULL

#define NV04_PART_NAME_STRING           "RIVA TNT"
#define NV05_PART_NAME_STRING           "RIVA TNT2"
#define NV10_PART_NAME_STRING           "GeForce 256"
#define NV10GL_PART_NAME_STRING         "Quadro"
#define NV11_PART_NAME_STRING           "GeForce2 MX"
#define NV11GL_PART_NAME_STRING         "Quadro2 MXR"
#define NV15_PART_NAME_STRING           "GeForce2 GTS"
#define NV15GL_PART_NAME_STRING         "Quadro2 Pro"
#define NV20_PART_NAME_STRING           "GeForce3"
#define NV04_COMPAT_PART_NAME_STRING    NV_COMPANY_NAME_STRING_SHORT " Compatible"

#define NV_PART_NAME_STRING             NV04_COMPAT_PART_NAME_STRING



// #define MSBLD               // Defined for MS source builds only
                               // comment out for NVidia builds.
#ifndef MSBLD
#ifndef WIN32
#define VERSION                     NV_VERSION_MS_STRING
#endif


#ifndef _WIN32_WINNT
//
// Use NVidia standard version numbers for Win9x builds.
//
#define VER_PRODUCTVERSION_STR      NV_VERSION_MS_STRING
#define VER_PRODUCTVERSION          NV_VERSION_NUMBER
#define VER_PRODUCTVERSION_DW       NV_VERSION_NUMBER_DW
#else

//
// Use "standard" NT version numbers.
//
#include "ntverp.h"
#endif // #ifdef _WIN32_WINNT
#endif // #ifdef MSBLD




//
// NVDISP.drv NVidia Display Driver
//          Please update version in string below, DO NOT change
//          string, just the Number after Version.  It should
//          always look like this
//                  "NVidia Display driver, Version X.XX\0"
//
#define NV_NVDISPVER95  NV_PART_NAME_STRING " Windows 95/98 Display driver, Version " NV_VERSION_STRING " \0"

//
//

//
// NV.vxd NVidia Display MiniVDD
//          Please update version in string below, DO NOT change
//          string, just the Number after Version.  It should
//          always look like this
//                  "NVidia Display MiniVDD, Version X.XX\0"
//
#define NV_NVVDDVER     NV_PART_NAME_STRING " Display MiniVDD, Version " NV_VERSION_STRING " \0"
//
//


//
// NVDD32.DLL NVidia Direct Draw Driver
//          Please update version in string below, DO NOT change
//          string, just the Number after Version.  It should
//          always look like this
//                  "NVidia Direct Draw Driver, Version X.XX\0"
//
#define NV_NVDD32VER    NV_PART_NAME_STRING " Direct Draw Driver, Version " NV_VERSION_STRING " \0"
//
//
//
// NVCPL.DLL NVidia Control Panel Extension
//          Please update version in string below, DO NOT change
//          string, just the Number after Version.  It should
//          always look like this
//                  "NVidia Direct Draw Driver, Version X.XX\0"
//
#define NV_NVCPLVER    NV_COMPANY_NAME_STRING_SHORT " Display Properties Extension\0"


// NVQTWK.DLL NVidia Taskbar Utility Library
//          Please update version in string below, DO NOT change
//          string, just the Number after Version.  It should
//          always look like this
//                  "NVidia Direct Draw Driver, Version X.XX\0"
//
#define NV_NVTASKBARVER   NV_COMPANY_NAME_STRING_SHORT " Taskbar Utility Library\0"


// NVDESK32.DLL NVidia Desktop Manager Library
//          Please update version in string below, DO NOT change
//          string, just the Number after Version.  It should
//          always look like this
//                  "NVidia Direct Draw Driver, Version X.XX\0"
//
#define NV_NVDESKMGRVER   NV_COMPANY_NAME_STRING_SHORT " Desktop Manager Hook Library\0"


// NVSTERCP.DLL NVidia Stereo Control Panel
//          Please update version in string below, DO NOT change
//          string, just the Number after Version.  It should
//          always look like this
//                  "NVidia Direct Draw Driver, Version X.XX\0"
//
#define NV_NVSTERCPVER   NV_COMPANY_NAME_STRING_SHORT " Stereo Properties Extension\0"


// NVSVC*.DLL NVIDIA Driver Helper Service
//          Please update version in string below, DO NOT change
//          string, just the Number after Version.  It should
//          always look like this
//                  "NVidia Direct Draw Driver, Version X.XX\0"
//
#define NV_NVSVCVER   NV_COMPANY_NAME_STRING_SHORT " Driver Helper Service, Version " NV_VERSION_STRING "\0"


//
// NVDCI.drv NVidia DCI Driver
//          Please update version in string below, DO NOT change
//          string, just the Number after Version.  It should
//          always look like this
//                  "NVidia DCI driver, Version X.XX\0"
//
#define NV_NVDCIVER     NV_PART_NAME_STRING " DCI driver, Version " NV_VERSION_STRING " \0"
//
//

//
//
//
// NVINST32.DLL NVidia Driver Installation Library
//          Please update version in string below, DO NOT change
//          string, just the Number after Version.  It should
//          always look like this
//                  "NVidia Driver Insatllation Library, Version X.XX\0"
//
#define NV_NVINST32VER      NV_PART_NAME_STRING " Driver Install Library, Version " NV_VERSION_STRING " \0"

//
//
//
// NVINSTNT.DLL NVidia Driver Installation Library
//          Please update version in string below, DO NOT change
//          string, just the Number after Version.  It should
//          always look like this
//                  "NVidia Driver Insatllation Library, Version X.XX\0"
//
#define NV_NVINSTNTVER      NV_PART_NAME_STRING " Driver Install Library, Version " NV_VERSION_STRING " \0"

//
// NVRM NVidia Resource Manager
//          Please update version in string below, DO NOT change
//          string, just the Number after Version.  It should
//          always look like this
//                  "NVidia Resource Manager DLL, Version X.XX\0"
//
#define NV_NVRMVER      NV_PART_NAME_STRING " Resource Manager, Version " NV_VERSION_STRING " \0"
//
//


//
//
//
// NVDD32.DLL NVidia Direct Draw/Direct 3D Driver
//          Please update version in string below, DO NOT change
//          string, just the Number after Version.  It should
//          always look like this
//                  "NVidia Direct Draw 2.x Driver, Version X.XX\0"
//
//#define NV_D3D32VER     NV_PART_NAME_STRING " Direct Draw/Direct 3D Driver, Version " NV_VERSION_STRING " \0"
#define NV_DD32VER      NV_PART_NAME_STRING " Direct Draw/Direct 3D Driver, Version " NV_VERSION_STRING " \0"

//
//
//
// NV4_MINI.SYS NVidia Windows NT Miniport Driver
//          Please update version in string below, DO NOT change
//          string, just the Number after Version.  It should
//          always look like this
//                  "NVidia Windows NT Miniport Driver, Version X.XX\0"
//
#ifdef _WIN32_WINNT
#if (_WIN32_WINNT < 0x0500)
#define NV_NTMINIVER    NV_PART_NAME_STRING " Windows NT 4.0 Miniport Driver, Version " NV_VERSION_STRING " \0"
#else
#define NV_NTMINIVER    NV_PART_NAME_STRING " Windows 2000 Miniport Driver, Version " NV_VERSION_STRING " \0"
#endif // #else
#endif // #ifdef _WIN32_WINNT

//
//
//
// NV4_DISP.DLL NVidia Windows NT Display Driver
//          Please update version in string below, DO NOT change
//          string, just the Number after Version.  It should
//          always look like this
//                  "NVidia Windows NT Display Driver, Version X.XX\0"
//
#ifdef _WIN32_WINNT
#if (_WIN32_WINNT < 0x0500)
#define NV_NTDISPVER    NV_PART_NAME_STRING " Windows NT 4.0 Display driver, Version " NV_VERSION_STRING " \0"
#else
#define NV_NTDISPVER    NV_PART_NAME_STRING " Windows 2000 Display driver, Version " NV_VERSION_STRING " \0"
#endif // #else
#endif // #ifdef _WIN32_WINNT
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\common\inc\nv_name.h ===
typedef struct _CHIP_INFO
{
	ULONG   ulDevID;
	PWSTR   pwszChip;
	PWSTR   pwszAdapterString;
} CHIP_INFO;

CHIP_INFO   sChipInfo[] =
{
 // DEVICE ID  Chip ID name              Adapter ID Name
{0x0020,	L"RIVA TNT",		L"RIVA TNT"		},
{0x0028,	L"RIVA TNT2",		L"RIVA TNT2"		},
{0x002C,	L"Vanta",		L"Vanta"		},
{0x0029,	L"RIVA TNT2 Ultra",	L"RIVA TNT2 Ultra"	},
{0x002D,	L"RIVA TNT2 Model 64",	L"RIVA TNT2 Model 64"	},
{0x00A0,	L"Aladdin TNT2",	L"Aladdin TNT2"		},
{0x0100,	L"GeForce 256",		L"GeForce 256"		},
{0x0101,	L"GeForce DDR",		L"GeForce DDR"		},
{0x0103,	L"Quadro",		L"Quadro"		},
{0x0110,	L"GeForce2 MX",		L"GeForce2 MX"		},
{0x0111,	L"GeForce2 MX 100",	L"GeForce2 MX 100"	},
{0x0113,	L"Quadro2 MXR",		L"Quadro2 MXR"		},
{0x01A0,	L"GeForce2 Integrated GPU",	L"GeForce2 Integrated GPU"	},
{0x0150,	L"GeForce2 GTS",	L"GeForce2 GTS"		},
{0x0151,	L"GeForce2 GTS",	L"GeForce2 GTS"		},
{0x0152,	L"GeForce2 Ultra",	L"GeForce2 Ultra"	},
{0x0153,	L"Quadro2 Pro",		L"Quadro2 Pro"		},
{0x0200,	L"GeForce3",		L"GeForce3"		},
{0x0203,	L"Quadro DCC",		L"Quadro DCC"		},
{0x0112,	L"GeForce2 Go",		L"GeForce2 Go"	}
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\common\inc\OEMSupport.h ===
/**************************************************************
 * File:	OEMSupport.h
 * Descr:	Has definitions for any OEM specific features
 *		    such as NT4.0 power management for gateway etc..
 **************************************************************/


//
// Following are the definitions and escape call to support NT4.0 power management for Gateway.
// Escape call made by NVSVC to set the power state.
// Input: ULONG:    Indicating the "PowerEvent". 
//                  For nVidia, this can be either POWER_EVENT_SUSPEND or POWER_EVENT_RESUME_NORMAL.
// Output: None: The call is always assumed to pass.
//
#define NV_ESC_GW_NT40_PM  0x7012

//
// possible values for 'PowerEvent' above
//
#define	POWER_EVENT_QUERY_SUSPEND	0x01
#define	POWER_EVENT_SUSPEND		0x02
#define	POWER_EVENT_RESUME_CRITICAL	0x03
#define	POWER_EVENT_RESUME_NORMAL	0x03

//
// The registry entry "APMSupport" will control if the NT4.0 APM support features are enabled for 
// a specific OEM. Possible values are given below
//
#define APM_SUPPORT_REGENTRY "APMSupport"
#define APM_SUPPORT_NONE    0
#define APM_SUPPORT_GATEWAY 1
#define APM_SUPPORT_IBM     2
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\common\inc\popupagent.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright 1993-2001 NVIDIA, Corporation.  All rights reserved.
// THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
// NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
// IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION
//
// Module: pupagent.h
//
// Description: This header describes the API for creating a popup tool
//				that works with the NVIDIA Stereo Driver.
//
///////////////////////////////////////////////////////////////////////////////
#ifndef		STEREO_POPUP_AGENTS_DECL
#define		STEREO_POPUP_AGENTS_DECL

#include "StereoStats.h"
#include <windows.h>

///////////////////////////////////////////////////////////
// Forward declarations
//////////////////////////////////////////////////////////
class CPopupAgentBase;
class CVertexBuffer;
class CVertexShader;

class Vertex {
public:
	float sx; /* Screen coordinates */
	float sy;
	float sz;
	float rhw; /* Reciprocal of homogeneous w */
	DWORD color; /* Vertex color */
	DWORD specular; /* Specular component of vertex */
	float tu; /* Texture coordinates */
	float tv;
};

#define D3DFVF_POPUP_VERTEX (D3DFVF_XYZRHW|D3DFVF_DIFFUSE|D3DFVF_SPECULAR|D3DFVF_TEX1)

///////////////////////////////////////////////////////////
// Function prototypes
///////////////////////////////////////////////////////////
// Callback for each flip
typedef HRESULT (__cdecl *FlipCallbackType)(CPopupAgentBase *pPopupAgent);

// Function defined by the agent provider and accessed/called by the driver to enable the popup
typedef HRESULT (__cdecl *InitPopupAgentType)(CPopupAgentBase *pPopupAgent);
typedef HRESULT (__cdecl *DestroyPopupAgentType)(CPopupAgentBase *pPopupAgent);

///////////////////////////////////////////////////////////
// Flags
///////////////////////////////////////////////////////////
#define RTF_NOTEXTURE 1 // This flag tells the RenderTriangle(...) call to not use the texture when rendering the triangles

///////////////////////////////////////////////////////////
// CPopupAgent: Interface specification for the popup 
// agent, holds all of the information passed from the 
// driver to the external popup code.
///////////////////////////////////////////////////////////
class CPopupAgentBase {
public:
	enum // Popup Agent IDs. Used to distinguish the type of the agent.
	{
		LASER_SIGHT_ID		= 1,   
		NVIDIA_LOGO_ID		= 2,
		PERF_STATS_ID		= 3,
		STEREO_STATS_ID		= 4,
		MESSENGER_ID		= 5,
		CUSTOM_ID			= 9999,
		UNKNOWN_ID			= 0xFFFFFFFF
	};
public:
	CPopupAgentBase() : m_pvUserData(NULL), m_dwAgentID(UNKNOWN_ID), m_pNextAgent(NULL), m_dwTexture(0), m_pFlipCallback(NULL) {}

	// Sets the callback called every frame, this is where the agent will do the drawing
	void SetFlipCallback(FlipCallbackType pFlipCallback) {m_pFlipCallback = pFlipCallback;}
	FlipCallbackType GetFlipCallback() {return(m_pFlipCallback);}

	// User data functions
	void*					GetUserData() {return(m_pvUserData);}
	void					SetUserData(void *pvUserData) {m_pvUserData = pvUserData;}
	// Agent IDs allowing multiple agent providers
	DWORD					GetAgentID() {return(m_dwAgentID);}
	//void					SetAgentID(DWORD dwAgentID) {m_dwAgentID = dwAgentID;}
	CPopupAgentBase*		GetNextAgent() {return m_pNextAgent;};
    void                    SetNextAgent(CPopupAgentBase* pThat) {m_pNextAgent = pThat;};
	// Create the 16bit texture map available from the driver, initialize it with pusData
	virtual HRESULT			CreateTextureMap(DWORD dwWidth, DWORD dwHeight, DWORD dwColorKey, unsigned short *pusData) = 0;
	// Call through to the driver to render triangles
	virtual HRESULT			RenderTriangles(Vertex *pVertexData, unsigned short *pusIndexData, int nIndexCount, DWORD dwFlags) = 0;

protected:
	void                   *m_pvUserData;
	DWORD                   m_dwAgentID;
	CPopupAgentBase        *m_pNextAgent; // Points to the next agent in the list
	DWORD                   m_dwTexture;
	FlipCallbackType        m_pFlipCallback;
};

class CTexture;
class CNvObject;

class CPopupAgent : public CPopupAgentBase 
{
protected: //attributes
	CTexture*				pTexture;
	CNvObject*				pTextureObj;
	NVD3DCONTEXT*			pContext;
	HMODULE					hMod;
	CVertexBuffer*			pVB;
	CVertexShader*			pVS;
protected: //methods
	void					destroyTexture();
	void					destroyVertexData();
	HRESULT					createVertexData();
	HRESULT					setupStates(DWORD dwFlags);
	HRESULT					restoreStates(DWORD dwFlags);

public: //methods
	CPopupAgent();
	virtual ~CPopupAgent();
	
    HRESULT         bindPopupAgent( HMODULE hmod );
	HRESULT			unbindPopupAgent( );
	void			setContext(NVD3DCONTEXT* aContext) {pContext = aContext;};
	
	virtual HRESULT CreateTextureMap(DWORD dwWidth, DWORD dwHeight, DWORD dwColorKey, unsigned short *pusData);
	virtual HRESULT RenderTriangles(Vertex *pVertexData, unsigned short *pusIndexData, int nIndexCount, DWORD dwFlags);
};
/*
class CPerfStatPopup: public CPopupAgent, protected STEREOSTATS  
{
public:
	CPerfStatPopup();
	virtual ~CPerfStatPopup();
	
	STEREOSTATS*	get() {return (STEREOSTATS*)this;}; 
	void			setContext(NVD3DCONTEXT* aContext); //extract performance data from context
};

class CPopupAgentList
{
protected:
	CPopupAgent*	popupAgentList;
public:
	CPopupAgentList();
	~CPopupAgentList();
	HRESULT			create();
	HRESULT			destroy();
	HRESULT			render(NVD3DCONTEXT *pContext);
};
  */
  /*
//exported functions (to nvStereo.cpp)
extern	HRESULT			createPopupList();
extern	HRESULT			destroyPopupList();
extern	HRESULT			renderPopupList(NVD3DCONTEXT *pContext);
*/
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\common\inc\targa.h ===
// **************************************************************************
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// ********************************* Direct 3D ******************************
//
//  Module: targa.h
//      header files for targa.c
//
// **************************************************************************
//
//  History:
//      Craig Duttweiler        12Jun00         filched from architects
//
// **************************************************************************

#ifndef __TARGA_H
#define __TARGA_H

typedef char int8;
typedef int int16;
typedef int int32;
typedef unsigned char uint8;
typedef unsigned int uint16;
typedef unsigned int uint32;

/* Header definition. */
typedef struct TGA_Header_  {
    unsigned char ImageIDLength;        /* length of Identifier String. */
    unsigned char CoMapType;            /* 0 = no map */
    unsigned char ImgType;              /* image type (see below for values) */
    unsigned char Index_lo, Index_hi;   /* index of first color map entry */
    unsigned char Length_lo, Length_hi; /* number of entries in color map */
    unsigned char CoSize;               /* size of color map entry (15,16,24,32) */
    unsigned char X_org_lo, X_org_hi;   /* x origin of image */
    unsigned char Y_org_lo, Y_org_hi;   /* y origin of image */
    unsigned char Width_lo, Width_hi;   /* width of image */
    unsigned char Height_lo, Height_hi; /* height of image */
    unsigned char PixelSize;            /* pixel size (8,16,24,32) */
    unsigned char Desc;         /* 4 bits, number of attribute bits per pixel */
} TGA_Header;

/* if we create the tga file, we will put the following in the ImageID field */
typedef struct TGA_ImageId_ {
        unsigned char Magic;            /* must be a specific magic value */
        unsigned char ImageFmt;         /* encodes special raster formats */
} TGA_ImageId;

/* Definitions for image types. */
#define TGA_NULL 0
#define TGA_MAP 1
#define TGA_RGB 2
#define TGA_MONO 3
#define TGA_RLEMAP 9
#define TGA_RLERGB 10
#define TGA_RLEMONO 11

#define TGA_DESC_ALPHA_MASK     ((unsigned char)0xF)    /* number of alpha channel bits */
#define TGA_DESC_ORG_MASK       ((unsigned char)0x30)   /* origin mask */
#define TGA_ORG_BOTTOM_LEFT     0x00
#define TGA_ORG_BOTTOM_RIGHT    0x10
#define TGA_ORG_TOP_LEFT        0x20
#define TGA_ORG_TOP_RIGHT       0x30har)0x30)   /* origin mask */
#define TGA_ORG_BOTTOM_LEFT     0x00
#define TGA_ORG_BOTTOM_RIGHT    0x10

#define TGA_NVIDIA_MAGIC        0xAF            /* not an ascii char so unlikely... */

typedef enum RasterFormat_ {
/* WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING
 * **** The RasterFormat defs _must_ be identical to the defs in vmodels/rasterDefs.vh ***
 * **** Do not change this enum without also updating rasterDefs.vh!                   ***
 * WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING */
        RASTER_A1R5G5B5 = 0,
        RASTER_X1R5G5B5 = 1,
        RASTER_A4R4G4B4 = 2,
        RASTER_R5G6B5 = 3,
        RASTER_A8R8G8B8 = 4,
        RASTER_X8R8G8B8 = 5,
        RASTER_Y8 = 6,
        RASTER_V8YB8U8YA8 = 7,
        RASTER_YB8V8YA8U8 = 8,
        RASTER_A8V8U8Y8 = 9,                    // A8Y8U8V8 was incorrect channel ordering, name changed
        RASTER_A4V6YB6A4U6YA6 = 10,
        RASTER_AY8 = 11,
        RASTER_Z16 = 12,                                // 16 bit Z/W buffer
        RASTER_Z24S8 = 13,                              // 24 bit Z/W plus 8 bit stencil in low 8 bits
// additional non-Nvidia formats for ease of use with tga
        RASTER_VOID32 = 100,                    // generic 32 bits/pixel format
        RASTER_R8G8B8 = 101,                    // 24 bits/pixel
        RASTER_VOID16 = 102,                    // generic 16 bits/pixel format
        RASTER_FORCELONG = 0x7FFFFFFFL  // force this enum to be a long
} RasterFormat;

// Read targa file "filename"
// Put pixels into **xbgr, and set *width and *height
// Pixels are xbgr words on the PC
// This routine copes with raw RGB and run-length encoded RGB targa files only

int read_targa_file(char *filename, unsigned char **xrgb, int *width, int *height);

#endif  // __TARGA_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\common\inc\vtxpgmcomp.h ===
/*
** vtxpgmcomp.h
**
** Vertex Program Declarations.
**
** Copyright 2000 NVIDIA, Corporation.  All rights reserved.
**
** THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
** NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
** IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
*/

/*
** This file is shared between OpenGL and D3D so don't mess with it!
**
** In particular, don't use any OpenGL or D3D specific types.  There are
** plenty of perfectly good types in the C language itself.
**
*/

#ifndef __gl_vtxpgmcomp_h_
#define __gl_vtxpgmcomp_h_

#include "vtxpgmconsts.h"

#define NV_INTERNAL_OPCODES 1

/*
** Optimization flags:
*/

#define OPT_LIVE_DEAD 1
#define OPT_HPOS_ONLY 2
#define OPT_ALL       1

/*
** Structures for instruction description.
*/

typedef enum OpcodeClasses_Enum {
    CLASS_ARL = 0,
    CLASS_VECTOR,
    CLASS_SCALAR,
    CLASS_BIN,
    CLASS_TRI,
#if defined(NV_INTERNAL_OPCODES)
    CLASS_NOP,
#endif
    CLASS_END,
} OpcodeClasses;

typedef enum Opcodes_Enum {

    // END op:

    OP_END = 0,
#if defined(NV_INTERNAL_OPCODES)
    OP_NOP,
#endif

    // ARL op:

    OP_ARL,

    // VECTOR ops:

    OP_LIT, OP_MOV,
#if defined(NV_INTERNAL_OPCODES)
    OP_IMV,
#endif

    // SCALAR ops:

    OP_EXP, OP_LOG, OP_RCP, OP_RSQ,
#if defined(NV_INTERNAL_OPCODES)
    OP_RCC,
#endif

    // BIN ops:

    OP_ADD, OP_DP3, OP_DP4, OP_DST, OP_MAX, OP_MIN, OP_MUL, OP_SGE, OP_SLT,
#if defined(NV_INTERNAL_OPCODES)
    OP_DPH,
#endif

    // TRI op:

    OP_MAD,
} Opcodes;

#define VERTEX_PROGRAM_OPCODE_NAMES                                         \
    "END", "NOP",                                                           \
    "ARL",                                                                  \
    "LIT", "MOV", "IMV",                                                    \
    "EXP", "LOG", "RCP", "RSQ", "RCC",                                      \
    "ADD", "DP3", "DP4", "DST", "MAX", "MIN", "MUL", "SGE", "SLT", "DPH",   \
    "MAD",

typedef enum Component_Enum {
    XX = 0, YY, ZZ, WW,
} Component_t;

typedef enum Component4_Enum {
    XYZW = (XX | YY << 2 | ZZ << 4 | WW << 6),
} Component4;

typedef enum DestMaskBits_Enum {
    DST_NONE_BITS = 0,
    DST_X_BIT = 1, DST_Y_BIT = 2, DST_Z_BIT = 4, DST_W_BIT = 8,
    DST_YZ_BITS = 6,
    DST_XYZ_BITS = 7,
    DST_XYW_BITS = 11,
    DST_XYZW_BITS = 15,
} DestMaskBits;

typedef enum Register_Enum {

    VA_0 = 0,   VA_OPOS = 0,  VA_1 = 1,   VA_WGHT = 1,
    VA_2 = 2,   VA_NRML = 2,  VA_3 = 3,   VA_COL0 = 3,
    VA_4 = 4,   VA_COL1 = 4,  VA_5 = 5,   VA_FOGC = 5,
    VA_6 = 6,                 VA_7 = 7,
    VA_8 = 8,   VA_TEX0 = 8,  VA_9 = 9,   VA_TEX1 = 9,
    VA_10 = 10, VA_TEX2 = 10, VA_11 = 11, VA_TEX3 = 11,
    VA_12 = 12, VA_TEX4 = 12, VA_13 = 13, VA_TEX5 = 13,
    VA_14 = 14, VA_TEX6 = 14, VA_15 = 15, VA_TEX7 = 15,

    VR_0 = 16,  VR_HPOS = VR_0,
    VR_1 = 17,  
    VR_2 = 18,  
    VR_3 = 19,  VR_COL0 = VR_3,
    VR_4 = 20,  VR_COL1 = VR_4,
    VR_5 = 21,  VR_FOGC = VR_5,
    VR_6 = 22,  VR_PSIZ = VR_6,
    VR_7 = 23,  VR_BFC0 = VR_7,
    VR_8 = 24,  VR_BFC1 = VR_8,
    VR_9 = 25,  VR_TEX0 = VR_9,
    VR_10 = 26, VR_TEX1 = VR_10,
    VR_11 = 27, VR_TEX2 = VR_11,
    VR_12 = 28, VR_TEX3 = VR_12,
    VR_13 = 29, VR_TEX4 = VR_13,
    VR_14 = 30, VR_TEX5 = VR_14,
    VR_15 = 31, VR_TEX6 = VR_15, VR_TEX7 = VR_15,

    PR_0 = 32,   PR_1 = 33,   PR_2 = 34,   PR_3 = 35,
    PR_4 = 36,   PR_5 = 37,   PR_6 = 38,   PR_7 = 39,
    PR_8 = 40,   PR_9 = 41,   PR_10 = 42,  PR_11 = 43,
    PR_12 = 44,  PR_13 = 45,  PR_14 = 46,  PR_15 = 47,
    PR_16 = 48,  PR_17 = 49,  PR_18 = 50,  PR_19 = 51,
    PR_20 = 52,  PR_21 = 53,  PR_22 = 54,  PR_23 = 55,
    PR_24 = 56,  PR_25 = 57,  PR_26 = 58,  PR_27 = 59,
    PR_28 = 60,  PR_29 = 61,  PR_30 = 62,  PR_31 = 63,
    PR_32 = 64,  PR_33 = 65,  PR_34 = 66,  PR_35 = 67,
    PR_36 = 68,  PR_37 = 69,  PR_38 = 70,  PR_39 = 71,
    PR_40 = 72,  PR_41 = 73,  PR_42 = 74,  PR_43 = 75,
    PR_44 = 76,  PR_45 = 77,  PR_46 = 78,  PR_47 = 79,
    PR_48 = 80,  PR_49 = 81,  PR_50 = 82,  PR_51 = 83,
    PR_52 = 84,  PR_53 = 85,  PR_54 = 86,  PR_55 = 87,
    PR_56 = 88,  PR_57 = 89,  PR_58 = 90,  PR_59 = 91,
    PR_60 = 92,  PR_61 = 93,  PR_62 = 94,  PR_63 = 95,
    PR_64 = 96,  PR_65 = 97,  PR_66 = 98,  PR_67 = 99,
    PR_68 = 100, PR_69 = 101, PR_70 = 102, PR_71 = 103,
    PR_72 = 104, PR_73 = 105, PR_74 = 106, PR_75 = 107,
    PR_76 = 108, PR_77 = 109, PR_78 = 110, PR_79 = 111,
    PR_80 = 112, PR_81 = 113, PR_82 = 114, PR_83 = 115,
    PR_84 = 116, PR_85 = 117, PR_86 = 118, PR_87 = 119,
    PR_88 = 120, PR_89 = 121, PR_90 = 122, PR_91 = 123,
    PR_92 = 124, PR_93 = 125, PR_94 = 126, PR_95 = 127,

    TR_0 = 128,  TR_1 = 129,  TR_2 = 130,  TR_3 = 131,
    TR_4 = 132,  TR_5 = 133,  TR_6 = 134,  TR_7 = 135,
    TR_8 = 136,  TR_9 = 137,  TR_10 = 138, TR_11 = 139,
    TR_12 = 140, TR_13 = 141, TR_14 = 142, TR_15 = 143,

    ARL = 144,

    ZER = 145,

    PPR_0 = 146, PPR_23 = 169, PPR_58 = 204, PPR_59 = 205, PPR_62 = 208,

} Register_t;

typedef struct SrcReg_Rec {
    Register_t reg;
    unsigned char AddrReg;
    int addrRegOffset;
} SrcReg;

typedef struct ScalarSrcReg_Rec {
    SrcReg reg;
    Component_t com;
    unsigned char Signed;
} ScalarSrcReg;

typedef struct SwizzleSrcReg_Rec {
    SrcReg reg;
    unsigned char com4;
    unsigned char Signed;
} SwizzleSrcReg;

typedef struct MaskedDstReg_Rec {
    Register_t reg;
    unsigned char mask;
} MaskedDstReg;

typedef struct Arl_Instruction_Rec {
    Opcodes opcode;
    OpcodeClasses opclass;

    ScalarSrcReg src;
} Arl_Instruction;

typedef struct Vector_Instruction_Rec {
    Opcodes opcode;
    OpcodeClasses opclass;

    MaskedDstReg dst;
    SwizzleSrcReg src;
} Vector_Instruction;

typedef struct Scalar_Instruction_Rec {
    Opcodes opcode;
    OpcodeClasses opclass;

    MaskedDstReg dst;
    ScalarSrcReg src;
} Scalar_Instruction;

typedef struct Bin_Instruction_Rec {
    Opcodes opcode;
    OpcodeClasses opclass;

    MaskedDstReg dst;
    SwizzleSrcReg srcA;
    SwizzleSrcReg srcB;
} Bin_Instruction;

typedef struct Tri_Instruction_Rec {
    Opcodes opcode;
    OpcodeClasses opclass;

    MaskedDstReg dst;
    SwizzleSrcReg srcA;
    SwizzleSrcReg srcB;
    SwizzleSrcReg srcC;
} Tri_Instruction;

typedef struct End_Instruction_Rec {
    Opcodes opcode;
    OpcodeClasses opclass;
} End_Instruction;

typedef union Instruction_Rec {
    Arl_Instruction arl_op;
    Vector_Instruction vector_op;
    Scalar_Instruction scalar_op;
    Bin_Instruction bin_op;
    Tri_Instruction tri_op;
    End_Instruction end_op;
} Instruction;

typedef struct ParsedProgram_Rec {
    Instruction *firstInstruction;  // Pointer to array of instructions
    unsigned int liveOnEntry;       // Mask of "live" temp registers upon entry
    unsigned char resultRegsWritten[__GL_NUMBER_OF_RESULT_REGISTERS];
                                    // Mask of result registers written
    int IsStateProgram;             // True if this is a state program
    Instruction instArray[1];
} ParsedProgram;

void vp_Optimize(ParsedProgram *parsed, int numInstructions, int optimizeMask);

/*
** Common structure for X86 compilation of vertex programs
*/

#define CALLER_ID_D3D    0xD3D
#define CALLER_ID_OPENGL 0xD4D

typedef struct VtxProgCompileX86_Rec {
    void *(* malloc)(void *tag, size_t size);
    void (* free)(void *tag, void *address);
    void *(* exec_malloc)(void *tag, size_t size);
    void *mallocArg;
    float (* expf)(float f);
    float (* logf)(float f);
    int caller_id;
    int attrib_offset;
    int temp_offset;
    int result_offset;
    int param_offset;
    int float_zero_offset;
    int float_one_offset;
    // Used to compile code to fill pushbuffer directly:
    int channel_number;
    int enables_offset;
} VtxProgCompileX86;

typedef struct VertexProgramOutput_Rec {
    void *residentProgram;
    size_t residentSize;
    int residentNumInstructions;
} VertexProgramOutput;

int vp_CompileX86(VtxProgCompileX86 *, ParsedProgram *, int numInstructions,
                  VertexProgramOutput *);
int vp_OutputCelsiusX86(VtxProgCompileX86 *, ParsedProgram *, int numInstructions,
                  VertexProgramOutput *);

/*
** Common structure for Kelvin compilation of vertex programs
*/

typedef struct vtxpgmInstPacked_Rec {
    unsigned int x, y, z, w;
} vtxpgmInstPacked;

typedef struct VtxProgCompileKelvin_Rec {
    void *(* malloc)(void *tag, size_t size);
    void (* free)(void *tag, void *address);
    void *mallocArg;
    int caller_id;
    int inputRegMap[16];
    int outputRegMap[16];
    int userMode;
    // No need to init by D3D.  OpenGL only.
    unsigned int textureScaling;
    int passthroughMode;
    // Internally used members.  No need to initialize by caller:
    struct vtxpgmTLiveDead_Rec *tLiveDead;
    int numExtraInstructions;
} VtxProgCompileKelvin;

int vp_CompileKelvin(VtxProgCompileKelvin *, ParsedProgram *, int numInstructions,
                     VertexProgramOutput *);

/*
** Static global data used in shared code to call imported functions:
**
** TEMPORARY!!!!!!!
*/


struct VtxProgImports_Rec {
    float (* expf)(float f);
    float (* logf)(float f);
};


extern struct VtxProgImports_Rec VtxProgImports;

#endif /* __gl_vtxpgmcomp_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\common\inc\wglcommon.h ===
#ifndef __WGLCOMMON_H_
#define __WGLCOMMON_H_

/*
 * Copyright (c) 1997, Nvidia Corporation.  All rights reserved.
 * Portions Copyright (c) 1996, 1997, Silicon Graphics Inc.
 */

extern int STDCALL __wglNVDescribePixelFormat(int bpp, 
                                              int iLayerPlane, 
                                              int iPixelFormat, 
                                              unsigned int nBytes,
                                              PIXELFORMATDESCRIPTOR *ppfd, 
                                              LAYERPLANEDESCRIPTOR *plpd,
                                              __WINpixelFormat *winPixelFormat,
                                              struct __WINNVpixelFormatFlagsRec *winPFFlags, 
                                              int showExtended,
                                              void *osother);

#endif  /* __WGLCOMMON_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\common\inc\wincommon.h ===
#ifndef __WINCOMMON_H_
#define __WINCOMMON_H_

/*
 * Copyright (c) 1997, Nvidia Corporation.  All rights reserved.
 * Portions Copyright (c) 1996, 1997, Silicon Graphics Inc.
 */

/* Remember, this file is used by non-Win32 OpenGL drivers, too. */

// the high two bits are the severity code, see ntstatus.h and winerror.h
// the low 8 bits are unexplained in the windows docs, but don't indicate an error
#define IS_EVENT_ERROR(a) (((a & 0xC0000000) != 0) || (a >= 0x100))

typedef struct __WINNVpixelFormatFlagsRec {
    int unifiedBuffers;
    int color32depth16;
    int color16depth32;
    int multisample;
    int pbuffers;
    int flippingControl;
} __WINNVpixelFormatFlags;

#define WIN_PFD_SUPPORTS_COLOR32_DEPTH16    0x00000001 /* nv11 */
#define WIN_PFD_SUPPORTS_COLOR16_DEPTH32    0x00000002 /* nv20 */
#define WIN_PFD_SUPPORTS_OVERLAYS           0x00000004
#define WIN_PFD_SUPPORTS_SWAPCOPYONLY       0x00000008
#define WIN_PFD_SUPPORTS_SWAP_LAYER_BUFFERS 0x00000010
#define WIN_PFD_SUPPORTS_STEREO             0x00000020
#define WIN_PFD_SUPPORTS_PBUFFERS           0x00000040
#define WIN_PFD_SUPPORTS_MULTISAMPLE        0x00000080

// ---------- Internal Nvidia Pixel Format structure ---------------------

// bits for flags1
#define WINPF_DRAW_TO_WINDOW       0x00000001
#define WINPF_DRAW_TO_BITMAP       0x00000002
#define WINPF_DRAW_TO_PBUFFER      0x00000004
#define WINPF_NEED_PALETTE         0x00000008
#define WINPF_NEED_SYSTEM_PALETTE  0x00000010
#define WINPF_SWAP_LAYER_BUFFERS   0x00000020
#define WINPF_SUPPORT_GDI          0x00000040
#define WINPF_OPENGL_COMPLIANT     0x00000080
#define WINPF_DOUBLE_BUFFER        0x00000100
#define WINPF_STEREO               0x00000200
#define WINPF_SHARE_DEPTH          0x00000400
#define WINPF_SHARE_STENCIL        0x00000800
#define WINPF_SHARE_ACCUM          0x00001000
#define WINPF_TRANSPARENCY         0x00002000

typedef enum {
	WINPF_SWAP_UNDEFINED,
    WINPF_SWAP_COPY,
    WINPF_SWAP_EXCHANGE
} __WINswapMethod;

typedef enum {
    WINPF_PIXEL_RGBA,
    WINPF_PIXEL_COLOR_INDEX
} __WINpixelType;

typedef struct __WINpixelFormatRec {
    unsigned int     flags1;
    __WINswapMethod  swapMethod;
    __WINpixelType   pixelType;
    unsigned int     numOverlays;
    unsigned int     numUnderlays;
    unsigned int     colorBits;
    unsigned int     redBits;
    unsigned int     redShift;
    unsigned int     greenBits;
    unsigned int     greenShift;
    unsigned int     blueBits;
    unsigned int     blueShift;
    unsigned int     alphaBits;
    unsigned int     alphaShift;
    unsigned int     accumBits;
    unsigned int     accumRedBits;
    unsigned int     accumGreenBits;
    unsigned int     accumBlueBits;
    unsigned int     accumAlphaBits;
    unsigned int     depthBits;
    unsigned int     stencilBits;
    unsigned int     auxBuffers;
    unsigned int     transparentRed;
    unsigned int     transparentGreen;
    unsigned int     transparentBlue;
    unsigned int     transparentAlpha;
    unsigned int     transparentIndex;
    unsigned int     maxPbufferPixels;
    unsigned int     maxPbufferWidth;
    unsigned int     maxPbufferHeight;
    unsigned int     sampleBuffers;
    unsigned int     samples;
    unsigned int     layerPlane;
} __WINpixelFormat;

// nvsharedpixelfmt.c
extern int STDCALL __winNVProcessWinFlags(__WINNVpixelFormatFlags *winPFFlags);
extern int __winDescribePixelFormat(struct __WINpixelFormatRec *winPixelFormat, int desktopBPP,
                                    int iLayerPlane, int pixelFormat, unsigned int flags,
                                    int *startNonVisible); 
#endif  /* __WINCOMMON_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\common\inc\StereoDDK.h ===
/***************************************************************************\
* Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.            *
* THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO       *
* NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY  *
* IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.                *
*                                                                           *
*  Portions: Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.*
*                                                                           *
* Module: StereoDDK.h                                                       *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Andrei Osnovich    02/02/00  Created                                *
*                                                                           *
\***************************************************************************/

#ifndef _STEREO_DDK_H_
#define _STEREO_DDK_H_

/*
 * Bit flags defining supported stereo viewing formats.
 */
#define SVF_NONE                0
#define SVF_OVERANDUNDER        0x00000001
#define SVF_FRAMESEQUENTIAL     0x00000002
#define SVF_MULTIMONITOR        0x00000004
#define SVF_LEFTANDRIGHT        0x00000008
#define SVF_LINEINTERLEAVE      0x00000010

/*
 * Activation Methods.
 */
#define SAM_VRAMPATTERN         0x00000001
#define SAM_DDC                 0x00000002
#define SAM_MANUAL              0x00000004

typedef DWORD   (WINAPI *LPDEACTIVATESTEREO)(void);

typedef struct _GraphicsServices_s
{
    DWORD               dwSize;
    DWORD               dwFlags;
    LPDEACTIVATESTEREO  DeactivateStereo;
} GRAPHICSSERVICES, *LPGRAPHICSSERVICES;

typedef DWORD   (FAR PASCAL *LPONFLIP)(void);

typedef struct _StereoViewerServices_s
{
    DWORD            dwSize;
    DWORD            dwFlags;
    LPONFLIP         OnFlip;
} STEREOVIEWERSERVICES, *LPSTEREOVIEWERSERVICES;

/*
 * Bits defining valid fields in the StereoCaps structure.
 */
#define STEREOCAPS_SUPPORTEDFORMATS     0x00000001
#define STEREOCAPS_PREFERREDFORMAT      0x00000002
#define STEREOCAPS_MINREFRESHRATE       0x00000004
#define STEREOCAPS_MAXREFRESHRATE       0x00000008
#define STEREOCAPS_ACTIVATIONMETHOD     0x00000010
#define STEREOCAPS_SERVICECALLBACKS     0x00000020

typedef struct StereoCaps
{
    DWORD dwSize;               //Indicates the version both ways.
    DWORD dwFlags;              //Indicates the valid fields both ways.
    DWORD dwSupportedFormats;
    DWORD dwPreferredFormat;
    WORD  dwMinRefreshRate;
    WORD  dwMaxRefreshRate;
    DWORD dwActivationMethod;
    union 
    {
        LPGRAPHICSSERVICES       pGraphicsServices;    
        LPSTEREOVIEWERSERVICES   pStereoViewerServices;
    };
} STEREOCAPS, *LPSTEREOCAPS;

#ifdef __cplusplus

typedef class CStereoViewer
{
    /*
     * methods
     */
public:
    virtual DWORD WINAPI DestroyStereoViewer(void);
	virtual DWORD WINAPI GetCaps(LPSTEREOCAPS);
    virtual DWORD WINAPI ActivateStereo(LPDDHALMODEINFO pVideoMode, LPVOID pScreenAddr, DWORD StereoFormat);
    virtual DWORD WINAPI DeactivateStereo(LPDDHALMODEINFO pVideoMode, LPVOID pScreenAddr, DWORD StereoFormat);
} STEREOVIEWER, *LPSTEREOVIEWER;

#else   //__cplusplus==0

typedef struct CStereoViewer
{
    struct  CStereoViewerVtbl FAR *lpVtbl;
} STEREOVIEWER, *LPSTEREOVIEWER;

struct  CStereoViewerVtbl {
    DWORD (WINAPI *DestroyStereoViewer)(LPSTEREOVIEWER);
	DWORD (WINAPI *GetCaps)(LPSTEREOVIEWER, LPSTEREOCAPS);
    DWORD (WINAPI *ActivateStereo)(LPSTEREOVIEWER, LPVOID pVideoMode, LPVOID pScreenAddr, DWORD StereoFormat);
    DWORD (WINAPI *DeactivateStereo)(LPSTEREOVIEWER, LPVOID pVideoMode, LPVOID pScreenAddr, DWORD StereoFormat);
};

#endif  //__cplusplus==0


typedef DWORD (WINAPI *LPCREATESTEREOVIEWER)(LPSTEREOVIEWER *);

#define _FACSTEREO  (*(WORD *)"NV")
#define MAKE_STEREOHRESULT( code )  MAKE_HRESULT( 1, _FACSTEREO, code )

/*
 * Error codes
 */
#define STEREO_OK                               0
#define STEREO_UNSUPPORTED_STEREO_FORMAT        MAKE_STEREOHRESULT(1)
#define STEREO_UNSUPPORTED_VIDEO_MODE           MAKE_STEREOHRESULT(2)
#define STEREO_UNSUPPORTED_REFRESHRATE          MAKE_STEREOHRESULT(3)
#define STEREO_INVALID_PARAMETERS               MAKE_STEREOHRESULT(4)
#define STEREO_HARDWARE_NOT_FOUND               MAKE_STEREOHRESULT(5)
#define STEREO_UNKNOWN_ERROR                    MAKE_STEREOHRESULT(6)

#endif  //_STEREO_DDK_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\common\inc\StereoStats.h ===
/***************************************************************************\
* Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.            *
* THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO       *
* NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY  *
* IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.                *
*                                                                           *
*  Portions: Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.*
*                                                                           *
* Module: StereoStats.h                                                     *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Andrei Osnovich    03/13/01  Created                                *
*                                                                           *
\***************************************************************************/

#ifndef _STEREO_STATS_H_
#define _STEREO_STATS_H_

// This structure is provided in return to the GetStereoStats call to the drivers. It contains all 
// stereo information required to build and display the application behaviour graph. 
typedef struct _Stereo_Stats_S {
    DWORD   dwFlags;
    // General settings.
    DWORD   dwWidth;
    DWORD   dwHeight;
    DWORD   dwBpp;
    // General stereo settings.
    float   StereoSeparation;
    float   StereoConvergence;
    // Frustum settings defined for HW TnL only.
    float   ZNear;
    float   ZFar;
    // Stereo settings defined for D3D & SW TnL only.
    float   RHWGreaterAtScreen; //No Stereo Start RHW boundary from the front side
    float   RHWLessAtScreen;    //No Stereo Start RHW boundary from the back side
    // Various useful stereo stats defined for D3D & SW TnL only (Used in ConfigAssist mode).
    float   rhwMin;
    float   rhwMax;
    float   rhwMin2D;
    float   rhwMax2D;
} STEREOSTATS, *LPSTEREOSTATS;

// Values that can be ORed in the dwFlags field of the STEREOSTATS structure
#define OPENGL_API              0x00000001      //If not present then D3D.
#define HW_TnL                  0x00000002      //If not present then SW TnL.
#define RHWGREATERATSCREEN      0x00000004      //RHWGreaterAtScreen is valid.
#define RHWLESSATSCREEN         0x00000008      //RHWLessAtScreen is valid.
#define CONFIGASSISTON          0x00000010      //ConfigAssist data is valid.

#endif  //_STEREO_STATS_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\common\inc\vtxpgmconsts.h ===
/*
** vtxpgmconsts.h
**
** Vertex Program Constant Declarations.
**
** Copyright 2000 NVIDIA, Corporation.  All rights reserved.
** 
** THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
** NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
** IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
*/

#ifndef __gl_vtxpgmconsts_h_
#define __gl_vtxpgmconsts_h_

#pragma warning (disable:4244)  /* Disable bogus VC++ 4.2 conversion warnings. */
#pragma warning (disable:4305)  /* VC++ 5.0 version of above warning. */

/*
** This file is shared between OpenGL and D3D so don't mess with it!
*/

/*
** Constants used for programs:
*/

#define __GL_NUMBER_OF_VERTEX_ATTRIBS       16
#define __GL_NUMBER_OF_PROGRAM_MATRICES     8
#define __GL_NUMBER_OF_TEMPORARY_REGISTERS  12
#define __GL_NUMBER_OF_RESULT_REGISTERS     16
#define __GL_NUMBER_OF_CONSTANT_REGISTERS   96
#define __GL_NUMBER_OF_PADDING_REGISTERS    128
#define __GL_MAX_NUMBER_OF_INSTRUCTIONS     128

#define __GL_ACTUAL_NUMBER_OF_INSTRUCTIONS_KELVIN   134

#define __GL_KELVIN_FIRST_USER_CONSTANT_REGISTER    96


/*
** Names for each of the vertex attributes
*/

#define __GL_ATTRIB_POSITION            0
#define __GL_ATTRIB_VERTEX_WEIGHT       1
#define __GL_ATTRIB_NORMAL              2
#define __GL_ATTRIB_COLOR               3
#define __GL_ATTRIB_SECONDARY_COLOR     4
#define __GL_ATTRIB_FOG_COORD           5
#define __GL_ATTRIB_UNUSED0             6
#define __GL_ATTRIB_UNUSED1             7
#define __GL_ATTRIB_TEXCOORD0           8
#define __GL_ATTRIB_TEXCOORD1           9
#define __GL_ATTRIB_TEXCOORD2           10
#define __GL_ATTRIB_TEXCOORD3           11
#define __GL_ATTRIB_TEXCOORD4           12
#define __GL_ATTRIB_TEXCOORD5           13
#define __GL_ATTRIB_TEXCOORD6           14
#define __GL_ATTRIB_TEXCOORD7           15

/*
** Names for the output components:
*/

#define __GL_ATTRIB_OUTPUT_HPOS         0
#define __GL_ATTRIB_OUTPUT_COL0         3
#define __GL_ATTRIB_OUTPUT_COL1         4
#define __GL_ATTRIB_OUTPUT_BFC0         7
#define __GL_ATTRIB_OUTPUT_BFC1         8
#define __GL_ATTRIB_OUTPUT_FOGC         5
#define __GL_ATTRIB_OUTPUT_PSIZ         6
#define __GL_ATTRIB_OUTPUT_TEX0         9
#define __GL_ATTRIB_OUTPUT_TEX1         10
#define __GL_ATTRIB_OUTPUT_TEX2         11
#define __GL_ATTRIB_OUTPUT_TEX3         12
#define __GL_ATTRIB_OUTPUT_TEX4         13
#define __GL_ATTRIB_OUTPUT_TEX5         14
#define __GL_ATTRIB_OUTPUT_TEX6         15
#define __GL_ATTRIB_OUTPUT_TEX7         15

/*
** Enable bits tested by compiled x886 code:
*/

#define __GL_PROGRAM_ENABLE_TEXTURE0    1
#define __GL_PROGRAM_ENABLE_TEXTURE1    2

#endif /* __gl_vtxpgmconsts_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\common\inc\x86.h ===
/*
 * Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.
 *
 * THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
 * NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
 * IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: x86.h                                                             *
*   x86 architexture specific macros - used mainly to generate assembly     *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Ben de Waal                 02/10/98 - wrote it.                    *
*                                                                           *
\***************************************************************************/

/*****************************************************************************
 * constants
 *****************************************************************************/

#ifndef _x86_h
#define _x86_h

#ifdef __cplusplus
extern "C" {
#endif

/*
 * registers
 */
#define rEAX            0
#define rECX            1
#define rEDX            2
#define rEBX            3
#define rESP            4
#define rEBP            5
#define rESI            6
#define rEDI            7

#define rAX             0
#define rCX             1
#define rDX             2
#define rBX             3
#define rSP             4
#define rBP             5
#define rSI             6
#define rDI             7

#define rAL             0
#define rCL             1
#define rDL             2
#define rBL             3
#define rAH             4
#define rCH             5
#define rDH             6
#define rBH             7

#define rMM0            0
#define rMM1            1
#define rMM2            2
#define rMM3            3
#define rMM4            4
#define rMM5            5
#define rMM6            6
#define rMM7            7

#define rXMM0           0
#define rXMM1           1
#define rXMM2           2
#define rXMM3           3
#define rXMM4           4
#define rXMM5           5
#define rXMM6           6
#define rXMM7           7

#define rST0            0
#define rST1            1
#define rST2            2
#define rST3            3
#define rST4            4
#define rST5            5
#define rST6            6
#define rST7            7

/*
 * op codes
 *  alphabetically sorted
 */
#define xADC_rEAX_imm(i)        x86s(5) x86b(0x15) x86d(i)
#define xADD_r_rm(r,rm)         x86s(2) x86b(0x03) x86b(mREG(r) | (rm))
#define xADD_r_i32(r,a)         x86s(6) x86b(0x03) x86b(mREG(r) | mOFS32) x86d(a)
#define xADD_rm_imm8(rm,i)      x86s(3) x86b(0x83) x86b(mREG(0) | (rm)) x86b(i)
#define xADD_rm_imm(rm,i)       x86s(6) x86b(0x81) x86b(mREG(0) | (rm)) x86d(i)
#define xADD_rm_r(rm,r)         x86s(2) x86b(0x01) x86b(mREG(r) | (rm))
#define xADD_i32_r(a,r)         x86s(6) x86b(0x01) x86b(mREG(r) | mOFS32) x86d(a)

#define xAND_r_rm(r,rm)         x86s(2) x86b(0x23) x86b(mREG(r) | (rm))
#define xAND_r_i32(r,a)         x86s(6) x86b(0x23) x86b(mREG(r) | mOFS32) x86d(a)
#define xAND_rm_imm8(rm,i)      x86s(3) x86b(0x83) x86b(mREG(4) | (rm)) x86b(i)
#define xAND_rm_imm(rm,i)       x86s(6) x86b(0x81) x86b(mREG(4) | (rm)) x86d(i)

#define xCALL_rm(rm)            x86s(2) x86b(0xff) x86b(mREG(2) | (rm))

#define xCMOVA_r_i32(r,a)       x86s(7) x86b(0x0f) x86b(0x47) x86b(mREG(r) | mOFS32) x86d(a)
#define xCMOVA_r_rm(r,rm)       x86s(3) x86b(0x0f) x86b(0x47) x86b(mREG(r) | (rm))
#define xCMOVB_r_i32(r,a)       x86s(7) x86b(0x0f) x86b(0x42) x86b(mREG(r) | mOFS32) x86d(a)
#define xCMOVB_r_rm(r,rm)       x86s(3) x86b(0x0f) x86b(0x42) x86b(mREG(r) | (rm))
#define xCMOVG_r_rm(r,rm)       x86s(3) x86b(0x0f) x86b(0x4f) x86b(mREG(r) | (rm))
#define xCMOVL_r_rm(r,rm)       x86s(3) x86b(0x0f) x86b(0x4c) x86b(mREG(r) | (rm))

#define xCMP_r_rm(r,rm)         x86s(2) x86b(0x3b) x86b(mREG(r) | (rm))
#define xCMP_r_i32(r,a)         x86s(6) x86b(0x3b) x86b(mREG(r) | mOFS32) x86d(a)
#define xCMP_rm_imm(rm,i)       x86s(6) x86b(0x81) x86b(mREG(7) | (rm)) x86d(i)

#define xDEC_r(r)               x86s(1) x86b(0x48 | (r))
#define xDEC_rm(rm)             x86s(2) x86b(0xff) x86b(mREG(1) | (rm))
#define xDEC_i32(a)             x86s(6) x86b(0xff) x86b(mREG(1) | mOFS32) x86d(a)

#define xDIV_rm(rm)             x86s(2) x86b(0xf7) x86b(mREG(6) | (rm))

#define xFABS()                 x86s(2) x86b(0xd9) x86b(0xe1)

#define xFADD_rm(rm)            x86s(2) x86b(0xd8) x86b(mREG(0) | (rm))
#define xFADD_i32(a)            x86s(6) x86b(0xd8) x86b(mREG(0) | mOFS32) x86d(a)
#define xFADD_st(r)             x86s(2) x86b(0xd8) x86b(0xc0 + (r))
#define xFADDP_st(r)            x86s(2) x86b(0xde) x86b(0xc0 + (r))

#define xFDECSTP                x86s(2) x86b(0xd9) x86b(0xf6)

#define xFCHS                   x86s(2) x86b(0xd9) x86b(0xe0)

#define xFCOM_rm(rm)            x86s(2) x86b(0xd8) x86b(mREG(2) | (rm))
#define xFCOM_i32(a)            x86s(6) x86b(0xd8) x86b(mREG(2) | mOFS32) x86d(a)
#define xFCOM_st(r)             x86s(2) x86b(0xd8) x86b(0xd0 + (r))
#define xFCOMI_st(r)            x86s(2) x86b(0xdb) x86b(0xf0 + (r))
#define xFCOMIP_st(r)           x86s(2) x86b(0xdf) x86b(0xf0 + (r))
#define xFCOMP_rm(rm)           x86s(2) x86b(0xd8) x86b(mREG(3) | (rm))
#define xFCOMPP()               x86s(2) x86b(0xde) x86b(0xd9)

#define xFDIV_rm(rm)            x86s(2) x86b(0xd8) x86b(mREG(6) | (rm))
#define xFDIVR_rm(rm)           x86s(2) x86b(0xd8) x86b(mREG(7) | (rm))

#define xFFREE_st(r)            x86s(2) x86b(0xdd) x86b(0xc0 + (r))

#define xFILD_rm(rm)            x86s(2) x86b(0xdb) x86b(mREG(0) | (rm))
#define xFILD_rm16(rm)          x86s(2) x86b(0xdf) x86b(mREG(0) | (rm))
#define xFILD_rm64(rm)          x86s(2) x86b(0xdf) x86b(mREG(5) | (rm))

#define xFINCSTP                x86s(2) x86b(0xd9) x86b(0xf7)

#define xFIST_rm(rm)            x86s(2) x86b(0xdb) x86b(mREG(2) | (rm))
#define xFISTP_rm(rm)           x86s(2) x86b(0xdb) x86b(mREG(3) | (rm))
#define xFISTP_i32(a)           x86s(6) x86b(0xdb) x86b(mREG(3) | mOFS32) x86d(a)

#define xFLD_rm(rm)             x86s(2) x86b(0xd9) x86b(mREG(0) | (rm))
#define xFLD_rm32(rm)           x86s(2) x86b(0xd9) x86b(mREG(0) | (rm))
#define xFLD_rm64(rm)           x86s(2) x86b(0xdd) x86b(mREG(0) | (rm))
#define xFLD_i32(a)             x86s(6) x86b(0xd9) x86b(mREG(0) | mOFS32) x86d(a)
#define xFLD_st(r)              x86s(2) x86b(0xd9) x86b(0xc0 + (r))
#define xFLD1                   x86s(2) x86b(0xd9) x86b(0xe8)
#define xFLDZ                   x86s(2) x86b(0xd9) x86b(0xee)

#define xFMUL_st(r)             x86s(2) x86b(0xd8) x86b(0xc8 + (r))
#define xFMUL_rm(rm)            x86s(2) x86b(0xd8) x86b(mREG(1) | (rm))
#define xFMUL_i32(a)            x86s(6) x86b(0xd8) x86b(mREG(1) | mOFS32) x86d(a)
#define xFMULP_st(r)            x86s(2) x86b(0xde) x86b(0xc8 + (r))
#define xFNSTSW                 x86s(2) x86b(0xdf) x86b(0xe0)

#define xFSQRT()                x86s(2) x86b(0xd9) x86b(0xfa)

#define xFSUB_rm(rm)            x86s(2) x86b(0xd8) x86b(mREG(4) | (rm))
#define xFSUBP_st(r)            x86s(2) x86b(0xde) x86b(0xe8 + (r))
#define xFSUBR_rm(rm)           x86s(2) x86b(0xd8) x86b(mREG(5) | (rm))
#define xFSUBRP_st(r)           x86s(2) x86b(0xde) x86b(0xe0 + (r))

#define xFST_rm(rm)             x86s(2) x86b(0xd9) x86b(mREG(2) | (rm))
#define xFSTP_rm(rm)            x86s(2) x86b(0xd9) x86b(mREG(3) | (rm))
#define xFSTP_i32(a)            x86s(6) x86b(0xd9) x86b(mREG(3) | mOFS32) x86d(a)
#define xFSTP_st(r)             x86s(2) x86b(0xdd) x86b(0xd8 + (r))

#define xFLDCW_rm(rm)           x86s(2) x86b(0xd9) x86b(mREG(5) | (rm))
#define xFSTCW_rm(rm)           x86s(2) x86b(0xd9) x86b(mREG(7) | (rm))


#define xFXCH_st(r)             x86s(2) x86b(0xd9) x86b(0xc8 + (r))

#define xFYL2X()                x86s(2) x86b(0xd9) x86b(0xf1)
#define xF2XM1()                x86s(2) x86b(0xd9) x86b(0xf0)

#define xINC_r(r)               x86s(1) x86b(0x40 | (r))
#define xINC_rm(rm)             x86s(2) x86b(0xff) x86b(mREG(0) | (rm))

#define xIMUL_r_rm(r,rm)        x86s(3) x86b(0x0f) x86b(0xaf) x86b(mREG(r) | (rm))
#define xIMUL_r_i32(r,a)        x86s(7) x86b(0x0f) x86b(0xaf) x86b(mREG(r) | mOFS32) x86d(a)
#define xIMUL_r_r_imm(r1,r2,i)  x86s(6) x86b(0x69) x86b(0xc0 | ((r1) << 3) | (r2)) x86d(i)

#define xINT3                   x86s(1) x86b(0xcc)

#define xJA(disp)               { unsigned int _x = (disp)-(ilcCount+2); x86s(2) x86b(0x77) x86b(_x) }
#define xJA32(disp)             { unsigned int _x = (disp)-(ilcCount+6); x86s(6) x86b(0x0f) x86b(0x87) x86d(_x) }
#define xJAE(disp)              { unsigned int _x = (disp)-(ilcCount+2); x86s(2) x86b(0x73) x86b(_x) }
#define xJAE32(disp)            { unsigned int _x = (disp)-(ilcCount+6); x86s(6) x86b(0x0f) x86b(0x83) x86d(_x) }
#define xJB(disp)               { unsigned int _x = (disp)-(ilcCount+2); x86s(2) x86b(0x72) x86b(_x) }
#define xJB32(disp)             { unsigned int _x = (disp)-(ilcCount+6); x86s(6) x86b(0x0f) x86b(0x82) x86d(_x) }
#define xJBE(disp)              { unsigned int _x = (disp)-(ilcCount+2); x86s(2) x86b(0x76) x86b(_x) }
#define xJBE32(disp)            { unsigned int _x = (disp)-(ilcCount+6); x86s(6) x86b(0x0f) x86b(0x86) x86d(_x) }
#define xJG(disp)               { unsigned int _x = (disp)-(ilcCount+2); x86s(2) x86b(0x7f) x86b(_x) }
#define xJG32(disp)             { unsigned int _x = (disp)-(ilcCount+6); x86s(6) x86b(0x0f) x86b(0x8f) x86d(_x) }
#define xJGE(disp)              { unsigned int _x = (disp)-(ilcCount+2); x86s(2) x86b(0x7d) x86b(_x) }
#define xJGE32(disp)            { unsigned int _x = (disp)-(ilcCount+6); x86s(6) x86b(0x0f) x86b(0x8d) x86d(_x) }
#define xJL(disp)               { unsigned int _x = (disp)-(ilcCount+2); x86s(2) x86b(0x7c) x86b(_x) }
#define xJL32(disp)             { unsigned int _x = (disp)-(ilcCount+6); x86s(6) x86b(0x0f) x86b(0x8c) x86d(_x) }
#define xJLE(disp)              { unsigned int _x = (disp)-(ilcCount+2); x86s(2) x86b(0x7e) x86b(_x) }
#define xJLE32(disp)            { unsigned int _x = (disp)-(ilcCount+6); x86s(6) x86b(0x0f) x86b(0x8e) x86d(_x) }
#define xJNZ(disp)              { unsigned int _x = (disp)-(ilcCount+2); x86s(2) x86b(0x75) x86b(_x) }
#define xJNZ32(disp)            { unsigned int _x = (disp)-(ilcCount+6); x86s(6) x86b(0x0f) x86b(0x85) x86d(_x) }
#define xJZ(disp)               { unsigned int _x = (disp)-(ilcCount+2); x86s(2) x86b(0x74) x86b(_x) }
#define xJZ32(disp)             { unsigned int _x = (disp)-(ilcCount+6); x86s(6) x86b(0x0f) x86b(0x84) x86d(_x) }


#define xJMP8(disp)             { unsigned int _x = (disp)-(ilcCount+2); x86s(2) x86b(0xeb) x86b(_x) }
#define xJMP(disp)              { unsigned int _x = (disp)-(ilcCount+5); x86s(5) x86b(0xe9) x86d(_x) }

#define xLEA_r_rm(r,rm)         x86s(2) x86b(0x8d) x86b(mREG(r) | (rm))

#define xMOV_r_rm(r,rm)         x86s(2) x86b(0x8b) x86b(mREG(r) | (rm))                     // mov eax,[ebx]
#define xMOV_r_i32(r,a)         x86s(6) x86b(0x8b) x86b(mREG(r) | mOFS32) x86d(a)           // mov eax,[1234h]
#define xMOV_rm_imm(rm,i)       x86s(6) x86b(0xc7) x86b(mREG(0) | (rm)) x86d(i)             // mov ebp,12345678
#define xMOV_r_imm(rm,i)        x86s(5) x86b(0xb8 | (rm)) x86d(i)                           // mov eax,12345678
#define xMOV_rm_r(rm,r)         x86s(2) x86b(0x89) x86b(mREG(r) | (rm))                     // mov [ebx],eax
#define xMOV_i32_r(a,r)         x86s(6) x86b(0x89) x86b(mREG(r) | mOFS32) x86d(a)           // mov [1234h],eax
#define xMOV_r_rm8(r,rm)        x86s(2) x86b(0x8a) x86b(mREG(r) | (rm))                     // mov al,[ebx]
#define xMOV_rm8_r(rm,r)        x86s(2) x86b(0x88) x86b(mREG(r) | (rm))                     // mov [ebx],al
#define xMOVSB                  x86s(1) x86b(0xa4)
#define xMOVSD                  x86s(1) x86b(0xa5)
#define xMOVSX_r_rm8(r,rm)      x86s(3) x86b(0x0f) x86b(0xbe) x86b(mREG(r) | (rm))
#define xMOVSX_r_rm16(r,rm)     x86s(3) x86b(0x0f) x86b(0xbf) x86b(mREG(r) | (rm))
#define xMOVZX_r_rm8(r,rm)      x86s(3) x86b(0x0f) x86b(0xb6) x86b(mREG(r) | (rm))
#define xMOVZX_r_rm16(r,rm)     x86s(3) x86b(0x0f) x86b(0xb7) x86b(mREG(r) | (rm))

#define xNEG_rm(rm)             x86s(2) x86b(0xf7) x86b(mREG(3) | (rm))

#define xNOP                    x86s(1) x86b(0x90)

#define xNOT_rm(rm)             x86s(2) x86b(0xf7) x86b(mREG(2) | (rm))

#define xOR_r_rm(r,rm)          x86s(2) x86b(0x0b) x86b(mREG(r) | (rm))
#define xOR_r_i32(r,a)          x86s(6) x86b(0x0b) x86b(mREG(r) | mOFS32) x86d(a)
#define xOR_rm_r(rm,r)          x86s(2) x86b(0x09) x86b(mREG(r) | (rm))
#define xOR_i32_r(a,r)          x86s(6) x86b(0x09) x86b(mREG(r) | mOFS32) x86d(a)
#define xOR_rm_imm(rm,i)        x86s(6) x86b(0x81) x86b(mREG(1) | (rm)) x86d(i)

#define xPOP_r(r)               x86s(1) x86b(0x58 | (r))
#define xPOP_rm(rm)             x86s(2) x86b(0xff) x86b(0x30 | (rm))
#define xPOPAD                  x86s(1) x86b(0x61)

#define xPUSH_r(r)              x86s(1) x86b(0x50 | (r))
#define xPUSH_rm(rm)            x86s(2) x86b(0xff) x86b(mREG(6) | (rm))
#define xPUSH_i32(a)            x86s(6) x86b(0xff) x86b(mREG(6) | mOFS32) x86d(a)
#define xPUSH_imm(i)            x86s(5) x86b(0x68) x86d(i)
#define xPUSHAD                 x86s(1) x86b(0x60)

#define xREP                    x86s(1) x86b(0xf3)
#define xRET                    x86s(1) x86b(0xc3)
#define xRET_imm(i)             x86s(3) x86b(0xc2) x86w(i)

#define xSAHF                   x86s(1) x86b(0x9e)

#define xSAL_rm_imm8(rm,i)      x86s(3) x86b(0xc1) x86b(mREG(4) | (rm)) x86b(i)
#define xSAR_rm_imm8(rm,i)      x86s(3) x86b(0xc1) x86b(mREG(7) | (rm)) x86b(i)

#define xSBB_r_rm(r,rm)         x86s(2) x86b(0x1b) x86b(mREG(r) | (rm))
#define xSBB_r_i32(r,a)         x86s(6) x86b(0x1b) x86b(mREG(r) | mOFS32) x86d(a)
#define xSBB_rm_r(rm,r)         x86s(2) x86b(0x19) x86b(mREG(r) | (rm))

#define xSETAE_rm8(rm)          x86s(3) x86b(0x0f) x86b(0x93) x86b(rm)
#define xSETG_rm8(rm)           x86s(3) x86b(0x0f) x86b(0x9f) x86b(rm)
#define xSETGE_rm8(rm)          x86s(3) x86b(0x0f) x86b(0x9d) x86b(rm)
#define xSETL_rm8(rm)           x86s(3) x86b(0x0f) x86b(0x9c) x86b(rm)
#define xSETLE_rm8(rm)          x86s(3) x86b(0x0f) x86b(0x9e) x86b(rm)
#define xSETNZ_rm8(rm)          x86s(3) x86b(0x0f) x86b(0x95) x86b(rm)
#define xSETZ_rm8(rm)           x86s(3) x86b(0x0f) x86b(0x94) x86b(rm)

#define xSHL_rm_1(rm)           x86s(2) x86b(0xd1) x86b(mREG(4) | (rm))
#define xSHL_rm_CL(rm)          x86s(2) x86b(0xd3) x86b(mREG(4) | (rm))
#define xSHL_rm_imm8(rm,i)      x86s(3) x86b(0xc1) x86b(mREG(4) | (rm)) x86b(i)
#define xSHR_rm_1(rm)           x86s(2) x86b(0xd1) x86b(mREG(5) | (rm))
#define xSHR_rm_CL(rm)          x86s(2) x86b(0xd3) x86b(mREG(5) | (rm))
#define xSHR_rm_imm8(rm,i)      x86s(3) x86b(0xc1) x86b(mREG(5) | (rm)) x86b(i)

#define xSTOSD                 x86s(1) x86b(0xab)

#define xSUB_r_rm(r,rm)         x86s(2) x86b(0x2b) x86b(mREG(r) | (rm))
#define xSUB_r_i32(r,a)         x86s(6) x86b(0x2b) x86b(mREG(r) | mOFS32) x86d(a)
#define xSUB_rm_r(rm,r)         x86s(2) x86b(0x29) x86b(mREG(r) | (rm))
#define xSUB_i32_r(a,r)         x86s(6) x86b(0x29) x86b(mREG(r) | mOFS32) x86d(a)
#define xSUB_rm_imm8(rm,i)      x86s(3) x86b(0x83) x86b(mREG(5) | (rm)) x86b(i)
#define xSUB_rm_imm(rm,i)       x86s(6) x86b(0x81) x86b(mREG(5) | (rm)) x86d(i)

#define xTEST_rm_r(rm,r)        x86s(2) x86b(0x85) x86b(mREG(r) | (rm))
#define xTEST_r_rm(r,rm)        x86s(2) x86b(0x85) x86b(mREG(r) | (rm))
#define xTEST_i32_r(a,r)        x86s(6) x86b(0x85) x86b(mREG(r) | mOFS32) x86d(a)
#define xTEST_r_i32(r,a)        x86s(6) x86b(0x85) x86b(mREG(r) | mOFS32) x86d(a)
#define xTEST_rm_imm8(rm,i)     x86s(3) x86b(0xf6) x86b(mREG(0) | (rm)) x86b(i)
#define xTEST_rm_imm(rm,i)      x86s(6) x86b(0xf7) x86b(mREG(0) | (rm)) x86d(i)

#define xXOR_r_rm(r,rm)         x86s(2) x86b(0x33) x86b(mREG(r) | (rm))
#define xXOR_r_i32(r,a)         x86s(6) x86b(0x33) x86b(mREG(r) | mOFS32) x86d(a)
#define xXOR_rm_r(rm,r)         x86s(2) x86b(0x31) x86b(mREG(r) | (rm))
#define xXOR_i32_r(a,r)         x86s(6) x86b(0x31) x86b(mREG(r) | mOFS32) x86d(a)
#define xXOR_rm_imm(rm,i)       x86s(6) x86b(0x81) x86b(mREG(6) | (rm)) x86d(i)

/*
 * mmx opcodes
 */
#define xMOVD_r_rm(r,rm)        x86s(3) x86b(0x0f) x86b(0x6e) x86b(mREG(r) | (rm))
#define xMOVD_r_i32(r,a)        x86s(7) x86b(0x0f) x86b(0x6e) x86b(mREG(r) | mOFS32) x86d(a)
#define xMOVD_rm_r(rm,r)        x86s(3) x86b(0x0f) x86b(0x7e) x86b(mREG(r) | (rm))
#define xMOVD_i32_r(a,r)        x86s(7) x86b(0x0f) x86b(0x7e) x86b(mREG(r) | mOFS32) x86d(a)
#define xMOVNTQ_rm_r(rm,r)      x86s(3) x86b(0x0f) x86b(0xe7) x86b(mREG(r) | (rm))
#define xMOVQ_r_rm(r,rm)        x86s(3) x86b(0x0f) x86b(0x6f) x86b(mREG(r) | (rm))
#define xMOVQ_rm_r(rm,r)        x86s(3) x86b(0x0f) x86b(0x7f) x86b(mREG(r) | (rm))
#define xMOVQ_i64_r(a,r)        x86s(7) x86b(0x0f) x86b(0x7f) x86b(mREG(r) | mOFS32) x86d(a)
#define xMOVQ_r_i64(r,a)        x86s(7) x86b(0x0f) x86b(0x6f) x86b(mREG(r) | mOFS32) x86d(a)
#define xPADDB_r_rm(r,rm)       x86s(3) x86b(0x0f) x86b(0xfc) x86b(mREG(r) | (rm))
#define xPADDB_r_i64(r,a)       x86s(7) x86b(0x0f) x86b(0xfc) x86b(mREG(4) | mOFS32) x86d(a)
#define xPADDW_r_rm(r,rm)       x86s(3) x86b(0x0f) x86b(0xfd) x86b(mREG(r) | (rm))
#define xPADDW_r_i64(r,a)       x86s(7) x86b(0x0f) x86b(0xfd) x86b(mREG(4) | mOFS32) x86d(a)
#define xPADDD_r_rm(r,rm)       x86s(3) x86b(0x0f) x86b(0xfe) x86b(mREG(r) | (rm))
#define xPADDD_r_i64(r,a)       x86s(7) x86b(0x0f) x86b(0xfe) x86b(mREG(4) | mOFS32) x86d(a)

#define xPMOVMSKB_r_r(r1, r2)   x86s(3) x86b(0x0f) x86b(0xd7) x86b(mREG(r1) | rmREG(r2))

#define xPUNPCKLBW_r_rm(r,rm)   x86s(3) x86b(0x0f) x86b(0x60) x86b(mREG(r) | (rm))
#define xPUNPCKLBW_r_i128(r,a)  x86s(7) x86b(0x0f) x86b(0x60) x86b(mREG(r) | mOFS32) x86d(a)
#define xPUNPCKLWD_r_rm(r,rm)   x86s(3) x86b(0x0f) x86b(0x61) x86b(mREG(r) | (rm))
#define xPUNPCKLWD_r_i128(r,a)  x86s(7) x86b(0x0f) x86b(0x61) x86b(mREG(r) | mOFS32) x86d(a)
#define xPUNPCKLDQ_r_rm(r,rm)   x86s(3) x86b(0x0f) x86b(0x62) x86b(mREG(r) | (rm))
#define xPUNPCKLDQ_r_i128(r,a)  x86s(7) x86b(0x0f) x86b(0x62) x86b(mREG(r) | mOFS32) x86d(a)

#define xEMMS                   x86s(2) x86b(0x0f) x86b(0x77)

/*
 * katmai opcodes
 */
#define xADDPS_r_rm(r,rm)       x86s(3) x86b(0x0f) x86b(0x58) x86b(mREG(r) | (rm))
#define xADDSS_r_rm(r,rm)       x86s(4) x86b(0xf3) x86b(0x0f) x86b(0x58) x86b(mREG(r) | (rm))

#define xCOMISS_r_rm(r,rm)      x86s(3) x86b(0x0f) x86b(0x2f) x86b(mREG(r) | (rm))
#define xCMPPSZ_r_rm(r,rm)      x86s(4) x86b(0x0f) x86b(0xc2) x86b(mREG(r) | (rm)) x86b(0)
#define xCMPPSL_r_rm(r,rm)      x86s(4) x86b(0x0f) x86b(0xc2) x86b(mREG(r) | (rm)) x86b(1)
#define xCMPPSLE_r_rm(r,rm)     x86s(4) x86b(0x0f) x86b(0xc2) x86b(mREG(r) | (rm)) x86b(2)
#define xCMPPSNZ_r_rm(r,rm)     x86s(4) x86b(0x0f) x86b(0xc2) x86b(mREG(r) | (rm)) x86b(4)
#define xCMPPSGE_r_rm(r,rm)     x86s(4) x86b(0x0f) x86b(0xc2) x86b(mREG(r) | (rm)) x86b(5)
#define xCMPPSG_r_rm(r,rm)      x86s(4) x86b(0x0f) x86b(0xc2) x86b(mREG(r) | (rm)) x86b(6)

#define xCVTPS2PI_r_rm(r,rm)    x86s(3) x86b(0x0f) x86b(0x2c) x86b(mREG(r) | (rm))

#define xDIVPS_r_rm(r,rm)       x86s(3) x86b(0x0f) x86b(0x5e) x86b(mREG(r) | (rm))

#define xMAXPS_r_rm(r,rm)       x86s(3) x86b(0x0f) x86b(0x5f) x86b(mREG(r) | (rm))
#define xMAXPS_r_i128(r,a)      x86s(7) x86b(0x0f) x86b(0x5f) x86b(mREG(r) | mOFS32) x86d(a)

#define xMINPS_r_rm(r,rm)       x86s(3) x86b(0x0f) x86b(0x5d) x86b(mREG(r) | (rm))
#define xMINPS_r_i128(r,a)      x86s(7) x86b(0x0f) x86b(0x5d) x86b(mREG(r) | mOFS32) x86d(a)

#define xMOVAPS_r_rm(r,rm)      x86s(3) x86b(0x0f) x86b(0x28) x86b(mREG(r) | (rm))
#define xMOVAPS_r_i128(r,a)     x86s(7) x86b(0x0f) x86b(0x28) x86b(mREG(r) | mOFS32) x86d(a)
#define xMOVAPS_rm_r(rm,r)      x86s(3) x86b(0x0f) x86b(0x29) x86b(mREG(r) | (rm))
#define xMOVAPS_i128_r(a,r)     x86s(7) x86b(0x0f) x86b(0x29) x86b(mREG(r) | mOFS32) x86d(a)

#define xMOVHLPS_r_r(r1,r2)     x86s(3) x86b(0x0f) x86b(0x12) x86b(mREG(r1) | rmREG(r2)) // special movlps
#define xMOVLHPS_r_r(r1,r2)     x86s(3) x86b(0x0f) x86b(0x16) x86b(mREG(r1) | rmREG(r2)) // special movhps

#define xMOVHPS_r_rm(r,rm)      x86s(3) x86b(0x0f) x86b(0x16) x86b(mREG(r) | (rm))
#define xMOVHPS_r_i64(r,a)      x86s(7) x86b(0x0f) x86b(0x16) x86b(mREG(r) | mOFS32) x86d(a)
#define xMOVHPS_i64_r(a,r)      x86s(7) x86b(0x0f) x86b(0x17) x86b(mREG(r) | mOFS32) x86d(a)
#define xMOVHPS_rm_r(rm,r)      x86s(3) x86b(0x0f) x86b(0x17) x86b(mREG(r) | (rm))

#define xMOVLPS_r_rm(r,rm)      x86s(3) x86b(0x0f) x86b(0x12) x86b(mREG(r) | (rm))
#define xMOVLPS_r_i64(r,a)      x86s(7) x86b(0x0f) x86b(0x12) x86b(mREG(r) | mOFS32) x86d(a)
#define xMOVLPS_i64_r(a,r)      x86s(7) x86b(0x0f) x86b(0x13) x86b(mREG(r) | mOFS32) x86d(a)
#define xMOVLPS_rm_r(rm,r)      x86s(3) x86b(0x0f) x86b(0x13) x86b(mREG(r) | (rm))

#define xMOVMSKPS_r_r(r1,r2)    x86s(3) x86b(0x0f) x86b(0x50) x86b(mREG(r1) | rmREG(r2))

#define xMOVNTPS_i128_r(a,r)    x86s(7) x86b(0x0f) x86b(0x2b) x86b(mREG(r) | mOFS32) x86d(a)
#define xMOVNTPS_rm_r(rm,r)     x86s(3) x86b(0x0f) x86b(0x2b) x86b(mREG(r) | (rm))

#define xMOVUPS_r_rm(r,rm)      x86s(3) x86b(0x0f) x86b(0x10) x86b(mREG(r) | (rm))
#define xMOVUPS_r_i128(r,a)     x86s(7) x86b(0x0f) x86b(0x10) x86b(mREG(r) | mOFS32) x86d(a)
#define xMOVUPS_rm_r(rm,r)      x86s(3) x86b(0x0f) x86b(0x11) x86b(mREG(r) | (rm))
#define xMOVUPS_i128_r(a,r)     x86s(7) x86b(0x0f) x86b(0x11) x86b(mREG(r) | mOFS32) x86d(a)

#define xMOVSS_r_rm(r,rm)       x86s(4) x86b(0xf3) x86b(0x0f) x86b(0x10) x86b(mREG(r) | (rm))
#define xMOVSS_r_i32(r,a)       x86s(8) x86b(0xf3) x86b(0x0f) x86b(0x10) x86b(mREG(r) | mOFS32) x86d(a)
#define xMOVSS_i32_r(a,r)       x86s(8) x86b(0xf3) x86b(0x0f) x86b(0x11) x86b(mREG(r) | mOFS32) x86d(a)

#define xMULPS_r_rm(r,rm)       x86s(3) x86b(0x0f) x86b(0x59) x86b(mREG(r) | (rm))
#define xMULPS_r_i128(r,a)      x86s(7) x86b(0x0f) x86b(0x59) x86b(mREG(r) | mOFS32) x86d(a)

#define xMULSS_r_rm(r,rm)       x86s(4) x86b(0xf3) x86b(0x0f) x86b(0x59) x86b(mREG(r) | (rm))

#define xRCPPS_r_rm(r,rm)       x86s(3) x86b(0x0f) x86b(0x53) x86b(mREG(r) | (rm))

#define xPREFETCH_rm8(h,rm,ofs) x86s(4) x86b(0x0f) x86b(0x18) x86b(mREG(h) | (rm)) x86b(ofs)

#define xPSHUFW_r_i64_imm(r,a,i) x86s(8) x86b(0xf) x86b(0x70) x86b(mREG(r) | mOFS32) x86d(a) x86b(i)
#define xPSHUFW_r_rm_imm(r,rm,i) x86s(4) x86b(0xf) x86b(0x70) x86b(mREG(r) | (rm)) x86b(i)

#define xSHUFPS_r_i64_imm(r,a,i) x86s(8) x86b(0x0f) x86b(0xc6) x86b(mREG(r) | mOFS32) x86d(a) x86b(i)
#define xSHUFPS_r_rm_imm(r,rm,i) x86s(4) x86b(0x0f) x86b(0xc6) x86b(mREG(r) | (rm)) x86b(i)

#define xSUBPS_r_rm(r,rm)       x86s(3) x86b(0x0f) x86b(0x5c) x86b(mREG(r) | (rm))
#define xSUBSS_r_rm(r,rm)       x86s(4) x86b(0xf3) x86b(0x0f) x86b(0x5c) x86b(mREG(r) | (rm))
#define xXORPS_r_rm(r,rm)       x86s(3) x86b(0x0f) x86b(0x57) x86b(mREG(r) | (rm))

 /*
 * Pentium 4 opcodes
 *
 * Note: Pentium 4 contains many equivalents to MMX instructions that use XMM registers instead of MM registers.
 * These new instructions are suffixed with an X after the opcode name.
 * example:
 *      MOVD    XMM0, ECX
 *  is
 *      xMOVDX_r_rm(rXMM0, rmREG(rECX))
 *
 *  do not write xMOVD_r_rm(rXMM0, rmREG(rECX)), as this actually generates MOVD    MM0, ECX   
 *
 * You would think that the macros would be smart enough to distinguish between XMM and MM registers, but they 
 * aren't. Sorry.
 */

#define xMOVDX_r_rm(r,rm)       x86s(4) x86b(0x66) x86b(0x0f) x86b(0x6e) x86b(mREG(r) | (rm))
#define xMOVDX_r_i32(r,a)       x86s(8) x86b(0x66) x86b(0x0f) x86b(0x6e) x86b(mREG(r) | mOFS32) x86d(a)
#define xMOVDX_rm_r(rm,r)       x86s(4) x86b(0x66) x86b(0x0f) x86b(0x7e) x86b(mREG(r) | (rm))
#define xMOVDX_i32_r(a,r)       x86s(8) x86b(0x66) x86b(0x0f) x86b(0x7e) x86b(mREG(r) | mOFS32) x86d(a)
#define xMOVSD_r_rm(r,rm)       x86s(4) x86b(0xf2) x86b(0x0f) x86b(0x10) x86b(mREG(r) | (rm))
#define xMOVSD_r_i128(r,a)      x86s(8) x86b(0xf2) x86b(0x0f) x86b(0x10) x86b(mREG(r) | mOFS32) x86d(a)
#define xMOVSD_rm_r(rm,r)       x86s(4) x86b(0xf2) x86b(0x0f) x86b(0x11) x86b(mREG(r) | (rm))
#define xMOVSD_i128_r(a,r)      x86s(8) x86b(0xf2) x86b(0x0f) x86b(0x11) x86b(mREG(r) | mOFS32) x86d(a)
#define xPADDBX_r_rm(r,rm)      x86s(4) x86b(0x66) x86b(0x0f) x86b(0xfc) x86b(mREG(r) | (rm))
#define xPADDBX_r_i64(r,a)      x86s(8) x86b(0x66) x86b(0x0f) x86b(0xfc) x86b(mREG(4) | mOFS32) x86d(a)
#define xPADDWX_r_rm(r,rm)      x86s(4) x86b(0x66) x86b(0x0f) x86b(0xfd) x86b(mREG(r) | (rm))
#define xPADDWX_r_i64(r,a)      x86s(8) x86b(0x66) x86b(0x0f) x86b(0xfd) x86b(mREG(4) | mOFS32) x86d(a)
#define xPADDDX_r_rm(r,rm)      x86s(4) x86b(0x66) x86b(0x0f) x86b(0xfe) x86b(mREG(r) | (rm))
#define xPADDDX_r_i64(r,a)      x86s(8) x86b(0x66) x86b(0x0f) x86b(0xfe) x86b(mREG(4) | mOFS32) x86d(a)
#define xPSHUFLW_r_i128_imm(r,a,i)  x86s(9) x86b(0xf2) x86b(0x0f) x86b(0x70) x86b(mREG(r) | mOFS32) x86d(a) x86b(i)
#define xPSHUFLW_r_rm_imm(r,rm,i)   x86s(5) x86b(0xf2) x86b(0x0f) x86b(0x70) x86b(mREG(r) | (rm)) x86b(i)
#define xPSHUFHW_r_i128_imm(r,a,i)  x86s(9) x86b(0xf3) x86b(0x0f) x86b(0x70) x86b(mREG(r) | mOFS32) x86d(a) x86b(i)
#define xPSHUFHW_r_rm_imm(r,rm,i)   x86s(5) x86b(0xf3) x86b(0x0f) x86b(0x70) x86b(mREG(r) | (rm)) x86b(i)
#define xPUNPCKLBWX_r_rm(r,rm)      x86s(4) x86b(0x66) x86b(0x0f) x86b(0x60) x86b(mREG(r) | (rm))
#define xPUNPCKLBWX_r_i128(r,a)     x86s(8) x86b(0x66) x86b(0x0f) x86b(0x60) x86b(mREG(r) | mOFS32) x86d(a)
#define xPUNPCKLWDX_r_rm(r,rm)      x86s(4) x86b(0x66) x86b(0x0f) x86b(0x61) x86b(mREG(r) | (rm))
#define xPUNPCKLWDX_r_i128(r,a)     x86s(8) x86b(0x66) x86b(0x0f) x86b(0x61) x86b(mREG(r) | mOFS32) x86d(a)
#define xPUNPCKLDQX_r_rm(r,rm)      x86s(4) x86b(0x66) x86b(0x0f) x86b(0x62) x86b(mREG(r) | (rm))
#define xPUNPCKLDQX_r_i128(r,a)     x86s(8) x86b(0x66) x86b(0x0f) x86b(0x62) x86b(mREG(r) | mOFS32) x86d(a)

 /*
 * 3dnow opcodes
 */
#define xFEMMS                  x86s(2) x86b(0x0f) x86b(0x0e)
#define xPFMUL_r_rm(r,rm)       x86s(4) x86b(0x0f) x86b(0x0f) x86b(mREG(r) | (rm)) x86b(0xb4)
#define xPFSUB_r_rm(r,rm)       x86s(4) x86b(0x0f) x86b(0x0f) x86b(mREG(r) | (rm)) x86b(0x9a)
#define xPFADD_r_rm(r,rm)       x86s(4) x86b(0x0f) x86b(0x0f) x86b(mREG(r) | (rm)) x86b(0x9e)
#define xPUNPCKHDQ_r_rm(r,rm)   x86s(3) x86b(0x0f) x86b(0x6a) x86b(mREG(r) | (rm))
#define xPUNPCKLDQ_r_rm(r,rm)   x86s(3) x86b(0x0f) x86b(0x62) x86b(mREG(r) | (rm))
#define xPFRCP_r_rm(r,rm) x86s(4) x86b(0x0f) x86b(0x0f) x86b(mREG(r) | (rm)) x86b(0x96)
#define xPFRCPIT1_r_rm(r,rm) x86s(4) x86b(0x0f) x86b(0x0f) x86b(mREG(r) | (rm)) x86b(0xa6)
#define xPFRCPIT2_r_rm(r,rm) x86s(4) x86b(0x0f) x86b(0x0f) x86b(mREG(r) | (rm)) x86b(0xb6)
#define xPSWAPD_r_rm(r,rm) x86s(4) x86b(0x0f) x86b(0x0f) x86b(mREG(r) | (rm)) x86b(0xbb)
#define xPFNACC_r_rm(r,rm) x86s(4) x86b(0x0f) x86b(0x0f) x86b(mREG(r) | (rm)) x86b(0x8a)

/*****************************************************************************
 * macros
 *****************************************************************************/

#if defined(IS_OPENGL)

#define ILC_GROW_TO(x) assert(!"can't grow ilcCount")

#else

/*****************************************************************************
 * externals
 *****************************************************************************/
void ILCGrowTo(unsigned long dwNeed);

#define ILC_GROW_TO(x) ILCGrowTo(x)

#endif

/*
 * emission
 */
#define x86s(x)                 if ((ilcCount+(x)) > ilcMax) ILC_GROW_TO(ilcCount+(x));
#define x86b(x)                 ilcData[ilcCount]=(unsigned char) (x); ilcCount++;
#define x86w(x)					*(unsigned short *) (ilcData + ilcCount) = (unsigned short) (x); ilcCount += 2;
#define x86d(x)                 *(unsigned int *) (ilcData+ilcCount) = (unsigned int) (x); ilcCount+=4;

/*
 * mod r/m
 */
#define mOFS32                  rmIND(rEBP)
#define mREG(x)                 ((x) << 3)

#define rmIND(x)                (0x00 | (x))
#define rmIND8(x)               (0x40 | (x))
#define rmIND32(x)              (0x80 | (x))
#define rmREG(x)                (0xc0 | (x))
#define rmSIB                   rmIND(rESP)
#define rmSIB8                  rmIND8(rESP)
#define rmSIB32                 rmIND32(rESP)

#define times1                  0
#define times2                  1
#define times4                  2
#define times8                  3

#if !defined(IS_OPENGL)
////// Don't use these macro names!  They are used everywhere as vars and members!
#define x1                      times1
#define x2                      times2
#define x4                      times4
#define x8                      times8
#else
////// Don't use these macro names!  They are used everywhere as vars and members!
#endif // !defined(IS_OPENGL)


// xSIBID is used to write expressions like "mov    eax, [ebx*4+0x01234567]" (index + displacement)
// Note that you can't use EBP as a base in an SIB expression the way you think you can:
// 
// mov  eax, [ebp+edx*4] != xMOV_r_rm    (rEAX, rmSIB) xSIB(rEBP,rEDX,x4)
// Specifying EBP in xSIB like this is interpreted as a 32 bit displacement. So you
// have to write:
// xMOV_r_rm    (rEAX, rmSIB8) xSIB(rEBP, rEDX, x4) xOFS8(0) which is technically:
// mov eax, [ebp+edx*4+0]

#define xSIB(r1,r2,s)           x86s(1) x86b((r1) | ((r2)<<3) | ((s)<<6))
#define xSIB32(r1,r2,e)         x86s(1) x86b((r1) | ((r2)<<3) | ((times1)<<6)) xOFS32(e)
#define xSIBID(r2,s)            x86s(1) x86b((rEBP) | ((r2)<<3) | ((s)<<6))
#define xSIB_esp                xSIB(rESP, rESP, times1)
#define xSIB8_esp(e)            xSIB_esp xOFS8(e)
#define xSIB32_esp(e)           xSIB_esp xOFS32(e)

#define x16r                    x86s(1) x86b(0x66)
#define x16m                    x86s(1) x86b(0x67)

#define xDS                     x86s(1) x86b(0x3e)

#define xOFS8(e)                x86s(1) x86b(e)
#define xOFS32(e)               x86s(4) x86d(e)

#define mMEM8(x)               ((unsigned int) &(x))
#define mMEM32(x)              ((unsigned int) &(x))
#define mMEM64(x)              ((unsigned int) &(x))
#define mMEM128(x)             ((unsigned int) &(x))

/*
 * jumps * branches
 */
#define xLABEL(x)               (x) = ilcCount;
#define xTARGET_b8(x)           *(unsigned char *) (ilcData + (x) + 1) = (unsigned char) (ilcCount - ((x) + 2));
#define xTARGET_b32(x)          *(unsigned int *) (ilcData + (x) + 2) = (unsigned int) (ilcCount - ((x) + 6));
#define xTARGET_jmp(x)          *(unsigned int *) (ilcData + (x) + 1) = (unsigned int) (ilcCount - ((x) + 5));

/*
 * inline instructions not supported by built-in asm
 */
#define rdtsc  __asm _emit 0x0f __asm _emit 0x31
#define sfence __asm _emit 0x0f __asm _emit 0xae __asm _emit 0xf8

// For tracking codegen position across function calls
#define X86_CODE_DECLARE            \
    unsigned int ilcCount, ilcMax;  \
    unsigned char *ilcData

#define X86_CODE_LOAD(p)            \
    ilcCount = (p)->ilcCount;       \
    ilcMax = (p)->ilcMax;           \
    ilcData = (p)->ilcData

#define X86_CODE_RESTORE(p)         \
    (p)->ilcCount = ilcCount;       \
    (p)->ilcMax = ilcMax;           \
    (p)->ilcData = ilcData

#ifdef __cplusplus
}
#endif

#endif // x86.h
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\common\mac\inc\naming.h ===
/*
	naming.h -- use 'Monica' or NVIDIA naming scheme
*/

#ifndef __NAMING__
#define __NAMING__

#define MONICA_NAMES	0		// Set to 1 if drivers use 'Monica' names, 0 if NVIDIA names

#if MONICA_NAMES
#define PROP_PREFIX		"MNCA,"	// prefix value for Name Registry properties
#else
#define PROP_PREFIX		"NVDA,"
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\common\mac\inc\driverinfo.h ===
/*
	driverinfo.h
*/

#include "naming.h"			// For Monica or NVIDIA names

#define FB_OFFSET	(16 * 1024)		// Offset (in bytes) of the frame buffer's first displayed pixel

#ifndef DEVICENAMESTRING
// This is the name of the NVIDIA board's Name Registry node, assigned by FCode.  If you have
//	multiple NV boards in your system, you'll have multiple "NVDA,NVMac" nodes and will need to
//	figure out (with bus and slot information) which one you want to use.
#if MONICA_NAMES	// Value set in naming.h
#define DEVICENAMESTRING	"MNCA,Monica"	// Generic NV with Mac ROM
#else
#define DEVICENAMESTRING	"NVDA,NVMac"	// Generic NV with Mac ROM
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\common\mac\inc\macEnv.h ===
#ifndef __MACENV__
#define __MACENV__


#ifdef __cplusplus
extern "C" {
#endif



char * GetEnv( char * inKey );
void SetEnv( char * inKey, char * inValue );



#ifdef __cplusplus
}
#endif

#endif /* __MACENV__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\common\mac\qdregions\ReleaseBuild.h ===
/******************************************************************************

 ReleaseBuild.h -- for the Resource-Manager-aware display driver

 *****************************************************************************/

#define DEBUG_BUILD			0
#define PROFILE_BUILD		0
#define STANDALONE_BUILD	0
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\common\mac\qdregions\DebugBuild.h ===
/******************************************************************************

 DebugBuild.h -- for the Resource-Manager-aware display driver

 *****************************************************************************/

#define DEBUG_BUILD			0	// Disable debugging until we resolve the link issues
#define PROFILE_BUILD		0
#define STANDALONE_BUILD	0
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\common\mac\qdregions\debug.h ===
/*
	debug.h

	Change history (most recent first):

	Date		By		Comments
	----		--		--------

	02-13-2000	SF		Added new routines, tweaked some old routine names 
	02-09-2000	SF		Added definitions for the font-drawing code
	11-16-1999	SF		DEBUGGER & SYSDEBUGSTR abstracted

*/

#include <MacTypes.h>
#include <stdarg.h>

/* Examples of debugging macro usage:

	DBUG();
		Drops into MacsBug with a user break, and no message.
	DBUGSTR("This is a message\n");
		Drops into MacsBug and prints the literal C string.
	DBUGPRINTF(("Max count = %d, address = 0x%X\n", max, addr));
		Drops into MacsBug and prints the printf-style formatted C string,
		such as "Max count = 25, address = 0x259A0E".
		Note that the formatted string and numeric arguments have to be
		enclosed in an extra set of parentheses in order to hide the
		variable number of arguments from the macro preprocessor.
		Currently, the %c, %u, %d, %x, %X, %f, and %s data types are implemented.
	DBUGIF(x != 7);
		Drops into MacsBug with a user break (no message) if the
		condition is true.
	DBUGSTRIF(handle == nil, "We got a bad handle!\n");
		Drops into MacsBug if the condition is true and prints the literal C string.
	DBUGPRINTFIF(freenodes < 10, ("Node count = %d, header at 0x%x\n", freenodes, hdraddr));
		Drops into MacsBug if the condition is true and prints the printf-style
		formatted C string, such as "Node count = 7, header at 0x8B207C".
		Note that the formatted string and numeric arguments have to be
		enclosed in an extra set of parentheses in order to hide the
		variable number of arguments from the macro preprocessor.
		Currently, the %c, %u, %d, %x, %X, %f, and %s data types are implemented.
	DBUGASSERT(x >= 0);
		Drops into MacsBug if the asserted condition is false, printing a message
		that lists the failed assertion condition and the file name and line
		number of the ASSERT statement, such as:
		"ASSERT(x >= 0) failed: 'main.c' line 324"

	// These are the 'drawing directly to the screen' equivalents
	_RAWSTR("This is a message\n");
		Draws the literal C string directly to the screen.  It doesn't invoke MacsBug.
	_RAWPRINTF(("Max count = %d, address = 0x%X\n", max, addr));
		Draws the printf-style formatted C string directly to the screen,
		such as "Max count = 25, address = 0x259A0E".  It doesn't invoke MacsBug.
		Note that the formatted string and numeric arguments have to be
		enclosed in an extra set of parentheses in order to hide the
		variable number of arguments from the macro preprocessor.
		Currently, the %c, %u, %d, %x, %X, %f, and %s data types are implemented.
	_RAWSTRIF(handle == nil, "We got a bad handle (it was nil)!\n");
		If the condition is true, it draws the literal C string directly to the screen.
		It doesn't invoke MacsBug.
	_RAWPRINTFIF(freenodes < 10, ("Node count = %d, header at 0x%x\n", freenodes, hdraddr));
		If the condition is true, it draws the printf-style formatted C string directly
		to the screen, such as "Node count = 7, header at 0x8B207C".  It doesn't invoke
		MacsBug.  Note that the formatted string and numeric arguments have to be
		enclosed in an extra set of parentheses in order to hide the
		variable number of arguments from the macro preprocessor.
		Currently, the %c, %u, %d, %x, %X, %f, and %s data types are implemented.
	_RAWASSERT(x >= 0);
		If the asserted condition is false, it prints a message directly to the screen
		that lists the failed assertion condition and the file name and line
		number of the ASSERT statement, such as:
		"ASSERT(x >= 0) failed: 'main.c' line 324"  It doesn't invoke MacsBug.
*/


#if DEBUG_BUILD	// All the macros are enabled and generate code for debug builds

// allow overrides via a Makefile
#ifndef _LOGTOMEM
#define _LOGTOMEM	0       	// Set to 1 to log to memory
#endif

#ifndef _RAWDRAW
#define _RAWDRAW	0			// Set to 1 for raw screen printfs, 0 to suppress
#endif

#define DEBUGGER	if ((*(UInt8 *)0xBFF & 0x20) != 0) Debugger	// Debugger for apps, SysDebug for drivers
#define DEBUGSTR	if ((*(UInt8 *)0xBFF & 0x20) != 0) DebugStr	// DebugStr for regular apps, SysDebugStr for drivers

#define DBUG()						\
			DEBUGGER()
#define DBUGSTR(str)				\
			DEBUGSTR("\p" str)
#define DBUGPRINTF(parenargs)		\
			DEBUGSTR(dbugfmttopstr parenargs)
#define DBUGIF(cond)				\
			if (cond)				\
				DEBUGGER()
#define DBUGSTRIF(cond, str)		\
			if (cond)				\
				DEBUGSTR("\p" str)
#define DBUGPRINTFIF(cond, parenargs)	\
			if (cond)				\
				DEBUGSTR(dbugfmttopstr parenargs)

/* The following two macros are utilities to do argument-to-string conversion. */
#define _QUOTE(_x)					#_x
#define _MAKESTR(_x)				_QUOTE(_x)

/* The DBUGASSERT macro tells us what file and line the assertion failed at. */
#define DBUGASSERT(cond)			\
			if (!(cond))			\
				DEBUGSTR("\pASSERT(" #cond ") failed: '" __FILE__	\
							"' line " _MAKESTR(__LINE__))
#if _LOGTOMEM

typedef struct {
	UInt32		signature;
	UInt32		memType;
	UInt8		*bufBase;
	UInt32		bufSize;
	UInt32		putOffset;
	UInt32		getOffset;
} LogHdr, *LogHdrPtr;

#define NOWRAP			0				// Don't wrap output in the buffer
#define DOWRAP			1				// Wrap output in the buffer
#define BUFFERWRAP		NOWRAP			// Set to DOWRAP or NOWRAP
#define SYSTEMMEM		0
#define VIDEOMEM		1
#define LOGMEM			SYSTEMMEM		// Set to SYSTEMMEM or VIDEOMEM
#define VIDEOBUFSIZE	(2*1024*1024)
#define VIDEOBUFOFFSET	(24*1024*1024)
#define SYSTEMBUFSIZE	(2*1024*1024)

#define LOGPROPERTY					"LOG"			// Our logging property name
#define LOGONSIGNATURE				'LOG1'			// Signature showing we're logging
#define LOGOFFSIGNATURE				'LOG0'			// Signature showing logging is disabled
#define DEVICENAME					"NVDA,NVMac"	// C string
#define DEVICEPNAMEANDNULL			"\p" DEVICENAME "\0"

#define LOGSTR(str)					\
			dbglogstr(str)
#define LOGPRINTF(parenargs)		\
			dbglogstr(dbugfmttostr parenargs)
#define LOGPRINTFIF(cond, parenargs)	\
			if (cond)				\
				dbglogstr(dbugfmttostr parenargs)
#else

#define LOGSTR(str)
#define LOGPRINTF(parenargs)
#define LOGPRINTFIF(cond, parenargs)

#endif


#if _RAWDRAW

#define _RAWSTR(str)				\
			dbgdrawstr(str)
#define _RAWPRINTF(parenargs)		\
			dbgdrawstr(dbugfmttostr parenargs)
#define _RAWSTRIF(cond, str)		\
			if (cond)				\
				dbgdrawstr(str)
#define _RAWPRINTFIF(cond, parenargs)	\
			if (cond)				\
				dbgdrawstr(dbugfmttostr parenargs)
#define _RAWASSERT(cond)			\
			if (!(cond))			\
				dbgdrawstr("ASSERT(" #cond ") failed: '" __FILE__	\
							"' line " _MAKESTR(__LINE__) "\n")

#else

#define _RAWSTR(str)
#define _RAWPRINTF(parenargs)
#define _RAWSTRIF(cond, str)
#define _RAWPRINTFIF(cond, parenargs)
#define _RAWASSERT(cond)				

#endif

//=====================================================================================================
//
// Routines exported from debug.c (see that file for full descriptions)
//
//=====================================================================================================

extern char *dbugfmttostr(const char *fmt, ...);
extern UInt8 *dbugfmttopstr(const char *fmt, ...);
extern int dbugsprintf(char *dest, const char *fmt, ...);
extern int dbugvsprintf(char *dest, const char *fmt, va_list args);
extern void dbglogstr(char *str);
extern void dbgdrawstr(char *str);

// The following are utility routines used by dbugsprintf() to format different types
//	of data values.  Most of the time you won't need to use them directly, but they're
//	listed here for completeness.  Consult the code in debug.c for sprintf() for
//	examples of how to use them.
extern int int32todecfmtstr(SInt32 s32val, UInt8 *dest, int fieldwidth, int flags);
extern int uint32tohexfmtstr(UInt32 u32val,  UInt8 *dest, int fieldwidth, int flags);
extern int float64todecfmtstr(Float64 f64val, UInt8 *dest, int fieldwidth,
								int precision, int flags);
extern int strtofmtstr(UInt8 *src, UInt8 *dest, int fieldwidth, int flags);
extern int millisectimestampfmtstr(UInt8 *dest, int fieldwidth, int flags);

// Numeric & string conversion flags (used if you call the 'XtoYfmtstr' routines directly)
enum {
	DONTTERMINATE = 1,	// Don't null-terminate the string if this flag is set
	UNSIGNED_F = 2,		// Force an unsigned number conversion (other sign options are ignored)
	PLUSSIGN_F = 4,		// For signed numbers >= 0, force a '+' in the sign position
	SPACESIGN_F = 8,	// For signed numbers >= 0, force a space in the sign position
	LEFTALIGN_F = 16,	// Left-justify the result in the destination field (overrides zero fill)
	ZEROFILL_F = 32,	// Use leading zeros for padding to a field width
	LOWERCASE_F = 64	// Use lower case hex digits: a-f instead of A-F
};


#else	// All the macros are disabled and don't generate any code for release builds


#define DBUG()
#define DBUGSTR(str)
#define DBUGPRINTF(parenargs)
#define DBUGIF(cond)
#define DBUGSTRIF(cond, str)
#define DBUGPRINTFIF(cond, parenargs)
#define DBUGASSERT(cond)

#define _LOGTOMEM	0	// Don't do logging if we're not doing a debug build
#define LOGSTR(str)
#define LOGPRINTF(parenargs)
#define LOGPRINTFIF(cond, parenargs)

#define _RAWDRAW	0	// Don't do raw drawing if we're not doing a debug build
#define _RAWSTR(str)
#define _RAWPRINTF(parenargs)
#define _RAWSTRIF(cond, str)
#define _RAWPRINTFIF(cond, parenargs)
#define _RAWASSERT(cond)				

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\common\mac\utils\QD app\ReleaseBuild.h ===
/******************************************************************************

 ReleaseBuild.h -- for the Resource-Manager-aware display driver

 *****************************************************************************/

#define DEBUG_BUILD			0
#define PROFILE_BUILD		0
#define STANDALONE_BUILD	0
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\common\mac\utils\QD app\DebugBuild.h ===
/******************************************************************************

 DebugBuild.h -- for the Resource-Manager-aware display driver

 *****************************************************************************/

#define DEBUG_BUILD			1
#define PROFILE_BUILD		0
#define STANDALONE_BUILD	0
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\common\mac\utils\QD app\debug.h ===
/*
	debug.h

	Change history (most recent first):

	Date		By		Comments
	----		--		--------

	02-13-2000	SF		Added new routines, tweaked some old routine names 
	02-09-2000	SF		Added definitions for the font-drawing code
	11-16-1999	SF		DEBUGGER & SYSDEBUGSTR abstracted

*/

#include <MacTypes.h>
#include <stdarg.h>

/* Examples of debugging macro usage:

	DBUG();
		Drops into MacsBug with a user break, and no message.
	DBUGSTR("This is a message\n");
		Drops into MacsBug and prints the literal C string.
	DBUGPRINTF(("Max count = %d, address = 0x%X\n", max, addr));
		Drops into MacsBug and prints the printf-style formatted C string,
		such as "Max count = 25, address = 0x259A0E".
		Note that the formatted string and numeric arguments have to be
		enclosed in an extra set of parentheses in order to hide the
		variable number of arguments from the macro preprocessor.
		Currently, the %c, %u, %d, %x, %X, %f, and %s data types are implemented.
	DBUGIF(x != 7);
		Drops into MacsBug with a user break (no message) if the
		condition is true.
	DBUGSTRIF(handle == nil, "We got a bad handle!\n");
		Drops into MacsBug if the condition is true and prints the literal C string.
	DBUGPRINTFIF(freenodes < 10, ("Node count = %d, header at 0x%x\n", freenodes, hdraddr));
		Drops into MacsBug if the condition is true and prints the printf-style
		formatted C string, such as "Node count = 7, header at 0x8B207C".
		Note that the formatted string and numeric arguments have to be
		enclosed in an extra set of parentheses in order to hide the
		variable number of arguments from the macro preprocessor.
		Currently, the %c, %u, %d, %x, %X, %f, and %s data types are implemented.
	DBUGASSERT(x >= 0);
		Drops into MacsBug if the asserted condition is false, printing a message
		that lists the failed assertion condition and the file name and line
		number of the ASSERT statement, such as:
		"ASSERT(x >= 0) failed: 'main.c' line 324"

	// These are the 'drawing directly to the screen' equivalents
	_RAWSTR("This is a message\n");
		Draws the literal C string directly to the screen.  It doesn't invoke MacsBug.
	_RAWPRINTF(("Max count = %d, address = 0x%X\n", max, addr));
		Draws the printf-style formatted C string directly to the screen,
		such as "Max count = 25, address = 0x259A0E".  It doesn't invoke MacsBug.
		Note that the formatted string and numeric arguments have to be
		enclosed in an extra set of parentheses in order to hide the
		variable number of arguments from the macro preprocessor.
		Currently, the %c, %u, %d, %x, %X, %f, and %s data types are implemented.
	_RAWSTRIF(handle == nil, "We got a bad handle (it was nil)!\n");
		If the condition is true, it draws the literal C string directly to the screen.
		It doesn't invoke MacsBug.
	_RAWPRINTFIF(freenodes < 10, ("Node count = %d, header at 0x%x\n", freenodes, hdraddr));
		If the condition is true, it draws the printf-style formatted C string directly
		to the screen, such as "Node count = 7, header at 0x8B207C".  It doesn't invoke
		MacsBug.  Note that the formatted string and numeric arguments have to be
		enclosed in an extra set of parentheses in order to hide the
		variable number of arguments from the macro preprocessor.
		Currently, the %c, %u, %d, %x, %X, %f, and %s data types are implemented.
	_RAWASSERT(x >= 0);
		If the asserted condition is false, it prints a message directly to the screen
		that lists the failed assertion condition and the file name and line
		number of the ASSERT statement, such as:
		"ASSERT(x >= 0) failed: 'main.c' line 324"  It doesn't invoke MacsBug.
*/


#if DEBUG_BUILD	// All the macros are enabled and generate code for debug builds

#define _RAWDRAW	0			// Set to 1 for raw screen printfs, 0 to suppress

#define DEBUGGER	Debugger	// Debugger for apps, SysDebug for drivers
#define DEBUGSTR	DebugStr	// DebugStr for regular apps, SysDebugStr for drivers

#define DBUG()						\
			DEBUGGER()
#define DBUGSTR(str)				\
			DEBUGSTR("\p" str)
#define DBUGPRINTF(parenargs)		\
			DEBUGSTR(dbugfmttopstr parenargs)
#define DBUGIF(cond)				\
			if (cond)				\
				DEBUGGER()
#define DBUGSTRIF(cond, str)		\
			if (cond)				\
				DEBUGSTR("\p" str)
#define DBUGPRINTFIF(cond, parenargs)	\
			if (cond)				\
				DEBUGSTR(dbugfmttopstr parenargs)

/* The following two macros are utilities to do argument-to-string conversion. */
#define _QUOTE(_x)					#_x
#define _MAKESTR(_x)				_QUOTE(_x)

/* The DBUGASSERT macro tells us what file and line the assertion failed at. */
#define DBUGASSERT(cond)			\
			if (!(cond))			\
				DEBUGSTR("\pASSERT(" #cond ") failed: '" __FILE__	\
							"' line " _MAKESTR(__LINE__))

#if _RAWDRAW

#define _RAWSTR(str)				\
			dbgdrawstr(str)
#define _RAWPRINTF(parenargs)		\
			dbgdrawstr(dbugfmttostr parenargs)
#define _RAWSTRIF(cond, str)		\
			if (cond)				\
				dbgdrawstr(str)
#define _RAWPRINTFIF(cond, parenargs)	\
			if (cond)				\
				dbgdrawstr(dbugfmttostr parenargs)
#define _RAWASSERT(cond)			\
			if (!(cond))			\
				dbgdrawstr("ASSERT(" #cond ") failed: '" __FILE__	\
							"' line " _MAKESTR(__LINE__) "\n")

#else

#define _RAWSTR(str)
#define _RAWPRINTF(parenargs)
#define _RAWSTRIF(cond, str)
#define _RAWPRINTFIF(cond, parenargs)
#define _RAWASSERT(cond)				

#endif

//=====================================================================================================
//
// Routines exported from debug.c (see that file for full descriptions)
//
//=====================================================================================================

extern char *dbugfmttostr(const char *fmt, ...);
extern UInt8 *dbugfmttopstr(const char *fmt, ...);
extern int dbugsprintf(char *dest, const char *fmt, ...);
extern int dbugvsprintf(char *dest, const char *fmt, va_list args);
extern void dbgdrawstr(char *str);

// The following are utility routines used by dbugsprintf() to format different types
//	of data values.  Most of the time you won't need to use them directly, but they're
//	listed here for completeness.  Consult the code in debug.c for sprintf() for
//	examples of how to use them.
extern int int32todecfmtstr(SInt32 s32val, UInt8 *dest, int fieldwidth, int flags);
extern int uint32tohexfmtstr(UInt32 u32val,  UInt8 *dest, int fieldwidth, int flags);
extern int float64todecfmtstr(Float64 f64val, UInt8 *dest, int fieldwidth,
								int precision, int flags);
extern int strtofmtstr(UInt8 *src, UInt8 *dest, int fieldwidth, int flags);

// Numeric & string conversion flags (used if you call the 'XtoYfmtstr' routines directly)
enum {
	DONTTERMINATE = 1,	// Don't null-terminate the string if this flag is set
	UNSIGNED_F = 2,		// Force an unsigned number conversion (other sign options are ignored)
	PLUSSIGN_F = 4,		// For signed numbers >= 0, force a '+' in the sign position
	SPACESIGN_F = 8,	// For signed numbers >= 0, force a space in the sign position
	LEFTALIGN_F = 16,	// Left-justify the result in the destination field (overrides zero fill)
	ZEROFILL_F = 32,	// Use leading zeros for padding to a field width
	LOWERCASE_F = 64	// Use lower case hex digits: a-f instead of A-F
};


#else	// All the macros are disabled and don't generate any code for release builds


#define DBUG()						
#define DBUGSTR(str)				
#define DBUGPRINTF(parenargs)		
#define DBUGIF(cond)				
#define DBUGSTRIF(cond, str)		
#define DBUGPRINTFIF(cond, parenargs)	
#define DBUGASSERT(cond)				
#define _RAWDRAW	0	// Don't do raw drawing if we're not doing a debug build
#define _RAWSTR(str)
#define _RAWPRINTF(parenargs)
#define _RAWSTRIF(cond, str)
#define _RAWPRINTFIF(cond, parenargs)
#define _RAWASSERT(cond)				

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\common\mac\utils\QD app\debug.c ===
/*
	debug.c

	Change history (most recent first):

	Date		By		Comments
	----		--		--------

	02-13-2000	SF		Reorganized the code, added more comments
	02-11-2000	SF		Added 'u', 's', 'f', field width, and precision support ('f' only)
	02-09-2000	SF		Added font-drawing tables and code for tough debugs
	12-08-1999	SF		Added 'c', 'X', and 'x' support, skip width specifier
	11-16-1999	SF		Basic macros and procedure names

*/

#include <stdarg.h>
#include <stdio.h>
#include <string.h>
#include <MacTypes.h>
#include <QuickDraw.h>
#include "debug.h"


#if DEBUG_BUILD		// Only generate code if we're doing a debug build

static char dbugstrbuf[512];	// Should be big enough for our usage


//=====================================================================================================
//
// dbugfmttostr()
//
//	This renders a printf-style argument list into a C string in a static buffer, and
//	returns a pointer to the beginning of the C string.  The arguments are the same as
//	what printf() uses.  See the description of dbugsprintf() for comments on the supported
//	print formatting options.
//
//=====================================================================================================

char *dbugfmttostr(const char *fmt, ...)
{
	va_list args;

	va_start(args, fmt);
	dbugvsprintf(&dbugstrbuf[0], fmt, args);
	va_end(args);
	return(dbugstrbuf);		// Point to the Pascal string (length byte first)
}

//=====================================================================================================
//
// dbugfmttopstr()
//
//	This renders a printf-style argument list into a Pascal string in a static buffer, and
//	returns a pointer to the beginning of the Pascal string.  The arguments are the same as
//	what printf() uses.  See the description of dbugsprintf() for comments on the supported
//	print formatting options.
//
//=====================================================================================================

UInt8 *dbugfmttopstr(const char *fmt, ...)
{
	va_list args;

	va_start(args, fmt);
	dbugstrbuf[0] = dbugvsprintf(&dbugstrbuf[1], fmt, args);	// Set the Pascal length byte
	va_end(args);
	return((UInt8 *)dbugstrbuf);	// Point to the Pascal string (length byte first)
}

//=====================================================================================================
//
// dbugsprintf()
//
//	It's equivalent to sprintf() -- it operates on C strings, recognizes many of the same
//	formatting options as sprintf, and returns the number of characters written to the
//	destination buffer.  It supports the following format types: c, u, d, x, X, f, and s,
//	with optional flags field width, and precision support ('f' only)
//	The 'precision' specifier is only implemented for floating point numbers, and '%f'
//	is the only floating point format implemented.  The field width specifier is fully
//	implemented for the options where it makes sense.  (See printf() documentation.)
//
//=====================================================================================================

int dbugsprintf(char *dest, const char *fmt, ...)
{
	int n;
	va_list args;

	va_start(args, fmt);
	n = dbugvsprintf(dest, fmt, args);
	va_end(args);
	return(n);		// Return the number of characters transferred
}

//=====================================================================================================
//
// dbugvsprintf()
//
//	This does the guts of dbugsprintf(), and takes a var-arg list instead of '...'
//
//=====================================================================================================

int dbugvsprintf(char *dest, const char *fmt, va_list args)
{
	int ch, fieldwidth, precision, flags;
	int usedefaultprecision;
	SInt32 s32val;
	UInt32 u32val;
	Float64 f64val;
	UInt8 *f, *d, *specptr;
	UInt8 *strpval;

	if (dest == nil)
		return(0);	// If we don't have a destination, we didn't do any characters

	f = (UInt8 *)fmt;
	d = (UInt8 *)dest;

	while ((ch = *f++) != 0) {
		if (ch != '%') {
			*d++ = ch;
			continue;
		}
		specptr = f - 1;	// Save a pointer to the '%' specifier, in case of syntax errors
		ch = *f++;

		flags = DONTTERMINATE;	// Don't terminate substrings -- we'll null-terminate when we're all done
		// Check for left-alignment
		if (ch == '-') {
			flags |= LEFTALIGN_F;
			ch = *f++;
		}
		// Check for using a plus sign for non-negative numbers
		if (ch == '+') {
			flags |= PLUSSIGN_F;
			ch = *f++;
		}
		// Check for using a space character (sign place-holder) for non-negative numbers
		if (ch == ' ') {
			flags |= SPACESIGN_F;
			ch = *f++;
		}
		// Check for leading zero fill
		if (ch == '0') {
			flags |= ZEROFILL_F;
			// Don't bump the character pointer in case '0' was the only digit
		}
		// Collect the field width specifier
		fieldwidth = 0;	// Default field width
		while (ch >= '0' && ch <= '9') {
			fieldwidth = fieldwidth * 10 + ch - '0';
			ch = *f++;
		}
		usedefaultprecision = true;	// In case a precision wasn't specified
		// Check for a precision specifier
		if (ch == '.') {	// We have a precision specifier, skip the '.'
			ch = *f++;
			precision = 0;	// Start with 0
			while (ch >= '0' && ch <= '9') {
				precision = precision * 10 + ch - '0';
				ch = *f++;
			}
			usedefaultprecision = false;
		}

		// Perform the conversion operation
		switch (ch) {
		case 'c':	// Copy an ASCII character
			u32val = va_arg(args, int);
			*d++ = u32val;
			break;
		case 'u':	// Copy a formatted, unsigned decimal number
			flags |= UNSIGNED_F;
		case 'd':	// Copy a formatted, signed decimal number
			s32val = va_arg(args, int);
			// Format the number, increment the dest pointer by the characters copied
			d += int32todecfmtstr(s32val, d, fieldwidth, flags);
			break;
		case 'x':	// Copy a formatted, lower-case hexadecimal number
			flags |= LOWERCASE_F;
		case 'X':	// Copy a formatted, upper-case hexadecimal number
			u32val = va_arg(args, int);
			// Format the number, increment the dest pointer by the characters copied
			d += uint32tohexfmtstr(u32val, d, fieldwidth, flags);
			break;
		case 'f':	// Copy a formatted floating point number
			f64val = va_arg(args, Float64);
			if (usedefaultprecision)
				precision = 6;
			// Format the number, increment the dest pointer by the characters copied
			d += float64todecfmtstr(f64val, d, fieldwidth, precision, flags);
			break;
		case 's':	// Copy a formatted string
			strpval = va_arg(args, UInt8 *);
			d += strtofmtstr(strpval, d, fieldwidth, flags);
			break;
		case '%':	// Copy a formatted '%' sign
			d += strtofmtstr((UInt8 *)"%", d, fieldwidth, flags);
			break;
		case 0:		// Gracefully handle premature end-of-string
			f--;	// Back up, now f points to the null character again
		default:	// Unexpected conversion operator, so just echo to the destination
			while (specptr < f)
				*d++ = *specptr++;
			if (ch == 0)
				goto stringdone;
			break;
		}
	}

stringdone:
	*d = 0;	// Null-terminate the string
	return(d - (UInt8 *)dest);	// Return the number of characters we transferred
}

enum {	// Padding option definitions
	PRESPACE_O = 1,
	PREZERO_O = 2,
	POSTSPACE_O = 4
};


#define NUMBUFSIZE	16	// Should be enough for 32-bit integers in decimal or hex

//=====================================================================================================
//
// int32todecfmtstr()
//
//	This takes a 32-bit integer value and converts it to a formatted decimal string,
//	using options (field width and flags) like those provided by sprintf().  The 32-bit
//	number is assumed to be signed unless the UNSIGNED_F flag is set.  Look at the code
//	for dbugsprintf() above to see which formatting options are implemented.
//
//=====================================================================================================

int int32todecfmtstr(SInt32 s32val, UInt8 *dest, int fieldwidth, int flags)
{
	int i, digitcount, destcount;
	int sign, signchar;
	int fillcount;
	int pad_options;
	UInt32 u32val, quotient, remainder;
	UInt8 *intdigp;
	UInt8 nbuf[NUMBUFSIZE];

	// Process the sign-related options
	if (flags & UNSIGNED_F) {	// Unsigned conversion
		sign = 0;	// No sign character
	} else {	// We're doing a signed conversion
		sign = 1;	// Assume we'll have a sign character
		if (s32val < 0) {
			signchar = '-';
			s32val = -s32val;	// Make the number positive now so we can 'digitize' it
		} else {	// s32val >= 0
			if (flags & PLUSSIGN_F)
				signchar = '+';
			else if (flags & SPACESIGN_F)
				signchar = ' ';
			else
				sign = 0;	// No sign character
		}
	}
	u32val = s32val;	// Do unsigned math from here on out

	// Convert the number into ASCII decimal digits in our local buffer, counting them
	intdigp = &nbuf[NUMBUFSIZE];	// Point past the last character in the buffer
	digitcount = 0;	// Nothing written to our local buffer yet
	do {
		quotient = u32val / 10;
		remainder = u32val - quotient * 10;
		*--intdigp = remainder + '0';	// Put the digit into the next lower buffer slot
		digitcount++;
		u32val = quotient;
	} while (u32val > 0);

	// Process the field-padding options
	pad_options = 0;	// Assume we won't be doing any padding
	fillcount = fieldwidth - (sign + digitcount);	// Account for the sign, if used
	if (fillcount > 0) {	// We need to do left or right padding
		if (flags & LEFTALIGN_F) {
			pad_options = POSTSPACE_O;
		} else {	// Right-aligned, fill with zeros or spaces
			if (flags & ZEROFILL_F)
				pad_options = PREZERO_O;
			else
				pad_options = PRESPACE_O;
		}
	}

	destcount = 0;	// Nothing written out to the destination yet

	// Copy any leading spaces
	if (pad_options & PRESPACE_O) {
		for (i = 0; i < fillcount; i++)	// Copy the pad character(s)
			*dest++ = ' ';
		destcount += fillcount;
	}
	// Copy the sign character, if any
	if (sign) {
		*dest++ = signchar;
		destcount++;
	}
	// Copy any leading zeros
	if (pad_options & PREZERO_O) {
		for (i = 0; i < fillcount; i++)	// Copy the pad character(s)
			*dest++ = '0';
		destcount += fillcount;
	}
	// Copy the decimal digits from our local buffer
	for (i = 0; i < digitcount; i++)
		*dest++ = *intdigp++;
	destcount += digitcount;

	// Copy any trailing spaces
	if (pad_options & POSTSPACE_O) {
		for (i = 0; i < fillcount; i++)	// Copy the pad character(s)
			*dest++ = ' ';
		destcount += fillcount;
	}
	if ((flags & DONTTERMINATE) == 0)	// Null-terminate the string unless requested not to
		*dest = 0;
	return(destcount);	// Return the character count, not including the null
}

//=====================================================================================================
//
// uint32tohexfmtstr()
//
//	This takes a 32-bit unsigned integer value and converts it to a formatted hexadecimal
//	string, using options (field width and flags) like those provided by sprintf().  Look
//	at the code for dbugsprintf() above to see which formatting options are implemented.
//
//=====================================================================================================

int uint32tohexfmtstr(UInt32 u32val,  UInt8 *dest, int fieldwidth, int flags)
{
	int i, digitcount, destcount;
	int c, hexadjust;
	int fillcount;
	UInt8 fillchar;
	int pad_options;
	UInt32 quotient;
	UInt8 *intdigp;
	UInt8 nbuf[NUMBUFSIZE];

	hexadjust = 'A' - '9' - 1;
	if (flags & LOWERCASE_F)
		hexadjust += 'a' - 'A';

	// Convert the number into ASCII hex digits in our local buffer, counting them
	intdigp = &nbuf[NUMBUFSIZE];	// Point past the last character in the buffer
	digitcount = 0;	// Nothing written to our local buffer yet
	do {
		quotient = u32val / 16;
		c = u32val % 16 + '0';
		if (c > '9')	/* A-F */
			c += hexadjust;
		*--intdigp = c;	// Put the digit into the next lower buffer slot
		digitcount++;
		u32val /= 16;
	} while (u32val > 0);

	// Process the field-padding options
	pad_options = 0;	// Assume we won't be doing any padding
	fillcount = fieldwidth - digitcount;	// No sign to worry about
	if (fillcount > 0) {	// We need to do left or right padding
		fillchar = ' ';		// Most common fill character is the space
		if (flags & LEFTALIGN_F) {
			pad_options = POSTSPACE_O;
		} else {	// Right-aligned, fill with zeros or spaces
			if (flags & ZEROFILL_F) {
				pad_options = PREZERO_O;
				fillchar = '0';
			} else {
				pad_options = PRESPACE_O;
			}
		}
	}

	destcount = 0;	// Nothing written out to the destination yet

	// Copy any leading zeros or spaces
	if (pad_options & (PREZERO_O | PRESPACE_O)) {
		for (i = 0; i < fillcount; i++)	// Copy the pad character(s)
			*dest++ = fillchar;
		destcount += fillcount;
	}
	// Copy the hex digits from our local buffer
	for (i = 0; i < digitcount; i++)
		*dest++ = *intdigp++;
	destcount += digitcount;

	// Copy any trailing spaces
	if (pad_options & POSTSPACE_O) {
		for (i = 0; i < fillcount; i++)	// Copy the pad character(s)
			*dest++ = fillchar;
		destcount += fillcount;
	}
	if ((flags & DONTTERMINATE) == 0)	// Null-terminate the string unless requested not to
		*dest = 0;
	return(destcount);	// Return the character count, not including the null
}

//=====================================================================================================
//
// float64todecfmtstr()
//
//	This takes a 64-bit floating-point value and converts it to a formatted decimal
//	string, using options (field width, precision, and flags) like those provided by
//	sprintf().  Look at the code for dbugsprintf() above to see which formatting options
//	are implemented.
//
//=====================================================================================================

int float64todecfmtstr(Float64 f64val, UInt8 *dest, int fieldwidth,
								int precision, int flags)
{
	int i, firstcount, destcount;
	int sign, signchar, decpt;
	int fillcount;
	int pad_options;
	int reducecount, loopdigits, digitsleft;
	UInt32 u32val, quotient, remainder;
	Float64 f64mant9, f64mant9factor, fone, ften, fbillion, powerof10;
	UInt8 *digp;
	UInt8 nbuf[NUMBUFSIZE];	// This only needs to hold the first 9 digits of the integer part

	// Process the sign-related options
	sign = 1;	// Assume at first we'll have a sign character
	if (f64val < 0.0) {
		signchar = '-';
		f64val = -f64val;	// Make the number positive now so we can 'digitize' it
	} else {	// f64val >= 0.0
		if (flags & PLUSSIGN_F)
			signchar = '+';
		else if (flags & SPACESIGN_F)
			signchar = ' ';
		else
			sign = 0;	// No sign character
	}

	// Round the number to N decimal places.  We add 0.5 x 10^(-N), which is
	//	equivalent to adding 1 / (2*10^N).  We'll use this latter formula.
	fone = 1.0;		// Keep the compiler from always loading these constants from memory
	ften = 10.0;
	powerof10 = fone;	// 10 ^ 0
	for (i = 0; i < precision; i++)
		powerof10 *= ften;	// Build 10 ^ N
	f64val += fone / (2.0 * powerof10);
	// f64val now contains the properly rounded number

	f64mant9 = f64val;	// Start hunting for the mantissa's 9 uppermost decimal digits
	fbillion = 1e9;		// Keep it in a register
	f64mant9factor = fone;
	// Reduce the mantissa to less than 1 billion, so it will fit in a 32-bit integer
	for (reducecount = 0; f64mant9 >= fbillion; reducecount++) {
		f64mant9 /= fbillion;
		f64mant9factor *= fbillion;
	}

	// Process the highest 32-bits of the mantissa so we can count those digits first

	f64mant9 = f64val / f64mant9factor;	// Grab highest 9 integer decimal digits
	u32val = f64mant9;	// Drop any fraction
	f64mant9 = u32val;	// Now we have a float with only an integer part
	f64val -= f64mant9 * f64mant9factor;	// Subtract out the previous high digits
	f64mant9factor /= fbillion;		// Adjust our division factor

	// Convert the binary into ASCII decimal digits in our local buffer, counting them
	digp = &nbuf[NUMBUFSIZE];	// Point past the last char. of these 9 digits
	firstcount = 0;	// No digits of the first 32-bit integer part yet
	do {
		quotient = u32val / 10;
		remainder = u32val - quotient * 10;
		*--digp = remainder + '0';	// Put the digit into the next lower buffer slot
		firstcount++;
		u32val = quotient;
	} while (u32val > 0);

	// Figure out whether we'll have a decimal point
	decpt = (precision > 0);	// Don't use a decimal point if no fractional part

	// Process the field-padding options
	pad_options = 0;	// Assume we won't be doing any padding
	// We have the information we need to calculate how many output characters we'll have
	fillcount = fieldwidth - (sign + firstcount + (reducecount * 9) + decpt + precision);
	if (fillcount > 0) {	// We need to do left or right padding
		if (flags & LEFTALIGN_F) {
			pad_options = POSTSPACE_O;
		} else {	// Right-aligned, fill with zeros or spaces
			if (flags & ZEROFILL_F)
				pad_options = PREZERO_O;
			else
				pad_options = PRESPACE_O;
		}
	}

	destcount = 0;	// Nothing written out to the destination yet

	// Copy any leading spaces
	if (pad_options & PRESPACE_O) {
		for (i = 0; i < fillcount; i++)	// Copy the pad character(s)
			*dest++ = ' ';
		destcount += fillcount;
	}
	// Copy the sign character, if any
	if (sign) {
		*dest++ = signchar;
		destcount++;
	}
	// Copy any leading zeros
	if (pad_options & PREZERO_O) {
		for (i = 0; i < fillcount; i++)	// Copy the pad character(s)
			*dest++ = '0';
		destcount += fillcount;
	}
	// Copy the highest chunk of integer digits from the local buffer
	for (i = 0; i < firstcount; i++)
		*dest++ = *digp++;
	destcount += firstcount;

	// Now we need to convert the remaining integer digits, if any
	for (i = 0; i < reducecount; i++) {
		f64mant9 = f64val / f64mant9factor;	// Grab 9 more decimal digits
		u32val = f64mant9;		// Drop any fraction
		f64mant9 = u32val;		// Now we have a float with only an integer part
		f64val -= f64mant9 * f64mant9factor;	// Subtract out the previous high digits
		f64mant9factor /= fbillion;			// Adjust our division factor
		// Convert the integer part into ASCII decimal digits, directly to the destination
		dest += 9;				// Point past the last char. of this 9-digit chunk
		digp = dest;
		for (loopdigits = 0; loopdigits < 9; loopdigits++) {
			quotient = u32val / 10;
			remainder = u32val - quotient * 10;
			*--digp = remainder + '0';	// Put the digit into the next lower buffer slot
			u32val = quotient;
		}
		destcount += 9;
	}
	// f64val has only the fractional part now

	if (!decpt)
		goto checktrailing;	// Skip the laborious fraction-processing part

	// Copy the decimal point
	*dest++ = '.';
	destcount++;

	// Similar to how we handled the integer part processing, we'll process up to
	//	9 digits at a time, by multiplying the fraction by a power of 10,
	//	converting to an integer, and converting digits to the destination.

	digitsleft = precision;
	do {
		loopdigits = digitsleft;
		if (loopdigits > 9)
			loopdigits = 9;
		powerof10 = fone;	// 10 ^ 0
		for (i = 0; i < loopdigits; i++)
			powerof10 *= ften;	// Build 10 ^ N
		f64val *= powerof10;	// Push some fractional digits into the integer part
		u32val = f64val;	// Conversion truncates any remaining fraction
		f64val -= u32val;	// Remove the integer part, leave remaining fraction digits
		digp = dest + loopdigits;	// Point past the last char. of this chunk
		for (i = 0; i < loopdigits; i++) {
			quotient = u32val / 10;
			remainder = u32val - quotient * 10;
			*--digp = remainder + '0';	// Put the digit into the next lower buffer slot
			u32val = quotient;
		}
		dest += loopdigits;
		destcount += loopdigits;
		digitsleft -= loopdigits;
	} while (digitsleft > 0);

checktrailing:
	// Copy any trailing spaces
	if (pad_options & POSTSPACE_O) {
		for (i = 0; i < fillcount; i++)	// Copy the pad character(s)
			*dest++ = ' ';
		destcount += fillcount;
	}
	if ((flags & DONTTERMINATE) == 0)	// Null-terminate the string unless requested not to
		*dest = 0;
	return(destcount);	// Return the character count, not including the null
}

//=====================================================================================================
//
// strtofmtstr()
//
//	This takes a source C string and converts it to a formatted output C string,
//	using options (field width and flags) like those provided by sprintf().  Look at
//	the code for dbugsprintf() above to see which formatting options are implemented.
//
//=====================================================================================================

int strtofmtstr(UInt8 *src, UInt8 *dest, int fieldwidth, int flags)
{
	int i, srclen;
	int fillcount;
	UInt8 fillchar;
	int pad_options;
	UInt8 *s, *d;

	// For padding calculations, we need to know the source string length
	for (s = src, srclen = 0; *s != 0; s++)
		srclen++;
	// Process the field-padding options
	pad_options = 0;	// Assume we won't be doing any padding
	fillcount = fieldwidth - srclen;

	if (fillcount > 0) {	// We need to do left or right padding
		fillchar = ' ';		// Most common fill character is the space
		if (flags & LEFTALIGN_F) {
			pad_options = POSTSPACE_O;
		} else {	// Right-aligned, fill with zeros or spaces
			if (flags & ZEROFILL_F) {
				pad_options = PREZERO_O;
				fillchar = '0';
			} else {
				pad_options = PRESPACE_O;
			}
		}
	}

	s = src;
	d = dest;

	// Copy any leading zeros or spaces
	if (pad_options & (PREZERO_O | PRESPACE_O)) {
		for (i = 0; i < fillcount; i++)	// Copy the pad character(s)
			*d++ = fillchar;
	}
	// Copy the characters from the source string
	for (i = 0; i < srclen; i++)
		*d++ = *s++;

	// Copy any trailing spaces
	if (pad_options & POSTSPACE_O) {
		for (i = 0; i < fillcount; i++)	// Copy the pad character(s)
			*d++ = fillchar;
	}

	if ((flags & DONTTERMINATE) == 0)	// Null-terminate the string unless requested not to
		*d = 0;
	return(d - dest);	// Return the character count, not including the null
}


#if _RAWDRAW

typedef struct {
	UInt8	ascent;
	UInt8	height;
	UInt16	rowbytes;
	UInt8	charwidth[256];
	UInt16	startoffset[256];
} fontdef, *fontdefptr;

static fontdef dbgfontdef = {   // Monaco 9
    // Ascent, height, rowbytes
     9, 11, 192,
    {   // Character width data
        0,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  0,  6,  6,
        6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,
        6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,
        6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,
        6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,
        6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,
        6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,
        6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  0,
        6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,
        6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,
        6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,
        6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,
        6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,
        6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,
        6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,
        6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6
    },
    {   // Character starting offset data
           0,      0,      6,     12,     18,     24,     30,     36,
          42,     48,     54,     60,     66,     72,     72,     78,
          84,     90,     96,    102,    108,    114,    120,    126,
         132,    138,    144,    150,    156,    162,    168,    174,
         180,    186,    192,    198,    204,    210,    216,    222,
         228,    234,    240,    246,    252,    258,    264,    270,
         276,    282,    288,    294,    300,    306,    312,    318,
         324,    330,    336,    342,    348,    354,    360,    366,
         372,    378,    384,    390,    396,    402,    408,    414,
         420,    426,    432,    438,    444,    450,    456,    462,
         468,    474,    480,    486,    492,    498,    504,    510,
         516,    522,    528,    534,    540,    546,    552,    558,
         564,    570,    576,    582,    588,    594,    600,    606,
         612,    618,    624,    630,    636,    642,    648,    654,
         660,    666,    672,    678,    684,    690,    696,    702,
         708,    714,    720,    726,    732,    738,    744,    750,
         750,    756,    762,    768,    774,    780,    786,    792,
         798,    804,    810,    816,    822,    828,    834,    840,
         846,    852,    858,    864,    870,    876,    882,    888,
         894,    900,    906,    912,    918,    924,    930,    936,
         942,    948,    954,    960,    966,    972,    978,    984,
         990,    996,   1002,   1008,   1014,   1020,   1026,   1032,
        1038,   1044,   1050,   1056,   1062,   1068,   1074,   1080,
        1086,   1092,   1098,   1104,   1110,   1116,   1122,   1128,
        1134,   1140,   1146,   1152,   1158,   1164,   1170,   1176,
        1182,   1188,   1194,   1200,   1206,   1212,   1218,   1224,
        1230,   1236,   1242,   1248,   1254,   1260,   1266,   1272,
        1278,   1284,   1290,   1296,   1302,   1308,   1314,   1320,
        1326,   1332,   1338,   1344,   1350,   1356,   1362,   1368,
        1374,   1380,   1386,   1392,   1398,   1404,   1410,   1416,
        1422,   1428,   1434,   1440,   1446,   1452,   1458,   1464,
        1470,   1476,   1482,   1488,   1494,   1500,   1506,   1512
    }
};

static UInt32 dbgfontdata[] = { // Monaco 9
    0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00001000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000008, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000002, 0x00014200,
    0x11A51400, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00C00000, 0x00000000,
    0x00000000, 0x00000000, 0x00060000, 0x00000000,
    0x00600000, 0x000041A6, 0x80000000, 0x00000000,
    0x05000000, 0x00000000, 0x00020411, 0x44082142,
    0x04200404, 0x21000000, 0x000C0002, 0x80880000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00020000, 0x81080000,
    0x00001000, 0x00000000, 0x00000000, 0x00000700,
    0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x000000C8, 0x0C100400, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000042, 0x08000500,
    0x22C00010, 0x82006880, 0x04408004, 0x40801A11,
    0x02006844, 0x08000300, 0x31201F30, 0x00000800,
    0x00000000, 0x00000000, 0x00080000, 0x00000000,
    0x00800000, 0x000022CB, 0x00000000, 0x00000000,
    0x00020000, 0x00000000, 0x00050A20, 0x02105001,
    0x08500208, 0x50800869, 0xE44C2002, 0x80500000,
    0x79E79E79, 0xE79E01E7, 0x9E79E79E, 0x79E79E79,
    0xE79E79E7, 0x9E79E008, 0x51471260, 0x82042000,
    0x00002708, 0x71C13E73, 0xE71C0000, 0x8041C89C,
    0xF1CF3EF9, 0xC8880A28, 0x2289CF1C, 0xF1CFA28A,
    0x28A2F884, 0x04280200, 0x80008018, 0x08082202,
    0x00000000, 0x00020000, 0x00000082, 0x0469C21C,
    0xFA272220, 0x4514B140, 0x08214508, 0x21452C20,
    0x8514B082, 0x14508480, 0x41003A4B, 0xCF3D1140,
    0x1E740204, 0x222008FB, 0xF00838C7, 0x00008100,
    0x00800000, 0x000071C7, 0x1E00000A, 0x78430001,
    0x48823800, 0x0C388000, 0x01071F73, 0xEF800080,
    0x1C702722, 0x022014B0, 0x03805005, 0x00200000,
    0x49249249, 0x24920124, 0x92492492, 0x49249249,
    0x24924924, 0x92492008, 0x53EAAA90, 0x8204A880,
    0x00002898, 0x8A232080, 0x28A23181, 0x002228A2,
    0x8A28A082, 0x28880A48, 0x36CA28A2, 0x8A22228A,
    0x25220884, 0x04440100, 0x80008020, 0x08000202,
    0x00000000, 0x00020000, 0x00000082, 0x04B22722,
    0x8328A200, 0x00000080, 0x00000000, 0x00000000,
    0x00000000, 0x0001C488, 0x40873A88, 0x20972001,
    0x28880208, 0x12200449, 0x20084928, 0x80040000,
    0x18808800, 0x00008A28, 0xA8000014, 0x28810820,
    0x08844400, 0x10488000, 0x02A8908A, 0x08082082,
    0x228848A2, 0x8A202200, 0x00002000, 0x00000000,
    0x49249249, 0x24920124, 0x92492492, 0x49249249,
    0x24924924, 0x92492008, 0x514A14A0, 0x04027080,
    0x00004988, 0x08253CF0, 0x28A23182, 0x3E102AA2,
    0x8A08A082, 0x08880A88, 0x2AAA28A2, 0x8A02228A,
    0x22221082, 0x0400001E, 0xF1C79C71, 0xEF082242,
    0x3CB1CF1E, 0xB1E7A28A, 0xA8A2F882, 0x040228A0,
    0x82A8A279, 0xE79E79E7, 0x1C71C708, 0x20822C71,
    0xC71C7228, 0xA288831C, 0xE14FBA93, 0x2697000F,
    0xA89B6F90, 0x09490621, 0x2F885928, 0x9C788100,
    0x11C7084A, 0x40008A28, 0xA870001E, 0x50C20052,
    0x2884F082, 0x3EE9C300, 0x0148908A, 0x08082082,
    0x2289B8A2, 0x8A220000, 0x00000000, 0x00000000,
    0x49249249, 0x24920124, 0x92492492, 0x49249249,
    0x24924924, 0x92492008, 0x03E70840, 0x0402ABE0,
    0x3E004A88, 0x10C90288, 0x47220004, 0x00084EBE,
    0xF208BCF2, 0x6F880B08, 0x229A2F22, 0xF1C22252,
    0x22142082, 0x04000022, 0x8A28A222, 0x28882282,
    0x2ACA28A2, 0xCA02228A, 0xA5221102, 0x0203E8A0,
    0xF268A28A, 0x28A28A28, 0xA28A2888, 0x2082328A,
    0x28A28A28, 0xA288802A, 0x412F9E92, 0xA8800002,
    0x3CAAA208, 0x13E90A11, 0x250828C8, 0xAA99013E,
    0x20889491, 0x2000FBE8, 0xACA9CFC0, 0x00003E8A,
    0x25084101, 0x12488300, 0x008F9EFB, 0xCF082082,
    0x228BE8A2, 0x8A220000, 0x00000000, 0x00000000,
    0x49249249, 0x24920124, 0x92492492, 0x49249249,
    0x24924924, 0x92492008, 0x014294A8, 0x04022080,
    0x00008C88, 0x202F8288, 0x889E0002, 0x3E108B22,
    0x8A08A082, 0x28888A88, 0x228A2822, 0x88222252,
    0xA2084081, 0x04000022, 0x8A08BE22, 0x28882382,
    0x2A8A28A2, 0x81C22252, 0xA2222082, 0x04022FA0,
    0x8228A28A, 0x28A28A28, 0x3EFBEF88, 0x2082228A,
    0x28A28A28, 0xA2888028, 0x40AF8A8B, 0x2880000F,
    0xA8CB6204, 0x20891221, 0x25080008, 0xAEAA0102,
    0xA0871491, 0x20008A28, 0xA8B80000, 0x00000052,
    0x2210F101, 0x12488000, 0x0128908A, 0x08082082,
    0x228BE8A2, 0x8A220000, 0x00000000, 0x00000000,
    0x49249249, 0x24920124, 0x92492492, 0x49249249,
    0x24924924, 0x92492000, 0x000AAA90, 0x02040086,
    0x00308888, 0x42212288, 0x88823181, 0x00200822,
    0x8A28A082, 0x28888A48, 0x228A2822, 0x8A222223,
    0x65088081, 0x04000026, 0x8A08A022, 0x28882242,
    0x2A8A28A2, 0x80222652, 0xA5224082, 0x040228A2,
    0x8228A29A, 0x69A69A68, 0x20820808, 0x2082228A,
    0x28A28A69, 0xA698802A, 0x48470A8A, 0xA6800004,
    0x28880000, 0x03E91249, 0x250879E5, 0x28CA2102,
    0x4088224A, 0x40008A28, 0xA8A00000, 0x00000822,
    0x22104482, 0x1248800C, 0x7AD8908A, 0x08082082,
    0x228BF8A2, 0x8A220000, 0x00000000, 0x00000000,
    0x79E79E79, 0xE79E01E7, 0x9E79E79E, 0x79E79E79,
    0xE79E79E7, 0x9E79E008, 0x00072468, 0x02040006,
    0x00310708, 0xF9C11C70, 0x871C3180, 0x804088A2,
    0xF1CF3E81, 0xC888722F, 0xA289C81C, 0x89C21C22,
    0x2888F880, 0x8403F01A, 0xF1E79E21, 0xE8882223,
    0x2A89CF1E, 0x83C19A21, 0x489EF882, 0x0402289C,
    0xFA271C69, 0xA69A69A7, 0x9E79E788, 0x20822271,
    0xC71C71A6, 0x9A68001C, 0xB0200BB0, 0x20800000,
    0x2F700F9E, 0x788E8CF9, 0x2508000D, 0x9EF1C100,
    0x40803E00, 0x0A808A27, 0x1E580000, 0x00000001,
    0xE2203800, 0x1249C00C, 0x29289F8B, 0xEF882082,
    0x1C71E71C, 0x71C20000, 0x00000080, 0x04000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00020000, 0x01080002,
    0x00010000, 0x00000000, 0x00000080, 0x00000700,
    0x00000000, 0x00000000, 0x00000002, 0x00000000,
    0x000000C0, 0x8C000000, 0x00000000, 0x20002000,
    0x00000802, 0x00000000, 0x00020042, 0x08000008,
    0x00000000, 0x00000002, 0x00000000, 0x00000000,
    0x00000000, 0x00000008, 0x01200083, 0xCF000000,
    0x00000000, 0x00880000, 0x00080000, 0x01000000,
    0x03000000, 0x00000000, 0x00000000, 0x00000000,
    0x20200000, 0x00008004, 0x50000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000040, 0x08000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000004,
    0x00000000, 0x00000000, 0x00000100, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000001, 0xC000C000,
    0x00000802, 0x00000000, 0x001C0002, 0x00000010,
    0x00000000, 0x00000004, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00C00000, 0x00000000,
    0x00000000, 0x00080000, 0x00300000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000001,
    0xC0000000, 0x00008008, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000080, 0x04000000
};

//=====================================================================================================
//
// dbgdrawstr()
//
//	Note: This routine assumes the maximum font character width is 32 pixels
//
//=====================================================================================================

void dbgdrawstr(char *str)	// Takes a C string
{
	static UInt32 gLineCount = 0;	// Counts how many lines we've printed
	static GDHandle gDrawingGDevH;
	static SInt32 gDrawX;	// Screen coords of top-left pixel of dest char box
	static SInt32 gDrawY;
	static SInt32 gStartX;	// Starting H coord. on the screen after horizontal wrap
	static SInt32 gStartY;	// Starting V coord. on the screen after vertical wrap
	static UInt32 gLastPageRight = 0;	// Max. right edge of the previous 'page'
	static UInt32 gCurPageRight = 0;	// Max. right edge of the current 'page'
	static UInt8 gDidEndOfLine = false;
	static UInt8 sbuf[512];
	Ptr destbase;
	UInt32 destrowbytes, destpixelshift;
	UInt32 clipheight, clipwidth;
	SInt32 destX, destY;
	SInt32 startX, startY;
	UInt32 i, j, ch;
	SInt32 clearwidth;
	UInt32 charheight, charwidth;
	UInt32 bitoffset, longindex, fontrowbytes;
	UInt32 shift, long0, long1;
	Ptr deststringrowptr, destpixrowptr, destpixptr;
	UInt32 *fontlongrowptr;
	UInt8 *bufp, *destp;
	GDHandle gdh;
	PixMapPtr pmp;
#define STARTX		0	// If set to a negative number, it insets from the right edge
#define STARTY		0	// If set to a negative number, it insets from the bottom edge
#define FGCOLOR8	0xFF
#define BGCOLOR8	0x00
#define FGCOLOR16	0x0000
#define BGCOLOR16	0x7FFF
#define FGCOLOR32	0x00000000
#define BGCOLOR32	0x00FFFFFF

	if (gLineCount == 0) {	// First-time initialization
		// We want to avoid the MacsBug screen above all, since we might be
		//	trying to debug graphics drivers that MacsBug may interact with.
		gdh = GetDeviceList();	// First device in list is the MacsBug device
		for (gdh = GetNextDevice(gdh); gdh != nil; gdh = GetNextDevice(gdh)) {
			// Secondarily, we want to avoid the menubar screen.
			if (gdh == GetMainDevice())	// Avoid the menu bar device if possible
				continue;
			goto gotgdev;	// Grab the first non-MacsBug, non-menubar screen
		}
		// Otherwise we'll just take the menubar device
		gdh = GetMainDevice();
gotgdev:
		gDrawingGDevH = gdh;
		gDidEndOfLine = true;	// Kick out a line number this time
	}

	pmp = *(*gDrawingGDevH)->gdPMap;
	destbase = pmp->baseAddr;
	destrowbytes = pmp->rowBytes & 0x7FFF;	// Mask the PixMap bit
	destpixelshift = pmp->pixelSize / 16;	// Map 8,16,32 onto 0,1,2
	clipheight = pmp->bounds.bottom - pmp->bounds.top;
	clipwidth = pmp->bounds.right - pmp->bounds.left;
	if (gLineCount == 0) {	// First-time initialization
		startY = STARTY;
		if (startY < 0)
			startY += clipheight;
		gStartY = startY;
		gDrawY = startY;

		startX = STARTX;
		if (startX < 0)
			startX += clipwidth;
		gStartX = startX;
		gDrawX = startX;
	}
	startY = gStartY;
	startX = gStartX;

	charheight = dbgfontdef.height;
	fontrowbytes = dbgfontdef.rowbytes;
	destY = gDrawY;
	destX = gDrawX;

	bufp = (UInt8 *)str;	// Get the start of the string

	if (gDidEndOfLine) {
		destp = sbuf;
		*destp++ = ' ';	// Put in a leading space for aesthetics
		// Convert the current line number into a string, as a prefix
		destp += int32todecfmtstr(gLineCount, destp, 4, DONTTERMINATE);
		*destp++ = ':';
		*destp++ = ' ';
		// Copy the rest of the source string into our buffer
		while ((*destp++ = *bufp++) != 0)
			;
		*destp = 0;	// Null-terminate the resulting string
		bufp = sbuf;
		gDidEndOfLine = false;
		gLineCount++;
	}

	for (ch = *bufp++; ch != 0; ch = *bufp++) {
		charwidth = dbgfontdef.charwidth[ch];
		deststringrowptr = destbase + destY * destrowbytes + (startX << destpixelshift);
		if (ch == '\n') {	// Check to see if we need to erase to a known width
			clearwidth = gLastPageRight - destX;
			if (clearwidth > 0) {	// We need to erase the rest of the line
				destpixrowptr = deststringrowptr + ((destX - startX) << destpixelshift);
				switch (destpixelshift) {
				case 0:		// 8 bits
					for (i = 0; i < charheight; i++) {
						destpixptr = destpixrowptr;
						for (j = 0; j < clearwidth; j++) {
							*(UInt8 *)destpixptr = BGCOLOR8;
							destpixptr += sizeof(UInt8);
						}
						destpixrowptr += destrowbytes;
					}
					break;
				case 1:		// 16 bits
					for (i = 0; i < charheight; i++) {
						destpixptr = destpixrowptr;
						for (j = 0; j < clearwidth; j++) {
							*(UInt16 *)destpixptr = BGCOLOR16;
							destpixptr += sizeof(UInt16);
						}
						destpixrowptr += destrowbytes;
					}
					break;
				default:	// 32 bits
					for (i = 0; i < charheight; i++) {
						destpixptr = destpixrowptr;
						for (j = 0; j < clearwidth; j++) {
							*(UInt32 *)destpixptr = BGCOLOR32;
							destpixptr += sizeof(UInt32);
						}
						destpixrowptr += destrowbytes;
					}
					break;
				}
			}
			gDidEndOfLine = true;	// Kick out a line number next time
		}
		// Wrap to beginning of next line if we get a newline or hit the right edge
		if (ch == '\n' || destX + charwidth > clipwidth) {
			// First save the width of the line just finished
			if (destX > gCurPageRight)
				gCurPageRight = destX;
			destX = startX;
			destY += charheight;
		}
		if (destY + charheight > clipheight) {	// Wrap vertically
			destY = startY;
			gLastPageRight = gCurPageRight;
			gCurPageRight = 0;
		}

		if (ch == '\n')	// Don't draw anything for newline
			continue;

		deststringrowptr = destbase + destY * destrowbytes + (destX << destpixelshift);
		destpixrowptr = deststringrowptr;
		bitoffset = dbgfontdef.startoffset[ch];	// Get the bit offset to the character
		longindex = bitoffset / 32;
		fontlongrowptr = &dbgfontdata[longindex];

		switch (destpixelshift) {
		case 0:		// 8 bits
			for (i = 0; i < charheight; i++) {
				// Extract and align the character's scan line data (max 32 bits)
				long0 = *fontlongrowptr;
				shift = bitoffset - longindex * 32;
				if (shift > 0) {	// Need to extract a 32-bit unaligned bitfield
					long1 = *(fontlongrowptr+1);
					long0 <<= shift;
					long1 >>= 32 - shift;
					long0 |= long1;
				}
				destpixptr = destpixrowptr;
				for (j = 0; j < charwidth; j++) {
					if (long0 & 0x80000000)	// Use foreground color
						*(UInt8 *)destpixptr = FGCOLOR8;
					else	// Use background color
						*(UInt8 *)destpixptr = BGCOLOR8;
					long0 <<= 1;
					destpixptr += sizeof(UInt8);
				}
				fontlongrowptr = (UInt32 *)((Ptr)fontlongrowptr + fontrowbytes);
				destpixrowptr += destrowbytes;
			}
			break;
		case 1:		// 16 bits
			for (i = 0; i < charheight; i++) {
				// Extract and align the character's scan line data (max 32 bits)
				long0 = *fontlongrowptr;
				shift = bitoffset - longindex * 32;
				if (shift > 0) {	// Need to extract a 32-bit unaligned bitfield
					long1 = *(fontlongrowptr+1);
					long0 <<= shift;
					long1 >>= 32 - shift;
					long0 |= long1;
				}
				destpixptr = destpixrowptr;
				for (j = 0; j < charwidth; j++) {
					if (long0 & 0x80000000)	// Use foreground color
						*(UInt16 *)destpixptr = FGCOLOR16;
					else	// Use background color
						*(UInt16 *)destpixptr = BGCOLOR16;
					long0 <<= 1;
					destpixptr += sizeof(UInt16);
				}
				fontlongrowptr = (UInt32 *)((Ptr)fontlongrowptr + fontrowbytes);
				destpixrowptr += destrowbytes;
			}
			break;
		default:	// 32 bits
			for (i = 0; i < charheight; i++) {
				// Extract and align the character's scan line data (max 32 bits)
				long0 = *fontlongrowptr;
				shift = bitoffset - longindex * 32;
				if (shift > 0) {	// Need to extract a 32-bit unaligned bitfield
					long1 = *(fontlongrowptr+1);
					long0 <<= shift;
					long1 >>= 32 - shift;
					long0 |= long1;
				}
				destpixptr = destpixrowptr;
				for (j = 0; j < charwidth; j++) {
					if (long0 & 0x80000000)	// Use foreground color
						*(UInt32 *)destpixptr = FGCOLOR32;
					else	// Use background color
						*(UInt32 *)destpixptr = BGCOLOR32;
					long0 <<= 1;
					destpixptr += sizeof(UInt32);
				}
				fontlongrowptr = (UInt32 *)((Ptr)fontlongrowptr + fontrowbytes);
				destpixrowptr += destrowbytes;
			}
			break;
		}

		destX += charwidth;
	}

	// Update the global state
	gDrawY = destY;
	gDrawX = destX;
}

#endif	// #if _RAWDRAW
#endif	// #if DEBUG_BUILD
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\common\mac\qdregions\regionparse.h ===
/******************************************************************************
 *
 *       Copyright 1993-2000 NVIDIA, Corporation.  All rights reserved.
 *
 *     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
 *     international laws.  Users and possessors of this source code are
 *     hereby granted a nonexclusive,  royalty-free copyright license to
 *     use this code in individual and commercial software.
 *
 *     Any use of this source code must include,  in the user documenta-
 *     tion and  internal comments to the code,  notices to the end user
 *     as follows:
 *
 *       Copyright 1993-2000 NVIDIA, Corporation.  All rights reserved.
 *
 *     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
 *     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
 *     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
 *     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
 *     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
 *     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
 *     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
 *     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
 *     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
 *     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
 *     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
 *
 *     U.S. Government  End  Users.   This source code  is a "commercial
 *     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
 *     consisting  of "commercial  computer  software"  and  "commercial
 *     computer  software  documentation,"  as such  terms  are  used in
 *     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
 *     ment only as  a commercial end item.   Consistent with  48 C.F.R.
 *     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
 *     all U.S. Government End Users  acquire the source code  with only
 *     those rights set forth herein.
 *
 ******************************************************************************
 *
 * MODULE:  regionparse.h
 *
 * PURPOSE: Contains definitions for region-parsing code.
 *
 ******************************************************************************/

#ifndef __QUICKDRAW__
#include <QuickDraw.h>
#endif

//=====================================================================================================
//
// Definitions
//
//=====================================================================================================

// Flag values for the region parser (parse_rgns and parse_rgns_callback)
#define RIGHT_TO_LEFT	1	// Emit rectangles in right-to-left order (default is left-to-right)
#define BOTTOM_TO_TOP	2	// Emit rectangles in bottom-to-top order (default is top-to-bottom)
#define USE_GLRECT_FMT	4	// Return rectangles in GLRect format (default is QuickDraw rects)

typedef struct {			// Rectangle list information
	int		maxRectCount;		// Maximum allocated rectangles in the list
	int		rectCount;			// How many rectangles were parsed
	void	*rectListPtr;		// Points to QuickDraw or OpenGL rectangles
} RectListInfo, *RectListInfoPtr;

typedef void (*RectCallbackProcPtr)(const void *rectPtr, void *dataPtr);	// dataPtr was passed into parse_rgns_callback

//=====================================================================================================
//
// Prototypes
//
//=====================================================================================================

extern int parse_rgns(void *startcliprectp,	// Points to QuickDraw or OpenGL rectangle, or is nil
						RgnHandle rh1, RgnHandle rh2, RgnHandle rh3,	// Set unused handles to nil
						RectListInfoPtr rectlistinfop, int flags);

extern int parse_rgns_callback(void *startcliprectp,	// Points to QuickDraw or OpenGL rectangle, or is nil
						RgnHandle rh1, RgnHandle rh2, RgnHandle rh3,	// Set unused handles to nil
						RectCallbackProcPtr callbackProcPtr, void *dataPtr,	// dataPtr is passed to callback proc
						int flags);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\common\mac\qdregions\regionparse.c ===
/******************************************************************************
 *
 *       Copyright 1993-2000 NVIDIA, Corporation.  All rights reserved.
 *
 *     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
 *     international laws.  Users and possessors of this source code are
 *     hereby granted a nonexclusive,  royalty-free copyright license to
 *     use this code in individual and commercial software.
 *
 *     Any use of this source code must include,  in the user documenta-
 *     tion and  internal comments to the code,  notices to the end user
 *     as follows:
 *
 *       Copyright 1993-2000 NVIDIA, Corporation.  All rights reserved.
 *
 *     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
 *     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
 *     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
 *     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
 *     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
 *     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
 *     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
 *     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
 *     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
 *     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
 *     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
 *
 *     U.S. Government  End  Users.   This source code  is a "commercial
 *     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
 *     consisting  of "commercial  computer  software"  and  "commercial
 *     computer  software  documentation,"  as such  terms  are  used in
 *     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
 *     ment only as  a commercial end item.   Consistent with  48 C.F.R.
 *     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
 *     all U.S. Government End Users  acquire the source code  with only
 *     those rights set forth herein.
 *
 ******************************************************************************
 *
 * MODULE:  regionparse.c
 *
 * PURPOSE: Contains the code to decompose regions into a list of rectangles.
 *
 ******************************************************************************/

#include <Quickdraw.h>
#include <Memory.h>
#include <stdio.h>

#include "regionparse.h"
#include "debug.h"


//=====================================================================================================
//
// Definitions
//
//=====================================================================================================

#define ENDMARKER		32767	// Marks 'end of line' and 'end of region'
#define UNINITIALIZEDV	65536	// Will never match valid coordinates (-32767 to 32767)
#define MAXCOORDS		3000	// Maximum allowable complexity per line


//=====================================================================================================
//
// Declarations
// This is duplicated from OpenGL Header files
// This is present in source file instead of header to avoid duplicate
// definition of the same structure while compiling OpenGL source files
//
//=====================================================================================================

typedef struct {			// OpenGL rectangle
    int		x0;  
    int		y0;
    int		x1; 
    int		y1; 
} __GLregionRect, *__GLregionRectPtr;

//=====================================================================================================
//
// Globals
//
//=====================================================================================================

static SInt16 gXcoord[MAXCOORDS];	// Horizontal coordinates for the line's region change information
static SInt8 gRgnID[MAXCOORDS];	// Identifies which region(s) each coordinate belongs to (max 8 regions)

//=====================================================================================================
//
// Prototypes for local procedures
//
//=====================================================================================================

static int parse1rgn(Rect *mincliprectp, RgnHandle rh1, RectListInfoPtr rectlistinfop,
						RectCallbackProcPtr callbackProcPtr, void *dataPtr, int flags);
static int parseNrgns(Rect *mincliprectp, int rgncount, RgnHandle *rhap, RectListInfoPtr rectlistinfop,
						RectCallbackProcPtr callbackProcPtr, void *dataPtr, int flags);


//=====================================================================================================
//
// parse_rgns()
//
//	This is the exported procedure that intersects and clips 1-3 input regions, and outputs a list
//	of hardware-efficient rectangles that make up the resulting region.  It does some parameter
//	checking and clipping, then dispatches to the subroutines that handle the one or N-way
//	intersecting region cases.
//
//=====================================================================================================
int parse_rgns(void *startcliprectp,
				RgnHandle rh1, RgnHandle rh2, RgnHandle rh3,
				RectListInfoPtr rectlistinfop, int flags)
{
	int cliptop, clipleft, clipbottom, clipright;	// Minimum rectangle we have to clip to
	int top, left, bottom, right;
	int i, rgncount, rectcount;
	RgnPtr rgnp;
	RgnHandle rh;
	RgnHandle inrgnh[3];	// Up to 3 input regions
	RgnHandle outrgnh[3];	// List of (output) regions we actually have to parse
	void *rectp;			// Generic rectangle pointer cast to the appropriate type
	Rect mergedcliprect;	// Rect resulting from merged cliprect and the region bounding boxes
#if DEBUG_BUILD
	SInt8 hstate[3];		// Hold the prior handle state for the regions
#endif

	if (startcliprectp == nil) {	// No clip rectangle, so start with wide-open bounds
		cliptop = -32767;
		clipleft = -32767;
		clipbottom = 32767;
		clipright = 32767;
	} else if (flags & USE_GLRECT_FMT) {	// GLRect format
		clipleft = ((__GLregionRectPtr)startcliprectp)->x0;
		cliptop = ((__GLregionRectPtr)startcliprectp)->y0;
		clipright = ((__GLregionRectPtr)startcliprectp)->x1;
		clipbottom = ((__GLregionRectPtr)startcliprectp)->y1;
	} else {	// QuickDraw rect format
		cliptop = ((Rect *)startcliprectp)->top;
		clipleft = ((Rect *)startcliprectp)->left;
		clipbottom = ((Rect *)startcliprectp)->bottom;
		clipright = ((Rect *)startcliprectp)->right;
	}

	inrgnh[0] = rh1;
	inrgnh[1] = rh2;
	inrgnh[2] = rh3;
	rgncount = 0;
	rectcount = 0;

	// Check each region, updating the clip rect and collecting non-rectangular regions

	for (i = 0; i < 3; i++) {
		rh = inrgnh[i];
		if (rh == nil)	// Make sure the region handle is good
			continue;
		rgnp = *rh;
		top = rgnp->rgnBBox.top;
		left = rgnp->rgnBBox.left;
		bottom = rgnp->rgnBBox.bottom;
		right = rgnp->rgnBBox.right;
		if (top >= bottom || left >= right)	// Empty region, nothing gets drawn
			goto done;
		if (rgnp->rgnSize > 10)	// A non-rectangular region we have to parse
			outrgnh[rgncount++] = rh;
		// Update the minimum clipping rectangle if the new bounds are smaller
		if (top > cliptop)
			cliptop = top;
		if (left > clipleft)
			clipleft = left;
		if (bottom < clipbottom)
			clipbottom = bottom;
		if (right < clipright)
			clipright = right;
	}

	// If none of the regions were non-rectangular, just return the cliprect
	if (rgncount == 0) {
		rectp = rectlistinfop->rectListPtr;
		if (flags & USE_GLRECT_FMT) {	// GLRect format
			((__GLregionRectPtr)rectp)->x0 = clipleft;
			((__GLregionRectPtr)rectp)->y0 = cliptop;
			((__GLregionRectPtr)rectp)->x1 = clipright;
			((__GLregionRectPtr)rectp)->y1 = clipbottom;
		} else {	// QuickDraw rect format
			((Rect *)rectp)->top = cliptop;
			((Rect *)rectp)->left = clipleft;
			((Rect *)rectp)->bottom = clipbottom;
			((Rect *)rectp)->right = clipright;
		}
		rectlistinfop->rectCount = 1;
		return(1);
	}

	mergedcliprect.top = cliptop;
	mergedcliprect.left = clipleft;
	mergedcliprect.bottom = clipbottom;
	mergedcliprect.right = clipright;

#if DEBUG_BUILD	// Lock down the region so they don't slide if we're using GUI debuggers that can move memory
	for (i = 0; i < rgncount; i++) {
		hstate[i] = HGetState((Handle)outrgnh[i]);
		HLock((Handle)outrgnh[i]);
	}
#endif

	if (rgncount == 1)	// Use a faster routine for the one-region case
		rectcount = parse1rgn(&mergedcliprect, outrgnh[0], rectlistinfop, nil, nil, flags);
	else
		rectcount = parseNrgns(&mergedcliprect, rgncount, outrgnh, rectlistinfop, nil, nil, flags);

#if DEBUG_BUILD
	for (i = 0; i < rgncount; i++) {
		HSetState((Handle)outrgnh[i], hstate[i]);
	}
#endif

done:
	return(rectcount);
}

//=====================================================================================================
//
// parse_rgns_callback()
//
//	This is the exported procedure that intersects and clips 1-3 input regions, and calls back
//	(using the supplied procptr) a routine that gets passed each rectangle discovered in the
//	region decomposition.  (The non-callback version passes back a list of all the rectangles.)
//
//=====================================================================================================
int parse_rgns_callback(void *startcliprectp,	// Points to QuickDraw or OpenGL rectangle, or is nil
						RgnHandle rh1, RgnHandle rh2, RgnHandle rh3,	// Set unused handles to nil
						RectCallbackProcPtr callbackProcPtr, void *dataPtr,	// dataPtr is passed to callback proc
						int flags)
{
	int cliptop, clipleft, clipbottom, clipright;	// Minimum rectangle we have to clip to
	int top, left, bottom, right;
	int i, rgncount, rectcount;
	RgnPtr rgnp;
	RgnHandle rh;
	RgnHandle inrgnh[3];	// Up to 3 input regions
	RgnHandle outrgnh[3];	// List of (output) regions we actually have to parse
	void *rectp;			// Generic rectangle pointer cast to the appropriate type
	Rect mergedcliprect;	// Rect resulting from merged cliprect and the region bounding boxes
	__GLregionRect mergedcliprect_gl;	// OpenGL rect version of merged cliprect
#if DEBUG_BUILD
	SInt8 hstate[3];		// Hold the prior handle state for the regions
#endif

	if (startcliprectp == nil) {	// No clip rectangle, so start with wide-open bounds
		cliptop = -32767;
		clipleft = -32767;
		clipbottom = 32767;
		clipright = 32767;
	} else if (flags & USE_GLRECT_FMT) {	// GLRect format
		clipleft = ((__GLregionRectPtr)startcliprectp)->x0;
		cliptop = ((__GLregionRectPtr)startcliprectp)->y0;
		clipright = ((__GLregionRectPtr)startcliprectp)->x1;
		clipbottom = ((__GLregionRectPtr)startcliprectp)->y1;
	} else {	// QuickDraw rect format
		cliptop = ((Rect *)startcliprectp)->top;
		clipleft = ((Rect *)startcliprectp)->left;
		clipbottom = ((Rect *)startcliprectp)->bottom;
		clipright = ((Rect *)startcliprectp)->right;
	}

	inrgnh[0] = rh1;
	inrgnh[1] = rh2;
	inrgnh[2] = rh3;
	rgncount = 0;
	rectcount = 0;

	// Check each region, updating the clip rect and collecting non-rectangular regions

	for (i = 0; i < 3; i++) {
		rh = inrgnh[i];
		if (rh == nil)	// Make sure the region handle is good
			continue;
		rgnp = *rh;
		top = rgnp->rgnBBox.top;
		left = rgnp->rgnBBox.left;
		bottom = rgnp->rgnBBox.bottom;
		right = rgnp->rgnBBox.right;
		if (top >= bottom || left >= right)	// Empty region, nothing gets drawn
			goto done;
		if (rgnp->rgnSize > 10)	// A non-rectangular region we have to parse
			outrgnh[rgncount++] = rh;
		// Update the minimum clipping rectangle if the new bounds are smaller
		if (top > cliptop)
			cliptop = top;
		if (left > clipleft)
			clipleft = left;
		if (bottom < clipbottom)
			clipbottom = bottom;
		if (right < clipright)
			clipright = right;
	}

	// If none of the regions were non-rectangular, just return the cliprect
	if (rgncount == 0) {
		if (flags & USE_GLRECT_FMT) {	// GLRect format
			mergedcliprect_gl.x0 = clipleft;
			mergedcliprect_gl.y0 = cliptop;
			mergedcliprect_gl.x1 = clipright;
			mergedcliprect_gl.y1 = clipbottom;
			rectp = (void *)&mergedcliprect_gl;
		} else {	// QuickDraw rect format
			mergedcliprect.top = cliptop;
			mergedcliprect.left = clipleft;
			mergedcliprect.bottom = clipbottom;
			mergedcliprect.right = clipright;
			rectp = (void *)&mergedcliprect;
		}
		(*callbackProcPtr)(rectp, dataPtr);	// Do the callback for the cliprect
		return(1);
	}

	mergedcliprect.top = cliptop;
	mergedcliprect.left = clipleft;
	mergedcliprect.bottom = clipbottom;
	mergedcliprect.right = clipright;

#if DEBUG_BUILD	// Lock down the region so they don't slide if we're using GUI debuggers that can move memory
	for (i = 0; i < rgncount; i++) {
		hstate[i] = HGetState((Handle)outrgnh[i]);
		HLock((Handle)outrgnh[i]);
	}
#endif

	if (rgncount == 1)	// Use a faster routine for the one-region case
		rectcount = parse1rgn(&mergedcliprect, outrgnh[0], nil, callbackProcPtr, dataPtr, flags);
	else
		rectcount = parseNrgns(&mergedcliprect, rgncount, outrgnh, nil, callbackProcPtr, dataPtr, flags);

#if DEBUG_BUILD
	for (i = 0; i < rgncount; i++) {
		HSetState((Handle)outrgnh[i], hstate[i]);
	}
#endif

done:
	return(rectcount);
}

static int parse1rgn(Rect *mincliprectp, RgnHandle rh1, RectListInfoPtr rectlistinfop,
						RectCallbackProcPtr callbackProcPtr, void *dataPtr, int flags)
{
	int i, j, start, stop, increment, searchstart;
	int rectcount, maxrectcount;
	int rectopenv, rectclosev;
	int recttop, rectbottom, rectleft, rectright;
	int cliptop, clipleft, clipbottom, clipright;
	int horizcoord, coord;
	int xcoordcount, coordcntparity;
	void *rectp;
	RgnPtr rgnp;
	SInt16 *rgnstartp, *rgnlinep, *rgndatap;
	Rect newrect;
	__GLregionRect newrect_gl;	// OpenGL version of newrect

	rgnp = *rh1;
	rgnstartp = (SInt16 *)((Ptr)rgnp + sizeof(Region));	// Skip over the region header

	if (flags & BOTTOM_TO_TOP) {	// Scan the region lines bottom-to-top
		// Skip to the end of the region, and back up to the last two 0x7FFFs
		rgnlinep = (SInt16 *)((Ptr)rgnp + rgnp->rgnSize - 2*sizeof(SInt16));
		// Back up and find the end of the previous line's data
		do {
			// We always back up by two shorts at a time.  The region change points always come
			//	in pairs, and the line vertical coordinate is always preceded by 0x7FFF (pairs
			//	again), except for the very first line in a region.  Since non-rectangular
			//	regions must always have at least two lines of data, we're guaranteed the last
			//	line is preceded by a previous line's 0x7FFF end marker.
			rgnlinep -= 2;
		} while (*rgnlinep != ENDMARKER);
		rgnlinep++;	// rgnlinep now points to the beginning of the line's data (Y coord)
	} else {	// Top to bottom
		rgnlinep = rgnstartp;
	}

	xcoordcount = 0;
	rgndatap = rgnlinep;
	rectopenv = *rgndatap++;	// First data on the line is the vertical coordinate
	// Pre-load the first line of X coordinates into the gXcoord array
	coordcntparity = 0;
	for (horizcoord = *rgndatap++; horizcoord != ENDMARKER || coordcntparity != 0; horizcoord = *rgndatap++) {
		gXcoord[xcoordcount++] = horizcoord;
		coordcntparity ^= 1;
	}

	cliptop = mincliprectp->top;
	clipleft = mincliprectp->left;
	clipbottom = mincliprectp->bottom;
	clipright = mincliprectp->right;

	rectcount = 0;
	if (rectlistinfop != nil) {	// We're building a rectangle list
		maxrectcount = rectlistinfop->maxRectCount;
		rectp = rectlistinfop->rectListPtr;
	}

	do {	// Keep processing lines of the region definition until we're done

		if (flags & BOTTOM_TO_TOP) {	// Scan the region lines bottom-to-top
			if (rgnlinep <= rgnstartp)
				break;
			rgnlinep--;	// Point to the even-earlier line's 0x7FFF end marker
			// Back up and find the end of the previous line's data.
			do {
				// We always back up by two shorts at a time.  The region change points always come
				//	in pairs, and the line vertical coordinate is always preceded by 0x7FFF (pairs
				//	again), except for the very first line in a region, which we also check for.
				rgnlinep -= 2;
			} while (*rgnlinep != ENDMARKER && rgnlinep > rgnstartp);
			rgnlinep++;	// rgnlinep now points to the beginning of the current line's data (Y coord)
			rgndatap = rgnlinep;
			rectclosev = *rgndatap++;
			recttop = rectclosev;	// Going bottom to top, the top Y coordinate is the latest one
			rectbottom = rectopenv;
		} else {	// Doing top to bottom
			rectclosev = *rgndatap++;
			if (rectclosev == ENDMARKER)
				break;
			recttop = rectopenv;	// Going top to bottom, the top Y coordinate was the earlier one
			rectbottom = rectclosev;
		}
		// Clip top and bottom to our clipping vertical bounds
		if (recttop < cliptop)
			recttop = cliptop;
		if (rectbottom > clipbottom)
			rectbottom = clipbottom;

		if (recttop < rectbottom) {	// Don't output rectangles clipped to zero height

			// Each new region definition line will flush out the old rectangles

			if (flags & RIGHT_TO_LEFT) {	// Do the reverse (right-to-left) horizontal rectangle order
				start = xcoordcount - 2;
				stop = -2;
				increment = -2;
			} else {			// Do the normal (left-to-right) horizontal rectangle order
				start = 0;
				stop = xcoordcount;
				increment = 2;
			}
			for (i = start; i != stop; i += increment) {
				rectleft = gXcoord[i];
				rectright = gXcoord[i+1];
				// Eliminate any rectangles horizontally outside the clipping rectangle
				if (rectleft >= clipright || rectright <= clipleft)
					continue;	// Completely skip this rectangle
				if (rectlistinfop != nil) {	// Doing the rectangle list
					if (rectcount < maxrectcount) {	// Don't overflow the rectangle list
						// Clip the horizontal coordinates to the clipping rectangle
						if (rectleft < clipleft)	// Partial or full clipping
							rectleft = clipleft;
						if (rectright > clipright)
							rectright = clipright;
						if (flags & USE_GLRECT_FMT) {
							((__GLregionRectPtr)rectp)[rectcount].x0 = rectleft;
							((__GLregionRectPtr)rectp)[rectcount].y0 = recttop;
							((__GLregionRectPtr)rectp)[rectcount].x1 = rectright;
							((__GLregionRectPtr)rectp)[rectcount].y1 = rectbottom;
						} else {
							((Rect *)rectp)[rectcount].top = recttop;
							((Rect *)rectp)[rectcount].left = rectleft;
							((Rect *)rectp)[rectcount].bottom = rectbottom;
							((Rect *)rectp)[rectcount].right = rectright;
						}
						rectlistinfop->rectCount = rectcount + 1;
					}
				} else {	// Doing the rectangle callback
					// Clip the horizontal coordinates to the clipping rectangle
					if (rectleft < clipleft)	// Partial or full clipping
						rectleft = clipleft;
					if (rectright > clipright)
						rectright = clipright;
					if (flags & USE_GLRECT_FMT) {
						newrect_gl.x0 = rectleft;
						newrect_gl.y0 = recttop;
						newrect_gl.x1 = rectright;
						newrect_gl.y1 = rectbottom;
						rectp = (void *)&newrect_gl;
					} else {	// QuickDraw rect format
						newrect.top = recttop;
						newrect.left = rectleft;
						newrect.bottom = rectbottom;
						newrect.right = rectright;
						rectp = (void *)&newrect;
					}
					(*callbackProcPtr)(rectp, dataPtr);	// Do the callback for newrect
				}
				rectcount++;	// Update the count even if we didn't store the rectangle
			}
		}

		// Update with the new coordinate information

		searchstart = 0;
		coordcntparity = 0;
		for (horizcoord = *rgndatap++; horizcoord != ENDMARKER || coordcntparity != 0; horizcoord = *rgndatap++) {
			coordcntparity ^= 1;
			// See whether the new point needs to be inserted into the coordinate
			//	array, or if it 'cancels' a point already in there.  Since the region's
			//	horizontal coordinates are sorted in increasing order, we know that the
			//	next coordinate to add to or delete from our array won't be any earlier
			//	than we've already searched.  So we save the array index where we did the
			//	last insert or delete, so we don't have to unnecessarily compare the
			//	array's previous entries.  ('searchstart' is used for this.)
			for (i = searchstart; i < xcoordcount; i++) {
				coord = gXcoord[i];
				if (horizcoord > coord)	// New point comes after this one
					continue;	// Keep looking for where to put it
				if (horizcoord < coord) {	// Insert the new point here
					if (xcoordcount == MAXCOORDS)	// Array is already full
						break;	// Prevent overflow
					// Shuffle each point up one slot in the array
					for (j = xcoordcount; j > i; j--)
						gXcoord[j] = gXcoord[j-1];
					goto newpoint;
				} else {	// horizcoord == coord, 'cancel' out this point
					// Shuffle each point down one slot in the array
					for (j = i+1; j < xcoordcount; j++)
						gXcoord[j-1] = gXcoord[j];
					xcoordcount--;
					goto savesearchstart;
				}
			}
			// If we reached here, we add the point at the end of the array
newpoint:
			gXcoord[i] = horizcoord;	// Put the new coordinate here
			xcoordcount++;
savesearchstart:
			searchstart = i;	// Optimize the start of our next search
		}

		rectopenv = rectclosev;	// New rect shares a border with the old one

	} while(1);	// Repeat until we 'break' from the loop

	return(rectcount);
}

#if 0	// Was #if DEBUG_BUILD
static void DUMPRGN(RgnHandle rgnh, int rgnnum)
{
	int newline, i, coordcntparity;
	UInt32 size, offset;
	RgnPtr rgnp;
	Ptr p;

	rgnp = *rgnh;
	size = rgnp->rgnSize;
	LOGPRINTF(("Region %d @ 0x%X: size = %d bytes\n", rgnnum, rgnp, size));
	LOGPRINTF(("Bounding rect (TLBR): %d, %d, %d, %d",
			rgnp->rgnBBox.top, rgnp->rgnBBox.left,
			rgnp->rgnBBox.bottom, rgnp->rgnBBox.right));
	p = (Ptr)rgnp;
	newline = true;
	for (offset = sizeof(Region); offset < size; offset += sizeof(SInt16)) {
		i = *(SInt16 *)(p + offset);
		if (newline) {
			LOGPRINTF(("\n%5d:\t", i));
			newline = false;
			coordcntparity = 0;
		} else {
			LOGPRINTF((" %6d", i));
			if (i == ENDMARKER && coordcntparity == 0)
				newline = true;
			coordcntparity ^= 1;
		}
	}
	LOGPRINTF(("\n"));
}
#else
#define DUMPRGN(rgnh, rgnnum)
#endif

static int parseNrgns(Rect *mincliprectp, int rgncount, RgnHandle *rhap, RectListInfoPtr rectlistinfop,
						RectCallbackProcPtr callbackProcPtr, void *dataPtr, int flags)
{
#define MAXRGNS	3
	int rgniter, i, j, searchstart;
	int rectcount, maxrectcount, intersectstartv, newv;
	int recttop, rectbottom, rectleft, rectright;
	int cliptop, clipleft, clipbottom, clipright;
	int horizcoord, coord;
	int xcoordcount, coordcntparity;
	UInt32 morergndatamask, mask, allrgnmask, rgnID;
	void *rectp;
	RgnPtr rgnp;
	SInt16 *rgndata1p, *rgndata2p;
	SInt16 *rgnlinestartp[MAXRGNS], *rgncoordp[MAXRGNS], *rgnendp[MAXRGNS];
	SInt16 *linestartp, *coordp, *endp;
	Rect newrect;
	__GLregionRect newrect_gl;	// OpenGL version of newrect

#if DEBUG_BUILD
	if (rgncount > MAXRGNS) {
		DBUGPRINTF(("parseNrgns: region count %d exceeds max %d\n", rgncount, MAXRGNS));
		return(0);
	}
#endif

	for (rgniter = 0; rgniter < rgncount; rgniter++) {
		rgnp = *rhap[rgniter];
		rgndata1p = (SInt16 *)((Ptr)rgnp + sizeof(Region));	// Skip over the region header
		rgndata2p = (SInt16 *)((Ptr)rgnp + rgnp->rgnSize - sizeof(SInt16));
		if (flags & BOTTOM_TO_TOP) {	// Scan the region lines bottom-to-top
			rgnlinestartp[rgniter] = rgndata2p;	// Points to the last 0x7FFF marker
			rgncoordp[rgniter] = rgndata2p;		// Also points to the last 0x7FFF marker
			rgnendp[rgniter] = rgndata1p;	// Top line is the last in bottom-to-top order
		} else {	// Top to bottom
			rgnlinestartp[rgniter] = rgndata1p;	// Top line is the first
			rgncoordp[rgniter] = rgndata1p;		// Also points to the first line
			rgnendp[rgniter] = rgndata2p;	// Bottom line is the last
		}
		LOGPRINTF(("parseNrgns(%d): rgn %d at 0x%08X, size = %d bytes\n", rgncount, rgniter, rgnp, rgnp->rgnSize));
//		DUMPRGN(rhap[rgniter], rgniter);
	}

	xcoordcount = 0;
	intersectstartv = UNINITIALIZEDV;	// Means we don't have a region intersection started yet
	cliptop = mincliprectp->top;
	clipleft = mincliprectp->left;
	clipbottom = mincliprectp->bottom;
	clipright = mincliprectp->right;
	allrgnmask = (1 << rgncount) - 1;	// Mask with 'rgncount' bits set

	rectcount = 0;
	if (rectlistinfop != nil) {	// We're building a rectangle list
		maxrectcount = rectlistinfop->maxRectCount;
		rectp = rectlistinfop->rectListPtr;
	}

	goto dowehavergndata;	// Kick off the loop (test the enormous loop condition)

	do {

		if (intersectstartv == UNINITIALIZEDV)	// Don't output rectangles if we haven't intersected yet
			goto mergergndata;

		if (flags & BOTTOM_TO_TOP) {
			recttop = newv;
			rectbottom = intersectstartv;
		} else {	// Top to bottom
			recttop = intersectstartv;
			rectbottom = newv;
		}
		// Clip top and bottom to our clipping vertical bounds
		if (recttop < cliptop)
			recttop = cliptop;
		if (rectbottom > clipbottom)
			rectbottom = clipbottom;
		if (recttop >= rectbottom)	// Don't output rectangles clipped to zero height
			goto mergergndata;

		rgnID = 0;	// Initialize for 'no regions active'

		/* The region ID operations are the key to making sure we only output
			rectangles that are in the intersection of ALL the regions.  We keep
			XORing in each coordinate's saved regionID(s), until the accumulated
			ID mask has all the bits set, indicating this coordinate was included
			in all the regions.  This is one of the rectangle sides, and the other
			is the very next coordinate in scanning order (L-R or R-L). */

		if (flags & RIGHT_TO_LEFT) {	// Do the reverse (right-to-left) horizontal rectangle order
			for (i = xcoordcount-1; i > 0; i--) {
				rgnID ^= gRgnID[i];
				if (rgnID != allrgnmask)
					continue;
				rectleft = gXcoord[i-1];
				rectright = gXcoord[i];
				// Eliminate any rectangles horizontally outside the clipping rectangle
				if (rectleft >= clipright || rectright <= clipleft)
					continue;	// Completely skip this rectangle
				if (rectlistinfop != nil) {	// Doing the rectangle list
					if (rectcount < maxrectcount) {	// Don't overflow the rectangle list
						// Clip the horizontal coordinates to the clipping rectangle
						if (rectleft < clipleft)	// Partial or full clipping
							rectleft = clipleft;
						if (rectright > clipright)
							rectright = clipright;
						LOGPRINTF(("\t\tGot a rect (TLBR): %3d, %3d, %3d, %3d\n", recttop, rectleft, rectbottom, rectright));
						if (flags & USE_GLRECT_FMT) {
							((__GLregionRectPtr)rectp)[rectcount].x0 = rectleft;
							((__GLregionRectPtr)rectp)[rectcount].y0 = recttop;
							((__GLregionRectPtr)rectp)[rectcount].x1 = rectright;
							((__GLregionRectPtr)rectp)[rectcount].y1 = rectbottom;
						} else {
							((Rect *)rectp)[rectcount].top = recttop;
							((Rect *)rectp)[rectcount].left = rectleft;
							((Rect *)rectp)[rectcount].bottom = rectbottom;
							((Rect *)rectp)[rectcount].right = rectright;
						}
						rectlistinfop->rectCount = rectcount + 1;
					}
				} else {	// Doing the rectangle callback
					// Clip the horizontal coordinates to the clipping rectangle
					if (rectleft < clipleft)	// Partial or full clipping
						rectleft = clipleft;
					if (rectright > clipright)
						rectright = clipright;
					if (flags & USE_GLRECT_FMT) {
						newrect_gl.x0 = rectleft;
						newrect_gl.y0 = recttop;
						newrect_gl.x1 = rectright;
						newrect_gl.y1 = rectbottom;
						rectp = (void *)&newrect_gl;
					} else {	// QuickDraw rect format
						newrect.top = recttop;
						newrect.left = rectleft;
						newrect.bottom = rectbottom;
						newrect.right = rectright;
						rectp = (void *)&newrect;
					}
					LOGPRINTF(("\t\tGot a rect (TLBR): %3d, %3d, %3d, %3d\n", recttop, rectleft, rectbottom, rectright));
					(*callbackProcPtr)(rectp, dataPtr);	// Do the callback for newrect
				}
				rectcount++;	// Update the count even if we didn't store the rectangle
			}
		} else {	// Do the normal (left-to-right) horizontal rectangle order
			for (i = 0; i < xcoordcount-1; i++) {
				rgnID ^= gRgnID[i];
				if (rgnID != allrgnmask)
					continue;
				rectleft = gXcoord[i];
				rectright = gXcoord[i+1];
				// Eliminate any rectangles horizontally outside the clipping rectangle
				if (rectleft >= clipright || rectright <= clipleft)
					continue;	// Completely skip this rectangle
				if (rectlistinfop != nil) {	// Doing the rectangle list
					if (rectcount < maxrectcount) {	// Don't overflow the rectangle list
						// Clip the horizontal coordinates to the clipping rectangle
						if (rectleft < clipleft)	// Partial or full clipping
							rectleft = clipleft;
						if (rectright > clipright)
							rectright = clipright;
						LOGPRINTF(("\t\tGot a rect (TLBR): %3d, %3d, %3d, %3d\n", recttop, rectleft, rectbottom, rectright));
						if (flags & USE_GLRECT_FMT) {
							((__GLregionRectPtr)rectp)[rectcount].x0 = rectleft;
							((__GLregionRectPtr)rectp)[rectcount].y0 = recttop;
							((__GLregionRectPtr)rectp)[rectcount].x1 = rectright;
							((__GLregionRectPtr)rectp)[rectcount].y1 = rectbottom;
						} else {
							((Rect *)rectp)[rectcount].top = recttop;
							((Rect *)rectp)[rectcount].left = rectleft;
							((Rect *)rectp)[rectcount].bottom = rectbottom;
							((Rect *)rectp)[rectcount].right = rectright;
						}
						rectlistinfop->rectCount = rectcount + 1;
					}
				} else {	// Doing the rectangle callback
					// Clip the horizontal coordinates to the clipping rectangle
					if (rectleft < clipleft)	// Partial or full clipping
						rectleft = clipleft;
					if (rectright > clipright)
						rectright = clipright;
					LOGPRINTF(("\t\tGot a rect (TLBR): %3d, %3d, %3d, %3d\n", recttop, rectleft, rectbottom, rectright));
					if (flags & USE_GLRECT_FMT) {
						newrect_gl.x0 = rectleft;
						newrect_gl.y0 = recttop;
						newrect_gl.x1 = rectright;
						newrect_gl.y1 = rectbottom;
						rectp = (void *)&newrect_gl;
					} else {	// QuickDraw rect format
						newrect.top = recttop;
						newrect.left = rectleft;
						newrect.bottom = rectbottom;
						newrect.right = rectright;
						rectp = (void *)&newrect;
					}
					(*callbackProcPtr)(rectp, dataPtr);	// Do the callback for newrect
				}
				rectcount++;	// Update the count even if we didn't store the rectangle
			}
		}

mergergndata:
		// Merge in one or more regions to the current span definition
		for (rgniter = 0, mask = 1; rgniter < rgncount; rgniter++, mask <<= 1) {
			if ((morergndatamask & mask) == 0)
				continue;	// Skip exhausted regions
			coordp = rgncoordp[rgniter];
			if (*coordp != newv)	// It's not this region's turn yet
				continue;
			coordp++;		// Skip the v coordinate, now point to the h coordinates
			searchstart = 0;
			horizcoord = *coordp;
			coordcntparity = 0;
			while (horizcoord != ENDMARKER || coordcntparity != 0) {
				coordp++;
				coordcntparity ^= 1;
				// See whether the new point needs to be inserted into the coordinate
				//	array, or if it 'cancels' a point already in there.  Since the region's
				//	horizontal coordinates are sorted in increasing order, we know that the
				//	next coordinate to add to or delete from our array won't be any earlier
				//	than we've already searched.  So we save the array index where we did the
				//	last insert or delete, so we don't have to unnecessarily compare the
				//	array's previous entries.  ('searchstart' is used for this.)
				for (i = searchstart; i < xcoordcount; i++) {
					coord = gXcoord[i];
					if (horizcoord > coord)	// New point comes after this one
						continue;	// Keep looking for where to put it
					if (horizcoord < coord) {	// Insert the new point here
						if (xcoordcount == MAXCOORDS)	// Array is already full
							break;	// Prevent overflow
						// Shuffle each point up one array slot
						for (j = xcoordcount; j > i; j--) {
							gXcoord[j] = gXcoord[j-1];
							gRgnID[j] = gRgnID[j-1];
						}
						goto newpoint;
					} else {	// horizcoord == coord, XOR the region IDs to see if they cancel
						rgnID = gRgnID[i] ^ mask;
						if (rgnID != 0) {	// Save back the update region ID mask
							gRgnID[i] = rgnID;
						} else {	// This region was the last to reference this point, so remove it
							// Shuffle each point down one array slot
							for (j = i+1; j < xcoordcount; j++) {
								gXcoord[j-1] = gXcoord[j];
								gRgnID[j-1] = gRgnID[j];
							}
							xcoordcount--;
						}
						goto savesearchstart;
					}
				}
				// If we reached here, we add the point at the end of the array
newpoint:
				gXcoord[i] = horizcoord;	// Put the new coordinate here
				gRgnID[i] = mask;			// Store the region ID as a bit mask
				xcoordcount++;
savesearchstart:
				searchstart = i;	// Optimize the start of our next search
				horizcoord = *coordp;
			}
			// Save away the current region pointer (points to ENDMARKER)
			rgncoordp[rgniter] = coordp;
#if DEBUG_BUILD
			LOGPRINTF(("parseNrgns(%d) after rgn %d --", rgncount, rgniter));
			linestartp = rgnlinestartp[rgniter];
			LOGPRINTF((" %4d:", *linestartp));
			coordcntparity = 0;
			for (linestartp++; *linestartp != ENDMARKER || coordcntparity != 0; linestartp++) {
				LOGPRINTF((" %4d", *linestartp));
				coordcntparity ^= 1;
			}
			LOGPRINTF(("\n"));
			LOGPRINTF(("\tgXcoord =\t"));
			for (i = 0; i < xcoordcount; i++)
				LOGPRINTF((" %4d", gXcoord[i]));
			LOGPRINTF(("\n"));
			LOGPRINTF(("\t gRgnID =\t"));
			for (i = 0; i < xcoordcount; i++)
				LOGPRINTF((" %4d", gRgnID[i]));
			LOGPRINTF(("\n"));
#endif
		}
		intersectstartv = UNINITIALIZEDV;	// We need to look for the start of an intersection again
		rgnID = 0;
		for (i = 0; i < xcoordcount-1; i++) {
			rgnID ^= gRgnID[i];
			if (rgnID != allrgnmask)
				continue;
			// We have a region intersection in this line of data
			intersectstartv = newv;	// Save this vertical coordinate for later rectangle output
			goto dowehavergndata;	// Don't need to check the rest of the line data
		}

dowehavergndata:
		// Update region pointers as needed, and find the next vertical coordinate to process
		morergndatamask = 0;
		if (flags & BOTTOM_TO_TOP) {
			newv = -32767;
			for (rgniter = 0, mask = 1; rgniter < rgncount; rgniter++, mask <<= 1) {
				linestartp = rgnlinestartp[rgniter];
				endp = rgnendp[rgniter];
				if (linestartp == endp)	// No more data in this region
					continue;
				coordp = rgncoordp[rgniter];
				coord = *coordp;
				if (coord == ENDMARKER) {	// Means we need to find the next line beginning
					linestartp--;	// Back up to previous marker
					do {
						// We always back up by two shorts at a time.  The region change points always come
						//	in pairs, and the line vertical coordinate is always preceded by 0x7FFF (pairs
						//	again), except for the very first line in a region, which we also check for.
						//	('endp' points to the highest line in the region, since we're going btm-to-top.)
						linestartp -= 2;
					} while (*linestartp != ENDMARKER && linestartp > endp);
					linestartp++;	// This now points to the beginning of the current line's data (Y coord)
					rgnlinestartp[rgniter] = linestartp;	// Save away the new line start
					rgncoordp[rgniter] = linestartp;	// Update the copy in memory
					coord = *linestartp;	// Get new vertical coordinate
				}
				if (coord > newv)	// Identify the next highest v coordinate (min rectangle height)
					newv = coord;
				morergndatamask |= mask;	// Mark that this region still has data left
			}
		} else {	// Top to bottom
			newv = 32767;
			for (rgniter = 0, mask = 1; rgniter < rgncount; rgniter++, mask <<= 1) {
				linestartp = rgnlinestartp[rgniter];
				endp = rgnendp[rgniter];
				if (linestartp == endp)	// No more data in this region
					continue;
				coordp = rgncoordp[rgniter];
				coord = *coordp;
				if (coord == ENDMARKER) {	// Means we need to go to the next line
					linestartp = coordp + 1;	// Next line starts after the marker
					rgnlinestartp[rgniter] = linestartp;	// Save away the new line start
					rgncoordp[rgniter] = linestartp;	// Update the copy in memory
					if (linestartp == endp)	// No more data in this region
						continue;
					coord = *linestartp;	// Get new vertical coordinate
				}
				if (coord < newv)	// Identify the next lowest v coordinate (min rectangle height)
					newv = coord;
				morergndatamask |= mask;	// Mark that this region still has data left
			}
		}

	} while (morergndatamask != 0);

	return(rectcount);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\common\nv10\inc\nv10ppm.h ===
#ifndef _NV10PPM_H_
#define _NV10PPM_H_

 /***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-1997 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-1997  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

//
// This is a portion of the chip REF file used for direct access to the 
// device performance monitor engine.
//

#define NV_PPM                                0x0000AFFF:0x0000A000 /* RW--D */
#define NV_PPM_NV_TRIG0_SEL                              0x0000A400 /* RW-4R */
#define NV_PPM_NV_TRIG0_SEL_SEL0                                7:0 /* RWXUF */
#define NV_PPM_NV_TRIG0_SEL_SEL1                               15:8 /* RWXUF */
#define NV_PPM_NV_TRIG0_SEL_SEL2                              23:16 /* RWXUF */
#define NV_PPM_NV_TRIG0_SEL_SEL3                              31:24 /* RWXUF */
#define NV_PPM_NV_TRIG0_OP                               0x0000A404 /* RW-4R */
#define NV_PPM_NV_TRIG0_OP_FUNC                                15:0 /* RWXUF */
#define NV_PPM_NV_TRIG0_OP_DSEL0                              16:16 /* RWXUF */
#define NV_PPM_NV_TRIG0_OP_DSEL1                              17:17 /* RWXUF */
#define NV_PPM_NV_TRIG1_SEL                              0x0000A408 /* RW-4R */
#define NV_PPM_NV_TRIG1_SEL_SEL0                                7:0 /* RWXUF */
#define NV_PPM_NV_TRIG1_SEL_SEL1                               15:8 /* RWXUF */
#define NV_PPM_NV_TRIG1_SEL_SEL2                              23:16 /* RWXUF */
#define NV_PPM_NV_TRIG1_SEL_SEL3                              31:24 /* RWXUF */
#define NV_PPM_NV_TRIG1_OP                               0x0000A40C /* RW-4R */
#define NV_PPM_NV_TRIG1_OP_FUNC                                15:0 /* RWXUF */
#define NV_PPM_NV_TRIG1_OP_DSEL0                              16:16 /* RWXUF */
#define NV_PPM_NV_TRIG1_OP_DSEL1                              17:17 /* RWXUF */
#define NV_PPM_NV_EVENT_SEL                              0x0000A410 /* RW-4R */
#define NV_PPM_NV_EVENT_SEL_SEL0                                7:0 /* RWXUF */
#define NV_PPM_NV_EVENT_SEL_SEL1                               15:8 /* RWXUF */
#define NV_PPM_NV_EVENT_SEL_SEL2                              23:16 /* RWXUF */
#define NV_PPM_NV_EVENT_SEL_SEL3                              31:24 /* RWXUF */
#define NV_PPM_NV_EVENT_OP                               0x0000A414 /* RW-4R */
#define NV_PPM_NV_EVENT_OP_FUNC                                15:0 /* RWXUF */
#define NV_PPM_NV_EVENT_OP_DSEL0                              16:16 /* RWXUF */
#define NV_PPM_NV_EVENT_OP_DSEL1                              17:17 /* RWXUF */
#define NV_PPM_NV_SAMPLE_SEL                             0x0000A418 /* RW-4R */
#define NV_PPM_NV_SAMPLE_SEL_SEL0                               7:0 /* RWXUF */
#define NV_PPM_NV_SAMPLE_SEL_SEL1                              15:8 /* RWXUF */
#define NV_PPM_NV_SAMPLE_SEL_SEL2                             23:16 /* RWXUF */
#define NV_PPM_NV_SAMPLE_SEL_SEL3                             31:24 /* RWXUF */
#define NV_PPM_NV_SAMPLE_OP                              0x0000A41C /* RW-4R */
#define NV_PPM_NV_SAMPLE_OP_FUNC                               15:0 /* RWXUF */
#define NV_PPM_NV_SAMPLE_OP_DSEL0                             16:16 /* RWXUF */
#define NV_PPM_NV_SAMPLE_OP_DSEL1                             17:17 /* RWXUF */
#define NV_PPM_NV_SETFLAG_SEL                            0x0000A420 /* RW-4R */
#define NV_PPM_NV_SETFLAG_SEL_SEL0                              7:0 /* RWXUF */
#define NV_PPM_NV_SETFLAG_SEL_SEL1                             15:8 /* RWXUF */
#define NV_PPM_NV_SETFLAG_SEL_SEL2                            23:16 /* RWXUF */
#define NV_PPM_NV_SETFLAG_SEL_SEL3                            31:24 /* RWXUF */
#define NV_PPM_NV_SETFLAG_OP                             0x0000A424 /* RW-4R */
#define NV_PPM_NV_SETFLAG_OP_FUNC                              15:0 /* RWXUF */
#define NV_PPM_NV_SETFLAG_OP_DSEL0                            16:16 /* RWXUF */
#define NV_PPM_NV_SETFLAG_OP_DSEL1                            17:17 /* RWXUF */
#define NV_PPM_NV_CLRFLAG_SEL                            0x0000A428 /* RW-4R */
#define NV_PPM_NV_CLRFLAG_SEL_SEL0                              7:0 /* RWXUF */
#define NV_PPM_NV_CLRFLAG_SEL_SEL1                             15:8 /* RWXUF */
#define NV_PPM_NV_CLRFLAG_SEL_SEL2                            23:16 /* RWXUF */
#define NV_PPM_NV_CLRFLAG_SEL_SEL3                            31:24 /* RWXUF */
#define NV_PPM_NV_CLRFLAG_OP                             0x0000A42C /* RW-4R */
#define NV_PPM_NV_CLRFLAG_OP_FUNC                              15:0 /* RWXUF */
#define NV_PPM_NV_CLRFLAG_OP_DSEL0                            16:16 /* RWXUF */
#define NV_PPM_NV_CLRFLAG_OP_DSEL1                            17:17 /* RWXUF */
#define NV_PPM_NV_ELAPSED_0                              0x0000A600 /* RR-4R */
#define NV_PPM_NV_ELAPSED_0_VAL                                31:0 /* RR-UF */
#define NV_PPM_NV_ELAPSED_1                              0x0000A604 /* RR-4R */
#define NV_PPM_NV_ELAPSED_1_VAL                                 7:0 /* RR-UF */
#define NV_PPM_NV_CYCLECNT_0                             0x0000A608 /* RR-4R */
#define NV_PPM_NV_CYCLECNT_0_VAL                               31:0 /* RR-UF */
#define NV_PPM_NV_CYCLECNT_1                             0x0000A60C /* RR-4R */
#define NV_PPM_NV_CYCLECNT_1_VAL                                7:0 /* RR-UF */
#define NV_PPM_NV_EVENTCNT_0                             0x0000A610 /* RR-4R */
#define NV_PPM_NV_EVENTCNT_0_VAL                               31:0 /* RR-UF */
#define NV_PPM_NV_EVENTCNT_1                             0x0000A614 /* RR-4R */
#define NV_PPM_NV_EVENTCNT_1_VAL                                7:0 /* RR-UF */
#define NV_PPM_NV_THRESHCNT_0                            0x0000A618 /* RR-4R */
#define NV_PPM_NV_THRESHCNT_0_VAL                              31:0 /* RR-UF */
#define NV_PPM_NV_THRESHCNT_1                            0x0000A61C /* RR-4R */
#define NV_PPM_NV_THRESHCNT_1_VAL                               7:0 /* RR-UF */
#define NV_PPM_NV_TRIGGERCNT                             0x0000A620 /* RW-4R */
#define NV_PPM_NV_TRIGGERCNT_VAL                               31:0 /* RWXUF */
#define NV_PPM_NV_SAMPLECNT                              0x0000A624 /* RW-4R */
#define NV_PPM_NV_SAMPLECNT_VAL                                31:0 /* RWXUF */
#define NV_PPM_NV_THRESHOLD_0                            0x0000A628 /* RW-4R */
#define NV_PPM_NV_THRESHOLD_0_VAL                              31:0 /* RWXUF */
#define NV_PPM_NV_THRESHOLD_1                            0x0000A62C /* RW-4R */
#define NV_PPM_NV_THRESHOLD_1_VAL                               7:0 /* RWXUF */
#define NV_PPM_NV_WATCH0                                 0x0000A430 /* RR-4R */
#define NV_PPM_NV_WATCH0_GR_XF2PM_XF_IDLE                      0: 0 /* RR-UF */
#define NV_PPM_NV_WATCH0_GR_XF2PM_XF2VTX_DATA_VALID            1: 1 /* RR-UF */
#define NV_PPM_NV_WATCH0_GR_XF2PM_XF2IDX_BUSY                  2: 2 /* RR-UF */
#define NV_PPM_NV_WATCH0_GR_VTX2PM_VTXPRIMIDLE                 3: 3 /* RR-UF */
#define NV_PPM_NV_WATCH0_GR_VTX2PM_VTX2STP_PRIMVALID           4: 4 /* RR-UF */
#define NV_PPM_NV_WATCH0_GR_VTX2PM_VTX2IDX_BUSY                5: 5 /* RR-UF */
#define NV_PPM_NV_WATCH0_GR_VTX2PM_VTX2COL_VALID               6: 6 /* RR-UF */
#define NV_PPM_NV_WATCH0_GR_TEX2PM_TP1_REPLACER_STALL          7: 7 /* RR-UF */
#define NV_PPM_NV_WATCH0_GR_TEX2PM_TP1_MP_QUEUE_STALL          8: 8 /* RR-UF */
#define NV_PPM_NV_WATCH0_GR_TEX2PM_TP1_COALESCER_STALL         9: 9 /* RR-UF */
#define NV_PPM_NV_WATCH0_GR_TEX2PM_TP0_REPLACER_STALL         10:10 /* RR-UF */
#define NV_PPM_NV_WATCH0_GR_TEX2PM_TP0_MP_QUEUE_STALL         11:11 /* RR-UF */
#define NV_PPM_NV_WATCH0_GR_TEX2PM_TP0_COALESCER_STALL        12:12 /* RR-UF */
#define NV_PPM_NV_WATCH0_GR_TEX2PM_TEX2MATH_TP1_BUSY          13:13 /* RR-UF */
#define NV_PPM_NV_WATCH0_GR_TEX2PM_TEX2MATH_TP0_BUSY          14:14 /* RR-UF */
#define NV_PPM_NV_WATCH0_GR_TEX2PM_TEX2LIT_REQ                15:15 /* RR-UF */
#define NV_PPM_NV_WATCH0_GR_TEX2PM_TEX2LIT_REGLD              16:16 /* RR-UF */
#define NV_PPM_NV_WATCH0_GR_TEX2PM_SNAP_PULSE                 17:17 /* RR-UF */
#define NV_PPM_NV_WATCH0_GR_TEX2PM_RBFR_FULL_STALL            18:18 /* RR-UF */
#define NV_PPM_NV_WATCH0_GR_TEX2PM_CACHE_IDLE                 19:19 /* RR-UF */
#define NV_PPM_NV_WATCH0_GR_TEX2PM_C2DMA_DV                   20:20 /* RR-UF */
#define NV_PPM_NV_WATCH0_GR_STP2PM_VTX_OFFSCREEN              21:21 /* RR-UF */
#define NV_PPM_NV_WATCH0_GR_STP2PM_STP_IDLE                   22:22 /* RR-UF */
#define NV_PPM_NV_WATCH0_GR_STP2PM_STP2VTX_BUSY               23:23 /* RR-UF */
#define NV_PPM_NV_WATCH0_GR_STP2PM_STP2RSTR_VALID             24:24 /* RR-UF */
#define NV_PPM_NV_WATCH0_GR_STP2PM_STP2RSTR_DO_SWATHS         25:25 /* RR-UF */
#define NV_PPM_NV_WATCH0_GR_STP2PM_STP2CLP_VALID              26:26 /* RR-UF */
#define NV_PPM_NV_WATCH0_GR_STP2PM_START_PRIM                 27:27 /* RR-UF */
#define NV_PPM_NV_WATCH0_GR_STP2PM_POLYMODE                   28:28 /* RR-UF */
#define NV_PPM_NV_WATCH0_GR_STP2PM_DUAL_TEXTURE               29:29 /* RR-UF */
#define NV_PPM_NV_WATCH0_GR_STP2PM_DO_POINT                   30:30 /* RR-UF */
#define NV_PPM_NV_WATCH0_GR_STP2PM_DO_LINE                    31:31 /* RR-UF */
#define NV_PPM_NV_WATCH1                                 0x0000A434 /* RR-4R */
#define NV_PPM_NV_WATCH1_GR_STP2PM_CYL_WRAP                    0: 0 /* RR-UF */
#define NV_PPM_NV_WATCH1_GR_STP2PM_CULL_SMALL                  1: 1 /* RR-UF */
#define NV_PPM_NV_WATCH1_GR_STP2PM_CULL_NEAR                   2: 2 /* RR-UF */
#define NV_PPM_NV_WATCH1_GR_STP2PM_CULL_FRONT                  3: 3 /* RR-UF */
#define NV_PPM_NV_WATCH1_GR_STP2PM_CULL_FAR                    4: 4 /* RR-UF */
#define NV_PPM_NV_WATCH1_GR_STP2PM_CULL_ENA                    5: 5 /* RR-UF */
#define NV_PPM_NV_WATCH1_GR_STP2PM_CULL_BBOX                   6: 6 /* RR-UF */
#define NV_PPM_NV_WATCH1_GR_STP2PM_CULL_BACK                   7: 7 /* RR-UF */
#define NV_PPM_NV_WATCH1_GR_RSTR2PM_SEARCH_MODE                8: 8 /* RR-UF */
#define NV_PPM_NV_WATCH1_GR_RSTR2PM_RSTR_EOPRIM                9: 9 /* RR-UF */
#define NV_PPM_NV_WATCH1_GR_RSTR2PM_RSTR2PIPE_XY_VALID        10:10 /* RR-UF */
#define NV_PPM_NV_WATCH1_GR_RSTR2PM_RSTR2PIPE_EOPOLY          11:11 /* RR-UF */
#define NV_PPM_NV_WATCH1_GR_RSTR2PM_RSTR2MATH_NEWLINE         12:12 /* RR-UF */
#define NV_PPM_NV_WATCH1_GR_RSTR2PM_RSTR2MATH_ABC_VALID       13:13 /* RR-UF */
#define NV_PPM_NV_WATCH1_GR_RSTR2PM_PIXCNT_0                  14:14 /* RR-UF */
#define NV_PPM_NV_WATCH1_GR_RSTR2PM_PIXCNT_1                  15:15 /* RR-UF */
#define NV_PPM_NV_WATCH1_GR_RSTR2PM_PIXCNT_2                  16:16 /* RR-UF */
#define NV_PPM_NV_WATCH1_GR_RSTR2PM_FINE_STALL                17:17 /* RR-UF */
#define NV_PPM_NV_WATCH1_GR_RSTR2PM_FINE_IDLE                 18:18 /* RR-UF */
#define NV_PPM_NV_WATCH1_GR_RSTR2PM_FINE_EDGE_EVAL            19:19 /* RR-UF */
#define NV_PPM_NV_WATCH1_GR_RSTR2PM_FINE_ALIASED              20:20 /* RR-UF */
#define NV_PPM_NV_WATCH1_GR_RSTR2PM_COARSE_VALID              21:21 /* RR-UF */
#define NV_PPM_NV_WATCH1_GR_RSTR2PM_COARSE_STALL              22:22 /* RR-UF */
#define NV_PPM_NV_WATCH1_GR_RSTR2PM_COARSE_IDLE               23:23 /* RR-UF */
#define NV_PPM_NV_WATCH1_GR_ROP2PM_ZWRITE                     24:24 /* RR-UF */
#define NV_PPM_NV_WATCH1_GR_ROP2PM_ZPARTIAL                   25:25 /* RR-UF */
#define NV_PPM_NV_WATCH1_GR_ROP2PM_WAITMEMWR                  26:26 /* RR-UF */
#define NV_PPM_NV_WATCH1_GR_ROP2PM_WAITMEMRD                  27:27 /* RR-UF */
#define NV_PPM_NV_WATCH1_GR_ROP2PM_WAIT_BUF                   28:28 /* RR-UF */
#define NV_PPM_NV_WATCH1_GR_ROP2PM_ROP_IDLE                   29:29 /* RR-UF */
#define NV_PPM_NV_WATCH1_GR_ROP2PM_ROP2FB_REQ                 30:30 /* RR-UF */
#define NV_PPM_NV_WATCH1_GR_ROP2PM_ROP2FB_RD                  31:31 /* RR-UF */
#define NV_PPM_NV_WATCH2                                 0x0000A438 /* RR-4R */
#define NV_PPM_NV_WATCH2_GR_ROP2PM_ROP2FB_ALOM                 0: 0 /* RR-UF */
#define NV_PPM_NV_WATCH2_GR_ROP2PM_CWRITE                      1: 1 /* RR-UF */
#define NV_PPM_NV_WATCH2_GR_R2D2PM_PRE_OUTPUT_BUSY             2: 2 /* RR-UF */
#define NV_PPM_NV_WATCH2_GR_R2D2PM_R2D2MATH_IM_NEWLINE         3: 3 /* RR-UF */
#define NV_PPM_NV_WATCH2_GR_R2D2PM_RSTR2D_IDLE                 4: 4 /* RR-UF */
#define NV_PPM_NV_WATCH2_GR_R2D2PM_R2D2FE_RSTR2D_BUSY          5: 5 /* RR-UF */
#define NV_PPM_NV_WATCH2_GR_R2D2PM_MATH_CACHE_BUSY             6: 6 /* RR-UF */
#define NV_PPM_NV_WATCH2_GR_R2D2PM_R2D2PRE_OUTPUT_REQ          7: 7 /* RR-UF */
#define NV_PPM_NV_WATCH2_GR_R2D2PM_R2D2PRE_OUTPUT_NOP          8: 8 /* RR-UF */
#define NV_PPM_NV_WATCH2_GR_R2D2PM_R2D2MATH_IM_RIGHT_DV        9: 9 /* RR-UF */
#define NV_PPM_NV_WATCH2_GR_R2D2PM_R2D2MATH_IM_LEFT_DV        10:10 /* RR-UF */
#define NV_PPM_NV_WATCH2_GR_R2D2PM_FE_REQ                     11:11 /* RR-UF */
#define NV_PPM_NV_WATCH2_GR_PRE2PM_PREROP_IDLE                12:12 /* RR-UF */
#define NV_PPM_NV_WATCH2_GR_PRE2PM_PRE2ROP_ROP_REQ            13:13 /* RR-UF */
#define NV_PPM_NV_WATCH2_GR_PRE2PM_PRE2ROP_POSTING_BUFFER     14:14 /* RR-UF */
#define NV_PPM_NV_WATCH2_GR_PRE2PM_PRE2R2D_OUTPUT_BUSY        15:15 /* RR-UF */
#define NV_PPM_NV_WATCH2_GR_PRE2PM_PRE2PIPE_BUSY              16:16 /* RR-UF */
#define NV_PPM_NV_WATCH2_GR_PRE2PM_PRE2LIT_BUSY               17:17 /* RR-UF */
#define NV_PPM_NV_WATCH2_GR_PRE2PM_COALESCE                   18:18 /* RR-UF */
#define NV_PPM_NV_WATCH2_GR_PRE2PM_ALL3D_REQ                  19:19 /* RR-UF */
#define NV_PPM_NV_WATCH2_GR_PIPE2PM_PIPE_XY_RDY               20:20 /* RR-UF */
#define NV_PPM_NV_WATCH2_GR_PIPE2PM_PIPE_IDLE                 21:21 /* RR-UF */
#define NV_PPM_NV_WATCH2_GR_MATH2PM_MATH2TEX_TP1_REQ          22:22 /* RR-UF */
#define NV_PPM_NV_WATCH2_GR_MATH2PM_MATH2TEX_TP0_REQ          23:23 /* RR-UF */
#define NV_PPM_NV_WATCH2_GR_MATH2PM_MATH2TEX_MAGNIFY          24:24 /* RR-UF */
#define NV_PPM_NV_WATCH2_GR_MATH2PM_MATH2TEX_ANISO_SAMPLE     25:25 /* RR-UF */
#define NV_PPM_NV_WATCH2_GR_MATH2PM_MATH2RSTR_RDY             26:26 /* RR-UF */
#define NV_PPM_NV_WATCH2_GR_MATH2PM_MATH2RSTR_ABC_RDY         27:27 /* RR-UF */
#define NV_PPM_NV_WATCH2_GR_LIT2PM_RECIRC_CYCLE               28:28 /* RR-UF */
#define NV_PPM_NV_WATCH2_GR_LIT2PM_LIT2TEX_BUSY               29:29 /* RR-UF */
#define NV_PPM_NV_WATCH2_GR_LIT2PM_LIT2PRE_REQ                30:30 /* RR-UF */
#define NV_PPM_NV_WATCH2_GR_LIT2PM_LIT2COL_BUSY               31:31 /* RR-UF */
#define NV_PPM_NV_WATCH3                                 0x0000A43C /* RR-4R */
#define NV_PPM_NV_WATCH3_GR_IDX2PM_THREADSTALLED               0: 0 /* RR-UF */
#define NV_PPM_NV_WATCH3_GR_IDX2PM_PTEBUSY                     1: 1 /* RR-UF */
#define NV_PPM_NV_WATCH3_GR_IDX2PM_INTALIGN                    2: 2 /* RR-UF */
#define NV_PPM_NV_WATCH3_GR_IDX2PM_IDXFRONTIDLE                3: 3 /* RR-UF */
#define NV_PPM_NV_WATCH3_GR_IDX2PM_IDX2XF_VALID_0              4: 4 /* RR-UF */
#define NV_PPM_NV_WATCH3_GR_IDX2PM_IDX2XF_VALID_1              5: 5 /* RR-UF */
#define NV_PPM_NV_WATCH3_GR_IDX2PM_IDX2VTX_VALID               6: 6 /* RR-UF */
#define NV_PPM_NV_WATCH3_GR_IDX2PM_IDX2PMI_VALID               7: 7 /* RR-UF */
#define NV_PPM_NV_WATCH3_GR_IDX2PM_IDX2FBI_VALID               8: 8 /* RR-UF */
#define NV_PPM_NV_WATCH3_GR_IDX2PM_IDX2DEC_BUSY                9: 9 /* RR-UF */
#define NV_PPM_NV_WATCH3_GR_IDX2PM_COMPOVFL                   10:10 /* RR-UF */
#define NV_PPM_NV_WATCH3_GR_IDX2PM_CACHETHRASH                11:11 /* RR-UF */
#define NV_PPM_NV_WATCH3_GR_FF2PM_FF_GR_RDY                   12:12 /* RR-UF */
#define NV_PPM_NV_WATCH3_GR_FF2PM_FF_GR_B2B                   13:13 /* RR-UF */
#define NV_PPM_NV_WATCH3_GR_FE2PM_NVINTR_GR                   14:14 /* RR-UF */
#define NV_PPM_NV_WATCH3_GR_FE2PM_WAIT_GR_IDLE                15:15 /* RR-UF */
#define NV_PPM_NV_WATCH3_GR_FE2PM_NOP                         16:16 /* RR-UF */
#define NV_PPM_NV_WATCH3_GR_FE2PM_GR_SWITCH                   17:17 /* RR-UF */
#define NV_PPM_NV_WATCH3_GR_FE2PM_GR_IDLE                     18:18 /* RR-UF */
#define NV_PPM_NV_WATCH3_GR_FE2PM_FBI_REQ_BURST               19:19 /* RR-UF */
#define NV_PPM_NV_WATCH3_GR_FE2PM_FBI_REQ                     20:20 /* RR-UF */
#define NV_PPM_NV_WATCH3_GR_FE2PM_FBI_RD                      21:21 /* RR-UF */
#define NV_PPM_NV_WATCH3_GR_FE2PM_FBI_INST                    22:22 /* RR-UF */
#define NV_PPM_NV_WATCH3_GR_FE2PM_CACHE_INVALIDATE            23:23 /* RR-UF */
#define NV_PPM_NV_WATCH3_GR_FBI2PM_FBI2IDX_BUSY               24:24 /* RR-UF */
#define NV_PPM_NV_WATCH3_GR_DMA2PM_DMA2C_DV                   25:25 /* RR-UF */
#define NV_PPM_NV_WATCH3_GR_DMA2PM_DMA2C_ASTALL               26:26 /* RR-UF */
#define NV_PPM_NV_WATCH3_GR_DEC2PM_DEC2IDX_VALID_0            27:27 /* RR-UF */
#define NV_PPM_NV_WATCH3_GR_DEC2PM_DEC2IDX_VALID_1            28:28 /* RR-UF */
#define NV_PPM_NV_WATCH3_GR_COL2PM_SPECULAR_RECIRC            29:29 /* RR-UF */
#define NV_PPM_NV_WATCH3_GR_COL2PM_COLOR_IDLE                 30:30 /* RR-UF */
#define NV_PPM_NV_WATCH3_GR_COL2PM_COL2XYPIPE_BUSY            31:31 /* RR-UF */
#define NV_PPM_NV_WATCH4                                 0x0000A630 /* RR-4R */
#define NV_PPM_NV_WATCH4_GR_COL2PM_COL2VTX_BUSY                0: 0 /* RR-UF */
#define NV_PPM_NV_WATCH4_GR_COL2PM_COL2LIT_REQ                 1: 1 /* RR-UF */
#define NV_PPM_NV_WATCH4_GR_COL2PM_COL2FCOMB_REQ               2: 2 /* RR-UF */
#define NV_PPM_NV_WATCH4_GR_COL2PM_COL2CLP_BUSY                3: 3 /* RR-UF */
#define NV_PPM_NV_WATCH4_GR_CLP2PM_CLP2STP_BUSY                4: 4 /* RR-UF */
#define NV_PPM_NV_WATCH4_TOP_PMI2PM_PMI2IDX_VALID              5: 5 /* RR-UF */
#define NV_PPM_NV_WATCH4_TOP_PMI2PM_PMI2IDX_BUSY               6: 6 /* RR-UF */
#define NV_PPM_NV_WATCH4_TOP_HOST2PM_TIMER_262US               7: 7 /* RR-UF */
#define NV_PPM_NV_WATCH4_TOP_HOST2PM_FF_GR_MDV                 8: 8 /* RR-UF */
#define NV_PPM_NV_WATCH4_TOP_HOST2PM_FF_DHV                    9: 9 /* RR-UF */
#define NV_PPM_NV_WATCH4_TOP_HOST2PM_FF_CHSW                  10:10 /* RR-UF */
#define NV_PPM_NV_WATCH4_TOP_FBI2PM_X_DLY                     11:11 /* RR-UF */
#define NV_PPM_NV_WATCH4_TOP_FBI2PM_S_DLY                     12:12 /* RR-UF */
#define NV_PPM_NV_WATCH4_TOP_FBI2PM_R2W_DLY                   13:13 /* RR-UF */
#define NV_PPM_NV_WATCH4_TOP_FBI2PM_H_DLY                     14:14 /* RR-UF */
#define NV_PPM_NV_WATCH4_TOP_FB2PM_FB2ROP_BUSY                15:15 /* RR-UF */
#define NV_PPM_NV_WATCH4_TOP_FBI2PM_D_DLY                     16:16 /* RR-UF */
#define NV_PPM_NV_WATCH4_TOP_FBI2PM_BC                        17:17 /* RR-UF */
#define NV_PPM_NV_WATCH4_TOP_CRTC2PM_CRTC2DAC_VSYNC2DAC       18:18 /* RR-UF */
#define NV_PPM_CONTROL                                   0x0000A73C /* RW-4R */
#define NV_PPM_CONTROL_OUT_SEL                                  0:0 /* RWXUF */
#define NV_PPM_CONTROL_OUT_SEL_PM                        0x00000000 /* RWI-V */
#define NV_PPM_CONTROL_OUT_SEL_FBIDEBUG                  0x00000001 /* RWI-V */
#define NV_PPM_CONTROL_DRIVE_OUT                                1:1 /* RWXUF */
#define NV_PPM_CONTROL_DRIVE_OUT_NORMAL                  0x00000000 /* RWI-V */
#define NV_PPM_CONTROL_DRIVE_OUT_OBSERVE                 0x00000001 /* RWI-V */
#define NV_PPM_CONTROL_NV_ADDTOEVENT                            2:2 /* RWXUF */
#define NV_PPM_CONTROL_NV_ADDTOEVENT_INCR                0x00000000 /* RWI-V */
#define NV_PPM_CONTROL_NV_ADDTOEVENT_ADDTRIG1            0x00000001 /* RWI-V */
#define NV_PPM_CONTROL_NV_STATE                                 4:3 /* RRIUF */
#define NV_PPM_CONTROL_STATE_IDLE                        0x00000000 /* RWI-V */
#define NV_PPM_CONTROL_STATE_WAIT_TRIG0                  0x00000001 /* RWI-V */
#define NV_PPM_CONTROL_STATE_WAIT_TRIG1                  0x00000002 /* RWI-V */
#define NV_PPM_CONTROL_STATE_CAPTURE                     0x00000003 /* RWI-V */

#endif // _NV10PPM_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\common\nv20\src\vpcompilekelvin.c ===
/*
 * vpcompilekelvin.c
 *
 * Copyright 2000 NVIDIA, Corporation.  All rights reserved.
 *
 * THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
 * NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
 * IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
 */

/*
** This file should only be compiled if it's needed.  The normal OpenGL ifdefs:
**
**      #if defined(GL_NV_vertex_program) && __NV_ACCEL>=10
**      #ifdef __GL_USE_OG_INTEL_ASM
**
** and any OpenGL includes like:
**
**      #include "context.h"
**
** can't be used since this is used by D3D as well.
**
*/

#include <stddef.h>

#if defined(IS_OPENGL)
#include "nvassert.h"
#endif

#include "vtxpgmconsts.h"
#include "vtxpgmcomp.h"

#if !defined(FALSE)
#define FALSE 0
#endif

#if !defined(TRUE)
#define TRUE 1
#endif

// Duplicate values so they can be seen by the common code:

#define __GLNV20_TEX_SCALE_FIELD_BITS                4 // 4 bits per field

#define __GLNV20_TEX_SCALE_IDENTITY                  0x0 // no scaling needed (MUST be zero value)
#define __GLNV20_TEX_SCALE_R_65535                   0x1 // scale R by 2^16-1 for 16-bit shadow mapping
#define __GLNV20_TEX_SCALE_R_16777215                0x2 // scale R by 2^24-1 for 24-bit shadow mapping
#define __GLNV20_TEX_SCALE_STR_65535                 0x3 // scale STR by 2^16-1 for 16-bit depth replace
#define __GLNV20_TEX_SCALE_STR_16777215              0x4 // scale STR by 2^24-1 for 24-bit depth replace
#define __GLNV20_NUM_TEX_SCALES                      5
#define __GLNV20_TEX_SCALE_MASK                      ((1 << __GLNV20_TEX_SCALE_FIELD_BITS) - 1)

// End duplicate values

#if defined(IS_OPENGL)

// Definitions so we can include nvTrace.h:

#define CDECLCALL
#define GL_POLYGON 9
typedef int GLenum;

#include "nvTrace.h"

#else // !IS_OPENGL

#define NV_FUN_NAME(X, Y, Z)
#define NV_TRACE_FUNC(A)
#define NV_TRACE_PUSH()
#define NV_TRACE_POP()

#ifdef DEBUG
    #define NV_TRACE(X, Y, Z)           if (dbgLevel & NVDBG_LEVEL_VSHADER_INS) { DPF_PLAIN Z; }
    #define NV_TRACE_COND(X, Y, Z)      Z
    #define NV_TRACE_CODE(X)            X
    #define TPRINTF(X)                  if (dbgLevel & NVDBG_LEVEL_VSHADER_INS) { DPF_PLAIN X; }
#else // !DEBUG
    #define NV_TRACE(X, Y, Z)
    #define NV_TRACE_COND(X, Y, Z)
    #define NV_TRACE_CODE(X)
    #define TPRINTF(X)
#endif // !DEBUG

#endif // !IS_OPENGL

typedef enum ILUop_Enum {
    ILU_NOP = 0x0, ILU_MOV = 0x1, ILU_RCP = 0x2, ILU_RCC = 0x3,
    ILU_RSQ = 0x4, ILU_EXP = 0x5, ILU_LOG = 0x6, ILU_LIT = 0x7,
} ILUop;

typedef enum MACop_Enum {
    MAC_NOP = 0x0, MAC_MOV = 0x1, MAC_MUL = 0x2, MAC_ADD = 0x3,
    MAC_MAD = 0x4, MAC_DP3 = 0x5, MAC_DPH = 0x6, MAC_DP4 = 0x7,
    MAC_DST = 0x8, MAC_MIN = 0x9, MAC_MAX = 0xa, MAC_SLT = 0xb,
    MAC_SGE = 0xc, MAC_ARL = 0xd,
} MACop;

typedef enum MUXVals_Enum {
    IN_MUX_CA = 3, IN_MUX_VA = 2, IN_MUX_RR = 1, IN_MUX_M_ILLEGAL = 0,
    OUT_MUX_OM_ALU = 0, OUT_MUX_OM_ILU = 1,
    OC_SELECT_CONTEXT = 0x000, OC_SELECT_OUTPUT = 0x100,
} MUXVals;

typedef enum WRITEMask_Enum {
    OUT_MASK_X = 8, OUT_MASK_Y = 4, OUT_MASK_Z = 2, OUT_MASK_W = 1,
    OUT_MASK_XYZW = 0xf,
} WRITEMask;

typedef struct SwizzleSrcReg20_Rec {
    unsigned char ne;
    unsigned char xs;
    unsigned char ys;
    unsigned char zs;
    unsigned char ws;
    unsigned char rr;
    unsigned char mx;
} SwizzleSrcReg20;

typedef struct vtxpgmInst_Rec {
    ILUop ilu;
    MACop mac;
    unsigned char ca;
    unsigned char va;
    SwizzleSrcReg20 a;
    SwizzleSrcReg20 b;
    SwizzleSrcReg20 c;
    unsigned char rwm;
    unsigned char rw;
    unsigned char swm;
    unsigned char owm;
    unsigned short oc;
    unsigned char om;
    unsigned char cin;
    unsigned char eos;
} vtxpgmInst;

#define ALU_TEMP 0x40
#define ILU_TEMP 0x00

///////////////////////////////////////////////////////////////////////////////

static void lInitInst(vtxpgmInst *pInst)
{
    char *pCode;
    int ii;

    pCode = (char *) pInst;
    for (ii = 0; ii < sizeof(vtxpgmInst); ii++)
        pCode[ii] = 0;

    // Setting unused inputs to IN_MUX_RR can cause unnecessary stalls, so we now use IN_MUX_VA.

    pInst->a.mx = IN_MUX_VA;
    pInst->b.mx = IN_MUX_VA;
    pInst->c.mx = IN_MUX_VA;
    pInst->oc = 0x1ff;
} // lInitInst

///////////////////////////////////////////////////////////////////////////////

typedef struct vtxpgmTLiveDead_Rec {
    unsigned char v[__GL_NUMBER_OF_TEMPORARY_REGISTERS], tmpReg;
} vtxpgmTLiveDead;

/*
** lDeftMaskedDstReg() - Mark registers set as "dead" prior to this point.
*/

static void lDefMaskedDstReg(VtxProgCompileKelvin *env, vtxpgmTLiveDead *pLive,
                             MaskedDstReg *reg, int IsALU)
{
    unsigned char *LiveDead;
    int mask, lreg, ii, jj, bits;

    lreg = reg->reg;
    if (lreg >= TR_0 && lreg <= TR_11) {

        // Mark any registers set as dead:

        LiveDead = &pLive->v[lreg - TR_0];
        mask = reg->mask;
        *LiveDead &= ~mask;
    } else {
        if (lreg >= VR_TEX0 && lreg <= VR_TEX3) {

            // Potential patch needed:

            ii = lreg - VR_TEX0;
            bits = (env->textureScaling >> (ii*__GLNV20_TEX_SCALE_FIELD_BITS)) &
                   __GLNV20_TEX_SCALE_MASK;
            if (bits) {

                // We need to scale it.  Find a dead scratch register:

                for (jj = __GL_NUMBER_OF_TEMPORARY_REGISTERS - 1; jj >= 0; jj--) {
                    if (!pLive->v[jj]) {
                        pLive->tmpReg = jj | 0x80;
                        if (IsALU)
                            pLive->tmpReg |= ALU_TEMP;
                        // Always use 2 instructions for now.  Could be optimized.
                        env->numExtraInstructions += 2;
                        break;
                    }
                }
                if (!pLive->tmpReg) {
                    assert(!"Can't find a dead temp register");
                }
            }
        }
    }
} // lDefMaskedDstReg

/*
** lRefScalarSrcReg() - Mark referenced registers as "live" prior to this point.
*/

static void lRefScalarSrcReg(vtxpgmTLiveDead *pLive, char mask, ScalarSrcReg *reg)
{
    int lreg;

    lreg = reg->reg.reg;
    if (lreg >= TR_0 && lreg <= TR_11) {
        if (mask) // Any output means we need the input
            pLive->v[lreg - TR_0] |= 1 << (reg->com & 3);
    }
} // lRefScalarSrcReg

/*
** lRefSwizzleSrcReg() - Mark referenced registers as "live" prior to this point.
*/

static void lRefSwizzleSrcReg(vtxpgmTLiveDead *pLive, char mask, SwizzleSrcReg *reg)
{
    unsigned char *LiveDead;
    int lreg;

    lreg = reg->reg.reg;
    if (lreg >= TR_0 && lreg <= TR_11) {
        LiveDead = &pLive->v[lreg - TR_0];
        if (mask & DST_X_BIT)
            *LiveDead |= 1 << (reg->com4 & 3);
        if (mask & DST_Y_BIT)
            *LiveDead |= 1 << ((reg->com4 >> 2) & 3);
        if (mask & DST_Z_BIT)
            *LiveDead |= 1 << ((reg->com4 >> 4) & 3);
        if (mask & DST_W_BIT)
            *LiveDead |= 1 << ((reg->com4 >> 6) & 3);
    }
} // lRefSwizzleSrcReg

/*
** lInitTempLiveDead() - Build live/dead vectors for temp registers.  Needed for hidden
**         texture coordinate scaling used by depth replace, etc.
*/

static void lInitTempLiveDead(VtxProgCompileKelvin *env, ParsedProgram *parsed,
                              int numInstructions)
{
    vtxpgmTLiveDead *pLive;
    Instruction *inst;
    Arl_Instruction *ainst;
    Scalar_Instruction *sinst;
    Vector_Instruction *vinst;
    Bin_Instruction *binst;
    Tri_Instruction *tinst;
    int ii, lop, pc;

    env->tLiveDead = (struct vtxpgmTLiveDead_Rec *) NULL;
    env->numExtraInstructions = 0;
    if (!env->textureScaling) {
        return;
    }

    pLive = env->tLiveDead = (vtxpgmTLiveDead *)
                     (env->malloc (env->mallocArg, sizeof(vtxpgmTLiveDead)*(numInstructions + 1)));
    for (pc = numInstructions; pc >= 0; pc--) {
        for (ii = __GL_NUMBER_OF_TEMPORARY_REGISTERS - 1; ii >= 0; ii--)
            pLive->v[ii] = 0;
        pLive->tmpReg = 0;
        pLive++;
    }

    // Walk the code backwards marking live temp registers:

    for (pc = numInstructions - 1; pc >= 0; pc--) {
        pLive = &env->tLiveDead[pc];
        *pLive = env->tLiveDead[pc + 1];
        pLive->tmpReg = 0;
        inst = &parsed->firstInstruction[pc];
        lop = inst->end_op.opcode;
        switch (lop) {

        // ARL op:

        case OP_ARL:
            ainst = (Arl_Instruction *) inst;
            lRefScalarSrcReg(pLive, DST_X_BIT, &ainst->src);
            break;

        // SCALAR ops:

        case OP_EXP:
        case OP_LOG:
#if defined(NV_INTERNAL_OPCODES)
        case OP_RCC:
#endif // NV_INTERNAL_OPCODES
        case OP_RCP:
        case OP_RSQ:
            sinst = (Scalar_Instruction *) inst;
            lDefMaskedDstReg(env, pLive, &sinst->dst, 0);
            lRefScalarSrcReg(pLive, sinst->dst.mask, &sinst->src);
            break;

        // VECTOR ops:

        case OP_LIT:
            vinst = (Vector_Instruction *) inst;
            lDefMaskedDstReg(env, pLive, &vinst->dst, 0);
            lRefSwizzleSrcReg(pLive, DST_XYW_BITS, &vinst->src);
            break;

#if defined(NV_INTERNAL_OPCODES)
        case OP_IMV:
            vinst = (Vector_Instruction *) inst;
            lDefMaskedDstReg(env, pLive, &vinst->dst, 0);
            lRefSwizzleSrcReg(pLive, vinst->dst.mask, &vinst->src);
            break;
#endif // NV_INTERNAL_OPCODES
        case OP_MOV:
            vinst = (Vector_Instruction *) inst;
            lDefMaskedDstReg(env, pLive, &vinst->dst, 1);
            lRefSwizzleSrcReg(pLive, vinst->dst.mask, &vinst->src);
            break;

        // BIN ops:

        case OP_ADD:
        case OP_MAX:
        case OP_MIN:
        case OP_MUL:
        case OP_SGE:
        case OP_SLT:
            binst = (Bin_Instruction *) inst;
            lDefMaskedDstReg(env, pLive, &binst->dst, 1);
            lRefSwizzleSrcReg(pLive, binst->dst.mask, &binst->srcA);
            lRefSwizzleSrcReg(pLive, binst->dst.mask, &binst->srcB);
            break;

        case OP_DP3:
            binst = (Bin_Instruction *) inst;
            lDefMaskedDstReg(env, pLive, &binst->dst, 1);
            lRefSwizzleSrcReg(pLive, DST_XYZ_BITS, &binst->srcA);
            lRefSwizzleSrcReg(pLive, DST_XYZ_BITS, &binst->srcB);
            break;

        case OP_DP4:
            binst = (Bin_Instruction *) inst;
            lDefMaskedDstReg(env, pLive, &binst->dst, 1);
            lRefSwizzleSrcReg(pLive, DST_XYZW_BITS, &binst->srcA);
            lRefSwizzleSrcReg(pLive, DST_XYZW_BITS, &binst->srcB);
            break;

#if defined(NV_INTERNAL_OPCODES)
        case OP_DPH:
            binst = (Bin_Instruction *) inst;
            lDefMaskedDstReg(env, pLive, &binst->dst, 1);
            lRefSwizzleSrcReg(pLive, DST_XYZ_BITS, &binst->srcA);
            lRefSwizzleSrcReg(pLive, DST_XYZW_BITS, &binst->srcB);
            break;
#endif // NV_INTERNAL_OPCODES

        case OP_DST:
            binst = (Bin_Instruction *) inst;
            lDefMaskedDstReg(env, pLive, &binst->dst, 1);
            lRefSwizzleSrcReg(pLive, DST_Y_BIT | DST_Z_BIT, &binst->srcA);
            lRefSwizzleSrcReg(pLive, DST_Y_BIT | DST_W_BIT, &binst->srcB);
            break;

       // TRIops:

        case OP_MAD:
            tinst = (Tri_Instruction *) inst;
            lDefMaskedDstReg(env, pLive, &tinst->dst, 1);
            lRefSwizzleSrcReg(pLive, tinst->dst.mask, &tinst->srcA);
            lRefSwizzleSrcReg(pLive, tinst->dst.mask, &tinst->srcB);
            lRefSwizzleSrcReg(pLive, tinst->dst.mask, &tinst->srcC);
            break;

        // NOPops:

        case OP_NOP:
            break;

        // ENDops:

        case OP_END:
            break;

        default:
            break;
        }
    }
} // lInitTempLiveDead

/*
** lDestroyTempLiveDead()
*/

static void lDestroyTempLiveDead(VtxProgCompileKelvin *env)
{
    if (env->tLiveDead) {
        env->free(env->mallocArg, env->tLiveDead);
        env->tLiveDead = NULL;
    }
} // lDestroyTempLiveDead

/*
** lInsertTextureScaling() - Insert the required scaling instructions.
*/

static void lInsertTextureScaling(VtxProgCompileKelvin *env, Instruction *fInsts,
                                  Instruction *tInsts, int fNum, int tNum)
{
#if 000
    const static int swizzles[] = {
        XX | (XX << 2) | (XX << 4) | (XX << 6), // __GLNV20_TEX_SCALE_IDENTITY
        XX | (XX << 2) | (YY << 4) | (XX << 6), // __GLNV20_TEX_SCALE_R_65535
        XX | (XX << 2) | (ZZ << 4) | (XX << 6), // __GLNV20_TEX_SCALE_R_16777215
        YY | (YY << 2) | (YY << 4) | (XX << 6), // __GLNV20_TEX_SCALE_STR_65535
        ZZ | (ZZ << 2) | (ZZ << 4) | (XX << 6), // __GLNV20_TEX_SCALE_STR_16777215
    };
#endif
    const static int scalemasks[] = {
        0,              // __GLNV20_TEX_SCALE_IDENTITY
        DST_Z_BIT,      // __GLNV20_TEX_SCALE_R_65535
        DST_Z_BIT,      // __GLNV20_TEX_SCALE_R_16777215
        DST_XYZ_BITS,   // __GLNV20_TEX_SCALE_STR_65535
        DST_XYZ_BITS,   // __GLNV20_TEX_SCALE_STR_16777215
    };
    const static int constreg[] = {
        0,        // __GLNV20_TEX_SCALE_IDENTITY
        PPR_58,   // __GLNV20_TEX_SCALE_R_65535
        PPR_59,   // __GLNV20_TEX_SCALE_R_16777215
        PPR_58,   // __GLNV20_TEX_SCALE_STR_65535
        PPR_59,   // __GLNV20_TEX_SCALE_STR_16777215
    };
    Instruction *frinst, *toinst;
    int fpc, tpc, tregno, texno, scaleinx, dstmask, count = 0;
    MaskedDstReg *dst;
    Scalar_Instruction *sinst;
    Vector_Instruction *vinst;
    Bin_Instruction *binst;
    Tri_Instruction *tinst;

    for (fpc = tpc = 0; fpc < fNum; fpc++, tpc++) {
        frinst = &fInsts[fpc];
        toinst = &tInsts[tpc];
        *toinst = *frinst;
        if (env->tLiveDead[fpc].tmpReg) {
            switch (frinst->bin_op.opclass) {
            case CLASS_VECTOR:
                vinst = (Vector_Instruction *) toinst;
                dst = &vinst->dst;
                break;
            case CLASS_SCALAR:
                sinst = (Scalar_Instruction *) toinst;
                dst = &sinst->dst;
                break;
            case CLASS_BIN:
                binst = (Bin_Instruction *) toinst;
                dst = &binst->dst;
                break;
            case CLASS_TRI:
                tinst = (Tri_Instruction *) toinst;
                dst = &tinst->dst;
                break;
            case CLASS_END:
            case CLASS_ARL:
            case CLASS_NOP:
            default:
                assert(0);
                continue;
            }
            texno = dst->reg - VR_TEX0;
            dstmask = dst->mask;
            tregno = env->tLiveDead[fpc].tmpReg & 0xf;
            scaleinx = (env->textureScaling >> (texno*__GLNV20_TEX_SCALE_FIELD_BITS)) &
                         __GLNV20_TEX_SCALE_MASK;
            // Patch old instruction to write to scratch register:

            dst->reg = (Register_t) (TR_0 + tregno);

#if 000
            // Build new instruction to scale temp value into final destination:
            // MUL o[TEXi].mask, Rtmp, c[23];  // c[23] = 1.0, 65535.0, 16777215.0

            count++;
            binst = (Bin_Instruction *) &tInsts[++tpc];
            binst->opclass = CLASS_BIN;
            binst->opcode = OP_MUL;
            binst->srcA.reg.reg = TR_0 + tregno;
            binst->srcA.reg.AddrReg = 0;
            binst->srcA.reg.addrRegOffset = 0;
            binst->srcA.com4 = XYZW;
            binst->srcA.Signed = 0;

            binst->srcB.reg.reg = PPR_23;
            binst->srcB.reg.AddrReg = 0;
            binst->srcB.reg.addrRegOffset = 0;
            binst->srcB.com4 = swizzles[scaleinx];
            binst->srcB.Signed = 0;

            binst->dst.reg = VR_TEX0 + texno;
            binst->dst.mask = dstmask;
#endif
            
            // Build two new instruction to scale temp value into final destination:
            // MUL o[TEXi].mask, Rtmp, c[58/59].w; // c[58].w = 65535, c[59].w = 16777215

            count++;
            binst = (Bin_Instruction *) &tInsts[++tpc];
            binst->opclass = CLASS_BIN;
            binst->opcode = OP_MUL;
            binst->srcA.reg.reg = (Register_t) (TR_0 + tregno);
            binst->srcA.reg.AddrReg = 0;
            binst->srcA.reg.addrRegOffset = 0;
            binst->srcA.com4 = XYZW;
            binst->srcA.Signed = 0;

            binst->srcB.reg.reg = (Register_t) constreg[scaleinx];
            binst->srcB.reg.AddrReg = 0;
            binst->srcB.reg.addrRegOffset = 0;
            binst->srcB.com4 = (WW | WW << 2 | WW << 4 | WW << 6);
            binst->srcB.Signed = 0;

            binst->dst.reg = (Register_t) (VR_TEX0 + texno);
            binst->dst.mask = dstmask & scalemasks[scaleinx];

            // MOV o[TEXi].mask, Rtmp;

            count++;
            vinst = (Vector_Instruction *) &tInsts[++tpc];
            vinst->opclass = CLASS_VECTOR;
            vinst->opcode = OP_MOV;
            vinst->src.reg.reg = (Register_t) (TR_0 + tregno);
            vinst->src.reg.AddrReg = 0;
            vinst->src.reg.addrRegOffset = 0;
            vinst->src.com4 = XYZW;
            vinst->src.Signed = 0;

            vinst->dst.reg = (Register_t) (VR_TEX0 + texno);
            vinst->dst.mask = dstmask & ~scalemasks[scaleinx];

            NV_TRACE(TR_PROGRAM, 50, ("Inserting texture scaling instruction(s) at: %03x\n", fpc));
        }
    }
    assert(count == env->numExtraInstructions);
} // lInsertTextureScaling

///////////////////////////////////////////////////////////////////////////////

/*
** lGenSrcReg()
*/

static void lGenSrcReg(VtxProgCompileKelvin *env, vtxpgmInst *pInst, SwizzleSrcReg20 *r, SrcReg *reg)
{
    int lreg = reg->reg;

    switch (lreg) {
    case VA_0:  case VA_1:  case VA_2:  case VA_3:
    case VA_4:  case VA_5:  case VA_6:  case VA_7:
    case VA_8:  case VA_9:  case VA_10: case VA_11:
    case VA_12: case VA_13: case VA_14: case VA_15:
        r->mx = IN_MUX_VA;
        pInst->va = (unsigned char) env->inputRegMap[lreg - VA_0];
        NV_TRACE(TR_PROGRAM, 50, ("v[%i]", pInst->va));
        break;
    case PR_0:  case PR_1:  case PR_2:  case PR_3:
    case PR_4:  case PR_5:  case PR_6:  case PR_7:
    case PR_8:  case PR_9:  case PR_10: case PR_11:
    case PR_12: case PR_13: case PR_14: case PR_15:
    case PR_16: case PR_17: case PR_18: case PR_19:
    case PR_20: case PR_21: case PR_22: case PR_23:
    case PR_24: case PR_25: case PR_26: case PR_27:
    case PR_28: case PR_29: case PR_30: case PR_31:
    case PR_32: case PR_33: case PR_34: case PR_35:
    case PR_36: case PR_37: case PR_38: case PR_39:
    case PR_40: case PR_41: case PR_42: case PR_43:
    case PR_44: case PR_45: case PR_46: case PR_47:
    case PR_48: case PR_49: case PR_50: case PR_51:
    case PR_52: case PR_53: case PR_54: case PR_55:
    case PR_56: case PR_57: case PR_58: case PR_59:
    case PR_60: case PR_61: case PR_62: case PR_63:
    case PR_64: case PR_65: case PR_66: case PR_67:
    case PR_68: case PR_69: case PR_70: case PR_71:
    case PR_72: case PR_73: case PR_74: case PR_75:
    case PR_76: case PR_77: case PR_78: case PR_79:
    case PR_80: case PR_81: case PR_82: case PR_83:
    case PR_84: case PR_85: case PR_86: case PR_87:
    case PR_88: case PR_89: case PR_90: case PR_91:
    case PR_92: case PR_93: case PR_94: case PR_95:
        if (reg->AddrReg) {
            r->mx = IN_MUX_CA;
            pInst->ca = (unsigned char) reg->addrRegOffset;
            if (env->userMode)
                pInst->ca += 96;
            pInst->cin = 1;
            NV_TRACE(TR_PROGRAM, 50, ("c[A0.x+%i]", pInst->ca));
        } else {
            r->mx = IN_MUX_CA;
            pInst->ca = lreg - PR_0;
            if (env->userMode)
                pInst->ca += 96;
            NV_TRACE(TR_PROGRAM, 50, ("c[%i]", pInst->ca));
        }
        break;
    case PPR_23:
    case PPR_58:
    case PPR_59:
    case PPR_62:
        // Special hook into priveledged (lower 96) registers:
        if (reg->AddrReg) {
            r->mx = IN_MUX_CA;
            pInst->ca = (unsigned char) reg->addrRegOffset;
            pInst->cin = 1;
            NV_TRACE(TR_PROGRAM, 50, ("ppr[A0.x+%i]", pInst->ca));
        } else {
            r->mx = IN_MUX_CA;
            pInst->ca = lreg - PPR_0;
            NV_TRACE(TR_PROGRAM, 50, ("ppr[%i]", pInst->ca));
        }
        break;
    case TR_0:  case TR_1:  case TR_2:  case TR_3:
    case TR_4:  case TR_5:  case TR_6:  case TR_7:
    case TR_8:  case TR_9:  case TR_10: case TR_11:
    case TR_12: case TR_13: case TR_14: case TR_15:
        r->mx = IN_MUX_RR;
        r->rr = lreg - TR_0;
        NV_TRACE(TR_PROGRAM, 50, ("R%i", r->rr));
        break;
    default:
        assert(!"lGenSrcReg() - Bad register number");
        NV_TRACE(TR_PROGRAM, 50, ("BAD-REG!"));
        break;
    }
} // lGenSrcReg

////////////////////////// NV20 Level Code Generation /////////////////////////

/*
** lGenScalarSrcReg()
*/
char *TEXT_XYZW = "xyzw";

static void lGenScalarSrcReg(VtxProgCompileKelvin *env, vtxpgmInst *pInst, SwizzleSrcReg20 *r, ScalarSrcReg *reg)
{
    // ???? Is there anything special about ScalarSrcReg?  ???? //
    // ???? I swizzled the input to all inputs;  I don't know if that's right/wrong/doesn't-matter ???? //
    NV_TRACE(TR_PROGRAM, 50, (", %s", reg->Signed ? "-" : ""));
    lGenSrcReg(env, pInst, r, &reg->reg);
    r->ne = reg->Signed;
    r->xs = reg->com;
    r->ys = reg->com;
    r->zs = reg->com;
    r->ws = reg->com;
    NV_TRACE(TR_PROGRAM, 50, (".%c", TEXT_XYZW[reg->com]));
} // lGenScalarSrcReg

/*
** lGenSwizzleSrcReg()
*/

static void lGenSwizzleSrcReg(VtxProgCompileKelvin *env, vtxpgmInst *pInst, SwizzleSrcReg20 *r, SwizzleSrcReg *reg)
{
    NV_TRACE(TR_PROGRAM, 50, (", %s", reg->Signed ? "-" : ""));
    lGenSrcReg(env, pInst, r, &reg->reg);
    r->ne = reg->Signed;
    r->xs = reg->com4 & 0x03;
    r->ys = (reg->com4 & 0x0c) >> 2;
    r->zs = (reg->com4 & 0x30) >> 4;
    r->ws = (reg->com4 & 0xc0) >> 6;
    NV_TRACE_COND(TR_PROGRAM, 50,
        if (reg->com4 != XYZW) {
            NV_TRACE(TR_PROGRAM, 50, (".%c", TEXT_XYZW[r->xs]));
            NV_TRACE(TR_PROGRAM, 50, ("%c", TEXT_XYZW[r->ys]));
            NV_TRACE(TR_PROGRAM, 50, ("%c", TEXT_XYZW[r->zs]));
            NV_TRACE(TR_PROGRAM, 50, ("%c", TEXT_XYZW[r->ws]));
        }
    )
} // lGenSwizzleSrcReg

/*
**
*/

static unsigned char lMakeWriteMask(int fval)
{
    unsigned char result = 0;

    if (fval & DST_X_BIT)
        result |= OUT_MASK_X;
    if (fval & DST_Y_BIT)
        result |= OUT_MASK_Y;
    if (fval & DST_Z_BIT)
        result |= OUT_MASK_Z;
    if (fval & DST_W_BIT)
        result |= OUT_MASK_W;
    return result;
} // lMakeWriteMask

/*
** lGenMaskedDstILU() - Store the masked output of the ILU in "reg".
*/

static void lGenMaskedDstILU(VtxProgCompileKelvin *env, vtxpgmInst *pInst, MaskedDstReg *reg)
{
    NV_TRACE_CODE(int mask);

    if (reg->reg >= TR_0 && reg->reg <= TR_15) {
        // Target is a scratch register.  Use swm:
        pInst->swm = lMakeWriteMask(reg->mask);
        pInst->rw = reg->reg - TR_0;
        NV_TRACE(TR_PROGRAM, 50, ("R%i", pInst->rw));
        NV_TRACE_CODE(mask = pInst->swm);
    } else {
        // Target is a context or output register.  Use owm:
        pInst->om = OUT_MUX_OM_ILU;
        pInst->owm = lMakeWriteMask(reg->mask);
        if (reg->reg >= PR_0 && reg->reg <= PR_95) {
            pInst->oc = (reg->reg - PR_0) | OC_SELECT_CONTEXT;
            if (env->userMode)
                pInst->oc += 96;
            NV_TRACE(TR_PROGRAM, 50, ("c[%i]", pInst->oc & 0x0ff));
        } else {
            assert(reg->reg >= VR_0 && reg->reg <= VR_15);
            pInst->oc = env->outputRegMap[(reg->reg - VR_0)] | OC_SELECT_OUTPUT;
            NV_TRACE(TR_PROGRAM, 50, ("o[%i]", pInst->oc & 0x0ff));
        }
        NV_TRACE_CODE(mask = pInst->owm);
    }
    NV_TRACE_COND(TR_PROGRAM, 50,
        if (mask != OUT_MASK_XYZW) {
            TPRINTF(("."));
            if (mask & OUT_MASK_X)
                TPRINTF(("x"));
            if (mask & OUT_MASK_Y)
                TPRINTF(("y"));
            if (mask & OUT_MASK_Z)
                TPRINTF(("z"));
            if (mask & OUT_MASK_W)
                TPRINTF(("w"));
        }
    );
} // lGenMaskedDstILU

/*
** lGenMaskedDstALU() - Store the masked output of the ALU in "reg".
*/

static void lGenMaskedDstALU(VtxProgCompileKelvin *env, vtxpgmInst *pInst, MaskedDstReg *reg)
{
    NV_TRACE_CODE(int mask);

    if (reg->reg >= TR_0 && reg->reg <= TR_15) {
        // Target is a scratch register.  Use rwm:
        pInst->rwm = lMakeWriteMask(reg->mask);
        pInst->rw = reg->reg - TR_0;
        NV_TRACE(TR_PROGRAM, 50, ("R%i", pInst->rw));
        NV_TRACE_CODE(mask = pInst->rwm);
    } else {
        // Target is a context or output register.  Use owm:
        pInst->om = OUT_MUX_OM_ALU;
        pInst->owm = lMakeWriteMask(reg->mask);
        if (reg->reg >= PR_0 && reg->reg <= PR_95) {
            pInst->oc = (reg->reg - PR_0) | OC_SELECT_CONTEXT;
            if (env->userMode)
                pInst->oc += 96;
            NV_TRACE(TR_PROGRAM, 50, ("c[%i]", pInst->oc & 0x0ff));
        } else {
            assert(reg->reg >= VR_0 && reg->reg <= VR_15);
            pInst->oc = env->outputRegMap[(reg->reg - VR_0)] | OC_SELECT_OUTPUT;
            NV_TRACE(TR_PROGRAM, 50, ("o[%i]", pInst->oc & 0x0ff));
        }
        NV_TRACE_CODE(mask = pInst->owm);
    }
    NV_TRACE_COND(TR_PROGRAM, 50,
        if (mask != OUT_MASK_XYZW) {
            TPRINTF(("."));
            if (mask & OUT_MASK_X)
                TPRINTF(("x"));
            if (mask & OUT_MASK_Y)
                TPRINTF(("y"));
            if (mask & OUT_MASK_Z)
                TPRINTF(("z"));
            if (mask & OUT_MASK_W)
                TPRINTF(("w"));
        }
    );
} // lGenMaskedDstALU

/*
** lAppendViewportXform(pCode, &pc);
*/

static void lAppendViewportXform(VtxProgCompileKelvin *env, vtxpgmInst *pCode, int *ppc)
{
    vtxpgmInst *curInst;
    int pc = *ppc;
    SwizzleSrcReg srcA, srcB, srcC;
    ScalarSrcReg src;
    MaskedDstReg dst;

    NV_TRACE(TR_PROGRAM, 50, ("--- Viewport Xform ---\n"));

    env->userMode = 0;

    curInst = &pCode[pc - 1];
    curInst->eos = 0;

    if (env->passthroughMode) {
        // If this vertex program is the passthrough vertex program, then
        // only apply the zscale and viewport offset.  Do not apply W-divide
        // since the vertices will already be in screen coordinates.

        // MUL o[HPOS].xyz, R12, c[58];
        srcA.reg.reg = TR_12;
        srcA.reg.AddrReg = FALSE;
        srcA.reg.addrRegOffset = 0;
        srcA.com4 = XYZW;
        srcA.Signed = 0;

        srcB.reg.reg = PPR_58;
        srcB.reg.AddrReg = FALSE;
        srcB.reg.addrRegOffset = 0;
        srcB.com4 = XYZW;
        srcB.Signed = 0;

        dst.reg = VR_HPOS;
        dst.mask = DST_XYZ_BITS;

        curInst = &pCode[pc];
        NV_TRACE(TR_PROGRAM, 50, ("%03x:  MUL ", pc));
        curInst->mac = MAC_MUL;
        lGenMaskedDstALU(env, curInst, &dst);
        lGenSwizzleSrcReg(env, curInst, &curInst->a, &srcA);
        lGenSwizzleSrcReg(env, curInst, &curInst->b, &srcB);
        NV_TRACE(TR_PROGRAM, 50, ("\n"));
        pc++;

        // ADD o[HPOS].xyz, R12, c[59]
        srcA.reg.reg = TR_12;
        srcA.reg.AddrReg = FALSE;
        srcA.reg.addrRegOffset = 0;
        srcA.com4 = XYZW;
        srcA.Signed = 0;

        srcC.reg.reg = PPR_59;
        srcC.reg.AddrReg = FALSE;
        srcC.reg.addrRegOffset = 0;
        srcC.com4 = XYZW;
        srcC.Signed = 0;

        dst.reg = VR_HPOS;
        dst.mask = DST_XYZ_BITS;

        curInst = &pCode[pc];
        NV_TRACE(TR_PROGRAM, 50, ("%03x:  ADD ", pc));
        curInst->mac = MAC_ADD;
        lGenMaskedDstALU(env, curInst, &dst);
        lGenSwizzleSrcReg(env, curInst, &curInst->a, &srcA);
        lGenSwizzleSrcReg(env, curInst, &curInst->c, &srcC);
        curInst->eos = 1;
        NV_TRACE(TR_PROGRAM, 50, ("\n"));
        pc++;
/*
        // MAD o[HPOS].xyz, R12, c[58], c[59];

        srcA.reg.reg = TR_12;
        srcA.reg.AddrReg = FALSE;
        srcA.reg.addrRegOffset = 0;
        srcA.com4 = XYZW;
        srcA.Signed = 0;

        srcB.reg.reg = PPR_58;
        srcB.reg.AddrReg = FALSE;
        srcB.reg.addrRegOffset = 0;
        srcB.com4 = XYZW;
        srcB.Signed = 0;

        srcC.reg.reg = PPR_59;
        srcC.reg.AddrReg = FALSE;
        srcC.reg.addrRegOffset = 0;
        srcC.com4 = XYZW;
        srcC.Signed = 0;

        dst.reg = VR_HPOS;
        dst.mask = DST_XYZ_BITS;

        curInst = &pCode[pc];
        NV_TRACE(TR_PROGRAM, 50, ("%03x:  MAD ", pc));
        curInst->mac = MAC_MAD;
        lGenMaskedDstALU(env, curInst, &dst);
        lGenSwizzleSrcReg(env, curInst, &curInst->a, &srcA);
        lGenSwizzleSrcReg(env, curInst, &curInst->b, &srcB);
        lGenSwizzleSrcReg(env, curInst, &curInst->c, &srcC);
        curInst->eos = 1;
        NV_TRACE(TR_PROGRAM, 50, ("\n"));
        pc++;
        */
    } else {
    // MUL R11.xyz, R12, c[58];

    srcA.reg.reg = TR_12;
    srcA.reg.AddrReg = FALSE;
    srcA.reg.addrRegOffset = 0;
    srcA.com4 = XYZW;
    srcA.Signed = 0;

    srcB.reg.reg = PPR_58;
    srcB.reg.AddrReg = FALSE;
    srcB.reg.addrRegOffset = 0;
    srcB.com4 = XYZW;
    srcB.Signed = 0;

    dst.reg = TR_11;
    dst.mask = DST_XYZ_BITS;

    curInst = &pCode[pc];
    NV_TRACE(TR_PROGRAM, 50, ("%03x:  MUL ", pc));
    curInst->mac = MAC_MUL;
    lGenMaskedDstALU(env, curInst, &dst);
    lGenSwizzleSrcReg(env, curInst, &curInst->a, &srcA);
    lGenSwizzleSrcReg(env, curInst, &curInst->b, &srcB);
    NV_TRACE(TR_PROGRAM, 50, ("\n"));
    pc++;

    // RCC R1, R12.w;  <<---<< Can be combined with previous instruction

    src.reg.reg = TR_12;
    src.reg.AddrReg = FALSE;
    src.reg.addrRegOffset = 0;
    src.com = WW;
    src.Signed = FALSE;

    dst.reg = TR_1;
    dst.mask = DST_XYZW_BITS;

    curInst = &pCode[pc];
    NV_TRACE(TR_PROGRAM, 50, ("%03x:  RCC ", pc));
    curInst->ilu = ILU_RCC;
    lGenMaskedDstILU(env, curInst, &dst);
    lGenScalarSrcReg(env, curInst, &curInst->c, &src);
    NV_TRACE(TR_PROGRAM, 50, ("\n"));
    pc++;

    // MAD o[HPOS].xyz, R1.w, R11, c[59];

    srcA.reg.reg = TR_1;
    srcA.reg.AddrReg = FALSE;
    srcA.reg.addrRegOffset = 0;
    srcA.com4 = WW | (WW << 2) | (WW << 4) | (WW << 6);
    srcA.Signed = 0;

    srcB.reg.reg = TR_11;
    srcB.reg.AddrReg = FALSE;
    srcB.reg.addrRegOffset = 0;
    srcB.com4 = XYZW;
    srcB.Signed = 0;

    srcC.reg.reg = PPR_59;
    srcC.reg.AddrReg = FALSE;
    srcC.reg.addrRegOffset = 0;
    srcC.com4 = XYZW;
    srcC.Signed = 0;

    dst.reg = VR_HPOS;
    dst.mask = DST_XYZ_BITS;

    curInst = &pCode[pc];
    NV_TRACE(TR_PROGRAM, 50, ("%03x:  MAD ", pc));
    curInst->mac = MAC_MAD;
    lGenMaskedDstALU(env, curInst, &dst);
    lGenSwizzleSrcReg(env, curInst, &curInst->a, &srcA);
    lGenSwizzleSrcReg(env, curInst, &curInst->b, &srcB);
    lGenSwizzleSrcReg(env, curInst, &curInst->c, &srcC);
    curInst->eos = 1;
    NV_TRACE(TR_PROGRAM, 50, ("\n"));
    pc++;
    }
    *ppc = pc;
} // lApendViewportXform

/*
** lPackCode() - Pack instruction fields into NV20 microcode format.
*/

static void lPackCode(vtxpgmInstPacked *theCode, vtxpgmInst *pCode, int pc)
{
    int ii;

    for (ii = 0; ii < pc; ii++) {
        theCode->x = 0;
        theCode->y = (pCode->ilu  << 25) |
                     (pCode->mac  << 21) |
                     (pCode->ca   << 13) |
                     (pCode->va   <<  9) |
                     (pCode->a.ne <<  8) |
                     (pCode->a.xs <<  6) |
                     (pCode->a.ys <<  4) |
                     (pCode->a.zs <<  2) |
                     (pCode->a.ws <<  0);
        theCode->z = (pCode->a.rr << 28) |
                     (pCode->a.mx << 26) |
                     (pCode->b.ne << 25) |
                     (pCode->b.xs << 23) |
                     (pCode->b.ys << 21) |
                     (pCode->b.zs << 19) |
                     (pCode->b.ws << 17) |
                     (pCode->b.rr << 13) |
                     (pCode->b.mx << 11) |
                     (pCode->c.ne << 10) |
                     (pCode->c.xs <<  8) |
                     (pCode->c.ys <<  6) |
                     (pCode->c.zs <<  4) |
                     (pCode->c.ws <<  2) |
                     (pCode->c.rr >>  2);
        theCode->w = (pCode->c.rr << 30) |
                     (pCode->c.mx << 28) |
                     (pCode->rwm  << 24) |
                     (pCode->rw   << 20) |
                     (pCode->swm  << 16) |
                     (pCode->owm  << 12) |
                     (pCode->oc   <<  3) |
                     (pCode->om   <<  2) |
                     (pCode->cin  <<  1) |
                     (pCode->eos  <<  0);
        NV_TRACE_COND(TR_PROGRAM, 50,
            if (!(ii & 0x1f)) {
                TPRINTF(("\n"));
                TPRINTF(("                                "));
                TPRINTF(("-I M       N              N              N              R   S O       C E\n"));
                TPRINTF(("                                "));
                TPRINTF(("-L A -C V  E X Y Z W R M  E X Y Z W R M  E X Y Z W R M  W R W W -O- O I O\n"));
                TPRINTF(("                                "));
                TPRINTF(("-U C -A A  G S S S S R X  G S S S S R X  G S S S S R X  M W M M -C- M N S\n"));
            }
        );
        NV_TRACE(TR_PROGRAM, 50, ("%02x: %08x %08x %08x: ",
                                  ii, theCode->y, theCode->z, theCode->w));
        NV_TRACE(TR_PROGRAM, 50, ("%02x %01x %02x %01x",
                                  (theCode->y >> 25) & 0x7f,
                                  (theCode->y >> 21) & 0xf,
                                  (theCode->y >> 13) & 0xff,
                                  (theCode->y >> 9) & 0xf
                                  ));
        NV_TRACE(TR_PROGRAM, 50, ("  %01x %01x %01x %01x %01x %01x %01x",
                                  (theCode->y >> 8) & 0x1,
                                  (theCode->y >> 6) & 0x3,
                                  (theCode->y >> 4) & 0x3,
                                  (theCode->y >> 2) & 0x3,
                                  (theCode->y >> 0) & 0x3,
                                  (theCode->z >> 28) & 0xf,
                                  (theCode->z >> 26) & 0x3
                                  ));
        NV_TRACE(TR_PROGRAM, 50, ("  %01x %01x %01x %01x %01x %01x %01x",
                                  (theCode->z >> 25) & 0x1,
                                  (theCode->z >> 23) & 0x3,
                                  (theCode->z >> 21) & 0x3,
                                  (theCode->z >> 19) & 0x3,
                                  (theCode->z >> 17) & 0x3,
                                  (theCode->z >> 13) & 0xf,
                                  (theCode->z >> 11) & 0x3
                                  ));
        NV_TRACE(TR_PROGRAM, 50, ("  %01x %01x %01x %01x %01x %01x %01x",
                                  (theCode->z >> 10) & 0x1,
                                  (theCode->z >> 8) & 0x3,
                                  (theCode->z >> 6) & 0x3,
                                  (theCode->z >> 4) & 0x3,
                                  (theCode->z >> 2) & 0x3,
                                  ((theCode->z << 2) | ((theCode->w >> 30) & 0x3)) & 0xf,
                                  (theCode->w >> 28) & 0x3
                                  ));
        NV_TRACE(TR_PROGRAM, 50, ("  %01x %01x %01x %01x %03x %01x %01x %01x",
                                  (theCode->w >> 24) & 0xf,
                                  (theCode->w >> 20) & 0xf,
                                  (theCode->w >> 16) & 0xf,
                                  (theCode->w >> 12) & 0xf,
                                  (theCode->w >> 3) & 0x1ff,
                                  (theCode->w >> 2) & 0x1,
                                  (theCode->w >> 1) & 0x1,
                                  (theCode->w >> 0) & 0x1
                                  ));
        NV_TRACE(TR_PROGRAM, 50, ("\n"));
        pCode++;
        theCode++;
    }
    NV_TRACE(TR_PROGRAM, 50, ("\n"));
} // lPackCode

/*
** vp_CompileKelvin() - Compile a vertex program into NV20 microcode.
*/

int vp_CompileKelvin(VtxProgCompileKelvin *env, ParsedProgram *fParsed,
                     int numInstructions, VertexProgramOutput *outArgs)
{
    NV_FUN_NAME(__glNV20MakeProgramResident, TR_PROGRAM, 20)
    vtxpgmInst *pCode, *curInst;
    vtxpgmInstPacked *theCode;
    Instruction *inst, *newinst;
    Arl_Instruction *ainst;
    Scalar_Instruction *sinst;
    Vector_Instruction *vinst;
    Bin_Instruction *binst;
    Tri_Instruction *tinst;
    int lop, lsize;
    int lNumInstructions;
    int pc, skipping, offset;

    NV_TRACE_FUNC(("ppi", env, fParsed, numInstructions));
    NV_TRACE_PUSH();

#if !defined(IS_OPENGL)
    env->textureScaling = __GLNV20_TEX_SCALE_IDENTITY;
    env->passthroughMode = 0;
#endif

    lInitTempLiveDead(env, fParsed, numInstructions);
    lNumInstructions = numInstructions + env->numExtraInstructions;
    if (env->numExtraInstructions > 0) {
        if (lNumInstructions > __GL_MAX_NUMBER_OF_INSTRUCTIONS) {
            // Too big!  Can't create program.
            assert(!"Program too big.  Can't add texture scaling instructions.");
            return FALSE;
        }
        newinst = (Instruction *) env->malloc(env->mallocArg,
                                                sizeof(Instruction)*(lNumInstructions));
        lInsertTextureScaling(env, fParsed->firstInstruction, newinst, numInstructions, lNumInstructions);
    } else {
        newinst = NULL;
    }

    pCode = (vtxpgmInst *) env->malloc(env->mallocArg,
                sizeof(vtxpgmInst)*(__GL_MAX_NUMBER_OF_INSTRUCTIONS + 3));
    if (!pCode) {
        NV_TRACE_POP();
        return FALSE;
    }

    // Initialize instructions:

    for (pc = 0; pc < (__GL_MAX_NUMBER_OF_INSTRUCTIONS + 3); pc++)
        lInitInst(&pCode[pc]);

    env->userMode = 1;

    offset = 0; skipping = 0;
    NV_TRACE(TR_PROGRAM, 50, ("\n"));
    inst = newinst ? newinst : fParsed->firstInstruction;
    for (pc = 0; pc < lNumInstructions; inst++, pc++) {

#if defined(ENABLE_TRACE_CODE)
        if (env->tLiveDead) {
            int ii;
            
            if (skipping) {
                NV_TRACE(TR_PROGRAM, 50, ("               "));
                skipping--;
                offset++;
            } else {
                for (ii = 0; ii < __GL_NUMBER_OF_TEMPORARY_REGISTERS; ii++) {
                    NV_TRACE(TR_PROGRAM, 50, ("%1x", env->tLiveDead[pc - offset].v[ii]));
                }
                if (env->tLiveDead[pc - offset].tmpReg) {
                    if (env->tLiveDead[pc - offset].tmpReg & ALU_TEMP) {
                        NV_TRACE(TR_PROGRAM, 50, ("A%1x ", env->tLiveDead[pc - offset].tmpReg & 0xf));
                    } else {
                        NV_TRACE(TR_PROGRAM, 50, ("I%1x ", env->tLiveDead[pc - offset].tmpReg & 0xf));
                    }
                    skipping = 2;
                } else {
                    NV_TRACE(TR_PROGRAM, 50, ("   "));
                }
            }
        }
#endif // defined(ENABLE_TRACE_CODE)

        curInst = &pCode[pc];
        lop = inst->end_op.opcode;
        switch (lop) {

        // ARL op:

        case OP_ARL:
            NV_TRACE(TR_PROGRAM, 50, ("%03x:  ARL ", pc));
            ainst = (Arl_Instruction *) inst;
            curInst->mac = MAC_ARL;
            NV_TRACE(TR_PROGRAM, 50, ("A0.x"));
            lGenScalarSrcReg(env, curInst, &curInst->a, &ainst->src);
            break;

        // SCALAR ops:

        case OP_EXP:
            NV_TRACE(TR_PROGRAM, 50, ("%03x:  EXP ", pc));
            sinst = (Scalar_Instruction *) inst;
            curInst->ilu = ILU_EXP;
            lGenMaskedDstILU(env, curInst, &sinst->dst);
            lGenScalarSrcReg(env, curInst, &curInst->c, &sinst->src);
            break;

        case OP_LOG:
            NV_TRACE(TR_PROGRAM, 50, ("%03x:  LOG ", pc));
            sinst = (Scalar_Instruction *) inst;
            curInst->ilu = ILU_LOG;
            lGenMaskedDstILU(env, curInst, &sinst->dst);
            lGenScalarSrcReg(env, curInst, &curInst->c, &sinst->src);
            break;

#if defined(NV_INTERNAL_OPCODES)
        case OP_RCC:
            NV_TRACE(TR_PROGRAM, 50, ("%03x:  RCC ", pc));
            sinst = (Scalar_Instruction *) inst;
            curInst->ilu = ILU_RCC;
            lGenMaskedDstILU(env, curInst, &sinst->dst);
            lGenScalarSrcReg(env, curInst, &curInst->c, &sinst->src);
            break;
#endif // NV_INTERNAL_OPCODES

        case OP_RCP:
            NV_TRACE(TR_PROGRAM, 50, ("%03x:  RCP ", pc));
            sinst = (Scalar_Instruction *) inst;
            curInst->ilu = ILU_RCP;
            lGenMaskedDstILU(env, curInst, &sinst->dst);
            lGenScalarSrcReg(env, curInst, &curInst->c, &sinst->src);
            break;

        case OP_RSQ:
            NV_TRACE(TR_PROGRAM, 50, ("%03x:  RSQ ", pc));
            sinst = (Scalar_Instruction *) inst;
            curInst->ilu = ILU_RSQ;
            lGenMaskedDstILU(env, curInst, &sinst->dst);
            lGenScalarSrcReg(env, curInst, &curInst->c, &sinst->src);
            break;

        // VECTOR ops:

        case OP_LIT:
            NV_TRACE(TR_PROGRAM, 50, ("%03x:  LIT ", pc));
            vinst = (Vector_Instruction *) inst;
            curInst->ilu = ILU_LIT;
            lGenMaskedDstILU(env, curInst, &vinst->dst);
            lGenSwizzleSrcReg/*lGenSwizzleSrcILU*/(env, curInst, &curInst->c, &vinst->src);
            break;

#if defined(NV_INTERNAL_OPCODES)
        case OP_IMV:
            NV_TRACE(TR_PROGRAM, 50, ("%03x:  IMV ", pc));
            vinst = (Vector_Instruction *) inst;
            curInst->ilu = ILU_MOV; // ???? Is there a separate ILU_IMV instruction? ???
            lGenMaskedDstILU(env, curInst, &vinst->dst);
            lGenSwizzleSrcReg/*lGenSwizzleSrcILU*/(env, curInst, &curInst->c, &vinst->src);
            break;
#endif // NV_INTERNAL_OPCODES

        case OP_MOV:
            NV_TRACE(TR_PROGRAM, 50, ("%03x:  MOV ", pc));
            vinst = (Vector_Instruction *) inst;
            curInst->ilu = ILU_MOV;
            lGenMaskedDstILU(env, curInst, &vinst->dst);
            lGenSwizzleSrcReg/*lGenSwizzleSrcILU*/(env, curInst, &curInst->c, &vinst->src);
            break;

        // BIN ops:

        case OP_ADD:
            NV_TRACE(TR_PROGRAM, 50, ("%03x:  ADD ", pc));
            binst = (Bin_Instruction *) inst;
            curInst->mac = MAC_ADD;
            lGenMaskedDstALU(env, curInst, &binst->dst);
            lGenSwizzleSrcReg(env, curInst, &curInst->a, &binst->srcA);
            lGenSwizzleSrcReg(env, curInst, &curInst->c, &binst->srcB);
            break;

        case OP_DP3:
            NV_TRACE(TR_PROGRAM, 50, ("%03x:  DP3 ", pc));
            binst = (Bin_Instruction *) inst;
            curInst->mac = MAC_DP3;
            lGenMaskedDstALU(env, curInst, &binst->dst);
            lGenSwizzleSrcReg(env, curInst, &curInst->a, &binst->srcA);
            lGenSwizzleSrcReg(env, curInst, &curInst->b, &binst->srcB);
            break;

        case OP_DP4:
            NV_TRACE(TR_PROGRAM, 50, ("%03x:  DP4 ", pc));
            binst = (Bin_Instruction *) inst;
            curInst->mac = MAC_DP4;
            lGenMaskedDstALU(env, curInst, &binst->dst);
            lGenSwizzleSrcReg(env, curInst, &curInst->a, &binst->srcA);
            lGenSwizzleSrcReg(env, curInst, &curInst->b, &binst->srcB);
            break;

#if defined(NV_INTERNAL_OPCODES)
        case OP_DPH:
            NV_TRACE(TR_PROGRAM, 50, ("%03x:  DPH ", pc));
            binst = (Bin_Instruction *) inst;
            curInst->mac = MAC_DPH;
            lGenMaskedDstALU(env, curInst, &binst->dst);
            lGenSwizzleSrcReg(env, curInst, &curInst->a, &binst->srcA);
            lGenSwizzleSrcReg(env, curInst, &curInst->b, &binst->srcB);
            break;
#endif // NV_INTERNAL_OPCODES

        case OP_DST:
            NV_TRACE(TR_PROGRAM, 50, ("%03x:  DST ", pc));
            binst = (Bin_Instruction *) inst;
            curInst->mac = MAC_DST;
            lGenMaskedDstALU(env, curInst, &binst->dst);
            lGenSwizzleSrcReg(env, curInst, &curInst->a, &binst->srcA);
            lGenSwizzleSrcReg(env, curInst, &curInst->b, &binst->srcB);
            break;

        case OP_MAX:
            NV_TRACE(TR_PROGRAM, 50, ("%03x:  MAX ", pc));
            binst = (Bin_Instruction *) inst;
            curInst->mac = MAC_MAX;
            lGenMaskedDstALU(env, curInst, &binst->dst);
            lGenSwizzleSrcReg(env, curInst, &curInst->a, &binst->srcA);
            lGenSwizzleSrcReg(env, curInst, &curInst->b, &binst->srcB);
            break;

        case OP_MIN:
            NV_TRACE(TR_PROGRAM, 50, ("%03x:  MIN ", pc));
            binst = (Bin_Instruction *) inst;
            curInst->mac = MAC_MIN;
            lGenMaskedDstALU(env, curInst, &binst->dst);
            lGenSwizzleSrcReg(env, curInst, &curInst->a, &binst->srcA);
            lGenSwizzleSrcReg(env, curInst, &curInst->b, &binst->srcB);
            break;

        case OP_MUL:
            NV_TRACE(TR_PROGRAM, 50, ("%03x:  MUL ", pc));
            binst = (Bin_Instruction *) inst;
            curInst->mac = MAC_MUL;
            lGenMaskedDstALU(env, curInst, &binst->dst);
            lGenSwizzleSrcReg(env, curInst, &curInst->a, &binst->srcA);
            lGenSwizzleSrcReg(env, curInst, &curInst->b, &binst->srcB);
            break;

        case OP_SGE:
            NV_TRACE(TR_PROGRAM, 50, ("%03x:  SGE ", pc));
            binst = (Bin_Instruction *) inst;
            curInst->mac = MAC_SGE;
            lGenMaskedDstALU(env, curInst, &binst->dst);
            lGenSwizzleSrcReg(env, curInst, &curInst->a, &binst->srcA);
            lGenSwizzleSrcReg(env, curInst, &curInst->b, &binst->srcB);
            break;

        case OP_SLT:
            NV_TRACE(TR_PROGRAM, 50, ("%03x:  SLT ", pc));
            binst = (Bin_Instruction *) inst;
            curInst->mac = MAC_SLT;
            lGenMaskedDstALU(env, curInst, &binst->dst);
            lGenSwizzleSrcReg(env, curInst, &curInst->a, &binst->srcA);
            lGenSwizzleSrcReg(env, curInst, &curInst->b, &binst->srcB);
            break;

        // TRIops:

        case OP_MAD:
            NV_TRACE(TR_PROGRAM, 50, ("%03x:  MAD ", pc));
            tinst = (Tri_Instruction *) inst;
            curInst->mac = MAC_MAD;
            lGenMaskedDstALU(env, curInst, &tinst->dst);
            lGenSwizzleSrcReg(env, curInst, &curInst->a, &tinst->srcA);
            lGenSwizzleSrcReg(env, curInst, &curInst->b, &tinst->srcB);
            lGenSwizzleSrcReg(env, curInst, &curInst->c, &tinst->srcC);
            break;

        // ENDops:

        case OP_END:
            curInst = &pCode[pc - 1];
            curInst->eos = 1;
            break;

        default:
            break;
        }
        NV_TRACE(TR_PROGRAM, 50, ("\n"));
    }

    --pc;   // Don't need the last "end" instruction.

    // Append the viewport xfrom code:

    if (!fParsed->IsStateProgram)
        lAppendViewportXform(env, pCode, &pc);

    lsize = pc*sizeof(vtxpgmInstPacked);
    theCode = (vtxpgmInstPacked *) env->malloc(env->mallocArg, lsize);
    if (theCode) {
        lPackCode(theCode, pCode, pc);
        outArgs->residentProgram = theCode;
        outArgs->residentSize = lsize;
        outArgs->residentNumInstructions = pc;
    } else {
        outArgs->residentProgram = NULL;
        outArgs->residentSize = 0;
        outArgs->residentNumInstructions = 0;
    }

    env->free(env->mallocArg, pCode);
    if (newinst)
        env->free(env->mallocArg, newinst);

    NV_TRACE_POP();
    return TRUE;
} // vp_CompileKelvin
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\common\mac\utils\QD app\main.c ===
#include <Types.h>
#include <Quickdraw.h>
#include <Devices.h>
#include <Dialogs.h>
#include <Fonts.h>
#include <LowMem.h>
#include <Menus.h>
#include <QDOffscreen.h>
#include <Resources.h>
#include <Scrap.h>
#include <Sound.h>
#include <TextUtils.h>
#include <ToolUtils.h>
#include <Windows.h>

#include "debug.h"

#if DEBUG_BUILD

#define	kludgeKeyMap(i)		(*((/*volatile*/ unsigned long*) (0x174+(i*4))))
#define	OptionIsDown		((kludgeKeyMap(1)&0x0004)!=0)
#define	ShiftIsDown			((kludgeKeyMap(1)&0x0001)!=0)
#define	CapsLockIsDown		((kludgeKeyMap(1)&0x0002)!=0)
#define	ControlIsDown		((kludgeKeyMap(1)&0x0008)!=0)
#define	CmdIsDown			((kludgeKeyMap(1)&0x8000)!=0)

#endif

/* Miscellaneous definitions */

#define RECTINSET		48
#define RRECT_CURVATURE	50
#define ARC_STARTANGLE	135
#define ARC_DEGREES		90

#define DESTWIND_ID			128
#define SOURCEWIND_ID		129
#define STATUSWIND_ID		130
#define DESTWINDREFCON		DESTWIND_ID
#define SRCWINDREFCON		SOURCEWIND_ID
#define STATUSWINDREFCON	STATUSWIND_ID
#define ERRORALERT_ID		128
#define ABOUTDLOG_ID		129
#define BOUNDRECTDLOG_ID	130
#define OTHERRECTDLOG_ID	131
enum {
	OK_BRDITM=1,
	DEFLTBTN_BRDITM,
	TITLE_BRDITM,
	HORIZ_BRDITM,
	HTITLE_BRDITM,
	VERT_BRDITM,
	VTITLE_BRDITM
};

/* Error values, closely tied to application error string indices */
#define NONQDMISC_ERR			1

#define ERRORSTR_ID			128		// Error strings
#define NONQDMISC_NDX			NONQDMISC_ERR
#define CANTGETWIND_NDX			2
#define CANTGETMENU_NDX			3
#define CANTGETDLOG_NDX			4
#define CANTGETPICT_NDX			5
#define CANTGETCTABLE_NDX		6
#define CANTGETGWORLD_NDX		7
#define CANTGETREGION_NDX		8
#define CANTGETPIXPAT_NDX		9
#define CANTGETNVBOARD_NDX		10
#define NEEDMILLIONS_NDX		11
#define DESTNOTONNV_NDX			12

#define PARAMSTR_ID			130		// Parameterized strings
#define DESTLOC_NDX				1
#define SOURCELOC_NDX			2
#define WINDTITLE_NDX			3
#define UNNAMEDPICT_NDX			4
#define UNNAMEDPIXPAT_NDX		5
#define TIMING_NDX				6
#define ADDR_NDX				7

#define PICT_BASEID			128		// Base resource IDs for PICTs

/* Definitions for the main application menus */

#define APPLEMENU_ID		128
enum {
	ABOUT_ITEM = 1
};
static MenuHandle gAppleMenu;

#define FILEMENU_ID			129
enum {
	QUIT_ITEM = 1
};
static MenuHandle gFileMenu;

#define EDITMENU_ID			130
enum {
	UNDO_ITEM = 1,
	EDITSEP1_ITEM,
	CUT_ITEM,
	COPY_ITEM,
	PASTE_ITEM,
	CLEAR_ITEM
};
static MenuHandle gEditMenu;

#define TESTMENU_ID			131
enum {
	RUN_ITEM = 1,
	NOREFRESH_ITEM,
	NOCURSORHIDE_ITEM,
	TESTSEP1_ITEM,
	COPYBITS_ITEM,
	LINES_ITEM,
	TEXT_ITEM,
	FRAMESHAPE_ITEM,
	PAINTSHAPE_ITEM,
	ERASESHAPE_ITEM,
	INVERTSHAPE_ITEM,
	PATFILLSHAPE_ITEM,
	TESTSEP2_ITEM,
	RECTANGLE_ITEM,
	REGION_ITEM,
	OVAL_ITEM,
	ROUNDRECT_ITEM,
	ARC_ITEM,
	POLYGON_ITEM,
	TESTSEP3_ITEM,
	BOUNDRECT_ITEM,
	RGNSHAPE_ITEM
};
static MenuHandle gTestMenu;
static UInt8 gNoRefresh = false;
static UInt8 gNoCursorHide = false;
static UInt8 gTest = PAINTSHAPE_ITEM;
static UInt8 gShape = RECTANGLE_ITEM;

#define DESTMENU_ID			132
enum {
	DESTLOCATION_ITEM = 1,
	DESTDIM_ITEM,
	DESTIMAGE_ITEM,
	DESTDITHER_ITEM,
	DESTSEP1_ITEM,
	FGCOLOR_ITEM,
	BGCOLOR_ITEM,
	SWAPFGBG_ITEM,
	RESETCOLORS_ITEM,
	DESTSEP2_ITEM,
	PENSIZE_ITEM,
	PENMODE_ITEM,
	PENPATTERN_ITEM,
	BGPATTERN_ITEM,
	FILLPATTERN_ITEM,
	DESTSEP3_ITEM,
	USECLIPRGN_ITEM,
	CLIPRGN_ITEM
};
static MenuHandle gDestMenu;
static UInt8 gDitherDest = false;
static UInt8 gSwapFgBg = false;
static UInt8 gUseClipRgn = false;

#define COPYBITSMENU_ID		133
enum {
	USESEPSRC_ITEM = 1,
	SRCLOCATION_ITEM,
	SRCDIM_ITEM,
	SRCIMAGE_ITEM,
	SRCDITHER_ITEM,
	COPYBITSSEP1_ITEM,
	TRANSFERMODE_ITEM,
	SOURCERECT_ITEM,
	DESTRECT_ITEM,
	USEMASKRGN_ITEM,
	MASKRGN_ITEM
};
static MenuHandle gCopyBitsMenu;
static UInt8 gSepSrc = false;
static UInt8 gDitherSrc = false;
static UInt8 gUseMaskRgn = false;

#define LINESMENU_ID		134
enum {
	HORIZONTAL_ITEM = 1,
	VERTICAL_ITEM,
	DIAGONAL_ITEM,
	SLANTED_ITEM
};
static MenuHandle gLinesMenu;
static UInt8 gLines = HORIZONTAL_ITEM;

#define TEXTMENU_ID			135
enum {
	TEXTMODE_ITEM = 1,
	STRING_ITEM,
	TEXTSEP1_ITEM,
	FONT_ITEM,
	SIZE_ITEM
};
static MenuHandle gTextMenu;

#define EXPMENU_ID			136
enum {
	LUTDITHER_ITEM = 1,
	SPATIALDITHER_ITEM
};
static MenuHandle gExpMenu;

#define RGNSHAPEMENU_ID		140
// RgnShape, ClipRgn, and MaskRgn menus use identical items
enum {
	TRIOVALRGN_ITEM = 1,
	RRECTRGN_ITEM,
	RECTHOLERGN_ITEM,
	MEDRECTRGN_ITEM,
	SMALLRECTRGN_ITEM,
	EMPTYRGN_ITEM,
	NUM_REGIONS
};
static MenuHandle gRgnShapeMenu;
static UInt8 gRgnShape = TRIOVALRGN_ITEM;

#define CLIPRGNMENU_ID		141
// RgnShape, ClipRgn, and MaskRgn menus use identical items
static MenuHandle gClipRgnMenu;
static UInt8 gClipRgn = RRECTRGN_ITEM;

#define MASKRGNMENU_ID		142
// RgnShape, ClipRgn, and MaskRgn menus use identical items
static MenuHandle gMaskRgnMenu;
static UInt8 gMaskRgn = RECTHOLERGN_ITEM;

/* Definitions for the hierarchical menus */

#define DESTLOCMENU_ID		150
// DestLoc and SrcLoc menus use identical items
enum {
	WINDOW_ITEM = 1,
	OFFSCRN1BW_ITEM,
	OFFSCRN8G_ITEM,
	OFFSCRN8C_ITEM,
	OFFSCRN16C_ITEM,
	OFFSCRN24C_ITEM
};
static MenuHandle gDestLocMenu;
static UInt8 gDestLoc = WINDOW_ITEM;

#define DESTDIMMENU_ID		151
// DestDim and SrcDim menus use identical items
enum {
	DIM_512X384_ITEM = 1,
	DIM_600X450_ITEM,
	DIM_640X480_ITEM,
	DIM_1024X768_ITEM
};
static MenuHandle gDestDimMenu;
static UInt8 gDestDim = DIM_600X450_ITEM;

#define DESTIMAGEMENU_ID	152
// DestImage and SrcImage menus use identical items (from PICT resources)
static MenuHandle gDestImageMenu;
static UInt16 gDestImage = 1;	// First picture is default

#define FGCOLORMENU_ID		153
// FgColor and BgColor menus use identical items
enum {
	BLACK_ITEM = 1,
	WHITE_ITEM,
	RED_ITEM,
	GREEN_ITEM,
	BLUE_ITEM,
	CYAN_ITEM,
	MAGENTA_ITEM,
	YELLOW_ITEM,
	GRAY53_ITEM,
	HILITE_ITEM,
	RANDOM_ITEM,
	OTHERCOLOR_ITEM
};
static MenuHandle gFgColorMenu;
static UInt8 gFgColor = BLACK_ITEM;
static RGBColor gFgOtherRGB = { 0, 0, 0 };
static RGBColor gFgSaveRGB = { 0, 0, 0 };

#define BGCOLORMENU_ID		154
// FgColor and BgColor menus use identical items
static MenuHandle gBgColorMenu;
static UInt8 gBgColor = WHITE_ITEM;
static RGBColor gBgOtherRGB = { 0xFFFF, 0xFFFF, 0xFFFF };
static RGBColor gBgSaveRGB = { 0xFFFF, 0xFFFF, 0xFFFF };

#define PENSIZEMENU_ID		155
enum {
	PS_1X1_ITEM = 1,
	PS_2X2_ITEM,
	PS_4X4_ITEM,
	PS_8X8_ITEM,
	PS_16X16_ITEM,
	PS_OTHER_ITEM
};
static MenuHandle gPenSizeMenu;
static UInt8 gPenSize = PS_1X1_ITEM;

#define PENMODEMENU_ID		156
enum {
	PATCOPY_ITEM = 1,
	PATOR_ITEM,
	PATXOR_ITEM,
	PATBIC_ITEM,
	NOTPATCOPY_ITEM,
	NOTPATOR_ITEM,
	NOTPATXOR_ITEM,
	NOTPATBIC_ITEM,
	PATCOPYPLUSTRANSP_ITEM,
	PENMODESEP1_ITEM,
	PM_PLUSHILITE_ITEM
};
static MenuHandle gPenModeMenu;
static UInt8 gPenMode = PATCOPY_ITEM;
static UInt8 gPMPlusHilite = false;

#define PENPATMENU_ID		157
// PenPat, BgPat, and FillPat menus use identical items
enum {
	BLACKPAT_ITEM = 1,
	WHITEPAT_ITEM,
	GRAY50PAT_ITEM,
	LTGRAYPAT_ITEM,
	DKGRAYPAT_ITEM,
	HSTRIPESPAT_ITEM,
	VSTRIPESPAT_ITEM,
	DSTRIPESPAT_ITEM,
	NUMNIBBLESPAT_ITEM,
	PATSEP1_ITEM,
	FIRSTPIXPAT_ITEM
};
static MenuHandle gPenPatMenu;
static UInt8 gPenPat = BLACKPAT_ITEM;
static UInt8 gPixPat = FIRSTPIXPAT_ITEM;

#define BGPATMENU_ID		158
// PenPat, BgPat, and FillPat menus use identical items
static MenuHandle gBgPatMenu;
static UInt8 gBgPat = WHITEPAT_ITEM;

#define FILLPATMENU_ID		159
// PenPat, BgPat, and FillPat menus use identical items
static MenuHandle gFillPatMenu;
static UInt8 gFillPat = GRAY50PAT_ITEM;

#define SRCLOCMENU_ID		170
// DestLoc and SrcLoc menus use identical items
static MenuHandle gSrcLocMenu;
static UInt8 gSrcLoc = WINDOW_ITEM;

#define SRCDIMMENU_ID		171
// DestDim and SrcDim menus use identical items
static MenuHandle gSrcDimMenu;
static UInt8 gSrcDim = DIM_600X450_ITEM;

#define SRCIMAGEMENU_ID		172
// DestImage and SrcImage menus use identical items (from PICT resources)
static MenuHandle gSrcImageMenu;
static UInt16 gSrcImage = 2;	// First picture is default

#define XFERMODEMENU_ID		173
enum {
	X_SRCCOPY_ITEM = 1,
	X_SRCOR_ITEM,
	X_SRCXOR_ITEM,
	X_SRCBIC_ITEM,
	X_NOTSRCCOPY_ITEM,
	X_NOTSRCOR_ITEM,
	X_NOTSRCXOR_ITEM,
	X_NOTSRCBIC_ITEM,
	X_ADDOVER_ITEM,
	X_ADDPIN_ITEM,
	X_SUBOVER_ITEM,
	X_SUBPIN_ITEM,
	X_ADMAX_ITEM,
	X_ADMIN_ITEM,
	X_BLEND_ITEM,
	X_TRANSPARENT_ITEM,
	X_HILITE_ITEM,
	XFERMODESEP1_ITEM,
	X_PLUSDITHER_ITEM
};
static MenuHandle gXferModeMenu;
static UInt8 gXferMode = X_SRCCOPY_ITEM;
static UInt8 gXPlusDither = false;

#define SRCRECTMENU_ID		174
// SrcRect and DestRect menus use identical items
enum {
	TOP50_ITEM = 1,
	BOTTOM50_ITEM,
	LEFT50_ITEM,
	RIGHT50_ITEM,
	TOP99_ITEM,
	BOTTOM99_ITEM,
	LEFT99_ITEM,
	RIGHT99_ITEM,
	FULLSIZE_ITEM,
	OTHERRECT_ITEM
};
static MenuHandle gSrcRectMenu;
static UInt8 gSrcRect = TOP50_ITEM;
static Rect gSrcOtherRect = { 100, 100, 300, 300 };	// Should be safe

#define DESTRECTMENU_ID		175
static MenuHandle gDestRectMenu;
static UInt8 gDestRect = BOTTOM50_ITEM;
static Rect gDestOtherRect = { 100, 100, 300, 300 };	// Should be safe

#define TEXTMODEMENU_ID		190
enum {
	T_SRCCOPY_ITEM = 1,
	T_SRCOR_ITEM,
	T_SRCXOR_ITEM,
	T_SRCBIC_ITEM,
	T_NOTSRCCOPY_ITEM,
	T_NOTSRCOR_ITEM,
	T_NOTSRCXOR_ITEM,
	T_NOTSRCBIC_ITEM,
	T_ADDOVER_ITEM,
	T_ADDPIN_ITEM,
	T_SUBOVER_ITEM,
	T_SUBPIN_ITEM,
	T_ADMAX_ITEM,
	T_ADMIN_ITEM,
	T_BLEND_ITEM,
	T_TRANSPARENT_ITEM,
	T_GRAYISHTEXTOR_ITEM,
	TEXTMODESEP1_ITEM,
	T_PLUSHILITE_ITEM,
	T_PLUSMASK_ITEM
};
static MenuHandle gTextModeMenu;
static UInt8 gTextMode = T_SRCOR_ITEM;
static UInt8 gTPlusHilite = false;
static UInt8 gTPlusMask = false;


/* Miscellaneous definitions */

#define MAX_PIXPATS		40		/* Maximum number of PixPats we handle */
#define BEEPTICKS		3		/* Number of ticks for beep duration */
#define TESTTICKS		4*60	/* Number of ticks to run each test */

#define UNIMPTRAP		0xA89F
#define NQDMISCTRAP		0xABC3


/* Other global variables visible in this file only */

static UInt8 gQuitFlag = false;	// Set to true when the user wants to quit
static WindowPtr gDestWind;	// Pointer to destination window 
static GWorldPtr gDestPictBufGW = nil;	// Pointer to dest pict buffer GWorld
static GWorldPtr gDestGW = nil;	// Pointer to dest offscreen GWorld
static WindowPtr gSrcWind;	// Pointer to separate source window
static GWorldPtr gSrcPictBufGW = nil;	// Pointer to source pict buffer GWorld
static GWorldPtr gSrcGW = nil;	// Pointer to source offscreen GWorld
static WindowPtr gStatusWind;	// Pointer to Status window
static CTabHandle gCTab1BW;	// Handle to 1-bit black & white color table
static CTabHandle gCTab8G;	// Handle to 8-bit gray-scale color table
static CTabHandle gCTab8C;	// Handle to standard 8-bit color table
static UInt32 gLastTest = 0;	// Last test number that was run
static UInt32 gTestBeginTicks = 0;	// Tick count at beginning of a test
static UInt32 gTestEndTicks = 0;	// Tick count at end of a test
static UInt32 gTestIterations = 0;	// Number of times a test was performed
static UInt32 gTestDestAddr = 0;	// Address of 0,0 in destination memory
static UInt32 gTestSrcAddr = 0;	// Address of 0,0 in source memory
static UInt32 gBoundRectHInset = RECTINSET;	// Horizontal inset for shape bounding rect
static UInt32 gBoundRectVInset = RECTINSET;	// Vertical inset for shape bounding rect
static RgnHandle gRgnh[NUM_REGIONS];	// Handles to the various regions
static PixPatHandle gPixPath[MAX_PIXPATS];	// Handles to the PixPats

/* Procedures visible in this file only */
static void doeventloop(void);
static void updatedestwind(WindowPtr wind);
static SInt32 initdest(void);
static void cleanupdest(void);
static SInt32 initsource(void);
static void cleanupsrc(void);
static SInt32 initstatus(void);
static void cleanupstatus(void);
static SInt32 initregions(void);
static void setlocdimtitle(WindowPtr wind);
static SInt32 allocgworld(UInt32 item, Rect *rectp, GWorldPtr *gwpp);
static void rectitemtorect(UInt32 rectitem, Rect *inr, Rect *otherr, Rect *outr);
static void copyGWtoGW(GWorldPtr srcgwp, GWorldPtr destgwp, UInt32 dither);
static SInt32 drawpicttogworld(UInt32 pictitem, GWorldPtr gwp);
static void invalwind(WindowPtr wind);
static void dimtowh(UInt32 dimitem, UInt32 *widthp, UInt32 *heightp);
static void runtest(UInt32 test);
static void sint32todstr(SInt32 num, unsigned char *strp);
static void uint32todstr(UInt32 num, unsigned char *strp);
static void uint32tohstr(UInt32 num, unsigned char *strp);
static void paramstr(unsigned char *dest, SInt32 index, unsigned char *sub0, unsigned char *sub1,
						unsigned char *sub2, unsigned char *sub3);

static void erroralert(SInt32 strindex)
{
	unsigned char str[256];

	GetIndString(str, ERRORSTR_ID, strindex);
	ParamText(str, nil, nil, nil);
	NoteAlert(ERRORALERT_ID, nil);
}

static void keepwindowonmain(WindowPtr wind)
{
	SInt32 x, y, yextra;
	GrafPtr oldport;
	Point topleft, btmright;

#define EDGEFACTOR	2	// Leave this many pixels between screen edge & window frame
	GetPort(&oldport);
	SetPort(wind);
	topleft = *(Point *)&wind->portRect.top;
	btmright = *(Point *)&wind->portRect.bottom;
	LocalToGlobal(&topleft);
	LocalToGlobal(&btmright);
	SetPort(oldport);

	yextra = GetMBarHeight() + 20;	/* Menu bar height + title bar */
	x = topleft.h + EDGEFACTOR;
	if (btmright.h > qd.screenBits.bounds.right)
		x = qd.screenBits.bounds.right -
			(btmright.h - topleft.h) - EDGEFACTOR-2;
	if (topleft.h < qd.screenBits.bounds.left + EDGEFACTOR)
		x = qd.screenBits.bounds.left + EDGEFACTOR+1;
	y = topleft.v;
	if (btmright.v > qd.screenBits.bounds.bottom)
		y = qd.screenBits.bounds.bottom -
			(btmright.v - topleft.v) - EDGEFACTOR-2;
	if (topleft.v < qd.screenBits.bounds.top + yextra + EDGEFACTOR)
		y = qd.screenBits.bounds.top + yextra + EDGEFACTOR+1;
	if (x != topleft.h || y != topleft.v)
		MoveWindow(wind, x, y, false);
}

static SInt32 checkconfig(void)
{
	if (NGetTrapAddress(NQDMISCTRAP, ToolTrap) == NGetTrapAddress(UNIMPTRAP, ToolTrap))
		return(NONQDMISC_ERR);
	return(0);
}

static SInt32 setupmenus(void)
{
	SInt16 resID;
	SInt32 i, pictcount, pixpatcount;
	Handle h;
	ResType restype;
	unsigned char str[256], countstr[16];
	/* Set up the main menus */

	if ((gAppleMenu = GetMenu(APPLEMENU_ID)) == nil)
		return(CANTGETMENU_NDX);
	AppendResMenu(gAppleMenu, 'DRVR');	/* Add items to the Apple menu */
	InsertMenu(gAppleMenu, 0);

	if ((gFileMenu = GetMenu(FILEMENU_ID)) == nil)
		return(CANTGETMENU_NDX);
	InsertMenu(gFileMenu, 0);

	if ((gEditMenu = GetMenu(EDITMENU_ID)) == nil)
		return(CANTGETMENU_NDX);
	InsertMenu(gEditMenu, 0);

	if ((gTestMenu = GetMenu(TESTMENU_ID)) == nil)
		return(CANTGETMENU_NDX);
	InsertMenu(gTestMenu, 0);
	CheckItem(gTestMenu, NOREFRESH_ITEM, gNoRefresh);
	CheckItem(gTestMenu, NOCURSORHIDE_ITEM, gNoCursorHide);
	CheckItem(gTestMenu, gTest, true);
	CheckItem(gTestMenu, gShape, true);

	if ((gDestMenu = GetMenu(DESTMENU_ID)) == nil)
		return(CANTGETMENU_NDX);
	InsertMenu(gDestMenu, 0);
	CheckItem(gDestMenu, DESTDITHER_ITEM, gDitherDest);
	CheckItem(gDestMenu, SWAPFGBG_ITEM, gSwapFgBg);
	CheckItem(gDestMenu, USECLIPRGN_ITEM, gUseClipRgn);

	if ((gCopyBitsMenu = GetMenu(COPYBITSMENU_ID)) == nil)
		return(CANTGETMENU_NDX);
	InsertMenu(gCopyBitsMenu, 0);
	CheckItem(gCopyBitsMenu, USESEPSRC_ITEM, gSepSrc);
	CheckItem(gCopyBitsMenu, SRCDITHER_ITEM, gDitherSrc);
	CheckItem(gCopyBitsMenu, USEMASKRGN_ITEM, gUseMaskRgn);
	if (gTest != COPYBITS_ITEM)	// Need to disable entire menu
		DisableItem(gCopyBitsMenu, 0);

	if ((gLinesMenu = GetMenu(LINESMENU_ID)) == nil)
		return(CANTGETMENU_NDX);
	InsertMenu(gLinesMenu, 0);
	CheckItem(gLinesMenu, gLines, true);
	if (gTest != LINES_ITEM)	// Need to disable entire menu
		DisableItem(gLinesMenu, 0);

	if ((gTextMenu = GetMenu(TEXTMENU_ID)) == nil)
		return(CANTGETMENU_NDX);
	InsertMenu(gTextMenu, 0);
	if (gTest != TEXT_ITEM)	// Need to disable entire menu
		DisableItem(gTextMenu, 0);

	if ((gExpMenu = GetMenu(EXPMENU_ID)) == nil)
		return(CANTGETMENU_NDX);
	InsertMenu(gExpMenu, 0);

	/* Set up the hierarchical menus */

	if ((gRgnShapeMenu = GetMenu(RGNSHAPEMENU_ID)) == nil)
		return(CANTGETMENU_NDX);
	InsertMenu(gRgnShapeMenu, -1);
	CheckItem(gRgnShapeMenu, gRgnShape, true);

	if ((gClipRgnMenu = GetMenu(CLIPRGNMENU_ID)) == nil)
		return(CANTGETMENU_NDX);
	InsertMenu(gClipRgnMenu, -1);
	CheckItem(gClipRgnMenu, gClipRgn, true);

	if ((gMaskRgnMenu = GetMenu(MASKRGNMENU_ID)) == nil)
		return(CANTGETMENU_NDX);
	InsertMenu(gMaskRgnMenu, -1);
	CheckItem(gMaskRgnMenu, gMaskRgn, true);

	if ((gDestLocMenu = GetMenu(DESTLOCMENU_ID)) == nil)
		return(CANTGETMENU_NDX);
	InsertMenu(gDestLocMenu, -1);
	CheckItem(gDestLocMenu, gDestLoc, true);

	if ((gDestDimMenu = GetMenu(DESTDIMMENU_ID)) == nil)
		return(CANTGETMENU_NDX);
	InsertMenu(gDestDimMenu, -1);
	CheckItem(gDestDimMenu, gDestDim, true);

	/* The dest and source image selection menus are done together,
		since they both are populated from the resource names of
		the PICT resources. */
	if ((gDestImageMenu = GetMenu(DESTIMAGEMENU_ID)) == nil)
		return(CANTGETMENU_NDX);
	if ((gSrcImageMenu = GetMenu(SRCIMAGEMENU_ID)) == nil)
		return(CANTGETMENU_NDX);
	if ((pictcount = Count1Resources('PICT')) == 0)
		return(CANTGETPICT_NDX);
	for (i = 1; i <= pictcount; i++) {
		SetResLoad(false);
		h = Get1Resource('PICT', PICT_BASEID - 1 + i);
		SetResLoad(true);
		if (h != nil) {
			GetResInfo(h, &resID, &restype, str);
			if (ResError() == noErr) {
				if (str[0] == 0) {
					/* The resource had no name, so we'll create one like
						'Unnamed Picture 1'. */
					sint32todstr(i, countstr);
					paramstr(str, UNNAMEDPICT_NDX, countstr, nil, nil, nil);
				}
				/* Now we append an empty name as the menu item,
					then we do a SetMenuItemText in case the picture name
					contains any metacharacters.  This makes it look clean. */
				AppendMenu(gDestImageMenu, "\p ");
				SetMenuItemText(gDestImageMenu, i, str);
				AppendMenu(gSrcImageMenu, "\p ");
				SetMenuItemText(gSrcImageMenu, i, str);
			}
		}
	}
	InsertMenu(gDestImageMenu, -1);
	if (gDestImage > pictcount)
		gDestImage = pictcount;
	CheckItem(gDestImageMenu, gDestImage, true);
	InsertMenu(gSrcImageMenu, -1);
	if (gSrcImage > pictcount)
		gSrcImage = pictcount;
	CheckItem(gSrcImageMenu, gSrcImage, true);

	if ((gFgColorMenu = GetMenu(FGCOLORMENU_ID)) == nil)
		return(CANTGETMENU_NDX);
	InsertMenu(gFgColorMenu, -1);
	CheckItem(gFgColorMenu, gFgColor, true);

	if ((gBgColorMenu = GetMenu(BGCOLORMENU_ID)) == nil)
		return(CANTGETMENU_NDX);
	InsertMenu(gBgColorMenu, -1);
	CheckItem(gBgColorMenu, gBgColor, true);

	if ((gPenSizeMenu = GetMenu(PENSIZEMENU_ID)) == nil)
		return(CANTGETMENU_NDX);
	InsertMenu(gPenSizeMenu, -1);
	CheckItem(gPenSizeMenu, gPenSize, true);

	if ((gPenModeMenu = GetMenu(PENMODEMENU_ID)) == nil)
		return(CANTGETMENU_NDX);
	InsertMenu(gPenModeMenu, -1);
	CheckItem(gPenModeMenu, gPenMode, true);
	CheckItem(gPenModeMenu, PM_PLUSHILITE_ITEM, gPMPlusHilite);

	// Get all three pattern menus
	if ((gPenPatMenu = GetMenu(PENPATMENU_ID)) == nil)
		return(CANTGETMENU_NDX);
	if ((gBgPatMenu = GetMenu(BGPATMENU_ID)) == nil)
		return(CANTGETMENU_NDX);
	if ((gFillPatMenu = GetMenu(FILLPATMENU_ID)) == nil)
		return(CANTGETMENU_NDX);

	// See how many PixPats we have in our resources
	if ((pixpatcount = Count1Resources('ppat')) == 0)
		return(CANTGETPIXPAT_NDX);
	if (pixpatcount > MAX_PIXPATS)
		pixpatcount = MAX_PIXPATS;

	// Add the PixPats to the end of all three pattern menus
	for (i = 1; i <= pixpatcount; i++) {
		SetResLoad(false);
		h = Get1IndResource('ppat', i);
		SetResLoad(true);
		if (h == nil)
			return(CANTGETPIXPAT_NDX);
		GetResInfo(h, &resID, &restype, str);
		if (ResError() == noErr) {
			if (str[0] == 0) {
				/* The resource had no name, so we'll create one like
					'Unnamed PixPat 1'. */
				sint32todstr(i, countstr);
				paramstr(str, UNNAMEDPIXPAT_NDX, countstr, nil, nil, nil);
			}
			/* Now we append an empty name as the menu item,
				then we do a SetMenuItemText in case the picture name
				contains any metacharacters.  This makes it look clean. */
			AppendMenu(gPenPatMenu, "\p ");
			SetMenuItemText(gPenPatMenu, i+FIRSTPIXPAT_ITEM-1, str);
			AppendMenu(gBgPatMenu, "\p ");
			SetMenuItemText(gBgPatMenu, i+FIRSTPIXPAT_ITEM-1, str);
			AppendMenu(gFillPatMenu, "\p ");
			SetMenuItemText(gFillPatMenu, i+FIRSTPIXPAT_ITEM-1, str);
		} else {
			DBUGSTR("ResError() returned error after getting PixPat ResInfo");
		}
		h = (Handle)GetPixPat(resID);
		if (h == nil)
			return(CANTGETPIXPAT_NDX);
		gPixPath[i-1] = (PixPatHandle)h;
	}
	InsertMenu(gPenPatMenu, -1);
	if (gPenPat > pixpatcount)
		gPenPat = pixpatcount + FIRSTPIXPAT_ITEM - 1;
	CheckItem(gPenPatMenu, gPenPat, true);

	InsertMenu(gBgPatMenu, -1);
	if (gBgPat > pixpatcount)
		gBgPat = pixpatcount + FIRSTPIXPAT_ITEM - 1;
	CheckItem(gBgPatMenu, gBgPat, true);

	InsertMenu(gFillPatMenu, -1);
	if (gFillPat > pixpatcount)
		gFillPat = pixpatcount + FIRSTPIXPAT_ITEM - 1;
	CheckItem(gFillPatMenu, gFillPat, true);

	if ((gSrcLocMenu = GetMenu(SRCLOCMENU_ID)) == nil)
		return(CANTGETMENU_NDX);
	InsertMenu(gSrcLocMenu, -1);
	CheckItem(gSrcLocMenu, gSrcLoc, true);

	if ((gSrcDimMenu = GetMenu(SRCDIMMENU_ID)) == nil)
		return(CANTGETMENU_NDX);
	InsertMenu(gSrcDimMenu, -1);
	if (!gSepSrc)	// Sync source & dest dimensions unless activated
		gSrcDim = gDestDim;
	CheckItem(gSrcDimMenu, gSrcDim, true);

	// SrcImage menu already set up with DestImage menu

	if ((gXferModeMenu = GetMenu(XFERMODEMENU_ID)) == nil)
		return(CANTGETMENU_NDX);
	InsertMenu(gXferModeMenu, -1);
	CheckItem(gXferModeMenu, gXferMode, true);
	CheckItem(gXferModeMenu, X_PLUSDITHER_ITEM, gXPlusDither);

	if ((gSrcRectMenu = GetMenu(SRCRECTMENU_ID)) == nil)
		return(CANTGETMENU_NDX);
	InsertMenu(gSrcRectMenu, -1);
	CheckItem(gSrcRectMenu, gSrcRect, true);

	if ((gDestRectMenu = GetMenu(DESTRECTMENU_ID)) == nil)
		return(CANTGETMENU_NDX);
	InsertMenu(gDestRectMenu, -1);
	CheckItem(gDestRectMenu, gDestRect, true);

	if ((gTextModeMenu = GetMenu(TEXTMODEMENU_ID)) == nil)
		return(CANTGETMENU_NDX);
	InsertMenu(gTextModeMenu, -1);
	CheckItem(gTextModeMenu, gTextMode, true);
	CheckItem(gTextModeMenu, T_PLUSHILITE_ITEM, gTPlusHilite);
	CheckItem(gTextModeMenu, T_PLUSMASK_ITEM, gTPlusMask);

	return(0);
}

int main(void)
{
	SInt32 err;

	/* The usual invocations */
	InitGraf(&qd.thePort);	/* Initialize Quickdraw */
	InitFonts();			/* Font Manager */
	InitWindows();			/* Window Manager */
	InitMenus();			/* Menu Manager */
	TEInit(); 				/* TextEdit */
	InitDialogs(nil);		/* Dialog Manager (no resume procedure) */
	InitCursor(); 			/* Initialize the cursor to an arrow */
	FlushEvents(everyEvent, 0);	/* Clear the event queue of all events */

	/* Do the application-specific setup */
	if ((err = checkconfig()) != 0) {
		erroralert(err);
		return(err);
	}
	if ((err = setupmenus()) != 0) {
		erroralert(err);
		return(err);
	}
	if ((err = initdest()) != 0 || (err = initsource()) != 0) {
		erroralert(err);
		return(err);
	}
	if ((err = initstatus()) != 0) {
		erroralert(err);
		return(err);
	}
	if ((err = initregions()) != 0) {
		erroralert(err);
		return(err);
	}
	/* Let there be menus and windows */
	DrawMenuBar();
	ShowWindow(gDestWind);
	if (gSepSrc && gSrcLoc == WINDOW_ITEM)
		ShowWindow(gSrcWind);
	ShowWindow(gStatusWind);

	doeventloop();	// Main event dispatching

	cleanupdest();
	cleanupsrc();
	cleanupstatus();

	return(0);
}

static void uint32tohstr(UInt32 num, unsigned char *strp)
{
	SInt32 i, digit;
	char numbuf[20];

	i = 0;
	do {	/* Convert the number to a reversed ASCII string */
		digit = num & 0x0F;
		if (digit >= 10)
			digit += ('A' - 10);
		else
			digit += '0';
		numbuf[i++] = digit;
	} while ((num >>= 4) > 0);
	*strp++ = i;		/* Copy the length byte */
	while (--i >= 0)	/* Copy the string forwards to its destination */
		*strp++ = numbuf[i];
}

static void uint32todstr(UInt32 num, unsigned char *strp)
{
	SInt32 i;
	char numbuf[20];

	i = 0;
	do {	/* Convert the number to a reversed ASCII string */
		numbuf[i++] = num % 10 + '0';
	} while ((num /= 10) > 0);
	*strp++ = i;		/* Copy the length byte */
	while (--i >= 0)	/* Copy the string forwards to its destination */
		*strp++ = numbuf[i];
}

static void sint32todstr(SInt32 num, unsigned char *strp)
{
	Boolean neg;
	SInt32 i;
	char numbuf[20];

	if (num < 0) {
		neg = true;
		num = -num;
	} else {
		neg = false;
	}
	i = 0;
	do {	/* Convert the number to a reversed ASCII string */
		numbuf[i++] = num % 10 + '0';
	} while ((num /= 10) > 0);
	if (neg)
		numbuf[i++] = '-';
	*strp++ = i;		/* Copy the length byte */
	while (--i >= 0)	/* Copy the string forwards to its destination */
		*strp++ = numbuf[i];
}

/* Note: all of these are Pascal strings */
static void paramstr(unsigned char *dest, SInt32 index, unsigned char *sub0, unsigned char *sub1,
			unsigned char *sub2, unsigned char *sub3)
{
	SInt32 srclen, substlen, destindex;
	unsigned char str[256], *source, *substitute;

	GetIndString(str, PARAMSTR_ID, index);
	source = str;

	srclen = *source++;
	destindex = 0;

	while (srclen > 0) {
		if (*source == '^') {	/* Substitution marker */
			if (srclen == 1) {	/* Last character in string was '^' */
				goto storedest;
			} else {
				switch (*(source+1)) {
				case '0':
					substitute = sub0;
					break;
				case '1':
					substitute = sub1;
					break;
				case '2':
					substitute = sub2;
					break;
				case '3':
					substitute = sub3;
					break;
				default:
					goto storedest;
				}
			}
			source += 2;	/* Skip over the '^n' characters */
			srclen -= 2;
			if (substitute != nil) {	/* Guard against NIL pointers */
				substlen = *substitute++;
				while (substlen) {
					destindex++;
					dest[destindex] = *substitute++;
					substlen--;
				}
			}
		} else {	/* Not doing a substitution, so copy a byte from the source */
storedest:
			destindex++;
			dest[destindex] = *source++;
			srclen--;
		}
	}

	dest[0] = destindex;	/* Finally, fill in the length byte */
}

static void coloritemtoRGB(UInt32 item, RGBColor *otherp, RGBColor *colorp)
{
	switch (item) {
	case BLACK_ITEM:
		colorp->red = 0;
		colorp->green = 0;
		colorp->blue = 0;
		break;
	case WHITE_ITEM:
		colorp->red = 0xFFFF;
		colorp->green = 0xFFFF;
		colorp->blue = 0xFFFF;
		break;
	case RED_ITEM:
		colorp->red = 0xFFFF;
		colorp->green = 0;
		colorp->blue = 0;
		break;
	case GREEN_ITEM:
		colorp->red = 0;
		colorp->green = 0xFFFF;
		colorp->blue = 0;
		break;
	case BLUE_ITEM:
		colorp->red = 0;
		colorp->green = 0;
		colorp->blue = 0xFFFF;
		break;
	case CYAN_ITEM:
		colorp->red = 0;
		colorp->green = 0xFFFF;
		colorp->blue = 0xFFFF;
		break;
	case MAGENTA_ITEM:
		colorp->red = 0xFFFF;
		colorp->green = 0;
		colorp->blue = 0xFFFF;
		break;
	case YELLOW_ITEM:
		colorp->red = 0xFFFF;
		colorp->green = 0xFFFF;
		colorp->blue = 0;
		break;
	case GRAY53_ITEM:
		colorp->red = 0x8888;
		colorp->green = 0x8888;
		colorp->blue = 0x8888;
		break;
	case HILITE_ITEM:
		LMGetHiliteRGB(colorp);
		break;
	case RANDOM_ITEM:
		colorp->red = Random();
		colorp->green = Random();
		colorp->blue = Random();
		break;
	case OTHERCOLOR_ITEM:
		*colorp = *otherp;
		break;
	}
}

static UInt32 windpttoaddr(WindowPtr wind, Point *originp)
{
	UInt32 v, h, addr;
	GrafPtr oldport;
	GDPtr gdp;
	GDHandle gdh;
	PixMapPtr pmp;
	Point pt;

	GetPort(&oldport);
	SetPort(wind);
	pt = *originp;	// Get top-left origin point
	LocalToGlobal(&pt);
	SetPort(oldport);

	for (gdh = GetDeviceList(); gdh != nil; gdh = GetNextDevice(gdh)) {
		if (!TestDeviceAttribute(gdh, screenDevice) ||
				!TestDeviceAttribute(gdh, screenActive))
			continue;
		gdp = *gdh;
		/* See if the window is on this GDevice */
		if (PtInRect(pt, &gdp->gdRect))
			goto gotgdev;
	}
	return(0);

gotgdev:
	v = pt.v - gdp->gdRect.top;
	h = pt.h - gdp->gdRect.left;
	pmp = *gdp->gdPMap;
	addr = (UInt32)pmp->baseAddr + v * ((UInt32)pmp->rowBytes & 0x3FFF);
	addr += h << (pmp->pixelSize >> 4);
	return(addr);
}

static UInt32 gwpixmappttoaddr(PixMapHandle pmh, Point *originp)
{
	UInt32 v, h, addr;
	PixMapPtr pmp;
	Point pt;

	addr = (UInt32)GetPixBaseAddr(pmh);
	pt = *originp;
	pmp = *pmh;
	v = pt.v - pmp->bounds.top;
	h = pt.h - pmp->bounds.left;
	addr += v * ((UInt32)pmp->rowBytes & 0x3FFF);
	addr += h << (pmp->pixelSize >> 4);
	return(addr);
}

static void docopybitstest(WindowPtr wind)
{
	UInt32 mode, width, height;
	UInt32 iter, beginticks, curticks, stopticks;
	BitMapPtr srcbits, destbits;
	CGrafPtr oldport;
	GDHandle oldgdh;
	PixMapHandle destpmh, srcpmh;
	RgnHandle maskrgnh;
	Rect srcrect, destrect, portrect, r;
	RGBColor foreRGB, backRGB, opRGB;

	switch (gXferMode) {
	case X_SRCCOPY_ITEM:
		mode = srcCopy;
		break;
	case X_SRCOR_ITEM:
		mode = srcOr;
		break;
	case X_SRCXOR_ITEM:
		mode = srcXor;
		break;
	case X_SRCBIC_ITEM:
		mode = srcBic;
		break;
	case X_NOTSRCCOPY_ITEM:
		mode = notSrcCopy;
		break;
	case X_NOTSRCOR_ITEM:
		mode = notSrcOr;
		break;
	case X_NOTSRCXOR_ITEM:
		mode = notSrcXor;
		break;
	case X_NOTSRCBIC_ITEM:
		mode = notSrcBic;
		break;
	case X_ADDOVER_ITEM:
		mode = addOver;
		break;
	case X_ADDPIN_ITEM:
		mode = addPin;
		opRGB.red = 0xFFFF;
		opRGB.green = 0xFFFF;
		opRGB.blue = 0xFFFF;
		OpColor(&opRGB);
		break;
	case X_SUBOVER_ITEM:
		mode = subOver;
		break;
	case X_SUBPIN_ITEM:
		mode = subPin;
		opRGB.red = 0;
		opRGB.green = 0;
		opRGB.blue = 0;
		OpColor(&opRGB);
		break;
	case X_ADMAX_ITEM:
		mode = adMax;
		break;
	case X_ADMIN_ITEM:
		mode = adMin;
		break;
	case X_BLEND_ITEM:
		mode = blend;
		opRGB.red = 0x4040;
		opRGB.green = 0x4040;
		opRGB.blue = 0x4040;
		OpColor(&opRGB);
		break;
	case X_TRANSPARENT_ITEM:
		mode = transparent;
		break;
	case X_HILITE_ITEM:
		mode = hilitetransfermode;
		break;
	}
	if (gXPlusDither)
		mode += ditherCopy;

	/* Get the source and destination rectangles */
	r.top = 0;
	r.left = 0;
	dimtowh(gSrcDim, &width, &height);
	r.bottom = height;
	r.right = width;
	rectitemtorect(gSrcRect, &r, &gSrcOtherRect, &srcrect);
	dimtowh(gDestDim, &width, &height);
	r.bottom = height;
	r.right = width;
	rectitemtorect(gDestRect, &r, &gDestOtherRect, &destrect);

	if (gDestLoc != WINDOW_ITEM) {	// Destination is offscreen
		GetGWorld(&oldport, &oldgdh);
		SetGWorld(gDestGW, nil);
		destpmh = GetGWorldPixMap(gDestGW);
		LockPixels(destpmh);
		destbits = &((GrafPtr)gDestGW)->portBits;
		portrect = ((GrafPtr)gDestGW)->portRect;
		gTestDestAddr = gwpixmappttoaddr(destpmh, (Point *)&destrect);
	} else {	// Destination is onscreen
		// The current port is already set to the window
		destbits = &wind->portBits;
		portrect = wind->portRect;
		gTestDestAddr = windpttoaddr(wind, (Point *)&destrect);
	}
	if (gSepSrc) {
		if (gSrcLoc != WINDOW_ITEM) {	// Source is offscreen
			srcpmh = GetGWorldPixMap(gSrcGW);
			LockPixels(srcpmh);
			srcbits = &((GrafPtr)gSrcGW)->portBits;
			gTestSrcAddr = gwpixmappttoaddr(srcpmh, (Point *)&srcrect);
		} else {	// Source is onscreen
			srcbits = &gSrcWind->portBits;
			gTestSrcAddr = windpttoaddr(gSrcWind, (Point *)&srcrect);
		}
	} else {	// No separate source, so source loc = destination
		srcbits = destbits;
		if (gDestLoc != WINDOW_ITEM)	// Destination is offscreen
			gTestSrcAddr = gwpixmappttoaddr(destpmh, (Point *)&srcrect);
		else	// Destination is onscreen
			gTestSrcAddr = windpttoaddr(wind, (Point *)&srcrect);
	}
	if (gUseClipRgn)
		SetClip(gRgnh[gClipRgn]);
	else
		ClipRect(&portrect);

	/* Set up any custom colors we might have */
	coloritemtoRGB(gFgColor, &gFgOtherRGB, &foreRGB);
	coloritemtoRGB(gBgColor, &gBgOtherRGB, &backRGB);
	RGBForeColor(&foreRGB);
	RGBBackColor(&backRGB);

	/* Grab the mask region, if it's being used */
	maskrgnh = nil;
	if (gUseMaskRgn)
		maskrgnh = gRgnh[gMaskRgn];

	/* Perform the actual test, gathering timing information */
	beginticks = TickCount();
	stopticks = beginticks + TESTTICKS;
	for (iter = 0; (curticks = TickCount()) < stopticks; iter++) {
		CopyBits(srcbits, destbits, &srcrect, &destrect, mode, maskrgnh);
	}
	gTestBeginTicks = beginticks;
	gTestEndTicks = curticks;
	gTestIterations = iter;

	/* Restore the foreground and background colors to black & white */
	coloritemtoRGB(BLACK_ITEM, &gFgOtherRGB, &foreRGB);
	coloritemtoRGB(WHITE_ITEM, &gBgOtherRGB, &backRGB);
	RGBForeColor(&foreRGB);
	RGBBackColor(&backRGB);

	ClipRect(&portrect);	// Restore the full clipping

	if (gDestLoc != WINDOW_ITEM) {	// Destination was offscreen
		SetGWorld(oldport, oldgdh);
		UnlockPixels(destpmh);
	}
	if (gSepSrc && gSrcLoc != WINDOW_ITEM)	// Source was offscreen
		UnlockPixels(srcpmh);
}

static void dotexttest(WindowPtr wind)
{
	UInt32 mode, width, height, fontheight, fontascent, v;
	UInt32 iter, beginticks, curticks, stopticks;
	BitMapPtr destbits;
	CGrafPtr oldport;
	GDHandle oldgdh;
	PixMapHandle destpmh;
	Rect destrect, portrect, r;
	RGBColor foreRGB, backRGB, opRGB;
	FontInfo fi;

	switch (gTextMode) {
	case T_SRCCOPY_ITEM:
		mode = srcCopy;
		break;
	case T_SRCOR_ITEM:
		mode = srcOr;
		break;
	case T_SRCXOR_ITEM:
		mode = srcXor;
		break;
	case T_SRCBIC_ITEM:
		mode = srcBic;
		break;
	case T_NOTSRCCOPY_ITEM:
		mode = notSrcCopy;
		break;
	case T_NOTSRCOR_ITEM:
		mode = notSrcOr;
		break;
	case T_NOTSRCXOR_ITEM:
		mode = notSrcXor;
		break;
	case T_NOTSRCBIC_ITEM:
		mode = notSrcBic;
		break;
	case T_ADDOVER_ITEM:
		mode = addOver;
		break;
	case T_ADDPIN_ITEM:
		mode = addPin;
		opRGB.red = 0xFFFF;
		opRGB.green = 0xFFFF;
		opRGB.blue = 0xFFFF;
		OpColor(&opRGB);
		break;
	case T_SUBOVER_ITEM:
		mode = subOver;
		break;
	case T_SUBPIN_ITEM:
		mode = subPin;
		opRGB.red = 0;
		opRGB.green = 0;
		opRGB.blue = 0;
		OpColor(&opRGB);
		break;
	case T_ADMAX_ITEM:
		mode = adMax;
		break;
	case T_ADMIN_ITEM:
		mode = adMin;
		break;
	case T_BLEND_ITEM:
		mode = blend;
		opRGB.red = 0x4040;
		opRGB.green = 0x4040;
		opRGB.blue = 0x4040;
		OpColor(&opRGB);
		break;
	case T_TRANSPARENT_ITEM:
		mode = transparent;
		break;
	case T_GRAYISHTEXTOR_ITEM:
		mode = grayishTextOr;
		break;
	}
	if (gTPlusHilite)
		mode += hilitetransfermode;
	if (gTPlusMask)
		mode += 64;

	/* Get the destination rectangle */
	r.top = 0;
	r.left = 0;
	dimtowh(gDestDim, &width, &height);
	r.bottom = height;
	r.right = width;
	rectitemtorect(gDestRect, &r, &gDestOtherRect, &destrect);

	if (gDestLoc != WINDOW_ITEM) {	// Destination is offscreen
		GetGWorld(&oldport, &oldgdh);
		SetGWorld(gDestGW, nil);
		destpmh = GetGWorldPixMap(gDestGW);
		LockPixels(destpmh);
		destbits = &((GrafPtr)gDestGW)->portBits;
		portrect = ((GrafPtr)gDestGW)->portRect;
		gTestDestAddr = gwpixmappttoaddr(destpmh, (Point *)&destrect);
	} else {	// Destination is onscreen
		// The current port is already set to the window
		destbits = &wind->portBits;
		portrect = wind->portRect;
		gTestDestAddr = windpttoaddr(wind, (Point *)&destrect);
	}
	gTestSrcAddr = 0;
	if (gUseClipRgn)
		SetClip(gRgnh[gClipRgn]);
	else
		ClipRect(&portrect);

	/* Set the Text parameters */
	TextFont(0);
	TextSize(20);
	TextFace(0);
	TextMode(mode);
	GetFontInfo(&fi);
	fontascent = fi.ascent;
	fontheight = fontascent + fi.descent;

	/* Set up any custom colors we might have */
	coloritemtoRGB(gFgColor, &gFgOtherRGB, &foreRGB);
	coloritemtoRGB(gBgColor, &gBgOtherRGB, &backRGB);
	RGBForeColor(&foreRGB);
	RGBBackColor(&backRGB);

	v = 0;

	/* Perform the actual test, gathering timing information */
	beginticks = TickCount();
	stopticks = beginticks + TESTTICKS;
	for (iter = 0; (curticks = TickCount()) < stopticks; iter++) {
		MoveTo(0, v + fontascent);
		DrawString("\pThe quick red fox jumped over the lazy brown dog.");
		v += fontascent;
		if (v >= destrect.bottom)
			v = 0;
	}
	gTestBeginTicks = beginticks;
	gTestEndTicks = curticks;
	gTestIterations = iter;

	/* Restore the foreground and background colors to black & white */
	coloritemtoRGB(BLACK_ITEM, &gFgOtherRGB, &foreRGB);
	coloritemtoRGB(WHITE_ITEM, &gBgOtherRGB, &backRGB);
	RGBForeColor(&foreRGB);
	RGBBackColor(&backRGB);

	/* Restore the transfer mode */
	TextMode(srcOr);

	ClipRect(&portrect);	// Restore the full clipping

	if (gDestLoc != WINDOW_ITEM) {	// Destination was offscreen
		SetGWorld(oldport, oldgdh);
		UnlockPixels(destpmh);
	}
}

static void patitemtopat(UInt32 patitem, PatPtr patptr)
{
	static Pattern gHStripes =
		{ 0xFF, 0x00, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00 };
	static Pattern gVStripes =
		{ 0xA6, 0xA6, 0xA6, 0xA6, 0xA6, 0xA6, 0xA6, 0xA6 };
	static Pattern gDStripes =
		{ 0x84, 0x42, 0x21, 0x90, 0x48, 0x24, 0x12, 0x09 };
	static Pattern gNumNibbles =
		{ 0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF };

	switch (patitem) {
	case BLACKPAT_ITEM:
		*patptr = qd.black;
		break;
	case WHITEPAT_ITEM:
		*patptr = qd.white;
		break;
	case GRAY50PAT_ITEM:
		*patptr = qd.gray;
		break;
	case LTGRAYPAT_ITEM:
		*patptr = qd.ltGray;
		break;
	case DKGRAYPAT_ITEM:
		*patptr = qd.dkGray;
		break;
	case HSTRIPESPAT_ITEM:
		*patptr = gHStripes;
		break;
	case VSTRIPESPAT_ITEM:
		*patptr = gVStripes;
		break;
	case DSTRIPESPAT_ITEM:
		*patptr = gDStripes;
		break;
	case NUMNIBBLESPAT_ITEM:
		*patptr = gNumNibbles;
		break;
	default:
		DBUGPRINTF(("Unknown patitem %d", patitem));
		break;
	}
}

static void pensizeitemtopt(UInt32 pensizeitem, Point *ptp)
{
	switch (pensizeitem) {
	case PS_1X1_ITEM:
		ptp->v = 1;
		ptp->h = 1;
		break;
	case PS_2X2_ITEM:
		ptp->v = 2;
		ptp->h = 2;
		break;
	case PS_4X4_ITEM:
		ptp->v = 4;
		ptp->h = 4;
		break;
	case PS_8X8_ITEM:
		ptp->v = 8;
		ptp->h = 8;
		break;
	case PS_16X16_ITEM:
		ptp->v = 16;
		ptp->h = 16;
		break;
	}
}

static void doshapetest(WindowPtr wind, UInt32 test)
{
	UInt32 mode, h, v, width, height;
	UInt32 iter, beginticks, curticks, stopticks;
	CGrafPtr oldport;
	GDHandle oldgdh;
	PixMapHandle destpmh;
	RgnHandle rgnh;
	PixPatHandle pixpath;
	Point pensize;
	Rect destrect, portrect;
	Pattern pat;
	RGBColor foreRGB, backRGB;

	switch (gPenMode) {
	case PATCOPY_ITEM:
		mode = patCopy;
		break;
	case PATOR_ITEM:
		mode = patOr;
		break;
	case PATXOR_ITEM:
		mode = patXor;
		break;
	case PATBIC_ITEM:
		mode = patBic;
		break;
	case NOTPATCOPY_ITEM:
		mode = notPatCopy;
		break;
	case NOTPATOR_ITEM:
		mode = notPatOr;
		break;
	case NOTPATXOR_ITEM:
		mode = notPatXor;
		break;
	case NOTPATBIC_ITEM:
		mode = notPatBic;
		break;
	case PATCOPYPLUSTRANSP_ITEM:
		mode = patCopy + transparent;
		break;
	}
	if (gPMPlusHilite)
		mode += hilitetransfermode;

	if (gDestLoc != WINDOW_ITEM) {	// Destination is offscreen
		GetGWorld(&oldport, &oldgdh);
		SetGWorld(gDestGW, nil);
		destpmh = GetGWorldPixMap(gDestGW);
		LockPixels(destpmh);
		destrect = ((GrafPtr)gDestGW)->portRect;
		portrect = destrect;
		InsetRect(&destrect, gBoundRectHInset, gBoundRectVInset);
		gTestDestAddr = gwpixmappttoaddr(destpmh, (Point *)&destrect);
	} else {	// Destination is onscreen
		// The current port is already set to the window
		destrect = wind->portRect;
		portrect = destrect;
		InsetRect(&destrect, gBoundRectHInset, gBoundRectVInset);
		gTestDestAddr = windpttoaddr(wind, (Point *)&destrect);
	}
	gTestSrcAddr = 0;
	if (gUseClipRgn)
		SetClip(gRgnh[gClipRgn]);
	else
		ClipRect(&portrect);

	switch (test) {
	case ERASESHAPE_ITEM:
		if (gBgPat >= FIRSTPIXPAT_ITEM) {
			/* It's a PixPat */
			BackPixPat(gPixPath[gBgPat-FIRSTPIXPAT_ITEM]);
		} else {
			/* Set the old-style background pattern */
			patitemtopat(gBgPat, &pat);
			BackPat(&pat);
		}
		break;
	case INVERTSHAPE_ITEM:
		break;	// Don't need to set the pen parameters
	case PATFILLSHAPE_ITEM:
		if (gFillPat >= FIRSTPIXPAT_ITEM) {
			/* It's a PixPat */
			pixpath = gPixPath[gFillPat-FIRSTPIXPAT_ITEM];
		} else {
			/* Set the old-style background pattern */
			patitemtopat(gFillPat, &pat);
			pixpath = nil;
		}
		break;
	default:
		/* Set the pen mode */
		PenMode(mode);
		/* Set the pen pixpat or pattern */
		if (gPenPat >= FIRSTPIXPAT_ITEM) {
			/* It's a PixPat */
			PenPixPat(gPixPath[gPenPat-FIRSTPIXPAT_ITEM]);
		} else {
			/* Set the old-style pen pattern */
			patitemtopat(gPenPat, &pat);
			PenPat(&pat);
		}
		/* Set the pen size */
		pensizeitemtopt(gPenSize, &pensize);
		PenSize(pensize.h, pensize.v);
		break;
	}

	/* Set up any custom colors we might have */
	coloritemtoRGB(gFgColor, &gFgOtherRGB, &foreRGB);
	coloritemtoRGB(gBgColor, &gBgOtherRGB, &backRGB);
	RGBForeColor(&foreRGB);
	RGBBackColor(&backRGB);

	if (gShape == REGION_ITEM)
		rgnh = gRgnh[gRgnShape];

	/* Perform the actual test, gathering timing information */
	beginticks = TickCount();
	stopticks = beginticks + TESTTICKS;

	switch (test) {
	case LINES_ITEM:
		switch (gLines) {
		case HORIZONTAL_ITEM:
			h = destrect.left;
			width = destrect.right - h;
			v = destrect.top;
			height = destrect.bottom - v;
			for (iter = 0; (curticks = TickCount()) < stopticks; iter++) {
				MoveTo(h, v);
				LineTo(h + width, v);
				v += pensize.v + 1;
				if (v >= destrect.bottom)
					v = destrect.top;
			}
			break;
		case VERTICAL_ITEM:
			h = destrect.left;
			width = destrect.right - h;
			v = destrect.top;
			height = destrect.bottom - v;
			for (iter = 0; (curticks = TickCount()) < stopticks; iter++) {
				MoveTo(h, v);
				LineTo(h, v + height);
				h += pensize.h + 1;
				if (h >= destrect.right)
					h = destrect.left;
			}
			break;
		case DIAGONAL_ITEM:
			h = destrect.left;
			width = destrect.right - h;
			v = destrect.top;
			height = destrect.bottom - v;
			for (iter = 0; (curticks = TickCount()) < stopticks; iter++) {
				MoveTo(h, v);
				LineTo(h + height, v + height);
			}
			break;
		case SLANTED_ITEM:
			break;
		}
		break;
	case FRAMESHAPE_ITEM:
		switch (gShape) {
		case RECTANGLE_ITEM:
			for (iter = 0; (curticks = TickCount()) < stopticks; iter++) {
				FrameRect(&destrect);
			}
			break;
		case REGION_ITEM:
			for (iter = 0; (curticks = TickCount()) < stopticks; iter++) {
				FrameRgn(rgnh);
			}
			break;
		case OVAL_ITEM:
			for (iter = 0; (curticks = TickCount()) < stopticks; iter++) {
				FrameOval(&destrect);
			}
			break;
		case ROUNDRECT_ITEM:
			for (iter = 0; (curticks = TickCount()) < stopticks; iter++) {
				FrameRoundRect(&destrect, RRECT_CURVATURE, RRECT_CURVATURE);
			}
			break;
		case ARC_ITEM:
			for (iter = 0; (curticks = TickCount()) < stopticks; iter++) {
				FrameArc(&destrect, ARC_STARTANGLE, ARC_DEGREES);
			}
			break;
		default:
			DBUGPRINTF(("Unimplemented Frame Shape %d", gShape));
			break;
		}
		break;
	case PAINTSHAPE_ITEM:
		switch (gShape) {
		case RECTANGLE_ITEM:
			for (iter = 0; (curticks = TickCount()) < stopticks; iter++) {
				PaintRect(&destrect);
			}
			break;
		case REGION_ITEM:
			for (iter = 0; (curticks = TickCount()) < stopticks; iter++) {
				PaintRgn(rgnh);
			}
			break;
		case OVAL_ITEM:
			for (iter = 0; (curticks = TickCount()) < stopticks; iter++) {
				PaintOval(&destrect);
			}
			break;
		case ROUNDRECT_ITEM:
			for (iter = 0; (curticks = TickCount()) < stopticks; iter++) {
				PaintRoundRect(&destrect, RRECT_CURVATURE, RRECT_CURVATURE);
			}
			break;
		case ARC_ITEM:
			for (iter = 0; (curticks = TickCount()) < stopticks; iter++) {
				PaintArc(&destrect, ARC_STARTANGLE, ARC_DEGREES);
			}
			break;
		default:
			DBUGPRINTF(("Unimplemented Paint Shape %d", gShape));
			break;
		}
		break;
	case ERASESHAPE_ITEM:
		switch (gShape) {
		case RECTANGLE_ITEM:
			for (iter = 0; (curticks = TickCount()) < stopticks; iter++) {
				EraseRect(&destrect);
			}
			break;
		case REGION_ITEM:
			for (iter = 0; (curticks = TickCount()) < stopticks; iter++) {
				EraseRgn(rgnh);
			}
			break;
		case OVAL_ITEM:
			for (iter = 0; (curticks = TickCount()) < stopticks; iter++) {
				EraseOval(&destrect);
			}
			break;
		case ROUNDRECT_ITEM:
			for (iter = 0; (curticks = TickCount()) < stopticks; iter++) {
				EraseRoundRect(&destrect, RRECT_CURVATURE, RRECT_CURVATURE);
			}
			break;
		case ARC_ITEM:
			for (iter = 0; (curticks = TickCount()) < stopticks; iter++) {
				EraseArc(&destrect, ARC_STARTANGLE, ARC_DEGREES);
			}
			break;
		default:
			DBUGPRINTF(("Unimplemented Erase Shape %d", gShape));
			break;
		}
		break;
	case INVERTSHAPE_ITEM:
		switch (gShape) {
		case RECTANGLE_ITEM:
			for (iter = 0; (curticks = TickCount()) < stopticks; iter++) {
				InvertRect(&destrect);
			}
			break;
		case REGION_ITEM:
			for (iter = 0; (curticks = TickCount()) < stopticks; iter++) {
				InvertRgn(rgnh);
			}
			break;
		case OVAL_ITEM:
			for (iter = 0; (curticks = TickCount()) < stopticks; iter++) {
				InvertOval(&destrect);
			}
			break;
		case ROUNDRECT_ITEM:
			for (iter = 0; (curticks = TickCount()) < stopticks; iter++) {
				InvertRoundRect(&destrect, RRECT_CURVATURE, RRECT_CURVATURE);
			}
			break;
		case ARC_ITEM:
			for (iter = 0; (curticks = TickCount()) < stopticks; iter++) {
				InvertArc(&destrect, ARC_STARTANGLE, ARC_DEGREES);
			}
			break;
		default:
			DBUGPRINTF(("Unimplemented Invert Shape %d", gShape));
			break;
		}
		break;
	case PATFILLSHAPE_ITEM:
		switch (gShape) {
		case RECTANGLE_ITEM:
			if (pixpath == nil) {
				for (iter = 0; (curticks = TickCount()) < stopticks; iter++) {
					FillRect(&destrect, &pat);
				}
			} else {
				for (iter = 0; (curticks = TickCount()) < stopticks; iter++) {
					FillCRect(&destrect, pixpath);
				}
			}
			break;
		case REGION_ITEM:
			if (pixpath == nil) {
				for (iter = 0; (curticks = TickCount()) < stopticks; iter++) {
					FillRgn(rgnh, &pat);
				}
			} else {
				for (iter = 0; (curticks = TickCount()) < stopticks; iter++) {
					FillCRgn(rgnh, pixpath);
				}
			}
			break;
		case OVAL_ITEM:
			if (pixpath == nil) {
				for (iter = 0; (curticks = TickCount()) < stopticks; iter++) {
					FillOval(&destrect, &pat);
				}
			} else {
				for (iter = 0; (curticks = TickCount()) < stopticks; iter++) {
					FillCOval(&destrect, pixpath);
				}
			}
			break;
		case ROUNDRECT_ITEM:
			if (pixpath == nil) {
				for (iter = 0; (curticks = TickCount()) < stopticks; iter++) {
					FillRoundRect(&destrect, RRECT_CURVATURE, RRECT_CURVATURE, &pat);
				}
			} else {
				for (iter = 0; (curticks = TickCount()) < stopticks; iter++) {
					FillCRoundRect(&destrect, RRECT_CURVATURE, RRECT_CURVATURE, pixpath);
				}
			}
			break;
		case ARC_ITEM:
			if (pixpath == nil) {
				for (iter = 0; (curticks = TickCount()) < stopticks; iter++) {
					FillArc(&destrect, ARC_STARTANGLE, ARC_DEGREES, &pat);
				}
			} else {
				for (iter = 0; (curticks = TickCount()) < stopticks; iter++) {
					FillCArc(&destrect, ARC_STARTANGLE, ARC_DEGREES, pixpath);
				}
			}
			break;
		default:
			DBUGPRINTF(("Unimplemented Pattern Fill Shape %d", gShape));
			break;
		}
		break;
	}

	gTestBeginTicks = beginticks;
	gTestEndTicks = curticks;
	gTestIterations = iter;

	/* Restore the foreground and background colors to black & white */
	coloritemtoRGB(BLACK_ITEM, &gFgOtherRGB, &foreRGB);
	coloritemtoRGB(WHITE_ITEM, &gBgOtherRGB, &backRGB);
	RGBForeColor(&foreRGB);
	RGBBackColor(&backRGB);

	/* Restore the default pen settings */
	PenNormal();

	ClipRect(&portrect);	// Restore the full clipping

	if (gDestLoc != WINDOW_ITEM) {	// Destination was offscreen
		SetGWorld(oldport, oldgdh);
		UnlockPixels(destpmh);
	}
}

static void runtest(UInt32 test)
{
	GrafPtr oldport;
	WindowPtr wind;

	if (gDestPictBufGW == nil || (gDestLoc != WINDOW_ITEM && gDestGW == nil)) {
		erroralert(CANTGETGWORLD_NDX);
		return;
	}
	if (gTest == COPYBITS_ITEM && gSepSrc) {
		if (gSrcPictBufGW == nil || (gSrcLoc != WINDOW_ITEM && gSrcGW == nil)) {
			erroralert(CANTGETGWORLD_NDX);
			return;
		}
	}

	if (!gNoRefresh && gDestLoc != WINDOW_ITEM)	// Destination is offscreen GWorld
		copyGWtoGW(gDestPictBufGW, gDestGW, gDitherDest);
	if (!gNoCursorHide)
		HideCursor();

	GetPort(&oldport);
	wind = gDestWind;
	SetPort(wind);
	if (!gNoRefresh || gDestLoc != WINDOW_ITEM)
		updatedestwind(wind);

	switch (test) {
	case COPYBITS_ITEM:
		docopybitstest(wind);
		break;
	case TEXT_ITEM:
		dotexttest(wind);
		break;
	case LINES_ITEM:
	case FRAMESHAPE_ITEM:
	case PAINTSHAPE_ITEM:
	case ERASESHAPE_ITEM:
	case INVERTSHAPE_ITEM:
	case PATFILLSHAPE_ITEM:
		doshapetest(wind, test);
		break;
	default:
		test = 0;
		break;
	}

	if (gDestLoc != WINDOW_ITEM)	// Destination is offscreen GWorld
		updatedestwind(wind);	// Show the changed pixels

	SetPort(oldport);
	if (!gNoCursorHide)
		ShowCursor();

	gLastTest = test;
	invalwind(gStatusWind);	// Update the timing statistics
}

static void showdialog(SInt32 resid)
{
	short itemhit;
	DialogPtr dlog;

	if ((dlog = GetNewDialog(resid, nil, (WindowPtr)-1)) == nil) {
		erroralert(CANTGETDLOG_NDX);
		return;
	}
	ModalDialog(nil, &itemhit);	/* Get all events until an active item is hit */
	DisposeDialog(dlog);		/* Get rid of the dialog */
}

static void setitemstate(MenuHandle menu, UInt32 item, UInt32 enable)
{
	if (enable)
		EnableItem(menu, item);
	else
		DisableItem(menu, item);
}

static void configmenus(void)
{
	UInt32 i, enable;
	WindowPtr wind;

	// Edit menu
	if ((wind = FrontWindow()) && ((WindowPeek)wind)->windowKind < 0) {
		// It's a DA window
		enable = true;
	} else {
		// We won't allow editing commands
		enable = false;
	}
	setitemstate(gEditMenu, UNDO_ITEM, enable);
	setitemstate(gEditMenu, CUT_ITEM, enable);
	setitemstate(gEditMenu, COPY_ITEM, true);
	setitemstate(gEditMenu, PASTE_ITEM, enable);
	setitemstate(gEditMenu, CLEAR_ITEM, enable);

	//  Test menu
	for (i = RECTANGLE_ITEM; i <= ARC_ITEM; i++)
		setitemstate(gTestMenu, i, gTest >= FRAMESHAPE_ITEM);
	enable = true;
	if (gTest == COPYBITS_ITEM || (gTest >= FRAMESHAPE_ITEM && gShape == REGION_ITEM))
		enable = false;
	setitemstate(gTestMenu, BOUNDRECT_ITEM, enable);
	enable = false;
	if (gTest >= FRAMESHAPE_ITEM && gShape == REGION_ITEM)
		enable = true;
	setitemstate(gTestMenu, RGNSHAPE_ITEM, enable);

	// Destination menu
	enable = true;
	if (gTest == INVERTSHAPE_ITEM || gTest == PATFILLSHAPE_ITEM)
		enable = false;
	setitemstate(gDestMenu, FGCOLOR_ITEM, enable);
	setitemstate(gDestMenu, BGCOLOR_ITEM, enable);
	setitemstate(gDestMenu, SWAPFGBG_ITEM, enable);
	setitemstate(gDestMenu, RESETCOLORS_ITEM, enable);
	enable = false;
	if (gTest == LINES_ITEM || gTest == FRAMESHAPE_ITEM)
		enable = true;
	setitemstate(gDestMenu, PENSIZE_ITEM, enable);
	enable = false;
	if (gTest == LINES_ITEM || gTest == FRAMESHAPE_ITEM ||
			gTest == PAINTSHAPE_ITEM)
		enable = true;
	setitemstate(gDestMenu, PENMODE_ITEM, enable);
	setitemstate(gDestMenu, PENPATTERN_ITEM, enable);
	setitemstate(gDestMenu, BGPATTERN_ITEM, gTest == ERASESHAPE_ITEM);
	setitemstate(gDestMenu, FILLPATTERN_ITEM, gTest == PATFILLSHAPE_ITEM);
	setitemstate(gDestMenu, CLIPRGN_ITEM, gUseClipRgn);

	// CopyBits menu
	for (i = SRCLOCATION_ITEM; i <= SRCDITHER_ITEM; i++)
		setitemstate(gCopyBitsMenu, i, gSepSrc);
	setitemstate(gCopyBitsMenu, MASKRGN_ITEM, gUseMaskRgn);
}

static void doapplemenu(UInt32 item)
{
	GrafPtr oldport;
	unsigned char str[256];

	if (item == ABOUT_ITEM) {
		showdialog(ABOUTDLOG_ID);
	} else {
		GetMenuItemText(gAppleMenu, item, str);	/* Get the DA name */
		GetPort(&oldport);		/* Preserve the current port in case the DA doesn't */
		OpenDeskAcc(str);		/* Open the DA */
		SetPort(oldport);		/* Restore the port */
	}
}

static void dofilemenu(UInt32 item)
{
	switch (item) {
	case QUIT_ITEM:
		gQuitFlag = true;	/* Set the flag so we leave the main event loop */
		break;
	}
}

static void docopy(void)
{

	SInt32 err;
	GrafPtr oldport;
	PicHandle pic;
	OpenCPicParams cpp;

	cpp.srcRect.top = 0;
	cpp.srcRect.left = 0;
	cpp.srcRect.bottom = 100;
	cpp.srcRect.right = 100;
	cpp.hRes = 0x00480000;
	cpp.vRes = 0x00480000;
	cpp.version = -2;
	cpp.reserved1 = 0;
	cpp.reserved2 = 0;
	GetPort(&oldport);
	SetPort(gDestWind);
	if ((pic = OpenCPicture(&cpp)) == nil) {
		DBUGSTR("OpenCPicture() failed");
		SetPort(oldport);	/* Restore the port */
		return;
	}
	ClipRect(&cpp.srcRect);
	/* Copy from the grafport to itself in order to record it */
	CopyBits((BitMap *)&gDestWind->portBits,
			 (BitMap *)&gDestWind->portBits,
			 &cpp.srcRect, &cpp.srcRect, srcCopy, nil);
#if 0
	MoveTo(2, 20);
DBUGSTR("About to call DrawString");
	DrawString("\pTest of a string!");
#endif
	ClosePicture();
	ClipRect(&gDestWind->portRect);

	if (*pic == nil) {
		DBUGSTR("Closed picture has null size");
		SetPort(oldport);	/* Restore the port */
		return;
	}

	HLock((Handle)pic);
	if (EmptyRect(&(*pic)->picFrame)) {	/* Did we run out of memory? */
		DBUGSTR("Closed picture has empty frame rectangle");
		KillPicture(pic);
		SetPort(oldport);	/* Restore the port */
		return;
	}
	ZeroScrap();
	err = PutScrap(GetHandleSize((Handle)pic), 'PICT', (Ptr)*pic);
	KillPicture(pic);
	if (err) {
		DBUGSTR("Error %d from PutScrap()");
		ZeroScrap();
	}
	SetPort(oldport);	/* Restore the port */
	return;
}

static void doeditmenu(UInt32 item)
{
	switch (item) {
	case COPY_ITEM:
		docopy();
		break;
	default:
		break;
	}
}

static SInt32 strtouint32(unsigned char *strp, UInt32 *valptr)
{
	UInt32 len, i, digits;
	long val;

	len = strp[0];
	strp++;
	i = 0;
	while (i < len) {	/* Ignore leading spaces */
		if (*strp != ' ')
			break;
		*strp++;
		i++;
	}
	digits = 0;
	val = 0;
	while (i < len && *strp >= '0' && *strp <= '9') {
		val = val * 10 + (*strp - '0');
		digits++;
		strp++;
		i++;
	}
	while (i < len) {	/* Ignore trailing spaces */
		if (*strp != ' ')
			break;
		*strp++;
		i++;
	}
	if (i < len || digits == 0 || digits > 9) {
		*valptr = 0;  /* Zero the number by default with errors!!! */
		return(1);
	} else {
		*valptr = val;
		return(0);
	}
}

static void doboundrectdlog(void)
{
	SInt16 itemhit, itemtype;
	UInt32 val, width, height;
	GrafPtr oldport;
	DialogPtr dlog;
	Handle horizitemh, vertitemh;
	Rect r;
	unsigned char str[256];

	if ((dlog = GetNewDialog(BOUNDRECTDLOG_ID, nil, (WindowPtr)-1)) == nil) {
		erroralert(CANTGETDLOG_NDX);
		return;
	}

	GetPort(&oldport);
	SetPort(dlog);

	dimtowh(gDestDim, &width, &height);

	GetDialogItem(dlog, HORIZ_BRDITM, &itemtype, &horizitemh, &r);
	GetDialogItem(dlog, VERT_BRDITM, &itemtype, &vertitemh, &r);
	uint32todstr(gBoundRectHInset, str);
	SetDialogItemText(horizitemh, str);
	uint32todstr(gBoundRectVInset, str);
	SetDialogItemText(vertitemh, str);
	/* Select the first editText item */
	SelectDialogItemText(dlog, HORIZ_BRDITM, 0, 32767);

	ShowWindow(dlog);

	do {
		ModalDialog(nil, &itemhit);
		switch (itemhit) {
		case OK_BRDITM:
			GetDialogItemText(horizitemh, str);
			if (strtouint32(str, &val) || val > (width/2 - 1)) {
				SysBeep(BEEPTICKS);
				uint32todstr(RECTINSET, str);
				SetDialogItemText(horizitemh, str);
				SelectDialogItemText(dlog, HORIZ_BRDITM, 0, 32767);
				break;
			}
			gBoundRectHInset = val;
			GetDialogItemText(vertitemh, str);
			if (strtouint32(str, &val) || val > (height/2 - 1)) {
				SysBeep(BEEPTICKS);
				uint32todstr(RECTINSET, str);
				SetDialogItemText(vertitemh, str);
				SelectDialogItemText(dlog, VERT_BRDITM, 0, 32767);
				break;
			}
			gBoundRectVInset = val;
			break;
		}
	} while (itemhit != OK_BRDITM);

	SetPort(oldport);
	DisposeDialog(dlog);
}

static void dotestmenu(UInt32 item)
{
	MenuHandle menu1, menu2;

	switch (item) {
	case RUN_ITEM:
		runtest(gTest);
		break;
	case NOREFRESH_ITEM:
		gNoRefresh = !gNoRefresh;
		CheckItem(gTestMenu, item, gNoRefresh);
		break;
	case NOCURSORHIDE_ITEM:
		gNoCursorHide = !gNoCursorHide;
		CheckItem(gTestMenu, item, gNoCursorHide);
		break;
	case COPYBITS_ITEM:
	case LINES_ITEM:
	case TEXT_ITEM:
	case FRAMESHAPE_ITEM:
	case PAINTSHAPE_ITEM:
	case ERASESHAPE_ITEM:
	case INVERTSHAPE_ITEM:
	case PATFILLSHAPE_ITEM:
		if (item == gTest)	// No change, we're done
			break;
		/* We're choosing a new test */
		CheckItem(gTestMenu, gTest, false);
		CheckItem(gTestMenu, item, true);
		menu1 = nil;
		if (gTest == COPYBITS_ITEM) {
			menu1 = gCopyBitsMenu;
		} else if (gTest == LINES_ITEM) {
			menu1 = gLinesMenu;
		} else if (gTest == TEXT_ITEM) {
			menu1 = gTextMenu;
		}
		if (menu1)
			DisableItem(menu1, 0);

		menu2 = nil;
		if (item == COPYBITS_ITEM) {
			menu2 = gCopyBitsMenu;
		} else if (item == LINES_ITEM) {
			menu2 = gLinesMenu;
		} else if (item == TEXT_ITEM) {
			menu2 = gTextMenu;
		}
		if (menu2)
			EnableItem(menu2, 0);
		if (menu1 || menu2)
			InvalMenuBar();
		gTest = item;
		break;
	case RECTANGLE_ITEM:
	case REGION_ITEM:
	case OVAL_ITEM:
	case ROUNDRECT_ITEM:
	case ARC_ITEM:
	case POLYGON_ITEM:
		if (item == gShape)	// No change, we're done
			break;
		CheckItem(gTestMenu, gShape, false);
		CheckItem(gTestMenu, item, true);
		gShape = item;
		break;
	case BOUNDRECT_ITEM:
		doboundrectdlog();
		break;
	}
}

static void dodestmenu(UInt32 item)
{
	UInt32 saveitem;

	switch (item) {
	case DESTDITHER_ITEM:
		gDitherDest = !gDitherDest;
		CheckItem(gDestMenu, DESTDITHER_ITEM, gDitherDest);
		if (gDestLoc != WINDOW_ITEM) {	// Destination is offscreen GWorld
			if (gDestPictBufGW == nil || gDestGW == nil)
				break;
			copyGWtoGW(gDestPictBufGW, gDestGW, gDitherDest);
		}
		invalwind(gDestWind);	// Invalidate so it redraws
		break;
	case SWAPFGBG_ITEM:
		gSwapFgBg = !gSwapFgBg;
		CheckItem(gDestMenu, SWAPFGBG_ITEM, gSwapFgBg);
		CheckItem(gFgColorMenu, gFgColor, false);
		CheckItem(gBgColorMenu, gBgColor, false);
		saveitem = gFgColor;
		gFgColor = gBgColor;
		gBgColor = saveitem;
		CheckItem(gFgColorMenu, gFgColor, true);
		CheckItem(gBgColorMenu, gBgColor, true);
		/* Keep 'Other' RGB values properly maintained */
		if (gFgColor == OTHERCOLOR_ITEM) {
			if (gSwapFgBg) {
				gFgSaveRGB = gFgOtherRGB;
				gFgOtherRGB = gBgOtherRGB;
			} else {
				gFgOtherRGB = gFgSaveRGB;
			}
		}
		if (gBgColor == OTHERCOLOR_ITEM) {
			if (gSwapFgBg) {
				gBgSaveRGB = gBgOtherRGB;
				gBgOtherRGB = gFgOtherRGB;
			} else {
				gBgOtherRGB = gBgSaveRGB;
			}
		}
		break;
	case RESETCOLORS_ITEM:
		gSwapFgBg = false;
		CheckItem(gDestMenu, SWAPFGBG_ITEM, false);
		CheckItem(gFgColorMenu, gFgColor, false);
		CheckItem(gBgColorMenu, gBgColor, false);
		gFgColor = BLACK_ITEM;
		gBgColor = WHITE_ITEM;
		CheckItem(gFgColorMenu, BLACK_ITEM, true);
		CheckItem(gBgColorMenu, WHITE_ITEM, true);
		break;
	case USECLIPRGN_ITEM:
		gUseClipRgn = !gUseClipRgn;
		CheckItem(gDestMenu, USECLIPRGN_ITEM, gUseClipRgn);
		break;
	case CLIPRGN_ITEM:
		DBUGPRINTF(("CLIPRGN_ITEM: supposed to be a hierarchical menu!!"));
		break;
	}
}

static void docopybitsmenu(UInt32 item)
{
	SInt32 err;
	UInt32 width, height;
	Rect r;

	switch (item) {
	case USESEPSRC_ITEM:
		gSepSrc = !gSepSrc;
		CheckItem(gCopyBitsMenu, USESEPSRC_ITEM, gSepSrc);
		if (gSepSrc) {
			dimtowh(gSrcDim, &width, &height);
			SizeWindow(gSrcWind, width, height, false);
			r = gSrcWind->portRect;
			/* Allocate the GWorld in main memory (keepLocal) */
			if ((err = NewGWorld(&gSrcPictBufGW, 32, &r, nil, nil, keepLocal)) != noErr) {
				erroralert(CANTGETGWORLD_NDX);
				break;
			}
			if (gSrcLoc != WINDOW_ITEM) {	// Source is offscreen GWorld
				if ((err = allocgworld(gSrcLoc, &r, &gSrcGW)) != 0) {
					erroralert(err);
					break;
				}
			}
			if ((err = drawpicttogworld(gSrcImage, gSrcPictBufGW)) != 0) {
				erroralert(err);
				break;
			}
			if (gSrcLoc != WINDOW_ITEM)	// Source is offscreen GWorld
				copyGWtoGW(gSrcPictBufGW, gSrcGW, gDitherSrc);
			ShowWindow(gSrcWind);
		} else {
			if (gSrcGW) {
				DisposeGWorld(gSrcGW);
				gSrcGW = nil;
			}
			if (gSrcPictBufGW) {	// Dispose of source picture buffer GWorld
				DisposeGWorld(gSrcPictBufGW);
				gSrcPictBufGW = nil;
			}
			HideWindow(gSrcWind);
		}
		break;
	case SRCDITHER_ITEM:
		gDitherSrc = !gDitherSrc;
		CheckItem(gCopyBitsMenu, SRCDITHER_ITEM, gDitherSrc);
		if (gSrcLoc != WINDOW_ITEM) {	// Source is offscreen GWorld
			if (gSrcPictBufGW == nil || gSrcGW == nil)
				break;
			copyGWtoGW(gSrcPictBufGW, gSrcGW, gDitherSrc);
		}
		invalwind(gSrcWind);	// Invalidate so it redraws
		break;
	case USEMASKRGN_ITEM:
		gUseMaskRgn = !gUseMaskRgn;
		CheckItem(gCopyBitsMenu, USEMASKRGN_ITEM, gUseMaskRgn);
		break;
	}
}

static void dolinesmenu(UInt32 item)
{
	if (item == gLines)	// No change, we're done
		return;
	/* We're choosing a new line type */
	CheckItem(gLinesMenu, gLines, false);
	CheckItem(gLinesMenu, item, true);
	gLines = item;
}

static void dotextmenu(UInt32 item)
{
	switch (item) {
	case STRING_ITEM:
		break;
	}
}

// Return non-zero if two Pascal-style strings are equal
static int pstrequal(unsigned char *strp1, unsigned char *strp2)
{
	int len, i;

	len = *strp1;	// Length byte
	for (i = 0; i <= len; i++) {	// Make sure the length bytes match, too
		if (strp1[i] != strp2[i])	// If they don't match, return zero
			return(0);
	}
	return(1);	// The length and the string characters are the same, return non-zero
}

static void dolutdither(void)
{
	int drvrrefnum;
	GrafPtr oldport;
	GDHandle gdh;
	GDPtr gdp;
	PixMapPtr pmp;
	unsigned int utableindex;
	AuxDCEHandle *unittable;
	AuxDCEPtr dcep;
	DRVRHeaderPtr drvrhdrp;
	Rect wr;
	static unsigned char *drivername = "\p.Display_NV";

	for (gdh = GetDeviceList(); gdh != nil; gdh = GetNextDevice(gdh)) {
		drvrrefnum = (*gdh)->gdRefNum;	// Signed number (should always be negative)
		utableindex = ~drvrrefnum;		// Convert negative refnum to positive Unit Table index
		unittable = (AuxDCEHandle *)LMGetUTableBase();	// Get the base address of the Unit Table
		dcep = *(unittable[utableindex]);	// Index into the table to get the handle to our AuxDCE
		drvrhdrp = (DRVRHeaderPtr)dcep->dCtlDriver;	// Get a pointer or handle to our driver header
		if (dcep->dCtlFlags & dRAMBasedMask)		// Means it was a handle, not a pointer
			drvrhdrp = *(DRVRHeaderHandle)drvrhdrp;	// De-reference to get the pointer
		if (pstrequal(drvrhdrp->drvrName, drivername))
			goto gotgdev;
	}
	erroralert(CANTGETNVBOARD_NDX);
	return;

gotgdev:
	pmp = *(*gdh)->gdPMap;
	if (pmp->pixelSize != 32) {
		erroralert(NEEDMILLIONS_NDX);
		return;
	}
	wr = gDestWind->portRect;
	GetPort(&oldport);
	SetPort(gDestWind);
	LocalToGlobal((Point *)&wr.top);
	LocalToGlobal((Point *)&wr.bottom);
	SetPort(oldport);
	// See if the window's global content rect is contained within the NV gdRect
	gdp = *gdh;
	if (wr.top < gdp->gdRect.top || wr.left < gdp->gdRect.left ||
			wr.bottom > gdp->gdRect.bottom || wr.right > gdp->gdRect.right) {
		erroralert(DESTNOTONNV_NDX);
		return;
	}
	// Now we have the destination window entirely on the 32-bit NVIDIA screen.
	
}

static void dospatialdither(void)
{
}

static void doexpmenu(UInt32 item)
{
	switch (item) {
	case LUTDITHER_ITEM:
		dolutdither();
		break;
	case SPATIALDITHER_ITEM:
		dospatialdither();
		break;
	}
}

static void dorgnshapemenu(UInt32 item)
{
	if (item == gRgnShape)	// No change, we're done
		return;
	/* We're choosing a new region */
	CheckItem(gRgnShapeMenu, gRgnShape, false);
	CheckItem(gRgnShapeMenu, item, true);
	gRgnShape = item;
}

static void docliprgnmenu(UInt32 item)
{
	if (item == gClipRgn)	// No change, we're done
		return;
	/* We're choosing a new region */
	CheckItem(gClipRgnMenu, gClipRgn, false);
	CheckItem(gClipRgnMenu, item, true);
	gClipRgn = item;
}

static void domaskrgnmenu(UInt32 item)
{
	if (item == gMaskRgn)	// No change, we're done
		return;
	/* We're choosing a new region */
	CheckItem(gMaskRgnMenu, gMaskRgn, false);
	CheckItem(gMaskRgnMenu, item, true);
	gMaskRgn = item;
}

static void dodestlocmenu(UInt32 item)
{
	SInt32 err;

	if (item == gDestLoc)	// No change, we're done
		return;
	/* We're choosing a new dest image location */
	CheckItem(gDestLocMenu, gDestLoc, false);
	CheckItem(gDestLocMenu, item, true);
	if (gDestLoc != WINDOW_ITEM) {	// Destination is offscreen GWorld
		if (gDestGW) {
			DisposeGWorld(gDestGW);
			gDestGW = nil;
		}
	}
	if (gDestPictBufGW == nil)
		return;
	if (item != WINDOW_ITEM) {	// New destination is offscreen GWorld
		if ((err = allocgworld(item, &gDestPictBufGW->portRect, &gDestGW)) != 0) {
			erroralert(err);
			return;
		}
		copyGWtoGW(gDestPictBufGW, gDestGW, gDitherDest);
	}
	gDestLoc = item;
	/* Invalidate the destination window so it will redraw */
	invalwind(gDestWind);
	setlocdimtitle(gDestWind);
}

static void dodestdimmenu(UInt32 item)
{
	SInt32 err;
	UInt32 width, height;
	Rect r;

	if (item == gDestDim)	// No change, we're done
		return;
	/* We're choosing new dest image dimensions */
	CheckItem(gDestDimMenu, gDestDim, false);
	CheckItem(gDestDimMenu, item, true);
	gDestDim = item;
	if (gDestLoc != WINDOW_ITEM) {	// Destination is offscreen GWorld
		if (gDestGW) {
			DisposeGWorld(gDestGW);
			gDestGW = nil;
		}
	}
	if (gDestPictBufGW) {	// Dispose of destination picture buffer GWorld
		DisposeGWorld(gDestPictBufGW);
		gDestPictBufGW = nil;
	}
	dimtowh(gDestDim, &width, &height);
	r.top = 0;
	r.left = 0;
	r.bottom = height;
	r.right = width;
	/* Allocate the GWorld in main memory (keepLocal) */
	if ((err = NewGWorld(&gDestPictBufGW, 32, &r, nil, nil, keepLocal)) != 0) {
		erroralert(CANTGETGWORLD_NDX);
		return;
	}
	if (gDestLoc != WINDOW_ITEM) {	// Destination is offscreen GWorld
		if ((err = allocgworld(gDestLoc, &r, &gDestGW)) != 0) {
			erroralert(err);
			return;
		}
	}
	if ((err = drawpicttogworld(gDestImage, gDestPictBufGW)) != 0) {
		erroralert(err);
		return;
	}
	if (gDestLoc != WINDOW_ITEM)	// Destination is offscreen GWorld
		copyGWtoGW(gDestPictBufGW, gDestGW, gDitherDest);

	SizeWindow(gDestWind, width, height, false);
	/* Invalidate the destination window so it will redraw */
	invalwind(gDestWind);
	setlocdimtitle(gDestWind);
}

static void dodestimagemenu(UInt32 item)
{
	SInt32 err;

	if (item == gDestImage)	// No change, we're done
		return;
	/* We're choosing a new dest image */
	CheckItem(gDestImageMenu, gDestImage, false);
	CheckItem(gDestImageMenu, item, true);
	gDestImage = item;
	if (gDestPictBufGW == nil)
		return;
	if ((err = drawpicttogworld(gDestImage, gDestPictBufGW)) != 0) {
		erroralert(err);
		return;
	}
	if (gDestLoc != WINDOW_ITEM) {	// Destination is offscreen GWorld
		if (gDestGW == nil)
			return;
		copyGWtoGW(gDestPictBufGW, gDestGW, gDitherDest);
	}
	/* Invalidate the destination window so it will redraw */
	invalwind(gDestWind);
}

static void dofgcolormenu(UInt32 item)
{
	if (item == OTHERCOLOR_ITEM) {	// Do a new custom color
	} else if (item == gFgColor) {	// No change, we're done
		return;
	}
	gSwapFgBg = false;
	CheckItem(gDestMenu, SWAPFGBG_ITEM, false);
	/* We've chosen a new foreground color item */
	CheckItem(gFgColorMenu, gFgColor, false);
	CheckItem(gFgColorMenu, item, true);
	gFgColor = item;
}

static void dobgcolormenu(UInt32 item)
{
	if (item == OTHERCOLOR_ITEM) {	// Do a new custom color
	} else if (item == gBgColor) {	// No change, we're done
		return;
	}
	gSwapFgBg = false;
	CheckItem(gDestMenu, SWAPFGBG_ITEM, false);
	/* We've chosen a new background color item */
	CheckItem(gBgColorMenu, gBgColor, false);
	CheckItem(gBgColorMenu, item, true);
	gBgColor = item;
}

static void dopensizemenu(UInt32 item)
{
	if (item == gPenSize)	// No change, we're done
		return;
	/* We're choosing a new pen size */
	CheckItem(gPenSizeMenu, gPenSize, false);
	CheckItem(gPenSizeMenu, item, true);
	gPenSize = item;
}

static void dopenmodemenu(UInt32 item)
{
	switch (item) {
	case PATCOPY_ITEM:
	case PATOR_ITEM:
	case PATXOR_ITEM:
	case PATBIC_ITEM:
	case NOTPATCOPY_ITEM:
	case NOTPATOR_ITEM:
	case NOTPATXOR_ITEM:
	case NOTPATBIC_ITEM:
	case PATCOPYPLUSTRANSP_ITEM:
		if (item == gPenMode) // No change, we're done
			break;
		/* We're choosing a new pen mode */
		CheckItem(gPenModeMenu, gPenMode, false);
		CheckItem(gPenModeMenu, item, true);
		gPenMode = item;
		break;
	case PM_PLUSHILITE_ITEM:
		gPMPlusHilite = !gPMPlusHilite;
		CheckItem(gPenModeMenu, PM_PLUSHILITE_ITEM, gPMPlusHilite);
		break;
	}
}

static void dopenpatmenu(UInt32 item)
{
	if (item == gPenPat) // No change, we're done
		return;
	/* We're choosing a new pen pattern */
	CheckItem(gPenPatMenu, gPenPat, false);
	CheckItem(gPenPatMenu, item, true);
	gPenPat = item;
}

static void dobgpatmenu(UInt32 item)
{
	if (item == gBgPat) // No change, we're done
		return;
	/* We're choosing a new background pattern */
	CheckItem(gBgPatMenu, gBgPat, false);
	CheckItem(gBgPatMenu, item, true);
	gBgPat = item;
}

static void dofillpatmenu(UInt32 item)
{
	if (item == gFillPat) // No change, we're done
		return;
	/* We're choosing a new fill pattern */
	CheckItem(gFillPatMenu, gFillPat, false);
	CheckItem(gFillPatMenu, item, true);
	gFillPat = item;
}

static void dosrclocmenu(UInt32 item)
{
	SInt32 err;

	if (item == gSrcLoc) // No change, we're done
		return;
	/* We're choosing a new source image location */
	CheckItem(gSrcLocMenu, gSrcLoc, false);
	CheckItem(gSrcLocMenu, item, true);
	if (gSrcLoc != WINDOW_ITEM) {	// Source is offscreen GWorld
		if (gSrcGW) {
			DisposeGWorld(gSrcGW);
			gSrcGW = nil;
		}
	}
	if (gSrcPictBufGW == nil)
		return;
	if (item != WINDOW_ITEM) {	// New source is offscreen GWorld
		if ((err = allocgworld(item, &gSrcPictBufGW->portRect, &gSrcGW)) != 0) {
			erroralert(err);
			return;
		}
		copyGWtoGW(gSrcPictBufGW, gSrcGW, gDitherSrc);
	}
	gSrcLoc = item;
	/* Invalidate the source window so it will redraw */
	invalwind(gSrcWind);
	setlocdimtitle(gSrcWind);
}

static void dosrcdimmenu(UInt32 item)
{
	SInt32 err;
	UInt32 width, height;
	Rect r;

	if (item == gSrcDim) // No change, we're done
		return;
	/* We're choosing new source image dimensions */
	CheckItem(gSrcDimMenu, gSrcDim, false);
	CheckItem(gSrcDimMenu, item, true);
	gSrcDim = item;

	if (gSrcLoc != WINDOW_ITEM) {	// Source is offscreen GWorld
		if (gSrcGW) {
			DisposeGWorld(gSrcGW);
			gSrcGW = nil;
		}
	}
	if (gSrcPictBufGW) {	// Dispose of source picture buffer GWorld
		DisposeGWorld(gSrcPictBufGW);
		gSrcPictBufGW = nil;
	}
	dimtowh(gSrcDim, &width, &height);
	r.top = 0;
	r.left = 0;
	r.bottom = height;
	r.right = width;
	/* Allocate the GWorld in main memory (keepLocal) */
	if ((err = NewGWorld(&gSrcPictBufGW, 32, &r, nil, nil, keepLocal)) != 0) {
		erroralert(CANTGETGWORLD_NDX);
		return;
	}
	if (gSrcLoc != WINDOW_ITEM) {	// Source is offscreen GWorld
		if ((err = allocgworld(gSrcLoc, &r, &gSrcGW)) != 0) {
			erroralert(err);
			return;
		}
	}
	if ((err = drawpicttogworld(gSrcImage, gSrcPictBufGW)) != 0) {
		erroralert(err);
		return;
	}
	if (gSrcLoc != WINDOW_ITEM)	// Source is offscreen GWorld
		copyGWtoGW(gSrcPictBufGW, gSrcGW, gDitherSrc);

	SizeWindow(gSrcWind, width, height, false);
	/* Invalidate the source window so it will redraw */
	invalwind(gSrcWind);
	setlocdimtitle(gSrcWind);
}

static void dosrcimagemenu(UInt32 item)
{
	SInt32 err;

	if (item == gSrcImage) // No change, we're done
		return;
	/* We're choosing a new source image */
	CheckItem(gSrcImageMenu, gSrcImage, false);
	CheckItem(gSrcImageMenu, item, true);
	gSrcImage = item;
	if (gSrcPictBufGW == nil)
		return;
	if ((err = drawpicttogworld(gSrcImage, gSrcPictBufGW)) != 0) {
		erroralert(err);
		return;
	}
	if (gSrcLoc != WINDOW_ITEM) {	// Source is offscreen GWorld
		if (gSrcGW == nil)
			return;
		copyGWtoGW(gSrcPictBufGW, gSrcGW, gDitherSrc);
	}
	/* Invalidate the source window so it will redraw */
	invalwind(gSrcWind);
}

static void doxfermodemenu(UInt32 item)
{
	switch (item) {
	case X_SRCCOPY_ITEM:
	case X_SRCOR_ITEM:
	case X_SRCXOR_ITEM:
	case X_SRCBIC_ITEM:
	case X_NOTSRCCOPY_ITEM:
	case X_NOTSRCOR_ITEM:
	case X_NOTSRCXOR_ITEM:
	case X_NOTSRCBIC_ITEM:
	case X_ADDOVER_ITEM:
	case X_ADDPIN_ITEM:
	case X_SUBOVER_ITEM:
	case X_SUBPIN_ITEM:
	case X_ADMAX_ITEM:
	case X_ADMIN_ITEM:
	case X_BLEND_ITEM:
	case X_TRANSPARENT_ITEM:
	case X_HILITE_ITEM:
		if (item == gXferMode) // No change, we're done
			break;
		/* We're choosing a new transfer mode */
		CheckItem(gXferModeMenu, gXferMode, false);
		CheckItem(gXferModeMenu, item, true);
		gXferMode = item;
		break;
	case X_PLUSDITHER_ITEM:
		gXPlusDither = !gXPlusDither;
		CheckItem(gXferModeMenu, X_PLUSDITHER_ITEM, gXPlusDither);
		break;
	}
}

static void dosrcrectmenu(UInt32 item)
{
	if (item == OTHERRECT_ITEM) {	/* Do a new custom rectangle */
	}
	if (item == gSrcRect) // No change, we're done
		return;
	/* We've chosen a new source rect */
	CheckItem(gSrcRectMenu, gSrcRect, false);
	CheckItem(gSrcRectMenu, item, true);
	gSrcRect = item;
}

static void dodestrectmenu(UInt32 item)
{
	if (item == OTHERRECT_ITEM) {	/* Do a new custom rectangle */
	}
	if (item == gDestRect) // No change, we're done
		return;
	/* We've chosen a new dest rect */
	CheckItem(gDestRectMenu, gDestRect, false);
	CheckItem(gDestRectMenu, item, true);
	gDestRect = item;
}

static void dotextmodemenu(UInt32 item)
{
	switch (item) {
	case T_SRCCOPY_ITEM:
	case T_SRCOR_ITEM:
	case T_SRCXOR_ITEM:
	case T_SRCBIC_ITEM:
	case T_NOTSRCCOPY_ITEM:
	case T_NOTSRCOR_ITEM:
	case T_NOTSRCXOR_ITEM:
	case T_NOTSRCBIC_ITEM:
	case T_ADDOVER_ITEM:
	case T_ADDPIN_ITEM:
	case T_SUBOVER_ITEM:
	case T_SUBPIN_ITEM:
	case T_ADMAX_ITEM:
	case T_ADMIN_ITEM:
	case T_BLEND_ITEM:
	case T_TRANSPARENT_ITEM:
	case T_GRAYISHTEXTOR_ITEM:
		if (item == gTextMode) // No change, we're done
			break;
		/* We're choosing a new transfer mode */
		CheckItem(gTextModeMenu, gTextMode, false);
		CheckItem(gTextModeMenu, item, true);
		gTextMode = item;
		break;
	case T_PLUSHILITE_ITEM:
		gTPlusHilite = !gTPlusHilite;
		CheckItem(gTextModeMenu, T_PLUSHILITE_ITEM, gTPlusHilite);
		break;
	case T_PLUSMASK_ITEM:
		gTPlusMask = !gTPlusMask;
		CheckItem(gTextModeMenu, T_PLUSMASK_ITEM, gTPlusMask);
		break;
	}
}


static void menucmd(long menuitem, short what)	/* Execute the appropriate routine */
{
#pragma unused(what)
	UInt32 menu, item;		/* Menu ID and item number */

	menu = menuitem >> 16;
	item = (UInt16)menuitem; //# check generated code for this

	switch (menu) {
	case APPLEMENU_ID:
		doapplemenu(item);
		break;
	case FILEMENU_ID:
		dofilemenu(item);
		break;
	case EDITMENU_ID:
		doeditmenu(item);
		break;
	case TESTMENU_ID:
		dotestmenu(item);
		break;
	case DESTMENU_ID:
		dodestmenu(item);
		break;
	case COPYBITSMENU_ID:
		docopybitsmenu(item);
		break;
	case LINESMENU_ID:
		dolinesmenu(item);
		break;
	case TEXTMENU_ID:
		dotextmenu(item);
		break;
	case EXPMENU_ID:
		doexpmenu(item);
		break;
	case RGNSHAPEMENU_ID:
		dorgnshapemenu(item);
		break;
	case CLIPRGNMENU_ID:
		docliprgnmenu(item);
		break;
	case MASKRGNMENU_ID:
		domaskrgnmenu(item);
		break;
	case DESTLOCMENU_ID:
		dodestlocmenu(item);
		break;
	case DESTDIMMENU_ID:
		dodestdimmenu(item);
		break;
	case DESTIMAGEMENU_ID:
		dodestimagemenu(item);
		break;
	case FGCOLORMENU_ID:
		dofgcolormenu(item);
		break;
	case BGCOLORMENU_ID:
		dobgcolormenu(item);
		break;
	case PENSIZEMENU_ID:
		dopensizemenu(item);
		break;
	case PENMODEMENU_ID:
		dopenmodemenu(item);
		break;
	case PENPATMENU_ID:
		dopenpatmenu(item);
		break;
	case BGPATMENU_ID:
		dobgpatmenu(item);
		break;
	case FILLPATMENU_ID:
		dofillpatmenu(item);
		break;
	case SRCLOCMENU_ID:
		dosrclocmenu(item);
		break;
	case SRCDIMMENU_ID:
		dosrcdimmenu(item);
		break;
	case SRCIMAGEMENU_ID:
		dosrcimagemenu(item);
		break;
	case XFERMODEMENU_ID:
		doxfermodemenu(item);
		break;
	case SRCRECTMENU_ID:
		dosrcrectmenu(item);
		break;
	case DESTRECTMENU_ID:
		dodestrectmenu(item);
		break;
	case TEXTMODEMENU_ID:
		dotextmodemenu(item);
		break;
	}

	HiliteMenu(0);			/* Invert the menu title back to normal */
}

static void closewind(WindowPtr wind)
{
	if (wind == nil)	/* No visible windows */
		return;
	if (((WindowPeek)wind)->windowKind < 0) {	/* Negative windowKind: it's a DA */
		CloseDeskAcc(((WindowPeek)wind)->windowKind);	/* windowKind = DA's refnum */
		return;
	}
	HideWindow(wind);	// Could dispose of it if we're sure we don't need it again
}

static void mouseclick(EventRecord *eventp)
{
	short part;
	WindowPtr wind;

	part = FindWindow(eventp->where, &wind);
	switch (part) {		/* Switch on the "window part" */
	case inMenuBar:
		configmenus();	/* Make sure the appropriate items are selected */
		menucmd(MenuSelect(eventp->where), eventp->what);	/* Process the selection */
		break;
	case inSysWindow:	/* DA or other system window */
		SystemClick(eventp, wind);
		break;
	case inContent:		/* Click in the content area of some window */
		if (wind != FrontWindow())	/* Is the window clicked on in front? */
			SelectWindow(wind); 		/* If not, bring it forward now */
		break;
	case inDrag:
		/* screenBits.bounds for the rect constrains to all GDevices */
		DragWindow(wind, eventp->where, &qd.screenBits.bounds);
		break;
	case inGoAway:
		if (TrackGoAway(wind, eventp->where))
			closewind(wind);
		break;
	}
}

static void keypress(EventRecord *eventp)	/* Handles command-key keyboard events */
{
	short key;

	key = eventp->message & charCodeMask;
	if (eventp->modifiers & cmdKey) {	/* Is the command key down? */
		configmenus();	/* Make sure the appropriate items are selected */
		/* Process the menu equivalent of that command key (if any) */
		menucmd(MenuKey(key), eventp->what);
	} else {	/* Not a command key */
	}
}

static void dimtowh(UInt32 dimitem, UInt32 *widthp, UInt32 *heightp)
{
	switch (dimitem) {
	case DIM_512X384_ITEM:
		*widthp = 512;
		*heightp = 384;
		break;
	case DIM_600X450_ITEM:
		*widthp = 600;
		*heightp = 450;
		break;
	case DIM_640X480_ITEM:
		*widthp = 640;
		*heightp = 480;
		break;
	case DIM_1024X768_ITEM:
		*widthp = 1024;
		*heightp = 768;
		break;
	}
}

static void rectitemtorect(UInt32 rectitem, Rect *inr, Rect *otherr, Rect *outr)
{
	*outr = *inr;	// Copy the whole input rect as default

	switch (rectitem) {
	case TOP50_ITEM:
		outr->bottom = (inr->top + inr->bottom) / 2;
		break;
	case BOTTOM50_ITEM:
		outr->top = (inr->top + inr->bottom) / 2;
		break;
	case LEFT50_ITEM:
		outr->right = (inr->left + inr->right) / 2;
		break;
	case RIGHT50_ITEM:
		outr->left = (inr->left + inr->right) / 2;
		break;
	case TOP99_ITEM:
		outr->bottom = inr->bottom - 1;
		break;
	case BOTTOM99_ITEM:
		outr->top = inr->top + 1;
		break;
	case LEFT99_ITEM:
		outr->right = inr->right - 1;
		break;
	case RIGHT99_ITEM:
		outr->left = inr->left + 1;
		break;
	case FULLSIZE_ITEM:
		// *outr = *inr
		break;
	case OTHERRECT_ITEM:
		*outr = *otherr;
		/* Constrain the 'other' rectangle to legal boundaries */
		if (outr->top < inr->top || outr->top >= inr->bottom)
			outr->top = inr->top;
		if (outr->left < inr->left || outr->left >= inr->right)
			outr->left = inr->left;
		if (outr->bottom > inr->bottom || outr->bottom <= inr->top)
			outr->bottom = inr->bottom;
		if (outr->right > inr->right || outr->right <= inr->left)
			outr->right = inr->right;
		break;
	}
}

static SInt32 allocgworld(UInt32 item, Rect *rectp, GWorldPtr *gwpp)
{
	SInt32 err;
	UInt32 depth;
	CTabHandle cth;

	switch (item) {
	case OFFSCRN1BW_ITEM:
		depth = 1;
		cth = gCTab1BW;
		break;
	case OFFSCRN8G_ITEM:
		depth = 8;
		cth = gCTab8G;
		break;
	case OFFSCRN8C_ITEM:
		depth = 8;
		cth = gCTab8C;
		break;
	case OFFSCRN16C_ITEM:
		depth = 16;
		cth = nil;
		break;
	case OFFSCRN24C_ITEM:
		depth = 32;
		cth = nil;
		break;
	}
	/* Allocate the GWorld in main memory (keepLocal) */
	if ((err = NewGWorld(gwpp, depth, rectp, cth, nil, keepLocal)) != 0) {
		return(CANTGETGWORLD_NDX);
	}
	return(0);
}

static SInt32 drawpicttogworld(UInt32 pictitem, GWorldPtr gwp)
{
	SInt32 err;
	CGrafPtr oldport;
	GDHandle oldgdh;
	PixMapHandle pmh;
	PicHandle pich;

	err = 0;
	if ((pich = (PicHandle)Get1Resource('PICT', PICT_BASEID - 1 + pictitem)) == nil)
		err = CANTGETPICT_NDX;
	GetGWorld(&oldport, &oldgdh);
	/* Draw the picture into the GWorld */
	SetGWorld(gwp, nil);
	pmh = GetGWorldPixMap(gwp);
	if (LockPixels(pmh)) {	// Drawing with the PixMap is OK
		if (pich) {
			EraseRect(&gwp->portRect);	// Set to a known state
			DrawPicture(pich, &gwp->portRect);
		} else {	// No picture, so fill it with something
			FillRect(&gwp->portRect, &qd.ltGray);
		}
		UnlockPixels(pmh);
	}
	SetGWorld(oldport, oldgdh);
	ReleaseResource((Handle)pich);
	return(err);
}

static void copyGWtoGW(GWorldPtr srcgwp, GWorldPtr destgwp, UInt32 dither)
{
	UInt32 mode;
	CGrafPtr oldport;
	GDHandle oldgdh;
	PixMapHandle srcpmh, destpmh;

	mode = srcCopy;
	if (dither)
		mode = srcCopy+ditherCopy;
	GetGWorld(&oldport, &oldgdh);
	/* Draw the picture into the GWorld */
	SetGWorld(destgwp, nil);
	srcpmh = GetGWorldPixMap(srcgwp);
	destpmh = GetGWorldPixMap(destgwp);
	if (LockPixels(srcpmh)) {
		if (LockPixels(destpmh)) {
			CopyBits(&((GrafPtr)srcgwp)->portBits, &((GrafPtr)destgwp)->portBits,
					&srcgwp->portRect, &destgwp->portRect, mode, nil);
			UnlockPixels(destpmh);
		}
		UnlockPixels(srcpmh);
	}
	SetGWorld(oldport, oldgdh);
}

static void setlocdimtitle(WindowPtr wind)
{
	unsigned char str[256], locstr[128], menuitemstr[128];

	if (wind == gSrcWind) {
		if (gSrcLoc == WINDOW_ITEM) {
			GetMenuItemText(gSrcLocMenu, WINDOW_ITEM, locstr);
		} else {
			GetMenuItemText(gSrcLocMenu, gSrcLoc, menuitemstr);
			paramstr(locstr, SOURCELOC_NDX, menuitemstr, nil, nil, nil);
		}
		GetMenuItemText(gSrcDimMenu, gSrcDim, menuitemstr);
	} else {	// Must be destination
		if (gDestLoc == WINDOW_ITEM) {
			GetMenuItemText(gDestLocMenu, WINDOW_ITEM, locstr);
		} else {
			GetMenuItemText(gDestLocMenu, gDestLoc, menuitemstr);
			paramstr(locstr, DESTLOC_NDX, menuitemstr, nil, nil, nil);
		}
		GetMenuItemText(gDestDimMenu, gDestDim, menuitemstr);
	}
	paramstr(str, WINDTITLE_NDX, locstr, menuitemstr, nil, nil);
	SetWTitle(wind, str);
}

static SInt32 initdest(void)
{
	SInt32 err;
	UInt32 width, height;
	Rect r;

	/* We initially bring up the window in a hidden state */
	if ((gDestWind = (GrafPtr)GetNewCWindow(DESTWIND_ID, 0L, (WindowPtr)-1L)) == nil)
		return(CANTGETWIND_NDX);
	dimtowh(gDestDim, &width, &height);
	SizeWindow(gDestWind, width, height, false);
	keepwindowonmain(gDestWind);	// Make sure it's not off the main display
	setlocdimtitle(gDestWind);

	if ((gCTab1BW = GetCTable(33)) == nil)	// 1-bit black & white table
		return(CANTGETCTABLE_NDX);
	if ((gCTab8G = GetCTable(40)) == nil)	// 8-bit gray-scale table
		return(CANTGETCTABLE_NDX);
	if ((gCTab8C = GetCTable(72)) == nil)	// 8-bit standard color table
		return(CANTGETCTABLE_NDX);

	r = gDestWind->portRect;
	/* Allocate the GWorld in main memory (keepLocal) */
	if ((err = NewGWorld(&gDestPictBufGW, 32, &r, nil, nil, keepLocal)) != 0) {
		return(CANTGETGWORLD_NDX);
	}
	if (gDestLoc != WINDOW_ITEM) {	// Destination is offscreen GWorld
		if ((err = allocgworld(gDestLoc, &r, &gDestGW)) != 0)
			return(err);
	}
	if ((err = drawpicttogworld(gDestImage, gDestPictBufGW)) != 0)
		return(err);
	if (gDestLoc != WINDOW_ITEM)	// Destination is offscreen GWorld
		copyGWtoGW(gDestPictBufGW, gDestGW, gDitherDest);
	return(0);
}

static void cleanupdest(void)
{
	if (gDestGW) {
		DisposeGWorld(gDestGW);
		gDestGW = nil;
	}
	if (gDestPictBufGW) {	// Dispose of destination picture buffer GWorld
		DisposeGWorld(gDestPictBufGW);
		gDestPictBufGW = nil;
	}
	DisposeCTable(gCTab8C);	// Dispose of the color tables we allocated
	DisposeCTable(gCTab8G);
	DisposeCTable(gCTab1BW);
	DisposeWindow(gDestWind);
}

static SInt32 initsource(void)
{
	SInt32 err;
	UInt32 width, height;
	Rect r;

	/* We initially bring up the window in a hidden state */
	if ((gSrcWind = (GrafPtr)GetNewCWindow(SOURCEWIND_ID, 0L, (WindowPtr)0L)) == nil)
		return(CANTGETWIND_NDX);
	dimtowh(gSrcDim, &width, &height);
	SizeWindow(gSrcWind, width, height, false);
	keepwindowonmain(gSrcWind);	// Make sure it's not off the main display
	setlocdimtitle(gSrcWind);

	if (!gSepSrc)	// No separate source, so we're done
		return(0);

	r = gSrcWind->portRect;
	/* Allocate the GWorld in main memory (keepLocal) */
	if ((err = NewGWorld(&gSrcPictBufGW, 32, &r, nil, nil, keepLocal)) != 0) {
		return(CANTGETGWORLD_NDX);
	}
	if (gSrcLoc != WINDOW_ITEM) {	// Source is offscreen GWorld
		if ((err = allocgworld(gSrcLoc, &r, &gSrcGW)) != 0)
			return(err);
	}
	if ((err = drawpicttogworld(gSrcImage, gSrcPictBufGW)) != 0)
		return(err);
	if (gSrcLoc != WINDOW_ITEM)	// Source is offscreen GWorld
		copyGWtoGW(gSrcPictBufGW, gSrcGW, gDitherSrc);
	return(0);
}

static void cleanupsrc(void)
{
	if (gSrcGW) {
		DisposeGWorld(gSrcGW);
		gSrcGW = nil;
	}
	if (gSrcPictBufGW) {	// Dispose of source picture buffer GWorld
		DisposeGWorld(gSrcPictBufGW);
		gSrcPictBufGW = nil;
	}
	DisposeWindow(gSrcWind);
}

static SInt32 initstatus(void)
{
	/* We initially bring up the window in a hidden state */
	if ((gStatusWind = (GrafPtr)GetNewCWindow(STATUSWIND_ID, 0L, (WindowPtr)0L)) == nil)
		return(CANTGETWIND_NDX);
	keepwindowonmain(gStatusWind);	// Make sure it's not off the main display
	return(0);
}

static void cleanupstatus(void)
{
	DisposeWindow(gStatusWind);
}

static SInt32 initregions(void)
{
	SInt32 err;
#define NUMPOLYPTS	17
	static SInt16 polypts[NUMPOLYPTS] = {
		0x0022, 0x001E, 0x001E, 0x0172, 0x023A, 0x0172, 0x001E, 0x0172,
		0x023A, 0x001E, 0x01B3, 0x0168, 0x012C, 0x001E, 0x00A5, 0x0172,
		0x001E
	};
	Rect maskrgnovalrect;
	static Rect bigrect = { 50, 50, 400, 550 };
	static Rect medrect = { 100, 100, 350, 500 };
	static Rect smallrect = { 150, 150, 300, 450 };
	PolyHandle polyh;
	RgnHandle rgnh, rgn2h;

	maskrgnovalrect = gDestWind->portRect;
	InsetRect(&maskrgnovalrect, 40, 140);

	/* Set up triangles and oval region */
	if ((polyh = (PolyHandle)NewHandle(NUMPOLYPTS*sizeof(SInt16))) == nil)
		return(CANTGETREGION_NDX);
	BlockMove((Ptr)polypts, (Ptr)*polyh, NUMPOLYPTS*sizeof(SInt16));
	if ((rgnh = NewRgn()) == nil)
		return(CANTGETREGION_NDX);
	OpenRgn();
	FramePoly(polyh);
	FrameOval(&maskrgnovalrect);
	CloseRgn(rgnh);
	err = QDError();
	DisposeHandle((Handle)polyh);
	if (err)
		return(CANTGETREGION_NDX);
	gRgnh[TRIOVALRGN_ITEM] = rgnh;

	/* Set up rounded rectangle region */
	if ((rgnh = NewRgn()) == nil)
		return(CANTGETREGION_NDX);
	OpenRgn();
	FrameRoundRect(&bigrect, RRECT_CURVATURE, RRECT_CURVATURE);
	CloseRgn(rgnh);
	err = QDError();
	if (err)
		return(CANTGETREGION_NDX);
	gRgnh[RRECTRGN_ITEM] = rgnh;

	/* Set up rectangle with hole region */
	if ((rgnh = NewRgn()) == nil)
		return(CANTGETREGION_NDX);
	OpenRgn();
	FrameRect(&bigrect);
	CloseRgn(rgnh);
	err = QDError();
	if (err)
		return(CANTGETREGION_NDX);
	if ((rgn2h = NewRgn()) == nil)
		return(CANTGETREGION_NDX);
	OpenRgn();
	FrameRect(&medrect);
	CloseRgn(rgn2h);
	err = QDError();
	if (err)
		return(CANTGETREGION_NDX);
	DiffRgn(rgnh, rgn2h, rgnh);
	DisposeRgn(rgn2h);
	gRgnh[RECTHOLERGN_ITEM] = rgnh;

	/* Set up the medium rectangular region */
	if ((rgnh = NewRgn()) == nil)
		return(CANTGETREGION_NDX);
	OpenRgn();
	FrameRect(&medrect);
	CloseRgn(rgnh);
	err = QDError();
	if (err)
		return(CANTGETREGION_NDX);
	gRgnh[MEDRECTRGN_ITEM] = rgnh;

	/* Set up the small rectangular region */
	if ((rgnh = NewRgn()) == nil)
		return(CANTGETREGION_NDX);
	OpenRgn();
	FrameRect(&smallrect);
	CloseRgn(rgnh);
	err = QDError();
	if (err)
		return(CANTGETREGION_NDX);
	gRgnh[SMALLRECTRGN_ITEM] = rgnh;

	/* Set up the empty region */
	if ((rgnh = NewRgn()) == nil)
		return(CANTGETREGION_NDX);
	OpenRgn();
	CloseRgn(rgnh);	// Open and Close Region with no other operations makes an empty region
	err = QDError();
	if (err)
		return(CANTGETREGION_NDX);
	gRgnh[EMPTYRGN_ITEM] = rgnh;

	return(0);
}

static void updatedestwind(WindowPtr wind)
{
	UInt32 mode;
	GWorldPtr gwp;
	PixMapHandle pmh;

	mode = srcCopy;	// Default
	if (gDestLoc == WINDOW_ITEM) {
		if (gDitherDest)
			mode = srcCopy+ditherCopy;
		gwp = gDestPictBufGW;
	} else {	// Offscreen GWorld
		gwp = gDestGW;
	}
	if (gwp == nil) {	// Must have run out of memory
		FillRect(&wind->portRect, &qd.ltGray);
		return;
	}
	pmh = GetGWorldPixMap(gwp);
	if (LockPixels(pmh)) {	// Drawing with the PixMap is OK
		CopyBits(&((GrafPtr)gwp)->portBits, &wind->portBits,
				&gwp->portRect, &wind->portRect, mode, nil);
		UnlockPixels(pmh);
	}
//InvertRect(&wind->portRect);
}

static void updatesrcwind(WindowPtr wind)
{
	UInt32 mode;
	GWorldPtr gwp;
	PixMapHandle pmh;

	mode = srcCopy;	// Default
	if (gSrcLoc == WINDOW_ITEM) {
		if (gDitherSrc)
			mode = srcCopy+ditherCopy;
		gwp = gSrcPictBufGW;
	} else {	// Offscreen GWorld
		gwp = gSrcGW;
	}
	if (gwp == nil) {	// Must have run out of memory
		FillRect(&wind->portRect, &qd.ltGray);
		return;
	}
	pmh = GetGWorldPixMap(gwp);
	if (LockPixels(pmh)) {	// Drawing with the PixMap is OK
		CopyBits(&((GrafPtr)gwp)->portBits, &wind->portBits,
				&gwp->portRect, &wind->portRect, mode, nil);
		UnlockPixels(pmh);
	}
}

static void updatestatuswind(WindowPtr wind)
{
	Rect r1, r2;
	unsigned char str[256], teststr[128], numstr1[16], numstr2[16];

	if (gLastTest == 0) {	// No tests have been run yet
		EraseRect(&wind->portRect);
		return;
	}
	r1 = wind->portRect;
	r2 = r1;
	r1.bottom = (r1.top + r1.bottom) / 2;
	r2.top = r1.bottom;
	GetMenuItemText(gTestMenu, gLastTest, teststr);
	sint32todstr(gTestEndTicks-gTestBeginTicks, numstr1);
	sint32todstr(gTestIterations, numstr2);
	paramstr(str, TIMING_NDX, teststr, numstr1, numstr2, nil);
	TETextBox(&str[1], str[0], &r1, teFlushDefault);
	uint32tohstr(gTestDestAddr, numstr1);
	uint32tohstr(gTestSrcAddr, numstr2);
	paramstr(str, ADDR_NDX, numstr1, numstr2, nil, nil);
	TETextBox(&str[1], str[0], &r2, teFlushDefault);
}

static void updatewind(WindowPtr wind)
{
	UInt32 refcon;
	GrafPtr oldport;

	GetPort(&oldport);
	SetPort(wind);
	BeginUpdate(wind);

	refcon = GetWRefCon(wind);
	if (refcon == DESTWINDREFCON)
		updatedestwind(wind);
	else if (refcon == SRCWINDREFCON)
		updatesrcwind(wind);
	else if (refcon == STATUSWINDREFCON)
		updatestatuswind(wind);

	EndUpdate(wind);
	SetPort(oldport);
}

static void invalwind(WindowPtr wind)
{
	GrafPtr oldport;

	GetPort(&oldport);
	SetPort(wind);
	InvalRect(&wind->portRect);
	SetPort(oldport);
}

static void activatewind(WindowPtr wind, short activate)
{
#pragma unused(wind, activate)
}

static void doeventloop(void)
{
	Boolean isourevent;
	EventRecord mainevent;

	do {
		isourevent = WaitNextEvent(everyEvent, &mainevent, 45, nil);
		if (isourevent) {
			switch (mainevent.what) {
			case mouseDown:
				mouseclick(&mainevent);
				break;
			case keyDown:
			case autoKey: 
				keypress(&mainevent);
				break;
			case updateEvt:
				updatewind((WindowPtr)mainevent.message);
				break;
			case activateEvt:
				activatewind((WindowPtr)mainevent.message,
								(mainevent.modifiers & activeFlag) != 0);
				break;
			}
		}
	} while (!gQuitFlag);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\common\nv4\src\ddmini16.c ===
/*==========================================================================;
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *  Portions Copyright (C) 1995,1997 NVidia Corporation.  All Rights Reserved.
 *
 *  File:       ddmini16.c
 *  Content:    Windows95 Direct Draw driver
 *
 *  exported functions:
 *      ddEnable
 *      ddDisable
 *      Control
 *
 *  internal functions:
 *      FindMode
 *      GetRegInt
 *      GetFlatSel
 *
 *  public functions:
 *      none
 *
 ***************************************************************************/

#ifndef WINNT
#include "ddmini.h"
//#include "opengl.h"
#include "windows.h"
#else
#include "nv32.h"
#include "nvd3ddrv.h"
#endif // #ifdef WINNT
#include "nvcm.h"
#include "nvos.h"
#include "tvout.h"
#include  "escape.h"
#define  MSVC
#ifndef WINNT
#include "display.inc"
#endif // #ifndef WINNT
#ifdef  MULTI_MON
#include "nv432.h"
#include "nvrmarch.inc"
#include "nvddobj.h"
#endif  // MULTI_MON
#include "nvver.h"

#ifndef WINNT
#define NV_ERROR_NOTIFIER          0x0FF5
#define NV_DD_COMMON_DMA_BUFFER_SIZE 32768
#else // #ifdef WINNT
#define NV_ERROR_NOTIFIER           NV01_CONTEXT_DMA
#define SIZEOF_NVNOTIFICATION 16

//
// Redefine Obsolete class.
//
#ifdef NV01_CONTEXT_DMA_TO_MEMORY
#undef NV01_CONTEXT_DMA_TO_MEMORY
#endif // #ifdef NV01_CONTEXT_DMA_TO_MEMORY
#define NV01_CONTEXT_DMA_TO_MEMORY  NV01_CONTEXT_DMA
#endif // #ifdef WINNT


//
// Video RAM types
//
#define BUFFER_DRAM                     0
#define BUFFER_SGRAM                    1
#define BUFFER_SDRAM                    2
//
// Monitor types
//
#define NV_MONITOR_VGA                  0
#define NV_MONITOR_NTSC                 2
#define NV_MONITOR_PAL                  3
//
// TV Out Device
//
#define NV_TV_OUT_NO_DEVICE             0
#define NV_TV_OUT_CHRONTEL7003          1
#define NV_TV_OUT_BT868                 2
#define NV_TV_OUT_BT869                 3

typedef VIDEOPARAMETERS FAR *LPVIDEOPARAMETERS;

#ifndef  MULTI_MON  // Generate the old structure used by the old code

typedef struct {
    DWORD function;
    DWORD device;
    WORD  owner[2];
    DWORD type;
    DWORD depth;
    DWORD width;
    DWORD height;
    DWORD pitch;
    DWORD offset;
    DWORD size;
    DWORD address;
    DWORD limit;
    DWORD total;
    DWORD free;
    DWORD status;
} NVIOControl_ParamX;

#endif   // NOT MULTI_MON

#ifndef WINNT
extern void (FAR PASCAL *NVSYSCLOSE)(DWORD);
#ifdef  MULTI_MON
extern void (FAR PASCAL *NVALLOCBUFFER)(BYTE FAR *lpBufferFlat, BYTE FAR *lpBuffer, DWORD numPages, DWORD dwDeviceID);
#else   // MULTI_MON
extern void (FAR PASCAL *NVALLOCBUFFER)(BYTE FAR *lpBufferFlat, BYTE FAR *lpBuffer, DWORD numPages);
#endif  // MULTI_MON

#ifdef  MULTI_MON
extern DWORD (FAR PASCAL *NvGetConfig)(DWORD dwConfigID, DWORD dwDeviceID);
extern DWORD (FAR PASCAL *NvGetRAMInfo)(DWORD dwDeviceID);
extern DWORD (FAR PASCAL *NvGetScreenSize)(DWORD dwDeviceID);
extern DWORD (FAR PASCAL *NvGetFrameBufferInfo)(DWORD dwDeviceID);
extern DWORD (FAR PASCAL *NvGetDeviceBase)(DWORD, DWORD dwDeviceID);
extern DWORD (FAR PASCAL *NvGetDeviceLimit)(DWORD, DWORD dwDeviceID);
extern void (FAR PASCAL *Nv01AllocContextDma)(Alloc_Ctx_DMA_Param FAR *);
extern void (FAR PASCAL *Nv01Free)(NV01Free_Param FAR *);
#else   // MULTI_MON
extern DWORD (FAR PASCAL *NvGetConfig)(DWORD dwConfigID);
extern DWORD (FAR PASCAL *NvGetRAMInfo)(VOID);
extern DWORD (FAR PASCAL *NvGetScreenSize)(VOID);
extern DWORD (FAR PASCAL *NvGetFrameBufferInfo)(VOID);
extern DWORD (FAR PASCAL *NvGetDeviceBase)(DWORD);
extern DWORD (FAR PASCAL *NvGetDeviceLimit)(DWORD);
#endif  // MULTI_MON
extern DWORD (FAR PASCAL *NvIOControl)(DWORD Function, LPVOID pParameters);
extern WORD FAR PASCAL UnsDwordDiv(DWORD dividend, DWORD divisor);
extern DWORD FAR PASCAL UnsDwordMul(DWORD multiplicand, DWORD multiplier);
extern DWORD FAR PASCAL GetFlatAddress(DWORD);
extern DWORD FAR PASCAL SetMacrovisionMode(DWORD mode);
#else // #ifdef WINNT
#define NVALLOCBUFFER(pflatptr, nop, numpages, nop1) \
    (pflatptr) = EngAllocMem(FL_ZERO_MEMORY, (numpages) * 4096, ALLOC_TAG)

#define NV_ALLOC_CONTEXT_DMA(hPar, hObj, clas, fl, offs, sel, limlo, limhi) \
    NvAllocContextDma(lpDevice->hDriver, (hPar), (hObj), (clas), (fl), (offs), (limlo))
#define NvGetConfig(dwConfigID, dwDeviceID) \
    (NvConfigGet(lpDevice->hDriver, lpDevice->hClient, lpDevice->hDevice, dwConfigID, &lpDevice->DummyReturn) == NVOS13_STATUS_SUCCESS ? lpDevice->DummyReturn : 0)
#define NvGetRAMInfo(dwDeviceID)            \
    ((lpDevice->cbFrameBuf >> 19) << 20)
#define NvGetScreenSize(dwDeviceID) \
    ((lpDevice->cyScreen << 16) | (lpDevice->cxScreen & 0xffff))
#define NvGetFrameBufferInfo(dwDeviceID) \
    (lpDevice->cBitsPerPel)
#define NvGetDeviceBase(dev, dwDeviceID) \
    (lpDevice->NvBaseAddr)
#define NvGetDeviceLimit(dev, dwDeviceID) \
    (lpDevice->cbFrameBuf + 1)
#define NV01Free_Param  NVOS00_PARAMETERS
#define Nv01Free(param) \
    NvFree(lpDevice->hDriver, (ULONG)param.hRoot, (ULONG)param.hObjectParent, (ULONG)param.hObjectOld)
#define NVSYSCLOSE(channel) \
    NvFree(lpDevice->hDriver, lpDevice->hClient, lpDevice->hDevice, channel)
#define dmaD3DPusherNotifier \
    (lpDevice->dmaD3DPusherNotifier)
#define dmaGDIPusherNotifier \
    (lpDevice->NvSyncNotifierFlat)
#define UnsDwordDiv(a, b) \
    (a / b)
#define UnsDwordMul(a, b) \
    (a * b)
#endif // #ifdef WINNT



#ifndef WINNT
extern LONG FAR PASCAL Control32(DIBENGINE FAR *, UINT, LPVOID, LPVOID);
extern void (FAR PASCAL DepopulateOffscreenCache)(void);

extern WORD PASCAL wSurfaceBUSY;
extern DWORD PASCAL NV_ddDmaBuffer;
extern DWORD PASCAL dmaGDIPusherNotifier;
extern DWORD PASCAL dmaD3DPusherNotifier;
extern OFFSCREENINITPARAMS PASCAL offscreenData;
extern DDHALMODEINFO NEAR *ModeList;

extern DDHALMODEINFO NEAR *ModeList;
extern DDHALMODEINFO NEAR NV4VGAModeList[];
extern DDHALMODEINFO NEAR NV4NTSCModeList[];
extern DDHALMODEINFO NEAR NV4PALModeList[];
extern int numModes;
extern int numNV4VGAModes;
extern int numNV4PALModes;
extern int numNV4NTSCModes;
#endif // #ifndef WINNT

#ifndef WINNT
extern int PASCAL videoRamSize;
extern int PASCAL wMonitorType;
extern DWORD PASCAL dwTVOutDeviceID;
#else
extern int videoRamSize;
extern int wMonitorType;
extern DWORD dwTVOutDeviceID;
#endif

#ifdef  MULTI_MON
#ifndef WINNT
// Global variables for multimonitor support
extern  DWORD PASCAL dwRoot_Handle;         // From ENABLE.ASM - RM id for client
extern  DWORD PASCAL dwDevice_ID_Num;       // From ENABLE.ASM - RM id for display
extern  DWORD        dwDeviceHandle;        // From DRV2.C - VDD id for display
extern  WORD  PASCAL wFlatSelector;         // From ENABLE.ASM - Ring3 flat selector
#else
#define dwRoot_Handle (lpDevice->hClient)
#define dwDevice_ID_Num (lpDevice->ulDeviceReference)
#define wFlatSelector 0
#endif // #ifdef WINNT
#endif  // MULTI_MON

/***************************************************************************
 *
 * globals
 *
 ***************************************************************************/

int             firstTimeCall = 1;
#ifndef WINNT
GLOBALDATA      DriverData;
#else // #ifdef WINNT
#define DriverData (*(lpDevice->pDriverData))
#endif // #ifdef WINNT
DWORD           macrovisionKey = 0x9999;
DWORD           macrovisionMode = 0;

/***************************************************************************
 *
 * internal functions.
 *
 ***************************************************************************/

UINT  GetFlatSel(void);
BOOL  DDCreateDriverObject(BOOL bReset);

#ifndef WINNT
/***************************************************************************
 *
 * FindMode
 *
 *  search through the mode table and find a mode that matchs
 *  call the HWTestMode function in setmode.c to make sure the
 *  mode is valid.
 *
 *  returns mode number 0-N if we found a valid mode
 *  returns -1 if we cant find a valid mode.
 *
 ***************************************************************************/

int PASCAL FindMode(DWORD dwWidth, DWORD dwHeight, DWORD dwBPP)
{
    int i;

    for (i=0; ModeList[i].dwWidth!=0; i++)
    {
        if (ModeList[i].dwWidth == dwWidth &&
            ModeList[i].dwHeight == dwHeight &&
            ModeList[i].dwBPP == dwBPP &&
            HWTestMode(i))
        {
            return i;
        }
    }

    return -1;
}
#endif // #ifndef WINNT

/***************************************************************************
 *
 * ddEnable   called by Enable to enable the device and set the video mode
 *
 ***************************************************************************/
#ifndef WINNT
UINT FAR PASCAL _loadds ddEnable(LPVOID lpDevice, UINT style, LPSTR lpDeviceType, LPSTR lpOutput, LPVOID lpStuff)
#else
ULONG ddEnable(PDEV *lpDevice)
#endif // #ifdef WINNT
{
    int   ModeNumber = 0;
    DWORD dwResolutionX;
    DWORD dwResolutionY;
    DWORD dwBPP;
    DWORD dwFrameBufferInfo;
    DWORD dwResolutionInfo;
    DWORD mclk;
    DWORD videoRamType;
#ifdef  MULTI_MON
    NVOS00_PARAMETERS freeParams;
#endif  // MULTI_MON

    //
    // If firstTimeCall connect to NV Resource Manager
    //
    if (firstTimeCall) {
        DriverData.NvFirstCall = 1;    // let 32 bit DDraw driver know to reset NV
        DriverData.dwGlobalStructSize = sizeof(GLOBALDATA); // let 32 bit DDraw driver know current struct size

#ifdef  MULTI_MON
        DriverData.TotalVRAM = NvGetRAMInfo( dwDevice_ID_Num ) >> 16;
        DriverData.TotalVRAM <<= 20; // convert MB to bytes
        DriverData.dwRootHandle = dwRoot_Handle;
  #ifndef WINNT
        DriverData.dwDeviceHandle = dwDeviceHandle;
        DriverData.dwDeviceIDNum = dwDevice_ID_Num;
        DriverData.dwDeviceClass = dwDevice_ID_Num + (NV01_DEVICE_0 - 1); // RM numbering starts at 1
        NVALLOCBUFFER((BYTE FAR *)&DriverData.NvCommonDmaBufferFlat,
            (BYTE FAR *)&DriverData.lpNvDmaBuffer, 8, DriverData.dwDeviceIDNum);
  #else
        DriverData.dwDeviceHandle = (DWORD)lpDevice->hDevice;
        DriverData.dwDeviceIDNum = dwDevice_ID_Num;
        DriverData.dwDeviceClass = dwDevice_ID_Num + (NV01_DEVICE_0 - 1); // RM numbering starts at 1
        NVALLOCBUFFER((PVOID)DriverData.NvCommonDmaBufferFlat, 0, 8, 0);
  #endif // #ifdef WINNT

#else   // MULTI_MON
        DriverData.TotalVRAM = NvGetRAMInfo() >> 16;
        DriverData.TotalVRAM <<= 20; // convert MB to bytes

        NVALLOCBUFFER((BYTE FAR *)&DriverData.NvCommonDmaBufferFlat,
            (BYTE FAR *)&DriverData.lpNvDmaBuffer, 8);
#endif  // MULTI_MON

        if (DriverData.NvCommonDmaBufferFlat == 0)
            return FALSE;

#ifdef  MULTI_MON

        /*
         * Allocate the Context Dmas that don't change until this board gets disabled
         *    They are never freed by us, we depend on the root closure in WEP to
         *    destroy them for us when the display driver gets unloaded.
         */

        NV_ALLOC_CONTEXT_DMA(DriverData.dwRootHandle,
            NV_DD_DMA_CONTEXT_ERROR_TO_MEMORY,
            NV_ERROR_NOTIFIER,
            ALLOC_CTX_DMA_FLAGS_LOCKED_CACHED,
            (PVOID)DriverData.NvCommonDmaBufferFlat,
            (DWORD)wFlatSelector,
            SIZEOF_NVNOTIFICATION - 1, /* required size for notifier */
            0);

//        Nv01AllocContextDma((Alloc_Ctx_DMA_Param FAR *)&allocContextDmaParams);

//        if (allocContextDmaParams.status != ALLOC_CTX_DMA_STATUS_SUCCESS)
//            return FALSE;

        NV_ALLOC_CONTEXT_DMA(DriverData.dwRootHandle,
            NV_DD_DMA_TO_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY,
            NV01_CONTEXT_DMA,
            ALLOC_CTX_DMA_FLAGS_ACCESS_WRITE_ONLY,
            (PVOID)DriverData.NvCommonDmaBufferFlat,
            (DWORD)wFlatSelector,
            SIZEOF_NVNOTIFICATION - 1, /* required size for notifier */
            0);

//        Nv01AllocContextDma((Alloc_Ctx_DMA_Param FAR *)&allocContextDmaParams);

//        if (allocContextDmaParams.status != ALLOC_CTX_DMA_STATUS_SUCCESS)
//            return FALSE;

        NV_ALLOC_CONTEXT_DMA(DriverData.dwRootHandle,
            NV_DD_DMA_BUFFER_NOTIFIER_CONTEXT_DMA_TO_MEMORY,
            NV01_CONTEXT_DMA,
            ALLOC_CTX_DMA_FLAGS_ACCESS_WRITE_ONLY,
            (PVOID)DriverData.NvCommonDmaBufferFlat,
            (DWORD)wFlatSelector,
            (2 * SIZEOF_NVNOTIFICATION) - 1, /* required size for notifier */
            0);

//        Nv01AllocContextDma((Alloc_Ctx_DMA_Param FAR *)&allocContextDmaParams);

//        if (allocContextDmaParams.status != ALLOC_CTX_DMA_STATUS_SUCCESS)
//            return FALSE;

        NV_ALLOC_CONTEXT_DMA(DriverData.dwRootHandle,
            NV_DD_DMA_FROM_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY,
            NV01_CONTEXT_DMA,
            ALLOC_CTX_DMA_FLAGS_ACCESS_WRITE_ONLY,
            (PVOID)(DriverData.NvCommonDmaBufferFlat + (SIZEOF_NVNOTIFICATION << 1)),
            (DWORD)wFlatSelector,
            SIZEOF_NVNOTIFICATION - 1, /* required size for notifier */
            0);

//        Nv01AllocContextDma((Alloc_Ctx_DMA_Param FAR *)&allocContextDmaParams);
//
//        if (allocContextDmaParams.status != ALLOC_CTX_DMA_STATUS_SUCCESS)
//            return FALSE;

        NV_ALLOC_CONTEXT_DMA(DriverData.dwRootHandle,
            NV_DD_DMA_PUSHER_SYNC_NOTIFIER_CONTEXT_DMA_TO_MEMORY,
            NV01_CONTEXT_DMA,
            ALLOC_CTX_DMA_FLAGS_ACCESS_WRITE_ONLY,
            (PVOID)(DriverData.NvCommonDmaBufferFlat + (SIZEOF_NVNOTIFICATION << 1) +
            SIZEOF_NVNOTIFICATION),
            (DWORD)wFlatSelector,
            SIZEOF_NVNOTIFICATION - 1, /* required size for notifier */
            0);

//        Nv01AllocContextDma((Alloc_Ctx_DMA_Param FAR *)&allocContextDmaParams);
//
//        if (allocContextDmaParams.status != ALLOC_CTX_DMA_STATUS_SUCCESS)
//            return FALSE;

        NV_ALLOC_CONTEXT_DMA(DriverData.dwRootHandle,
            NV_DD_DMA_SYNC_NOTIFIER_CONTEXT_DMA_TO_MEMORY,
            NV01_CONTEXT_DMA,
            ALLOC_CTX_DMA_FLAGS_ACCESS_WRITE_ONLY,
            (PVOID)(DriverData.NvCommonDmaBufferFlat + (SIZEOF_NVNOTIFICATION << 2)),
            (DWORD)wFlatSelector,
            SIZEOF_NVNOTIFICATION - 1, /* required size for notifier */
            0);

//        Nv01AllocContextDma((Alloc_Ctx_DMA_Param FAR *)&allocContextDmaParams);
//
//        if (allocContextDmaParams.status != ALLOC_CTX_DMA_STATUS_SUCCESS)
//            return FALSE;

        NV_ALLOC_CONTEXT_DMA(DriverData.dwRootHandle,
            NV_DD_DMA_FLIP_PRIMARY_NOTIFIER_CONTEXT_DMA_TO_MEMORY,
            NV01_CONTEXT_DMA,
            ALLOC_CTX_DMA_FLAGS_ACCESS_WRITE_ONLY,
            (PVOID)(DriverData.NvCommonDmaBufferFlat + (SIZEOF_NVNOTIFICATION << 2) +
            SIZEOF_NVNOTIFICATION),
            (DWORD)wFlatSelector,
            (5 * SIZEOF_NVNOTIFICATION) - 1, /* required size for notifier */
            0);

//        Nv01AllocContextDma((Alloc_Ctx_DMA_Param FAR *)&allocContextDmaParams);
//
//        if (allocContextDmaParams.status != ALLOC_CTX_DMA_STATUS_SUCCESS)
//            return FALSE;

        NV_ALLOC_CONTEXT_DMA(DriverData.dwRootHandle,
            NV_DD_PIO_FLIP_OVERLAY_NOTIFIER_CONTEXT_DMA_TO_MEMORY,
            NV01_CONTEXT_DMA,
            ALLOC_CTX_DMA_FLAGS_ACCESS_WRITE_ONLY,
            (PVOID)(DriverData.NvCommonDmaBufferFlat + (SIZEOF_NVNOTIFICATION << 3) +
            (SIZEOF_NVNOTIFICATION << 1)),
            (DWORD)wFlatSelector,
            (5 * SIZEOF_NVNOTIFICATION) - 1, /* required size for notifier */
            0);

//        Nv01AllocContextDma((Alloc_Ctx_DMA_Param FAR *)&allocContextDmaParams);
//
//        if (allocContextDmaParams.status != ALLOC_CTX_DMA_STATUS_SUCCESS)
//            return FALSE;

        NV_ALLOC_CONTEXT_DMA(DriverData.dwRootHandle,
            NV_DD_DMA_CONTEXT_DMA_TO_SYSTEM_MEMORY,
            NV01_CONTEXT_DMA,
            ALLOC_CTX_DMA_FLAGS_ACCESS_WRITE_ONLY,
            (PVOID)DriverData.NvCommonDmaBufferFlat,
            (DWORD)wFlatSelector,
            NV_DD_COMMON_DMA_BUFFER_SIZE - 1,
            0);

//        Nv01AllocContextDma((Alloc_Ctx_DMA_Param FAR *)&allocContextDmaParams);
//
//        if (allocContextDmaParams.status != ALLOC_CTX_DMA_STATUS_SUCCESS)
//            return FALSE;

        NV_ALLOC_CONTEXT_DMA(DriverData.dwRootHandle,
            NV_DD_DMA_CONTEXT_DMA_FROM_SYSTEM_MEMORY,
            NV01_CONTEXT_DMA,
            ALLOC_CTX_DMA_FLAGS_ACCESS_READ_ONLY,
            (PVOID)DriverData.NvCommonDmaBufferFlat,
            (DWORD)wFlatSelector,
            NV_DD_COMMON_DMA_BUFFER_SIZE - 1,
            0);

//        Nv01AllocContextDma((Alloc_Ctx_DMA_Param FAR *)&allocContextDmaParams);
//
//        if (allocContextDmaParams.status != ALLOC_CTX_DMA_STATUS_SUCCESS)
//            return FALSE;

        /*
         * Let the 32 bit DDraw code know that the following Context Dmas have not yet
         * been allocated.
         */

        DriverData.dwVidMemCtxDmaSize = 0;
        DriverData.dwDmaPusherCtxDmaSize = 0;


#endif  /* MULTI_MON */

        DriverData.NvDevFlatDma = 0;
        DriverData.NvDmaPusherBufferHandle = 0;
        DriverData.NvDmaPusherBufferBase = 0;
        DriverData.NvDevVideoFlatPio = 0;
        DriverData.NvDevFlatVPE = 0;
        DriverData.DDrawVideoSurfaceCount = 0;
        DriverData.GARTLinearBase = 0;
        DriverData.GARTPhysicalBase = 0;
        DriverData.NvAGPDmaPusherBufferBase = 0;
        DriverData.NvDmaPusherBufferSize = 0;
        DriverData.NvDmaPusherBufferEnd = 0;

        // initialize mode switch counter
        DriverData.dwModeSwitchCount = 0;

        // initialize shared clip change counter
        DriverData.dwSharedClipChangeCount = 0;
        DriverData.dwDDMostRecentClipChangeCount = 0;

        DriverData.wDDrawActive = 0;

        DriverData.dwMacrovisionNavigatorID = 0;
#ifndef WINNT
        firstTimeCall = 0;
#endif
    } else {
#ifdef  MULTI_MON
        if (DriverData.NvDevFlatDma != 0) {
            freeParams.hRoot = DriverData.dwRootHandle;
            freeParams.hObjectParent = NV_WIN_DEVICE;
            freeParams.hObjectOld = NV_DD_DEV_DMA;

#ifndef WINNT
            Nv01Free((NV01Free_Param FAR *)&freeParams);
#else
            Nv01Free(&freeParams);
#endif

            DriverData.NvDevFlatDma = 0;
        }
        if (DriverData.NvDevVideoFlatPio != 0) {
            freeParams.hRoot = DriverData.dwRootHandle;
            freeParams.hObjectParent = NV_WIN_DEVICE;
            freeParams.hObjectOld = NV_DD_DEV_VIDEO;

#ifndef WINNT
            Nv01Free((NV01Free_Param FAR *)&freeParams);
#else
            Nv01Free(&freeParams);
#endif

            DriverData.NvDevVideoFlatPio = 0;
        }
        if (DriverData.NvDevFlatVPE != 0) {
            freeParams.hRoot = DriverData.dwRootHandle;
            freeParams.hObjectParent = NV_WIN_DEVICE;
            freeParams.hObjectOld = NV_DD_DEV_VPE;

#ifndef WINNT
            Nv01Free((NV01Free_Param FAR *)&freeParams);
#else
            Nv01Free(&freeParams);
#endif

            DriverData.NvDevFlatVPE = 0;
        }
#else   /* MULTI_MON */
        if (DriverData.NvDevFlatDma != 0) {
            NVSYSCLOSE(DriverData.NvDevFlatDma);
            DriverData.NvDevFlatDma = 0;
        }
        if (DriverData.NvDevVideoFlatPio != 0) {
            NVSYSCLOSE(DriverData.NvDevVideoFlatPio);
            DriverData.NvDevVideoFlatPio = 0;
        }
        if (DriverData.NvDevFlatVPE != 0) {
            NVSYSCLOSE(DriverData.NvDevFlatVPE);
            DriverData.NvDevFlatVPE = 0;
        }
#endif  /* MULTI_MON */
    }

#ifdef  MULTI_MON
    dwResolutionInfo  = NvGetScreenSize( DriverData.dwDeviceIDNum );
    dwFrameBufferInfo = NvGetFrameBufferInfo( DriverData.dwDeviceIDNum );
#else   // MULTI_MON
    dwResolutionInfo  = NvGetScreenSize();
    dwFrameBufferInfo = NvGetFrameBufferInfo();
#endif  // MULTI_MON
    dwResolutionX = LOWORD(dwResolutionInfo);
    dwResolutionY = HIWORD(dwResolutionInfo);
    dwBPP = dwFrameBufferInfo & 0xFFFF;

#ifdef  MULTI_MON
    mclk = NvGetConfig( NV_CFG_DAC_MEMORY_CLOCK, DriverData.dwDeviceIDNum );
    videoRamType = NvGetConfig( NV_CFG_RAM_TYPE, DriverData.dwDeviceIDNum );
#else   // MULTI_MON
    mclk = NvGetConfig( NV_CFG_DAC_MEMORY_CLOCK );
    videoRamType = NvGetConfig( NV_CFG_RAM_TYPE );
#endif  // MULTI_MON

#ifndef WINNT
    ModeList = &NV4VGAModeList[0];
    numModes = numNV4VGAModes;

    if (wMonitorType == NV_MONITOR_PAL) {
        ModeList = &NV4PALModeList[0];
        numModes = numNV4PALModes;
    }

    if (wMonitorType == NV_MONITOR_NTSC) {
        ModeList = &NV4NTSCModeList[0];
        numModes = numNV4NTSCModes;
    }

    //
    // see if the mode is valid.
    // if it is not a mode we can support we fail
    //
    ModeNumber = FindMode(dwResolutionX, dwResolutionY, dwBPP);

    //
    // InquireInfo means fill in a GDIINFO structure
    // that describes the mode and the capabilities of the device
    //
    // we call DIB_Enable() and modify the fields specific to our
    // driver.
    //
    // NOTE you should never set (ie assign to) the dpRasterCaps
    // or dpCaps1 fields.  you should set specific bits (|=val), or in
    // rare cases clear a bit (&=~val).
    //
    // return the size of the structure we filled in.
    //
    if (style == InquireInfo) {
        return TRUE;
    }
    //
    //  EnableDevice means actualy set the mode.
    //  return zero for fail, non zero for success.
    //
    if (style == EnableDevice)
#endif // #ifndef WINNT
    {
#ifndef WINNT
        DIBENGINE FAR *pde;
#endif // #ifndef WINNT

        //
        // call the code in setmode.c to set the mode
        //
        // if HWSetMode works we expect the following globals
        // to be set.
        //
        //      DriverData.TotalVRAM        ; total amount of VRAM
        //      DriverData.BaseAddress      ; *flat* address of frame buffer (if flat)
        //      DriverData.ScreenSel        ; selector to framebuffer (if vflatd)
        //

//        HWSetMode(ModeNumber);

#if defined(NVHP) && !defined(WINNT)
        if (ModeNumber >= 0)
        {
            //
            // Allocate the primary display surface from the heap.
            //

            //
            // First clear out anything lying around.
            //
#ifdef  MULTI_MON
            NVIOControl_Param   heapParams;


            heapParams.hRoot         = DriverData.dwRootHandle;
            heapParams.hObjectParent = NV_WIN_DEVICE;
            heapParams.owner         = (((DWORD)'NV') << 16) + 'DD';
#else   // MULTI_MON
            NVIOControl_ParamX  heapParams;


            heapParams.device   = 0;
            heapParams.owner[0] = 'DD';
            heapParams.owner[1] = 'NV';
#endif  // MULTI_MON
            heapParams.function = NVIOCONTROL_HEAP_PURGE;
            NvIOControl( NVIOCONTROL_ARCH_HEAP, (LPVOID)&heapParams );

            //
            // Allocate  primary surface.
            //
#ifdef  MULTI_MON
            heapParams.hRoot         = DriverData.dwRootHandle;
            heapParams.hObjectParent = NV_WIN_DEVICE;
            heapParams.owner         = (((DWORD)'NV') << 16) + 'DD';
#else   // MULTI_MON
            heapParams.device   = 0;
            heapParams.owner[0] = 'DD';
            heapParams.owner[1] = 'NV';
#endif  // MULTI_MON
            heapParams.function = NVIOCONTROL_HEAP_ALLOC_DEPTH_WIDTH_HEIGHT;
            heapParams.type     = NVIOCONTROL_TYPE_PRIMARY;
            heapParams.depth    = dwBPP;
            heapParams.width    = ModeList[ModeNumber].dwWidth;
            heapParams.height   = ModeList[ModeNumber].dwHeight;
            NvIOControl( NVIOCONTROL_ARCH_HEAP, (LPVOID)&heapParams );

            DriverData.BaseAddress    = heapParams.address;  // *flat* address
            DriverData.VideoHeapBase  = heapParams.limit + 1;
            DriverData.VideoHeapTotal = heapParams.free;
            DriverData.VideoHeapFree  = heapParams.free;
        }
#else   // NVHP
        // fill in the framebuffer address
#ifdef  MULTI_MON
#ifndef WINNT
        DriverData.BaseAddress = NvGetDeviceBase( NV_DEV_BUFFER_0, DriverData.dwDeviceIDNum ); // *flat* address
#else // WINNT
        DriverData.BaseAddress = 0;
#endif // #ifdef WINNT
#else   // MULTI_MON
        DriverData.BaseAddress = NvGetDeviceBase( NV_DEV_BUFFER_0 );  // *flat* address
#endif  // MULTI_MON
        if (ModeNumber >= 0)
#ifndef WINNT
            DriverData.VideoHeapBase = DriverData.BaseAddress +
                UnsDwordMul(ModeList[ModeNumber].lPitch, ModeList[ModeNumber].dwHeight);
#else
            DriverData.VideoHeapBase = DriverData.BaseAddress +
                UnsDwordMul(lpDevice->lDelta, lpDevice->cyScreen);
 #endif // #ifdef WINNT

#endif  // NVHP

#ifdef  MULTI_MON
#ifndef WINNT
        DriverData.NvBaseFlat = NvGetDeviceBase( NV_DEV_BASE, DriverData.dwDeviceIDNum );  // *flat* address
#else
        DriverData.NvBaseFlat = (DWORD)lpDevice->NvBaseAddr;
#endif // #ifdef WINNT
#else   // MULTI_MON
        DriverData.NvBaseFlat = NvGetDeviceBase( NV_DEV_BASE );  // *flat* address
#endif  // MULTI_MON
        DriverData.ScreenSel     = GetFlatSel();
        DriverData.flatSelector = (USHORT)GetFlatSel();
#ifdef  MULTI_MON
        dwResolutionInfo = NvGetScreenSize( DriverData.dwDeviceIDNum );
        dwFrameBufferInfo = NvGetFrameBufferInfo( DriverData.dwDeviceIDNum );
#else   // MULTI_MON
        dwResolutionInfo = NvGetScreenSize();
        dwFrameBufferInfo = NvGetFrameBufferInfo();
#endif  // MULTI_MON

        dwFrameBufferInfo &= 0xFFFF;

        if (dwFrameBufferInfo == 8) { // Pixel depth
            DriverData.physicalColorMask = 0xFF;
        } else if (dwFrameBufferInfo == 16) {
            DriverData.physicalColorMask = 0xFFFF;
        } else if (dwFrameBufferInfo == 32) {
            DriverData.physicalColorMask = 0xFFFFFF;
        }

#ifdef  MULTI_MON
#ifndef WINNT
        DriverData.VideoHeapEnd = NvGetDeviceLimit( NV_DEV_BUFFER_0, DriverData.dwDeviceIDNum );
#else
        DriverData.VideoHeapEnd = lpDevice->cbFrameBuf - 1;
#endif // #ifdef WINNT
#else   // MULTI_MON
        DriverData.VideoHeapEnd = NvGetDeviceLimit( NV_DEV_BUFFER_0 );
#endif  // MULTI_MON
#ifndef WINNT
        /* Let display driver caching mechanism know it's usable range */
        offscreenData.left   = 0;
        offscreenData.top    = (unsigned short) dwResolutionY;

        if (ModeNumber >= 0)
            DriverData.maxOffScreenY =
                UnsDwordDiv(DriverData.VideoHeapEnd, ModeList[ModeNumber].lPitch);
#else

//
// Now initialized in ResetNV
//
DriverData.maxOffScreenY =
            UnsDwordDiv(DriverData.VideoHeapEnd, lpDevice->lDelta);
#endif // #ifdef WINNT

#ifndef WINNT
        offscreenData.right  = (unsigned short) dwResolutionX;
        offscreenData.bottom = (unsigned short) DriverData.maxOffScreenY;
#endif // #ifndef WINNT
        DriverData.VideoHeapEnd += DriverData.BaseAddress;

        //
        // now fill in a BITMAPINFO that describes our mode
        // and call the DIBENG function CreateDIBPDevice to
        // fill in our PDevice
        //
        DriverData.bi.biSize        = sizeof(BITMAPINFOHEADER);
        DriverData.bi.biPlanes      = 1;
#ifdef WINNT
        DriverData.bi.biWidth       = lpDevice->cxScreen;
        DriverData.bi.biHeight      = lpDevice->cyScreen;
        DriverData.bi.biBitCount    = (USHORT)lpDevice->cBitsPerPel;
        DriverData.bi.biCompression = 0;
        DriverData.color_table[0]   = lpDevice->flRed;
        DriverData.color_table[1]   = lpDevice->flGreen;
        DriverData.color_table[2]   = lpDevice->flBlue;
#else // #ifndef WINNT
        if (ModeNumber >= 0) {
            DriverData.bi.biWidth       = ModeList[ModeNumber].dwWidth;
            DriverData.bi.biHeight      = ModeList[ModeNumber].dwHeight;
            DriverData.bi.biBitCount    = (BYTE)ModeList[ModeNumber].dwBPP;
            DriverData.bi.biCompression = 0; // ModeList[ModeNumber].dwBPP <= 8 ? 0 : 3;
            DriverData.color_table[0]   = ModeList[ModeNumber].dwRBitMask;
            DriverData.color_table[1]   = ModeList[ModeNumber].dwGBitMask;
            DriverData.color_table[2]   = ModeList[ModeNumber].dwBBitMask;
        } else {
            DriverData.ModeNumber       = ModeNumber; // 32 bit code needs this
            DriverData.bi.biWidth       = dwResolutionInfo & 0xFFFF;
            DriverData.bi.biHeight      = dwResolutionInfo >> 16;
            DriverData.bi.biBitCount = (BYTE)dwBPP;
            DriverData.bi.biCompression = 0; // ModeList[ModeNumber].dwBPP <= 8 ? 0 : 3;
            DriverData.NvPrevDepth = 0;
            return FALSE;
        }

        //
        //  set a few things in the DIBENGINE structure that CreateDIBPDevice
        //  did not do.
        //
        pde = (DIBENGINE FAR *)lpDevice;

        pde->deBitsSelector = (UINT)DriverData.ScreenSel;
        pde->deBits = (void NVFAR *)DriverData.BaseAddress;

        if (ModeNumber >= 0)
            pde->deDeltaScan = ModeList[ModeNumber].lPitch;

        pde->deDriverReserved = 0x42;
        pde->deBeginAccess = (void FAR *)BeginAccess;
        pde->deEndAccess = (void FAR *)EndAccess;

        if (dwFrameBufferInfo == 8)
            pde->deFlags |= PALETTIZED;
        else
            pde->deFlags &= ~PALETTIZED;

        if (dwFrameBufferInfo == 16)
            pde->deFlags |= FIVE6FIVE;
        else
            pde->deFlags &= ~FIVE6FIVE;

        pde->deFlags &= ~BUSY;       // device is not BUSY
        pde->deFlags &= ~BANKEDVRAM;
        wSurfaceBUSY = 0;
#endif // #ifndef WINNT
        //
        // Everything worked remember the mode number and the driver
        // PDevice and return success
        //
        DriverData.dwVersion = DDMINI_VERSION;
        DriverData.ModeNumber = ModeNumber;
#ifndef WINNT
        DriverData.lpPDevice = (void FAR *)lpDevice;
#else
        DriverData.lpPDevice = (DWORD)lpDevice;
#endif
        DriverData.fReset = TRUE;

        DriverData.fVidMemLocked = FALSE;

        //
        // Let 32 bit Direct Draw know that there are currently no external users
        // (like NVLIB, NVDDX, etc)
        //
        DriverData.fActiveExternalUser = FALSE;

        //
        // Let Direct Draw know about Display Driver's notifier
        //
        DriverData.NvWinDmaPusherNotifierFlat = (DWORD)dmaGDIPusherNotifier;

        //
        // Let Display Driver know about Direct Draw's DMA pusher sync notifier
        //
        dmaD3DPusherNotifier = (DWORD *)DriverData.NvCommonDmaBufferFlat;
        dmaD3DPusherNotifier += (SIZEOF_NVNOTIFICATION << 1) + SIZEOF_NVNOTIFICATION;
#ifndef WINNT
        //
        // Now re-register with DirectDraw so it knows all about the
        // new display mode.
        //
        if (DriverData.HALCallbacks.lpSetInfo)
        {
            DDCreateDriverObject(TRUE);
        }
#endif // #ifndef WINNT
        return TRUE;
    }

    return FALSE;
}

/***************************************************************************
 *
 * Disable
 *
 ***************************************************************************/
#ifndef WINNT
UINT FAR PASCAL _loadds ddDisable(DIBENGINE FAR *pde)
#else
UINT FAR PASCAL _loadds ddDisable(PDEV *lpDevice)
#endif
{
#ifdef  MULTI_MON
    NV01Free_Param freeParams;
#endif  // MULTI_MON

#ifndef WINNT
    pde->deFlags |= BUSY;       // device is BUSY
    wSurfaceBUSY = 1;
#else

    /*
     * Free the Context Dmas.
     */

    NvFree(DriverData.ppdev->hDriver,
        DriverData.dwRootHandle,
        DriverData.dwRootHandle,
        NV_DD_DMA_CONTEXT_ERROR_TO_MEMORY
        );

    NvFree(DriverData.ppdev->hDriver,
        DriverData.dwRootHandle,
        DriverData.dwRootHandle,
        NV_DD_DMA_TO_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY
        );

    NvFree(DriverData.ppdev->hDriver,
        DriverData.dwRootHandle,
        DriverData.dwRootHandle,
        NV_DD_DMA_BUFFER_NOTIFIER_CONTEXT_DMA_TO_MEMORY
        );

    NvFree(DriverData.ppdev->hDriver,
        DriverData.dwRootHandle,
        DriverData.dwRootHandle,
        NV_DD_DMA_FROM_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY
        );

    NvFree(DriverData.ppdev->hDriver,
        DriverData.dwRootHandle,
        DriverData.dwRootHandle,
        NV_DD_DMA_PUSHER_SYNC_NOTIFIER_CONTEXT_DMA_TO_MEMORY
        );

    NvFree(DriverData.ppdev->hDriver,
        DriverData.dwRootHandle,
        DriverData.dwRootHandle,
        NV_DD_DMA_SYNC_NOTIFIER_CONTEXT_DMA_TO_MEMORY
        );

    NvFree(DriverData.ppdev->hDriver,
        DriverData.dwRootHandle,
        DriverData.dwRootHandle,
        NV_DD_DMA_FLIP_PRIMARY_NOTIFIER_CONTEXT_DMA_TO_MEMORY
        );

    NvFree(DriverData.ppdev->hDriver,
        DriverData.dwRootHandle,
        DriverData.dwRootHandle,
        NV_DD_PIO_FLIP_OVERLAY_NOTIFIER_CONTEXT_DMA_TO_MEMORY
        );

    NvFree(DriverData.ppdev->hDriver,
        DriverData.dwRootHandle,
        DriverData.dwRootHandle,
        NV_DD_DMA_CONTEXT_DMA_TO_SYSTEM_MEMORY
        );

    NvFree(DriverData.ppdev->hDriver,
        DriverData.dwRootHandle,
        DriverData.dwRootHandle,
        NV_DD_DMA_CONTEXT_DMA_FROM_SYSTEM_MEMORY
        );

    /*
     * If this is WINNT we need to free per device common DMA buffer
     * which under Win9x is freed when the 16 bit driver instance (created
     * for each device) is destroyed.
     */
    if (DriverData.NvCommonDmaBufferFlat != 0) {
        EngFreeMem((PVOID)DriverData.NvCommonDmaBufferFlat);
        DriverData.NvCommonDmaBufferFlat = 0;
    }

    /*
     * Under WINNT we also need to free the DMA push buffer, which under
     * Win9x is freed by the 16 bit display driver's WEP exit point.
     */
    if (DriverData.NvDmaPusherBufferHandle != 0) {
        EngFreeMem((PVOID)DriverData.NvDmaPusherBufferBase);
        DriverData.NvDmaPusherBufferHandle =
        DriverData.NvDmaPusherBufferBase = 0;
    }

#endif // #ifdef WINNT

    DriverData.ModeNumber = 0xDEADDEAD;

#ifdef  MULTI_MON
        if (DriverData.NvDevFlatDma != 0) {
            freeParams.hRoot = DriverData.dwRootHandle;
            freeParams.hObjectParent = NV_WIN_DEVICE;
            freeParams.hObjectOld = NV_DD_DEV_DMA;

            Nv01Free((NV01Free_Param FAR *)&freeParams);

            DriverData.NvDevFlatDma = 0;
        }
        if (DriverData.NvDevVideoFlatPio != 0) {
            freeParams.hRoot = DriverData.dwRootHandle;
            freeParams.hObjectParent = NV_WIN_DEVICE;
            freeParams.hObjectOld = NV_DD_DEV_VIDEO;

            Nv01Free((NV01Free_Param FAR *)&freeParams);

            DriverData.NvDevVideoFlatPio = 0;
        }
        if (DriverData.NvDevFlatVPE != 0) {
            freeParams.hRoot = DriverData.dwRootHandle;
            freeParams.hObjectParent = NV_WIN_DEVICE;
            freeParams.hObjectOld = NV_DD_DEV_VPE;

            Nv01Free((NV01Free_Param FAR *)&freeParams);

            DriverData.NvDevFlatVPE = 0;
        }
#else   /* MULTI_MON */
        if (DriverData.NvDevFlatDma != 0) {
            NVSYSCLOSE(DriverData.NvDevFlatDma);
            DriverData.NvDevFlatDma = 0;
        }
        if (DriverData.NvDevVideoFlatPio != 0) {
            NVSYSCLOSE(DriverData.NvDevVideoFlatPio);
            DriverData.NvDevVideoFlatPio = 0;
        }
        if (DriverData.NvDevFlatVPE != 0) {
            NVSYSCLOSE(DriverData.NvDevFlatVPE);
            DriverData.NvDevFlatVPE = 0;
        }
#endif  /* MULTI_MON */

#if defined(NVHP) && !defined(WINNT)
    {

#ifdef  MULTI_MON
        NVIOControl_Param   heapParams;

        heapParams.hRoot         = DriverData.dwRootHandle;
        heapParams.hObjectParent = NV_WIN_DEVICE;
        heapParams.owner         = (((DWORD)'NV') << 16) + 'DD';
#else   // MULTI_MON
        NVIOControl_ParamX  heapParams;

        heapParams.device   = 0;
        heapParams.owner[0] = 'DD';
        heapParams.owner[1] = 'NV';
#endif  // MULTI_MON
        heapParams.function = NVIOCONTROL_HEAP_PURGE;
        NvIOControl( NVIOCONTROL_ARCH_HEAP, (LPVOID)&heapParams );
    }
#endif  // NVHP

    return 1;
}
#ifndef WINNT
/***************************************************************************
 *
 * BeginAccess
 *
 ***************************************************************************/

void FAR PASCAL _loadds BeginAccess(DIBENGINE FAR *pde, int left, int top, int right, int bottom, UINT flags)
{
    // call device specific code to access the frame buffer

    //***********************************************************************
    // Call nvPixelDev because it will wait for the NV Engine to complete
    // before continuing on.  We simply do a GetPixel (specify DrawMode=0)
    //
    // lpDestDev         -> DWORD            Need to specify '5250' and VRAM
    // X = 10 ; Y = 20   -> 2 bytes each     Dummy values, no significance
    // Color = 30        -> DWORD            Dummy value, no significance
    // Drawmode = 0      -> DWORD            Drawmode = 0 means GetPixel
    //
    //***********************************************************************
    if (!DriverData.fVidMemLocked)
        HWBeginAccess(DriverData.lpPDevice,10,20,(DWORD)30,(DWORD)0);
}

/***************************************************************************
 *
 * EndAccess
 *
 ***************************************************************************/

void FAR PASCAL _loadds EndAccess(DIBENGINE FAR *pde, UINT flags)
{
    // call device specific code to release the frame buffer
    HWEndAccess();
}

/***************************************************************************
 *
 * Control
 *
 * this is what GDI calls when a app calles Escape or ExtEscape
 * if you dont handle a escape make sure to pass it to the DIBENG
 *
 ***************************************************************************/

LONG FAR PASCAL _loadds Control(
    DIBENGINE FAR * lpDevice,
    UINT            function,
    LPVOID          lpInput,
    LPVOID          lpOutput)
{
    DCICMD        FAR  *pdci;
    unsigned long FAR  *lpResult;
    LPVIDEOPARAMETERS   lpTVparams;

    switch (function)
    {
        case QUERYESCSUPPORT:

            //
            // QUERYESCSUPPORT is sent to ask
            // "do you support this" lpInput points
            // the function code to query
            //
            switch (*(UINT FAR *)lpInput)
            {
                // QUERYDIBSUPPORT MUST BE PASSED ON TO DIB ENGINE

                case DCICOMMAND:
                    return DD_HAL_VERSION;
                    break;

                case OPENGL_GETINFO:
                    return TRUE;  // return non-zero if supported
                    break;

                case OPENGL_CMD:
                    return FALSE; // return non-zero if supported
                    break;

                case VIDEO_PARAMETERS:
                    return TRUE;  // return non-zero if supported
                    break;

                case DVD_MACROVISION_CMD:
                    return TRUE;  // return non-zero if supported
                    break;


            }
            break;

        case GETNVCHANNELPTR:
            lpResult = (unsigned long FAR *)lpOutput;
            *lpResult = (unsigned long)DriverData.NvDevFlatDma;
            DriverData.fActiveExternalUser = TRUE; // NVLIB, NVDDX, etc. is active
            return TRUE;

        case NVGETAGPBASE:
            lpResult = (unsigned long FAR *)lpOutput;
            *lpResult = (DWORD)DriverData.GARTLinearBase;
            return TRUE;

        case NVDMAPUSHMODESWITCHCOUNT:
            lpResult = (unsigned long FAR *)lpOutput;
            *lpResult = (DWORD)
                GetFlatAddress((DWORD)((void FAR *)&(DriverData.dwModeSwitchCount)));
            return TRUE;

        case NVDMAPUSH3DOCCUR:
            lpResult = (unsigned long FAR *)lpOutput;
            *lpResult = (DWORD)
                GetFlatAddress((DWORD)((void FAR *)&(DriverData.ThreeDRenderingOccurred)));
            return TRUE;

        case NVDMAPUSHSYNCNOTIFIER:
            lpResult = (unsigned long FAR *)lpOutput;
            *lpResult = (unsigned long)DriverData.NvDmaPusherSyncNotifierFlat;
            return TRUE;

        case NV_ESC_DVD_MACROVISION_CMD: /* No NV3 generation chip supports Macrovision */
            if ((DriverData.dwMacrovisionNavigatorID != 0) &&
                (DriverData.dwMacrovisionNavigatorID != ((MACROVISION_INFO FAR *)lpInput)->dwMacrovisionNavigatorID)) {
                ((MACROVISION_INFO FAR *)lpOutput)->dwMacrovisionData = FOURCC_UBAD; /* Invalid Navigator ID */
                return FALSE;
            }
            if ((wMonitorType == NV_MONITOR_NTSC) || (wMonitorType == NV_MONITOR_PAL)) {
                if (DriverData.dwMacrovisionNavigatorID == 0) {
                    DriverData.dwMacrovisionNavigatorID = ((MACROVISION_INFO FAR *)lpInput)->dwMacrovisionNavigatorID;
                    return FALSE;
                }
            }
            return TRUE;

        case RECONFIGNVOFFSCREEN:
            DepopulateOffscreenCache(); // in misc.asm

            return TRUE;

        case NVSETDDRAWMODE:
            HWSetMode();  // in ddmode.c

            return TRUE;

        case OPENGL_GETINFO:
            if (*((unsigned long *) lpInput) == OPENGL_GETINFO_DRVNAME) {
                (void) lstrcpy(((LP_OPENGL_INFO) lpOutput)->awch, OPENGL_KEY_NAME );
                ((LP_OPENGL_INFO) lpOutput)->ulVersion = OPENGL_ICD_VER;            // DDI version
                ((LP_OPENGL_INFO) lpOutput)->ulDriverVersion = OPENGL_DRIVER_VER;   // driver version
                return TRUE;
            } else {
                return FALSE;
            }

        case OPENGL_CMD:
            return FALSE;

        case DCICOMMAND:
            pdci = (DCICMD FAR *)lpInput;

            if (pdci == NULL || pdci->dwVersion != DD_VERSION)
                break;

            /*
             * this request gives us our direct draw routines to call
             */
            if (pdci->dwCommand == DDNEWCALLBACKFNS) {
                DriverData.HALCallbacks = *((LPDDHALDDRAWFNS)pdci->dwParam1);
                return TRUE;
            }
            /*
             * return information about our 32-bit DLL
             *
             * we pass a pointer to our shared global Data
             * to the 32-bit driver so we can talk to each
             * other by reading each others mind.
             */
            else if (pdci->dwCommand == DDGET32BITDRIVERNAME) {
                LPDD32BITDRIVERDATA p32dd = (LPDD32BITDRIVERDATA)lpOutput;

                lstrcpy(p32dd->szName, DIRECTDRAW_DLLNAME);
                lstrcpy(p32dd->szEntryPoint, "DriverInit");
                p32dd->dwContext = GetFlatAddress((DWORD)((void FAR *)&DriverData));

                return TRUE;
            }
            /*
             * handle the request to create a driver
             * NOTE we must return our HINSTANCE in *lpOutput
             */
            else if (pdci->dwCommand == DDCREATEDRIVEROBJECT) {
                DDCreateDriverObject(FALSE);
                *(DWORD FAR *)lpOutput = DriverData.HALInfo.hInstance;
                return TRUE;
            }

            break;

        // This is the new Windows98 tv out API extension.
        case VIDEO_PARAMETERS:
            lpTVparams = ((LPVIDEOPARAMETERS) lpInput);

            switch (lpTVparams->dwCommand) {

                case VP_COMMAND_GET:

                    if (lpTVparams->dwFlags & VP_FLAGS_TV_MODE)
                        lpTVparams->dwMode = VP_MODE_WIN_GRAPHICS;

                    if (lpTVparams->dwFlags & VP_FLAGS_TV_STANDARD) {
                        lpTVparams->dwTVStandard = 0;

                        if (wMonitorType == NV_MONITOR_VGA)
                            lpTVparams->dwTVStandard = VP_TV_STANDARD_WIN_VGA;
                        else if (wMonitorType == NV_MONITOR_NTSC)
                            lpTVparams->dwTVStandard = VP_TV_STANDARD_NTSC_M;
                        else if (wMonitorType == NV_MONITOR_PAL)
                            lpTVparams->dwTVStandard = VP_TV_STANDARD_PAL_B;
                    }

                    lpTVparams->dwAvailableModes = VP_MODE_WIN_GRAPHICS;

                    lpTVparams->dwAvailableTVStandard = 0;

                    /* Currently we support only 1 mode at a time controlled by physical connections */
                    if (wMonitorType == NV_MONITOR_VGA)
                        lpTVparams->dwAvailableTVStandard = VP_TV_STANDARD_WIN_VGA;
                    else if (wMonitorType == NV_MONITOR_NTSC)
                        lpTVparams->dwAvailableTVStandard = VP_TV_STANDARD_NTSC_M;
                    else if (wMonitorType == NV_MONITOR_PAL)
                        lpTVparams->dwAvailableTVStandard = VP_TV_STANDARD_PAL_B;

                    if (lpTVparams->dwFlags & VP_FLAGS_FLICKER)
                        lpTVparams->dwFlickerFilter = 0;

                    if (lpTVparams->dwFlags & VP_FLAGS_OVERSCAN) {
                        lpTVparams->dwOverScanX = 0;
                        lpTVparams->dwOverScanY = 0;
                    }

                    if (lpTVparams->dwFlags & VP_FLAGS_MAX_UNSCALED) {
                        lpTVparams->dwMaxUnscaledX = DriverData.bi.biWidth;
                        lpTVparams->dwMaxUnscaledY = DriverData.bi.biHeight;
                    }

                    if (lpTVparams->dwFlags & VP_FLAGS_POSITION) {
                        lpTVparams->dwPositionX = 0;
                        lpTVparams->dwPositionY = 0;
                    }

                    if (lpTVparams->dwFlags & VP_FLAGS_BRIGHTNESS)
                        lpTVparams->dwBrightness = 100;

                    if (lpTVparams->dwFlags & VP_FLAGS_CONTRAST)
                        lpTVparams->dwContrast = 100;

                    if (lpTVparams->dwFlags & VP_FLAGS_COPYPROTECT) {
                        lpTVparams->dwCPType = 0;
                        lpTVparams->dwCPStandard = 0;

                        if (dwTVOutDeviceID == NV_TV_OUT_BT869) {
//                              lpTVparams->dwCPType = VP_CP_TYPE_APS_TRIGGER |
//                                                      VP_CP_TYPE_MACROVISION;
                            lpTVparams->dwCPType = VP_CP_TYPE_APS_TRIGGER;
                            lpTVparams->bCP_APSTriggerBits = macrovisionMode;
                            if (wMonitorType == NV_MONITOR_NTSC)
                                lpTVparams->dwCPStandard = VP_TV_STANDARD_NTSC_M;
                            else if (wMonitorType == NV_MONITOR_PAL)
                                lpTVparams->dwCPStandard = VP_TV_STANDARD_PAL_B;
                        }
                    }

                    return TRUE;
                    break;

                case VP_COMMAND_SET:

                    if (lpTVparams->dwFlags & VP_FLAGS_COPYPROTECT) {
                        /* If not connected to a device that supports Macrovision copy protection */
                        if (dwTVOutDeviceID != NV_TV_OUT_BT869) {
                            return FALSE;
                        }
                        /* Currently we only support APS trigger bits */
                        if (lpTVparams->dwCPType != VP_CP_TYPE_APS_TRIGGER)
                            return FALSE;

                        if (lpTVparams->dwCPCommand == VP_CP_CMD_ACTIVATE) {
                            macrovisionMode = lpTVparams->bCP_APSTriggerBits & 3;
                            if (SetMacrovisionMode(macrovisionMode)) {
                                lpTVparams->dwCPKey = macrovisionKey;
                                return TRUE;
                            }
                        } else if (lpTVparams->dwCPCommand == VP_CP_CMD_DEACTIVATE) {
                            if (lpTVparams->dwCPKey != macrovisionKey)
                                return FALSE;
                            macrovisionMode = 0;
                            if (SetMacrovisionMode(macrovisionMode))
                                return TRUE;
                        } else if (lpTVparams->dwCPCommand == VP_CP_CMD_CHANGE) {
                            if (lpTVparams->dwCPKey != macrovisionKey)
                                return FALSE;
                            macrovisionMode = lpTVparams->bCP_APSTriggerBits & 3;
                            if (SetMacrovisionMode(macrovisionMode))
                                return TRUE;
                        } else return FALSE;
                    }

                    return FALSE;
                    break;

                default:
                    return FALSE;
                    break;
            }

            break;

#ifdef  NV_ESCAPE_ID
        case NV_ESCAPE_ID:
            lpResult = (unsigned long FAR *)lpOutput;
            if (lpResult != NULL) {
                *lpResult = (unsigned long) NV_ESCAPE_ID_RETURN;
                return TRUE;
            } else
                return FALSE;
#endif  // NV_ESCAPE_ID

    }

    if (lpDevice != 0)
        return DIB_Control(lpDevice,function,lpInput,lpOutput);
    else
        return FALSE;
}

/***************************************************************************
 * GetRegInt
 *
 *   read a integer from the HKEY_CURRENT_CONFIG\Display\Settings
 *   key in the registy.
 *
 *   will read a string value and return a integer, if the string is of
 *   the form X,Y will return X<<16+Y
 *
 * Entry:
 *       valname     name of value to read (ie "Resolution")
 *       default     default value to use if not found (ie 0)
 *
 * Returns:
 *       int from registry, or default if not there
 *
 ***************************************************************************/

/*
DWORD GetRegInt(LPSTR valname, DWORD def)
{
    HKEY    hkey;
    char    ach[20];
    DWORD   cb;
    int     i;

    if (RegOpenKey(HKEY_CURRENT_CONFIG, "Display\\Settings", &hkey) == 0)
    {
        ach[0] = 0;
        cb = sizeof(ach);

        if (RegQueryValueEx(hkey, valname, NULL, NULL, ach, &cb) == 0)
        {
            for (def=i=0; ach[i]; i++)
            {
                if (ach[i] >= '0' && ach[i] <= '9')
                    *((WORD*)&def) = LOWORD(def) * 10 + ach[i]-'0';

                if (ach[i] == ',')
                    def = def << 16;
            }
        }

        RegCloseKey(hkey);
    }

    return def;
}
*/
#endif // #ifndef WINNT
/***************************************************************************
 * GetFlatSel
 ***************************************************************************/

UINT GetFlatSel()
{
#ifndef WINNT
    extern WORD PASCAL NVVD_API_DATA;
    return NVVD_API_DATA;
#else
    return(0);
#endif // #ifdef WINNT
}

#ifdef MSDEBUG

#define START_STR "DDMINI: "

void __cdecl DPF(LPSTR szFormat, ...)
{
    static int (WINAPI *fpwvsprintf)(LPSTR lpszOut, LPCSTR lpszFmt, const void FAR* lpParams);
    char        str[256];

    if (fpwvsprintf == NULL)
    {
        fpwvsprintf = (LPVOID) GetProcAddress(GetModuleHandle("USER"),"wvsprintf");
        if (fpwvsprintf == NULL)
            return;
    }

    lstrcpy(str, START_STR);
    fpwvsprintf(str+lstrlen(str), szFormat, (LPVOID)(&szFormat+1));
    lstrcat(str, "\r\n");
    OutputDebugString(str);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\common\NVUCL\matrix.h ===
/*
 * (C) Copyright NVIDIA Corporation Inc., 1996,1997,1998. All rights reserved.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: MATRIX.H                                                          *
*   Matrix private interface                                                *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Ben de Waal                 07/07/98 - Created                      *
*                                                                           *
\***************************************************************************/
#ifndef _matrix_h
#define _matrix_h

struct UCL_MATRIX : public NVUCL_MATRIX
{
    /*
     * exported
     */
public:
    NVUCL_RESULT NVUCL_STDCALL attach        (void);
    NVUCL_RESULT NVUCL_STDCALL detach        (void);

    NVUCL_RESULT NVUCL_STDCALL setStore      (float *pfAddress);
    NVUCL_RESULT NVUCL_STDCALL setUnit       (void);

    NVUCL_RESULT NVUCL_STDCALL setElement    (DWORD dwIndex,float  fValue);
    NVUCL_RESULT NVUCL_STDCALL setRow        (DWORD dwRow,  float *pfValue);
    NVUCL_RESULT NVUCL_STDCALL setAll        (float *pfValue);

    NVUCL_RESULT NVUCL_STDCALL getElement    (DWORD dwIndex,float *pfValue);
    NVUCL_RESULT NVUCL_STDCALL getRow        (DWORD dwRow,  float *pfValue);
    NVUCL_RESULT NVUCL_STDCALL getAll        (float *pfValue);

    NVUCL_RESULT NVUCL_STDCALL multiply      (void *pMatrix);
    NVUCL_RESULT NVUCL_STDCALL invert        (void);

    /*
     * private
     */
protected:
    /*
     * variables
     */
    float  m_fInternalStorage[16];
    float *m_fElement;
    DWORD  m_dwRefCount;
    enum e_Class { unit,rotation,translation,threebyfour,general } m_eClass;

    /*
     * methods
     */
    void classify (void);

    /*
     * construction
     */
public:
    UCL_MATRIX (void);
};

#endif //_matrix_h
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\common\NVUCL\disasm.cpp ===
/*
 * (C) Copyright NVIDIA Corporation Inc., 1996,1997,1998. All rights reserved.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: MATRIX.CPP                                                        *
*   Push buffer diassembler private implementation                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Ben de Waal                 07/21/98 - Created                      *
*                                                                           *
\***************************************************************************/
#include "precomp.h"
#include "disasm.h"

/*
 * attach
 *
 * bump reference count up
 */
NVUCL_RESULT NVUCL_STDCALL UCL_DISASM::attach
(
    void
)
{
    m_dwRefCount++;
    return NVUCL_OK;
}

/*
 * detach
 *
 * bump reference count down & delete object if it reaches zero
 */
NVUCL_RESULT NVUCL_STDCALL UCL_DISASM::detach
(
    void
)
{
    if (--m_dwRefCount)
    {
        return NVUCL_OK;
    }
    /*
     * kill self
     */
    delete this;
    return NVUCL_OK;
}

/*
 * redirect
 *
 * redirects output to the specified file
 */
NVUCL_RESULT NVUCL_STDCALL UCL_DISASM::redirect
(
    char* pszFilename
)
{
    /*
     * copy filename
     */
    m_pszFilename = strdup(pszFilename);

    /*
     * open file
     */
    m_hFile = fopen(pszFilename,"wt");
    if (!m_hFile)
    {
        /*
         * fail
         */
        return NVUCL_ERROR_ACCESSDENIED;
    }
    m_bToDebugger = FALSE;

    /*
     * banner
     */
    //todo

    /*
     * close file
     */
    fclose (m_hFile);
    m_hFile = 0;

    /*
     * done
     */
    return NVUCL_OK;
}

/*
 * traverse
 *
 * disassembles a push buffer
 */
NVUCL_RESULT NVUCL_STDCALL UCL_DISASM::traverse
(
    void* pBuffer,
    DWORD dwByteCount
)
{
    DWORD dwBuffer;

    /*
     * open file
     */
    if (!m_bToDebugger)
    {
        m_hFile = fopen(m_pszFilename,"a+t");
        if (!m_hFile)
        {
            /*
             * fail
             */
            return NVUCL_ERROR_ACCESSDENIED;
        }
    }

    emit ("PushBuffer %08x, ByteCount = %d\n",pBuffer,dwByteCount);

    dwBuffer = (DWORD)pBuffer;
    while (dwByteCount)
    {
        DWORD method  = *(DWORD*)dwBuffer;
        DWORD count   = (method & 0x00fc0000) >> 16;

        if (method & 0xff000000)
        {
            /*
             * not a method
             */
            emit ("   other: %08x - count=%d\n",method,count/4);

            /*
             * next
             */
            dwBuffer    += 4;
            dwByteCount -= 4;

            /*
             * show contents
             */
            while (count)
            {
                DWORD data = *(DWORD*)dwBuffer;

                /*
                 * print
                 */
                emit ("        : %08x\n",data);

                /*
                 * next
                 */
                count       -= 4;
                dwBuffer    += 4;
                dwByteCount -= 4;
            }
        }
        else
        {
            DWORD channel = (method & 0x0003e000) >> 13;
            DWORD addr    = (method & 0x00001fff) >>  0;

            emit ("\n  method: %08x - ch=%d, start=0x%x, count = %d\n",method,channel,addr,count/4);

            /*
             * next
             */
            dwBuffer    += 4;
            dwByteCount -= 4;

            /*
             * show contents
             */
            while (count)
            {
                DWORD data = *(DWORD*)dwBuffer;

                /*
                 * print
                 */
                emit ("%08x: %08x\n",addr,data);

                /*
                 * next
                 */
                addr        += 4;
                count       -= 4;
                dwBuffer    += 4;
                dwByteCount -= 4;
            }
        }
    }

    emit ("\n");

    /*
     * close file
     */
    if (!m_bToDebugger)
    {
        fflush (m_hFile);
        fclose (m_hFile);
        m_hFile = 0;
    }

    /*
     * done
     */
    return NVUCL_OK;
}

/*
 * emit
 *
 * helper function that either fprintf or sprintf/OutDB depending on file handle
 */
void UCL_DISASM::emit 
(
    char *szFormat,
    ...
)
{
    if (m_hFile)
    {
        vfprintf (m_hFile,szFormat,(char*)(((DWORD)&szFormat)+4));
    }
    else
    {
        char sz[1024];
        vsprintf (sz,szFormat,(char*)(((DWORD)&szFormat)+4));
        OutputDebugString (sz);
    }
}

/*
 * construction
 */
UCL_DISASM::UCL_DISASM (void)
{
    m_dwRefCount  = 1;
    m_bToDebugger = TRUE;
    m_hFile       = NULL;
    m_pszFilename = NULL;
}

UCL_DISASM::~UCL_DISASM (void)
{
    if (m_hFile)
    {
        fclose (m_hFile);
    }
    if (m_pszFilename)
    {
        free (m_pszFilename);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\common\NVUCL\disasm.h ===
/*
 * (C) Copyright NVIDIA Corporation Inc., 1996,1997,1998. All rights reserved.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: DISASM.H                                                          *
*   Push buffer disassembler private interface                              *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Ben de Waal                 07/21/98 - Created                      *
*                                                                           *
\***************************************************************************/
#ifndef _disasm_h
#define _disasm_h

struct UCL_DISASM : public NVUCL_DISASM
{
    /*
     * exported
     */
public:
    NVUCL_RESULT NVUCL_STDCALL attach        (void);
    NVUCL_RESULT NVUCL_STDCALL detach        (void);

    NVUCL_RESULT NVUCL_STDCALL redirect      (char* pszFilename);
    NVUCL_RESULT NVUCL_STDCALL traverse      (void* pBuffer,DWORD dwByteCount);

    /*
     * private
     */
protected:
    /*
     * variables
     */
    char  *m_pszFilename;
    DWORD  m_dwRefCount;
    BOOL   m_bToDebugger;
    FILE  *m_hFile;          // if NULL we go to debugger also

    /*
     * methods
     */
    void emit (char *szFormat,...);

    /*
     * construction
     */
public:
    UCL_DISASM (void);
    virtual ~UCL_DISASM (void);
};

#endif //_disasm_h
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\common\NVUCL\matrix.cpp ===
/*
 * (C) Copyright NVIDIA Corporation Inc., 1996,1997,1998. All rights reserved.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: MATRIX.CPP                                                        *
*   Matrix private implementation                                           *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Ben de Waal                 07/07/98 - Created                      *
*                                                                           *
\***************************************************************************/
#include "precomp.h"
#include "matrix.h"

/*
 * attach
 *
 * bump reference count up
 */
NVUCL_RESULT NVUCL_STDCALL UCL_MATRIX::attach
(
    void
)
{
    m_dwRefCount++;
    return NVUCL_OK;
}

/*
 * detach
 *
 * bump reference count down & delete object if it reaches zero
 */
NVUCL_RESULT NVUCL_STDCALL UCL_MATRIX::detach
(
    void
)
{
    if (--m_dwRefCount)
    {
        return NVUCL_OK;
    }
    /*
     * kill self
     */
    delete this;
    return NVUCL_OK;
}

/*
 * setStore
 *
 * redirect matrix element storage
 */
NVUCL_RESULT NVUCL_STDCALL UCL_MATRIX::setStore
(
    float *pfAddress
)
{
    m_fElement = pfAddress;
    classify();
    return NVUCL_OK;
}


/*
 * setUnit
 *
 * sets the matrix to unity
 */
NVUCL_RESULT NVUCL_STDCALL UCL_MATRIX::setUnit
(
    void
)
{
    /*
     * set to unit
     */
    memset (m_fElement,0,sizeof(float) * 16);
    m_fElement[0] = m_fElement[5] = m_fElement[10] = m_fElement[15] = 1.0f;
    m_eClass = unit;
    /*
     * done
     */
    return NVUCL_OK;
}

/*
 * setElement
 * 
 * set a specific element
 */
NVUCL_RESULT NVUCL_STDCALL UCL_MATRIX::setElement
(
    DWORD dwIndex,
    float fValue
)
{
    /*
     * check parameters
     */
    if (dwIndex > 15)
    {
        return NVUCL_ERROR_INVALIDPARAM;
    }
    /*
     * assign
     */
    m_fElement[dwIndex] = fValue;

    /*
     * reclassify matrix
     */
    classify();

    /*
     * done
     */
    return NVUCL_OK;
}

/*
 * setRow
 *
 * set an entire row
 */
NVUCL_RESULT NVUCL_STDCALL UCL_MATRIX::setRow
(
    DWORD dwRow,
    float *pfValue
)
{
    /*
     * check parameters
     */
    if (dwRow > 3)
    {
        return NVUCL_ERROR_INVALIDPARAM;
    }
    /*
     * assign
     */
    memcpy (m_fElement + (dwRow << 2),pfValue,sizeof(float) * 4);

    /*
     * reclassify matrix
     */
    classify();

    /*
     * done
     */
    return NVUCL_OK;
}

/*
 * setAll
 *
 * set all elements in matrix
 */
NVUCL_RESULT NVUCL_STDCALL UCL_MATRIX::setAll
(
    float *pfValue
)
{
    return NVUCL_ERROR_NOTIMLEMENTED;
}

/*
 * getElement
 *
 * get a specific element
 */
NVUCL_RESULT NVUCL_STDCALL UCL_MATRIX::getElement
(
    DWORD dwIndex,
    float *pfValue
)
{
    return NVUCL_ERROR_NOTIMLEMENTED;
}

/*
 * getRow
 *
 * get a whole row of elements
 */
NVUCL_RESULT NVUCL_STDCALL UCL_MATRIX::getRow
(
    DWORD dwRow,
    float *pfValue
)
{
    return NVUCL_ERROR_NOTIMLEMENTED;
}


/*
 * getAll
 *
 * get all the elements
 */
NVUCL_RESULT NVUCL_STDCALL UCL_MATRIX::getAll
(
    float *pfValue
)
{
    return NVUCL_ERROR_NOTIMLEMENTED;
}

/*
 * multiply
 *
 * multiply tow matrices
 */
NVUCL_RESULT NVUCL_STDCALL UCL_MATRIX::multiply
(
    void *pMatrix
)
{
    return NVUCL_ERROR_NOTIMLEMENTED;
}

/*
 * invert
 *
 * invert matrix
 */
NVUCL_RESULT NVUCL_STDCALL UCL_MATRIX::invert
(
    void
)
{
    return NVUCL_ERROR_NOTIMLEMENTED;
}

/*
 * classify
 *
 * look at elements in matrix and classify acorrdingly
 */
void UCL_MATRIX::classify
(
    void
)
{
    /*
     * test for general
     */
    if (m_fElement[3] || m_fElement[7] || m_fElement[11] || (m_fElement[15] != 1.0f))
    {
        m_eClass = general;
        return;
    }

    /*
     * test for translation
     */
    if (m_fElement[12] || m_fElement[13] || m_fElement[14])
    {
        m_eClass = translation;
    }
    else
    {
        m_eClass = unit;
    }

    /*
     * test for rotation
     */
    if ((m_fElement[0] != 1.0f) || (m_fElement[5] != 1.0f) || (m_fElement[10] != 1.0f)
     || m_fElement[1] || m_fElement[2] 
     || m_fElement[4] || m_fElement[6]
     || m_fElement[8] || m_fElement[9])
    {
        m_eClass = (m_eClass == unit) ? rotation : threebyfour;
    }
}

/*
 * construction
 */
UCL_MATRIX::UCL_MATRIX (void)
{
    m_dwRefCount = 1;
    m_fElement   = m_fInternalStorage;
    setUnit();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\common\NVUCL\nvucl.h ===
/*
 * (C) Copyright NVIDIA Corporation Inc., 1996,1997,1998. All rights reserved.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: NVUCL.H                                                           *
*   NVIDIA Unified Component Library Public Interface                       *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Ben de Waal                 07/06/98 - Created                      *
*                                                                           *
\***************************************************************************/
#ifndef _nvucl_h
#define _nvucl_h
#pragma pack(push,1)

/*
 *---------------------------------------------------------------------------
 * Constants
 *---------------------------------------------------------------------------
 */

/*
 * interface identifiers
 */
#define NVUCL_PROFILER_ID               0x4e560001
#define NVUCL_MATRIX_ID                 0x4e560002
#define NVUCL_DISASM_ID                 0x4e560003

/*
 * error codes
 */
#define NVUCL_OK                        0
#define NVUCL_ERROR_INVALIDPARAM        1
#define NVUCL_ERROR_UNKNOWNINTERFACE    2
#define NVUCL_ERROR_UNKNOWN             3
#define NVUCL_ERROR_OUTOFRESOURCE       4
#define NVUCL_ERROR_INVALIDCALL         5
#define NVUCL_ERROR_UNKNOWNENTITY       6
#define NVUCL_ERROR_NOTIMLEMENTED       7
#define NVUCL_ERROR_ACCESSDENIED        8

/*
 *---------------------------------------------------------------------------
 * Types
 *---------------------------------------------------------------------------
 */
typedef DWORD                           NVUCL_RESULT;

/*
 *---------------------------------------------------------------------------
 * Macros
 *---------------------------------------------------------------------------
 */

/*
 * compiler specific
 */
#ifdef __cplusplus
#define NVUCL_INTERFACE_BEGIN           struct NVUCL_INTERFACE : public NVUCL_BASE {
#define NVUCL_INTERFACE_END             };
#define NVUCL_METHOD(x)                 virtual NVUCL_RESULT NVUCL_STDCALL x (
#define NVUCL_METHOD_(x)                virtual NVUCL_RESULT NVUCL_STDCALL x (void
#define NVUCL_PURE                      )=0
#else //!__cplusplus
#define NVUCL_INTERFACE_BEGIN           typedef struct { struct {
#define NVUCL_INTERFACE_END             } *pVPtr; } *NVUCL_INTERFACE;
#define NVUCL_METHOD(x)                 NVUCL_RESULT (NVUCL_STDCALL *x) (void*,
#define NVUCL_METHOD_(x)                NVUCL_RESULT (NVUCL_STDCALL *x) (void*
#define NVUCL_PURE                      )
#endif //!__cplusplus
#define NVUCL_STDCALL                   __stdcall
#ifdef __NVUCL_INCLUDED
#define NVUCL_EXPORT                    __declspec(dllexport)
#else //!__NVUCL_INCLUDED
#define NVUCL_EXPORT
#endif //!__NVUCL_INCLUDED

/*
 * Dynamic Binding
 */
#define NVUCL_IMPORT                                                           \
    typedef NVUCL_RESULT (NVUCL_STDCALL *_nvuclGetInterfacePtr)(DWORD,void**); \
    _nvuclGetInterfacePtr nvuclGetInterfaceProc = 0;                           \
    HANDLE                _nvuclModule          = 0;

#define NVUCL_LOAD(x)                                                          \
    _nvuclModule = LoadLibrary(x);                                             \
    if (_nvuclModule)                                                          \
    {                                                                          \
        nvuclGetInterfaceProc = (_nvuclGetInterfacePtr)GetProcAddress(_nvuclModule,"_nvuclGetInterface@8");\
    }

#define NVUCL_UNLOAD                                                           \
    if (_nvuclModule) FreeLibrary(_nvuclModule);                               \
    _nvuclModule = 0;

/*
 *---------------------------------------------------------------------------
 * Structures
 *---------------------------------------------------------------------------
 */

/*
 *---------------------------------------------------------------------------
 * Interfaces
 *---------------------------------------------------------------------------
 */

/*
 * Base
 */
#ifdef __cplusplus
#undef  NVUCL_INTERFACE
#define NVUCL_INTERFACE     NVUCL_BASE
struct NVUCL_INTERFACE {
    NVUCL_METHOD_(attach) NVUCL_PURE;
    NVUCL_METHOD_(detach) NVUCL_PURE;
};
#endif //__cplusplus

/*
 * Profiler
 */
#undef  NVUCL_INTERFACE
#define NVUCL_INTERFACE     NVUCL_PROFILER
NVUCL_INTERFACE_BEGIN
    NVUCL_METHOD_(attach)                                   NVUCL_PURE;
    NVUCL_METHOD_(detach)                                   NVUCL_PURE;

    NVUCL_METHOD (registerEvent) LPCSTR cszName,DWORD dwID  NVUCL_PURE;
    NVUCL_METHOD (registerCount) LPCSTR cszName,DWORD dwID  NVUCL_PURE;
    NVUCL_METHOD (registerTime)  LPCSTR cszName,DWORD dwID  NVUCL_PURE;

    NVUCL_METHOD (logEvent)      DWORD  dwID                NVUCL_PURE;
    NVUCL_METHOD (logCount)      DWORD  dwID,int iCount     NVUCL_PURE;
    NVUCL_METHOD (logTime)       DWORD  dwID,__int64 iTime  NVUCL_PURE;

    NVUCL_METHOD (startCapture)  LPCSTR cszFileName         NVUCL_PURE;
    NVUCL_METHOD_(stopCapture)                              NVUCL_PURE;
    NVUCL_METHOD (flush)         BOOL bOptional             NVUCL_PURE;

    NVUCL_METHOD (getCPUTime)    __int64 *pdwTicks          NVUCL_PURE;
    NVUCL_METHOD (getCPUSpeed)   DWORD *pdwSpeed            NVUCL_PURE;
NVUCL_INTERFACE_END

/*
 * Matrix
 */
#undef  NVUCL_INTERFACE
#define NVUCL_INTERFACE     NVUCL_MATRIX
NVUCL_INTERFACE_BEGIN
    NVUCL_METHOD_(attach)                                       NVUCL_PURE;
    NVUCL_METHOD_(detach)                                       NVUCL_PURE;

    NVUCL_METHOD (setStore)     float *pfAddress                NVUCL_PURE;
    NVUCL_METHOD_(setUnit)                                      NVUCL_PURE;

    NVUCL_METHOD (setElement)   DWORD dwIndex,float fValue      NVUCL_PURE;
    NVUCL_METHOD (setRow)       DWORD dwRow,  float *pfValue    NVUCL_PURE;
    NVUCL_METHOD (setAll)       float *pfValue                  NVUCL_PURE;

    NVUCL_METHOD (getElement)   DWORD dwIndex,float *pfValue    NVUCL_PURE;
    NVUCL_METHOD (getRow)       DWORD dwRow,  float *pfValue    NVUCL_PURE;
    NVUCL_METHOD (getAll)       float *pfValue                  NVUCL_PURE;

    NVUCL_METHOD (multiply)     void *pMatrix                   NVUCL_PURE;
    NVUCL_METHOD_(invert)                                       NVUCL_PURE;
NVUCL_INTERFACE_END

/*
 * Push-buffer disassembler
 */
#undef  NVUCL_INTERFACE
#define NVUCL_INTERFACE     NVUCL_DISASM
NVUCL_INTERFACE_BEGIN
    NVUCL_METHOD_(attach)                                       NVUCL_PURE;
    NVUCL_METHOD_(detach)                                       NVUCL_PURE;

    NVUCL_METHOD (redirect)     char* pszFilename               NVUCL_PURE;
    NVUCL_METHOD (traverse)     void* pBuffer,DWORD dwByteCount NVUCL_PURE;
NVUCL_INTERFACE_END

/*
 *---------------------------------------------------------------------------
 * Publics
 *---------------------------------------------------------------------------
 */
#ifdef __cplusplus
extern "C" {
#endif //!__cplusplus
NVUCL_RESULT NVUCL_EXPORT NVUCL_STDCALL nvuclGetInterface (DWORD,void**);
#ifdef __cplusplus
}
#endif //!__cplusplus

#pragma pack(pop)
#endif //_nvucl_h
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\common\NVUCL\nvucl.cpp ===
/*
 * (C) Copyright NVIDIA Corporation Inc., 1996,1997,1998. All rights reserved.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: NVUCL.CPP                                                         *
*   Basic interface fulfillment routines                                    *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Ben de Waal                 07/06/98 - Created                      *
*                                                                           *
\***************************************************************************/
#include "precomp.h"
#include "disasm.h"
#include "matrix.h"
#include "profiler.h"

DWORD g_dwLastError;

/*
 * nvuclGetInterface
 *
 * instanciate a object of class dwIdentifier & returns it through 
 * ppInterface
 */
NVUCL_RESULT NVUCL_EXPORT NVUCL_STDCALL nvuclGetInterface
(
    DWORD   dwIdentifier,
    void  **ppInterface
)
{
    /*
     * setup
     */
    *ppInterface  = NULL;
    g_dwLastError = NVUCL_ERROR_UNKNOWN;

    /*
     * create object
     */
    switch (dwIdentifier)
    {
        /*
         * profiler
         */
        case NVUCL_PROFILER_ID:
            *ppInterface = (void*)(new UCL_PROFILER);
            break;
        /*
         * matrix
         */
        case NVUCL_MATRIX_ID:
            *ppInterface = (void*)(new UCL_MATRIX);
            break;
        case NVUCL_DISASM_ID:
            *ppInterface = (void*)(new UCL_DISASM);
            break;
        /*
         * unknown
         */
        default:
            return NVUCL_ERROR_UNKNOWNINTERFACE;
    }

    /*
     * return
     */
    return (*ppInterface) ? NVUCL_OK : g_dwLastError;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\common\NVUCL\profiler.h ===
/*
 * (C) Copyright NVIDIA Corporation Inc., 1996,1997,1998. All rights reserved.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: PROFILER.H                                                        *
*   Profiler private interface                                              *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Ben de Waal                 07/06/98 - Created                      *
*                                                                           *
\***************************************************************************/
#ifndef _profiler_h
#define _profiler_h

/*
 * constants
 */
#define CAPMAX          65536*2
#define CAPMARK         (CAPMAX - 32)

/*
 * implementation interface
 */
struct UCL_PROFILER : public NVUCL_PROFILER
{
    /*
     * exported
     */
public:
    NVUCL_RESULT NVUCL_STDCALL attach        (void);
    NVUCL_RESULT NVUCL_STDCALL detach        (void);

    NVUCL_RESULT NVUCL_STDCALL registerEvent (LPCSTR cszName,DWORD dwID);
    NVUCL_RESULT NVUCL_STDCALL registerCount (LPCSTR cszName,DWORD dwID);
    NVUCL_RESULT NVUCL_STDCALL registerTime  (LPCSTR cszName,DWORD dwID);

    NVUCL_RESULT NVUCL_STDCALL logEvent      (DWORD  dwID);
    NVUCL_RESULT NVUCL_STDCALL logCount      (DWORD  dwID,int iCount);
    NVUCL_RESULT NVUCL_STDCALL logTime       (DWORD  dwID,__int64 iTime);

    NVUCL_RESULT NVUCL_STDCALL startCapture  (LPCSTR cszFileName);
    NVUCL_RESULT NVUCL_STDCALL stopCapture   (void);
    NVUCL_RESULT NVUCL_STDCALL flush         (BOOL bOptional);

    NVUCL_RESULT NVUCL_STDCALL getCPUTime    (__int64 *pdwTicks);
    NVUCL_RESULT NVUCL_STDCALL getCPUSpeed   (DWORD *pdwSpeed);

    /*
     * private
     */
protected:

    /*
     * structures
     */
    struct ALPHABET
    {
        char  szName[16];               // human readable description
        DWORD dwRecordSize;             // size of record
        DWORD dwAttributes;             // Record description
    };
    
    /*
     * member variables
     */
    DWORD     m_dwRefCount;             // reference count
    DWORD     m_dwMax;                  // alphabet max allocated
    DWORD     m_dwCount;                // alphabet count
    HANDLE    m_hFile;                  // capture file handle
    DWORD     m_dwIndex;                // index in local capture file
    ALPHABET *m_pAlphabet;              // alphabet (may be NULL)
    DWORD     _pad[2];
    BYTE      m_pBuffer[CAPMAX];        // capture buffer
    DWORD     m_dwTranslationCount;     // max number registered
    BYTE      m_bTranslate[256];        // translation table

    /*
     * methods
     */
    void allocAlphabet (DWORD dwPlace);

    /*
     * constructors
     */
public:
    UCL_PROFILER (void);
    virtual ~UCL_PROFILER (void);
};
  
#endif //_profiler_h
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\common\NVUCL\Sample\Sample.c ===
/*
 * Some standard libraries
 */
#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#include <stdlib.h>

/*
 * include NVUCL
 */
#include "..\nvucl.h"
#pragma hdrstop

/*
 * globals
 */
NVUCL_PROFILER profiler = NULL;

/*
 * creation code
 */
int createProfiler (void)
{
    if (nvuclGetInterface(NVUCL_PROFILER_ID,&profiler))
    {
        return 0; // fail
    }
    return 1; // success
}
int destroyProfiler (void)
{
    profiler->pVPtr->detach(profiler);
    return 1;
}


/*
 * main entry point
 */
int main (void) 
{
    DWORD i;
    
    /*
     * create a profiler instance
     */
    if (!createProfiler()) return 1;

    /*
     * create alphabet
     */
    profiler->pVPtr->registerEvent (profiler,"event.1",0x00);
    profiler->pVPtr->registerCount (profiler,"count.1",0x11);
    profiler->pVPtr->registerCount (profiler,"count.2",0x22);
    profiler->pVPtr->registerTime  (profiler,"time.1", 0x33);

    /*
     * start capture
     */
    profiler->pVPtr->startCapture(profiler,"test.btd");

    /*
     * do something
     */
    for (i=0; i<1000; i++)
    {
        /*
         * flush the file buffers at known times so that we can work around
         * timing the HDD writing. logXXX functions will flush if internal
         * buffer overflows - but we consider that uncontrolled
         */
        if ((i % 100) == 99)
        {
            /*
             * stop all active timers here
             */
            // ...
            /*
             * flush
             */
            profiler->pVPtr->flush(profiler);
            /*
             * restart all active timers here
             */
            // ...
        }

        switch (rand() & 3)
        {
            case 0: profiler->pVPtr->logEvent (profiler,0x00);
                    break;
            case 1: profiler->pVPtr->logCount (profiler,0x11,rand());
                    break;
            case 2: profiler->pVPtr->logCount (profiler,0x22,rand());
                    break;
            case 3: {
                __int64 time1,time2;
                profiler->pVPtr->getCPUTime (profiler,&time1);
                Sleep (rand() & 15);
                profiler->pVPtr->getCPUTime (profiler,&time2);
                profiler->pVPtr->logTime    (profiler,0x33,time2-time1);
                break;
            }
        }
    }
 
    /*
     * stop capture
     */
    profiler->pVPtr->stopCapture(profiler);

    /*
     * done
     */
    if (!destroyProfiler()) return 1;
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\common\NVUCL\profiler.cpp ===
/*
 * (C) Copyright NVIDIA Corporation Inc., 1996,1997,1998. All rights reserved.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: PROFILER.CPP                                                      *
*   Profiler routines                                                       *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Ben de Waal                 07/06/98 - Created                      *
*                                                                           *
\***************************************************************************/
#include "precomp.h"
#include "profiler.h"

/*
 * local constants
 */
#define BTFT_1              0x42EC5201  // version 1 file header
#define BTRT_EOF            0xff

#define BTAA_EVENT          0x00000000  // event
#define BTAA_TIME           0x00000001  // time
#define BTAA_COUNT          0x00000002  // count

/*
 * attach
 *
 * bump reference count up
 */
NVUCL_RESULT NVUCL_STDCALL UCL_PROFILER::attach
(
    void
)
{
    m_dwRefCount++;
    return NVUCL_OK;
}

/*
 * detach
 *
 * bump reference count down & delete object if it reaches zero
 */
NVUCL_RESULT NVUCL_STDCALL UCL_PROFILER::detach
(
    void
)
{
    if (--m_dwRefCount)
    {
        return NVUCL_OK;
    }
    /*
     * kill self
     */
    delete this;
    return NVUCL_OK;
}

/*
 * registerEvent
 *
 * register a Locutus Event ID for profile usage
 */
NVUCL_RESULT NVUCL_STDCALL UCL_PROFILER::registerEvent
(
    LPCSTR cszName,
    DWORD  dwID
)
{
    /*
     * program translation
     */
    m_bTranslate[dwID] = (BYTE)m_dwTranslationCount;

    /*
     * make sure we have enough space
     */
    if (m_dwTranslationCount >= m_dwCount)
    {
        allocAlphabet (m_dwTranslationCount);
    }

    /*
     * register entry
     */
    strncpy (m_pAlphabet[m_dwTranslationCount].szName,cszName,15);
    m_pAlphabet[m_dwTranslationCount].szName[15]   = 0;
    m_pAlphabet[m_dwTranslationCount].dwRecordSize = 0;
    m_pAlphabet[m_dwTranslationCount].dwAttributes = BTAA_EVENT;
    m_dwTranslationCount++;

    /*
     * done
     */
    return NVUCL_OK;
}

/*
 * registerCount
 *
 * register a Locutus Count ID for profile usage
 */
NVUCL_RESULT NVUCL_STDCALL UCL_PROFILER::registerCount
(
    LPCSTR cszName,
    DWORD  dwID
)
{
    /*
     * program translation
     */
    m_bTranslate[dwID] = (BYTE)m_dwTranslationCount;

    /*
     * make sure we have enough space
     */
    if (m_dwTranslationCount >= m_dwCount)
    {
        allocAlphabet (m_dwTranslationCount);
    }

    /*
     * register entry
     */
    strncpy (m_pAlphabet[m_dwTranslationCount].szName,cszName,15);
    m_pAlphabet[m_dwTranslationCount].szName[15]   = 0;
    m_pAlphabet[m_dwTranslationCount].dwRecordSize = sizeof(DWORD);
    m_pAlphabet[m_dwTranslationCount].dwAttributes = BTAA_COUNT;
    m_dwTranslationCount++;

    /*
     * done
     */
    return NVUCL_OK;
}

/*
 * registerTime
 *
 * register a Locutus Time ID for profile usage
 */
NVUCL_RESULT NVUCL_STDCALL UCL_PROFILER::registerTime
(
    LPCSTR cszName,
    DWORD  dwID
)
{
    /*
     * program translation
     */
    m_bTranslate[dwID] = (BYTE)m_dwTranslationCount;

    /*
     * make sure we have enough space
     */
    if (m_dwTranslationCount >= m_dwCount)
    {
        allocAlphabet (m_dwTranslationCount);
    }

    /*
     * register entry
     */
    strncpy (m_pAlphabet[m_dwTranslationCount].szName,cszName,15);
    m_pAlphabet[m_dwTranslationCount].szName[15]   = 0;
    m_pAlphabet[m_dwTranslationCount].dwRecordSize = sizeof(__int64);
    m_pAlphabet[m_dwTranslationCount].dwAttributes = BTAA_TIME;
    m_dwTranslationCount++;

    /*
     * done
     */
    return NVUCL_OK;
}

/*
 * logEvent
 *
 * logs a Locutus event
 */
NVUCL_RESULT NVUCL_STDCALL UCL_PROFILER::logEvent
(
    DWORD dwID
)
{
    /*
     * log
     */
    m_pBuffer[m_dwIndex++] = m_bTranslate[dwID];

    /*
     * flush if buffer is full
     */
    if (m_dwIndex > CAPMARK) flush (FALSE);

    /*
     * done
     */
    return NVUCL_OK;
}

/*
 * logCount
 *
 * logs a Locutus count
 */
NVUCL_RESULT NVUCL_STDCALL UCL_PROFILER::logCount
(
    DWORD dwID,
    int   iCount
)
{
    /*
     * log
     */
    m_pBuffer[m_dwIndex++] = m_bTranslate[dwID];
    *(int*)(m_pBuffer + m_dwIndex) = iCount;
    m_dwIndex += 4;

    /*
     * flush if buffer is full
     */
    if (m_dwIndex > CAPMARK) flush (FALSE);

    /*
     * done
     */
    return NVUCL_OK;
}

/*
 * logTime
 *
 * logs a Locutus time
 */
NVUCL_RESULT NVUCL_STDCALL UCL_PROFILER::logTime
(
    DWORD   dwID,
    __int64 iTime
)
{
    /*
     * log
     */
    m_pBuffer[m_dwIndex++] = m_bTranslate[dwID];
    *(__int64*)(m_pBuffer + m_dwIndex) = iTime;
    m_dwIndex += 8;

    /*
     * flush if buffer is full
     */
    if (m_dwIndex > CAPMARK) flush (FALSE);

    /*
     * done
     */
    return NVUCL_OK;
}

/*
 * startCapture
 *
 * starts a capture session
 */
NVUCL_RESULT NVUCL_STDCALL UCL_PROFILER::startCapture
(
    LPCSTR cszFileName
)
{
    /*
     * make sure we have at least one alphabet entry
     */
    if (!m_dwCount)
    {
        return NVUCL_ERROR_INVALIDCALL;
    }

    /*
     * open up file
     */
    m_hFile = CreateFile(cszFileName,GENERIC_WRITE,0,0,CREATE_ALWAYS,0,0);
    if (m_hFile == INVALID_HANDLE_VALUE) {
        return NVUCL_ERROR_OUTOFRESOURCE;
    }

    /*
     * place header information
     */
    m_dwIndex = 0;
    *(DWORD*)(m_pBuffer + m_dwIndex) = BTFT_1;
    m_dwIndex += 4;
    DWORD dw = 1;
    getCPUSpeed (&dw);
    *(DWORD*)(m_pBuffer + m_dwIndex) = dw;
    m_dwIndex += 4;
    *(DWORD*)(m_pBuffer + m_dwIndex) = m_dwCount;
    m_dwIndex += 4;
    memcpy (m_pBuffer + m_dwIndex,m_pAlphabet,sizeof(ALPHABET) * m_dwCount);
    m_dwIndex += sizeof(ALPHABET) * m_dwCount;

    /*
     * done
     */
    return NVUCL_OK;
}

/*
 * stopCapture
 *
 * ends off a capture session
 */
NVUCL_RESULT NVUCL_STDCALL UCL_PROFILER::stopCapture 
(
    void
)
{
    /*
     * make sure we have a capture in progress
     */
    if (!m_hFile)
    {
        return NVUCL_ERROR_INVALIDCALL;
    }

    /*
     * finish off capture
     */
    m_pBuffer[m_dwIndex++] = BTRT_EOF;
    flush (FALSE);
    CloseHandle (m_hFile);
    m_hFile = NULL; // tag as closed

    /*                     
     * done
     */
    return NVUCL_OK;
}

/*
 * flush
 *
 * flush a Locutus batch to disk
 */
NVUCL_RESULT NVUCL_STDCALL UCL_PROFILER::flush
(
    BOOL bOptional
)
{
    /*
     * flush only when we have enough data (50% full)
     */
    if (bOptional && (m_dwIndex < (CAPMAX / 2)))
    {
        return NVUCL_OK;
    }

    /*
     * send data if any
     */
    if (m_dwIndex) {
        /*
         * write data
         */
        DWORD dw;
        if (!WriteFile(m_hFile,m_pBuffer,m_dwIndex,&dw,0)) {
            return NVUCL_ERROR_OUTOFRESOURCE;
        }
        /*
         * make sure it is comitted now
         */
        FlushFileBuffers (m_hFile);
        /*
         * reset index
         */
        m_dwIndex = 0;
    }

    /*
     * done
     */
    return NVUCL_OK;
}

/*
 * getCPUTime
 *
 * get # of clock ticks elasped since startup
 */
NVUCL_RESULT NVUCL_STDCALL UCL_PROFILER::getCPUTime
(
    __int64 *pdwTicks
)
{
    __asm 
    {
        mov ebx,[pdwTicks]
        _emit 0x0f 
        _emit 0x31
        mov dword ptr [ebx],eax
        mov dword ptr [ebx+4],edx
    }
    return NVUCL_OK;
}

/*
 * getCPUSpeed
 *
 * measure the CPU speed (& latch to know values)
 */
NVUCL_RESULT NVUCL_STDCALL UCL_PROFILER::getCPUSpeed
(
    DWORD *pdwSpeed
)
{
    double      speed;
    SYSTEM_INFO si;

    GetSystemInfo (&si);
    if (si.wProcessorArchitecture != PROCESSOR_ARCHITECTURE_INTEL) return NVUCL_ERROR_UNKNOWNENTITY; // unknown
    if (si.dwProcessorType        != PROCESSOR_INTEL_PENTIUM)      return NVUCL_ERROR_UNKNOWNENTITY; // not pentium

    SetPriorityClass  (GetCurrentProcess(),REALTIME_PRIORITY_CLASS);
    SetThreadPriority (GetCurrentThread(), THREAD_PRIORITY_TIME_CRITICAL);
    GetTickCount(); // break in cache
    {
	    DWORD   start,stop;
        __int64 clock_ticks;

	    start = GetTickCount();
	    __asm {
		    pushad
            lea esi,[clock_ticks]

		    _emit 0x0f
		    _emit 0x31
		    mov ebp,eax
		    mov ebx,edx

		    mov ecx,8000000h
	    here:
		    loop here

		    _emit 0x0f
		    _emit 0x31
		    sub eax,ebp
		    sbb edx,ebx

		    mov [dword ptr esi+0],eax
		    mov [dword ptr esi+4],edx

		    popad
	    }
	    stop = GetTickCount();
        speed = ((double)clock_ticks)/(1000.0*(double)(stop-start));
    }
    SetPriorityClass  (GetCurrentProcess(),NORMAL_PRIORITY_CLASS);
    SetThreadPriority (GetCurrentThread(), THREAD_PRIORITY_NORMAL);
 
    /*
     * normalize to known values
     */
#define LATCH_VALUE(x,y)    if (fabs(((x)-(y))/(y)) < 0.05) { *pdwSpeed = (DWORD)(y); return NVUCL_OK; }
    LATCH_VALUE (speed, 90);
    LATCH_VALUE (speed,100);
    LATCH_VALUE (speed,166);
    LATCH_VALUE (speed,200);
    LATCH_VALUE (speed,233);
    LATCH_VALUE (speed,266);
    LATCH_VALUE (speed,300);
    LATCH_VALUE (speed,333);
    LATCH_VALUE (speed,400);
    LATCH_VALUE (speed,450);
    LATCH_VALUE (speed,500);

    /*
     * did not latch - return unaltered (can be up to 10% off)
     */
    *pdwSpeed = (DWORD)(speed);
    return NVUCL_OK;
}

/*
 * allocAlphabet
 *
 * allocates enough space in alphabet to register the dwPlace'th alphabet
 * entry
 */
void UCL_PROFILER::allocAlphabet
(
    DWORD dwPlace
)
{
    /*
     * bump alphabet count if needed
     */
    if (dwPlace >= m_dwCount)
    {
        m_dwCount = dwPlace + 1;
    }

    /*
     * Do we have enough space?
     */
    if (m_dwCount > m_dwMax)
    {
        /*
         * alloc enough space
         */
        m_dwMax     = (m_dwCount + 15) & ~15;        
        m_pAlphabet = (ALPHABET*)realloc(m_pAlphabet,sizeof(ALPHABET) * m_dwMax);
    }
}

/*
 * constructor
 */
UCL_PROFILER::UCL_PROFILER
(
    void
)
{
    m_dwRefCount = 1;
    m_dwMax      = 0;
    m_dwCount    = 0;
    m_pAlphabet  = NULL;
    m_hFile      = NULL;
    m_dwIndex    = 0;
    m_dwTranslationCount = 0;
}

UCL_PROFILER::~UCL_PROFILER
(
    void
)
{
    if (m_hFile)
    {
        CloseHandle (m_hFile);
    }
    if (m_pAlphabet)
    {
        free (m_pAlphabet);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\common\NVUCL\precomp.h ===
#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#include <stdio.h>
#include <math.h>
#include <string.h>
#include <malloc.h>

#define __NVUCL_INCLUDED
#include "nvucl.h"

/*
 * global macros
 */
#define PREFETCH(x)     (volatile DWORD)*(DWORD*)(x)

/*
struct UCL_BASE : public NVUCL_BASE
{
private:
    DWORD m_dwRefCount;
public:
    virtual NVUCL_RESULT NVUCL_STDCALL attach (void)
    {
        m_dwRefCount++;
        return NVUCL_OK;
    }
    virtual NVUCL_RESULT NVUCL_STDCALL detach (void)
    {
        if (--m_dwRefCount) return NVUCL_OK;
        delete this;
        return NVUCL_OK;
    }
    virtual ~UCL_BASE (void)
    {
    }
};
*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\common\nvUtil\nvdetect.h ===
#ifndef _nvdetect_h
#define _nvdetect_h

DWORD nvGetCPUSpeed  (void);
BOOL  nvDetectMMX    (void);
BOOL  nvDetectKATMAI (void);

#endif //!_nvdetect_h
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\common\nvUtil\nvdetect.cpp ===
/*
 * Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.
 *
 * THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
 * NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
 * IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: NVDETECT.CPP                                                      *
*   Detects CPU family and capabilities                                     *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Ben de Waal                 10/20/98 - wrote it                     *
*                                                                           *
\***************************************************************************/
#include "precomp.h"
#include "nvutil.h"
#include "nvdetect.h"

/*
 * macros
 */
#define LATCH_VALUE(x,y)    if (fabs(((x)-(y))/(y)) < 0.05) return (DWORD)(y)


/*
 * nvGetCPUSpeed
 *
 * detects CPU speed
 */
__int64 _clock_ticks;
DWORD nvGetCPUSpeed
(
    void
)
{
    double      speed;
    DWORD       dwCaps;
    SYSTEM_INFO si;

    GetSystemInfo (&si);
    if (si.wProcessorArchitecture != PROCESSOR_ARCHITECTURE_INTEL) return 1; // unknown
    if (si.dwProcessorType != PROCESSOR_INTEL_PENTIUM) return 1; // not pentium

    __asm
    {
        mov eax,1
        // cpuid
        _emit 0x0f
        _emit 0xa2
        mov [dwCaps],edx
    }
    if (!(dwCaps & 0x00000010)) return 1; // does not have tsc


    SetPriorityClass  (GetCurrentProcess(),REALTIME_PRIORITY_CLASS);
    SetThreadPriority (GetCurrentThread(), THREAD_PRIORITY_TIME_CRITICAL);
    GetTickCount(); // break in cache
    {
        DWORD start,stop;

        start = GetTickCount();
        __asm {
            pushad

            // rdtsc
            _emit 0x0f
            _emit 0x31
            mov ebp,eax
            mov ebx,edx
#ifdef NV_PROFILE
            mov ecx,8000000h
#else
            mov ecx,1000000h
#endif
        here:
            loop here

            // rdtsc
            _emit 0x0f
            _emit 0x31
            sub eax,ebp
            sbb edx,ebx

            mov [dword ptr _clock_ticks  ],eax
            mov [dword ptr _clock_ticks+4],edx

            popad
        }
        stop = GetTickCount();
        speed = ((double)_clock_ticks)/(1000.0*(double)(stop-start));
    }
    SetPriorityClass  (GetCurrentProcess(),NORMAL_PRIORITY_CLASS);
    SetThreadPriority (GetCurrentThread(), THREAD_PRIORITY_NORMAL);

// normalize to known values
    LATCH_VALUE (speed, 90);
    LATCH_VALUE (speed,100);
    LATCH_VALUE (speed,166);
    LATCH_VALUE (speed,200);
    LATCH_VALUE (speed,233);
    LATCH_VALUE (speed,266);
    LATCH_VALUE (speed,300);
    LATCH_VALUE (speed,333);
    LATCH_VALUE (speed,400);
    LATCH_VALUE (speed,450);
    LATCH_VALUE (speed,500);
    LATCH_VALUE (speed,550);
    LATCH_VALUE (speed,600);
// did not latch - return unaltered (can be up to 10% off)
    return (DWORD)speed;
}

/*
 * nvDetectMMX
 *
 * detect MMX capability
 */
BOOL nvDetectMMX
(
    void
)
{
    DWORD       dwCaps;
    SYSTEM_INFO si;

    GetSystemInfo (&si);
    if (si.wProcessorArchitecture != PROCESSOR_ARCHITECTURE_INTEL) return FALSE; // unknown
    if (si.dwProcessorType != PROCESSOR_INTEL_PENTIUM) return FALSE; // not pentium

    __asm
    {
        mov eax,1
        // cpuid
        _emit 0x0f
        _emit 0xa2
        mov [dwCaps],edx
    }

    return (dwCaps & 0x00800000) ? TRUE : FALSE;
}

/*
 * nvDetectKATMAI
 *
 * detect P3 capability and OS support for it
 */
BOOL nvDetectKATMAI
(
    void
)
{
    DWORD         dwCaps;
    SYSTEM_INFO   si;
    OSVERSIONINFO osvi;
    BOOL          bIsWindows98orLater;

    GetSystemInfo (&si);
    if (si.wProcessorArchitecture != PROCESSOR_ARCHITECTURE_INTEL) return FALSE; // unknown
    if (si.dwProcessorType != PROCESSOR_INTEL_PENTIUM) return FALSE; // not pentium

    __asm
    {
        mov eax,1
        // cpuid
        _emit 0x0f
        _emit 0xa2
        mov [dwCaps],edx

/*
        //mov eax,cr4
        _emit 0x0f
        _emit 0x20
        _emit 0xe0
        mov [dwCR4],eax
*/
    }

    /*
     * detect at least win 98
     */
    osvi.dwOSVersionInfoSize = sizeof(osvi);
    GetVersionEx (&osvi);
    bIsWindows98orLater = (osvi.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS)
                       && ((osvi.dwMajorVersion > 4)
                        || ((osvi.dwMajorVersion == 4)
                         && (osvi.dwMinorVersion > 0)));

    return ((dwCaps & 0x02000000) && bIsWindows98orLater/*&& (dwCR4 & 0x200)*/) ? TRUE : FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\common\nvUtil\nvinit.cpp ===
/*
 * Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.
 *
 * THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
 * NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
 * IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: NVSWIZ.CPP                                                        *
*   CPU Texture swizzling routines                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Ben de Waal                 10/20/98 - wrote it                     *
*                                                                           *
\***************************************************************************/
#include "precomp.h"
#include "nvutil.h"
#include "nvdetect.h"

/*
 * globals
 */
DWORD g_dwCPUFeatureSet = 0;
DWORD g_dwCPUClockSpeed = 0;

/*
 * nvUtilCreate
 *
 * initializes the nvutil component
 */
void nvUtilCreate
(
    void
)
{
    /*
     * feature set
     */
    g_dwCPUFeatureSet = (nvDetectMMX()    ? NV_FS_MMX    : 0)
                      | (nvDetectKATMAI() ? NV_FS_KATMAI : 0);

    MEMORYSTATUS ms;
    ms.dwLength = sizeof(ms);
    GlobalMemoryStatus (&ms);

    if (ms.dwTotalPhys >= 250*1024*1024)      g_dwCPUFeatureSet |= NV_FS_64MB | NV_FS_128MB | NV_FS_256MB;
    else if (ms.dwTotalPhys >= 120*1024*1024) g_dwCPUFeatureSet |= NV_FS_64MB | NV_FS_128MB;
    else if (ms.dwTotalPhys >=  60*1024*1024) g_dwCPUFeatureSet |= NV_FS_64MB;

    /*
     * clock speed
     */
    g_dwCPUClockSpeed = nvGetCPUSpeed();
}

/*
 * nvUtilDestroy
 *
 * destroys the nvutil component
 */
void nvUtilDestroy
(
    void
)
{
}

/*
 * nvGetCPUCaps
 *
 * returns CPU caps
 */
void nvGetCPUCaps
(
    NVCPUINFO *pInfo
)
{
    pInfo->dwCPUClockSpeed = g_dwCPUClockSpeed;
    pInfo->dwCPUFeatureSet = g_dwCPUFeatureSet;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\common\nvUtil\precomp.h ===
#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#include <malloc.h>
#include <math.h>
#include "..\..\ddraw\win9x\nv4\x86\x86.h" // this should be moved to a better place
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\common\nvUtil\nvswiz.cpp ===
/*
 * Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.
 *
 * THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
 * NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
 * IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: NVSWIZ.CPP                                                        *
*   CPU Texture swizzling routines                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Ben de Waal                 10/20/98 - wrote it                     *
*                                                                           *
\***************************************************************************/
#include "precomp.h"
#include "nvutil.h"
#include "nvinit.h"

/*
 * constants
 */
#define L2MB        5
#define MB          (1<<L2MB)   // swizzle macroblock size

#define MB_UMASK    ((MB*MB-1) & 0x55555555)
#define MB_VMASK    ((MB*MB-1) & 0xaaaaaaaa)

/*
 * macros
 */
#define ilcData         global.dwILCData
#define ilcCount        global.dwILCCount
#define ilcMax          global.dwILCMax

#define TEXELCOPY(d,s,bpp)                          \
{                                                   \
    if ((bpp) == 2) *(WORD*)(d)  = *(WORD*)(s);     \
    /*else if ((bpp) == 1) *(BYTE*)(d)  = *(BYTE*)(s);*/\
    else *(DWORD*)(d) = *(DWORD*)(s);               \
}

#define movaps_r_rm8(r,rm,ofs)      __asm _emit 0x0f __asm _emit 0x28 __asm _emit (mREG(r) | (rm)) __asm _emit (ofs)
#define movaps_rm8_r(rm,ofs,r)      __asm _emit 0x0f __asm _emit 0x29 __asm _emit (mREG(r) | (rm)) __asm _emit (ofs)
#define movups_r_rm8(r,rm,ofs)      __asm _emit 0x0f __asm _emit 0x10 __asm _emit (mREG(r) | (rm)) __asm _emit (ofs)
#define movups_rm8_r(rm,ofs,r)      __asm _emit 0x0f __asm _emit 0x11 __asm _emit (mREG(r) | (rm)) __asm _emit (ofs)
#define prefetch_rm8(h,rm,ofs)      __asm _emit 0x0f __asm _emit 0x18 __asm _emit (mREG(h) | (rm)) __asm _emit (ofs)

/*
 * swizzle table buffer layout
 */
BYTE nvTexelScratchBuffer[8192];  // must be as wide as the widest pitch (4 * 2048 = 8192)

/*****************************************************************************
 * swizzle address generation
 *****************************************************************************/
typedef struct
{
    DWORD dwBase;
    DWORD dwOffset;
    DWORD dwLine;

    DWORD dwDUDXOr;
    DWORD dwDUDXAnd;
    DWORD dwDUDXAdd;

    DWORD dwDVDYOr;
    DWORD dwDVDYAnd;
    DWORD dwDVDYAdd;
} SWIZZLE_ADDR;

__inline DWORD nvSwizzleAddrGet (SWIZZLE_ADDR *lpSA)
{
    return lpSA->dwBase + lpSA->dwOffset;
}

__inline void nvSwizzleAddrNext (SWIZZLE_ADDR *lpSA)
{
    DWORD u,v;

    u              = ((lpSA->dwOffset | lpSA->dwDUDXOr) + lpSA->dwDUDXAdd) & lpSA->dwDUDXAnd;
    v              =   lpSA->dwOffset & lpSA->dwDVDYAnd;
    lpSA->dwOffset = u | v;
}

__inline void nvSwizzleAddrNewLine (SWIZZLE_ADDR *lpSA)
{
    DWORD u,v;

    u            =   lpSA->dwLine & lpSA->dwDUDXAnd;
    v            = ((lpSA->dwLine | lpSA->dwDVDYOr) + lpSA->dwDVDYAdd) & lpSA->dwDVDYAnd;
    lpSA->dwLine = lpSA->dwOffset = u | v;
}

void nvSwizzleAddrCreate
(
    SWIZZLE_ADDR *lpSA,
    DWORD         dwBase,
    DWORD         dwX,
    DWORD         dwY,
    DWORD         dwLogW,
    DWORD         dwLogH,
    DWORD         dwBPP
)
{
    if (!dwLogW)
    {
        lpSA->dwBase    = dwBase;
        lpSA->dwOffset  = lpSA->dwLine
                        = dwY * dwBPP;
        lpSA->dwDUDXAnd = 0;
        lpSA->dwDUDXOr  = 0;
        lpSA->dwDUDXAdd = 0;
        lpSA->dwDVDYAnd = ~0;
        lpSA->dwDVDYOr  = 0;
        lpSA->dwDVDYAdd = dwBPP;
    }
    else if (!dwLogH)
    {
        lpSA->dwBase    = dwBase;
        lpSA->dwOffset  = lpSA->dwLine
                        = dwX * dwBPP;
        lpSA->dwDUDXAnd = ~0;
        lpSA->dwDUDXOr  = 0;
        lpSA->dwDUDXAdd = dwBPP;
        lpSA->dwDVDYAnd = 0;
        lpSA->dwDVDYOr  = 0;
        lpSA->dwDVDYAdd = 0;
    }
    else
    {
        DWORD dwLog       = min(dwLogW,dwLogH);
        DWORD dw2Log      = dwLog << 1;            // # of bits to interleave
        DWORD dwUpperMask = ~((1 << dw2Log) - 1);  // bits to preserve
        DWORD dwLowerMask = ~dwUpperMask;          // bits to interleave

        /*
         * calc offset
         */
        DWORD dwUpperU    = (dwX << dwLog) & dwUpperMask;
        DWORD dwUpperV    = (dwY << dwLog) & dwUpperMask;

        DWORD dwLower     = ((dwX & 0x001) <<  0) | ((dwY & 0x001) <<  1)
                          | ((dwX & 0x002) <<  1) | ((dwY & 0x002) <<  2)
                          | ((dwX & 0x004) <<  2) | ((dwY & 0x004) <<  3)
                          | ((dwX & 0x008) <<  3) | ((dwY & 0x008) <<  4)
                          | ((dwX & 0x010) <<  4) | ((dwY & 0x010) <<  5)
                          | ((dwX & 0x020) <<  5) | ((dwY & 0x020) <<  6)
                          | ((dwX & 0x040) <<  6) | ((dwY & 0x040) <<  7)
                          | ((dwX & 0x080) <<  7) | ((dwY & 0x080) <<  8)
                          | ((dwX & 0x100) <<  8) | ((dwY & 0x100) <<  9)
                          | ((dwX & 0x200) <<  9) | ((dwY & 0x200) << 10)
                          | ((dwX & 0x400) << 10) | ((dwY & 0x400) << 11)
                          | ((dwX & 0x800) << 11) | ((dwY & 0x800) << 12);

        lpSA->dwBase   = dwBase;
        lpSA->dwOffset = lpSA->dwLine
                       = ((dwLower & dwLowerMask) | dwUpperU | dwUpperV) * dwBPP;

        /*
         * calc masks
         */
        lpSA->dwDUDXOr  = (0xaaaaaaaa & dwLowerMask) * dwBPP;
        lpSA->dwDUDXAnd = ((dwLogW > dwLogH) ? (0x55555555 | dwUpperMask)
                                             : (0x55555555 & dwLowerMask)) * dwBPP;
        lpSA->dwDUDXAdd = dwBPP;
        lpSA->dwDVDYOr  = (0x55555555 & dwLowerMask) * dwBPP;
        lpSA->dwDVDYAnd = ((dwLogW < dwLogH) ? (0xaaaaaaaa | dwUpperMask)
                                             : (0xaaaaaaaa & dwLowerMask)) * dwBPP;
        lpSA->dwDVDYAdd = dwBPP << 1;
    }
}

/*
 * SOFTWARE SWIZZLE
 * ----------------
 */

/*
 * nvSwizzleSmallBlock
 *
 * swizzles any texture with a dimension less than 8 (i.e. 2048 x 4)
 */
void nvSwizzleSmallBlock
(
    DWORD dwSrcBase,
    DWORD dwSrcPitch,

    DWORD dwDestBase,

    DWORD dwLogW,
    DWORD dwLogH,
    DWORD dwBPP
)
{
    SWIZZLE_ADDR sa;
    DWORD        dwCount,dwSize,dwLine;
    DWORD        dwScratch0,dwScratch1;
    DWORD        x,y;
    void        *pMemory;

    /*
     * figure out memory requirements
     */
    dwCount = 1     << (dwLogW + dwLogH);
    dwSize  = dwBPP << (dwLogW + dwLogH);
    if (dwSize > 4096)
    {
        pMemory = malloc(dwSize * 2);
        dwScratch0 = (DWORD)pMemory;
        dwScratch1 = ((DWORD)pMemory) + dwSize;
    }
    else
    {
        pMemory    = NULL;
        dwScratch0 = (DWORD)(nvTexelScratchBuffer + 0);
        dwScratch1 = (DWORD)(nvTexelScratchBuffer + 4096);
    }

    /*
     * read texels
     */
    dwLine = dwBPP << dwLogW;
    if (dwLine != dwSrcPitch)
    {
        DWORD u = dwSrcBase;
        DWORD v = dwScratch0;
        for (y = (1 << dwLogH); y; y--)
        {
            nvMemCopy (v,u,dwLine,NV_MEMCOPY_WANTSRCALIGNED);
            v += dwLine;
            u += dwSrcPitch;
        }
    }
    else
    {
        nvMemCopy (dwScratch0,dwSrcBase,dwLine << dwLogH,NV_MEMCOPY_WANTSRCALIGNED);
    }

    /*
     * prepare swizzle address generation
     */
    nvSwizzleAddrCreate (&sa,dwScratch1,0,0,dwLogW,dwLogH,dwBPP);

    /*
     * do swizzle
     */
    switch (dwBPP)
    {
        case 1:
        {
            for (y = (1 << dwLogH); y; y--)
            {
                for (x = (1 << dwLogW); x; x--)
                {
                    *(BYTE*)nvSwizzleAddrGet(&sa) = *(BYTE*)dwScratch0;

                    dwScratch0 += 1;
                    nvSwizzleAddrNext (&sa);
                }
                nvSwizzleAddrNewLine (&sa);
            }
            break;
        }
        case 2:
        {
            for (y = (1 << dwLogH); y; y--)
            {
                for (x = (1 << dwLogW); x; x--)
                {
                    *(WORD*)nvSwizzleAddrGet(&sa) = *(WORD*)dwScratch0;

                    dwScratch0 += 2;
                    nvSwizzleAddrNext (&sa);
                }
                nvSwizzleAddrNewLine (&sa);
            }
            break;
        }
        case 4:
        {
            for (y = (1 << dwLogH); y; y--)
            {
                for (x = (1 << dwLogW); x; x--)
                {
                    *(DWORD*)nvSwizzleAddrGet(&sa) = *(DWORD*)dwScratch0;

                    dwScratch0 += 4;
                    nvSwizzleAddrNext (&sa);
                }
                nvSwizzleAddrNewLine (&sa);
            }
            break;
        }
    }

    /*
     * write texels
     */
    nvMemCopy (dwDestBase,dwScratch1,dwSize,NV_MEMCOPY_WANTDESTALIGNED);

    /*
     * free memory
     */
    if (pMemory) free (pMemory);
}

/*
 * nvSwizzleMacroBlock_LS
 *
 * swizzles a full MBxMB block (lin -> swz)
 */
void nvSwizzleMacroBlock_LS
(
    DWORD dwSrcBase,
    DWORD dwSrcPitch,
    DWORD dwDestBase,
    DWORD dwBPP
)
{
    if (g_dwCPUFeatureSet & NV_FS_KATMAI)
    {
        switch (dwBPP)
        {
            case 2: // 16bpp Pentium3
            {
                __asm
                {
                    mov eax,offset nvTexelScratchBuffer
                    mov ecx,(MB * MB * 2) / 32
            xxx16:   prefetch_rm8 (1,rmIND8(rEAX), 0)
                     add eax,32
                     dec ecx
                    jnz xxx16

                    mov eax,[dwSrcBase]
                    prefetch_rm8 (1,rmIND8(rEAX), 0)
                    prefetch_rm8 (1,rmIND8(rEAX),32)
                }

                {
                    DWORD src = dwSrcBase;
                    DWORD dst = (DWORD)nvTexelScratchBuffer;
                    DWORD v = 0;
                    DWORD y;

                    for (y = MB; y; y--)
                    {
                        DWORD addr;

                        addr  = src;
                        src  += dwSrcPitch;
                        __asm
                        {
                            mov eax,[src]
                            prefetch_rm8 (1,rmIND8(rEAX), 0)
                            prefetch_rm8 (1,rmIND8(rEAX),32)
                        }


#define NXT1(u)  ((((u) | (MB_VMASK*2)) + 1*2) & (MB_UMASK*2))
#define NXT2(u)  NXT1(NXT1(u))
#define NXT4(u)  NXT2(NXT2(u))
#define NXT8(u)  NXT4(NXT4(u))
#define NXT16(u) NXT8(NXT8(u))
#define NXT32(u) NXT16(NXT16(u))

                        // MB assumed to be 32
                        __asm {
                            push esi
                            push edi
                            push ebx

                        // load 8 texels
                            mov eax,[addr]
                            mov ebx,[eax]
                            mov ecx,[eax + 4]
                            mov edx,[eax + 8]
                            mov edi,[eax + 12]

                            mov eax,[v]

                            mov esi,eax
                          //or esi,0
                            add esi,[dst]
                            mov [esi],ebx // 2 at a time

                            mov esi,eax
                            or  esi,NXT2(0)
                            add esi,[dst]
                            mov [esi],ecx

                            mov esi,eax
                            or  esi,NXT4(0)
                            add esi,[dst]
                            mov [esi],edx

                            mov esi,eax
                            or  esi,NXT4(NXT2(0))
                            add esi,[dst]
                            mov [esi],edi

                        // 8 more texels
                            mov eax,[addr]
                            mov ebx,[eax + 16]
                            mov ecx,[eax + 20]
                            mov edx,[eax + 24]
                            mov edi,[eax + 28]

                            mov eax,[v]

                            mov esi,eax
                            or  esi,NXT8(0)
                            add esi,[dst]
                            mov [esi],ebx // 2 at a time

                            mov esi,eax
                            or  esi,NXT8(NXT2(0))
                            add esi,[dst]
                            mov [esi],ecx

                            mov esi,eax
                            or  esi,NXT8(NXT4(0))
                            add esi,[dst]
                            mov [esi],edx

                            mov esi,eax
                            or  esi,NXT8(NXT4(NXT2(0)))
                            add esi,[dst]
                            mov [esi],edi

                        // 8 more texels
                            mov eax,[addr]
                            mov ebx,[eax + 32]
                            mov ecx,[eax + 36]
                            mov edx,[eax + 40]
                            mov edi,[eax + 44]

                            mov eax,[v]

                            mov esi,eax
                            or  esi,NXT16(0)
                            add esi,[dst]
                            mov [esi],ebx // 2 at a time

                            mov esi,eax
                            or  esi,NXT16(NXT2(0))
                            add esi,[dst]
                            mov [esi],ecx

                            mov esi,eax
                            or  esi,NXT16(NXT4(0))
                            add esi,[dst]
                            mov [esi],edx

                            mov esi,eax
                            or  esi,NXT16(NXT4(NXT2(0)))
                            add esi,[dst]
                            mov [esi],edi

                        // 8 more texels
                            mov eax,[addr]
                            mov ebx,[eax + 48]
                            mov ecx,[eax + 52]
                            mov edx,[eax + 56]
                            mov edi,[eax + 60]

                            mov eax,[v]

                            mov esi,eax
                            or  esi,NXT16(NXT8(0))
                            add esi,[dst]
                            mov [esi],ebx // 2 at a time

                            mov esi,eax
                            or  esi,NXT16(NXT8(NXT2(0)))
                            add esi,[dst]
                            mov [esi],ecx

                            mov esi,eax
                            or  esi,NXT16(NXT8(NXT4(0)))
                            add esi,[dst]
                            mov [esi],edx

                            mov esi,eax
                            or  esi,NXT16(NXT8(NXT4(NXT2(0))))
                            add esi,[dst]
                            mov [esi],edi

                            pop ebx
                            pop edi
                            pop esi
                        }

                        v = ((v | (MB_UMASK*2)) + 2*2) & (MB_VMASK*2);
                    }

                    nvMemCopy (dwDestBase,(DWORD)nvTexelScratchBuffer,MB*MB*2,NV_MEMCOPY_WANTDESTALIGNED);
                }

                return;
            }
            case 4: // 32bpp Pentium3
            {
                __asm
                {
                    mov eax,offset nvTexelScratchBuffer
                    mov ecx,(MB * MB * 4) / 32
            xxx32:   prefetch_rm8 (1,rmIND8(rEAX), 0)
                     add eax,32
                     dec ecx
                    jnz xxx32

                    mov eax,[dwSrcBase]
                    prefetch_rm8 (1,rmIND8(rEAX), 0)
                    prefetch_rm8 (1,rmIND8(rEAX),32)
                }

                {
                    DWORD src = dwSrcBase;
                    DWORD dst = (DWORD)nvTexelScratchBuffer;
                    DWORD v = 0;
                    DWORD y;

                    for (y = MB; y; y--)
                    {
                        DWORD u,x;
                        DWORD addr;

                        addr  = src;
                        src  += dwSrcPitch;
                        __asm
                        {
                            mov eax,[src]
                            prefetch_rm8 (1,rmIND8(rEAX), 0)
                            prefetch_rm8 (1,rmIND8(rEAX),32)
                        }

                        u = 0;
                        for (x = MB; x; x--)
                        {
                            DWORD store = dst + (u | v);
                            *(WORD*)store = *(WORD*)addr;

                            addr += 4;
                            u = ((u | (MB_VMASK*4)) + 1*4) & (MB_UMASK*4);
                        }
                        v = ((v | (MB_UMASK*4)) + 2*4) & (MB_VMASK*4);
                    }

                    nvMemCopy (dwDestBase,(DWORD)nvTexelScratchBuffer,MB*MB*4,NV_MEMCOPY_WANTDESTALIGNED);
                }

                return;
            }

        }
    }

    /*
     * default code
     */
    {
        DWORD src = dwSrcBase;
        DWORD dst = (DWORD)nvTexelScratchBuffer;
        DWORD v = 0;
        DWORD y;

        for (y = MB; y; y--)
        {
            DWORD u,x;
            DWORD addr;

            addr  = src;
            src  += dwSrcPitch;

            u = 0;
            for (x = MB; x; x--)
            {
                DWORD store = dst + (u | v);
                *(WORD*)store = *(WORD*)addr;

                addr += dwBPP;
                u     = ((u | (MB_VMASK*dwBPP)) + 1*dwBPP) & (MB_UMASK*dwBPP);
            }
            v = ((v | (MB_UMASK*dwBPP)) + 2*dwBPP) & (MB_VMASK*dwBPP);
        }

        nvMemCopy (dwDestBase,(DWORD)nvTexelScratchBuffer,MB*MB*dwBPP,NV_MEMCOPY_WANTDESTALIGNED);
    }
}

/*
 * nvSwizzleBlt_Lin_Swz_FullTexture
 *
 * software swizzle algorithm for full textures
 *  full texture means:
 *    source width & height == dest width & height
 *    blt rectangle is (0,0) - (w,h)
 */
void nvSwizzleBlt_Lin_Swz_FullTexture
(
    DWORD dwSrcBase,
    DWORD dwSrcPitch,

    DWORD dwDestBase,

    DWORD dwLogW,
    DWORD dwLogH,
    DWORD dwBPP
)
{
    SWIZZLE_ADDR sa;
    DWORD        dwMBPP,dwMBPP2;
    DWORD        x,y;

    /*
     * handle small cases
     */
    if ((dwLogW < L2MB) || (dwLogH < L2MB))
    {
        nvSwizzleSmallBlock (dwSrcBase,dwSrcPitch,
                             dwDestBase,
                             dwLogW,dwLogH,dwBPP);
        return;
    }

    /*
     * adjust width & height for macroblocks
     */
    dwLogW -= L2MB;
    dwLogH -= L2MB;
    dwMBPP  = dwBPP << L2MB;
    dwMBPP2 = dwBPP << (L2MB + L2MB);

    /*
     * optimize for thin vertical case (swizzle bit does not work for this)
     */
    if (!dwLogW)
    {
        for (y = (1 << dwLogH); y; y--)
        {
            nvSwizzleMacroBlock_LS (dwSrcBase,dwSrcPitch,
                                    dwDestBase,
                                    dwBPP);
            dwSrcBase  += dwSrcPitch << L2MB;
            dwDestBase += dwMBPP2;
        }
        return;
    }

    /*
     * prepare swizzle address generation
     */
    nvSwizzleAddrCreate (&sa,dwDestBase,0,0,dwLogW,dwLogH,dwMBPP2);

    /*
     * do macroblock swizzle
     */
    for (y = (1 << dwLogH); y; y--)
    {
        DWORD dwSrc = dwSrcBase;

        for (x = (1 << dwLogW); x; x--)
        {
            nvSwizzleMacroBlock_LS (dwSrc,dwSrcPitch,
                                    nvSwizzleAddrGet(&sa),
                                    dwBPP);

            nvSwizzleAddrNext (&sa);
            dwSrc += dwBPP << L2MB;
        }

        nvSwizzleAddrNewLine (&sa);
        dwSrcBase += dwSrcPitch << L2MB;
    }
}

/*
 * nvSwizzleBlt_Lin_Lin
 *
 * simple SW bit-blt
 */
void nvSwizzleBlt_Lin_Lin
(
    DWORD dwSrcAddr,
    DWORD dwSrcPitch,

    DWORD dwDestAddr,
    DWORD dwDestPitch,

    DWORD dwWidth,
    DWORD dwHeight,
    DWORD dwSubHeight,
    DWORD dwBPP
)
{
    DWORD dwBytes = dwWidth * dwBPP;
    DWORD y;

    for (y = dwHeight; y;)
    {
        DWORD a;
        DWORD h;
        DWORD f = min(dwSubHeight,y);

        /*
         * read linear
         */
        a = (DWORD)&nvTexelScratchBuffer;
        for (h = f; h; h--)
        {
            nvMemCopy (a,dwSrcAddr,dwBytes,NV_MEMCOPY_WANTSRCALIGNED);
            dwSrcAddr += dwSrcPitch;
            a         += dwBytes;
        }

        /*
         * write linear
         */
        a = (DWORD)&nvTexelScratchBuffer;
        for (h = f; h; h--)
        {
            nvMemCopy (dwDestAddr,a,dwBytes,NV_MEMCOPY_WANTDESTALIGNED);
            a          += dwBytes;
            dwDestAddr += dwDestPitch;
        }

        y -= f;
    }
}

/*
 * nvSwizzleBlt_Swz_Lin
 *
 * deswizzle anything
 */
void nvSwizzleBlt_Swz_Lin
(
    SWIZZLE_ADDR *lpSA,

    DWORD         dwDestAddr,
    DWORD         dwDestPitch,

    DWORD         dwWidth,
    DWORD         dwHeight,
    DWORD         dwSubHeight,
    DWORD         dwBPP
)
{
    DWORD dwBytes = dwWidth * dwBPP;
    DWORD y;

    for (y = dwHeight; y;)
    {
        DWORD a;
        DWORD h;
        DWORD f = min(dwSubHeight,y);

        /*
         * read swizzle
         */
        a = (DWORD)&nvTexelScratchBuffer;

        for (h = f; h; h--)
        {
            DWORD x;

            for (x = dwWidth; x; x--)
            {
                TEXELCOPY (a,nvSwizzleAddrGet(lpSA),dwBPP);
                a += dwBPP;
                nvSwizzleAddrNext (lpSA);
            }

            nvSwizzleAddrNewLine (lpSA);
        }

        /*
         * write linear
         */
        a = (DWORD)&nvTexelScratchBuffer;
        for (h = f; h; h--)
        {
            nvMemCopy (dwDestAddr,a,dwBytes,NV_MEMCOPY_WANTDESTALIGNED);
            a          += dwBytes;
            dwDestAddr += dwDestPitch;
        }

        y -= f;
    }
}

/*
 * nvSwizzleBlt_Lin_Swz
 *
 * swizzles anything
 */
void nvSwizzleBlt_Lin_Swz
(
    DWORD         dwSrcAddr,
    DWORD         dwSrcPitch,

    SWIZZLE_ADDR *lpSA,

    DWORD         dwWidth,
    DWORD         dwHeight,
    DWORD         dwSubHeight,
    DWORD         dwBPP
)
{
    DWORD dwBytes   = dwWidth * dwBPP;
    DWORD y;

    for (y = dwHeight; y;)
    {
        DWORD a;
        DWORD h;
        DWORD f = min(dwSubHeight,y);

        /*
         * read linear
         */
        a = (DWORD)&nvTexelScratchBuffer;
        for (h = f; h; h--)
        {
            nvMemCopy (a,dwSrcAddr,dwBytes,NV_MEMCOPY_WANTSRCALIGNED);
            a         += dwBytes;
            dwSrcAddr += dwSrcPitch;
        }

        /*
         * write swizzle
         */
        a = (DWORD)&nvTexelScratchBuffer;
        for (h = f; h; h--)
        {
            DWORD x;

            for (x = dwWidth; x; x--)
            {
                TEXELCOPY (nvSwizzleAddrGet(lpSA),a,dwBPP);
                a += dwBPP;
                nvSwizzleAddrNext (lpSA);
            }
            nvSwizzleAddrNewLine (lpSA);
        }

        y -= f;
    }
}

/*
 * nvSwizzleBlt_Swz_Swz
 *
 * swizzle - swizzle copy, handles anything
 */
void nvSwizzleBlt_Swz_Swz
(
    SWIZZLE_ADDR *lpSASrc,

    SWIZZLE_ADDR *lpSADest,

    DWORD         dwWidth,
    DWORD         dwHeight,
    DWORD         dwSubHeight,
    DWORD         dwBPP
)
{
    DWORD dwBytes   = dwWidth * dwBPP;
    DWORD y;

    for (y = dwHeight; y;)
    {
        DWORD a;
        DWORD h;
        DWORD f = min(dwSubHeight,y);

        /*
         * read swizzle
         */
        a = (DWORD)&nvTexelScratchBuffer;
        for (h = f; h; h--)
        {
            DWORD x;

            for (x = dwWidth; x; x--)
            {
                TEXELCOPY (a,nvSwizzleAddrGet(lpSASrc),dwBPP);
                a += dwBPP;
                nvSwizzleAddrNext (lpSASrc);
            }
            nvSwizzleAddrNewLine (lpSASrc);
        }

        /*
         * write swizzle
         */
        a = (DWORD)&nvTexelScratchBuffer;
        for (h = f; h; h--)
        {
            DWORD x;

            for (x = dwWidth; x; x--)
            {
                TEXELCOPY (nvSwizzleAddrGet(lpSADest),a,dwBPP);
                a += dwBPP;
                nvSwizzleAddrNext (lpSADest);
            }
            nvSwizzleAddrNewLine (lpSADest);
        }

        y -= f;
    }
}

/*
 * exported
 * --------
 */

/*
 * nvSwizzleBlt
 *
 * performs swizzle or deswizzle in the most optimal fashion depending
 * on surface location and specified flags
 *
 * if pTexture != NULL we will block CPU before writing (if needed)
 * & also update retirement date for proper syncronization.
 */
BOOL nvSwizzleBlt
(
    DWORD         dwSrcAddr,
    DWORD         dwSrcLogW,
    DWORD         dwSrcLogH,
    DWORD         dwSrcX0,
    DWORD         dwSrcY0,
    DWORD         dwSrcX1,
    DWORD         dwSrcY1,
    DWORD         dwSrcPitch,

    DWORD         dwDestAddr,
    DWORD         dwDestLogW,
    DWORD         dwDestLogH,
    DWORD         dwDestX,
    DWORD         dwDestY,
    DWORD         dwDestPitch,

    DWORD         dwBPP,
    DWORD         dwFlags
)
{
    /*
     * prepare common variables
     */
    DWORD dwW         = dwSrcX1 - dwSrcX0;
    DWORD dwH         = dwSrcY1 - dwSrcY0;
    BOOL  bWholeSrc   = ((1U << dwSrcLogW)  == dwW) && ((1U << dwSrcLogH)  == dwH);
    BOOL  bWholeDest  = ((1U << dwDestLogW) == dwW) && ((1U << dwDestLogH) == dwH);
    BOOL  bFullTex    = bWholeSrc && bWholeDest && (dwSrcLogW == dwDestLogW) && (dwSrcLogH == dwDestLogH);

    /*
     * sanity check
     */
    if (!dwH || !dwW || !dwSrcAddr || !dwDestAddr) return FALSE;

    /*
     * break into different swizzle cases
     */
    switch (dwFlags & (NV_SWIZFLAG_SRCSWIZZLED | NV_SWIZFLAG_DESTSWIZZLED))
    {
        case 0:                         // lin -> lin
        {
            DWORD dwSubHeight = 4096 / (dwW * dwBPP);
            if (!dwSubHeight) dwSubHeight = 1;
                         else dwSubHeight = min(dwSubHeight,dwH);

            nvSwizzleBlt_Lin_Lin  (dwSrcAddr + dwSrcY0 * dwSrcPitch + dwSrcX0 * dwBPP,
                                   dwSrcPitch,
                                   dwDestAddr + dwDestY * dwDestPitch + dwDestX * dwBPP,
                                   dwDestPitch,
                                   dwW,dwH,dwSubHeight,dwBPP);
            break;
        }
        case NV_SWIZFLAG_SRCSWIZZLED:   // swz -> lin
        {
            SWIZZLE_ADDR sa;
            DWORD        dwSubHeight = 4096 / (dwW * dwBPP);
            if (!dwSubHeight) dwSubHeight = 1;
                         else dwSubHeight = min(dwSubHeight,dwH);

            nvSwizzleAddrCreate (&sa,dwSrcAddr,dwSrcX0,dwSrcY0,dwSrcLogW,dwSrcLogH,dwBPP);

            nvSwizzleBlt_Swz_Lin (&sa,
                                  dwDestAddr + dwDestY * dwDestPitch + dwDestX * dwBPP,
                                  dwDestPitch,
                                  dwW,dwH,dwSubHeight,dwBPP);
        }
        case NV_SWIZFLAG_DESTSWIZZLED:  // lin -> swz
        {
            if (!bFullTex)
            {
                SWIZZLE_ADDR sa;
                DWORD        dwSubHeight = 4096 / (dwW * dwBPP);
                if (!dwSubHeight) dwSubHeight = 1;
                             else dwSubHeight = min(dwSubHeight,dwH);

                nvSwizzleAddrCreate (&sa,dwDestAddr,dwDestX,dwDestY,dwDestLogW,dwDestLogH,dwBPP);

                nvSwizzleBlt_Lin_Swz (dwSrcAddr + dwSrcY0 * dwSrcPitch + dwSrcX0 * dwBPP,
                                      dwSrcPitch,
                                      &sa,
                                      dwW,dwH,dwSubHeight,dwBPP);
            }
            else
            {
                nvSwizzleBlt_Lin_Swz_FullTexture (dwSrcAddr,dwSrcPitch,
                                                  dwDestAddr,
                                                  dwSrcLogW,dwSrcLogH,dwBPP);
            }
            break;
        }
        case NV_SWIZFLAG_SRCSWIZZLED | NV_SWIZFLAG_DESTSWIZZLED: // swz -> swz
        {
            SWIZZLE_ADDR saSrc;
            SWIZZLE_ADDR saDest;
            DWORD        dwSubHeight = 4096 / (dwW * dwBPP);
            if (!dwSubHeight) dwSubHeight = 1;
                         else dwSubHeight = min(dwSubHeight,dwH);

            nvSwizzleAddrCreate (&saSrc, dwSrcAddr, dwSrcX0,dwSrcY0,dwSrcLogW, dwSrcLogH, dwBPP);
            nvSwizzleAddrCreate (&saDest,dwDestAddr,dwDestX,dwDestY,dwDestLogW,dwDestLogH,dwBPP);

            nvSwizzleBlt_Swz_Swz (&saSrc,
                                  &saDest,
                                  dwW,dwH,dwSubHeight,dwBPP);
            break;
        }
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\common\nvUtil\nvmem.cpp ===
/*
 * Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.
 *
 * THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
 * NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
 * IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: NVMEM.CPP                                                         *
*   NVIDIA Fast memory copy loops - copyright strictly enforced             *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Ben de Waal                 11/05/98 - Created                      *
*                                                                           *
\***************************************************************************/
#include "precomp.h"
#include "nvutil.h"
#include "nvinit.h"

/*
 * local macros
 */
#define movaps_r_rm8(r,rm,ofs)      __asm _emit 0x0f __asm _emit 0x28 __asm _emit (mREG(r) | (rm)) __asm _emit (ofs)
#define movaps_rm8_r(rm,ofs,r)      __asm _emit 0x0f __asm _emit 0x29 __asm _emit (mREG(r) | (rm)) __asm _emit (ofs)
#define movups_r_rm8(r,rm,ofs)      __asm _emit 0x0f __asm _emit 0x10 __asm _emit (mREG(r) | (rm)) __asm _emit (ofs)
#define movups_rm8_r(rm,ofs,r)      __asm _emit 0x0f __asm _emit 0x11 __asm _emit (mREG(r) | (rm)) __asm _emit (ofs)
#define prefetch_rm8(h,rm,ofs)      __asm _emit 0x0f __asm _emit 0x18 __asm _emit (mREG(h) | (rm)) __asm _emit (ofs)

/*
 * nvMemCopy1
 *
 * copies src to dest using byte atoms
 */
__inline void nvMemCopy1
(
    DWORD dwDest,
    DWORD dwSrc,
    DWORD dwCount
)
{
    while (dwCount)
    {
        *(BYTE*)dwDest = *(BYTE*)dwSrc;
        dwSrc  ++;
        dwDest ++;
        dwCount--;
    }
}

/*
 * nvMemCopy4
 *
 * copies src to dest using dword atoms.
 */
__inline void nvMemCopy4
(
    DWORD dwDest,
    DWORD dwSrc,
    DWORD dwCount   // in dwords
)
{
    while (dwCount)
    {
        *(DWORD*)dwDest = *(DWORD*)dwSrc;
        dwSrc  += 4;
        dwDest += 4;
        dwCount--;
    }
}

/*
 * nvMemCopy16
 *
 * copies src to dest using 4*dword atoms (if possible).
 */
__inline void nvMemCopy16
(
    DWORD dwDest,
    DWORD dwSrc,
    DWORD dwCount
)
{
    if (g_dwCPUFeatureSet & NV_FS_KATMAI)
    {
        if (dwSrc & 15)
        {
            if (dwDest & 15)
            {
                __asm
                {
                    mov ebx,[dwSrc]
                    mov edx,[dwDest]
                    mov ecx,[dwCount]
            mc16_11: movups_r_rm8 (rXMM0,rmIND8(rEBX),0)
                     add ebx,16
                     movups_rm8_r (rmIND8(rEDX),rXMM0,0)
                     add edx,16
                     dec ecx
                    jnz mc16_11
                }
            }
            else
            {
                __asm
                {
                    mov ebx,[dwSrc]
                    mov edx,[dwDest]
                    mov ecx,[dwCount]
            mc16_12: movups_r_rm8 (rXMM0,rmIND8(rEBX),0)
                     add ebx,16
                     movaps_rm8_r (rmIND8(rEDX),rXMM0,0)
                     add edx,16
                     dec ecx
                    jnz mc16_12
                }
            }
        }
        else
        {
            if (dwDest & 15)
            {
                __asm
                {
                    mov ebx,[dwSrc]
                    mov edx,[dwDest]
                    mov ecx,[dwCount]
            mc16_13: movaps_r_rm8 (rXMM0,rmIND8(rEBX),0)
                     add ebx,16
                     movups_rm8_r (rmIND8(rEDX),rXMM0,0)
                     add edx,16
                     dec ecx
                    jnz mc16_13
                }
            }
            else
            {
                __asm
                {
                    mov ebx,[dwSrc]
                    mov edx,[dwDest]
                    mov ecx,[dwCount]
            mc16_14: movaps_r_rm8 (rXMM0,rmIND8(rEBX),0)
                     add ebx,16
                     movaps_rm8_r (rmIND8(rEDX),rXMM0,0)
                     add edx,16
                     dec ecx
                    jnz mc16_14
                }
            }
        }
    }
    else if (g_dwCPUFeatureSet & NV_FS_MMX)
    {
        __asm
        {
            mov ebx,[dwSrc]
            mov edx,[dwDest]
            mov ecx,[dwCount]
mc16_2:      movq mm0,[ebx]
             movq mm1,[ebx+8]
             add ebx,16
             movq [edx],mm0
             movq [edx+8],mm1
             add edx,16
             dec ecx
            jnz mc16_2
            emms
        }
    }
    else
    {
        nvMemCopy4 (dwDest,dwSrc,dwCount*4);
    }
}

/*
 * nvMemCopy64
 *
 * copies src to dest using 16*dword atoms (if possible).
 */
__inline void nvMemCopy64
(
    DWORD dwDest,
    DWORD dwSrc,
    DWORD dwCount   // in dwords
)
{
    if (g_dwCPUFeatureSet & NV_FS_KATMAI)
    {
        if (dwSrc & 15)
        {
            if (dwDest & 15)
            {
                __asm
                {
                    mov ebx,[dwSrc]
                    mov edx,[dwDest]
                    mov ecx,[dwCount]
        mc64_11:     movups_r_rm8 (rXMM0,rmIND8(rEBX), 0)
                     movups_r_rm8 (rXMM1,rmIND8(rEBX),16)
                     movups_r_rm8 (rXMM2,rmIND8(rEBX),32)
                     movups_r_rm8 (rXMM3,rmIND8(rEBX),48)
                     add ebx,64
                     movups_rm8_r (rmIND8(rEDX), 0,rXMM0)
                     movups_rm8_r (rmIND8(rEDX),16,rXMM1)
                     movups_rm8_r (rmIND8(rEDX),32,rXMM2)
                     movups_rm8_r (rmIND8(rEDX),48,rXMM3)
                     add edx,64
                     dec ecx
                    jnz mc64_11
                }
            }
            else
            {
                __asm
                {
                    mov ebx,[dwSrc]
                    mov edx,[dwDest]
                    mov ecx,[dwCount]
        mc64_12:     movups_r_rm8 (rXMM0,rmIND8(rEBX), 0)
                     movups_r_rm8 (rXMM1,rmIND8(rEBX),16)
                     movups_r_rm8 (rXMM2,rmIND8(rEBX),32)
                     movups_r_rm8 (rXMM3,rmIND8(rEBX),48)
                     add ebx,64
                     movaps_rm8_r (rmIND8(rEDX), 0,rXMM0)
                     movaps_rm8_r (rmIND8(rEDX),16,rXMM1)
                     movaps_rm8_r (rmIND8(rEDX),32,rXMM2)
                     movaps_rm8_r (rmIND8(rEDX),48,rXMM3)
                     add edx,64
                     dec ecx
                    jnz mc64_12
                }
            }
        }
        else
        {
            if (dwDest & 15)
            {
                __asm
                {
                    mov ebx,[dwSrc]
                    mov edx,[dwDest]
                    mov ecx,[dwCount]
        mc64_13:     movaps_r_rm8 (rXMM0,rmIND8(rEBX), 0)
                     movaps_r_rm8 (rXMM1,rmIND8(rEBX),16)
                     movaps_r_rm8 (rXMM2,rmIND8(rEBX),32)
                     movaps_r_rm8 (rXMM3,rmIND8(rEBX),48)
                     add ebx,64
                     movups_rm8_r (rmIND8(rEDX), 0,rXMM0)
                     movups_rm8_r (rmIND8(rEDX),16,rXMM1)
                     movups_rm8_r (rmIND8(rEDX),32,rXMM2)
                     movups_rm8_r (rmIND8(rEDX),48,rXMM3)
                     add edx,64
                     dec ecx
                    jnz mc64_13
                }
            }
            else
            {
                __asm
                {
                    mov ebx,[dwSrc]
                    mov edx,[dwDest]
                    mov ecx,[dwCount]
        mc64_14:     movaps_r_rm8 (rXMM0,rmIND8(rEBX), 0)
                     movaps_r_rm8 (rXMM1,rmIND8(rEBX),16)
                     movaps_r_rm8 (rXMM2,rmIND8(rEBX),32)
                     movaps_r_rm8 (rXMM3,rmIND8(rEBX),48)
                     add ebx,64

                     movaps_rm8_r (rmIND8(rEDX), 0,rXMM0)
                     movaps_rm8_r (rmIND8(rEDX),16,rXMM1)
                     movaps_rm8_r (rmIND8(rEDX),32,rXMM2)
                     movaps_rm8_r (rmIND8(rEDX),48,rXMM3)

                     add edx,64
                     dec ecx
                    jnz mc64_14
                }
            }
        }
    }
    else if (g_dwCPUFeatureSet & NV_FS_MMX)
    {
        __asm
        {
            mov ebx,[dwSrc]
            mov edx,[dwDest]
            mov ecx,[dwCount]
mc64_2:      movq mm0,[ebx+ 0]
             movq mm1,[ebx+ 8]
             movq mm2,[ebx+16]
             movq mm3,[ebx+24]
             movq mm4,[ebx+32]
             movq mm5,[ebx+40]
             movq mm6,[ebx+48]
             movq mm7,[ebx+56]
             add ebx,64
             movq [edx+ 0],mm0
             movq [edx+ 8],mm1
             movq [edx+16],mm2
             movq [edx+24],mm3
             movq [edx+32],mm4
             movq [edx+40],mm5
             movq [edx+48],mm6
             movq [edx+56],mm7
             add edx,64
             dec ecx
            jnz mc64_2
            emms
        }
    }
    else
    {
        nvMemCopy4 (dwDest,dwSrc,dwCount*16);
    }
}

/*
 * nvMemCopy
 *
 * copy memory as fast as we can
 */
void nvMemCopy
(
    DWORD dwDest,
    DWORD dwSrc,
    DWORD dwCount,
    DWORD dwFlags
)
{
    /*
     * small block optimizations
     *  less than 32 bytes gets unaligned dword accesses followed by some bytes (normal memcpy)
     *  less than 128 bytes and caller does not care for alignment
     */
    if ( (dwCount < 32)
     || ((dwCount < 128) && (dwFlags == NV_MEMCOPY_DONTCARE)))
    {
        memcpy ((void*)dwDest,(void*)dwSrc,dwCount);
        return;
    }

    /*
     * align source or dest depending on flags
     */
    {
        DWORD dwNum = (dwFlags & NV_MEMCOPY_WANTSRCALIGNED)
                    ? (dwSrc  & 15)
                    : (dwDest & 15);

        if (dwCount >= 4)
        {
            /*
             * align to 4
             */
            if (dwNum & 3)
            {
                DWORD dwTemp = 4 - (dwNum & 3);
                nvMemCopy1 (dwDest,dwSrc,dwTemp);
                dwSrc   += dwTemp;
                dwDest  += dwTemp;
                dwCount -= dwTemp;
            }

            if (dwCount >= 16)
            {
                /*
                 * align to 16
                 */
                if (dwNum & 12)
                {
                    DWORD dwTemp = 16 - (dwNum & 12);
                    nvMemCopy4 (dwDest,dwSrc,dwTemp / 4);
                    dwSrc   += dwTemp;
                    dwDest  += dwTemp;
                    dwCount -= dwTemp;
                }
            }
        }
    }

    /*
     * copy remaining data
     */
    {
        DWORD dw64 = dwCount & 0xffffffc0;
        DWORD dw16 = dwCount & 0x00000030;
        DWORD dw4  = dwCount & 0x0000000c;
        DWORD dw1  = dwCount & 0x00000003;

        if (dw64)
        {
            nvMemCopy64 (dwDest,dwSrc,dw64 / 64);
            dwDest += dw64;
            dwSrc  += dw64;
        }
        if (dw16)
        {
            nvMemCopy16 (dwDest,dwSrc,dw16 / 16);
            dwDest += dw16;
            dwSrc  += dw16;
        }
        if (dw4)
        {
            nvMemCopy4 (dwDest,dwSrc,dw4 / 4);
            dwDest += dw4;
            dwSrc  += dw4;
        }
        if (dw1)
        {
            nvMemCopy1 (dwDest,dwSrc,dw1 / 1);
            dwDest += dw1;
            dwSrc  += dw1;
        }
    }
}

/*
 * nvMemTouch
 *
 * moves given data block to L1 cache if it fits - else is wastes time
 */
void nvMemTouch
(
    DWORD dwSrc,
    DWORD dwCount
)
{
    __asm
    {
        mov ecx,[dwCount]
        shr ecx,5
         jz mts

        mov ebx,[dwSrc]

    mtl: mov eax,[ebx]
         add ebx,32
         dec ecx
        jnz mtl

    mts:
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\common\nvUtil\nvUtil.h ===
/*
 * Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.
 *
 * THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
 * NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
 * IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: NVUTIL.H                                                          *
*   interface to NV utility functions common to most 3D drivers             *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Ben de Waal                 02/15/99 - wrote it                     *
*                                                                           *
\***************************************************************************/
#ifndef _nvutil_h
#define _nvutil_h

/*
 * constants
 */
#define NV_MEMCOPY_DONTCARE         0   // alignment is not an issue
#define NV_MEMCOPY_WANTSRCALIGNED   1   // source must be aligned
#define NV_MEMCOPY_WANTDESTALIGNED  2   // dest must be aligned

#define NV_SWIZFLAG_SRCSWIZZLED     1   // source is swizzled
#define NV_SWIZFLAG_DESTSWIZZLED    2   // dest is swizzled

#define NV_FS_MMX                   0x00000001      // CPU can do MMX
#define NV_FS_KATMAI                0x00000002      // CPU is a P3 (or later)
#define NV_FS_64MB                  0x10000000      // has at least 64Mb
#define NV_FS_128MB                 0x20000000      // has at least 128Mb
#define NV_FS_256MB                 0x40000000      // has at least 256Mb

/*
 * types
 */
#ifndef _WINDOWS_
#error windows.h must be included before including nvutil.h
#endif

/*
 * macros
 */

/*
 * structs
 */
typedef struct
{
    DWORD dwCPUFeatureSet;
    DWORD dwCPUClockSpeed;
} NVCPUINFO;

/*
 * exports
 */
#ifdef __cplusplus
extern "C" 
{
#endif

/*
 * creation and destruction
 */
void nvUtilCreate  (void);
void nvUtilDestroy (void);

/*
 * CPU caps
 */
void nvGetCPUCaps (NVCPUINFO*);

/*
 * mem copy
 */
void nvMemCopy
(
    DWORD dwDest,                   // dest address
    DWORD dwSrc,                    // source address
    DWORD dwCount,                  // # of bytes to copy
    DWORD dwFlags                   // alignment flags (NV_MEMCOPY_xxx)
);

/*
 * swizzling
 */
BOOL nvSwizzleBlt
(
    DWORD         dwSrcAddr,        // base address
    DWORD         dwSrcLogW,        // log2 of texture width
    DWORD         dwSrcLogH,        // log2 of texture height
    DWORD         dwSrcX0,          // sub rectangle to swizzlw
    DWORD         dwSrcY0,
    DWORD         dwSrcX1,
    DWORD         dwSrcY1,
    DWORD         dwSrcPitch,       // pitch

    DWORD         dwDestAddr,
    DWORD         dwDestLogW,
    DWORD         dwDestLogH,
    DWORD         dwDestX,
    DWORD         dwDestY,
    DWORD         dwDestPitch,

    DWORD         dwBPP,            // bytes pre pixel (not bits per pixel!)
    DWORD         dwFlags           // swizzle flags (NV_SWIZFLAG_xxx)
);

#ifdef __cplusplus
}
#endif

#endif //!_nvutil_h
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\common\nvUtil\nvinit.h ===
#ifndef _nvinit_h
#define _nvinit_h

/*
 * globals
 */
extern DWORD g_dwCPUFeatureSet;
extern DWORD g_dwCPUClockSpeed;

#endif //!_nvinit_h
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\common\src\nvCapture.c ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/

#include "nvCapture.h"
#include <time.h>

#include "targa.c"

#define CAPTURE_MAX_FILESIZE  0x80000000          // 2 GB
#define CAPTURE_MAX_TEMP      (65536 * 10)
#define CAPTURE_MAX_INCS      16                  // maximum number of times file can be inc'ed
                                                  // before temp buffer is flushed
#define CAPTURE_STRING_SIZE   64

#define CAPTURE_FILE_FORMAT_RECORD "%s\\%s%05d.acf"
#define CAPTURE_FILE_FORMAT_PLAY   "%s\\%s%06d.tga"

// globals
HANDLE hCaptureFile                        = NULL;
BYTE   abTempSpace[CAPTURE_MAX_TEMP];
DWORD  adwTempOffset[CAPTURE_MAX_INCS];
DWORD  adwTempSerial[CAPTURE_MAX_INCS];               // the serial number of the file for which this temp data is eventually destined
DWORD  dwTempOffsetCount                   = 0;
DWORD  dwTempOffsetCurrent                 = 0;
DWORD  dwSerialNumber                      = 0;
DWORD  dwPlaySerialNumber                  = 0;
DWORD  dwFileSize                          = 0;
char   szPath[CAPTURE_STRING_SIZE]         = "|||||||";
char   szFilename[CAPTURE_STRING_SIZE]     = "|||||||";
char   szPlayPath[CAPTURE_STRING_SIZE]     = "|||||||";
char   szPlayFilename[CAPTURE_STRING_SIZE] = "|||||||";

// ---------------------------- RECORDING -----------------------------------

//
// captureFilePurge
// remove all old files beginning with serial number dwSerial
//
int captureFilePurge
(
    DWORD dwSerial
)
{
    char  filename[128];
    BOOL  bSuccess;

    do {

        // generate filename
        sprintf (filename, CAPTURE_FILE_FORMAT_RECORD, szPath, szFilename, dwSerial);
        // delete
        bSuccess = DeleteFile (filename);
        // increment
        dwSerial++;

    } while (bSuccess);

    return 1;
}

//
// captureFileOpen
// opens a new capture file with the current serial number
//
int captureFileOpen
(
    DWORD dwSerial
)
{
    char filename[128];

    if (hCaptureFile)
    {
        // shouldn't re-open a file
        __asm int 3
    }

    // generate filename
    sprintf (filename, CAPTURE_FILE_FORMAT_RECORD, szPath, szFilename, dwSerial);

    // open file
    hCaptureFile = CreateFile (filename, GENERIC_WRITE, 0,0, OPEN_ALWAYS, 0,0);
    if (hCaptureFile == INVALID_HANDLE_VALUE)
    {
        hCaptureFile = NULL;
        return 0;
    }

    // set the file pointer to the end. this appears to be
    // the only way to append to a file. how retarded.
    SetFilePointer(hCaptureFile, 0,0, FILE_END);

    return 1;
}

//
// captureFileClose
// closes the current capture file, if any
//
int captureFileClose
(
    void
)
{
    if (hCaptureFile)
    {
        BOOL bSuccess = CloseHandle (hCaptureFile);
        if (!bSuccess)
        {
            __asm int 3
        }
        hCaptureFile = NULL;
    }

    return 1;
}

//
// captureFileInc
// close the current file and open the next in the series
//
int captureFileInc
(
    void
)
{
    dwSerialNumber++;
    dwFileSize = 0;
    return 1;
}

//
// captureLog
// write stuff into the log file (or into a temporary buffer for lack of the former)
//
int captureLog
(
    void     *pBuffer,
    unsigned  uCount
)
{
    DWORD dw;
    DWORD dwCount;

    // do we have to save off buffered data first?
    if (dwTempOffsetCount)
    {
        for (dwCount=0; dwCount<dwTempOffsetCount; dwCount++)
        {
            DWORD dwStart = dwCount ? adwTempOffset[dwCount-1] : 0;
            DWORD dwEnd   = adwTempOffset[dwCount];
            if ((!captureFileOpen(adwTempSerial[dwCount]))
                ||
                (!WriteFile (hCaptureFile, &(abTempSpace[dwStart]), dwEnd-dwStart, &dw, NULL)))
            {
                captureFileClose();
                goto noFileAccess;
            }
            captureFileClose();
        }
        // reset, now that it is empty
        dwTempOffsetCount = 0;
    }

    // write out new data
    if (captureFileOpen(dwSerialNumber))
    {
        if (!WriteFile (hCaptureFile,pBuffer,uCount,&dw,NULL))
        {
            captureFileClose();
            goto noFileAccess;
        }
        captureFileClose();
        dwFileSize += uCount;
        if (dwFileSize > CAPTURE_MAX_FILESIZE)
        {
            // don't let files grow too large
            captureFileInc();
        }
        return 1;
    }

noFileAccess:

    if ((dwTempOffsetCount == 0) ||
        (adwTempSerial[dwTempOffsetCount-1] != dwSerialNumber))
    {
        if (dwTempOffsetCount < CAPTURE_MAX_INCS)
        {
            // move to the next file and save a pointer to this location in the buffer
            adwTempOffset[dwTempOffsetCount] = dwTempOffsetCurrent;
            adwTempSerial[dwTempOffsetCount] = dwSerialNumber;
            dwTempOffsetCount++;
        }
        else
        {
            // we're out of array space
            __asm int 3;
            return 0;
        }
    }

    if (adwTempOffset[dwTempOffsetCount-1] + uCount > CAPTURE_MAX_TEMP)
    {
        DWORD err = GetLastError();
        __asm mov eax,[err]
        __asm int 3; // out of temp space
        return 0;
    }

    // save off temporarily
    memcpy (abTempSpace + adwTempOffset[dwTempOffsetCount-1], pBuffer, uCount);

    dwTempOffsetCurrent += uCount;
    adwTempOffset[dwTempOffsetCount-1] = dwTempOffsetCurrent;

    return 1;
}

//
// captureSetParams
// set name, path, and base serial number of recorded files
//
int captureSetParams
(
    char  *szBasePath,      // directory in which to dump captures (NULL is legal)
    char  *szBaseFilename,  // base name of files to write
    DWORD  dwBaseFilenum    // the serial number of the first file recorded
)
{
    DWORD dwStrEnd;

    // get rid of terminating '\' (if it exists) since
    // we'll tack one on later and having two is ugly
    dwStrEnd = strlen(szBasePath) - 1;
    if (szBasePath[dwStrEnd] == '\\') {
        szBasePath[dwStrEnd] = '\0';
    }

    // if things have changed, update and reset
    if ((strcmp (szBasePath, szPath)) ||
        (strcmp (szBaseFilename, szFilename)))
    {
        if (szBasePath) {
            strncpy (szPath, szBasePath, CAPTURE_STRING_SIZE);
        }
        if (szBaseFilename) {
            strncpy (szFilename, szBaseFilename, CAPTURE_STRING_SIZE);
        }
        dwSerialNumber = dwBaseFilenum;
        dwFileSize     = 0;
        captureFilePurge (dwBaseFilenum);
    }

    return 1;
}

//
// captureStartup
// should be called only once to initialize root capture file
//
int captureStartup
(
    char  *szBasePath,      // directory in which to dump captures (NULL is legal)
    char  *szBaseFilename,  // base name of files to write
    DWORD  dwBaseFilenum    // the serial number of the first file recorded
)
{
    CAPTURE_INFORMATION  info;
    struct tm           *newtime;
    time_t               aclock;
    static BOOL          bCalled = FALSE;

    // defer multiple creations
    if (bCalled) {
        // this shouldn't get called more than once
        __asm int 3
        return 0;
    }
    else {
        bCalled = TRUE;
    }

    captureSetParams (szBasePath, szBaseFilename, dwBaseFilenum);

    // reset temporary file buffer stuff
    dwTempOffsetCount = 0;

    // write header
    memset (&info,0,sizeof(info));
    info.dwJmpCommand         = CAPTURE_JMP_COMMAND;
    info.dwExtensionSignature = CAPTURE_EXT_SIGNATURE;
    info.dwExtensionID        = CAPTURE_XID_INFORMATION;
    info.dwSchema             = CAPTURE_CURRENT_SCHEMA;
    strcpy (info.szInformation,"Capture V1.00::");
#if defined(NVDD32)
    strcat (info.szInformation,"Direct3D::");
#elif defined(__GL_ICD)
    strcat (info.szInformation,"OpenGL::");
#else
    strcat (info.szInformation,"Unknown::");
#endif
    time (&aclock);
    newtime = localtime(&aclock);
    strcat (info.szInformation,asctime(newtime));
    captureLog (&info,sizeof(info));

    // done
    return 1;
}

//
// captureShutdown
// called once when all capturing is done
//
int captureShutdown
(
    void
)
{
    // close the file, if any
    captureFileClose();

    return 1;
}

// ------------------------------ PLAYBACK ----------------------------------

//
// capturePlayFileInc
// increment the playback file counter
//
int capturePlayFileInc
(
    void
)
{
    dwPlaySerialNumber++;
    return 1;
}

//
// capturePlay
// copy the contents of a file into the render target
//
int capturePlay
(
    void *pRenderTarget,
    DWORD dwPitch,
    DWORD dwWidth,
    DWORD dwHeight
)
{
    char  filename[128];
    BYTE *pBuffer;
    int   iTGAWidth, iTGAHeight;
    DWORD i;

    // clear the frame buffer, so we know we're in playback mode
    // even if the file copy fails for some reason
    for (i=0; i<dwHeight; i++)
    {
        memset ((BYTE *)pRenderTarget+i*dwPitch, 0xff, dwWidth);
    }

    // generate filename
    sprintf (filename, CAPTURE_FILE_FORMAT_PLAY, szPlayPath, szPlayFilename, dwPlaySerialNumber);

    // copy contents to render target
    read_targa_file (filename, &pBuffer, &iTGAWidth, &iTGAHeight);

    if (!pBuffer)
    {
        return 0;
    }

    // sanity checks
    if ((4*iTGAWidth != (int)dwWidth) || (iTGAHeight != (int)dwHeight))
    {
        // sizes must match
        __asm int 3
        return 0;
    }

    // copy into the render target
    for (i=0; i<dwHeight; i++)
    {
        memcpy ((BYTE *)pRenderTarget+i*dwPitch, pBuffer+i*dwWidth, dwWidth);
    }

    // free the buffer
    GlobalFree (pBuffer);

    return 1;
}

//
// capturePlaySetParams
// change the name / path / base serial number of the playback files
//
int capturePlaySetParams
(
    char  *szBasePath,      // directory from which to read bitmaps
    char  *szBaseFilename,  // base name of files to read
    DWORD  dwBaseFilenum    // the serial number of the first file played back
)
{
    DWORD dwStrEnd;

    // get rid of terminating '\' (if it exists) since
    // we'll tack one on later and having two is ugly
    dwStrEnd = strlen(szBasePath) - 1;
    if (szBasePath[dwStrEnd] == '\\') {
        szBasePath[dwStrEnd] = '\0';
    }

    // if things have changed, update and reset
    if ((strcmp (szBasePath, szPlayPath)) ||
        (strcmp (szBaseFilename, szPlayFilename)))
    {
        if (szBasePath) {
            strncpy (szPlayPath, szBasePath, CAPTURE_STRING_SIZE);
        }
        if (szBaseFilename) {
            strncpy (szPlayFilename, szBaseFilename, CAPTURE_STRING_SIZE);
        }
        dwPlaySerialNumber = dwBaseFilenum;
    }

    return 1;
}

//
// capturePlayStartup
// should be called only once to initialize root capture file
//
int capturePlayStartup
(
    char  *szBasePath,      // directory from which to read bitmaps
    char  *szBaseFilename,  // base name of files to read
    DWORD  dwBaseFilenum    // the serial number of the first file played back
)
{
    capturePlaySetParams (szBasePath, szBaseFilename, dwBaseFilenum);

    // done
    return 1;
}

//
// capturePlayShutdown
// called once when all playback is done
//
int capturePlayShutdown
(
    void
)
{
    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\common\src\nvD3DKelvinBackend.c ===
#if !defined(IS_OPENGL)
  #include "nvprecomp.h"
#endif

/*****************************************************************************/
#if !defined(IS_OPENGL)
static NV_INLINE void CopyPoint(float *dst, const float *src)
{
    dst[0] = src[0];
    dst[1] = src[1];
    dst[2] = src[2];
    dst[3] = src[3];
}
#endif

/*****************************************************************************/
/*****************************************************************************/

// routines for integer tessellations
void SendGuardCurve(unsigned long curvetype, NV_PATCH_INFO *info, NV_PATCH_QUAD_INFO *quadInfo, unsigned long flags)
{
    unsigned long dwCount = 0x0;
    int i;
    NV_PATCH_CURVE_INFO *pTemp, *pTempN;
    float *pBegin, *pBeginN;
    float *pEnd, *pEndN;
    unsigned long dwMethod;

    HOS_CREATE_AND_ASSIGN_PUSHBUF_LOCALS();

    nvAssert(curvetype == NV097_SET_BEGIN_END_CURVE_CMD_LEFT_GUARD_CURVE ||
             curvetype == NV097_SET_BEGIN_END_CURVE_CMD_RIGHT_GUARD_CURVE);


    //don't send guard curves if there aren't any attribs on that can be guarded
    if (!(info->evalEnables & (0x1 << NV_PATCH_ATTRIB_POSITION)) && !(flags & NV_PATCH_HAS_NORMAL)) { return; }

    //GUARD CURVE DATA SENT IN THIS ORDER!!!!!
    //(1) GUARDPOINT NORMAL (2) GUARDPOINT POSITION (3) GUARDCURVE POSITION (4) GUARDCURVE NORMAL

    if (NV097_SET_BEGIN_END_CURVE_CMD_LEFT_GUARD_CURVE == curvetype) {
        pTemp  = (*quadInfo->pSwatchVBegin)[ATTR_V];
        pBegin = info->pSwatchCorner[ATTR_V][0][0];
        pEnd = info->pSwatchCorner[ATTR_V][1][0];
        if (flags & NV_PATCH_HAS_NORMAL) {
            pTempN = (*quadInfo->pSwatchVBegin)[info->dstNormal];
            pBeginN = info->pSwatchCorner[info->dstNormal][0][0];
            pEndN = info->pSwatchCorner[info->dstNormal][1][0];
        }

    } else {
        pTemp  = (*quadInfo->pSwatchVEnd)[ATTR_V];
        pBegin = info->pSwatchCorner[ATTR_V][0][1];
        pEnd = info->pSwatchCorner[ATTR_V][1][1];
        if (flags & NV_PATCH_HAS_NORMAL)
            pTempN = (*quadInfo->pSwatchVEnd)[info->dstNormal];
            pBeginN = info->pSwatchCorner[info->dstNormal][0][1];
            pEndN = info->pSwatchCorner[info->dstNormal][1][1];
    }

    //  ^-----^-----^
    // /|\ s /|\ s /|\
    //  |  w  |  w  |
    //  |  a  |  a  |
    //  |--t--o--t--|
    //  |  h  |  h  |
    //  o-----+-----o

    //if I'm an inner guard curve (i.e. a RIGHT guard curve, or left guard not on first row/last row) then step forward
    if (quadInfo->stitchVBegin
            && ( ((curvetype == NV097_SET_BEGIN_END_CURVE_CMD_RIGHT_GUARD_CURVE) && !(flags & NV_PATCH_SWATCH_LAST_COL))
                 || ((curvetype == NV097_SET_BEGIN_END_CURVE_CMD_LEFT_GUARD_CURVE)  && !(flags & NV_PATCH_SWATCH_FIRST_COL))))
    {
        if (info->evalEnables & (0x1 << NV_PATCH_ATTRIB_POSITION)) {
            // position is on
            OffsetCurve(info, pTemp,1);
            // and tweak to swatch corner
            CopyPoint(pTemp->coeffs[0], pBegin);
        }
        if (flags & NV_PATCH_HAS_NORMAL) {
            // normal is on
            OffsetCurve(info, pTempN,1);
            // and tweak to swatch corner
            CopyPoint(pTempN->coeffs[0], pBeginN);
        }
    }

    HOS_NOTE("Begin Curve (Guard Curve)");
    dwMethod = ((0x1 << 18) | (HOS_KELVIN_CHANNEL << 13) | (NV097_SET_BEGIN_END_CURVE));
    HOS_PUSH(dwCount, dwMethod);
    HOS_PUSH(dwCount+1, curvetype);
    dwCount += 0x2;

    // send guard point normal
    if (flags & NV_PATCH_HAS_NORMAL) {
        //send guard point normal if active
        HOS_NOTE("Set Curve Coefficients");
        HOS_PUSH(dwCount, ((0x4 << 18) | (HOS_KELVIN_CHANNEL << 13) | (NV097_SET_CURVE_COEFFICIENTS(0))));
        HOS_PUSHF(dwCount+1, VIEW_AS_DWORD(pEndN[0]));
        HOS_PUSHF(dwCount+2, VIEW_AS_DWORD(pEndN[1]));
        HOS_PUSHF(dwCount+3, VIEW_AS_DWORD(pEndN[2]));
        HOS_PUSHF(dwCount+4, VIEW_AS_DWORD(pEndN[3]));
        dwCount+=5;
    }
    HOS_PUSH_ADJUST(dwCount);

    // send guard point position
    dwCount = 0;
    if (info->evalEnables & (0x1 << NV_PATCH_ATTRIB_POSITION)) {
        HOS_PUSH(dwCount, ((0x4 << 18) | (HOS_KELVIN_CHANNEL << 13) | (NV097_SET_CURVE_COEFFICIENTS(0))));
        HOS_PUSHF(dwCount+1, VIEW_AS_DWORD(pEnd[0]));
        HOS_PUSHF(dwCount+2, VIEW_AS_DWORD(pEnd[1]));
        HOS_PUSHF(dwCount+3, VIEW_AS_DWORD(pEnd[2]));
        HOS_PUSHF(dwCount+4, VIEW_AS_DWORD(pEnd[3]));
        dwCount+=5;

        //send guard curve position
        for (i = 0; i < pTemp->order; i++) {
            HOS_NOTE("Set Curve Coefficients");
            HOS_PUSH(dwCount, ((0x4 << 18) | (HOS_KELVIN_CHANNEL << 13) | (NV097_SET_CURVE_COEFFICIENTS(0))));
            HOS_PUSHF(dwCount+1, VIEW_AS_DWORD(pTemp->coeffs[i][0]));
            HOS_PUSHF(dwCount+2, VIEW_AS_DWORD(pTemp->coeffs[i][1]));
            HOS_PUSHF(dwCount+3, VIEW_AS_DWORD(pTemp->coeffs[i][2]));
            HOS_PUSHF(dwCount+4, VIEW_AS_DWORD(pTemp->coeffs[i][3]));
            dwCount+=5;
        }
        HOS_PUSH_ADJUST(dwCount);
    }

    //send guard curve for normal if active
    dwCount = 0;
    if (flags & NV_PATCH_HAS_NORMAL) {
        //send guard curve...
        for (i = 0; i < pTempN->order; i++) {
            HOS_NOTE("Set Curve Coefficients");
            HOS_PUSH(dwCount, ((0x4 << 18) | (HOS_KELVIN_CHANNEL << 13) | (NV097_SET_CURVE_COEFFICIENTS(0))));
            HOS_PUSHF(dwCount+1, VIEW_AS_DWORD(pTempN->coeffs[i][0]));
            HOS_PUSHF(dwCount+2, VIEW_AS_DWORD(pTempN->coeffs[i][1]));
            HOS_PUSHF(dwCount+3, VIEW_AS_DWORD(pTempN->coeffs[i][2]));
            HOS_PUSHF(dwCount+4, VIEW_AS_DWORD(pTempN->coeffs[i][3]));
            dwCount+=5;
        }
    }
    HOS_PUSH(dwCount, ((0x1 << 18) | (HOS_KELVIN_CHANNEL << 13) | (NV097_SET_BEGIN_END_CURVE)));
    HOS_PUSH(dwCount+1, NV097_SET_BEGIN_END_CURVE_CMD_END_CURVE_DATA);
    dwCount+=2;
    HOS_PUSH_ADJUST(dwCount);

    return;
}

void ComputeKelvinHOSControlWords(NV_PATCH_INFO *info, NV_PATCH_QUAD_INFO *quadInfo, long flags)
{
    int hwAttr, numcoeffs, order;
    unsigned int BPControl[4];
    HOS_CREATE_AND_ASSIGN_PUSHBUF_LOCALS();
    unsigned int t1, t2;
    int uMaxSegs = quadInfo->uMaxSegs;
    int vMaxSegs = quadInfo->vMaxSegs;
    int partialWidth, partialHeight, nSwatchU, nSwatchV;
    int doFrac = info->flags & NV_PATCH_FLAG_TESS_FRACTIONAL;

    nvAssert(NV_PATCH_NUMBER_OF_ATTRIBS == 16);   //this is assumed in this loop that follows
    BPControl[0] = BPControl[1] = 0x0;
    numcoeffs = 0;

    for (hwAttr = 0; hwAttr <= 7; hwAttr++) {               //BPControl0
        if (info->evalEnables & (1 << hwAttr)) {
            order = info->maps[hwAttr].uorder;
            nvAssert(order-1 > 0);
            BPControl[0] |= ((order-1) << (hwAttr<<2));     //hwAttr*4
            numcoeffs+=order;
        }
    }

    for (hwAttr = 8; hwAttr < 16; hwAttr++) {               //BPControl1
        if (info->evalEnables & (1 << hwAttr)) {
            order = info->maps[hwAttr].uorder;
            nvAssert(order-1 > 0);
            BPControl[1] |= ((order-1) << ((hwAttr-8)<<2));
            numcoeffs+=order;
        }
    }       

    //in the fractional case we've intentionally rounded up by 1 to subsume the fractional portion of the transition
    //but we don't want to fool the HW with this notational convenience, drop by 1 here if necessary
    if (doFrac) { 
        //stitchUEnd/stitchVEnd are never set in the fractional case so decrement these in the non degenerate cases
        //because the partialwidth/height below won't account for it properly -- in the degenerate case
        //we don't have a last row or last col transition so DON'T decrement here... UGH.
        if (uMaxSegs>1) uMaxSegs--;     
        if (vMaxSegs>1) vMaxSegs--; 
    }
        
    partialWidth = (uMaxSegs - quadInfo->stitchUEnd) % info->maxSwatch;   //should truncate to integer...   
    partialHeight = (vMaxSegs - quadInfo->stitchVEnd) % info->maxSwatch;
    nSwatchU = (uMaxSegs - quadInfo->stitchUEnd - partialWidth)  / info->maxSwatch;
    nSwatchV = (vMaxSegs - quadInfo->stitchVEnd - partialHeight) / info->maxSwatch;   

    //if we have a degenerate regular grid -- ignore the normal
    //counts of SwatchU,SwatchV and set them to 0.  This is required by HW
    //despite appearances.  The Transition inside/outside params in the transition
    //control words will disambiguate this apparent strangeness.
    if (quadInfo->stitchUBegin || quadInfo->stitchUEnd) {
        if (uMaxSegs  <= 1) { nSwatchU = 0; nSwatchV = 0; }
    }
    if (quadInfo->stitchVBegin || quadInfo->stitchVEnd) {
        if (vMaxSegs  <= 1) { nSwatchU = 0; nSwatchV = 0; }
    }

    BPControl[2] = 0x0; //BPControl2
    nvAssert(info->maxSwatch <=17);

    //assumed as a QUAD..
    BPControl[2] = (partialHeight << 26) | (partialWidth << 21) | (info->maxSwatch << 16) | (nSwatchU << 8) | (nSwatchV << 0);

    //Don't turn this on because we don't actully support triangle patches natively... for future work
    //BPControl[2] |=  ((info->flags & NV_PATCH_FLAG_TYPE_TRIANGULAR ? 1 : 0) << 31 /*primitive type */);//
    if (doFrac) {        
        BPControl[3] = (NV097_SET_BEGIN_PATCH3_TESSELATION_FIXED_STITCH << 16); 
        if (quadInfo->uMaxSegs == 1 || quadInfo->vMaxSegs == 1) {
            BPControl[3] |= NV097_SET_BEGIN_PATCH3_ROW_TRNS_FIRST;
            BPControl[3] |= (NV097_SET_BEGIN_PATCH3_COL_TRNS_FIRST << 3);
        } else {
            BPControl[3] |= (NV097_SET_BEGIN_PATCH3_ROW_TRNS_FIRST_AND_LAST | (NV097_SET_BEGIN_PATCH3_COL_TRNS_FIRST_AND_LAST << 3));
        }

    } else {
        // row transitions
        t1 = (quadInfo->stitchVEnd ? 2 : 0) | (quadInfo->stitchVBegin ? 1 : 0);
        if (quadInfo->u0Dir != quadInfo->u1Dir  &&  t1) {
            // reverse transition, and not degenerate
            t1 |= 4;
        }
        nvAssert(t1 != 7);

        // col transitions
        t2 = (quadInfo->stitchUEnd ? 16 : 0) | (quadInfo->stitchUBegin ? 8 : 0);
        if (quadInfo->v0Dir != quadInfo->v1Dir  &&  t2) {
            // reverse col transition, and not degenerate
            t2 |= 0x20;
        }
        nvAssert(t2 != 0x38);
        BPControl[3] = t2 | t1;
    }

    if (quadInfo->uMaxDir ^ quadInfo->vMaxDir ^ info->flipUV) {
        BPControl[3] |= (1 << 14);
    }

    if (info->evalEnables & (1 << NV_PATCH_ATTRIB_POSITION)) {
        order = (info->maps[NV_PATCH_ATTRIB_POSITION].vorder - 1);
        nvAssert(order > 0);
        BPControl[3] |= (order << 6 );
    }
    if (flags & NV_PATCH_HAS_NORMAL || info->evalEnables & (1 << NV_PATCH_ATTRIB_NORMAL)) {
        order = (info->maps[info->dstNormal].vorder - 1);
        nvAssert(order > 0);
        BPControl[3] |= (order << 10);
    }
    BPControl[3] |= (numcoeffs << 24);

    HOS_NOTE("Set Begin Patch");
    HOS_PUSH(0, ((0x1 << 18) | (HOS_KELVIN_CHANNEL << 13) | (NV097_SET_BEGIN_PATCH0)));
    HOS_PUSH(1, BPControl[0]);
    HOS_PUSH(2, ((0x1 << 18) | (HOS_KELVIN_CHANNEL << 13) | (NV097_SET_BEGIN_PATCH1)));
    HOS_PUSH(3, BPControl[1]);
    HOS_PUSH(4, ((0x1 << 18) | (HOS_KELVIN_CHANNEL << 13) | (NV097_SET_BEGIN_PATCH2)));
    HOS_PUSH(5, BPControl[2]);
    HOS_PUSH(6, ((0x1 << 18) | (HOS_KELVIN_CHANNEL << 13) | (NV097_SET_BEGIN_PATCH3)));
    HOS_PUSH(7, BPControl[3]);
    HOS_PUSH_ADJUST(8);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\common\src\nvdbg.cpp ===
// **************************************************************************
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// ********************************* NV Common ******************************
//
//  Module: nvDbg.cpp
//      Shared debugging routines for printing, tracing, etc.
//
// **************************************************************************
//
//  History:
//      Matt Lavoie             18Nov00         extracted from d3d
//      Craig Duttweiler        21Nov00         major rehash
//
// **************************************************************************

#include "CompileControl.h"

#if (IS_WINNT5 || IS_WIN9X)
    #include "nvprecomp.h"
    #pragma hdrstop
    // need to port nvFile to NT4
    #define HAVE_NV_FILE_FACILITY
#endif  // (IS_WINNT5 || IS_WIN9X)

#include "nvUtil.h"
#include "nvDbg.h"
#include <stdarg.h>
#include <minmax.h>

//-------------------------------------------------------------------------
// GLOBAL VARIABLES
//---------------------------------------------------------------------------

#ifdef DEBUG

    int        dbgTrace    = 0;
    NvU32      dbgLevel    = 0;
    NvU32      dbgLog      = 0;
    int        dbgDP2      = 0;

    static int iTraceLevel = 0;

#endif

//-------------------------------------------------------------------------
// DEBUG PRINTING
//---------------------------------------------------------------------------

#if (IS_WINNT4)
    extern "C" void EngDebugPrint( char *, char *, va_list ap );
#endif  // (IS_WINNT4)

static __inline void nvOutputDebugString (char *szStr)
{
#if (IS_WINNT5 || IS_WINNT4)
    EngDebugPrint("", szStr, (va_list)(NULL));
#elif (IS_WIN9X)
    OutputDebugStringA(szStr);
#endif
}
#if 0
//---------------------------------------------------------------------------

void __cdecl PF (char * szFormat, ...)
{
    char str[256];

    nvStrCpy (str, DPF_START_STR);
    nvSprintfVAL (str+nvStrLen(str), szFormat, (va_list)(&szFormat+1));
    nvStrCat (str, DPF_END_STR);
    nvOutputDebugString (str);
}
#endif
//---------------------------------------------------------------------------

#ifdef DEBUG

void __cdecl DPF (char * szFormat, ...)
{
    char str[256];

    nvStrCpy (str, DPF_START_STR);
    nvSprintfVAL (str+nvStrLen(str), szFormat, (va_list)(&szFormat+1));
    nvStrCat (str, DPF_END_STR);

    DPF_PLAIN ("%s", str);
}

#ifdef HAVE_NV_FILE_FACILITY
HANDLE dpf_file;
//-------------------------------------------------------------------------

void __cdecl createDPFLog()
{
    if (dbgLog)
    {
        dpf_file = NvCreateFile(DPF_LOG_FILE, GENERIC_WRITE, 0,0, CREATE_ALWAYS,0,0);
        if (dpf_file != INVALID_HANDLE_VALUE)
        {
            return;
        }

    }
    else
    {
        dpf_file = 0;
    }
}

//-------------------------------------------------------------------------

void __cdecl closeDPFLog()
{
    if (dbgLog)
    {
        if (dpf_file != INVALID_HANDLE_VALUE)
        {
            NvCloseHandle(dpf_file);
            dpf_file = 0;
        }

    }
    else
    {
        dpf_file = 0;
    }
}
#endif

//-------------------------------------------------------------------------

void __cdecl DPF_PLAIN (char * szFormat, ...)
{
    static NvU8 bFirst = TRUE;
    char   str[256];

    nvSprintfVAL (str, szFormat, (va_list)(&szFormat+1));
    nvOutputDebugString (str);

#ifdef HAVE_NV_FILE_FACILITY
    // echo output to root of current working drive
    if (dbgLog) {
        NvU32 dw;
        NvWriteFile (dpf_file,str,nvStrLen(str),&dw,NULL);
    }
#endif
}

//-------------------------------------------------------------------------

void __cdecl DPF_LEVEL (NvU32 dwLevel, char *szFormat, ...)
{
    if (dbgLevel & dwLevel) {
        char str[256];
        nvStrCpy (str, DPF_START_STR);
        nvSprintfVAL (str+nvStrLen(str), szFormat, (va_list)(&szFormat+1));
        nvStrCat (str, DPF_END_STR);
        DPF_PLAIN ("%s", str);
    }
}

//-------------------------------------------------------------------------

void __cdecl DPF_LEVEL_PLAIN (NvU32 dwLevel, char * szFormat, ...)
{
    if (dbgLevel & dwLevel) {
        char str[256];
        nvSprintfVAL (str, szFormat, (va_list)(&szFormat+1));
        DPF_PLAIN ("%s", str);
    }
}

#endif  // DEBUG

//-------------------------------------------------------------------------
// TRACING
//-------------------------------------------------------------------------

#ifdef DEBUG

void __cdecl dbgResetTraceLevel(void)
{
    iTraceLevel = 0;
}

//-------------------------------------------------------------------------

void __cdecl dbgTracePush (char * szFormat, ...)
{
    char szIndent[2*NV_TRACE_MAX_DEPTH+1];
    char szFullStr[512];
    char szSubStr[NV_TRACE_MAX_COLS+1];
    char szOutStr[NV_TRACE_MAX_COLS+1];
    char szDP2[512];
    int  i;

#if IS_WIN9X
    if (global.b16BitCode) { return; }
#endif

    //print only dp2 calls
    nvStrCpy(szDP2,szFormat);
    szDP2[5] = '\0';
    if (dbgDP2 && nvStrCmp(szDP2,"nvDP2")) {
        iTraceLevel++;
        return;
    }
    
    
    
    // Make sure we want to print this level
    if (iTraceLevel >= (dbgTrace & ~NVDBG_TRACE_EXIT)) {
        iTraceLevel++;
        return;
    }

    // get the proper indent
    szIndent[0] = '\0';
    for (i = 0; (i < iTraceLevel) && (i < NV_TRACE_MAX_DEPTH); i++) {
        nvStrCat (szIndent, "  ");
    }
    

    // generate the full string.
    nvStrCpy (szFullStr, NV_TRACE_START_STR);
    nvSprintfVAL (szFullStr+nvStrLen(szFullStr), szFormat, (va_list)(&szFormat+1));
    NvU32 dwLength = nvStrLen (szFullStr);

    // dole it out in chunks
    NvU32 dwMaxCharsPerLine = NV_TRACE_MAX_COLS - nvStrLen(DPF_START_STR) - nvStrLen(szIndent);
    i = 0;
    while (dwLength) {
        NvU32 dwThisLength = min (dwLength,dwMaxCharsPerLine);
        nvStrNCpy (szSubStr, szFullStr+i, dwThisLength);
        szSubStr[dwThisLength] = '\0';
        nvSprintf (szOutStr, "%s%s", szIndent, szSubStr);
        DPF (szOutStr);
        dwLength -= dwThisLength;
        i += dwThisLength;
    }

    iTraceLevel++;
}

//-------------------------------------------------------------------------

void __cdecl dbgTracePop (void)
{
    char szIndent[2 * NV_TRACE_MAX_DEPTH + 1];
    int i;

#if IS_WIN9X
    if (global.b16BitCode) { return; }
#endif


    iTraceLevel--;

    if ((dbgTrace & NVDBG_TRACE_EXIT) && (iTraceLevel < (dbgTrace & ~NVDBG_TRACE_EXIT))) {
        // get the proper indent
        szIndent[0] = '\0';
        for (i = 0; (i < iTraceLevel) && (i < NV_TRACE_MAX_DEPTH); i++) {
            nvStrCat (szIndent, "  ");
        }
        DPF("%sTRACE: [exit]", szIndent);
    }

    // sanity check
    if (iTraceLevel < 0) {
        dbgError("error: iTraceLevel < 0");
    }
}

#elif INSTRUMENT_ALL_CALLS

#define MAXSTACK 1024   // keep track this many levels deep.
char  aszProcName[MAXSTACK][256];
DWORD adwTimeStack[MAXSTACK];
DWORD dwTimeStackIndex = 0;
BOOL  bTimedBefore     = FALSE;

//-------------------------------------------------------------------------

void __cdecl dbgTracePush (LPSTR szFormat, ...)
{
    if (global.b16BitCode) { return; }

    if (dwTimeStackIndex < MAXSTACK) {
        // for now we just keep the format string (no expantion)
        strcpy (&aszProcName[dwTimeStackIndex][10],szFormat);
        // start timer
        adwTimeStack[dwTimeStackIndex] = GetTickCount();
    }
    dwTimeStackIndex++;
}

//-------------------------------------------------------------------------

void __cdecl dbgTracePop (void)
{
    if (global.b16BitCode) { return; }

    // stop timer
    dwTimeStackIndex--;

    if (dwTimeStackIndex < MAXSTACK) {

        DWORD dwDelta = GetTickCount() - adwTimeStack[dwTimeStackIndex];

        if (dwDelta >= IAC_THRESHOLD) {
            // open file
            HANDLE h = NvCreateFile("\\timeinfo.txt",
                                    GENERIC_WRITE,
                                    0,
                                    NULL,
                                    bTimedBefore ? OPEN_ALWAYS : CREATE_ALWAYS, // delete old file on new runs
                                    FILE_ATTRIBUTE_NORMAL,
                                    NULL);
            if (!h) {
                __asm int 3 // cannot create file
            }
            SetFilePointer (h,0,NULL,FILE_END);

            // log time
            DWORD dw;
            aszProcName[dwTimeStackIndex][0] = char('0' + (dwTimeStackIndex / 100) % 10);
            aszProcName[dwTimeStackIndex][1] = char('0' + (dwTimeStackIndex / 10) % 10);
            aszProcName[dwTimeStackIndex][2] = char('0' + (dwTimeStackIndex / 1) % 10);
            aszProcName[dwTimeStackIndex][3] = char(':');
            aszProcName[dwTimeStackIndex][4] = char('0' + (dwDelta / 10000) % 10);
            aszProcName[dwTimeStackIndex][5] = char('0' + (dwDelta / 1000) % 10);
            aszProcName[dwTimeStackIndex][6] = char('0' + (dwDelta / 100) % 10);
            aszProcName[dwTimeStackIndex][7] = char('0' + (dwDelta / 10) % 10);
            aszProcName[dwTimeStackIndex][8] = char('0' + (dwDelta / 1) % 10);
            aszProcName[dwTimeStackIndex][9] = char(':');
            strcat (&aszProcName[dwTimeStackIndex][10],"\r\n");
            NvWriteFile (h,aszProcName[dwTimeStackIndex],strlen(aszProcName[dwTimeStackIndex]),&dw,NULL);

            // done
            NvCloseHandle (h);
            bTimedBefore = TRUE;
        }
    }
}

#endif // INSTRUMENT_ALL_CALLS

//-------------------------------------------------------------------------
// ERROR HANDLING
//---------------------------------------------------------------------------

#ifdef DEBUG

int _nvAssertReport(const char *pszExpr, const char *pszFile, const int nLine)
{
    DPF("Assertion failed!");
    DPF("File: %s", pszFile);
    DPF("Line: %d", nLine);
    DPF("Expression: %s", pszExpr);
    return TRUE;
}

#endif  // DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\common\src\nvGLBackend.c ===
//**************************************************************************
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// **************************************************************************
//
//  Module: nvGLBackend.c
//        gl immediate mode entry points for the patch shared library
//
//  History:
//        Daniel Rohrer    (drohrer)      23Jun00      created
//
// **************************************************************************

/*** OpenGL immediate mode backend ***/

static void GLImm_BeginPrimitive(void *info, NV_PATCH_PRIMITIVE_TYPE primType)
{
    __GLcontext *gc = (__GLcontext *)((NV_PATCH_INFO *)info)->context;

    switch (primType) {
    case NV_PATCH_PRIMITIVE_TSTRIP:
        (*gc->dispatchState->dispatch.Begin)(GL_TRIANGLE_STRIP);
        break;
    case NV_PATCH_PRIMITIVE_TFAN:
        (*gc->dispatchState->dispatch.Begin)(GL_TRIANGLE_FAN);
        break;
    }
}

static void GLImm_EndPrimitive(void *info)
{
    __GLcontext *gc = (__GLcontext *)((NV_PATCH_INFO *)info)->context;

    (*gc->dispatchState->dispatch.End)();
}

#if defined(COMPILE_DEBUG_LIBRARY)
// to check that proper unique vertices are generated
#define MAX_UNIQUE_CHECK    (16*16) //512
int enableUniqueCheck = 0;
int nUniqueVertices = 0;
float   uniqueVertices[MAX_UNIQUE_CHECK][4];

#define EQUAL_VERTEX4FV(p0, p1) ( \
           (EV_AS_INT(p0[0]) == EV_AS_INT(p1[0])) \
        && (EV_AS_INT(p0[1]) == EV_AS_INT(p1[1])) \
        && (EV_AS_INT(p0[2]) == EV_AS_INT(p1[2])) \
        && (EV_AS_INT(p0[3]) == EV_AS_INT(p1[3])) \
    ) \

void addUniqueVertex4fv(float *v)
{
    int ii;

    if (nvDebugLevel < 2) {
        return;
    }
    for (ii = 0;  ii < nUniqueVertices;  ii++) {
        if (EQUAL_VERTEX4FV(uniqueVertices[ii], v)) {
            // found match
            return;
        }
    }
    assert(nUniqueVertices < MAX_UNIQUE_CHECK);
    if (nUniqueVertices >= MAX_UNIQUE_CHECK) {
        return;
    }
    uniqueVertices[nUniqueVertices][0] = v[0];
    uniqueVertices[nUniqueVertices][1] = v[1];
    uniqueVertices[nUniqueVertices][2] = v[2];
    uniqueVertices[nUniqueVertices][3] = v[3];
    nUniqueVertices++;
}

void drawUniqueVertices(void)
{
    int ii;
    float *p;

    glColor3f(0.5f, 0.f, 0.f);
    glEnable(GL_BLEND);
    glBlendFunc(GL_ONE, GL_ONE);

    glPointSize(16);
    glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);

    glBegin(GL_POINTS);
    //ffglBegin(GL_TRIANGLES);
    for (ii = 0;  ii < nUniqueVertices;  ii++) {
        p = uniqueVertices[ii];
        TPRINTF(("%2d) x%08X x%08X x%08X : %g %g %g\n", ii,
                    EV_AS_INT(p[0]), EV_AS_INT(p[1]), EV_AS_INT(p[2]),
                    p[0], p[1], p[2]));
        glVertex4fv(p);

        //ffglVertex3f(p[0],        p[1],       p[2]);
        //ffglVertex3f(p[0]+.05,    p[1],       p[2]);
        //ffglVertex3f(p[0]+.05,    p[1]+.05,   p[2]);
        //ffglVertex3f(p[0],        p[1],       p[2]);
        //ffglVertex3f(p[0]+.05,    p[1],       p[2]);
        //ffglVertex3f(p[0]+.05,    p[1]-.05,   p[2]);
    }
    glEnd();
    glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
}
#endif

// This won't work quite right until we have state aliasing for vertex programs.
static void GLImm_SendVertex(void *info,
                             NV_PATCH_EVAL_OUTPUT *pData, int index)
{
    __GLcontext *gc = (__GLcontext *)((NV_PATCH_INFO *)info)->context;
    unsigned int evalEnables = ((NV_PATCH_INFO *)info)->evalEnables;
    float *attribs = &pData->vertexAttribs[index][0][0];
    int i;

#if defined(COMPILE_DEBUG_LIBRARY)
    if (enableUniqueCheck) {
        addUniqueVertex4fv(&attribs[4*__GL_ATTRIB_POSITION]);
        NV_TRACE_COND(TR_EVAL, 35,
            tprintf("vert x%08X x%08X x%08X : %g %g %g\n",
                    EV_AS_INT(attribs[4*__GL_ATTRIB_POSITION+0]),
                    EV_AS_INT(attribs[4*__GL_ATTRIB_POSITION+1]),
                    EV_AS_INT(attribs[4*__GL_ATTRIB_POSITION+2]),
                    attribs[4*__GL_ATTRIB_POSITION+0],
                    attribs[4*__GL_ATTRIB_POSITION+1],
                    attribs[4*__GL_ATTRIB_POSITION+2]);
        );
    }
#endif

    if (gc->state.enables.general & __GL_VERTEX_PROGRAM_ENABLE) {
        for (i = 1; i < __GL_NUMBER_OF_VERTEX_ATTRIBS; i++) {
            if (evalEnables & (1 << i)) {
                (*gc->dispatchState->extensions.VertexAttrib4fvNV)(i, &attribs[4*i]);
            }
        }
        (*gc->dispatchState->extensions.VertexAttrib4fvNV)(0, &attribs[4*0]);
    } else {
        if (evalEnables & (1 << __GL_ATTRIB_VERTEX_WEIGHT)) {
            (*gc->dispatchState->extensions.VertexWeightfvEXT)
                (&attribs[4*__GL_ATTRIB_VERTEX_WEIGHT]);
        }
        if (evalEnables & (1 << __GL_ATTRIB_NORMAL)) {
            (*gc->dispatchState->dispatch.Normal3fv)
                (&attribs[4*__GL_ATTRIB_NORMAL]);
        }
        if (evalEnables & (1 << __GL_ATTRIB_COLOR)) {
            (*gc->dispatchState->dispatch.Color4fv)
                (&attribs[4*__GL_ATTRIB_COLOR]);
        }
        if (evalEnables & (1 << __GL_ATTRIB_SECONDARY_COLOR)) {
            (*gc->dispatchState->extensions.SecondaryColor3fvEXT)
                (&attribs[4*__GL_ATTRIB_SECONDARY_COLOR]);
        }
        if (evalEnables & (1 << __GL_ATTRIB_FOG_COORD)) {
            (*gc->dispatchState->extensions.FogCoordfvEXT)
                (&attribs[4*__GL_ATTRIB_FOG_COORD]);
        }
        // 2 unused attribs
        for (i = 0; i < __GL_NUMBER_OF_TEXTURE_UNITS; i++) {
            if (evalEnables & (1 << (__GL_ATTRIB_TEXCOORD0 + i))) {
                (*gc->dispatchState->extensions.MultiTexCoord4fvARB)
                    (GL_TEXTURE0_ARB + i, &attribs[4*(__GL_ATTRIB_TEXCOORD0 + i)]);
            }
        }
        // 6 (NV10) or 4 (NV20) unused attribs

        // Must do position (vertex attrib 0) last
        (*gc->dispatchState->dispatch.Vertex4fv)
            (&attribs[4*__GL_ATTRIB_POSITION]);
    }
}

// This allows us to flip the orientation of geometry.
static void GLImm_SetFrontFace(void *info, int reversed)
{
    __GLcontext *gc = (__GLcontext *)((NV_PATCH_INFO *)info)->context;
    unsigned int evalEnables = ((NV_PATCH_INFO *)info)->evalEnables;

    (*gc->dispatchState->dispatch.FrontFace)
        (gc->eval.cachedFrontFaceDirection ^ reversed);
}

static void GLImm_BeginPatch(void *void_info)
{
    NV_PATCH_INFO *info = (NV_PATCH_INFO *)void_info;
    __GLNVstate *state = NV_GET_HWSTATE(info->context);

    assert(!(state->fdEvalMask & NV_PATCH_STATE_OPEN));
    state->fdEvalMask |= NV_PATCH_STATE_OPEN | NV_PATCH_STATE_IN_PB;
}

static void GLImm_EndPatch(void *void_info)
{
    NV_PATCH_INFO *info = (NV_PATCH_INFO *)void_info;
    __GLNVstate *state = NV_GET_HWSTATE(info->context);

    assert(state->fdEvalMask & NV_PATCH_STATE_OPEN);
    state->fdEvalMask &= ~NV_PATCH_STATE_OPEN;
}

static NV_PATCH_BACKEND GLImm_Backend = {
    NULL,
    NULL,
    GLImm_BeginPrimitive,
    GLImm_EndPrimitive,
    GLImm_SendVertex,
    GLImm_SetFrontFace,
    GLImm_BeginPatch,
    GLImm_EndPatch,
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\common\src\nvpatchutilinit.c ===
/*
 * nvPatchUtilInit.c
 *
 * Software emulation for curved surfaces.
 *
 * Copyright (c) 2000, Nvidia Corporation.  All rights reserved.
 */

#if !defined(IS_OPENGL)
#include "nvprecomp.h"
#endif

#if !defined(_WIN64)
#include "x86.h"
#endif

//FOWARD DECLARATIONS ========================================================================

PFOFSTM CompileOffsetFDMatrix2x2(NV_PATCH_INFO *info);
PFOFSTM CompileOffsetFDMatrix4x4(NV_PATCH_INFO *info);
PFOFSTM CompileOffsetFDMatrix6x6(NV_PATCH_INFO *info);
PFOFSTMED CompileOffsetFDMatrixExtractDiscard2x2(NV_PATCH_INFO *info);
PFOFSTMED CompileOffsetFDMatrixExtractDiscard4x4(NV_PATCH_INFO *info);
PFOFSTMED CompileOffsetFDMatrixExtractDiscard6x6(NV_PATCH_INFO *info);
PFOFSC CompileOffsetCurve2x2(NV_PATCH_INFO *info);
PFOFSC CompileOffsetCurve4x4(NV_PATCH_INFO *info);
PFOFSC CompileOffsetCurve6x6(NV_PATCH_INFO *info);
PFMM MatrixMult2x2(NV_PATCH_INFO *info);
PFMM MatrixMult4x4(NV_PATCH_INFO *info);
PFMM MatrixMult6x6(NV_PATCH_INFO *info);

//FD UNIT GLOBAL DATA ========================================================================
/*int bForceSoftware = 0;
void *HOSInnerLoops[16] = {0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0};
unsigned int RetessFDtag[2][2] = {0x3f800000, 0, 0x3f800000, 0};     //[slot][0=ratio/ 1=order]
FDMatrix *RetessFDCache[2] = {NULL,NULL};                            //ptrs to cached FDMatrices
int RetessFDMRU = 0;                                                 //most recently used cache slot*/
NV_PATCH_GLOBAL_DATA g_FDGlobalData = DEFAULT_PATCH_GLOBAL_DATA;

//file scope global variables used by x86.h macros to setup inner loops
static unsigned char *ilcData;
static unsigned int ilcCount = 0x0;
static unsigned int ilcMax = 0x0;

//INIT THE FD UNIT ========================================================================
#ifdef DCR_SEMAPHORE
void InitSemaphoreData(NV_PATCH_INFO *info);
#endif
void nvPatchInitFD(NV_PATCH_INFO *info)
{
#if !defined(IS_OPENGL)
    //init pCache to NULL
    int i;
    for(i=0; i < MAX_EV_CACHE; i++){ if(info->pCache[i]) memset(info->pCache[i],0,sizeof(NV_PATCH_ALLOC_CACHE)); }

#endif

    g_FDGlobalData.cpuType = 0x0;
#if !defined(_WIN64)
    if(info->cpuType & FS_KATMAI)
    {
        g_FDGlobalData.cpuType = FS_KATMAI;
        g_FDGlobalData.HOSInnerLoops[OFFSET_FDMATRIX_ED_2x2] = (void *) CompileOffsetFDMatrixExtractDiscard2x2(info);
        g_FDGlobalData.HOSInnerLoops[OFFSET_FDMATRIX_ED_4x4] = (void *) CompileOffsetFDMatrixExtractDiscard4x4(info);
        g_FDGlobalData.HOSInnerLoops[OFFSET_FDMATRIX_ED_6x6] = (void *) CompileOffsetFDMatrixExtractDiscard6x6(info);
        g_FDGlobalData.HOSInnerLoops[OFFSET_FDMATRIX_ED_DEF] = (void *) 0x0;

        g_FDGlobalData.HOSInnerLoops[OFFSET_FDMATRIX_2x2] =    (void *) CompileOffsetFDMatrix2x2(info);
        g_FDGlobalData.HOSInnerLoops[OFFSET_FDMATRIX_4x4] =    (void *) CompileOffsetFDMatrix4x4(info);
        g_FDGlobalData.HOSInnerLoops[OFFSET_FDMATRIX_6x6] =    (void *) CompileOffsetFDMatrix6x6(info);
        g_FDGlobalData.HOSInnerLoops[OFFSET_FDMATRIX_DEF] =    (void *) 0x0;

        g_FDGlobalData.HOSInnerLoops[OFFSET_CURVE_2x2] = (void *) CompileOffsetCurve2x2(info);
        g_FDGlobalData.HOSInnerLoops[OFFSET_CURVE_4x4] = (void *) CompileOffsetCurve4x4(info);
        g_FDGlobalData.HOSInnerLoops[OFFSET_CURVE_6x6] = (void *) CompileOffsetCurve6x6(info);
        g_FDGlobalData.HOSInnerLoops[OFFSET_CURVE_DEF] =  (void *) 0x0;

        g_FDGlobalData.HOSInnerLoops[OFFSET_MATRIX_MULT_2x2] = (void *) MatrixMult2x2(info);
        g_FDGlobalData.HOSInnerLoops[OFFSET_MATRIX_MULT_4x4] = (void *) MatrixMult4x4(info);
        g_FDGlobalData.HOSInnerLoops[OFFSET_MATRIX_MULT_6x6] = (void *) MatrixMult6x6(info);
        g_FDGlobalData.HOSInnerLoops[OFFSET_MATRIX_MULT_DEF] = 0x0;
    }
    else if(info->cpuType & FS_3DNOW)
    {
        //turn off optimized assembly routines -- I haven't written any 3DNOW stuff
        g_FDGlobalData.cpuType = 0x0;
    }
    else{
        //turn off optimized assembly routines if we don't have KATMAI support
        g_FDGlobalData.cpuType = 0x0;
    }    
#endif

#ifdef DCR_SEMAPHORE
    InitSemaphoreData(info);    
#else
    g_FDGlobalData.bForceSoftware = 0;
#endif

    return;
}

#ifdef DCR_SEMAPHORE
#define PAGE_SIZE   0x00001000
void InitSemaphoreData(NV_PATCH_INFO *info){        
    unsigned long dwSize = 2*PAGE_SIZE;    
    unsigned long dwRootHandle, dwDeviceHandle;

#if defined(IS_OPENGL)
    dwRootHandle = 0;
    dwDeviceHandle = 0;
    nvAssert(0);
#else
    dwRootHandle = ((PNVD3DCONTEXT)info->context)->pDriverData->dwRootHandle;
    dwDeviceHandle = ((PNVD3DCONTEXT)info->context)->pDriverData->dwDeviceHandle;
#endif
 
    dwSize--;
    //setup up mutual exclusion area for FD      
    if(NvRmAllocMemory(dwRootHandle, dwDeviceHandle, 
                        FD_SEMAPHORE_HANDLE, 
                        NV01_MEMORY_SYSTEM,
                        (NVOS02_FLAGS_PHYSICALITY_NONCONTIGUOUS << 4) | 
                        (NVOS02_FLAGS_LOCATION_PCI << 8) | 
                        (NVOS02_FLAGS_COHERENCY_CACHED << 12),
                        (void**)&g_FDGlobalData.baseAllocation,
                        &(dwSize)
                        )){
        g_FDGlobalData.bForceSoftware = 1;
        return;
    }

    //FORCE ALIGNMENT TO A PAGE BOUNDARY FOR SEMAPHORES.
    g_FDGlobalData.alignedAllocation = (BYTE*)((uintptr_t)(g_FDGlobalData.baseAllocation + PAGE_SIZE - 1) & ~(PAGE_SIZE-1));
    g_FDGlobalData.FDSynchCounter = (long *)g_FDGlobalData.alignedAllocation;
    memset(g_FDGlobalData.alignedAllocation,0x0,PAGE_SIZE);

    // map a context dma to the page of semaphores
    if(NvRmAllocContextDma(dwRootHandle,
                        FD_SEMAPHORE_206E_CONTEXT_DMA,
                        NV01_CONTEXT_DMA,
                        DRF_DEF(OS03, _FLAGS, _ACCESS, _READ_ONLY) |
                        DRF_DEF(OS03, _FLAGS, _COHERENCY, _CACHED),
                        (void*) &(g_FDGlobalData.alignedAllocation),
                        PAGE_SIZE-1)){
        g_FDGlobalData.bForceSoftware = 1;
        return;
    }
    
    if(NvRmAllocContextDma(dwRootHandle,
                        FD_SEMAPHORE_097_CONTEXT_DMA,
                        NV01_CONTEXT_DMA,
                        DRF_DEF(OS03, _FLAGS, _ACCESS, _READ_WRITE) |
                        DRF_DEF(OS03, _FLAGS, _COHERENCY, _CACHED),
                        (void*) &(g_FDGlobalData.alignedAllocation),
                        PAGE_SIZE-1)){
        g_FDGlobalData.bForceSoftware = 1;
        return;
    }

    // success
    g_FDGlobalData.bForceSoftware = 0;
    return;
}
#undef PAGE_SIZE
#endif

//TEAR DOWN THE FD UNIT ========================================================================
#if !defined(IS_OPENGL)
void nvPatchDestroyFD()
{
    int i;

#ifdef DCR_SEMAPHORE
#if defined(IS_OPENGL)
    unsigned long dwRootHandle, dwDeviceHandle;
    dwRootHandle = 0;
    dwDeviceHandle = 0;
    nvAssert(0);
#else
    unsigned long dwRootHandle, dwDeviceHandle;
//    dwRootHandle = ((PNVD3DCONTEXT)info->context)->pDriverData->dwRootHandle;
//    dwDeviceHandle = ((PNVD3DCONTEXT)info->context)->pDriverData->dwDeviceHandle;
    dwRootHandle = pDriverData->dwRootHandle;
    dwDeviceHandle = pDriverData->dwDeviceHandle;
#endif
#endif

    if(g_FDGlobalData.bFirstTimeInit){ return; } //we've never initialized FD so ignore this call

    //delete HOS inner loops and Retess cache data
    for(i = 0; i < 16; i++){
        if(g_FDGlobalData.HOSInnerLoops[i]){
            delete (unsigned char *)g_FDGlobalData.HOSInnerLoops[i];
            g_FDGlobalData.HOSInnerLoops[i] = NULL;
        }
    }
    for(i=0; i < MAX_EV_CACHE; i++){
        if(MyCache[i].pBaseCache){ delete MyCache[i].pBaseCache; }
        MyCache[i].pBaseCache = NULL;
        MyCache[i].bytesAllocCache = 0;
        MyCache[i].inUse = 0;
        MyCache[i].contextCache = NULL;
        MyCache[i].countFreeCheck = 0;
    }
    g_FDGlobalData.RetessFDtag[0][0] = (unsigned int)0x3f800000;    g_FDGlobalData.RetessFDtag[0][1] = 0;
    g_FDGlobalData.RetessFDtag[1][0] = (unsigned int)0x3f800000;    g_FDGlobalData.RetessFDtag[1][1] = 0;
    if(g_FDGlobalData.RetessFDCache[0]){ delete g_FDGlobalData.RetessFDCache[0]; g_FDGlobalData.RetessFDCache[0] = NULL; }
    if(g_FDGlobalData.RetessFDCache[1]){ delete g_FDGlobalData.RetessFDCache[1]; g_FDGlobalData.RetessFDCache[1] = NULL; }

    g_FDGlobalData.RetessFDCache[0] = NULL;  //ptrs to cached FDMatrices
    g_FDGlobalData.RetessFDCache[1] = NULL;  //ptrs to cached FDMatrices

#ifdef DCR_SEMAPHORE
    NvRmFree (dwRootHandle, dwDeviceHandle, FD_SEMAPHORE_HANDLE );
    NvRmFree (dwRootHandle, dwDeviceHandle, FD_SEMAPHORE_097_CONTEXT_DMA );
    NvRmFree (dwRootHandle, dwDeviceHandle, FD_SEMAPHORE_206E_CONTEXT_DMA );
#endif

    g_FDGlobalData.bFirstTimeInit = 1;   
}
#endif

#if !defined(_WIN64)
//EXTRACT DISCARD ROUTINES ========================================================================
#define BOFFSET    0xc
#define AOFFSET    0x8
#define MOFFSET    0x4
PFOFSTMED CompileOffsetFDMatrixExtractDiscard2x2(NV_PATCH_INFO *info)
{
    return (PFOFSTMED)(0x0);
}

PFOFSTMED CompileOffsetFDMatrixExtractDiscard4x4(NV_PATCH_INFO *info)
{
    unsigned int loop, extract_v, finished, finished2, finished3, skip_rows, skip_columns;
    unsigned int lEntry;

    ilcData = (unsigned char *)__NV_MALLOC(info->context, 1024);
    if(ilcData == 0x0) return (PFOFSTMED)NULL;    
    ilcCount = 0;    ilcMax = 1024;

    while(ilcCount &31)
    {
        xINT3;
    }
    
    //IF FDMatrix format changes this MUST be changed also.
    nvAssert(sizeof(FDMatrix) == (FDMATRIX_HEADER_SIZE + 16*16*4*sizeof(float)));
    xLABEL(lEntry)

    //void (FASTCALL *PFOFSTMED)(NV_PATCH_CURVE_INFO *dst, int dir, FDMatrix *m, int a, int b);
    //for function above stack frame will look like 
    //      ECX                                         dst            
    //      EDX                                         dir             
    
    xTEST_r_rm          (rEDX, rmREG(rEDX))
    xLABEL(extract_v)
    xJNZ32(0)
    //process as though I were extracting a row
        xMOV_r_rm       (rEAX, rmSIB8) xSIB8_esp(MOFFSET)      //EAX = m
        xADD_rm_imm     (rmREG(rEAX), FDMATRIX_HEADER_SIZE)    //#row/cols data members skipped  ECX=m->data[0][0][0];
        xMOV_rm_imm     (rmIND(rECX), 0x4)                     //fill in the #coeffs in the extracted curve
        xADD_rm_imm     (rmREG(rECX), PATCH_CURVE_HEADER_SIZE) //#coeffs data members skipped  ECX=dst->data;
               
        xMOVLPS_r_rm    (rXMM0,rmIND32(rEAX)) xOFS32(0)     //fetch first two columns
        xMOVHPS_r_rm    (rXMM0,rmIND32(rEAX)) xOFS32(8)
        xMOVLPS_r_rm    (rXMM4,rmIND32(rEAX)) xOFS32(16)
        xMOVHPS_r_rm    (rXMM4,rmIND32(rEAX)) xOFS32(24)        

        xMOV_r_rm       (rEDX, rmSIB8) xSIB8_esp(BOFFSET)   //EDX = b
        xPUSH_r         (rEDX)                              //save off loop var I'll need it again.
        xTEST_r_rm      (rEDX,rmREG(rEDX))
        xLABEL(skip_columns)   
        xJZ32(0)

        xMOVLPS_r_rm    (rXMM1,rmIND32(rEAX)) xOFS32(256)   //fetch rest of values if I'm actually going to use them.
        xMOVHPS_r_rm    (rXMM1,rmIND32(rEAX)) xOFS32(264)
        xMOVLPS_r_rm    (rXMM5,rmIND32(rEAX)) xOFS32(272)
        xMOVHPS_r_rm    (rXMM5,rmIND32(rEAX)) xOFS32(280)        
        xMOVLPS_r_rm    (rXMM2,rmIND32(rEAX)) xOFS32(512)
        xMOVHPS_r_rm    (rXMM2,rmIND32(rEAX)) xOFS32(520)
        xMOVLPS_r_rm    (rXMM6,rmIND32(rEAX)) xOFS32(528)
        xMOVHPS_r_rm    (rXMM6,rmIND32(rEAX)) xOFS32(536)
        xMOVLPS_r_rm    (rXMM3,rmIND32(rEAX)) xOFS32(768)
        xMOVHPS_r_rm    (rXMM3,rmIND32(rEAX)) xOFS32(776)
        xMOVLPS_r_rm    (rXMM7,rmIND32(rEAX)) xOFS32(784)
        xMOVHPS_r_rm    (rXMM7,rmIND32(rEAX)) xOFS32(792)
        xADD_rm_imm     (rmREG(rEAX),32)                    //skip to next two columns
        
        xLABEL(loop)
            xADDPS_r_rm     (rXMM0, rmREG(rXMM1))    
            xADDPS_r_rm     (rXMM1, rmREG(rXMM2))    
            xSUB_rm_imm     (rmREG(rEDX), 0x1)
            xADDPS_r_rm     (rXMM2, rmREG(rXMM3))               
            xADDPS_r_rm     (rXMM4, rmREG(rXMM5))
            xTEST_r_rm      (rEDX,rmREG(rEDX))
            xADDPS_r_rm     (rXMM5, rmREG(rXMM6))
            xADDPS_r_rm     (rXMM6, rmREG(rXMM7))
        xJNZ(loop)
        
        xTARGET_b32     (skip_columns)                      //we skipped columns       
        xMOVLPS_rm_r    (rmIND8(rECX), rXMM0) xOFS8(0)      //save off intermediate results
        xMOVHPS_rm_r    (rmIND8(rECX), rXMM0) xOFS8(8)      
        xMOVLPS_rm_r    (rmIND8(rECX), rXMM4) xOFS8(16)      
        xMOVHPS_rm_r    (rmIND8(rECX), rXMM4) xOFS8(24)     

        xMOVLPS_r_rm    (rXMM0,rmIND32(rEAX)) xOFS32(0)     //fetch next two columns
        xMOVHPS_r_rm    (rXMM0,rmIND32(rEAX)) xOFS32(8)
        xMOVLPS_r_rm    (rXMM4,rmIND32(rEAX)) xOFS32(16)
        xMOVHPS_r_rm    (rXMM4,rmIND32(rEAX)) xOFS32(24)        

        xPOP_r          (rEDX)
        xTEST_r_rm      (rEDX,rmREG(rEDX))
        xLABEL(skip_columns)   
        xJZ32(0)

        xMOVLPS_r_rm    (rXMM1,rmIND32(rEAX)) xOFS32(256)   //fetch rest of values if I'm actually going to use them.
        xMOVHPS_r_rm    (rXMM1,rmIND32(rEAX)) xOFS32(264)
        xMOVLPS_r_rm    (rXMM5,rmIND32(rEAX)) xOFS32(272)
        xMOVHPS_r_rm    (rXMM5,rmIND32(rEAX)) xOFS32(280)        
        xMOVLPS_r_rm    (rXMM2,rmIND32(rEAX)) xOFS32(512)
        xMOVHPS_r_rm    (rXMM2,rmIND32(rEAX)) xOFS32(520)
        xMOVLPS_r_rm    (rXMM6,rmIND32(rEAX)) xOFS32(528)
        xMOVHPS_r_rm    (rXMM6,rmIND32(rEAX)) xOFS32(536)
        xMOVLPS_r_rm    (rXMM3,rmIND32(rEAX)) xOFS32(768)
        xMOVHPS_r_rm    (rXMM3,rmIND32(rEAX)) xOFS32(776)
        xMOVLPS_r_rm    (rXMM7,rmIND32(rEAX)) xOFS32(784)
        xMOVHPS_r_rm    (rXMM7,rmIND32(rEAX)) xOFS32(792)

        xLABEL(loop)
            xADDPS_r_rm     (rXMM0, rmREG(rXMM1))    
            xADDPS_r_rm     (rXMM1, rmREG(rXMM2))    
            xSUB_rm_imm     (rmREG(rEDX), 0x1)
            xADDPS_r_rm     (rXMM2, rmREG(rXMM3))               
            xADDPS_r_rm     (rXMM4, rmREG(rXMM5))
            xTEST_r_rm      (rEDX,  rmREG(rEDX))             //loop over first two cols
            xADDPS_r_rm     (rXMM5, rmREG(rXMM6))
            xADDPS_r_rm     (rXMM6, rmREG(rXMM7))
        xJNZ(loop)
        
        xTARGET_b32     (skip_columns)                       //we skipped columns       
        xMOVLPS_rm_r    (rmIND8(rECX), rXMM0) xOFS8(32)      //save off intermediate results
        xMOVHPS_rm_r    (rmIND8(rECX), rXMM0) xOFS8(40)      
        xMOVLPS_rm_r    (rmIND8(rECX), rXMM4) xOFS8(48)      
        xMOVHPS_rm_r    (rmIND8(rECX), rXMM4) xOFS8(56)     


        xMOV_r_rm       (rEDX, rmSIB8) xSIB8_esp(AOFFSET)  //load EDX<-a
        xTEST_r_rm      (rEDX, rmREG(rEDX))                //skip primary loop if we don't do any work here
        xLABEL(finished2)   
        xJZ32(0)
        
        //fetch data to process from temporary storage...   
        xMOVLPS_r_rm    (rXMM0, rmIND8(rECX)) xOFS8(0)   //only process the row we are interested in
        xMOVHPS_r_rm    (rXMM0, rmIND8(rECX)) xOFS8(8)      
        xMOVLPS_r_rm    (rXMM1, rmIND8(rECX)) xOFS8(16)      
        xMOVHPS_r_rm    (rXMM1, rmIND8(rECX)) xOFS8(24)     
        xMOVLPS_r_rm    (rXMM2, rmIND8(rECX)) xOFS8(32)  
        xMOVHPS_r_rm    (rXMM2, rmIND8(rECX)) xOFS8(40)      
        xMOVLPS_r_rm    (rXMM3, rmIND8(rECX)) xOFS8(48)      
        xMOVHPS_r_rm    (rXMM3, rmIND8(rECX)) xOFS8(56)     

        xLABEL(loop)
            xADDPS_r_rm     (rXMM0, rmREG(rXMM1))
            xSUB_rm_imm     (rmREG(rEDX), 0x1)
            xADDPS_r_rm     (rXMM1, rmREG(rXMM2))    
            xTEST_r_rm      (rEDX, rmREG(rEDX))        //loop over row
            xADDPS_r_rm     (rXMM3, rmREG(rXMM3))               
        xJNZ(loop)

        xMOVLPS_rm_r    (rmIND8(rECX), rXMM0) xOFS8(0)      //save final results
        xMOVHPS_rm_r    (rmIND8(rECX), rXMM0) xOFS8(8)      
        xMOVLPS_rm_r    (rmIND8(rECX), rXMM1) xOFS8(16)      
        xMOVHPS_rm_r    (rmIND8(rECX), rXMM1) xOFS8(24)     
        xMOVLPS_rm_r    (rmIND8(rECX), rXMM2) xOFS8(32)     
        xMOVHPS_rm_r    (rmIND8(rECX), rXMM2) xOFS8(40)      
        //xMOVLPS_rm_r    (rmIND8(rEAX), rXMM3) xOFS8(48)   //XMM3 should already have been stored off from before.
        //xMOVHPS_rm_r    (rmIND8(rEAX), rXMM3) xOFS8(56)     

    xLABEL(finished)
    xJMP(0)
    xTARGET_b32(extract_v)
        //process as though I were extracting a column
        xMOV_r_rm       (rEAX, rmSIB8) xSIB8_esp(MOFFSET)      //ECX = m
        xADD_rm_imm     (rmREG(rEAX), FDMATRIX_HEADER_SIZE)    //#row/cols data members skipped  ECX=m->data[0][0][0];
        xMOV_rm_imm     (rmIND(rECX), 0x4)                     //fill in the #coeffs in the extracted curve
        xADD_rm_imm     (rmREG(rECX), PATCH_CURVE_HEADER_SIZE) //#coeffs data members skipped  ECX=dst->data;

        xMOVLPS_r_rm    (rXMM0,rmIND32(rEAX)) xOFS32(0)     //fetch first two rows
        xMOVHPS_r_rm    (rXMM0,rmIND32(rEAX)) xOFS32(8)
        xMOVLPS_r_rm    (rXMM4,rmIND32(rEAX)) xOFS32(256)
        xMOVHPS_r_rm    (rXMM4,rmIND32(rEAX)) xOFS32(264)        

        xMOV_r_rm       (rEDX, rmSIB8) xSIB8_esp(AOFFSET)   //EDX = a
        xPUSH_r         (rEDX)                              //save off loop var I'll need it again.        
        xTEST_r_rm      (rEDX,rmREG(rEDX))
        xLABEL(skip_rows)   
        xJZ32(0)

        xMOVLPS_r_rm    (rXMM1,rmIND32(rEAX)) xOFS32(16)   //fetch rest of values if I'm actually going to use them.
        xMOVHPS_r_rm    (rXMM1,rmIND32(rEAX)) xOFS32(24)
        xMOVLPS_r_rm    (rXMM5,rmIND32(rEAX)) xOFS32(272)
        xMOVHPS_r_rm    (rXMM5,rmIND32(rEAX)) xOFS32(280)        
        xMOVLPS_r_rm    (rXMM2,rmIND32(rEAX)) xOFS32(32)
        xMOVHPS_r_rm    (rXMM2,rmIND32(rEAX)) xOFS32(40)
        xMOVLPS_r_rm    (rXMM6,rmIND32(rEAX)) xOFS32(288)
        xMOVHPS_r_rm    (rXMM6,rmIND32(rEAX)) xOFS32(296)
        xMOVLPS_r_rm    (rXMM3,rmIND32(rEAX)) xOFS32(48)
        xMOVHPS_r_rm    (rXMM3,rmIND32(rEAX)) xOFS32(56)
        xMOVLPS_r_rm    (rXMM7,rmIND32(rEAX)) xOFS32(304)
        xMOVHPS_r_rm    (rXMM7,rmIND32(rEAX)) xOFS32(312)
        xADD_rm_imm     (rmREG(rEAX),512)                    //skip to next two rows
        
        xLABEL(loop)
            xADDPS_r_rm     (rXMM0, rmREG(rXMM1))    
            xADDPS_r_rm     (rXMM1, rmREG(rXMM2))    
            xSUB_rm_imm     (rmREG(rEDX), 0x1)
            xADDPS_r_rm     (rXMM2, rmREG(rXMM3))               
            xADDPS_r_rm     (rXMM4, rmREG(rXMM5))
            xTEST_r_rm      (rEDX,rmREG(rEDX))
            xADDPS_r_rm     (rXMM5, rmREG(rXMM6))
            xADDPS_r_rm     (rXMM6, rmREG(rXMM7))
        xJNZ(loop)
        
        xTARGET_b32     (skip_rows)                         //we skipped rows
        xMOVLPS_rm_r    (rmIND8(rECX), rXMM0) xOFS8(0)      //save off intermediate results
        xMOVHPS_rm_r    (rmIND8(rECX), rXMM0) xOFS8(8)      
        xMOVLPS_rm_r    (rmIND8(rECX), rXMM4) xOFS8(16)      
        xMOVHPS_rm_r    (rmIND8(rECX), rXMM4) xOFS8(24)     

        xMOVLPS_r_rm    (rXMM0,rmIND32(rEAX)) xOFS32(0)     //fetch first two rows
        xMOVHPS_r_rm    (rXMM0,rmIND32(rEAX)) xOFS32(8)
        xMOVLPS_r_rm    (rXMM4,rmIND32(rEAX)) xOFS32(256)
        xMOVHPS_r_rm    (rXMM4,rmIND32(rEAX)) xOFS32(264)        

        xPOP_r          (rEDX)
        xTEST_r_rm      (rEDX,rmREG(rEDX))
        xLABEL(skip_rows)   
        xJZ32(0)

        xMOVLPS_r_rm    (rXMM1,rmIND32(rEAX)) xOFS32(16)   //fetch rest of values if I'm actually going to use them.
        xMOVHPS_r_rm    (rXMM1,rmIND32(rEAX)) xOFS32(24)
        xMOVLPS_r_rm    (rXMM5,rmIND32(rEAX)) xOFS32(272)
        xMOVHPS_r_rm    (rXMM5,rmIND32(rEAX)) xOFS32(280)        
        xMOVLPS_r_rm    (rXMM2,rmIND32(rEAX)) xOFS32(32)
        xMOVHPS_r_rm    (rXMM2,rmIND32(rEAX)) xOFS32(40)
        xMOVLPS_r_rm    (rXMM6,rmIND32(rEAX)) xOFS32(288)
        xMOVHPS_r_rm    (rXMM6,rmIND32(rEAX)) xOFS32(296)
        xMOVLPS_r_rm    (rXMM3,rmIND32(rEAX)) xOFS32(48)
        xMOVHPS_r_rm    (rXMM3,rmIND32(rEAX)) xOFS32(56)
        xMOVLPS_r_rm    (rXMM7,rmIND32(rEAX)) xOFS32(304)
        xMOVHPS_r_rm    (rXMM7,rmIND32(rEAX)) xOFS32(312)

        xLABEL(loop)
            xADDPS_r_rm     (rXMM0, rmREG(rXMM1))    
            xADDPS_r_rm     (rXMM1, rmREG(rXMM2))    
            xSUB_rm_imm     (rmREG(rEDX), 0x1)
            xADDPS_r_rm     (rXMM2, rmREG(rXMM3))               
            xADDPS_r_rm     (rXMM4, rmREG(rXMM5))
            xTEST_r_rm      (rEDX,  rmREG(rEDX))            //loop over first two colsdd 
            xADDPS_r_rm     (rXMM5, rmREG(rXMM6))
            xADDPS_r_rm     (rXMM6, rmREG(rXMM7))
        xJNZ(loop)
        
        xTARGET_b32     (skip_rows)                         //we skipped rows
        xMOVLPS_rm_r    (rmIND8(rECX), rXMM0) xOFS8(32)     //save off intermediate results
        xMOVHPS_rm_r    (rmIND8(rECX), rXMM0) xOFS8(40)      
        xMOVLPS_rm_r    (rmIND8(rECX), rXMM4) xOFS8(48)      
        xMOVHPS_rm_r    (rmIND8(rECX), rXMM4) xOFS8(56)     

        xMOV_r_rm       (rEDX, rmSIB8) xSIB8_esp(BOFFSET)
        xTEST_r_rm      (rEDX, rmREG(rEDX))                 //skip primary loop if we don't do any work here
        xLABEL(finished3)   
        xJZ32(0)
        
        //fetch data to process from temporary storage...   
        xMOVLPS_r_rm    (rXMM0, rmIND8(rECX)) xOFS8(0)      //only process the row we are interested in
        xMOVHPS_r_rm    (rXMM0, rmIND8(rECX)) xOFS8(8)      
        xMOVLPS_r_rm    (rXMM1, rmIND8(rECX)) xOFS8(16)      
        xMOVHPS_r_rm    (rXMM1, rmIND8(rECX)) xOFS8(24)     
        xMOVLPS_r_rm    (rXMM2, rmIND8(rECX)) xOFS8(32)  
        xMOVHPS_r_rm    (rXMM2, rmIND8(rECX)) xOFS8(40)      
        //xMOVLPS_r_rm    (rXMM3, rmIND8(rECX)) xOFS8(48)      
        //xMOVHPS_r_rm    (rXMM3, rmIND8(rECX)) xOFS8(56)     

        xLABEL(loop)
            xADDPS_r_rm     (rXMM0, rmREG(rXMM1))
            xSUB_rm_imm     (rmREG(rEDX), 0x1)
            xADDPS_r_rm     (rXMM1, rmREG(rXMM2))    
            xTEST_r_rm      (rEDX, rmREG(rEDX))             //loop over row
            xADDPS_r_rm     (rXMM3, rmREG(rXMM3))               
        xJNZ(loop)

        xMOVLPS_rm_r    (rmIND8(rECX), rXMM0) xOFS8(0)      //save final results
        xMOVHPS_rm_r    (rmIND8(rECX), rXMM0) xOFS8(8)      
        xMOVLPS_rm_r    (rmIND8(rECX), rXMM1) xOFS8(16)      
        xMOVHPS_rm_r    (rmIND8(rECX), rXMM1) xOFS8(24)     
        xMOVLPS_rm_r    (rmIND8(rECX), rXMM2) xOFS8(32)     
        xMOVHPS_rm_r    (rmIND8(rECX), rXMM2) xOFS8(40)      
        //xMOVLPS_rm_r    (rmIND8(rEAX), rXMM3) xOFS8(48)   //XMM3 should already have been stored off from before.
        //xMOVHPS_rm_r    (rmIND8(rEAX), rXMM3) xOFS8(56)     

    xTARGET_jmp(finished)
    xTARGET_b32(finished2)
    xTARGET_b32(finished3)
    //save final data

    xRET_imm            (0xc)                           //pop off 10 words for the b,a,m,dir that was pushed via fast call.
    nvAssert(ilcCount < ilcMax);
    return (PFOFSTMED)(ilcData + lEntry);
}


PFOFSTMED CompileOffsetFDMatrixExtractDiscard6x6(NV_PATCH_INFO *info)
{
    return (PFOFSTMED)(0x0);
}


//OFFSET FDMATRIX ROUTINES ========================================================================
PFOFSTM CompileOffsetFDMatrix2x2(NV_PATCH_INFO *info)
{
    unsigned int loop, skip_rows, skip_cols;

    ilcData = (unsigned char *)__NV_MALLOC(info->context, 512);
    if(ilcData == 0x0) return (PFOFSTM)NULL;    
    ilcCount = 0;    ilcMax = 512;

    while(ilcCount &31)
    {
        xINT3;
    }

    //void (FASTCALL *PFOFSTM)(FDMatrix *m, int a, int b);
    //for function above stack frame will look like 
    //      ECX                                         m            
    //      EDX                                         a             
    //      xMOV_r_rm       (rECX, rmSIB8) xSIB8_esp(0x4)   //b
        
    xADD_rm_imm     (rmREG(rECX), FDMATRIX_HEADER_SIZE) //#row/cols data members skipped  ECX=m->data[0][0][0];

    xMOVLPS_r_rm    (rXMM0,rmIND32(rECX)) xOFS32(0)         xMOVHPS_r_rm    (rXMM0,rmIND32(rECX)) xOFS32(8)
    xMOVLPS_r_rm    (rXMM1,rmIND32(rECX)) xOFS32(16)        xMOVHPS_r_rm    (rXMM1,rmIND32(rECX)) xOFS32(24)
    xMOVLPS_r_rm    (rXMM2,rmIND32(rECX)) xOFS32(32)        xMOVHPS_r_rm    (rXMM2,rmIND32(rECX)) xOFS32(40)
    xMOVLPS_r_rm    (rXMM3,rmIND32(rECX)) xOFS32(48)        xMOVHPS_r_rm    (rXMM3,rmIND32(rECX)) xOFS32(56)

    xTEST_r_rm(rEDX, rmREG(rEDX))
    xLABEL(skip_rows)
    xJZ32(0)
    xLABEL(loop)
        xADDPS_r_rm     (rXMM0, rmREG(rXMM1))    
        xSUB_rm_imm     (rmREG(rEDX), 0x1)
        xADDPS_r_rm     (rXMM2, rmREG(rXMM3))    
        xTEST_r_rm      (rEDX,rmREG(rEDX))
    xJNZ(loop)
    
    xTARGET_b32(skip_rows)

    xTEST_r_rm(rEDX, rmREG(rEDX))
    xLABEL(skip_cols)
    xJZ32(0)
    xLABEL(loop)
        xADDPS_r_rm     (rXMM0, rmREG(rXMM2))    
        xSUB_rm_imm     (rmREG(rEDX), 0x1)
        xADDPS_r_rm     (rXMM1, rmREG(rXMM3))    
        xTEST_r_rm      (rEDX,rmREG(rEDX))
    xJNZ(loop)
    
    xTARGET_b32(skip_cols)

    xMOVLPS_rm_r    (rmIND32(rECX),rXMM0) xOFS32(0)         xMOVHPS_rm_r    (rmIND32(rECX),rXMM0) xOFS32(8)
    xMOVLPS_rm_r    (rmIND32(rECX),rXMM1) xOFS32(16)        xMOVHPS_rm_r    (rmIND32(rECX),rXMM1) xOFS32(24)
    xMOVLPS_rm_r    (rmIND32(rECX),rXMM2) xOFS32(32)        xMOVHPS_rm_r    (rmIND32(rECX),rXMM2) xOFS32(40)
    xMOVLPS_rm_r    (rmIND32(rECX),rXMM3) xOFS32(48)        xMOVHPS_rm_r    (rmIND32(rECX),rXMM3) xOFS32(56)

    return (PFOFSTM)(0x0);
}

PFOFSTM CompileOffsetFDMatrix4x4(NV_PATCH_INFO *info)
{
    unsigned int loop, skip_rows, skip_cols;
    unsigned int lEntry;

    ilcData = (unsigned char *)__NV_MALLOC(info->context, 1280);
    if(ilcData == 0x0) return (PFOFSTM)NULL;    
    ilcCount = 0;    ilcMax = 1280;

    while(ilcCount &31)
    {
        xINT3;
    }
    
    //IF FDMatrix format changes this MUST be changed also.
    nvAssert(sizeof(FDMatrix) == (FDMATRIX_HEADER_SIZE + 16*16*4*sizeof(float)));
    xLABEL(lEntry)

    //void (FASTCALL *PFOFSTM)(FDMatrix *m, int a, int b);
    //for function above stack frame will look like 
    //      ECX                                         m            
    //      EDX                                         a             
    //      xMOV_r_rm       (rECX, rmSIB8) xSIB8_esp(0x4)   //b
        
    xADD_rm_imm     (rmREG(rECX), FDMATRIX_HEADER_SIZE)     //#row/cols data members skipped  ECX=m->data[0][0][0];
    xTEST_r_rm(rEDX, rmREG(rEDX))
    xLABEL(skip_rows);
    xJZ32(0)
    xPUSH_r         (rEDX)                              //save this for later.
    //fetch first two rows
    xMOVLPS_r_rm    (rXMM0,rmIND32(rECX)) xOFS32(0)         xMOVHPS_r_rm    (rXMM0,rmIND32(rECX)) xOFS32(8)
    xMOVLPS_r_rm    (rXMM1,rmIND32(rECX)) xOFS32(16)        xMOVHPS_r_rm    (rXMM1,rmIND32(rECX)) xOFS32(24)
    xMOVLPS_r_rm    (rXMM2,rmIND32(rECX)) xOFS32(32)        xMOVHPS_r_rm    (rXMM2,rmIND32(rECX)) xOFS32(40)
    xMOVLPS_r_rm    (rXMM3,rmIND32(rECX)) xOFS32(48)        xMOVHPS_r_rm    (rXMM3,rmIND32(rECX)) xOFS32(56)
    xMOVLPS_r_rm    (rXMM4,rmIND32(rECX)) xOFS32(256+0)     xMOVHPS_r_rm    (rXMM4,rmIND32(rECX)) xOFS32(256+8)
    xMOVLPS_r_rm    (rXMM5,rmIND32(rECX)) xOFS32(256+16)    xMOVHPS_r_rm    (rXMM5,rmIND32(rECX)) xOFS32(256+24)
    xMOVLPS_r_rm    (rXMM6,rmIND32(rECX)) xOFS32(256+32)    xMOVHPS_r_rm    (rXMM6,rmIND32(rECX)) xOFS32(256+40)
    xMOVLPS_r_rm    (rXMM7,rmIND32(rECX)) xOFS32(256+48)    xMOVHPS_r_rm    (rXMM7,rmIND32(rECX)) xOFS32(256+56)        
    xLABEL(loop)
        xADDPS_r_rm     (rXMM0, rmREG(rXMM1))    
        xADDPS_r_rm     (rXMM1, rmREG(rXMM2))    
        xSUB_rm_imm     (rmREG(rEDX), 0x1)
        xADDPS_r_rm     (rXMM2, rmREG(rXMM3))               
        xADDPS_r_rm     (rXMM4, rmREG(rXMM5))
        xTEST_r_rm      (rEDX,rmREG(rEDX))
        xADDPS_r_rm     (rXMM5, rmREG(rXMM6))
        xADDPS_r_rm     (rXMM6, rmREG(rXMM7))
    xJNZ(loop)
    //save results 
    xMOVLPS_rm_r    (rmIND32(rECX),rXMM0) xOFS32(0)         xMOVHPS_rm_r    (rmIND32(rECX),rXMM0) xOFS32(8)
    xMOVLPS_rm_r    (rmIND32(rECX),rXMM1) xOFS32(16)        xMOVHPS_rm_r    (rmIND32(rECX),rXMM1) xOFS32(24)
    xMOVLPS_rm_r    (rmIND32(rECX),rXMM2) xOFS32(32)        xMOVHPS_rm_r    (rmIND32(rECX),rXMM2) xOFS32(40)
    xMOVLPS_rm_r    (rmIND32(rECX),rXMM3) xOFS32(48)        xMOVHPS_rm_r    (rmIND32(rECX),rXMM3) xOFS32(56)
    xMOVLPS_rm_r    (rmIND32(rECX),rXMM4) xOFS32(256+0)     xMOVHPS_rm_r    (rmIND32(rECX),rXMM4) xOFS32(256+8)
    xMOVLPS_rm_r    (rmIND32(rECX),rXMM5) xOFS32(256+16)    xMOVHPS_rm_r    (rmIND32(rECX),rXMM5) xOFS32(256+24)
    xMOVLPS_rm_r    (rmIND32(rECX),rXMM6) xOFS32(256+32)    xMOVHPS_rm_r    (rmIND32(rECX),rXMM6) xOFS32(256+40)
    xMOVLPS_rm_r    (rmIND32(rECX),rXMM7) xOFS32(256+48)    xMOVHPS_rm_r    (rmIND32(rECX),rXMM7) xOFS32(256+56)                    
    
    xADD_rm_imm     (rmREG(rECX), 512)                    //skip to next two rows
    xPOP_r          (rEDX)    
    
    //fetch second two rows
    xMOVLPS_r_rm    (rXMM0,rmIND32(rECX)) xOFS32(0)         xMOVHPS_r_rm    (rXMM0,rmIND32(rECX)) xOFS32(8)
    xMOVLPS_r_rm    (rXMM1,rmIND32(rECX)) xOFS32(16)        xMOVHPS_r_rm    (rXMM1,rmIND32(rECX)) xOFS32(24)
    xMOVLPS_r_rm    (rXMM2,rmIND32(rECX)) xOFS32(32)        xMOVHPS_r_rm    (rXMM2,rmIND32(rECX)) xOFS32(40)
    xMOVLPS_r_rm    (rXMM3,rmIND32(rECX)) xOFS32(48)        xMOVHPS_r_rm    (rXMM3,rmIND32(rECX)) xOFS32(56)
    xMOVLPS_r_rm    (rXMM4,rmIND32(rECX)) xOFS32(256+0)     xMOVHPS_r_rm    (rXMM4,rmIND32(rECX)) xOFS32(256+8)
    xMOVLPS_r_rm    (rXMM5,rmIND32(rECX)) xOFS32(256+16)    xMOVHPS_r_rm    (rXMM5,rmIND32(rECX)) xOFS32(256+24)
    xMOVLPS_r_rm    (rXMM6,rmIND32(rECX)) xOFS32(256+32)    xMOVHPS_r_rm    (rXMM6,rmIND32(rECX)) xOFS32(256+40)
    xMOVLPS_r_rm    (rXMM7,rmIND32(rECX)) xOFS32(256+48)    xMOVHPS_r_rm    (rXMM7,rmIND32(rECX)) xOFS32(256+56)        
    xLABEL(loop)
        xADDPS_r_rm     (rXMM0, rmREG(rXMM1))    
        xADDPS_r_rm     (rXMM1, rmREG(rXMM2))    
        xSUB_rm_imm     (rmREG(rEDX), 0x1)
        xADDPS_r_rm     (rXMM2, rmREG(rXMM3))               
        xADDPS_r_rm     (rXMM4, rmREG(rXMM5))
        xTEST_r_rm      (rEDX,rmREG(rEDX))
        xADDPS_r_rm     (rXMM5, rmREG(rXMM6))
        xADDPS_r_rm     (rXMM6, rmREG(rXMM7))
    xJNZ(loop)
    //save results 
    xMOVLPS_rm_r    (rmIND32(rECX),rXMM0) xOFS32(0)         xMOVHPS_rm_r    (rmIND32(rECX),rXMM0) xOFS32(8)
    xMOVLPS_rm_r    (rmIND32(rECX),rXMM1) xOFS32(16)        xMOVHPS_rm_r    (rmIND32(rECX),rXMM1) xOFS32(24)
    xMOVLPS_rm_r    (rmIND32(rECX),rXMM2) xOFS32(32)        xMOVHPS_rm_r    (rmIND32(rECX),rXMM2) xOFS32(40)
    xMOVLPS_rm_r    (rmIND32(rECX),rXMM3) xOFS32(48)        xMOVHPS_rm_r    (rmIND32(rECX),rXMM3) xOFS32(56)
    xMOVLPS_rm_r    (rmIND32(rECX),rXMM4) xOFS32(256+0)     xMOVHPS_rm_r    (rmIND32(rECX),rXMM4) xOFS32(256+8)
    xMOVLPS_rm_r    (rmIND32(rECX),rXMM5) xOFS32(256+16)    xMOVHPS_rm_r    (rmIND32(rECX),rXMM5) xOFS32(256+24)
    xMOVLPS_rm_r    (rmIND32(rECX),rXMM6) xOFS32(256+32)    xMOVHPS_rm_r    (rmIND32(rECX),rXMM6) xOFS32(256+40)
    xMOVLPS_rm_r    (rmIND32(rECX),rXMM7) xOFS32(256+48)    xMOVHPS_rm_r    (rmIND32(rECX),rXMM7) xOFS32(256+56)                        
    xADD_rm_imm     (rmREG(rECX), -512) //move back to beginning
    
    xTARGET_b32(skip_rows)    

    xMOV_r_rm       (rEDX, rmSIB8) xSIB8_esp(0x4)   //EDX <-- b
    xTEST_r_rm      (rEDX,rmREG(rEDX))    
    xLABEL(skip_cols)   
    xJZ32(0)
    
    xPUSH_r         (rEDX)
    //fetch first two cols
    xMOVLPS_r_rm    (rXMM0,rmIND32(rECX)) xOFS32(0)         xMOVHPS_r_rm    (rXMM0,rmIND32(rECX)) xOFS32(8)
    xMOVLPS_r_rm    (rXMM1,rmIND32(rECX)) xOFS32(256)       xMOVHPS_r_rm    (rXMM1,rmIND32(rECX)) xOFS32(264)
    xMOVLPS_r_rm    (rXMM2,rmIND32(rECX)) xOFS32(512)       xMOVHPS_r_rm    (rXMM2,rmIND32(rECX)) xOFS32(520)
    xMOVLPS_r_rm    (rXMM3,rmIND32(rECX)) xOFS32(768)       xMOVHPS_r_rm    (rXMM3,rmIND32(rECX)) xOFS32(776)
    xMOVLPS_r_rm    (rXMM4,rmIND32(rECX)) xOFS32(16+0)      xMOVHPS_r_rm    (rXMM4,rmIND32(rECX)) xOFS32(16+8)
    xMOVLPS_r_rm    (rXMM5,rmIND32(rECX)) xOFS32(16+256)    xMOVHPS_r_rm    (rXMM5,rmIND32(rECX)) xOFS32(16+264)
    xMOVLPS_r_rm    (rXMM6,rmIND32(rECX)) xOFS32(16+512)    xMOVHPS_r_rm    (rXMM6,rmIND32(rECX)) xOFS32(16+520)
    xMOVLPS_r_rm    (rXMM7,rmIND32(rECX)) xOFS32(16+768)    xMOVHPS_r_rm    (rXMM7,rmIND32(rECX)) xOFS32(16+776)        
    xLABEL(loop)
        xADDPS_r_rm     (rXMM0, rmREG(rXMM1))    
        xADDPS_r_rm     (rXMM1, rmREG(rXMM2))    
        xSUB_rm_imm     (rmREG(rEDX), 0x1)
        xADDPS_r_rm     (rXMM2, rmREG(rXMM3))               
        xADDPS_r_rm     (rXMM4, rmREG(rXMM5))
        xTEST_r_rm      (rEDX,rmREG(rEDX))
        xADDPS_r_rm     (rXMM5, rmREG(rXMM6))
        xADDPS_r_rm     (rXMM6, rmREG(rXMM7))
    xJNZ(loop)
    //save results 
    xMOVLPS_rm_r    (rmIND32(rECX),rXMM0) xOFS32(0)         xMOVHPS_rm_r    (rmIND32(rECX),rXMM0) xOFS32(8)
    xMOVLPS_rm_r    (rmIND32(rECX),rXMM1) xOFS32(256)       xMOVHPS_rm_r    (rmIND32(rECX),rXMM1) xOFS32(264)
    xMOVLPS_rm_r    (rmIND32(rECX),rXMM2) xOFS32(512)       xMOVHPS_rm_r    (rmIND32(rECX),rXMM2) xOFS32(520)
    xMOVLPS_rm_r    (rmIND32(rECX),rXMM3) xOFS32(768)       xMOVHPS_rm_r    (rmIND32(rECX),rXMM3) xOFS32(776)
    xMOVLPS_rm_r    (rmIND32(rECX),rXMM4) xOFS32(16+0)      xMOVHPS_rm_r    (rmIND32(rECX),rXMM4) xOFS32(16+8)
    xMOVLPS_rm_r    (rmIND32(rECX),rXMM5) xOFS32(16+256)    xMOVHPS_rm_r    (rmIND32(rECX),rXMM5) xOFS32(16+264)
    xMOVLPS_rm_r    (rmIND32(rECX),rXMM6) xOFS32(16+512)    xMOVHPS_rm_r    (rmIND32(rECX),rXMM6) xOFS32(16+520)
    xMOVLPS_rm_r    (rmIND32(rECX),rXMM7) xOFS32(16+768)    xMOVHPS_rm_r    (rmIND32(rECX),rXMM7) xOFS32(16+776)        
    
    xADD_rm_imm     (rmREG(rECX), 32)                    //skip to next two rows
    xPOP_r          (rEDX)    

    xMOVLPS_r_rm    (rXMM0,rmIND32(rECX)) xOFS32(0)         xMOVHPS_r_rm    (rXMM0,rmIND32(rECX)) xOFS32(8)
    xMOVLPS_r_rm    (rXMM1,rmIND32(rECX)) xOFS32(256)       xMOVHPS_r_rm    (rXMM1,rmIND32(rECX)) xOFS32(264)
    xMOVLPS_r_rm    (rXMM2,rmIND32(rECX)) xOFS32(512)       xMOVHPS_r_rm    (rXMM2,rmIND32(rECX)) xOFS32(520)
    xMOVLPS_r_rm    (rXMM3,rmIND32(rECX)) xOFS32(768)       xMOVHPS_r_rm    (rXMM3,rmIND32(rECX)) xOFS32(776)
    xMOVLPS_r_rm    (rXMM4,rmIND32(rECX)) xOFS32(16+0)      xMOVHPS_r_rm    (rXMM4,rmIND32(rECX)) xOFS32(16+8)
    xMOVLPS_r_rm    (rXMM5,rmIND32(rECX)) xOFS32(16+256)    xMOVHPS_r_rm    (rXMM5,rmIND32(rECX)) xOFS32(16+264)
    xMOVLPS_r_rm    (rXMM6,rmIND32(rECX)) xOFS32(16+512)    xMOVHPS_r_rm    (rXMM6,rmIND32(rECX)) xOFS32(16+520)
    xMOVLPS_r_rm    (rXMM7,rmIND32(rECX)) xOFS32(16+768)    xMOVHPS_r_rm    (rXMM7,rmIND32(rECX)) xOFS32(16+776)        
    xLABEL(loop)
        xADDPS_r_rm     (rXMM0, rmREG(rXMM1))    
        xADDPS_r_rm     (rXMM1, rmREG(rXMM2))    
        xSUB_rm_imm     (rmREG(rEDX), 0x1)
        xADDPS_r_rm     (rXMM2, rmREG(rXMM3))               
        xADDPS_r_rm     (rXMM4, rmREG(rXMM5))
        xTEST_r_rm      (rEDX,rmREG(rEDX))
        xADDPS_r_rm     (rXMM5, rmREG(rXMM6))
        xADDPS_r_rm     (rXMM6, rmREG(rXMM7))
    xJNZ(loop)
    //save results 
    xMOVLPS_rm_r    (rmIND32(rECX),rXMM0) xOFS32(0)         xMOVHPS_rm_r    (rmIND32(rECX),rXMM0) xOFS32(8)
    xMOVLPS_rm_r    (rmIND32(rECX),rXMM1) xOFS32(256)       xMOVHPS_rm_r    (rmIND32(rECX),rXMM1) xOFS32(264)
    xMOVLPS_rm_r    (rmIND32(rECX),rXMM2) xOFS32(512)       xMOVHPS_rm_r    (rmIND32(rECX),rXMM2) xOFS32(520)
    xMOVLPS_rm_r    (rmIND32(rECX),rXMM3) xOFS32(768)       xMOVHPS_rm_r    (rmIND32(rECX),rXMM3) xOFS32(776)
    xMOVLPS_rm_r    (rmIND32(rECX),rXMM4) xOFS32(16+0)      xMOVHPS_rm_r    (rmIND32(rECX),rXMM4) xOFS32(16+8)
    xMOVLPS_rm_r    (rmIND32(rECX),rXMM5) xOFS32(16+256)    xMOVHPS_rm_r    (rmIND32(rECX),rXMM5) xOFS32(16+264)
    xMOVLPS_rm_r    (rmIND32(rECX),rXMM6) xOFS32(16+512)    xMOVHPS_rm_r    (rmIND32(rECX),rXMM6) xOFS32(16+520)
    xMOVLPS_rm_r    (rmIND32(rECX),rXMM7) xOFS32(16+768)    xMOVHPS_rm_r    (rmIND32(rECX),rXMM7) xOFS32(16+776)        

    xTARGET_b32(skip_cols)
    xRET_imm            (0x4)                           //pop off 4 words for the m,a,b that was pushed via fast call.
    nvAssert(ilcCount < ilcMax);
    return (PFOFSTM)(ilcData + lEntry);
}

PFOFSTM CompileOffsetFDMatrix6x6(NV_PATCH_INFO *info)
{
    unsigned int loop, outer_loop, skip_rows, skip_cols;
    unsigned int lEntry;

    ilcData = (unsigned char *)__NV_MALLOC(info->context, 1024);
    if(ilcData == 0x0) return (PFOFSTM)NULL;    
    ilcCount = 0;    ilcMax = 1024;

    while(ilcCount &31)
    {
        xINT3;
    }
    
    //IF FDMatrix format changes this MUST be changed also.
    nvAssert(sizeof(FDMatrix) == (FDMATRIX_HEADER_SIZE + 16*16*4*sizeof(float)));
    xLABEL(lEntry)

    //void (FASTCALL *PFOFSTM)(FDMatrix *m, int a, int b);
    //for function above stack frame will look like 
    //      ECX                                         m            
    //      EDX                                         a             
    //      xMOV_r_rm       (rECX, rmSIB8) xSIB8_esp(0x4)   //b
        
    xADD_rm_imm     (rmREG(rECX), FDMATRIX_HEADER_SIZE)     //#row/cols data members skipped  ECX=m->data[0][0][0];
    xTEST_r_rm(rEDX, rmREG(rEDX))
    xLABEL(skip_rows);
    xJZ32(0)
    xMOV_rm_imm     (rmREG(rEAX), 0x6)                  //how many rows to do.
    
    xLABEL(outer_loop)
        xSUB_rm_imm     (rmREG(rEAX), 0x1)
        xPUSH_r         (rEDX)                              //save this for later.
        //fetch a row
        xMOVLPS_r_rm    (rXMM0,rmIND32(rECX)) xOFS32(0)         xMOVHPS_r_rm    (rXMM0,rmIND32(rECX)) xOFS32(8)
        xMOVLPS_r_rm    (rXMM1,rmIND32(rECX)) xOFS32(16)        xMOVHPS_r_rm    (rXMM1,rmIND32(rECX)) xOFS32(24)
        xMOVLPS_r_rm    (rXMM2,rmIND32(rECX)) xOFS32(32)        xMOVHPS_r_rm    (rXMM2,rmIND32(rECX)) xOFS32(40)
        xMOVLPS_r_rm    (rXMM3,rmIND32(rECX)) xOFS32(48)        xMOVHPS_r_rm    (rXMM3,rmIND32(rECX)) xOFS32(56)
        xMOVLPS_r_rm    (rXMM4,rmIND32(rECX)) xOFS32(64)        xMOVHPS_r_rm    (rXMM4,rmIND32(rECX)) xOFS32(72)
        xMOVLPS_r_rm    (rXMM5,rmIND32(rECX)) xOFS32(80)        xMOVHPS_r_rm    (rXMM5,rmIND32(rECX)) xOFS32(88)
        xLABEL(loop)
            xADDPS_r_rm     (rXMM0, rmREG(rXMM1))    
            xADDPS_r_rm     (rXMM1, rmREG(rXMM2))    
            xSUB_rm_imm     (rmREG(rEDX), 0x1)
            xADDPS_r_rm     (rXMM2, rmREG(rXMM3))               
            xADDPS_r_rm     (rXMM3, rmREG(rXMM4))
            xTEST_r_rm      (rEDX,rmREG(rEDX))
            xADDPS_r_rm     (rXMM4, rmREG(rXMM5))
        xJNZ(loop)
        //save results 
        xMOVLPS_rm_r    (rmIND32(rECX),rXMM0) xOFS32(0)         xMOVHPS_rm_r    (rmIND32(rECX),rXMM0) xOFS32(8)
        xMOVLPS_rm_r    (rmIND32(rECX),rXMM1) xOFS32(16)        xMOVHPS_rm_r    (rmIND32(rECX),rXMM1) xOFS32(24)
        xMOVLPS_rm_r    (rmIND32(rECX),rXMM2) xOFS32(32)        xMOVHPS_rm_r    (rmIND32(rECX),rXMM2) xOFS32(40)
        xMOVLPS_rm_r    (rmIND32(rECX),rXMM3) xOFS32(48)        xMOVHPS_rm_r    (rmIND32(rECX),rXMM3) xOFS32(56)
        xMOVLPS_rm_r    (rmIND32(rECX),rXMM4) xOFS32(64)        xMOVHPS_rm_r    (rmIND32(rECX),rXMM4) xOFS32(72)
        //xMOVLPS_rm_r    (rmIND32(rECX),rXMM5) xOFS32(80)        xMOVHPS_rm_r    (rmIND32(rECX),rXMM5) xOFS32(88)    
        xADD_rm_imm     (rmREG(rECX), 256)                      //skip to next row
        xPOP_r          (rEDX)        
    xTEST_r_rm      (rEAX,rmREG(rEAX))
    xJNZ32(outer_loop)
    
    xTARGET_b32(skip_rows)    

    xMOV_r_rm       (rEDX, rmSIB8) xSIB8_esp(0x4)   //EDX <-- b
    xTEST_r_rm      (rEDX,rmREG(rEDX))    
    xLABEL(skip_cols)   
    xJZ32(0)

    xMOV_rm_imm         (rmREG(rEAX), 0x6)                  //how many cols to do.    
    xLABEL(outer_loop)
        xSUB_rm_imm     (rmREG(rEAX), 0x1)    
        xPUSH_r         (rEDX)
        //fetch first two cols
        xMOVLPS_r_rm    (rXMM0,rmIND32(rECX)) xOFS32(0)         xMOVHPS_r_rm    (rXMM0,rmIND32(rECX)) xOFS32(8)
        xMOVLPS_r_rm    (rXMM1,rmIND32(rECX)) xOFS32(256)       xMOVHPS_r_rm    (rXMM1,rmIND32(rECX)) xOFS32(264)
        xMOVLPS_r_rm    (rXMM2,rmIND32(rECX)) xOFS32(512)       xMOVHPS_r_rm    (rXMM2,rmIND32(rECX)) xOFS32(520)
        xMOVLPS_r_rm    (rXMM3,rmIND32(rECX)) xOFS32(768)       xMOVHPS_r_rm    (rXMM3,rmIND32(rECX)) xOFS32(776)
        xMOVLPS_r_rm    (rXMM4,rmIND32(rECX)) xOFS32(1024)      xMOVHPS_r_rm    (rXMM4,rmIND32(rECX)) xOFS32(1032)
        xMOVLPS_r_rm    (rXMM5,rmIND32(rECX)) xOFS32(1280)      xMOVHPS_r_rm    (rXMM5,rmIND32(rECX)) xOFS32(1288)
        xLABEL(loop)
            xADDPS_r_rm     (rXMM0, rmREG(rXMM1))    
            xADDPS_r_rm     (rXMM1, rmREG(rXMM2))    
            xSUB_rm_imm     (rmREG(rEDX), 0x1)
            xADDPS_r_rm     (rXMM2, rmREG(rXMM3))               
            xADDPS_r_rm     (rXMM3, rmREG(rXMM4))
            xTEST_r_rm      (rEDX,rmREG(rEDX))
            xADDPS_r_rm     (rXMM4, rmREG(rXMM5))
        xJNZ(loop)
        //save results 
        xMOVLPS_rm_r    (rmIND32(rECX),rXMM0) xOFS32(0)         xMOVHPS_rm_r    (rmIND32(rECX),rXMM0) xOFS32(8)
        xMOVLPS_rm_r    (rmIND32(rECX),rXMM1) xOFS32(256)       xMOVHPS_rm_r    (rmIND32(rECX),rXMM1) xOFS32(264)
        xMOVLPS_rm_r    (rmIND32(rECX),rXMM2) xOFS32(512)       xMOVHPS_rm_r    (rmIND32(rECX),rXMM2) xOFS32(520)
        xMOVLPS_rm_r    (rmIND32(rECX),rXMM3) xOFS32(768)       xMOVHPS_rm_r    (rmIND32(rECX),rXMM3) xOFS32(776)
        xMOVLPS_rm_r    (rmIND32(rECX),rXMM4) xOFS32(1024)      xMOVHPS_rm_r    (rmIND32(rECX),rXMM4) xOFS32(1032)
        //xMOVLPS_rm_r    (rmIND32(rECX),rXMM5) xOFS32(1280)      xMOVHPS_rm_r    (rmIND32(rECX),rXMM5) xOFS32(1288)    
        xADD_rm_imm     (rmREG(rECX), 16)                    //skip to next column
        xPOP_r          (rEDX)    
    xTEST_r_rm      (rEAX,rmREG(rEAX))
    xJNZ32(outer_loop)    
    xTARGET_b32(skip_cols)
    xRET_imm            (0x4)                           //pop off 4 words for the m,a,b that was pushed via fast call.
    
    nvAssert(ilcCount < ilcMax);
    return (PFOFSTM)(ilcData + lEntry);
}

//OFFSET CURVE ROUTINES ========================================================================
PFOFSC CompileOffsetCurve2x2(NV_PATCH_INFO *info)
{
    return (PFOFSC)(0x0);
}

PFOFSC CompileOffsetCurve4x4(NV_PATCH_INFO *info)
{
    unsigned int loop, finished, lEntry;

    ilcData = (unsigned char *)__NV_MALLOC(info->context, 512);
    if(ilcData == 0x0) return (PFOFSC)NULL;    
    ilcCount = 0;    ilcMax = 512;

    while(ilcCount &31)
    {
        xINT3;
    }

    nvAssert(sizeof(NV_PATCH_CURVE_INFO) == (PATCH_CURVE_HEADER_SIZE + 16*4*sizeof(float)));
    xLABEL(lEntry)

    //void (FASTCALL *PFOFSTM)(NV_PATCH_CURVE *c, int n);
    //for function above stack frame will look like 
    //      ECX                                         c            
    //      EDX                                         n             
    xTEST_r_rm  (rEDX, rmREG(rEDX))
    xLABEL(finished)
    xJZ32(0)
    xMOVLPS_r_rm    (rXMM0,rmIND8(rECX)) xOFS8(PATCH_CURVE_HEADER_SIZE+0)     //4+ skips the order member of the        
    xMOVHPS_r_rm    (rXMM0,rmIND8(rECX)) xOFS8(PATCH_CURVE_HEADER_SIZE+8)     //curve struct
    xMOVLPS_r_rm    (rXMM1,rmIND8(rECX)) xOFS8(PATCH_CURVE_HEADER_SIZE+16)       
    xMOVHPS_r_rm    (rXMM1,rmIND8(rECX)) xOFS8(PATCH_CURVE_HEADER_SIZE+24)
    xMOVLPS_r_rm    (rXMM2,rmIND8(rECX)) xOFS8(PATCH_CURVE_HEADER_SIZE+32)       
    xMOVHPS_r_rm    (rXMM2,rmIND8(rECX)) xOFS8(PATCH_CURVE_HEADER_SIZE+40)
    xMOVLPS_r_rm    (rXMM3,rmIND8(rECX)) xOFS8(PATCH_CURVE_HEADER_SIZE+48)       
    xMOVHPS_r_rm    (rXMM3,rmIND8(rECX)) xOFS8(PATCH_CURVE_HEADER_SIZE+56)       
    xLABEL(loop)
        xADDPS_r_rm     (rXMM0, rmREG(rXMM1))    
        xSUB_rm_imm     (rmREG(rEDX), 0x1)
        xADDPS_r_rm     (rXMM1, rmREG(rXMM2))    
        xTEST_r_rm      (rEDX,rmREG(rEDX))
        xADDPS_r_rm     (rXMM2, rmREG(rXMM3))                   
    xJNZ(loop)
    xMOVLPS_rm_r    (rmIND8(rECX),rXMM0) xOFS8(PATCH_CURVE_HEADER_SIZE+0)     //4+ skips the order member of the        
    xMOVHPS_rm_r    (rmIND8(rECX),rXMM0) xOFS8(PATCH_CURVE_HEADER_SIZE+8)     //curve struct
    xMOVLPS_rm_r    (rmIND8(rECX),rXMM1) xOFS8(PATCH_CURVE_HEADER_SIZE+16)       
    xMOVHPS_rm_r    (rmIND8(rECX),rXMM1) xOFS8(PATCH_CURVE_HEADER_SIZE+24)
    xMOVLPS_rm_r    (rmIND8(rECX),rXMM2) xOFS8(PATCH_CURVE_HEADER_SIZE+32)       
    xMOVHPS_rm_r    (rmIND8(rECX),rXMM2) xOFS8(PATCH_CURVE_HEADER_SIZE+40)
    //xMOVLPS_rm_r    (rmIND8(rECX),rXMM3) xOFS8(4+48)  //don't save off last one     
    //xMOVHPS_rm_r    (rmIND8(rECX),rXMM3) xOFS8(4+56)       
 
    xTARGET_b32(finished)
    xRET_imm            (0x0)                           
    nvAssert(ilcCount < ilcMax);

    return (PFOFSC)(ilcData + lEntry);
}

PFOFSC CompileOffsetCurve6x6(NV_PATCH_INFO *info)
{
   unsigned int loop, finished, lEntry;

    ilcData = (unsigned char *)__NV_MALLOC(info->context, 512);
    if(ilcData == 0x0) return (PFOFSC)NULL;    
    ilcCount = 0;    ilcMax = 512;

    while(ilcCount &31)
    {
        xINT3;
    }
    nvAssert(sizeof(NV_PATCH_CURVE_INFO) == (PATCH_CURVE_HEADER_SIZE + 16*4*sizeof(float)));
    xLABEL(lEntry);

    //void (FASTCALL *PFOFSTM)(NV_PATCH_CURVE *c, int n);
    //for function above stack frame will look like 
    //      ECX                                         c            
    //      EDX                                         n             
    xTEST_r_rm  (rEDX, rmREG(rEDX))
    xLABEL(finished)
    xJZ32(0)
    xMOVLPS_r_rm    (rXMM0,rmIND8(rECX)) xOFS8(PATCH_CURVE_HEADER_SIZE+0)     //4+ skips the order member of the        
    xMOVHPS_r_rm    (rXMM0,rmIND8(rECX)) xOFS8(PATCH_CURVE_HEADER_SIZE+8)     //curve struct
    xMOVLPS_r_rm    (rXMM1,rmIND8(rECX)) xOFS8(PATCH_CURVE_HEADER_SIZE+16)       
    xMOVHPS_r_rm    (rXMM1,rmIND8(rECX)) xOFS8(PATCH_CURVE_HEADER_SIZE+24)
    xMOVLPS_r_rm    (rXMM2,rmIND8(rECX)) xOFS8(PATCH_CURVE_HEADER_SIZE+32)       
    xMOVHPS_r_rm    (rXMM2,rmIND8(rECX)) xOFS8(PATCH_CURVE_HEADER_SIZE+40)
    xMOVLPS_r_rm    (rXMM3,rmIND8(rECX)) xOFS8(PATCH_CURVE_HEADER_SIZE+48)       
    xMOVHPS_r_rm    (rXMM3,rmIND8(rECX)) xOFS8(PATCH_CURVE_HEADER_SIZE+56)       
    xMOVLPS_r_rm    (rXMM4,rmIND8(rECX)) xOFS8(PATCH_CURVE_HEADER_SIZE+64)       
    xMOVHPS_r_rm    (rXMM4,rmIND8(rECX)) xOFS8(PATCH_CURVE_HEADER_SIZE+72)       
    xMOVLPS_r_rm    (rXMM5,rmIND8(rECX)) xOFS8(PATCH_CURVE_HEADER_SIZE+80)       
    xMOVHPS_r_rm    (rXMM5,rmIND8(rECX)) xOFS8(PATCH_CURVE_HEADER_SIZE+88)       

    xLABEL(loop)
        xADDPS_r_rm     (rXMM0, rmREG(rXMM1))    
        xADDPS_r_rm     (rXMM1, rmREG(rXMM2))    
        xSUB_rm_imm     (rmREG(rEDX), 0x1)   
        xADDPS_r_rm     (rXMM2, rmREG(rXMM3))                   
        xTEST_r_rm      (rEDX,rmREG(rEDX))
        xADDPS_r_rm     (rXMM3, rmREG(rXMM4))                   
        xADDPS_r_rm     (rXMM4, rmREG(rXMM5))                   
    xJNZ(loop)
    xMOVLPS_rm_r    (rmIND8(rECX),rXMM0) xOFS8(PATCH_CURVE_HEADER_SIZE+0)   //4+ skips the order member of the        
    xMOVHPS_rm_r    (rmIND8(rECX),rXMM0) xOFS8(PATCH_CURVE_HEADER_SIZE+8)   //curve struct
    xMOVLPS_rm_r    (rmIND8(rECX),rXMM1) xOFS8(PATCH_CURVE_HEADER_SIZE+16)       
    xMOVHPS_rm_r    (rmIND8(rECX),rXMM1) xOFS8(PATCH_CURVE_HEADER_SIZE+24)
    xMOVLPS_rm_r    (rmIND8(rECX),rXMM2) xOFS8(PATCH_CURVE_HEADER_SIZE+32)       
    xMOVHPS_rm_r    (rmIND8(rECX),rXMM2) xOFS8(PATCH_CURVE_HEADER_SIZE+40)
    xMOVLPS_rm_r    (rmIND8(rECX),rXMM3) xOFS8(PATCH_CURVE_HEADER_SIZE+48)  
    xMOVHPS_rm_r    (rmIND8(rECX),rXMM3) xOFS8(PATCH_CURVE_HEADER_SIZE+56)       
    xMOVLPS_rm_r    (rmIND8(rECX),rXMM4) xOFS8(PATCH_CURVE_HEADER_SIZE+64)       
    xMOVHPS_rm_r    (rmIND8(rECX),rXMM4) xOFS8(PATCH_CURVE_HEADER_SIZE+72)   
    //xMOVLPS_rm_r    (rmIND8(rECX),rXMM5) xOFS8(4+80) //don't save off last one       
    //xMOVHPS_rm_r    (rmIND8(rECX),rXMM5) xOFS8(4+88)       
 
    xTARGET_b32(finished)
    xRET_imm            (0x0)                           
    nvAssert(ilcCount < ilcMax);

    return (PFOFSC)(ilcData + lEntry);
}

//MATRIX MULTIPLY ROUTINES ========================================================================
PFMM MatrixMult2x2(NV_PATCH_INFO *info){
/*      x[1][1] = a00*b00+a01*b10;
        x[1][2] = a00*b01+a01*b11;
        x[2][1] = a10*b00+a11*b10;
        x[2][2] = a10*b01+a11*b11;      */
       return (PFMM)(NULL);
}


PFMM MatrixMult6x6(NV_PATCH_INFO *info)
{
    unsigned int lEntry = 0;

#if !defined(IS_OPENGL)
    ilcData = (unsigned char *)__NV_MALLOC(info->context, 8192);
    if(ilcData == 0x0) return (PFMM)NULL;    
    ilcCount = 0;    ilcMax = 8192;

    while(ilcCount &31){
        xINT3;
    }
    xLABEL(lEntry);

    //typedef void (FASTCALL *PFMM)(FDMatrix *dst, FDMatrix *a, FDMatrix *b);
    //for function above stack frame will look like 
    //      ECX                                             dst            
    //      EDX                                             a             
    //      xMOV_r_rm       (rECX, rmSIB8) xSIB8_esp(0x4)   b
    
    xMOV_r_rm       (rEAX, rmSIB8) xSIB8_esp(0x4)           //EAX<-b
    xADD_rm_imm     (rmREG(rEAX), FDMATRIX_HEADER_SIZE)     //#row/cols data members skipped  EAX=b->data[0][0][0];
    xADD_rm_imm     (rmREG(rECX), FDMATRIX_HEADER_SIZE)     //#row/cols data members skipped  ECX=dst->data[0][0][0];
    xADD_rm_imm     (rmREG(rEDX), FDMATRIX_HEADER_SIZE)     //#row/cols data members skipped  EDX=a->data[0][0][0];    

//get first half row vector of a
#define GET_ROWa(a) {                                                               \
                    xMOVLPS_r_rm    (rXMM0,rmIND32(rEDX)) xOFS32((256*a+0));        \
                    xMOVHPS_r_rm    (rXMM0,rmIND32(rEDX)) xOFS32((256*a+8));        \
                    xMOVLPS_r_rm    (rXMM1,rmIND32(rEDX)) xOFS32((256*a+16));       \
                    xMOVHPS_r_rm    (rXMM1,rmIND32(rEDX)) xOFS32((256*a+24));       \
                    xMOVLPS_r_rm    (rXMM2,rmIND32(rEDX)) xOFS32((256*a+32));       \
                    xMOVHPS_r_rm    (rXMM2,rmIND32(rEDX)) xOFS32((256*a+40));       \
                   }

#define GET_ROWb(a) {                                                               \
                    xMOVLPS_r_rm    (rXMM0,rmIND32(rEDX)) xOFS32((256*a+48));       \
                    xMOVHPS_r_rm    (rXMM0,rmIND32(rEDX)) xOFS32((256*a+56));       \
                    xMOVLPS_r_rm    (rXMM1,rmIND32(rEDX)) xOFS32((256*a+64));       \
                    xMOVHPS_r_rm    (rXMM1,rmIND32(rEDX)) xOFS32((256*a+72));       \
                    xMOVLPS_r_rm    (rXMM2,rmIND32(rEDX)) xOFS32((256*a+80));       \
                    xMOVHPS_r_rm    (rXMM2,rmIND32(rEDX)) xOFS32((256*a+88));       \
                   }

//get first half row vector of a
#define GET_COLa(a) {                                                              \
                    xMOVLPS_r_rm    (rXMM3,rmIND32(rEAX)) xOFS32((16*a+0));        \
                    xMOVHPS_r_rm    (rXMM3,rmIND32(rEAX)) xOFS32((16*a+8));        \
                    xMOVLPS_r_rm    (rXMM4,rmIND32(rEAX)) xOFS32((16*a+256));      \
                    xMOVHPS_r_rm    (rXMM4,rmIND32(rEAX)) xOFS32((16*a+264));      \
                    xMOVLPS_r_rm    (rXMM5,rmIND32(rEAX)) xOFS32((16*a+512));      \
                    xMOVHPS_r_rm    (rXMM5,rmIND32(rEAX)) xOFS32((16*a+520));      \
                   }

//get first half row vector of a
#define GET_COLb(a) {                                                              \
                    xMOVLPS_r_rm    (rXMM3,rmIND32(rEAX)) xOFS32((16*a+768));      \
                    xMOVHPS_r_rm    (rXMM3,rmIND32(rEAX)) xOFS32((16*a+776));      \
                    xMOVLPS_r_rm    (rXMM4,rmIND32(rEAX)) xOFS32((16*a+1024));     \
                    xMOVHPS_r_rm    (rXMM4,rmIND32(rEAX)) xOFS32((16*a+1032));     \
                    xMOVLPS_r_rm    (rXMM5,rmIND32(rEAX)) xOFS32((16*a+1280));     \
                    xMOVHPS_r_rm    (rXMM5,rmIND32(rEAX)) xOFS32((16*a+1288));     \
                   }

#define CROSSa() {                                                               \
                    xMULPS_r_rm     (rXMM3, rmREG(rXMM0));                       \
                    xMULPS_r_rm     (rXMM4, rmREG(rXMM1));                       \
                    xADDPS_r_rm     (rXMM3, rmREG(rXMM4));                       \
                    xMULPS_r_rm     (rXMM5, rmREG(rXMM2));                       \
                    xADDPS_r_rm     (rXMM3, rmREG(rXMM5));                       \
                    xMOVAPS_r_rm    (rXMM6, rmREG(rXMM3));                       \
                }

#define CROSSb() {                                                               \
                    xMULPS_r_rm     (rXMM3, rmREG(rXMM0));                       \
                    xMULPS_r_rm     (rXMM4, rmREG(rXMM1));                       \
                    xADDPS_r_rm     (rXMM3, rmREG(rXMM4));                       \
                    xMULPS_r_rm     (rXMM5, rmREG(rXMM2));                       \
                    xADDPS_r_rm     (rXMM3, rmREG(rXMM5));                       \
                    xMOVAPS_r_rm    (rXMM7, rmREG(rXMM3));                       \
                }

#define SAVE(a,b) {                                                              \
                    xADDPS_r_rm     (rXMM6, rmREG(rXMM7));                       \
                    xMOVLPS_rm_r    (rmIND32(rECX), rXMM6) xOFS32(256*a+16*b+0); \
                    xMOVHPS_rm_r    (rmIND32(rECX), rXMM6) xOFS32(256*a+16*b+8); \
                  }    
    
    // x[0][0] = a00*b00+a01*b10+a02*b20+a03*b30+a04*b40+a05*b50;
    GET_ROWa(0)    GET_COLa(0)    CROSSa()
    GET_ROWb(0)    GET_COLb(0)    CROSSb()
    SAVE(0,0)
    // x[0][1] = a00*b01+a01*b11+a02*b21+a03*b31+a04*b41+a05*b51;
    GET_ROWa(0)    GET_COLa(1)    CROSSa()
    GET_ROWb(0)    GET_COLb(1)    CROSSb()
    SAVE(0,1)
    // x[0][2] = a00*b02+a01*b12+a02*b22+a03*b32+a04*b42+a05*b52;
    GET_ROWa(0)    GET_COLa(2)    CROSSa()
    GET_ROWb(0)    GET_COLb(2)    CROSSb()
    SAVE(0,2)
    // x[0][3] = a00*b03+a01*b13+a02*b23+a03*b33+a04*b43+a05*b53;
    GET_ROWa(0)    GET_COLa(3)    CROSSa()
    GET_ROWb(0)    GET_COLb(3)    CROSSb()
    SAVE(0,3)
    // x[0][4] = a00*b04+a01*b14+a02*b24+a03*b34+a04*b44+a05*b54;
    GET_ROWa(0)    GET_COLa(4)    CROSSa()
    GET_ROWb(0)    GET_COLb(4)    CROSSb()
    SAVE(0,4)
    // x[0][5] = a00*b05+a01*b15+a02*b25+a03*b35+a04*b45+a05*b55;
    GET_ROWa(0)    GET_COLa(5)    CROSSa()
    GET_ROWb(0)    GET_COLb(5)    CROSSb()
    SAVE(0,5)
    // x[1][0] = a10*b00+a11*b10+a12*b20+a13*b30+a14*b40+a15*b50;
    GET_ROWa(1)    GET_COLa(0)    CROSSa()
    GET_ROWb(1)    GET_COLb(0)    CROSSb()
    SAVE(1,0)
    // x[1][1] = a10*b01+a11*b11+a12*b21+a13*b31+a14*b41+a15*b51;
    GET_ROWa(1)    GET_COLa(1)    CROSSa()
    GET_ROWb(1)    GET_COLb(1)    CROSSb()
    SAVE(1,1)
    // x[1][2] = a10*b02+a11*b12+a12*b22+a13*b32+a14*b42+a15*b52;
    GET_ROWa(1)    GET_COLa(2)    CROSSa()
    GET_ROWb(1)    GET_COLb(2)    CROSSb()
    SAVE(1,2)
    // x[1][3] = a10*b03+a11*b13+a12*b23+a13*b33+a14*b43+a15*b53;
    GET_ROWa(1)    GET_COLa(3)    CROSSa()
    GET_ROWb(1)    GET_COLb(3)    CROSSb()
    SAVE(1,3)
    // x[1][4] = a10*b04+a11*b14+a12*b24+a13*b34+a14*b44+a15*b54;
    GET_ROWa(1)    GET_COLa(4)    CROSSa()
    GET_ROWb(1)    GET_COLb(4)    CROSSb()
    SAVE(1,4)
    // x[1][5] = a10*b05+a11*b15+a12*b25+a13*b35+a14*b45+a15*b55;*/
    GET_ROWa(1)    GET_COLa(5)    CROSSa()
    GET_ROWb(1)    GET_COLb(5)    CROSSb()
    SAVE(1,5)

    // x[2][0] = a20*b00+a21*b10+a22*b20+a23*b30+a24*b40+a25*b50;
    GET_ROWa(2)    GET_COLa(0)    CROSSa()
    GET_ROWb(2)    GET_COLb(0)    CROSSb()
    SAVE(2,0)
    // x[2][1] = a20*b01+a21*b11+a22*b21+a23*b31+a24*b41+a25*b51;
    GET_ROWa(2)    GET_COLa(1)    CROSSa()
    GET_ROWb(2)    GET_COLb(1)    CROSSb()
    SAVE(2,1)
    // x[2][2] = a20*b02+a21*b12+a22*b22+a23*b32+a24*b42+a25*b52;
    GET_ROWa(2)    GET_COLa(2)    CROSSa()
    GET_ROWb(2)    GET_COLb(2)    CROSSb()
    SAVE(2,2)
    // x[2][3] = a20*b03+a21*b13+a22*b23+a23*b33+a24*b43+a25*b53;
    GET_ROWa(2)    GET_COLa(3)    CROSSa()
    GET_ROWb(2)    GET_COLb(3)    CROSSb()
    SAVE(2,3)
    // x[2][4] = a20*b04+a21*b14+a22*b24+a23*b34+a24*b44+a25*b54;
    GET_ROWa(2)    GET_COLa(4)    CROSSa()
    GET_ROWb(2)    GET_COLb(4)    CROSSb()
    SAVE(2,4)
    // x[2][5] = a20*b05+a21*b15+a22*b25+a23*b35+a24*b45+a25*b55;
    GET_ROWa(2)    GET_COLa(5)    CROSSa()
    GET_ROWb(2)    GET_COLb(5)    CROSSb()
    SAVE(2,5)

    // x[3][0] = a30*b00+a31*b10+a32*b20+a33*b30+a34*b40+a35*b50;
    GET_ROWa(3)    GET_COLa(0)    CROSSa()
    GET_ROWb(3)    GET_COLb(0)    CROSSb()
    SAVE(3,0)
    // x[3][1] = a30*b01+a31*b11+a32*b21+a33*b31+a34*b41+a35*b51;
    GET_ROWa(3)    GET_COLa(1)    CROSSa()
    GET_ROWb(3)    GET_COLb(1)    CROSSb()
    SAVE(3,1)
    // x[3][2] = a30*b02+a31*b12+a32*b22+a33*b32+a34*b42+a35*b52;
    GET_ROWa(3)    GET_COLa(2)    CROSSa()
    GET_ROWb(3)    GET_COLb(2)    CROSSb()
    SAVE(3,2)
    // x[3][3] = a30*b03+a31*b13+a32*b23+a33*b33+a34*b43+a35*b53;
    GET_ROWa(3)    GET_COLa(3)    CROSSa()
    GET_ROWb(3)    GET_COLb(3)    CROSSb()
    SAVE(3,3)
    // x[3][4] = a30*b04+a31*b14+a32*b24+a33*b34+a34*b44+a35*b54;
    GET_ROWa(3)    GET_COLa(4)    CROSSa()
    GET_ROWb(3)    GET_COLb(4)    CROSSb()
    SAVE(3,4)
    // x[3][5] = a30*b05+a31*b15+a32*b25+a33*b35+a34*b45+a35*b55;
    GET_ROWa(3)    GET_COLa(5)    CROSSa()
    GET_ROWb(3)    GET_COLb(5)    CROSSb()
    SAVE(3,5)

    // x[4][0] = a40*b00+a41*b10+a42*b20+a43*b30+a44*b40+a45*b50;
    GET_ROWa(4)    GET_COLa(0)    CROSSa()
    GET_ROWb(4)    GET_COLb(0)    CROSSb()
    SAVE(4,0)
    // x[4][1] = a40*b01+a41*b11+a42*b21+a43*b31+a44*b41+a45*b51;
    GET_ROWa(4)    GET_COLa(1)    CROSSa()
    GET_ROWb(4)    GET_COLb(1)    CROSSb()
    SAVE(4,1)
    // x[4][2] = a40*b02+a41*b12+a42*b22+a43*b32+a44*b42+a45*b52;
    GET_ROWa(4)    GET_COLa(2)    CROSSa()
    GET_ROWb(4)    GET_COLb(2)    CROSSb()
    SAVE(4,2)
    // x[4][3] = a40*b03+a41*b13+a42*b23+a43*b33+a44*b43+a45*b53;
    GET_ROWa(4)    GET_COLa(3)    CROSSa()
    GET_ROWb(4)    GET_COLb(3)    CROSSb()
    SAVE(4,3)
    // x[4][4] = a40*b04+a41*b14+a42*b24+a43*b34+a44*b44+a45*b54;
    GET_ROWa(4)    GET_COLa(4)    CROSSa()
    GET_ROWb(4)    GET_COLb(4)    CROSSb()
    SAVE(4,4)
    // x[4][5] = a40*b05+a41*b15+a42*b25+a43*b35+a44*b45+a45*b55;
    GET_ROWa(4)    GET_COLa(5)    CROSSa()
    GET_ROWb(4)    GET_COLb(5)    CROSSb()
    SAVE(4,5)

    // x[5][0] = a50*b00+a51*b10+a52*b20+a53*b30+a54*b40+a55*b50;
    GET_ROWa(5)    GET_COLa(0)    CROSSa()
    GET_ROWb(5)    GET_COLb(0)    CROSSb()
    SAVE(5,0)
    // x[5][1] = a50*b01+a51*b11+a52*b21+a53*b31+a54*b41+a55*b51;
    GET_ROWa(5)    GET_COLa(1)    CROSSa()
    GET_ROWb(5)    GET_COLb(1)    CROSSb()
    SAVE(5,1)
    // x[5][2] = a50*b02+a51*b12+a52*b22+a53*b32+a54*b42+a55*b52;
    GET_ROWa(5)    GET_COLa(2)    CROSSa()
    GET_ROWb(5)    GET_COLb(2)    CROSSb()
    SAVE(5,2)
    // x[5][3] = a50*b03+a51*b13+a52*b23+a53*b33+a54*b43+a55*b53;
    GET_ROWa(5)    GET_COLa(3)    CROSSa()
    GET_ROWb(5)    GET_COLb(3)    CROSSb()
    SAVE(5,3)
    // x[5][4] = a50*b04+a51*b14+a52*b24+a53*b34+a54*b44+a55*b54;
    GET_ROWa(5)    GET_COLa(4)    CROSSa()
    GET_ROWb(5)    GET_COLb(4)    CROSSb()
    SAVE(5,4)
    // x[5][5] = a50*b05+a51*b15+a52*b25+a53*b35+a54*b45+a55*b55;
    GET_ROWa(5)    GET_COLa(5)    CROSSa()
    GET_ROWb(5)    GET_COLb(5)    CROSSb()
    SAVE(5,5)
#endif

    xRET_imm            (0x4)                           
    nvAssert(ilcCount < ilcMax);

    return (PFMM)(ilcData + lEntry);

#undef GET_COLa
#undef GET_ROWa
#undef CROSSa
#undef GET_COLb
#undef GET_ROWb
#undef CROSSb
#undef SAVE

}

PFMM MatrixMult4x4(NV_PATCH_INFO *info){
    unsigned int lEntry;

    ilcData = (unsigned char *)__NV_MALLOC(info->context, 2048);
    if(ilcData == 0x0) return (PFMM)NULL;    
    ilcCount = 0;    ilcMax = 2048;

    while(ilcCount &31){
        xINT3;
    }
    xLABEL(lEntry);

    //typedef void (FASTCALL *PFMM)(FDMatrix *dst, FDMatrix *a, FDMatrix *b);
    //for function above stack frame will look like 
    //      ECX                                             dst            
    //      EDX                                             a             
    //      xMOV_r_rm       (rECX, rmSIB8) xSIB8_esp(0x4)   b
    
    xMOV_r_rm       (rEAX, rmSIB8) xSIB8_esp(0x4)           //EAX<-b
    xADD_rm_imm     (rmREG(rEAX), FDMATRIX_HEADER_SIZE)     //#row/cols data members skipped  EAX=b->data[0][0][0];
    xADD_rm_imm     (rmREG(rECX), FDMATRIX_HEADER_SIZE)     //#row/cols data members skipped  ECX=dst->data[0][0][0];
    xADD_rm_imm     (rmREG(rEDX), FDMATRIX_HEADER_SIZE)     //#row/cols data members skipped  EDX=a->data[0][0][0];    
//get first column vector of b
#define GET_COL(a) {                                                               \
                    xMOVLPS_r_rm    (rXMM4,rmIND32(rEAX)) xOFS32((16*a+0));        \
                    xMOVHPS_r_rm    (rXMM4,rmIND32(rEAX)) xOFS32((16*a+8));        \
                    xMOVLPS_r_rm    (rXMM5,rmIND32(rEAX)) xOFS32((16*a+256));      \
                    xMOVHPS_r_rm    (rXMM5,rmIND32(rEAX)) xOFS32((16*a+264));      \
                    xMOVLPS_r_rm    (rXMM6,rmIND32(rEAX)) xOFS32((16*a+512));      \
                    xMOVHPS_r_rm    (rXMM6,rmIND32(rEAX)) xOFS32((16*a+520));      \
                    xMOVLPS_r_rm    (rXMM7,rmIND32(rEAX)) xOFS32((16*a+768));      \
                    xMOVHPS_r_rm    (rXMM7,rmIND32(rEAX)) xOFS32((16*a+776));      \
                   }

//get first row vector of a
#define GET_ROW(a) {                                                                \
                    xMOVLPS_r_rm    (rXMM0,rmIND32(rEDX)) xOFS32((256*a+0));        \
                    xMOVHPS_r_rm    (rXMM0,rmIND32(rEDX)) xOFS32((256*a+8));        \
                    xMOVLPS_r_rm    (rXMM1,rmIND32(rEDX)) xOFS32((256*a+16));       \
                    xMOVHPS_r_rm    (rXMM1,rmIND32(rEDX)) xOFS32((256*a+24));       \
                    xMOVLPS_r_rm    (rXMM2,rmIND32(rEDX)) xOFS32((256*a+32));       \
                    xMOVHPS_r_rm    (rXMM2,rmIND32(rEDX)) xOFS32((256*a+40));       \
                    xMOVLPS_r_rm    (rXMM3,rmIND32(rEDX)) xOFS32((256*a+48));       \
                    xMOVHPS_r_rm    (rXMM3,rmIND32(rEDX)) xOFS32((256*a+56));       \
                   }

#define CROSS() {                                                                \
                    xMULPS_r_rm     (rXMM4, rmREG(rXMM0));                       \
                    xMULPS_r_rm     (rXMM5, rmREG(rXMM1));                       \
                    xADDPS_r_rm     (rXMM4, rmREG(rXMM5));                       \
                    xMULPS_r_rm     (rXMM6, rmREG(rXMM2));                       \
                    xADDPS_r_rm     (rXMM4, rmREG(rXMM6));                       \
                    xMULPS_r_rm     (rXMM7, rmREG(rXMM3));                       \
                    xADDPS_r_rm     (rXMM4, rmREG(rXMM7));                       \
                }

#define SAVE(a,b) {                                                              \
                    xMOVLPS_rm_r    (rmIND32(rECX), rXMM4) xOFS32(256*a+16*b+0); \
                    xMOVHPS_rm_r    (rmIND32(rECX), rXMM4) xOFS32(256*a+16*b+8); \
                  }    

    GET_ROW(0)
    //  x[0][0] = a00*b00+a01*b10+a02*b20+a03*b30;
    GET_COL(0)
    CROSS()
    SAVE(0,0)
    //  x[0][1] = a00*b01+a01*b11+a02*b21+a03*b31;    
    GET_COL(1)
    CROSS()
    SAVE(0,1)
    //  x[0][2] = a00*b02+a01*b12+a02*b22+a03*b32;
    GET_COL(2)
    CROSS()
    SAVE(0,2)
    //  x[0][3] = a00*b03+a01*b13+a02*b23+a03*b33;
    GET_COL(3)
    CROSS()
    SAVE(0,3)

    GET_ROW(1)
    //  x[1][0] = a10*b00+a11*b10+a12*b20+a13*b30;
    GET_COL(0)
    CROSS()
    SAVE(1,0)
    //  x[1][1] = a10*b01+a11*b11+a12*b21+a13*b31;
    GET_COL(1)
    CROSS()
    SAVE(1,1)
    //  x[1][2] = a10*b02+a11*b12+a12*b22+a13*b32;
    GET_COL(2)
    CROSS()
    SAVE(1,2)
    //  x[1][3] = a10*b03+a11*b13+a12*b23+a13*b33;
    GET_COL(3)
    CROSS()
    SAVE(1,3)

    GET_ROW(2)
    //  x[2][0] = a20*b00+a21*b10+a22*b20+a23*b30;
    GET_COL(0)
    CROSS()
    SAVE(2,0)
    //  x[2][1] = a20*b01+a21*b11+a22*b21+a23*b31;
    GET_COL(1)
    CROSS()
    SAVE(2,1)
    //  x[2][2] = a20*b02+a21*b12+a22*b22+a23*b32;
    GET_COL(2)
    CROSS()
    SAVE(2,2)
    //  x[2][3] = a20*b03+a21*b13+a22*b23+a23*b33;
    GET_COL(3)
    CROSS()
    SAVE(2,3)

    GET_ROW(3)
    //  x[3][0] = a30*b00+a31*b10+a32*b20+a33*b30;
    GET_COL(0)
    CROSS()
    SAVE(3,0)
    //  x[3][1] = a30*b01+a31*b11+a32*b21+a33*b31;
    GET_COL(1)
    CROSS()
    SAVE(3,1)
    //  x[3][2] = a30*b02+a31*b12+a32*b22+a33*b32;
    GET_COL(2)
    CROSS()
    SAVE(3,2)
    //  x[3][3] = a30*b03+a31*b13+a32*b23+a33*b33;
    GET_COL(3)
    CROSS()
    SAVE(3,3)
    
    xRET_imm            (0x4)                           
    assert(ilcCount < ilcMax);

    return (PFMM)(ilcData + lEntry);
#undef GET_COL
#undef GET_ROW
#undef SAVE
#undef CROSS
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\common\src\nvPatchConsts.c ===
/*
 * nvPatchConsts.c
 *
 * Tables of constants used for curved surfaces.
 *
 * Copyright (c) 2000, Nvidia Corporation.  All rights reserved.
 */

#if defined(_MSC_VER)
# pragma warning (disable:4305)  /* Disable VC++ 5.0 "truncation from 'const double' to 'float' */
#endif

/*** Patch interface ***/
#include "nvPatchInterface.h"

// Bezier basis matrices
static float bezBasis1[1][1] = {
    {1},
};

static float bezBasis2[2][2] = {
    {-1, 1},
    { 1, 0},
};

static float bezBasis3[3][3] = {
    { 1, -2, 1},
    {-2,  2, 0},
    { 1,  0, 0},
};

static float bezBasis4[4][4] = {
    {-1,  3, -3, 1},
    { 3, -6,  3, 0},
    {-3,  3,  0, 0},
    { 1,  0,  0, 0},
};

static float bezBasis5[5][5] = {
    { 1,  -4,   6, -4, 1},
    {-4,  12, -12,  4, 0},
    { 6, -12,   6,  0, 0},
    {-4,   4,   0,  0, 0},
    { 1,   0,   0,  0, 0},
};

static float bezBasis6[6][6] = {
    { -1,   5, -10,  10, -5, 1},
    {  5, -20,  30, -20,  5, 0},
    {-10,  30, -30,  10,  0, 0},
    { 10, -20,  10,   0,  0, 0},
    { -5,   5,   0,   0,  0, 0},
    {  1,   0,   0,   0,  0, 0},
};

static float bezBasis7[7][7] = {
    {  1,  -6,  15, -20,  15, -6, 1},
    { -6,  30, -60,  60, -30,  6, 0},
    { 15, -60,  90, -60,  15,  0, 0},
    {-20,  60, -60,  20,   0,  0, 0},
    { 15, -30,  15,   0,   0,  0, 0},
    { -6,   6,   0,   0,   0,  0, 0},
    {  1,   0,   0,   0,   0,  0, 0},
};

static float bezBasis8[8][8] = {
    { -1,    7,  -21,   35,  -35,  21, -7, 1},
    {  7,  -42,  105, -140,  105, -42,  7, 0},
    {-21,  105, -210,  210, -105,  21,  0, 0},
    { 35, -140,  210, -140,   35,   0,  0, 0},
    {-35,  105, -105,   35,    0,   0,  0, 0},
    { 21,  -42,   21,    0,    0,   0,  0, 0},
    { -7,    7,    0,    0,    0,   0,  0, 0},
    {  1,    0,    0,    0,    0,   0,  0, 0},
};

static float bezBasis9[9][9] = {
    {  1,   -8,   28,  -56,   70,  -56,  28, -8, 1},
    { -8,   56, -168,  280, -280,  168, -56,  8, 0},
    { 28, -168,  420, -560,  420, -168,  28,  0, 0},
    {-56,  280, -560,  560, -280,   56,   0,  0, 0},
    { 70, -280,  420, -280,   70,    0,   0,  0, 0},
    {-56,  168, -168,   56,    0,    0,   0,  0, 0},
    { 28,  -56,   28,    0,    0,    0,   0,  0, 0},
    { -8,    8,    0,    0,    0,    0,   0,  0, 0},
    {  1,    0,    0,    0,    0,    0,   0,  0, 0},
};

static float bezBasis10[10][10] = {
    {  -1,    9,   -36,    84,  -126,  126,  -84,  36, -9, 1},
    {   9,  -72,   252,  -504,   630, -504,  252, -72,  9, 0},
    { -36,  252,  -756,  1260, -1260,  756, -252,  36,  0, 0},
    {  84, -504,  1260, -1680,  1260, -504,   84,   0,  0, 0},
    {-126,  630, -1260,  1260,  -630,  126,    0,   0,  0, 0},
    { 126, -504,   756,  -504,   126,    0,    0,   0,  0, 0},
    { -84,  252,  -252,    84,     0,    0,    0,   0,  0, 0},
    {  36,  -72,    36,     0,     0,    0,    0,   0,  0, 0},
    {  -9,    9,     0,     0,     0,    0,    0,   0,  0, 0},
    {   1,    0,     0,     0,     0,    0,    0,   0,  0, 0},
};

static float bezBasis11[11][11] = {
    {1, -10, 45, -120, 210, -252, 210, -120, 45, -10, 1},
    {-10, 90, -360, 840, -1260, 1260, -840, 360, -90, 10, 0},
    {45, -360, 1260, -2520, 3150, -2520, 1260, -360, 45, 0, 0},
    {-120, 840, -2520, 4200, -4200, 2520, -840, 120, 0, 0, 0},
    {210, -1260, 3150, -4200, 3150, -1260, 210, 0, 0, 0, 0},
    {-252, 1260, -2520, 2520, -1260, 252, 0, 0, 0, 0, 0},
    {210, -840, 1260, -840, 210, 0, 0, 0, 0, 0, 0},
    {-120, 360, -360, 120, 0, 0, 0, 0, 0, 0, 0},
    {45, -90, 45, 0, 0, 0, 0, 0, 0, 0, 0},
    {-10, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
};

static float bezBasis12[12][12] = {
    {-1, 11, -55, 165, -330, 462, -462, 330, -165, 55, -11, 1},
    {11, -110, 495, -1320, 2310, -2772, 2310, -1320, 495, -110, 11, 0},
    {-55, 495, -1980, 4620, -6930, 6930, -4620, 1980, -495, 55, 0, 0},
    {165, -1320, 4620, -9240, 11550, -9240, 4620, -1320, 165, 0, 0, 0},
    {-330, 2310, -6930, 11550, -11550, 6930, -2310, 330, 0, 0, 0, 0},
    {462, -2772, 6930, -9240, 6930, -2772, 462, 0, 0, 0, 0, 0},
    {-462, 2310, -4620, 4620, -2310, 462, 0, 0, 0, 0, 0, 0},
    {330, -1320, 1980, -1320, 330, 0, 0, 0, 0, 0, 0, 0},
    {-165, 495, -495, 165, 0, 0, 0, 0, 0, 0, 0, 0},
    {55, -110, 55, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {-11, 11, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
};

static float bezBasis13[13][13] = {
    {1, -12, 66, -220, 495, -792, 924, -792, 495, -220, 66, -12, 1},
    {-12, 132, -660, 1980, -3960, 5544, -5544, 3960, -1980, 660, -132, 12, 0},
    {66, -660, 2970, -7920, 13860, -16632, 13860, -7920, 2970, -660, 66, 0, 0},
    {-220, 1980, -7920, 18480, -27720, 27720, -18480, 7920, -1980, 220, 0, 0, 0},
    {495, -3960, 13860, -27720, 34650, -27720, 13860, -3960, 495, 0, 0, 0, 0},
    {-792, 5544, -16632, 27720, -27720, 16632, -5544, 792, 0, 0, 0, 0, 0},
    {924, -5544, 13860, -18480, 13860, -5544, 924, 0, 0, 0, 0, 0, 0},
    {-792, 3960, -7920, 7920, -3960, 792, 0, 0, 0, 0, 0, 0, 0},
    {495, -1980, 2970, -1980, 495, 0, 0, 0, 0, 0, 0, 0, 0},
    {-220, 660, -660, 220, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {66, -132, 66, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {-12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
};

static float bezBasis14[14][14] = {
    {   -1,     13,    -78,    286,   -715,   1287,  -1716,   1716,  -1287,   715, -286,   78, -13, 1},
    {   13,   -156,    858,  -2860,   6435, -10296,  12012, -10296,   6435, -2860,  858, -156,  13, 0},
    {  -78,    858,  -4290,  12870, -25740,  36036, -36036,  25740, -12870,  4290, -858,   78,   0, 0},
    {  286,  -2860,  12870, -34320,  60060, -72072,  60060, -34320,  12870, -2860,  286,    0,   0, 0},
    { -715,   6435, -25740,  60060, -90090,  90090, -60060,  25740,  -6435,   715,    0,    0,   0, 0},
    { 1287, -10296,  36036, -72072,  90090, -72072,  36036, -10296,   1287,     0,    0,    0,   0, 0},
    {-1716,  12012, -36036,  60060, -60060,  36036, -12012,   1716,      0,     0,    0,    0,   0, 0},
    { 1716, -10296,  25740, -34320,  25740, -10296,   1716,      0,      0,     0,    0,    0,   0, 0},
    {-1287,   6435, -12870,  12870,  -6435,   1287,      0,      0,      0,     0,    0,    0,   0, 0},
    {  715,  -2860,   4290,  -2860,    715,      0,      0,      0,      0,     0,    0,    0,   0, 0},
    { -286,    858,   -858,    286,      0,      0,      0,      0,      0,     0,    0,    0,   0, 0},
    {   78,   -156,     78,      0,      0,      0,      0,      0,      0,     0,    0,    0,   0, 0},
    {  -13,     13,      0,      0,      0,      0,      0,      0,      0,     0,    0,    0,   0, 0},
    {    1,      0,      0,      0,      0,      0,      0,      0,      0,     0,    0,    0,   0, 0},
};

static float bezBasis15[15][15] = {
    {    1, -14, 91, -364, 1001, -2002, 3003, -3432, 3003, -2002, 1001, -364, 91, -14, 1},
    {  -14, 182, -1092, 4004, -10010, 18018, -24024, 24024, -18018, 10010, -4004, 1092, -182, 14, 0},
    {   91, -1092, 6006, -20020, 45045, -72072, 84084, -72072, 45045, -20020, 6006, -1092, 91, 0, 0},
    { -364, 4004, -20020, 60060, -120120, 168168, -168168, 120120, -60060, 20020, -4004, 364, 0, 0, 0},
    { 1001, -10010, 45045, -120120, 210210, -252252, 210210, -120120, 45045, -10010, 1001, 0, 0, 0, 0},
    {-2002, 18018, -72072, 168168, -252252, 252252, -168168, 72072, -18018, 2002, 0, 0, 0, 0, 0},
    { 3003, -24024, 84084, -168168, 210210, -168168, 84084, -24024, 3003, 0, 0, 0, 0, 0, 0},
    {-3432, 24024, -72072, 120120, -120120, 72072, -24024, 3432, 0, 0, 0, 0, 0, 0, 0},
    { 3003, -18018, 45045, -60060, 45045, -18018, 3003, 0, 0, 0, 0, 0, 0, 0, 0},
    {-2002,  10010, -20020, 20020, -10010, 2002, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    { 1001,  -4004,   6006, -4004, 1001, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    { -364,   1092,  -1092, 364, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {   91,   -182,     91, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {  -14,     14,      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {    1,      0,      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
};

static float bezBasis16[16][16] = {
    {-1, 15, -105, 455, -1365, 3003, -5005, 6435, -6435, 5005, -3003, 1365, -455, 105, -15, 1},
    {15, -210, 1365, -5460, 15015, -30030, 45045, -51480, 45045, -30030, 15015, -5460, 1365, -210, 15, 0},
    {-105, 1365, -8190, 30030, -75075, 135135, -180180, 180180, -135135, 75075, -30030, 8190, -1365, 105, 0, 0},
    {455, -5460, 30030, -100100, 225225, -360360, 420420, -360360, 225225, -100100, 30030, -5460, 455, 0, 0, 0},
    {-1365, 15015, -75075, 225225, -450450, 630630, -630630, 450450, -225225, 75075, -15015, 1365, 0, 0, 0, 0},
    {3003, -30030, 135135, -360360, 630630, -756756, 630630, -360360, 135135, -30030, 3003, 0, 0, 0, 0, 0},
    {-5005, 45045, -180180, 420420, -630630, 630630, -420420, 180180, -45045, 5005, 0, 0, 0, 0, 0, 0},
    {6435, -51480, 180180, -360360, 450450, -360360, 180180, -51480, 6435, 0, 0, 0, 0, 0, 0, 0},
    {-6435, 45045, -135135, 225225, -225225, 135135, -45045, 6435, 0, 0, 0, 0, 0, 0, 0, 0},
    {5005, -30030, 75075, -100100, 75075, -30030, 5005, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {-3003, 15015, -30030, 30030, -15015, 3003, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {1365, -5460, 8190, -5460, 1365, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {-455, 1365, -1365, 455, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {105, -210, 105, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {-15, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
};

static float catmullRomBasis4[4][4] = {
    {-1.0f/2,  3.0f/2, -3.0f/2,  1.0f/2}, 
    {   1.0f, -5.0f/2,    2.0f, -1.0f/2}, 
    {-1.0f/2,    0.0f,  1.0f/2,    0.0f}, 
    {   0.0f,    1.0f,    0.0f,    0.0f}
};

//divisors on bspline basis are factorial(order)
static float bsplineBasis1[1][1] = {
    {1},
};

static float bsplineBasis2[2][2] = {
    {-1.0f, 1.0f},
    { 1.0f, 0.0f}
};

static float bsplineBasis3[3][3] = {
    { 1.0f/2, -2.0f/2, 1.0f/2}, 
    {-2.0f/2,  2.0f/2, 0.0f/2}, 
    { 1.0f/2,  1.0f/2, 0.0f/2}
};

static float bsplineBasis4[4][4] = {
    {-1.0f/6,  3.0f/6, -3.0f/6, 1.0f/6}, 
    { 3.0f/6, -6.0f/6,  3.0f/6, 0.0f/6}, 
    {-3.0f/6,  0.0f/6,  3.0f/6, 0.0f/6},  
    { 1.0f/6,  4.0f/6,  1.0f/6, 0.0f/6}
};

static float bsplineBasis5[5][5] = {
    { 1.0f/24,  -4.0f/24,   6.0f/24, -4.0f/24, 1.0f/24}, 
    {-4.0f/24,  12.0f/24, -12.0f/24,  4.0f/24, 0.0f/24}, 
    { 6.0f/24,  -6.0f/24,  -6.0f/24,  6.0f/24, 0.0f/24}, 
    {-4.0f/24, -12.0f/24,  12.0f/24,  4.0f/24, 0.0f/24}, 
    { 1.0f/24,  11.0f/24,  11.0f/24,  1.0f/24, 0.0f/24}
};

static float bsplineBasis6[6][6] = {
    { -1.0f/120,   5.0f/120, -10.0f/120,  10.0f/120, -5.0f/120, 1.0f/120}, 
    {  5.0f/120, -20.0f/120,  30.0f/120, -20.0f/120,  5.0f/120, 0.0f/120}, 
    {-10.0f/120,  20.0f/120,   0.0f/120,  20.0f/120, 10.0f/120, 0.0f/120}, 
    { -5.0f/120, -50.0f/120,   0.0f/120,  50.0f/120,  5.0f/120, 0.0f/120}, 
    {  1.0f/120,  26.0f/120,  66.0f/120,  26.0f/120,  1.0f/120, 0.0f/120}
};

static float bsplineBasis7[7][7] = {
    {  1.0f/720,   -6.0f/720,   15.0f/720,  -20.0f/720,  15.0f/720, -6.0f/720, 1.0f/720}, 
    { -6.0f/720,   30.0f/720,  -60.0f/720,   60.0f/720, -30.0f/720,  6.0f/720, 0.0f/720}, 
    { 15.0f/720,  -45.0f/720,   30.0f/720,   30.0f/720, -45.0f/720, 15.0f/720, 0.0f/720}, 
    {-20.0f/720,  -20.0f/720,  160.0f/720, -160.0f/720,  20.0f/720, 20.0f/720, 0.0f/720}, 
    { 15.0f/720,  135.0f/720, -150.0f/720, -150.0f/720, 135.0f/720, 15.0f/720, 0.0f/720}, 
    { -6.0f/720, -150.0f/720, -240.0f/720,  240.0f/720, 150.0f/720,  6.0f/720, 0.0f/720}, 
    {  1.0f/720,   57.0f/720,  302.0f/720,  302.0f/720,  57.0f/720,  1.0f/720, 0.0f/720}
};
 
static float bsplineBasis8[8][8] = {
    { -1.0f/5040,    7.0f/5040,   -21.0f/5040,    35.0f/5040,  -35.0f/5040,  21.0f/5040,  -7.0f/5040,  1.0f/5040}, 
    {  7.0f/5040,  -42.0f/5040,   105.0f/5040,  -140.0f/5040,  105.0f/5040, -42.0f/5040,   7.0f/5040,  0.0f/5040}, 
    {-21.0f/5040,   84.0f/5040,  -105.0f/5040,     0.0f/5040,  105.0f/5040, -84.0f/5040,  21.0f/5040,  0.0f/5040}, 
    { 35.0f/5040,    0.0f/5040,  -315.0f/5040,   560.0f/5040, -315.0f/5040,   0.0f/5040,  35.0f/5040,  0.0f/5040}, 
    {-35.0f/5040, -280.0f/5040,   665.0f/5040,     0.0f/5040, -665.0f/5040, 280.0f/5040,  35.0f/5040,  0.0f/5040}, 
    { 21.0f/5040,  504.0f/5040,   315.0f/5040, -1680.0f/5040,  315.0f/5040, 504.0f/5040,  21.0f/5040,  0.0f/5040}, 
    { -7.0f/5040, -392.0f/5040, -1715.0f/5040,     0.0f/5040, 1715.0f/5040, 392.0f/5040,   7.0f/5040,  0.0f/5040}, 
    {  1.0f/5040,  120.0f/5040,  1191.0f/5040,  2416.0f/5040, 1191.0f/5040, 120.0f/5040,   1.0f/5040,  0.0f/5040}
};

static float bsplineBasis9[9][9] = {
    {  1.0f/362880,    -8.0f/362880,    28.0f/362880,   -56.0f/362880,    70.0f/362880,   -56.0f/362880,   28.0f/362880, -8.0f/362880, 1.0f/362880}, 
    { -8.0f/362880,    56.0f/362880,  -168.0f/362880,   280.0f/362880,  -280.0f/362880,   168.0f/362880,  -56.0f/362880,  8.0f/362880, 0.0f/362880}, 
    { 28.0f/362880,  -140.0f/362880,   252.0f/362880,  -140.0f/362880,  -140.0f/362880,   252.0f/362880, -140.0f/362880, 28.0f/362880, 0.0f/362880}, 
    {-56.0f/362880,    56.0f/362880,   504.0f/362880, -1400.0f/362880,  1400.0f/362880,  -504.0f/362880,  -56.0f/362880, 56.0f/362880, 0.0f/362880}, 
    { 70.0f/362880,   490.0f/362880, -1890.0f/362880,  1330.0f/362880,  1330.0f/362880, -1890.0f/362880,  490.0f/362880, 70.0f/362880, 0.0f/362880}, 
    {-56.0f/362880, -1288.0f/362880,   504.0f/362880,  5320.0f/362880, -5320.0f/362880,  -504.0f/362880, 1288.0f/362880, 56.0f/362880, 0.0f/362880}, 
    { 28.0f/362880,  1540.0f/362880,  5292.0f/362880, -6860.0f/362880, -6860.0f/362880,  5292.0f/362880, 1540.0f/362880, 28.0f/362880, 0.0f/362880}, 
    { -8.0f/362880,  -952.0f/362880, -8568.0f/362880, -9800.0f/362880,  9800.0f/362880,  8568.0f/362880,  952.0f/362880,  8.0f/362880, 0.0f/362880}, 
    {  1.0f/362880,   247.0f/362880,  4293.0f/362880, 15619.0f/362880, 15619.0f/362880,  4293.0f/362880,  247.0f/362880,  1.0f/362880, 0.0f/362880}
};

static float bsplineBasis10[10][10] = {
    {  -1.0f/3628800,     9.0f/3628800,    -36.0f/3628800,      84.0f/3628800,   -126.0f/3628800,    126.0f/3628800,   -84.0f/3628800,   36.0f/3628800,  -9.0f/3628800, 1.0f/3628800}, 
    {   9.0f/3628800,   -72.0f/3628800,    252.0f/3628800,    -504.0f/3628800,    630.0f/3628800,   -504.0f/3628800,   252.0f/3628800,  -72.0f/3628800,   9.0f/3628800, 0.0f/3628800}, 
    { -36.0f/3628800,   216.0f/3628800,   -504.0f/3628800,     504.0f/3628800,      0.0f/3628800,   -504.0f/3628800,   504.0f/3628800, -216.0f/3628800,  36.0f/3628800, 0.0f/3628800}, 
    {  84.0f/3628800,  -168.0f/3628800,   -672.0f/3628800,    2856.0f/3628800,  -4200.0f/3628800,   2856.0f/3628800,  -672.0f/3628800, -168.0f/3628800,  84.0f/3628800, 0.0f/3628800}, 
    {-126.0f/3628800,  -756.0f/3628800,   4284.0f/3628800,   -5796.0f/3628800,      0.0f/3628800,   5796.0f/3628800, -4284.0f/3628800,  756.0f/3628800, 126.0f/3628800, 0.0f/3628800}, 
    { 126.0f/3628800,  2772.0f/3628800,  -4032.0f/3628800,  -10836.0f/3628800,  23940.0f/3628800, -10836.0f/3628800, -4032.0f/3628800, 2772.0f/3628800, 126.0f/3628800, 0.0f/3628800}, 
    { -84.0f/3628800, -4536.0f/3628800, -11256.0f/3628800,   36456.0f/3628800,      0.0f/3628800, -36456.0f/3628800, 11256.0f/3628800, 4536.0f/3628800,  84.0f/3628800, 0.0f/3628800}, 
    {  36.0f/3628800,  4248.0f/3628800,  34272.0f/3628800,    5544.0f/3628800, -88200.0f/3628800,   5544.0f/3628800, 34272.0f/3628800, 4248.0f/3628800,  36.0f/3628800, 0.0f/3628800}, 
    {  -9.0f/3628800, -2214.0f/3628800, -36414.0f/3628800, -101934.0f/3628800,      0.0f/3628800, 101934.0f/3628800, 36414.0f/3628800, 2214.0f/3628800,   9.0f/3628800, 0.0f/3628800}, 
    {   1.0f/3628800,   502.0f/3628800,  14608.0f/3628800,   88234.0f/3628800, 156190.0f/3628800,  88234.0f/3628800, 14608.0f/3628800,  502.0f/3628800,   1.0f/3628800, 0.0f/3628800}
};

static float bsplineBasis11[11][11] = {
    {   1.0f/39916800,    -10.0f/39916800,      45.0f/39916800,    -120.0f/39916800,     210.0f/39916800,    -252.0f/39916800,     210.0f/39916800,   -120.0f/39916800,    45.0f/39916800, -10.0f/39916800, 1.0f/39916800}, 
    { -10.0f/39916800,     90.0f/39916800,    -360.0f/39916800,     840.0f/39916800,   -1260.0f/39916800,    1260.0f/39916800,    -840.0f/39916800,    360.0f/39916800,   -90.0f/39916800,  10.0f/39916800, 0.0f/39916800}, 
    {  45.0f/39916800,   -315.0f/39916800,     900.0f/39916800,   -1260.0f/39916800,     630.0f/39916800,     630.0f/39916800,   -1260.0f/39916800,    900.0f/39916800,  -315.0f/39916800,  45.0f/39916800, 0.0f/39916800}, 
    {-120.0f/39916800,    360.0f/39916800,     720.0f/39916800,   -5040.0f/39916800,   10080.0f/39916800,  -10080.0f/39916800,    5040.0f/39916800,   -720.0f/39916800,  -360.0f/39916800, 120.0f/39916800, 0.0f/39916800}, 
    { 210.0f/39916800,   1050.0f/39916800,   -8400.0f/39916800,   16800.0f/39916800,   -9660.0f/39916800,   -9660.0f/39916800,   16800.0f/39916800,  -8400.0f/39916800,  1050.0f/39916800, 210.0f/39916800, 0.0f/39916800}, 
    {-252.0f/39916800,  -5292.0f/39916800,   13608.0f/39916800,   13608.0f/39916800,  -69552.0f/39916800,   69552.0f/39916800,  -13608.0f/39916800, -13608.0f/39916800,  5292.0f/39916800, 252.0f/39916800, 0.0f/39916800}, 
    { 210.0f/39916800,  11130.0f/39916800,   16800.0f/39916800, -119280.0f/39916800,   91140.0f/39916800,   91140.0f/39916800, -119280.0f/39916800,  16800.0f/39916800, 11130.0f/39916800, 210.0f/39916800, 0.0f/39916800}, 
    {-120.0f/39916800, -14040.0f/39916800, -100080.0f/39916800,   95760.0f/39916800,  312480.0f/39916800, -312480.0f/39916800,  -95760.0f/39916800, 100080.0f/39916800, 14040.0f/39916800, 120.0f/39916800, 0.0f/39916800}, 
    {  45.0f/39916800,  11025.0f/39916800,  171000.0f/39916800,  327600.0f/39916800, -509670.0f/39916800, -509670.0f/39916800,  327600.0f/39916800, 171000.0f/39916800, 11025.0f/39916800,  45.0f/39916800, 0.0f/39916800}, 
    { -10.0f/39916800,  -5010.0f/39916800, -141060.0f/39916800, -736260.0f/39916800, -679560.0f/39916800,  679560.0f/39916800,  736260.0f/39916800, 141060.0f/39916800,  5010.0f/39916800,  10.0f/39916800, 0.0f/39916800}, 
    {   1.0f/39916800,   1013.0f/39916800,   47840.0f/39916800,  455192.0f/39916800, 1310354.0f/39916800, 1310354.0f/39916800,  455192.0f/39916800,  47840.0f/39916800,  1013.0f/39916800,   1.0f/39916800, 0.0f/39916800}
};

// Matrices to convert from power basis to FD basis
static float powerToFD1[1][1] = {
    {1},
};

static float powerToFD2[2][2] = {
    {0, 1},
    {1, 0},
};

static float powerToFD3[3][3] = {
    {0, 0, 1},
    {1, 1, 0},
    {2, 0, 0},
};

static float powerToFD4[4][4] = {
    {0, 0, 0, 1},
    {1, 1, 1, 0},
    {6, 2, 0, 0},
    {6, 0, 0, 0},
};

static float powerToFD5[5][5] = {
    {0, 0, 0, 0, 1},
    {1, 1, 1, 1, 0},
    {14, 6, 2, 0, 0},
    {36, 6, 0, 0, 0},
    {24, 0, 0, 0, 0},
};

static float powerToFD6[6][6] = {
    {0, 0, 0, 0, 0, 1},
    {1, 1, 1, 1, 1, 0},
    {30, 14, 6, 2, 0, 0},
    {150, 36, 6, 0, 0, 0},
    {240, 24, 0, 0, 0, 0},
    {120, 0, 0, 0, 0, 0},
};

static float powerToFD7[7][7] = {
    {0, 0, 0, 0, 0, 0, 1},
    {1, 1, 1, 1, 1, 1, 0},
    {62, 30, 14, 6, 2, 0, 0},
    {540, 150, 36, 6, 0, 0, 0},
    {1560, 240, 24, 0, 0, 0, 0},
    {1800, 120, 0, 0, 0, 0, 0},
    {720, 0, 0, 0, 0, 0, 0},
};

static float powerToFD8[8][8] = {
    {0, 0, 0, 0, 0, 0, 0, 1},
    {1, 1, 1, 1, 1, 1, 1, 0},
    {126, 62, 30, 14, 6, 2, 0, 0},
    {1806, 540, 150, 36, 6, 0, 0, 0},
    {8400, 1560, 240, 24, 0, 0, 0, 0},
    {16800, 1800, 120, 0, 0, 0, 0, 0},
    {15120, 720, 0, 0, 0, 0, 0, 0},
    {5040, 0, 0, 0, 0, 0, 0, 0},
};

static float powerToFD9[9][9] = {
    {0, 0, 0, 0, 0, 0, 0, 0, 1},
    {1, 1, 1, 1, 1, 1, 1, 1, 0},
    {254, 126, 62, 30, 14, 6, 2, 0, 0},
    {5796, 1806, 540, 150, 36, 6, 0, 0, 0},
    {40824, 8400, 1560, 240, 24, 0, 0, 0, 0},
    {126000, 16800, 1800, 120, 0, 0, 0, 0, 0},
    {191520, 15120, 720, 0, 0, 0, 0, 0, 0},
    {141120, 5040, 0, 0, 0, 0, 0, 0, 0},
    {40320, 0, 0, 0, 0, 0, 0, 0, 0},
};

static float powerToFD10[10][10] = {
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 1},
    {1, 1, 1, 1, 1, 1, 1, 1, 1, 0},
    {510, 254, 126, 62, 30, 14, 6, 2, 0, 0},
    {18150, 5796, 1806, 540, 150, 36, 6, 0, 0, 0},
    {186480, 40824, 8400, 1560, 240, 24, 0, 0, 0, 0},
    {834120, 126000, 16800, 1800, 120, 0, 0, 0, 0, 0},
    {1905120, 191520, 15120, 720, 0, 0, 0, 0, 0, 0},
    {2328480, 141120, 5040, 0, 0, 0, 0, 0, 0, 0},
    {1451520, 40320, 0, 0, 0, 0, 0, 0, 0, 0},
    {362880, 0, 0, 0, 0, 0, 0, 0, 0, 0},
};

static float powerToFD11[11][11] = {
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1},
    {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0},
    {1022, 510, 254, 126, 62, 30, 14, 6, 2, 0, 0},
    {55980, 18150, 5796, 1806, 540, 150, 36, 6, 0, 0, 0},
    {818520, 186480, 40824, 8400, 1560, 240, 24, 0, 0, 0, 0},
    {5103000, 834120, 126000, 16800, 1800, 120, 0, 0, 0, 0, 0},
    {16435440, 1905120, 191520, 15120, 720, 0, 0, 0, 0, 0, 0},
    {29635200, 2328480, 141120, 5040, 0, 0, 0, 0, 0, 0, 0},
    {30240000, 1451520, 40320, 0, 0, 0, 0, 0, 0, 0, 0},
    {16329600, 362880, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {3628800, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
};

static float powerToFD12[12][12] = {
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1},
    {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0},
    {2046, 1022, 510, 254, 126, 62, 30, 14, 6, 2, 0, 0},
    {171006, 55980, 18150, 5796, 1806, 540, 150, 36, 6, 0, 0, 0},
    {3498000, 818520, 186480, 40824, 8400, 1560, 240, 24, 0, 0, 0, 0},
    {29607600, 5103000, 834120, 126000, 16800, 1800, 120, 0, 0, 0, 0, 0},
    {129230640, 16435440, 1905120, 191520, 15120, 720, 0, 0, 0, 0, 0, 0},
    {322494480, 29635200, 2328480, 141120, 5040, 0, 0, 0, 0, 0, 0, 0},
    {479001600, 30240000, 1451520, 40320, 0, 0, 0, 0, 0, 0, 0, 0},
    {419126400, 16329600, 362880, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {199584000, 3628800, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {39916800, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
};

static float powerToFD13[13][13] = {
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1},
    {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0},
    {4094, 2046, 1022, 510, 254, 126, 62, 30, 14, 6, 2, 0, 0},
    {519156, 171006, 55980, 18150, 5796, 1806, 540, 150, 36, 6, 0, 0, 0},
    {14676024, 3498000, 818520, 186480, 40824, 8400, 1560, 240, 24, 0, 0, 0, 0},
    {165528000.0, 29607600, 5103000, 834120, 126000, 16800, 1800, 120, 0, 0, 0, 0, 0},
    {953029440.0, 129230640, 16435440, 1905120, 191520, 15120, 720, 0, 0, 0, 0, 0, 0},
    {3162075840.0, 322494480, 29635200, 2328480, 141120, 5040, 0, 0, 0, 0, 0, 0, 0},
    {6411968640.0, 479001600, 30240000, 1451520, 40320, 0, 0, 0, 0, 0, 0, 0, 0},
    {8083152000.0, 419126400, 16329600, 362880, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {6187104000.0, 199584000, 3628800, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {2634508800.0, 39916800, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {479001600, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
};

static float powerToFD14[14][14] = {
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1},
    {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0},
    {8190, 4094, 2046, 1022, 510, 254, 126, 62, 30, 14, 6, 2, 0, 0},
    {1569750, 519156, 171006, 55980, 18150, 5796, 1806, 540, 150, 36, 6, 0, 0, 0},
    {60780720, 14676024, 3498000, 818520, 186480, 40824, 8400, 1560, 240, 24, 0, 0, 0, 0},
    {901020120, 165528000.0, 29607600, 5103000, 834120, 126000, 16800, 1800, 120, 0, 0, 0, 0, 0},
    {6711344640.0, 953029440.0, 129230640, 16435440, 1905120, 191520, 15120, 720, 0, 0, 0, 0, 0, 0},
    {28805736960.0, 3162075840.0, 322494480, 29635200, 2328480, 141120, 5040, 0, 0, 0, 0, 0, 0, 0},
    {76592355840.0, 6411968640.0, 479001600, 30240000, 1451520, 40320, 0, 0, 0, 0, 0, 0, 0, 0},
    {130456085760.0, 8083152000.0, 419126400, 16329600, 362880, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {142702560000.0, 6187104000.0, 199584000, 3628800, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {97037740800.0, 2634508800.0, 39916800, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {37362124800.0, 479001600.0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {1932053504.0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
};

static float powerToFD15[15][15] = {
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1},
    {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0},
    {16382, 8190, 4094, 2046, 1022, 510, 254, 126, 62, 30, 14, 6, 2, 0, 0},
    {4733820, 1569750, 519156, 171006, 55980, 18150, 5796, 1806, 540, 150, 36, 6, 0, 0, 0},
    {249401880.0, 60780720, 14676024, 3498000, 818520, 186480, 40824, 8400, 1560, 240, 24, 0, 0, 0, 0},
    {4809004200.0, 901020120.0, 165528000.0, 29607600.0, 5103000, 834120, 126000, 16800, 1800, 120, 0, 0, 0, 0, 0},
    {45674188560.0, 6711344640.0, 953029440.0, 129230640.0, 16435440.0, 1905120, 191520, 15120, 720, 0, 0, 0, 0, 0, 0},
    {248619571200.0, 28805736960.0, 3162075840.0, 322494480.0, 29635200.0, 2328480, 141120, 5040, 0, 0, 0, 0, 0, 0, 0},
    {843184742400.0, 76592355840.0, 6411968640.0, 479001600.0, 30240000.0, 1451520, 40320, 0, 0, 0, 0, 0, 0, 0, 0},
    {1863435974400.0, 130456085760.0, 8083152000.0, 419126400.0, 16329600.0, 362880, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {2731586457600.0, 142702560000.0, 6187104000.0, 199584000.0, 3628800, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {2637143308800.0, 97037740800.0, 2634508800.0, 39916800.0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {1612798387200.0, 37362124800.0, 479001600.0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {175816868864.0, 1932053504.0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {1278945280.0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
};

static float powerToFD16[16][16] = {
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1},
    {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0},
    {32766, 16382, 8190, 4094, 2046, 1022, 510, 254, 126, 62, 30, 14, 6, 2, 0, 0},
    {14250606, 4733820, 1569750, 519156, 171006, 55980, 18150, 5796, 1806, 540, 150, 36, 6, 0, 0, 0},
    {1016542800.0, 249401880.0, 60780720.0, 14676024.0, 3498000, 818520, 186480, 40824, 8400, 1560, 240, 24, 0, 0, 0, 0},
    {25292030400.0, 4809004200.0, 901020120.0, 165528000.0, 29607600.0, 5103000.0, 834120, 126000, 16800, 1800, 120, 0, 0, 0, 0, 0},
    {302899156560.0, 45674188560.0, 6711344640.0, 953029440.0, 129230640.0, 16435440.0, 1905120.0, 191520.0, 15120, 720, 0, 0, 0, 0, 0, 0},
    {2060056318320.0, 248619571200.0, 28805736960.0, 3162075840.0, 322494480.0, 29635200.0, 2328480.0, 141120, 5040, 0, 0, 0, 0, 0, 0, 0},
    {8734434508800.0, 843184742400.0, 76592355840.0, 6411968640.0, 479001600.0, 30240000.0, 1451520.0, 40320, 0, 0, 0, 0, 0, 0, 0, 0},
    {24359586451200.0, 1863435974400.0, 130456085760.0, 8083152000.0, 419126400.0, 16329600.0, 362880, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {45950224320000.0, 2731586457600.0, 142702560000.0, 6187104000.0, 199584000.0, 3628800.0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {59056027430400.0, 2637143308800.0, 97037740800.0, 2634508800.0, 39916800.0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {50999300352000.0, 1612798387200.0, 37362124800.0, 479001600.0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {8790843443200.0, 175816868864.0, 1932053504.0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {134289254400.0, 1278945280.0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {2004310016.0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
};

static float inversePowerToFD1[1][1] = {
 {1},
};

static float inversePowerToFD2[2][2] = {
 {0, 1},
 {1, 0},
};

static float inversePowerToFD3[3][3] = {
 {0, 0, 0.5},
 {0, 1.0, -0.5},
 {1.0, 0, 0},
};

static float inversePowerToFD4[4][4] = {
 {0, 0, 0, 0.1666666666666667},
 {0, 0, 0.5, -0.5},
 {0, 1.0, -0.5, 0.3333333333333334},
 {1.0, 0, 0, 0},
};

static float inversePowerToFD5[5][5] = {
 { 0, 0, 0, 0, 0.04166666666666666},
 { 0, 0, 0, 0.1666666666666667, -0.25},
 { 0, 0, 0.5, -0.5, 0.4583333333333334},
 { 0, 1.0, -0.5, 0.3333333333333333, -0.25},
 { 1.0, 0, 0, 0, 0}, 
};

static float inversePowerToFD6[6][6] = {
 { 0, 0, 0, 0, -8.673617379884036e-019, 8.333333333333335e-003},
 { 0, 0, 0, 0, 4.166666666666666e-002, -8.333333333333333e-002},
 { 0, 0, 0, 1.666666666666667e-001, -2.500000000000000e-001, 2.916666666666667e-001},
 { 0, 0, 5.000000000000000e-001, -5.000000000000000e-001, 4.583333333333334e-001, -4.166666666666667e-001},
 { 0, 1.000000000000000e+000, -5.000000000000000e-001, 3.333333333333333e-001, -2.500000000000000e-001, 2.000000000000001e-001},
 { 1.000000000000000e+000, 0, 0, 0, 0, 0},
};

static float inversePowerToFD7[7][7] = {
 { 0, 0, 0, 0, 1.084202172485504e-019, -2.168404344971009e-019, 1.388888888888889e-003},
 { 0, 0, 0, -1.734723475976807e-018, 2.602085213965211e-018, 8.333333333333332e-003, -2.083333333333333e-002},
 { 0, 0, 0, 0, 4.166666666666667e-002, -8.333333333333334e-002, 1.180555555555556e-001},
 { 0, 0, 0, 1.666666666666667e-001, -2.500000000000000e-001, 2.916666666666667e-001, -3.125000000000001e-001},
 { 0, 0, 5.000000000000000e-001, -5.000000000000000e-001, 4.583333333333334e-001, -4.166666666666667e-001, 3.805555555555557e-001},
 { 0, 1.000000000000000e+000, -5.000000000000000e-001, 3.333333333333334e-001, -2.500000000000001e-001, 2.000000000000001e-001, -1.666666666666668e-001},
 {1.000000000000000e+000, 0, 0, 0, 0, 0, 0},
};

static float inversePowerToFD8[8][8] = {
 { 0, 0, 0, 1.355252715606881e-020, -1.355252715606881e-020, 2.710505431213761e-020, -2.710505431213761e-020, 1.984126984126984e-004},
 { 0, 0, 0, 0, -2.168404344971009e-019, 2.168404344971009e-019, 1.388888888888889e-003, -4.166666666666667e-003},
 { 0, 0, 0, 0, 1.734723475976807e-018, 8.333333333333333e-003, -2.083333333333333e-002, 3.472222222222222e-002},
 { 0, 0, 0, 0, 4.166666666666666e-002, -8.333333333333332e-002, 1.180555555555556e-001, -1.458333333333333e-001},
 { 0, 0, 0, 1.666666666666667e-001, -2.500000000000000e-001, 2.916666666666667e-001, -3.125000000000001e-001, 3.222222222222224e-001},
 { 0, 0, 5.000000000000000e-001, -5.000000000000000e-001, 4.583333333333334e-001, -4.166666666666669e-001, 3.805555555555558e-001, -3.500000000000003e-001},
 { 0, 1.000000000000000e+000, -5.000000000000000e-001, 3.333333333333333e-001, -2.500000000000000e-001, 2.000000000000000e-001, -1.666666666666667e-001, 1.428571428571431e-001},
 { 1.000000000000000e+000, 0, 0, 0, 0, 0, 0, 0},
};

static float inversePowerToFD9[9][9] = {
 {0, 0, 0, 3.388131789017201e-021, -3.388131789017201e-021, 8.470329472543003e-021, -9.317362419797304e-021, 6.776263578034403e-021, 2.480158730158730e-005},
 {0, 0, 0, -2.710505431213761e-020, 0, 5.421010862427522e-020, -5.421010862427522e-020, 1.984126984126985e-004, -6.944444444444445e-004},
 {0, 0, 0, -4.336808689942018e-019, 8.673617379884036e-019, -8.673617379884036e-019, 1.388888888888890e-003, -4.166666666666668e-003, 7.986111111111112e-003},
 {0, 0, 0, 0, 0, 8.333333333333335e-003, -2.083333333333333e-002, 3.472222222222222e-002, -4.861111111111112e-002},
 {0, 0, 0, 2.081668171172169e-017, 4.166666666666664e-002, -8.333333333333332e-002, 1.180555555555555e-001, -1.458333333333333e-001, 1.678819444444444e-001},
 {0, 0, 0, 1.666666666666666e-001, -2.499999999999999e-001, 2.916666666666666e-001, -3.124999999999999e-001, 3.222222222222220e-001, -3.256944444444442e-001},
 {0, 0, 5.000000000000000e-001, -5.000000000000000e-001, 4.583333333333332e-001, -4.166666666666664e-001, 3.805555555555553e-001, -3.499999999999995e-001, 3.241071428571424e-001},
 {0, 1.000000000000000e+000, -5.000000000000000e-001, 3.333333333333333e-001, -2.499999999999999e-001, 1.999999999999999e-001, -1.666666666666665e-001, 1.428571428571426e-001, -1.249999999999997e-001},
 {1.000000000000000e+000, 0, 0, 0, 0, 0, 0, 0, 0},
};

static float inversePowerToFD10[10][10] = {
 { 0, 0, 0, -1.058791184067875e-022, 0, 0, -2.117582368135751e-022, 8.470329472543003e-022, -2.117582368135751e-021, 2.755731922398594e-006}, 
 { 0, 0, 0, 3.388131789017201e-021, 0, -1.355252715606881e-020, 2.032879073410321e-020, -2.371692252312041e-020, 2.480158730158734e-005, -9.920634920634926e-005},
 { 0, 0, 0, -5.421010862427522e-020, 0, 1.084202172485504e-019, -2.710505431213761e-019, 1.984126984126989e-004, -6.944444444444453e-004, 1.504629629629631e-003}, 
 { 0, 0, 0, 0, 0, -8.673617379884036e-019, 1.388888888888891e-003, -4.166666666666669e-003, 7.986111111111116e-003, -1.250000000000001e-002},
 { 0, 0, 0, 0, 0, 8.333333333333338e-003, -2.083333333333335e-002, 3.472222222222225e-002, -4.861111111111115e-002, 6.186342592592600e-002}, 
 { 0, 0, 0, 0, 4.166666666666667e-002, -8.333333333333337e-002, 1.180555555555556e-001, -1.458333333333334e-001, 1.678819444444446e-001, -1.854166666666670e-001},
 { 0, 0, 0, 1.666666666666667e-001, -2.500000000000000e-001, 2.916666666666668e-001, -3.125000000000002e-001, 3.222222222222225e-001, -3.256944444444448e-001, 3.255180776014118e-001}, 
 { 0, 0, 5.000000000000000e-001, -4.999999999999999e-001, 4.583333333333333e-001, -4.166666666666669e-001, 3.805555555555559e-001, -3.500000000000004e-001, 3.241071428571435e-001, -3.019841269841282e-001},
 { 0, 1.000000000000000e+000, -5.000000000000000e-001, 3.333333333333333e-001, -2.499999999999999e-001, 2.000000000000000e-001, -1.666666666666667e-001, 1.428571428571430e-001, -1.250000000000003e-001, 1.111111111111117e-001}, 
 { 1.000000000000000e+000, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
};

static float inversePowerToFD11[11][11] = {
{ 0, 0, 0, 0, 0, -1.323488980084844e-023, 1.985233470127266e-023, 0, -2.646977960169689e-023, 2.646977960169689e-023, 2.755731922398589e-007},
{ 0, 0, 0, 0, 0, 6.352747104407253e-022, -1.694065894508601e-021, 3.388131789017201e-021, -6.988021814847978e-021, 2.755731922398603e-006, -1.240079365079368e-005},
{ 0, 0, 0, 2.710505431213761e-020, -1.355252715606881e-020, 0, 1.355252715606881e-020, -2.710505431213761e-020, 2.480158730158737e-005, -9.920634920634938e-005, 2.397486772486777e-004},
{ 0, 0, 0, -2.168404344971009e-019, 1.084202172485504e-019, 2.168404344971009e-019, -5.963111948670274e-019, 1.984126984126994e-004, -6.944444444444463e-004, 1.504629629629633e-003, -2.604166666666673e-003},
{ 0, 0, 0, 0, 8.673617379884036e-019, -2.168404344971009e-018, 1.388888888888893e-003, -4.166666666666673e-003, 7.986111111111123e-003, -1.250000000000002e-002, 1.743634259259262e-002},
{ 0, 0, 0, 0, -3.469446951953614e-018, 8.333333333333344e-003, -2.083333333333335e-002, 3.472222222222225e-002, -4.861111111111115e-002, 6.186342592592597e-002, -7.421875000000003e-002},
{ 0, 0, 0, 1.387778780781446e-017, 4.166666666666666e-002, -8.333333333333334e-002, 1.180555555555556e-001, -1.458333333333335e-001, 1.678819444444446e-001, -1.854166666666667e-001, 1.994268077601409e-001},
{ 0, 0, 0, 1.666666666666667e-001, -2.500000000000000e-001, 2.916666666666667e-001, -3.125000000000001e-001, 3.222222222222226e-001, -3.256944444444450e-001, 3.255180776014112e-001, -3.231646825396818e-001},
{ 0, 0, 5.000000000000000e-001, -5.000000000000000e-001, 4.583333333333334e-001, -4.166666666666668e-001, 3.805555555555558e-001, -3.500000000000005e-001, 3.241071428571436e-001, -3.019841269841275e-001, 2.828968253968248e-001},
{ 0, 1.000000000000000e+000, -5.000000000000000e-001, 3.333333333333333e-001, -2.500000000000000e-001, 2.000000000000000e-001, -1.666666666666668e-001, 1.428571428571432e-001, -1.250000000000005e-001, 1.111111111111115e-001, -9.999999999999990e-002},
{ 1.000000000000000e+000, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
};

static float inversePowerToFD12[12][12] = {
 { 0, 0, 0, 0, 0, -4.135903062765138e-025, 1.654361225106055e-024, 0, -4.963083675318166e-024, 1.571643163850753e-023, -3.308722450212111e-023, 2.505210838544177e-008},
 { 0, 0, 0, -1.058791184067875e-022, 1.588186776101813e-022, -1.588186776101813e-022, 1.323488980084844e-022, -2.117582368135751e-022, 4.235164736271502e-022, -8.999725064576941e-022, 2.755731922398606e-007, -1.377865961199297e-006},
 { 0, 0, 0, 0, 1.694065894508601e-021, -8.470329472543003e-022, 0, 3.388131789017201e-021, -1.016439536705160e-020, 2.755731922398615e-006, -1.240079365079371e-005, 3.306878306878317e-005},
 { 0, 0, 0, -2.710505431213761e-020, 0, 3.388131789017201e-020, -8.131516293641283e-020, 1.084202172485504e-019, 2.480158730158719e-005, -9.920634920634925e-005, 2.397486772486777e-004, -4.546957671957683e-004},
 { 0, 0, 0, 0, 2.168404344971009e-019, -3.794707603699266e-019, 5.421010862427522e-019, 1.984126984126981e-004, -6.944444444444450e-004, 1.504629629629632e-003, -2.604166666666673e-003, 3.952546296296310e-003},
 { 0, 0, 0, 0, 0, 1.301042606982605e-018, 1.388888888888886e-003, -4.166666666666662e-003, 7.986111111111107e-003, -1.250000000000000e-002, 1.743634259259261e-002, -2.259837962962969e-002},
 { 0, 0, 0, 6.938893903907228e-018, -6.938893903907228e-018, 8.333333333333338e-003, -2.083333333333333e-002, 3.472222222222222e-002, -4.861111111111111e-002, 6.186342592592592e-002, -7.421875000000003e-002, 8.560130070546752e-002},
 { 0, 0, 0, -1.387778780781446e-017, 4.166666666666668e-002, -8.333333333333334e-002, 1.180555555555555e-001, -1.458333333333333e-001, 1.678819444444442e-001, -1.854166666666664e-001, 1.994268077601408e-001, -2.106757054673722e-001},
 { 0, 0, 0, 1.666666666666667e-001, -2.500000000000000e-001, 2.916666666666667e-001, -3.124999999999999e-001, 3.222222222222221e-001, -3.256944444444441e-001, 3.255180776014103e-001, -3.231646825396818e-001, 3.195039682539682e-001},
 { 0, 0, 5.000000000000000e-001, -5.000000000000000e-001, 4.583333333333333e-001, -4.166666666666668e-001, 3.805555555555558e-001, -3.500000000000001e-001, 3.241071428571427e-001, -3.019841269841264e-001, 2.828968253968248e-001, -2.662698412698415e-001},
 { 0, 1.000000000000000e+000, -5.000000000000000e-001, 3.333333333333334e-001, -2.500000000000001e-001, 2.000000000000002e-001, -1.666666666666669e-001, 1.428571428571430e-001, -1.250000000000001e-001, 1.111111111111111e-001, -9.999999999999995e-002, 9.090909090909122e-002},
 { 1.000000000000000e+000, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
};

static float inversePowerToFD13[13][13] = {
{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1.000000000000000e+000},
{1.000000000000000e+000, 1.000000000000000e+000, 1.000000000000000e+000, 1.000000000000000e+000, 1.000000000000000e+000, 1.000000000000000e+000, 1.000000000000000e+000, 1.000000000000000e+000, 1.000000000000000e+000, 1.000000000000000e+000, 1.000000000000000e+000, 1.000000000000000e+000, 0},
{4.094000000000000e+003, 2.046000000000000e+003, 1.022000000000000e+003, 5.100000000000000e+002, 2.540000000000000e+002, 1.260000000000000e+002, 6.200000000000000e+001, 3.000000000000000e+001, 1.400000000000000e+001, 6.000000000000000e+000, 2.000000000000000e+000, 0, 0},
{5.191560000000000e+005, 1.710060000000000e+005, 5.598000000000000e+004, 1.815000000000000e+004, 5.796000000000000e+003, 1.806000000000000e+003, 5.400000000000000e+002, 1.500000000000000e+002, 3.600000000000000e+001, 6.000000000000000e+000, 0, 0, 0},
{1.467602400000000e+007, 3.498000000000000e+006, 8.185200000000000e+005, 1.864800000000000e+005, 4.082400000000000e+004, 8.400000000000000e+003, 1.560000000000000e+003, 2.400000000000000e+002, 2.400000000000000e+001, 0, 0, 0, 0},
{1.655280000000000e+008, 2.960760000000000e+007, 5.103000000000000e+006, 8.341200000000000e+005, 1.260000000000000e+005, 1.680000000000000e+004, 1.800000000000000e+003, 1.200000000000000e+002, 0, 0, 0, 0, 0},
{9.530294400000000e+008, 1.292306400000000e+008, 1.643544000000000e+007, 1.905120000000000e+006, 1.915200000000000e+005, 1.512000000000000e+004, 7.200000000000000e+002, 0, 0, 0, 0, 0, 0},
{3.162075840000000e+009, 3.224944800000000e+008, 2.963520000000000e+007, 2.328480000000000e+006, 1.411200000000000e+005, 5.040000000000000e+003, 0, 0, 0, 0, 0, 0, 0},
{6.411968640000000e+009, 4.790016000000000e+008, 3.024000000000000e+007, 1.451520000000000e+006, 4.032000000000000e+004, 0, 0, 0, 0, 0, 0, 0, 0},
{8.083152000000000e+009, 4.191264000000000e+008, 1.632960000000000e+007, 3.628800000000000e+005, 0, 0, 0, 0, 0, 0, 0, 0, 0},
{6.187104000000000e+009, 1.995840000000000e+008, 3.628800000000000e+006, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
{2.634508800000000e+009, 3.991680000000000e+007, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
{4.790016000000000e+008, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
};
 
static float inversePowerToFD14[14][14] = {
 { 0, 0, 0, 0, 1.292469707114106e-026, -1.938704560671159e-026, 3.231174267785264e-026, -4.523643974899370e-026, 7.270142102516845e-026, -1.292469707114106e-025, 1.898314882323843e-025, -1.809457589959748e-025, -1.292469707114106e-026, 5.175840099301946e-010},
 { 0, 0, 3.308722450212111e-024, -4.135903062765138e-024, 4.135903062765138e-024, -3.308722450212111e-024, 2.067951531382569e-024, -4.135903062765138e-025, -1.033975765691285e-024, 3.308722450212111e-024, -5.480071558163808e-024, 3.722312756488625e-024, 2.087675698786818e-009, -4.037155277455517e-008},
 { 0, 0, 0, 5.293955920339377e-023, -5.293955920339377e-023, 6.617444900424221e-023, -7.940933880509066e-023, 7.940933880509066e-023, -4.632211430296955e-023, -5.293955920339377e-023, 1.753622898612419e-022, 2.505210838544154e-008, -1.377865961199296e-007, 1.406275754980337e-006},
 { 0, 0, 0, -8.470329472543003e-022, 0, 1.058791184067875e-021, -2.117582368135751e-021, 2.964615315390051e-021, -4.658681209898652e-021, 6.776263578034403e-021, 2.755731922398507e-007, -1.377865961199290e-006, 4.018775720164620e-006, -2.886566023380700e-005},
 { 0, 0, 0, -1.355252715606881e-020, 1.355252715606881e-020, -5.082197683525802e-021, 0, 3.388131789017201e-021, 3.388131789017201e-021, 2.755731922398567e-006, -1.240079365079363e-005, 3.306878306878313e-005, -6.820436507936541e-005, 3.879100648343151e-004},
 { 0, 0, 0, -1.084202172485504e-019, 0, 6.776263578034403e-020, -1.084202172485504e-019, 1.626303258728257e-019, 2.480158730158704e-005, -9.920634920634864e-005, 2.397486772486765e-004, -4.546957671957671e-004, 7.461833112874805e-004, -3.585115001038839e-003},
 { 0, 0, 0, 4.336808689942018e-019, 0, -6.505213034913027e-019, 1.301042606982605e-018, 1.984126984126960e-004, -6.944444444444401e-004, 1.504629629629622e-003, -2.604166666666656e-003, 3.952546296296286e-003, -5.506365740740740e-003, 2.328622416866577e-002},
 { 0, 0, 0, 0, -3.469446951953614e-018, 6.071532165918825e-018, 1.388888888888879e-003, -4.166666666666650e-003, 7.986111111111083e-003, -1.249999999999995e-002, 1.743634259259251e-002, -2.259837962962950e-002, 2.784862305261595e-002, -1.066586145639159e-001},
 { 0, 0, 0, -6.938893903907228e-018, 2.081668171172169e-017, 8.333333333333297e-003, -2.083333333333329e-002, 3.472222222222215e-002, -4.861111111111099e-002, 6.186342592592570e-002, -7.421874999999956e-002, 8.560130070546657e-002, -9.602416776895803e-002, 3.401597495304081e-001},
 { 0, 0, 0, -2.775557561562891e-017, 4.166666666666671e-002, -8.333333333333337e-002, 1.180555555555556e-001, -1.458333333333333e-001, 1.678819444444443e-001, -1.854166666666662e-001, 1.994268077601399e-001, -2.106757054673695e-001, 2.197447273662498e-001, -7.318714958320032e-001},
 { 0, 0, 0, 1.666666666666667e-001, -2.499999999999999e-001, 2.916666666666666e-001, -3.125000000000000e-001, 3.222222222222222e-001, -3.256944444444445e-001, 3.255180776014106e-001, -3.231646825396810e-001, 3.195039682539639e-001, -3.150677910052809e-001, 9.997443383430656e-001},
 { 0, 0, 5.000000000000000e-001, -5.000000000000000e-001, 4.583333333333334e-001, -4.166666666666666e-001, 3.805555555555557e-001, -3.500000000000004e-001, 3.241071428571435e-001, -3.019841269841277e-001, 2.828968253968255e-001, -2.662698412698387e-001, 2.516564454064369e-001, -7.693590663625261e-001},
 { 0, 1.000000000000000e+000, -5.000000000000000e-001, 3.333333333333333e-001, -2.500000000000000e-001, 2.000000000000000e-001, -1.666666666666668e-001, 1.428571428571432e-001, -1.250000000000006e-001, 1.111111111111118e-001, -1.000000000000005e-001, 9.090909090909052e-002, -8.333333333333075e-002, 2.479235688909577e-001},
 { 1.000000000000000e+000, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
};

static float inversePowerToFD15[15][15] = {
{ 0, 0, 0, -8.077935669463161e-028, -3.231174267785264e-027, -4.846761401677897e-027, 8.885729236409477e-027, -1.130910993724843e-026, 1.262177448353619e-026, -1.292469707114106e-026, 1.231885189593132e-026, -1.050131637030211e-026, 8.279884061199740e-027, -3.231174267785264e-026, 7.818942808874530e-010},
{ 0, -1.654361225106055e-024, 8.271806125530277e-025, -6.203854594147708e-025, 4.135903062765138e-025, -8.788794008375919e-025, 1.654361225106055e-024, -2.584939414228212e-024, 3.405657678245669e-024, -3.929107909626882e-024, 4.148827759836279e-024, -4.135903062765138e-024, 3.877409121342317e-024, 5.175840099301827e-010, -7.115237956075797e-008},
{ 0, 1.058791184067875e-022, -5.293955920339377e-023, 3.639594695233322e-023, -3.970466940254533e-023, 4.632211430296955e-023, -7.610061635487855e-023, 1.091878408569997e-022, -1.302809464771019e-022, 1.323488980084844e-022, -1.162188760637004e-022, 8.271806125530277e-023, 2.087675698786772e-009, -4.037155277455509e-008, 2.917247561991086e-006},
{ 0, 0, 0, -1.058791184067875e-022, 0, -3.176373552203626e-022, 7.411538288475128e-022, -1.111730743271269e-021, 1.164670302474663e-021, -8.470329472543003e-022, 1.654361225106055e-022, 2.505210838544245e-008, -1.377865961199311e-007, 1.406275754980341e-006, -7.122353194031895e-005},
{ 0, 2.710505431213761e-020, -1.355252715606881e-020, 1.016439536705160e-020, -6.776263578034403e-021, 5.082197683525802e-021, -6.776263578034403e-021, 1.101142831430590e-020, -1.641126335305207e-020, 2.032879073410321e-020, 2.755731922398387e-007, -1.377865961199279e-006, 4.018775720164597e-006, -2.886566023380679e-005, 1.152882006022958e-003},
{ 0, 0, 0, 0, 0, -1.355252715606881e-020, 9.486769009248164e-020, -2.371692252312041e-019, 3.642241673193492e-019, 2.755731922398134e-006, -1.240079365079315e-005, 3.306878306878255e-005, -6.820436507936449e-005, 3.879100648343091e-004, -1.303390634507821e-002},
{ 0, 0, -4.336808689942018e-019, 4.336808689942018e-019, -4.336808689942018e-019, 3.252606517456513e-019, -1.084202172485504e-018, 2.168404344971009e-018, 2.480158730158389e-005, -9.920634920634452e-005, 2.397486772486715e-004, -4.546957671957603e-004, 7.461833112874690e-004, -3.585115001038764e-003, 1.055842459499107e-001},
{ 0, 0, 3.469446951953614e-018, -3.469446951953614e-018, 0, -1.734723475976807e-018, 6.071532165918825e-018, 1.984126984126851e-004, -6.944444444444233e-004, 1.504629629629601e-003, -2.604166666666629e-003, 3.952546296296247e-003, -5.506365740740666e-003, 2.328622416866524e-002, -6.184339278377696e-001},
{ 0, 1.110223024625157e-016, -4.163336342344337e-017, 2.081668171172169e-017, -1.387778780781446e-017, 1.040834085586084e-017, 1.388888888888867e-003, -4.166666666666614e-003, 7.986111111111024e-003, -1.249999999999987e-002, 1.743634259259239e-002, -2.259837962962934e-002, 2.784862305261564e-002, -1.066586145639135e-001, 2.608492199134465e+000},
{ 0, 0, 0, 0, 2.775557561562891e-017, 8.333333333333297e-003, -2.083333333333328e-002, 3.472222222222211e-002, -4.861111111111089e-002, 6.186342592592550e-002, -7.421874999999928e-002, 8.560130070546618e-002, -9.602416776895736e-002, 3.401597495304019e-001, -7.785871617587367e+000},
{ 0, 4.440892098500626e-016, -1.110223024625157e-016, 5.551115123125783e-017, 4.166666666666663e-002, -8.333333333333332e-002, 1.180555555555555e-001, -1.458333333333331e-001, 1.678819444444439e-001, -1.854166666666656e-001, 1.994268077601391e-001, -2.106757054673686e-001, 2.197447273662489e-001, -7.318714958319950e-001, 1.588320736912066e+001},
{ 0, 0, 0, 1.666666666666667e-001, -2.500000000000001e-001, 2.916666666666667e-001, -3.124999999999997e-001, 3.222222222222215e-001, -3.256944444444432e-001, 3.255180776014087e-001, -3.231646825396785e-001, 3.195039682539611e-001, -3.150677910052783e-001, 9.997443383430542e-001, -2.079582095646540e+001},
{ 0, 4.440892098500626e-016, 4.999999999999998e-001, -4.999999999999999e-001, 4.583333333333333e-001, -4.166666666666664e-001, 3.805555555555550e-001, -3.499999999999990e-001, 3.241071428571413e-001, -3.019841269841243e-001, 2.828968253968205e-001, -2.662698412698328e-001, 2.516564454064311e-001, -7.693590663625061e-001, 1.548366403916549e+001},
{ 0, 1.000000000000000e+000, -5.000000000000000e-001, 3.333333333333334e-001, -2.500000000000000e-001, 1.999999999999998e-001, -1.666666666666664e-001, 1.428571428571424e-001, -1.249999999999993e-001, 1.111111111111098e-001, -9.999999999999774e-002, 9.090909090908705e-002, -8.333333333332699e-002, 2.479235688909449e-001, -4.868871950486066e+000},
{ 1.000000000000000e+000, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
};

static float inversePowerToFD16[16][16] = {
 { 0, 1.615587133892632e-027, -8.077935669463161e-028, -1.615587133892632e-027, 2.827277484312106e-027, -3.534096855390133e-027, 3.837019442995001e-027, -4.266159775435232e-027, 4.846761401677897e-027, -5.578824321722996e-027, 6.866245319043687e-027, -9.125542951596665e-027, 1.259653093456912e-026, -5.593970451103239e-026, 1.589737739750350e-024, 4.989248130364881e-010},
 { 0, 0, -2.584939414228212e-026, 2.067951531382569e-025, -3.618915179919496e-025, 4.911384887033602e-025, -5.686866711302065e-025, 6.656218991637645e-025, -7.754818242684635e-025, 9.031132078459814e-025, -1.072749856904708e-024, 1.319732739998544e-024, -1.659207986507733e-024, 6.643294294566504e-024, 7.818942808872849e-010, -5.238710536883159e-008},
 { 0, 0, 0, 0, 1.654361225106055e-024, -5.790264287871194e-024, 8.271806125530277e-024, -1.137373342260413e-023, 1.488925102595450e-023, -1.912855166528877e-023, 2.646977960169689e-023, -3.931692849041110e-023, 5.955700410381799e-023, 5.175840099299126e-010, -7.115237956075005e-008, 2.497118689247629e-006},
 { 0, 0, -5.293955920339377e-023, 4.235164736271502e-022, -6.882142696441190e-022, 8.470329472543003e-022, -8.999725064576941e-022, 9.926167350636332e-022, -1.111730743271269e-021, 1.297019200483147e-021, -1.641126335305207e-021, 2.283018490646356e-021, 2.087675698783468e-009, -4.037155277453942e-008, 2.917247561990624e-006, -7.150839882845188e-005},
 { 0, 0, 0, -1.016439536705160e-020, 1.524659305057741e-020, -1.905824131322176e-020, 2.159934015498466e-020, -2.456395547037471e-020, 2.795208725939191e-020, -3.224019155486681e-020, 3.981054852095212e-020, 2.505210838538786e-008, -1.377865961198519e-007, 1.406275754979971e-006, -7.122353194030805e-005, 1.371917007872563e-003},
 { 0, -5.421010862427522e-020, 2.710505431213761e-020, 5.421010862427522e-020, -1.219727444046193e-019, 1.694065894508601e-019, -2.032879073410321e-019, 2.456395547037471e-019, -2.981555974335137e-019, 3.710004308973836e-019, 2.755731922393627e-007, -1.377865961198568e-006, 4.018775720163491e-006, -2.886566023380136e-005, 1.152882006022794e-003, -1.861601982833958e-002},
 { 0, 0, -1.084202172485504e-019, -8.673617379884036e-019, 1.517883041479706e-018, -1.897353801849633e-018, 2.168404344971009e-018, -2.561427632497004e-018, 3.144186300207963e-018, 2.755731922394627e-006, -1.240079365078829e-005, 3.306878306877514e-005, -6.820436507935272e-005, 3.879100648342507e-004, -1.303390634507643e-002, 1.838096961343281e-001},
 { 0, 3.469446951953614e-018, -8.673617379884036e-019, 1.387778780781446e-017, -1.908195823574488e-017, 2.168404344971009e-017, -2.168404344971009e-017, 2.423191855505102e-017, 2.480158730155859e-005, -9.920634920631432e-005, 2.397486772486312e-004, -4.546957671957010e-004, 7.461833112873777e-004, -3.585115001038322e-003, 1.055842459498977e-001, -1.337843823357720e+000},
 { 0, 0, 3.469446951953614e-018, -2.775557561562891e-017, 5.551115123125783e-017, -7.459310946700271e-017, 8.673617379884036e-017, 1.984126984125923e-004, -6.944444444443101e-004, 1.504629629629458e-003, -2.604166666666432e-003, 3.952546296295948e-003, -5.506365740740204e-003, 2.328622416866305e-002, -6.184339278377090e-001, 7.189168747834084e+000},
 { 0, 0, 1.387778780781446e-017, 1.110223024625157e-016, -2.220446049250313e-016, 3.122502256758253e-016, 1.388888888888530e-003, -4.166666666666218e-003, 7.986111111110555e-003, -1.249999999999931e-002, 1.743634259259168e-002, -2.259837962962829e-002, 2.784862305261406e-002, -1.066586145639066e-001, 2.608492199134309e+000, -2.827075966674896e+001},
 { 0, 2.220446049250313e-016, -1.110223024625157e-016, -6.661338147750939e-016, 9.992007221626409e-016, 8.333333333332138e-003, -2.083333333333204e-002, 3.472222222222073e-002, -4.861111111110933e-002, 6.186342592592379e-002, -7.421874999999725e-002, 8.560130070546350e-002, -9.602416776895391e-002, 3.401597495303908e-001, -7.785871617587300e+000, 7.968907225177995e+001},
 { 0, 0, 0, 8.881784197001252e-016, 4.166666666666519e-002, -8.333333333333143e-002, 1.180555555555534e-001, -1.458333333333307e-001, 1.678819444444413e-001, -1.854166666666630e-001, 1.994268077601365e-001, -2.106757054673658e-001, 2.197447273662466e-001, -7.318714958320010e-001, 1.588320736912164e+001, -1.551602586014341e+002},
 { 0, 0, -1.110223024625157e-016, 1.666666666666661e-001, -2.499999999999987e-001, 2.916666666666647e-001, -3.124999999999974e-001, 3.222222222222189e-001, -3.256944444444407e-001, 3.255180776014069e-001, -3.231646825396781e-001, 3.195039682539627e-001, -3.150677910052848e-001, 9.997443383431157e-001, -2.079582095646863e+001, 1.956567570353576e+002},
 { 0, 0, 5.000000000000000e-001, -4.999999999999996e-001, 4.583333333333323e-001, -4.166666666666651e-001, 3.805555555555534e-001, -3.499999999999973e-001, 3.241071428571400e-001, -3.019841269841246e-001, 2.828968253968234e-001, -2.662698412698396e-001, 2.516564454064454e-001, -7.693590663626030e-001, 1.548366403916965e+001, -1.414280451113939e+002},
 { 0, 1.000000000000000e+000, -5.000000000000000e-001, 3.333333333333328e-001, -2.499999999999993e-001, 1.999999999999992e-001, -1.666666666666656e-001, 1.428571428571416e-001, -1.249999999999988e-001, 1.111111111111102e-001, -9.999999999999960e-002, 9.090909090909112e-002, -8.333333333333474e-002, 2.479235688909923e-001, -4.868871950487935e+000, 4.349541263781754e+001},
 { 1.000000000000000e+000, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
};

/*****************************************************************************/
float cachedBinomialCoefficients[11][11] = {
  { 1.000000000000000e+000f, 1.000000000000000e+000f, 5.000000000000000e-001f, 1.666666666666667e-001f, 4.166666666666666e-002f,
    8.333333333333333e-003f, 1.388888888888889e-003f, 1.984126984126984e-004f, 2.480158730158730e-005f, 2.755731922398589e-006f, 2.755731922398589e-007f},
  { 1.000000000000000e+000f, 1.000000000000000e+000f, 5.000000000000000e-001f, 1.666666666666667e-001f, 4.166666666666666e-002f,
    8.333333333333333e-003f, 1.388888888888889e-003f, 1.984126984126984e-004f, 2.480158730158730e-005f, 2.755731922398589e-006f, 2.755731922398589e-007f},
  { 1.000000000000000e+000f, 2.000000000000000e+000f, 1.000000000000000e+000f, 3.333333333333333e-001f, 8.333333333333333e-002f,
    1.666666666666667e-002f, 2.777777777777778e-003f, 3.968253968253968e-004f, 4.960317460317460e-005f, 5.511463844797179e-006f, 5.511463844797179e-007f},
  { 1.000000000000000e+000f, 3.000000000000000e+000f, 3.000000000000000e+000f, 1.000000000000000e+000f, 2.500000000000000e-001f,
    5.000000000000000e-002f, 8.333333333333333e-003f, 1.190476190476190e-003f, 1.488095238095238e-004f, 1.653439153439153e-005f, 1.653439153439153e-006f},
  { 1.000000000000000e+000f, 4.000000000000000e+000f, 6.000000000000000e+000f, 4.000000000000000e+000f, 1.000000000000000e+000f,
    2.000000000000000e-001f, 3.333333333333333e-002f, 4.761904761904762e-003f, 5.952380952380952e-004f, 6.613756613756613e-005f, 6.613756613756613e-006f},
  { 1.000000000000000e+000f, 5.000000000000000e+000f, 1.000000000000000e+001f, 1.000000000000000e+001f, 5.000000000000000e+000f,
    1.000000000000000e+000f, 1.666666666666667e-001f, 2.380952380952381e-002f, 2.976190476190476e-003f, 3.306878306878307e-004f, 3.306878306878306e-005f},
  { 1.000000000000000e+000f, 6.000000000000000e+000f, 1.500000000000000e+001f, 2.000000000000000e+001f, 1.500000000000000e+001f,
    6.000000000000000e+000f, 1.000000000000000e+000f, 1.428571428571429e-001f, 1.785714285714286e-002f, 1.984126984126984e-003f, 1.984126984126984e-004f},
  { 1.000000000000000e+000f, 7.000000000000000e+000f, 2.100000000000000e+001f, 3.500000000000000e+001f, 3.500000000000000e+001f,
    2.100000000000000e+001f, 7.000000000000000e+000f, 1.000000000000000e+000f, 1.250000000000000e-001f, 1.388888888888889e-002f, 1.388888888888889e-003f},
  { 1.000000000000000e+000f, 8.000000000000000e+000f, 2.800000000000000e+001f, 5.600000000000000e+001f, 7.000000000000000e+001f,
    5.600000000000000e+001f, 2.800000000000000e+001f, 8.000000000000000e+000f, 1.000000000000000e+000f, 1.111111111111111e-001f, 1.111111111111111e-002f},
  { 1.000000000000000e+000f, 9.000000000000000e+000f, 3.600000000000000e+001f, 8.400000000000000e+001f, 1.260000000000000e+002f,
    1.260000000000000e+002f, 8.400000000000000e+001f, 3.600000000000000e+001f, 9.000000000000000e+000f, 1.000000000000000e+000f, 1.000000000000000e-001f},
  { 1.000000000000000e+000f, 1.000000000000000e+001f, 4.500000000000000e+001f, 1.200000000000000e+002f, 2.100000000000000e+002f,
    2.520000000000000e+002f, 2.100000000000000e+002f, 1.200000000000000e+002f, 4.500000000000000e+001f, 1.000000000000000e+001f, 1.000000000000000e+000f},
};

/*****************************************************************************/
const double rtable2[2][2][2] = {{{1, 0}, {0, 0}}, {{0, 0}, {0, 1}}};

const double rtable3[3][3][3] = {
    {{1, 0, 0}, {0, 0, 0}, {0, 0, 0}}, 
    {{0, 0, 0}, {0, 1, 0}, {0, -1./2, 1./2}}, {{0, 0, 0}, {0, 0, 0}, {0, 0, 1}}};

const double rtable4[4][4][4] = {
    {{1, 0, 0, 0}, {0, 0, 0, 0}, {0, 0, 0, 0}, {0, 0, 0, 0}}, 
    {{0, 0, 0, 0}, {0, 1, 0, 0}, {0, -1./2, 1./2, 0}, {0, 1./3, -1./2, 1./6}}, 
    {{0, 0, 0, 0}, {0, 0, 0, 0}, {0, 0, 1, 0}, {0, 0, -1, 1}}, 
    {{0, 0, 0, 0}, {0, 0, 0, 0}, {0, 0, 0, 0}, {0, 0, 0, 1}}};

const double rtable5[5][5][5] = {
    {{1, 0, 0, 0, 0}, {0, 0, 0, 0, 0}, {0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0}, {0, 0, 0, 0, 0}}, 
    {{0, 0, 0, 0, 0}, {0, 1, 0, 0, 0}, {0, -1./2, 1./2, 0, 0}, 
     {0, 1./3, -1./2, 1./6, 0}, {0, -1./4, 11./24, -1./4, 1./24}}, 
    {{0, 0, 0, 0, 0}, {0, 0, 0, 0, 0}, {0, 0, 1, 0, 0}, {0, 0, -1, 1, 0}, 
     {0, 0, 11./12, -3./2, 7./12}}, 
    {{0, 0, 0, 0, 0}, {0, 0, 0, 0, 0}, {0, 0, 0, 0, 0}, {0, 0, 0, 1, 0}, 
     {0, 0, 0, -3./2, 3./2}}, {{0, 0, 0, 0, 0}, {0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0}, {0, 0, 0, 0, 0}, {0, 0, 0, 0, 1}}};

const double rtable6[6][6][6] = {
    {{1, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0}}, {{0, 0, 0, 0, 0, 0}, {0, 1, 0, 0, 0, 0}, 
     {0, -1./2, 1./2, 0, 0, 0}, {0, 1./3, -1./2, 1./6, 0, 0}, 
     {0, -1./4, 11./24, -1./4, 1./24, 0}, {0, 1./5, -5./12, 7./24, -1./12, 1./120}}, 
    {{0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0}, {0, 0, 1, 0, 0, 0}, 
     {0, 0, -1, 1, 0, 0}, {0, 0, 11./12, -3./2, 7./12, 0}, 
     {0, 0, -5./6, 7./4, -7./6, 1./4}}, 
    {{0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 1, 0, 0}, {0, 0, 0, -3./2, 3./2, 0}, {0, 0, 0, 7./4, -3, 5./4}}, 
    {{0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 1, 0}, {0, 0, 0, 0, -2, 2}}, 
    {{0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 1}}};

const double rtable7[7][7][7] = {
    {{1, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0}}, 
    {{0, 0, 0, 0, 0, 0, 0}, {0, 1, 0, 0, 0, 0, 0}, 
     {0, -1./2, 1./2, 0, 0, 0, 0}, {0, 1./3, -1./2, 1./6, 0, 0, 0}, 
     {0, -1./4, 11./24, -1./4, 1./24, 0, 0}, 
     {0, 1./5, -5./12, 7./24, -1./12, 1./120, 0}, 
     {0, -1./6, 137./360, -5./16, 17./144, -1./48, 1./720}}, 
    {{0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0}, {0, 0, 1, 0, 0, 0, 0}, 
     {0, 0, -1, 1, 0, 0, 0}, {0, 0, 11./12, -3./2, 7./12, 0, 0}, 
     {0, 0, -5./6, 7./4, -7./6, 1./4, 0}, 
     {0, 0, 137./180, -15./8, 119./72, -5./8, 31./360}}, 
    {{0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 1, 0, 0, 0}, {0, 0, 0, -3./2, 3./2, 0, 0}, 
     {0, 0, 0, 7./4, -3, 5./4, 0}, {0, 0, 0, -15./8, 17./4, -25./8, 3./4}}, 
    {{0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 1, 0, 0}, {0, 0, 0, 0, -2, 2, 0}, 
     {0, 0, 0, 0, 17./6, -5, 13./6}}, 
    {{0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 1, 0}, 
     {0, 0, 0, 0, 0, -5./2, 5./2}}, 
    {{0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 1}}};

const double rtable8[8][8][8] = {
    {{1, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0}, {0, 1, 0, 0, 0, 0, 0, 0}, 
     {0, -1./2, 1./2, 0, 0, 0, 0, 0}, {0, 1./3, -1./2, 1./6, 0, 0, 0, 0}, 
     {0, -1./4, 11./24, -1./4, 1./24, 0, 0, 0}, 
     {0, 1./5, -5./12, 7./24, -1./12, 1./120, 0, 0}, 
     {0, -1./6, 137./360, -5./16, 17./144, -1./48, 1./720, 0}, 
     {0, 1./7, -7./20, 29./90, -7./48, 5./144, -1./240, 1./5040}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 1, 0, 0, 0, 0, 0}, {0, 0, -1, 1, 0, 0, 0, 0}, 
     {0, 0, 11./12, -3./2, 7./12, 0, 0, 0}, {0, 0, -5./6, 7./4, -7./6, 1./4, 0, 0}, 
     {0, 0, 137./180, -15./8, 119./72, -5./8, 31./360, 0}, 
     {0, 0, -7./10, 29./15, -49./24, 25./24, -31./120, 1./40}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 1, 0, 0, 0, 0}, 
     {0, 0, 0, -3./2, 3./2, 0, 0, 0}, {0, 0, 0, 7./4, -3, 5./4, 0, 0}, 
     {0, 0, 0, -15./8, 17./4, -25./8, 3./4, 0}, 
     {0, 0, 0, 29./15, -21./4, 125./24, -9./4, 43./120}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 1, 0, 0, 0}, {0, 0, 0, 0, -2, 2, 0, 0}, 
     {0, 0, 0, 0, 17./6, -5, 13./6, 0}, {0, 0, 0, 0, -7./2, 25./3, -13./2, 5./3}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 1, 0, 0}, 
     {0, 0, 0, 0, 0, -5./2, 5./2, 0}, {0, 0, 0, 0, 0, 25./6, -15./2, 10./3}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 1, 0}, {0, 0, 0, 0, 0, 0, -3, 3}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 1}}};

const double rtable9[9][9][9] = {
    {{1, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 1, 0, 0, 0, 0, 0, 0, 0}, 
     {0, -1./2, 1./2, 0, 0, 0, 0, 0, 0}, {0, 1./3, -1./2, 1./6, 0, 0, 0, 0, 0}, 
     {0, -1./4, 11./24, -1./4, 1./24, 0, 0, 0, 0}, 
     {0, 1./5, -5./12, 7./24, -1./12, 1./120, 0, 0, 0}, 
     {0, -1./6, 137./360, -5./16, 17./144, -1./48, 1./720, 0, 0}, 
     {0, 1./7, -7./20, 29./90, -7./48, 5./144, -1./240, 1./5040, 0}, 
     {0, -1./8, 363./1120, -469./1440, 967./5760, -7./144, 23./2880, -1./1440, 
      1./40320}}, {{0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 1, 0, 0, 0, 0, 0, 0}, {0, 0, -1, 1, 0, 0, 0, 0, 0}, 
     {0, 0, 11./12, -3./2, 7./12, 0, 0, 0, 0}, 
     {0, 0, -5./6, 7./4, -7./6, 1./4, 0, 0, 0}, 
     {0, 0, 137./180, -15./8, 119./72, -5./8, 31./360, 0, 0}, 
     {0, 0, -7./10, 29./15, -49./24, 25./24, -31./120, 1./40, 0}, 
     {0, 0, 363./560, -469./240, 6769./2880, -35./24, 713./1440, -7./80, 
      127./20160}}, {{0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 1, 0, 0, 0, 0, 0}, {0, 0, 0, -3./2, 3./2, 0, 0, 0, 0}, 
     {0, 0, 0, 7./4, -3, 5./4, 0, 0, 0}, 
     {0, 0, 0, -15./8, 17./4, -25./8, 3./4, 0, 0}, 
     {0, 0, 0, 29./15, -21./4, 125./24, -9./4, 43./120, 0}, 
     {0, 0, 0, -469./240, 967./160, -175./24, 69./16, -301./240, 23./160}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 1, 0, 0, 0, 0}, {0, 0, 0, 0, -2, 2, 0, 0, 0}, 
     {0, 0, 0, 0, 17./6, -5, 13./6, 0, 0}, 
     {0, 0, 0, 0, -7./2, 25./3, -13./2, 5./3, 0}, 
     {0, 0, 0, 0, 967./240, -35./3, 299./24, -35./6, 81./80}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 1, 0, 0, 0}, 
     {0, 0, 0, 0, 0, -5./2, 5./2, 0, 0}, 
     {0, 0, 0, 0, 0, 25./6, -15./2, 10./3, 0}, 
     {0, 0, 0, 0, 0, -35./6, 115./8, -35./3, 25./8}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 1, 0, 0}, {0, 0, 0, 0, 0, 0, -3, 3, 0}, 
     {0, 0, 0, 0, 0, 0, 23./4, -21./2, 19./4}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 1, 0}, 
     {0, 0, 0, 0, 0, 0, 0, -7./2, 7./2}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 1}}};

const double rtable10[10][10][10] = {
    {{1, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 1, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, -1./2, 1./2, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 1./3, -1./2, 1./6, 0, 0, 0, 0, 0, 0}, 
     {0, -1./4, 11./24, -1./4, 1./24, 0, 0, 0, 0, 0}, 
     {0, 1./5, -5./12, 7./24, -1./12, 1./120, 0, 0, 0, 0}, 
     {0, -1./6, 137./360, -5./16, 17./144, -1./48, 1./720, 0, 0, 0}, 
     {0, 1./7, -7./20, 29./90, -7./48, 5./144, -1./240, 1./5040, 0, 0}, 
     {0, -1./8, 363./1120, -469./1440, 967./5760, -7./144, 23./2880, -1./1440, 
      1./40320, 0}, {0, 1./9, -761./2520, 29531./90720, -89./480, 1069./17280, 
      -1./80, 13./8640, -1./10080, 1./362880}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 1, 0, 0, 0, 0, 0, 0, 0}, {0, 0, -1, 1, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 11./12, -3./2, 7./12, 0, 0, 0, 0, 0}, 
     {0, 0, -5./6, 7./4, -7./6, 1./4, 0, 0, 0, 0}, 
     {0, 0, 137./180, -15./8, 119./72, -5./8, 31./360, 0, 0, 0}, 
     {0, 0, -7./10, 29./15, -49./24, 25./24, -31./120, 1./40, 0, 0}, 
     {0, 0, 363./560, -469./240, 6769./2880, -35./24, 713./1440, -7./80, 
      127./20160, 0}, {0, 0, -761./1260, 29531./15120, -623./240, 1069./576, 
      -31./40, 91./480, -127./5040, 17./12096}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 1, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, -3./2, 3./2, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 7./4, -3, 5./4, 0, 0, 0, 0}, 
     {0, 0, 0, -15./8, 17./4, -25./8, 3./4, 0, 0, 0}, 
     {0, 0, 0, 29./15, -21./4, 125./24, -9./4, 43./120, 0, 0}, 
     {0, 0, 0, -469./240, 967./160, -175./24, 69./16, -301./240, 23./160, 0}, 
     {0, 0, 0, 29531./15120, -267./40, 5345./576, -27./4, 3913./1440, -23./40, 
      605./12096}}, {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 1, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, -2, 2, 0, 0, 0, 0}, {0, 0, 0, 0, 17./6, -5, 13./6, 0, 0, 0}, 
     {0, 0, 0, 0, -7./2, 25./3, -13./2, 5./3, 0, 0}, 
     {0, 0, 0, 0, 967./240, -35./3, 299./24, -35./6, 81./80, 0}, 
     {0, 0, 0, 0, -89./20, 1069./72, -39./2, 455./36, -81./20, 37./72}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 1, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, -5./2, 5./2, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 25./6, -15./2, 10./3, 0, 0}, 
     {0, 0, 0, 0, 0, -35./6, 115./8, -35./3, 25./8, 0}, 
     {0, 0, 0, 0, 0, 1069./144, -45./2, 455./18, -25./2, 331./144}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 1, 0, 0, 0}, {0, 0, 0, 0, 0, 0, -3, 3, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 23./4, -21./2, 19./4, 0}, 
     {0, 0, 0, 0, 0, 0, -9, 91./4, -19, 21./4}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 1, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, -7./2, 7./2, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 91./12, -14, 77./12}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 1, 0}, {0, 0, 0, 0, 0, 0, 0, 0, -4, 4}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 1}}};

const double rtable11[11][11][11] = {
    {{1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, -1./2, 1./2, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 1./3, -1./2, 1./6, 0, 0, 0, 0, 0, 0, 0}, 
     {0, -1./4, 11./24, -1./4, 1./24, 0, 0, 0, 0, 0, 0}, 
     {0, 1./5, -5./12, 7./24, -1./12, 1./120, 0, 0, 0, 0, 0}, 
     {0, -1./6, 137./360, -5./16, 17./144, -1./48, 1./720, 0, 0, 0, 0}, 
     {0, 1./7, -7./20, 29./90, -7./48, 5./144, -1./240, 1./5040, 0, 0, 0}, 
     {0, -1./8, 363./1120, -469./1440, 967./5760, -7./144, 23./2880, -1./1440, 
      1./40320, 0, 0}, {0, 1./9, -761./2520, 29531./90720, -89./480, 1069./17280, 
      -1./80, 13./8640, -1./10080, 1./362880, 0}, 
     {0, -1./10, 7129./25200, -1303./4032, 4523./22680, -19./256, 3013./172800, 
      -1./384, 29./120960, -1./80640, 1./3628800}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, -1, 1, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 11./12, -3./2, 7./12, 0, 0, 0, 0, 0, 0}, 
     {0, 0, -5./6, 7./4, -7./6, 1./4, 0, 0, 0, 0, 0}, 
     {0, 0, 137./180, -15./8, 119./72, -5./8, 31./360, 0, 0, 0, 0}, 
     {0, 0, -7./10, 29./15, -49./24, 25./24, -31./120, 1./40, 0, 0, 0}, 
     {0, 0, 363./560, -469./240, 6769./2880, -35./24, 713./1440, -7./80, 
      127./20160, 0, 0}, {0, 0, -761./1260, 29531./15120, -623./240, 1069./576, 
      -31./40, 91./480, -127./5040, 17./12096, 0}, 
     {0, 0, 7129./12600, -1303./672, 4523./1620, -285./128, 93403./86400, -21./64, 
      3683./60480, -17./2688, 73./259200}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, -3./2, 3./2, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 7./4, -3, 5./4, 0, 0, 0, 0, 0}, 
     {0, 0, 0, -15./8, 17./4, -25./8, 3./4, 0, 0, 0, 0}, 
     {0, 0, 0, 29./15, -21./4, 125./24, -9./4, 43./120, 0, 0, 0}, 
     {0, 0, 0, -469./240, 967./160, -175./24, 69./16, -301./240, 23./160, 0, 0}, 
     {0, 0, 0, 29531./15120, -267./40, 5345./576, -27./4, 3913./1440, -23./40, 
      605./12096, 0}, {0, 0, 0, -1303./672, 4523./630, -1425./128, 3013./320, 
      -301./64, 667./480, -605./2688, 311./20160}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, -2, 2, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 17./6, -5, 13./6, 0, 0, 0, 0}, 
     {0, 0, 0, 0, -7./2, 25./3, -13./2, 5./3, 0, 0, 0}, 
     {0, 0, 0, 0, 967./240, -35./3, 299./24, -35./6, 81./80, 0, 0}, 
     {0, 0, 0, 0, -89./20, 1069./72, -39./2, 455./36, -81./20, 37./72, 0}, 
     {0, 0, 0, 0, 4523./945, -285./16, 39169./1440, -175./8, 783./80, -37./16, 
      6821./30240}}, {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, -5./2, 5./2, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 25./6, -15./2, 10./3, 0, 0, 0}, 
     {0, 0, 0, 0, 0, -35./6, 115./8, -35./3, 25./8, 0, 0}, 
     {0, 0, 0, 0, 0, 1069./144, -45./2, 455./18, -25./2, 331./144, 0}, 
     {0, 0, 0, 0, 0, -285./32, 3013./96, -175./4, 725./24, -331./32, 45./32}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, -3, 3, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 23./4, -21./2, 19./4, 0, 0}, 
     {0, 0, 0, 0, 0, 0, -9, 91./4, -19, 21./4, 0}, 
     {0, 0, 0, 0, 0, 0, 3013./240, -315./8, 551./12, -189./8, 1087./240}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, -7./2, 7./2, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 91./12, -14, 77./12, 0}, 
     {0, 0, 0, 0, 0, 0, 0, -105./8, 203./6, -231./8, 49./6}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, -4, 4, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 29./3, -18, 25./3}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, -9./2, 9./2}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1}}};

const double rtable12[12][12][12] = {
    {{1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, -1./2, 1./2, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 1./3, -1./2, 1./6, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, -1./4, 11./24, -1./4, 1./24, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 1./5, -5./12, 7./24, -1./12, 1./120, 0, 0, 0, 0, 0, 0}, 
     {0, -1./6, 137./360, -5./16, 17./144, -1./48, 1./720, 0, 0, 0, 0, 0}, 
     {0, 1./7, -7./20, 29./90, -7./48, 5./144, -1./240, 1./5040, 0, 0, 0, 0}, 
     {0, -1./8, 363./1120, -469./1440, 967./5760, -7./144, 23./2880, -1./1440, 
      1./40320, 0, 0, 0}, {0, 1./9, -761./2520, 29531./90720, -89./480, 
      1069./17280, -1./80, 13./8640, -1./10080, 1./362880, 0, 0}, 
     {0, -1./10, 7129./25200, -1303./4032, 4523./22680, -19./256, 3013./172800, 
      -1./384, 29./120960, -1./80640, 1./3628800, 0}, 
     {0, 1./11, -671./2520, 16103./50400, -7645./36288, 31063./362880, 
      -781./34560, 683./172800, -11./24192, 1./30240, -1./725760, 1./39916800}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, -1, 1, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 11./12, -3./2, 7./12, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, -5./6, 7./4, -7./6, 1./4, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 137./180, -15./8, 119./72, -5./8, 31./360, 0, 0, 0, 0, 0}, 
     {0, 0, -7./10, 29./15, -49./24, 25./24, -31./120, 1./40, 0, 0, 0, 0}, 
     {0, 0, 363./560, -469./240, 6769./2880, -35./24, 713./1440, -7./80, 
      127./20160, 0, 0, 0}, {0, 0, -761./1260, 29531./15120, -623./240, 
      1069./576, -31./40, 91./480, -127./5040, 17./12096, 0, 0}, 
     {0, 0, 7129./12600, -1303./672, 4523./1620, -285./128, 93403./86400, 
      -21./64, 3683./60480, -17./2688, 73./259200, 0}, 
     {0, 0, -671./1260, 16103./8400, -7645./2592, 31063./12096, -24211./17280, 
      4781./9600, -1397./12096, 17./1008, -73./51840, 31./604800}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, -3./2, 3./2, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 7./4, -3, 5./4, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, -15./8, 17./4, -25./8, 3./4, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 29./15, -21./4, 125./24, -9./4, 43./120, 0, 0, 0, 0}, 
     {0, 0, 0, -469./240, 967./160, -175./24, 69./16, -301./240, 23./160, 0, 0, 
      0}, {0, 0, 0, 29531./15120, -267./40, 5345./576, -27./4, 3913./1440, 
      -23./40, 605./12096, 0, 0}, 
     {0, 0, 0, -1303./672, 4523./630, -1425./128, 3013./320, -301./64, 667./480, 
      -605./2688, 311./20160, 0}, 
     {0, 0, 0, 16103./8400, -7645./1008, 155315./12096, -781./64, 205583./28800, 
      -253./96, 605./1008, -311./4032, 2591./604800}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, -2, 2, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 17./6, -5, 13./6, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, -7./2, 25./3, -13./2, 5./3, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 967./240, -35./3, 299./24, -35./6, 81./80, 0, 0, 0}, 
     {0, 0, 0, 0, -89./20, 1069./72, -39./2, 455./36, -81./20, 37./72, 0, 0}, 
     {0, 0, 0, 0, 4523./945, -285./16, 39169./1440, -175./8, 783./80, -37./16, 
      6821./30240, 0}, {0, 0, 0, 0, -7645./1512, 31063./1512, -10153./288, 
      4781./144, -297./16, 37./6, -6821./6048, 265./3024}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, -5./2, 5./2, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 25./6, -15./2, 10./3, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, -35./6, 115./8, -35./3, 25./8, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 1069./144, -45./2, 455./18, -25./2, 331./144, 0, 0}, 
     {0, 0, 0, 0, 0, -285./32, 3013./96, -175./4, 725./24, -331./32, 45./32, 0}, 
     {0, 0, 0, 0, 0, 31063./3024, -3905./96, 4781./72, -1375./24, 331./12, 
      -225./32, 2243./3024}}, {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, -3, 3, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 23./4, -21./2, 19./4, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, -9, 91./4, -19, 21./4, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 3013./240, -315./8, 551./12, -189./8, 1087./240, 0}, 
     {0, 0, 0, 0, 0, 0, -781./48, 4781./80, -1045./12, 63, -1087./48, 259./80}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, -7./2, 7./2, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 91./12, -14, 77./12, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, -105./8, 203./6, -231./8, 49./6, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 4781./240, -385./6, 77, -245./6, 1939./240}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, -4, 4, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 29./3, -18, 25./3, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, -55./3, 48, -125./3, 12}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, -9./2, 9./2, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 12, -45./2, 21./2}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -5, 5}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1}}};

const double rtable13[13][13][13] = {
    {{1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, -1./2, 1./2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 1./3, -1./2, 1./6, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, -1./4, 11./24, -1./4, 1./24, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 1./5, -5./12, 7./24, -1./12, 1./120, 0, 0, 0, 0, 0, 0, 0}, 
     {0, -1./6, 137./360, -5./16, 17./144, -1./48, 1./720, 0, 0, 0, 0, 0, 0}, 
     {0, 1./7, -7./20, 29./90, -7./48, 5./144, -1./240, 1./5040, 0, 0, 0, 0, 0}, 
     {0, -1./8, 363./1120, -469./1440, 967./5760, -7./144, 23./2880, -1./1440, 
      1./40320, 0, 0, 0, 0}, {0, 1./9, -761./2520, 29531./90720, -89./480, 
      1069./17280, -1./80, 13./8640, -1./10080, 1./362880, 0, 0, 0}, 
     {0, -1./10, 7129./25200, -1303./4032, 4523./22680, -19./256, 3013./172800, 
      -1./384, 29./120960, -1./80640, 1./3628800, 0, 0}, 
     {0, 1./11, -671./2520, 16103./50400, -7645./36288, 31063./362880, 
      -781./34560, 683./172800, -11./24192, 1./30240, -1./725760, 1./39916800, 0}, 
     {0, -1./12, 83711./332640, -190553./604800, 341747./1555200, 
      -139381./1451520, 242537./8709120, -1903./345600, 10831./14515200, 
      -11./161280, 1./248832, -1./7257600, 1./479001600}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, -1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 11./12, -3./2, 7./12, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, -5./6, 7./4, -7./6, 1./4, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 137./180, -15./8, 119./72, -5./8, 31./360, 0, 0, 0, 0, 0, 0}, 
     {0, 0, -7./10, 29./15, -49./24, 25./24, -31./120, 1./40, 0, 0, 0, 0, 0}, 
     {0, 0, 363./560, -469./240, 6769./2880, -35./24, 713./1440, -7./80, 
      127./20160, 0, 0, 0, 0}, {0, 0, -761./1260, 29531./15120, -623./240, 
      1069./576, -31./40, 91./480, -127./5040, 17./12096, 0, 0, 0}, 
     {0, 0, 7129./12600, -1303./672, 4523./1620, -285./128, 93403./86400, 
      -21./64, 3683./60480, -17./2688, 73./259200, 0, 0}, 
     {0, 0, -671./1260, 16103./8400, -7645./2592, 31063./12096, -24211./17280, 
      4781./9600, -1397./12096, 17./1008, -73./51840, 31./604800, 0}, 
     {0, 0, 83711./166320, -190553./100800, 2392229./777600, -139381./48384, 
      7518647./4354560, -13321./19200, 1375537./7257600, -187./5376, 511./124416, 
      -341./1209600, 2047./239500800}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, -3./2, 3./2, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 7./4, -3, 5./4, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, -15./8, 17./4, -25./8, 3./4, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 29./15, -21./4, 125./24, -9./4, 43./120, 0, 0, 0, 0, 0}, 
     {0, 0, 0, -469./240, 967./160, -175./24, 69./16, -301./240, 23./160, 0, 0, 
      0, 0}, {0, 0, 0, 29531./15120, -267./40, 5345./576, -27./4, 3913./1440, 
      -23./40, 605./12096, 0, 0, 0}, 
     {0, 0, 0, -1303./672, 4523./630, -1425./128, 3013./320, -301./64, 667./480, 
      -605./2688, 311./20160, 0, 0}, 
     {0, 0, 0, 16103./8400, -7645./1008, 155315./12096, -781./64, 205583./28800, 
      -253./96, 605./1008, -311./4032, 2591./604800, 0}, 
     {0, 0, 0, -190553./100800, 341747./43200, -696905./48384, 242537./16128, 
      -572803./57600, 249113./57600, -6655./5376, 1555./6912, -28501./1209600, 
      437./403200}}, {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, -2, 2, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 17./6, -5, 13./6, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, -7./2, 25./3, -13./2, 5./3, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 967./240, -35./3, 299./24, -35./6, 81./80, 0, 0, 0, 0}, 
     {0, 0, 0, 0, -89./20, 1069./72, -39./2, 455./36, -81./20, 37./72, 0, 0, 0}, 
     {0, 0, 0, 0, 4523./945, -285./16, 39169./1440, -175./8, 783./80, -37./16, 
      6821./30240, 0, 0}, {0, 0, 0, 0, -7645./1512, 31063./1512, -10153./288, 
      4781./144, -297./16, 37./6, -6821./6048, 265./3024, 0}, 
     {0, 0, 0, 0, 341747./64800, -139381./6048, 3152981./72576, -13321./288, 
      97479./3200, -407./32, 34105./10368, -2915./6048, 55591./1814400}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, -5./2, 5./2, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 25./6, -15./2, 10./3, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, -35./6, 115./8, -35./3, 25./8, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 1069./144, -45./2, 455./18, -25./2, 331./144, 0, 0, 0}, 
     {0, 0, 0, 0, 0, -285./32, 3013./96, -175./4, 725./24, -331./32, 45./32, 0, 
      0}, {0, 0, 0, 0, 0, 31063./3024, -3905./96, 4781./72, -1375./24, 331./12, 
      -225./32, 2243./3024, 0}, {0, 0, 0, 0, 0, -139381./12096, 1212685./24192, 
      -13321./144, 54155./576, -3641./64, 2625./128, -24673./6048, 1045./3024}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, -3, 3, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 23./4, -21./2, 19./4, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, -9, 91./4, -19, 21./4, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 3013./240, -315./8, 551./12, -189./8, 1087./240, 0, 0}, 
     {0, 0, 0, 0, 0, 0, -781./48, 4781./80, -1045./12, 63, -1087./48, 259./80, 
      0}, {0, 0, 0, 0, 0, 0, 242537./12096, -13321./160, 205789./1440, 
      -2079./16, 38045./576, -2849./160, 30083./15120}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, -7./2, 7./2, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 91./12, -14, 77./12, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, -105./8, 203./6, -231./8, 49./6, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 4781./240, -385./6, 77, -245./6, 1939./240, 0}, 
     {0, 0, 0, 0, 0, 0, 0, -13321./480, 75817./720, -2541./16, 8575./72, 
      -21329./480, 4753./720}}, {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, -4, 4, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 29./3, -18, 25./3, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, -55./3, 48, -125./3, 12, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 10831./360, -99, 4375./36, -66, 4819./360}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, -9./2, 9./2, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 12, -45./2, 21./2, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, -99./4, 525./8, -231./4, 135./8}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -5, 5, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 175./12, -55./2, 155./12}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -11./2, 11./2}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1}}};

const double rtable14[14][14][14] = {
    {{1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, -1./2, 1./2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 1./3, -1./2, 1./6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, -1./4, 11./24, -1./4, 1./24, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 1./5, -5./12, 7./24, -1./12, 1./120, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, -1./6, 137./360, -5./16, 17./144, -1./48, 1./720, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 1./7, -7./20, 29./90, -7./48, 5./144, -1./240, 1./5040, 0, 0, 0, 0, 0, 0}, 
     {0, -1./8, 363./1120, -469./1440, 967./5760, -7./144, 23./2880, -1./1440, 
      1./40320, 0, 0, 0, 0, 0}, 
     {0, 1./9, -761./2520, 29531./90720, -89./480, 1069./17280, -1./80, 13./8640, 
      -1./10080, 1./362880, 0, 0, 0, 0}, 
     {0, -1./10, 7129./25200, -1303./4032, 4523./22680, -19./256, 3013./172800, 
      -1./384, 29./120960, -1./80640, 1./3628800, 0, 0, 0}, 
     {0, 1./11, -671./2520, 16103./50400, -7645./36288, 31063./362880, 
      -781./34560, 683./172800, -11./24192, 1./30240, -1./725760, 1./39916800, 0, 
      0}, {0, -1./12, 83711./332640, -190553./604800, 341747./1555200, 
      -139381./1451520, 242537./8709120, -1903./345600, 10831./14515200, 
      -11./161280, 1./248832, -1./7257600, 1./479001600, 0}, 
     {0, 1./13, -6617./27720, 128977./415800, -412009./1814400, 
      1148963./10886400, -9607./290304, 314617./43545600, -299./268800, 
      1747./14515200, -13./1451520, 19./43545600, -1./79833600, 1./6227020800}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, -1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 11./12, -3./2, 7./12, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, -5./6, 7./4, -7./6, 1./4, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 137./180, -15./8, 119./72, -5./8, 31./360, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, -7./10, 29./15, -49./24, 25./24, -31./120, 1./40, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 363./560, -469./240, 6769./2880, -35./24, 713./1440, -7./80, 
      127./20160, 0, 0, 0, 0, 0}, 
     {0, 0, -761./1260, 29531./15120, -623./240, 1069./576, -31./40, 91./480, 
      -127./5040, 17./12096, 0, 0, 0, 0}, 
     {0, 0, 7129./12600, -1303./672, 4523./1620, -285./128, 93403./86400, 
      -21./64, 3683./60480, -17./2688, 73./259200, 0, 0, 0}, 
     {0, 0, -671./1260, 16103./8400, -7645./2592, 31063./12096, -24211./17280, 
      4781./9600, -1397./12096, 17./1008, -73./51840, 31./604800, 0, 0}, 
     {0, 0, 83711./166320, -190553./100800, 2392229./777600, -139381./48384, 
      7518647./4354560, -13321./19200, 1375537./7257600, -187./5376, 
      511./124416, -341./1209600, 2047./239500800, 0}, 
     {0, 0, -6617./13860, 128977./69300, -412009./129600, 1148963./362880, 
      -297817./145152, 314617./345600, -37973./134400, 29699./483840, 
      -949./103680, 6479./7257600, -2047./39916800, 1./760320}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, -3./2, 3./2, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 7./4, -3, 5./4, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, -15./8, 17./4, -25./8, 3./4, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 29./15, -21./4, 125./24, -9./4, 43./120, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, -469./240, 967./160, -175./24, 69./16, -301./240, 23./160, 0, 0, 
      0, 0, 0}, {0, 0, 0, 29531./15120, -267./40, 5345./576, -27./4, 3913./1440, 
      -23./40, 605./12096, 0, 0, 0, 0}, 
     {0, 0, 0, -1303./672, 4523./630, -1425./128, 3013./320, -301./64, 667./480, 
      -605./2688, 311./20160, 0, 0, 0}, 
     {0, 0, 0, 16103./8400, -7645./1008, 155315./12096, -781./64, 205583./28800, 
      -253./96, 605./1008, -311./4032, 2591./604800, 0, 0}, 
     {0, 0, 0, -190553./100800, 341747./43200, -696905./48384, 242537./16128, 
      -572803./57600, 249113./57600, -6655./5376, 1555./6912, -28501./1209600, 
      437./403200, 0}, {0, 0, 0, 128977./69300, -412009./50400, 1148963./72576, 
      -48035./2688, 13528531./1036800, -20631./3200, 211387./96768, -4043./8064, 
      541519./7257600, -437./67200, 115./456192}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, -2, 2, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 17./6, -5, 13./6, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, -7./2, 25./3, -13./2, 5./3, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 967./240, -35./3, 299./24, -35./6, 81./80, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, -89./20, 1069./72, -39./2, 455./36, -81./20, 37./72, 0, 0, 0, 
      0}, {0, 0, 0, 0, 4523./945, -285./16, 39169./1440, -175./8, 783./80, 
      -37./16, 6821./30240, 0, 0, 0}, 
     {0, 0, 0, 0, -7645./1512, 31063./1512, -10153./288, 4781./144, -297./16, 
      37./6, -6821./6048, 265./3024, 0, 0}, 
     {0, 0, 0, 0, 341747./64800, -139381./6048, 3152981./72576, -13321./288, 
      97479./3200, -407./32, 34105./10368, -2915./6048, 55591./1814400, 0}, 
     {0, 0, 0, 0, -412009./75600, 1148963./45360, -624455./12096, 314617./5184, 
      -72657./1600, 64639./2880, -88673./12096, 55385./36288, -55591./302400, 
      253./25920}}, {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, -5./2, 5./2, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 25./6, -15./2, 10./3, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, -35./6, 115./8, -35./3, 25./8, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 1069./144, -45./2, 455./18, -25./2, 331./144, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, -285./32, 3013./96, -175./4, 725./24, -331./32, 45./32, 0, 
      0, 0}, {0, 0, 0, 0, 0, 31063./3024, -3905./96, 4781./72, -1375./24, 
      331./12, -225./32, 2243./3024, 0, 0}, 
     {0, 0, 0, 0, 0, -139381./12096, 1212685./24192, -13321./144, 54155./576, 
      -3641./64, 2625./128, -24673./6048, 1045./3024, 0}, 
     {0, 0, 0, 0, 0, 1148963./90720, -240175./4032, 314617./2592, -4485./32, 
      578257./5760, -2925./64, 468787./36288, -1045./504, 7501./51840}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, -3, 3, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 23./4, -21./2, 19./4, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, -9, 91./4, -19, 21./4, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 3013./240, -315./8, 551./12, -189./8, 1087./240, 0, 0, 
      0}, {0, 0, 0, 0, 0, 0, -781./48, 4781./80, -1045./12, 63, -1087./48, 
      259./80, 0, 0}, {0, 0, 0, 0, 0, 0, 242537./12096, -13321./160, 
      205789./1440, -2079./16, 38045./576, -2849./160, 30083./15120, 0}, 
     {0, 0, 0, 0, 0, 0, -48035./2016, 314617./2880, -17043./80, 36687./160, 
      -14131./96, 54131./960, -30083./2520, 97./90}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, -7./2, 7./2, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 91./12, -14, 77./12, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, -105./8, 203./6, -231./8, 49./6, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 4781./240, -385./6, 77, -245./6, 1939./240, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, -13321./480, 75817./720, -2541./16, 8575./72, 
      -21329./480, 4753./720, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 314617./8640, -6279./40, 134519./480, -3185./12, 
      405251./2880, -4753./120, 1249./270}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, -4, 4, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 29./3, -18, 25./3, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, -55./3, 48, -125./3, 12, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 10831./360, -99, 4375./36, -66, 4819./360, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, -897./20, 1747./10, -1625./6, 209, -4819./60, 
      123./10}}, {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, -9./2, 9./2, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 12, -45./2, 21./2, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, -99./4, 525./8, -231./4, 135./8, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 1747./40, -585./4, 1463./8, -405./4, 419./20}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -5, 5, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 175./12, -55./2, 155./12, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -65./2, 1045./12, -155./2, 275./12}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -11./2, 11./2, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 209./12, -33, 187./12}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -6, 6}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1}}};

const double rtable15[15][15][15] = {
    {{1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, -1./2, 1./2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 1./3, -1./2, 1./6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, -1./4, 11./24, -1./4, 1./24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 1./5, -5./12, 7./24, -1./12, 1./120, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, -1./6, 137./360, -5./16, 17./144, -1./48, 1./720, 0, 0, 0, 0, 0, 0, 0, 
      0}, {0, 1./7, -7./20, 29./90, -7./48, 5./144, -1./240, 1./5040, 0, 0, 0, 0, 
      0, 0, 0}, {0, -1./8, 363./1120, -469./1440, 967./5760, -7./144, 23./2880, 
      -1./1440, 1./40320, 0, 0, 0, 0, 0, 0}, 
     {0, 1./9, -761./2520, 29531./90720, -89./480, 1069./17280, -1./80, 13./8640, 
      -1./10080, 1./362880, 0, 0, 0, 0, 0}, 
     {0, -1./10, 7129./25200, -1303./4032, 4523./22680, -19./256, 3013./172800, 
      -1./384, 29./120960, -1./80640, 1./3628800, 0, 0, 0, 0}, 
     {0, 1./11, -671./2520, 16103./50400, -7645./36288, 31063./362880, 
      -781./34560, 683./172800, -11./24192, 1./30240, -1./725760, 1./39916800, 0, 
      0, 0}, {0, -1./12, 83711./332640, -190553./604800, 341747./1555200, 
      -139381./1451520, 242537./8709120, -1903./345600, 10831./14515200, 
      -11./161280, 1./248832, -1./7257600, 1./479001600, 0, 0}, 
     {0, 1./13, -6617./27720, 128977./415800, -412009./1814400, 
      1148963./10886400, -9607./290304, 314617./43545600, -299./268800, 
      1747./14515200, -13./1451520, 19./43545600, -1./79833600, 1./6227020800, 0}\
, {0, -1./14, 1145993./5045040, -9061./29700, 9301169./39916800, 
      -355277./3110400, 1666393./43545600, -112879./12441600, 944311./609638400, 
      -793./4147200, 491./29030400, -13./12441600, 41./958003200, -1./958003200, 
      1./87178291200}}, {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, -1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 11./12, -3./2, 7./12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, -5./6, 7./4, -7./6, 1./4, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 137./180, -15./8, 119./72, -5./8, 31./360, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, -7./10, 29./15, -49./24, 25./24, -31./120, 1./40, 0, 0, 0, 0, 0, 0, 
      0}, {0, 0, 363./560, -469./240, 6769./2880, -35./24, 713./1440, -7./80, 
      127./20160, 0, 0, 0, 0, 0, 0}, 
     {0, 0, -761./1260, 29531./15120, -623./240, 1069./576, -31./40, 91./480, 
      -127./5040, 17./12096, 0, 0, 0, 0, 0}, 
     {0, 0, 7129./12600, -1303./672, 4523./1620, -285./128, 93403./86400, 
      -21./64, 3683./60480, -17./2688, 73./259200, 0, 0, 0, 0}, 
     {0, 0, -671./1260, 16103./8400, -7645./2592, 31063./12096, -24211./17280, 
      4781./9600, -1397./12096, 17./1008, -73./51840, 31./604800, 0, 0, 0}, 
     {0, 0, 83711./166320, -190553./100800, 2392229./777600, -139381./48384, 
      7518647./4354560, -13321./19200, 1375537./7257600, -187./5376, 
      511./124416, -341./1209600, 2047./239500800, 0, 0}, 
     {0, 0, -6617./13860, 128977./69300, -412009./129600, 1148963./362880, 
      -297817./145152, 314617./345600, -37973./134400, 29699./483840, 
      -949./103680, 6479./7257600, -2047./39916800, 1./760320, 0}, 
     {0, 0, 1145993./2522520, -9061./4950, 9301169./2851200, -355277./103680, 
      51658183./21772800, -790153./691200, 119927497./304819200, -13481./138240, 
      35843./2073600, -4433./2073600, 83927./479001600, -13./1520640, 
      8191./43589145600}}, {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, -3./2, 3./2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 7./4, -3, 5./4, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, -15./8, 17./4, -25./8, 3./4, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 29./15, -21./4, 125./24, -9./4, 43./120, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, -469./240, 967./160, -175./24, 69./16, -301./240, 23./160, 0, 0, 
      0, 0, 0, 0}, {0, 0, 0, 29531./15120, -267./40, 5345./576, -27./4, 
      3913./1440, -23./40, 605./12096, 0, 0, 0, 0, 0}, 
     {0, 0, 0, -1303./672, 4523./630, -1425./128, 3013./320, -301./64, 667./480, 
      -605./2688, 311./20160, 0, 0, 0, 0}, 
     {0, 0, 0, 16103./8400, -7645./1008, 155315./12096, -781./64, 205583./28800, 
      -253./96, 605./1008, -311./4032, 2591./604800, 0, 0, 0}, 
     {0, 0, 0, -190553./100800, 341747./43200, -696905./48384, 242537./16128, 
      -572803./57600, 249113./57600, -6655./5376, 1555./6912, -28501./1209600, 
      437./403200, 0, 0}, {0, 0, 0, 128977./69300, -412009./50400, 
      1148963./72576, -48035./2688, 13528531./1036800, -20631./3200, 
      211387./96768, -4043./8064, 541519./7257600, -437./67200, 115./456192, 0}, 
     {0, 0, 0, -9061./4950, 9301169./1108800, -355277./20736, 1666393./80640, 
      -33976579./2073600, 21719153./2419200, -95953./27648, 152701./161280, 
      -370513./2073600, 17917./806400, -1495./912384, 289./5322240}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, -2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 17./6, -5, 13./6, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, -7./2, 25./3, -13./2, 5./3, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 967./240, -35./3, 299./24, -35./6, 81./80, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, -89./20, 1069./72, -39./2, 455./36, -81./20, 37./72, 0, 0, 0, 
      0, 0}, {0, 0, 0, 0, 4523./945, -285./16, 39169./1440, -175./8, 783./80, 
      -37./16, 6821./30240, 0, 0, 0, 0}, 
     {0, 0, 0, 0, -7645./1512, 31063./1512, -10153./288, 4781./144, -297./16, 
      37./6, -6821./6048, 265./3024, 0, 0, 0}, 
     {0, 0, 0, 0, 341747./64800, -139381./6048, 3152981./72576, -13321./288, 
      97479./3200, -407./32, 34105./10368, -2915./6048, 55591./1814400, 0, 0}, 
     {0, 0, 0, 0, -412009./75600, 1148963./45360, -624455./12096, 314617./5184, 
      -72657./1600, 64639./2880, -88673./12096, 55385./36288, -55591./302400, 
      253./25920, 0}, {0, 0, 0, 0, 9301169./1663200, -355277./12960, 
      21663109./362880, -790153./10368, 2832933./44800, -205387./5760, 
      3349111./241920, -37895./10368, 2279231./3628800, -3289./51840, 
      7613./2661120}}, {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, -5./2, 5./2, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 25./6, -15./2, 10./3, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, -35./6, 115./8, -35./3, 25./8, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 1069./144, -45./2, 455./18, -25./2, 331./144, 0, 0, 0, 0, 
      0}, {0, 0, 0, 0, 0, -285./32, 3013./96, -175./4, 725./24, -331./32, 45./32, 
      0, 0, 0, 0}, {0, 0, 0, 0, 0, 31063./3024, -3905./96, 4781./72, -1375./24, 
      331./12, -225./32, 2243./3024, 0, 0, 0}, 
     {0, 0, 0, 0, 0, -139381./12096, 1212685./24192, -13321./144, 54155./576, 
      -3641./64, 2625./128, -24673./6048, 1045./3024, 0, 0}, 
     {0, 0, 0, 0, 0, 1148963./90720, -240175./4032, 314617./2592, -4485./32, 
      578257./5760, -2925./64, 468787./36288, -1045./504, 7501./51840, 0}, 
     {0, 0, 0, 0, 0, -355277./25920, 1666393./24192, -790153./5184, 
      4721555./24192, -1837381./11520, 22095./256, -320749./10368, 42845./6048, 
      -97513./103680, 2669./48384}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, -3, 3, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 23./4, -21./2, 19./4, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, -9, 91./4, -19, 21./4, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 3013./240, -315./8, 551./12, -189./8, 1087./240, 0, 0, 
      0, 0}, {0, 0, 0, 0, 0, 0, -781./48, 4781./80, -1045./12, 63, -1087./48, 
      259./80, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 242537./12096, -13321./160, 
      205789./1440, -2079./16, 38045./576, -2849./160, 30083./15120, 0, 0}, 
     {0, 0, 0, 0, 0, 0, -48035./2016, 314617./2880, -17043./80, 36687./160, 
      -14131./96, 54131./960, -30083./2520, 97./90, 0}, 
     {0, 0, 0, 0, 0, 0, 1666393./60480, -790153./5760, 17941909./60480, 
      -116571./320, 533717./1920, -259259./1920, 1233403./30240, -1261./180, 
      63373./120960}}, {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, -7./2, 7./2, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 91./12, -14, 77./12, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, -105./8, 203./6, -231./8, 49./6, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 4781./240, -385./6, 77, -245./6, 1939./240, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, -13321./480, 75817./720, -2541./16, 8575./72, 
      -21329./480, 4753./720, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 314617./8640, -6279./40, 134519./480, -3185./12, 
      405251./2880, -4753./120, 1249./270, 0}, 
     {0, 0, 0, 0, 0, 0, 0, -790153./17280, 944311./4320, -427427./960, 
      24059./48, -1940939./5760, 194873./1440, -16237./540, 77./27}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, -4, 4, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 29./3, -18, 25./3, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, -55./3, 48, -125./3, 12, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 10831./360, -99, 4375./36, -66, 4819./360, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, -897./20, 1747./10, -1625./6, 209, -4819./60, 
      123./10, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 944311./15120, -5551./20, 12275./24, 
      -1001./2, 197579./720, -1599./20, 1828./189}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, -9./2, 9./2, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 12, -45./2, 21./2, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, -99./4, 525./8, -231./4, 135./8, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 1747./40, -585./4, 1463./8, -405./4, 419./20, 
      0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, -5551./80, 4419./16, -7007./16, 5535./16, 
      -5447./40, 171./8}}, {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -5, 5, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 175./12, -55./2, 155./12, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -65./2, 1045./12, -155./2, 275./12, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 491./8, -5005./24, 6355./24, -3575./24, 
      94./3}}, {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -11./2, 11./2, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 209./12, -33, 187./12, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1001./24, 451./4, -2431./24, 121./4}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -6, 6, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 41./2, -39, 37./2}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -13./2, 13./2}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1}}};

const double rtable16[16][16][16] = {
    {{1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, -1./2, 1./2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 1./3, -1./2, 1./6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, -1./4, 11./24, -1./4, 1./24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 1./5, -5./12, 7./24, -1./12, 1./120, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, -1./6, 137./360, -5./16, 17./144, -1./48, 1./720, 0, 0, 0, 0, 0, 0, 0, 
      0, 0}, {0, 1./7, -7./20, 29./90, -7./48, 5./144, -1./240, 1./5040, 0, 0, 0, 
      0, 0, 0, 0, 0}, {0, -1./8, 363./1120, -469./1440, 967./5760, -7./144, 
      23./2880, -1./1440, 1./40320, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 1./9, -761./2520, 29531./90720, -89./480, 1069./17280, -1./80, 13./8640, 
      -1./10080, 1./362880, 0, 0, 0, 0, 0, 0}, 
     {0, -1./10, 7129./25200, -1303./4032, 4523./22680, -19./256, 3013./172800, 
      -1./384, 29./120960, -1./80640, 1./3628800, 0, 0, 0, 0, 0}, 
     {0, 1./11, -671./2520, 16103./50400, -7645./36288, 31063./362880, 
      -781./34560, 683./172800, -11./24192, 1./30240, -1./725760, 1./39916800, 0, 
      0, 0, 0}, {0, -1./12, 83711./332640, -190553./604800, 341747./1555200, 
      -139381./1451520, 242537./8709120, -1903./345600, 10831./14515200, 
      -11./161280, 1./248832, -1./7257600, 1./479001600, 0, 0, 0}, 
     {0, 1./13, -6617./27720, 128977./415800, -412009./1814400, 
      1148963./10886400, -9607./290304, 314617./43545600, -299./268800, 
      1747./14515200, -13./1451520, 19./43545600, -1./79833600, 1./6227020800, 
      0, 0}, {0, -1./14, 1145993./5045040, -9061./29700, 9301169./39916800, 
      -355277./3110400, 1666393./43545600, -112879./12441600, 
      944311./609638400, -793./4147200, 491./29030400, -13./12441600, 
      41./958003200, -1./958003200, 1./87178291200, 0}, 
     {0, 1./15, -1171733./5405400, 30946717./103194000, -406841./1710720, 
      21939781./179625600, -22463./518400, 899683./81648000, -35717./17418240, 
      515261./1828915200, -71./2488320, 2747./1306368000, -1./9123840, 
      1./261273600, -1./12454041600, 1./1307674368000}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, -1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 11./12, -3./2, 7./12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, -5./6, 7./4, -7./6, 1./4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 137./180, -15./8, 119./72, -5./8, 31./360, 0, 0, 0, 0, 0, 0, 0, 0, 
      0}, {0, 0, -7./10, 29./15, -49./24, 25./24, -31./120, 1./40, 0, 0, 0, 0, 0, 
      0, 0, 0}, {0, 0, 363./560, -469./240, 6769./2880, -35./24, 713./1440, 
      -7./80, 127./20160, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, -761./1260, 29531./15120, -623./240, 1069./576, -31./40, 91./480, 
      -127./5040, 17./12096, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 7129./12600, -1303./672, 4523./1620, -285./128, 93403./86400, 
      -21./64, 3683./60480, -17./2688, 73./259200, 0, 0, 0, 0, 0}, 
     {0, 0, -671./1260, 16103./8400, -7645./2592, 31063./12096, -24211./17280, 
      4781./9600, -1397./12096, 17./1008, -73./51840, 31./604800, 0, 0, 0, 0}, 
     {0, 0, 83711./166320, -190553./100800, 2392229./777600, -139381./48384, 
      7518647./4354560, -13321./19200, 1375537./7257600, -187./5376, 
      511./124416, -341./1209600, 2047./239500800, 0, 0, 0}, 
     {0, 0, -6617./13860, 128977./69300, -412009./129600, 1148963./362880, 
      -297817./145152, 314617./345600, -37973./134400, 29699./483840, 
      -949./103680, 6479./7257600, -2047./39916800, 1./760320, 0, 0}, 
     {0, 0, 1145993./2522520, -9061./4950, 9301169./2851200, -355277./103680, 
      51658183./21772800, -790153./691200, 119927497./304819200, 
      -13481./138240, 35843./2073600, -4433./2073600, 83927./479001600, 
      -13./1520640, 8191./43589145600, 0}, 
     {0, 0, -1171733./2702700, 30946717./17199000, -2847887./855360, 
      21939781./5987520, -696353./259200, 899683./648000, -4536059./8709120, 
      8759437./60963840, -36281./1244160, 936727./217728000, -2047./4561920, 
      13./414720, -8191./6227020800, 5461./217945728000}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, -3./2, 3./2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 7./4, -3, 5./4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, -15./8, 17./4, -25./8, 3./4, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 29./15, -21./4, 125./24, -9./4, 43./120, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, -469./240, 967./160, -175./24, 69./16, -301./240, 23./160, 0, 0, 
      0, 0, 0, 0, 0}, {0, 0, 0, 29531./15120, -267./40, 5345./576, -27./4, 
      3913./1440, -23./40, 605./12096, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, -1303./672, 4523./630, -1425./128, 3013./320, -301./64, 667./480, 
      -605./2688, 311./20160, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 16103./8400, -7645./1008, 155315./12096, -781./64, 205583./28800, 
      -253./96, 605./1008, -311./4032, 2591./604800, 0, 0, 0, 0}, 
     {0, 0, 0, -190553./100800, 341747./43200, -696905./48384, 242537./16128, 
      -572803./57600, 249113./57600, -6655./5376, 1555./6912, -28501./1209600, 
      437./403200, 0, 0, 0}, {0, 0, 0, 128977./69300, -412009./50400, 
      1148963./72576, -48035./2688, 13528531./1036800, -20631./3200, 
      211387./96768, -4043./8064, 541519./7257600, -437./67200, 115./456192, 0, 
      0}, {0, 0, 0, -9061./4950, 9301169./1108800, -355277./20736, 
      1666393./80640, -33976579./2073600, 21719153./2419200, -95953./27648, 
      152701./161280, -370513./2073600, 17917./806400, -1495./912384, 
      289./5322240, 0}, {0, 0, 0, 30946717./17199000, -406841./47520, 
      21939781./1197504, -22463./960, 38686369./1944000, -821491./69120, 
      62346581./12192768, -22081./13824, 78292247./217728000, -437./7680, 
      1495./248832, -289./760320, 2375101./217945728000}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, -2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 17./6, -5, 13./6, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, -7./2, 25./3, -13./2, 5./3, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 967./240, -35./3, 299./24, -35./6, 81./80, 0, 0, 0, 0, 0, 0, 
      0}, {0, 0, 0, 0, -89./20, 1069./72, -39./2, 455./36, -81./20, 37./72, 0, 0, 
      0, 0, 0, 0}, {0, 0, 0, 0, 4523./945, -285./16, 39169./1440, -175./8, 
      783./80, -37./16, 6821./30240, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, -7645./1512, 31063./1512, -10153./288, 4781./144, -297./16, 
      37./6, -6821./6048, 265./3024, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 341747./64800, -139381./6048, 3152981./72576, -13321./288, 
      97479./3200, -407./32, 34105./10368, -2915./6048, 55591./1814400, 0, 0, 0}, 
     {0, 0, 0, 0, -412009./75600, 1148963./45360, -624455./12096, 314617./5184, 
      -72657./1600, 64639./2880, -88673./12096, 55385./36288, -55591./302400, 
      253./25920, 0, 0}, {0, 0, 0, 0, 9301169./1663200, -355277./12960, 
      21663109./362880, -790153./10368, 2832933./44800, -205387./5760, 
      3349111./241920, -37895./10368, 2279231./3628800, -3289./51840, 
      7613./2661120, 0}, {0, 0, 0, 0, -406841./71280, 21939781./748440, 
      -292019./4320, 899683./9720, -107151./1280, 19064657./362880, 
      -484291./20736, 1601501./217728, -55591./34560, 36179./155520, 
      -7613./380160, 3103./3991680}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, -5./2, 5./2, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 25./6, -15./2, 10./3, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, -35./6, 115./8, -35./3, 25./8, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 1069./144, -45./2, 455./18, -25./2, 331./144, 0, 0, 0, 0, 
      0, 0}, {0, 0, 0, 0, 0, -285./32, 3013./96, -175./4, 725./24, -331./32, 
      45./32, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 31063./3024, -3905./96, 4781./72, 
      -1375./24, 331./12, -225./32, 2243./3024, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, -139381./12096, 1212685./24192, -13321./144, 54155./576, 
      -3641./64, 2625./128, -24673./6048, 1045./3024, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 1148963./90720, -240175./4032, 314617./2592, -4485./32, 
      578257./5760, -2925./64, 468787./36288, -1045./504, 7501./51840, 0, 0}, 
     {0, 0, 0, 0, 0, -355277./25920, 1666393./24192, -790153./5184, 
      4721555./24192, -1837381./11520, 22095./256, -320749./10368, 42845./6048, 
      -97513./103680, 2669./48384, 0}, 
     {0, 0, 0, 0, 0, 21939781./1496880, -22463./288, 899683./4860, 
      -892925./3456, 170551391./725760, -37275./256, 67776731./1088640, 
      -5225./288, 1072643./311040, -2669./6912, 19301./997920}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, -3, 3, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 23./4, -21./2, 19./4, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, -9, 91./4, -19, 21./4, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 3013./240, -315./8, 551./12, -189./8, 1087./240, 0, 0, 
      0, 0, 0}, {0, 0, 0, 0, 0, 0, -781./48, 4781./80, -1045./12, 63, 
      -1087./48, 259./80, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 242537./12096, -13321./160, 205789./1440, -2079./16, 
      38045./576, -2849./160, 30083./15120, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, -48035./2016, 314617./2880, -17043./80, 36687./160, 
      -14131./96, 54131./960, -30083./2520, 97./90, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 1666393./60480, -790153./5760, 17941909./60480, 
      -116571./320, 533717./1920, -259259./1920, 1233403./30240, -1261./180, 
      63373./120960, 0}, {0, 0, 0, 0, 0, 0, -22463./720, 899683./5400, 
      -678623./1728, 515261./960, -540239./1152, 7826203./28800, -30083./288, 
      13871./540, -63373./17280, 6671./28800}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, -7./2, 7./2, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 91./12, -14, 77./12, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, -105./8, 203./6, -231./8, 49./6, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 4781./240, -385./6, 77, -245./6, 1939./240, 0, 0, 0, 
      0}, {0, 0, 0, 0, 0, 0, 0, -13321./480, 75817./720, -2541./16, 8575./72, 
      -21329./480, 4753./720, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 314617./8640, -6279./40, 134519./480, -3185./12, 
      405251./2880, -4753./120, 1249./270, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, -790153./17280, 944311./4320, -427427./960, 
      24059./48, -1940939./5760, 194873./1440, -16237./540, 77./27, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 899683./16200, -250019./864, 5667871./8640, 
      -121765./144, 58590763./86400, -33271./96, 178607./1620, -539./27, 
      136111./86400}}, {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, -4, 4, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 29./3, -18, 25./3, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, -55./3, 48, -125./3, 12, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 10831./360, -99, 4375./36, -66, 4819./360, 0, 0, 
      0}, {0, 0, 0, 0, 0, 0, 0, 0, -897./20, 1747./10, -1625./6, 209, 
      -4819./60, 123./10, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 944311./15120, -5551./20, 12275./24, -1001./2, 
      197579./720, -1599./20, 1828./189, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, -35717./432, 515261./1260, -62125./72, 30217./30, 
      -33733./48, 5863./20, -1828./27, 2104./315}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, -9./2, 9./2, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 12, -45./2, 21./2, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, -99./4, 525./8, -231./4, 135./8, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 1747./40, -585./4, 1463./8, -405./4, 419./20, 
      0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, -5551./80, 4419./16, -7007./16, 
      5535./16, -5447./40, 171./8, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 515261./5040, -7455./16, 211519./240, 
      -14175./16, 59917./120, -1197./8, 46943./2520}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -5, 5, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 175./12, -55./2, 155./12, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -65./2, 1045./12, -155./2, 275./12, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 491./8, -5005./24, 6355./24, -3575./24, 
      94./3, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -2485./24, 30217./72, -5425./8, 
      39325./72, -658./3, 1265./36}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -11./2, 11./2, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 209./12, -33, 187./12, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1001./24, 451./4, -2431./24, 121./4, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 30217./360, -1155./4, 26741./72, -847./4, 
      8129./180}}, {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -6, 6, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 41./2, -39, 37./2, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -105./2, 143, -259./2, 39}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -13./2, 13./2, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 143./6, -91./2, 65./3}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -7, 7}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1}}};

const double rtable17[17][17][17] = {
    {{1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, -1./2, 1./2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 1./3, -1./2, 1./6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, -1./4, 11./24, -1./4, 1./24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 1./5, -5./12, 7./24, -1./12, 1./120, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, -1./6, 137./360, -5./16, 17./144, -1./48, 1./720, 0, 0, 0, 0, 0, 0, 0, 
      0, 0, 0}, {0, 1./7, -7./20, 29./90, -7./48, 5./144, -1./240, 1./5040, 0, 0, 
      0, 0, 0, 0, 0, 0, 0}, {0, -1./8, 363./1120, -469./1440, 967./5760, 
      -7./144, 23./2880, -1./1440, 1./40320, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 1./9, -761./2520, 29531./90720, -89./480, 1069./17280, -1./80, 13./8640, 
      -1./10080, 1./362880, 0, 0, 0, 0, 0, 0, 0}, 
     {0, -1./10, 7129./25200, -1303./4032, 4523./22680, -19./256, 3013./172800, 
      -1./384, 29./120960, -1./80640, 1./3628800, 0, 0, 0, 0, 0, 0}, 
     {0, 1./11, -671./2520, 16103./50400, -7645./36288, 31063./362880, 
      -781./34560, 683./172800, -11./24192, 1./30240, -1./725760, 1./39916800, 0, 
      0, 0, 0, 0}, {0, -1./12, 83711./332640, -190553./604800, 341747./1555200, 
      -139381./1451520, 242537./8709120, -1903./345600, 10831./14515200, 
      -11./161280, 1./248832, -1./7257600, 1./479001600, 0, 0, 0, 0}, 
     {0, 1./13, -6617./27720, 128977./415800, -412009./1814400, 
      1148963./10886400, -9607./290304, 314617./43545600, -299./268800, 
      1747./14515200, -13./1451520, 19./43545600, -1./79833600, 1./6227020800, 
      0, 0, 0}, {0, -1./14, 1145993./5045040, -9061./29700, 9301169./39916800, 
      -355277./3110400, 1666393./43545600, -112879./12441600, 
      944311./609638400, -793./4147200, 491./29030400, -13./12441600, 
      41./958003200, -1./958003200, 1./87178291200, 0, 0}, 
     {0, 1./15, -1171733./5405400, 30946717./103194000, -406841./1710720, 
      21939781./179625600, -22463./518400, 899683./81648000, -35717./17418240, 
      515261./1828915200, -71./2488320, 2747./1306368000, -1./9123840, 
      1./261273600, -1./12454041600, 1./1307674368000, 0}, 
     {0, -1./16, 1195757./5765760, -13215487./44844800, 
      35118025721./145297152000, -2065639./15966720, 277382447./5748019200, 
      -2271089./174182400, 54576553./20901888000, -4783./12192768, 
      324509./7315660800, -109./29030400, 26921./114960384000, -1./95800320, 
      47./149448499200, -1./174356582400, 1./20922789888000}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, -1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 11./12, -3./2, 7./12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, -5./6, 7./4, -7./6, 1./4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 137./180, -15./8, 119./72, -5./8, 31./360, 0, 0, 0, 0, 0, 0, 0, 0, 
      0, 0}, {0, 0, -7./10, 29./15, -49./24, 25./24, -31./120, 1./40, 0, 0, 0, 0, 
      0, 0, 0, 0, 0}, {0, 0, 363./560, -469./240, 6769./2880, -35./24, 
      713./1440, -7./80, 127./20160, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, -761./1260, 29531./15120, -623./240, 1069./576, -31./40, 91./480, 
      -127./5040, 17./12096, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 7129./12600, -1303./672, 4523./1620, -285./128, 93403./86400, 
      -21./64, 3683./60480, -17./2688, 73./259200, 0, 0, 0, 0, 0, 0}, 
     {0, 0, -671./1260, 16103./8400, -7645./2592, 31063./12096, -24211./17280, 
      4781./9600, -1397./12096, 17./1008, -73./51840, 31./604800, 0, 0, 0, 0, 0}, 
     {0, 0, 83711./166320, -190553./100800, 2392229./777600, -139381./48384, 
      7518647./4354560, -13321./19200, 1375537./7257600, -187./5376, 
      511./124416, -341./1209600, 2047./239500800, 0, 0, 0, 0}, 
     {0, 0, -6617./13860, 128977./69300, -412009./129600, 1148963./362880, 
      -297817./145152, 314617./345600, -37973./134400, 29699./483840, 
      -949./103680, 6479./7257600, -2047./39916800, 1./760320, 0, 0, 0}, 
     {0, 0, 1145993./2522520, -9061./4950, 9301169./2851200, -355277./103680, 
      51658183./21772800, -790153./691200, 119927497./304819200, 
      -13481./138240, 35843./2073600, -4433./2073600, 83927./479001600, 
      -13./1520640, 8191./43589145600, 0, 0}, 
     {0, 0, -1171733./2702700, 30946717./17199000, -2847887./855360, 
      21939781./5987520, -696353./259200, 899683./648000, -4536059./8709120, 
      8759437./60963840, -36281./1244160, 936727./217728000, -2047./4561920, 
      13./414720, -8191./6227020800, 5461./217945728000, 0}, 
     {0, 0, 1195757./2882880, -39646461./22422400, 35118025721./10378368000, 
      -2065639./532224, 8598855857./2874009600., -2271089./1382400., 
      6931222231./10450944000, -406555./2032128, 23689157./522547200, 
      -37169./4838400, 55107287./57480192000, -13./152064, 384977./74724249600, 
      -5461./29059430400, 4681./1494484992000}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, -3./2, 3./2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 7./4, -3, 5./4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, -15./8, 17./4, -25./8, 3./4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 29./15, -21./4, 125./24, -9./4, 43./120, 0, 0, 0, 0, 0, 0, 0, 0, 
      0}, {0, 0, 0, -469./240, 967./160, -175./24, 69./16, -301./240, 23./160, 0, 
      0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 29531./15120, -267./40, 5345./576, 
      -27./4, 3913./1440, -23./40, 605./12096, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, -1303./672, 4523./630, -1425./128, 3013./320, -301./64, 667./480, 
      -605./2688, 311./20160, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 16103./8400, -7645./1008, 155315./12096, -781./64, 205583./28800, 
      -253./96, 605./1008, -311./4032, 2591./604800, 0, 0, 0, 0, 0}, 
     {0, 0, 0, -190553./100800, 341747./43200, -696905./48384, 242537./16128, 
      -572803./57600, 249113./57600, -6655./5376, 1555./6912, -28501./1209600, 
      437./403200, 0, 0, 0, 0}, 
     {0, 0, 0, 128977./69300, -412009./50400, 1148963./72576, -48035./2688, 
      13528531./1036800, -20631./3200, 211387./96768, -4043./8064, 
      541519./7257600, -437./67200, 115./456192, 0, 0, 0}, 
     {0, 0, 0, -9061./4950, 9301169./1108800, -355277./20736, 1666393./80640, 
      -33976579./2073600, 21719153./2419200, -95953./27648, 152701./161280, 
      -370513./2073600, 17917./806400, -1495./912384, 289./5322240, 0, 0}, 
     {0, 0, 0, 30946717./17199000, -406841./47520, 21939781./1197504, 
      -22463./960, 38686369./1944000, -821491./69120, 62346581./12192768, 
      -22081./13824, 78292247./217728000, -437./7680, 1495./248832, 
      -289./760320, 2375101./217945728000, 0}, 
     {0, 0, 0, -39646461./22422400, 35118025721./4036032000., -10328195./532224, 
      277382447./10644480, -97656827./4147200, 1255260719./82944000, 
      -14468575./2032128, 100922299./40642560, -3106609./4838400, 
      11764477./96768000, -7475./456192, 13583./9123840, -2375101./29059430400, 
      1190281./581188608000}}, {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
      0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, -2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 17./6, -5, 13./6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, -7./2, 25./3, -13./2, 5./3, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 967./240, -35./3, 299./24, -35./6, 81./80, 0, 0, 0, 0, 0, 0, 
      0, 0}, {0, 0, 0, 0, -89./20, 1069./72, -39./2, 455./36, -81./20, 37./72, 0, 
      0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 4523./945, -285./16, 39169./1440, 
      -175./8, 783./80, -37./16, 6821./30240, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, -7645./1512, 31063./1512, -10153./288, 4781./144, -297./16, 
      37./6, -6821./6048, 265./3024, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 341747./64800, -139381./6048, 3152981./72576, -13321./288, 
      97479./3200, -407./32, 34105./10368, -2915./6048, 55591./1814400, 0, 0, 0, 
      0}, {0, 0, 0, 0, -412009./75600, 1148963./45360, -624455./12096, 
      314617./5184, -72657./1600, 64639./2880, -88673./12096, 55385./36288, 
      -55591./302400, 253./25920, 0, 0, 0}, 
     {0, 0, 0, 0, 9301169./1663200, -355277./12960, 21663109./362880, 
      -790153./10368, 2832933./44800, -205387./5760, 3349111./241920, 
      -37895./10368, 2279231./3628800, -3289./51840, 7613./2661120, 0, 0}, 
     {0, 0, 0, 0, -406841./71280, 21939781./748440, -292019./4320, 
      899683./9720, -107151./1280, 19064657./362880, -484291./20736, 
      1601501./217728, -55591./34560, 36179./155520, -7613./380160, 
      3103./3991680, 0}, {0, 0, 0, 0, 35118025721./6054048000, -2065639./66528, 
      3605971811./47900160, -2271089./20736, 54576553./512000, -884855./12096, 
      2213475889./60963840, -317735./24192, 1496565311./435456000, -3289./5184, 
      357811./4561920, -3103./532224, 171798901./871782912000}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, -5./2, 5./2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 25./6, -15./2, 10./3, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, -35./6, 115./8, -35./3, 25./8, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 1069./144, -45./2, 455./18, -25./2, 331./144, 0, 0, 0, 0, 
      0, 0, 0}, {0, 0, 0, 0, 0, -285./32, 3013./96, -175./4, 725./24, -331./32, 
      45./32, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 31063./3024, -3905./96, 4781./72, -1375./24, 331./12, 
      -225./32, 2243./3024, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, -139381./12096, 1212685./24192, -13321./144, 54155./576, 
      -3641./64, 2625./128, -24673./6048, 1045./3024, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 1148963./90720, -240175./4032, 314617./2592, -4485./32, 
      578257./5760, -2925./64, 468787./36288, -1045./504, 7501./51840, 0, 0, 0}, 
     {0, 0, 0, 0, 0, -355277./25920, 1666393./24192, -790153./5184, 
      4721555./24192, -1837381./11520, 22095./256, -320749./10368, 42845./6048, 
      -97513./103680, 2669./48384, 0, 0}, 
     {0, 0, 0, 0, 0, 21939781./1496880, -22463./288, 899683./4860, 
      -892925./3456, 170551391./725760, -37275./256, 67776731./1088640, 
      -5225./288, 1072643./311040, -2669./6912, 19301./997920, 0}, 
     {0, 0, 0, 0, 0, -2065639./133056, 277382447./3193344, -2271089./10368, 
      54576553./165888, -7915865./24192, 1622545./7168, -2689357./24192, 
      5626489./145152, -97513./10368, 125443./82944, -19301./133056, 
      8923./1419264}}, {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, -3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 23./4, -21./2, 19./4, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, -9, 91./4, -19, 21./4, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 3013./240, -315./8, 551./12, -189./8, 1087./240, 0, 0, 
      0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, -781./48, 4781./80, -1045./12, 63, 
      -1087./48, 259./80, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 242537./12096, -13321./160, 205789./1440, -2079./16, 
      38045./576, -2849./160, 30083./15120, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, -48035./2016, 314617./2880, -17043./80, 36687./160, 
      -14131./96, 54131./960, -30083./2520, 97./90, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 1666393./60480, -790153./5760, 17941909./60480, 
      -116571./320, 533717./1920, -259259./1920, 1233403./30240, -1261./180, 
      63373./120960, 0, 0}, {0, 0, 0, 0, 0, 0, -22463./720, 899683./5400, 
      -678623./1728, 515261./960, -540239./1152, 7826203./28800, -30083./288, 
      13871./540, -63373./17280, 6671./28800, 0}, 
     {0, 0, 0, 0, 0, 0, 277382447./7983360, -2271089./11520, 
      1036954507./2073600, -23915./32, 352741283./483840, -310541./640, 
      809864443./3628800, -1261./18, 2978531./207360, -6671./3840, 
      5009023./53222400}}, {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
      0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, -7./2, 7./2, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 91./12, -14, 77./12, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, -105./8, 203./6, -231./8, 49./6, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 4781./240, -385./6, 77, -245./6, 1939./240, 0, 0, 0, 
      0, 0}, {0, 0, 0, 0, 0, 0, 0, -13321./480, 75817./720, -2541./16, 
      8575./72, -21329./480, 4753./720, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 314617./8640, -6279./40, 134519./480, -3185./12, 
      405251./2880, -4753./120, 1249./270, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, -790153./17280, 944311./4320, -427427./960, 
      24059./48, -1940939./5760, 194873./1440, -16237./540, 77./27, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 899683./16200, -250019./864, 5667871./8640, 
      -121765./144, 58590763./86400, -33271./96, 178607./1620, -539./27, 
      136111./86400, 0}, {0, 0, 0, 0, 0, 0, 0, -2271089./34560, 
      382035871./1036800, -263065./288, 2271563./1728, -2324861./1920, 
      127955513./172800, -16237./54, 25333./324, -136111./11520, 273217./345600}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, -4, 4, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 29./3, -18, 25./3, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, -55./3, 48, -125./3, 12, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 10831./360, -99, 4375./36, -66, 4819./360, 0, 0, 
      0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, -897./20, 1747./10, -1625./6, 209, 
      -4819./60, 123./10, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 944311./15120, -5551./20, 12275./24, -1001./2, 
      197579./720, -1599./20, 1828./189, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, -35717./432, 515261./1260, -62125./72, 30217./30, 
      -33733./48, 5863./20, -1828./27, 2104./315, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 54576553./518400, -23915./42, 8112725./6048, 
      -3597./2, 129732299./86400, -1599./2, 21479./81, -1052./21, 4992457./1209600}
}, {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, -9./2, 9./2, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 12, -45./2, 21./2, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, -99./4, 525./8, -231./4, 135./8, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 1747./40, -585./4, 1463./8, -405./4, 419./20, 
      0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, -5551./80, 4419./16, -7007./16, 
      5535./16, -5447./40, 171./8, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 515261./5040, -7455./16, 211519./240, 
      -14175./16, 59917./120, -1197./8, 46943./2520, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, -23915./168, 324509./448, -25179./16, 
      242289./128, -5447./4, 18753./32, -46943./336, 12755./896}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -5, 5, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 175./12, -55./2, 155./12, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -65./2, 1045./12, -155./2, 275./12, 0, 0, 
      0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 491./8, -5005./24, 6355./24, 
      -3575./24, 94./3, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -2485./24, 
      30217./72, -5425./8, 39325./72, -658./3, 1265./36, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 324509./2016, -5995./8, 834551./576, 
      -17875./12, 15463./18, -6325./24, 135493./4032}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -11./2, 11./2, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 209./12, -33, 187./12, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1001./24, 451./4, -2431./24, 121./4, 0, 
      0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 30217./360, -1155./4, 26741./72, 
      -847./4, 8129./180, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1199./8, 
      296131./480, -12155./12, 39809./48, -8129./24, 8833./160}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -6, 6, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 41./2, -39, 37./2, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -105./2, 143, -259./2, 39, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 26921./240, -390, 12173./24, -585./2, 
      15149./240}}, {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -13./2, 13./2, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 143./6, -91./2, 65./3, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -65, 4277./24, -325./2, 1183./24}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -7, 7, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 329./12, -105./2, 301./12}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -15./2, 15./2}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1}}};

const double rtable18[18][18][18] = {
    {{1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, -1./2, 1./2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 1./3, -1./2, 1./6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, -1./4, 11./24, -1./4, 1./24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 1./5, -5./12, 7./24, -1./12, 1./120, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
      0}, {0, -1./6, 137./360, -5./16, 17./144, -1./48, 1./720, 0, 0, 0, 0, 0, 0, 
      0, 0, 0, 0, 0}, {0, 1./7, -7./20, 29./90, -7./48, 5./144, -1./240, 1./5040, 
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, -1./8, 363./1120, -469./1440, 967./5760, -7./144, 23./2880, -1./1440, 
      1./40320, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 1./9, -761./2520, 29531./90720, -89./480, 1069./17280, -1./80, 13./8640, 
      -1./10080, 1./362880, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, -1./10, 7129./25200, -1303./4032, 4523./22680, -19./256, 3013./172800, 
      -1./384, 29./120960, -1./80640, 1./3628800, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 1./11, -671./2520, 16103./50400, -7645./36288, 31063./362880, 
      -781./34560, 683./172800, -11./24192, 1./30240, -1./725760, 1./39916800, 0, 
      0, 0, 0, 0, 0}, {0, -1./12, 83711./332640, -190553./604800, 
      341747./1555200, -139381./1451520, 242537./8709120, -1903./345600, 
      10831./14515200, -11./161280, 1./248832, -1./7257600, 1./479001600, 0, 0, 
      0, 0, 0}, {0, 1./13, -6617./27720, 128977./415800, -412009./1814400, 
      1148963./10886400, -9607./290304, 314617./43545600, -299./268800, 
      1747./14515200, -13./1451520, 19./43545600, -1./79833600, 1./6227020800, 
      0, 0, 0, 0}, {0, -1./14, 1145993./5045040, -9061./29700, 
      9301169./39916800, -355277./3110400, 1666393./43545600, 
      -112879./12441600, 944311./609638400, -793./4147200, 491./29030400, 
      -13./12441600, 41./958003200, -1./958003200, 1./87178291200, 0, 0, 0}, 
     {0, 1./15, -1171733./5405400, 30946717./103194000, -406841./1710720, 
      21939781./179625600, -22463./518400, 899683./81648000, -35717./17418240, 
      515261./1828915200, -71./2488320, 2747./1306368000, -1./9123840, 
      1./261273600, -1./12454041600, 1./1307674368000, 0, 0}, 
     {0, -1./16, 1195757./5765760, -13215487./44844800, 
      35118025721./145297152000, -2065639./15966720, 277382447./5748019200, 
      -2271089./174182400, 54576553./20901888000, -4783./12192768, 
      324509./7315660800, -109./29030400, 26921./114960384000, -1./95800320, 
      47./149448499200, -1./174356582400, 1./20922789888000, 0}, 
     {0, 1./17, -143327./720720, 58433327./201801600, -4446371981./18162144000, 
      2195261857./16144128000, -38101097./718502400, 86853967./5748019200, 
      -8424673./2612736000., 76492463./146313216000., -59279./914457600, 
      44941./7315660800, -6341./14370048000, 2713./114960384000, 
      -17./18681062400, 1./41845579776, -1./2615348736000, 1./355687428096000}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, -1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 11./12, -3./2, 7./12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, -5./6, 7./4, -7./6, 1./4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 137./180, -15./8, 119./72, -5./8, 31./360, 0, 0, 0, 0, 0, 0, 0, 0, 
      0, 0, 0}, {0, 0, -7./10, 29./15, -49./24, 25./24, -31./120, 1./40, 0, 0, 0, 
      0, 0, 0, 0, 0, 0, 0}, {0, 0, 363./560, -469./240, 6769./2880, -35./24, 
      713./1440, -7./80, 127./20160, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, -761./1260, 29531./15120, -623./240, 1069./576, -31./40, 91./480, 
      -127./5040, 17./12096, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 7129./12600, -1303./672, 4523./1620, -285./128, 93403./86400, 
      -21./64, 3683./60480, -17./2688, 73./259200, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, -671./1260, 16103./8400, -7645./2592, 31063./12096, -24211./17280, 
      4781./9600, -1397./12096, 17./1008, -73./51840, 31./604800, 0, 0, 0, 0, 0, 
      0}, {0, 0, 83711./166320, -190553./100800, 2392229./777600, 
      -139381./48384, 7518647./4354560, -13321./19200, 1375537./7257600, 
      -187./5376, 511./124416, -341./1209600, 2047./239500800, 0, 0, 0, 0, 0}, 
     {0, 0, -6617./13860, 128977./69300, -412009./129600, 1148963./362880, 
      -297817./145152, 314617./345600, -37973./134400, 29699./483840, 
      -949./103680, 6479./7257600, -2047./39916800, 1./760320, 0, 0, 0, 0}, 
     {0, 0, 1145993./2522520, -9061./4950, 9301169./2851200, -355277./103680, 
      51658183./21772800, -790153./691200, 119927497./304819200, 
      -13481./138240, 35843./2073600, -4433./2073600, 83927./479001600, 
      -13./1520640, 8191./43589145600, 0, 0, 0}, 
     {0, 0, -1171733./2702700, 30946717./17199000, -2847887./855360, 
      21939781./5987520, -696353./259200, 899683./648000, -4536059./8709120, 
      8759437./60963840, -36281./1244160, 936727./217728000, -2047./4561920, 
      13./414720, -8191./6227020800, 5461./217945728000, 0, 0}, 
     {0, 0, 1195757./2882880, -39646461./22422400, 35118025721./10378368000, 
      -2065639./532224, 8598855857./2874009600., -2271089./1382400, 
      6931222231./10450944000, -406555./2032128, 23689157./522547200, 
      -37169./4838400, 55107287./57480192000, -13./152064, 384977./74724249600, 
      -5461./29059430400, 4681./1494484992000, 0}, 
     {0, 0, -143327./360360, 58433327./33633600, -4446371981./1297296000, 
      2195261857./538137600, -1181134007./359251200, 86853967./45619200, 
      -1069933471./1306368000, 1300371871./4877107200, -4327367./65318400, 
      15324881./1219276800, -12980027./7185024000, 35269./182476800, 
      -139247./9340531200, 5461./6974263296, -4681./186810624000, 
      257./697426329600}}, {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
      0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, -3./2, 3./2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 7./4, -3, 5./4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, -15./8, 17./4, -25./8, 3./4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 29./15, -21./4, 125./24, -9./4, 43./120, 0, 0, 0, 0, 0, 0, 0, 0, 
      0, 0}, {0, 0, 0, -469./240, 967./160, -175./24, 69./16, -301./240, 23./160, 
      0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 29531./15120, -267./40, 5345./576, -27./4, 3913./1440, -23./40, 
      605./12096, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, -1303./672, 4523./630, -1425./128, 3013./320, -301./64, 667./480, 
      -605./2688, 311./20160, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 16103./8400, -7645./1008, 155315./12096, -781./64, 205583./28800, 
      -253./96, 605./1008, -311./4032, 2591./604800, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, -190553./100800, 341747./43200, -696905./48384, 242537./16128, 
      -572803./57600, 249113./57600, -6655./5376, 1555./6912, -28501./1209600, 
      437./403200, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 128977./69300, -412009./50400, 1148963./72576, -48035./2688, 
      13528531./1036800, -20631./3200, 211387./96768, -4043./8064, 
      541519./7257600, -437./67200, 115./456192, 0, 0, 0, 0}, 
     {0, 0, 0, -9061./4950, 9301169./1108800, -355277./20736, 1666393./80640, 
      -33976579./2073600, 21719153./2419200, -95953./27648, 152701./161280, 
      -370513./2073600, 17917./806400, -1495./912384, 289./5322240, 0, 0, 0}, 
     {0, 0, 0, 30946717./17199000, -406841./47520, 21939781./1197504, 
      -22463./960, 38686369./1944000, -821491./69120, 62346581./12192768, 
      -22081./13824, 78292247./217728000, -437./7680, 1495./248832, 
      -289./760320, 2375101./217945728000, 0, 0}, 
     {0, 0, 0, -39646461./22422400, 35118025721./4036032000., 
      -10328195./532224, 277382447./10644480, -97656827./4147200, 
      1255260719./82944000, -14468575./2032128, 100922299./40642560, 
      -3106609./4838400, 11764477./96768000, -7475./456192, 13583./9123840, 
      -2375101./29059430400, 1190281./581188608000, 0}, 
     {0, 0, 0, 58433327./33633600, -4446371981./504504000, 
      2195261857./107627520, -38101097./1330560, 3734720581./136857600, 
      -193767479./10368000, 9255588023./975421440, -18435769./5080320, 
      1280863441./1219276800, -2771017./12096000, 811187./21897216, 
      -4913./1140480, 2375101./6974263296, -1190281./72648576000, 
      50489./139485265920}}, {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
      0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, -2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 17./6, -5, 13./6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, -7./2, 25./3, -13./2, 5./3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 967./240, -35./3, 299./24, -35./6, 81./80, 0, 0, 0, 0, 0, 0, 
      0, 0, 0}, {0, 0, 0, 0, -89./20, 1069./72, -39./2, 455./36, -81./20, 37./72, 
      0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 4523./945, -285./16, 39169./1440, -175./8, 783./80, -37./16, 
      6821./30240, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, -7645./1512, 31063./1512, -10153./288, 4781./144, -297./16, 
      37./6, -6821./6048, 265./3024, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 341747./64800, -139381./6048, 3152981./72576, -13321./288, 
      97479./3200, -407./32, 34105./10368, -2915./6048, 55591./1814400, 0, 0, 0, 
      0, 0}, {0, 0, 0, 0, -412009./75600, 1148963./45360, -624455./12096, 
      314617./5184, -72657./1600, 64639./2880, -88673./12096, 55385./36288, 
      -55591./302400, 253./25920, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 9301169./1663200, -355277./12960, 21663109./362880, 
      -790153./10368, 2832933./44800, -205387./5760, 3349111./241920, 
      -37895./10368, 2279231./3628800, -3289./51840, 7613./2661120, 0, 0, 0}, 
     {0, 0, 0, 0, -406841./71280, 21939781./748440, -292019./4320, 
      899683./9720, -107151./1280, 19064657./362880, -484291./20736, 
      1601501./217728, -55591./34560, 36179./155520, -7613./380160, 
      3103./3991680, 0, 0}, {0, 0, 0, 0, 35118025721./6054048000, 
      -2065639./66528, 3605971811./47900160, -2271089./20736, 54576553./512000, 
      -884855./12096, 2213475889./60963840, -317735./24192, 
      1496565311./435456000, -3289./5184, 357811./4561920, -3103./532224, 
      171798901./871782912000, 0}, 
     {0, 0, 0, 0, -4446371981./756756000, 2195261857./67267200, 
      -495314261./5987520, 86853967./684288, -8424673./64000, 
      2830221131./29030400, -404342059./7620480, 131003015./6096384, 
      -352502531./54432000, 8923057./6220800, -129421./570240, 77575./3193344, 
      -171798901./108972864000, 4084337./87178291200}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, -5./2, 5./2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 25./6, -15./2, 10./3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, -35./6, 115./8, -35./3, 25./8, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 1069./144, -45./2, 455./18, -25./2, 331./144, 0, 0, 0, 0, 
      0, 0, 0, 0}, {0, 0, 0, 0, 0, -285./32, 3013./96, -175./4, 725./24, 
      -331./32, 45./32, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 31063./3024, -3905./96, 4781./72, -1375./24, 331./12, 
      -225./32, 2243./3024, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, -139381./12096, 1212685./24192, -13321./144, 54155./576, 
      -3641./64, 2625./128, -24673./6048, 1045./3024, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 1148963./90720, -240175./4032, 314617./2592, -4485./32, 
      578257./5760, -2925./64, 468787./36288, -1045./504, 7501./51840, 0, 0, 0, 
      0}, {0, 0, 0, 0, 0, -355277./25920, 1666393./24192, -790153./5184, 
      4721555./24192, -1837381./11520, 22095./256, -320749./10368, 42845./6048, 
      -97513./103680, 2669./48384, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 21939781./1496880, -22463./288, 899683./4860, 
      -892925./3456, 170551391./725760, -37275./256, 67776731./1088640, 
      -5225./288, 1072643./311040, -2669./6912, 19301./997920, 0, 0}, 
     {0, 0, 0, 0, 0, -2065639./133056, 277382447./3193344, -2271089./10368, 
      54576553./165888, -7915865./24192, 1622545./7168, -2689357./24192, 
      5626489./145152, -97513./10368, 125443./82944, -19301./133056, 
      8923./1419264, 0}, {0, 0, 0, 0, 0, 2195261857./134534400, 
      -38101097./399168, 86853967./342144, -8424673./20736, 
      25319005253./58060800, -296395./896, 1108829293./6096384, -1325269./18144, 
      264552769./12441600, -45373./10368, 482525./798336, -8923./177408, 
      332514803./174356582400}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, -3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 23./4, -21./2, 19./4, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, -9, 91./4, -19, 21./4, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 3013./240, -315./8, 551./12, -189./8, 1087./240, 0, 0, 
      0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, -781./48, 4781./80, -1045./12, 63, 
      -1087./48, 259./80, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 242537./12096, -13321./160, 205789./1440, -2079./16, 
      38045./576, -2849./160, 30083./15120, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, -48035./2016, 314617./2880, -17043./80, 36687./160, 
      -14131./96, 54131./960, -30083./2520, 97./90, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 1666393./60480, -790153./5760, 17941909./60480, 
      -116571./320, 533717./1920, -259259./1920, 1233403./30240, -1261./180, 
      63373./120960, 0, 0, 0}, {0, 0, 0, 0, 0, 0, -22463./720, 899683./5400, 
      -678623./1728, 515261./960, -540239./1152, 7826203./28800, -30083./288, 
      13871./540, -63373./17280, 6671./28800, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 277382447./7983360, -2271089./11520, 
      1036954507./2073600, -23915./32, 352741283./483840, -310541./640, 
      809864443./3628800, -1261./18, 2978531./207360, -6671./3840, 
      5009023./53222400, 0}, {0, 0, 0, 0, 0, 0, -38101097./997920, 
      86853967./380160, -160068787./259200, 76492463./76800, -64436273./60480, 
      18290987./23040, -190756303./453600, 3421093./21600, -1077341./25920, 
      33355./4608, -5009023./6652800, 89809./2534400}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, -7./2, 7./2, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 91./12, -14, 77./12, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, -105./8, 203./6, -231./8, 49./6, 0, 0, 0, 0, 0, 0, 
      0}, {0, 0, 0, 0, 0, 0, 0, 4781./240, -385./6, 77, -245./6, 1939./240, 0, 
      0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, -13321./480, 75817./720, 
      -2541./16, 8575./72, -21329./480, 4753./720, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 314617./8640, -6279./40, 134519./480, -3185./12, 
      405251./2880, -4753./120, 1249./270, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, -790153./17280, 944311./4320, -427427./960, 
      24059./48, -1940939./5760, 194873./1440, -16237./540, 77./27, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 899683./16200, -250019./864, 5667871./8640, 
      -121765./144, 58590763./86400, -33271./96, 178607./1620, -539./27, 
      136111./86400, 0, 0}, {0, 0, 0, 0, 0, 0, 0, -2271089./34560, 
      382035871./1036800, -263065./288, 2271563./1728, -2324861./1920, 
      127955513./172800, -16237./54, 25333./324, -136111./11520, 273217./345600, 
      0}, {0, 0, 0, 0, 0, 0, 0, 86853967./1140480, -58972711./129600, 
      841417093./691200, -414953./216, 136935227./69120, -30138773./21600, 
      44050981./64800, -18326./81, 680555./13824, -273217./43200, 
      2769673./7603200}}, {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
      0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, -4, 4, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 29./3, -18, 25./3, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, -55./3, 48, -125./3, 12, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 10831./360, -99, 4375./36, -66, 4819./360, 0, 0, 
      0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, -897./20, 1747./10, -1625./6, 209, 
      -4819./60, 123./10, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 944311./15120, -5551./20, 12275./24, -1001./2, 
      197579./720, -1599./20, 1828./189, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, -35717./432, 515261./1260, -62125./72, 30217./30, 
      -33733./48, 5863./20, -1828./27, 2104./315, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 54576553./518400, -23915./42, 8112725./6048, 
      -3597./2, 129732299./86400, -1599./2, 21479./81, -1052./21, 
      4992457./1209600, 0}, {0, 0, 0, 0, 0, 0, 0, 0, -8424673./64800, 
      76492463./100800, -1481975./756, 494351./168, -30557279./10800, 
      1446029./800, -62152./81, 13150./63, -4992457./151200, 77761./33600}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, -9./2, 9./2, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 12, -45./2, 21./2, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, -99./4, 525./8, -231./4, 135./8, 0, 0, 0, 0, 
      0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 1747./40, -585./4, 1463./8, -405./4, 
      419./20, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, -5551./80, 4419./16, 
      -7007./16, 5535./16, -5447./40, 171./8, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 515261./5040, -7455./16, 211519./240, 
      -14175./16, 59917./120, -1197./8, 46943./2520, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, -23915./168, 324509./448, -25179./16, 
      242289./128, -5447./4, 18753./32, -46943./336, 12755./896, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 76492463./403200, -59279./56, 494351./192, 
      -57069./16, 14777711./4800, -6783./4, 1173575./2016, -12755./112, 
      186653./19200}}, {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
      0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -5, 5, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 175./12, -55./2, 155./12, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -65./2, 1045./12, -155./2, 275./12, 0, 0, 
      0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 491./8, -5005./24, 6355./24, 
      -3575./24, 94./3, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -2485./24, 30217./72, -5425./8, 39325./72, 
      -658./3, 1265./36, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 324509./2016, 
      -5995./8, 834551./576, -17875./12, 15463./18, -6325./24, 135493./4032, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -59279./252, 2471755./2016, -196571./72, 
      1939795./576, -22372./9, 158125./144, -135493./504, 113465./4032}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -11./2, 11./2, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 209./12, -33, 187./12, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1001./24, 451./4, -2431./24, 121./4, 0, 
      0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 30217./360, -1155./4, 
      26741./72, -847./4, 8129./180, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1199./8, 296131./480, -12155./12, 
      39809./48, -8129./24, 8833./160, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 494351./2016, -69751./60, 6595303./2880, 
      -14399./6, 203225./144, -8833./20, 1158509./20160}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -6, 6, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 41./2, -39, 37./2, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -105./2, 143, -259./2, 39, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 26921./240, -390, 12173./24, 
      -585./2, 15149./240, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -6341./30, 
      35269./40, -4403./3, 4875./4, -15149./30, 3341./40}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -13./2, 13./2, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 143./6, -91./2, 65./3, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -65, 4277./24, -325./2, 1183./24, 
      0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 35269./240, -1547./3, 
      8125./12, -1183./3, 6877./80}}, 
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -7, 7, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 329./12, -105./2, 301./12, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -238./3, 875./4, -602./3, 
      245./4}}, {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -15./2, 15./2, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 125./4, -60, 115./4}},
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -8, 8}},
    {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1}}};

// export ratio tables
const double    *evalRetessTables[NV_PATCH_MAX_RETESS] = {
    NULL,
    NULL,
    &rtable2[0][0][0],
    &rtable3[0][0][0],
    &rtable4[0][0][0],
    &rtable5[0][0][0],
    &rtable6[0][0][0],
    &rtable7[0][0][0],
    &rtable8[0][0][0],
    &rtable9[0][0][0],
    &rtable10[0][0][0],
    &rtable11[0][0][0],
    &rtable12[0][0][0],
    &rtable13[0][0][0],
    &rtable14[0][0][0],
    &rtable15[0][0][0],
    &rtable16[0][0][0],
    //ff&rtable17[0][0][0],
    //ff&rtable18[0][0][0],
};

/*****************************************************************************/
// Exports
float *bsplineBasis[16] = {
    &bsplineBasis1[0][0],
    &bsplineBasis2[0][0],
    &bsplineBasis3[0][0],
    &bsplineBasis4[0][0],
    &bsplineBasis5[0][0],
    &bsplineBasis6[0][0],
    &bsplineBasis7[0][0],
    &bsplineBasis8[0][0],
    &bsplineBasis9[0][0],
    &bsplineBasis10[0][0],
    &bsplineBasis11[0][0],
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
};

float *catmullRomBasis[16] = {
    NULL,
    NULL,
    NULL,
    &catmullRomBasis4[0][0],
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
};

float *bezBasis[16] = {
    &bezBasis1[0][0],
    &bezBasis2[0][0],
    &bezBasis3[0][0],
    &bezBasis4[0][0],
    &bezBasis5[0][0],
    &bezBasis6[0][0],
    &bezBasis7[0][0],
    &bezBasis8[0][0],
    &bezBasis9[0][0],
    &bezBasis10[0][0],
    &bezBasis11[0][0],
    &bezBasis12[0][0],
    &bezBasis13[0][0],
    &bezBasis14[0][0],
    &bezBasis15[0][0],
    &bezBasis16[0][0],
};

#if 0
float *invBezBasis[16] = {
    &invBezBasis1[0][0],
    &invBezBasis2[0][0],
    &invBezBasis3[0][0],
    &invBezBasis4[0][0],
    &invBezBasis5[0][0],
    &invBezBasis6[0][0],
    &invBezBasis7[0][0],
    &invBezBasis8[0][0],
    &invBezBasis9[0][0],
    &invBezBasis10[0][0],
    &invBezBasis11[0][0],
    &invBezBasis12[0][0],
    &invBezBasis13[0][0],
    &invBezBasis14[0][0],
    &invBezBasis15[0][0],
    &invBezBasis16[0][0],
};
#endif

float *powerToFD[16] = {
    &powerToFD1[0][0],
    &powerToFD2[0][0],
    &powerToFD3[0][0],
    &powerToFD4[0][0],
    &powerToFD5[0][0],
    &powerToFD6[0][0],
    &powerToFD7[0][0],
    &powerToFD8[0][0],
    &powerToFD9[0][0],
    &powerToFD10[0][0],
    &powerToFD11[0][0],
    &powerToFD12[0][0],
    &powerToFD13[0][0],
    &powerToFD14[0][0],
    &powerToFD15[0][0],
    &powerToFD16[0][0],
};

float *inversePowerToFD[16] = {
    &inversePowerToFD1[0][0],
    &inversePowerToFD2[0][0],
    &inversePowerToFD3[0][0],
    &inversePowerToFD4[0][0],
    &inversePowerToFD5[0][0],
    &inversePowerToFD6[0][0],
    &inversePowerToFD7[0][0],
    &inversePowerToFD8[0][0],
    &inversePowerToFD9[0][0],
    &inversePowerToFD10[0][0],
    &inversePowerToFD11[0][0],
    &inversePowerToFD12[0][0],
    &inversePowerToFD13[0][0],
    &inversePowerToFD14[0][0],
    &inversePowerToFD15[0][0],
    &inversePowerToFD16[0][0],
};

#if 0
// Inverse Bezier basis matrices
static float invBezBasis1[1][1] = {
    {1},
};

static float invBezBasis2[2][2] = {
    {0, 1},
    {1, 1},
};

static float invBezBasis3[3][3] = {
    {0,     0, 1},
    {0, 1.0/2, 1},
    {1,     1, 1},
};

static float invBezBasis4[4][4] = {
    {0,     0,     0, 1},
    {0,     0, 1.0/3, 1},
    {0, 1.0/3, 2.0/3, 1},
    {1,     1,     1, 1},
};

static float invBezBasis5[5][5] = {
    {0, 0, 0, 0, 1},
    {0, 0, 0, 1.0/4, 1},
    {0, 0, 1.0/6, 1.0/2, 1},
    {0, 1.0/4, 1.0/2, 3.0/4, 1},
    {1, 1, 1, 1, 1},
};

static float invBezBasis6[6][6] = {
    {0, 0, 0, 0, 0, 1},
    {0, 0, 0, 0, 1.0/5, 1},
    {0, 0, 0, 1.0/10, 2.0/5, 1},
    {0, 0, 1.0/10, 3.0/10, 3.0/5, 1},
    {0, 1.0/5, 2.0/5, 3.0/5, 4.0/5, 1},
    {1, 1, 1, 1, 1, 1},
};

static float invBezBasis7[7][7] = {
    {0, 0, 0, 0, 0, 0, 1},{0, 0, 0, 0, 0, 1.0/6, 1},
    {0, 0, 0, 0, 1.0/15, 1.0/3, 1},{0, 0, 0, 1.0/20, 1.0/5, 1.0/2, 1},
    {0, 0, 1.0/15, 1.0/5, 2.0/5, 2.0/3, 1},{0, 1.0/6, 1.0/3, 1.0/2, 2.0/3, 5.0/6, 1},
    {1, 1, 1, 1, 1, 1, 1},
};

static float invBezBasis8[8][8] = {
    {0, 0, 0, 0, 0, 0, 0, 1},
    {0, 0, 0, 0, 0, 0, 1.0/7, 1},{0, 0, 0, 0, 0, 1.0/21, 2.0/7, 1},
    {0, 0, 0, 0, 1.0/35, 1.0/7, 3.0/7, 1},{0, 0, 0, 1.0/35, 4.0/35, 2.0/7, 4.0/7, 1},
    {0, 0, 1.0/21, 1.0/7, 2.0/7, 10.0/21, 5.0/7, 1},
    {0, 1.0/7, 2.0/7, 3.0/7, 4.0/7, 5.0/7, 6.0/7, 1},{1, 1, 1, 1, 1, 1, 1, 1},
};

static float invBezBasis9[9][9] = {
    {0, 0, 0, 0, 0, 0, 0, 0, 1},{0, 0, 0, 0, 0, 0, 0, 1.0/8, 1},
    {0, 0, 0, 0, 0, 0, 1.0/28, 1.0/4, 1},{0, 0, 0, 0, 0, 1.0/56, 3.0/28, 3.0/8, 1},
    {0, 0, 0, 0, 1.0/70, 1.0/14, 3.0/14, 1.0/2, 1},
    {0, 0, 0, 1.0/56, 1.0/14, 5.0/28, 5.0/14, 5.0/8, 1},
    {0, 0, 1.0/28, 3.0/28, 3.0/14, 5.0/14, 15.0/28, 3.0/4, 1},
    {0, 1.0/8, 1.0/4, 3.0/8, 1.0/2, 5.0/8, 3.0/4, 7.0/8, 1},{1, 1, 1, 1, 1, 1, 1, 1, 1},
};

static float invBezBasis10[10][10] = {
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 1},{0, 0, 0, 0, 0, 0, 0, 0, 1.0/9, 1},
    {0, 0, 0, 0, 0, 0, 0, 1.0/36, 2.0/9, 1},
    {0, 0, 0, 0, 0, 0, 1.0/84, 1.0/12, 1.0/3, 1},
    {0, 0, 0, 0, 0, 1.0/126, 1.0/21, 1.0/6, 4.0/9, 1},
    {0, 0, 0, 0, 1.0/126, 5.0/126, 5.0/42, 5.0/18, 5.0/9, 1},
    {0, 0, 0, 1.0/84, 1.0/21, 5.0/42, 5.0/21, 5.0/12, 2.0/3, 1},
    {0, 0, 1.0/36, 1.0/12, 1.0/6, 5.0/18, 5.0/12, 7.0/12, 7.0/9, 1},
    {0, 1.0/9, 2.0/9, 1.0/3, 4.0/9, 5.0/9, 2.0/3, 7.0/9, 8.0/9, 1},
    {1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
};

static float invBezBasis11[11][11] = {
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1},{0, 0, 0, 0, 0, 0, 0, 0, 0, 1.0/10, 1},
    {0, 0, 0, 0, 0, 0, 0, 0, 1.0/45, 1.0/5, 1},
    {0, 0, 0, 0, 0, 0, 0, 1.0/120, 1.0/15, 3.0/10, 1},
    {0, 0, 0, 0, 0, 0, 1.0/210, 1.0/30, 2.0/15, 2.0/5, 1},
    {0, 0, 0, 0, 0, 1.0/252, 1.0/42, 1.0/12, 2.0/9, 1.0/2, 1},
    {0, 0, 0, 0, 1.0/210, 1.0/42, 1.0/14, 1.0/6, 1.0/3, 3.0/5, 1},
    {0, 0, 0, 1.0/120, 1.0/30, 1.0/12, 1.0/6, 7.0/24, 7.0/15, 7.0/10, 1},
    {0, 0, 1.0/45, 1.0/15, 2.0/15, 2.0/9, 1.0/3, 7.0/15, 28.0/45, 4.0/5, 1},
    {0, 1.0/10, 1.0/5, 3.0/10, 2.0/5, 1.0/2, 3.0/5, 7.0/10, 4.0/5, 9.0/10, 1},
    {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
};

static float invBezBasis12[12][12] = {
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1},
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1.0/11, 1},
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 1.0/55, 2.0/11, 1},
    {0, 0, 0, 0, 0, 0, 0, 0, 1.0/165, 3.0/55, 3.0/11, 1},
    {0, 0, 0, 0, 0, 0, 0, 1.0/330, 4.0/165, 6.0/55, 4.0/11, 1},
    {0, 0, 0, 0, 0, 0, 1.0/462, 1.0/66, 2.0/33, 2.0/11, 5.0/11, 1},
    {0, 0, 0, 0, 0, 1.0/462, 1.0/77, 1.0/22, 4.0/33, 3.0/11, 6.0/11, 1},
    {0, 0, 0, 0, 1.0/330, 1.0/66, 1.0/22, 7.0/66, 7.0/33, 21.0/55, 7.0/11, 1},
    {0, 0, 0, 1.0/165, 4.0/165, 2.0/33, 4.0/33, 7.0/33, 56.0/165, 28.0/55, 8.0/11, 1},
    {0, 0, 1.0/55, 3.0/55, 6.0/55, 2.0/11, 3.0/11, 21.0/55, 28.0/55, 36.0/55, 9.0/11, 1},
    {0, 1.0/11, 2.0/11, 3.0/11, 4.0/11, 5.0/11, 6.0/11, 7.0/11, 8.0/11, 9.0/11, 10.0/11, 1},
    {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
};

static float invBezBasis13[13][13] = {
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1},
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1.0/12, 1},
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1.0/66, 1.0/6, 1},
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 1.0/220, 1.0/22, 1.0/4, 1},
    {0, 0, 0, 0, 0, 0, 0, 0, 1.0/495, 1.0/55, 1.0/11, 1.0/3, 1},
    {0, 0, 0, 0, 0, 0, 0, 1.0/792, 1.0/99, 1.0/22, 5.0/33, 5.0/12, 1},
    {0, 0, 0, 0, 0, 0, 1.0/924, 1.0/132, 1.0/33, 1.0/11, 5.0/22, 1.0/2, 1},
    {0, 0, 0, 0, 0, 1.0/792, 1.0/132, 7.0/264, 7.0/99, 7.0/44, 7.0/22, 7.0/12, 1},
    {0, 0, 0, 0, 1.0/495, 1.0/99, 1.0/33, 7.0/99, 14.0/99, 14.0/55, 14.0/33, 2.0/3, 1},
    {0, 0, 0, 1.0/220, 1.0/55, 1.0/22, 1.0/11, 7.0/44, 14.0/55, 21.0/55, 6.0/11, 3.0/4, 1},
    {0, 0, 1.0/66, 1.0/22, 1.0/11, 5.0/33, 5.0/22, 7.0/22, 14.0/33, 6.0/11, 15.0/22, 5.0/6, 1},
    {0, 1.0/12, 1.0/6, 1.0/4, 1.0/3, 5.0/12, 1.0/2, 7.0/12, 2.0/3, 3.0/4, 5.0/6, 11.0/12, 1},
    {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
};

static float invBezBasis14[14][14] = {
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1},
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1.0/13, 1},
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1.0/78, 2.0/13, 1},
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1.0/286, 1.0/26, 3.0/13, 1},
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 1.0/715, 2.0/143, 1.0/13, 4.0/13, 1},
    {0, 0, 0, 0, 0, 0, 0, 0, 1.0/1287, 1.0/143, 5.0/143, 5.0/39, 5.0/13, 1},
    {0, 0, 0, 0, 0, 0, 0, 1.0/1716, 2.0/429, 3.0/143, 10.0/143, 5.0/26, 6.0/13, 1},
    {0, 0, 0, 0, 0, 0, 1.0/1716, 7.0/1716, 7.0/429, 7.0/143, 35.0/286, 7.0/26, 7.0/13, 1},
    {0, 0, 0, 0, 0, 1.0/1287, 2.0/429, 7.0/429, 56.0/1287, 14.0/143, 28.0/143, 14.0/39, 
    8.0/13, 1},{0, 0, 0, 0, 1.0/715, 1.0/143, 3.0/143, 7.0/143, 14.0/143, 126.0/715, 
    42.0/143, 6.0/13, 9.0/13, 1},{0, 0, 0, 1.0/286, 2.0/143, 5.0/143, 10.0/143, 35.0/286, 
    28.0/143, 42.0/143, 60.0/143, 15.0/26, 10.0/13, 1},
    {0, 0, 1.0/78, 1.0/26, 1.0/13, 5.0/39, 5.0/26, 7.0/26, 14.0/39, 6.0/13, 15.0/26, 55.0/78, 
    11.0/13, 1},{0, 1.0/13, 2.0/13, 3.0/13, 4.0/13, 5.0/13, 6.0/13, 7.0/13, 8.0/13, 9.0/13, 
    10.0/13, 11.0/13, 12.0/13, 1},{1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
};

static float invBezBasis15[15][15] = {
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1},
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1.0/14, 1},
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1.0/91, 1.0/7, 1},
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1.0/364, 3.0/91, 3.0/14, 1},
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1.0/1001, 1.0/91, 6.0/91, 2.0/7, 1},
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 1.0/2002, 5.0/1001, 5.0/182, 10.0/91, 5.0/14, 1},
    {0, 0, 0, 0, 0, 0, 0, 0, 1.0/3003, 3.0/1001, 15.0/1001, 5.0/91, 15.0/91, 3.0/7, 1},
    {0, 0, 0, 0, 0, 0, 0, 1.0/3432, 1.0/429, 3.0/286, 5.0/143, 5.0/52, 3.0/13, 1.0/2, 1},
    {0, 0, 0, 0, 0, 0, 1.0/3003, 1.0/429, 4.0/429, 4.0/143, 10.0/143, 2.0/13, 4.0/13, 4.0/7, 
    1},{0, 0, 0, 0, 0, 1.0/2002, 3.0/1001, 3.0/286, 4.0/143, 9.0/143, 18.0/143, 3.0/13, 
    36.0/91, 9.0/14, 1},{0, 0, 0, 0, 1.0/1001, 5.0/1001, 15.0/1001, 5.0/143, 10.0/143, 
    18.0/143, 30.0/143, 30.0/91, 45.0/91, 5.0/7, 1},
    {0, 0, 0, 1.0/364, 1.0/91, 5.0/182, 5.0/91, 5.0/52, 2.0/13, 3.0/13, 30.0/91, 165.0/364, 
    55.0/91, 11.0/14, 1},{0, 0, 1.0/91, 3.0/91, 6.0/91, 10.0/91, 15.0/91, 3.0/13, 4.0/13, 
    36.0/91, 45.0/91, 55.0/91, 66.0/91, 6.0/7, 1},
    {0, 1.0/14, 1.0/7, 3.0/14, 2.0/7, 5.0/14, 3.0/7, 1.0/2, 4.0/7, 9.0/14, 5.0/7, 11.0/14, 6.0/7, 
    13.0/14, 1},{1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
};

static float invBezBasis16[16][16] = {
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1},
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1.0/15, 1},
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1.0/105, 2.0/15, 1},
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1.0/455, 1.0/35, 1.0/5, 1},
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1.0/1365, 4.0/455, 2.0/35, 4.0/15, 1},
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1.0/3003, 1.0/273, 2.0/91, 2.0/21, 1.0/3, 1},
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 1.0/5005, 2.0/1001, 1.0/91, 4.0/91, 1.0/7, 2.0/5, 1},
    {0, 0, 0, 0, 0, 0, 0, 0, 1.0/6435, 1.0/715, 1.0/143, 1.0/39, 1.0/13, 1.0/5, 7.0/15, 1},
    {0, 0, 0, 0, 0, 0, 0, 1.0/6435, 8.0/6435, 4.0/715, 8.0/429, 2.0/39, 8.0/65, 4.0/15, 
    8.0/15, 1},
    {0, 0, 0, 0, 0, 0, 1.0/5005, 1.0/715, 4.0/715, 12.0/715, 6.0/143, 6.0/65, 
    12.0/65, 12.0/35, 3.0/5, 1},
    {0, 0, 0, 0, 0, 1.0/3003, 2.0/1001, 1.0/143, 8.0/429, 
    6.0/143, 12.0/143, 2.0/13, 24.0/91, 3.0/7, 2.0/3, 1},
    {0, 0, 0, 0, 1.0/1365, 1.0/273, 1.0/91, 1.0/39, 2.0/39, 6.0/65, 2.0/13, 22.0/91, 33.0/91, 
    11.0/21, 11.0/15, 1},
    {0, 0, 0, 1.0/455, 4.0/455, 2.0/91, 4.0/91, 1.0/13, 8.0/65, 12.0/65, 
    24.0/91, 33.0/91, 44.0/91, 22.0/35, 4.0/5, 1},
    {0, 0, 1.0/105, 1.0/35, 2.0/35, 2.0/21, 1.0/7, 1.0/5, 4.0/15, 12.0/35, 3.0/7, 11.0/21, 22.0/35, 
    26.0/35, 13.0/15, 1},
    {0, 1.0/15, 2.0/15, 1.0/5, 4.0/15, 1.0/3, 2.0/5, 7.0/15, 8.0/15, 3.0/5, 
    2.0/3, 11.0/15, 4.0/5, 13.0/15, 14.0/15, 1},
    {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1}
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\common\src\nvPM.c ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/
#include "nvPM.h"

/*
#undef NV_PRAMDAC_TEST_CONTROL
#undef NV_PRAMDAC_CHECKSUM
#include "..\..\resman\kernel\inc\nv_ref.h"
#include "..\..\resman\kernel\inc\nv10\nv10_ref.h"
*/
#include "..\..\..\common\nv10\inc\nv10ppm.h"
#include <stdio.h>

/*
 * build specific aliases (aliaii?)
 */
#ifdef NVDD32

#define pmAllocMemory       AllocIPM
#define pmFreeMemory        FreeIPM

#define writeMethod140()                                                    \
    nvglSetObject(NV_DD_SPARE, D3D_RENDER_SOLID_RECTANGLE);                 \
    nvPushData (0,0x0004e140);                                              \
    nvPushData (1,0x00000001);                                              \
    nvPusherAdjust (2);                                                     \
    pDriverData->dDrawSpareSubchannelObject = D3D_RENDER_SOLID_RECTANGLE;

#define flush()  getDC()->nvPusher.flush (TRUE, CPushBuffer::FLUSH_WITH_DELAY);

#elif defined(IS_OPENGL)

#define pmAllocMemory       malloc
#define pmFreeMemory        free

#define writeMethod140()                    \
{                                           \
    __GL_SETUP();                           \
    __GLNV_SETUP();                         \
    NV_CREATE_AND_ASSIGN_PUSHBUF_LOCALS();  \
    nvCurrent[0].u = 0x0004e140;            \
    nvCurrent[1].u = 0x00000001;            \
    nvCurrent += 2;                         \
    NV_GET_SKID_SPACE_IF_NEEDED();          \
}

#define flush()                             \
{                                           \
    __GL_SETUP();                           \
    if (gc) (*gc->procs.finish)(gc);        \
}

#define DPF(_a, _b, _c, _d)

// define TRACE_QUAKE in nvTrace.h
extern int InQuake;
int reset = 1;

#else

#define pmAllocMemory       malloc
#define pmFreeMemory        free

#define writeMethod140()                    _error_
#define flush()                             _error_

#endif

/*
 * macros
 */
#define rdtsc  __asm _emit 0x0f __asm _emit 0x31

/*
 * globals
 */
DWORD g_dwPMTrigger      = PM_REG_PMTRIGGER_DISABLED;
DWORD g_dwPMTriggerCount = 0;
DWORD g_dwPMTriggerValue = 0;

HANDLE         hPMFile              = 0;
PM_PGM_HEADER *pbPMProgramSetup     = NULL;
PM_PGM_HEADER *pbPMProgramStart     = NULL;
PM_PGM_HEADER *pbPMProgramSample    = NULL;
BYTE          *pbPMEventBuffer      = NULL;
DWORD          dwPMEventBufferIndex = 0;
DWORD          dwPMHWLinearBase     = 0;
DWORD          dwPMHWArch           = 0;
DWORD          dwPMFirstTrigger     = 1;
DWORD          dwPMFlags            = 0;

/*
 * pmFlush
 *
 * commit capture buffer to disk
 */
void pmFlush
(
    void
)
{
#ifdef WINNT
#else
    /*
     * commit to disk
     */
    if (dwPMEventBufferIndex)
    {
        DWORD dw;
        WriteFile (hPMFile,pbPMEventBuffer,dwPMEventBufferIndex * sizeof(PM_LOG_EVENT),&dw,NULL);
        FlushFileBuffers (hPMFile);

        /*
         * reset
         */
        dwPMEventBufferIndex = 0;
    }
#endif
}

/*
 * pmLogEvent
 *
 * writes a single event into the log
 */
void pmLogEvent
(
    PM_LOG_EVENT *pEvent
)
{
#ifdef WINNT
#else
    /*
     * store it
     */
    ((PM_LOG_EVENT*)pbPMEventBuffer)[dwPMEventBufferIndex++] = *pEvent;

    /*
     * flush?
     */
    if (dwPMEventBufferIndex >= PM_LOG_EVENT_BUFFER_SIZE)
    {
        pmFlush();
    }
#endif
}

/*
 * pmExecuteProgram
 *
 * executes a program
 */
void pmExecuteProgram
(
    PM_PGM_HEADER *pPgm
)
{
#ifdef WINNT
#else
    /*
     * for all entries
     */
    DWORD dwIndex = 0;
    DWORD dwCount = pPgm->dwEntryCount;
    for (; dwCount; dwIndex++, dwCount--)
    {
        PM_PGM_ENTRY *pEntry = pPgm->Entry + dwIndex;

        if (pEntry->dwFlags & PM_PGM_FLAG_READ)
        {
            PM_LOG_EVENT event;

            /*
             * read operation
             */
            switch (pEntry->dwFlags & PM_PGM_MASK_SIZE)
            {
                case PM_PGM_VAL_SIZE_8:
                {
                    event.dwValueHi = 0;
                    event.dwValueLo = (DWORD)*(BYTE*)(dwPMHWLinearBase + pEntry->dwOffset);
                    DPF ("---pmread8(%08x) -> %02x%08x",pEntry->dwOffset,event.dwValueHi,event.dwValueLo);
                    break;
                }
                case PM_PGM_VAL_SIZE_16:
                {
                    event.dwValueHi = 0;
                    event.dwValueLo = (DWORD)*(WORD*)(dwPMHWLinearBase + pEntry->dwOffset);
                    DPF ("---pmread16(%08x) -> %02x%08x",pEntry->dwOffset,event.dwValueHi,event.dwValueLo);
                    break;
                }
                case PM_PGM_VAL_SIZE_32:
                {
                    event.dwValueHi = 0;
                    event.dwValueLo = (DWORD)*(DWORD*)(dwPMHWLinearBase + pEntry->dwOffset);
                    DPF ("---pmread32(%08x) -> %02x%08x",pEntry->dwOffset,event.dwValueHi,event.dwValueLo);
                    break;
                }
                case PM_PGM_VAL_SIZE_40:
                {
                    DWORD hi;
                    event.dwValueHi = (DWORD)*(BYTE*)(dwPMHWLinearBase + pEntry->dwOffset + 4);
                    do
                    {
                        hi = event.dwValueHi;
                        event.dwValueLo = (DWORD)*(DWORD*)(dwPMHWLinearBase + pEntry->dwOffset);
                        event.dwValueHi = (DWORD)*(BYTE*) (dwPMHWLinearBase + pEntry->dwOffset + 4);
                    } while (hi != event.dwValueHi);
                    DPF ("---pmread40(%08x) -> %02x%08x",pEntry->dwOffset,event.dwValueHi,event.dwValueLo);
                    break;
                }
            }

            /*
             * log it
             */
            pmLogEvent (&event);
        }
        else
        {
            /*
             * write operation
             */
            switch (pEntry->dwFlags & PM_PGM_MASK_SIZE)
            {
                case PM_PGM_VAL_SIZE_8:
                {
                    DPF ("---pmwrite8(%08x) -> %02x%08x",pEntry->dwOffset,pEntry->dwValueHi,pEntry->dwValueLo);
                    *(BYTE*)(dwPMHWLinearBase + pEntry->dwOffset) = (BYTE)pEntry->dwValueLo;
                    break;
                }
                case PM_PGM_VAL_SIZE_16:
                {
                    DPF ("---pmwrite16(%08x) -> %02x%08x",pEntry->dwOffset,pEntry->dwValueHi,pEntry->dwValueLo);
                    *(WORD*)(dwPMHWLinearBase + pEntry->dwOffset) = (WORD)pEntry->dwValueLo;
                    break;
                }
                case PM_PGM_VAL_SIZE_32:
                {
                    DPF ("---pmwrite32(%08x) -> %02x%08x",pEntry->dwOffset,pEntry->dwValueHi,pEntry->dwValueLo);
                    *(DWORD*)(dwPMHWLinearBase + pEntry->dwOffset) = (DWORD)pEntry->dwValueLo;
                    break;
                }
                case PM_PGM_VAL_SIZE_40:
                {
                    DPF ("---pmwrite40(%08x) -> %02x%08x",pEntry->dwOffset,pEntry->dwValueHi,pEntry->dwValueLo);
                    *(BYTE*) (dwPMHWLinearBase + pEntry->dwOffset + 4) = (BYTE) pEntry->dwValueHi;
                    *(DWORD*)(dwPMHWLinearBase + pEntry->dwOffset)     = (DWORD)pEntry->dwValueLo;
                    break;
                }
            }
        }
    }
#endif
}

/*
 * pmConnect
 *
 * connect to PM host (Locutus II)
 */
BOOL pmConnect
(
#if defined(IS_OPENGL)
    HDC hEscapeDC,
#else
    DWORD dwHeadNumber,
#endif
    DWORD dwHWLinearBase,
    DWORD dwArch
)
{
#ifdef WINNT
    return FALSE;
#else
    /*
     * open registry
     */
    DWORD dwSize  = sizeof(DWORD);
    DWORD dwType  = REG_DWORD;
    DWORD dwValue;
    HKEY  hKey;
    HKEY  hPrimaryKey;
    char  szLocalRegPath[128];
    char  szD3DSubKey[256];
    char  szLogFileName[256] = "\\lc2.tmp";
    PM_LOG_HEADER hdr;

    /*
     * save constants
     */
    dwPMHWArch       = dwArch;
    dwPMHWLinearBase = dwHWLinearBase;

    /*
     * get the registry path for this particular device
     * (of the many devices possible in a multi-mon configuration)
     */
#if defined(IS_OPENGL)
    ExtEscape (hEscapeDC,NV_ESC_GET_LOCAL_REGISTRY_PATH,0,NULL,128,szLocalRegPath);
#else
    MyExtEscape (dwHeadNumber,NV_ESC_GET_LOCAL_REGISTRY_PATH,0,NULL,128,szLocalRegPath);
#endif

    /*
     * the first DWORD of the value returned is the primary key (e.g. HKEY_LOCAL_MACHINE)
     */
    hPrimaryKey = (HKEY)(*(DWORD*)szLocalRegPath);

    /*
     * the NV subkey for this device starts after the first four bytes.
     * concatenate this with driver's subtree's name
     */
    sprintf (szD3DSubKey,"%s\\%s",szLocalRegPath + 4,PM_REGISTRY_SUBKEY);

    /*
     * finally open the key
     */
    if (RegOpenKeyEx(hPrimaryKey,szD3DSubKey,0,KEY_ALL_ACCESS,&hKey) == ERROR_SUCCESS)
    {
        /*
         * read master switch
         */
        DWORD dwConnectCount;
        if (!RegQueryValueEx(hKey,
                             PM_REG_CONNECTCOUNT,
                             NULL,
                             &dwType,
                             (LPBYTE)&dwConnectCount,
                             &dwSize) == ERROR_SUCCESS)
        {
            dwConnectCount = 0;
        }

        //
        // read type of trigger
        //
        if (RegQueryValueEx(hKey,
                            PM_REG_PMTRIGGER,
                            NULL,
                            &dwType,
                            (LPBYTE)&dwValue,
                            &dwSize) == ERROR_SUCCESS)
        {
            if (dwValue > PM_REG_PMTRIGGER_MAX) dwValue = PM_REG_PMTRIGGER_DISABLED;
            g_dwPMTrigger = dwValue;
        }

        /*
         * if enabled, read other information
         */
        if (dwConnectCount && (g_dwPMTrigger != PM_REG_PMTRIGGER_DISABLED))
        {
            /*
             * decrement master switch
             */
            dwConnectCount--;
            RegSetValueEx(hKey,
                          PM_REG_CONNECTCOUNT,
                          (unsigned long)NULL,
                          dwType,
                          (LPBYTE)&dwConnectCount,
                          dwSize);

            /*
             * read log file name
             */
            dwType = REG_SZ;
            dwSize = sizeof(szLocalRegPath);
            if (RegQueryValueEx(hKey,
                                PM_REG_LOGFILENAME,
                                NULL,
                                &dwType,
                                (LPBYTE)szLogFileName,
                                &dwSize) != ERROR_SUCCESS)
            {
                pmDisconnect();
                g_dwPMTrigger = 0;
                return FALSE;
            }

            /*
             * read PM trigger count
             */
            dwType = REG_DWORD;
            dwSize = sizeof(DWORD);
            if (RegQueryValueEx(hKey,
                                PM_REG_TRIGGERCOUNT,
                                NULL,
                                &dwType,
                                (LPBYTE)&g_dwPMTriggerCount,
                                &dwSize) != ERROR_SUCCESS)
            {
                pmDisconnect();
                g_dwPMTrigger = 0;
                return FALSE;
            }
            g_dwPMTriggerValue = g_dwPMTriggerCount;

            /*
             * read PM flags
             */
            // no error checking on this for backwards compatability
            dwType = REG_DWORD;
            dwSize = sizeof(DWORD);
            RegQueryValueEx(hKey,
                                PM_REG_FLAGS,
                                NULL,
                                &dwType,
                                (LPBYTE)&dwPMFlags,
                                &dwSize);

            /*
             * read programs
             */
            dwType = REG_BINARY;
            if (RegQueryValueEx(hKey,
                                PM_REG_PROGRAM_SETUP,
                                NULL,
                                &dwType,
                                NULL,
                                &dwSize) == ERROR_SUCCESS)
            {
                pbPMProgramSetup = (PM_PGM_HEADER*)pmAllocMemory(dwSize);
                if (RegQueryValueEx(hKey,
                                    PM_REG_PROGRAM_SETUP,
                                    NULL,
                                    &dwType,
                                    (BYTE*)pbPMProgramSetup,
                                    &dwSize) != ERROR_SUCCESS)
                {
                    pmDisconnect();
                    g_dwPMTrigger = 0;
                    return FALSE;
                }
            }
            else
            {
                pmDisconnect();
                g_dwPMTrigger = 0;
                return FALSE;
            }

            if (RegQueryValueEx(hKey,
                                PM_REG_PROGRAM_START,
                                NULL,
                                &dwType,
                                NULL,
                                &dwSize) == ERROR_SUCCESS)
            {
                pbPMProgramStart = (PM_PGM_HEADER*)pmAllocMemory(dwSize);
                if (RegQueryValueEx(hKey,
                                    PM_REG_PROGRAM_START,
                                    NULL,
                                    &dwType,
                                    (BYTE*)pbPMProgramStart,
                                    &dwSize) != ERROR_SUCCESS)
                {
                    pmDisconnect();
                    g_dwPMTrigger = 0;
                    return FALSE;
                }
            }
            else
            {
                pmDisconnect();
                g_dwPMTrigger = 0;
                return FALSE;
            }

            if (RegQueryValueEx(hKey,
                                PM_REG_PROGRAM_SAMPLE,
                                NULL,
                                &dwType,
                                NULL,
                                &dwSize) == ERROR_SUCCESS)
            {
                pbPMProgramSample = (PM_PGM_HEADER*)pmAllocMemory(dwSize);
                if (RegQueryValueEx(hKey,
                                    PM_REG_PROGRAM_SAMPLE,
                                    NULL,
                                    &dwType,
                                    (BYTE*)pbPMProgramSample,
                                    &dwSize) != ERROR_SUCCESS)
                {
                    pmDisconnect();
                    g_dwPMTrigger = 0;
                    return FALSE;
                }
            }
            else
            {
                pmDisconnect();
                g_dwPMTrigger = 0;
                return FALSE;
            }
        }
        else
        {
            pmDisconnect();
            g_dwPMTrigger = 0;
            return FALSE;
        }

        RegCloseKey(hKey);
    }
    else
    {
        pmDisconnect();
        g_dwPMTrigger = 0;
        return FALSE;
    }

    /*
     * enable PM
     */
    switch (dwPMHWArch)
    {
        case 0x10:        
        case 0x20:
        {
            //
            // enable PM_TRIGGER bit for nv10/nv20
            //
            #define NV_PGRAPH_DEBUG_3                                0x0040008C /* RW-4R */
            #define NV_PGRAPH_DEBUG_3_PM_TRIGGER_ENABLED             0x00000001 /* RW--V */
            #define NV_PGRAPH_DEBUG_3_PM_TRIGGER                          15:15 /* RWIVF */

            DWORD dwAddr = dwPMHWLinearBase + NV_PGRAPH_DEBUG_3;
            DWORD dwBits = *(DWORD*)dwAddr;
            dwBits |= NV_PGRAPH_DEBUG_3_PM_TRIGGER_ENABLED << (0 ? NV_PGRAPH_DEBUG_3_PM_TRIGGER);
            *(DWORD*)dwAddr = dwBits;
            break;
        }                
        default: // HW not supported
        {
            pmDisconnect();
            return FALSE;
        }
    }

    /*
     * open log file
     */
    hPMFile = CreateFile(szLogFileName,GENERIC_WRITE,0,0,CREATE_ALWAYS,0,0);
    if (hPMFile == INVALID_HANDLE_VALUE)
    {
        hPMFile = NULL;
        pmDisconnect();
        return FALSE;
    }

    /*
     * write header
     */
    strcpy (hdr.szID,PM_LOG_ID);
    hdr.dwVersion = PM_LOG_VERSION;
    WriteFile (hPMFile,&hdr,sizeof(hdr) - sizeof(hdr.Event),&dwValue,NULL);

    /*
     * create event buffer
     */
    pbPMEventBuffer = (BYTE*)pmAllocMemory(sizeof(PM_LOG_EVENT) * PM_LOG_EVENT_BUFFER_SIZE);
    if (!pbPMEventBuffer)
    {
        pmDisconnect();
        return FALSE;
    }
    dwPMEventBufferIndex = 0;

    /*
     * setup PM
     */
    pmExecuteProgram (pbPMProgramSetup);

    /*
     * start 1st experiment
     */
#ifdef NVDD32
    pmExecuteProgram (pbPMProgramStart);
    writeMethod140();
    dwPMFirstTrigger = 0;
#endif

    /*
     * done
     */
    return TRUE;
#endif
}

/*
 * pmDisconnect
 *
 * disconnect from PM host
 */
BOOL pmDisconnect
(
    void
)
{
#ifdef WINNT
    return FALSE;
#else
    /*
     * general clean up
     */
    g_dwPMTrigger      = PM_REG_PMTRIGGER_DISABLED;
    g_dwPMTriggerCount = 0;
    g_dwPMTriggerValue = 0;

    /*
     * close log file
     */
    if (hPMFile)
    {
        pmFlush();
        CloseHandle (hPMFile);
        hPMFile = NULL;
    }

    /*
     * free programs
     */
    if (pbPMProgramSetup)
    {
        pmFreeMemory (pbPMProgramSetup);
        pbPMProgramSetup = NULL;
    }
    if (pbPMProgramStart)
    {
        pmFreeMemory (pbPMProgramStart);
        pbPMProgramStart = NULL;
    }
    if (pbPMProgramSample)
    {
        pmFreeMemory (pbPMProgramSample);
        pbPMProgramSample = NULL;
    }

    /*
     * free event buffer
     */
    if (pbPMEventBuffer)
    {
        pmFreeMemory (pbPMEventBuffer);
        pbPMEventBuffer = NULL;
    }

    /*
     * done
     */
    return TRUE;
#endif
}

/*
 * pmSignal
 *
 * signals the end of an experiment
 *  wait for HW flush to capture data.
 *  logs results to log file.
 */
BOOL pmSignal
(
    void
)
{
#ifdef WINNT
    return FALSE;
#else
    PM_LOG_EVENT event;
    BOOL bTimedOut;

    /*
     * Return if this call to pmSignal() is just starting the trigger
     */
    if (dwPMFirstTrigger) {
        pmExecuteProgram (pbPMProgramStart);
        writeMethod140();
        dwPMFirstTrigger = 0;
        return TRUE;
    }

    /*
     * signal end-of-experiment (fe2pm_nop)
     */
    writeMethod140();
    flush();

    /*
     * wait for PM idle
     */
    bTimedOut = FALSE;
    
#if defined(IS_OPENGL)
    if (!(dwPMFlags & PM_FLAGS_IN_QUAKE3) || InQuake) 
    {
        if (reset && (dwPMFlags & PM_FLAGS_IN_QUAKE3))
        {
            reset = 0;
            pmExecuteProgram (pbPMProgramStart);
        }
        else
        {
#endif
            if (!(dwPMFlags & PM_FLAGS_NO_WAIT))
            {
                switch (dwPMHWArch)
                {
                    case 0x10:
                    case 0x20:
                    {
                        DWORD dwAddr    = dwPMHWLinearBase + NV_PPM_CONTROL;
                        DWORD dwBits;
                        DWORD dwTimeout = GetTickCount() + 2000; // 2s timeout window
                        do
                        {
                            bTimedOut   = GetTickCount() >= dwTimeout;
                            dwBits      = *(volatile DWORD*)dwAddr;
                            dwBits    >>= 0 ? NV_PPM_CONTROL_NV_STATE;
                            dwBits     &= (1 << ((1 ? NV_PPM_CONTROL_NV_STATE) - (0 ? NV_PPM_CONTROL_NV_STATE) + 1)) - 1;
                        } while ((dwBits != NV_PPM_CONTROL_STATE_IDLE)
                              && !bTimedOut);
                    }
                }
            }

            /*
             * if PM timed out, we do not log anything but we do reset the PM engine
             */

            if (!bTimedOut)
            {
                /*
                 * log current time
                 */
                __asm
                {
                    rdtsc
                    mov [event.dwValueLo],eax
                    mov [event.dwValueHi],edx
                }
                pmLogEvent (&event);

                /*
                 * sample PM and log events
                 */
                pmExecuteProgram (pbPMProgramSample);
            }
            else
            {
                /*
                 * reset engine by reprogramming state
                 */
                pmExecuteProgram (pbPMProgramSetup);
            }
#if defined(IS_OPENGL)
        }
    }
    else if (dwPMFlags & PM_FLAGS_IN_QUAKE3)
    {
        reset = 1;        
    }
#endif

    /*
     * start next experiment
     */
    if (!(dwPMFlags & PM_FLAGS_NO_RESET))
        pmExecuteProgram (pbPMProgramStart);

    writeMethod140();

    /*
     * done
     */
    return TRUE;
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\common\src\nvOverlaySurf.cpp ===
// **************************************************************************
//
//       Copyright 1993-2001 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// **************************************************************************

#include "nvprecomp.h"
#include "nvOverlaySurf.h"

// A cleaner solution to this would be nice.  Note too that we may have multiple heads
// in different modes; so this is a bit ambiguous. @mjl@
#if (IS_WINNT4 || IS_WINNT5)
#undef GET_MODE_BPP
#define GET_MODE_BPP()           (vpp.m_ppdev->cBitsPerPel)
#endif


static DWORD nvCSCreate4ccIF09(Vpp_t *pVpp, LPDDRAWI_DDRAWSURFACE_LCL pSurf, HANDLE hOverlayOwner, DWORD dwExtraSize, DWORD dwExtraNumSurfaces);
static DWORD nvCSCreate4ccRGB0(Vpp_t *pVpp, LPDDRAWI_DDRAWSURFACE_LCL pSurf);
static DWORD nvCSCreate4ccIF09(Vpp_t *pVpp, LPDDRAWI_DDRAWSURFACE_LCL pSurf, HANDLE hOverlayOwner, DWORD dwExtraSize, DWORD dwExtraNumSurfaces);
static DWORD nvCSCreate4ccYUY2 (Vpp_t *pVpp, LPDDRAWI_DDRAWSURFACE_LCL pSurf, HANDLE hOverlayOwner, DWORD dwExtraSize, DWORD dwExtraNumSurfaces, DWORD dwBlockHeight);
static DWORD nvCSCreate4ccYV12 (Vpp_t *pVpp, LPDDRAWI_DDRAWSURFACE_LCL pSurf, HANDLE hOverlayOwner, DWORD dwExtraSize, DWORD dwExtraNumSurfaces);
#if (IS_WINNT5 || IS_WIN9X)
static DWORD nvCSCreate4ccNVID (Vpp_t *pVpp, LPDDRAWI_DDRAWSURFACE_LCL pSurf, LPDDRAWI_DIRECTDRAW_GBL pDDGbl);
static DWORD nvCSCreate4ccNV12 (Vpp_t *pVpp, LPDDRAWI_DDRAWSURFACE_LCL pSurf, HANDLE hOverlayOwner, DWORD dwExtraSize, DWORD dwExtraNumSurfaces);
static DWORD nvCSCreate4ccNVMC (Vpp_t *pVpp, LPDDRAWI_DDRAWSURFACE_LCL pSurf);
static DWORD nvCSCreate4ccNVSP (Vpp_t *pVpp, LPDDRAWI_DDRAWSURFACE_LCL pSurf);
#endif

//---------------------------------------------------------------------------

static DWORD nvCSCreate4ccRGB0 (Vpp_t *pVpp,LPDDRAWI_DDRAWSURFACE_LCL pSurf)
{
    Vpp_t &vpp = *pVpp;
    DWORD dwPitch;

    DWORD dwModeBPP = GET_MODE_BPP();

    if (pSurf->lpGbl->ddpfSurface.dwFourCC == FOURCC_RAW8) {
        dwPitch = pSurf->lpGbl->wWidth;
    }
    else {
        dwPitch = pSurf->lpGbl->wWidth * (dwModeBPP >> 3);
    }

    dwPitch = (dwPitch + vpp.pDriverData->dwSurfaceAlignPad) & ~vpp.pDriverData->dwSurfaceAlignPad;
    DWORD dwBlockSize = (dwPitch * ((DWORD)pSurf->lpGbl->wHeight));
    if (pSurf->lpGbl->ddpfSurface.dwFourCC == FOURCC_RAW8) {
        pSurf->lpGbl->ddpfSurface.dwRGBBitCount = 8;
        pSurf->lpGbl->ddpfSurface.dwRBitMask = 0;
        pSurf->lpGbl->ddpfSurface.dwGBitMask = 0;
        pSurf->lpGbl->ddpfSurface.dwBBitMask = 0;
    }
    else {
        pSurf->lpGbl->ddpfSurface.dwRGBBitCount = dwModeBPP;
        if (dwModeBPP == 8) {
            pSurf->lpGbl->ddpfSurface.dwRBitMask = 0;
            pSurf->lpGbl->ddpfSurface.dwGBitMask = 0;
            pSurf->lpGbl->ddpfSurface.dwBBitMask = 0;
            pSurf->lpGbl->ddpfSurface.dwFlags |= DDPF_PALETTEINDEXED8;
        }
        else if (dwModeBPP == 16) {
            pSurf->lpGbl->ddpfSurface.dwRBitMask = 0x0000F800;
            pSurf->lpGbl->ddpfSurface.dwGBitMask = 0x000007E0;
            pSurf->lpGbl->ddpfSurface.dwBBitMask = 0x0000001F;

        }
        else if (dwModeBPP == 32) {
            pSurf->lpGbl->ddpfSurface.dwRBitMask = 0x00FF0000;
            pSurf->lpGbl->ddpfSurface.dwGBitMask = 0x0000FF00;
            pSurf->lpGbl->ddpfSurface.dwBBitMask = 0x000000FF;
        }
    }
    pSurf->lpGbl->ddpfSurface.dwRGBAlphaBitMask = 0;
    NV_DBG_SHOW_FOURCC();
    pSurf->lpGbl->lPitch = dwPitch;
    pSurf->lpGbl->fpVidMem = 0;
    pSurf->lpGbl->dwReserved1 = 0;
    pSurf->ddsCaps.dwCaps |= DDSCAPS_HWCODEC;

    if (pSurf->ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY) {
        DWORD dwStatus;
        NVHEAP_ALLOC (dwStatus, pSurf->lpGbl->fpVidMem, dwBlockSize, TYPE_IMAGE);
        if (dwStatus == 0) {
            vpp.pDriverData->DDrawVideoSurfaceCount++;
            pSurf->ddsCaps.dwCaps &= ~DDSCAPS_SYSTEMMEMORY;
            pSurf->ddsCaps.dwCaps |= DDSCAPS_LOCALVIDMEM;
            return (DD_OK);
        }
    }

    return (DDERR_OUTOFMEMORY);
}

//---------------------------------------------------------------------------

static DWORD nvCSCreate4ccIF09 (Vpp_t *pVpp,LPDDRAWI_DDRAWSURFACE_LCL pSurf,
                                HANDLE hOverlayOwner,
                                DWORD dwExtraSize, DWORD dwExtraNumSurfaces)
{
    DWORD dwPitch;
    DWORD i;
    Vpp_t &vpp = *pVpp;

    if ((pSurf->ddsCaps.dwCaps & DDSCAPS_OVERLAY) &&
        (vpp.dwOverlaySurfaces > 0)) {
        if (vpp.overlayRelaxOwnerCheck)
            vpp.dwOverlayOwner = (DWORD)hOverlayOwner;
        if ((vpp.dwOverlayOwner != (DWORD)hOverlayOwner) ||
            (vpp.dwOverlaySurfaces + 1 >= NV_VPP_MAX_OVERLAY_SURFACES)) {
            return (DDERR_OUTOFCAPS);
        }
    }

    dwPitch = ((pSurf->lpGbl->wWidth + 1) & 0xFFFE) << 1;
    dwPitch = (dwPitch + vpp.dwOverlayByteAlignmentPad) & ~vpp.dwOverlayByteAlignmentPad;
    // first alloc some extra space for YUV9 surfaces to format chroma
    DWORD dwBlockSize = (dwPitch >> 1) * (((DWORD)pSurf->lpGbl->wHeight + 3) >> 2);
    // now allocate enough video memory for the Indeo part of the surface
    dwPitch = pSurf->lpGbl->wWidth;
    // allow extra room for block skip bits between Indeo portion of surface and YUY2 portion
    dwBlockSize += ((dwPitch * ((DWORD)pSurf->lpGbl->wHeight * 10L)) >> 3);
    // Force block to be properly aligned
    dwBlockSize = (dwBlockSize + vpp.dwOverlayByteAlignmentPad) & ~vpp.dwOverlayByteAlignmentPad;

    if ((pSurf->ddsCaps.dwCaps & DDSCAPS_OVERLAY) && (vpp.pDriverData->TotalVRAM >> 20 > 4)) {
        // Remember offset to 2nd half YUY2 portion of surface
        pSurf->lpGbl->dwReserved1 = dwBlockSize;
        // reset dwPitch to actual Indeo surface pitch
        dwPitch = pSurf->lpGbl->wWidth;
    }
    else
        pSurf->lpGbl->dwReserved1 = 0;

    pSurf->lpGbl->ddpfSurface.dwYUVBitCount = 9;
    pSurf->lpGbl->ddpfSurface.dwYBitMask = 0;
    pSurf->lpGbl->ddpfSurface.dwUBitMask = 0;
    pSurf->lpGbl->ddpfSurface.dwVBitMask = 0;
    pSurf->lpGbl->ddpfSurface.dwYUVAlphaBitMask = 0;
    NV_DBG_SHOW_FOURCC();
    pSurf->lpGbl->lPitch = dwPitch;
    pSurf->lpGbl->fpVidMem = 0;
    pSurf->ddsCaps.dwCaps |= DDSCAPS_HWCODEC;

    if (pSurf->ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY) {

        DWORD dwStatus;

        if (vpp.extraOverlayOffset[0] == 0 && dwExtraSize > 0) {
            // first time through, allocate extra space for VPP
            NVHEAP_ALLOC (dwStatus, pSurf->lpGbl->fpVidMem, dwBlockSize + dwExtraSize * dwExtraNumSurfaces, TYPE_OVERLAY);
            if (dwExtraNumSurfaces > 0) {
                vpp.extraOverlayOffset[0] = pSurf->lpGbl->fpVidMem - vpp.pDriverData->BaseAddress + dwBlockSize;
                vpp.extraOverlayOffset[0] = (vpp.extraOverlayOffset[0] + NV_TEXTURE_OFFSET_ALIGN) & ~NV_TEXTURE_OFFSET_ALIGN;
            }
            for (i=1; i<dwExtraNumSurfaces; i++) {
                vpp.extraOverlayOffset[i] = vpp.extraOverlayOffset[i-1] + dwExtraSize;
            }
        }
        else {
            NVHEAP_ALLOC (dwStatus, pSurf->lpGbl->fpVidMem, dwBlockSize, TYPE_OVERLAY);
        }

        if (dwStatus == 0) {
            vpp.pDriverData->DDrawVideoSurfaceCount++;
            pSurf->ddsCaps.dwCaps &= ~DDSCAPS_SYSTEMMEMORY;
            pSurf->ddsCaps.dwCaps |= DDSCAPS_LOCALVIDMEM;

            if (pSurf->ddsCaps.dwCaps & DDSCAPS_OVERLAY) {
                DWORD index = 0;
                while ((vpp.dwOverlaySurfaceLCL[index] != 0) &&
                    (index < NV_VPP_MAX_OVERLAY_SURFACES))
                    index++;
                nvAssert(index < NV_VPP_MAX_OVERLAY_SURFACES);
                vpp.dwOverlaySurfaceLCL[index] = (DWORD) pSurf;
                vpp.dwOverlayOwner = (DWORD)hOverlayOwner;
                vpp.dwOverlaySurfaces++;
            }
            return (DD_OK);
        }

        else {
            for (i=0; i<NV_VPP_MAX_EXTRA_SURFACES; i++) {
                vpp.extraOverlayOffset[i] = 0;
            }
            // We can't support overlay surfaces in system memory
            if (pSurf->ddsCaps.dwCaps & DDSCAPS_OVERLAY) {
                return (DDERR_OUTOFMEMORY);
            }
        }

    }

    if (pSurf->ddsCaps.dwCaps & DDSCAPS_OVERLAY) {
        DWORD index = 0;
        while ((vpp.dwOverlaySurfaceLCL[index] != 0) &&
            (index < NV_VPP_MAX_OVERLAY_SURFACES))
            index++;
        nvAssert(index < NV_VPP_MAX_OVERLAY_SURFACES);
        vpp.dwOverlaySurfaceLCL[index] = (DWORD) pSurf;
        vpp.dwOverlayOwner = (DWORD)hOverlayOwner;
        vpp.dwOverlaySurfaces++;
    }

    return (DD_OK);
}

//---------------------------------------------------------------------------
#if (IS_WIN9X || IS_WINNT5)

static DWORD nvCSCreate4ccNV12 (Vpp_t *pVpp, LPDDRAWI_DDRAWSURFACE_LCL pSurf, HANDLE hOverlayOwner,
                         DWORD dwExtraSize, DWORD dwExtraNumSurfaces)
{
    DWORD dwPitch, dwStatus;
    DWORD dwBlockSize;
    DWORD dw422BlockSize;
    int i;
    Vpp_t &vpp = *pVpp;

    if ((pSurf->ddsCaps.dwCaps & DDSCAPS_OVERLAY) &&
        (vpp.dwOverlaySurfaces > 0)) {
        if (vpp.overlayRelaxOwnerCheck)
            vpp.dwOverlayOwner = (DWORD)hOverlayOwner;
        if ((vpp.dwOverlayOwner != (DWORD)hOverlayOwner) ||
            (vpp.dwOverlaySurfaces + 1 >= NV_VPP_MAX_OVERLAY_SURFACES)) {
            return (DDERR_OUTOFCAPS);
        }
    }

    // Round up surface height to an integer multiple of 16 scanlines
    pSurf->lpGbl->wHeight = (pSurf->lpGbl->wHeight + 15) & 0xFFF0;

    dwPitch = (pSurf->lpGbl->wWidth + 3) & ~3;
    dwPitch = (dwPitch + 127) & ~127;                                   // These surfaces MUST be 128 byte aligned so that
    pSurf->lpGbl->lPitch = dwPitch;                                     // when odd field is used as a texture it will be 128 byte aligned
    dwBlockSize = (dwPitch * (DWORD)pSurf->lpGbl->wHeight);       // 420 LUMA portion
    dwBlockSize += (dwPitch * ((DWORD)pSurf->lpGbl->wHeight >> 1));     // 420 CHROMA portion
    dwBlockSize += (8 * dwPitch) + 256;                                 // 8 scanline safety buffer + 16x16 block of 0x80 for Intra Block processing
    dwPitch = (pSurf->lpGbl->wWidth + 3) & ~3;
    dwPitch = ((dwPitch << 1) + 127) & ~127;

//    if ((pSurf->lpGbl->wWidth > 1600) && (vpp.pDriverData->TotalVRAM <= 0x2000000))  // Try to fit 1080i with motion comp in a 32 MB frame buffer
    if (pSurf->lpGbl->wWidth > 1600) // Our hardware isn't fast enough or memory efficient enough yet, always run 1080i in crippled mode
    {
        if ((vpp.pSysInfo->dwNVClasses & NVCLASS_FAMILY_KELVIN) &&
            (vpp.pDriverData->TotalVRAM > 0x2000000)) {
            vpp.pDriverData->bMCOverlaySrcIsSingleField1080i = FALSE;
            dw422BlockSize = (dwPitch * (DWORD)pSurf->lpGbl->wHeight);    // 422 portion
        } else {   
            vpp.pDriverData->bMCOverlaySrcIsSingleField1080i = TRUE;
            dw422BlockSize = (dwPitch * (DWORD)((pSurf->lpGbl->wHeight + 2) >> 1));    // 422 portion
        }
        if ((vpp.pSysInfo->dwNVClasses & NVCLASS_1196_CELSIUS) && 
            (!(vpp.pSysInfo->dwNVClasses & NVCLASS_FAMILY_KELVIN)))
            vpp.pDriverData->bMCHorizontallyDownscale1080i = TRUE;
        else
            vpp.pDriverData->bMCHorizontallyDownscale1080i = FALSE;
    } else if ((pSurf->lpGbl->wWidth > 1024) && 
               (vpp.pSysInfo->dwNVClasses & NVCLASS_1196_CELSIUS) &&
               (!(vpp.pSysInfo->dwNVClasses & NVCLASS_FAMILY_KELVIN))) { // actually this is 720p
        vpp.pDriverData->bMCOverlaySrcIsSingleField1080i = TRUE;
        vpp.pDriverData->bMCHorizontallyDownscale1080i = TRUE;
        dw422BlockSize = (dwPitch * (DWORD)pSurf->lpGbl->wHeight);    // 422 portion
    } else {
        vpp.pDriverData->bMCOverlaySrcIsSingleField1080i = FALSE;
        vpp.pDriverData->bMCHorizontallyDownscale1080i = FALSE;
        dw422BlockSize = (dwPitch * (DWORD)pSurf->lpGbl->wHeight);    // 422 portion
    }

    // Only allocate extra space for temporal filtering if it's allowed.
    // This decision was made earlier when the NVMC surface was created.
    if (vpp.pDriverData->bMCTemporalFilterDisabled < 2) {
        if (pSurf->lpGbl->wWidth < 1024)
            dw422BlockSize += (dwPitch * (DWORD)pSurf->lpGbl->wHeight);     // another 422 portion for filtering
    }

    pSurf->lpGbl->ddpfSurface.dwYUVBitCount = 12;
    pSurf->lpGbl->ddpfSurface.dwYBitMask = 0;
    pSurf->lpGbl->ddpfSurface.dwUBitMask = 0;
    pSurf->lpGbl->ddpfSurface.dwVBitMask = 0;
    pSurf->lpGbl->ddpfSurface.dwYUVAlphaBitMask = 0;
    NV_DBG_SHOW_FOURCC();
    pSurf->lpGbl->dwReserved1 = 0;
    pSurf->lpGbl->fpVidMem = 0;
    pSurf->ddsCaps.dwCaps |= DDSCAPS_HWCODEC;

    // Let overlay code know that we haven't got enough extra video memory for front end downscaling
    if ((vpp.pDriverData->NvDeviceVersion >= NV_DEVICE_VERSION_10) &&  (dwExtraNumSurfaces >= 2)) {
        if (vpp.pDriverData->TotalVRAM <= 0x1000000) {
            vpp.extraNumSurfaces = 0;
            dwExtraNumSurfaces = 0;
        }
    }

    if ((pSurf->ddsCaps.dwCaps & DDSCAPS_OVERLAY) && (vpp.extraOverlayOffset[0] == 0) && (dwExtraSize > 0) && (dwExtraNumSurfaces > 0)) {
        // first time through, allocate extra space for VPP
        NVHEAP_ALLOC (dwStatus, pSurf->lpGbl->fpVidMem, dwBlockSize + dw422BlockSize + dwExtraSize * dwExtraNumSurfaces, TYPE_OVERLAY);
        if (dwExtraNumSurfaces > 0) {
            vpp.extraOverlayOffset[0] = pSurf->lpGbl->fpVidMem - vpp.pDriverData->BaseAddress + dwBlockSize + dw422BlockSize;
        }
        for (i=1; i<(int)dwExtraNumSurfaces; i++) {
            vpp.extraOverlayOffset[i] = vpp.extraOverlayOffset[i-1] + dwExtraSize;
        }
    } else {
        NVHEAP_ALLOC (dwStatus, pSurf->lpGbl->fpVidMem, dwBlockSize + dw422BlockSize, TYPE_OVERLAY);
    }

    if (dwStatus == 0) {
        vpp.pDriverData->DDrawVideoSurfaceCount++;
        pSurf->ddsCaps.dwCaps |= (DDSCAPS_VIDEOMEMORY | DDSCAPS_LOCALVIDMEM);
        pSurf->ddsCaps.dwCaps &= ~DDSCAPS_SYSTEMMEMORY;

        // Clear Intra block area to 0x80 bias value 
        // Actually, clear entire 420 surface to gray which avoids prediction pixel blending problems at edges of video image
        memset((char *)(VIDMEM_ADDR(pSurf->lpGbl->fpVidMem)), 128, dwBlockSize);
        // <<<NOTE>>>: Uncomment the following line if line above is ever removed
        // memset((char *)(VIDMEM_ADDR(pSurf->lpGbl->fpVidMem) + dwBlockSize - 256), 128, 256);

        // find a free surface
        for (i=0; i<8; i++) {
            if (vpp.pDriverData->dwMCNV12Surface[i] == 0) {
                break;
            }
        }

        if (i == 8) {
            // no free surfaces
            NVHEAP_FREE(pSurf->lpGbl->fpVidMem);
            vpp.pDriverData->DDrawVideoSurfaceCount--;
            return (DDERR_OUTOFCAPS);
        }

        vpp.pDriverData->dwMCNV12Surface[i] = (DWORD)pSurf;

        if (i==0) {
            vpp.pDriverData->nvMCSurfaceFlags[8].dwMCSurfaceBase = 0; // End of list marker
            vpp.pDriverData->dwMCDestinationSurface = (DWORD)pSurf;
        }

        vpp.pDriverData->nvMCSurfaceFlags[i].dwMCSurfaceBase = pSurf->lpGbl->fpVidMem;
        vpp.pDriverData->nvMCSurfaceFlags[i].dwMCSurface422Offset = pSurf->lpGbl->fpVidMem + dwBlockSize - vpp.pDriverData->BaseAddress;

        vpp.pDriverData->nvMCSurfaceFlags[i].dwMCMotionCompReferenceCount =
        vpp.pDriverData->nvMCSurfaceFlags[i].dwMCFormatCnvReferenceCount =
        vpp.pDriverData->nvMCSurfaceFlags[i].dwMCCompositeReferenceCount =
        vpp.pDriverData->nvMCSurfaceFlags[i].dwMCTemporalFilterReferenceCount = vpp.pDriverData->pRefCount->inc (CReferenceCount::INC_IMMEDIATE);

    } else {
        i = 8;
        while (--i >= 0) {
            if (vpp.pDriverData->nvMCSurfaceFlags[i].dwMCSurfaceBase != 0) {
                NVHEAP_FREE(vpp.pDriverData->nvMCSurfaceFlags[i].dwMCSurfaceBase);
                vpp.pDriverData->nvMCSurfaceFlags[i].dwMCSurfaceBase = 0;
                if (vpp.pDriverData->DDrawVideoSurfaceCount > 0)
                    vpp.pDriverData->DDrawVideoSurfaceCount--;
                if (vpp.dwOverlaySurfaces > 0)
                    vpp.dwOverlaySurfaces--;
                pSurf = (LPDDRAWI_DDRAWSURFACE_LCL)vpp.pDriverData->dwMCNV12Surface[i];
                vpp.pDriverData->dwMCNV12Surface[i] = 0;
                pSurf->lpGbl->fpVidMem = 0;
            }
        }
        if (vpp.dwOverlaySurfaces == 0) {
            vpp.dwOverlayOwner = 0;
            for (i=0; i<NV_VPP_MAX_EXTRA_SURFACES; i++) {
                vpp.extraOverlayOffset[i] = 0;
            }
            vpp.extraNumSurfaces = 0;
        }
        // We can't support overlay surfaces in system memory
        return (DDERR_OUTOFMEMORY);
    }

    if (pSurf->ddsCaps.dwCaps & DDSCAPS_OVERLAY) {
        DWORD index = 0;
        while ((vpp.dwOverlaySurfaceLCL[index] != 0) &&
            (index < NV_VPP_MAX_OVERLAY_SURFACES))
            index++;
        nvAssert(index < NV_VPP_MAX_OVERLAY_SURFACES);
        vpp.dwOverlaySurfaceLCL[index] = (DWORD) pSurf;
        vpp.dwOverlayOwner = (DWORD)hOverlayOwner;
        vpp.dwOverlaySurfaces++;
    }

    return (DD_OK);
}
#endif


//---------------------------------------------------------------------------

#if (IS_WIN9X || IS_WINNT5)
static DWORD nvCSCreate4ccNVMC (Vpp_t *pVpp, LPDDRAWI_DDRAWSURFACE_LCL pSurf)
{
    DWORD dwStatus, i;
    DWORD dwBlockSize = 256;
    Vpp_t &vpp = *pVpp;

    NV_DBG_SHOW_FOURCC();

    pSurf->lpGbl->lPitch = 16;
    pSurf->lpGbl->dwReserved1 = 0;
    pSurf->lpGbl->fpVidMem = 0;
    pSurf->ddsCaps.dwCaps |= DDSCAPS_HWCODEC;

    // Currently we only support one motion comp session only because the display function only works with our 1 overlay
    if (pSurf->lpGbl->ddpfSurface.dwFourCC == FOURCC_NVMC) {

        if (vpp.pDriverData->dwMCNVMCSurface == 0) {

            NVHEAP_ALLOC (dwStatus, pSurf->lpGbl->fpVidMem, dwBlockSize, TYPE_IMAGE);

            if (dwStatus == 0) {
                vpp.pDriverData->DDrawVideoSurfaceCount++;
                pSurf->ddsCaps.dwCaps |= (DDSCAPS_VIDEOMEMORY | DDSCAPS_LOCALVIDMEM);
                pSurf->ddsCaps.dwCaps &= ~DDSCAPS_SYSTEMMEMORY;
                vpp.pDriverData->dwMCNVMCSurface = (DWORD)pSurf;

                // If frame buffer is 16MB, don't allow temporal filtering, to save room
                // for higher resolutions and video mirror buffers.
                // Possible values for bMCTemporalFilterDisabled:
                // 0 = temporal filtering enabled.
                // 1 = temporal filtering disabled but allowed (temporal space in NV12 buffers.)
                // 2 = temporal filtering disabled and not allowed (no temporal space in NV12 buffers.)
                if (vpp.pDriverData->TotalVRAM < 0x2000000)
                    vpp.pDriverData->bMCTemporalFilterDisabled = 2;
                else
                    vpp.pDriverData->bMCTemporalFilterDisabled = FALSE; // Default mode is enabled

                vpp.pDriverData->bMCPercentCurrentField = 65;       // Default temporal filter combination factor
                vpp.pDriverData->bMCOverlaySrcIsSingleField1080i = FALSE; // This is only needed to support 1080i in 32MB
                vpp.pDriverData->bMCHorizontallyDownscale1080i = FALSE; // This is only needed to support 1080i on NV15 or lower
                vpp.pDriverData->dwMCMostRecentlyDecodedSurfaceBase = -1;
                for (i=0; i<8; i++) {
                    vpp.pDriverData->dwMCNV12Surface[i] = 0;
                }
                for (i=0; i<9; i++) {
                    vpp.pDriverData->nvMCSurfaceFlags[i].dwMCSurfaceBase = 0;
                }
            }
            else {
                return (DDERR_OUTOFMEMORY);
            }

        } else {
            return (DDERR_OUTOFCAPS);
        }

    }

    else {

        if (vpp.pDriverData->dwMCNVDSSurfaceBase == 0) {

            NVHEAP_ALLOC (dwStatus, pSurf->lpGbl->fpVidMem, dwBlockSize, TYPE_IMAGE);

            if (dwStatus == 0) {
                vpp.pDriverData->dwMCNVDSSurfaceBase = pSurf->lpGbl->fpVidMem;
                vpp.pDriverData->DDrawVideoSurfaceCount++;
                pSurf->ddsCaps.dwCaps |= (DDSCAPS_VIDEOMEMORY | DDSCAPS_LOCALVIDMEM);
                pSurf->ddsCaps.dwCaps &= ~DDSCAPS_SYSTEMMEMORY;
            }
            else {
                return (DDERR_OUTOFMEMORY);
            }
        } else {
            pSurf->lpGbl->fpVidMem = vpp.pDriverData->dwMCNVDSSurfaceBase;
        }
    }

    return (DD_OK);
}
#endif

//---------------------------------------------------------------------------
#if (IS_WIN9X || IS_WINNT5)
static DWORD nvCSCreate4ccNVSP (Vpp_t *pVpp, LPDDRAWI_DDRAWSURFACE_LCL pSurf)
{
    DWORD dwPitch, dwStatus;
    Vpp_t &vpp = *pVpp;

    pSurf->lpGbl->ddpfSurface.dwRGBBitCount = 8;
    pSurf->lpGbl->ddpfSurface.dwRBitMask = 0;
    pSurf->lpGbl->ddpfSurface.dwGBitMask = 0;
    pSurf->lpGbl->ddpfSurface.dwBBitMask = 0;
    pSurf->lpGbl->ddpfSurface.dwRGBAlphaBitMask = 8;

    // Round up surface height to an integer multiple of 16 scanlines
    pSurf->lpGbl->wHeight = (pSurf->lpGbl->wHeight + 15) & 0xFFF0;

    dwPitch = ((pSurf->lpGbl->wWidth + 1) & 0xFFFE);
    dwPitch = (dwPitch + 127) & ~127;
    pSurf->lpGbl->lPitch = dwPitch;
    DWORD dwBlockSize = dwPitch * (DWORD)pSurf->lpGbl->wHeight; // calculate size of 8 bit index per pixel plane
    dwBlockSize <<= 1;  // double size to include 8 bit alpha per pixel plane
    dwBlockSize += (dwBlockSize << 1); // increase to include fully decompressed 32 bit per pixel plane
    dwBlockSize += 1024; // include room for indexed image look up table
    dwPitch = (pSurf->lpGbl->wWidth + 3) & ~3;
    dwPitch = ((dwPitch << 1) + 127) & ~127;
    dwBlockSize += (dwPitch * (DWORD)pSurf->lpGbl->wHeight);    // 422 work area for repairing NV12 surfaces
    NV_DBG_SHOW_FOURCC();
    pSurf->lpGbl->dwReserved1 = 0;
    pSurf->lpGbl->fpVidMem = 0;
    pSurf->ddsCaps.dwCaps |= DDSCAPS_HWCODEC;

    NVHEAP_ALLOC (dwStatus, pSurf->lpGbl->fpVidMem, dwBlockSize, TYPE_IMAGE);

    if (dwStatus == 0) {
        vpp.pDriverData->DDrawVideoSurfaceCount++;
        pSurf->ddsCaps.dwCaps |= (DDSCAPS_VIDEOMEMORY | DDSCAPS_LOCALVIDMEM);
        pSurf->ddsCaps.dwCaps &= ~DDSCAPS_SYSTEMMEMORY;
        vpp.pDriverData->dwMCNVSPSurface = (DWORD)pSurf;
    }
    else { // We could but currently don't support system memory subpictures
        return (DDERR_OUTOFMEMORY);
    }

    return (DD_OK);
}
#endif

//---------------------------------------------------------------------------
#if (IS_WINNT5 || IS_WIN9X)
static DWORD nvCSCreate4ccNVID (Vpp_t *pVpp, LPDDRAWI_DDRAWSURFACE_LCL pSurf, LPDDRAWI_DIRECTDRAW_GBL pDDGbl)
{
    DWORD dwPitch, dwIndex;
    Vpp_t &vpp = *pVpp;

    // find an unused surface
    for (dwIndex=0; dwIndex<4; dwIndex++) {
        if (vpp.pDriverData->dwMCIDCTAGPSurfaceBase[dwIndex] == 0) {
            break;
        }
    }
    if (dwIndex == 4) {
        return (DDERR_OUTOFCAPS);
    }

    pSurf->lpGbl->ddpfSurface.dwYUVBitCount = 8;
    pSurf->lpGbl->ddpfSurface.dwYBitMask = 0;
    pSurf->lpGbl->ddpfSurface.dwUBitMask = 0;
    pSurf->lpGbl->ddpfSurface.dwVBitMask = 0;
    pSurf->lpGbl->ddpfSurface.dwYUVAlphaBitMask = 0;

    pSurf->lpGbl->fpVidMem = 0;
    pSurf->lpGbl->dwReserved1 = 0;
    pSurf->ddsCaps.dwCaps |= DDSCAPS_HWCODEC;

    dwPitch = ((pSurf->lpGbl->wWidth + 1) & 0xFFFE);

    LONG adjustedHeight = (DWORD)((pSurf->lpGbl->wHeight + 1) & ~1);

    DWORD dwBlockSize = dwPitch * adjustedHeight;

    // pad the surface enough to be able to align it's base pointer to 256 bytes and it's size to end at 0xFF
    dwBlockSize += 1024;
    NV_DBG_SHOW_FOURCC();
    // now allocate enough AGP memory for the surface
    dwPitch = pSurf->lpGbl->wWidth;
    pSurf->lpGbl->lPitch = dwPitch;

    FLATPTR fpVidMem = 0;
    DWORD   dwStatus;

    NVHEAP_ALLOC (dwStatus, pSurf->lpGbl->fpVidMem, dwBlockSize, TYPE_IMAGE);

    if (dwStatus == 0) {
        // save initial unadjusted memory pointer for use when destroying this surface
        pSurf->lpGbl->dwReserved1 = pSurf->lpGbl->fpVidMem;
        pSurf->lpGbl->fpVidMem = (pSurf->lpGbl->fpVidMem + 511) & ~255;
        pSurf->ddsCaps.dwCaps |= (DDSCAPS_VIDEOMEMORY | DDSCAPS_LOCALVIDMEM);
        vpp.pDriverData->DDrawVideoSurfaceCount++;

    } else {
        return (DDERR_OUTOFMEMORY);
    }

    // Make sure we reset this on next use
    vpp.pDriverData->dwMCCurrentCelsiusIDCTCtxDma = 0;

    nvAssert (dwIndex < 4);
    if (vpp.pDriverData->dwMCIDCTAGPCtxDmaSize[dwIndex] != 0) {
        NvRmFree(vpp.pDriverData->dwRootHandle, vpp.pDriverData->dwRootHandle,
                 NV_DD_DMA_FLOATING_MC_IDCT0_CONTEXT_DMA_FROM_MEMORY+dwIndex);
        vpp.pDriverData->dwMCIDCTAGPCtxDmaSize[dwIndex] = 0;
    }
    vpp.pDriverData->dwMCNVIDSurface[dwIndex] = (DWORD)pSurf;
    vpp.pDriverData->dwMCNVIDSurfaceReferenceCount[dwIndex] = vpp.pDriverData->pRefCount->inc (CReferenceCount::INC_IMMEDIATE);
    vpp.pDriverData->dwMCIDCTAGPSurfaceBase[dwIndex] = (DWORD)pSurf->lpGbl->fpVidMem;

    return (DD_OK);
}
#endif

//---------------------------------------------------------------------------

static DWORD nvCSCreate4ccYUY2 (Vpp_t *pVpp, LPDDRAWI_DDRAWSURFACE_LCL pSurf,
                         HANDLE hOverlayOwner,
                         DWORD dwExtraSize, DWORD dwExtraNumSurfaces, DWORD dwBlockHeight)
{
    DWORD dwPitch, dwStatus;
    DWORD i;
    Vpp_t &vpp = *pVpp;

    if ((pSurf->ddsCaps.dwCaps & DDSCAPS_OVERLAY) &&
        (vpp.dwOverlaySurfaces > 0)) {
        if (vpp.overlayRelaxOwnerCheck)
            vpp.dwOverlayOwner = (DWORD)hOverlayOwner;
        if ((vpp.dwOverlayOwner != (DWORD)hOverlayOwner) ||
            (vpp.dwOverlaySurfaces + 1 >= NV_VPP_MAX_OVERLAY_SURFACES)) {
            return (DDERR_OUTOFCAPS);
        }
    }

    // First try video memory
    dwPitch = ((pSurf->lpGbl->wWidth + 1) & 0xFFFE) << 1;
    dwPitch = (dwPitch + vpp.dwOverlayByteAlignmentPad) & ~vpp.dwOverlayByteAlignmentPad;
    if ((vpp.regOverlayMode & (NV4_REG_OVL_MODE_TFILTER | NV4_REG_OVL_MODE_DFILTER)) &&
        (vpp.pDriverData->NvDeviceVersion >= NV_DEVICE_VERSION_10)) {
        // texture alignment
        dwPitch = (dwPitch + NV_TEXTURE_OFFSET_ALIGN) & ~NV_TEXTURE_OFFSET_ALIGN;
    }

    DWORD dwBlockSize = (dwPitch * pSurf->lpGbl->wHeight);  // default block size

    pSurf->lpGbl->ddpfSurface.dwYUVBitCount = 16;
    if (pSurf->lpGbl->ddpfSurface.dwFourCC == FOURCC_YUY2) {
        pSurf->lpGbl->ddpfSurface.dwYBitMask = 0x00FF00FF;
        pSurf->lpGbl->ddpfSurface.dwUBitMask = 0x0000FF00;
        pSurf->lpGbl->ddpfSurface.dwVBitMask = 0xFF000000;
    }
    else {
        pSurf->lpGbl->ddpfSurface.dwYBitMask = 0xFF00FF00;
        pSurf->lpGbl->ddpfSurface.dwUBitMask = 0x000000FF;
        pSurf->lpGbl->ddpfSurface.dwVBitMask = 0x00FF0000;
    }
    pSurf->lpGbl->ddpfSurface.dwYUVAlphaBitMask = 0;
    NV_DBG_SHOW_FOURCC();

    pSurf->lpGbl->lPitch = dwPitch;
    pSurf->lpGbl->dwReserved1 = 0;
    pSurf->lpGbl->fpVidMem = 0;
    pSurf->ddsCaps.dwCaps |= DDSCAPS_HWCODEC;

    if ((pSurf->ddsCaps.dwCaps & DDSCAPS_OVERLAY) && (vpp.pDriverData->TotalVRAM >> 20 > 4)) {
        // Remember offset to 2nd half of surface
        pSurf->lpGbl->dwReserved1 = dwBlockSize;
    }

    if ((pSurf->ddsCaps.dwCaps & DDSCAPS_OVERLAY) && vpp.extraOverlayOffset[0] == 0 && dwExtraSize > 0) {
        // first time through, allocate extra space for VPP
        NVHEAP_ALLOC (dwStatus, pSurf->lpGbl->fpVidMem, dwBlockSize + dwExtraSize * dwExtraNumSurfaces, TYPE_OVERLAY);
        if (dwExtraNumSurfaces > 0) {
            vpp.extraOverlayOffset[0] = pSurf->lpGbl->fpVidMem - vpp.pDriverData->BaseAddress + dwBlockSize;
        }
        for (i=1; i<dwExtraNumSurfaces; i++) {
            vpp.extraOverlayOffset[i] = vpp.extraOverlayOffset[i-1] + dwExtraSize;
        }

    }
    else {
        // NV10 mediaport has a bug where it might write up to extra 256 bytes.
        // Workaround this bug by allocating a 256 byte guard band for all UYVY
        // surfaces.  Unfortunately, even non-videoport surfaces now get this guard band.
        if ((vpp.pDriverData->NvDeviceVersion >= NV_DEVICE_VERSION_10) &&
            (pSurf->lpGbl->ddpfSurface.dwFourCC == FOURCC_UYVY)) {
            dwBlockSize += 256;
        }
        NVHEAP_ALLOC (dwStatus, pSurf->lpGbl->fpVidMem, dwBlockSize, TYPE_OVERLAY);
    }

    if (dwStatus == 0) {
        vpp.pDriverData->DDrawVideoSurfaceCount++;
        pSurf->ddsCaps.dwCaps |= (DDSCAPS_VIDEOMEMORY | DDSCAPS_LOCALVIDMEM);
        pSurf->ddsCaps.dwCaps &= ~DDSCAPS_SYSTEMMEMORY;
    }
    else {
        for (i=0; i<NV_VPP_MAX_EXTRA_SURFACES; i++) {
            vpp.extraOverlayOffset[i] = 0;
        }

        return (DDERR_OUTOFMEMORY);
    }

    if (pSurf->ddsCaps.dwCaps & DDSCAPS_OVERLAY) {
        DWORD index = 0;
        while ((vpp.dwOverlaySurfaceLCL[index] != 0) &&
            (index < NV_VPP_MAX_OVERLAY_SURFACES))
            index++;
        nvAssert(index < NV_VPP_MAX_OVERLAY_SURFACES);
        vpp.dwOverlaySurfaceLCL[index] = (DWORD) pSurf;
        vpp.dwOverlayOwner = (DWORD)hOverlayOwner;
        vpp.dwOverlaySurfaces++;
    }

    return (DD_OK);
}
//---------------------------------------------------------------------------

static DWORD nvCSCreate4ccYV12 (Vpp_t *pVpp, LPDDRAWI_DDRAWSURFACE_LCL pSurf,
                         HANDLE hOverlayOwner,
                         DWORD dwExtraSize, DWORD dwExtraNumSurfaces)
{
    DWORD dwPitch, dwStatus;
    DWORD i;
    Vpp_t &vpp = *pVpp;

    if ((pSurf->ddsCaps.dwCaps & DDSCAPS_OVERLAY) &&
        (vpp.dwOverlaySurfaces > 0)) {
        if (vpp.overlayRelaxOwnerCheck)
            vpp.dwOverlayOwner = (DWORD)hOverlayOwner;
        if ((vpp.dwOverlayOwner != (DWORD)hOverlayOwner) ||
            (vpp.dwOverlaySurfaces + 1 >= NV_VPP_MAX_OVERLAY_SURFACES)) {
            return(DDERR_OUTOFCAPS);
        }
    }

    dwPitch = pSurf->lpGbl->wWidth;
    // allow extra room for block skip bits between Indeo portion of surface and YUY2 portion
    DWORD dwBlockSize = ((dwPitch * ((DWORD)pSurf->lpGbl->wHeight * 12L)) >> 3);
    // Force block to be properly aligned
    dwBlockSize = (dwBlockSize + vpp.dwOverlayByteAlignmentPad) & ~vpp.dwOverlayByteAlignmentPad;

    if ((pSurf->ddsCaps.dwCaps & DDSCAPS_OVERLAY) && (vpp.pDriverData->TotalVRAM >> 20 > 4)) {
        // Remember offset to 2nd half YUY2 portion of surface
        pSurf->lpGbl->dwReserved1 = dwBlockSize;
        // reset dwPitch to actual Indeo surface pitch
        dwPitch = pSurf->lpGbl->wWidth;
    }
    else {
        pSurf->lpGbl->dwReserved1 = 0;
    }

    pSurf->lpGbl->ddpfSurface.dwYUVBitCount = 9;
    pSurf->lpGbl->ddpfSurface.dwYBitMask = 0;
    pSurf->lpGbl->ddpfSurface.dwUBitMask = 0;
    pSurf->lpGbl->ddpfSurface.dwVBitMask = 0;
    pSurf->lpGbl->ddpfSurface.dwYUVAlphaBitMask = 0;
    NV_DBG_SHOW_FOURCC();
    pSurf->lpGbl->lPitch = dwPitch;
    pSurf->lpGbl->fpVidMem = 0;
    pSurf->ddsCaps.dwCaps |= DDSCAPS_HWCODEC;

    if (pSurf->ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY) {

        if (vpp.extraOverlayOffset[0] == 0 && dwExtraSize > 0) {
            // first time through, allocate extra space for VPP
            NVHEAP_ALLOC (dwStatus, pSurf->lpGbl->fpVidMem, dwBlockSize + dwExtraSize * dwExtraNumSurfaces, TYPE_OVERLAY);
            if (dwExtraNumSurfaces > 0) {
                vpp.extraOverlayOffset[0] = pSurf->lpGbl->fpVidMem - vpp.pDriverData->BaseAddress + dwBlockSize;
            }
            for (i=1; i<dwExtraNumSurfaces; i++) {
                vpp.extraOverlayOffset[i] = vpp.extraOverlayOffset[i-1] + dwExtraSize;
            }
        }
        else {
            NVHEAP_ALLOC (dwStatus, pSurf->lpGbl->fpVidMem, dwBlockSize, TYPE_OVERLAY);
        }

        if (dwStatus == 0) {
            vpp.pDriverData->DDrawVideoSurfaceCount++;
            pSurf->ddsCaps.dwCaps &= ~DDSCAPS_SYSTEMMEMORY;
            pSurf->ddsCaps.dwCaps |= DDSCAPS_LOCALVIDMEM;

            if (pSurf->ddsCaps.dwCaps & DDSCAPS_OVERLAY) {
                DWORD index = 0;
                while ((vpp.dwOverlaySurfaceLCL[index] != 0) &&
                       (index < NV_VPP_MAX_OVERLAY_SURFACES))
                    index++;
                nvAssert(index < NV_VPP_MAX_OVERLAY_SURFACES);
                vpp.dwOverlaySurfaceLCL[index] = (DWORD)pSurf;
                vpp.dwOverlayOwner = (DWORD)hOverlayOwner;
                vpp.dwOverlaySurfaces++;
            }

            return (DD_OK);
        }
        else {
            for (i=0; i<NV_VPP_MAX_EXTRA_SURFACES; i++) {
                vpp.extraOverlayOffset[i] = 0;
            }
            // We can't support overlay surfaces in system memory
            if (pSurf->ddsCaps.dwCaps & DDSCAPS_OVERLAY) {
                return(DDERR_OUTOFMEMORY);
            }
        }
    }

    if (pSurf->ddsCaps.dwCaps & DDSCAPS_OVERLAY) {
        DWORD index = 0;
        while ((vpp.dwOverlaySurfaceLCL[index] != 0) &&
               (index < NV_VPP_MAX_OVERLAY_SURFACES))
            index++;
        nvAssert(index < NV_VPP_MAX_OVERLAY_SURFACES);
        vpp.dwOverlaySurfaceLCL[index] = (DWORD) pSurf;
        vpp.dwOverlayOwner = (DWORD)hOverlayOwner;
        vpp.dwOverlaySurfaces++;
    }

    return (DD_OK);
}
//---------------------------------------------------------------------------
// figure out how much extra space is required for video post processing
// dwExtraSize is the size of one workspace surface, for NV4/5 we need 4,
// for NV10 we need 3.  For superpipelining, we need 8 or 5.
//
//

extern void VppCalcExtraSurfaceSpace(Vpp_t *pVpp, LPDDRAWI_DDRAWSURFACE_LCL pDDSLcl, NvU32 dwDisplayHeight, NvU32 dwRequestedSurfaces,
                         NvU32 *dwExtraSize, NvU32 *dwExtraNumSurfaces, NvU32 *dwBlockHeight)
{
    DWORD dwPitch;
    Vpp_t &vpp = *pVpp;

    dbgTracePush ("nvCSCalcExtraSpace");

    *dwExtraSize = 0;
    *dwExtraNumSurfaces = 0;

    if (dwDisplayHeight > 768) {
        // disable HQVUp for resolutions greater than 1024x768
        vpp.regOverlayMode &= ~NV4_REG_OVL_MODE_VUPSCALE;
    }

    // find the height
    if (vpp.regOverlayMode & NV4_REG_OVL_MODE_VUPSCALE)
    {
        *dwBlockHeight = dwDisplayHeight;
    }
    else
    {
        *dwBlockHeight = (DWORD)pDDSLcl->lpGbl->wHeight;
    }

    if (IS_OVERLAY(pDDSLcl->ddsCaps.dwCaps, pDDSLcl->lpGbl->ddpfSurface.dwFourCC)) {

#if (IS_WINNT5 || IS_WIN9X)
        // just set this to something valid for now
        vpp.pDriverData->dwMCDestinationSurface = (DWORD)(pDDSLcl);
#endif

        // OPTIMIZEME: we can bring down the number of required surfaces to 2 if we
        // know that the VPP pipe is only going to use a single stage.
        if (vpp.pDriverData->NvDeviceVersion < NV_DEVICE_VERSION_10) {
            *dwExtraNumSurfaces = vpp.regVPPMaxSurfaces;
        } else {
            *dwExtraNumSurfaces = vpp.regVPPMaxSurfaces; // OPTIMIZEME: eventually want to make this 5 for NV10
        }

        // if less than 16M, then default to unpipelined VPP
        if (vpp.pDriverData->TotalVRAM < 0x1000000) {
            *dwExtraNumSurfaces = min(*dwExtraNumSurfaces, 4);
        }

        // find the YUYV pitch
        dwPitch = ((pDDSLcl->lpGbl->wWidth + 1) & 0xFFFE) << 1;
        dwPitch = (dwPitch + vpp.dwOverlayByteAlignmentPad) & ~vpp.dwOverlayByteAlignmentPad;
        *dwExtraSize = (dwPitch * *dwBlockHeight);
        vpp.extraPitch = dwPitch;

        if (vpp.regOverlayMode & (NV4_REG_OVL_MODE_TFILTER | NV4_REG_OVL_MODE_DFILTER)) {

            if (vpp.pDriverData->NvDeviceVersion < NV_DEVICE_VERSION_10) {

                // NV5 requires textures to have dimensions which are a power of 2
                DWORD dwBigPitch;

                // will be using texture unit, so must be a power of 2.
                // round up to the nearest one
#if 1
                DWORD dwLSBIndex, dwMSBIndex;

                dwLSBIndex = dwMSBIndex = dwPitch;
                ASM_LOG2(dwLSBIndex);
                ASM_LOG2_R(dwMSBIndex);
                // this wasn't an even power of 2. round up.
                if (dwMSBIndex != dwLSBIndex) { dwMSBIndex++; }
                // lowest allowed bigPitch is 32
                if (dwMSBIndex < 5) { dwMSBIndex = 5; }
                dwBigPitch = 1 << dwMSBIndex;

                dwLSBIndex = dwMSBIndex = *dwBlockHeight;
                ASM_LOG2(dwLSBIndex);
                ASM_LOG2_R(dwMSBIndex);
                // this wasn't an even power of 2. round up.
                if (dwMSBIndex != dwLSBIndex) { dwMSBIndex++; }
                *dwBlockHeight = 1 << dwMSBIndex;
#else

                if      (dwPitch > 4096) { dwBigPitch = 8192; }
                else if (dwPitch > 2048) { dwBigPitch = 4096; }
                else if (dwPitch > 1024) { dwBigPitch = 2048; }
                else if (dwPitch > 512)  { dwBigPitch = 1024; }
                else if (dwPitch > 256)  { dwBigPitch = 512;  }
                else if (dwPitch > 128)  { dwBigPitch = 256;  }
                else if (dwPitch > 64)   { dwBigPitch = 128;  }
                else if (dwPitch > 32)   { dwBigPitch = 64;   }
                else                     { dwBigPitch = 32;   }

                if      (*dwBlockHeight > 4096) { *dwBlockHeight = 8192; }
                else if (*dwBlockHeight > 2048) { *dwBlockHeight = 4096; }
                else if (*dwBlockHeight > 1024) { *dwBlockHeight = 2048; }
                else if (*dwBlockHeight > 512)  { *dwBlockHeight = 1024; }
                else if (*dwBlockHeight > 256)  { *dwBlockHeight = 512;  }
                else if (*dwBlockHeight > 128)  { *dwBlockHeight = 256;  }
                else if (*dwBlockHeight > 64)   { *dwBlockHeight = 128;  }
                else if (*dwBlockHeight > 32)   { *dwBlockHeight = 64;   }
                else if (*dwBlockHeight > 16)   { *dwBlockHeight = 32;   }
                else if (*dwBlockHeight > 8)    { *dwBlockHeight = 16;   }
                else if (*dwBlockHeight > 4)    { *dwBlockHeight = 8;    }
                else if (*dwBlockHeight > 2)    { *dwBlockHeight = 4;    }
                else if (*dwBlockHeight > 1)    { *dwBlockHeight = 2;    }
                else                            { *dwBlockHeight = 1;    }
#endif

                vpp.extraPitch = dwBigPitch;
                *dwExtraSize = (dwBigPitch * *dwBlockHeight);

            } else {    // NV10 or above

                // NV10 requires texture offsets to be a multiple of 256, so round up pitch to multiple of 256 for BOB
                dwPitch = (dwPitch + NV_TEXTURE_OFFSET_ALIGN) & ~NV_TEXTURE_OFFSET_ALIGN;
                vpp.extraPitch = dwPitch;
                *dwExtraSize = dwPitch * *dwBlockHeight;

            }

        }

        // add extra for alignment requirements
        *dwExtraSize += NV_TEXTURE_OFFSET_ALIGN + 1;

        // only allow extra surfaces to be created if they consume less than 1/2 of the total
        // video memory, other memory checks for various features is done in DriverInit and
        // will zero out the enable bits if there isn't enough memory
        if ((*dwExtraNumSurfaces * *dwExtraSize) > (vpp.pDriverData->TotalVRAM >> 1)) {
            if ((4 * *dwExtraSize) <= (vpp.pDriverData->TotalVRAM >> 1) && vpp.regVPPMaxSurfaces >= 4) {
                // can still do everything, but not superpipelined
                *dwExtraNumSurfaces = 4;
            } else if ((3 * *dwExtraSize) <= (vpp.pDriverData->TotalVRAM >> 1) && vpp.regVPPMaxSurfaces >= 3) {
                // at least we will be able to do one VPP stage superpipelined...
                if (vpp.pDriverData->TotalVRAM < 0x1000000) {
                    // 8M boards, lets be extra stingy
                    // Fixes WHQL update bob test in 1024x768x16 which accidentally allocates 720x960 surfaces instead of 720x480
                    *dwExtraNumSurfaces = 2;
                } else {
                    *dwExtraNumSurfaces = 3;
                }
            } else if ((2 * *dwExtraSize) <= (vpp.pDriverData->TotalVRAM >> 1) && vpp.regVPPMaxSurfaces >= 2) {
                // at least we will be able to do one VPP stage...
                *dwExtraNumSurfaces = 2;
            } else {
                *dwExtraNumSurfaces = 0;
            }
        }

        // refine this heuristic by checking free memory, if we don't have enough for 720x576x2x3, then back off if we can
        if ((NV_GET_VIDEO_HEAP_FREE() - (int)(*dwExtraNumSurfaces * *dwExtraSize)) < (768*576*2*3)) {
            switch (*dwExtraNumSurfaces) {
            case 6: *dwExtraNumSurfaces = 4; break;
            case 4: 
            case 3: *dwExtraNumSurfaces = 2; break;
            default: break;
            }
        }

        // This limit is primarily to allow enough FOURCC_NV12 surfaces to be created for HDTV sized HWMC
        // and to allow HWMC support in a 16 MB frame buffer.
        if ((vpp.pDriverData->NvDeviceVersion >= NV_DEVICE_VERSION_10) &&  (*dwExtraNumSurfaces > 2)) {
            if (vpp.pDriverData->TotalVRAM <= 0x1000000) {
                *dwExtraNumSurfaces = 2;
            } else {
                if (dwPitch > 3200) {
                    if (vpp.pDriverData->TotalVRAM <= 0x2000000)
                        *dwExtraNumSurfaces = 0;
                    else
                        *dwExtraNumSurfaces = 2;
                } else
                    if (dwPitch > 2048)
                        *dwExtraNumSurfaces = 2;
            }
        }

        // in low memory configurations, demote number of VPP surfaces if many overlay buffers requested
        if (vpp.pDriverData->TotalVRAM < 0x1000000 && dwRequestedSurfaces > 3) {
            switch (*dwExtraNumSurfaces) {
            case 6:
            case 5: *dwExtraNumSurfaces = 4; break;
            case 4: *dwExtraNumSurfaces = 3; break;
            case 3: *dwExtraNumSurfaces = 2; break;
            case 2:
            default: *dwExtraNumSurfaces = 0; break;
            }
        }

        vpp.extraNumSurfaces = *dwExtraNumSurfaces;
        vpp.extraIndex = 0;
        if (*dwExtraNumSurfaces >= NV_VPP_MAX_EXTRA_SURFACES || *dwExtraNumSurfaces == 3) {
            // enable VPP superpipelining
            vpp.regOverlayMode |= NV4_REG_OVL_MODE_LATEFLIPSYNC;
        }
    }

    if (*dwExtraNumSurfaces >= 4) {
        // enable multipass overlay downscale on factors greater than 2
        if (vpp.pDriverData->NvDeviceVersion < NV_DEVICE_VERSION_10) {
            vpp.dwOverlayMaxDownScaleX = min(vpp.dwOverlayMaxDownScale, 2);
            vpp.dwOverlayMaxDownScaleY = min(vpp.dwOverlayMaxDownScale, 2);
        } else {
            vpp.dwOverlayMaxDownScaleX = min(vpp.dwOverlayMaxDownScale, 4);
            vpp.dwOverlayMaxDownScaleY = min(vpp.dwOverlayMaxDownScale, 2);
        }
    }

    dbgTracePop();
}


//---------------------------------------------------------------------------

extern DWORD VppCreateFourCCSurface(Vpp_t *pVpp, LPDDRAWI_DDRAWSURFACE_LCL pSurf, LPDDRAWI_DIRECTDRAW_GBL pDDGbl, DWORD dwExtraSize, DWORD dwExtraNumSurfaces, DWORD dwBlockHeight)
{
    Vpp_t &vpp = *pVpp;
    DWORD dwRV;
    DWORD i;

    HANDLE hOverlayOwner = GetCurrentProcess();

    DPF_LEVEL(NVDBG_LEVEL_OVERLAY_INFO, "  FOURCC surface requested" );

    if ((pSurf->ddsCaps.dwCaps & DDSCAPS_OVERLAY) &&
        (vpp.dwOverlaySurfaces > 0) &&
        (vpp.dwOverlayOwner != (DWORD) hOverlayOwner)) {
        return DDERR_OUTOFCAPS;
    }

    switch (pSurf->lpGbl->ddpfSurface.dwFourCC) {

        case FOURCC_RGB0:
        case FOURCC_RAW8:
            dwRV = nvCSCreate4ccRGB0 (pVpp, pSurf);
            if (dwRV != DD_OK) return(dwRV);
            break;
        case FOURCC_IF09:
        case FOURCC_YVU9:
        case FOURCC_IV32:
        case FOURCC_IV31:
            dwRV = nvCSCreate4ccIF09 (pVpp, pSurf, hOverlayOwner, dwExtraSize, dwExtraNumSurfaces);
            if (dwRV != DD_OK) return(dwRV);
            break;
#if IS_WINNT5 || IS_WIN9X
        case FOURCC_NV12:   // Our motion comp surface format
            dwRV = nvCSCreate4ccNV12 (pVpp, pSurf, hOverlayOwner, dwExtraSize, dwExtraNumSurfaces);
            if (dwRV != DD_OK) return(dwRV);
            break;
        case FOURCC_NVMC: // Our motion comp control surface, NV10 or greater
        case FOURCC_NVDS:
            dwRV = nvCSCreate4ccNVMC (pVpp, pSurf);
            if (dwRV != DD_OK) return(dwRV);
            break;
        case FOURCC_NVSP: // A subpicture surface (overlay)
            dwRV = nvCSCreate4ccNVSP (pVpp, pSurf);
            if (dwRV != DD_OK) return(dwRV);
            break;
        case FOURCC_NVID:
            dwRV = nvCSCreate4ccNVID (pVpp, pSurf, pDDGbl);
            if (dwRV != DD_OK) return(dwRV);
            break;
#endif
        case FOURCC_YUY2:
        case FOURCC_YUNV:
        case FOURCC_UYVY:
        case FOURCC_UYNV:
            dwRV = nvCSCreate4ccYUY2 (pVpp, pSurf, hOverlayOwner, dwExtraSize, dwExtraNumSurfaces, dwBlockHeight);
            if (dwRV != DD_OK) return(dwRV);
            break;
        case FOURCC_YV12:
        case FOURCC_420i:
            dwRV = nvCSCreate4ccYV12 (pVpp, pSurf, hOverlayOwner, dwExtraSize, dwExtraNumSurfaces);
            if (dwRV != DD_OK) return(dwRV);
            break;
        case FOURCC_NVT0:
        case FOURCC_NVT1:
        case FOURCC_NVT2:
        case FOURCC_NVT3:
        case FOURCC_NVT4:
        case FOURCC_NVT5:
        case FOURCC_NVS0:
        case FOURCC_NVS1:
        case FOURCC_NVS2:
        case FOURCC_NVS3:
        case FOURCC_NVS4:
        case FOURCC_NVS5:
        case FOURCC_NVHU:
        case FOURCC_NVHS:
#ifdef DXT_SUPPORT
        case FOURCC_DXT1:
        case FOURCC_DXT2:
        case FOURCC_DXT3:
        case FOURCC_DXT4:
        case FOURCC_DXT5:
#endif
            DPF ("should have been handled by texture-create or rejected by CanCreateSurface" );
            dbgError("NV Error!");
            return DDERR_INVALIDPARAMS;
        default:
            DPF ("unknown 4cc code in VppCreateFourCCSurface");
            dbgError("NV Error!");
            return DDERR_INVALIDPARAMS;
    }  // switch

    // align extra surfaces
    for (i=0; i<NV_VPP_MAX_EXTRA_SURFACES; i++) {
        vpp.extraOverlayOffset[i] = (vpp.extraOverlayOffset[i] + NV_TEXTURE_OFFSET_ALIGN - 1) & ~(NV_TEXTURE_OFFSET_ALIGN - 1);
    }

    if (vpp.regOverlayColourControlEnable) {
        // allocate an AGP workspace if overlay has been created
        if (IS_OVERLAY(pSurf->ddsCaps.dwCaps, pSurf->lpGbl->ddpfSurface.dwFourCC) && vpp.fpOverlayShadow==0) {
            DWORD szHostWorkSpace;

            if (vpp.extraOverlayOffset[0]) {
                szHostWorkSpace = (vpp.extraPitch) * (dwBlockHeight + 10) + 8192;
            } else if (pSurf->lpGbl->ddpfSurface.dwFourCC == FOURCC_YV12 ||
                       pSurf->lpGbl->ddpfSurface.dwFourCC == FOURCC_420i ||
                       pSurf->lpGbl->ddpfSurface.dwFourCC == FOURCC_YVU9 ||
                       pSurf->lpGbl->ddpfSurface.dwFourCC == FOURCC_IV32 ||
                       pSurf->lpGbl->ddpfSurface.dwFourCC == FOURCC_IV31 ||
                       pSurf->lpGbl->ddpfSurface.dwFourCC == FOURCC_IF09) {
                szHostWorkSpace = (pSurf->lpGbl->lPitch << 1) * (dwBlockHeight + 10) + 8192;
            } else {
                szHostWorkSpace = pSurf->lpGbl->lPitch * (dwBlockHeight + 10) + 8192;
            }

            // allocate work space in shared system memory
            // add an extra 10 lines + 4k for cache preload overrrun and page alignment
            vpp.fpOverlayShadow = (DWORD) AllocIPM(szHostWorkSpace);

            if (vpp.fpOverlayShadow) {
                unsigned long status;

                // First disconnect everything

                vpp.pDriverData->dDrawSpareSubchannelObject = 0;

                NvRmFree(vpp.pDriverData->dwRootHandle, vpp.pDriverData->dwRootHandle,
                    vpp.hFloatingContextDmaInOverlayShadow);

                // Now reconnect everything
                status = NvRmAllocContextDma(vpp.pDriverData->dwRootHandle,
                    vpp.hFloatingContextDmaInOverlayShadow,
                    NV01_CONTEXT_DMA,
                    DRF_DEF(OS03, _FLAGS, _ACCESS, _READ_WRITE) |
                    DRF_DEF(OS03, _FLAGS, _LOCKED, _ALWAYS) |
                    DRF_DEF(OS03, _FLAGS, _COHERENCY, _CACHED),
                    (PVOID)vpp.fpOverlayShadow,
                    (szHostWorkSpace - 1));
                }
            // tells ring0 code that it can run now
            vpp.regRing0ColourCtlInterlockFlags = vpp.regRing0ColourCtlInterlockFlags | 0x1;
        }
    }

#if IS_WINNT4
    if (pSurf->ddsCaps.dwCaps & (DDSCAPS_OVERLAY)) {
#else
    if (pSurf->ddsCaps.dwCaps & (DDSCAPS_OVERLAY | DDSCAPS_VIDEOPORT)) {
#endif
        //
        // Initialize some stuff so KMVT stuff doesn't go crazy.  This can happen if
        // the KMVT routines (mainly vddFlipOverlay) gets called before UpdateOverlay32.
        //
        vpp.dwOverlaySrcX = 0;
        vpp.dwOverlaySrcY = 0;

        // Put some information about the surface in the surface so DVD decoders can
        // initialize DMA blits properly
        VppBltWriteDword(pVpp,VIDMEM_OFFSET(pSurf->lpGbl->fpVidMem), 0, GUID_NV_OVERLAY_INFO.Data1);
        VppBltWriteDword(pVpp,VIDMEM_OFFSET(pSurf->lpGbl->fpVidMem), 1, (GUID_NV_OVERLAY_INFO.Data3 << 16) |
                                                                 GUID_NV_OVERLAY_INFO.Data2);
        VppBltWriteDword(pVpp,VIDMEM_OFFSET(pSurf->lpGbl->fpVidMem), 2, (GUID_NV_OVERLAY_INFO.Data4[3] << 24) |
                                                                (GUID_NV_OVERLAY_INFO.Data4[2] << 16) |
                                                                (GUID_NV_OVERLAY_INFO.Data4[1] << 8) |
                                                                 GUID_NV_OVERLAY_INFO.Data4[0]);
        VppBltWriteDword(pVpp,VIDMEM_OFFSET(pSurf->lpGbl->fpVidMem), 3, (GUID_NV_OVERLAY_INFO.Data4[7] << 24) |
                                                                (GUID_NV_OVERLAY_INFO.Data4[6] << 16) |
                                                                (GUID_NV_OVERLAY_INFO.Data4[5] << 8) |
                                                                 GUID_NV_OVERLAY_INFO.Data4[4]);
        VppBltWriteDword(pVpp,VIDMEM_OFFSET(pSurf->lpGbl->fpVidMem), 4, VIDMEM_OFFSET(pSurf->lpGbl->fpVidMem));
        VppBltWriteDword(pVpp,VIDMEM_OFFSET(pSurf->lpGbl->fpVidMem), 5, (DWORD)pSurf);
        VppBltWriteDword(pVpp,VIDMEM_OFFSET(pSurf->lpGbl->fpVidMem), 6, (DWORD)pDDGbl);
    }

    return (DD_OK);

}  // VppCreateFourCCSurface()
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\common\src\nvPatchUtil.c ===
/*
 * nvPatchUtil.c
 *
 * Software emulation for curved surfaces.
 *
 * Copyright (c) 2000, Nvidia Corporation.  All rights reserved.
 */

// Constants defined in nvPatchConsts.c
extern float *bezBasis[16];
extern float *catmullRomBasis[16];
extern float *bsplineBasis[16];
extern float *invBezBasis[16];
extern float *powerToFD[16];
extern float *inversePowerToFD[16];
extern float cachedBinomialCoefficients[11][11];
static double factorial[1+NV_PATCH_MAX_RETESS];
static double oofactorial[1+NV_PATCH_MAX_RETESS];

#define DCR_COMPUTEFDMATRIXFLIP_OPT
#define DCR_COMPUTEFDCURVEFLIP_OPT
#define DCR_HOS_OPT
#if !defined(IS_OPENGL)
    //#define DCR_HOS_MATRIX_OPT
    #define DCR_HOS_RETESSCURVE_OPT     // XXX not yet thread safe for OpenGL
    #define DCR_HOS_RETESS_OPT          // XXX not yet thread safe for OpenGL
#endif

#if !defined(IS_OPENGL)
    #undef  NV_TRACE_COND
    #define NV_TRACE_COND(class, level, code)
    #undef  NV_TRACE_CODE
    #define NV_TRACE_CODE(code)
    #define TPRINTF(xx)
    #define EV_DRAW(code)
#ifdef MAX
#undef MAX
#endif
#ifdef MIN
#undef MIN
#endif
    #define MAX max
    #define MIN min

#else
    #define nvAssert assert
    #if defined(COMPILE_TRACE_LIBRARY)
        #define ENABLE_DEBUG_REVERSE_TRANSITIONS  // for testing reverse transitions
        #define ENABLE_DEBUG_SWATH // for testing swathing. I'll remove this when things are more stable. Thanks. Fred.
        static int evalTrace = 0;
        static int skipQuads = 0;   // set to draw only 1 quad of frac cases to simplify debugging
        static int retessit = 0;
        static int drawRef = 0;
        #define EV_DRAW(code) \
                if (drawRef  &&  (nvDebugLevel >= 2)) { \
                    { code; } \
                } \

    #else
        #define EV_DRAW(code)
    #endif
#endif

#define EV_GUARD_ATTR(index)        (((index) == NV_PATCH_ATTRIB_NORMAL) || ((index) == NV_PATCH_ATTRIB_POSITION))
#define EV_GUARD_BITS               ((1 << NV_PATCH_ATTRIB_NORMAL) | (1 << NV_PATCH_ATTRIB_POSITION))
#define EV_GUARD_BIT_VERTEX         ((1 << NV_PATCH_ATTRIB_POSITION))
#define EV_GUARD_BIT_NORMAL         ((1 << NV_PATCH_ATTRIB_NORMAL))

// note: conventions for specifying indices.
// For matrices, the ordering is [row][col] or [Vcoord][Ucoord].
// This matches how the control points are specified.
// For function arguments, it's tempting to use (Ucoord, Vcoord) since that
// is similar to (X, Y), but this can be confusing (matrices vs routines).
// Therefore, routines also take arguments in the (V, U) order.

// For the HW interface, integer step patches,
// the curve for the outside determines the direction of drawing the stitch.
// The inside curve may be evaluated in the reverse order. In these cases
// the n points are saved away in order to match the outside direction,
// then the stitch is drawn in the outside direction.

// Normally, matrices and curves are calculated with small step sizes.

// When swathing, the matrices are calculated with big steps, and
// converted during swathing. The low level routine DrawIntPatchGrid()
// receives matrices with small steps.
// Guard curves are calculated with big steps in nvEvalPatch(), then
// stepped and converted to small steps in DrawIntPatchSwaths()
// DrawIntStitch() receives a set of small step curves.

#define ASSERT_CURVE(PCURVE) nvAssert((PCURVE)->order > 0  &&  (PCURVE)->order < NV_PATCH_MAX_ORDER)
#define ASSERT_MATRIX(PMATRIX) nvAssert((PMATRIX)->rows > 0  &&  (PMATRIX)->rows < NV_PATCH_MAX_ORDER \
                                     && (PMATRIX)->cols > 0  &&  (PMATRIX)->cols < NV_PATCH_MAX_ORDER)

/*****************************************************************************/
#define EV_SWAP(a, b, t) { t = a; a = b; b = t; }

// index into curve*[]. For given attrib, and term of the curve equation, point to the 'X' of the attribute
static NV_INLINE int idxCurve(int attribIndex, int orderTerm)
{
    return (attribIndex*NV_PATCH_MAX_ORDER + orderTerm)*4;
}

static NV_INLINE float *pRawData(NV_PATCH_INFO *info, NV_PATCH_MAP_INFO *map, float *rawData, int vCoord, int uCoord)
{
    int uOrder = map->uorder;//, ii;
    int vOrder = map->vorder;
    int ufStride = map->ufStride;
    int vfStride = map->vfStride;

    //ffif (info->flipT) {
        //ffEV_SWAP(uOrder, vOrder, ii);
        //ffEV_SWAP(ufStride, vfStride, ii);
    //ff}
    if (info->flipV) {
        vCoord = vOrder - 1 - vCoord;
    }
    if (info->flipU) {
        uCoord = uOrder - 1 - uCoord;
    }
    return (rawData + vCoord * vfStride + uCoord * ufStride);
}

static NV_INLINE void getRawData(NV_PATCH_INFO *info, NV_PATCH_MAP_INFO *map, float *rawData, int vCoord, int uCoord, float *pOut)
{
    float *data = pRawData(info, map, rawData, vCoord, uCoord);
    pOut[0] = data[0]; pOut[1] = data[1]; pOut[2] = data[2]; pOut[3] = data[3];

}

/*****************************************************************************/
#if defined(COMPILE_TRACE_LIBRARY)

void TraceMatrix(NV_PATCH_INFO *info, const FDMatrix *m);

static float approxOK = 1E-5;
#define EV_ABS(x)       ((x) >=  0  ? (x) : -(x))
#define EV_MIN(x, y)    ((x) < (y) ? (x) : (y))
#define EV_MAX(x, y)    ((x) > (y) ? (x) : (y))

static NV_INLINE int FloatsIdentical(float src, float src2)
{
    if (EV_AS_INT(src) == EV_AS_INT(src2)) {
        return 1;
    }

    TPRINTF(("src=%g=x%x src2=%g=x%x\n", src, *(int *)&src, src2, *(int *)&src2));
    nvAssert(("FLOATS NOT IDENTICAL", 0));
    return 0;
}

static NV_INLINE int DoublesIdentical(double src, double src2)
{
    int *pSrc = (int *)&src;
    int *pSrc2 = (int *)&src2;

    if (pSrc[0] == pSrc2[0]  &&  pSrc[1] == pSrc2[1]) {
        return 1;
    }

    TPRINTF(("src=%g=x%X x%08X src2=%g=x%X x%08X\n", src, pSrc[0], pSrc[1], src2, pSrc2[0], pSrc2[1]));
    nvAssert(("DOUBLES NOT IDENTICAL", 0));
    return 0;
}

static NV_INLINE int FloatsEqual(float src, float src2)
{
    float fmin = EV_MIN(EV_ABS(src), EV_ABS(src2));
    float fmax = EV_MAX(EV_ABS(src), EV_ABS(src2));
    float fok = approxOK * fmax;

    if (src == 0.f) {
        if (fmax < approxOK) {
            return 1;
        }
        return 0;
    }
    if (src2 == 0.f) {
        if (fmax < approxOK) {
            return 1;
        }
        return 0;
    }
    if (EV_ABS(src - src2) <= fok) {
        return 1;
    }
    TPRINTF(("src=%g=x%x src2=%g=x%x\n", src, *(int *)&src, src2, *(int *)&src2));
    nvAssert(("FLOATS NOT EQUAL", 0));
    return 0;
}

static NV_INLINE int PointsEqual(float *src, float *src2)
{
    int ret = FloatsEqual(src[0], src2[0]);

    ret = ret && FloatsEqual(src[1], src2[1]);
    ret = ret && FloatsEqual(src[2], src2[2]);
    ret = ret && FloatsEqual(src[3], src2[3]);
    return ret;
}

// Compare the U curve from a FDMatrix to a curve
void CompareUCurveMatrix(NV_PATCH_CURVE_INFO *dst, FDMatrix *m)
{
    int i, stride = 4*sizeof(float);
    float *data = dst->coeffs[0];

    nvAssert(dst->order == m->columns);
    // Empty data
    for (i = 0; i < dst->order; i++) {
        // Compare data
        PointsEqual(data, m->data[0][i]);

        // Step pointer
        data = (float *)((char *)data + stride);
    }
}

static NV_INLINE void CompareCurves(NV_PATCH_INFO *info, NV_PATCH_CURVE_INFO *src, NV_PATCH_CURVE_INFO *src2)
{
    int i;

    nvAssert(src->order == src2->order);
    for (i = 0;  i < src->order;  i++) {
        PointsEqual(src->coeffs[i], src2->coeffs[i]);
    }
}

static NV_INLINE int CompareMatrices(NV_PATCH_INFO *info, FDMatrix *src, FDMatrix *src2)
{
    int i, j, ret = 1;

    nvAssert(src->rows == src2->rows);
    nvAssert(src->columns == src2->columns);
    for (i=0; i < src->rows; i++) {
        for (j = 0; j < src->columns; j++) {
            ret = ret && FloatsEqual(src->data[i][j][0], src2->data[i][j][0]);
            ret = ret && FloatsEqual(src->data[i][j][1], src2->data[i][j][1]);
            ret = ret && FloatsEqual(src->data[i][j][2], src2->data[i][j][2]);
            ret = ret && FloatsEqual(src->data[i][j][3], src2->data[i][j][3]);
        }
    }
    if (!ret) {
        TPRINTF(("BAD MATRIX COMPARE\n"));
        TraceMatrix(info, src);
        TraceMatrix(info, src2);
    }
    return ret;
}

void CheckCache(NV_PATCH_INFO *info, FDMatrix *src)
{
    int i, j;
    double sum;

    for (i=0; i < src->rows; i++) {
        sum = 0.;
        for (j = 0; j < src->columns; j++) {
            FloatsIdentical(src->data[i][j][0], src->data[i][j][1]);
            FloatsIdentical(src->data[i][j][0], src->data[i][j][2]);
            FloatsIdentical(src->data[i][j][0], src->data[i][j][3]);
            sum += src->data[i][j][0];
        }
        TPRINTF(("CheckCache %2d) sum=%g\n", i, sum));
        if (!i) {
            FloatsEqual(sum, 1.f);
        } else {
            FloatsEqual(sum, 0.f);
        }
    }
}

void CheckCached(NV_PATCH_INFO *info, FDMatrixd *src)
{
    int i, j;
    double sum;

    for (i=0; i < src->rows; i++) {
        sum = 0.;
        for (j = 0; j < src->columns; j++) {
            DoublesIdentical(src->data[i][j][0], src->data[i][j][1]);
            DoublesIdentical(src->data[i][j][0], src->data[i][j][2]);
            DoublesIdentical(src->data[i][j][0], src->data[i][j][3]);
            sum += src->data[i][j][0];
        }
        TPRINTF(("CheckCache %2d) sum=%g\n", i, sum));
        if (!i) {
            //ffFloatsEqual(sum, 1.f);
            assert(sum == 1.);
        } else {
            //ffFloatsEqual(sum, 0.f);
            assert(sum == 0.);
        }
    }
}

#endif  // defined(COMPILE_TRACE_LIBRARY)

/*****************************************************************************/
// Print a matrix for tracing purposes
static int traceHex = 0;
static int traceWrap = 1;
void TraceMatrix(NV_PATCH_INFO *info, const FDMatrix *m)
{
    int row, col;
#if !defined(IS_OPENGL)
    DPF_LEVEL(NVDBG_LEVEL_HOS_INFO, "%dx%d matrix:\n", m->rows, m->columns);
    for (row = 0; row < m->rows; row++) {
        DPF_LEVEL(NVDBG_LEVEL_HOS_INFO, "  ");
        for (col = 0; col < m->columns; col++) {
            DPF_LEVEL(NVDBG_LEVEL_HOS_INFO, "[%f %f %f %f] ",
                m->data[row][col][0], m->data[row][col][1],
                m->data[row][col][2], m->data[row][col][3]);
        }
        DPF_LEVEL(NVDBG_LEVEL_HOS_INFO, "\n");
    }
#else
    NV_TRACE(TR_EVAL, 25, ("%dx%d matrix:\n", m->rows, m->columns));
    for (row = 0; row < m->rows; row++) {
        NV_TRACE(TR_EVAL, 25, ("row%d:", row));
        for (col = 0; col < m->columns; col++) {
            NV_TRACE(TR_EVAL, 25, ("%s%2d) [%13g %13g %13g %13g]%s",
                col && (m->columns > traceWrap) ? "      " : " ", col,
                m->data[row][col][0], m->data[row][col][1],
                m->data[row][col][2], m->data[row][col][3],
                m->columns > traceWrap ? "\n" : ""));
            if (traceHex) {
                NV_TRACE(TR_EVAL, 85, ("%2d) [x%08X x%08X x%08X x%08X] ", col,
                    *(const int *)&m->data[row][col][0], *(const int *)&m->data[row][col][1],
                    *(const int *)&m->data[row][col][2], *(const int *)&m->data[row][col][3]));
            }
        }
        NV_TRACE(TR_EVAL, 25, ("\n"));
    }
#endif
}

void TraceCurve(NV_PATCH_INFO *info, const NV_PATCH_CURVE_INFO *pCurve, char *pMess)
{
    int i;

    TPRINTF(("Curve '%s':\n", pMess));

    for (i = 0;  i < pCurve->order;  i++) {
        TPRINTF(("%2d) [%13g %13g %13g %13g]\n", i, pCurve->coeffs[i][0],
                pCurve->coeffs[i][1], pCurve->coeffs[i][2], pCurve->coeffs[i][3]));
    }
}

/*****************************************************************************/
NV_INLINE void CopyPoint(float *dst, const float *src)
// This will generate better code if dst and/or src are expressions or fancy structures.
// The reason is that dst and src are evaluated once.
// If done by hand in-line, the compiler may not optimize for the similarity of expressions.
// Looking at a few tests, without the inline function took 4*12=48 instructions,
// vs only 21 using CopyPoint
// Also, and just as important, I think it makes the code easier to read because
// it's more compact, not expanding x4 for each simple copy.
// And, as a bonus, if you are "watching" dst in the debugger, you may optionally
// step into this routine to see the values being copied. Otherwise, it may be a more
// laborious procedure to see what just happened.
{
    dst[0] = src[0];
    dst[1] = src[1];
    dst[2] = src[2];
    dst[3] = src[3];
}

static NV_INLINE void AddPoint(float *dst, float *src)
{
    dst[0] += src[0];
    dst[1] += src[1];
    dst[2] += src[2];
    dst[3] += src[3];
}

static NV_INLINE void AddPoint3(float *dst, float *src1, float *src2)
{
    dst[0] = src1[0] + src2[0];
    dst[1] = src1[1] + src2[1];
    dst[2] = src1[2] + src2[2];
    dst[3] = src1[3] + src2[3];
}

/*****************************************************************************/
static NV_INLINE void CopyCoeffs(NV_PATCH_INFO *info, NV_PATCH_CURVE_COEFFS *dst, NV_PATCH_CURVE_COEFFS *src)
// copy curve coeffs. Does not copy 'order'. May be used to copy matrix rows to curve coeffs.
{
    __NV_MEMCPY(dst, src, 4*info->maxOrder*sizeof(float));
}

void CopyCurve(NV_PATCH_INFO *info, NV_PATCH_CURVE_INFO *dst, NV_PATCH_CURVE_INFO *src)
// copy curve, including order
{
#ifdef DCR_HOS_OPT
    float *srcptr, *dstptr;

    ASSERT_CURVE(src);
    switch (src->order) {
    case 2:
        dst->order = src->order;
        srcptr = (float*)(&src->coeffs[0][0]); dstptr = (float*)(&dst->coeffs[0][0]);
        dstptr[0] = srcptr[0]; dstptr[1] = srcptr[1]; dstptr[2] = srcptr[2]; dstptr[3] = srcptr[3];  //v0-xyzw
        dstptr[4] = srcptr[4]; dstptr[5] = srcptr[5]; dstptr[6] = srcptr[6]; dstptr[7] = srcptr[7];  //v1-xyzw
        return;
    case 4:
        dst->order = src->order;
        srcptr = (float*)(&src->coeffs[0][0]); dstptr = (float*)(&dst->coeffs[0][0]);
        dstptr[0] = srcptr[0]; dstptr[1] = srcptr[1]; dstptr[2] = srcptr[2]; dstptr[3] = srcptr[3];  //v0-xyzw
        dstptr[4] = srcptr[4]; dstptr[5] = srcptr[5]; dstptr[6] = srcptr[6]; dstptr[7] = srcptr[7];  //v1-xyzw
        dstptr[8] = srcptr[8]; dstptr[9] = srcptr[9]; dstptr[10] = srcptr[10]; dstptr[11] = srcptr[11];  //v2-xyzw
        dstptr[12] = srcptr[12]; dstptr[13] = srcptr[13]; dstptr[14] = srcptr[14]; dstptr[15] = srcptr[15];  //v3-xyzw
        return;
    case 6:
        dst->order = src->order;
        srcptr = (float*)(&src->coeffs[0][0]); dstptr = (float*)(&dst->coeffs[0][0]);
        dstptr[0] = srcptr[0]; dstptr[1] = srcptr[1]; dstptr[2] = srcptr[2]; dstptr[3] = srcptr[3];  //v0-xyzw
        dstptr[4] = srcptr[4]; dstptr[5] = srcptr[5]; dstptr[6] = srcptr[6]; dstptr[7] = srcptr[7];  //v1-xyzw
        dstptr[8] = srcptr[8]; dstptr[9] = srcptr[9]; dstptr[10] = srcptr[10]; dstptr[11] = srcptr[11];  //v2-xyzw
        dstptr[12] = srcptr[12]; dstptr[13] = srcptr[13]; dstptr[14] = srcptr[14]; dstptr[15] = srcptr[15];  //v3-xyzw
        dstptr[16] = srcptr[16]; dstptr[17] = srcptr[17]; dstptr[18] = srcptr[18]; dstptr[19] = srcptr[19];  //v4-xyzw
        dstptr[20] = srcptr[20]; dstptr[21] = srcptr[21]; dstptr[22] = srcptr[22]; dstptr[23] = srcptr[23];  //v5-xyzw
        return;
     default:
        ;   // fall thru to C code
    }
#endif

    ASSERT_CURVE(src);
    __NV_MEMCPY(dst, src, PATCH_CURVE_HEADER_SIZE + 4*info->maxOrder*sizeof(float));
}

static NV_INLINE void CopyCurveSet(NV_PATCH_INFO *info, int evalEnables, FDCurveAttrSet *dst, FDCurveAttrSet *src)
{
    int index;
    for (index = 0; index < info->maxAttr; index++) {
        if (evalEnables & (1 << index)) {
            CopyCurve(info, (*dst)[index], (*src)[index]);
        }
    }
}

/*****************************************************************************/
// copy one matrix
static NV_INLINE void CopyMatrix(NV_PATCH_INFO *info, FDMatrix *dst, const FDMatrix *src)
{
#ifdef DCR_HOS_OPT
    int i;
    float *srcptr, *dstptr;
#if !defined(IS_OPENGL)
    switch (src->rows) {
#else
    switch (MAX(src->rows, src->columns)) { // }
#endif
    case 2:
        dst->rows = src->rows;
        dst->columns = src->columns;
        srcptr = (float*)(&src->data[0][0][0]);
        dstptr = (float*)(&dst->data[0][0][0]);
        dstptr[0] = srcptr[0]; dstptr[1] = srcptr[1]; dstptr[2] = srcptr[2]; dstptr[3] = srcptr[3];  //v0-xyzw
        dstptr[4] = srcptr[4]; dstptr[5] = srcptr[5]; dstptr[6] = srcptr[6]; dstptr[7] = srcptr[7];  //v1-xyzw
        dstptr+=16*4; srcptr+=16*4;                                                                  //skip to next row
        dstptr[0] = srcptr[0]; dstptr[1] = srcptr[1]; dstptr[2] = srcptr[2]; dstptr[3] = srcptr[3];  //v2-xyzw
        dstptr[4] = srcptr[4]; dstptr[5] = srcptr[5]; dstptr[6] = srcptr[6]; dstptr[7] = srcptr[7];  //v3-xyzw
        return;
    case 4:
        dst->rows = src->rows;
        dst->columns = src->columns;
        srcptr = (float*)(&src->data[0][0][0]);
        dstptr = (float*)(&dst->data[0][0][0]);
        for (i=0; i < 4; i++) {
            dstptr[0] = srcptr[0]; dstptr[1] = srcptr[1]; dstptr[2] = srcptr[2]; dstptr[3] = srcptr[3];  //v0-xyzw
            dstptr[4] = srcptr[4]; dstptr[5] = srcptr[5]; dstptr[6] = srcptr[6]; dstptr[7] = srcptr[7];  //v1-xyzw
            dstptr[8] = srcptr[8]; dstptr[9] = srcptr[9]; dstptr[10] = srcptr[10]; dstptr[11] = srcptr[11];  //v2-xyzw
            dstptr[12] = srcptr[12]; dstptr[13] = srcptr[13]; dstptr[14] = srcptr[14]; dstptr[15] = srcptr[15];  //v3-xyzw
            dstptr+=16*4; srcptr+=16*4;                                                                  //skip to next row
        }
        return;
    case 6:
        dst->rows = src->rows;
        dst->columns = src->columns;
        srcptr = (float*)(&src->data[0][0][0]);
        dstptr = (float*)(&dst->data[0][0][0]);
        for (i=0; i < 6; i++) {
            dstptr[0] = srcptr[0]; dstptr[1] = srcptr[1]; dstptr[2] = srcptr[2]; dstptr[3] = srcptr[3];  //v0-xyzw
            dstptr[4] = srcptr[4]; dstptr[5] = srcptr[5]; dstptr[6] = srcptr[6]; dstptr[7] = srcptr[7];  //v1-xyzw
            dstptr[8] = srcptr[8]; dstptr[9] = srcptr[9]; dstptr[10] = srcptr[10]; dstptr[11] = srcptr[11];  //v2-xyzw
            dstptr[12] = srcptr[12]; dstptr[13] = srcptr[13]; dstptr[14] = srcptr[14]; dstptr[15] = srcptr[15];  //v3-xyzw
            dstptr[16] = srcptr[16]; dstptr[17] = srcptr[17]; dstptr[18] = srcptr[18]; dstptr[19] = srcptr[19];  //v4-xyzw
            dstptr[20] = srcptr[20]; dstptr[21] = srcptr[21]; dstptr[22] = srcptr[22]; dstptr[23] = srcptr[23];  //v5-xyzw
            dstptr+=16*4; srcptr+=16*4;                                                                  //skip to next row
        }
        return;
    default:
        ;   // fall thru to C code
    }
#endif

    __NV_MEMCPY(dst, src, sizeof(FDMatrix));
}

static NV_INLINE void CopyMatrixTranspose(NV_PATCH_INFO *info, FDMatrix *dst, FDMatrix *src)
{
    int i,j;
    //THIS NEEDS TO BE IMPROVED!!!
    dst->rows = src->columns;
    dst->columns = src->rows;
    for (i=0; i < src->rows; i++) {
        for (j = 0; j < src->columns; j++) {
            dst->data[j][i][0] = src->data[i][j][0];
            dst->data[j][i][1] = src->data[i][j][1];
            dst->data[j][i][2] = src->data[i][j][2];
            dst->data[j][i][3] = src->data[i][j][3];
        }
    }
}

static NV_INLINE void CopyMatrixSet(NV_PATCH_INFO *info, int evalEnables, FDMatrixAttrSet *dst, FDMatrixAttrSet *src)
// copy set of matrices
{
    int index;
    for (index = 0; index < info->maxAttr; index++) {
        if (!(evalEnables & (1 << index))) {
            continue;
        }
        CopyMatrix(info, (*dst)[index], (*src)[index]);
    }
}

/*****************************************************************************/
void MatrixMult(NV_PATCH_INFO *info, FDMatrix *c, const FDMatrix *a, const FDMatrix *b)
{
    int row, col, term;

    NV_TRACE_COND(TR_EVAL, 55,
        TPRINTF(("MatrixMult:\n"));
        TraceMatrix(info, a);
        TraceMatrix(info, b);
    );

    c->rows    = a->rows;
    c->columns = b->columns;
    nvAssert(a->columns == b->rows);

#ifdef DCR_HOS_MATRIX_OPT
    if (g_FDGlobalData.cpuType) {
        switch (a->columns) {
        ??? what is this next line? Fred.
        PFMM p;
        case 4:
            p=(PFMM)(g_FDGlobalData.HOSInnerLoops[OFFSET_MATRIX_MULT_4x4]);
            p(c, (FDMatrix*)a, (FDMatrix*)b);
            return;
        case 6:
            p=(PFMM)(g_FDGlobalData.HOSInnerLoops[OFFSET_MATRIX_MULT_6x6]);
            p(c, (FDMatrix*)a, (FDMatrix*)b);
            return;
        case 2:
            //OFFSET_MATRIX_MULT_2x2
        default:
            //OFFSET_MATRIX_MULT_DEF
            ;   // fall thru to C code
        }
    }
#endif
    {
        for (row = 0; row < c->rows; row++) {
            for (col = 0; col < c->columns; col++) {
                c->data[row][col][0] = 0.0f;
                c->data[row][col][1] = 0.0f;
                c->data[row][col][2] = 0.0f;
                c->data[row][col][3] = 0.0f;
                for (term = 0; term < a->columns; term++) {
                    c->data[row][col][0] += a->data[row][term][0] * b->data[term][col][0];
                    c->data[row][col][1] += a->data[row][term][1] * b->data[term][col][1];
                    c->data[row][col][2] += a->data[row][term][2] * b->data[term][col][2];
                    c->data[row][col][3] += a->data[row][term][3] * b->data[term][col][3];
                }
            }
        }
    }
    NV_TRACE_COND(TR_EVAL, 45,
        TPRINTF(("... result:\n"));
        TraceMatrix(info, c);
    );
}

/*****************************************************************************/
// Fill in a column vector matrix using a sequence of strided xyzw values
void FillColumnVectorMatrix(int n, int stride, const float *data, FDMatrix *m, int col)
{
    int i;

    // nx1 matrix
    m->rows = n;
    //this implicitly assumes that  we are filling this one column at a time
    //such that we have the right value when we are done (i.e. the calls are made)
    //col = 1... n whe col=n is the LAST call.
    nvAssert(!col  ||  (col == m->columns));
    m->columns = (col+1);
    for (i = 0; i < n; i++) {
        m->data[i][col][0] = data[0]; m->data[i][col][1] = data[1];
        m->data[i][col][2] = data[2]; m->data[i][col][3] = data[3];
        data = (const float *)((const char *)data + stride);
    }
}

// Empty a column vector matrix into a sequence of strided xyzw values
void EmptyColumnVectorMatrix(int n, const FDMatrix *m, int stride, float *data, int col)
{
    int i;

    // Verify that it is a nx1 matrix
    nvAssert(m->rows == n);
    nvAssert(col < m->columns);

    // Empty data
    for (i = 0; i < n; i++) {
        // Copy data
        data[0] = m->data[i][col][0];
        data[1] = m->data[i][col][1];
        data[2] = m->data[i][col][2];
        data[3] = m->data[i][col][3];

        // Step pointer
        data = (float *)((char *)data + stride);
    }
}

/*****************************************************************************/
static FDMatrix bigToSmallMatrix[NV_PATCH_MAX_RETESS];
static FDMatrix smallToBigMatrix[NV_PATCH_MAX_RETESS];
static int retessGuard = 0xfeed1;

/*****************************************************************************/
// Compute FD coefficients from curve control points
void RetessCurveInOut(NV_PATCH_INFO *info, int smallToBig, NV_PATCH_CURVE_INFO *curve, NV_PATCH_CURVE_INFO *curveOut)
{
    FDMatrix *temp[3];

    ASSERT_CURVE(curve);
    BEGIN_USING_TEMP_MATRIX(info->tempMatrix_m0);
    BEGIN_USING_TEMP_MATRIX(info->tempMatrix_m1);
    temp[0] = &info->tempMatrix_m0;
    temp[1] = &info->tempMatrix_m1;

    if (smallToBig) {
        temp[2] = &smallToBigMatrix[curve->order];
    } else {
        temp[2] = &bigToSmallMatrix[curve->order];
    }

    // Compute FD curve coefficients
    FillColumnVectorMatrix(curve->order, 4*sizeof(float), &curve->coeffs[0][0], temp[0], 0);
    MatrixMult(info, temp[1], temp[2], temp[0]);
    EmptyColumnVectorMatrix(curve->order, temp[1], 4*sizeof(float), &curveOut->coeffs[0][0], 0);

    curveOut->order = curve->order;
    END_USING_TEMP_MATRIX(info->tempMatrix_m0);
    END_USING_TEMP_MATRIX(info->tempMatrix_m1);
}

// Compute FD coefficients from curve control points
void RetessCurveSetInOut(NV_PATCH_INFO *info, int smallToBig, int evalEnables, FDCurveAttrSet *pIn, FDCurveAttrSet *pOut)
{
    int attr;

    for (attr = 0;  evalEnables;  attr++, evalEnables >>=1 ) {
        if (evalEnables & 1) {
            RetessCurveInOut(info, smallToBig, (*pIn)[attr], (*pOut)[attr]);
        }
    }
}

void RetessCurve(NV_PATCH_INFO *info, int smallToBig, NV_PATCH_CURVE_INFO *curve)
{
    RetessCurveInOut(info, smallToBig, curve, curve);
}

/*****************************************************************************/
void RetessMatrixU(NV_PATCH_INFO *info, int smallToBig, FDMatrix *matrix)
{
    FDMatrix *temp[3];

    BEGIN_USING_TEMP_MATRIX(info->tempMatrix_m0);
    BEGIN_USING_TEMP_MATRIX(info->tempMatrix_m1);
    temp[0] = &info->tempMatrix_m0;
    temp[1] = &info->tempMatrix_m1;

    if (smallToBig) {
        temp[2] = &smallToBigMatrix[matrix->columns];
    } else {
        temp[2] = &bigToSmallMatrix[matrix->columns];
    }

    // note: if we had MultTransposeMatrix then we could use the identity
    // transpose(AB) = transpose(B) * transpose(A)
    // and avoid a copy step
    CopyMatrixTranspose(info, temp[0], matrix);
    MatrixMult(info, temp[1], temp[2], temp[0]);
    CopyMatrixTranspose(info, matrix, temp[1]);
    END_USING_TEMP_MATRIX(info->tempMatrix_m0);
    END_USING_TEMP_MATRIX(info->tempMatrix_m1);
}

void RetessMatrixV(NV_PATCH_INFO *info, int smallToBig, FDMatrix *matrix)
{

    FDMatrix *temp[3];

    BEGIN_USING_TEMP_MATRIX(info->tempMatrix_m0);
    BEGIN_USING_TEMP_MATRIX(info->tempMatrix_m1);
    temp[0] = &info->tempMatrix_m0;
    temp[1] = &info->tempMatrix_m1;
    if (smallToBig) {
        temp[2] = &smallToBigMatrix[matrix->rows];
    } else {
        temp[2] = &bigToSmallMatrix[matrix->rows];
    }

    // don't need a copy cause its not a transpose...
    MatrixMult(info, temp[1], temp[2], matrix);
    CopyMatrix(info, matrix, temp[1]);
    END_USING_TEMP_MATRIX(info->tempMatrix_m0);
    END_USING_TEMP_MATRIX(info->tempMatrix_m1);
}

void RetessMatrixUV(NV_PATCH_INFO *info, int smallToBig, FDMatrix *matrix)
{
    RetessMatrixU(info, smallToBig, matrix);
    RetessMatrixV(info, smallToBig, matrix);
}

void RetessMatrixSetU(NV_PATCH_INFO *info, int smallToBig, int evalEnables, FDMatrixAttrSet *pSet)
{
    int attr;

    for (attr = 0;  evalEnables;  attr++, evalEnables >>=1 ) {
        if (evalEnables & 1) {
            RetessMatrixU(info, smallToBig, (*pSet)[attr]);
        }
    }
}

void RetessMatrixSetV(NV_PATCH_INFO *info, int smallToBig, int evalEnables, FDMatrixAttrSet *pSet)
{
    int attr;

    for (attr = 0;  evalEnables;  attr++, evalEnables >>=1 ) {
        if (evalEnables & 1) {
            RetessMatrixV(info, smallToBig, (*pSet)[attr]);
        }
    }
}

void RetessMatrixSetUV(NV_PATCH_INFO *info, int smallToBig, int evalEnables, FDMatrixAttrSet *pSet)
{
    int attr;

    for (attr = 0;  evalEnables;  attr++, evalEnables >>=1 ) {
        if (evalEnables & 1) {
            RetessMatrixU(info, smallToBig, (*pSet)[attr]);
            RetessMatrixV(info, smallToBig, (*pSet)[attr]);
        }
    }
}

/*****************************************************************************/
/*****************************************************************************/
// Compare two vertices and return an edge direction
// a->b is 1, b->a is 0
static int CompareVertices(const float *a, const float *b)
{
    // Compare X
    if (a[0] > b[0]) {
        return 0;
    } else if (a[0] < b[0]) {
        return 1;
    }

    // Compare Y
    if (a[1] > b[1]) {
        return 0;
    } else if (a[1] < b[1]) {
        return 1;
    }

    // Compare Z
    if (a[2] > b[2]) {
        return 0;
    } else if (a[2] < b[2]) {
        return 1;
    }

    // Compare W
    if (a[3] > b[3]) {
        return 0;
    } else if (a[3] < b[3]) {
        return 1;
    }

    // actually, if the two points are equal, the "right" thing to do
    // would be to examine the interior control points to determine
    // a sorting.

    // Arbitrary case
    return 1;
}

#if defined(ENABLE_DEBUG_REVERSE_TRANSITIONS)
void
setDebugColors(int tri, NV_PATCH_INFO *info, NV_PATCH_MAP_INFO *map, int *u0Dir, int *u1Dir, int *v0Dir, int *v1Dir)
{
    int uorder = map->uorder;
    int vorder = map->vorder;
    int ufStride = map->ufStride;
    int vfStride = map->vfStride;
    float *rawData = map->rawData;
    float *pf;

    // test to force reverse transitions whether colors altered or not
    if (nvDebugOptions & TRO_TEMP1) {
        *u0Dir ^= 1;
    }
    if (nvDebugOptions & TRO_TEMP2) {
        *u1Dir ^= 1;
    }
    if (nvDebugOptions & TRO_TEMP3) {
        *v0Dir ^= 1;
    }
    if (nvDebugOptions & TRO_TEMP4) {
        *v1Dir ^= 1;
    }

    if (uorder < 4  ||  vorder < 4) {
        return;
    }

    if (nvDebugOptions & TRO_TEMP1) {
        pf = pRawData(info, map, rawData, 0, 1);
        pf[0] = 9.f; pf[1] = 0.f; pf[2] = 0.f; pf[3] = 1.f;
        pf += ufStride;
        pf[0] = 9.f; pf[1] = 0.f; pf[2] = 0.f; pf[3] = 1.f;
    }

    if (nvDebugOptions & TRO_TEMP2) {
        pf = pRawData(info, map, rawData, vorder-1, 1);
        pf[0] = 0.f; pf[1] = 9.f; pf[2] = 0.f; pf[3] = 1.f;
        pf += ufStride;
        pf[0] = 0.f; pf[1] = 9.f; pf[2] = 0.f; pf[3] = 1.f;
    }

    if (nvDebugOptions & TRO_TEMP3) {
        pf = pRawData(info, map, rawData, 1, 0);
        pf[0] = 0.f; pf[1] = 0.f; pf[2] = 9.f; pf[3] = 1.f;
        pf += vfStride;
        pf[0] = 0.f; pf[1] = 0.f; pf[2] = 9.f; pf[3] = 1.f;
    }

    if (nvDebugOptions & TRO_TEMP4) {
        pf = pRawData(info, map, rawData, 1, uorder-1-tri);
        pf[0] = 9.f; pf[1] = 0.f; pf[2] = 9.f; pf[3] = 1.f;
        pf += vfStride;
        if (tri) {
            pf -= 4;
        }
        pf[0] = 9.f; pf[1] = 0.f; pf[2] = 9.f; pf[3] = 1.f;
    }
}
#endif

// Compute the directions of the four edges of a patch
void ComputeEdgeDirections(NV_PATCH_INFO *info, int tri, NV_PATCH_MAP_INFO *map,
                           int *u0Dir, int *u1Dir, int *v0Dir, int *v1Dir)
{
    int uorder = map->uorder;
    int vorder = map->vorder;
    float *rawData = map->rawData;
    const float *p00, *p10, *p01, *p11; //p[x][y]

    if (rawData == NULL) {
        // assuming that unenabled maps have a null pointer
        // if we don't have a position punt for now and assume no reversals
        *u0Dir = *u1Dir = *v0Dir = *v1Dir = 1;
        return;
    }

    p00 = pRawData(info, map, rawData, 0,        0);
    p10 = pRawData(info, map, rawData, 0,        uorder-1);
    p01 = pRawData(info, map, rawData, vorder-1, 0       );
    p11 = pRawData(info, map, rawData, vorder-1, uorder-1);

    if (tri) {
        *u0Dir = *u1Dir = CompareVertices(p00, p10);
        *v0Dir = CompareVertices(p00, p01);
        *v1Dir = CompareVertices(p10, p01);
    } else {
        *u0Dir = CompareVertices(p00, p10);
        *u1Dir = CompareVertices(p01, p11);
        *v0Dir = CompareVertices(p00, p01);
        *v1Dir = CompareVertices(p10, p11);
    }

#if defined(ENABLE_DEBUG_REVERSE_TRANSITIONS)
    NV_TRACE_COND(TR_EVAL, 1,
        setDebugColors(tri, info, &map[3], u0Dir, u1Dir, v0Dir, v1Dir);
    );
    NV_TRACE_COND(TR_EVAL, 20,
        if (nvDebugOptions & TRO_TEMP1) { TPRINTF(("Change u0dir to %d\n", *u0Dir)); }
        if (nvDebugOptions & TRO_TEMP2) { TPRINTF(("Change u1dir to %d\n", *u1Dir)); }
        if (nvDebugOptions & TRO_TEMP3) { TPRINTF(("Change v0dir to %d\n", *v0Dir)); }
        if (nvDebugOptions & TRO_TEMP4) { TPRINTF(("Change v1dir to %d\n", *v1Dir)); }
    );
#endif
}

void ComputeEdgeDirectionsFromCorners(NV_PATCH_INFO *info, int tri,
                           int *u0Dir, int *u1Dir, int *v0Dir, int *v1Dir)
{
    const float *p00, *p10, *p01, *p11; //p[x][y]

    //cornAttr[attrib][v][u][xyzw]
    p00 = &(info->quadInfo->cornAttr[0].corners[0][0][0]); //    p00 = pRawData(info, map, rawData, 0,        0);
    p10 = &(info->quadInfo->cornAttr[0].corners[0][1][0]); //    p10 = pRawData(info, map, rawData, 0,        uorder-1);
    p01 = &(info->quadInfo->cornAttr[0].corners[1][0][0]); //    p01 = pRawData(info, map, rawData, vorder-1, 0       );
    p11 = &(info->quadInfo->cornAttr[0].corners[1][1][0]); //    p11 = pRawData(info, map, rawData, vorder-1, uorder-1);

    if (tri) {
        *u0Dir = *u1Dir = CompareVertices(p00, p10);
        *v0Dir = CompareVertices(p00, p01);
        *v1Dir = CompareVertices(p10, p01);
    } else {
        *u0Dir = CompareVertices(p00, p10);
        *u1Dir = CompareVertices(p01, p11);
        *v0Dir = CompareVertices(p00, p01);
        *v1Dir = CompareVertices(p10, p11);
    }

#if defined(ENABLE_DEBUG_REVERSE_TRANSITIONS)
    nvAssert(0); //shouldn't ever really get this in OGL without Cached patches which they don't have
/*
    NV_TRACE_COND(TR_EVAL, 1,
        setDebugColors(tri, info, &map[3], u0Dir, u1Dir, v0Dir, v1Dir);
    );
    NV_TRACE_COND(TR_EVAL, 20,
        if (nvDebugOptions & TRO_TEMP1) { TPRINTF(("Change u0dir to %d\n", *u0Dir)); }
        if (nvDebugOptions & TRO_TEMP2) { TPRINTF(("Change u1dir to %d\n", *u1Dir)); }
        if (nvDebugOptions & TRO_TEMP3) { TPRINTF(("Change v0dir to %d\n", *v0Dir)); }
        if (nvDebugOptions & TRO_TEMP4) { TPRINTF(("Change v1dir to %d\n", *v1Dir)); }
    );
*/
#endif
}


#if defined(ENABLE_DEBUG_SWATH) && defined(IS_OPENGL)
/*****************************************************************************/
int onColor = 0;
float evalColors[8][3] = {
        {1, 0, 0},
        {0, 1, 0},
        {0, 0, 1},
        {0, 1, 1},
        {1, 0, 1},
        {1, 1, 0},
        {1, 1, 1},
        {0, 0, 0},
    };
void evalDrawCurve(NV_PATCH_INFO *info, NV_PATCH_CURVE_INFO *pCurve, int scaleDown)
{
    int ii, lColor;
    NV_PATCH_CURVE_INFO curve;

    if (scaleDown & 8) {
        scaleDown = (info->swatchFlags & NV_PATCH_SWATCH);
    }
    glColor3fv(evalColors[(onColor++) & 0x7]);
    CopyCurve(info, &curve, pCurve);
    if ((info->swatchFlags & NV_PATCH_SWATCH)  &&  scaleDown) {
        RetessCurveInOut(info, 0, &curve, &curve);
    }
    glBegin(GL_LINE_STRIP);
    for (ii = 0;  ii < 4;  ii++) {
        glVertex3fv(curve.coeffs[0]);
        OffsetCurve(info, &curve, 1);
    }
    glEnd();

    CopyCurve(info, &curve, pCurve);
    if (scaleDown) {
        RetessCurveInOut(info, 0, &curve, &curve);
    }
    lColor = 0;
    glPointSize(8.f);
    glBegin(GL_POINTS);
    for (ii = 0;  ii < 4;  ii++) {
        glColor3fv(evalColors[(lColor++) & 0x7]);
        glVertex3fv(curve.coeffs[0]);
        OffsetCurve(info, &curve, 1);
    }
    glEnd();
}

void evalDrawMatrix(NV_PATCH_INFO *info, const FDMatrix *m, int bigU, int bigV)
{
    NV_PATCH_CURVE_INFO curveU, curveV;
    FDMatrix lm;
    int row;

    ExtractUCurve(info, &curveU, m);
    ExtractVCurve(info, &curveV, m);

    evalDrawCurve(info, &curveU, bigU);

    evalDrawCurve(info, &curveV, bigV);

    CopyMatrix(info, &lm, m);

    if (bigV & 8) {
        bigV = (info->swatchFlags & NV_PATCH_SWATCH);
    }
    if (bigV) {
        RetessMatrixV(info, 0, &lm);
    }
    for (row = 0;  row < 3;  row++) {
        OffsetFDMatrix(info, &lm, 0, 1);
        ExtractUCurve(info, &curveU, &lm);
        evalDrawCurve(info, &curveU, bigU);
    }
}
#endif  // defined(ENABLE_DEBUG_SWATH) && defined(IS_OPENGL)

/*****************************************************************************/
// Load m with a Bezier basis matrix, or the inverse of a Bezier basis matrix
void ComputeBasis(int order, int inverse, FDMatrix *m)
{
    int row, col;
    float *matrix = NULL;

    // Inverse matrices have been pulled out for now, as the current code does not need them
    nvAssert(inverse == 0);

    // nxn matrix where n = order
    m->rows = m->columns = order;

    // Select the appropriate matrix
    matrix = bezBasis[order-1];

    if (!matrix) { nvAssert(0); return; }

    // Load matrix
    for (row = 0; row < order; row++) {
        for (col = 0; col < order; col++) {
            float coeff = *matrix++;
            m->data[row][col][0] = coeff;
            m->data[row][col][1] = coeff;
            m->data[row][col][2] = coeff;
            m->data[row][col][3] = coeff;
        }
    }
}

// Compute the matrix 'P' for FD coefficients, as defined by Henry's paper
void ComputeP(int order, float step, FDMatrix *m)
{
    int row, col, i;
    float f;

    // nxn matrix where n = order
    m->rows = m->columns = order;

    // Fill with zeros
    for (row = 0; row < order; row++) {
        for (col = 0; col < order; col++) {
            m->data[row][col][0] = 0.0f;
            m->data[row][col][1] = 0.0f;
            m->data[row][col][2] = 0.0f;
            m->data[row][col][3] = 0.0f;
        }
    }

    // Fill in diagonal
    for (i = order-1, f = 1.0f; i >= 0; i--, f *= step) {
        m->data[i][i][0] = f;
        m->data[i][i][1] = f;
        m->data[i][i][2] = f;
        m->data[i][i][3] = f;
    }
}

// Compute the matrix to convert from a power basis to an FD basis
void ComputePowerToFD(int order, FDMatrix *m, int flags)
{
    int row, col;
    float *matrix;

    // nxn matrix where n = order
    m->rows = m->columns = order;

    if (flags & 1) {
        matrix = inversePowerToFD[order-1];
    } else {
        matrix = powerToFD[order-1];
    }

    // Load matrix
    for (row = 0; row < order; row++) {
        for (col = 0; col < order; col++) {
            float coeff = *matrix++;
            if (flags & 2) {
                coeff *= oofactorial[row];
            }
            m->data[row][col][0] = coeff;
            m->data[row][col][1] = coeff;
            m->data[row][col][2] = coeff;
            m->data[row][col][3] = coeff;
        }
    }
}

/*****************************************************************************/
// Extract the U curve from a FDMatrix into a curve
void ExtractUCurve(NV_PATCH_INFO *info, NV_PATCH_CURVE_INFO *dst, const FDMatrix *m)
{
    dst->order = m->columns;
    __NV_MEMCPY(dst->coeffs[0], m->data[0][0], 4*m->columns*sizeof(float));
}

void ExtractUCurveSet(NV_PATCH_INFO *info, int evalEnables, FDCurveAttrSet *dst, FDMatrixAttrSet *pSet)
{
    int index;

    for (index = 0; index < info->maxAttr; index++) {
        if (evalEnables & (1 << index)) {
            ExtractUCurve(info, (*dst)[index], (*pSet)[index]);
        }
    }
}

/*****************************************************************************/
// Compare the V curve from a FDMatrix to a curve
void CompareVCurveMatrix(NV_PATCH_CURVE_INFO *dst, FDMatrix *m)
{
    int i, stride = 4*sizeof(float);
    float *data = dst->coeffs[0];

    nvAssert(dst->order == m->rows);
    // Empty data
    for (i = 0; i < dst->order; i++) {
        // Compare data
        nvAssert(EV_AS_INT(data[0]) == EV_AS_INT(m->data[i][0][0]));
        nvAssert(EV_AS_INT(data[1]) == EV_AS_INT(m->data[i][0][1]));
        nvAssert(EV_AS_INT(data[2]) == EV_AS_INT(m->data[i][0][2]));
        nvAssert(EV_AS_INT(data[3]) == EV_AS_INT(m->data[i][0][3]));

        // Step pointer
        data = (float *)((char *)data + stride);
    }
}

// Extract the V curve from a FDMatrix into a curve
void ExtractVCurve(NV_PATCH_INFO *info, NV_PATCH_CURVE_INFO *dst, const FDMatrix *m)
{
    int i, stride = 4*sizeof(float);
    float *data = dst->coeffs[0];

    dst->order = m->rows;
    for (i = 0; i < dst->order; i++) {
        // Copy data
        CopyPoint(data, m->data[i][0]);

        // Step pointer
        data = (float *)((char *)data + stride);
    }
}

void ExtractVCurveSet(NV_PATCH_INFO *info, int evalEnables, FDCurveAttrSet *dst, FDMatrixAttrSet *pSet)
{
    int index;

    for (index = 0; index < info->maxAttr; index++) {
        if (evalEnables & (1 << index)) {
            ExtractVCurve(info, (*dst)[index], (*pSet)[index]);
        }
    }
}

/*****************************************************************************/
extern const double *evalRetessTables[NV_PATCH_MAX_RETESS];
void evalFillPower(double r, double *prPower)
{
    prPower[1] = r;
    prPower[2] = r*r;
    prPower[3] = prPower[2] * r;
    prPower[4] = prPower[2] * prPower[2];
    prPower[5] = prPower[4] * r;
    prPower[6] = prPower[4] * prPower[2];
    prPower[7] = prPower[4] * prPower[3];
    prPower[8] = prPower[4] * prPower[4];
    prPower[9] = prPower[8] * r;
    prPower[10] = prPower[8] * prPower[2];
    prPower[11] = prPower[8] * prPower[3];
    prPower[12] = prPower[8] * prPower[4];
    prPower[13] = prPower[8] * prPower[5];
    prPower[14] = prPower[8] * prPower[6];
    prPower[15] = prPower[8] * prPower[7];
    //ffprPower[16] = prPower[8] * prPower[8];
    //ffprPower[17] = prPower[16] * r;
    //ffprPower[18] = prPower[16] * prPower[2];
}

void evalFillOneRetessMatrix(NV_PATCH_INFO *info, double *prPower, int order, FDMatrix *dst)
{
    int elem, idx, row, col;
    double dd;
    const double *prTable;

    (*dst).rows = order;
    (*dst).columns = order;
    for (row = 0;  row < order;  row++) {
        for (col = 0;  col < order;  col++) {
            idx = order * (order * row + col);
            prTable = &evalRetessTables[order][idx];
            dd = 0.;
            for (elem = 0;  elem < order;  elem++) {
                dd += prPower[elem] * prTable[elem];
            }
            (*dst).data[row][col][0] = dd;
            (*dst).data[row][col][1] = dd;
            (*dst).data[row][col][2] = dd;
            (*dst).data[row][col][3] = dd;
        }
    }
    NV_TRACE_COND(TR_EVAL, 55,
        TPRINTF(("calc retess matrix r=%g order=%d\n", prPower[1], order));
        TraceMatrix(info, dst);
    );
}

void evalFillOnePowerAndRetessMatrix(NV_PATCH_INFO *info, int order, float newOverOld, FDMatrix *dst)
{
    double rPower[NV_PATCH_MAX_RETESS] = {1.};

    evalFillPower(newOverOld, rPower);
    evalFillOneRetessMatrix(info, rPower, order, dst);
}

void evalFillAllRetessMatrices(NV_PATCH_INFO *info, float newOverOld, FDMatrix *dst)
{
    int order;
    double rPower[NV_PATCH_MAX_RETESS] = {1.};

    evalFillPower(newOverOld, rPower);
    for (order = 2;  order < NV_PATCH_MAX_RETESS;  order++) {
        evalFillOneRetessMatrix(info, rPower, order, &dst[order]);
    }
}

void evalFillRetessMatrices(NV_PATCH_INFO *info)
// note: order = (degree + 1)
{
    int degree;

    factorial[0] = 1.;
    factorial[1] = 1.;
    for (degree = 2;  degree <= NV_PATCH_MAX_RETESS;  degree++) {
        factorial[degree] = degree * factorial[degree-1];
    }
    for (degree = 0;  degree <= NV_PATCH_MAX_RETESS;  degree++) {
        oofactorial[degree] = 1. / factorial[degree];
    }

    evalFillAllRetessMatrices(info, info->maxSwatch,      smallToBigMatrix);
    evalFillAllRetessMatrices(info, 1. / info->maxSwatch, bigToSmallMatrix);
    nvAssert(retessGuard == 0xfeed1);   // attempt to catch init over-runs
}

/*****************************************************************************/
// Check the retessllation cache to see if we've cached some work here
int CheckRetessellationCache(NV_PATCH_INFO *info, unsigned int tag1, unsigned int tag2, FDMatrix **m)
{
    //m should be null because it will be overwritten here.
    nvAssert(*m==NULL);

    if (g_FDGlobalData.RetessFDtag[0][0] == tag1 && g_FDGlobalData.RetessFDtag[0][1] == tag2) {
        *m = g_FDGlobalData.RetessFDCache[0];
        g_FDGlobalData.RetessFDMRU = 0;
    } else if (g_FDGlobalData.RetessFDtag[1][0] == tag1 && g_FDGlobalData.RetessFDtag[1][1] == tag2) {
        *m = g_FDGlobalData.RetessFDCache[1];
        g_FDGlobalData.RetessFDMRU = 1;
    } else {
        *m = (FDMatrix *)__NV_MALLOC(info->context, sizeof(FDMatrix));

        //replace cache slot with newly computed value
        g_FDGlobalData.RetessFDMRU = (1-g_FDGlobalData.RetessFDMRU);
        if (g_FDGlobalData.RetessFDCache[g_FDGlobalData.RetessFDMRU]) {
            __NV_FREE(info->context, g_FDGlobalData.RetessFDCache[g_FDGlobalData.RetessFDMRU]);
        }
        g_FDGlobalData.RetessFDCache[g_FDGlobalData.RetessFDMRU] = *m;
        g_FDGlobalData.RetessFDtag[g_FDGlobalData.RetessFDMRU][0] = tag1;
        g_FDGlobalData.RetessFDtag[g_FDGlobalData.RetessFDMRU][1] = tag2;
        return 0;
    }

    return 1;
}

/*****************************************************************************/
// Compute FD coefficients from curve control points
void ComputeFDCurveFlip(NV_PATCH_INFO *info, int order, float step, NV_PATCH_CURVE_INFO *pCurve,
                const float *points, int stride, int dir, int flipped)
{
    float *coeffs = pCurve->coeffs[0];
    FDMatrix *basis, *m, *p;
    FDMatrix *temp[3];
    EV_ALLOC_DECL();
#ifdef DCR_COMPUTEFDCURVEFLIP_OPT
    unsigned int tag1, tag2;
#endif
    int mbytes = EV_ROUND(sizeof(FDMatrixd));

    EV_ALLOC_INIT_WITH_CACHE(info->context, /*16 + 2* */6 * mbytes, computeFDCurveCoeffsEnd, info->pCache[EV_CACHE_9FDMATRICES]);
#if 0
if (*(int *)evMemory.pBase & 8) {
    EV_ALLOC(basis, info->context, 8);
}

EV_ALLOC(ptemp, info->context, mbytes);
EV_ALLOC(ptemp, info->context, mbytes);
EV_ALLOC(ptemp, info->context, mbytes);
#endif
    EV_ALLOC(basis, info->context, mbytes);
    EV_ALLOC(m, info->context, mbytes);
    EV_ALLOC(p, info->context, mbytes);
    EV_ALLOC(temp[0], info->context, mbytes);
    EV_ALLOC(temp[1], info->context, mbytes);
    EV_ALLOC(temp[2], info->context, mbytes);
//ffEV_ALLOC(ptemp, info->context, mbytes);
//ffEV_ALLOC(ptemp, info->context, mbytes);
//ffEV_ALLOC(ptemp, info->context, mbytes);
    EV_ALLOC_FULL(info->context);

    if (flipped) {
        stride = -stride;
    }
    // Reverse direction of points if necessary
    if (!dir) {
        points = (const float *)((const char *)points + (order-1)*stride);
        stride = -stride;
    }

#if 0
if (order == 6 && dotime) {
dotime = 0;
tprintf("\ntime curve info: order %d\n", order);
PrintInt(mbytes);
PrintInt(basis);
PrintInt(p);
PrintInt(m);
PrintInt(temp[0]);
PrintInt(temp[1]);
PrintInt(temp[2]);

    ComputeBasisd(order, 0, (FDMatrixd *)basis);
    ComputePd(order, step, (FDMatrixd *)p);
    ComputePowerToFDd(order, (FDMatrixd *)m, 0);

    FillMatrixd(info, 0, (FDMatrixd *)basis);
    FillMatrixd(info, 0, (FDMatrixd *)p);
    FillMatrixd(info, 0, (FDMatrixd *)m);
    MatrixMultd(info, (FDMatrixd *)temp[0], (FDMatrixd *)p, (FDMatrixd *)basis);
    MatrixMultd(info, (FDMatrixd *)temp[1], (FDMatrixd *)p, (FDMatrixd *)basis);
    MatrixMultd(info, (FDMatrixd *)temp[2], (FDMatrixd *)m, (FDMatrixd *)temp[1]);
    FillMatrixd(info, 0, (FDMatrixd *)temp[0]);
    FillMatrixd(info, 0, (FDMatrixd *)temp[1]);
    FillMatrixd(info, 0, (FDMatrixd *)temp[2]);

//ffTIME_CODE_REPEAT(nRepeat, 1, "double 1 P B",
    //ffMatrixMultd(info, (FDMatrixd *)temp[1], (FDMatrixd *)p, (FDMatrixd *)basis);
//ff); 
//ffTIME_CODE_REPEAT(nRepeat, 1, "double 2 M 1",
    //ffMatrixMultd(info, (FDMatrixd *)temp[2], (FDMatrixd *)m, (FDMatrixd *)temp[1]);
//ff);

VtResumeSampling();
TIME_CODE_REPEAT(nRepeat, 1, "double P M B",
    MatrixMultd(info, (FDMatrixd *)p, (FDMatrixd *)m, (FDMatrixd *)basis);
);
VtPauseSampling();

TIME_CODE_REPEAT(nRepeat, 1, "double 0 M B",
    MatrixMultd(info, (FDMatrixd *)temp[0], (FDMatrixd *)m, (FDMatrixd *)basis);
);
#if 0
TIME_CODE_REPEAT(nRepeat, 1, "double 1 M B",
    MatrixMultd(info, (FDMatrixd *)temp[1], (FDMatrixd *)m, (FDMatrixd *)basis);
);
TIME_CODE_REPEAT(nRepeat, 1, "double 2 M B",
    MatrixMultd(info, (FDMatrixd *)temp[2], (FDMatrixd *)m, (FDMatrixd *)basis);
);
//...
TIME_CODE_REPEAT(nRepeat, 1, "double P M B rev",
    MatrixMultd(info, (FDMatrixd *)p, (FDMatrixd *)basis, (FDMatrixd *)m);
);
TIME_CODE_REPEAT(nRepeat, 1, "double 0 M B rev",
    MatrixMultd(info, (FDMatrixd *)temp[0], (FDMatrixd *)basis, (FDMatrixd *)m);
);
TIME_CODE_REPEAT(nRepeat, 1, "double 1 M B rev",
    MatrixMultd(info, (FDMatrixd *)temp[1], (FDMatrixd *)basis, (FDMatrixd *)m);
);
TIME_CODE_REPEAT(nRepeat, 1, "double 2 M B rev",
    MatrixMultd(info, (FDMatrixd *)temp[2], (FDMatrixd *)basis, (FDMatrixd *)m);
);

TIME_CODE_REPEAT(nRepeat, 1, "double 0 P B",
    MatrixMultd(info, (FDMatrixd *)temp[0], (FDMatrixd *)p, (FDMatrixd *)basis);
);
TIME_CODE_REPEAT(nRepeat, 1, "double 1 P B",
    MatrixMultd(info, (FDMatrixd *)temp[1], (FDMatrixd *)p, (FDMatrixd *)basis);
);
TIME_CODE_REPEAT(nRepeat, 1, "double 1 P B",
    MatrixMultd(info, (FDMatrixd *)temp[1], (FDMatrixd *)p, (FDMatrixd *)basis);
);
//...
TIME_CODE_REPEAT(nRepeat, 1, "double 0 P B rev",
    MatrixMultd(info, (FDMatrixd *)temp[0], (FDMatrixd *)basis, (FDMatrixd *)p);
);
TIME_CODE_REPEAT(nRepeat, 1, "double 1 P B rev",
    MatrixMultd(info, (FDMatrixd *)temp[1], (FDMatrixd *)basis, (FDMatrixd *)p);
);
TIME_CODE_REPEAT(nRepeat, 1, "double 1 P B rev",
    MatrixMultd(info, (FDMatrixd *)temp[1], (FDMatrixd *)basis, (FDMatrixd *)p);
);

TIME_CODE_REPEAT(nRepeat, 1, "double 0 P B",
    MatrixMultd(info, (FDMatrixd *)temp[1], (FDMatrixd *)temp[0], (FDMatrixd *)basis);
);
TIME_CODE_REPEAT(nRepeat, 1, "double 0 P B",
    MatrixMultd(info, (FDMatrixd *)temp[2], (FDMatrixd *)temp[0], (FDMatrixd *)basis);
);
//...
TIME_CODE_REPEAT(nRepeat, 1, "double 0 P B rev",
    MatrixMultd(info, (FDMatrixd *)temp[1], (FDMatrixd *)basis, (FDMatrixd *)temp[0]);
);
TIME_CODE_REPEAT(nRepeat, 1, "double 0 P B rev",
    MatrixMultd(info, (FDMatrixd *)temp[2], (FDMatrixd *)basis, (FDMatrixd *)temp[0]);
);
#endif

}
#endif

#ifdef DCR_COMPUTEFDCURVEFLIP_OPT
    temp[2] = NULL;
    tag1 = (0xFFFF0000 | order);
    tag2 = *(unsigned int *)(&step);
    if (!CheckRetessellationCache(info, tag1, tag2, &temp[2])) 
    {
        // Compute matrices for the calculation
        ComputeBasis(order, 0, basis);
        ComputeP(order, step, p);
        ComputePowerToFD(order, m, 0);
        MatrixMult(info, temp[1], p, basis);
        MatrixMult(info, temp[2], m, temp[1]);
    }
    // Compute FD curve coefficients
    FillColumnVectorMatrix(order, stride, points, temp[0], 0);
    MatrixMult(info, temp[1], temp[2], temp[0]);
    EmptyColumnVectorMatrix(order, temp[1], 4*sizeof(float), coeffs, 0);
#else
    // Compute matrices for the calculation
    ComputeBasis(order, 0, basis);
    ComputeP(order, step, p);
    ComputePowerToFD(order, m, 0);

    // Compute FD curve coefficients
    FillColumnVectorMatrix(order, stride, points, temp[0], 0);
    MatrixMult(info, temp[1], basis, temp[0]);
    MatrixMult(info, temp[0], p, temp[1]);
    MatrixMult(info, temp[1], m, temp[0]);
    EmptyColumnVectorMatrix(order, temp[1], 4*sizeof(float), coeffs, 0);
#endif

    NV_TRACE_COND(TR_EVAL, 35,
        int i;

        TPRINTF(("FDCurve order=%d  stride=%d  dir=%d\n", order, stride, dir));
        for (i = 0;  i < order;  i++) {
            TPRINTF(("\t%d) [%7.5f %7.5f %7.5f %7.5f]\n", i, coeffs[i*4+0], coeffs[i*4+1], coeffs[i*4+2], coeffs[i*4+3]));
        }
        TPRINTF(("\n"));
    );
computeFDCurveCoeffsEnd:
    EV_FREE(basis, info->context);
    EV_FREE(m, info->context);
    EV_FREE(p, info->context);
    EV_FREE(temp[0], info->context);
    EV_FREE(temp[1], info->context);
}

#define ONE_HALF 0.5
#define ONE_SIXTH 1.0f/6.0f
#define ONE_ONE_TWENTIETH 1.0f/120.0f
#define ONE_TWENTY_FOURTH 1.0f/24.0f
#define ONE_TWELFTH 1.0f/12.0f
#define ONE_FOURTH 1.0f/4.0f
void ComputeReversedRetessellation(NV_PATCH_INFO *info, int order, float a, float b, FDMatrix *temp[3], FDMatrix *m, FDMatrix *p, FDMatrix *mInv)
{
    float ib,ib2,ib3,ib4,ib5,b2,b3,b4;
    float r,r2,r3,r4,r5;    
    float ftemp;   
    FDMatrix *outMatrix = temp[2];
    r=a/b;
    switch(order-1) {                
    case 3: //cubic
        ib = 1/b; ib2 = ib*ib; ib3 = ib2*ib; r2 = r*r; r3 = r2*r;
        outMatrix->rows = outMatrix->columns = order;        
        outMatrix->data[0][0][3] = outMatrix->data[0][0][2] = outMatrix->data[0][0][1] = outMatrix->data[0][0][0] = 1;
        outMatrix->data[0][1][3] = outMatrix->data[0][1][2] = outMatrix->data[0][1][1] = outMatrix->data[0][1][0] = ib;    ftemp = (1-b)*ONE_HALF*ib2;
        outMatrix->data[0][2][3] = outMatrix->data[0][2][2] = outMatrix->data[0][2][1] = outMatrix->data[0][2][0] = ftemp; ftemp = (-1+b)*(-1+2*b)*ONE_SIXTH*ib3;
        outMatrix->data[0][3][3] = outMatrix->data[0][3][2] = outMatrix->data[0][3][1] = outMatrix->data[0][3][0] = ftemp;    

        outMatrix->data[1][0][3] = outMatrix->data[1][0][2] = outMatrix->data[1][0][1] = outMatrix->data[1][0][0] = 0;
        outMatrix->data[1][1][3] = outMatrix->data[1][1][2] = outMatrix->data[1][1][1] = outMatrix->data[1][1][0] = -r;    ftemp = r*(-2+b+b*r)*ONE_HALF*ib;
        outMatrix->data[1][2][3] = outMatrix->data[1][2][2] = outMatrix->data[1][2][1] = outMatrix->data[1][2][0] = ftemp; ftemp = -r*(3+b*(2+r)*(-3+b+b*r))*ONE_SIXTH*ib2;
        outMatrix->data[1][3][3] = outMatrix->data[1][3][2] = outMatrix->data[1][3][1] = outMatrix->data[1][3][0] = ftemp;    

        outMatrix->data[2][0][3] = outMatrix->data[2][0][2] = outMatrix->data[2][0][1] = outMatrix->data[2][0][0] = 0;
        outMatrix->data[2][1][3] = outMatrix->data[2][1][2] = outMatrix->data[2][1][1] = outMatrix->data[2][1][0] = 0;
        outMatrix->data[2][2][3] = outMatrix->data[2][2][2] = outMatrix->data[2][2][1] = outMatrix->data[2][2][0] = r2;    ftemp = -r2*(-1+b+b*r)*ib;
        outMatrix->data[2][3][3] = outMatrix->data[2][3][2] = outMatrix->data[2][3][1] = outMatrix->data[2][3][0] = ftemp;    

        outMatrix->data[3][0][3] = outMatrix->data[3][0][2] = outMatrix->data[3][0][1] = outMatrix->data[3][0][0] = 0;
        outMatrix->data[3][1][3] = outMatrix->data[3][1][2] = outMatrix->data[3][1][1] = outMatrix->data[3][1][0] = 0;
        outMatrix->data[3][2][3] = outMatrix->data[3][2][2] = outMatrix->data[3][2][1] = outMatrix->data[3][2][0] = 0;
        outMatrix->data[3][3][3] = outMatrix->data[3][3][2] = outMatrix->data[3][3][1] = outMatrix->data[3][3][0] = -r3;       
        return;        
    case 5:
        ib = 1/b; ib2 = ib*ib; ib3 = ib2*ib; ib4 = ib2*ib2; ib5 = ib4*ib; 
        r2 = r*r; r3 = r2*r, r4=r2*r2; r5=r3*r2;
        b2 = b*b; b3 = b2*b; b4 = b2*b2;
        outMatrix->rows = outMatrix->columns = order;        
        outMatrix->data[0][0][3] = outMatrix->data[0][0][2] = outMatrix->data[0][0][1] = outMatrix->data[0][0][0] = 1;
        outMatrix->data[0][1][3] = outMatrix->data[0][1][2] = outMatrix->data[0][1][1] = outMatrix->data[0][1][0] = ib;    ftemp = (1-b)*ONE_HALF*ib2;
        outMatrix->data[0][2][3] = outMatrix->data[0][2][2] = outMatrix->data[0][2][1] = outMatrix->data[0][2][0] = ftemp; ftemp = (-1+b)*(-1+2*b)*ONE_SIXTH*ib3;
        outMatrix->data[0][3][3] = outMatrix->data[0][3][2] = outMatrix->data[0][3][1] = outMatrix->data[0][3][0] = ftemp; ftemp = (1+b*(-6+(11-6*b)*b))*ONE_TWENTY_FOURTH*ib4;    
        outMatrix->data[0][4][3] = outMatrix->data[0][4][2] = outMatrix->data[0][4][1] = outMatrix->data[0][4][0] = ftemp; ftemp = (-1+b)*(-1+2*b)*(-1+3*b)*(-1+4*b)*ONE_ONE_TWENTIETH*ib5;
        outMatrix->data[0][5][3] = outMatrix->data[0][5][2] = outMatrix->data[0][5][1] = outMatrix->data[0][5][0] = ftemp;    

        outMatrix->data[1][0][3] = outMatrix->data[1][0][2] = outMatrix->data[1][0][1] = outMatrix->data[1][0][0] = 0;
        outMatrix->data[1][1][3] = outMatrix->data[1][1][2] = outMatrix->data[1][1][1] = outMatrix->data[1][1][0] = -r;    ftemp = r*(-2+b+b*r)*ONE_HALF*ib;
        outMatrix->data[1][2][3] = outMatrix->data[1][2][2] = outMatrix->data[1][2][1] = outMatrix->data[1][2][0] = ftemp; ftemp = -r*(3+b*(2+r)*(-3+b+b*r))*ONE_SIXTH*ib2;
        outMatrix->data[1][3][3] = outMatrix->data[1][3][2] = outMatrix->data[1][3][1] = outMatrix->data[1][3][0] = ftemp; ftemp = r*(2+b2*(1+r)*(2+r)-2*b*(3+r))*(-2+b*(3+r))*ONE_TWENTY_FOURTH*ib3;
        outMatrix->data[1][4][3] = outMatrix->data[1][4][2] = outMatrix->data[1][4][1] = outMatrix->data[1][4][0] = ftemp; ftemp = r*(-5+10*b*(4+r)-b4*(1+r)*(2+r)*(3+r)*(4+r)+5*b3*(4+r)*(5+r*(4+r))-5*b2*(21+2*r*(6+r)))*ONE_ONE_TWENTIETH*ib4;
        outMatrix->data[1][5][3] = outMatrix->data[1][5][2] = outMatrix->data[1][5][1] = outMatrix->data[1][5][0] = ftemp;    

        outMatrix->data[2][0][3] = outMatrix->data[2][0][2] = outMatrix->data[2][0][1] = outMatrix->data[2][0][0] = 0;
        outMatrix->data[2][1][3] = outMatrix->data[2][1][2] = outMatrix->data[2][1][1] = outMatrix->data[2][1][0] = 0;
        outMatrix->data[2][2][3] = outMatrix->data[2][2][2] = outMatrix->data[2][2][1] = outMatrix->data[2][2][0] = r2;    ftemp = -r2*(-1+b+b*r)*ib;
        outMatrix->data[2][3][3] = outMatrix->data[2][3][2] = outMatrix->data[2][3][1] = outMatrix->data[2][3][0] = ftemp; ftemp = r2*(6-6*b*(3+2*r)+b2*(1+r)*(11+7*r))*ib2*ONE_TWELFTH;
        outMatrix->data[2][4][3] = outMatrix->data[2][4][2] = outMatrix->data[2][4][1] = outMatrix->data[2][4][0] = ftemp; ftemp = -r2*(-1+b*(2+r))*(2-4*b*(2+r)+b2*(1+r)*(5+3*r))*ONE_TWELFTH*ib3;
        outMatrix->data[2][5][3] = outMatrix->data[2][5][2] = outMatrix->data[2][5][1] = outMatrix->data[2][5][0] = ftemp;    

        outMatrix->data[3][0][3] = outMatrix->data[3][0][2] = outMatrix->data[3][0][1] = outMatrix->data[3][0][0] = 0;
        outMatrix->data[3][1][3] = outMatrix->data[3][1][2] = outMatrix->data[3][1][1] = outMatrix->data[3][1][0] = 0;
        outMatrix->data[3][2][3] = outMatrix->data[3][2][2] = outMatrix->data[3][2][1] = outMatrix->data[3][2][0] = 0;
        outMatrix->data[3][3][3] = outMatrix->data[3][3][2] = outMatrix->data[3][3][1] = outMatrix->data[3][3][0] = -r3;   ftemp = r3*(-2+3*b*(1+r))*ONE_HALF*ib;     
        outMatrix->data[3][4][3] = outMatrix->data[3][4][2] = outMatrix->data[3][4][1] = outMatrix->data[3][4][0] = ftemp; ftemp = -r3*(2-2*b*(4+3*r)+b2*(1+r)*(7+5*r))*ONE_FOURTH*ib2;
        outMatrix->data[3][5][3] = outMatrix->data[3][5][2] = outMatrix->data[3][5][1] = outMatrix->data[3][5][0] = ftemp;       

        outMatrix->data[4][0][3] = outMatrix->data[4][0][2] = outMatrix->data[4][0][1] = outMatrix->data[4][0][0] = 0;
        outMatrix->data[4][1][3] = outMatrix->data[4][1][2] = outMatrix->data[4][1][1] = outMatrix->data[4][1][0] = 0;
        outMatrix->data[4][2][3] = outMatrix->data[4][2][2] = outMatrix->data[4][2][1] = outMatrix->data[4][2][0] = 0;
        outMatrix->data[4][3][3] = outMatrix->data[4][3][2] = outMatrix->data[4][3][1] = outMatrix->data[4][3][0] = 0;   
        outMatrix->data[4][4][3] = outMatrix->data[4][4][2] = outMatrix->data[4][4][1] = outMatrix->data[4][4][0] = r4;    ftemp = r4*(1-2*b*(1+r))*ib;
        outMatrix->data[4][5][3] = outMatrix->data[4][5][2] = outMatrix->data[4][5][1] = outMatrix->data[4][5][0] = ftemp;       

        outMatrix->data[5][0][3] = outMatrix->data[5][0][2] = outMatrix->data[5][0][1] = outMatrix->data[5][0][0] = 0;
        outMatrix->data[5][1][3] = outMatrix->data[5][1][2] = outMatrix->data[5][1][1] = outMatrix->data[5][1][0] = 0;
        outMatrix->data[5][2][3] = outMatrix->data[5][2][2] = outMatrix->data[5][2][1] = outMatrix->data[5][2][0] = 0;
        outMatrix->data[5][3][3] = outMatrix->data[5][3][2] = outMatrix->data[5][3][1] = outMatrix->data[5][3][0] = 0;
        outMatrix->data[5][4][3] = outMatrix->data[5][4][2] = outMatrix->data[5][4][1] = outMatrix->data[5][4][0] = 0;
        outMatrix->data[5][5][3] = outMatrix->data[5][5][2] = outMatrix->data[5][5][1] = outMatrix->data[5][5][0] = -r5;
        return;
    default: 
    case 1:
    case 9:
        //THESE CONVERSION MATRICES NEED TO BE ADDED.
        nvAssert(0);
        break;
    }

    // Compute matrices for the calculation
    ComputePowerToFD(order, m, 0);
    ComputeP(order, r, p);
    ComputePowerToFD(order, mInv, 1);
    MatrixMult(info, temp[1], p, mInv);
    MatrixMult(info, temp[2], m, temp[1]);
    return;
}

/*****************************************************************************/
// Compute FD coefficients from curve control points
void RetessellateFDCurveInOut(NV_PATCH_INFO *info, float stepOld, float stepNew,
                    NV_PATCH_CURVE_INFO *curve, NV_PATCH_CURVE_INFO *curveOut, int reverseDirection)
{
    FDMatrix *m, *p, *mInv;
    FDMatrix *temp[3];
    EV_ALLOC_DECL();
    float ratio;
#ifdef DCR_HOS_RETESSCURVE_OPT
    unsigned int tag1, tag2;
#endif

    EV_ALLOC_INIT_WITH_CACHE(info->context, 5 * sizeof(FDMatrix), computeFDCurveCoeffsEnd, info->pCache[EV_CACHE_9FDMATRICES]);
    EV_ALLOC(m, info->context, sizeof(FDMatrix));
    EV_ALLOC(p, info->context, sizeof(FDMatrix));
    EV_ALLOC(mInv, info->context, sizeof(FDMatrix));
    EV_ALLOC(temp[0], info->context, sizeof(FDMatrix));
    EV_ALLOC(temp[1], info->context, sizeof(FDMatrix));
    EV_ALLOC_FULL(info->context);

#ifdef DCR_HOS_RETESSCURVE_OPT
    ratio = stepNew / stepOld;
    temp[2] = NULL;
    tag1 = (*(unsigned int*)(&ratio));
    tag2 = (0x0000FFFF & (unsigned int)(curve->order)) | reverseDirection << 20;    
    if (ratio != 1.0) {
        if (!CheckRetessellationCache(info, tag1, tag2, &temp[2])) {
            if (reverseDirection) {
                //the direciton of the curve is reversed so we need an uglier
                //retessellation matrix to 'reverse' the control point order here
                ComputeReversedRetessellation(info, curve->order, stepNew, stepOld, temp, m, p, mInv);
            } else {
                // Compute matrices for the calculation
                ComputePowerToFD(curve->order, m, 0);
                ComputeP(curve->order, ratio, p);
                ComputePowerToFD(curve->order, mInv, 1);
                MatrixMult(info, temp[1], p, mInv);
                MatrixMult(info, temp[2], m, temp[1]);
            }
        }

        // Compute FD curve coefficients
        FillColumnVectorMatrix(curve->order, 4*sizeof(float), &curve->coeffs[0][0], temp[0], 0);
        MatrixMult(info, temp[1], temp[2], temp[0]);
        EmptyColumnVectorMatrix(curve->order, temp[1], 4*sizeof(float), &curveOut->coeffs[0][0], 0);
        curveOut->order = curve->order;
    }
#else
    ratio = stepNew / stepOld;
    // Compute matrices for the calculation
    ComputePowerToFD(curve->order, mInv, 1);
    ComputeP(curve->order, ratio, p);
    ComputePowerToFD(curve->order, m, 0);

    // Compute FD curve coefficients
    FillColumnVectorMatrix(curve->order, 4*sizeof(float), &curve->coeffs[0][0], temp[0], 0);
    MatrixMult(info, temp[1], mInv, temp[0]);
    MatrixMult(info, temp[0], p, temp[1]);
    MatrixMult(info, temp[1], m, temp[0]);
    EmptyColumnVectorMatrix(curve->order, temp[1], 4*sizeof(float), &curveOut->coeffs[0][0], 0);
    curveOut->order = curve->order;
#endif

computeFDCurveCoeffsEnd:
    EV_FREE(m, info->context);
    EV_FREE(p, info->context);
    EV_FREE(mInv, info->context);
    EV_FREE(temp[0], info->context);
    EV_FREE(temp[1], info->context);
}

// Compute FD coefficients from curve control points
unsigned int RetessellateFDCurveSetInOut(NV_PATCH_INFO *info, int evalEnables,
                    float stepOld, float stepNew,
                    FDCurveAttrSet *pIn, FDCurveAttrSet *pOut)
{
    int index;

    for (index = 0; index < info->maxAttr; index++) {
        if (evalEnables & (1 << index)) {
            RetessellateFDCurveInOut(info, stepOld, stepNew, (*pIn)[index], (*pOut)[index], 0);
        }
    }
    return 0;
}

void RetessellateFDCurve(NV_PATCH_INFO *info, float stepOld, float stepNew,
                                NV_PATCH_CURVE_INFO *curve, int reverseDirection)
{
    RetessellateFDCurveInOut(info, stepOld, stepNew, curve, curve, reverseDirection);
}

/*****************************************************************************/

void OffsetCurve(NV_PATCH_INFO *info, NV_PATCH_CURVE_INFO *curve, int n)
{
    ASSERT_CURVE(curve);
#ifdef DCR_HOS_OPT
    if (g_FDGlobalData.cpuType) {
        PFOFSC p;
        switch (curve->order) {
        case 4:
            p=(PFOFSC)(g_FDGlobalData.HOSInnerLoops[OFFSET_CURVE_4x4]);
            p(curve,n);
            return;
        case 6:
            p=(PFOFSC)(g_FDGlobalData.HOSInnerLoops[OFFSET_CURVE_6x6]);
            p(curve,n);
            return;
        case 2:
           /* p=(PFOFSC)(g_FDGlobalData.HOSInnerLoops[OFFSET_CURVE_2x2]);
            p(curve,n);
            break;*/
        default:
            ;   // fall thru to C code
        }
    }
#endif
    {
        int i, j;

        for (i = 0; i < n; i++) {
            for (j = 0; j < curve->order-1; j++) {
                AddPoint(curve->coeffs[j], curve->coeffs[j+1]);
            }
        }
    }
}

void OffsetCurveSet(NV_PATCH_INFO *info, int evalEnables, FDCurveAttrSet *pSet, int n)
{
    int index;

    for (index = 0; index < info->maxAttr; index++) {
        if (evalEnables & (1 << index)) {
            OffsetCurve(info, (*pSet)[index], n);
        }
    }
}

// Offset curve coefficients by n steps
void OffsetCoeffs(float *coeffs, int order, int n)
{
    int i, j;

    for (i = 0; i < n; i++) {
        for (j = 0; j < order-1; j++) {
            coeffs[4*j+0] += coeffs[4*(j+1)+0];
            coeffs[4*j+1] += coeffs[4*(j+1)+1];
            coeffs[4*j+2] += coeffs[4*(j+1)+2];
            coeffs[4*j+3] += coeffs[4*(j+1)+3];
        }
    }
}

/*****************************************************************************/
// Evaluate along a curve
static void EvalCurve(const float *curve, int order, int n, float *outputs, int stride, int revIdx)
{
    int i, j;
    float temp[NV_PATCH_MAX_ORDER][4];

    if (revIdx) {
        outputs = (float *)((char *)outputs + (n-1)*stride);
        stride = -stride;
    }

    // Initialize FD
    for (j = 0; j < order; j++) {
        temp[j][0] = curve[4*j + 0];
        temp[j][1] = curve[4*j + 1];
        temp[j][2] = curve[4*j + 2];
        temp[j][3] = curve[4*j + 3];
    }

    for (i = 0; i < n; i++) {
        // Output a vertex
        outputs[0] = temp[0][0];
        outputs[1] = temp[0][1];
        outputs[2] = temp[0][2];
        outputs[3] = temp[0][3];
        NV_TRACE_COND(TR_EVAL, 35,
            static int cnt = 0;
            TPRINTF(("EvalCurve#%d %d-->%d) %9g %9g %9g %9g\n", cnt++, i, revIdx ? n-i : i,
                        outputs[0], outputs[1], outputs[2], outputs[3]));
        );
        outputs = (float *)((char *)outputs + stride);

        // Step FD
        for (j = 0; j < order-1; j++) {
            AddPoint(temp[j], temp[j+1]);
        }
    }
}

// Evaluate all the enabled curves along a strip in either direction
void EvalStrip(NV_PATCH_INFO *info,
                       FDCurveAttrSet *curves,
                       int n, NV_PATCH_EVAL_OUTPUT *pOutput, int revIdx)
{
    int index;

    for (index = 0; index < info->maxAttr; index++) {
        if (info->evalEnables & (1 << index)) {
            NV_TRACE_COND(TR_EVAL, 35,
                TPRINTF(("attr %d\n", index));
            );
            ASSERT_CURVE((*curves)[index]);
            EvalCurve((*curves)[index]->coeffs[0], (*curves)[index]->order,
                n, &pOutput->vertexAttribs[0][index][0],
                4*sizeof(float)*NV_PATCH_NUMBER_OF_ATTRIBS, revIdx);
        }
    }
}

/*****************************************************************************/
#define EVAL_IWRAP(serial) ((serial) % NV_PATCH_MAX_SW_VERTICES)

// Evaluate attr0 along a curve
static void EvalCurveIdx(int attr, int order, const float *curve, int n, NV_PATCH_EVAL_OUTPUT *pOutput, int startIdx, int revIdx)
{
    int i, j, sign = 1, idx;
    float temp[NV_PATCH_MAX_ORDER][4];

    if (revIdx) {
        startIdx = startIdx + n - 1;
        sign = -1;
    }

    // Initialize FD
    for (j = 0; j < order; j++) {
        temp[j][0] = curve[4*j + 0];
        temp[j][1] = curve[4*j + 1];
        temp[j][2] = curve[4*j + 2];
        temp[j][3] = curve[4*j + 3];
    }

    for (i = 0; i < n; i++) {
        // Output a vertex
        nvAssert((startIdx + i*sign) >= 0);
        idx = EVAL_IWRAP(startIdx + i*sign);
        CopyPoint(pOutput->vertexAttribs[idx][0], temp[0]);
        NV_TRACE_COND(TR_EVAL, 35,
            static int cnt = 0;
            TPRINTF(("EvalCurveIdx#%d/%d %d-->%d) %9g %9g %9g %9g\n", cnt++, attr, i, idx,
                        temp[0][0], temp[0][1], temp[0][2], temp[0][3]));
        );

        // Step FD
        for (j = 0; j < order-1; j++) {
            AddPoint(temp[j], temp[j+1]);
        }
    }
}

// Evaluate all the enabled curves along a strip in either direction
void EvalStripIdx(NV_PATCH_INFO *info,
                       FDCurveAttrSet *curves,
                       int n, NV_PATCH_EVAL_OUTPUT *pOutput, int startIdx,
                       int revIdx)
{
    int index;

    for (index = 0; index < info->maxAttr; index++) {
        if (info->evalEnables & (1 << index)) {
            // call pretending current attr is attr0
            EvalCurveIdx(index, (*curves)[index]->order, (*curves)[index]->coeffs[0],
                n, (NV_PATCH_EVAL_OUTPUT *)&pOutput->vertexAttribs[0][index], startIdx, revIdx);
        }
    }
}

/*****************************************************************************/
// Compute a FD matrix
void ComputeFDMatrixFlip(NV_PATCH_INFO *info, NV_PATCH_MAP_INFO *map, int uorder, int vorder, float ustep, float vstep,
                     FDMatrix *m,
                     const float *points, int vCoord, int uCoord,
                     int ufStride, int vfStride)
{
    FDMatrix *uCoeffs;
    FDMatrix *basisU, *basisV;
    FDMatrix *mU, *mV, *pU, *pV;
    FDMatrix *temp[3];
    int i, j;
#ifdef DCR_COMPUTEFDMATRIXFLIP_OPT
    unsigned int tag1, tag2;
#endif
    EV_ALLOC_DECL();

    EV_ALLOC_INIT_WITH_CACHE(info->context, 9 * sizeof(FDMatrix), computeFDMatrixEnd, info->pCache[EV_CACHE_9FDMATRICES]);
    EV_ALLOC(uCoeffs, info->context, sizeof(FDMatrix));
    EV_ALLOC(basisU, info->context, sizeof(FDMatrix));
    EV_ALLOC(basisV, info->context, sizeof(FDMatrix));
    EV_ALLOC(mU, info->context, sizeof(FDMatrix));
    EV_ALLOC(mV, info->context, sizeof(FDMatrix));
    EV_ALLOC(pU, info->context, sizeof(FDMatrix));
    EV_ALLOC(pV, info->context, sizeof(FDMatrix));
    EV_ALLOC(temp[0], info->context, sizeof(FDMatrix));
    EV_ALLOC(temp[1], info->context, sizeof(FDMatrix));
    EV_ALLOC_FULL(info->context);

    if (map) {
        if (info->flags & NV_PATCH_FLAG_FLIPPED_U) {
            uCoord = (uorder - 1 - uCoord);
            ufStride = -ufStride;
        }
        if (info->flags & NV_PATCH_FLAG_FLIPPED_V) {
            vCoord = (vorder - 1 - vCoord);
            vfStride = -vfStride;
        }
        points += vCoord * map->vfStride + uCoord * map->ufStride;
    }

    // The matrix will be mxn, where n = uorder and m = vorder
    m->rows = vorder;
    m->columns = uorder;
    uCoeffs->rows = vorder;
    uCoeffs->columns = uorder;

#ifdef DCR_COMPUTEFDMATRIXFLIP_OPT
    // Compute u-direction FD curve coefficients
    for (j = 0; j < vorder; j++) { FillColumnVectorMatrix(uorder, ufStride * sizeof(float), points + j*vfStride, temp[0], j); }
    temp[2] = NULL;
    tag1 = (0xFFFF0000 | uorder);
    tag2 = *(unsigned int *)(&ustep);
    if (!CheckRetessellationCache(info, tag1, tag2, &temp[2])) {
        // Compute matrices in each direction
        ComputeBasis(uorder, 0, basisU);
        ComputeP(uorder, ustep, pU);
        ComputePowerToFD(uorder, mU, 0);

        MatrixMult(info, temp[1], pU, basisU);
        MatrixMult(info, temp[2], mU, temp[1]);
    }
    MatrixMult(info, temp[1], temp[2], temp[0]);
    for (j = 0; j < vorder; j++) { EmptyColumnVectorMatrix(uorder, temp[1], 4*sizeof(float), &uCoeffs->data[j][0][0], j);}

    // Compute v-direction FD curve coefficients
    for (i = 0; i < uorder; i++) { FillColumnVectorMatrix(vorder, 4*sizeof(float)*NV_PATCH_MAX_ORDER, &uCoeffs->data[0][i][0], temp[0], i); }
    temp[2] = NULL;
    tag1 = (0xFFFF0000 | vorder);
    tag2 = *(unsigned int *)(&vstep);
    if (!CheckRetessellationCache(info, tag1, tag2, &temp[2])) {
        // Compute matrices in each direction
        ComputeBasis(vorder, 0, basisV);
        ComputeP(vorder, vstep, pV);
        ComputePowerToFD(vorder, mV, 0);

        MatrixMult(info, temp[1], pV, basisV);
        MatrixMult(info, temp[2], mV, temp[1]);
    }
    MatrixMult(info, temp[1], temp[2], temp[0]);
    for (i = 0; i < uorder; i++) { EmptyColumnVectorMatrix(vorder, temp[1], 4*sizeof(float)*NV_PATCH_MAX_ORDER, &m->data[0][i][0], i); }
#else
    // Compute matrices in each direction
    ComputeBasis(uorder, 0, basisU);
    ComputeP(uorder, ustep, pU);
    ComputePowerToFD(uorder, mU, 0);

    // Compute u-direction FD curve coefficients
    for (j = 0; j < vorder; j++) {
        FillColumnVectorMatrix(uorder, ufStride * sizeof(float), points + j*vfStride, temp[0], 0);
        MatrixMult(info, temp[1], basisU, temp[0]);
        MatrixMult(info, temp[0], pU, temp[1]);
        MatrixMult(info, temp[1], mU, temp[0]);
        EmptyColumnVectorMatrix(uorder, temp[1], 4*sizeof(float), &uCoeffs->data[j][0][0], 0);
    }
    NV_TRACE_COND(TR_EVAL, 25,
        TraceMatrix(info, temp[1]);
    );

    // Compute matrices in each direction
    ComputeBasis(vorder, 0, basisV);
    ComputeP(vorder, vstep, pV);
    ComputePowerToFD(vorder, mV, 0);

    // Compute v-direction FD curve coefficients
    for (i = 0; i < uorder; i++) {
        FillColumnVectorMatrix(vorder, 4*sizeof(float)*NV_PATCH_MAX_ORDER, &uCoeffs->data[0][i][0], temp[0], 0);
        MatrixMult(info, temp[1], basisV, temp[0]);
        MatrixMult(info, temp[0], pV, temp[1]);
        MatrixMult(info, temp[1], mV, temp[0]);
        EmptyColumnVectorMatrix(vorder, temp[1], 4*sizeof(float)*NV_PATCH_MAX_ORDER, &m->data[0][i][0], 0);
    }
#endif

computeFDMatrixEnd:
    EV_FREE(uCoeffs, info->context);
    EV_FREE(basisU, info->context);
    EV_FREE(basisV, info->context);
    EV_FREE(mU, info->context);
    EV_FREE(mV, info->context);
    EV_FREE(pU, info->context);
    EV_FREE(pV, info->context);
    EV_FREE(temp[0], info->context);
    EV_FREE(temp[1], info->context);

    NV_TRACE_COND(TR_EVAL, 25,
        TraceMatrix(info, m);
    );
}

void ComputeFDMatrix(NV_PATCH_INFO *info, int uorder, int vorder, float ustep, float vstep,
                             FDMatrix *m, const float *points, int ustride, int vstride)
// wrapper for now, eventually change all calls to be direct
{
    ComputeFDMatrixFlip(info, 0, uorder, vorder, ustep, vstep, m,
                (const float *)points, 0, 0, ustride, vstride);
}

// Offset an FD matrix by 'a' steps in u and 'b' steps in v
// Not particularly fast -- try to step along a curve when possible!
void OffsetFDMatrix(NV_PATCH_INFO *info, FDMatrix *m, int a, int b)
{
#ifdef DCR_HOS_OPT
#if !defined(IS_OPENGL)
    int order = m->rows;
#else
    int order = (m->rows == m->columns) ? m->rows : 0;
#endif
    PFOFSTM p;
    if (g_FDGlobalData.cpuType) {
        switch (order) {
        case 4:
            p=(PFOFSTM)(g_FDGlobalData.HOSInnerLoops[OFFSET_FDMATRIX_4x4]);
            p(m, a, b);
            return;
        case 6:
            p=(PFOFSTM)(g_FDGlobalData.HOSInnerLoops[OFFSET_FDMATRIX_6x6]);
            p(m, a, b);
            return;
        case 2:
            //OFFSET_FDMATRIX_2x2
        default:
            //OFFSET_FDMATRIX_DEF
            ;   // fall thru to C code
        }
    }
#endif
    {
        int i, row, col;
        // Step in u
        for (i = 0; i < a; i++) {
            for (row = 0; row < m->rows; row++) {
                for (col = 0; col < m->columns-1; col++) {
                    AddPoint(m->data[row][col], m->data[row][col+1]);
                }
            }
        }

        // Step in v
        for (i = 0; i < b; i++) {
            for (row = 0; row < m->rows-1; row++) {
                for (col = 0; col < m->columns; col++) {
                    AddPoint(m->data[row][col], m->data[row+1][col]);
                }
            }
        }
    }
}

void OffsetFDMatrix_Extract_Discard(NV_PATCH_INFO *info, NV_PATCH_CURVE_INFO *dst, int dir, FDMatrix *m, int a, int b)
{
#ifdef DCR_HOS_OPT
#if !defined(IS_OPENGL)
    int order = m->rows;
#else
    int order = (m->rows == m->columns) ? m->rows : 0;
#endif
    PFOFSTMED p;
    if (g_FDGlobalData.cpuType) {
        switch (order) {
        case 4:
            p=(PFOFSTMED)(g_FDGlobalData.HOSInnerLoops[OFFSET_FDMATRIX_ED_4x4]);
            p(dst, dir, m, a, b);
            return;
        case 2:
            /*p=(PFOFSTMED)(g_FDGlobalData.HOSInnerLoops[OFFSET_FDMATRIX_ED_2x2]);
            p(dst, dir, m, a, b);
            return;
        case 6:
            /*p=(PFOFSTMED)(g_FDGlobalData.HOSInnerLoops[OFFSET_FDMATRIX_ED_6x6]);
            p(dst, dir, m, a, b);
            break;*/
        default:
            ;   // fall thru to C code
        }
    }
#endif
    {
        BEGIN_USING_TEMP_MATRIX(info->tempMatrix);
        CopyMatrix(info, &info->tempMatrix, m);
        OffsetFDMatrix(info, &info->tempMatrix, a, b);
        if (dir) ExtractVCurve(info, dst, &info->tempMatrix);
        else ExtractUCurve(info, dst, &info->tempMatrix);
        END_USING_TEMP_MATRIX(info->tempMatrix);
    }
}

void OffsetFDMatrixSet(NV_PATCH_INFO *info, int evalEnables, FDMatrixAttrSet *pSet, int a, int b)
{
    int attr;

    for (attr = 0;  attr < info->maxAttr;  attr++) {
        if (!(evalEnables & (1 << attr))) {
            continue;
        }
        OffsetFDMatrix(info, (*pSet)[attr], a, b);
    }
}

// Compute FD coefficients from curve control points
void RetessellateFDMatrix(NV_PATCH_INFO *info, float stepOldU, float stepOldV,
                                 float stepNewU, float stepNewV, FDMatrix *matrix)
{
    const int uorder = matrix->columns;
    const int vorder = matrix->rows;
#ifndef DCR_HOS_RETESS_OPT
    int i,j;
#else
    unsigned int tag1, tag2;
    int reverseDirection;
    float ratio;
#endif
    FDMatrix *m, *p, *mInv;
    FDMatrix *temp[3];
    int freeTemp2 = 1;

    EV_ALLOC_DECL();

    EV_ALLOC_INIT_WITH_CACHE(info->context, 5 * sizeof(FDMatrix), RetessellateFDMatrixEnd, info->pCache[EV_CACHE_9FDMATRICES]);
    EV_ALLOC(m, info->context, sizeof(FDMatrix));
    EV_ALLOC(p, info->context, sizeof(FDMatrix));
    EV_ALLOC(mInv, info->context, sizeof(FDMatrix));
    EV_ALLOC(temp[0], info->context, sizeof(FDMatrix));
    EV_ALLOC(temp[1], info->context, sizeof(FDMatrix));
    EV_ALLOC_FULL(info->context);

#ifdef DCR_HOS_RETESS_OPT
    // Compute matrices for the calculation
    ratio = stepNewU / stepOldU;
    if (ratio != 1.0) {
        temp[2] = NULL;
        reverseDirection = (info->quadInfo->uMaxDir != info->quadInfo->olduMaxDir ? 1 : 0);
        tag1 = (*(unsigned int*)(&ratio));
        tag2 = (0x0000FFFF & uorder) | reverseDirection << 20;
        if (!CheckRetessellationCache(info, tag1, tag2, &temp[2])) {            
            //cache miss calculate the step matrix
            if (reverseDirection) {
                ComputeReversedRetessellation(info, uorder, stepNewU, stepOldU, temp, m, p, mInv);
            } else {
                ComputePowerToFD(uorder, m, 0);
                ComputeP(uorder, ratio, p);
                ComputePowerToFD(uorder, mInv, 1);
                MatrixMult(info, temp[0], p, mInv);
                MatrixMult(info, temp[2], m, temp[0]);
            }
        }
        CopyMatrixTranspose(info, temp[0], matrix);
        MatrixMult(info, temp[1], temp[2], temp[0]);
        CopyMatrixTranspose(info, matrix, temp[1]);
    }

    ratio = stepNewV / stepOldV;
    if (ratio != 1.0) {        
        temp[2] = NULL;
        reverseDirection = (info->quadInfo->vMaxDir != info->quadInfo->oldvMaxDir ? 1 : 0);
        tag1 = (*(unsigned int*)(&ratio));
        tag2 = (0x0000FFFF & vorder) | reverseDirection << 20;
        if (!CheckRetessellationCache(info, tag1, tag2, &temp[2])) {
            //cache miss calculate the step matrix
            if (reverseDirection) {
                ComputeReversedRetessellation(info, uorder, stepNewV, stepOldV, temp, m, p, mInv);
            } else {
                ComputePowerToFD(vorder, m, 0);
                ComputeP(vorder, ratio, p);
                ComputePowerToFD(vorder, mInv, 1);
                MatrixMult(info, temp[0], p, mInv);
                MatrixMult(info, temp[2], m, temp[0]);
            }
        }

        //don't need a copy cause its not a transpose...
        MatrixMult(info, temp[1], temp[2], matrix);
        CopyMatrix(info, matrix, temp[1]);
    }

#else
    // Compute matrices for the calculation
    ComputePowerToFD(uorder, mInv, 1);
    ComputeP(uorder, stepNewU / stepOldU, p);
    ComputePowerToFD(uorder, m, 0);

    // Recompute in u direction
    for (j = 0; j < vorder; j++) {
        FillColumnVectorMatrix(uorder, 4*sizeof(float), &matrix->data[j][0][0], temp[0], 0);
        MatrixMult(info, temp[1], mInv, temp[0]);
        MatrixMult(info, temp[0], p, temp[1]);
        MatrixMult(info, temp[1], m, temp[0]);
        EmptyColumnVectorMatrix(uorder, temp[1], 4*sizeof(float), &matrix->data[j][0][0], 0);
    }

    // Compute matrices for the calculation
    ComputePowerToFD(vorder, mInv, 1);
    ComputeP(vorder, stepNewV / stepOldV, p);
    ComputePowerToFD(vorder, m, 0);

    // Recompute in v direction
    for (i = 0; i < uorder; i++) {
        FillColumnVectorMatrix(vorder, 4*sizeof(float)*NV_PATCH_MAX_ORDER, &matrix->data[0][i][0], temp[0], 0);
        MatrixMult(info, temp[1], mInv, temp[0]);
        MatrixMult(info, temp[0], p, temp[1]);
        MatrixMult(info, temp[1], m, temp[0]);
        EmptyColumnVectorMatrix(vorder, temp[1], 4*sizeof(float)*NV_PATCH_MAX_ORDER, &matrix->data[0][i][0], 0);
    }
#endif

RetessellateFDMatrixEnd:
    EV_FREE(m, info->context);
    EV_FREE(p, info->context);
    EV_FREE(mInv, info->context);
    EV_FREE(temp[0], info->context);
    EV_FREE(temp[1], info->context);
}
#undef RATIO
#undef ORDER

unsigned int RetessellateFDMatrixSet(NV_PATCH_INFO *info, int evalEnables,
                    float stepOldU, float stepOldV,
                    float stepNewU, float stepNewV, FDMatrixAttrSet *pSet)
{
    int attr;

    for (attr = 0;  attr < info->maxAttr;  attr++) {
        if (!(evalEnables & (1 << attr))) {
            continue;
        }
        RetessellateFDMatrix(info, stepOldU, stepOldV, stepNewU, stepNewV, (*pSet)[attr]);
    }
    return 0;
}

/*****************************************************************************/
// Compute a Bezier curve's midpoint given its control points
// This uses the de Casteljau algorithm.

void ComputeCurvePoint(int order, float *point, const float *points,
                       int stride, float t)
{
    float temp[NV_PATCH_MAX_ORDER][4];
    int i, j;

    // Copy points
    for (i = 0; i < order; i++) {
        temp[i][0] = points[0]; temp[i][1] = points[1];
        temp[i][2] = points[2]; temp[i][3] = points[3];
        points = (const float *)((const char *)points + stride);
    }

    // Compute midpoint
    for (i = order-1; i >= 1; i--) {
        for (j = 0; j < i; j++) {
            temp[j][0] = (1-t) * temp[j][0] + (t)*temp[j+1][0];
            temp[j][1] = (1-t) * temp[j][1] + (t)*temp[j+1][1];
            temp[j][2] = (1-t) * temp[j][2] + (t)*temp[j+1][2];
            temp[j][3] = (1-t) * temp[j][3] + (t)*temp[j+1][3];
        }
    }

    //note that this is 'point' variable and not 'points'
    point[0] = temp[0][0];
    point[1] = temp[0][1];
    point[2] = temp[0][2];
    point[3] = temp[0][3];
}

void ComputePatchPoint(int uorder, int vorder,
                  float *point, const float *points,
                  int ustride, int vstride,
                  float u, float v) {

    int j;
    float curvePoints[NV_PATCH_MAX_ORDER][4];

    //calculate offset curve in v direction.
    for (j = 0; j < uorder; j++) {
        ComputeCurvePoint(vorder, &curvePoints[j][0], points + 4*j, vstride, v);
    }
    ComputeCurvePoint(uorder, point, &curvePoints[0][0], 4*sizeof(float), u);
}

void ComputeTriPatchCenter(int order, float *point, const float *points,
                           int ustride, int vstride)
{
    float temp[NV_PATCH_MAX_ORDER][NV_PATCH_MAX_ORDER][4];
    const float *ptemp;
    int i, j, k;

    // Copy points
    for (j = 0; j < order; j++) {
        ptemp = (const float *)((const char *)points + j*vstride);
        for (i = 0; i < order; i++) {
            temp[j][i][0] = ptemp[0];
            temp[j][i][1] = ptemp[1];
            temp[j][i][2] = ptemp[2];
            temp[j][i][3] = ptemp[3];
            ptemp = (const float *)((const char *)ptemp + ustride);
        }
    }

    // Compute midpoint
    for (i = order-1; i >= 1; i--) {
        for (j = 0; j < i; j++) {
            for (k = 0; k < i-j; k++) {
                temp[k][j][0] = (temp[k][j][0] + temp[k][j+1][0] + temp[k+1][j][0]) / 3.0f;
                temp[k][j][1] = (temp[k][j][1] + temp[k][j+1][1] + temp[k+1][j][1]) / 3.0f;
                temp[k][j][2] = (temp[k][j][2] + temp[k][j+1][2] + temp[k+1][j][2]) / 3.0f;
                temp[k][j][3] = (temp[k][j][3] + temp[k][j+1][3] + temp[k+1][j][3]) / 3.0f;
            }
        }
    }

    //note that this is 'point' variable and not 'points'
    point[0] = temp[0][0][0];
    point[1] = temp[0][0][1];
    point[2] = temp[0][0][2];
    point[3] = temp[0][0][3];
}

const static float triTo3QuadDomains[3][4][2] = {
    {
        {0, 0},
        {0.5f, 0},
        {0, 0.5f},
        {1/3.0f, 1/3.0f},
    },
    {
        {1, 0},
        {0.5f, 0},
        {0.5f, 0.5f},
        {1/3.0f, 1/3.0f},
    },
    {
        {0, 1},
        {0.5f, 0.5f},
        {0, 0.5f},
        {1/3.0f, 1/3.0f},
    },
};

const static float triTo1QuadDomain[4][2] = {
    {0, 0},
    {1.0f, 0},
    {0, 1.0f},
    {0, 1.0f},
};

static FDMatrix *ReduceTriPatch(NV_PATCH_INFO *info, int level, FDMatrix *p, float w0, float w1)
{
    FDMatrix *rp;
    int deg = p->rows-2;
    int i, j, k;
    float w2 = 1.0f - w0 - w1;

    rp = info->reduceTri[level];
    if (!rp) {
        return NULL;
    }
    rp->rows    = deg+1;
    rp->columns = deg+1;

    for (i = 0; i <= deg; i++) {
        for (j = 0; j <= deg-i; j++) {
            for (k = 0; k < 4; k++) {
                rp->data[i][j][k]  = w0*p->data[i+1][j][k];
                rp->data[i][j][k] += w1*p->data[i][j+1][k];
                rp->data[i][j][k] += w2*p->data[i][j][k];
            }
        }
    }
    return rp;
}

// NOTE: this is a recursive routine
static unsigned int ComputeTriToQuad(NV_PATCH_INFO *info, int level, FDMatrix *f, FDMatrix *g, FDMatrix *h,
                                    float **weights, int n, int mini,
                                    int si, int sj, float c, int mu)
{
    FDMatrix *fn;
    int indexi, indexj, firsti, i;
    unsigned int retVal;
    float bc[4];

    if (n == 0) {
        for (i = 0; i < 4; i++) {
            h->data[sj][si][i] += c * f->data[0][0][i];
        }
        weights[sj][si] += c;
        return 0;
    }

    firsti = 1;
    for (indexi = mini; indexi <= 1; indexi++) {
        if (firsti) {
            mu++;
            firsti = 0;
        } else {
            mu = 1;
        }
        for (indexj = 0; indexj <= 1; indexj++) {
            bc[0] = g->data[1 - indexi][indexj][0];
            bc[1] = g->data[1 - indexi][indexj][1];
            fn = ReduceTriPatch(info, level, f, bc[1], bc[0]);
            if (!fn) {
                return NV_PATCH_EVAL_ERR_OUT_OF_MEMORY;
            }
            retVal = ComputeTriToQuad(info, level+1, fn, g, h,
                                    weights, n-1, indexi,
                                    si + 1 - indexi,
                                    sj + indexj,
                                    c*n/mu,
                                    mu);
            if (retVal) {
                return retVal;
            }
        }
    }
    return 0;
}

static unsigned int ReparameterizeTriPatch(NV_PATCH_INFO *info, FDMatrix *in,
                                           FDMatrix *out, int domain, int frac)
{
    FDMatrix *domainMatrix = &info->tempMatrix;
    float *weights[NV_PATCH_MAX_ORDER], invWeight;
    int i, j;
    EV_ALLOC_DECL();

    BEGIN_USING_TEMP_MATRIX(info->tempMatrix);
    EV_ALLOC_INIT_WITH_CACHE(info->context, NV_PATCH_MAX_ORDER*NV_PATCH_MAX_ORDER*sizeof(float)
                                            + (in->rows-1) * sizeof(FDMatrix),
                        reparameterizeTriPatchOutOfMemory, info->pCache[EV_CACHE_TRI_WEIGHTS]);

    for (i = 0; i < NV_PATCH_MAX_ORDER; i++) {
        EV_ALLOC(weights[i], info->context, NV_PATCH_MAX_ORDER*sizeof(float));
        for (j = 0; j < NV_PATCH_MAX_ORDER; j++) {
            out->data[i][j][0] = 0.0f;
            out->data[i][j][1] = 0.0f;
            out->data[i][j][2] = 0.0f;
            out->data[i][j][3] = 0.0f;
            weights[i][j] = 0.0f;
        }
    }
    for (i = 0;  i < in->rows-1;  i++) {
        EV_ALLOC(info->reduceTri[i], info->context, sizeof(FDMatrix));
    }
    EV_ALLOC_FULL(info->context);

    for (i = 0; i < 2; i++) {
        for (j = 0; j < 2; j++) {
            if (frac) {
                domainMatrix->data[i][j][0] = triTo3QuadDomains[domain][j*2+i][0];
                domainMatrix->data[i][j][1] = triTo3QuadDomains[domain][j*2+i][1];
            } else {
                domainMatrix->data[i][j][0] = triTo1QuadDomain[j*2+i][0];
                domainMatrix->data[i][j][1] = triTo1QuadDomain[j*2+i][1];
            }
        }
    }

    info->retVal |= ComputeTriToQuad(info, 0, in, domainMatrix, out,
                                    weights, in->rows-1, 0,
                                    0, 0, 1.0f, 0);

    out->rows = in->rows;
    out->columns = in->columns;
    for (i = 0; i < out->rows; i++) {
        for (j = 0; j < out->columns; j++) {
            invWeight = 1.0f / weights[i][j];
            out->data[i][j][0] *= invWeight;
            out->data[i][j][1] *= invWeight;
            out->data[i][j][2] *= invWeight;
            out->data[i][j][3] *= invWeight;
        }
    }

reparameterizeTriPatchOutOfMemory:
    for (i = 0; i < NV_PATCH_MAX_ORDER; i++) {
        if (weights[i]) {
            EV_FREE(weights[i], info->context);
        }
    }
    END_USING_TEMP_MATRIX(info->tempMatrix);

    return info->retVal;
}

NV_INLINE void SendTransitionEndPoints(NV_PATCH_INFO *info, NV_PATCH_QUAD_INFO *quadInfo,
                    FDCurveAttrSet **ppCurvesInnerList, int revTran, int nCurveIn,
                    int gridIdxV, int gridIdxU, int cornerIdxV, int cornerIdxU, int doFrac, int transitionFlag)
{
    int index;
    int dwCount;
    HOS_CREATE_AND_ASSIGN_PUSHBUF_LOCALS();

    // SEND THE OUTER ENDPOINT
    HOS_NOTE("Send Outer Transition endpoint"); // always send this...
    HOS_PUSH(0, ((0x1 << 18) | (HOS_KELVIN_CHANNEL << 13) | (NV097_SET_BEGIN_END_CURVE)));
    HOS_PUSH(1,  NV097_SET_BEGIN_END_CURVE_CMD_OUTER_END_PT);
    HOS_PUSH_ADJUST(2);
    for (index = 0; index < info->maxAttr; index++) {
        dwCount = 0;
        if (info->evalEnables & (1 << index)) {
            HOS_NOTE("Set Curve Coefficients");
            HOS_PUSH(dwCount, ((0x4 << 18) | (HOS_KELVIN_CHANNEL << 13) | (NV097_SET_CURVE_COEFFICIENTS(0))));
            HOS_PUSHF(dwCount+1, VIEW_AS_DWORD(quadInfo->pCorners[index][cornerIdxV][cornerIdxU][0]));
            HOS_PUSHF(dwCount+2, VIEW_AS_DWORD(quadInfo->pCorners[index][cornerIdxV][cornerIdxU][1]));
            HOS_PUSHF(dwCount+3, VIEW_AS_DWORD(quadInfo->pCorners[index][cornerIdxV][cornerIdxU][2]));
            HOS_PUSHF(dwCount+4, VIEW_AS_DWORD(quadInfo->pCorners[index][cornerIdxV][cornerIdxU][3]));
            dwCount+=5;
        }
        HOS_PUSH_ADJUST(dwCount);
    }
    HOS_PUSH(0, ((0x1 << 18) | (HOS_KELVIN_CHANNEL << 13) | (NV097_SET_BEGIN_END_CURVE)));
    HOS_PUSH(1,  NV097_SET_BEGIN_END_CURVE_CMD_END_CURVE_DATA);
    HOS_PUSH_ADJUST(2);

    if (!doFrac) {
        // SEND THE INNER ENDPOINT -- integer case
        // this should only happen in degenerate transitions cases
        //ffif (quadInfo->nv0 == 1 && quadInfo->nv1 == 1)
        {
            float *pPoint;

            //HACK HACK HACK  -- just testing out a theory on the degenerate case Fred gave me...
            //Fix this up.
            HOS_NOTE("Send Inner Transition endpoint");
            HOS_PUSH(0, ((0x1 << 18) | (HOS_KELVIN_CHANNEL << 13) | (NV097_SET_BEGIN_END_CURVE)));
            HOS_PUSH(1,  NV097_SET_BEGIN_END_CURVE_CMD_INNER_END_PT);
            HOS_PUSH_ADJUST(2);
            //ffif (transitionFlag == LAST_ROW || transitionFlag == FIRST_ROW)
            {
                for (index = 0; index < info->maxAttr; index++) {
                    dwCount = 0;
                    if (info->evalEnables & (1 << index)) {
                        //in degenerate case use patch corners not grid corners
                        // XXX gridCorner is not set up for some degen cases. WHY?
                        //ffpPoint = info->gridCorner[index][gridIdxV][gridIdxU];

                        if (transitionFlag == FIRST_ROW) {
                            //ffpPoint = quadInfo->pCorners[index][cornerIdxV][cornerIdxU];
                            pPoint = quadInfo->pCorners[index][quadInfo->vMaxDir][quadInfo->uMaxDir];

                        } else if (transitionFlag == LAST_ROW) {
                            pPoint = quadInfo->pCorners[index][1-quadInfo->vMaxDir][quadInfo->uMaxDir];

                        } else if (transitionFlag == FIRST_COL) {
                            pPoint = quadInfo->pCorners[index][quadInfo->vMaxDir][quadInfo->uMaxDir];

                        } else if (transitionFlag == LAST_COL) {
                            pPoint = quadInfo->pCorners[index][quadInfo->vMaxDir][1-quadInfo->uMaxDir];

                        } else {
                            pPoint = info->gridCorner[index][gridIdxV][gridIdxU];
                        }
                        HOS_NOTE("Set Curve Coefficients");
                        HOS_PUSH(dwCount, ((0x4 << 18) | (HOS_KELVIN_CHANNEL << 13) | (NV097_SET_CURVE_COEFFICIENTS(0))));
                        HOS_PUSH4F(dwCount+1, pPoint);
                        dwCount+=5;
                    }
                    HOS_PUSH_ADJUST(dwCount);
                }
                HOS_PUSH(0, ((0x1 << 18) | (HOS_KELVIN_CHANNEL << 13) | (NV097_SET_BEGIN_END_CURVE)));
                HOS_PUSH(1,  NV097_SET_BEGIN_END_CURVE_CMD_INNER_END_PT);
                HOS_PUSH_ADJUST(2);
            }
        }

    } else {
        // SEND THE INNER ENDPOINT -- fractional case
        if (transitionFlag == FIRST_ROW) {
            float *pPoint;
            HOS_NOTE("Send Inner Transition endpoint");
            HOS_PUSH(0, ((0x1 << 18) | (HOS_KELVIN_CHANNEL << 13) | (NV097_SET_BEGIN_END_CURVE)));
            HOS_PUSH(1,  NV097_SET_BEGIN_END_CURVE_CMD_INNER_END_PT);
            HOS_PUSH_ADJUST(2);
            for (index = 0; index < info->maxAttr; index++) {
                dwCount = 0;
                if (info->evalEnables & (1 << index)) {
                    if (quadInfo->uMaxSegs > 1) {
                        //ffpPoint = info->gridCorner[index][0][1];
                        pPoint = info->gridCorner[index][gridIdxV][gridIdxU];
                    } else {
                        //in degenerate case use patch corners not grid corners
                        //ffpPoint = quadInfo->pCorners[index][1][1];
                        //ffpPoint = quadInfo->pCorners[index][cornerIdxV][cornerIdxU];
                        pPoint = quadInfo->pCorners[index][quadInfo->vMaxDir][cornerIdxU];
                    }
                    HOS_NOTE("Set Curve Coefficients");
                    HOS_PUSH(dwCount, ((0x4 << 18) | (HOS_KELVIN_CHANNEL << 13) | (NV097_SET_CURVE_COEFFICIENTS(0))));
                    HOS_PUSHF(dwCount+1, VIEW_AS_DWORD(pPoint[0]));
                    HOS_PUSHF(dwCount+2, VIEW_AS_DWORD(pPoint[1]));
                    HOS_PUSHF(dwCount+3, VIEW_AS_DWORD(pPoint[2]));
                    HOS_PUSHF(dwCount+4, VIEW_AS_DWORD(pPoint[3]));
                    dwCount+=5;
                }
                HOS_PUSH_ADJUST(dwCount);
            }
            HOS_PUSH(0, ((0x1 << 18) | (HOS_KELVIN_CHANNEL << 13) | (NV097_SET_BEGIN_END_CURVE)));
            HOS_PUSH(1,  NV097_SET_BEGIN_END_CURVE_CMD_END_CURVE_DATA);
            HOS_PUSH_ADJUST(2);
        } else if (transitionFlag == FIRST_COL) {
            float *pPoint;
            HOS_NOTE("Send Inner Transition endpoint");
            HOS_PUSH(0, ((0x1 << 18) | (HOS_KELVIN_CHANNEL << 13) | (NV097_SET_BEGIN_END_CURVE)));
            HOS_PUSH(1,  NV097_SET_BEGIN_END_CURVE_CMD_INNER_END_PT);
            HOS_PUSH_ADJUST(2);
            for (index = 0; index < info->maxAttr; index++) {
                dwCount = 0;
                if (info->evalEnables & (1 << index)) {
                    if (doFrac && (quadInfo->vMaxSegs == 1)) {
                        CopyCurve(info, &info->tempCurve, (*ppCurvesInnerList[!revTran ? 0 : nCurveIn-1])[index]);
                        OffsetCurve(info, &info->tempCurve,1);
                        pPoint = (float*)&info->tempCurve.coeffs[0];
                    } else if (quadInfo->vMaxSegs > 1) {
                        //ffpPoint = info->gridCorner[index][1][0];
                        pPoint = info->gridCorner[index][gridIdxV][gridIdxU];
                    } else {
                        //in degenerate case use patch corners not grid corners
                        //ffpPoint = quadInfo->pCorners[index][1][1];
                        pPoint = quadInfo->pCorners[index][cornerIdxV][cornerIdxU];
                    }
                    HOS_NOTE("Set Curve Coefficients");
                    HOS_PUSH(dwCount, ((0x4 << 18) | (HOS_KELVIN_CHANNEL << 13) | (NV097_SET_CURVE_COEFFICIENTS(0))));
                    HOS_PUSHF(dwCount+1, VIEW_AS_DWORD(pPoint[0]));
                    HOS_PUSHF(dwCount+2, VIEW_AS_DWORD(pPoint[1]));
                    HOS_PUSHF(dwCount+3, VIEW_AS_DWORD(pPoint[2]));
                    HOS_PUSHF(dwCount+4, VIEW_AS_DWORD(pPoint[3]));
                    dwCount+=5;
                }
                HOS_PUSH_ADJUST(dwCount);
            }
            HOS_PUSH(0, ((0x1 << 18) | (HOS_KELVIN_CHANNEL << 13) | (NV097_SET_BEGIN_END_CURVE)));
            HOS_PUSH(1,  NV097_SET_BEGIN_END_CURVE_CMD_END_CURVE_DATA);
            HOS_PUSH_ADJUST(2);
        }
    }
}

/*****************************************************************************/
// where do the transition curves start?
// for INT cases, they all start on the swatch boundary
// for FRAC cases, curves are rooted as follows:
//  TOP:
//      LAST ROW outer, at actual UL corner that starts the stitch
//      LAST ROW inner, at left of swatch, like INT stitch top
//  RIGHT:
//      LAST COL outer, at actual LR corner that starts the stitch
//      LAST COL inner, at bot of swatch, like INT stitch right
//  BOT:
//      FIRST ROW outer, at LL of swatch, like INT stitch bot
//      FIRST ROW inner, at left of swatch, like INT stitch bot
//  LEFT:
//      FIRST COL outer, at LL of swatch, like INT stitch left
//      FIRST COL inner, at bot of swatch, like INT stitch left
//
// so, the normal "exceptions" are the TOP/RIGHT outer curves
// but, for degenerates:
// but, when there is no FRAC TOP stitch,   then the BOT FIRST ROW inner starts at actual UL of stitch (like TOP LAST ROW outer)
// and, when there is no FRAC RIGHT stitch, either nInnerU > nInnerV and there's no FRAC TOP, or transpose to get same case

NV_INLINE void SendFirstInnerTransitionCurve(NV_PATCH_INFO *info, NV_PATCH_QUAD_INFO *quadInfo,
                    FDCurveAttrSet **ppCurvesInnerList, int revTran, int nCurveIn, int doFrac, int transitionFlag)
{
    int index, i;
    int dwCount;
    NV_PATCH_CURVE_INFO *pCurve;
    HOS_CREATE_AND_ASSIGN_PUSHBUF_LOCALS();

    // SEND THE FIRST INNER TRANSITION CURVE
    HOS_NOTE("Begin Curve: Send Inner Transition");
    HOS_PUSH(0, ((0x1 << 18) | (HOS_KELVIN_CHANNEL << 13) | (NV097_SET_BEGIN_END_CURVE)));
    HOS_PUSH(1, NV097_SET_BEGIN_END_CURVE_CMD_INNER_TRANSITION_CURVE);
    HOS_PUSH_ADJUST(2);
    for (index = 0; index < info->maxAttr; index++) {
        if (info->evalEnables & (1 << index)) {
            dwCount = 0;
            pCurve = (*ppCurvesInnerList[!revTran ? 0 : nCurveIn-1])[index];
            if (doFrac && (quadInfo->vMaxSegs == 1) && (transitionFlag == FIRST_ROW)) {
                CopyCurve(info, &info->tempCurve, pCurve);
                OffsetCurve(info, &info->tempCurve,1);
                pCurve = &info->tempCurve;
            }

            // if this is a not a new swath... do we pre adjust that row??? or just not send the last row in the previous patch?
            for (i = 0; i < pCurve->order; i++) {
                HOS_NOTE("Set Curve Coefficients");
                HOS_PUSH(dwCount, ((0x4 << 18) | (HOS_KELVIN_CHANNEL << 13) | (NV097_SET_CURVE_COEFFICIENTS(0))));
                HOS_PUSHF(dwCount+1, VIEW_AS_DWORD(pCurve->coeffs[i][0]));
                HOS_PUSHF(dwCount+2, VIEW_AS_DWORD(pCurve->coeffs[i][1]));
                HOS_PUSHF(dwCount+3, VIEW_AS_DWORD(pCurve->coeffs[i][2]));
                HOS_PUSHF(dwCount+4, VIEW_AS_DWORD(pCurve->coeffs[i][3]));
                dwCount+=5;
            }
            HOS_PUSH_ADJUST(dwCount);
        }
    }
    HOS_PUSH(0, ((0x1 << 18) | (HOS_KELVIN_CHANNEL << 13) | (NV097_SET_BEGIN_END_CURVE)));
    HOS_PUSH(1, NV097_SET_BEGIN_END_CURVE_CMD_END_CURVE_DATA);
    HOS_PUSH_ADJUST(2);
    HOS_FLUSH();
}

NV_INLINE void SendFirstOuterTransitionCurve(NV_PATCH_INFO *info, NV_PATCH_QUAD_INFO *quadInfo, FDCurveAttrSet *pCurvesOuter,
                    int doFrac, int transitionFlag)
{
    int index, i;
    int dwCount;
    NV_PATCH_CURVE_INFO *pCurve;
    HOS_CREATE_AND_ASSIGN_PUSHBUF_LOCALS();

    // SEND THE FIRST OUTER TRANSITION CURVE
    HOS_NOTE("Send Outer Transition");
    HOS_PUSH(0, ((0x1 << 18) | (HOS_KELVIN_CHANNEL << 13) | (NV097_SET_BEGIN_END_CURVE)));
    HOS_PUSH(1, NV097_SET_BEGIN_END_CURVE_CMD_OUTER_TRANSITION_CURVE);
    HOS_PUSH_ADJUST(2);
    for (index = 0; index < info->maxAttr; index++) {
        if (info->evalEnables & (1 << index)) {
            dwCount = 0;
            pCurve = (*pCurvesOuter)[index];
            //if this is a not a new swath... do we pre adjust that row??? or just not send the last row in the previous patch?
            if (doFrac && (transitionFlag == LAST_ROW || transitionFlag == LAST_COL)) {
                CopyCurve(info, &info->tempCurve, pCurve);
                OffsetCurve(info, &info->tempCurve,1);
                pCurve = &info->tempCurve;
            }

            for (i = 0; i < pCurve->order; i++) {
                HOS_NOTE("Set Curve Coefficients");
                HOS_PUSH(dwCount, ((0x4 << 18) | (HOS_KELVIN_CHANNEL << 13) | (NV097_SET_CURVE_COEFFICIENTS(0))));
                HOS_PUSHF(dwCount+1, VIEW_AS_DWORD(pCurve->coeffs[i][0]));
                HOS_PUSHF(dwCount+2, VIEW_AS_DWORD(pCurve->coeffs[i][1]));
                HOS_PUSHF(dwCount+3, VIEW_AS_DWORD(pCurve->coeffs[i][2]));
                HOS_PUSHF(dwCount+4, VIEW_AS_DWORD(pCurve->coeffs[i][3]));
                dwCount+=5;
            }
            HOS_PUSH_ADJUST(dwCount);
        }
    }
    HOS_PUSH(0, ((0x1 << 18) | (HOS_KELVIN_CHANNEL << 13) | (NV097_SET_BEGIN_END_CURVE)));
    HOS_PUSH(1, NV097_SET_BEGIN_END_CURVE_CMD_END_CURVE_DATA);
    HOS_PUSH_ADJUST(2);
    HOS_FLUSH();
}

/*****************************************************************************/
// Draw stitch for INT or FRAC cases
// gridIdx* are indices for inside endpoint:
//      info->gridCorner[index][gridIdxV][gridIdxU]
// cornerIdx* are indices for outside endpoint:
//      quadInfo->pCorners[index][cornerIdxV][cornerIdxU]

void DrawIntStitch(int stripU, NV_PATCH_INFO *info, NV_PATCH_QUAD_INFO *quadInfo,
                    FDCurveAttrSet **ppCurvesOuter, FDCurveAttrSet **ppCurvesInnerList,
                    int outSegs, int inSegs,
                    NV_PATCH_EVAL_OUTPUT *pDataOut, NV_PATCH_EVAL_OUTPUT *pDataIn,
                    int gridIdxVBegin, int gridIdxUBegin,   // for inner beginpoint from regular grid corner
                    int gridIdxV, int gridIdxU,             // for inner endpoint from regular grid corner
                    int cornerIdxV, int cornerIdxU,         // for outer endpoint from patch corners[][]
                    int stitchLowOut, int stitchHighOut,
                    int stitchLowIn, int stitchHighIn,
                    int qDir, int qOtherDir, int qMaxDir,
                    int reverse, int ifEqualStepInner, int transitionFlag)
{
    // World's messiest state machine.  I wish this was cleaner. -- MJC
    // ... and now perhaps messier, but does swathing. -- FBF
    // and may even match the HW
    int dist, in, out, i, first;
    int inStrip, lastWasIn;
    int fanCenter, fanFirst, fanLast;
    int idxInnerEnd;
    int index;
    FDCurveAttrSet *pCurves;
    int doFrac = !!(info->flags & NV_PATCH_FLAG_TESS_FRACTIONAL);
    //ff// calc swaths WITHOUT including the ending FRAC-only stitches
    //ffint nSwatchU = (quadInfo->uMaxSegs - 1 - doFrac) / info->maxSwatch + 1;
    //ffint nSwatchV = (quadInfo->vMaxSegs - 1 - doFrac) / info->maxSwatch + 1;
    int nCurveOut;
    int nCurveIn; // = stripU ? nSwatchU : nSwatchV;
    int revTran = qDir != qMaxDir;          // qDir is from outerDir
    int revInner = qOtherDir != qMaxDir;    // qOtherDir
    int totalToDoOut, totalToDoIn;
    int onCurveOut = 1, onCurveIn = 1;
    int oneToDoOut, oneToDoIn;
    int onLowIn, onHighIn;
    int innerCurve;         // temp to hold curve number to select from ppCurvesInnerList
    int lastInsideCurve;    // means last in list. Not necessarily last drawn.
    int lastOutsideCurve;   // last drawn
    int usingHW = info->usingHW; // identifies places that probably need code for HW version
    int dwCount;
    int lastFrontFace;

    HOS_CREATE_AND_ASSIGN_PUSHBUF_LOCALS();

    nCurveOut = (outSegs - 1) / info->maxSwatch + 1;
    nCurveIn =  (inSegs - 1 - doFrac) / info->maxSwatch + 1;
    NV_TRACE_COND(TR_EVAL, 30,
        TPRINTF(("DrawIntStitch out=%d in=%d stitchLowOut=%d stitchHighOut=%d\n",
                outSegs, inSegs, stitchLowOut, stitchHighOut));
        TPRINTF(("\t stitchLowIn=%d stitchHighIn=%d\n", stitchLowIn, stitchHighIn));
        TPRINTF(("\trev=%d ifEqualStepInner=%d\n", reverse, ifEqualStepInner));
    );
    nvAssert(qOtherDir == qMaxDir);
    nvAssert((outSegs <= inSegs)  ||  doFrac);

    if (!usingHW) {
        reverse ^= info->flipUV;
    }
    ifEqualStepInner ^= info->flipUV;

    out = 0;
    in = 0;
    if (stitchLowOut && (!usingHW /*|| doFrac*/)) {
        // these cases start the 'dist' algorithm at the first inner point
        in = 1;
        dist = inSegs - 3*outSegs;  // start with inside step
    } else {
        dist = inSegs - outSegs;
    }
    totalToDoOut = 1+outSegs; totalToDoIn = 1+inSegs;

    if (totalToDoOut > 1+info->maxSwatch) {
        oneToDoOut = info->maxSwatch;   // doesn't fit in one curve
        lastOutsideCurve = 0;
    } else {
        oneToDoOut = totalToDoOut;
        lastOutsideCurve = 1;
    }

    if (!usingHW) EvalStrip(info, ppCurvesOuter[0], oneToDoOut, pDataOut, 0); // outer

    if (totalToDoIn > 1+info->maxSwatch) {
        // doesn't fit in one curve
        if (revTran) {
            // reversed inner curve
            if (!usingHW) {
                oneToDoIn = inSegs % info->maxSwatch;
                assert(oneToDoIn >= 0);
                if (oneToDoIn <= 0) {
                    oneToDoIn += info->maxSwatch;
                }
            } else {
                oneToDoIn = inSegs % info->maxSwatch;
                assert(oneToDoIn >= 0);
                if ((oneToDoIn - stitchHighIn) <= 0) {
                    if ((oneToDoIn == 1)  &&  stitchHighIn /* && (nCurveIn == 2)*/) {
                        nCurveIn--;
                    }
                    oneToDoIn += info->maxSwatch; // + stitchHighIn;
                }
            }
            oneToDoIn++;
            lastInsideCurve = 1;
            onLowIn = 0;
            onHighIn = stitchHighIn;
        } else {
            if (doFrac && (nCurveIn == 1) && (totalToDoIn == (2+info->maxSwatch))) {
                oneToDoIn = 2+info->maxSwatch;
                lastInsideCurve = 1;
            } else {
                oneToDoIn = info->maxSwatch;
                lastInsideCurve = 0;
            }
            onLowIn = stitchLowIn;
            onHighIn = 0;
        }

    } else {
        // fits in one curve
        oneToDoIn = totalToDoIn;
        lastInsideCurve = 1;
        onLowIn = stitchLowIn;
        onHighIn = stitchHighIn;
    }

    if (!usingHW) {
        EvalStripIdx(info, ppCurvesInnerList[!revTran ? 0 : nCurveIn-1], oneToDoIn, pDataIn, 0, revTran); // inner
        if (onHighIn ) {
            //ffif (stitchHighIn) {
                oneToDoIn--;
                totalToDoIn--;
            //ff}
        }
    }

    if (revTran) {
        idxInnerEnd = in;
    } else {
        nvAssert(qDir == qOtherDir);
        idxInnerEnd = oneToDoIn-1;
    }
    if (!usingHW) {
        if (onLowIn) {
            oneToDoIn--;
            totalToDoIn--;
        }
    }

    if (usingHW) {
        //setup transition
        unsigned long TControl[3], order;
        unsigned long numcoeffs = 0x0;
        int hwAttr;
        TControl[0] = TControl[1] = TControl[2] = 0x0;
        for (hwAttr = 0; hwAttr <= 7; hwAttr++) {               //TPControl0
            if (info->evalEnables & (1 << hwAttr)) {
                order = (*ppCurvesOuter[0])[hwAttr]->order;
                assert((int)order == (*ppCurvesInnerList[0])[hwAttr]->order);
                TControl[0] |= ((order-1) << (hwAttr<<2));      //hwAttr*4
                numcoeffs += order;
            }
        }
        for (hwAttr = 8; hwAttr <= 15; hwAttr++) {              //TPControl1
            if (info->evalEnables & (1 << hwAttr)) {
                order = (*ppCurvesOuter[0])[hwAttr]->order;
                assert((int)order == (*ppCurvesInnerList[0])[hwAttr]->order);
                TControl[1] |= ((order-1) << ((hwAttr-8)<<2));
                numcoeffs += order;
            }
        }

        TControl[2] = (numcoeffs << 24) | (outSegs << 10) | inSegs;
        HOS_NOTE("Set Begin Transition");
        HOS_PUSH(0, ((0x3 << 18) | (HOS_KELVIN_CHANNEL << 13) | (NV097_SET_BEGIN_TRANSITION0)));
        HOS_PUSH(1, TControl[0]);
        HOS_PUSH(2, TControl[1]);
        HOS_PUSH(3, TControl[2]);
        HOS_PUSH_ADJUST(4);

        //SEND Transition endpoints as necessary
        SendTransitionEndPoints(info, quadInfo, ppCurvesInnerList, revTran, nCurveIn,
                                gridIdxV, gridIdxU, cornerIdxV, cornerIdxU, doFrac, transitionFlag);

        //SEND Beginning Transition Curves
        SendFirstInnerTransitionCurve(info, quadInfo, ppCurvesInnerList, revTran, nCurveIn, doFrac, transitionFlag);
        SendFirstOuterTransitionCurve(info, quadInfo, ppCurvesOuter[0], doFrac, transitionFlag);

    } else {
        // Force first and last point
        for (index = 0; index < info->maxAttr; index++) {
            if (!EV_GUARD_ATTR(index)  &&  !doFrac) {
                continue;
            }
            if (!(info->evalEnables & (1 << index))) {
                continue;
            }
            if (lastOutsideCurve) {
                CopyPoint(pDataOut->vertexAttribs[oneToDoOut-1][index], quadInfo->pCorners[index][cornerIdxV][cornerIdxU]);
            }
            if (!doFrac) {
                // for starting grid corner
                if (revTran) {
                    if (lastInsideCurve && (nCurveIn == 1)) {
                        CopyPoint(pDataIn->vertexAttribs[oneToDoIn-onLowIn][index], info->gridCorner[index][gridIdxVBegin][gridIdxUBegin]);
                    }
                } else {
                    CopyPoint(pDataIn->vertexAttribs[in][index], info->gridCorner[index][gridIdxVBegin][gridIdxUBegin]);
                }
            }
            if (lastInsideCurve) {
                CopyPoint(pDataIn->vertexAttribs[idxInnerEnd][index], info->gridCorner[index][gridIdxV][gridIdxU]);
            }
        }

        if (doFrac  &&  stitchHighOut) {
            out++;
            oneToDoOut--;
            totalToDoOut--;

            in++;
            oneToDoIn--;
            totalToDoIn--;
        }

        info->backend->setFrontFace(info, lastFrontFace = reverse ^ info->reverse);
        info->backend->beginPrimitive(info, NV_PATCH_PRIMITIVE_TSTRIP);
        info->backend->sendVertex(info, pDataOut, out);
    }

    if (inSegs != outSegs) {
        // if we have a reversal, bias the stitching direction so it comes
        // out the same as the non reversed case.
        int lastTrans = (transitionFlag == LAST_ROW  || transitionFlag == LAST_COL) ? 1 : 0;
        int rowTrans =  (transitionFlag == FIRST_ROW || transitionFlag == LAST_ROW) ? 1 : 0;
        int fudge;
        if (rowTrans) {
            fudge = !(revTran ^ (lastTrans)); // row
        } else {
            fudge = !(revTran ^ (!lastTrans)); // col
        }
        if (!usingHW) {
            dist += fudge ^ quadInfo->uMaxDir ^ quadInfo->vMaxDir ^ info->flipUV;
        } else {
            dist += fudge;
        }
    } else {
        // when segs equal, initial dist == 0. if dist==0 means to select
        // inner edge first, then adjust 'dist' to step inner edge first.
        if (ifEqualStepInner) {
            dist += 1;
        }
    }

    // The algorithm in the Unit test (and presumably the actual HW) assumes
    // the first outside and inside points have been sent (accounted for), even
    // though the starting 'totalToDoIn' and 'oneToDoIn' do not reflect this.
    // Similarly for 'oneToDoOut' and 'totalToDoOut'. That's why they start out
    // with the total counts.
    // Here we fudge an "extra" loop to avoid duplicating the code to send
    // and inside curve (by setting 'first'). To compensate, adjust the
    // various counts.
    first = 1;
    dist += 2*outSegs;
    in--;
    oneToDoIn++;
    totalToDoIn++;
    inStrip = 1;
    lastWasIn = 0;

    // The FD unit test algorithm does "extra" steps at the end which don't
    // matter for HW, but cause extra lines for SW emulation.
    // That's why this code checks for "> 1" instead of "> 0"

    if (doFrac) {
        // fudge things to get alternating out-in-out-in-out ... out
        // NOTE: first 'out' already sent, so start with 'in' below.
        dist = 1;       // set up to alternate in-out-in-out ...
        outSegs = inSegs = 1;       // from now on, only used by 'dist' adjustment
        if (stitchLowOut && usingHW) {
            // for Bot and Left, adjust since first inner point skipped
            oneToDoIn--;
            totalToDoIn--;
        }
    }

    //tag:stst
    while (totalToDoOut > 1  ||  totalToDoIn > 1) {
        while (first || ((totalToDoIn > 1) && (dist > 0))) {
            // step and use an inside point
            first = 0;
            dist -= 2*outSegs;
            in++;
            oneToDoIn--;
            totalToDoIn--;

            if (oneToDoIn == 0  &&  totalToDoIn > 1) {
                // need another inside curve
                if (totalToDoIn > (1+info->maxSwatch+doFrac)) {
                    oneToDoIn = info->maxSwatch;
                    onLowIn = 0;
                    onHighIn = 0;
                    lastInsideCurve = 0;
                } else {
                    oneToDoIn = totalToDoIn;
                    onLowIn = stitchLowIn && revTran;
                    onHighIn = stitchHighIn && !revTran;
                    lastInsideCurve = 1;
                }

                innerCurve = !revTran ? onCurveIn : nCurveIn-1-onCurveIn;
                pCurves = ppCurvesInnerList[innerCurve];

                if (usingHW) {
                    // SEND NEXT INNER TRANSITION CURVE
                    HOS_NOTE("Send Inner Transition");
                    HOS_PUSH(0, ((0x1 << 18) | (HOS_KELVIN_CHANNEL << 13) | (NV097_SET_BEGIN_END_CURVE)));
                    HOS_PUSH(1, NV097_SET_BEGIN_END_CURVE_CMD_INNER_TRANSITION_CURVE);
                    HOS_PUSH_ADJUST(2);
                    for (index = 0; index < info->maxAttr; index++) {
                        if (info->evalEnables & (1 << index)) {
                            dwCount = 0;
                            //if this is a not a new swath... do we pre adjust that row??? or just not send the last row in the previous patch?
                            //fffor (i = 0; i < (*ppCurvesInnerList[!revTran ? 0 : nCurveIn-1])[index]->order; i++) { // }
                            for (i = 0; i < (*pCurves)[index]->order; i++) {
                                HOS_NOTE("Set Curve Coefficients");
                                HOS_PUSH(dwCount, ((0x4 << 18) | (HOS_KELVIN_CHANNEL << 13) | (NV097_SET_CURVE_COEFFICIENTS(0))));
                                HOS_PUSHF(dwCount+1, VIEW_AS_DWORD((*pCurves)[index]->coeffs[i][0]));
                                HOS_PUSHF(dwCount+2, VIEW_AS_DWORD((*pCurves)[index]->coeffs[i][1]));
                                HOS_PUSHF(dwCount+3, VIEW_AS_DWORD((*pCurves)[index]->coeffs[i][2]));
                                HOS_PUSHF(dwCount+4, VIEW_AS_DWORD((*pCurves)[index]->coeffs[i][3]));
                                dwCount+=5;
                            }
                            HOS_PUSH_ADJUST(dwCount);
                        }
                    }
                    HOS_PUSH(0, ((0x1 << 18) | (HOS_KELVIN_CHANNEL << 13) | (NV097_SET_BEGIN_END_CURVE)));
                    HOS_PUSH(1, NV097_SET_BEGIN_END_CURVE_CMD_END_CURVE_DATA);
                    HOS_PUSH_ADJUST(2);
                    HOS_FLUSH();
                } else {
                    EvalStripIdx(info, pCurves, oneToDoIn, pDataIn, in, revTran); // inner
                    if (onHighIn) {
                        if (stitchHighIn) {
                            oneToDoIn--;
                            totalToDoIn--;
                        }
                    }
                    if (revTran) {
                        //ffidxInnerEnd = in+0;
                        idxInnerEnd = in+oneToDoIn-1-onLowIn;
                    } else {
                        idxInnerEnd = in+oneToDoIn-1;
                    }
                    if (onLowIn) {
                        oneToDoIn--;
                        totalToDoIn--;
                    }

                    // Force last point
                    for (index = 0; index < info->maxAttr; index++) {
                        if (!EV_GUARD_ATTR(index)  &&  !doFrac) {
                            continue;
                        }
                        if (!(info->evalEnables & (1 << index))) {
                            continue;
                        }
                        if (lastInsideCurve) {
                            if (revTran) {
                                CopyPoint(pDataIn->vertexAttribs[EVAL_IWRAP(idxInnerEnd)][index],
                                        info->gridCorner[index][gridIdxVBegin][gridIdxUBegin]);
                            } else {
                                CopyPoint(pDataIn->vertexAttribs[EVAL_IWRAP(idxInnerEnd)][index],
                                        info->gridCorner[index][gridIdxV][gridIdxU]);
                            }
                        }
                    }
                }
                onCurveIn++;
            }

            if (!usingHW) {
                if (inStrip && lastWasIn) {
                    info->backend->endPrimitive(info);
                    fanCenter = out;
                    fanFirst = in-1;
                    inStrip = 0;
                    if (lastFrontFace != (reverse ^ info->reverse)) {
                        info->backend->setFrontFace(info, lastFrontFace = !lastFrontFace);
                    }
                    info->backend->beginPrimitive(info, NV_PATCH_PRIMITIVE_TFAN);
                    info->backend->sendVertex(info, pDataOut, EVAL_IWRAP(fanCenter));
                    info->backend->sendVertex(info, pDataIn, EVAL_IWRAP(fanFirst));

                } else if (!inStrip && !lastWasIn) {
                    info->backend->endPrimitive(info);
                    info->backend->beginPrimitive(info, NV_PATCH_PRIMITIVE_TSTRIP);
                    info->backend->sendVertex(info, pDataIn, EVAL_IWRAP(in-1));
                    info->backend->sendVertex(info, pDataOut, EVAL_IWRAP(out));
                    inStrip = 1;
                }
                if (inStrip) {
                    info->backend->sendVertex(info, pDataIn, EVAL_IWRAP(in));
                } else {
                    fanLast = in;
                    info->backend->sendVertex(info, pDataIn, EVAL_IWRAP(fanLast));
                }
                lastWasIn = 1;
            }

            if (doFrac) {
                if (totalToDoOut == 1) {
                    dist = 0xDAD;       // complete stitch with fan of inside pts
                }
            }
        }

        if (totalToDoOut > 1) {
            dist += 2*inSegs;
            out++;
            oneToDoOut--;
            totalToDoOut--;

            if (oneToDoOut == 0  &&  totalToDoOut > 1) {
                // need another outside curve
                if (totalToDoOut > 1+info->maxSwatch) {
                    oneToDoOut = info->maxSwatch;   // doesn't fit in one curve
                    lastOutsideCurve = 0;
                } else {
                    oneToDoOut = totalToDoOut;
                    lastOutsideCurve = 1;
                }

                pCurves = ppCurvesOuter[onCurveOut];

                if (usingHW) {
                    // SEND THE NEXT OUTER TRANSITION CURVE
                    HOS_NOTE("Send Outer Transition");
                    HOS_PUSH(0, ((0x1 << 18) | (HOS_KELVIN_CHANNEL << 13) | (NV097_SET_BEGIN_END_CURVE)));
                    HOS_PUSH(1, NV097_SET_BEGIN_END_CURVE_CMD_OUTER_TRANSITION_CURVE);
                    HOS_PUSH_ADJUST(2);
                    for (index = 0; index < info->maxAttr; index++) {
                        if (info->evalEnables & (1 << index)) {
                            // if this is a not a new swath... do we pre adjust that row???
                            // or just not send the last row in the previous patch?
                            dwCount = 0;
                            for (i = 0; i < (*pCurves)[index]->order; i++) {
                                HOS_NOTE("Set Curve Coefficients");
                                HOS_PUSH(dwCount, ((0x4 << 18) | (HOS_KELVIN_CHANNEL << 13) | (NV097_SET_CURVE_COEFFICIENTS(0))));
                                HOS_PUSHF(dwCount+1, VIEW_AS_DWORD((*pCurves)[index]->coeffs[i][0]));
                                HOS_PUSHF(dwCount+2, VIEW_AS_DWORD((*pCurves)[index]->coeffs[i][1]));
                                HOS_PUSHF(dwCount+3, VIEW_AS_DWORD((*pCurves)[index]->coeffs[i][2]));
                                HOS_PUSHF(dwCount+4, VIEW_AS_DWORD((*pCurves)[index]->coeffs[i][3]));
                                dwCount+=5;
                            }
                            HOS_PUSH_ADJUST(dwCount);
                        }
                    }
                    HOS_PUSH(0, ((0x1 << 18) | (HOS_KELVIN_CHANNEL << 13) | (NV097_SET_BEGIN_END_CURVE)));
                    HOS_PUSH(1, NV097_SET_BEGIN_END_CURVE_CMD_END_CURVE_DATA);
                    HOS_PUSH_ADJUST(2);
                    HOS_FLUSH();
                } else {
                    EvalStripIdx(info, pCurves, oneToDoOut, pDataOut, out, 0); // outer

                    // Force last point
                    if (lastOutsideCurve) {
                        for (index = 0; index < info->maxAttr; index++) {
                            if (!EV_GUARD_ATTR(index)  &&  !doFrac) {
                                continue;
                            }
                            if (info->evalEnables & (1 << index)) {
                                CopyPoint(pDataOut->vertexAttribs[EVAL_IWRAP(out+oneToDoOut-1)][index],
                                          quadInfo->pCorners[index][cornerIdxV][cornerIdxU]);
                            }
                        }
                    }

                }

                onCurveOut++;
            }

            if (!usingHW) {
                if (inStrip && !lastWasIn) {
                    info->backend->endPrimitive(info);
                    fanCenter = in;
                    fanFirst = out-1;
                    inStrip = 0;
                    if (lastFrontFace != (1 ^ reverse ^ info->reverse)) {
                        info->backend->setFrontFace(info, lastFrontFace = !lastFrontFace);
                    }
                    info->backend->beginPrimitive(info, NV_PATCH_PRIMITIVE_TFAN);
                    info->backend->sendVertex(info, pDataIn, EVAL_IWRAP(fanCenter));
                    info->backend->sendVertex(info, pDataOut, EVAL_IWRAP(fanFirst));

                } else if (!inStrip && lastWasIn) {
                    info->backend->endPrimitive(info);
                    info->backend->beginPrimitive(info, NV_PATCH_PRIMITIVE_TSTRIP);
                    info->backend->sendVertex(info, pDataOut, EVAL_IWRAP(out-1));
                    info->backend->sendVertex(info, pDataIn, EVAL_IWRAP(in));
                    inStrip = 1;
                }
                if (inStrip) {
                    info->backend->sendVertex(info, pDataOut, EVAL_IWRAP(out));
                } else {
                    fanLast = out;
                    info->backend->sendVertex(info, pDataOut, EVAL_IWRAP(fanLast));
                }
                lastWasIn = 0;
            }

            //ffif (doFrac) {
                if (totalToDoIn == 1) {
                    dist = -0xDAD;      // complete stitch with fan of outside pts
                }
            //ff}
        }
    }
    nvAssert(totalToDoOut == 1);
    nvAssert(totalToDoIn == 1);
    nvAssert(onCurveOut == nCurveOut);
    nvAssert(onCurveIn == nCurveIn);

    if (usingHW) {
        HOS_NOTE("END Transition");
        HOS_PUSH(0, ((0x1 << 18) | (HOS_KELVIN_CHANNEL << 13) | (NV097_SET_END_TRANSITION)));
        HOS_PUSH(1, 0);
        HOS_PUSH_ADJUST(2);
        HOS_FLUSH();
    } else {
        info->backend->endPrimitive(info);

        info->backend->setFrontFace(info, 0);
    }
}


/*****************************************************************************/
unsigned int DrawIntPatch(NV_PATCH_INFO *info, NV_PATCH_QUAD_INFO *quadInfo, FDMatrix **matrices);
unsigned int DrawIntPatchGrid(NV_PATCH_INFO *info, NV_PATCH_QUAD_INFO *quadInfo, FDMatrix **matrices);

unsigned int DrawFracPatch(NV_PATCH_INFO *info,
                           int botOutSegs, int botInSegs,
                           int leftOutSegs, int leftInSegs,
                           int reverse, FDMatrix **matrices)
{
    unsigned int retVal;
    NV_PATCH_QUAD_INFO *quadInfo = info->quadInfo;

    // layer on top of DrawIntPatch() cases
    quadInfo->nu0 = botOutSegs;
    quadInfo->nu1 = botInSegs;
    quadInfo->nv0 = leftOutSegs;
    quadInfo->nv1 = leftInSegs;

    quadInfo->uMaxSegs = botInSegs;
    quadInfo->vMaxSegs = leftInSegs;
    quadInfo->uMinSegs = botOutSegs;
    quadInfo->vMinSegs = leftOutSegs;
    quadInfo->needUInner = 1;
    quadInfo->needVInner = 1;

    quadInfo->stitchLeft = 1;
    quadInfo->stitchRight = 0;
    quadInfo->stitchTop = 0;
    quadInfo->stitchBottom = 1;

    quadInfo->stitchUBegin = 1;
    quadInfo->stitchUEnd = 0;
    quadInfo->stitchVBegin = 1;
    quadInfo->stitchVEnd = 0;

    quadInfo->u0Dir = 1;
    quadInfo->v0Dir = 1;
    quadInfo->u1Dir = 1;
    quadInfo->v1Dir = 1;
    quadInfo->uMaxDir = 1;
    quadInfo->vMaxDir = 1;

    quadInfo->du0 = 1.f / quadInfo->nu0;
    quadInfo->du1 = 1.f / quadInfo->nu1;
    quadInfo->dv0 = 1.f / quadInfo->nv0;
    quadInfo->dv1 = 1.f / quadInfo->nv1;
    quadInfo->duMax = 1.f / quadInfo->uMaxSegs;
    quadInfo->dvMax = 1.f / quadInfo->vMaxSegs;

    //             *-*-*    the set frontface call will adjust for this
    // winding on  |X|O|
    // subpatches  *-*-*
    // X=CW        |O|X|
    // O=CCW       *-*-*

    info->reverse ^= reverse;
    retVal = DrawIntPatch(info, quadInfo, matrices);
    info->reverse ^= reverse;

    return retVal;
}

/*****************************************************************************/
void
evalPrepareInnerCurves(NV_PATCH_INFO *info, int bigStep, FDMatrix **matrices)
// XXX for swathing, calc the inner curves at the appropriate swatch
{
    NV_PATCH_QUAD_INFO *quadInfo = info->quadInfo;
    int doFrac = !!(info->flags & NV_PATCH_FLAG_TESS_FRACTIONAL);
    FDMatrix *pMatrix;
    int attr, needRetess;

    BEGIN_USING_TEMP_MATRIX(info->tempMatrix_m2);
    if (!(info->swatchFlags & NV_PATCH_SWATCH)) {
        needRetess = 0;
    } else {
        needRetess = 1;
    }

    for (attr = 0;  attr < info->maxAttr;  attr++) {
        if (!(info->evalEnables & (1 << attr))) {
            continue;
        }

        // If we're stitching on the top or bottom, do a U inner guard
        if (quadInfo->needUInner) {
            if (needRetess) {
                pMatrix = &info->tempMatrix_m2;
                CopyMatrix(info, pMatrix, matrices[attr]);
                // big to small, only in V so extract produces a big-step curve
                RetessMatrixV(info, 0, pMatrix);
            } else {
                pMatrix = matrices[attr];
            }
            if (quadInfo->stitchVBegin) {
                OffsetFDMatrix_Extract_Discard(info, quadInfo->pUInner[attr], 0, pMatrix, 0, 1);
            } else {
                nvAssert(quadInfo->stitchVEnd);
                OffsetFDMatrix_Extract_Discard(info, quadInfo->pUInner[attr], 0, pMatrix, 0, quadInfo->vMaxSegs-1);
            }
            if (doFrac) {
                // Calc UInnerFrac
                OffsetFDMatrix_Extract_Discard(info, info->guardSetUInnerFrac[attr], 0, pMatrix, 0, quadInfo->vMaxSegs-1);
            }
        }

        // If we're stitching on the left or right, do a V inner guard
        if (quadInfo->needVInner) {
            if (needRetess) {
                pMatrix = &info->tempMatrix_m2;
                CopyMatrix(info, pMatrix, matrices[attr]);
                // big to small, only in U so extract produces a big-step curve
                RetessMatrixU(info, 0, pMatrix);
            } else {
                pMatrix = matrices[attr];
            }
            if (quadInfo->stitchUBegin) {
                OffsetFDMatrix_Extract_Discard(info, quadInfo->pVInner[attr], 1, pMatrix, 1, 0);
            } else {
                nvAssert(quadInfo->stitchUEnd);
                OffsetFDMatrix_Extract_Discard(info, quadInfo->pVInner[attr], 1, pMatrix, quadInfo->uMaxSegs-1, 0);
            }
            if (doFrac) {
                // Calc VInnerFrac
                OffsetFDMatrix_Extract_Discard(info, info->guardSetVInnerFrac[attr], 1, pMatrix, quadInfo->uMaxSegs-1, 0);
            }
        }
    }
    END_USING_TEMP_MATRIX(info->tempMatrix_m2);
}

/*****************************************************************************/
/*****************************************************************************/
static unsigned int
FillIntCornerLL(NV_PATCH_INFO *info, NV_PATCH_QUAD_INFO *quadInfo, NV_PATCH_QUAD_INFO *quadInfoOrig,
            int index, float *pPoint)
{
    NV_PATCH_CURVE_INFO *tempCurve = &info->tempCurve;

    if (quadInfo->stitchVBegin) {
        nvAssert(!quadInfo->stitchVEnd);
        if (quadInfo->vMaxSegs > 1) {
            if (quadInfo->stitchUBegin) {
                CopyCurve(info, tempCurve, (*quadInfo->pSwatchUBegin)[index]);
                OffsetCurve(info, tempCurve, 1);
                CopyPoint(pPoint, tempCurve->coeffs[0]);
                return 0;
            } else {
                // since outside edge takes priority, step along VBegin, and tweak pSwatchUBegin
                CopyCurve(info, tempCurve, (*quadInfo->pSwatchVBegin)[index]);
                OffsetCurve(info, tempCurve, 1);
                CopyPoint(pPoint, tempCurve->coeffs[0]);
                CopyPoint((*quadInfo->pSwatchUBegin)[index]->coeffs[0], pPoint);
                return 0;
            }
        }
        if (quadInfo->stitchUBegin) {
            // must step along ending patch edge
            CopyCurve(info, tempCurve, (*quadInfo->pSwatchUEnd)[index]);
            OffsetCurve(info, tempCurve, 1);
            CopyPoint(pPoint, tempCurve->coeffs[0]);
            return 0;
        }
        CopyPoint(pPoint, quadInfoOrig->pCorners[index][  quadInfo->vMaxDir][1-quadInfo->uMaxDir]);
        return 0;

    } else if (quadInfo->stitchUBegin) {
        nvAssert(!quadInfo->stitchUEnd);
        // must step along edge, even though (*quadInfo->pSwatchVBegin)[index]->coeffs[0] is about right
        CopyCurve(info, tempCurve, (*quadInfo->pSwatchUBegin)[index]);
        OffsetCurve(info, tempCurve, 1);
        CopyPoint(pPoint, tempCurve->coeffs[0]);
        // Since the outside edge takes priority, we tweak start of pSwatchVBegin to be on the outside edge
        CopyPoint((*quadInfo->pSwatchVBegin)[index]->coeffs[0], pPoint);

    } else {
        CopyPoint(pPoint, quadInfoOrig->pCorners[index][1-quadInfo->vMaxDir][1-quadInfo->uMaxDir]);
    }

    return 0;
}

/*****************************************************************************/
static unsigned int
FillIntCornerLR(NV_PATCH_INFO *info, NV_PATCH_QUAD_INFO *quadInfo, NV_PATCH_QUAD_INFO *quadInfoOrig,
            int index, float *pPoint)
{
    NV_PATCH_CURVE_INFO *tempCurve = &info->tempCurve;

    if (quadInfo->stitchVBegin) {
        nvAssert(!quadInfo->stitchVEnd);
        if (quadInfo->vMaxSegs > 1) {
            CopyCurve(info, tempCurve, (*quadInfo->pSwatchVEnd)[index]);
            OffsetCurve(info, tempCurve, 1);
            CopyPoint(pPoint, tempCurve->coeffs[0]);
            return 0;
        }
        if (quadInfo->stitchUEnd) {
            CopyCurve(info, tempCurve, (*quadInfo->pSwatchUEnd)[index]);
            OffsetCurve(info, tempCurve, quadInfo->uMaxSegs - 1);
            CopyPoint(pPoint, tempCurve->coeffs[0]);
            return 0;
        }
        CopyPoint(pPoint, quadInfoOrig->pCorners[index][  quadInfo->vMaxDir][quadInfo->uMaxDir]);
        return 0;

    } else if (quadInfo->stitchUEnd) {
        nvAssert(!quadInfo->stitchUBegin);
        CopyPoint(pPoint, (*quadInfo->pSwatchVEnd)[index]->coeffs[0]);

    } else {
        CopyPoint(pPoint, quadInfoOrig->pCorners[index][1-quadInfo->vMaxDir][quadInfo->uMaxDir]);
    }

    return 0;
}

/*****************************************************************************/
static unsigned int
FillIntCornerUL(NV_PATCH_INFO *info, NV_PATCH_QUAD_INFO *quadInfo, NV_PATCH_QUAD_INFO *quadInfoOrig,
            int index, float *pPoint)
{
    NV_PATCH_CURVE_INFO *tempCurve = &info->tempCurve;

    if (quadInfo->stitchVEnd) {
        nvAssert(!quadInfo->stitchVBegin);
        if (quadInfo->vMaxSegs > 1) {
            if (quadInfo->stitchUBegin) {
                CopyCurve(info, tempCurve, (*quadInfo->pSwatchUEnd)[index]);
                OffsetCurve(info, tempCurve, 1);
                CopyPoint(pPoint, tempCurve->coeffs[0]);
            } else {
                CopyPoint(pPoint, (*quadInfo->pSwatchUEnd)[index]->coeffs[0]);
            }
            return 0;
        }
        if (quadInfo->stitchUBegin) {
            CopyCurve(info, tempCurve, (*quadInfo->pSwatchUBegin)[index]);
            OffsetCurve(info, tempCurve, 1);
            CopyPoint(pPoint, tempCurve->coeffs[0]);
            return 0;
        }
        CopyPoint(pPoint, quadInfoOrig->pCorners[index][1-quadInfo->vMaxDir][1-quadInfo->uMaxDir]);
        return 0;

    } else if (quadInfo->stitchUBegin) {
        nvAssert(!quadInfo->stitchUEnd);
        CopyCurve(info, tempCurve, (*quadInfo->pSwatchUEnd)[index]);
        OffsetCurve(info, tempCurve, 1);
        CopyPoint(pPoint, tempCurve->coeffs[0]);

    } else {
        CopyPoint(pPoint, quadInfoOrig->pCorners[index][quadInfo->vMaxDir][1-quadInfo->uMaxDir]);
    }
    return 0;
}

/*****************************************************************************/
static unsigned int
FillIntCornerUR(NV_PATCH_INFO *info, NV_PATCH_QUAD_INFO *quadInfo, NV_PATCH_QUAD_INFO *quadInfoOrig,
            int index, float *pPoint)
{
    NV_PATCH_CURVE_INFO *tempCurve = &info->tempCurve;
    int doFrac = !!(info->flags & NV_PATCH_FLAG_TESS_FRACTIONAL);
    int adjust = doFrac && (info->swatchFlags & NV_PATCH_SWATCH);

    if (quadInfo->stitchVEnd  ||  doFrac) {
        nvAssert(!quadInfo->stitchVBegin  ||  doFrac);
        if ((quadInfo->vMaxSegs > 1)  ||  doFrac) {
            CopyCurve(info, tempCurve, (*quadInfo->pSwatchVEnd)[index]);
            OffsetCurve(info, tempCurve, quadInfo->vMaxSegs - 1 + adjust);
            CopyPoint(pPoint, tempCurve->coeffs[0]);
            return 0;
        }
        if (quadInfo->stitchUEnd  ||  doFrac) {
            CopyCurve(info, tempCurve, (*quadInfo->pSwatchUBegin)[index]);
            OffsetCurve(info, tempCurve, quadInfo->uMaxSegs - 1 + adjust);
            CopyPoint(pPoint, tempCurve->coeffs[0]);
            return 0;
        }
        nvAssert(!(info->flags & NV_PATCH_FLAG_TESS_FRACTIONAL));
        CopyPoint(pPoint, quadInfoOrig->pCorners[index][1-quadInfo->vMaxDir][quadInfo->uMaxDir]);
        return 0;

    } else if (quadInfo->stitchUEnd) {
        nvAssert(!quadInfo->stitchUBegin);
        CopyCurve(info, tempCurve, (*quadInfo->pSwatchUEnd)[index]);
        OffsetCurve(info, tempCurve, quadInfo->uMaxSegs - 1);
        CopyPoint(pPoint, tempCurve->coeffs[0]);

    } else {
        CopyPoint(pPoint, quadInfoOrig->pCorners[index][quadInfo->vMaxDir][quadInfo->uMaxDir]);
    }

    return 0;
}

/*****************************************************************************/
// routines for integer tessellations
// NOTE: tempVBegin and tempVEnd, are scratch storage.
// This means that the guards may be stepping without a copy.
// The guard setup is handled by the caller, which allows the caller
// to make intelligent choices about the setup and avoid double copies.
// However, the matrix doesn't have any options, so it's better to have
// this routine do the copy from 'matrices' to ppMatrixSetSS0
// since an attr loop is required here anyways.
// So, 'matrices' data must not be altered, and ppMatrixSetSS0[*] are scratch.

// For SW emulation, I tried a strategy of having the formation of the regular
// grid generate curves and guards in preparation for the transitions.
// This can work.
// One of the problems is that a swatch UR guard point is required
// by the HW, so it's not possible to simply write the "top" UInner guard
// from the matrix and just use it, there would still need to be
// a UR guard point to match the swatch to the right.
// In SW, we could save the results from EvalStrip() and feed that into
// the starting point for the next UInner transition (for both the
// FIRST_ROW and LAST_ROW), but not for the inner swatches which naturally get
// guard points and curves from the big step matrices and curves obtained
// while doing swaths.
// In SW, it's required to save all the UInner and VInner curves for later
// doing the transitions, so the storage issue is identical, but with HW it's
// not feasible to store arbitrary amounts of data for later use during the
// transitions.
// So, the "top" UEnd is calculated as a series of guard curves, and the
// guard UR comes from the next curve to the right of the current swatch.
// This could be optimized for SW emulation, but is not done in order to have
// SW emulation more closely match and test requirements for HW drawing.
// Similar reasoning applies to the swatch LR corner guard.
// Also, the VBegin and UBegin inner curves could be totally obtained from
// the matrix at appropriate times, feeding UL and LR to the next
// swatch curve along the outer boundaries of the regular grid.
// Finally, LL could always be obtained from the starting point of the matrix,
// or after one step to the regular grid (as needed for EvalStrip)

unsigned int
DrawIntPatchGrid(NV_PATCH_INFO *info, NV_PATCH_QUAD_INFO *quadInfo, FDMatrix **matrices)
{
    int ix, iy, degen, ylimit, ymax, index, useVBegin, useVEnd;
    NV_PATCH_CURVE_INFO **tempVBegin, **tempVEnd, *tempCurve;
    FDMatrix **ppMatrixSetSS0;
    FDCurveAttrSet *pCurvesTop, *pCurvesBot, *pCurvesTemp;
    NV_PATCH_EVAL_OUTPUT *pOut1, *pOut2, *pTemp;
    int fixUL = 0, fixUR = 0;
    int fixLL = 0, fixLR = 0;
    int iEvalRight = quadInfo->uMaxSegs - quadInfo->stitchUEnd;
    unsigned int retVal = NV_PATCH_EVAL_OK;
    int doFrac = !!(info->flags & NV_PATCH_FLAG_TESS_FRACTIONAL);
    NV_PATCH_CURVE_COEFFS *pCoeffs[NV_PATCH_NUMBER_OF_ATTRIBS];
    HOS_CREATE_AND_ASSIGN_PUSHBUF_LOCALS();
    int usingHW = info->usingHW;

    tempVBegin = info->tempVBegin;
    tempVEnd = info->tempVEnd;
    tempCurve = &info->tempCurve;
    ppMatrixSetSS0 = info->ppMatrixSetSS0;
    pCurvesTop = quadInfo->pCurvesTop;
    pCurvesBot = quadInfo->pCurvesBot;
    pOut1 = quadInfo->pOut1;
    pOut2 = quadInfo->pOut2;

#if defined(ENABLE_DEBUG_SWATH) && defined(IS_OPENGL)
    if (!usingHW && nvDebugLevel >= 3 && (evalTrace & 1)) {
        // draw red X through each sub-patch using corner points

        glDisable(GL_TEXTURE_2D);
        glPushMatrix();
        glTranslatef(0, 0, .1);
        glBegin(GL_LINE_STRIP);
            glColor3f(1, 0, 0); glVertex3fv(info->pSwatchCorner[0][0][0]);
            glColor3f(1, 0, 0); glVertex3fv(info->pSwatchCorner[0][0][1]);
            glColor3f(0, 1, 0); glVertex3fv(info->pSwatchCorner[0][1][0]); 
            glColor3f(0, 1, 0); glVertex3fv(info->pSwatchCorner[0][1][1]);
            glColor3f(1, 0, 0); glVertex3fv(info->pSwatchCorner[0][0][0]);
        glEnd();

        glPopMatrix();
        glColor3f(1, 1, 0);
        if (info->evalEnables & (1 << NV_PATCH_ATTRIB_TEXCOORD0)) {
            glEnable(GL_TEXTURE_2D);
        }
    }
#endif

    // tag:iii
    // setup the swatch
    degen = 0;//(quadInfo->vMaxSegs == 1); // && (quadInfo->stitchVBegin || quadInfo->stitchVEnd);
    ymax = quadInfo->vMaxSegs - quadInfo->stitchVEnd - quadInfo->stitchVBegin;// + degen;

    // check for degenerate regular grid.
    if (!doFrac) {
        if ((ymax <= 0)  ||  ((iEvalRight - quadInfo->stitchUBegin) <= 0)) {
            return retVal;
        }
    } else {
        // this test is normal against <= 2 but we've already pre-subtracted
        // 1 from each before calling here assuming that the regular grid
        // has 1 less segment due to the additional 2 transitions in frac.
        if ((ymax <= 0)  ||  ((iEvalRight - quadInfo->stitchUBegin) <= 0)) {
            return retVal;
        }
    }

    // Note: the 'use' vars are for non-std-guard attributes
    useVBegin = 0;
    useVEnd = 0; //doFrac && (info->swatchFlags & NV_PATCH_SWATCH_LAST_COL);

    for (index = 0; index < info->maxAttr; index++) {
        if (info->evalEnables & (1 << index)) {

            // copy and step the forward differencing matrix to the first row of regular grid (as for HW)
            CopyMatrix(info, ppMatrixSetSS0[index], matrices[index]);

#if defined(IS_OPENGL) && defined(COMPILE_TRACE_LIBRARY)
            if ((1 << index) & EV_GUARD_BITS) {
                if (!quadInfo->stitchVBegin) {
                    nvAssert(PointsEqual(tempVBegin[index]->coeffs[0], info->pSwatchCorner[index][0][0]));
                    nvAssert(PointsEqual(tempVEnd[index]->coeffs[0],   info->pSwatchCorner[index][0][1]));
                }

                if ((info->swatchFlags & NV_PATCH_SWATCH_FIRST_ROW) && !quadInfo->stitchVBegin
                            &&  !quadInfo->stitchUBegin) { // && !quadInfo->needUInner ?
                    // the guard start should match pSwatchUBegin
                    nvAssert(PointsEqual(tempVBegin[index]->coeffs[0], (*quadInfo->pSwatchUBegin)[index]->coeffs[0]));
                    // tempVBegin should be extracted from matrix
                    nvAssert(PointsEqual(tempVBegin[index]->coeffs[0], ppMatrixSetSS0[index]->data[0][0]));
                }

                if (0 && nvDebugLevel >= 4) {
                    if (info->swatchFlags & NV_PATCH_SWATCH_FIRST_ROW) {
                        if (!(quadInfo->stitchVBegin)) {
                            CompareUCurveMatrix((*quadInfo->pSwatchUBegin)[index], matrices[index]);
                        }
                    }
                    if (info->swatchFlags & NV_PATCH_SWATCH_FIRST_COL) {
                        if (!(quadInfo->stitchUBegin)) {
                            CompareVCurveMatrix((*quadInfo->pSwatchVBegin)[index], matrices[index]);
                        }
                    }
                }

            }
#endif

            OffsetFDMatrix(info, ppMatrixSetSS0[index], 0, quadInfo->stitchVBegin);

            if (usingHW) {
                continue;
            }
            if (!EV_GUARD_ATTR(index)/*  &&  !doFrac*/) {
                continue;
            }

#if defined(IS_OPENGL) && defined(COMPILE_TRACE_LIBRARY)
            // test code for guard curve
            if (0 && nvDebugLevel >= 4) {
                if ((*quadInfo->pSwatchUBegin)[index]) {
                    CopyCurve(info, tempCurve, (*quadInfo->pSwatchUBegin)[index]);
                    OffsetCurve(info, tempCurve, quadInfo->stitchUBegin);
                    CompareUCurveMatrix(tempCurve, ppMatrixSetSS0[index]);
                }

                if ((*quadInfo->pSwatchVBegin)[index]) {
                    CopyCurve(info, tempCurve, (*quadInfo->pSwatchVBegin)[index]);
                    OffsetCurve(info, tempCurve, quadInfo->stitchVBegin);
                    CompareVCurveMatrix(tempCurve, ppMatrixSetSS0[index]);
                }
            }
#endif

            // Step V Begin/End curves
            if (quadInfo->stitchVBegin) {
                OffsetCurve(info, tempVBegin[index], 1);
                OffsetCurve(info, tempVEnd[index], 1);
                if (!quadInfo->stitchUBegin) {
                    // tweak UInner curve to start at guard locations
                    CopyPoint((*quadInfo->pSwatchUBegin)[index]->coeffs[0], tempVBegin[index]->coeffs[0]);
                }
            }
        }
    }

    if (usingHW) {
        //BEGIN_END_SWATCH/SWATH?
        unsigned long dwFormat;
        dwFormat = NV097_SET_BEGIN_END_SWATCH_SWATCH_CMD_BEGIN;
        dwFormat |= (((info->swatchFlags  & NV_PATCH_SWATCH_FIRST_ROW) ? NV097_SET_BEGIN_END_SWATCH_NEW_SWATH_NEW : NV097_SET_BEGIN_END_SWATCH_NEW_SWATH_CONTINUE)   << 4);
        dwFormat |= ((quadInfo->stitchVBegin ? NV097_SET_BEGIN_END_SWATCH_SKIP_FIRST_ROW_TRUE : NV097_SET_BEGIN_END_SWATCH_SKIP_FIRST_ROW_FALSE) << 8);
        dwFormat |= ((quadInfo->stitchUBegin ? NV097_SET_BEGIN_END_SWATCH_SKIP_FIRST_COL_TRUE : NV097_SET_BEGIN_END_SWATCH_SKIP_FIRST_COL_FALSE) << 12);
        dwFormat |= (((quadInfo->vMaxSegs - quadInfo->stitchVEnd < info->maxSwatch) ?  NV097_SET_BEGIN_END_SWATCH_SHORT_SWATCH_PARTIAL_HEIGHT : NV097_SET_BEGIN_END_SWATCH_SHORT_SWATCH_FULL_HEIGHT) << 16);
        dwFormat |= (((quadInfo->uMaxSegs - quadInfo->stitchUEnd < info->maxSwatch) ?  NV097_SET_BEGIN_END_SWATCH_NARROW_SWATCH_PARTIAL_WIDTH : NV097_SET_BEGIN_END_SWATCH_NARROW_SWATCH_FULL_WIDTH) << 20);

        HOS_NOTE("Begin Swatch");
        HOS_PUSH(0, ((0x1 << 18) | (HOS_KELVIN_CHANNEL << 13) | (NV097_SET_BEGIN_END_SWATCH)));
        HOS_PUSH(1, dwFormat);
        HOS_PUSH_ADJUST(2);

        //send guard curves!!!!
        SendGuardCurve(NV097_SET_BEGIN_END_CURVE_CMD_LEFT_GUARD_CURVE,  info, quadInfo, info->swatchFlags );
        SendGuardCurve(NV097_SET_BEGIN_END_CURVE_CMD_RIGHT_GUARD_CURVE, info, quadInfo, info->swatchFlags );
    }

    // prep INT patch
    if (info->swatchFlags & NV_PATCH_SWATCH_FIRST_ROW) {
        for (index = 0; index < info->maxAttr; index++) {
            if (info->evalEnables & (1 << index)) {
                pCoeffs[index] = &(*quadInfo->pSwatchUBegin)[index]->coeffs;

                if (!usingHW) {
                    // no UInner curve, the last curve should be taken from the patch edge
                    CopyCoeffs(info, &(*pCurvesBot)[index]->coeffs, pCoeffs[index]);
                }
            }
        }

        if (usingHW) {
            unsigned long dwCount;  //precount the first two methods.
            int i;
            HOS_NOTE("Begin Curve");
            HOS_PUSH(0, ((0x1 << 18) | (HOS_KELVIN_CHANNEL << 13) | (NV097_SET_BEGIN_END_CURVE)));
            HOS_PUSH(1, NV097_SET_BEGIN_END_CURVE_CMD_STRIP_CURVE);
            HOS_PUSH_ADJUST(2);
            for (index = 0; index < info->maxAttr; index++) {
                if (info->evalEnables & (1 << index)) {
                    //if this is a not a new swath... do we pre adjust that row??? or just not send the last row in the previous patch?
                    dwCount = 0;
                    for (i = 0; i < ppMatrixSetSS0[index]->columns; i++) {
                        HOS_NOTE("Set Curve Coefficients");
                        HOS_PUSH(dwCount, ((0x4 << 18) | (HOS_KELVIN_CHANNEL << 13) | (NV097_SET_CURVE_COEFFICIENTS(0))));
                        HOS_PUSHF(dwCount+1, VIEW_AS_DWORD((*pCoeffs[index])[i][0]));
                        HOS_PUSHF(dwCount+2, VIEW_AS_DWORD((*pCoeffs[index])[i][1]));
                        HOS_PUSHF(dwCount+3, VIEW_AS_DWORD((*pCoeffs[index])[i][2]));
                        HOS_PUSHF(dwCount+4, VIEW_AS_DWORD((*pCoeffs[index])[i][3]));
                        dwCount+=5;
                    }
                    HOS_PUSH_ADJUST(dwCount);
                }
            }
            HOS_PUSH(0, ((0x1 << 18) | (HOS_KELVIN_CHANNEL << 13) | (NV097_SET_BEGIN_END_CURVE)));
            HOS_PUSH(1, NV097_SET_BEGIN_END_CURVE_CMD_END_CURVE_DATA);
            HOS_PUSH_ADJUST(2);

        } else {
            // first strip of regular grid. Will become first bot strip.
            EvalStrip(info, pCurvesBot, 1+quadInfo->uMaxSegs - quadInfo->stitchUEnd, pOut2, 0);
            for (index = 0; index < info->maxAttr; index++) {
                if (info->evalEnables & (1 << index)) {
                    if (EV_GUARD_ATTR(index) || useVBegin) {
                        if (info->swatchFlags & NV_PATCH_SWATCH_FIRST_COL) {
                            // Force last point from grid corner
                            CopyPoint(pOut2->vertexAttribs[quadInfo->stitchUBegin][index],
                                                            info->gridCorner[index][1-quadInfo->vMaxDir][1-quadInfo->uMaxDir]);
                        } else {
                            // Force first point from guard curve
                            CopyPoint(pOut2->vertexAttribs[quadInfo->stitchUBegin][index], tempVBegin[index]->coeffs[0]);
                        }
                    }
                    if (EV_GUARD_ATTR(index) || useVEnd) {
                        if (info->swatchFlags & NV_PATCH_SWATCH_LAST_COL) {
                            // Force last point from grid corner
                            CopyPoint(pOut2->vertexAttribs[iEvalRight][index],
                                                            info->gridCorner[index][1-quadInfo->vMaxDir][  quadInfo->uMaxDir]);
                        } else {
                            // Force last point from guard curve
                            CopyPoint(pOut2->vertexAttribs[iEvalRight][index], tempVEnd[index]->coeffs[0]);
                        }
                    }
                }
            }
        }

    } else {
        // not first row
        for (index = 0; index < info->maxAttr; index++) {
            if (info->evalEnables & (1 << index)) {
                // tweak 
            }
        }
    }

    if (doFrac) {
        // for FRAC patches, check after writing UBegin
        if ((ymax <= 0)  ||  ((iEvalRight - quadInfo->stitchUBegin) <= 0)) {
            return retVal;
        }
    }

    // tag:rrr
    // loop thru regular grid, plus 1 for top stitch to init info for "bot" of top stitch
    ylimit = ymax - 1;
    for (iy = 0; iy < ymax; iy++) {
        for (index = 0; index < info->maxAttr; index++) {
            if (info->evalEnables & (1 << index)) {
                OffsetFDMatrix(info, ppMatrixSetSS0[index], 0, 1);
                if (EV_GUARD_ATTR(index)  ||  useVBegin) {
                    OffsetCurve(info, tempVBegin[index], 1);
                }
                if (EV_GUARD_ATTR(index)  ||  useVEnd) {
                    OffsetCurve(info, tempVEnd[index], 1);
                }

                if ((iy == ylimit) && (info->swatchFlags & NV_PATCH_SWATCH_LAST_ROW)) {
                    if (quadInfo->stitchVEnd) {
                        float t4[4];
                        int doTweak = !quadInfo->stitchUBegin && EV_GUARD_ATTR(index);

                        if (doTweak) {
                            // save curve, but preserve starting point
                            // copy since swatchCorner may be the same as pSwatchUEnd
                            CopyPoint(t4, info->pSwatchCorner[index][1][0]);
                            ExtractUCurve(info, (*quadInfo->pSwatchUEnd)[index], ppMatrixSetSS0[index]);
                        }

                        if (doTweak) {
                            // but tweak to swatchCorner set up by higher level routine
                            CopyPoint((*quadInfo->pSwatchUEnd)[index]->coeffs[0], t4);
                        }
                    }
                    pCoeffs[index] = &(*quadInfo->pSwatchUEnd)[index]->coeffs;
                } else {
                    // "inside" regular grid
                    pCoeffs[index] = &ppMatrixSetSS0[index]->data[0];
                }

                if (!usingHW) {
                    CopyCoeffs(info, &(*pCurvesTop)[index]->coeffs, pCoeffs[index]);
                }
            }
        }

        if (iy == ylimit  &&  !doFrac  &&  (info->swatchFlags & NV_PATCH_SWATCH_LAST_ROW)) {
            //ffif (quadInfo->stitchVEnd && !quadInfo->stitchUBegin) {
            if (quadInfo->stitchVEnd) {
                // tweak UInner curve to start at guard locations
                //ffCopyPoint((*quadInfo->pSwatchUEnd)[ATTR_V]->coeffs[0], tempVBegin[ATTR_V]->coeffs[0]);
                //ff(*quadInfo->pSwatchUEnd)[ATTR_V]->coeffs[0][1] += .05;
            }
        }

        if (!usingHW) {
            // eval "top" strip
            EvalStrip(info, pCurvesTop, 1+quadInfo->uMaxSegs - quadInfo->stitchUEnd, pOut1, 0);

            if (iy == ylimit  &&  !doFrac) {
                // force first and last point from swatch corner
                for (index = 0; index < info->maxAttr; index++) {
                    if (!(info->evalEnables & (1 << index))) {
                        continue;
                    }
                    if (EV_GUARD_ATTR(index)) {
                        CopyPoint(pOut1->vertexAttribs[quadInfo->stitchUBegin][index], info->pSwatchCorner[index][1][0]);
                        CopyPoint(pOut1->vertexAttribs[iEvalRight][index], info->pSwatchCorner[index][1][1]);
                        continue;
                    }
                    if (!doFrac) {
                        continue;
                    }
                    if (!useVEnd) {
                        continue;
                    }
                    // Force first point from guard curve
                    //ffCopyPoint(pOut1->vertexAttribs[quadInfo->stitchUBegin][index], tempVBegin[index]->coeffs[0]);

                    if (!(info->swatchFlags & NV_PATCH_SWATCH_LAST_ROW)) {
                        // Force last point from guard curve
                        //ffCopyPoint(pOut1->vertexAttribs[iEvalRight][index], tempVEnd[index]->coeffs[0]);
                    } else {
                        //ff// get first point from corner
                        //ffCopyPoint(pOut1->vertexAttribs[quadInfo->stitchUBegin][index], info->pSwatchCorner[index][1][0]);
                        // get end point from corner
                        CopyPoint(pOut1->vertexAttribs[iEvalRight][index], info->pSwatchCorner[index][1][1]);
                    }
                }

            } else {
                for (index = 0; index < info->maxAttr; index++) {
                    if (info->evalEnables & (1 << index)) {
                        if (EV_GUARD_ATTR(index)  ||  useVBegin) {
                            // Force first point from guard curve
                            CopyPoint(pOut1->vertexAttribs[quadInfo->stitchUBegin][index], tempVBegin[index]->coeffs[0]);
                        }
                        if (EV_GUARD_ATTR(index)  ||  useVEnd) {
                            // Force last point from guard curve
                            CopyPoint(pOut1->vertexAttribs[iEvalRight][index], tempVEnd[index]->coeffs[0]);
                        }
                    }
                }
            }
        }

        // avoid strip when degenerate regular grid (have only bottom stitch)
        // and avoid degenerate strip at top of regular grid
        if (!degen) {
            if (usingHW) {
                unsigned long dwCount;  //precount the first two methods.
                int i;
                HOS_NOTE("Begin Curve");
                HOS_PUSH(0, ((0x1 << 18) | (HOS_KELVIN_CHANNEL << 13) | (NV097_SET_BEGIN_END_CURVE)));
                HOS_PUSH(1, NV097_SET_BEGIN_END_CURVE_CMD_STRIP_CURVE);
                HOS_PUSH_ADJUST(2);
                for (index = 0; index < info->maxAttr; index++) {
                    if (info->evalEnables & (1 << index)) {
                        dwCount = 0;
                        //if this is a not a new swath... do we pre adjust that row??? or just not send the last row in the previous patch?
                        for (i = 0; i < ppMatrixSetSS0[index]->columns; i++) {
                            HOS_NOTE("Set Curve Coefficients");
                            HOS_PUSH(dwCount, ((0x4 << 18) | (HOS_KELVIN_CHANNEL << 13) | (NV097_SET_CURVE_COEFFICIENTS(0))));
                            HOS_PUSHF(dwCount+1, VIEW_AS_DWORD((*pCoeffs[index])[i][0]));
                            HOS_PUSHF(dwCount+2, VIEW_AS_DWORD((*pCoeffs[index])[i][1]));
                            HOS_PUSHF(dwCount+3, VIEW_AS_DWORD((*pCoeffs[index])[i][2]));
                            HOS_PUSHF(dwCount+4, VIEW_AS_DWORD((*pCoeffs[index])[i][3]));
                            dwCount+=5;
                        }
                        HOS_PUSH_ADJUST(dwCount);
                    }
                }
                HOS_PUSH(0, ((0x1 << 18) | (HOS_KELVIN_CHANNEL << 13) | (NV097_SET_BEGIN_END_CURVE)));
                HOS_PUSH(1, NV097_SET_BEGIN_END_CURVE_CMD_END_CURVE_DATA);
                HOS_PUSH_ADJUST(2);

            } else {
                // output a strip of the regular grid
                info->backend->beginPrimitive(info, NV_PATCH_PRIMITIVE_TSTRIP);
                if (!(quadInfo->uMaxDir ^ quadInfo->vMaxDir ^ info->flipUV)) {
                    // "normal", start with top-bot-top
                    for (ix = quadInfo->stitchUBegin; ix <= quadInfo->uMaxSegs - quadInfo->stitchUEnd; ix++) {
                        info->backend->sendVertex(info, pOut1, ix);
                        info->backend->sendVertex(info, pOut2, ix);
                    }
                } else {
                    // flipped case
                    for (ix = quadInfo->stitchUBegin; ix <= quadInfo->uMaxSegs - quadInfo->stitchUEnd; ix++) {
                        info->backend->sendVertex(info, pOut2, ix);
                        info->backend->sendVertex(info, pOut1, ix);
                    }
                }
                info->backend->endPrimitive(info);
            }
        }
        pTemp = pOut1;
        pOut1 = pOut2;
        pOut2 = pTemp;
        pCurvesTemp = pCurvesTop;
        pCurvesTop = pCurvesBot;
        pCurvesBot = pCurvesTemp;
    }

    if (usingHW) {
        HOS_NOTE("End Swatch");
        HOS_PUSH(0, ((0x1 << 18) | (HOS_KELVIN_CHANNEL << 13) | (NV097_SET_BEGIN_END_SWATCH)));
        HOS_PUSH(1, NV097_SET_BEGIN_END_SWATCH_SWATCH_CMD_END);
        HOS_PUSH_ADJUST(2);
    }

    quadInfo->pCurvesTop = pCurvesTop;
    quadInfo->pCurvesBot = pCurvesBot;
    quadInfo->pOut1 = pOut1;
    quadInfo->pOut2 = pOut2;

    return retVal;
}


void DrawAllPatchTransitions(NV_PATCH_INFO *info, NV_PATCH_QUAD_INFO *quadInfo,
            FDCurveAttrSet **ppSetU0, FDCurveAttrSet **ppSetU1, FDCurveAttrSet **ppSetUInner, FDCurveAttrSet **ppSetUInnerFrac,
            FDCurveAttrSet **ppSetV0, FDCurveAttrSet **ppSetV1, FDCurveAttrSet **ppSetVInner, FDCurveAttrSet **ppSetVInnerFrac)
{
    FDCurveAttrSet **ppCurvesOut, **ppCurvesInner;

    NV_TRACE_COND(TR_EVAL, 25,
        TPRINTF(("DrawAllPatchTransitions nU0=%d nU1=%d nV0=%d nV1=%d\n",
                quadInfo->nu0, quadInfo->nu1, quadInfo->nv0, quadInfo->nv1));
        TPRINTF(("\tdir U0=%d U1=%d V0=%d V1=%d\n",
                quadInfo->u0Dir, quadInfo->u1Dir, quadInfo->v0Dir, quadInfo->v1Dir));
        TPRINTF(("\tmaxDir U=%d V=%d\n", quadInfo->uMaxDir, quadInfo->vMaxDir));
    );

    if (info->flags & NV_PATCH_FLAG_TESS_FRACTIONAL) {
        int index;

        for (index = 0; index < info->maxAttr; index++) {
            if (!(info->evalEnables & (1 << index))) {
                continue;
            }

            //These are INNER TRANSITION ENDPOINTS -- we are storing them in the grid corners
            //slot because they are free and the original data there won't be needed anymore
            //ffCopyCurve(info, &info->tempCurve, quadInfo->pU1[index]);
            CopyCurve(info, &info->tempCurve, (*ppSetU1[0])[index]);
            OffsetCurve(info, &info->tempCurve, 1);
            CopyPoint(info->gridCorner[index][1][0], (float*)&info->tempCurve.coeffs[0]);

            //ffCopyCurve(info, &info->tempCurve, quadInfo->pV1[index]);
            CopyCurve(info, &info->tempCurve, (*ppSetV1[0])[index]);
            OffsetCurve(info, &info->tempCurve, 1);
            CopyPoint(info->gridCorner[index][0][1], (float*)&info->tempCurve.coeffs[0]);
        }

        // do initial stitches for FRAC : RIGHT/TOP/LEFT
        nvAssert(quadInfo->v1Dir == quadInfo->vMaxDir);
        nvAssert(quadInfo->u1Dir == quadInfo->uMaxDir);

        // TOP/RIGHT/BOTTOM/LEFT
        // DCR HW must      *---*-----------*
        // render FRAC      |   |    0     /|
        // stitches in      |   *---------* |
        // order TOP /      |   |         | |
        // RIGHT / BOTTOM   | 3 |         |1|
        // LEFT             |   |         | |
        //                  |  _*---------*-*
        //                  |_/      2      |
        //                  *---------------*
        if (quadInfo->nu1 < quadInfo->nv1) {
assert(0);
            // this should not happen because we call MaybeTransposeFlipQuad() to
            // make nu1 >= nv1
            // Mostly this is an optimization, but it may be that
            // HW requires a transpose of the transitions when we are in a degenerate grid case.
        }

        {
            // TOP
            {
                if (quadInfo->uMaxSegs > 1 && quadInfo->vMaxSegs > 1) {
                    ppCurvesOut = ppSetU1;
                    ppCurvesInner = ppSetUInnerFrac;
                    DrawIntStitch(1, info, quadInfo, ppCurvesOut, ppCurvesInner,
                        quadInfo->uMaxSegs, quadInfo->uMaxSegs,
                        quadInfo->pOut1, quadInfo->pOut2,
                        1, 1-quadInfo->uMaxDir,  // for inner beginpoint from regular grid corner
                        1, quadInfo->uMaxDir,  // for inner endpoint from regular grid corner
                        1, quadInfo->u1Dir,    // for outer endpoint from patch corners[][]
                        0, 1,                  // stitchLowOut, stitchHighOut,
                        0, 1,                  // stitchLowIn, stitchHighIn,
                        quadInfo->u1Dir, quadInfo->u0Dir, quadInfo->uMaxDir,
                        quadInfo->u1Dir, 1 ^ quadInfo->u1Dir, LAST_ROW);
                }
            }

            // RIGHT
            {
                if (quadInfo->uMaxSegs > 1 && quadInfo->vMaxSegs > 1) {
                    ppCurvesOut = ppSetV1;
                    ppCurvesInner = ppSetVInnerFrac;
                    //don't render a bottom transition if degenerate regular grid

                    DrawIntStitch(0, info, quadInfo, ppCurvesOut, ppCurvesInner, quadInfo->vMaxSegs, quadInfo->vMaxSegs,
                        quadInfo->pOut1, quadInfo->pOut2,
                        1-quadInfo->vMaxDir, 1,   // for inner beginpoint from regular grid corner
                        quadInfo->vMaxDir, 1,   // for inner endpoint from regular grid corner
                        quadInfo->v1Dir, 1,     // for outer endpoint from patch corners[][]
                        0, 1,                   // stitchLowOut, stitchHighOut,
                        0, 1,                   // stitchLowIn, stitchHighIn,
                        quadInfo->v1Dir, quadInfo->v0Dir, quadInfo->vMaxDir,
                        1 ^ quadInfo->v1Dir, 1 ^ quadInfo->v1Dir, LAST_COL);
                }
            }

            // BOT
            if (quadInfo->stitchBottom) {
                ppCurvesOut = ppSetU0;
                if (quadInfo->vMaxSegs != 2) {
                    ppCurvesInner = ppSetUInner;
                } else {
                    ppCurvesInner = ppSetUInnerFrac;
                }

                DrawIntStitch(1, info, quadInfo, ppCurvesOut, ppCurvesInner, quadInfo->uMinSegs, quadInfo->uMaxSegs,
                    quadInfo->pOut1, quadInfo->pOut2,
                    0, 1-quadInfo->uMaxDir,   // for inner beginpoint from regular grid corner
                    0, quadInfo->uMaxDir,   // for inner endpoint from regular grid corner
                    0, quadInfo->u0Dir,     // for outer endpoint from patch corners[][]
                    quadInfo->u0Dir == quadInfo->uMaxDir ? quadInfo->stitchUBegin : quadInfo->stitchUEnd,   // stitchLowOut
                    quadInfo->u0Dir == quadInfo->uMaxDir ? quadInfo->stitchUEnd : quadInfo->stitchUBegin,   // stitchHighOut
                    quadInfo->stitchUBegin, quadInfo->stitchUEnd,   // stitchLowIn, stitchHighIn,
                    quadInfo->u0Dir, quadInfo->u1Dir, quadInfo->uMaxDir,
                    1 ^ quadInfo->u0Dir, quadInfo->u0Dir, FIRST_ROW);
            }

            // LEFT
            //ffif (quadInfo->stitchLeft && ((quadInfo->vMaxSegs > 1) || (quadInfo->uMaxSegs == 1)))
            if (quadInfo->stitchLeft)
            {
                ppCurvesOut = ppSetV0;
                ppCurvesInner = ppSetVInner;

                DrawIntStitch(0, info, quadInfo, ppCurvesOut, ppCurvesInner, quadInfo->vMinSegs, quadInfo->vMaxSegs,
                    quadInfo->pOut1, quadInfo->pOut2,
                    1-quadInfo->vMaxDir, 0,   // for inner beginpoint from regular grid corner
                    quadInfo->vMaxDir, 0,   // for inner endpoint from regular grid corner
                    quadInfo->v0Dir, 0,     // for outer endpoint from patch corners[][]
                    quadInfo->v0Dir == quadInfo->vMaxDir ? quadInfo->stitchVBegin : quadInfo->stitchVEnd,   // stitchLowOut
                    quadInfo->v0Dir == quadInfo->vMaxDir ? quadInfo->stitchVEnd : quadInfo->stitchVBegin,   // stitchHighOut
                    quadInfo->stitchVBegin, quadInfo->stitchVEnd,   // stitchLowIn, stitchHighIn,
                    quadInfo->v0Dir, quadInfo->v1Dir, quadInfo->vMaxDir,
                    quadInfo->v0Dir, quadInfo->v0Dir, FIRST_COL );
            }
        }

        return;
    }

    // HW INT Transitions must be rendered in order TOP/RIGHT/BOTTOM/LEFT
    if (quadInfo->stitchVEnd) {
        if (quadInfo->stitchTop) {
            ppCurvesOut = ppSetU1;
            ppCurvesInner = ppSetUInner;
            DrawIntStitch(1, info, quadInfo, ppCurvesOut, ppCurvesInner, quadInfo->uMinSegs, quadInfo->uMaxSegs,
                quadInfo->pOut1, quadInfo->pOut2,
                1, 1-quadInfo->uMaxDir,   // for inner beginpoint from regular grid corner
                1, quadInfo->uMaxDir,   // for inner endpoint from regular grid corner
                1, quadInfo->u1Dir,     // for outer endpoint from patch corners[][]
                quadInfo->u1Dir == quadInfo->uMaxDir ? quadInfo->stitchUBegin : quadInfo->stitchUEnd,   // stitchLowOut
                quadInfo->u1Dir == quadInfo->uMaxDir ? quadInfo->stitchUEnd : quadInfo->stitchUBegin,   // stitchHighOut
                quadInfo->stitchUBegin, quadInfo->stitchUEnd,   // stitchLowIn, stitchHighIn,
                quadInfo->u1Dir, quadInfo->u0Dir, quadInfo->uMaxDir,
                quadInfo->u1Dir, 1 ^ quadInfo->u1Dir, LAST_ROW);
        } else {
            ppCurvesOut = ppSetU0;
            ppCurvesInner = ppSetUInner;
            DrawIntStitch(1, info, quadInfo, ppCurvesOut, ppCurvesInner, quadInfo->uMinSegs, quadInfo->uMaxSegs,
                quadInfo->pOut1, quadInfo->pOut2,
                0, 1-quadInfo->uMaxDir,   // for inner beginpoint from regular grid corner
                0, quadInfo->uMaxDir,   // for inner endpoint from regular grid corner
                0, quadInfo->u0Dir,     // for outer endpoint from patch corners[][]
                quadInfo->u0Dir == quadInfo->uMaxDir ? quadInfo->stitchUBegin : quadInfo->stitchUEnd,   // stitchLowOut
                quadInfo->u0Dir == quadInfo->uMaxDir ? quadInfo->stitchUEnd : quadInfo->stitchUBegin,   // stitchHighOut
                quadInfo->stitchUBegin, quadInfo->stitchUEnd,   // stitchLowIn, stitchHighIn,
                quadInfo->u0Dir, quadInfo->u1Dir, quadInfo->uMaxDir,
                1 ^ quadInfo->u0Dir, quadInfo->u0Dir, LAST_ROW);
        }
    }

    if (quadInfo->stitchUEnd) {
        if (quadInfo->stitchRight) {
            ppCurvesOut = ppSetV1;
            ppCurvesInner = ppSetVInner;
            DrawIntStitch(0, info, quadInfo, ppCurvesOut, ppCurvesInner, quadInfo->vMinSegs, quadInfo->vMaxSegs,
                quadInfo->pOut1, quadInfo->pOut2,
                1-quadInfo->vMaxDir, 1,   // for inner beginpoint from regular grid corner
                quadInfo->vMaxDir, 1,   // for inner endpoint from regular grid corner
                quadInfo->v1Dir, 1,     // for outer endpoint from patch corners[][]
                quadInfo->v1Dir == quadInfo->vMaxDir ? quadInfo->stitchVBegin : quadInfo->stitchVEnd,   // stitchLowOut
                quadInfo->v1Dir == quadInfo->vMaxDir ? quadInfo->stitchVEnd : quadInfo->stitchVBegin,   // stitchHighOut
                quadInfo->stitchVBegin, quadInfo->stitchVEnd,   // stitchLowIn, stitchHighIn,
                quadInfo->v1Dir, quadInfo->v0Dir, quadInfo->vMaxDir,
                1 ^ quadInfo->v1Dir, 1 ^ quadInfo->v1Dir, LAST_COL);
        } else {
            ppCurvesOut = ppSetV0;
            ppCurvesInner = ppSetVInner;
            DrawIntStitch(0, info, quadInfo, ppCurvesOut, ppCurvesInner, quadInfo->vMinSegs, quadInfo->vMaxSegs,
                quadInfo->pOut1, quadInfo->pOut2,
                1-quadInfo->vMaxDir, 0,   // for inner beginpoint from regular grid corner
                quadInfo->vMaxDir, 0,   // for inner endpoint from regular grid corner
                quadInfo->v0Dir, 0,     // for outer endpoint from patch corners[][]
                quadInfo->v0Dir == quadInfo->vMaxDir ? quadInfo->stitchVBegin : quadInfo->stitchVEnd,   // stitchLowOut
                quadInfo->v0Dir == quadInfo->vMaxDir ? quadInfo->stitchVEnd : quadInfo->stitchVBegin,   // stitchHighOut
                quadInfo->stitchVBegin, quadInfo->stitchVEnd,   // stitchLowIn, stitchHighIn,
                quadInfo->v0Dir, quadInfo->v1Dir, quadInfo->vMaxDir,
                quadInfo->v0Dir, quadInfo->v0Dir, LAST_COL);
        }
    }

    if (quadInfo->stitchVBegin) {
        if (quadInfo->stitchBottom) {
            ppCurvesOut = ppSetU0;
            ppCurvesInner = ppSetUInner;
            DrawIntStitch(1, info, quadInfo, ppCurvesOut, ppCurvesInner, quadInfo->uMinSegs, quadInfo->uMaxSegs,
                quadInfo->pOut1, quadInfo->pOut2,
                0, 1-quadInfo->uMaxDir,   // for inner beginpoint from regular grid corner
                0, quadInfo->uMaxDir,   // for inner endpoint from regular grid corner
                0, quadInfo->u0Dir,     // for outer endpoint from patch corners[][]
                quadInfo->u0Dir == quadInfo->uMaxDir ? quadInfo->stitchUBegin : quadInfo->stitchUEnd,   // stitchLowOut
                quadInfo->u0Dir == quadInfo->uMaxDir ? quadInfo->stitchUEnd : quadInfo->stitchUBegin,   // stitchHighOut
                quadInfo->stitchUBegin, quadInfo->stitchUEnd,   // stitchLowIn, stitchHighIn,
                quadInfo->u0Dir, quadInfo->u1Dir, quadInfo->uMaxDir,
                1 ^ quadInfo->u0Dir, quadInfo->u0Dir, FIRST_ROW);
        } else {
            ppCurvesOut = ppSetU1;
            ppCurvesInner = ppSetUInner;
            DrawIntStitch(1, info, quadInfo, ppCurvesOut, ppCurvesInner, quadInfo->uMinSegs, quadInfo->uMaxSegs,
                quadInfo->pOut1, quadInfo->pOut2,
                1, 1-quadInfo->uMaxDir,   // for inner beginpoint from regular grid corner
                1, quadInfo->uMaxDir,   // for inner endpoint from regular grid corner
                1, quadInfo->u1Dir,     // for outer endpoint from patch corners[][]
                quadInfo->u1Dir == quadInfo->uMaxDir ? quadInfo->stitchUBegin : quadInfo->stitchUEnd,   // stitchLowOut
                quadInfo->u1Dir == quadInfo->uMaxDir ? quadInfo->stitchUEnd : quadInfo->stitchUBegin,   // stitchHighOut
                quadInfo->stitchUBegin, quadInfo->stitchUEnd,   // stitchLowIn, stitchHighIn,
                quadInfo->u1Dir, quadInfo->u0Dir, quadInfo->uMaxDir,
                quadInfo->u1Dir, 1 ^ quadInfo->u1Dir, FIRST_ROW);
        }
    }

    if (quadInfo->stitchUBegin) {
        if (quadInfo->stitchLeft) {
            ppCurvesOut = ppSetV0;
            ppCurvesInner = ppSetVInner;
            DrawIntStitch(0, info, quadInfo, ppCurvesOut, ppCurvesInner, quadInfo->vMinSegs, quadInfo->vMaxSegs,
                quadInfo->pOut1, quadInfo->pOut2,
                1-quadInfo->vMaxDir, 0,   // for inner beginpoint from regular grid corner
                quadInfo->vMaxDir, 0,   // for inner endpoint from regular grid corner
                quadInfo->v0Dir, 0,     // for outer endpoint from patch corners[][]
                quadInfo->v0Dir == quadInfo->vMaxDir ? quadInfo->stitchVBegin : quadInfo->stitchVEnd,   // stitchLowOut
                quadInfo->v0Dir == quadInfo->vMaxDir ? quadInfo->stitchVEnd : quadInfo->stitchVBegin,   // stitchHighOut
                quadInfo->stitchVBegin, quadInfo->stitchVEnd,   // stitchLowIn, stitchHighIn,
                quadInfo->v0Dir, quadInfo->v1Dir, quadInfo->vMaxDir,
                quadInfo->v0Dir, quadInfo->v0Dir, FIRST_COL);
        } else {
            ppCurvesOut = ppSetV1;
            ppCurvesInner = ppSetVInner;
            DrawIntStitch(0, info, quadInfo, ppCurvesOut, ppCurvesInner, quadInfo->vMinSegs, quadInfo->vMaxSegs,
                quadInfo->pOut1, quadInfo->pOut2,
                1-quadInfo->vMaxDir, 1,   // for inner beginpoint from regular grid corner
                quadInfo->vMaxDir, 1,   // for inner endpoint from regular grid corner
                quadInfo->v1Dir, 1,     // for outer endpoint from patch corners[][]
                quadInfo->v1Dir == quadInfo->vMaxDir ? quadInfo->stitchVBegin : quadInfo->stitchVEnd,   // stitchLowOut
                quadInfo->v1Dir == quadInfo->vMaxDir ? quadInfo->stitchVEnd : quadInfo->stitchVBegin,   // stitchHighOut
                quadInfo->stitchVBegin, quadInfo->stitchVEnd,   // stitchLowIn, stitchHighIn,
                quadInfo->v1Dir, quadInfo->v0Dir, quadInfo->vMaxDir,
                1 ^ quadInfo->v1Dir, 1 ^ quadInfo->v1Dir, FIRST_COL);
        }
    }
}

/*****************************************************************************/
// For given GuardSet ptr, and attrib, point to the curve for the attribute
static NV_INLINE NV_PATCH_CURVE_INFO *
pGuardSetCurve(NV_PATCH_INFO *info, FDCurveAttrSet *pBase, int attribIndex)
{
    nvAssert(attribIndex < info->maxAttr);
    return (*pBase)[attribIndex];
}

// draw series of sub-patches in swaths.
// General algorithm:
//  1) high level code computes for "normal" step sizes. This is to optimize
//      for smaller cases where swathing is not needed.
//  2) This routine converts matrices and curves to stepping by 'maxSwatch'
//  3) guard curves and other info is set up stepping around the patch
//      using the larger maxSwatch steps.
//  4) curves and matrices are converted to the smaller step size as needed
//      and passed to DrawIntPatchGrid()
//  5) DrawAllPatchTransitions() is used to draw all transitions
//
// swaths are drawn in col-major order
//
// swatch stepping algorithm:
//          FOR EACH BIG COL
//              horz step BB0 to BB1
//              cvt BB0 to BS0 (in place, BB0 not needed any more)
//              extract BV1 from BB1
//
//              pUL points into BS0 (will be correct when ready for EACH SMALL ROW)
//              pUR points into BV1 (will be correct when ready for EACH SMALL ROW)
//
//              FOR EACH BIG ROW
//                  extract LL from BS0
//                  cvt BS0 to SS0
//                  extract SU0 from SS0
//                  extract SV0 from SS0
//
//                  step BS0 vert (whole matrix, but on last row may just step COL to get UL point)
//                  // note: pUL now points to UL
//
//                  extract LR from BV1
//                  cvt BV1 to SV1
//                  step BV1
//                  // note: pUR now points to UR
//
//                  FOR EACH SMALL ROW
//                      extract SH0 row from SS0 (send to HW, or EvalStrip for SW emulation)
//                      if not last row then step SS0 vert
//

unsigned int DrawIntPatchSwaths(NV_PATCH_INFO *info, NV_PATCH_QUAD_INFO *quadInfo, FDMatrix **matrices)
{
    NV_PATCH_QUAD_INFO  sQuadInfo = *quadInfo;      // swatch quad info
    NV_PATCH_QUAD_INFO  *quadInfoOrig = quadInfo;
    unsigned int retVal = NV_PATCH_EVAL_OK;
    int doFrac = !!(info->flags & NV_PATCH_FLAG_TESS_FRACTIONAL);
    int onRow, onCol, index;
    int nSwatchU, nSwatchV;
    int stitch_nSwatchU, stitch_nSwatchV;
    int usingHW = info->usingHW;

    // each original guard curve is stepped 'maxSwatch' steps,
    // and intermediate big step curves are stored in a "GuardSet"
    // These get used once while drawing the regular grid,
    // and again when drawing the transition stitches.
    // Each GuardSet is an array of ptrs to info for each big step.
    // pp means ptr to ptr
    FDCurveAttrSet **ppGuardSetU0;  // pp to curves per attribute
    FDCurveAttrSet **ppGuardSetU1;  // [maxAttr][maxOrder][4]
    FDCurveAttrSet **ppGuardSetV0;  // ...
    FDCurveAttrSet **ppGuardSetV1;
    FDCurveAttrSet **ppGuardSetUInner, **ppGuardSetVInner;
    FDCurveAttrSet **ppGuardSetUInnerFrac, **ppGuardSetVInnerFrac;
    FDCurveAttrSet **ppGuardSetUBegin, **ppGuardSetUEnd;    // at begin/end of regular grid
    FDCurveAttrSet **ppGuardSetVBegin, **ppGuardSetVEnd;    // at begin/end of regular grid
    FDCurveAttrSet **ppStitchUInner = NULL, **ppStitchVInner = NULL; // inner curves for stitching
    FDCurveAttrSet **ppStitchUInnerFrac = NULL, **ppStitchVInnerFrac = NULL; // inner curves for stitching FRAC patches

    // for doing one swatch
    //ffFDCurveAttrSet lguardSetUBegin;
    //ffFDCurveAttrSet lguardSetUEnd;
    //ffFDCurveAttrSet lguardSetVBegin, lguardSetVEnd;

    // variables for stepping around the regular grid in col-major order
    //      U1-->
    //      UL      UR
    //      +-------+
    //      |       |
    //    ^ |       | ^     <--- one swatch
    //    | |       | |
    //    | |       | |
    //   V0 +-------+ V1
    //      LL      LR
    //      U0-->

    // matrix names have letters B and S to indicate big vs small steps in Vert and Horz directions
    FDMatrixAttrSet *pBB0;          // ptr to FD matrixSet at LL, Big steps Up and Right
    FDMatrixAttrSet *pBB1;          // ptr to FD matrixSet at LR, Big steps Up and Right
    FDMatrixAttrSet *pTempMatrix;   // for ptr swap
    FDMatrixAttrSet matrix0, matrix1;   // actual set of ptrs to matrix set
    FDMatrixAttrSet *pBS0;              // FD matrix at LL, Big steps Up, Small steps Right
    FDMatrixAttrSet SS0;                // ptrs to inner loop FD Matrices, small steps Up and Right

    int needBV0;
    int enablesSU0, enablesSU1, enablesSV0, enablesSV1;
    FDCurveAttrSet  BV0;        // curve from LL to UL, for UInner curve list, big steps
    FDCurveAttrSet  SV0;        // curve from LL to UL, for UInner curve list, small steps
    FDCurveAttrSet  BV1;        // curve from LR to UR, for UInner curve list, big steps
    FDCurveAttrSet  SV1;        // curve from LR to UR, for UInner curve list, small steps
    FDCurveAttrSet  *pSU0;      // ptr to SU0 or ppGuardSetUBegin[onCol]
    FDCurveAttrSet  *pSU1;      // ptr to SU1 or ppGuardSetUEnd[onCol]
    FDCurveAttrSet  *pSV0;      // ptr to SV0 or ppGuardSetVBegin[onRow]
    FDCurveAttrSet  *pSU1Next;  // ptr to next pSU1
    FDCurveAttrSet  *pSV0Next;  // ptr to next pSV0
    FDCurveAttrSet  *pSV1Next;  // ptr to next pSV1
    //ffFDCurveAttrSet  *pBV1;      // ptr to current BV1 (maybe really SV1, but only used to get start point)
    FDCurveAttrSet  *pSV1;      // ptr to current SV1 or ppGuardSetVEnd[onRow]
    //ffFDCurveAttrSet  *pTempCurveSet;

    float LL[NV_PATCH_NUMBER_OF_ATTRIBS][4];
    float LR[NV_PATCH_NUMBER_OF_ATTRIBS][4];
    float UL[NV_PATCH_NUMBER_OF_ATTRIBS][4];
    float UR[NV_PATCH_NUMBER_OF_ATTRIBS][4];        // vertex: for extracting from BS0 and BV1
    float *pLL[NV_PATCH_NUMBER_OF_ATTRIBS];
    float *pLR[NV_PATCH_NUMBER_OF_ATTRIBS];
    float *pUL[NV_PATCH_NUMBER_OF_ATTRIBS];
    float *pUR[NV_PATCH_NUMBER_OF_ATTRIBS];         // vertex: ptr to swatch corner points

    int bytesGuardCurve = EV_ROUND(PATCH_CURVE_HEADER_SIZE + (info->maxOrder * 4) * sizeof(float));   // truncated NV_PATCH_CURVE_INFO
    int bytesGuardCurveAllAttr = info->nAttr * bytesGuardCurve;                 // just the set of curve info

    EV_ALLOC_DECL();
    int nBytes;

    if (doFrac) {
        // The max for nSwatchU/V is not the whole story. The minSegs for the transitions
        // may actually have more steps in the frac case.
        // This is also complicated by the fact that for TRI FRAC, when drawing the
        // third sub-QUAD-FRAC, the U and V get transposed.
        // So, recalc here according to min/max
        int uMax = MAX(quadInfo->uMinSegs, quadInfo->uMaxSegs);

        int vMax = MAX(quadInfo->vMinSegs, quadInfo->vMaxSegs);

        // calc values including end stitch
        stitch_nSwatchU = (uMax - 1) / info->maxSwatch + 1;
        stitch_nSwatchV = (vMax - 1) / info->maxSwatch + 1;
    } else {
        stitch_nSwatchU = info->nSwatchU;
        stitch_nSwatchV = info->nSwatchV;
    }

    evalPrepareInnerCurves(info, 1, matrices);      // prepare the *Inner and *InnerFrac curves

    // use local quadInfo
    quadInfo = &sQuadInfo;
    quadInfo->needUInner = quadInfoOrig->needUInner;
    quadInfo->needVInner = quadInfoOrig->needVInner;

    // allocating full 16 attr's, 16 order, 1000x1000 steps, 16 maxSwatch, 2 Grid FDMatrix columns --> 9.4 Mbytes
    // 4 order --> 8.3 Mbytes
    // and 2 attr --> 1.0 Mbytes

    nBytes =  EV_ROUND(info->maxAttr * sizeof(NV_PATCH_CURVE_INFO *)); // for ppGuardSet's, for U and V
    nBytes += bytesGuardCurveAllAttr;
    nBytes *= (stitch_nSwatchU+1 + stitch_nSwatchV+1);
    nBytes += EV_ROUND((stitch_nSwatchU+1)*sizeof(FDCurveAttrSet *));
    nBytes += EV_ROUND((stitch_nSwatchV+1)*sizeof(FDCurveAttrSet *));
    nBytes *= (doFrac ? 4 : 3);
    nBytes += 6 * bytesGuardCurveAllAttr;                                                           // guards for current swatch
    nBytes += info->nAttr * sizeof(FDMatrix) * (3);                                                 // matrix0,1 and SS0
    nBytes += info->nAttr * bytesGuardCurve * (4);                                                  // BV0, BV1, SV0, SV1

    EV_ALLOC_INIT_WITH_CACHE(info->context, nBytes, drawIntPatchSwathsEnd, info->pCache[EV_CACHE_SWATHING]);

    nBytes = EV_ROUND((stitch_nSwatchU+1) * sizeof(FDCurveAttrSet *));
    EV_ALLOC(ppGuardSetU0,     info->context, nBytes );
    EV_ALLOC(ppGuardSetU1,     info->context, nBytes);
    EV_ALLOC(ppGuardSetUInner, info->context, nBytes);
    if (doFrac) {
        EV_ALLOC(ppGuardSetUInnerFrac, info->context, nBytes);
    }

    nBytes = EV_ROUND((stitch_nSwatchV+1) * sizeof(FDCurveAttrSet *));
    EV_ALLOC(ppGuardSetV0,     info->context, nBytes);
    EV_ALLOC(ppGuardSetV1,     info->context, nBytes);
    EV_ALLOC(ppGuardSetVInner, info->context, nBytes);
    if (doFrac) {
        EV_ALLOC(ppGuardSetVInnerFrac, info->context, nBytes);
    }

    for (index = 0; index < info->maxAttr; index++) {
        if (!(info->evalEnables & (1 << index))) {
            continue;
        }
        EV_ALLOC(quadInfo->pU0[index], info->context, bytesGuardCurve);
        EV_ALLOC(quadInfo->pU1[index], info->context, bytesGuardCurve);
        EV_ALLOC(quadInfo->pV0[index], info->context, bytesGuardCurve);
        EV_ALLOC(quadInfo->pV1[index], info->context, bytesGuardCurve);
        EV_ALLOC(quadInfo->pUInner[index], info->context, bytesGuardCurve);
        EV_ALLOC(quadInfo->pVInner[index], info->context, bytesGuardCurve);

        EV_ALLOC(matrix0[index], info->context, sizeof(FDMatrix));
        EV_ALLOC(matrix1[index], info->context, sizeof(FDMatrix));
        EV_ALLOC(SS0[index], info->context, sizeof(FDMatrix));

        EV_ALLOC(BV0[index], info->context, bytesGuardCurve);
        EV_ALLOC(BV1[index], info->context, bytesGuardCurve);
        EV_ALLOC(SV0[index], info->context, bytesGuardCurve);
        EV_ALLOC(SV1[index], info->context, bytesGuardCurve);
    }
    //ffquadInfo->pSwatchVBegin = &lguardSetVBegin;
    //ffquadInfo->pSwatchVEnd = &lguardSetVEnd;

    // set up sets of guard curves for each big step
    // init pointers to guard sub-curves for each big step
    nBytes = EV_ROUND(info->maxAttr * sizeof(NV_PATCH_CURVE_INFO *));
    for (onCol = 0;  onCol <= stitch_nSwatchU;  onCol++) {
        EV_ALLOC(ppGuardSetU0[onCol], info->context, nBytes);
        EV_ALLOC(ppGuardSetU1[onCol], info->context, nBytes);
        EV_ALLOC(ppGuardSetUInner[onCol], info->context, nBytes);
        if (doFrac) {
            EV_ALLOC(ppGuardSetUInnerFrac[onCol], info->context, nBytes);
        }

        for (index = 0; index < info->maxAttr; index++) {
            if (!(info->evalEnables & (1 << index))) {
                continue;
            }
            EV_ALLOC((*ppGuardSetU0[onCol])[index], info->context, bytesGuardCurve);
            EV_ALLOC((*ppGuardSetU1[onCol])[index], info->context, bytesGuardCurve);
            EV_ALLOC((*ppGuardSetUInner[onCol])[index], info->context, bytesGuardCurve);
            if (doFrac) {
                EV_ALLOC((*ppGuardSetUInnerFrac[onCol])[index], info->context, bytesGuardCurve);
                if (!onCol) {
                    // XXX maybe just point to this
                    CopyCurve(info, (*ppGuardSetUInnerFrac[0])[index], (*info->ppGuardSetUInnerFrac[0])[index]);
                }
            }
        }
    }

    // again for V
    nBytes = EV_ROUND(info->maxAttr * sizeof(NV_PATCH_CURVE_INFO *));
    for (onRow = 0;  onRow <= stitch_nSwatchV;  onRow++) {
        EV_ALLOC(ppGuardSetV0[onRow], info->context, nBytes);
        EV_ALLOC(ppGuardSetV1[onRow], info->context, nBytes);
        EV_ALLOC(ppGuardSetVInner[onRow], info->context, nBytes);
        if (doFrac) {
            EV_ALLOC(ppGuardSetVInnerFrac[onRow], info->context, nBytes);
        }

        for (index = 0; index < info->maxAttr; index++) {
            if (!(info->evalEnables & (1 << index))) {
                continue;
            }
            EV_ALLOC((*ppGuardSetV0[onRow])[index], info->context, bytesGuardCurve);
            EV_ALLOC((*ppGuardSetV1[onRow])[index], info->context, bytesGuardCurve);
            EV_ALLOC((*ppGuardSetVInner[onRow])[index], info->context, bytesGuardCurve);
            if (doFrac) {
                EV_ALLOC((*ppGuardSetVInnerFrac[onRow])[index], info->context, bytesGuardCurve);
                if (!onRow) {
                    // XXX maybe just point to this
                    CopyCurve(info, (*ppGuardSetVInnerFrac[0])[index], (*info->ppGuardSetVInnerFrac[0])[index]);
                }
            }
        }
    }
    EV_ALLOC_FULL(info->context);

    /*****************************************************************************/
    // This code is analogous to code in DrawIntPatch() to calc quadInfo->guard[i]->pGuardXXX
    // BEGIN SIMILAR CODE
    if (quadInfo->vMaxDir == 1) {
        if (quadInfo->stitchTop) {
            ppGuardSetUBegin = ppGuardSetU0;
            if (quadInfo->vMaxSegs > 1) {
                ppGuardSetUEnd = ppGuardSetUInner;
                ppStitchUInner = ppGuardSetUInner;
            } else {
                ppGuardSetUEnd = ppGuardSetU0;
                ppStitchUInner = ppGuardSetU0;
            }
        } else if (quadInfo->stitchBottom) {
            if (quadInfo->vMaxSegs > 1) {
                ppGuardSetUBegin = ppGuardSetUInner;
                ppStitchUInner = ppGuardSetUInner;
            } else {
                ppGuardSetUBegin = ppGuardSetU1;
                ppStitchUInner = ppGuardSetU1;
            }
            ppGuardSetUEnd = ppGuardSetU1;
        } else {
            ppGuardSetUBegin = ppGuardSetU0;
            ppStitchUInner = NULL;
            ppGuardSetUEnd = ppGuardSetU1;
        }
    } else {
        if (quadInfo->stitchTop) {
            if (quadInfo->vMaxSegs > 1) {
                ppGuardSetUBegin = ppGuardSetUInner;
                ppStitchUInner = ppGuardSetUInner;
            } else {
                ppGuardSetUBegin = ppGuardSetU0;
                ppStitchUInner = ppGuardSetU0;
            }
            ppGuardSetUEnd = ppGuardSetU0;
        } else if (quadInfo->stitchBottom) {
            ppGuardSetUBegin = ppGuardSetU1;
            if (quadInfo->vMaxSegs > 1) {
                ppGuardSetUEnd = ppGuardSetUInner;
                ppStitchUInner = ppGuardSetUInner;
            } else {
                ppGuardSetUEnd = ppGuardSetU1;
                ppStitchUInner = ppGuardSetU1;
            }
        } else {
            ppGuardSetUBegin = ppGuardSetU1;
            ppStitchUInner = NULL;
            ppGuardSetUEnd = ppGuardSetU0;
        }
    }

    if (quadInfo->uMaxDir == 1) {
        if (quadInfo->stitchRight) {
            ppGuardSetVBegin = ppGuardSetV0;
            if (quadInfo->uMaxSegs > 1) {
                ppGuardSetVEnd = ppGuardSetVInner;
                ppStitchVInner = ppGuardSetVInner;
            } else {
                ppGuardSetVEnd = ppGuardSetV0;
                ppStitchVInner = ppGuardSetV0;
            }
        } else if (quadInfo->stitchLeft) {
            if (quadInfo->uMaxSegs > 1) {
                ppGuardSetVBegin = ppGuardSetVInner;
                ppStitchVInner = ppGuardSetVInner;
            } else {
                ppGuardSetVBegin = ppGuardSetV1;
                ppStitchVInner = ppGuardSetV1;
            }
            ppGuardSetVEnd = ppGuardSetV1;
        } else {
            ppGuardSetVBegin = ppGuardSetV0;
            ppStitchVInner = NULL;
            ppGuardSetVEnd = ppGuardSetV1;
        }
    } else {
        if (quadInfo->stitchRight) {
            if (quadInfo->uMaxSegs > 1) {
                ppGuardSetVBegin = ppGuardSetVInner;
                ppStitchVInner = ppGuardSetVInner;
            } else {
                ppGuardSetVBegin = ppGuardSetV0;
                ppStitchVInner = ppGuardSetV0;
            }
            ppGuardSetVEnd = ppGuardSetV0;
        } else if (quadInfo->stitchLeft) {
            ppGuardSetVBegin = ppGuardSetV1;
            if (quadInfo->uMaxSegs > 1) {
                ppGuardSetVEnd = ppGuardSetVInner;
                ppStitchVInner = ppGuardSetVInner;
            } else {
                ppGuardSetVEnd = ppGuardSetV1;
                ppStitchVInner = ppGuardSetV1;
            }
        } else {
            ppGuardSetVBegin = ppGuardSetV1;
            ppStitchVInner = NULL;
            ppGuardSetVEnd = ppGuardSetV0;
        }
    }
    if (doFrac) {
        ppStitchUInnerFrac = ppGuardSetUEnd = ppGuardSetUInnerFrac;
        ppStitchVInnerFrac = ppGuardSetVEnd = ppGuardSetVInnerFrac;
    }
    // END SIMILAR CODE

    /*****************************************************************************/
    // calc initial big step U guard curves
    // For now, use BV0, BV1, SV0, SV1  for BU0, BU1, BUInner, BUInnerFrac
    // XXX TODO: one of the outside curves may not require as many steps
    for (index = 0; index < info->maxAttr; index++) {
        if (!(info->evalEnables & (1 << index))) {
            continue;
        }
        CopyCurve(info, BV0[index], quadInfoOrig->pU0[index]);
        RetessCurveInOut(info, 0, quadInfoOrig->pU0[index], pGuardSetCurve(info, ppGuardSetU0[0], index));
        CopyCurve(info, BV1[index], quadInfoOrig->pU1[index]);
        RetessCurveInOut(info, 0, quadInfoOrig->pU1[index], pGuardSetCurve(info, ppGuardSetU1[0], index));

        if (quadInfo->needUInner) {
            CopyCurve(info, SV0[index], quadInfoOrig->pUInner[index]);
            RetessCurveInOut(info, 0, quadInfoOrig->pUInner[index], pGuardSetCurve(info, ppGuardSetUInner[0], index));
        }
        //ffif (doFrac  &&  EV_GUARD_ATTR(index)) { // }
        if (doFrac) {
            CopyCurve(info, SV1[index], pGuardSetCurve(info, ppGuardSetUInnerFrac[0], index));
            RetessCurveInOut(info, 0, SV1[index], pGuardSetCurve(info, ppGuardSetUInnerFrac[0], index));
        }
    }

    // make big steps and cvt to small for later
    for (onCol = 1;  onCol <= stitch_nSwatchU;  onCol++) {
        // copy all prev attrs
        __NV_MEMCPY(pGuardSetCurve(info, ppGuardSetU0[onCol], info->firstAttr),
                    pGuardSetCurve(info, ppGuardSetU0[onCol-1], info->firstAttr), 3*bytesGuardCurveAllAttr);
        for (index = 0;  index < info->maxAttr;  index++) {
            if (!(info->evalEnables & (1 << index))) {
                continue;
            }
            OffsetCurve(info, BV0[index], 1);
            RetessCurveInOut(info, 0, BV0[index], pGuardSetCurve(info, ppGuardSetU0[onCol], index));
            OffsetCurve(info, BV1[index], 1);
            RetessCurveInOut(info, 0, BV1[index], pGuardSetCurve(info, ppGuardSetU1[onCol], index));
            //ffif (quadInfo->needUInner && quadInfo->stitchVEnd && (EV_GUARD_ATTR(index) || !usingHW)) { // }
            if (quadInfo->needUInner) {
                OffsetCurve(info, SV0[index], 1);
                RetessCurveInOut(info, 0, SV0[index], pGuardSetCurve(info, ppGuardSetUInner[onCol], index));
            }
            //ffif (doFrac  &&  EV_GUARD_ATTR(index)) { // }
            if (doFrac) {
                OffsetCurve(info, SV1[index], 1);
                RetessCurveInOut(info, 0, SV1[index], pGuardSetCurve(info, ppGuardSetUInnerFrac[onCol], index));
            }
        }
    }

#if defined(ENABLE_DEBUG_SWATH)
    if (!usingHW && nvDebugLevel >= 4 && (evalTrace & 4)) {
        // red lines from "outside" to swatch boundaries for U0
        // grn lines from "outside" to swatch boundaries for U1
        // blue lines from center to swatch boundaries for UInner
        glDisable(GL_TEXTURE_2D);
        glBegin(GL_LINES);
        for (onCol = 0;  onCol <= stitch_nSwatchU;  onCol++) {
            if (info->evalEnables & (1 << 3)) {
                glColor3fv(pGuardSetCurve(info, ppGuardSetU0[onCol], 3)->coeffs[0]);
            } else {
                glColor3f(1, 0, 0);
            }
            glVertex3f(.5, -1, 0); glVertex3fv(pGuardSetCurve(info, ppGuardSetU0[onCol], 0)->coeffs[0]);

            if (info->evalEnables & (1 << 3)) {
                glColor3fv(pGuardSetCurve(info, ppGuardSetU1[onCol], 3)->coeffs[0]);
            } else {
                glColor3f(0, 1, 0);
            }
            glVertex3f(.5, 2, 0); glVertex3fv(pGuardSetCurve(info, ppGuardSetU1[onCol], 0)->coeffs[0]);

            if (quadInfo->needUInner) {
                if (info->evalEnables & (1 << 3)) {
                    glColor3fv(pGuardSetCurve(info, ppGuardSetUInner[onCol], 3)->coeffs[0]);
                } else {
                    glColor3f(0, 0, 1);
                }
                glVertex3f(.5, .5, 0); glVertex3fv(pGuardSetCurve(info, ppGuardSetUInner[onCol], 0)->coeffs[0]);
            }
        }
        glEnd();
        if (!(info->evalEnables & (1 << 3))) {
            glColor3f(.5, .5, .5);
        }
        if (info->evalEnables & (1 << NV_PATCH_ATTRIB_TEXCOORD0)) {
            glEnable(GL_TEXTURE_2D);
        }
    }
#endif

    /*****************************************************************************/
    /*****************************************************************************/
    // calc initial big step V guard curves
    // For now, use BV0, BV1, SV0, SV1  for BV0, BV1, BVInner, BVInnerFrac
    // XXX TODO: one of the outside curves may not require as many steps
    for (index = 0; index < info->maxAttr; index++) {
        if (!(info->evalEnables & (1 << index))) {
            continue;
        }
        CopyCurve(info, BV0[index], quadInfoOrig->pV0[index]);
        RetessCurveInOut(info, 0, quadInfoOrig->pV0[index], pGuardSetCurve(info, ppGuardSetV0[0], index));
        CopyCurve(info, BV1[index], quadInfoOrig->pV1[index]);
        RetessCurveInOut(info, 0, quadInfoOrig->pV1[index], pGuardSetCurve(info, ppGuardSetV1[0], index));

        //ffif (quadInfo->needVInner && quadInfo->stitchUEnd) {
        if (quadInfo->needVInner) {
            CopyCurve(info, SV0[index], quadInfoOrig->pVInner[index]);
            RetessCurveInOut(info, 0, quadInfoOrig->pVInner[index], pGuardSetCurve(info, ppGuardSetVInner[0], index));
        }
        if (doFrac) {
            CopyCurve(info, SV1[index], pGuardSetCurve(info, ppGuardSetVInnerFrac[0], index));
            RetessCurveInOut(info, 0, SV1[index], pGuardSetCurve(info, ppGuardSetVInnerFrac[0], index));
        }
    }

    // make big steps and cvt to small for later
    for (onRow = 1;  onRow <= stitch_nSwatchV;  onRow++) {
        // copy all prev attrs
        __NV_MEMCPY(pGuardSetCurve(info, ppGuardSetV0[onRow], info->firstAttr),
                    pGuardSetCurve(info, ppGuardSetV0[onRow-1], info->firstAttr), 3*bytesGuardCurveAllAttr);
        for (index = 0;  index < info->maxAttr;  index++) {
            if (!(info->evalEnables & (1 << index))) {
                continue;
            }
            OffsetCurve(info, BV0[index], 1);
            RetessCurveInOut(info, 0, BV0[index], pGuardSetCurve(info, ppGuardSetV0[onRow], index));
            OffsetCurve(info, BV1[index], 1);
            RetessCurveInOut(info, 0, BV1[index], pGuardSetCurve(info, ppGuardSetV1[onRow], index));
            //ffif (quadInfo->needVInner && quadInfo->stitchUEnd) {
            if (quadInfo->needVInner) {
                OffsetCurve(info, SV0[index], 1);
                RetessCurveInOut(info, 0, SV0[index], pGuardSetCurve(info, ppGuardSetVInner[onRow], index));
            }
            if (doFrac) {
                OffsetCurve(info, SV1[index], 1);
                RetessCurveInOut(info, 0, SV1[index], pGuardSetCurve(info, ppGuardSetVInnerFrac[onRow], index));
            }
        }
    }

#if defined(ENABLE_DEBUG_SWATH)
    if (!usingHW && nvDebugLevel >= 4 && (evalTrace & 8)) {
        // red lines from "outside" to swatch boundaries for V0
        // grn lines from "outside" to swatch boundaries for V1
        // violet lines from center to swatch boundaries for VInner
        glDisable(GL_TEXTURE_2D);
        glBegin(GL_LINES);
        for (onRow = 0;  onRow < stitch_nSwatchV;  onRow++) {
            if (info->evalEnables & (1 << 3)) {
                glColor3fv(pGuardSetCurve(info, ppGuardSetV0[onRow], 3)->coeffs[0]);
            } else {
                glColor3f(1, 0, 0);
            }
            glVertex3f(-1, .5, 0); glVertex3fv(pGuardSetCurve(info, ppGuardSetV0[onRow], 0)->coeffs[0]);

            if (info->evalEnables & (1 << 3)) {
                glColor3fv(pGuardSetCurve(info, ppGuardSetV1[onRow], 3)->coeffs[0]);
            } else {
                glColor3f(0, 1, 0);
            }
            glVertex3f(2, .5, 0); glVertex3fv(pGuardSetCurve(info, ppGuardSetV1[onRow], 0)->coeffs[0]);

            if (quadInfo->needVInner) {
                if (info->evalEnables & (1 << 3)) {
                    glColor3fv(pGuardSetCurve(info, ppGuardSetVInner[onRow], 3)->coeffs[0]);
                } else {
                    glColor3f(1, 0, 1);
                }
                glVertex3f(.5, .5, 0); glVertex3fv(pGuardSetCurve(info, ppGuardSetVInner[onRow], 0)->coeffs[0]);
            }
        }
        glEnd();
        if (!(info->evalEnables & (1 << 3))) {
            glColor3f(.5, .5, .5);
        }
        if (info->evalEnables & (1 << NV_PATCH_ATTRIB_TEXCOORD0)) {
            glEnable(GL_TEXTURE_2D);
        }
    }
#endif

    /*****************************************************************************/
    // work on regular grid

    // calc swaths WITHOUT including ending stitch
    index = 1 + doFrac; // index is a temp // adjust to not draw FRAC RIGHT and TOP stitch
    nSwatchU = (quadInfo->uMaxSegs - index - quadInfo->stitchUEnd) / info->maxSwatch + 1;
    nSwatchV = (quadInfo->vMaxSegs - index - quadInfo->stitchVEnd) / info->maxSwatch + 1;
    if (!doFrac) {
        // note: for FRAC cases, the quadInfo->uMaxSegs used at this point can be
        // quite different than the full MAX calculated in evalCommonSetup()
        // Therefore, the following is only generally true for INT cases.
        nvAssert((stitch_nSwatchU - nSwatchU) <= 1);
    }
    nvAssert((*ppGuardSetU0[0])[0]->order == (*ppGuardSetU1[0])[0]->order);
    nvAssert((*ppGuardSetV0[0])[0]->order == (*ppGuardSetV1[0])[0]->order);
    // note: ppStitchUInner and ppStitchVInner may not be formed yet

    // convert small to big steps for starting matrix BB0
    pBB0 = &matrix0;
    pBB1 = &matrix1;

    for (index = 0; index < info->maxAttr; index++) {
        if (!(info->evalEnables & (1 << index))) {
            continue;
        }
        CopyMatrix(info, (*pBB0)[index], matrices[index]);
    }

    // tag:sss swathing loop
    for (onCol = 0;  onCol < nSwatchU;  onCol++) {          // ********** for each col in the patch
        int rem, rightSV1;

        CopyMatrixSet(info, info->evalEnables, pBB1, pBB0);     // horz step BB0 to BB1
        OffsetFDMatrixSet(info, info->evalEnables, pBB1, 1, 0); // ...

        // cvt BB0 to BS0 (in place)
        pBS0 = pBB0;
        RetessMatrixSetU(info, 0, info->evalEnables, pBS0);

        // if no left stitch, then BV0 may be extracted from BS0,
        // otherwise must create and step BV0 and SV0
        needBV0 = !onCol && quadInfoOrig->stitchUBegin;
        if (needBV0) {
            CopyMatrixSet(info, info->evalEnables, (FDMatrixAttrSet *)info->ppMatrixSetSS0, pBS0);
            // XXX: steps of '1'-and-never-more can be done with short-cut
            OffsetFDMatrixSet(info, info->evalEnables, (FDMatrixAttrSet *)info->ppMatrixSetSS0, 1, 0);
            ExtractVCurveSet(info, info->evalEnables, &BV0, (FDMatrixAttrSet *)info->ppMatrixSetSS0);
        }

        if (onCol != (nSwatchU-1)) {
            rightSV1 = 0;
            ExtractVCurveSet(info, info->evalEnables, &BV1, pBB1);  // extract BV1 from BB1
        } else {
            rightSV1 = 1;
        }

        if (info->evalEnables & EV_GUARD_BIT_VERTEX) {
            pUL[ATTR_V] = (*pBS0)[ATTR_V]->data[0][0];
        }
        if (info->evalEnables & EV_GUARD_BIT_NORMAL) {
            pUL[ATTR_N] = (*pBS0)[ATTR_N]->data[0][0];
        }

        // tag:roww
        for (onRow = 0;  onRow < nSwatchV;  onRow++) {      // ********** for each row in the col
            //ffint needUL = 0;
            int needLL = 0;

            info->swatchFlags = NV_PATCH_SWATCH;
            info->setGridCorner = 0;
            enablesSU0 = enablesSU1 = enablesSV0 = enablesSV1 = info->evalEnables;

// ... col
            if (!onCol) {
                info->swatchFlags |= NV_PATCH_SWATCH_FIRST_COL;
                quadInfo->stitchUBegin = quadInfoOrig->stitchUBegin;
                if (!onRow) {
                    info->setGridCorner |= NV_PATCH_SET_GRID_CORNER00;
                }
                pSV0 = ppGuardSetVBegin[onRow];
                pSV0Next = ppGuardSetVBegin[onRow+1];

            } else {
                quadInfo->stitchUBegin = 0;
                pSV0 = &SV0;
                pSV0Next = NULL;
            }

            if (onCol == (nSwatchU-1)) {
                info->swatchFlags |= NV_PATCH_SWATCH_LAST_COL;
                quadInfo->stitchUEnd = quadInfoOrig->stitchUEnd;
                if (!onRow) {
                    info->setGridCorner |= NV_PATCH_SET_GRID_CORNER01;
                }
                pSV1 = ppGuardSetVEnd[onRow];
                pSV1Next = ppGuardSetVEnd[onRow+1];

            } else {
                quadInfo->stitchUEnd = 0;
                pSV1 = &SV1;
                pSV1Next = NULL;
            }

            for (index = 0; index < info->maxAttr; index++) {
                if (!(info->evalEnables & (1 << index))) {
                    continue;
                }
                //ffif (!EV_GUARD_ATTR(index)  &&  !doFrac) {
                    //ffcontinue;
                //ff}
                //ff(*quadInfo->pSwatchVEnd)[index] = (*pSV1)[index];
            }
// ... row
            if (!onRow) {
                info->swatchFlags |= NV_PATCH_SWATCH_FIRST_ROW;
                quadInfo->stitchVBegin = quadInfoOrig->stitchVBegin;
                pSU0 = ppGuardSetUBegin[onCol];

            } else {
                quadInfo->stitchVBegin = 0;
                pSU0 = NULL;
            }

            if (onRow == (nSwatchV-1)) {
                info->swatchFlags |= NV_PATCH_SWATCH_LAST_ROW;
                quadInfo->stitchVEnd = quadInfoOrig->stitchVEnd;
                quadInfo->pSwatchUEnd = pSU1 = ppGuardSetUEnd[onCol];
                pSU1Next = ppGuardSetUEnd[onCol+1];

                if (!onCol) {
                    info->setGridCorner |= NV_PATCH_SET_GRID_CORNER10;
                }
                if (onCol==(nSwatchU-1)) {
                    info->setGridCorner |= NV_PATCH_SET_GRID_CORNER11;
                }
            } else {
                quadInfo->stitchVEnd = 0;
                //ffquadInfo->pSwatchUEnd = &lguardSetUEnd;
                pSU1 = NULL;
                pSU1Next = NULL;
            }
// ... end row
            quadInfo->pSwatchUBegin = pSU0;
            quadInfo->pSwatchUEnd = pSU1;
            quadInfo->pSwatchVBegin = pSV0;
            quadInfo->pSwatchVEnd = pSV1;

            // ***** compute segs for this swatch, including any ending stitches
            quadInfo->uMaxSegs = info->maxSwatch;
            quadInfo->vMaxSegs = info->maxSwatch;
            rem = quadInfoOrig->uMaxSegs - doFrac - quadInfo->stitchUEnd - (onCol + 1) * info->maxSwatch;
            if (rem < 0) {
                quadInfo->uMaxSegs += rem;
            }
            rem = quadInfoOrig->vMaxSegs - doFrac - quadInfo->stitchVEnd - (onRow + 1) * info->maxSwatch;
            if (rem < 0) {
                quadInfo->vMaxSegs += rem;
            }
            quadInfo->uMaxSegs += quadInfo->stitchUEnd;
            quadInfo->vMaxSegs += quadInfo->stitchVEnd;

            // ***** prepare matrices and curves for this swatch *****
            CopyMatrixSet(info, info->evalEnables, &SS0, pBS0);
            RetessMatrixSetV(info, 0, info->evalEnables, &SS0);
            //ffEV_DRAW( evalDrawMatrix(info, SS0[0], 0, 0) );

            BEGIN_USING_TEMP_MATRIX(info->tempMatrix);
            if (rightSV1 && !onRow /*&& quadInfo->stitchUEnd*/) {
                // prepare first BV1
                for (index = 0; index < info->maxAttr; index++) {
                    if (info->evalEnables & (1 << index)) {
                        CopyMatrix(info, &info->tempMatrix, (*pBS0)[index]);
                        OffsetFDMatrix(info, &info->tempMatrix, quadInfo->uMaxSegs, 0);
                        ExtractUCurve(info, BV1[index], &info->tempMatrix);
                    }
                }
            }
            END_USING_TEMP_MATRIX(info->tempMatrix);
            OffsetFDMatrixSet(info, info->evalEnables, pBS0, 0, 1); // up to next row

            if (!rightSV1) {
                RetessCurveSetInOut(info, 0, info->evalEnables, &BV1, pSV1);
                OffsetCurveSet(info, info->evalEnables & EV_GUARD_BITS, &BV1, 1);
            }

            // ***** prepare guard information
            // prepare U0 info
            BEGIN_USING_TEMP_MATRIX(info->tempMatrix);
            for (index = 0; index < info->maxAttr; index++) {
                if (!(info->evalEnables & (1 << index))) {
                    continue;
                }
                if (!onRow && quadInfo->stitchVBegin) {
                    CopyMatrix(info, &info->tempMatrix, SS0[index]);
                    OffsetFDMatrix(info, &info->tempMatrix, 0, 1);
                    ExtractUCurve(info, (*pSU0)[index], &info->tempMatrix);
                }
                if ((info->swatchFlags & NV_PATCH_SWATCH_LAST_ROW) && quadInfo->stitchVEnd) {
                    //ffCopyMatrix(info, &info->tempMatrix, SS0[index]);
                    //ffOffsetFDMatrix(info, &info->tempMatrix, 0, quadInfo->vMaxSegs - 1);
                    //ffExtractUCurve(info, (*pSU1)[index], &info->tempMatrix);
                }
                if (!onCol && quadInfo->stitchUBegin) {
                    CopyMatrix(info, &info->tempMatrix, SS0[index]);
                    OffsetFDMatrix(info, &info->tempMatrix, 1, 0);
                    ExtractVCurve(info, (*pSV0)[index], &info->tempMatrix);
                }
                if ((info->swatchFlags & NV_PATCH_SWATCH_LAST_COL) && !onRow) {
                    CopyMatrix(info, &info->tempMatrix, SS0[index]);
                    OffsetFDMatrix(info, &info->tempMatrix, quadInfo->uMaxSegs - quadInfo->stitchUEnd, 0);
                    ExtractVCurve(info, (*pSV1)[index], &info->tempMatrix);
                }
            }
            END_USING_TEMP_MATRIX(info->tempMatrix);

            // prepare V0 info
            if (needBV0) {
                int eset = info->evalEnables;// & ~EV_GUARD_BITS;

                // BV0-->SV0 will be saved away for VInner transition curve set
                RetessCurveSetInOut(info, 0, eset, &BV0, pSV0);
                OffsetCurveSet(info, eset, &BV0, 1);        // to next swatch row

            } else if (onCol) {
                // other columns extract SV0 from SS0
                ExtractVCurveSet(info, info->evalEnables & EV_GUARD_BITS, pSV0, &SS0);
            }

            // tag:ccorn prepare corner points
            for (index = 0; index < info->maxAttr; index++) {
                if (!(info->evalEnables & (1 << index))) {
                    continue;
                }

                if (quadInfo->stitchUBegin) {
                    nvAssert(needBV0);
                    if (info->swatchFlags & NV_PATCH_SWATCH_LAST_ROW) {
                        // on the last row, always get from UEnd curve
                        AddPoint3(UL[index], (*pSU1)[index]->coeffs[0], (*pSU1)[index]->coeffs[1]);
                        pUL[index] = UL[index];
                    } else {
                        pUL[index] = (BV0)[index]->coeffs[0];
                    }
                    if (!(info->swatchFlags & NV_PATCH_SWATCH_FIRST_ROW)) {
                        pLL[index] = (*pSV0)[index]->coeffs[0];
                    } else {
                        // bot row
                        AddPoint3(LL[index], (*pSU0)[index]->coeffs[0], (*pSU0)[index]->coeffs[1]);
                        pLL[index] = LL[index];
                    }
                } else {
                    if (quadInfo->stitchVBegin) {
                        AddPoint3(LL[index], (*pSV0)[index]->coeffs[0], (*pSV0)[index]->coeffs[1]);
                        pLL[index] = LL[index];
                    } else {
                        pLL[index] = (*pSV0)[index]->coeffs[0];
                    }
                    if (info->swatchFlags & NV_PATCH_SWATCH_FIRST_COL) {
                        if (info->swatchFlags & NV_PATCH_SWATCH_LAST_ROW) {
                            pUL[index] = (*pSU1)[index]->coeffs[0];
                        } else {
                            pUL[index] = (*pSV0Next)[index]->coeffs[0];
                        }
                    } else {
                        if (info->swatchFlags & NV_PATCH_SWATCH_LAST_ROW) {
                            pUL[index] = (*pSU1)[index]->coeffs[0];
                        } else {
                            pUL[index] = (*pBS0)[index]->data[0][0];
                        }
                    }
                }

                if (quadInfo->stitchVBegin) {
                    AddPoint3(LR[index], (*pSV1)[index]->coeffs[0], (*pSV1)[index]->coeffs[1]);
                    pLR[index] = LR[index];
                } else {
                    pLR[index] = (*pSV1)[index]->coeffs[0];
                }

                if (info->swatchFlags & NV_PATCH_SWATCH_LAST_ROW) {
                    if (info->swatchFlags & NV_PATCH_SWATCH_LAST_COL) {
                        // step cur U1 to get there
                        FillIntCornerUR(info, quadInfo, quadInfoOrig, index, UR[index]);
                        pUR[index] = UR[index];
                        //ffCopyCurve(info, &info->tempCurve, (*pSU1)[index]);
                        //ffOffsetCurve(info, &info->tempCurve, quadInfo->uMaxSegs - quadInfo->stitchVEnd);
                        //ffCopyPoint(UR, info->tempCurve.coeffs[0]);
                    } else {
                        pUR[index] = (*pSU1Next)[index]->coeffs[0];
                    }
                } else {
                    if (info->swatchFlags & NV_PATCH_SWATCH_LAST_COL) {
                        pUR[index] = (*pSV1Next)[index]->coeffs[0];
                    } else {
                        pUR[index] = (BV1)[index]->coeffs[0];
                    }
                }
                //ffCopyCurve(info, &info->tempCurve, (*pSV1)[index]);
                //ffOffsetCurve(info, &info->tempCurve, quadInfo->vMaxSegs - quadInfo->stitchVEnd);
                //ffCopyPoint(UR, info->tempCurve.coeffs[0]);
                //ffpUR[index] = UR;
                if (quadInfo->stitchVEnd) {
                } else {
                }

                info->pSwatchCorner[index][0][0] = pLL[index];
                info->pSwatchCorner[index][0][1] = pLR[index];
                info->pSwatchCorner[index][1][0] = pUL[index];
                info->pSwatchCorner[index][1][1] = pUR[index];

                if (info->setGridCorner & NV_PATCH_SET_GRID_CORNER00) {
                    CopyPoint(info->gridCorner[index][1-quadInfo->vMaxDir][ 1-quadInfo->uMaxDir], pLL[index]);
                }
                if (info->setGridCorner & NV_PATCH_SET_GRID_CORNER01) {
                    CopyPoint(info->gridCorner[index][1-quadInfo->vMaxDir][   quadInfo->uMaxDir], pLR[index]);
                }

                if (info->setGridCorner & NV_PATCH_SET_GRID_CORNER10) {
                    CopyPoint(info->gridCorner[index][  quadInfo->vMaxDir][ 1-quadInfo->uMaxDir], pUL[index]);
                }
                if (info->setGridCorner & NV_PATCH_SET_GRID_CORNER11) {
                    CopyPoint(info->gridCorner[index][  quadInfo->vMaxDir][   quadInfo->uMaxDir], pUR[index]);
                }
            }

            // Copy V guard curves
            // Note: must be done after FillIntCorner*() because the start values for
            // the pSwatch curves may be tweaked to match between the regular grid and stitches.
            for (index = 0; index < info->maxAttr; index++) {
                if (!EV_GUARD_ATTR(index)  &&  !doFrac) {
                    continue;
                }
                if (!(info->evalEnables & (1 << index))) {
                    continue;
                }
                CopyCurve(info, info->tempVEnd[index], (*quadInfo->pSwatchVEnd)[index]);
                if (!EV_GUARD_ATTR(index)) {
                    continue;
                }
                CopyCurve(info, info->tempVBegin[index], (*quadInfo->pSwatchVBegin)[index]);
            }

            // call to draw regular grid for each small row
            {
                //cache a ptr to the global patch data inside the subpatch structure.
                if (info->evalEnables & (1 << ATTR_N)) {
                    info->swatchFlags |= NV_PATCH_HAS_NORMAL;
                };

                if (usingHW) {
                    if ((info->swatchFlags & NV_PATCH_SWATCH_FIRST_ROW) && (info->swatchFlags & NV_PATCH_SWATCH_FIRST_COL)) {
                        ComputeKelvinHOSControlWords(info, quadInfoOrig, info->swatchFlags);
                    }
                }

                retVal |= DrawIntPatchGrid(info, quadInfo, &SS0[0]);
            }
        }

        if (needBV0) {
            // complete generation of any inner curves
            for (onRow = nSwatchV;  onRow < stitch_nSwatchV;  onRow++) {
                RetessCurveSetInOut(info, 0, info->evalEnables, &BV0, &SV0);
                OffsetCurveSet(info, info->evalEnables, &BV0, 1);
                CopyCurveSet(info, info->evalEnables, ppGuardSetVBegin[onRow], &SV0);
            }
        }

        // swap ptrs for next big column
        pTempMatrix = pBB0; pBB0 = pBB1; pBB1 = pTempMatrix;
    }

    if (quadInfoOrig->stitchVBegin) { // now done in U1 setup || (quadInfo->stitchVEnd && (info->evalEnables & ~EV_GUARD_BITS))) { // }
        // last set of curves from regular grid was not written
        // because the regular grid is multiple of swatch size
        int lEnables = info->evalEnables;

        if (quadInfo->stitchVEnd) {
            if (!usingHW) {
                lEnables = info->evalEnables;
            } else {
                lEnables = info->evalEnables & ~EV_GUARD_BITS;
            }
        }
        for (onCol = nSwatchU;  onCol < stitch_nSwatchU;  onCol++) {
            //ffCopyMatrixSet(info, lEnables, pBB1, pBB0);     // horz step BB0 to BB1
            //ffOffsetFDMatrixSet(info, lEnables, pBB1, 1, 0); // ...

            // cvt BB0 to BS0 (in place)
            pBS0 = pBB0;
            RetessMatrixSetU(info, 0, lEnables, pBS0);

            // prepare matrices for swatch row 0
            CopyMatrixSet(info, lEnables, &SS0, pBS0);
            RetessMatrixSetV(info, 0, lEnables, &SS0);

            if (quadInfoOrig->stitchVBegin) {
                OffsetFDMatrixSet(info, lEnables, &SS0, 0, 1);
                ExtractUCurveSet(info, lEnables, ppGuardSetUBegin[onCol], &SS0);
            } else {
                OffsetFDMatrixSet(info, lEnables, &SS0, 0, quadInfo->vMaxSegs-1);
                ExtractUCurveSet(info, lEnables, ppGuardSetUEnd[onCol], &SS0);
            }

            // swap ptrs for next big column
            //ffpTempMatrix = pBB0; pBB0 = pBB1; pBB1 = pTempMatrix;
        }
    }

    // but restore everything else
    quadInfo = quadInfoOrig;

    nvAssert((*ppGuardSetU0[0])[0]->order == (*ppGuardSetU1[0])[0]->order);
    nvAssert((*ppGuardSetV0[0])[0]->order == (*ppGuardSetV1[0])[0]->order);
    if (ppStitchUInner) {
        nvAssert((*ppGuardSetU0[0])[0]->order == (*ppStitchUInner[0])[0]->order);
    }
    if (ppStitchVInner) {
        nvAssert((*ppGuardSetV0[0])[0]->order == (*ppStitchVInner[0])[0]->order);
    }
    DrawAllPatchTransitions(info, quadInfo,
                                    ppGuardSetU0, ppGuardSetU1, ppStitchUInner, ppStitchUInnerFrac,
                                    ppGuardSetV0, ppGuardSetV1, ppStitchVInner, ppStitchVInnerFrac);

    if (usingHW && (info->swatchFlags & NV_PATCH_SWATCH_LAST_ROW) && (info->swatchFlags & NV_PATCH_SWATCH_LAST_COL)) {
        HOS_CREATE_AND_ASSIGN_PUSHBUF_LOCALS();

        HOS_NOTE("End Patch");
        HOS_PUSH(0, ((0x1 << 18) | (HOS_KELVIN_CHANNEL << 13) | (NV097_SET_END_PATCH)));
        HOS_PUSH(1, 0x0);
        HOS_PUSH_ADJUST(2);
    }

drawIntPatchSwathsEnd:
    EV_FREE(ppGuardSetU0, info->context);
    EV_FREE(ppGuardSetU1, info->context);
    EV_FREE(ppGuardSetUInner, info->context);
    EV_FREE(ppGuardSetV0, info->context);
    EV_FREE(ppGuardSetV1, info->context);
    EV_FREE(ppGuardSetVInner, info->context);

    return retVal;
}

unsigned int
DrawIntPatch(NV_PATCH_INFO *info, NV_PATCH_QUAD_INFO *quadInfo, FDMatrix **matrices)
{
    unsigned int retVal = NV_PATCH_EVAL_OK;
    int doFrac = !!(info->flags & NV_PATCH_FLAG_TESS_FRACTIONAL);
    int index;
    int usingHW = info->usingHW;

    FDCurveAttrSet curves1, curves2;
    FDCurveAttrSet guardSetU0, guardSetU1, guardSetUInner;
    FDCurveAttrSet guardSetV0, guardSetV1, guardSetVInner;

    FDCurveAttrSet *ppGuardSetU0[1];  // pp to curves per attribute
    FDCurveAttrSet *ppGuardSetU1[1];  // [maxAttr][maxOrder][4]
    FDCurveAttrSet *ppGuardSetV0[1];  // ...
    FDCurveAttrSet *ppGuardSetV1[1];
    FDCurveAttrSet *ppGuardSetUInner[1];
    FDCurveAttrSet *ppGuardSetVInner[1];

    FDCurveAttrSet **ppGuardSetUBegin, **ppGuardSetUEnd;    // at begin/end of regular grid
    FDCurveAttrSet **ppGuardSetVBegin, **ppGuardSetVEnd;    // at begin/end of regular grid
    FDCurveAttrSet **ppStitchUInner = NULL, **ppStitchVInner = NULL; // inner curves for stitching

    NV_PATCH_EVAL_OUTPUT *pOut1, *pOut2;
    EV_ALLOC_DECL();
    int nBytes;
    int bytesGuardCurve = EV_ROUND(PATCH_CURVE_HEADER_SIZE + (info->maxOrder * 4) * sizeof(float));   // truncated NV_PATCH_CURVE_INFO
    int bytesGuardCurveAllAttr = info->nAttr * bytesGuardCurve;                 // just the set of curve info
    HOS_CREATE_AND_ASSIGN_PUSHBUF_LOCALS();


    ppGuardSetU0[0] = &guardSetU0;  // pp to curves per attribute
    ppGuardSetU1[0] = &guardSetU1;  // [maxAttr][maxOrder][4]
    ppGuardSetV0[0] = &guardSetV0;  // ...
    ppGuardSetV1[0] = &guardSetV1;
    ppGuardSetUInner[0] = &guardSetUInner;
    ppGuardSetVInner[0] = &guardSetVInner;

    if (!usingHW) {
        // Reverse the front face direction
        info->backend->setFrontFace(info, 1 ^ info->reverse);

    } else {
        if (!doFrac) {
            info->reverse = info->reverse ^ (quadInfo->uMaxDir ^ quadInfo->vMaxDir);
        }
        info->backend->setFrontFace(info, 1 ^ info->reverse);
    }

    NV_TRACE_CODE(nUniqueVertices = 0);
    nBytes = 0;
    if (!usingHW) {
        nBytes += 2 * sizeof(NV_PATCH_EVAL_OUTPUT);
        nBytes += info->nAttr * 2*bytesGuardCurve;
    }
    if (nBytes) {
        EV_ALLOC_INIT_WITH_CACHE(info->context, nBytes, drawIntPatchEnd, info->pCache[EV_CACHE_DRAW_SW]);
    }

    if (!usingHW) {
        // current output points. pOut1 for outer, pOut2 for inner
        EV_ALLOC(pOut1, info->context, sizeof(NV_PATCH_EVAL_OUTPUT));
        EV_ALLOC(pOut2, info->context, sizeof(NV_PATCH_EVAL_OUTPUT));
    }

    for (index = 0; index < info->maxAttr; index++) {
        if (!(info->evalEnables & (1<<index))) {
            continue;
        }

        if (!usingHW) {
            EV_ALLOC(curves1[index], info->context, bytesGuardCurve);
            EV_ALLOC(curves2[index], info->context, bytesGuardCurve);
            curves1[index]->order = info->maps[index].uorder;
            curves2[index]->order = info->maps[index].uorder;
        }

        if (info->swatchFlags & NV_PATCH_SWATCH) {
            continue;
        }

        guardSetU0[index]     = quadInfo->pU0[index];
        guardSetU1[index]     = quadInfo->pU1[index];
        guardSetUInner[index] = quadInfo->pUInner[index];
        guardSetV0[index]     = quadInfo->pV0[index];
        guardSetV1[index]     = quadInfo->pV1[index];
        guardSetVInner[index] = quadInfo->pVInner[index];
    }
    if (nBytes) {
        EV_ALLOC_FULL(info->context);
    }

    /*****************************************************************************/
    // This code is analogous to code in DrawIntPatchSwaths() to calc ppGuardXXX
    // BEGIN SIMILAR CODE
    if (quadInfo->vMaxDir == 1) {
        if (quadInfo->stitchTop) {
            ppGuardSetUBegin = ppGuardSetU0;
            if (quadInfo->vMaxSegs > 1) {
                ppGuardSetUEnd = ppGuardSetUInner;
                ppStitchUInner = ppGuardSetUInner;
            } else {
                ppGuardSetUEnd = ppGuardSetU0;
                ppStitchUInner = ppGuardSetU0;
            }
        } else if (quadInfo->stitchBottom) {
            if (quadInfo->vMaxSegs > 1) {
                ppGuardSetUBegin = ppGuardSetUInner;
                ppStitchUInner = ppGuardSetUInner;
            } else {
                ppGuardSetUBegin = ppGuardSetU1;
                ppStitchUInner = ppGuardSetU1;
            }
            ppGuardSetUEnd = ppGuardSetU1;
        } else {
            ppGuardSetUBegin = ppGuardSetU0;
            ppStitchUInner = NULL;
            ppGuardSetUEnd = ppGuardSetU1;
        }
    } else {
        if (quadInfo->stitchTop) {
            if (quadInfo->vMaxSegs > 1) {
                ppGuardSetUBegin = ppGuardSetUInner;
                ppStitchUInner = ppGuardSetUInner;
            } else {
                ppGuardSetUBegin = ppGuardSetU0;
                ppStitchUInner = ppGuardSetU0;
            }
            ppGuardSetUEnd = ppGuardSetU0;
        } else if (quadInfo->stitchBottom) {
            ppGuardSetUBegin = ppGuardSetU1;
            if (quadInfo->vMaxSegs > 1) {
                ppGuardSetUEnd = ppGuardSetUInner;
                ppStitchUInner = ppGuardSetUInner;
            } else {
                ppGuardSetUEnd = ppGuardSetU1;
                ppStitchUInner = ppGuardSetU1;
            }
        } else {
            ppGuardSetUBegin = ppGuardSetU1;
            ppStitchUInner = NULL;
            ppGuardSetUEnd = ppGuardSetU0;
        }
    }

    if (quadInfo->uMaxDir == 1) {
        if (quadInfo->stitchRight) {
            ppGuardSetVBegin = ppGuardSetV0;
            if (quadInfo->uMaxSegs > 1) {
                ppGuardSetVEnd = ppGuardSetVInner;
                ppStitchVInner = ppGuardSetVInner;
            } else {
                ppGuardSetVEnd = ppGuardSetV0;
                ppStitchVInner = ppGuardSetV0;
            }
        } else if (quadInfo->stitchLeft) {
            if (quadInfo->uMaxSegs > 1) {
                ppGuardSetVBegin = ppGuardSetVInner;
                ppStitchVInner = ppGuardSetVInner;
            } else {
                ppGuardSetVBegin = ppGuardSetV1;
                ppStitchVInner = ppGuardSetV1;
            }
            ppGuardSetVEnd = ppGuardSetV1;
        } else {
            ppGuardSetVBegin = ppGuardSetV0;
            ppStitchVInner = NULL;
            ppGuardSetVEnd = ppGuardSetV1;
        }
    } else {
        if (quadInfo->stitchRight) {
            if (quadInfo->uMaxSegs > 1) {
                ppGuardSetVBegin = ppGuardSetVInner;
                ppStitchVInner = ppGuardSetVInner;
            } else {
                ppGuardSetVBegin = ppGuardSetV0;
                ppStitchVInner = ppGuardSetV0;
            }
            ppGuardSetVEnd = ppGuardSetV0;
        } else if (quadInfo->stitchLeft) {
            ppGuardSetVBegin = ppGuardSetV1;
            if (quadInfo->uMaxSegs > 1) {
                ppGuardSetVEnd = ppGuardSetVInner;
                ppStitchVInner = ppGuardSetVInner;
            } else {
                ppGuardSetVEnd = ppGuardSetV1;
                ppStitchVInner = ppGuardSetV1;
            }
        } else {
            ppGuardSetVBegin = ppGuardSetV1;
            ppStitchVInner = NULL;
            ppGuardSetVEnd = ppGuardSetV0;
        }
    }
    if (doFrac) {
        ppGuardSetUEnd = /*ppGuardSetUInnerFrac =*/ info->ppGuardSetUInnerFrac;
        ppGuardSetVEnd = /*ppGuardSetVInnerFrac =*/ info->ppGuardSetVInnerFrac;
    }
    // END SIMILAR CODE

    quadInfo->pCurvesTop = &curves1;
    quadInfo->pCurvesBot = &curves2;
    quadInfo->pOut1 = pOut1;
    quadInfo->pOut2 = pOut2;

    info->setGridCorner = NV_PATCH_SET_GRID_CORNER_ALL;

    if (info->swatchFlags & NV_PATCH_SWATCH) {
        retVal |= DrawIntPatchSwaths(info, quadInfo, matrices);

    } else {
        // set up ptrs for writing U curves from matrix
        quadInfo->pSwatchUBegin = ppGuardSetUBegin[0];
        quadInfo->pSwatchUEnd = ppGuardSetUEnd[0];
        quadInfo->pSwatchVBegin = ppGuardSetVBegin[0];
        quadInfo->pSwatchVEnd = ppGuardSetVEnd[0];

        evalPrepareInnerCurves(info, 0, matrices);      // prepare the UInner and VInner curves

        for (index = 0; index < info->maxAttr; index++) {
            if (!EV_GUARD_ATTR(index)  &&  !doFrac) {
                continue;
            }
            if (!(info->evalEnables & (1 << index))) {
                continue;
            }
            info->pSwatchCorner[index][0][0] = info->gridCorner[index][1-quadInfo->vMaxDir][ 1-quadInfo->uMaxDir];
            FillIntCornerLL(info, quadInfo, quadInfo, index, info->pSwatchCorner[index][0][0]);

            info->pSwatchCorner[index][0][1] = info->gridCorner[index][1-quadInfo->vMaxDir][   quadInfo->uMaxDir];
            FillIntCornerLR(info, quadInfo, quadInfo, index, info->pSwatchCorner[index][0][1]);

            info->pSwatchCorner[index][1][0] = info->gridCorner[index][  quadInfo->vMaxDir][ 1-quadInfo->uMaxDir];
            FillIntCornerUL(info, quadInfo, quadInfo, index, info->pSwatchCorner[index][1][0]);

            info->pSwatchCorner[index][1][1] = info->gridCorner[index][  quadInfo->vMaxDir][   quadInfo->uMaxDir];
            FillIntCornerUR(info, quadInfo, quadInfo, index, info->pSwatchCorner[index][1][1]);

            // Copy U and V guard curves
            // note: be sure to do after Fill*() routines in case pSwatchV* curves are tweaked.
            CopyCurve(info, info->tempVBegin[index], (*quadInfo->pSwatchVBegin)[index]);
            CopyCurve(info, info->tempVEnd[index], (*quadInfo->pSwatchVEnd)[index]);
        }

        if (info->evalEnables & (1 << ATTR_N)) {
            info->swatchFlags |= NV_PATCH_HAS_NORMAL;
        };

        if (usingHW) {
            //calculate and send the Patch control words
            ComputeKelvinHOSControlWords(info, quadInfo, info->swatchFlags);
        }

        quadInfo->uMaxSegs -= doFrac;
        quadInfo->vMaxSegs -= doFrac;
        retVal |= DrawIntPatchGrid(info, quadInfo, matrices);
        quadInfo->uMaxSegs += doFrac;
        quadInfo->vMaxSegs += doFrac;

        DrawAllPatchTransitions(info, quadInfo,
                            ppGuardSetU0, ppGuardSetU1, ppStitchUInner, info->ppGuardSetUInnerFrac,
                            ppGuardSetV0, ppGuardSetV1, ppStitchVInner, info->ppGuardSetVInnerFrac);

        if (usingHW) {
            //end patch
            HOS_NOTE("End Patch");
            HOS_PUSH(0, ((0x1 << 18) | (HOS_KELVIN_CHANNEL << 13) | (NV097_SET_END_PATCH)));
            HOS_PUSH(1, 0x0);
            HOS_PUSH_ADJUST(2);
        }
    }

#if defined(ENABLE_DEBUG_SWATH)
    if (!usingHW && nvDebugLevel >= 3 && (evalTrace & 2)) {
        // when all done with regular grid, draw green X through regular grid corners
        float *pGridLL = info->gridCorner[ATTR_V][1-quadInfo->vMaxDir][ 1-quadInfo->uMaxDir];
        float *pGridLR = info->gridCorner[ATTR_V][1-quadInfo->vMaxDir][   quadInfo->uMaxDir];
        float *pGridUL = info->gridCorner[ATTR_V][  quadInfo->vMaxDir][ 1-quadInfo->uMaxDir];
        float *pGridUR = info->gridCorner[ATTR_V][  quadInfo->vMaxDir][   quadInfo->uMaxDir];

        glDisable(GL_TEXTURE_2D);
        glPushMatrix();

        // and green X through gridCorner points
        glTranslatef(0, 0, .2);
        glColor3f(0, 1, 0);
        glEnable(GL_LINE_STIPPLE);
        glLineStipple(1, 0xFF00);
        glBegin(GL_LINE_STRIP);
            glVertex3fv(pGridLL); glVertex3fv(pGridLR);
            glVertex3fv(pGridUL); glVertex3fv(pGridUR);
            glVertex3fv(pGridLL);
        glEnd();
        glDisable(GL_LINE_STIPPLE);

        glPopMatrix();
        glColor3f(1, 1, 0);
        if (info->evalEnables & (1 << NV_PATCH_ATTRIB_TEXCOORD0)) {
            glEnable(GL_TEXTURE_2D);
        }
    }
#endif


drawIntPatchEnd:
    if (!usingHW) {
        EV_FREE(pOut1, info->context);
        EV_FREE(pOut2, info->context);
    }

    for (index = 0; index < info->maxAttr; index++) {
        if (info->evalEnables & (1 << index)) {
            if (!usingHW) {
                EV_FREE(curves1[index], info->context);
                EV_FREE(curves2[index], info->context);
            }
        }
    }
    NV_TRACE_CODE( if (enableUniqueCheck && !usingHW  &&  (nvDebugLevel >= 2)) {
        int A = quadInfo->nu0;
        int B = quadInfo->nv0;
        int C = quadInfo->nu1;
        int D = quadInfo->nv1;
        int maxac = MAX(A,C);
        int maxbd = MAX(B,D);
        int minac = MIN(A,C);
        int minbd = MIN(B,D);
        int expect = MAX(A,C) * MAX(B,D) + MIN(A,C) + MIN(B,D) + 1;
        int expectedTris = (maxac-1)*(maxbd-1)*2+minbd+maxbd-1+minac+maxac-1;

        if (doFrac) {
            expect = quadInfo->uMaxSegs * quadInfo->vMaxSegs + quadInfo->uMinSegs + quadInfo->vMinSegs + 1;
            expectedTris = (quadInfo->uMaxSegs-1)*(quadInfo->vMaxSegs-1)
                                +quadInfo->uMinSegs+quadInfo->uMinSegs-1
                                +quadInfo->vMinSegs+quadInfo->vMinSegs-1;
        }
        nvAssert((nvDebugLevel & 1) || expect == nUniqueVertices);
        TPRINTF(("nUniqueVertices=%d    expectV=%d expectTri=%d\n",
                 nUniqueVertices, expect, expectedTris));
        if (expect != nUniqueVertices) {
            drawUniqueVertices();
        }
    } );
    NV_TRACE_COND(TR_EVAL, 20,
        TPRINTF(("nu0=%d nu1=%d nv0=%d nv1=%d maxU=%d maxV=%d minU=%d minV=%d\n",
                quadInfo->nu0, quadInfo->nu1, quadInfo->nv0, quadInfo->nv1,
                quadInfo->uMaxSegs, quadInfo->vMaxSegs, quadInfo->uMinSegs, quadInfo->vMinSegs));
        TPRINTF(("dir BTLR=[%d %d %d %d]  uMaxDir=%d vMaxDir=%d\n",
                quadInfo->u0Dir, quadInfo->u1Dir, quadInfo->v0Dir, quadInfo->v1Dir, quadInfo->uMaxDir, quadInfo->vMaxDir));
        TPRINTF(("  stitch BTLR=[%d %d %d %d]  stitch UBE=[%d %d] VBE=[%d %d]\n",
                quadInfo->stitchBottom, quadInfo->stitchTop, quadInfo->stitchLeft, quadInfo->stitchRight,
                quadInfo->stitchUBegin, quadInfo->stitchUEnd, quadInfo->stitchVBegin, quadInfo->stitchVEnd ));
        TPRINTF(("force rev bits=%d %d %d %d  info->flags=x%X\n",
                (nvDebugOptions & TRO_TEMP1) != 0,
                (nvDebugOptions & TRO_TEMP2) != 0,
                (nvDebugOptions & TRO_TEMP3) != 0,
                (nvDebugOptions & TRO_TEMP4) != 0,
                info->flags));
        if (info->flipT && info->flipU && info->flipV) {
            TPRINTF(("\n\n***** transpose/flip alert %d <--> %d\n\n", quadInfo->nu1, quadInfo->nv1));
            TPRINTF(("***** flipU=%d flipV=%d\n", info->flipU, info->flipV));
        }
    );
    return retVal;
}

// Determine if a patch is rational (i.e. w != 1)
static int IsPatchRational(NV_PATCH_INFO *info, int attrib)
{
    NV_PATCH_MAP_INFO *map = &info->maps[attrib];
    unsigned int i, j;

/*    switch (type) {
    case NV_PATCH_VERTEX_FORMAT_FLOAT_4:*/
        if (info->flags & NV_PATCH_FLAG_TYPE_TRIANGULAR) {
            for (j = 0; j < map->vorder; j++) {
                for (i = 0; i < map->uorder - j; i++) {
                    if (map->rawData[4*(j*map->uorder + i) + 3] != 1.0f) {
                        return 1;
                    }
                }
            }
        } else {
            for (j = 0; j < map->vorder; j++) {
                for (i = 0; i < map->uorder; i++) {
                    if (map->rawData[4*(j*map->uorder + i) + 3] != 1.0f) {
                        return 1;
                    }
                }
            }
        }
/*        break;
    case NV_PATCH_VERTEX_FORMAT_FLOAT_1:
    case NV_PATCH_VERTEX_FORMAT_FLOAT_2:
    case NV_PATCH_VERTEX_FORMAT_FLOAT_3:
        break;  // fall through we are guaranteed non-rational by our expansion methods
    default:
        nvAssert(0);
    }
*/
    return 0;
}

static float BinomialCoefficient(int n, int r)
{
    float x;
    if (n<=10 && r <= 10) {
        x = cachedBinomialCoefficients[n][r];
    }
    else {
        int i;
        x = 1.0f;
        for (i = 2; i <= n; i++) {
            x *= i;
        }
        for (i = 2; i <= r; i++) {
            x /= i;
        }
        for (i = 2; i <= n-r; i++) {
            x /= i;
        }
    }

    return x;
}

static float TrinomialCoefficient(int n, int r, float s)
{
    float x = 1.0f;
    int i;

    for (i = 2; i <= n; i++) {
        x *= i;
    }
    for (i = 2; i <= r; i++) {
        x /= i;
    }
    for (i = 2; i <= s; i++) {
        x /= i;
    }
    for (i = 2; i <= n-r-s; i++) {
        x /= i;
    }
    return x;
}

static void ComputeNormalPatch(NV_PATCH_INFO *info, float *normalPatch,
                                int uorder, int vorder, int rational)
{
    NV_PATCH_MAP_INFO *map = &info->maps[info->srcNormal];
    float *rawData = map->rawData;
    int pitch = map->pitch;
    int ufStride = 4;
    int vfStride = 4 * map->pitch;
    int i, j;
    FDMatrix *derivU, *derivV, *derivUTemp = NULL, *derivVTemp = NULL;
    FDMatrix *temp[6], *pFDMatrix;
    int normalUOrder, normalVOrder;
    int uRow, uCol, vRow, vCol;
    EV_ALLOC_DECL();

    EV_ALLOC_INIT_WITH_CACHE(info->context, 8 * sizeof(FDMatrix), computeNormalPatchEnd, info->pCache[EV_CACHE_9FDMATRICES]);
    EV_ALLOC(derivU, info->context, sizeof(FDMatrix));
    EV_ALLOC(derivV, info->context, sizeof(FDMatrix));
    EV_ALLOC(temp[0], info->context, sizeof(FDMatrix));
    EV_ALLOC(temp[1], info->context, sizeof(FDMatrix));
    EV_ALLOC(temp[2], info->context, sizeof(FDMatrix));
    EV_ALLOC(temp[3], info->context, sizeof(FDMatrix));
    EV_ALLOC(temp[4], info->context, sizeof(FDMatrix));
    EV_ALLOC(temp[5], info->context, sizeof(FDMatrix));
    EV_ALLOC_FULL(info->context);

    if (info->flags & NV_PATCH_FLAG_TYPE_TRIANGULAR) {
        if (rational) {
            normalUOrder = normalVOrder = 4*uorder - 5;
        } else {
            normalUOrder = normalVOrder = 2*uorder - 3;
        }

        // Compute derivatives in u
        derivU->columns = uorder-1;
        derivU->rows = uorder-1;
        for (j = 0; j < uorder-1; j++) {
            FillColumnVectorMatrix(uorder-j, ufStride*sizeof(float), pRawData(info, map, rawData, j, 0), temp[0], 0);
            for (i = 0; i < uorder-1-j; i++) {
                derivU->data[j][i][0] = temp[0]->data[i+1][0][0] - temp[0]->data[i][0][0];
                derivU->data[j][i][1] = temp[0]->data[i+1][0][1] - temp[0]->data[i][0][1];
                derivU->data[j][i][2] = temp[0]->data[i+1][0][2] - temp[0]->data[i][0][2];
                derivU->data[j][i][3] = temp[0]->data[i+1][0][3] - temp[0]->data[i][0][3];
            }
        }

        // Compute derivatives in v
        derivV->columns = uorder-1;
        derivV->rows = uorder-1;
        for (i = 0; i < uorder; i++) {
            FillColumnVectorMatrix(uorder-i, vfStride * sizeof(float), pRawData(info, map, rawData, 0, i), temp[0], 0);
            for (j = 0; j < uorder-1-i; j++) {
                derivV->data[j][i][0] = temp[0]->data[j+1][0][0] - temp[0]->data[j][0][0];
                derivV->data[j][i][1] = temp[0]->data[j+1][0][1] - temp[0]->data[j][0][1];
                derivV->data[j][i][2] = temp[0]->data[j+1][0][2] - temp[0]->data[j][0][2];
                derivV->data[j][i][3] = temp[0]->data[j+1][0][3] - temp[0]->data[j][0][3];
            }
        }

        if (rational) {
            int derivRow, derivCol, vertRow, vertCol;

            // This code makes the assumption that type == NV_PATCH_VERTEX_FORMAT_FLOAT_4.
            // Seeing as the patch is rational, this is probably safe, unless people start
            // using unsigned byte types for rational patches.

            derivUTemp = temp[2];
            derivVTemp = temp[3];

            // Initialize matrices
            derivUTemp->columns = 2*uorder - 2;
            derivUTemp->rows    = 2*uorder - 2;
            derivVTemp->columns = 2*uorder - 2;
            derivVTemp->rows    = 2*uorder - 2;
            for (derivRow = 0; derivRow < derivUTemp->rows; derivRow++) {
                for (derivCol = 0; derivCol < derivUTemp->columns; derivCol++) {
                    derivUTemp->data[derivRow][derivCol][0] = 0.0f;
                    derivUTemp->data[derivRow][derivCol][1] = 0.0f;
                    derivUTemp->data[derivRow][derivCol][2] = 0.0f;
                    derivUTemp->data[derivRow][derivCol][3] = 0.0f;
                }
            }
            for (derivRow = 0; derivRow < derivVTemp->rows; derivRow++) {
                for (derivCol = 0; derivCol < derivVTemp->columns; derivCol++) {
                    derivVTemp->data[derivRow][derivCol][0] = 0.0f;
                    derivVTemp->data[derivRow][derivCol][1] = 0.0f;
                    derivVTemp->data[derivRow][derivCol][2] = 0.0f;
                    derivVTemp->data[derivRow][derivCol][3] = 0.0f;
                }
            }

            // derivU <-- derivU.xyz * vertices.w - derivU.w * vertices.xyz
            for (derivRow = 0; derivRow < derivU->rows; derivRow++) {
                for (derivCol = 0; derivCol < derivU->columns-derivRow; derivCol++) {
                    float derivPoint[4];

                    derivPoint[0] = derivU->data[derivRow][derivCol][0];
                    derivPoint[1] = derivU->data[derivRow][derivCol][1];
                    derivPoint[2] = derivU->data[derivRow][derivCol][2];
                    derivPoint[3] = derivU->data[derivRow][derivCol][3];

                    for (vertRow = 0; vertRow < vorder; vertRow++) {
                        for (vertCol = 0; vertCol < uorder-vertRow; vertCol++) {
                            float vert[4], *result;
                            float factor;

                            vert[0] = rawData[4*(vertRow*pitch + vertCol) + 0];
                            vert[1] = rawData[4*(vertRow*pitch + vertCol) + 1];
                            vert[2] = rawData[4*(vertRow*pitch + vertCol) + 2];
                            vert[3] = rawData[4*(vertRow*pitch + vertCol) + 3];

                            factor  = TrinomialCoefficient(derivU->rows-1, derivRow, derivCol);
                            factor *= TrinomialCoefficient(uorder-1, vertRow, vertCol);
                          