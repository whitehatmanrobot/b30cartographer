 i = 0; i < POOL_SMALL_LISTS; i += 1) {

            ULONG Location;
            SMALL_POOL_LOOKASIDE LookasideList;

            Location = Address + i * sizeof(SMALL_POOL_LOOKASIDE);

            ReadAtAddress( Location, LookasideList, sizeof(SMALL_POOL_LOOKASIDE) );

            LookasideList.TotalAllocates = 0;
            LookasideList.AllocateHits = 0;
            LookasideList.TotalFrees = 0;
            LookasideList.FreeHits = 0;

            WriteAtAddress( Location, LookasideList, sizeof(SMALL_POOL_LOOKASIDE) );
        }

#endif // TARGET_PPC

    } else {

        ULONG Address;
        ULONG Results;
        ULONG i;

        //
        //  Get the location of the nonpaged list
        //

        GetAddressFromName( Address, "ExpSmallNPagedPoolLookasideLists" );
        dprintf("\nExpSmallNPagedLookasideLists @ %08lx\n", Address);

        //
        //  Read in each list and dump it out
        //

        for ( i = 0; i < POOL_SMALL_LISTS; i += 1) {

            ULONG Location;
            SMALL_POOL_LOOKASIDE LookasideList;
            ULONG AllocationHitRate;
            ULONG FreeHitRate;

            Location = Address + i * sizeof(SMALL_POOL_LOOKASIDE);

            ReadAtAddress( Location, LookasideList, sizeof(SMALL_POOL_LOOKASIDE) );

            TotalNPagedUsed += LookasideList.SListHead.Depth * (i+1)*32;
            TotalNPagedPotential += LookasideList.Depth * (i+1)*32;

            AllocationHitRate = (LookasideList.TotalAllocates > 0 ? ((LookasideList.AllocateHits*100)/LookasideList.TotalAllocates) : 0);
            FreeHitRate = (LookasideList.TotalFrees > 0 ? ((LookasideList.FreeHits*100)/LookasideList.TotalFrees) : 0);

            dprintf("\n  Nonpaged %d bytes @ %08lx\n", (i+1)*32, Location);

            dprintf("    Current Depth  = %8ld   Max Depth  = %8ld\n", LookasideList.SListHead.Depth, LookasideList.Depth);
            dprintf("    Size           = %8ld   Max Alloc  = %8ld\n", (i+1)*32, LookasideList.Depth * (i+1)*32);
            dprintf("    AllocateHits   = %8ld   FreeHits   = %8ld\n", LookasideList.AllocateHits, LookasideList.FreeHits);
            dprintf("    TotalAllocates = %8ld   TotalFrees = %8ld\n", LookasideList.TotalAllocates, LookasideList.TotalFrees);
            dprintf("    Hit Rate       =      %3d%%  Hit Rate   =      %3d%%\n", AllocationHitRate, FreeHitRate);
        }

        //
        //  Get the location of the paged list
        //

#ifndef TARGET_PPC

        GetAddressFromName( Address, "ExpSmallPagedPoolLookasideLists" );
        dprintf("\nExpSmallPagedLookasideLists @ %08lx\n", Address);

        //
        //  Read in each list and dump it out
        //

        for ( i = 0; i < POOL_SMALL_LISTS; i += 1) {

            ULONG Location;
            SMALL_POOL_LOOKASIDE LookasideList;
            ULONG AllocationHitRate;
            ULONG FreeHitRate;

            Location = Address + i * sizeof(SMALL_POOL_LOOKASIDE);

            ReadAtAddress( Location, LookasideList, sizeof(SMALL_POOL_LOOKASIDE) );

            TotalPagedUsed += LookasideList.SListHead.Depth * (i+1)*32;
            TotalPagedPotential += LookasideList.Depth * (i+1)*32;

            AllocationHitRate = (LookasideList.TotalAllocates > 0 ? ((LookasideList.AllocateHits*100)/LookasideList.TotalAllocates) : 0);
            FreeHitRate = (LookasideList.TotalFrees > 0 ? ((LookasideList.FreeHits*100)/LookasideList.TotalFrees) : 0);

            dprintf("\n  Paged %d bytes @ %08lx\n", (i+1)*32, Location);

            dprintf("    Current Depth  = %8ld   Max Depth  = %8ld\n", LookasideList.SListHead.Depth, LookasideList.Depth);
            dprintf("    Size           = %8ld   Max Alloc  = %8ld\n", (i+1)*32, LookasideList.Depth * (i+1)*32);
            dprintf("    AllocateHits   = %8ld   FreeHits   = %8ld\n", LookasideList.AllocateHits, LookasideList.FreeHits);
            dprintf("    TotalAllocates = %8ld   TotalFrees = %8ld\n", LookasideList.TotalAllocates, LookasideList.TotalFrees);
            dprintf("    Hit Rate       =      %3d%%  Hit Rate   =      %3d%%\n", AllocationHitRate, FreeHitRate);
        }

#endif // TARGET_PPC

        dprintf("\n");
        dprintf("Total NonPaged currently allocated for pool lists = %8ld\n", TotalNPagedUsed);
        dprintf("Total NonPaged potential for pool lists           = %8ld\n", TotalNPagedPotential);
        dprintf("Total Paged currently allocated for pool lists    = %8ld\n", TotalPagedUsed);
        dprintf("Total Paged potential for pool lists              = %8ld\n", TotalPagedPotential);
    }

    {
        ULONG Address;
        ULONG Results;

        ULONG i;
        ULONG j;

        UCHAR KeNumberProcessors;
        ULONG KiProcessorBlock[32];

        //
        //  First find out how many processors there are and then read in the
        //  array of processor block pointers
        //

        GetAddressFromName( Address, "KeNumberProcessors" );
        ReadAtAddress( Address, Address, sizeof(ULONG) );

        //
        //  For some bizarre reason sometimes we do a indirect read to get the
        //  number of processors and at other times it is more direct
        //

        if (Address <= 32) {

            KeNumberProcessors = (UCHAR)Address;

        } else {

            ReadAtAddress( Address, KeNumberProcessors, sizeof(UCHAR) );
        }

        GetAddressFromName( Address, "KiProcessorBlock" );
        ReadAtAddress( Address, KiProcessorBlock, sizeof(ULONG)*KeNumberProcessors );

        //
        //  Check if we are to reset the counters
        //

        if (Options == 1) {

            KPRCB Kprcb;

            for (i = 0; i < KeNumberProcessors; i += 1) {


                ReadAtAddress( KiProcessorBlock[i], Kprcb, sizeof(KPRCB) );

                for (j = 0; j < POOL_SMALL_LISTS; j += 1) {

                    Kprcb.SmallNPagedPoolLookasideLists[j].AllocateHits = 0;
                    Kprcb.SmallNPagedPoolLookasideLists[j].TotalAllocates = 0;

#ifndef TARGET_PPC
                    Kprcb.SmallPagedPoolLookasideLists[j].AllocateHits = 0;
                    Kprcb.SmallPagedPoolLookasideLists[j].TotalAllocates = 0;
#endif // TARGET_PPC
                }

                WriteAtAddress( KiProcessorBlock[i], Kprcb, sizeof(KPRCB) );
            }


        } else {

            KPRCB Kprcb[32];
            ULONG Addr[32];
            ULONG Depth[32];
            ULONG Hits[32];
            ULONG Total[32];
            ULONG HitRate[32];
            ULONG MaxAlloc[32];

            dprintf("\nSmall Pool Lookaside lists\n\n");
            dprintf("Kprcb    =");
            for (i = 0; i < KeNumberProcessors; i += 1) {

                dprintf(" %08lx ", KiProcessorBlock[i]);
                ReadAtAddress( KiProcessorBlock[i], Kprcb[i], sizeof(KPRCB) );
            }
            dprintf("\n");

            for ( j = 0; j < POOL_SMALL_LISTS; j += 1) {

                dprintf("\nNonpaged %d bytes\n", (j+1)*32);
                for (i = 0; i < KeNumberProcessors; i += 1) {

                    Addr[i] = KiProcessorBlock[i] + FIELD_OFFSET(KPRCB, SmallNPagedPoolLookasideLists[j]);

                    Depth[i] = Kprcb[i].SmallNPagedPoolLookasideLists[j].Depth;
                    Hits[i] = Kprcb[i].SmallNPagedPoolLookasideLists[j].AllocateHits;
                    Total[i] = Kprcb[i].SmallNPagedPoolLookasideLists[j].TotalAllocates;

                    HitRate[i] = (Total[i] > 0 ? ((Hits[i]*100)/Total[i]) : 0);
                    MaxAlloc[i] = ((j+1)*32) * Depth[i];
                }

                dprintf("Address  ="); for (i = 0; i < KeNumberProcessors; i += 1) { dprintf(" %08lx ", Addr[i]); }   dprintf("\n");
                dprintf("Depth    ="); for (i = 0; i < KeNumberProcessors; i += 1) { dprintf(" %8d ", Depth[i]); }   dprintf("\n");
                dprintf("MaxAlloc ="); for (i = 0; i < KeNumberProcessors; i += 1) { dprintf(" %8d ", MaxAlloc[i]); } dprintf("\n");
                dprintf("Hits     ="); for (i = 0; i < KeNumberProcessors; i += 1) { dprintf(" %8d ", Hits[i]); }    dprintf("\n");
                dprintf("Total    ="); for (i = 0; i < KeNumberProcessors; i += 1) { dprintf(" %8d ", Total[i]); }   dprintf("\n");
                dprintf("HitRate  ="); for (i = 0; i < KeNumberProcessors; i += 1) { dprintf(" %8d%%", HitRate[i]); } dprintf("\n");
            }

#ifndef TARGET_PPC
            for ( j = 0; j < POOL_SMALL_LISTS; j += 1) {

                dprintf("\nPaged %d bytes\n", (j+1)*32);
                for (i = 0; i < KeNumberProcessors; i += 1) {

                    Addr[i] = KiProcessorBlock[i] + FIELD_OFFSET(KPRCB, SmallPagedPoolLookasideLists[j]);

                    Depth[i] = Kprcb[i].SmallPagedPoolLookasideLists[j].Depth;
                    Hits[i] = Kprcb[i].SmallPagedPoolLookasideLists[j].AllocateHits;
                    Total[i] = Kprcb[i].SmallPagedPoolLookasideLists[j].TotalAllocates;

                    HitRate[i] = (Total[i] > 0 ? ((Hits[i]*100)/Total[i]) : 0);
                    MaxAlloc[i] = ((j+1)*32) * Depth[i];
                }

                dprintf("Address  ="); for (i = 0; i < KeNumberProcessors; i += 1) { dprintf(" %08lx ", Addr[i]); }   dprintf("\n");
                dprintf("Depth    ="); for (i = 0; i < KeNumberProcessors; i += 1) { dprintf(" %8d ", Depth[i]); }   dprintf("\n");
                dprintf("MaxAlloc ="); for (i = 0; i < KeNumberProcessors; i += 1) { dprintf(" %8d ", MaxAlloc[i]); } dprintf("\n");
                dprintf("Hits     ="); for (i = 0; i < KeNumberProcessors; i += 1) { dprintf(" %8d ", Hits[i]); }    dprintf("\n");
                dprintf("Total    ="); for (i = 0; i < KeNumberProcessors; i += 1) { dprintf(" %8d ", Total[i]); }   dprintf("\n");
                dprintf("HitRate  ="); for (i = 0; i < KeNumberProcessors; i += 1) { dprintf(" %8d%%", HitRate[i]); } dprintf("\n");
            }
#endif // TARGET_PPC
        }
    }
*/

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\kdexts\mmx.c ===
/*++

Copyright (c) 1992-2001  Microsoft Corporation

Module Name:

    mmx.c

Abstract:

    WinDbg Extension Api

--*/

#include "precomp.h"
#pragma hdrstop

PMMPTE
DbgGetPdeAddress(
    IN PVOID VirtualAddress
    )
{
    return MiGetPdeAddress(VirtualAddress);
}

PMMPTE
DbgGetPteAddress(
    IN PVOID VirtualAddress
    )
{
    return MiGetPteAddress(VirtualAddress);
}

ULONG
DbgGetPteSize(
    VOID
    )
{
    return sizeof(MMPTE);
}

ULONG
DbgGetPfnSize(
    VOID
    )
{
    return sizeof(MMPFN);
}

PVOID
DbgGetVirtualAddressMappedByPte(
    IN PMMPTE Pte
    )
{
    return MiGetVirtualAddressMappedByPte (Pte);
}

VOID
DumpPte(
    LPCSTR Label,
    PMMPTE Pte
    );

ULONG
MiGetFrameFromPte (
    PMMPTE lpte
    )
/*++

Routine Description:

    If the PTE is valid, returns the page frame number that
    the PTE maps.  Zero is returned otherwise.

Arguments:

    lpte - the PTE to examine.

--*/


{
    MMPTE Pte1;

    Pte1.Long = lpte->Long;

    if (Pte1.Hard.Valid) {
        return (ULONG)(Pte1.Hard.PageFrameNumber);
    }
    return(0);
}

ULONG
GetAddressState(
    IN PVOID VirtualAddress
    )
{
    ULONG   Address;
    ULONG   result;
    ULONG   flags = 0;
    PMMPTE  Pte;
    PMMPTE  Pde;
    ULONG   PdeContents;
    ULONG   PteContents;

    if (MI_IS_PHYSICAL_ADDRESS (VirtualAddress)) {
        return ADDRESS_VALID;
    }
    Address = (ULONG)VirtualAddress;

    Pde = DbgGetPdeAddress (VirtualAddress);
    Pte = DbgGetPteAddress (VirtualAddress);

    if ( !ReadMemory( (DWORD)Pde,
                      &PdeContents,
                      sizeof(ULONG),
                      &result) ) {
        dprintf("%08lx: Unable to get PDE\n",Pde);
        return ADDRESS_NOT_VALID;
    }

    if (PdeContents & MM_PTE_VALID_MASK) {
        if (PdeContents & MM_PTE_LARGE_PAGE_MASK) {
            return ADDRESS_VALID;
        }
        if ( !ReadMemory( (DWORD)Pte,
                          &PteContents,
                          sizeof(ULONG),
                          &result) ) {
            dprintf("%08lx: Unable to get PTE\n",Pte);
            return ADDRESS_NOT_VALID;
        }
        if (PteContents & MM_PTE_VALID_MASK) {
            return ADDRESS_VALID;
        }
    }
    return ADDRESS_NOT_VALID;
}


BOOLEAN
CopyPfnDatabaseLocal(
    OUT PMMPFN *PfnDatabaseLocalOutput,
    OUT ULONG *NumberOfPages
    )
{
    PFN_NUMBER HighestPhysicalPage;
    PMMPFN PfnDatabase;
    SIZE_T SizeOfPfnDatabase;
    PMMPFN PfnDatabaseLocal;
    PFN_NUMBER CurrentPage;
    PFN_NUMBER EntriesToRead;
    ULONG result;

    HighestPhysicalPage = GetNtDebuggerDataValue(MmHighestPhysicalPage);
    PfnDatabase = (PMMPFN)GetNtDebuggerDataValue(MmPfnDatabase);

    if (HighestPhysicalPage == 0 || PfnDatabase == 0) {
        return FALSE;
    }

    //  Make the value exclusive.
    HighestPhysicalPage++;

    SizeOfPfnDatabase = HighestPhysicalPage * sizeof(MMPFN);

    PfnDatabaseLocal = (PMMPFN)LocalAlloc(LPTR, SizeOfPfnDatabase);

    if (PfnDatabaseLocal == NULL) {
        return FALSE;
    }

    EntriesToRead = 1024;

    for (CurrentPage = 0; CurrentPage < HighestPhysicalPage; CurrentPage += EntriesToRead) {

        dprintf("loading (%d%% complete)\r", (CurrentPage * 100) / HighestPhysicalPage);

        if ((HighestPhysicalPage - CurrentPage) < EntriesToRead) {
            EntriesToRead = HighestPhysicalPage - CurrentPage;
        }

        if (!ReadMemory((DWORD)(&PfnDatabase[CurrentPage]),
                        (&PfnDatabaseLocal[CurrentPage]),
                        EntriesToRead * sizeof(MMPFN),
                        &result)) {
            dprintf("unable to read PFNs starting at index %x\n", CurrentPage);
            LocalFree(PfnDatabaseLocal);
            return FALSE;
        }

        if (CheckControlC()) {
            LocalFree(PfnDatabaseLocal);
            return FALSE;
        }
    }

    *PfnDatabaseLocalOutput = PfnDatabaseLocal;
    *NumberOfPages = HighestPhysicalPage;

    return TRUE;
}

#define STRINGIZE(_name) #_name
#define DUMP_CASE(name) dprintf("%6d pages  " STRINGIZE(name) " (%d KB)\n", AllocatedPagesByUsageLocal[name], AllocatedPagesByUsageLocal[name] * 4096 / 1024)

DECLARE_API(memusage)
{
    PFN_COUNT value;
    PFN_COUNT *AllocatedPagesByUsage;
    PFN_COUNT AllocatedPagesByUsageLocal[MmMaximumUsage];
    ULONG result;

    value = GetNtDebuggerDataValue(MmNumberOfPhysicalPages);
    dprintf("%6d  Total number of pages (%d MB)\n", value, value * 4096 / (1024 * 1024));
    value = GetNtDebuggerDataValue(MmAvailablePages);
    dprintf("%6d  Available number of pages (%d KB)\n", value, value * 4096 / 1024);
    dprintf("\n");

    AllocatedPagesByUsage = (PFN_COUNT *)GetNtDebuggerData(MmAllocatedPagesByUsage);

    if (AllocatedPagesByUsage == NULL) {
        dprintf("cannot resolve MmAllocatedPagesByUsage\n");
        return;
    }

    if (!ReadMemory((DWORD)AllocatedPagesByUsage,
                    AllocatedPagesByUsageLocal,
                    sizeof(AllocatedPagesByUsageLocal),
                    &result)) {
        dprintf("cannot read MmAllocatedPagesByUsage\n");
        return;
    }

    DUMP_CASE(MmUnknownUsage);
    DUMP_CASE(MmStackUsage);
    DUMP_CASE(MmVirtualPageTableUsage);
    DUMP_CASE(MmSystemPageTableUsage);
    DUMP_CASE(MmPoolUsage);
    DUMP_CASE(MmVirtualMemoryUsage);
    DUMP_CASE(MmSystemMemoryUsage);
    DUMP_CASE(MmImageUsage);
    DUMP_CASE(MmFsCacheUsage);
    DUMP_CASE(MmContiguousUsage);
    DUMP_CASE(MmDebuggerUsage);
}

#define STRING_CASE(name) case Mm##name##Usage: TypeName = STRINGIZE(name); break

VOID
DumpPfnEntry(
    ULONG PageFrameNumber,
    PMMPFN PageFrame
    )
{
    ULONG Color;
    LPCSTR TypeName;

    if (PageFrame->Pte.Hard.Valid != 0) {

        dprintf("%05x ", PageFrameNumber);
        DumpPte("PTE", &PageFrame->Pte);

    } else if (PageFrame->Busy.Busy != 0) {

        switch (PageFrame->Busy.BusyType) {

            STRING_CASE(Unknown);
            STRING_CASE(Stack);
            STRING_CASE(VirtualPageTable);
            STRING_CASE(SystemPageTable);
            STRING_CASE(Pool);
            STRING_CASE(VirtualMemory);
            STRING_CASE(SystemMemory);
            STRING_CASE(Image);
            STRING_CASE(FsCache);
            STRING_CASE(Contiguous);
            STRING_CASE(Debugger);

            default: TypeName = "UNKNOWN";
        }

        dprintf("%05x %-20s lockcount=%04x ", PageFrameNumber, TypeName,
            PageFrame->Busy.LockCount >> 1);

        if (PageFrame->Busy.BusyType == MmVirtualPageTableUsage) {
            dprintf("ptecount=%d", PageFrame->Directory.NumberOfUsedPtes);
        } else if (PageFrame->Busy.BusyType == MmFsCacheUsage) {
            dprintf("fsindex=%d", PageFrame->FsCache.ElementIndex);
        } else {
            if (PageFrame->Busy.BusyType != MmUnknownUsage) {
                dprintf("pteindex=%03x ", PageFrame->Busy.PteIndex);
            }
        }

    } else {

        dprintf("%05x %-20s", PageFrameNumber, "Free");

        Color = MiGetPfnColor(PageFrameNumber);

        if (PageFrame->Free.PackedPfnBlink == MM_PACKED_PFN_NULL) {
            dprintf(" blink=<null>   ");
        } else {
            dprintf(" blink=%05x   ", MiUnpackFreePfn(PageFrame->Free.PackedPfnBlink, Color));
        }

        if (PageFrame->Free.PackedPfnFlink == MM_PACKED_PFN_NULL) {
            dprintf(" flink=<null>");
        } else {
            dprintf(" flink=%05x", MiUnpackFreePfn(PageFrame->Free.PackedPfnFlink, Color));
        }
    }

    dprintf("\n");
}

DECLARE_API(pfn)
{
    ULONG Address = 0;
    ULONG Flags = 0;
    PMMPFN PfnDatabaseLocal = NULL;
    ULONG NumberOfPages;
    PMMPFN Pfn;
    ULONG i;
    ULONG printed = 0;
    MMPFN PfnLocal;
    PMMPFN PfnDatabase;
    PMMPTE PointerPde;
    PMMPTE PointerPte;
    MMPTE TempPte;
    ULONG result;
    char ExprBuf[256] ;

    sscanf(args, "%s %lx", ExprBuf, &Flags);

    if (ExprBuf[0]) {
        if (IsHexNumber(ExprBuf) || ExprBuf[0] == '-') {
            sscanf(ExprBuf, "%lx", &Address) ;
        } else {
            Address = GetExpression(ExprBuf);
            if (Address==0) {
                dprintf("An error occured trying to evaluate the expression\n") ;
                return;
            }
        }
    }

    //
    // Dump the whole thing?
    //

    if (Address == (ULONG)-1 || Address == (ULONG)-2 || Address == (ULONG)-3 || Address == (ULONG)-4) {

        if (CopyPfnDatabaseLocal(&PfnDatabaseLocal, &NumberOfPages)) {

            if (((LONG)Flags) < 0) {
                Flags = (1 << ((ULONG)-((LONG)Flags)));
            }

            for (i = 0; i < NumberOfPages; i++) {

                if (Flags != 0) {

                    // Use flags to filter the busy type.
                    if (PfnDatabaseLocal[i].Busy.Busy == 0 ||
                        ((Flags & (1 << PfnDatabaseLocal[i].Busy.BusyType)) == 0)) {
                        continue;
                    }
                }

                // Only dump locked pages.
                if (Address == (ULONG)-2) {
                    if (PfnDatabaseLocal[i].Pte.Hard.Valid != 0) {
                        continue;
                    }
                    if ((PfnDatabaseLocal[i].Busy.Busy == 0) ||
                        (PfnDatabaseLocal[i].Busy.LockCount == 0)) {
                        continue;
                    }
                }

                // Only dump free pages.
                if (Address == (ULONG)-3) {
                    if (PfnDatabaseLocal[i].Busy.Busy != 0) {
                        continue;
                    }
                }

                // Only dump physically mapped pages.
                if (Address == (ULONG)-4) {
                    if (PfnDatabaseLocal[i].Pte.Hard.Valid == 0) {
                        continue;
                    }
                }

                DumpPfnEntry(i, &PfnDatabaseLocal[i]);
                printed++;

                if (CheckControlC()) {
                    break;
                }
            }

            dprintf("%08x entries printed\n", printed);

            LocalFree((HLOCAL)PfnDatabaseLocal);
        }

        return;
    }

    //
    // Dump an address's corresponding PFN?
    //

    if (Address >= 0x00010000) {

        PointerPde = DbgGetPdeAddress((PVOID)Address);

        if (!ReadMemory((DWORD)PointerPde,
                        &TempPte,
                        sizeof(MMPTE),
                        &result)) {
            dprintf("unable to read PDE for %p\n", Address);
            return;
        }

        if (TempPte.Hard.Valid == 0) {
            dprintf("PDE not marked valid for %p\n", Address);
            return;
        }

        if (TempPte.Hard.LargePage == 0) {

            PointerPte = DbgGetPteAddress((PVOID)Address);

            if (!ReadMemory((DWORD)PointerPte,
                            &TempPte,
                            sizeof(MMPTE),
                            &result)) {
                dprintf("unable to read PTE for %p\n", Address);
                return;
            }

            if (TempPte.Hard.Valid == 0) {
                dprintf("PTE not marked valid for %p\n", Address);
                return;
            }

            Address = TempPte.Hard.PageFrameNumber;

        } else {

            Address = TempPte.Hard.PageFrameNumber +
                (BYTE_OFFSET_LARGE(Address) >> PAGE_SHIFT);
        }
    }

    //
    // Dump an index.
    //

    PfnDatabase = (PMMPFN)GetNtDebuggerDataValue(MmPfnDatabase);

    if (PfnDatabase == 0) {
        return;
    }

    if (!ReadMemory((DWORD)(&PfnDatabase[Address]),
                    &PfnLocal,
                    sizeof(MMPFN),
                    &result)) {
        dprintf("unable to read PFN %x\n", Address);
        return;
    }

    DumpPfnEntry(Address, &PfnLocal);
}

VOID
DumpPte(
    LPCSTR Label,
    PMMPTE Pte
    )
{
    char *CachingType;

    if (Pte->Hard.Valid != 0) {

        if (Pte->Hard.CacheDisable != 0) {
            CachingType = "UC";
        } else if (Pte->Hard.WriteThrough == 1) {
            CachingType = "WC";
        } else {
            CachingType = "WB";
        }

        dprintf("%s %05x %c%c%c%c%c%c%c%c%c%c%c %s  ",
            Label,
            Pte->Hard.PageFrameNumber,
            Pte->Hard.PersistAllocation ? 'K' : '-',
            Pte->Hard.GuardOrEndOfAllocation ? 'E' : '-',
            Pte->Hard.Global ? 'G' : '-',
            Pte->Hard.LargePage ? 'L' : '-',
            Pte->Hard.Dirty ? 'D' : '-',
            Pte->Hard.Accessed ? 'A' : '-',
            Pte->Hard.CacheDisable ? 'C' : '-',
            Pte->Hard.WriteThrough ? 'T' : '-',
            Pte->Hard.Owner ? 'O' : '-',
            Pte->Hard.Write ? 'W' : 'R',
            Pte->Hard.Valid ? 'V' : '-',
            CachingType);

    } else {
        dprintf("%s invalid %08x   ", Label, Pte->Long);
    }
}

DECLARE_API(pte)
{
    ULONG Address = 0;
    MMPTE TempPte;
    ULONG result;
    char ExprBuf[256] ;

    sscanf(args, "%s", ExprBuf);

    if (ExprBuf[0]) {
        if (IsHexNumber(ExprBuf)) {
            sscanf(ExprBuf, "%lx", &Address) ;
        } else {
            Address = GetExpression(ExprBuf);
            if (Address==0) {
                dprintf("An error occured trying to evaluate the expression\n") ;
                return;
            }
        }
    }

    //
    // Convert a non-PTE section address to it's PTE address.
    //

    if (Address < (ULONG)MiGetPteAddress(0) || Address > (ULONG)MiGetPteAddress(0xFFFFFFFF)) {
        Address = (ULONG)MiGetPteAddress(Address);
    }

    dprintf("va %p:  ", MiGetVirtualAddressMappedByPte(Address));

    if (!ReadMemory((DWORD)MiGetPteAddress(Address),
                    &TempPte,
                    sizeof(MMPTE),
                    &result)) {
        dprintf("\nunable to read PDE for %p\n", Address);
        return;
    }

    DumpPte("PDE", &TempPte);

    if (TempPte.Hard.Valid != 0 && TempPte.Hard.LargePage == 0) {

        if (!ReadMemory((DWORD)Address,
                        &TempPte,
                        sizeof(MMPTE),
                        &result)) {
            dprintf("\nunable to read PTE for %p\n", Address);
            return;
        }

        DumpPte("PTE", &TempPte);
    }

    dprintf("\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\kdexts\object.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    object.c

Abstract:

    WinDbg Extension Api

Author:

    Ramon J San Andres (ramonsa) 5-Nov-1993

Environment:

    User Mode.

Revision History:

--*/


#include "precomp.h"
#pragma hdrstop

typedef PVOID (*ENUM_LIST_ROUTINE)(
                                  IN PLIST_ENTRY ListEntry,
                                  IN PVOID Parameter
                                  );


ULONG EXPRLastDump = 0;

static POBJECT_DIRECTORY ObpRootDirectoryObject = NULL;
static OCHAR             ObjectNameBuffer[ MAX_PATH ];

BOOLEAN
DumpObjectsForType(
                  IN PVOID            pObjectHeader,
                  IN POBJECT_HEADER   ObjectHeader,
                  IN PVOID            Parameter
                  );

PVOID
WalkRemoteList(
              IN PLIST_ENTRY       Head,
              IN ENUM_LIST_ROUTINE EnumRoutine,
              IN PVOID             Parameter
              );

POSTR
GetObjectName(
             PVOID Object
             );


ULONG HighestUserAddress = (ULONG)MM_HIGHEST_USER_ADDRESS;

DECLARE_API( object )

/*++

Routine Description:

    Dump an object manager object.

Arguments:

    args - [TypeName]

Return Value:

    None

--*/
{
    ULONG   ObjectToDump;
    ULONG   NumberOfObjects;
    char ExprBuf[256] ;

    if (!FetchObjectManagerVariables(FALSE)) {
        return;
    }

    ObjectToDump    = EXPRLastDump;

    //
    // If the argument looks like a path, try to chase it.
    //

    if (args[0] == '\\') {

        PVOID object;

        object = FindObjectByName((PUCHAR) args, NULL);

        if (object != NULL) {
            DumpObject("", object, NULL, 0xffffffff);
        } else {
            dprintf("Object %s not found\n", args);
        }
        return;
    }

    //
    // If the argument is -r or -R, reload the cached symbol information
    //

    if (!strcmp(args, "-r")) {
        FetchObjectManagerVariables(TRUE);
        return;
    }

    sscanf(args, "%s", ExprBuf);

    if (ExprBuf[0]) {
        if (IsHexNumber(ExprBuf) || ExprBuf[0] == '-') {
            sscanf(ExprBuf, "%lx", &ObjectToDump) ;
        } else {
            ObjectToDump = GetExpression(ExprBuf);
            if (ObjectToDump==0) {
                dprintf("An error occured trying to evaluate the expression\n") ;
                return;
            }
        }
        DumpObject("", (PVOID)ObjectToDump, NULL, 0xFFFFFFFF);
        return;
    }

    dprintf( "*** invalid syntax.\n" );
    return;
}



DECLARE_API( obja )

/*++

Routine Description:

    Dump an object's attributes

Arguments:

    args -

Return Value:

    None

--*/
{
    OBJECT_STRING ObjectString;
    DWORD dwAddrObja;
    OBJECT_ATTRIBUTES Obja;
    DWORD dwAddrString;
    CHAR Symbol[256];
    LPSTR StringData;
    DWORD Displacement;
    BOOL b;

    //
    // Evaluate the argument string to get the address of
    // the Obja to dump.
    //

    dwAddrObja = GetExpression(args);
    if ( !dwAddrObja ) {
        return;
    }


    //
    // Get the symbolic name of the Obja
    //

    GetSymbol((LPVOID)dwAddrObja,Symbol,&Displacement);

    //
    // Read the obja from the debuggees address space into our
    // own.

    b = ReadMemory(
                  (DWORD)dwAddrObja,
                  &Obja,
                  sizeof(Obja),
                  NULL
                  );
    if ( !b ) {
        return;
    }
    StringData = NULL;
    if ( Obja.ObjectName ) {
        dwAddrString = (DWORD)Obja.ObjectName;
        b = ReadMemory(
                      (DWORD)dwAddrString,
                      &ObjectString,
                      sizeof(ObjectString),
                      NULL
                      );
        if ( !b ) {
            return;
        }

        StringData = (LPSTR)LocalAlloc(
                                      LMEM_ZEROINIT,
                                      ObjectString.Length+sizeof(OBJECT_NULL)
                                      );

        b = ReadMemory(
                      (DWORD)ObjectString.Buffer,
                      StringData,
                      ObjectString.Length,
                      NULL
                      );
        if ( !b ) {
            LocalFree(StringData);
            return;
        }
        ObjectString.Buffer = (POSTR)StringData;
        ObjectString.MaximumLength = ObjectString.Length+(USHORT)sizeof(OBJECT_NULL);
    }

    //
    // We got the object name in ObjectString. StringData is NULL if no name.
    //

    dprintf(
           "Obja %s+%lx at %lx:\n",
           Symbol,
           Displacement,
           dwAddrObja
           );
    if ( StringData ) {
        dprintf("\t%s is " POSTR_FORMATCODE "\n",
                Obja.RootDirectory ? "Relative Name" : "Full Name",
                ObjectString.Buffer
               );
        LocalFree(StringData);
    }
    if ( Obja.Attributes ) {
        if ( Obja.Attributes & OBJ_INHERIT ) {
            dprintf("\tOBJ_INHERIT\n");
        }
        if ( Obja.Attributes & OBJ_PERMANENT ) {
            dprintf("\tOBJ_PERMANENT\n");
        }
        if ( Obja.Attributes & OBJ_EXCLUSIVE ) {
            dprintf("\tOBJ_EXCLUSIVE\n");
        }
        if ( Obja.Attributes & OBJ_CASE_INSENSITIVE ) {
            dprintf("\tOBJ_CASE_INSENSITIVE\n");
        }
        if ( Obja.Attributes & OBJ_OPENIF ) {
            dprintf("\tOBJ_OPENIF\n");
        }
    }
}

BOOLEAN
DumpObjectsForType(
                  IN PVOID            pObjectHeader,
                  IN POBJECT_HEADER   ObjectHeader,
                  IN PVOID            Parameter
                  )
{
    PVOID Object;
    PULONG NumberOfObjects = (PULONG)Parameter;

    *NumberOfObjects += 1;
    Object = (PVOID)&(((POBJECT_HEADER)pObjectHeader)->Body);
    DumpObject( "", Object, NULL, 0xFFFFFFFF );
    return TRUE;
}

BOOLEAN
FetchObjectManagerVariables(
                           BOOLEAN ForceReload
                           )
{
    ULONG        Result;
    DWORD        Addr;
    static BOOL  HaveObpVariables = FALSE;

    if (HaveObpVariables && !ForceReload) {
        return TRUE;
    }

    Addr = GetNtDebuggerData( ObpRootDirectoryObject );
    if ( !Addr ||
         !ReadMemory( Addr,
                      &ObpRootDirectoryObject,
                      sizeof(ObpRootDirectoryObject),
                      &Result) ) {
        dprintf("%08lx: Unable to get value of ObpRootDirectoryObject\n",Addr );
        return FALSE;
    }

    HaveObpVariables = TRUE;
    return TRUE;
}

PVOID
WalkRemoteList(
              IN PLIST_ENTRY       Head,
              IN ENUM_LIST_ROUTINE EnumRoutine,
              IN PVOID             Parameter
              )
{
    ULONG       Result;
    PVOID       Element;
    LIST_ENTRY  ListEntry;
    PLIST_ENTRY Next;

    if ( !ReadMemory( (DWORD)Head,
                      &ListEntry,
                      sizeof( ListEntry ),
                      &Result) ) {
        dprintf( "%08lx: Unable to read list\n", Head );
        return NULL;
    }

    Next = ListEntry.Flink;
    while (Next != Head) {

        if ( !ReadMemory( (DWORD)Next,
                          &ListEntry,
                          sizeof( ListEntry ),
                          &Result) ) {
            dprintf( "%08lx: Unable to read list\n", Next );
            return NULL;
        }

        Element = (EnumRoutine)( Next, Parameter );
        if (Element != NULL) {
            return Element;
        }

        if ( CheckControlC() ) {
            return NULL;
        }

        Next = ListEntry.Flink;
    }

    return NULL;
}


typedef struct _OBJECT_INFO {
    POBJECT_HEADER pObjectHeader;
    OBJECT_HEADER ObjectHeader;
    OBJECT_TYPE ObjectType;
    OBJECT_HEADER_NAME_INFO NameInfo;
    union {
        ULONG PoolTag;
        CHAR TypeName[4];
    };
    OCHAR ObjectName[ 256 ];
    OCHAR FileSystemName[ 32 ];
    CHAR Message[ 256 ];
} OBJECT_INFO, *POBJECT_INFO;



BOOLEAN
GetObjectInfo(
             PVOID Object,
             IN POBJECT_HEADER OptObjectHeader OPTIONAL,
             POBJECT_INFO ObjectInfo
             )
{
    ULONG           Result;
    POBJECT_HEADER_NAME_INFO pNameInfo;
    BOOLEAN         PagedOut;
    OBJECT_STRING   ObjectName;
    POSTR           FileSystemName;
    FILE_OBJECT     FileObject;

    PagedOut = FALSE;
    memset( ObjectInfo, 0, sizeof( *ObjectInfo ) );
    ObjectInfo->pObjectHeader = OBJECT_TO_OBJECT_HEADER( Object );
    if (!ReadMemory( (DWORD)ObjectInfo->pObjectHeader,
                     &ObjectInfo->ObjectHeader,
                     sizeof( ObjectInfo->ObjectHeader ),
                     &Result
                   )
       ) {
        if ((ULONG)Object >= HighestUserAddress && (ULONG)Object < 0xF0000000) {
            sprintf( ObjectInfo->Message, "%08lx: object is paged out.", Object );
            if (!ARGUMENT_PRESENT( OptObjectHeader )) {
                return FALSE;
            }
            ObjectInfo->ObjectHeader = *OptObjectHeader;
            PagedOut = TRUE;
        } else {
            sprintf( ObjectInfo->Message, "%08lx: not a valid object (ObjectHeader invalid)", Object );
            return FALSE;
        }
    }

    if (!ReadMemory( (DWORD)ObjectInfo->ObjectHeader.Type,
                     &ObjectInfo->ObjectType,
                     sizeof( ObjectInfo->ObjectType ),
                     &Result
                   )
       ) {
        sprintf( ObjectInfo->Message, "%08lx: Not a valid object (ObjectType invalid)", Object );
        return FALSE;
    }

    ObjectInfo->PoolTag = ObjectInfo->ObjectType.PoolTag;

    if (PagedOut) {
        return TRUE;
    }

    if (ObjectInfo->PoolTag == 'eliF') {
        if (!ReadMemory( (DWORD)Object,
                         &FileObject,
                         sizeof( FileObject ),
                         &Result
                       )
           ) {
            sprintf( ObjectInfo->Message, "%08lx: unable to read file object for name\n", Object );
        } else {
            ObjectName.Length = 0;
            FileSystemName = GetObjectName( FileObject.DeviceObject );
            if (FileSystemName != NULL) {
                ocscpy( ObjectInfo->FileSystemName, FileSystemName );
            }
        }
    } else {
        pNameInfo = KD_OBJECT_HEADER_TO_NAME_INFO( ObjectInfo->pObjectHeader, &ObjectInfo->ObjectHeader );
        if (pNameInfo == NULL) {
            return TRUE;
        }

        if (!ReadMemory( (DWORD)pNameInfo,
                         &ObjectInfo->NameInfo,
                         sizeof( ObjectInfo->NameInfo ),
                         &Result
                       )
           ) {
            sprintf( ObjectInfo->Message, "*** unable to read object name info at %08x\n", pNameInfo );
            return FALSE;
        }

        ObjectName = ObjectInfo->NameInfo.Name;
    }

    if (ObjectName.Length >= sizeof( ObjectInfo->ObjectName )) {
        ObjectName.Length = sizeof( ObjectInfo->ObjectName ) - sizeof( UNICODE_NULL );
    }

    if (ObjectName.Length != 0) {
        if (!ReadMemory( (DWORD)ObjectName.Buffer,
                         ObjectInfo->ObjectName,
                         ObjectName.Length,
                         &Result
                       )
           ) {
            ocscpy( ObjectInfo->ObjectName, OTEXT("(*** Name not accessable ***)") );
        } else {
            ObjectInfo->ObjectName[ ObjectName.Length / sizeof( OCHAR ) ] = OBJECT_NULL;
        }
    }

    return TRUE;
}


PVOID
FindObjectByName(
                IN PUCHAR Path,
                IN PVOID RootObject
                )
{
    ULONG Result, i, j;
    POBJECT_DIRECTORY pDirectoryObject;
    OBJECT_DIRECTORY DirectoryObject;
    POBJECT_HEADER_NAME_INFO pDirectoryEntry;
    OBJECT_HEADER_NAME_INFO DirectoryEntry;
    OBJECT_INFO ObjectInfo;

    BOOLEAN foundMatch = FALSE;

    PUCHAR nextPath;

    if (RootObject == NULL) {

        if (!FetchObjectManagerVariables(FALSE)) {
            return NULL;
        }

        RootObject = (PVOID) ObpRootDirectoryObject;
    }

    pDirectoryObject = (POBJECT_DIRECTORY)RootObject;

    //
    // See if we've reached the end of the path, at which point we know
    // that RootObject is the object to be dumped.
    //

    if (*Path == '\0') {
        return RootObject;
    }

    //
    // Scan the path looking for another delimiter or for the end of the
    // string.

    nextPath = Path;

    while ((*nextPath != '\0') &&
           (*nextPath != '\\')) {

        nextPath++;
    }

    //
    // if we found a delimeter remove it from the next path and use it to
    // truncate the current path.
    //

    if (*nextPath == '\\') {
        *nextPath = '\0';
        nextPath++;
    }

    //
    // Make sure there's a path node here.  If not, recursively call ourself
    // with the remainder of the path.
    //

    if (*Path == '\0') {
        return FindObjectByName(nextPath, RootObject);
    }

    if (!ReadMemory( (DWORD)pDirectoryObject,
                     &DirectoryObject,
                     sizeof( DirectoryObject ),
                     &Result
                   )
       ) {
        dprintf( "Unable to read directory object at %x\n", RootObject );
        return FALSE;
    }

    for (i=0; i<OB_NUMBER_HASH_BUCKETS; i++) {
        if (DirectoryObject.HashBuckets[ i ] != NULL) {
            pDirectoryEntry = DirectoryObject.HashBuckets[ i ];
            while (pDirectoryEntry != NULL) {

                if (!ReadMemory( (DWORD)pDirectoryEntry,
                                 &DirectoryEntry,
                                 sizeof( DirectoryEntry ),
                                 &Result
                               )
                   ) {
                    // dprintf( "Unable to read directory entry at %x\n", pDirectoryEntry );
                    break;
                }

                if (!GetObjectInfo( OBJECT_HEADER_NAME_INFO_TO_OBJECT(pDirectoryEntry), NULL, &ObjectInfo)) {
                    // dprintf( " - %s\n", ObjectInfo.Message );
                } else {
                    foundMatch = TRUE;

                    for (j = 0;
                        (Path[j] != '\0') && (ObjectInfo.ObjectName[j] != L'\0');
                        j++) {

                        if (tolower(Path[j]) !=
                            towlower(ObjectInfo.ObjectName[j])) {
                            foundMatch = FALSE;
                            break;
                        }

                    }

                    if (foundMatch) {

                        if ((Path[j] == '\0') &&
                            (ObjectInfo.ObjectName[j] == L'\0')) {

                            return FindObjectByName(nextPath, OBJECT_HEADER_NAME_INFO_TO_OBJECT(pDirectoryEntry));
                        }

                    }

                }
                pDirectoryEntry = DirectoryEntry.ChainLink;
            }
        }
    }

    return NULL;
}

VOID
DumpDirectoryObject(
                   IN char     *Pad,
                   IN PVOID    Object
                   )
{
    ULONG Result, i;
    POBJECT_DIRECTORY pDirectoryObject = (POBJECT_DIRECTORY)Object;
    OBJECT_DIRECTORY DirectoryObject;
    POBJECT_HEADER_NAME_INFO pDirectoryEntry;
    OBJECT_HEADER_NAME_INFO DirectoryEntry;
    OBJECT_INFO ObjectInfo;

    if (!ReadMemory( (DWORD)pDirectoryObject,
                     &DirectoryObject,
                     sizeof( DirectoryObject ),
                     &Result
                   )
       ) {
        dprintf( "Unable to read directory object at %x\n", Object );
        return;
    }

    for (i=0; i<OB_NUMBER_HASH_BUCKETS; i++) {
        if (DirectoryObject.HashBuckets[ i ] != NULL) {
            dprintf( "%s    HashBucket[ %02u ]: ",
                     Pad,
                     i
                   );
            pDirectoryEntry = DirectoryObject.HashBuckets[ i ];
            while (pDirectoryEntry != NULL) {
                if (!ReadMemory( (DWORD)pDirectoryEntry,
                                 &DirectoryEntry,
                                 sizeof( DirectoryEntry ),
                                 &Result
                               )
                   ) {
                    dprintf( "Unable to read directory entry at %x\n", pDirectoryEntry );
                    break;
                }

                if (pDirectoryEntry != DirectoryObject.HashBuckets[ i ]) {
                    dprintf( "%s                      ", Pad );
                }
                dprintf( "%x", OBJECT_HEADER_NAME_INFO_TO_OBJECT(pDirectoryEntry) );

                if (!GetObjectInfo( OBJECT_HEADER_NAME_INFO_TO_OBJECT(pDirectoryEntry), NULL, &ObjectInfo)) {
                    dprintf( " - %s\n", ObjectInfo.Message );
                } else {
                    dprintf( " %c%c%c%c '" POSTR_FORMATCODE "'\n",
                            ObjectInfo.TypeName[0],
                            ObjectInfo.TypeName[1],
                            ObjectInfo.TypeName[2],
                            ObjectInfo.TypeName[3],
                            ObjectInfo.ObjectName );
                }
                pDirectoryEntry = DirectoryEntry.ChainLink;
            }
        }
    }
}

VOID
DumpSymbolicLinkObject(
                      IN char     *Pad,
                      IN PVOID    Object
                      )
{
    ULONG Result, i;
    POBJECT_SYMBOLIC_LINK pSymbolicLinkObject = (POBJECT_SYMBOLIC_LINK)Object;
    OBJECT_SYMBOLIC_LINK SymbolicLinkObject;
    POSTR s, FreeBuffer;
    OBJECT_INFO ObjectInfo;

    if (!ReadMemory( (DWORD)pSymbolicLinkObject,
                     &SymbolicLinkObject,
                     sizeof( SymbolicLinkObject ),
                     &Result
                   )
       ) {
        dprintf( "Unable to read symbolic link object at %x\n", Object );
        return;
    }

    FreeBuffer = s = HeapAlloc( GetProcessHeap(),
                                HEAP_ZERO_MEMORY,
                                SymbolicLinkObject.LinkTarget.Length + sizeof( UNICODE_NULL )
                              );
    if (s == NULL ||
        !ReadMemory( (DWORD)SymbolicLinkObject.LinkTarget.Buffer,
                     s,
                     SymbolicLinkObject.LinkTarget.Length,
                     &Result
                   )
       ) {
        s = OTEXT("*** target string unavailable ***");
    }
    dprintf( "%s    Target String is '" POSTR_FORMATCODE "'\n",
             Pad,
             s
           );

    if (!GetObjectInfo( SymbolicLinkObject.LinkTargetObject, NULL, &ObjectInfo)) {
        dprintf( "%s    Target Object is %08lx - %s\n",
                Pad,
                SymbolicLinkObject.LinkTargetObject,
                ObjectInfo.Message);
    } else {
        dprintf( "%s    Target Object is %08lx %c%c%c%c '" POSTR_FORMATCODE "'\n",
                Pad,
                SymbolicLinkObject.LinkTargetObject,
                ObjectInfo.TypeName[0],
                ObjectInfo.TypeName[1],
                ObjectInfo.TypeName[2],
                ObjectInfo.TypeName[3],
                ObjectInfo.ObjectName );
    }

    if (FreeBuffer != NULL) {
        HeapFree( GetProcessHeap(), 0, FreeBuffer );
    }

    return;
}


BOOLEAN
DumpObject(
          IN char     *Pad,
          IN PVOID    Object,
          IN POBJECT_HEADER OptObjectHeader OPTIONAL,
          IN ULONG    Flags
          )
{
    OBJECT_INFO ObjectInfo;

    if (!GetObjectInfo( Object, OptObjectHeader, &ObjectInfo)) {
        dprintf( "KD: %s\n", ObjectInfo.Message );
        return FALSE;
    }
    dprintf( "Object: %08lx  Type: (%08lx) %c%c%c%c\n",
             Object,
             ObjectInfo.ObjectHeader.Type,
             ObjectInfo.TypeName[0],
             ObjectInfo.TypeName[1],
             ObjectInfo.TypeName[2],
             ObjectInfo.TypeName[3]
           );
    dprintf( "    ObjectHeader: %08lx\n",
             ObjectInfo.pObjectHeader
           );

    if (!(Flags & 0x1)) {
        return TRUE;
    }

    dprintf( "%s    HandleCount: %u  PointerCount: %u\n",
             Pad,
             ObjectInfo.ObjectHeader.HandleCount,
             ObjectInfo.ObjectHeader.PointerCount
           );

    if (ObjectInfo.ObjectName[ 0 ] != UNICODE_NULL ||
        ObjectInfo.NameInfo.Directory != NULL
       ) {
        dprintf( "%s    Directory Object: %08lx  Name: " POSTR_FORMATCODE,
                 Pad,
                 ObjectInfo.NameInfo.Directory,
                 ObjectInfo.ObjectName
               );
        if (ObjectInfo.FileSystemName[0] != UNICODE_NULL) {
            dprintf( " {" POSTR_FORMATCODE "}\n", ObjectInfo.FileSystemName );
        } else {
            dprintf( "\n" );
        }
    }

    if ((Flags & 0x8)) {
        if (ObjectInfo.PoolTag == 'eriD') {
            DumpDirectoryObject( Pad, Object );
        } else if (ObjectInfo.PoolTag == 'bmyS') {
            DumpSymbolicLinkObject( Pad, Object );
        }
    }

    return TRUE;
}


POSTR
GetObjectName(
             PVOID Object
             )
{
    ULONG           Result;
    POBJECT_HEADER  pObjectHeader;
    OBJECT_HEADER   ObjectHeader;
    OBJECT_STRING   ObjectName;

    POBJECT_HEADER_NAME_INFO pNameInfo;
    OBJECT_HEADER_NAME_INFO NameInfo;

    pObjectHeader = OBJECT_TO_OBJECT_HEADER( Object );
    if ( !ReadMemory( (DWORD)pObjectHeader,
                      &ObjectHeader,
                      sizeof( ObjectHeader ),
                      &Result) ) {
        if ((ULONG)Object >= HighestUserAddress && (ULONG)Object < 0xF0000000) {
            soprintf( ObjectNameBuffer, OTEXT("(%08lx: object is paged out)"), Object );
            return ObjectNameBuffer;
        } else {
            soprintf( ObjectNameBuffer, OTEXT("(%08lx: invalid object header)"), Object );
            return ObjectNameBuffer;
        }
    }

    pNameInfo = KD_OBJECT_HEADER_TO_NAME_INFO( pObjectHeader, &ObjectHeader );
    if (pNameInfo == NULL) {
        return NULL;
    }

    if ( !ReadMemory( (DWORD)pNameInfo,
                      &NameInfo,
                      sizeof( NameInfo ),
                      &Result) ) {
        dprintf( "%08lx: Unable to read object name info\n", pNameInfo );
        return NULL;
    }

    ObjectName = NameInfo.Name;
    if (ObjectName.Length == 0 || ObjectName.Buffer == NULL) {
        return NULL;
    }

    if ( !ReadMemory( (DWORD)ObjectName.Buffer,
                      ObjectNameBuffer,
                      ObjectName.Length,
                      &Result) ) {
        soprintf( ObjectNameBuffer, OTEXT("(%08lx: name not accessable)"), ObjectName.Buffer );
    } else {
        ObjectNameBuffer[ ObjectName.Length / sizeof( OCHAR ) ] = OBJECT_NULL;
    }

    return ObjectNameBuffer;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\kdexts\patchp.h ===
//
// The following are stuctures for the category/patch lists...
//
typedef enum { LISTSTYLE_NONE, LISTSTYLE_EXCLUSIVE, LISTSTYLE_NON_EXCLUSIVE } LIST_STYLE ;
typedef enum { ENTRYTYPE_PATCH, ENTRYTYPE_PATCH_COLLECTION } ENTRY_TYPE ;

struct _PATCH_ENTRY ;
struct _PATCH_CATEGORY ;
typedef struct _PATCH_ENTRY PATCH_ENTRY, *PPATCH_ENTRY ;
typedef struct _PATCH_CATEGORY PATCH_CATEGORY, *PPATCH_CATEGORY ;

struct _PATCH_ENTRY {
   ENTRY_TYPE EntryType ;
   ULONG WalkFlags ;
   PVOID WalkNext ;
   char *Action ;
   char *ShortcutName ;
   char *MenuDescription ;
   char *LengthyDescription ;
   PPATCH_ENTRY Parent ;
   PPATCH_ENTRY Sibling ;
   PPATCH_ENTRY Child ;
   LIST_STYLE ChildStyle ;
} ;

struct _PATCH_CATEGORY {   
   char *CategoryName ;
   PPATCH_CATEGORY Sibling ;
   PPATCH_ENTRY Child ;
   LIST_STYLE ChildStyle ;
} ;

//
// This structure manages the a given patch tree
//
typedef struct {
   PPATCH_CATEGORY FirstCategory ;
   PPATCH_CATEGORY CurrentCategory ;
   BOOL InCategory ;
   PPATCH_ENTRY LastEntry ;
   PPATCH_ENTRY LastParent ;

} PATCH_TREE, *PPATCH_TREE ;

//
// The following functions build up an patch tree.
//
VOID
PatchCategoryBegin(
   PPATCH_TREE PatchTree,
   char *CategoryName
   ) ;

VOID
PatchCategoryEnd(
   PPATCH_TREE PatchTree
   );

VOID
PatchSiblingListBegin(
   PPATCH_TREE PatchTree,
   LIST_STYLE  ListStyle
   );

VOID
PatchSiblingListEnd(
   PPATCH_TREE PatchTree
   );

VOID
PatchDeclareEntry(
   PPATCH_TREE PatchTree,
   char *Action,
   char *ShortCut,
   char *MenuDescription,
   char *LengthyDescription
   );

VOID
PatchDeclareCollection(
   PPATCH_TREE PatchTree,
   char *Action,
   char *ShortCut,
   char *MenuDescription,
   char *LengthyDescription
   );

VOID
PatchBuildTree(
   PPATCH_TREE PatchTree
   );

extern PPATCH_TREE gpPatchTree ;

//
// This function is a printf to a malloc'd string
//
char *
PatchMallocSprintf(
   char *szFormat, ...
   ) ;

//
// The following macro's turn an "patch table" into a series of calls
// to the table building functions.
//
#define NO_SHORTCUT "###"

#define BEGIN_CATEGORY(CategoryName) \
   PatchCategoryBegin(gpPatchTree, CategoryName)

// And a hack so that Action and PatchList may be NULL
#define PatchMallocSprintfNULL NULL

#define DECLARE_ENTRY(Action, ShortCut, MenuDescription, LengthyDescription) \
   {\
      char *szOutputAction = PatchMallocSprintf##Action ; \
      PatchDeclareEntry(gpPatchTree, szOutputAction, \
                        " " ShortCut " ", MenuDescription, \
                        LengthyDescription) ;\
   }

#define DECLARE_COLLECTION(PatchList, ShortCut, MenuDescription, LengthyDescription) \
   {\
      char *szOutputList = PatchMallocSprintf##PatchList ; \
      PatchDeclareCollection(gpPatchTree, szOutputList, \
                             " " ShortCut " ", MenuDescription, \
                             LengthyDescription) ;\
   }

#define BEGIN_SIBLING_LIST(Style) \
   PatchSiblingListBegin(gpPatchTree, Style) 

#define END_SIBLING_LIST() \
   PatchSiblingListEnd(gpPatchTree) 

#define END_CATEGORY() \
   PatchCategoryEnd(gpPatchTree)

//
// When walking entries in an patch tree, we will use callback functions
// of the following type. And the walking functions follow afterwards...
//
typedef VOID (*PPATCH_WALKCALLBACK)(PPATCH_CATEGORY, PPATCH_ENTRY, ULONG Depth, PVOID Context) ;

VOID
PatchTreeWalk(
   PPATCH_TREE PatchTree,
   PPATCH_WALKCALLBACK PreCallback,
   PPATCH_WALKCALLBACK PostCallback,
   PVOID Context,
   BOOL ZeroWalkFlags
   );

VOID
PatchTreeWalkHelper(
   PPATCH_ENTRY Entry,
   PPATCH_WALKCALLBACK PreCallback,
   PPATCH_WALKCALLBACK PostCallback,
   ULONG Depth,
   PVOID Context
   );

VOID 
PatchTreeWalkZeroFlags(
   PPATCH_CATEGORY  Category,
   PPATCH_ENTRY     Entry,
   ULONG            Depth,
   PVOID            Context
   );

//
// Useful tree functions
//
VOID
PatchTreeFree(
   PPATCH_TREE PatchTree
   );

VOID
PatchTreePrint(
   PPATCH_TREE PatchTree
   );

//
// The following definitions control a selected "set" of patchs.
// 
typedef struct {
   char          *TokenList ;
   PPATCH_ENTRY  PatchEntry ;
   BOOL          GenReg ;
   BOOL          InProgress ;
   PPATCH_TREE   PatchTree ;
} PATCHSET, *PPATCHSET ;

VOID 
PatchSetBuild(
   PPATCH_TREE PatchTree,
   char *szCommandLine,
   PPATCHSET PatchSet
   );

VOID 
PatchSetBuildTreeCallback(
   PPATCH_CATEGORY  Category,
   PPATCH_ENTRY     Entry,
   ULONG            Depth,
   PVOID            Context
   );

VOID 
PatchSetBuildTreeCallback2(
   PPATCH_ENTRY     Entry,
   PPATCHSET        PatchSet,
   ENTRY_TYPE       EntryType,
   BOOL             IsQuestion
   );

VOID
PatchSetPrint(
   PPATCHSET PatchSet
   );

//
// This group of definitions describe patches to binaries. Note that setting
// a variable to a given variable is represented by AND'ing the variable with
// zero and following up with an or of the appropriate value.
//
typedef struct _DRIVERENTRY DRIVERENTRY, *PDRIVERENTRY ;
typedef struct _DRIVERMOD DRIVERMOD, *PDRIVERMOD ;

struct _DRIVERENTRY {
   char szModuleName[256] ;
   ULONG BaseAddress ;
   ULONG Checksum ;
   PDRIVERMOD FirstPatch ;
   PDRIVERENTRY Sibling ;
} ;

#define PATCHFLAG_BYTE_PATCH        0x00000000
#define PATCHFLAG_WORD_PATCH        0x00000001
#define PATCHFLAG_DWORD_PATCH       0x00000003
#define PATCHFLAG_FIXUPS_COMPLETE   0x00000010
#define PATCHVALUE_INVALID          0xFFFFFFFF

#define APPLIED_PATCH_SIZE(x) (((x)->PatchFlags)&0x7)

struct _DRIVERMOD {
   char      szSymbolicName[512] ;
   ULONG_PTR ulModuleOffset ;
   ULONG     PatchFlags ;
   ULONG     AndPatch ;
   ULONG     OrPatch ;
   PDRIVERMOD Sibling ;
} ;

PDRIVERENTRY
ModSetBuild(
   PPATCHSET PatchSet,
   BOOL      DebugMode
   );

BOOL
ModEntryParse(
   IN     char *Action, 
   IN     BOOL DebugMode,
   IN OUT char *szModuleDestination, 
   IN OUT PDRIVERMOD DriverPatchDest,
   IN OUT PULONG pulMore
   );

VOID
ModEntryMerge(
   PDRIVERMOD DriverPatchDest,
   PDRIVERMOD DriverPatchNew
   );

VOID
ModSetPrint(
   PDRIVERENTRY DriverPatchDest
   );

BOOL
ModSetGetDriverInfo(
   char *szModuleName,
   PVOID *ModuleBaseAddress,
   PULONG Checksum
   );

VOID
ModSetFixupAddresses(
   PDRIVERENTRY DriverPatchHead
   );

BOOL
ModSetApply(
   PDRIVERENTRY DriverPatchHead
   );

VOID 
PatchTreeMenuPrintCallback(
   PPATCH_CATEGORY  Category,
   PPATCH_ENTRY     Entry,
   ULONG            Depth,
   PVOID            Context
   );

VOID
PatchTreeMenuPrint(
   PPATCH_TREE PatchTree
   );
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\kdexts\patchbld.c ===
#include "precomp.h"
#include "patchp.h"
#pragma hdrstop

#define PATCHASSERT(x) { if (!(x)) { dprintf("Assertion on file %s line %d\n", __FILE__, __LINE__); ASSERT(x); } }

//
// These functions build the assertion tree.
//

PPATCH_TREE gpPatchTree ;

VOID
PatchCategoryBegin(
   PPATCH_TREE PatchTree,
   char *CategoryName
   )
{
   PPATCH_CATEGORY newCategory ;

   PATCHASSERT(!PatchTree->InCategory) ;
   PatchTree->InCategory = TRUE ;
   newCategory = (PPATCH_CATEGORY) malloc(sizeof(PATCH_CATEGORY)) ;
   if (newCategory) {
      newCategory->CategoryName = CategoryName ;
      newCategory->ChildStyle = LISTSTYLE_NONE ;
      newCategory->Child = NULL ;
      newCategory->Sibling = NULL ;
      if (PatchTree->CurrentCategory) {
         PatchTree->CurrentCategory->Sibling = newCategory ;
      } else {
         PatchTree->FirstCategory = newCategory ;
      }
      PatchTree->CurrentCategory = newCategory ;
   }
}

VOID
PatchCategoryEnd(
   PPATCH_TREE PatchTree
   )
{
   PATCHASSERT(PatchTree->InCategory) ;
   PatchTree->InCategory = FALSE ;

   //
   // We don't zero out the CurrentCategory as the next category will be
   // linked into the list through it.
   //
}

VOID
PatchSiblingListBegin(
   PPATCH_TREE PatchTree,
   LIST_STYLE ListStyle
   )
{
   PATCHASSERT(PatchTree->InCategory) ;
   //dprintf("[ %x %x\n", PatchTree, PatchTree->LastEntry);
   if (PatchTree->LastEntry == NULL) {
       PATCHASSERT(PatchTree->CurrentCategory->ChildStyle == LISTSTYLE_NONE) ;
       PatchTree->CurrentCategory->ChildStyle = ListStyle ;
   } else {
       PATCHASSERT(PatchTree->LastEntry->ChildStyle == LISTSTYLE_NONE) ;
       PatchTree->LastEntry->ChildStyle = ListStyle ;
   }
   PatchTree->LastParent = PatchTree->LastEntry ;
   PatchTree->LastEntry = NULL ;
}

VOID
PatchSiblingListEnd(
   PPATCH_TREE PatchTree
   )
{
   PATCHASSERT(PatchTree->InCategory) ;
   PATCHASSERT(PatchTree->CurrentCategory->Child) ;

   //dprintf("] %x of %x\n", PatchTree, PatchTree->LastParent);
   if (PatchTree->LastParent == NULL) {
       PATCHASSERT(PatchTree->CurrentCategory->ChildStyle != LISTSTYLE_NONE) ;
   } else {
       PATCHASSERT(PatchTree->LastParent->ChildStyle != LISTSTYLE_NONE) ;
   }

   PATCHASSERT(PatchTree->LastEntry) ;
   PatchTree->LastEntry = PatchTree->LastParent ;
   if (PatchTree->LastParent) {
      PatchTree->LastParent = PatchTree->LastParent->Parent ;
   }
}

char *
PatchMallocSprintf(
   char *szFormat, ...
   )
{
   va_list arglist;
   char Buffer[1024], *szReturn ;
   int cb;

   va_start(arglist, szFormat);

   cb = _vsnprintf(Buffer, sizeof(Buffer), szFormat, arglist);
   if (cb == -1) {             // detect buffer overflow
      Buffer[sizeof(Buffer) - 1] = '\0';
      cb = sizeof(Buffer)-1 ;
   }
   szReturn = malloc(cb+1) ;
   memcpy(szReturn, Buffer, cb+1) ;
   return szReturn ;
}

VOID
PatchInsertEntry(
   PPATCH_TREE PatchTree,
   PPATCH_ENTRY NewEntry
   )
{
   PATCHASSERT(PatchTree->InCategory) ;

   NewEntry->Sibling = NULL ;
   NewEntry->Child = NULL ;
   if (PatchTree->LastEntry) {
      PatchTree->LastEntry->Sibling = NewEntry ;
      NewEntry->Parent = PatchTree->LastEntry->Parent ;
   } else {
      NewEntry->Parent = PatchTree->LastParent ;
      if (PatchTree->LastParent) {
         PatchTree->LastParent->Child = NewEntry ;
      } else {
         PatchTree->CurrentCategory->Child = NewEntry ;
      }
   }
   PatchTree->LastEntry = NewEntry ;
}

VOID
PatchDeclareEntry(
   PPATCH_TREE PatchTree,
   char *Action,
   char *ShortCut,
   char *MenuDescription,
   char *LengthyDescription
   )
{
   PPATCH_ENTRY newEntry ;

   newEntry = (PPATCH_ENTRY) malloc(sizeof(PATCH_ENTRY)) ;
   if (newEntry) {
      newEntry->EntryType = ENTRYTYPE_PATCH ;
      newEntry->Action = Action ;
      if (!strcmp(ShortCut, " " NO_SHORTCUT " ")) {
         newEntry->ShortcutName = NULL ;
      } else {
         newEntry->ShortcutName = ShortCut ;
      }
      newEntry->MenuDescription = MenuDescription ;
      newEntry->LengthyDescription = LengthyDescription ;
      newEntry->ChildStyle = LISTSTYLE_NONE ;
      PatchInsertEntry(PatchTree, newEntry) ;
   } else {
      free(Action) ;
   }
}

VOID
PatchDeclareCollection(
   PPATCH_TREE PatchTree,
   char *Action,
   char *ShortCut,
   char *MenuDescription,
   char *LengthyDescription
   )
{
   PPATCH_ENTRY newEntry ;

   newEntry = (PPATCH_ENTRY) malloc(sizeof(PATCH_ENTRY)) ;
   if (newEntry) {
      newEntry->EntryType = ENTRYTYPE_PATCH_COLLECTION ;
      newEntry->Action = Action ;
      if (!strcmp(ShortCut, " " NO_SHORTCUT " ")) {
         newEntry->ShortcutName = NULL ;
      } else {
         newEntry->ShortcutName = ShortCut ;
      }
      newEntry->MenuDescription = MenuDescription ;
      newEntry->LengthyDescription = LengthyDescription ;
      newEntry->ChildStyle = LISTSTYLE_NONE ;
      PatchInsertEntry(PatchTree, newEntry) ;
   } else {
      free(Action) ;
   }
}

VOID
PatchBuildTree(
   PPATCH_TREE pTree
   )
{
   //
   // Initialize the Tree
   //
   memset(pTree, 0, sizeof(PATCH_TREE)) ;

   //
   // This is the global to include into
   //
   gpPatchTree = pTree ;

   //
   // Generate the code to read the table...
   //
   #include "patch.h"
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\kdexts\physical.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    physical.c

Abstract:

    WinDbg Extension Api

Author:

    Wesley Witt (wesw) 15-Aug-1993

Environment:

    User Mode.

Revision History:

--*/


#include "precomp.h"
#pragma hdrstop


#define MAX_PHYSICAL_MEMORY_FRAGMENTS 20

typedef struct _PHYSICAL_MEMORY_RUN {
    PFN_NUMBER BasePage;
    PFN_NUMBER PageCount;
} PHYSICAL_MEMORY_RUN, *PPHYSICAL_MEMORY_RUN;

typedef struct _PHYSICAL_MEMORY_DESCRIPTOR {
    ULONG NumberOfRuns;
    PFN_NUMBER NumberOfPages;
    PHYSICAL_MEMORY_RUN Run[1];
} PHYSICAL_MEMORY_DESCRIPTOR, *PPHYSICAL_MEMORY_DESCRIPTOR;


DECLARE_API( db )

/*++

Routine Description:

    Does a read of 16 ULONGS from the physical memory of the target maching

Arguments:

    args - Supplies physical address

Return Value:

    None.

--*/

{
#define NumberBytesToRead 32*4

    static ULONG64 LastAddress = 0;
    ULONG64 Address = 0;
    UCHAR Buffer[NumberBytesToRead];
    ULONG ActualRead;
    UCHAR hexstring[80];
    UCHAR bytestring[40];
    UCHAR ch, *p;
    int cnt, d;

    if(*args == '\0') {
        Address=LastAddress;
    } else {
        sscanf(args,"%I64x",&Address);
        Address &= (~0x3);      // Truncate to dword boundary
        LastAddress=Address;
    }
    ReadPhysical(Address,Buffer,sizeof(Buffer),&ActualRead);
    if (ActualRead != sizeof(Buffer)) {
        dprintf("Physical memory read failed\n");
    } else {
        for(cnt=0;cnt<NumberBytesToRead;cnt+=16) {
            p = hexstring + sprintf(hexstring, "#%12I64x  ",Address+cnt);
            for (d=0; d < 16; d++) {
                ch = Buffer[cnt+d];
                p += sprintf (p, "%02lx", ch);
                *(p++) = d == 7 ? '-' : ' ';
                if (ch < 0x20 || ch > 0x7e) {
                    ch = '.';
                }
                bytestring[d] = ch;
            }

            bytestring[d] = '\0';
            dprintf("%s %s\n", hexstring, bytestring);
        }
        LastAddress += sizeof(Buffer);
    }
}

DECLARE_API( dd )

/*++

Routine Description:

    Does a read of 16 ULONGS from the physical memory of the target maching

Arguments:

    args - Supplies physical address

Return Value:

    None.

--*/

{
#define NumberToRead 32

    static ULONG64 LastAddress = 0;
    ULONG64 Address = 0;
    ULONG Buffer[NumberToRead];
    ULONG ActualRead;
    int cnt;

    if(*args == '\0') {
        Address=LastAddress;
    } else {
        sscanf(args,"%I64x",&Address);
        Address &= (~0x3);      // Truncate to dword boundary
        LastAddress=Address;
    }
    ReadPhysical(Address,Buffer,sizeof(Buffer),&ActualRead);
    if (ActualRead != sizeof(Buffer)) {
        dprintf("Physical memory read failed\n");
    } else {
        for(cnt=0;cnt<NumberToRead;cnt+=4) {
            dprintf("#%12I64x  ",Address+(cnt*sizeof(ULONG)));
            dprintf("%08lx ",Buffer[cnt]);
            dprintf("%08lx ",Buffer[cnt+1]);
            dprintf("%08lx ",Buffer[cnt+2]);
            dprintf("%08lx\n",Buffer[cnt+3]);
        }
        LastAddress+=sizeof(Buffer);
    }
}


DECLARE_API( ed )

/*++

Routine Description:

    Writes a sequence of ULONGs into a given physical address on the
    target machine.

Arguments:

    arg - Supplies both the target address and the data in the form of
          "PHYSICAL_ADDRESS ULONG [ULONG, ULONG,...]"

Return Value:

    None.

--*/

{
    ULONG64 Address = 0;
    ULONG Buffer;
    ULONG ActualWritten;
    PUCHAR NextToken;

    sscanf(args,"%I64x",&Address);

    strtok((PSTR)args," \t,");      // The first token is the address

    // Since we're picking off one ULONG at a time, we'll make
    // one DbgKdWritePhysicalMemoryAddress call per ULONG.  This
    // is slow, but easy to code.
    while((NextToken=strtok(NULL," \t,")) != NULL) {
        sscanf(NextToken,"%lx",&Buffer);
        WritePhysical(Address,&Buffer,sizeof(Buffer),&ActualWritten);
        Address+=sizeof(Buffer);
    }
}


DECLARE_API( eb )

/*++

Routine Description:

    Writes a sequence of BYTEs into a given physical address on the
    target machine.

Arguments:

    arg - Supplies both the target address and the data in the form of
          "PHYSICAL_ADDRESS ULONG [ULONG, ULONG,...]"

Return Value:

    None.

--*/

{
    ULONG64 Address = 0;
    ULONG Buffer;
    UCHAR c;
    ULONG ActualWritten;
    PUCHAR NextToken;

    sscanf(args,"%I64x",&Address);

    strtok((PSTR)args," \t,");      // The first token is the address

    // Since we're picking off one BYTE at a time, we'll make
    // one DbgKdWritePhysicalMemoryAddress call per BYTE.  This
    // is slow, but easy to code.
    while((NextToken=strtok(NULL," \t,")) != NULL) {
        sscanf(NextToken,"%lx",&Buffer);
        c = (UCHAR)Buffer;
        WritePhysical(Address,&c,sizeof(UCHAR),&ActualWritten);
        Address+=sizeof(UCHAR);
    }
}


DECLARE_API( chklowmem )

/*++

Routine Description:

    Calls an Mm function that checks if the physical pages
    below 4Gb have a required fill pattern for PAE systems
    booted with /LOWMEM switch.

Arguments:

    None.

Return Value:

    None.

--*/
{
    dprintf ("Checking the low 4GB of RAM for required fill pattern. \n");
    dprintf ("Please wait (verification takes approx. 20s) ...\n");

    Ioctl (IG_LOWMEM_CHECK, NULL, 0);

    dprintf ("Lowmem check done.\n");
}


/////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////// !search
/////////////////////////////////////////////////////////////////////

//
//  Kernel variable modification functions.
//


ULONG 
ReadValue (
    ULONG Address
    )
{
    ULONG Value = 0;
    ULONG BytesRead;

    if (! ReadMemory (Address, &Value, sizeof Value, &BytesRead)) {
        dprintf ("Search: read error \n");
    }

    return Value;
}

VOID
WriteValue (
    ULONG Address,
    ULONG Value
    )
{
    ULONG BytesWritten; 

    if (! WriteMemory (Address, &Value, sizeof Value, &BytesWritten)) {
        dprintf ("Search: write error \n");
    }
}
            
ULONG_PTR 
ReadPointer (
    ULONG_PTR Address
    )
{
    ULONG_PTR Value = 0;
    ULONG BytesRead;

    if (! ReadMemory (Address, &Value, sizeof Value, &BytesRead)) {
        dprintf ("Search: read error \n");
    }

    return Value;
}

VOID
WritePointer (
    ULONG_PTR Address,
    ULONG_PTR Value
    )
{
    ULONG BytesWritten;

    if (! WriteMemory (Address, &Value, sizeof Value, &BytesWritten)) {
        dprintf ("Search: write error \n");
    }
}

BOOLEAN
SearchIsSystemPageFrame (
    PFN_NUMBER PageFrameIndex
    );

PPHYSICAL_MEMORY_DESCRIPTOR
SearchGetSystemMemoryDescriptor (
    VOID
    );

ULONG_PTR 
SearchConvertPageFrameToVa (
    PFN_NUMBER PageFrameIndex,
    PULONG Flags
    );

#define SEARCH_VA_PROTOTYPE_ADDRESS     0x0001
#define SEARCH_VA_NORMAL_ADDRESS        0x0002
#define SEARCH_VA_LARGE_PAGE_ADDRESS    0x0004
#define SEARCH_VA_UNKNOWN_TYPE_ADDRESS  0x0008

//
// PAE independent functions from p_i386\pte.c
//

#if defined(_X86_) || defined(_X86PAE_)
PMMPTE
DbgGetPdeAddress(
    IN PVOID VirtualAddress
    );

PMMPTE
DbgGetPteAddress(
    IN PVOID VirtualAddress
    );
#endif // #if defined(_X86_) || defined(_X86PAE_)



DECLARE_API( search )

/*++

Routine Description:

    This routine triggers a search within a given physical
    memory range for a pointer. The hits are defined by
    an interval (below and above the pointer value) and also
    by a Hamming distance equal to one (only on bit different).

Arguments:

    None.
    
Return Value:

    None.

--*/
{
    const ULONG SEARCH_SYMBOL_CHECK = 0xABCDDCBA;

    ULONG_PTR KdpSearchPageHits;
    ULONG_PTR KdpSearchPageHitOffsets;
    ULONG_PTR KdpSearchPageHitIndex;

    ULONG_PTR KdpSearchCheckPoint;
    ULONG_PTR KdpSearchInProgress;

    ULONG_PTR KdpSearchStartPageFrame;
    ULONG_PTR KdpSearchEndPageFrame;

    ULONG_PTR KdpSearchAddressRangeStart;
    ULONG_PTR KdpSearchAddressRangeEnd;

    ULONG_PTR MmLowestPhysicalPage;
    ULONG_PTR MmHighestPhysicalPage;

    ULONG_PTR PageFrame;
    ULONG_PTR StartPage;
    ULONG_PTR EndPage;
    ULONG_PTR RunStartPage;
    ULONG_PTR RunEndPage;
    ULONG RunIndex;

    BOOLEAN RequestForInterrupt;
    BOOLEAN RequestAllOffsets;
    BOOLEAN RawSearch;
    ULONG Hits;
    ULONG LastHits;
    ULONG Index;
    ULONG_PTR PfnHit;
    ULONG_PTR VaHit;
    ULONG VaFlags;
    ULONG PfnOffset;
    ULONG PfnValue;
    ULONG_PTR AddressStart;
    ULONG_PTR AddressEnd;
    ULONG DefaultRange;
    PPHYSICAL_MEMORY_DESCRIPTOR MemoryDescriptor;
    
    ULONG_PTR ParamAddress;
    ULONG_PTR ParamDelta;
    ULONG_PTR ParamStart;
    ULONG_PTR ParamEnd;

    RequestForInterrupt = FALSE;
    RequestAllOffsets = FALSE;
    RawSearch = FALSE;

    DefaultRange = 128;

    ParamAddress = 0;
    ParamDelta = 0;
    ParamStart = 0;
    ParamEnd = 0;
    
    //
    // Help requested ?
    //

    if (strstr (args, "?") != 0) {

        dprintf ("!search ADDRESS [DELTA [START_PFN END_PFN]]                     \n");
        dprintf ("                                                                \n");
        dprintf ("Search the physical pages in range [START_PFN..END_PFN]         \n");
        dprintf ("for ULONG_PTRs with values in range ADDRESS+/-DELTA or values   \n");
        dprintf ("that differ in only one bit position from ADDRESS.              \n");
        dprintf ("                                                                \n");
        dprintf ("The default value for DELTA is 0. For START/END_PFN the default \n");
        dprintf ("values are lowest physical page and highest physical page.      \n");
        dprintf ("                                                                \n");
        dprintf ("Examples:                                                       \n");
        dprintf ("                                                                \n");
        dprintf ("!search AABBCCDD 0A                                             \n");
        dprintf ("                                                                \n");
        dprintf ("    Search all physical memory for values in range AABBCCD3 -   \n");
        dprintf ("    AABBCCE8 or with only one bit different than AABBCCDD.      \n");
        dprintf ("                                                                \n");
        dprintf ("!search AABBCCDD 0A 13F 240                                     \n");
        dprintf ("                                                                \n");
        dprintf ("    Search page frames in range 13F - 240 for values in range   \n");
        dprintf ("    AABBCCD3 - AABBCCE8 or with only one bit different          \n");
        dprintf ("    than AABBCCDD.                                              \n");
        dprintf ("                                                                \n");
        dprintf ("By default only the first hit in the page is detected. If all   \n");
        dprintf ("hits within the page are needed the START_PFN and END_PFN       \n");
        dprintf ("must have the same value.                                       \n");
        dprintf ("                                                                \n");
        return;
        
    }
    
    //
    // Get command line arguments.
    //

    {
        PCHAR Current = (PCHAR)args;
        CHAR Buffer [64];
        ULONG Index;
        ULONG BufferIndex;
        BOOLEAN PhysicalMemorySearch;

        PhysicalMemorySearch = FALSE;

        //
        // Identify subcommand used. 
        //

        {
            while (*Current == ' ' || *Current == '\t') {
                Current++;
            }

            if (*Current == '-' && *(Current + 1) == 'm') {

                PhysicalMemorySearch = TRUE;
                Current += 2;
            }
            else if (*Current == '-' && *(Current + 1) == 'r') {

                PhysicalMemorySearch = TRUE;
                RawSearch = TRUE;
                Current += 2;
            }
            else {

                //
                // Default is equivalent with `-m'
                //

                PhysicalMemorySearch = TRUE;
            }

            if (!PhysicalMemorySearch) {
                
                dprintf ("Use `!search ?' for help. \n");
                return;
            }
        }

        //
        // Get the 4 numeric arguments.
        //

        for (Index = 0; Index < 4; Index++) {

            //
            // Get rid of any leading spaces.
            //

            while (*Current == ' ' || *Current == '\t') {
                Current++;
            }
            
            if (*Current == 0) {

                if (Index == 0) {
                    
                    dprintf ("Use `!search ?' for help. \n");
                    return;
                }
                else {

                    break;
                }
            }

            //
            // Get the digits from the Index-th parameter.
            //

            Buffer [0] = '0';
            Buffer [1] = 'x';
            BufferIndex = 2;

            while ((*Current >= '0' && *Current <= '9')
                   || (*Current >= 'a' && *Current <= 'f')
                   || (*Current >= 'A' && *Current <= 'F')) {

                
                Buffer[BufferIndex] = *Current;
                Buffer[BufferIndex + 1] = 0;

                Current++;
                BufferIndex++;
            }

            switch (Index) {
                
#if defined(_IA64_)
            case 0: sscanf (Buffer, "%I64x", &ParamAddress); break;
            case 1: sscanf (Buffer, "%I64x", &ParamDelta); break;
            case 2: sscanf (Buffer, "%I64x", &ParamStart); break;
            case 3: sscanf (Buffer, "%I64x", &ParamEnd); break;
#else
            case 0: sscanf (Buffer, "%x", &ParamAddress); break;
            case 1: sscanf (Buffer, "%x", &ParamDelta); break;
            case 2: sscanf (Buffer, "%x", &ParamStart); break;
            case 3: sscanf (Buffer, "%x", &ParamEnd); break;
#endif
            default: return;
            }
        }
    }

    //
    // Verify that we have the right symbols.
    //

    KdpSearchCheckPoint = (ULONG_PTR) GetExpression ("xboxkrnl!KdpSearchCheckPoint");

    if (KdpSearchCheckPoint == 0 
        || ReadValue (KdpSearchCheckPoint) != SEARCH_SYMBOL_CHECK) {

        dprintf ("Search error: Incorrect symbols for kernel\n");
        return;
    }

    //
    // Get all symbol values so that we can manipulate only addresses
    // from now on.
    //

    KdpSearchPageHits = (ULONG_PTR) GetExpression ("xboxkrnl!KdpSearchPageHits");
    KdpSearchPageHitOffsets = (ULONG_PTR) GetExpression ("xboxkrnl!KdpSearchPageHitOffsets");
    KdpSearchPageHitIndex = (ULONG_PTR) GetExpression ("xboxkrnl!KdpSearchPageHitIndex");

    KdpSearchCheckPoint = (ULONG_PTR) GetExpression ("xboxkrnl!KdpSearchCheckPoint");
    KdpSearchInProgress = (ULONG_PTR) GetExpression ("xboxkrnl!KdpSearchInProgress");

    KdpSearchStartPageFrame = (ULONG_PTR) GetExpression ("xboxkrnl!KdpSearchStartPageFrame");
    KdpSearchEndPageFrame = (ULONG_PTR) GetExpression ("xboxkrnl!KdpSearchEndPageFrame");

    KdpSearchAddressRangeStart = (ULONG_PTR) GetExpression ("xboxkrnl!KdpSearchAddressRangeStart");
    KdpSearchAddressRangeEnd = (ULONG_PTR) GetExpression ("xboxkrnl!KdpSearchAddressRangeEnd");
    
    //
    // Perform some sanity checks on the values.
    //


    if (ReadValue (KdpSearchInProgress) != 0) {
        dprintf ("Search error: Inconsistent value for xboxkrnl!KdpSearchInProgress \n");
        return;
    }

    //
    // Reset the search engine
    //

    WriteValue (KdpSearchPageHitIndex, 0);
    WriteValue (KdpSearchInProgress, 1);

    //
    // Read physical memory limits.
    //

    MmLowestPhysicalPage = (ULONG_PTR) GetExpression ("xboxkrnl!MmLowestPhysicalPage");
    MmHighestPhysicalPage = (ULONG_PTR) GetExpression ("xboxkrnl!MmHighestPhysicalPage");

    //
    // Figure out proper search parameters.
    //

    AddressStart = ParamAddress - ParamDelta;
    AddressEnd = ParamAddress + ParamDelta;

    WritePointer (KdpSearchAddressRangeStart, AddressStart);
    WritePointer (KdpSearchAddressRangeEnd, AddressEnd);

    if (ParamStart == 0) {
        StartPage = ReadPointer (MmLowestPhysicalPage);
        ParamStart = StartPage;
    }
    else {
        StartPage = ParamStart;
    }

    if (ParamEnd == 0) {
        EndPage = ReadPointer (MmHighestPhysicalPage);
        ParamEnd = EndPage;
    }
    else {
        EndPage = ParamEnd;
    }

    dprintf ("Searching pfn's in range %08X - %08X for [%08X - %08X]\n\n", 
             StartPage, EndPage, 
             AddressStart, AddressEnd);

    dprintf ("%-8s %-8s %-8s \n", "Pfn","Offset", "Va");
    dprintf ("--------------------------------\n");
    
    //
    // Get system memory description to figure out what ranges
    // should we skip. This is important for sparse PFN database
    // and for pages managed by drivers.
    //

    MemoryDescriptor = SearchGetSystemMemoryDescriptor ();

    if (MemoryDescriptor == NULL) {
        dprintf ("Search error: cannot allocate system memory descriptor \n");
        return;
    }

    //
    // Search all physical memory in the specified range.
    //

    WriteValue (KdpSearchPageHitIndex, 0);

    if (StartPage == EndPage) {

        EndPage += 1;
        RequestAllOffsets = TRUE;
    }

    if (RawSearch) {
        DefaultRange = 4096;
    }
    
    for (PageFrame = StartPage; PageFrame < EndPage; PageFrame += DefaultRange) {

        for (RunIndex = 0; RunIndex < MemoryDescriptor->NumberOfRuns; RunIndex++) {

            WriteValue (KdpSearchPageHitIndex, 0);

            //
            // Figure out real start and end page.
            //

            RunStartPage = PageFrame;
            RunEndPage = PageFrame + DefaultRange;

            if (RunEndPage < MemoryDescriptor->Run[RunIndex].BasePage) {
                continue;
            }
            
            if (RunStartPage >= MemoryDescriptor->Run[RunIndex].BasePage + MemoryDescriptor->Run[RunIndex].PageCount) {
                continue;
            }
            
            if (RunStartPage < MemoryDescriptor->Run[RunIndex].BasePage) {
                RunStartPage = MemoryDescriptor->Run[RunIndex].BasePage;
            }

            if (RunEndPage > MemoryDescriptor->Run[RunIndex].BasePage + MemoryDescriptor->Run[RunIndex].PageCount) {
                RunEndPage = MemoryDescriptor->Run[RunIndex].BasePage + MemoryDescriptor->Run[RunIndex].PageCount;
            }


            WritePointer (KdpSearchStartPageFrame, RunStartPage);

            if (RequestAllOffsets) {

                //
                // If the search is in only one page then we
                // will try to get all offsets with a hit.
                //

                WritePointer (KdpSearchEndPageFrame, RunStartPage);
            }
            else {

                WritePointer (KdpSearchEndPageFrame, RunEndPage);
            }

            //
            // Invalidate kd cache
            //

            WriteValue (KdpSearchPageHits, 0);
            WriteValue (KdpSearchPageHitOffsets, 0);

            //
            // This is the trigger for memory search. We piggy back on the same
            // code as for !chklowmem and the logic in kernel detects what 
            // we really want to do.
            //

            Ioctl (IG_LOWMEM_CHECK, NULL, 0);

            //
            // Display results
            //

            Hits = ReadValue (KdpSearchPageHitIndex);

            for (Index = 0; Index < Hits; Index++) {

                PfnHit = ReadPointer (KdpSearchPageHits + Index * sizeof (PFN_NUMBER));
                PfnOffset = ReadValue (KdpSearchPageHitOffsets + Index * sizeof (ULONG));

                if (!RawSearch) {

                    VaHit = SearchConvertPageFrameToVa (PfnHit, &VaFlags);
                }
                else {

                    VaHit = 0;
                }

#if defined(_IA64_)
                dprintf ("%I64X %I64X %I64X \n",
#else
                dprintf ("%08X %08X %08X \n", 
#endif
                         PfnHit,
                         (PfnOffset & 0xFFFF), 
                         (VaHit == 0 ? 0 : VaHit + PfnOffset));
            }

            //
            // check for ctrl-c
            //

            if (CheckControlC()) {

                dprintf ("Search interrupted \n");
                RequestForInterrupt = TRUE;
                break;
            }
        }

        if (RequestForInterrupt) {
            break;
        }
    }
    
    //
    // Reset the search engine state
    //

    WriteValue (KdpSearchInProgress, 0);
    
    //
    // Print final result
    //

    free (MemoryDescriptor);

    if (RequestForInterrupt) {
        
        return;
    }
    else {

        dprintf ("Search done.\n");
    }
}


BOOLEAN
SearchIsSystemPageFrame (
    PFN_NUMBER PageFrameIndex
    )
/*++

Routine Description:

    This routine verifies if a page frame is among the ones managed by the
    system. This is the way we can deal with sparse PFN database were certain
    ranges of pages are taken for private use by drivers.

Arguments:

    PageFrameIndex - PFN to verify

Return Value:

    TRUE if page frame is managed by the system. FALSE otherwise.

Environment:

    Call triggered only from !search Kd extension.

--*/

{
    PPHYSICAL_MEMORY_RUN MemoryRun;
    PPHYSICAL_MEMORY_DESCRIPTOR MemoryDescriptor;
    
    ULONG MemoryDescriptorAddress;
    ULONG MemoryDescriptorSize;
    ULONG MemoryRunAddress;
    ULONG NumberOfRuns;
    ULONG BytesRead;
    ULONG Index;
    BOOLEAN Found;

    Found = FALSE;

    MemoryDescriptorAddress = ReadPointer (GetExpression ("xboxkrnl!MmPhysicalMemoryBlock"));
    NumberOfRuns = ReadValue (MemoryDescriptorAddress);

    if (NumberOfRuns == 0) {
        return FALSE;
    }

    MemoryDescriptorSize = sizeof (PHYSICAL_MEMORY_DESCRIPTOR) 
        + (NumberOfRuns - 1) * sizeof (PHYSICAL_MEMORY_RUN);

    MemoryDescriptor = (PPHYSICAL_MEMORY_DESCRIPTOR) malloc (MemoryDescriptorSize);
    
    if (MemoryDescriptor == NULL) {
        return FALSE;
    }

    BytesRead = 0;

    ReadMemory (MemoryDescriptorAddress,
                MemoryDescriptor,
                MemoryDescriptorSize,
                &BytesRead);

    if (BytesRead == 0) {
        
        free (MemoryDescriptor);
        return FALSE;
    }

    for (Index = 0; Index < MemoryDescriptor->NumberOfRuns; Index++) {

        MemoryRun = &(MemoryDescriptor->Run[Index]);

        if (PageFrameIndex >= MemoryRun->BasePage
            && PageFrameIndex < MemoryRun->BasePage + MemoryRun->PageCount) {
            
            Found = TRUE;
            break;
        }
    }

    free (MemoryDescriptor);
    
    return Found;
}


PPHYSICAL_MEMORY_DESCRIPTOR
SearchGetSystemMemoryDescriptor (
    VOID
    )
/*++

Routine Description:


Arguments:

    None.
    
Return Value:

    A malloc'd PHYSICAL_MEMORY_DESCRIPTOR structure.
    Caller is responsible of freeing.

Environment:

    Call triggered only from !search Kd extension.

--*/

{
    PPHYSICAL_MEMORY_RUN MemoryRun;
    PPHYSICAL_MEMORY_DESCRIPTOR MemoryDescriptor;
    
    ULONG MemoryDescriptorAddress;
    ULONG MemoryDescriptorSize;
    ULONG NumberOfRuns;
    ULONG BytesRead;

    MemoryDescriptorAddress = ReadPointer (GetExpression ("xboxkrnl!MmPhysicalMemoryBlock"));
    NumberOfRuns = ReadValue (MemoryDescriptorAddress);

    if (NumberOfRuns == 0) {
        return NULL;
    }

    MemoryDescriptorSize = sizeof (PHYSICAL_MEMORY_DESCRIPTOR) 
        + (NumberOfRuns - 1) * sizeof (PHYSICAL_MEMORY_RUN);

    MemoryDescriptor = (PPHYSICAL_MEMORY_DESCRIPTOR) malloc (MemoryDescriptorSize);
    
    if (MemoryDescriptor == NULL) {
        return NULL;
    }

    BytesRead = 0;

    ReadMemory (MemoryDescriptorAddress,
                MemoryDescriptor,
                MemoryDescriptorSize,
                &BytesRead);

    if (BytesRead == 0) {

        free (MemoryDescriptor);
        return NULL;
    }

    return MemoryDescriptor;
}


ULONG_PTR 
SearchConvertPageFrameToVa (
    PFN_NUMBER PageFrameIndex,
    PULONG Flags
    )
/*++

Routine Description:

    This routine returnes the virtual address corresponding to a
    PFN index if the reverse mapping is easy to figure out. For all
    other cases (e.g. prototype PTE) the result is null.

Arguments:

    PageFrameIndex - PFN index to convert.

Return Value:

    The corresponding virtual address or null in case the PFN index
    cannot be easily converted to a virtual address.

Environment:

    Call triggered only from Kd extension.

--*/

{
    PMMPTE PdeCurrent;
    PMMPTE PdeStart, PdeEnd;
    MMPTE PdeValue;
    ULONG_PTR Delta;
    ULONG_PTR Va;
    MMPFN Pfn;
    ULONG_PTR PfnAddress;
    ULONG BytesRead;

    PfnAddress = (ULONG_PTR)(ReadPointer(GetExpression("xboxkrnl!MmPfnDatabase")))
        + PageFrameIndex * sizeof (MMPFN);

    BytesRead = 0;
    *Flags = 0;

    ReadMemory (PfnAddress,
                &Pfn,
                sizeof(Pfn),
                &BytesRead);

    if (BytesRead < sizeof(Pfn)) {

        return 0;
    }


    //
    // bugbug (silviuc): should check if MI_IS_PFN_DELETED(Pfn)
    //

    //
    // Try to figure out Va if possible.
    //

    PdeStart = DbgGetPdeAddress ((PVOID)(MM_SYSTEM_PHYSICAL_MAP));
    PdeEnd = DbgGetPdeAddress ((PVOID)(MM_SYSTEM_PHYSICAL_MAP + MM_BYTES_IN_PHYSICAL_MAP));
    Va = MM_SYSTEM_PHYSICAL_MAP;

    for (PdeCurrent = PdeStart; PdeCurrent < PdeEnd; PdeCurrent++) {

        BytesRead = 0;

        ReadMemory ((ULONG_PTR)PdeCurrent,
                    &PdeValue,
                    sizeof PdeValue,
                    &BytesRead);

        if (BytesRead < sizeof(PdeValue)) {

            return 0;
        }

        if (PdeValue.Hard.Valid && PdeValue.Hard.LargePage) {

            Delta = (ULONG_PTR)PageFrameIndex - (ULONG_PTR)(PdeValue.Hard.PageFrameNumber);

            if (Delta < 1024 * PAGE_SIZE) {

                *Flags |= SEARCH_VA_LARGE_PAGE_ADDRESS;
                return (Va + Delta * PAGE_SIZE);
            }
        }

        Va += 1024 * PAGE_SIZE;
    }

    *Flags |= SEARCH_VA_UNKNOWN_TYPE_ADDRESS;
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\kdexts\peb.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    peb.c

Abstract:

    WinDbg Extension Api

Author:

    Ramon J San Andres (ramonsa) 5-Nov-1993

Environment:

    User Mode.

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

VOID
PebExtension(
    PCSTR lpArgumentString,
    PPEB pPeb
    );

DECLARE_API( peb )

/*++

Routine Description:

    This function is called as an NTSD extension to dump the PEB

    Called as:

        !peb

Arguments:

    None

Return Value:

    None

--*/

{
    PVOID Process;
    EPROCESS ProcessContents;

    Process = GetCurrentProcessAddress( dwProcessor, hCurrentThread, NULL );
    if ( !ReadMemory( (DWORD)Process,
                      &ProcessContents,
                      sizeof(EPROCESS),
                      NULL) ) {
        dprintf("%08lx: Unable to read _EPROCESS\n", Process );
        return;
        }

    PebExtension( args, ProcessContents.Peb );
}

VOID
TebExtension(
    PCSTR lpArgumentString,
    PTEB pTeb
    );

DECLARE_API( teb )

/*++

Routine Description:

    This function is called as an NTSD extension to dump the TEB

    Called as:

        !teb

Arguments:

    None

Return Value:

    None

--*/

{
    PVOID Thread;
    ETHREAD ThreadContents;
    TEB TheTeb;

    Thread = GetCurrentThreadAddress( (USHORT)dwProcessor, hCurrentThread );

    if ( !ReadMemory( (DWORD)Thread,
                      &ThreadContents,
                      sizeof(ETHREAD),
                      NULL) ) {
        dprintf("%08lx: Unable to read _EThread\n", Thread );
        return;
        }

    TebExtension( args, ThreadContents.Tcb.Teb );
}

#include "..\\ntsdexts\\pebext.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\kdexts\ready.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    ready.c

Abstract:

    WinDbg Extension Api

Author:

    Ramon J San Andres (ramonsa) 8-Nov-1993

Environment:

    User Mode.

Revision History:
    Jamie Hankins (a-jamhan) 20-Oct-1997 Added CheckControlC to loop.

--*/

#include "precomp.h"
#pragma hdrstop


DECLARE_API( ready )

/*++

Routine Description:



Arguments:

    args -

Return Value:

    None

--*/

{
    ULONG       KiDispatcherReadyListHead;
    LIST_ENTRY  ReadyList[MAXIMUM_PRIORITY];
    ULONG       result;
    DWORD       Flags = 6;
    LONG        i;
    BOOLEAN     ThreadDumped = FALSE;

    sscanf(args, "%lx", &Flags);

    KiDispatcherReadyListHead = GetExpression( "xboxkrnl!KiDispatcherReadyListHead" );
    if ( KiDispatcherReadyListHead ) {

        if ( !ReadMemory( (DWORD)KiDispatcherReadyListHead,
                          ReadyList,
                          sizeof(ReadyList),
                          &result) ) {
            dprintf("Could not read contents of KiDispatcherReadyListHead at %08lx\n", KiDispatcherReadyListHead);
            return;
        }

        for (i = MAXIMUM_PRIORITY-1; i >= 0 ; i -= 1 ) {

            if ((ULONG)ReadyList[i].Flink != KiDispatcherReadyListHead+i*sizeof(LARGE_INTEGER)) {
                DWORD ThreadEntry;
                ETHREAD Thread;

                dprintf("Ready Threads at priority %ld\n", i);

                for (ThreadEntry = (DWORD)ReadyList[i].Flink ;
                     ThreadEntry != KiDispatcherReadyListHead+i*sizeof(LARGE_INTEGER) ;
                     ThreadEntry = (DWORD)Thread.Tcb.WaitListEntry.Flink ) {
                    PETHREAD ThreadBaseAddress = CONTAINING_RECORD(ThreadEntry, ETHREAD, Tcb.WaitListEntry);

                    if ( !ReadMemory( (DWORD)ThreadBaseAddress,
                                      &Thread,
                                      sizeof(ETHREAD),
                                      &result) ) {
                        dprintf("Could not read contents of thread %lx\n", ThreadBaseAddress);
                    }

                    if(CheckControlC()) {
                        return;
                    }

                    DumpThread(dwProcessor,"    ", &Thread, ThreadBaseAddress, Flags);
                    ThreadDumped = TRUE;

                }
            } else {
                if (ReadyList[i].Flink != ReadyList[i].Blink) {
                    dprintf("Ready linked list may to be corrupt...\n");
                }
            }
        }

        if (!ThreadDumped) {
            dprintf("No threads in READY state\n");
        }
    } else {
        dprintf("Could not determine address of KiDispatcherReadyListHead\n");
        return;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\kdexts\pool.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    pool.c

Abstract:

    WinDbg Extension Api

Author:

    Lou Perazzoli (Loup) 5-Nov-1993

Environment:

    User Mode.

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#include <limits.h>

typedef struct _POOL_BLOCK_HEAD {
    POOL_HEADER Header;
    LIST_ENTRY  List;
} POOL_BLOCK_HEAD, *PPOOL_BLOCK_HEADER;

typedef struct _POOL_HACKER {
    POOL_HEADER Header;
    ULONG Contents[8];
} POOL_HACKER;


#define TAG 0
#define NONPAGED_ALLOC 1
#define NONPAGED_FREE 2
#define PAGED_ALLOC 3
#define PAGED_FREE 4
#define NONPAGED_USED 5

ULONG SortBy;

typedef struct _FILTER {
    ULONG Tag;
    BOOLEAN Exclude;
} FILTER, *PFILTER;

#define MAX_FILTER 64
FILTER Filter[MAX_FILTER];

ULONG PageSize = 0x1000;

PPOOL_TRACKER_BIG_PAGES PoolBigTableAddress;

#define DecodeLink(Pool)    ((PUCHAR)((ULONG)Pool & ~1))

#define PP(x) isprint(((x)&0xff))?((x)&0xff):('.')

#define SPECIAL_POOL_BLOCK_SIZE(PoolHeader) (PoolHeader->Ulong1 & (MI_SPECIAL_POOL_VERIFIER - 1))

BOOLEAN
CheckSingleFilter (
    PCHAR Tag,
    PCHAR Filter
    );

BOOLEAN
CopyPfnDatabaseLocal(
    OUT PMMPFN *PfnDatabaseLocalOutput,
    OUT ULONG *NumberOfPages
    );

int __cdecl
ulcomp(const void *e1,const void *e2)
{
    ULONG u1;

    switch (SortBy) {
        case TAG:

            u1 = ((PUCHAR)e1)[0] - ((PUCHAR)e2)[0];
            if (u1 != 0) {
                return u1;
            }
            u1 = ((PUCHAR)e1)[1] - ((PUCHAR)e2)[1];
            if (u1 != 0) {
                return u1;
            }
            u1 = ((PUCHAR)e1)[2] - ((PUCHAR)e2)[2];
            if (u1 != 0) {
                return u1;
            }
            u1 = ((PUCHAR)e1)[3] - ((PUCHAR)e2)[3];
            return u1;
            break;

        case NONPAGED_ALLOC:
            u1 = ((PPOOL_TRACKER_TABLE)e2)->NonPagedAllocs -
                        ((PPOOL_TRACKER_TABLE)e1)->NonPagedAllocs;
            return (u1);
            break;

        case NONPAGED_FREE:
            u1 = ((PPOOL_TRACKER_TABLE)e2)->NonPagedFrees -
                        ((PPOOL_TRACKER_TABLE)e1)->NonPagedFrees;
            return (u1);
            break;

        case NONPAGED_USED:
            u1 = ((PPOOL_TRACKER_TABLE)e2)->NonPagedBytes -
                        ((PPOOL_TRACKER_TABLE)e1)->NonPagedBytes;
            return (u1);
            break;

        default:
            return(0);
            break;
    }
}


DECLARE_API( frag )

/*++

Routine Description:

    Dump pool fragmentation

Arguments:

    args - Flags

Return Value:

    None

--*/

{
    ULONG Flags;
    ULONG result;
    ULONG i;
    ULONG count;
    PUCHAR Pool;
    ULONG PoolLoc1;
    ULONG TotalFrag;
    ULONG TotalCount;
    ULONG Frag;
    ULONG PoolStart;
    POOL_DESCRIPTOR PoolDesc;
    PPOOL_DESCRIPTOR PoolLoc;
    POOL_BLOCK_HEAD PoolBlock;

    UNREFERENCED_PARAMETER (hCurrentThread);
    UNREFERENCED_PARAMETER (hCurrentProcess);
    UNREFERENCED_PARAMETER (dwProcessor);
    UNREFERENCED_PARAMETER (dwCurrentPc);

    dprintf("\n  NonPaged Pool Fragmentation\n\n");
    Flags = 0;
    PoolStart = 0;

    sscanf(args,"%lx %lx", &Flags, &PoolStart);

    if (PoolStart != 0) {
        PoolStart += POOL_OVERHEAD;

        Pool = (PUCHAR)DecodeLink(PoolStart);
        do {

            Pool = Pool - POOL_OVERHEAD;
            if ( !ReadMemory( (DWORD)Pool,
                              &PoolBlock,
                              sizeof(PoolBlock),
                              &result) ) {
                dprintf("%08lx: Unable to get contents of pool block\n", Pool );
                return;
            }

            dprintf(" %lx size: %4lx previous size: %4lx  %c%c%c%c links: %8lx %8lx\n",
                    (ULONG)Pool,
                    (ULONG)PoolBlock.Header.BlockSize << POOL_BLOCK_SHIFT,
                    (ULONG)PoolBlock.Header.PreviousSize << POOL_BLOCK_SHIFT,
                    (ULONG)PoolBlock.Header.PoolTag,
                    (ULONG)PoolBlock.Header.PoolTag >> 8,
                    (ULONG)PoolBlock.Header.PoolTag >> 16,
                    (ULONG)PoolBlock.Header.PoolTag >> 24,
                    (ULONG)PoolBlock.List.Flink,
                    (ULONG)PoolBlock.List.Blink);

            if (Flags != 3) {
                Pool = (PUCHAR)PoolBlock.List.Flink;
            } else {
                Pool = (PUCHAR)PoolBlock.List.Blink;
            }

            Pool = DecodeLink(Pool);

            if (CheckControlC()) {
                return;
            }

        } while ( ((ULONG)Pool & 0xfffffff0) != (PoolStart & 0xfffffff0) );

        return;
    }

    PoolLoc1 = GetNtDebuggerData( NonPagedPoolDescriptor );

    if (PoolLoc1 == 0) {
        dprintf ("unable to get nonpaged pool head\n");
        return;
    }

    PoolLoc = (PPOOL_DESCRIPTOR)PoolLoc1;

    if ( !ReadMemory( (DWORD)PoolLoc,
                      &PoolDesc,
                      sizeof(POOL_DESCRIPTOR),
                      &result) ) {
        dprintf ("%08lx: Unable to get pool descriptor\n", PoolLoc1);
        return;
    }

    TotalFrag   = 0;
    TotalCount  = 0;

    for (i = 0; i < POOL_LIST_HEADS; i += 1) {

        Frag  = 0;
        count = 0;
        Pool  = (PUCHAR)PoolDesc.ListHeads[i].Flink;
        Pool = DecodeLink(Pool);

        while (Pool != (PUCHAR)(&PoolLoc->ListHeads[i])) {

            Pool = Pool - POOL_OVERHEAD;
            if ( !ReadMemory( (DWORD)Pool,
                              &PoolBlock,
                              sizeof(PoolBlock),
                              &result) ) {
                dprintf("%08lx: Unable to get contents of pool block\n", Pool );
                return;
            }

            Frag  += (ULONG)PoolBlock.Header.BlockSize << POOL_BLOCK_SHIFT;
            count += 1;

            if (Flags & 2) {
                dprintf(" ListHead[%x]: %lx size: %4lx previous size: %4lx  %c%c%c%c\n",
                        i,
                        (ULONG)Pool,
                        (ULONG)PoolBlock.Header.BlockSize << POOL_BLOCK_SHIFT,
                        (ULONG)PoolBlock.Header.PreviousSize << POOL_BLOCK_SHIFT,
                        (ULONG)PoolBlock.Header.PoolTag,
                        (ULONG)PoolBlock.Header.PoolTag >> 8,
                        (ULONG)PoolBlock.Header.PoolTag >> 16,
                        (ULONG)PoolBlock.Header.PoolTag >> 24);
            }
            Pool = (PUCHAR)PoolBlock.List.Flink;
            Pool = DecodeLink(Pool);

            if (CheckControlC()) {
                return;
            }
        }
        if (Flags & 1) {
            dprintf("index: %2ld number of fragments: %5ld  bytes: %6ld\n",
                i,count,Frag);
        }
        TotalFrag  += Frag;
        TotalCount += count;
    }

    dprintf("\n Number of fragments: %7ld consuming %7ld bytes\n",
            TotalCount,TotalFrag);
    dprintf(  " NonPagedPool Usage:  %7ld bytes\n",(PoolDesc.TotalPages + PoolDesc.TotalBigPages)*PageSize);
    return;
}


PRTL_BITMAP
GetBitmap(
    ULONG pBitmap
    )
{
    ULONG Result;
    RTL_BITMAP Bitmap;
    PRTL_BITMAP p;

    if ( !ReadMemory( (DWORD)pBitmap,
                      &Bitmap,
                      sizeof(Bitmap),
                      &Result) ) {
        dprintf("%08lx: Unable to get contents of bitmap\n", pBitmap );
        return NULL;
    }

    p = HeapAlloc( GetProcessHeap(), 0, sizeof( *p ) + (Bitmap.SizeOfBitMap / 8) );
    if (p) {
        p->SizeOfBitMap = Bitmap.SizeOfBitMap;
        p->Buffer = (PULONG)(p + 1);
        if ( !ReadMemory( (DWORD)Bitmap.Buffer,
                          p->Buffer,
                          Bitmap.SizeOfBitMap / 8,
                          &Result) ) {
            dprintf("%08lx: Unable to get contents of bitmap buffer\n", Bitmap.Buffer );
            HeapFree( GetProcessHeap(), 0, p );
            p = NULL;
        }
    }

    return p;
}


VOID
DumpPool(
    VOID
    )
{
#if 1
    // The new memory manager doesn't track paged pool the same way.  The code
    // needs to be rewritten to walk the PFN database to find pool pages.
    dprintf("DumpPool is not implemented.\n");
#else
    PCHAR p, pStart;
    ULONG Size;
    ULONG BusyFlag;
    ULONG CurrentPage;
    PRTL_BITMAP StartMap;
    PRTL_BITMAP EndMap;
    PVOID PagedPoolStart;
    PVOID PagedPoolEnd;
    ULONG Result;
    MM_PAGED_POOL_INFO PagedPoolInfo;
    PMM_PAGED_POOL_INFO PagedPoolInfoPointer;

    PagedPoolInfoPointer = (PMM_PAGED_POOL_INFO) GetNtDebuggerData( MmPagedPoolInformation );

    if ( !ReadMemory( (DWORD)PagedPoolInfoPointer,
                      &PagedPoolInfo,
                      sizeof(PagedPoolInfo),
                      &Result) ) {
        dprintf("%08lx: Unable to get contents of paged pool information\n",
            PagedPoolInfoPointer );
        return;
    }

    StartMap = GetBitmap( (ULONG) PagedPoolInfo.PagedPoolAllocationMap );
    EndMap = GetBitmap( (ULONG) PagedPoolInfo.EndOfPagedPoolBitmap );

    PagedPoolStart = (PVOID)GetNtDebuggerDataValue( MmPagedPoolStart );
    PagedPoolEnd = (PVOID)GetNtDebuggerDataValue( MmPagedPoolEnd );

    if (StartMap && EndMap) {
        p = PagedPoolStart;
        CurrentPage = 0;
        dprintf( "Paged Pool: %x .. %x\n", PagedPoolStart, PagedPoolEnd );

        while (p < (PCHAR)PagedPoolEnd) {
            if ( CheckControlC() ) {
                return;
            }
            pStart = p;
            BusyFlag = RtlCheckBit( StartMap, CurrentPage );
            while ( ~(BusyFlag ^ RtlCheckBit( StartMap, CurrentPage )) ) {
                p += PageSize;
                if (RtlCheckBit( EndMap, CurrentPage )) {
                    CurrentPage++;
                    break;
                    }

                CurrentPage++;
                if (p > (PCHAR)PagedPoolEnd) {
                   break;
                   }
                }

            Size = p - pStart;
            dprintf( "%08x: %x - %s\n", pStart, Size, BusyFlag ? "busy" : "free" );
            }
        }

    HeapFree( GetProcessHeap(), 0, StartMap );
    HeapFree( GetProcessHeap(), 0, EndMap );
#endif
}

DECLARE_API( pool )

/*++

Routine Description:

    Dump kernel mode heap

Arguments:

    args - Page Flags

Return Value:

    None

--*/

{
    DWORD       PoolTableAddress;
    ULONG       PoolTag;
    ULONG       Flags;
    ULONG       Result;
    PVOID       PoolPageToDump;
    PVOID       StartPage;
    PUCHAR      Pool;
    POOL_HACKER PoolBlock;
    ULONG       PoolBlockSize;
    PPOOL_HEADER PoolHeader;
    ULONG       Previous;
    UCHAR       c;
    PUCHAR      DataPage;
    PUCHAR      DataStart;
    LOGICAL     Pagable;
    LOGICAL     FirstBlock;
    ULONG       BlockType;
    ULONG       i;
    ULONG       j;
    ULONG       ct;
    ULONG       PoolBigPageTableSize;
    PPOOL_TRACKER_BIG_PAGES BigTable;

    UNREFERENCED_PARAMETER (hCurrentThread);
    UNREFERENCED_PARAMETER (hCurrentProcess);
    UNREFERENCED_PARAMETER (dwProcessor);
    UNREFERENCED_PARAMETER (dwCurrentPc);

    DataPage = (PUCHAR) malloc (PageSize);

    if (DataPage == NULL) {
        dprintf ("Not enough memory\n");
        return;
    }

    __try {

        PoolPageToDump = (PVOID)-1;
        Flags = 0;
        sscanf(args,"%lx %lx",&PoolPageToDump,&Flags);
        if (PoolPageToDump == (PVOID)-1) {
            DumpPool();
            __leave;
        }

        Pool        = (PUCHAR)PAGE_ALIGN (PoolPageToDump);
        StartPage   = (PVOID)Pool;
        Previous    = 0;

        FirstBlock = TRUE;

        while ((PVOID)PAGE_ALIGN(Pool) == StartPage) {
            if ( CheckControlC() ) {
                __leave;
            }

            if ( !ReadMemory( (DWORD)Pool,
                              &PoolBlock,
                              sizeof(POOL_HACKER),
                              &Result) ) {
                dprintf("%08lx: Unable to get contents of pool block\n", Pool );
                __leave;
            }
    
            if ((ULONG)PoolPageToDump >= (ULONG)Pool &&
                (ULONG)PoolPageToDump < ((ULONG)Pool + ((ULONG)PoolBlock.Header.BlockSize << POOL_BLOCK_SHIFT))
               ) {
                c = '*';
            } else {
                c = ' ';
            }

#ifdef TARGET_ALPHA
            if (PoolBlock.Header.BlockSize == 0 &&
                PoolBlock.Header.PreviousSize == 0 &&
                (PVOID)PAGE_ALIGN(Pool+0x20) != StartPage
               ) {
                dprintf("%c%lx size:   20 previous size:    0 (wasted)\n",
                        c,
                        Pool
                       );
                break;
            }
#endif
    
            BlockType = 0;
    
            if ((PoolBlock.Header.BlockSize << POOL_BLOCK_SHIFT) >= PAGE_SIZE) {
                BlockType = 1;
            }
            else if (PoolBlock.Header.BlockSize == 0) {
                BlockType = 2;
            }
            else if (PoolBlock.Header.PreviousSize != Previous) {
                BlockType = 3;
            }

            if (BlockType != 0) {

                //
                // See if this is a big block allocation.  Iff we have not
                // parsed any other small blocks in here already.
                //
    
                if (FirstBlock == TRUE) {
    
                    if (!PoolBigTableAddress) {
                        PoolBigTableAddress = (PPOOL_TRACKER_BIG_PAGES)GetUlongValue ("xboxkrnl!PoolBigPageTable");
                    }

                    PoolTableAddress = (DWORD)PoolBigTableAddress;

                    if (PoolTableAddress) {

                        PoolBigPageTableSize = GetUlongValue ("xboxkrnl!PoolBigPageTableSize");
                        //
                        // Scan the table looking for a match.
                        //

                        i = 0;
                        ct = PageSize / sizeof (POOL_TRACKER_BIG_PAGES);
    
                        while (i < PoolBigPageTableSize) {
    
                            if (PoolBigPageTableSize - i < ct) {
                                ct = PoolBigPageTableSize - i;
                            }
    
                            if ( !ReadMemory( PoolTableAddress,
                                              DataPage,
                                              ct * sizeof (POOL_TRACKER_BIG_PAGES),
                                              &Result) ) {
                                dprintf("%08lx: Unable to get contents of pool block\n", PoolTableAddress );
                                __leave;
                            }
        
                            BigTable = (PPOOL_TRACKER_BIG_PAGES)DataPage;

                            for (j = 0; j < ct; j += 1) {
    
                                if (BigTable[j].Va == PAGE_ALIGN(Pool)) {

                                    //
                                    // Match !
                                    //
                                    PoolTag = BigTable[j].Key;
                                    dprintf("*%lx : large page allocation, Tag is %c%c%c%c, size is 0x%x bytes\n",
                                        Pool,
                                        PP(PoolTag),
                                        PP(PoolTag >> 8),
                                        PP(PoolTag >> 16),
                                        PP(PoolTag >> 24),
                                        BigTable[j].NumberOfPages * PageSize
                                    );
                                    __leave;
                                }
                            }
                            i += ct;
                            PoolTableAddress += (ct * sizeof (POOL_TRACKER_BIG_PAGES));
                        }
    
                        //
                        // No match in small or large pool, must be
                        // freed or corrupt pool
                        //
    
                        dprintf("%lx is freed (or corrupt) pool\n", Pool);
                        __leave;
                    }
    
                    dprintf("unable to get pool big page table - either wrong symbols or pool tagging is disabled\n");
                }
    
                if (BlockType == 1) {
                    dprintf("Bad allocation size @%lx, too large\n", Pool);
                    __leave;
                }
                else if (BlockType == 2) {
                    dprintf("Bad allocation size @%lx, zero is invalid\n", Pool);
                    __leave;
                }
                else if (BlockType == 3) {
                    dprintf("Bad previous allocation size @%lx, last size was %lx\n",
                            Pool, Previous);
                    __leave;
                }
            }

            if (!(Flags & 2) || c == '*') {
              dprintf("%c%lx size: %4lx previous size: %4lx ",
                    c,
                    (ULONG)Pool,
                    (ULONG)PoolBlock.Header.BlockSize << POOL_BLOCK_SHIFT,
                    (ULONG)PoolBlock.Header.PreviousSize << POOL_BLOCK_SHIFT);
    
              if (PoolBlock.Header.PoolType == 0) {

                dprintf(" (Free)");

                dprintf("      %c%c%c%c%c\n",
                        c,
                        PP(PoolBlock.Header.PoolTag),
                        PP(PoolBlock.Header.PoolTag >> 8),
                        PP(PoolBlock.Header.PoolTag >> 16),
                        PP(PoolBlock.Header.PoolTag >> 24)
                        );
              }
              else {

                if (PoolBlock.Header.PoolIndex & 0x80) {
                    dprintf(" (Allocated)");
                } else {
                    dprintf(" (Lookaside)");
                }
                PoolTag = PoolBlock.Header.PoolTag;

                dprintf(" %c%c%c%c%c\n",
                    c,
                    PoolTag,
                    PoolTag >> 8,
                    PoolTag >> 16,
                    PoolTag >> 24
                    );
              }
            }
    
    
            if (Flags & 1) {
                dprintf("    %08lx  %08lx %08lx %08lx %08lx\n",
                    Pool+sizeof(POOL_HEADER),
                    PoolBlock.Contents[0],
                    PoolBlock.Contents[1],
                    PoolBlock.Contents[2],
                    PoolBlock.Contents[3]);
    
                dprintf("    %08lx  %08lx %08lx %08lx %08lx\n",
                    Pool+sizeof(POOL_HEADER)+16,
                    PoolBlock.Contents[4],
                    PoolBlock.Contents[5],
                    PoolBlock.Contents[6],
                    PoolBlock.Contents[7]);
                dprintf("\n");
            }
    
            Previous = PoolBlock.Header.BlockSize;
            Pool += (Previous << POOL_BLOCK_SHIFT);
            FirstBlock = FALSE;
        }

    } __finally {
    }

    free (DataPage);

    return;
}



DECLARE_API( poolused )

/*++

Routine Description:

    Dump usage by pool tag

Arguments:

    args -

Return Value:

    None

--*/

{
    ULONG PoolTrackTableSize;
    SIZE_T PoolTrackTableSizeInBytes;
    PPOOL_TRACKER_TABLE p;
    PPOOL_TRACKER_TABLE PoolTrackTableData;
    ULONG Flags;
    ULONG i;
    ULONG result;
    ULONG ct;
    DWORD PoolTableAddress;
    ULONG TagName;
    CHAR TagNameX[4] = {'*','*','*','*'};
    PPOOL_TRACKER_TABLE PoolTrackTable;

    UNREFERENCED_PARAMETER (hCurrentThread);
    UNREFERENCED_PARAMETER (hCurrentProcess);
    UNREFERENCED_PARAMETER (dwProcessor);
    UNREFERENCED_PARAMETER (dwCurrentPc);

    Flags = 0;
    sscanf(args,"%lx %c%c%c%c", &Flags, &TagNameX[0],
        &TagNameX[1], &TagNameX[2], &TagNameX[3]);

    TagName = TagNameX[0] | (TagNameX[1] << 8) | (TagNameX[2] << 16) | (TagNameX[3] << 24);

    if ((PVOID)GetNtDebuggerData( PoolTrackTable ) == NULL) {
        dprintf ("unable to get PoolTrackTable - either pool tagging is off or bad symbols\n");
        return;
    }

    PoolTrackTable = (PPOOL_TRACKER_TABLE)GetNtDebuggerDataValue( PoolTrackTable );
    PoolTrackTableSize = GetNtDebuggerDataValue( PoolTrackTableSize );
    PoolTrackTableSizeInBytes = PoolTrackTableSize * sizeof(POOL_TRACKER_TABLE);

    PoolTrackTableData = malloc (PoolTrackTableSizeInBytes);
    if (PoolTrackTableData == NULL) {
        dprintf("unable to allocate memory for tag table.\n");
        return;
    }

    if (Flags & 2) {
        SortBy = NONPAGED_USED;
        dprintf("   Sorting by NonPaged Pool Consumed\n");
    } else {
        SortBy = TAG;
        dprintf("   Sorting by Tag\n");
    }

    dprintf("\n  Pool Used:\n");
    if (!(Flags & 1)) {
        dprintf(" Tag    Allocs     Used\n");

    } else {
        dprintf(" Tag    Allocs    Frees     Diff     Used\n");
    }

    ct = PageSize / sizeof (POOL_TRACKER_TABLE);
    i = 0;
    PoolTableAddress = (DWORD)PoolTrackTable;

    while (i < PoolTrackTableSize) {

        if ( CheckControlC() ) {
            free (PoolTrackTableData);
            return;
        }

        if (PoolTrackTableSize - i < ct) {
            ct = PoolTrackTableSize - i;
        }

        if ( !ReadMemory( PoolTableAddress,
                          &PoolTrackTableData[i],
                          ct * sizeof (POOL_TRACKER_TABLE),
                          &result) ) {
            dprintf("%08lx: Unable to get contents of pool block\n", PoolTableAddress );
            free (PoolTrackTableData);
            return;
        }

        PoolTableAddress += (ct * sizeof(POOL_TRACKER_TABLE));
        i += ct;
    }

    qsort((void *)PoolTrackTableData,
          (size_t)PoolTrackTableSize,
          (size_t)sizeof(POOL_TRACKER_TABLE),
          ulcomp);

    i = 0;
    p = &PoolTrackTableData[i];

    for ( ; i < PoolTrackTableSize; i += 1, p += 1) {

        if ((p->Key != 0) &&
            (CheckSingleFilter ((PCHAR)&p->Key, (PCHAR)&TagName))) {

            if (!(Flags & 1)) {
                if (p->NonPagedBytes != 0) {
                    dprintf(" %c%c%c%c %8ld %8ld\n",
                            p->Key,
                            p->Key >> 8,
                            p->Key >> 16,
                            p->Key >> 24,
                            p->NonPagedAllocs - p->NonPagedFrees,
                            p->NonPagedBytes);
                }

            } else {
                dprintf(" %c%c%c%c %8ld %8ld %8ld %8ld\n",
                        p->Key,
                        p->Key >> 8,
                        p->Key >> 16,
                        p->Key >> 24,
                        p->NonPagedAllocs,
                        p->NonPagedFrees,
                        p->NonPagedAllocs - p->NonPagedFrees,
                        p->NonPagedBytes);
            }
        }

    }

    free (PoolTrackTableData);
    return;
}


BOOLEAN WINAPI
CheckSingleFilterAndPrint (
    PCHAR Tag,
    PCHAR Filter,
    ULONG Flags,
    PPOOL_HEADER PoolHeader,
    ULONG BlockSize,
    PVOID Data,
    PVOID Context
    )

/*++

Routine Description:

    Callback to check a piece of pool and print out information about it
    if it matches the specified tag.

Arguments:

    Tag - Supplies the tag to search for.

    Filter - Supplies the filter string to match against.

    Flags - Supplies 0 if a nonpaged pool search is desired.
            Supplies 1 if a paged pool search is desired.
            Supplies 2 if a special pool search is desired.

    PoolHeader - Supplies the pool header.

    BlockSize - Supplies the size of the pool block in bytes.

    Data - Supplies the address of the pool block.

    Context - Unused.

Return Value:

    TRUE for a match, FALSE if not.

--*/

{
    ULONG UTag;

    UNREFERENCED_PARAMETER (Context);
    
    UTag = *((PULONG)Tag);

    if (CheckSingleFilter (Tag, Filter) == FALSE) {
        return FALSE;
    }

    if (BlockSize >= PageSize) {
        dprintf("*%lx :%slarge page allocation, Tag is %c%c%c%c, size is 0x%x bytes\n",
            (ULONG_PTR)Data | MINLONG_PTR,
            ((ULONG_PTR)Data & MINLONG_PTR) ? " " : "Free ",
            PP(UTag),
            PP(UTag >> 8),
            PP(UTag >> 16),
            PP(UTag >> 24),
            BlockSize
            );
    } else if (Flags & 0x2) {
        
        dprintf("*%lx size: %4lx %s special pool, Tag is %c%c%c%c\n",
            Data,
            BlockSize,
            "non-paged",
            PP(UTag),
            PP(UTag >> 8),
            PP(UTag >> 16),
            PP(UTag >> 24)
            );
    } else {

        dprintf("%lx size: %4lx previous size: %4lx ",
                (ULONG)Data - sizeof( POOL_HEADER ),
                (ULONG)PoolHeader->BlockSize << POOL_BLOCK_SHIFT,
                (ULONG)PoolHeader->PreviousSize << POOL_BLOCK_SHIFT);

        if (PoolHeader->PoolType == 0) {
            dprintf(" (Free)");
            dprintf("      %c%c%c%c\n",
                    PP(UTag),
                    PP(UTag >> 8),
                    PP(UTag >> 16),
                    PP(UTag >> 24) 
                   );
        } else {

            if (PoolHeader->PoolIndex & 0x80) {
                dprintf(" (Allocated)");
            } else {
                dprintf(" (Lookaside)");
            }
            UTag = PoolHeader->PoolTag;

            dprintf(" %c%c%c%c\n",
                PP(UTag),
                PP(UTag >> 8),
                PP(UTag >> 16),
                PP(UTag >> 24)
                );
        }
    }

    return TRUE;
}

PVOID
GetPoolVirtualAddress(
    PFN_NUMBER PageFrameNumber,
    ULONG PteIndex
    )
{
    PMMPTE PointerPde;
    MMPTE PdeContents;
    PMMPTE PointerPte;
    MMPTE PteContents;
    ULONG Result;

    PointerPde = MiGetPdeAddress(MM_SYSTEM_PTE_BASE);

    while (PointerPde <= MiGetPdeAddress(MM_SYSTEM_PTE_END)) {

        if (ReadMemory((ULONG)PointerPde, &PdeContents, sizeof(PdeContents), &Result)) {

            if (PdeContents.Hard.Valid != 0 &&
                PdeContents.Hard.LargePage == 0) {

                PointerPte = (PMMPTE)MiGetVirtualAddressMappedByPte(PointerPde) + PteIndex;

                if (ReadMemory((ULONG)PointerPte, &PteContents, sizeof(PteContents), &Result)) {

                    if (PteContents.Hard.Valid != 0 &&
                        PteContents.Hard.PageFrameNumber == PageFrameNumber) {
                        return MiGetVirtualAddressMappedByPte(PointerPte);
                    }
                }
            }
        }

        PointerPde++;
    }

    //
    // Give up and return NULL.
    //

    return NULL;
}

VOID
SearchPool(
    ULONG TagName,
    ULONG RestartAddr,
    POOLFILTER Filter,
    PVOID Context
)

/*++

Routine Description:

    Engine to search the pool.

Arguments:

    TagName - Supplies the tag to search for.

    RestartAddr - Supplies the address to restart the search from.

    Filter - Supplies the filter routine to use.

    Context - Supplies the user defined context blob.

Return Value:

    None.

--*/

{
    ULONG       PoolBlockSize;
    PPOOL_HEADER PoolHeader;
    ULONG       PoolTag;
    ULONG       Result;
    PVOID       PoolPage;
    PVOID       StartPage;
    PUCHAR      Pool;
    POOL_HACKER PoolBlock;
    ULONG       Previous;
    ULONG       SkipSize;
    PUCHAR      DataPage;
    PUCHAR      DataStart;
    LOGICAL     Found;
    ULONG       i;
    ULONG       j;
    ULONG       ct;
    ULONG       PoolBigPageTableSize;
    DWORD       PoolTableAddress;
    UCHAR       FastTag[4];
    ULONG       TagLength;
    PPOOL_TRACKER_BIG_PAGES BigTable;
    PMMPFN      PfnDatabaseLocal = NULL;
    ULONG       NumberOfPages;
    ULONG       z;

    DataPage = malloc( PageSize );

    if (DataPage == NULL) {
        dprintf( "Out of memory\n" );
        return;
    }

    if (!CopyPfnDatabaseLocal(&PfnDatabaseLocal, &NumberOfPages)) {
        free(DataPage);
        return;
    }

    __try {

        if (!PoolBigTableAddress) {
            PoolBigTableAddress = (PPOOL_TRACKER_BIG_PAGES)GetUlongValue ("xboxkrnl!PoolBigPageTable");
        }

        PoolTableAddress = (DWORD)PoolBigTableAddress;

        if (PoolTableAddress) {

            dprintf("\nScanning large pool allocation table for Tag: %c%c%c%c\n\n",
                                                TagName,
                                                TagName >> 8,
                                                TagName >> 16,
                                                TagName >> 24);

            PoolBigPageTableSize = GetUlongValue ("xboxkrnl!PoolBigPageTableSize");

            //
            // Scan the table looking for a match.
            //

            i = 0;
            ct = PageSize / sizeof (POOL_TRACKER_BIG_PAGES);

            BigTable = (PPOOL_TRACKER_BIG_PAGES)DataPage;

            while (i < PoolBigPageTableSize) {

                if (PoolBigPageTableSize - i < ct) {
                    ct = PoolBigPageTableSize - i;
                }

                if ( !ReadMemory( PoolTableAddress,
                                  DataPage,
                                  ct * sizeof (POOL_TRACKER_BIG_PAGES),
                                  &Result) ) {
                    dprintf("%08lx: Unable to get contents of pool block\n", PoolTableAddress );
                    __leave;
                }

                for (j = 0; j < ct; j += 1) {

                    Filter( (PCHAR)&BigTable[j].Key,
                            (PCHAR)&TagName,
                            0,
                            NULL,
                            BigTable[j].NumberOfPages * PageSize,
                            BigTable[j].Va,
                            Context );
                }
                i += ct;
                PoolTableAddress += (ct * sizeof (POOL_TRACKER_BIG_PAGES));
            }
        }
        else {
            dprintf("unable to get large pool allocation table - either wrong symbols or pool tagging is disabled\n");
        }

        dprintf("\nSearching pool for Tag: %c%c%c%c\n\n",
                                                TagName,
                                                TagName >> 8,
                                                TagName >> 16,
                                                TagName >> 24);

        for (z = 0; z < NumberOfPages; z++) {

            if (PfnDatabaseLocal[z].Busy.Busy == 0) {
                continue;
            }

            if (PfnDatabaseLocal[z].Busy.BusyType != MmPoolUsage) {
                continue;
            }

            PoolPage = GetPoolVirtualAddress(z, PfnDatabaseLocal[z].Busy.PteIndex);

            if (PoolPage == NULL) {
                dprintf("Failed to find virtual address for pool page %08x\n", z);
                continue;
            }

            Pool        = (PUCHAR)PAGE_ALIGN (PoolPage);
            StartPage   = (PVOID)Pool;
            Previous    = 0;

            while ((PVOID)PAGE_ALIGN(Pool) == StartPage) {
                if ( !ReadMemory( (DWORD)Pool,
                                  &PoolBlock,
                                  sizeof(POOL_HACKER),
                                  &Result) ) {
                    goto nextpage;
                }

                if ((PoolBlock.Header.BlockSize << POOL_BLOCK_SHIFT) > PAGE_SIZE) {
                    //dprintf("Bad allocation size @%lx, too large\n", Pool);
                    break;
                }

                if (PoolBlock.Header.BlockSize == 0) {
                    //dprintf("Bad allocation size @%lx, zero is invalid\n", Pool);
                    break;
                }

                if (PoolBlock.Header.PreviousSize != Previous) {
                    //dprintf("Bad previous allocation size @%lx, last size was %lx\n",Pool, Previous);
                    break;
                }

                PoolTag = PoolBlock.Header.PoolTag;

                Filter((PCHAR)&PoolTag,
                       (PCHAR)&TagName,
                       0,
                       &PoolBlock.Header,
                       PoolBlock.Header.BlockSize << POOL_BLOCK_SHIFT,
                       Pool + sizeof( POOL_HEADER ),
                       Context );

                Previous = PoolBlock.Header.BlockSize;
                Pool += (Previous << POOL_BLOCK_SHIFT);
                if ( CheckControlC() ) {
                    dprintf("\n...terminating - searched pool to %lx\n",
                            PoolPage);
                    __leave;
                }
            }
            PoolPage = (PVOID)((PCHAR)PoolPage + PageSize);
nextpage:
            if ( CheckControlC() ) {
                dprintf("\n...terminating - searched pool to %lx\n",
                        PoolPage);
                __leave;
            }
        }


    }  __finally {
    }

    LocalFree((HLOCAL)PfnDatabaseLocal);
    free (DataPage);
    return;
}



DECLARE_API( poolfind )

/*++

Routine Description:

    Find all allocations with the specified tag in the system pool.

Arguments:

    Tag - Supplies the tag to be found.

    Flags - Supplies 0 if a nonpaged pool search is desired.
            Supplies 1 if a paged pool search is desired.
            Supplies 2 if a special pool search is desired.

Return Value:

    None.

--*/

{
    CHAR        TagNameX[4] = {' ',' ',' ',' '};
    ULONG       TagName;

    UNREFERENCED_PARAMETER (hCurrentThread);
    UNREFERENCED_PARAMETER (hCurrentProcess);
    UNREFERENCED_PARAMETER (dwProcessor);
    UNREFERENCED_PARAMETER (dwCurrentPc);

    sscanf (args,"%c%c%c%c", &TagNameX[0],
                             &TagNameX[1],
                             &TagNameX[2],
                             &TagNameX[3]);

    if (TagNameX[0] == '0' && TagNameX[1] == 'x') {
        sscanf (args, "%lx %lx", &TagName);
    } else {
        TagName = TagNameX[0] | (TagNameX[1] << 8) | (TagNameX[2] << 16) | (TagNameX[3] << 24);
    }

    SearchPool (TagName, 0, CheckSingleFilterAndPrint, NULL);
}


BOOLEAN
CheckSingleFilter (
    PCHAR Tag,
    PCHAR Filter
    )

/*++

Routine Description:

    Check the tag for a filter match.

Arguments:

    Tag - Supplies the tag to be examined.

    Filter - Supplies the filter to use for matching purposes.

Return Value:

    TRUE if the Tag matches, FALSE if not.

--*/

{
    ULONG i;
    UCHAR tc;
    UCHAR fc;

    for (i = 0; i < 4; i += 1) {

        tc = (UCHAR) *Tag;

        Tag += 1;

        fc = (UCHAR) *Filter;

        Filter += 1;

        if (fc == '*') {
            break;
        }

        if (fc == '?') {
            continue;
        }

        if (tc != fc) {
            return FALSE;
        }
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\kdexts\ptov.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    ptov.c

Abstract:

    Kernel debugger extension for dumping all physical to
    virtual translations for a given process.

Author:

    John Vert (jvert) 25-Jul-1995

Revision History:

--*/
#include "precomp.h"

BOOL
ReadPhysicalPage(
    IN ULONG PageNumber,
    OUT PVOID Buffer
    );

DECLARE_API( ptov )

/*++

Routine Description:

    Dumps all physical to virtual translations for a given process

Arguments:

    args - supplies physical address of PDE

Return Value:

    None.

--*/

{
    ULONG PdeAddress;
    ULONG ActualRead;
    PHARDWARE_PTE PageDirectory;
    PHARDWARE_PTE PageTable;
    ULONG i,j;
    ULONG VirtualPage=0;

    if (sscanf(args,"%lx",&PdeAddress) != 1 || PdeAddress == 0) {
        dprintf("usage: ptov PFNOfPDE\n");
        return;
    }

    PageDirectory = LocalAlloc(LMEM_FIXED, PAGE_SIZE);
    if (PageDirectory == NULL) {
        dprintf("Couldn't allocate %d bytes for page directory\n",PAGE_SIZE);
        return;
    }
    PageTable = LocalAlloc(LMEM_FIXED, PAGE_SIZE);
    if (PageTable == NULL) {
        dprintf("Couldn't allocate %d bytes for page table\n",PAGE_SIZE);
        LocalFree(PageTable);
    }

    __try {
        if (ReadPhysicalPage(PdeAddress,PageDirectory)) {
            for (i=0;i<PAGE_SIZE/sizeof(HARDWARE_PTE);i++) {
                if (CheckControlC()) {
                    return;
                }
                if (PageDirectory[i].Valid == 1) {
                    if (!ReadPhysicalPage((ULONG)PageDirectory[i].PageFrameNumber,PageTable)) {
                        break;
                    }
                    for (j=0;j<PAGE_SIZE/sizeof(HARDWARE_PTE);j++) {
                        if ( CheckControlC() ) {
                            return;
                        }
                        if (PageTable[j].Valid == 1) {
                            dprintf("%lx %lx\n",PageTable[j].PageFrameNumber*PAGE_SIZE,VirtualPage);
                        }
                        VirtualPage+=PAGE_SIZE;
                    }
                } else {
                    VirtualPage += PAGE_SIZE * (PAGE_SIZE/sizeof(HARDWARE_PTE));
                }
            }
        }
    } __finally {
        LocalFree(PageDirectory);
        LocalFree(PageTable);
    }
}

BOOL
ReadPhysicalPage(
    IN ULONG PageNumber,
    OUT PVOID Buffer
    )
{
    ULONG i;
    ULONG64 Address;
    ULONG ActualRead;

    //
    // do the read 1k at a time to avoid overflowing the packet maximum.
    //
    Address = PageNumber << PAGE_SHIFT;
    for (i=0; i<PAGE_SIZE/1024; i++) {
        ReadPhysical(Address, Buffer, 1024, &ActualRead);
        if (ActualRead != 1024) {
            dprintf("physical read at %d failed\n",Address);
            return(FALSE);
        }
        Address += 1024;
        Buffer = (PVOID)((ULONG)Buffer + 1024);
    }
    return(TRUE);
}

DECLARE_API( vtop )

/*++

Routine Description:

    Dumps the virtual to physical translation for a page

Arguments:

    args - supplies physical address of PDE

Return Value:

    None.

--*/

{
    ULONG ActualRead;
    PHARDWARE_PTE PageDirectory;
    PHARDWARE_PTE PageTable;
    MMPTE Pte;
    ULONG i,j;
    ULONG PdeAddress = 0;
    ULONG VirtualPage= 0;

    sscanf(args,"%lx %lx",&PdeAddress,&VirtualPage);

    if (PdeAddress == 0) {
        dprintf("usage: vtop PFNOfPDE VA\n");
        return;
    }

    // Common mistake, typed in full 32 bit address, not pfn
    if( PdeAddress & ~((1 << (32-PAGE_SHIFT)) - 1) ) {
        PdeAddress >>= PAGE_SHIFT;
    }

    PageDirectory = LocalAlloc(LMEM_FIXED, PAGE_SIZE);
    if (PageDirectory == NULL) {
        dprintf("Couldn't allocate %d bytes for page directory\n",PAGE_SIZE);
        return;
    }
    PageTable = LocalAlloc(LMEM_FIXED, PAGE_SIZE);
    if (PageTable == NULL) {
        dprintf("Couldn't allocate %d bytes for page table\n",PAGE_SIZE);
        LocalFree(PageTable);
    }

    i = VirtualPage / (PAGE_SIZE*PTE_PER_PAGE);
    j = (VirtualPage % (PAGE_SIZE*PTE_PER_PAGE)) / PAGE_SIZE;

    dprintf("Pdi %x Pti %x\n",i,j);

    __try {
        if (ReadPhysicalPage(PdeAddress,PageDirectory)) {

	    if (CheckControlC()) {
                return;
            }

	    if (PageDirectory[i].Valid == 1) {
                if (!ReadPhysicalPage(PageDirectory[i].PageFrameNumber,PageTable)) {
                    return;
                }

		if (PageTable[j].Valid == 1) {
                    dprintf("%08lx %08lx pfn(%05lx)\n",
		        VirtualPage,
			PageTable[j].PageFrameNumber*PAGE_SIZE,
			PageTable[j].PageFrameNumber
			);
                }
                else {
    		    Pte.Hard = PageTable[j];
		        dprintf("%08lx Not present (%lx)\n",VirtualPage,Pte.Long);
                }
            }
            else {
                dprintf("PageDirectory Entry %u not valid, try another process\n",i);
	    }
	}
    } __finally {
        LocalFree(PageDirectory);
        LocalFree(PageTable);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\kdexts\process.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    process.c

Abstract:

    WinDbg Extension Api

Author:

    Wesley Witt (wesw) 15-Aug-1993

Environment:

    User Mode.

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

extern ULONG STeip, STebp, STesp;

PKPROCESS ProcessLastDump;
ULONG ThreadLastDump;

ULONG TotalProcessCommit;

#ifdef TARGET_i386
VOID GetStackTraceRegs(ULONG,PULONG,PULONG,PULONG);
#endif

BOOLEAN
GetTheSystemTime (
    OUT PLARGE_INTEGER Time
    );

CHAR * SecImpLevel[] = {
            "Anonymous",
            "Identification",
            "Impersonation",
            "Delegation" };

#define SecImpLevels(x) (x < sizeof( SecImpLevel ) / sizeof( PSTR ) ? \
                        SecImpLevel[ x ] : "Illegal Value" )

typedef BOOLEAN (WINAPI *PENUM_PROCESS_CALLBACK)(PVOID ProcessAddress, PVOID Process, PVOID ThreadAddress, PVOID Thread);


DECLARE_API( process )

/*++

Routine Description:

    Dumps the active process list.

Arguments:

    None.

Return Value:

    None.

--*/

{
    ULONG ProcessToDump;
    ULONG Flags;
    ULONG Result;
    LIST_ENTRY List;
    PLIST_ENTRY Next;
    ULONG ProcessHead;
    PKPROCESS Process;
    KPROCESS ProcessContents;
    PETHREAD Thread;
    ETHREAD ThreadContents;
    PCHAR ImageFileName;
    CHAR  Buf[256];

    UNREFERENCED_PARAMETER (hCurrentProcess);
    UNREFERENCED_PARAMETER (dwCurrentPc);

    ProcessToDump = 0xFFFFFFFF;
    Flags = 0xFFFFFFFF;

    RtlZeroMemory(Buf, 256);
    sscanf(args,"%lx %lx %s",&ProcessToDump, &Flags, Buf);

    if (Buf[0] != '\0') {
        ImageFileName = Buf;
    } else {
        ImageFileName = NULL;
    }

    if (ProcessToDump == 0xFFFFFFFF || ProcessToDump == 0) {
        ProcessToDump = GetNtDebuggerDataValue(PsActiveProcessHead);
        if (ProcessToDump == 0) {
            ProcessToDump = (ULONG)GetCurrentProcessAddress( dwProcessor, hCurrentThread, NULL );
            if (ProcessToDump == 0) {
                dprintf("Unable to get current process pointer.\n");
                return;
            }
        }
        if (Flags == 0xFFFFFFFF) {
            Flags = 3;
        }
    }

    Process = (PKPROCESS)ProcessToDump;

    if (!ReadMemory( (DWORD)Process, &ProcessContents, sizeof(KPROCESS), &Result )) {
        dprintf("Unable to read _KPROCESS at %lx\n",Process);
        return;
    }

    if (DumpProcess ("", &ProcessContents, Process, Flags, ImageFileName) && (Flags & 6)) {
        Next = ProcessContents.ThreadListHead.Flink;

        while ( Next != &Process->ThreadListHead) {

            Thread = (PETHREAD)(CONTAINING_RECORD(Next,KTHREAD,ThreadListEntry));
            if (!ReadMemory((DWORD)Thread,
                            &ThreadContents,
                            sizeof(ETHREAD),
                            &Result)) {
                dprintf("Unable to read _ETHREAD at %lx\n",Thread);
                break;
            }

            if (!DumpThread(dwProcessor,"        ", &ThreadContents, Thread, Flags)) {
                break;
                }


            Next = ((PKTHREAD)&ThreadContents)->ThreadListEntry.Flink;

            if (CheckControlC()) {
                return;
            }
        }
        EXPRLastDump = (ULONG)Process;
        ProcessLastDump = Process;
        dprintf("\n");
    }

    return;
}

ULONG_PTR
FindThreadFromStackPointerThisProcess(
    ULONG_PTR StackPointer,
    ULONG_PTR Process
    )
{
    ULONG_PTR list;
    LIST_ENTRY listValue;
    ULONG result;
    ULONG_PTR next;
    ULONG_PTR thread;
    ULONG_PTR threadHead;
    ULONG_PTR stackBase;
    ULONG_PTR stackBaseValue;
    ULONG_PTR stackLimit;
    ULONG_PTR stackLimitValue;

    //
    // Calculate a pointer to the ThreadListHead within that structure and
    // read it.
    //

    list = Process + FIELD_OFFSET( KPROCESS, ThreadListHead );
    if (ReadMemory( list,
                    &listValue,
                    sizeof(ULONG_PTR),
                    &result ) == 0) {
        dprintf("Unable to get value of thread list head\n");
        return 0;
    }

    next = (ULONG_PTR)listValue.Flink;
    threadHead = list;

    while (next != threadHead) {

        //
        // On control-c readmemory will fail and this call would return
        //

        //
        // Derive a pointer to the thread structure
        //

        thread = (ULONG_PTR)CONTAINING_RECORD( (PVOID)next,
                                               KTHREAD,
                                               ThreadListEntry );

        //
        // We need two values from the thread structure: the kernel thread
        // base and the kernel thread limit.
        //

        stackBase = thread +
                    FIELD_OFFSET( ETHREAD, Tcb ) +
                    FIELD_OFFSET( KTHREAD, StackBase );

        stackLimit = thread +
                    FIELD_OFFSET( ETHREAD, Tcb ) +
                    FIELD_OFFSET( KTHREAD, StackLimit );

        if (ReadMemory( stackBase,
                        &stackBaseValue,
                        sizeof(stackBaseValue),
                        &result ) == 0) {
            dprintf("Unable to get value of stack base (0x%08x)\n",
                     stackBase);
            return 0;
        }

        if (StackPointer <= stackBaseValue) {

            if (ReadMemory( stackLimit,
                            &stackLimitValue,
                            sizeof(stackLimitValue),
                            &result ) == 0) {
                dprintf("Unable to get value of stack limit\n");
                return 0;
            }

            if (StackPointer >  stackLimitValue) {

                //
                // We have found our thread.
                //

                return thread;
            }
        }

        //
        // Look at the next thread
        //

        list = thread +
               FIELD_OFFSET( KTHREAD, ThreadListEntry );

        if (ReadMemory( list,
                        &listValue,
                        sizeof(ULONG_PTR),
                        &result ) == 0) {
            dprintf("Unable to read value of ThreadListEntry\n");
            return 0;
        }

        next = (ULONG_PTR)listValue.Flink;
    }

    return 0;
}



ULONG_PTR
FindThreadFromStackPointer(
    ULONG_PTR StackPointer
    )
{
    ULONG_PTR processHead;
    ULONG_PTR list;
    LIST_ENTRY listValue;
    ULONG_PTR next;
    ULONG_PTR process;
    ULONG_PTR thread;
    ULONG result;

    //
    // First check the idle process, which is not included in the PS
    // process list.
    //

    process = GetExpression( "xboxkrnl!KeIdleProcess" );
    if (process != 0) {

        if (ReadMemory( process,
                        &process,
                        sizeof(PVOID),
                        &result ) != 0) {

            thread = FindThreadFromStackPointerThisProcess( StackPointer,
                                                            process );

            if (thread != 0) {
                return thread;
            }
        }
    }

    //
    // Now check the single system process.
    //

    process = GetNtDebuggerDataValue(PsActiveProcessHead);
    if (process != 0) {

        thread = FindThreadFromStackPointerThisProcess( StackPointer,
                                                        process );

        if (thread != 0) {
            return thread;
        }
    }

    return 0;
}

DECLARE_API( thread )

/*++

Routine Description:

    Dumps the specified thread.

Arguments:

    None.

Return Value:

    None.

--*/

{
    ULONG       Address;
    ULONG       Flags;
    ULONG       result;
    PETHREAD    Thread;
    ETHREAD     ThreadContents;
    char        threadExprBuf[256] ;

    UNREFERENCED_PARAMETER (hCurrentProcess);
    UNREFERENCED_PARAMETER (dwCurrentPc);

    Address = 0xFFFFFFFF;
    Flags = 6;

    threadExprBuf[0] = '\0';

    sscanf(args,"%s %lx",threadExprBuf,&Flags);

    if (threadExprBuf[0]) {
        if (IsHexNumber(threadExprBuf)) {
            sscanf(threadExprBuf, "%lx", &Address) ;
        } else {
            Address = GetExpression(threadExprBuf);
            if (Address==0) {
                dprintf("An error occured trying to evaluate the expression\n") ;
                return;
            }
        }
    }

    if (Address == 0xFFFFFFFF) {
        Address = (ULONG)GetCurrentThreadAddress( (USHORT)dwProcessor, hCurrentThread);
    }

    Thread = (PETHREAD)(PVOID)Address;
    if ( !ReadMemory( (DWORD)Thread,
                      &ThreadContents,
                      sizeof(ETHREAD),
                      &result) ) {
        dprintf("%08lx: Unable to get thread contents\n", Thread );
        return;
    }

    if (ThreadContents.Tcb.Header.Type != ThreadObject &&
        Address > MM_USER_PROBE_ADDRESS) {

        ULONG_PTR stackThread;

        //
        // What was passed in was not a thread.  Maybe it was a kernel stack
        // pointer.  Search the thread stack ranges to find out.
        //

        dprintf("%x is not a thread object, interpreting as stack value...\n",Address);
        stackThread = FindThreadFromStackPointer( (ULONG_PTR)Address );
        if (stackThread != 0) {

            if ( !ReadMemory( stackThread,
                              &ThreadContents,
                              sizeof(ETHREAD),
                              &result) ) {
                dprintf("%08lx: Unable to get thread contents\n", Address );
                return;
            }

            Thread = (PETHREAD)stackThread;
        }
    }

    DumpThread (dwProcessor,"", &ThreadContents, Thread, Flags);
    EXPRLastDump = (ULONG)Thread;
    ThreadLastDump = (ULONG)Thread;
    return;

}

BOOL
DumpProcess(
    IN char * pad,
    IN PKPROCESS ProcessContents,
    IN PKPROCESS RealProcessBase,
    IN ULONG Flags,
    IN PCHAR    ImageFileName OPTIONAL
    )
{
    OBJECT_HANDLE_TABLE HandleTable;
    ULONG NumberOfHandles;
    WCHAR Buf[256];
    ULONG Result;
    STRING  string1, string2;

    //
    // Get the image file name
    //
    strcpy((PCHAR)Buf,"System Process");

    if (ImageFileName != NULL) {
        RtlInitString(&string1, ImageFileName);
        RtlInitString(&string2, (PCSZ) Buf);
        if (RtlCompareString(&string1, &string2, TRUE) != 0) {
            return TRUE;
        }
    }

    NumberOfHandles = 0;
    if (ReadMemory((DWORD)GetNtDebuggerData(ObpObjectHandleTable),
                     &HandleTable,
                     sizeof(HandleTable),
                     &Result)) {

        NumberOfHandles = HandleTable.HandleCount;
    }

    dprintf("%sPROCESS %08lx\n",
            pad,
            RealProcessBase
           );

    dprintf("%s    ObjectTable: %08lx  TableSize: %3u.\n",
            pad,
            GetNtDebuggerData(ObpObjectHandleTable),
            NumberOfHandles
            );

    dprintf("%s    Image: %s\n",pad,Buf);

    if (!(Flags & 1)) {
        dprintf("\n");
        return TRUE;
    }

    dprintf("%s    BasePriority                      %ld\n", pad, ProcessContents->BasePriority);


    dprintf("\n");
    return TRUE;
}


UCHAR *WaitReasonList[] = {
    (PUCHAR) "Executive",
    (PUCHAR) "FreePage",
    (PUCHAR) "PageIn",
    (PUCHAR) "PoolAllocation",
    (PUCHAR) "DelayExecution",
    (PUCHAR) "Suspended",
    (PUCHAR) "UserRequest",
    (PUCHAR) "WrExecutive",
    (PUCHAR) "WrFreePage",
    (PUCHAR) "WrPageIn",
    (PUCHAR) "WrPoolAllocation",
    (PUCHAR) "WrDelayExecution",
    (PUCHAR) "WrSuspended",
    (PUCHAR) "WrUserRequest",
    (PUCHAR) "WrEventPairHigh",
    (PUCHAR) "WrEventPairLow",
    (PUCHAR) "WrLpcReceive",
    (PUCHAR) "WrLpcReply",
    (PUCHAR) "WrVirtualMemory",
    (PUCHAR) "WrPageOut",
    (PUCHAR) "WrRendezvous",
    (PUCHAR) "WrFsCacheIn",
    (PUCHAR) "WrFsCacheOut",
    (PUCHAR) "Spare4",
    (PUCHAR) "Spare5",
    (PUCHAR) "Spare6",
    (PUCHAR) "Spare7"};

BOOL
DumpThread (
    IN ULONG Processor,
    IN char *Pad,
    IN PETHREAD Thread,
    IN PETHREAD RealThreadBase,
    IN ULONG Flags
    )
{
    #define MAX_STACK_FRAMES  40
    TIME_FIELDS Times;
    LARGE_INTEGER RunTime;
    ULONG Address;
    ULONG Result;
    KMUTANT WaitObject;
    PVOID PointerWaitObject = &WaitObject;
    PKWAIT_BLOCK WaitBlock;
    KWAIT_BLOCK OutsideBlock;
    ULONG WaitOffset;
    PKPROCESS Process;
    CHAR Buffer[256];
    ULONG TimeIncrement;
    ULONG frames = 0;
    ULONG i;
    ULONG displacement;
    EXTSTACKTRACE stk[MAX_STACK_FRAMES];
#ifdef TARGET_i386
    struct {
        KSWITCHFRAME Frame;
        DWORD SavedEbp;
    } SwitchFrame;
#endif

    UNREFERENCED_PARAMETER (Processor);

    if (Thread->Tcb.Header.Type != ThreadObject) {
        dprintf("TYPE mismatch for thread object at %lx\n",RealThreadBase);
        return FALSE;
    }

    dprintf("%sTHREAD %lx  tid: %lx  ",
        Pad,
        RealThreadBase,
        Thread->UniqueThread
        );


    switch (Thread->Tcb.State) {
        case Initialized:
            dprintf("%s","INITIALIZED");break;
        case Ready:
            dprintf("%s","READY");break;
        case Running:
            dprintf("%s","RUNNING");break;
        case Standby:
            dprintf("%s","STANDBY");break;
        case Terminated:
            dprintf("%s","TERMINATED");break;
        case Waiting:
            dprintf("%s","WAIT");break;
        case Transition:
            dprintf("%s","TRANSITION");break;
    }

    if (!(Flags & 2)) {
        dprintf("\n");
        return TRUE;
        }

    if (Thread->Tcb.State == Waiting) {
        dprintf(": (%s) %s %s\n",
            WaitReasonList[Thread->Tcb.WaitReason],
            (Thread->Tcb.WaitMode==KernelMode) ? "KernelMode" : "UserMode",Thread->Tcb.Alertable ? "Alertable" : "Non-Alertable");
        if ( Thread->Tcb.SuspendCount ) {
            dprintf("SuspendCount %lx\n",Thread->Tcb.SuspendCount);
        }

        WaitOffset =
               (ULONG)Thread->Tcb.WaitBlockList - (ULONG)RealThreadBase;

        if (WaitOffset > (ULONG)sizeof(ETHREAD)) {
            if (!ReadMemory((DWORD)Thread->Tcb.WaitBlockList,
                            &OutsideBlock,
                            sizeof(KWAIT_BLOCK),
                            &Result)) {
                dprintf("%sunable to get Wait object\n",Pad);
                goto BadWaitBlock;
            }
            WaitBlock = &OutsideBlock;
        } else {
            WaitBlock = (PKWAIT_BLOCK)((ULONG)Thread + WaitOffset);
        }

        do {

            dprintf("%s    %lx  ",Pad,WaitBlock->Object);

            if (!ReadMemory((DWORD)WaitBlock->Object,
                            &WaitObject,
                            sizeof(KMUTANT),
                            &Result)) {
                dprintf("%sunable to get Wait object\n",Pad);
                break;
            }

            switch (WaitObject.Header.Type) {
                case EventNotificationObject:
                    dprintf("NotificationEvent\n");
                    break;
                case EventSynchronizationObject:
                    dprintf("SynchronizationEvent\n");
                    break;
                case SemaphoreObject:
                    dprintf("Semaphore Limit 0x%lx\n",
                             ((PKSEMAPHORE)PointerWaitObject)->Limit);
                    break;
                case ThreadObject:
                    dprintf("Thread\n");
                    break;
                case TimerNotificationObject:
                    dprintf("NotificationTimer\n");
                    break;
                case TimerSynchronizationObject:
                    dprintf("SynchronizationTimer\n");
                    break;
                case EventPairObject:
                    dprintf("EventPair\n");
                    break;
                case ProcessObject:
                    dprintf("ProcessObject\n");
                    break;
                case MutantObject:
                    dprintf("Mutant - owning thread %lx\n",
                            ((PKMUTANT)PointerWaitObject)->OwnerThread);
                    break;
                case QueueObject:
                    dprintf("QueueObject\n");
                    break;
                default:
                    dprintf("Unknown\n");
                    break;
            }

            if (WaitBlock->NextWaitBlock == Thread->Tcb.WaitBlockList) {
                break;
            }
            WaitOffset =
                   (ULONG)WaitBlock->NextWaitBlock - (ULONG)RealThreadBase;

            if (WaitOffset > (ULONG)sizeof(ETHREAD)) {

                if (!ReadMemory((DWORD)WaitBlock->NextWaitBlock,
                                &OutsideBlock,
                                sizeof(KWAIT_BLOCK),
                                &Result)) {
                    dprintf("%sunable to get Wait object\n",Pad);
                    break;
                }
                WaitBlock = &OutsideBlock;
            } else {
                WaitBlock = (PKWAIT_BLOCK)((ULONG)Thread + WaitOffset);
            }
        } while ( TRUE );
    } else {
        dprintf("\n");
    }

BadWaitBlock:
    if (!(Flags & 4)) {
        dprintf("\n");
        return TRUE;
    }


    if (Thread->IrpList.Flink != Thread->IrpList.Blink ||
        Thread->IrpList.Flink != &RealThreadBase->IrpList
       ) {

        ULONG IrpListHead = (ULONG)&RealThreadBase->IrpList;
        PLIST_ENTRY Next;
        IRP IrpContents;
        PIRP p;
        ULONG Counter = 0;

        Next = Thread->IrpList.Flink;
        dprintf("%sIRP List:\n",Pad);
        while (((ULONG)Next != IrpListHead) && (Counter < 17)) {
            Counter += 1;
            Address = (ULONG)CONTAINING_RECORD(Next,IRP,ThreadListEntry);
            if (!ReadMemory((DWORD)Address,
                           &IrpContents,
                           sizeof(IRP),
                           &Result)) {
                dprintf( "%sunable to get IRP object\n", Pad );
                break;
            }

            p = &IrpContents;
            dprintf("%s    %08lx: (%04x,%04x) Flags: %08lx  Buffer: %08lx\n",
                    Pad,Address,p->Type,p->Size,p->Flags,p->UserBuffer);

            Next = p->ThreadListEntry.Flink;
        }
    }

    Process = Thread->Tcb.ApcState.Process;
    dprintf("%sOwning Process %lx  XapiThread %lx\n", Pad, Process, Thread->Tcb.TlsData);

    GetTheSystemTime (&RunTime);

    dprintf("%sWaitTime (ticks)        %ld\n",
              Pad,
              Thread->Tcb.WaitTime);

    dprintf("%sContext Switch Count    %ld",
              Pad,
              Thread->Tcb.ContextSwitches);

    dprintf ("\n");

    //
    // Get the time increment value which is used to compute runtime.
    //
    TimeIncrement = GetNtDebuggerDataValue( KeTimeIncrement );

    RunTime.QuadPart = UInt32x32To64(Thread->Tcb.KernelTime, TimeIncrement);
    RtlTimeToElapsedTimeFields ( &RunTime, &Times);
    dprintf("%sKernelTime              %3ld:%02ld:%02ld.%04ld\n",
              Pad,
              Times.Hour,
              Times.Minute,
              Times.Second,
              Times.Milliseconds);

    dumpSymbolicAddress((ULONG)Thread->StartAddress, (PUCHAR)Buffer, TRUE);
    dprintf("%sStart Address %s\n",
        Pad,
        Buffer
        );

    dprintf("%sStack Current %lx Base %lx Limit %lx\n",
        Pad,
        Thread->Tcb.KernelStack,
        Thread->Tcb.StackBase,
        Thread->Tcb.StackLimit
        );

    dprintf("%sPriority %ld BasePriority %ld PriorityDecrement %ld DecrementCount %ld\n",
        Pad,
        Thread->Tcb.Priority,
        Thread->Tcb.BasePriority,
        Thread->Tcb.PriorityDecrement,
        Thread->Tcb.DecrementCount
        );

#ifdef TARGET_i386

    if (Thread->Tcb.State == Running) {
        ULONG Cpu;
        PROCESSORINFO ProcessorInfo;

        //
        // Default to the old (broken) processor number.
        //

        Cpu = 0;

        if (Ioctl(IG_KD_CONTEXT, &ProcessorInfo, sizeof(ProcessorInfo))) {
            if (ProcessorInfo.NumberProcessors != 1) {
                PVOID * KiProcessorBlock;

                KiProcessorBlock = (PVOID *)GetExpression("xboxkrnl!KiProcessorBlock");
                if (KiProcessorBlock) {
                    for (i = 0; i < ProcessorInfo.NumberProcessors; i++) {

                        //
                        // Check the PRCB for this processor to see
                        // if the current thread is the thread we are
                        // dumping.
                        //

                        PKPRCB ProcessorBlockN;
                        PVOID  ProcessorThread;

                        ReadMemory((DWORD)(KiProcessorBlock + i),
                                   &ProcessorBlockN,
                                   sizeof(ProcessorBlockN),
                                   &Result);

                        if (Result != sizeof(ProcessorBlockN)) {

                            //
                            // Read failed, give up.
                            //

                            break;
                        }

                        ReadMemory((DWORD)&ProcessorBlockN->CurrentThread,
                                   &ProcessorThread,
                                   sizeof(ProcessorThread),
                                   &Result);
                        if (Result != sizeof(ProcessorThread)) {

                            //
                            // Couldn't read CurrentThread from PRCB
                            // something's wrong, give up.
                            //

                            break;
                        }

                        if (ProcessorThread == (PVOID)RealThreadBase) {

                            //
                            // Found it!
                            //

                            Cpu = i;
                            break;
                        }
                    }

                    //
                    // We get here, either we found it or we didn't.
                    // If we didn't find it, it's set to the processor
                    // in the same way as it was before we decided to
                    // search for it,... 
                    //
                }
            }
        }
        GetStackTraceRegs( Cpu, &STeip, &STebp, &STesp );
        SetThreadForOperation( (PULONG)&RealThreadBase );
        frames = StackTrace( STebp, STesp, STeip, stk, MAX_STACK_FRAMES );
    } else {
        //
        // Get SwitchFrame and perform backtrace providing EBP,ESP,EIP
        // (full FPO backtrace context)
        //
        // N.B. The dword immediately preceding the switch frame contains
        //      the saved EBP.
        //
        ZeroMemory( &SwitchFrame, sizeof(SwitchFrame) );
        ReadMemory(
            (DWORD)Thread->Tcb.KernelStack,
            (PVOID)&SwitchFrame,
            sizeof(SwitchFrame),
            &Result
            );
        if (Result == sizeof(SwitchFrame)) {
            STeip = SwitchFrame.Frame.RetAddr;
            STebp = SwitchFrame.SavedEbp;
            STesp = (ULONG) Thread->Tcb.KernelStack + sizeof(KSWITCHFRAME);

            //
            // Terminated threads don't necessarily have decent switch frames.
            //

            if ((Thread->Tcb.State != Terminated) ||
                (PAGE_ALIGN(STebp) == PAGE_ALIGN(STesp))) {

                SetThreadForOperation( (PULONG)&RealThreadBase );
                frames = StackTrace( STebp, STesp, STeip, stk, MAX_STACK_FRAMES );
            }
        }
    }

#elif defined(TARGET_MIPS) || defined(TARGET_ALPHA) || defined(TARGET_PPC)

    if (Thread->Tcb.State != Running) {
        SetThreadForOperation( (PULONG)&RealThreadBase );
        frames = StackTrace( (DWORD)Thread->Tcb.KernelStack,
                             (DWORD)Thread->Tcb.KernelStack,
                             0,
                             stk,
                             MAX_STACK_FRAMES
                             );
    }

#endif

    for (i=0; i<frames; i++) {

        if (i==0) {
#ifdef TARGET_PPC
            dprintf( "\n%sChildEBP RetAddr\n", Pad );
#else
            dprintf( "\n%sChildEBP RetAddr  Args to Child\n", Pad );
#endif
        }

        Buffer[0] = '!';
        GetSymbol((LPVOID)stk[i].ProgramCounter, (PUCHAR)Buffer, &displacement);

#ifdef TARGET_PPC
        dprintf( "%s%08x %08x %s",
                 Pad,
                 stk[i].FramePointer,
                 stk[i].ReturnAddress,
                 Buffer
               );
#else
        dprintf( "%s%08x %08x %08x %08x %08x %s",
                 Pad,
                 stk[i].FramePointer,
                 stk[i].ReturnAddress,
                 stk[i].Args[0],
                 stk[i].Args[1],
                 stk[i].Args[2],
                 Buffer
               );
#endif

        if (displacement) {
            dprintf( "+0x%x", displacement );
        }

        dprintf( "\n" );
    }

    dprintf("\n");
    return TRUE;
}

DECLARE_API( threadfields )

/*++

Routine Description:

    Displays the field offsets for ETHREAD type.

Arguments:

    None.

Return Value:

    None.

--*/

{
    UNREFERENCED_PARAMETER (args);
    UNREFERENCED_PARAMETER (hCurrentThread);
    UNREFERENCED_PARAMETER (hCurrentProcess);
    UNREFERENCED_PARAMETER (dwProcessor);
    UNREFERENCED_PARAMETER (dwCurrentPc);

    dprintf(" ETHREAD structure offsets:\n\n");

    dprintf("    Tcb:                           0x%lx\n", FIELD_OFFSET(ETHREAD, Tcb) );
    dprintf("    CreateTime:                    0x%lx\n", FIELD_OFFSET(ETHREAD, CreateTime) );
    dprintf("    ExitTime:                      0x%lx\n", FIELD_OFFSET(ETHREAD, ExitTime) );
    dprintf("    ExitStatus:                    0x%lx\n", FIELD_OFFSET(ETHREAD, ExitStatus) );
    dprintf("    ReaperListEntry:               0x%lx\n", FIELD_OFFSET(ETHREAD, ReaperListEntry) );
    dprintf("    ActiveTimerListHead:           0x%lx\n", FIELD_OFFSET(ETHREAD, ActiveTimerListHead) );

    dprintf("    IrpList:                       0x%lx\n", FIELD_OFFSET(ETHREAD, IrpList) );
    dprintf("    HasTerminated:                 0x%lx\n", FIELD_OFFSET(KTHREAD, HasTerminated) );
    dprintf("    StartAddress:                  0x%lx\n", FIELD_OFFSET(ETHREAD, StartAddress) );

    return;

}

PVOID
GetCurrentProcessAddress(
    DWORD    Processor,
    HANDLE   hCurrentThread,
    PETHREAD CurrentThread
    )

{
    ULONG Result;
    ETHREAD Thread;

    if (CurrentThread == NULL) {
        CurrentThread = (PETHREAD)GetCurrentThreadAddress( (USHORT)Processor, hCurrentThread );
        if (CurrentThread == NULL) {
            return NULL;
        }
    }

    if (!ReadMemory((DWORD)CurrentThread, &Thread, sizeof(Thread), &Result)) {
        return NULL;
    }

    return Thread.Tcb.ApcState.Process;
}

PVOID
GetCurrentThreadAddress(
    USHORT Processor,
    HANDLE hCurrentThread
    )
{
    ULONG Address;

#ifdef TARGET_ALPHA

    UNREFERENCED_PARAMETER (hCurrentThread);

    ReadControlSpace( (USHORT)Processor,
                      DEBUG_CONTROL_SPACE_THREAD,
                      (PVOID)&Address,
                      sizeof(PKTHREAD)
                     );

    return CONTAINING_RECORD(Address, ETHREAD, Tcb);

#elif defined(TARGET_MIPS)

    KPRCB  Prcb;

    if (!ReadPcr(Processor, &Prcb, &Address, hCurrentThread)) {
        dprintf("Unable to read PCR for Processor %u\n",Processor);
        return NULL;
    }

    return CONTAINING_RECORD(Prcb.CurrentThread,ETHREAD,Tcb);

#elif defined(TARGET_PPC)

    KPCR  Pcr;
    PKPCR pp;
    KPRCB Prcb;
    ULONG Result;

    Processor = 0;
    pp = &Pcr;
    if (!ReadPcr(Processor, pp, &Address, hCurrentThread)) {
        dprintf("Unable to read PCR for Processor %u\n",Processor);
        return NULL;
    }

    //
    // Address -> base of the pcr, read the PCR in.
    //

    if (!ReadMemory((DWORD)pp->Prcb, &Prcb, sizeof(KPRCB), &Result)) {
        return NULL;
    }

    return CONTAINING_RECORD(Prcb.CurrentThread,ETHREAD,Tcb);

#elif defined(TARGET_i386)

    KPCR  Pcr;
    PKPCR pp;

    pp = &Pcr;
    if (!ReadPcr(Processor, pp, &Address, hCurrentThread)) {
        dprintf("Unable to read PCR for Processor %u\n",Processor);
        return NULL;
    }

    return CONTAINING_RECORD(pp->PrcbData.CurrentThread,ETHREAD,Tcb);

#else

#error( "unknown processor type" )

#endif
}


#if defined(TARGET_i386)
#define SYSTEM_TIME_ADDRESS  KI_USER_SHARED_DATA
#elif defined(TARGET_MIPS)
#define SYSTEM_TIME_ADDRESS  KIPCR2
#elif defined(TARGET_ALPHA)
#define SYSTEM_TIME_ADDRESS  KI_USER_SHARED_DATA
#elif defined(TARGET_PPC)
#define SYSTEM_TIME_ADDRESS  KI_USER_SHARED_DATA
#else
#error( "unknown target machine" );
#endif



//+---------------------------------------------------------------------------
//
//  Function:   GetHandleTableAddress
//
//  Synopsis:   Return the address of the handle table given a thread handle
//
//  Arguments:  [Processor]      -- processor number
//              [hCurrentThread] -- thread handle
//
//  Returns:    address of handle table or null
//
//  History:    9-23-1998   benl   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

PVOID GetHandleTableAddress(
    USHORT Processor,
    HANDLE hCurrentThread
    )
{
    return (PVOID)GetNtDebuggerDataValue(ObpObjectHandleTable);
} // GetHandleTableAddress


BOOLEAN
GetTheSystemTime (
    OUT PLARGE_INTEGER Time
    )
{
    ULONG              Result;

    ZeroMemory( Time, sizeof(*Time) );

    if (!ReadMemory( GetExpression("xboxkrnl!KeSystemTime"),
                     Time,
                     sizeof(*Time),
                     &Result) ) {
        dprintf("Unable to get system time\n");
        return FALSE;
    }

    return TRUE;
}

VOID
dumpSymbolicAddress(
    ULONG Address,
    PUCHAR Buffer,
    BOOL AlwaysShowHex
    )
{
    ULONG displacement;
    PUCHAR s;

    Buffer[0] = '!';
    GetSymbol((LPVOID)Address, Buffer, &displacement);
    s = Buffer + strlen( (PCHAR)Buffer );
    if (s == Buffer) {
        sprintf( (PCHAR)s, "0x%08x", Address );
        }
    else {
        if (displacement != 0) {
            sprintf( (PCHAR)s, "+0x%x", displacement );
            }
        if (AlwaysShowHex) {
            sprintf( (PCHAR)s, " (0x%08x)", Address );
            }
        }

    return;
}

PVOID
LookupUniqueId(
    HANDLE UniqueId
    )
{
    return NULL;
}

int
__cdecl
CmpFunc(
    const void *pszElem1,
    const void *pszElem2
    )
{
    PPROCESS_COMMIT_USAGE p1, p2;

    p1 = (PPROCESS_COMMIT_USAGE)pszElem1;
    p2 = (PPROCESS_COMMIT_USAGE)pszElem2;
    return p2->CommitCharge - p1->CommitCharge;
}

PPROCESS_COMMIT_USAGE
GetProcessCommit (
    PULONG TotalCommitCharge,
    PULONG NumberOfProcesses
    )
{
    PPROCESS_COMMIT_USAGE p;
    ULONG n;
    PKPROCESS Process;
    KPROCESS ProcessContents;
    ULONG Total;
    ULONG Result;

    Total = 0;

    n = 0;
    p = HeapAlloc( GetProcessHeap(), 0, 1 );

    Process = (PKPROCESS)GetNtDebuggerDataValue( PsActiveProcessHead );
    if (!Process) {
        dprintf("Unable to get value of PsActiveProcessHead\n");
        return 0;
    }

    if (!ReadMemory( (DWORD)Process, &ProcessContents, sizeof(KPROCESS), &Result )) {
        dprintf("Unable to read _KPROCESS at %lx\n",Process);
        return 0;
    }

    n += 1;
    p = HeapReAlloc( GetProcessHeap(), HEAP_ZERO_MEMORY, p, n * sizeof( *p ) );
    if (p != NULL) {
        strcpy( (PCHAR)p[ n-1 ].ImageFileName, "unknown");
        p[ n-1 ].CommitCharge = 0;
        p[ n-1 ].NumberOfPrivatePages = 0;
        p[ n-1 ].NumberOfLockedPages = 0;
    }

    qsort( p, n, sizeof( *p ), CmpFunc );

    *TotalCommitCharge = Total;
    *NumberOfProcesses = n;
    return p;
}


/*++

Routine Description:

    Helper function exported for other extensions to walk the process tree

Arguments:

    Callback -- a function to callback to for every thread.

Return Value:

    None.

--*/



VOID
EnumerateProcesses (
    IN PENUM_PROCESS_CALLBACK Callback
    )
{
    ULONG Result;
    PLIST_ENTRY NextThread;
    PLIST_ENTRY NextProcess;
    PKPROCESS Process;
    KPROCESS ProcessContents;
    PETHREAD Thread;
    ETHREAD  ThreadContents;

    Process = (PKPROCESS)GetNtDebuggerDataValue( PsActiveProcessHead );
    if (!Process) {
        dprintf("Unable to get value of PsActiveProcessHead, 0x%x\n", KdDebuggerData.PsActiveProcessHead);
        return;
    }

    if (!ReadMemory( (DWORD)Process, &ProcessContents, sizeof(KPROCESS), &Result )) {
        dprintf( "Unable to read _KPROCESS at %lx\n",Process );
        return;
    }

    NextThread = ProcessContents.ThreadListHead.Flink;
    while ( NextThread != &Process->ThreadListHead ) {

        Thread = (PETHREAD)(CONTAINING_RECORD( NextThread, KTHREAD, ThreadListEntry));

        if (!ReadMemory( (DWORD)Thread,
                         &ThreadContents,
                         sizeof( ETHREAD ),
                         &Result)) {
            dprintf( "Unable to read _ETHREAD at %lx in process 0x%x\n", Thread, Process );
            break;
        }

        NextThread = ((PKTHREAD)&ThreadContents)->ThreadListEntry.Flink;

        //
        //  Do callback
        //

        if (!Callback( Process, &ProcessContents, Thread, &ThreadContents )) {
            return;
        }

        if (CheckControlC()) {
            return;
        }

    } //  endwhile traversing threads
}

ULONG_PTR ZombieCount;
ULONG_PTR ZombiePool;
ULONG_PTR ZombieCommit;
ULONG_PTR ZombieResidentAvailable;

#define BLOB_LONGS 32

BOOLEAN WINAPI
CheckForZombieThread(
    IN PCHAR Tag,
    IN PCHAR Filter,
    IN ULONG Flags,
    IN PPOOL_HEADER PoolHeader,
    IN ULONG BlockSize,
    IN PVOID Data,
    IN PVOID Context
    )
{
    ULONG           result;
    ETHREAD         ThreadContents;
    PETHREAD        Thread;
    PKTHREAD        KThread;
    OBJECT_HEADER   ObjectHeaderContents;
    POBJECT_HEADER  ObjectHeader;
    ULONG           Blob[BLOB_LONGS];
    ULONG           i;
    PVOID           StackBase;
    PVOID           StackLimit;

    UNREFERENCED_PARAMETER (Flags);
    UNREFERENCED_PARAMETER (BlockSize);
    UNREFERENCED_PARAMETER (Context);

    if (PoolHeader == NULL) {
        return FALSE;
    }

    if ((PoolHeader->PoolIndex & 0x80) == 0) {
        return FALSE;
    }

    if (!CheckSingleFilter (Tag, Filter)) {
        return FALSE;
    }

    if ((PoolHeader->BlockSize << POOL_BLOCK_SHIFT) < sizeof(Blob)) {
        return FALSE;
    }

    //
    // There must be a better way to find the object header given the start
    // of a pool block ?
    //

    if (!ReadMemory ((ULONG) Data,
                    &Blob[0],
                    sizeof(Blob),
                    &result)) {
        dprintf ("Could not read process blob at %p\n", Data);
        return FALSE;
    }

    for (i = 0; i < BLOB_LONGS; i += 1) {
        KThread = (PKTHREAD)&Blob[i];
        if ((KThread->Header.Type == ThreadObject) &&
            (KThread->Header.Size == sizeof(KTHREAD) / sizeof(LONG))) {

            break;
        }
    }

    if (i == BLOB_LONGS) {
        return FALSE;
    }

    ObjectHeader = OBJECT_TO_OBJECT_HEADER ((PULONG)Data + i);

    if (!ReadMemory ((ULONG) ObjectHeader,
                    &ObjectHeaderContents,
                    sizeof(OBJECT_HEADER),
                    &result)) {
        dprintf ("Could not read process object header at %p\n", ObjectHeader);
        return FALSE;
    }

    Thread = (PETHREAD)(&ObjectHeader->Body);

    if (!ReadMemory ((ULONG) Thread,
                    &ThreadContents,
                    sizeof(ETHREAD),
                    &result)) {

        dprintf ("Could not read thread data at %p\n", Thread);
        return FALSE;
    }

    KThread = (PKTHREAD)&ThreadContents;

    if (KThread->State != Terminated) {
        return FALSE;
    }

    dprintf ("HandleCount: %u  PointerCount: %u\n",
            ObjectHeaderContents.HandleCount, ObjectHeaderContents.PointerCount);
    DumpThread (0, "", &ThreadContents, Thread, 7);

    ZombieCount += 1;

    ZombiePool += (PoolHeader->BlockSize << POOL_BLOCK_SHIFT);
    ZombieCommit += ((PCHAR)KThread->StackBase - (PCHAR)KThread->StackLimit);

    StackBase = (PVOID)((PCHAR)KThread->StackBase - 1);
    StackLimit = KThread->StackLimit;

    while (StackBase >= StackLimit) {
        if (GetAddressState(StackBase) == ADDRESS_VALID) {
            ZombieResidentAvailable += PAGE_SIZE;
        }
        StackBase = (PVOID)((PCHAR)StackBase - PAGE_SIZE);
    }

    return TRUE;
}

DECLARE_API( zombies )

/*++

Routine Description:

    Finds zombie processes and threads in non-paged pool.

Arguments:

    None.

Return Value:

    None.

--*/


{
    ULONG       Flags;
    ULONG       RestartAddress;
    ULONG       TagName;

    UNREFERENCED_PARAMETER (hCurrentThread);
    UNREFERENCED_PARAMETER (hCurrentProcess);
    UNREFERENCED_PARAMETER (dwProcessor);
    UNREFERENCED_PARAMETER (dwCurrentPc);

    Flags = 1;
    RestartAddress = 0;

    sscanf(args,"%lx %lx", &Flags, &RestartAddress);

    if ((Flags & 0x3) == 0) {
        dprintf("Invalid parameter for !zombies\n");
        return;
    }

    if (Flags & 0x2) {

        dprintf("Looking for zombie threads...");

        TagName = '?rhT';
    
        ZombieCount = 0;
        ZombiePool = 0;
        ZombieCommit = 0;
        ZombieResidentAvailable = 0;

        SearchPool (TagName, RestartAddress, &CheckForZombieThread, NULL);
        SearchPool (TagName, RestartAddress, &CheckForZombieThread, NULL);

    }

    //
    // Print summary statistics last so they don't get lost on screen scroll.
    //

    if (Flags & 0x2) {
        if (ZombieCount == 0) {
            dprintf ("\n\n************ NO zombie threads found ***********\n");
        }
        else {
            dprintf ("\n\n************ %d zombie threads found ***********\n", ZombieCount);
            dprintf ("       Resident page cost : %8ld Kb\n",
                ZombieResidentAvailable / 1024);
            dprintf ("       Commit cost :        %8ld Kb\n",
                ZombieCommit / 1024);
            dprintf ("       Pool cost :          %8ld bytes\n",
                ZombiePool);
        }
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\kdexts\stacks.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    stacks.c

Abstract:

    WinDbg Extension Api

Author:

    Adrian J. Oney (adriao) 07-28-1998

Environment:

    User Mode.

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#define ETHREAD_NOT_READABLE    1
#define THREAD_VALID            2
#define FIRST_THREAD_VALID      3
#define NO_THREADS              4

struct _BLOCKER_TREE ;
typedef struct _BLOCKER_TREE BLOCKER_TREE, *PBLOCKER_TREE ;

BOOL
StacksValidateProcess(
    IN PKPROCESS RealProcessBase,
    IN PKPROCESS ProcessContents
    );

BOOL
StacksValidateThread(
    IN PETHREAD Thread,
    IN PETHREAD RealThreadBase
    );

VOID StacksDumpProcessAndThread(
    IN PKPROCESS ProcessContents,
    IN PKPROCESS RealProcessBase,
    IN ULONG     ThreadDesc,
    IN PETHREAD  Thread,
    IN PETHREAD  RealThreadBase,
    IN PBLOCKER_TREE BlockerTree,
    IN ULONG     Verbosity
    );

VOID StacksGetThreadStateName(
    IN PETHREAD Thread,
    OUT PCHAR Dest
    );

VOID
DumpThreadBlockageInfo (
    IN char *pad,
    IN PETHREAD Thread,
    IN PETHREAD RealThreadBase,
    IN ULONG Verbosity
    );

VOID
DumpThreadStackInfo (
    IN char *pad,
    IN PETHREAD Thread,
    IN PETHREAD RealThreadBase,
    IN ULONG Verbosity
    );

extern ULONG STeip, STebp, STesp;

PKPROCESS ProcessLastDump;
ULONG ThreadLastDump;

ULONG TotalProcessCommit;

#ifdef TARGET_i386
VOID GetStackTraceRegs(ULONG,PULONG,PULONG,PULONG);
#endif

struct _BLOCKER_TREE {
   char const *Symbolic ;
   PBLOCKER_TREE Child ;
   PBLOCKER_TREE Sibling ;
   PBLOCKER_TREE Parent ;
   BOOL Nested ;
} ;

VOID
GetThreadBlocker (
    IN PETHREAD Thread,
    IN PETHREAD RealThreadBase,
    IN ULONG Verbosity,
    IN PBLOCKER_TREE BlockerTree,
    OUT PCHAR Buffer
    );

BOOL
BlockerTreeWalk(
   IN OUT PBLOCKER_TREE *blockerHead,
   IN char *szSymbolic
   ) ;

PBLOCKER_TREE
BlockerTreeBuild(
   VOID
   ) ;

VOID
BlockerTreeFree(
   IN PBLOCKER_TREE BlockerTree
   ) ;

DECLARE_API( stacks )

/*++

Routine Description:

    Dumps the active process list.

Arguments:

    None.

Return Value:

    None.

--*/

{
    ULONG Result;
    LIST_ENTRY List;
    PLIST_ENTRY Next;
    PLIST_ENTRY NextThread;
    ULONG ProcessHead;
    PKPROCESS Process;
    KPROCESS ProcessContents;
    PETHREAD Thread;
    ETHREAD ThreadContents;
    ULONG UserProbeAddress;
    ULONG Verbosity = 0 ;
    PBLOCKER_TREE blockerTree ;

    blockerTree = BlockerTreeBuild() ;

    sscanf(args, "%lx", &Verbosity);

    dprintf("Thread  Thread   ThreadState  Blocker\n") ;

    Process = (PKPROCESS)GetNtDebuggerDataValue( PsActiveProcessHead );
    if (!Process) {
        dprintf("Unable to get value of PsActiveProcessHead\n");
        goto Exit;
    }

    if (!ReadMemory( (DWORD)Process, &ProcessContents, sizeof(KPROCESS), &Result )) {
        dprintf("Unable to read _KPROCESS at %lx\n",Process);
        goto Exit;
    }

    if (!StacksValidateProcess(Process, &ProcessContents)) {

        dprintf("Process list damaged, or maybe symbols are incorrect?\n%lx\n",Process);
        goto Exit;
    }

    NextThread = ProcessContents.ThreadListHead.Flink;

    if (NextThread == &Process->ThreadListHead) {

        StacksDumpProcessAndThread(&ProcessContents, Process, NO_THREADS, NULL, NULL, blockerTree, Verbosity) ;

    } else {

        while ( NextThread != &Process->ThreadListHead) {

            Thread = (PETHREAD)(CONTAINING_RECORD(NextThread,KTHREAD,ThreadListEntry));
            if (!ReadMemory((DWORD)Thread,
                        &ThreadContents,
                        sizeof(ETHREAD),
                        &Result)) {

                StacksDumpProcessAndThread(&ProcessContents, Process, ETHREAD_NOT_READABLE, NULL, NULL, blockerTree, Verbosity) ;

                dprintf("Unable to read _ETHREAD at %lx\n",Thread);
                break;
            }

            if (!StacksValidateThread(&ThreadContents, Thread)) {

                StacksDumpProcessAndThread(&ProcessContents, Process, ETHREAD_NOT_READABLE, NULL, NULL, blockerTree, Verbosity) ;
            } else if (NextThread == ProcessContents.ThreadListHead.Flink) {

                StacksDumpProcessAndThread(&ProcessContents, Process, FIRST_THREAD_VALID, &ThreadContents, Thread, blockerTree, Verbosity) ;
            } else {

                StacksDumpProcessAndThread(&ProcessContents, Process, THREAD_VALID, &ThreadContents, Thread, blockerTree, Verbosity) ;
            }

            NextThread = ((PKTHREAD)&ThreadContents)->ThreadListEntry.Flink;

            if (CheckControlC()) {
                goto Exit;
            }
        }
    }
Exit:
   BlockerTreeFree(blockerTree) ;
   return;
}

BOOL
StacksValidateProcess(
    IN PKPROCESS RealProcessBase,
    IN PKPROCESS ProcessContents
    )
{
    return TRUE ;
}

VOID StacksDumpProcessAndThread(
    IN PKPROCESS     ProcessContents,
    IN PKPROCESS     RealProcessBase,
    IN ULONG         ThreadDesc,
    IN PETHREAD      Thread,
    IN PETHREAD      RealThreadBase,
    IN PBLOCKER_TREE BlockerTree,
    IN ULONG         Verbosity
    )
{
    OBJECT_HANDLE_TABLE HandleTable;
    ULONG NumberOfHandles;
    ULONG Result;
    CHAR  ThreadState[13] ;
    CHAR  ThreadBlocker[256] ;
    UINT  i ;
    struct THREAD_STATE_NAMES *ThreadStateName ;

    NumberOfHandles = 0;
    if (ReadMemory((DWORD)GetNtDebuggerData(ObpObjectHandleTable),
                     &HandleTable,
                     sizeof(HandleTable),
                     &Result)) {

        NumberOfHandles = HandleTable.HandleCount;
    }

    switch(ThreadDesc) {

        case FIRST_THREAD_VALID:
        case THREAD_VALID:
            StacksGetThreadStateName(Thread, ThreadState) ;
            i=strlen(ThreadState) ;
            while(i<11) ThreadState[i++]=' ' ;
            ThreadState[i]='\0' ;
            GetThreadBlocker (Thread, RealThreadBase, Verbosity, BlockerTree, ThreadBlocker) ;
            dprintf("%06lx  %08lx  %s  %s\n",
                Thread->UniqueThread,
                RealThreadBase,
                ThreadState,
                ThreadBlocker
                );

            break ;

        case NO_THREADS:

            dprintf("------  NOTHREADS\n");

            break ;

        case ETHREAD_NOT_READABLE:

            dprintf("------  NO ETHREAD DATA\n");

            break ;
    }

    if ((ThreadDesc != FIRST_THREAD_VALID) && (ThreadDesc != THREAD_VALID)) {

        return ;
    }
    //DumpThreadBlockageInfo("    ", Thread, RealThreadBase, Verbosity) ;
    DumpThreadStackInfo("    ", Thread, RealThreadBase, Verbosity) ;
}

UCHAR *StacksWaitReasonList[] = {
    "Executive",
    "FreePage",
    "PageIn",
    "PoolAllocation",
    "DelayExecution",
    "Suspended",
    "UserRequest",
    "WrExecutive",
    "WrFreePage",
    "WrPageIn",
    "WrPoolAllocation",
    "WrDelayExecution",
    "WrSuspended",
    "WrUserRequest",
    "WrEventPairHigh",
    "WrEventPairLow",
    "WrLpcReceive",
    "WrLpcReply",
    "WrVirtualMemory",
    "WrPageOut",
    "WrRendezvous",
    "WrFsCacheIn",
    "WrFsCacheOut",
    "Spare4",
    "Spare5",
    "Spare6",
    "Spare7"};


VOID StacksGetThreadStateName(
    IN PETHREAD Thread,
    OUT PCHAR Dest
    )
{
    switch (Thread->Tcb.State) {
        case Initialized: strcpy(Dest, "INITIALIZED"); break;
        case Ready:       strcpy(Dest, "READY"); break;
        case Running:     strcpy(Dest, "RUNNING"); break;
        case Standby:     strcpy(Dest, "STANDBY"); break;
        case Terminated:  strcpy(Dest, "TERMINATED"); break;
        case Waiting:     strcpy(Dest, "BLOCKED"); break;
        case Transition:  strcpy(Dest, "TRANSITION"); break;
        default:          strcpy(Dest, "????") ; break ;
    }
}


BOOL
StacksValidateThread (
    IN PETHREAD Thread,
    IN PETHREAD RealThreadBase
    )
{
    if (Thread->Tcb.Header.Type != ThreadObject) {
        dprintf("TYPE mismatch for thread object at %lx\n",RealThreadBase);
        return FALSE;
    }
    return TRUE ;
}


VOID
DumpThreadBlockageInfo (
    IN char *Pad,
    IN PETHREAD Thread,
    IN PETHREAD RealThreadBase,
    IN ULONG Verbosity
    )
{
    #define MAX_STACK_FRAMES  40
    TIME_FIELDS Times;
    LARGE_INTEGER RunTime;
    ULONG Address;
    ULONG Result;
    KMUTANT WaitObject;
    PVOID PointerWaitObject = &WaitObject;
    PKWAIT_BLOCK WaitBlock;
    KWAIT_BLOCK OutsideBlock;
    ULONG WaitOffset;
    PKPROCESS Process;
    CHAR Buffer[80];
    ULONG KeTimeIncrement;
    ULONG TimeIncrement;
    ULONG frames = 0;
    ULONG i;
    ULONG displacement;
    EXTSTACKTRACE stk[MAX_STACK_FRAMES];
#ifdef TARGET_i386
    struct {
        KSWITCHFRAME Frame;
        DWORD SavedEbp;
    } SwitchFrame;
#endif


    if (Thread->Tcb.State == Waiting) {
        dprintf("%s (%s) %s %s\n",
            Pad,
            StacksWaitReasonList[Thread->Tcb.WaitReason],
            (Thread->Tcb.WaitMode==KernelMode) ? "KernelMode" : "UserMode",Thread->Tcb.Alertable ? "Alertable" : "Non-Alertable");
        if ( Thread->Tcb.SuspendCount ) {
            dprintf("SuspendCount %lx\n",Thread->Tcb.SuspendCount);
        }

        WaitOffset =
               (ULONG)Thread->Tcb.WaitBlockList - (ULONG)RealThreadBase;

        if (WaitOffset > (ULONG)sizeof(ETHREAD)) {
            if (!ReadMemory((DWORD)Thread->Tcb.WaitBlockList,
                            &OutsideBlock,
                            sizeof(KWAIT_BLOCK),
                            &Result)) {
                dprintf("%sunable to get Wait object\n",Pad);
                goto BadWaitBlock;
            }
            WaitBlock = &OutsideBlock;
        } else {
            WaitBlock = (PKWAIT_BLOCK)((ULONG)Thread + WaitOffset);
        }

        do {

            dprintf("%s    %lx  ",Pad,WaitBlock->Object);
            if (!ReadMemory((DWORD)WaitBlock->Object,
                            &WaitObject,
                            sizeof(KMUTANT),
                            &Result)) {

                dprintf("%sunable to get Wait object\n",Pad);
                break;
            }

            switch (WaitObject.Header.Type) {
                case EventNotificationObject:
                    dprintf("NotificationEvent\n");
                    break;
                case EventSynchronizationObject:
                    dprintf("SynchronizationEvent\n");
                    break;
                case SemaphoreObject:
                    dprintf("Semaphore Limit 0x%lx\n",
                             ((PKSEMAPHORE)PointerWaitObject)->Limit);
                    break;
                case ThreadObject:
                    dprintf("Thread\n");
                    break;
                case TimerNotificationObject:
                    dprintf("NotificationTimer\n");
                    break;
                case TimerSynchronizationObject:
                    dprintf("SynchronizationTimer\n");
                    break;
                case EventPairObject:
                    dprintf("EventPair\n");
                    break;
                case ProcessObject:
                    dprintf("ProcessObject\n");
                    break;
                case MutantObject:
                    dprintf("Mutant - owning thread %lx\n",
                            ((PKMUTANT)PointerWaitObject)->OwnerThread);
                    break;
                case QueueObject:
                    dprintf("QueueObject\n");
                    break;
                default:
                    dprintf("Unknown\n");
                    break;
            }

            if (WaitBlock->NextWaitBlock == Thread->Tcb.WaitBlockList) {
                break;
            }
            WaitOffset =
                   (ULONG)WaitBlock->NextWaitBlock - (ULONG)RealThreadBase;

            if (WaitOffset > (ULONG)sizeof(ETHREAD)) {

                if (!ReadMemory((DWORD)WaitBlock->NextWaitBlock,
                                &OutsideBlock,
                                sizeof(KWAIT_BLOCK),
                                &Result)) {
                    dprintf("%sunable to get Wait object\n",Pad);
                    break;
                }
                WaitBlock = &OutsideBlock;
            } else {
                WaitBlock = (PKWAIT_BLOCK)((ULONG)Thread + WaitOffset);
            }
        } while ( TRUE );
    }

BadWaitBlock:

    if (Thread->IrpList.Flink != Thread->IrpList.Blink ||
        Thread->IrpList.Flink != &RealThreadBase->IrpList
       ) {

        ULONG IrpListHead = (ULONG)&RealThreadBase->IrpList;
        PLIST_ENTRY Next;
        IRP IrpContents;
        PIRP p;
        ULONG Counter = 0;

        Next = Thread->IrpList.Flink;
        dprintf("%sIRP List:\n",Pad);
        while (((ULONG)Next != IrpListHead) && (Counter < 17)) {
            Counter += 1;
            Address = (ULONG)CONTAINING_RECORD(Next,IRP,ThreadListEntry);
            if (!ReadMemory((DWORD)Address,
                           &IrpContents,
                           sizeof(IRP),
                           &Result)) {
                dprintf( "%sunable to get IRP object\n", Pad );
                break;
            }

            p = &IrpContents;
            dprintf("%s    %08lx: (%04x,%04x) Flags: %08lx  Buffer: %08lx\n",
                    Pad,Address,p->Type,p->Size,p->Flags,p->UserBuffer);

            Next = p->ThreadListEntry.Flink;
        }
    }

}

VOID
DumpThreadStackInfo (
    IN char *Pad,
    IN PETHREAD Thread,
    IN PETHREAD RealThreadBase,
    IN ULONG Verbosity
    )
{
    #define MAX_STACK_FRAMES  40
    TIME_FIELDS Times;
    LARGE_INTEGER RunTime;
    ULONG Address;
    ULONG Result;
    KMUTANT WaitObject;
    PVOID PointerWaitObject = &WaitObject;
    PKWAIT_BLOCK WaitBlock;
    KWAIT_BLOCK OutsideBlock;
    ULONG WaitOffset;
    PKPROCESS Process;
    CHAR Buffer[256];
    ULONG KeTimeIncrement;
    ULONG TimeIncrement;
    ULONG frames = 0;
    ULONG i;
    ULONG displacement;
    EXTSTACKTRACE stk[MAX_STACK_FRAMES];
#ifdef TARGET_i386
    struct {
        KSWITCHFRAME Frame;
        DWORD SavedEbp;
    } SwitchFrame;
#endif

    if (Verbosity==0) {
        return ;
    }

#ifdef TARGET_i386

    if (Thread->Tcb.State == Running) {
        GetStackTraceRegs( 0, &STeip, &STebp, &STesp );
        SetThreadForOperation( (PULONG)&RealThreadBase );
        frames = StackTrace( STebp, STesp, STeip, stk, MAX_STACK_FRAMES );
    } else {
        //
        // Get SwitchFrame and perform backtrace providing EBP,ESP,EIP
        // (full FPO backtrace context)
        //
        // N.B. The dword immediately preceding the switch frame contains
        //      the saved EBP.
        //
        ZeroMemory( &SwitchFrame, sizeof(SwitchFrame) );
        ReadMemory(
            (DWORD)Thread->Tcb.KernelStack,
            (PVOID)&SwitchFrame,
            sizeof(SwitchFrame),
            &Result
            );
        if (Result == sizeof(SwitchFrame)) {
            STeip = SwitchFrame.Frame.RetAddr;
            STebp = SwitchFrame.SavedEbp;
            STesp = (ULONG) Thread->Tcb.KernelStack + sizeof(KSWITCHFRAME);
            SetThreadForOperation( (PULONG)&RealThreadBase );
            frames = StackTrace( STebp, STesp, STeip, stk, MAX_STACK_FRAMES );
        }
    }

#elif defined(TARGET_MIPS) || defined(TARGET_ALPHA) || defined(TARGET_PPC)

    if (Thread->Tcb.State != Running) {
        SetThreadForOperation( (PULONG)&RealThreadBase );
        frames = StackTrace( (DWORD)Thread->Tcb.KernelStack,
                             (DWORD)Thread->Tcb.KernelStack,
                             0,
                             stk,
                             MAX_STACK_FRAMES
                             );
    }

#endif

    for (i=1; i<frames; i++) {

        if ((i==0)&&(Verbosity>=2)) {
#ifdef TARGET_PPC
            dprintf( "\n%s      ChildEBP EIP\n", Pad );
#else
            dprintf( "\n%s      ChildEBP EIP\n", Pad );
#endif
        }

        Buffer[0] = '!';
        GetSymbol((LPVOID)stk[i].ProgramCounter, Buffer, &displacement);

        if (Verbosity>=2) {
#ifdef TARGET_PPC
            dprintf( "      %s%08x %08x %s",
                     Pad,
                     stk[i].FramePointer,
                     stk[i].ProgramCounter,
                     Buffer
                   );
#else
            dprintf( "      %s%08x %08x %s(%08x, %08x, %08x)",
                     Pad,
                     stk[i].FramePointer,
                     stk[i].ProgramCounter,
                     Buffer,
                     stk[i].Args[0],
                     stk[i].Args[1],
                     stk[i].Args[2]
                     );
#endif
        } else if (Verbosity==1) {
            dprintf( "                                %s%s",
                     Pad,
                     Buffer
                   ) ;
        }

        if (displacement) {
            dprintf( "+0x%x", displacement );
        }
        dprintf("\n") ;
    }
}

VOID
GetThreadBlocker (
    IN PETHREAD Thread,
    IN PETHREAD RealThreadBase,
    IN ULONG Verbosity,
    IN PBLOCKER_TREE BlockerTree,
    OUT PCHAR Buffer
    )
{
    #define MAX_STACK_FRAMES  40
    TIME_FIELDS Times;
    LARGE_INTEGER RunTime;
    ULONG Address;
    ULONG Result;
    KMUTANT WaitObject;
    PVOID PointerWaitObject = &WaitObject;
    PKWAIT_BLOCK WaitBlock;
    KWAIT_BLOCK OutsideBlock;
    ULONG WaitOffset;
    PKPROCESS Process;
    ULONG KeTimeIncrement;
    ULONG TimeIncrement;
    ULONG frames = 0;
    ULONG i;
    ULONG displacement;
    PBLOCKER_TREE blockerCur ;
    EXTSTACKTRACE stk[MAX_STACK_FRAMES];
#ifdef TARGET_i386
    struct {
        KSWITCHFRAME Frame;
        DWORD SavedEbp;
    } SwitchFrame;
#endif


#ifdef TARGET_i386

    if (Thread->Tcb.State == Running) {
        GetStackTraceRegs( 0, &STeip, &STebp, &STesp );
        SetThreadForOperation( (PULONG)&RealThreadBase );
        frames = StackTrace( STebp, STesp, STeip, stk, MAX_STACK_FRAMES );
    } else {
        //
        // Get SwitchFrame and perform backtrace providing EBP,ESP,EIP
        // (full FPO backtrace context)
        //
        // N.B. The dword immediately preceding the switch frame contains
        //      the saved EBP.
        //
        ZeroMemory( &SwitchFrame, sizeof(SwitchFrame) );
        ReadMemory(
            (DWORD)Thread->Tcb.KernelStack,
            (PVOID)&SwitchFrame,
            sizeof(SwitchFrame),
            &Result
            );
        if (Result == sizeof(SwitchFrame)) {
            STeip = SwitchFrame.Frame.RetAddr;
            STebp = SwitchFrame.SavedEbp;
            STesp = (ULONG) Thread->Tcb.KernelStack + sizeof(KSWITCHFRAME);
            SetThreadForOperation( (PULONG)&RealThreadBase );
            frames = StackTrace( STebp, STesp, STeip, stk, MAX_STACK_FRAMES );
        }
    }

#elif defined(TARGET_MIPS) || defined(TARGET_ALPHA) || defined(TARGET_PPC)

    if (Thread->Tcb.State != Running) {
        SetThreadForOperation( (PULONG)&RealThreadBase );
        frames = StackTrace( (DWORD)Thread->Tcb.KernelStack,
                             (DWORD)Thread->Tcb.KernelStack,
                             0,
                             stk,
                             MAX_STACK_FRAMES
                             );
    }

#endif

    Buffer[0] = '!';
    if (frames == 0) {

         strcpy(Buffer, "?? Kernel stack not resident ??") ;
    } else {

        if (Thread->Tcb.State == Running) {

            GetSymbol((LPVOID)stk[0].ProgramCounter, Buffer, &displacement);
            sprintf(Buffer+strlen(Buffer), "+0x%x", displacement );

        } else if (Verbosity>=1) {

            GetSymbol((LPVOID)stk[0].ProgramCounter, Buffer, &displacement);
        } else {

            blockerCur = BlockerTree ;
            for(i=0; i<frames; i++) {

                GetSymbol((LPVOID)stk[i].ProgramCounter, Buffer, &displacement);
                if (!BlockerTreeWalk(&blockerCur, Buffer)) break ;
            }
            if (Buffer[0]) {
               strcat(Buffer, "+") ;
            }
            sprintf(Buffer+strlen(Buffer), "0x%x", displacement );
        }
    }
}

#define BEGIN_TREE()
#define END_TREE()
#define DECLARE_ENTRY(foo) BlockerTreeDeclareEntry(foo)
#define BEGIN_LIST() BlockerTreeListBegin()
#define END_LIST() BlockerTreeListEnd()

PBLOCKER_TREE gpCurrentBlocker ;

VOID
BlockerTreeListBegin(
   VOID
   )
{
   //dprintf("Nest for %x\n", gpCurrentBlocker) ;
   ASSERT(!gpCurrentBlocker->Nested) ;
   gpCurrentBlocker->Nested = TRUE ;
}

VOID
BlockerTreeListEnd(
   VOID
   )
{
   //dprintf("Unnest for %x\n", gpCurrentBlocker) ;
   gpCurrentBlocker = gpCurrentBlocker->Parent ;
   ASSERT(gpCurrentBlocker->Nested) ;
   gpCurrentBlocker->Nested = FALSE ;
}

VOID
BlockerTreeDeclareEntry(
   const char *szSymbolic
   )
{
   PBLOCKER_TREE blockerEntry ;

   blockerEntry = (PBLOCKER_TREE) malloc(sizeof(BLOCKER_TREE)) ;
   if (!blockerEntry) {
      return ;
   }

   memset(blockerEntry, 0, sizeof(BLOCKER_TREE)) ;
   blockerEntry->Symbolic = szSymbolic ;

   if (gpCurrentBlocker->Nested) {
      ASSERT(!gpCurrentBlocker->Child) ;
      //dprintf("Child %x for %x\n", blockerEntry, gpCurrentBlocker) ;
      blockerEntry->Parent = gpCurrentBlocker ;
      gpCurrentBlocker->Child = blockerEntry ;
   } else {
      ASSERT(!gpCurrentBlocker->Sibling) ;
      //dprintf("sibling %x for %x\n", blockerEntry, gpCurrentBlocker) ;
      blockerEntry->Parent = gpCurrentBlocker->Parent ;
      gpCurrentBlocker->Sibling = blockerEntry ;
   }
   gpCurrentBlocker = blockerEntry ;
}

PBLOCKER_TREE
BlockerTreeBuild(
   VOID
   )
{
   BLOCKER_TREE blockerHead ;

   memset(&blockerHead, 0, sizeof(BLOCKER_TREE)) ;

   gpCurrentBlocker = &blockerHead ;

   //
   // Generate the list...
   //
   #include "stacks.h"

   //
   // And return it.
   //
   return blockerHead.Sibling ;
}

VOID BlockerTreeFree(
   PBLOCKER_TREE BlockerHead
   )
{
   PBLOCKER_TREE blockerCur, blockerNext ;

   for(blockerCur = BlockerHead; blockerCur; blockerCur = blockerNext) {
      if (blockerCur->Child) {
         BlockerTreeFree(blockerCur->Child) ;
      }
      blockerNext = blockerCur->Sibling ;
      free(blockerCur) ;
   }
}

BOOL
BlockerTreeWalk(
   IN OUT PBLOCKER_TREE *blockerHead,
   IN char *szSymbolic
   )
{
   PBLOCKER_TREE blockerCur ;

   for(blockerCur = *blockerHead; blockerCur; blockerCur = blockerCur->Sibling) {
      if (!_strcmpi(blockerCur->Symbolic, szSymbolic)) {
         *blockerHead = blockerCur->Child ;
         return TRUE ;
      }
   }
   return FALSE ;
}


#if defined(TARGET_i386)
#define SYSTEM_TIME_ADDRESS  KI_USER_SHARED_DATA
#elif defined(TARGET_MIPS)
#define SYSTEM_TIME_ADDRESS  KIPCR2
#elif defined(TARGET_ALPHA)
#define SYSTEM_TIME_ADDRESS  KI_USER_SHARED_DATA
#elif defined(TARGET_PPC)
#define SYSTEM_TIME_ADDRESS  KI_USER_SHARED_DATA
#else
#error( "unknown target machine" );
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\kdexts\sources.inc ===
!IF 0

Common sources file information.  The variable COMMON_SOURCES is defined
here to contain the source file names that are common across all platforms.

!ENDIF

DLLENTRY=_DllMainCRTStartup

!IF "$(NTNOPCH)" == ""
PRECOMPILED_INCLUDE=precomp.h
PRECOMPILED_PCH=precomp.pch
PRECOMPILED_OBJ=precomp.obj
!ENDIF

SUBSYSTEM_VERSION=5.00

COMMON_SOURCES=    \
    ..\usbtree.cpp \
    ..\ohcd.cpp    \
    ..\dbgprint.c  \
    ..\device.c    \
    ..\driver.c    \
    ..\exceptn.c   \
    ..\fscache.c   \
    ..\gentable.c  \
    ..\gflag.c     \
    ..\handle.c    \
    ..\heap.c      \
    ..\image.c     \
    ..\iospace.c   \
    ..\irp.c       \
    ..\lists.c     \
    ..\mmx.c       \
    ..\object.c    \
    ..\patch.c     \
    ..\patchbld.c  \
    ..\physical.c  \
    ..\pool.c      \
    ..\process.c   \
    ..\ptov.c      \
    ..\ready.c     \
    ..\stacks.c    \
    ..\time.c      \
    ..\util.c      \
    ..\vad.c       \
    ..\kdexts.c    \
    ..\kdexts.rc   \
    help.c         \
    pcr.c          \
    trap.c         \
    cxr.c          \
    exsup.c

INCLUDES=\
    ..\;\
    $(BASEDIR)\private\inc;\
    $(BASEDIR)\public\ddk\inc\wdm; \
    $(BASEDIR)\private\ntos\inc;\
    $(BASEDIR)\private\ntos\cache;\
    $(BASEDIR)\private\ntos\cntfs;\
    $(BASEDIR)\private\ntos\config;\
    $(BASEDIR)\private\ntos\io;\
    $(BASEDIR)\private\ntos\ke;\
    $(BASEDIR)\private\ntos\mmx;\
    $(BASEDIR)\private\ntos\se;\
    $(BASEDIR)\private\ntos\po;\
    $(BASEDIR)\private\ntos\rtl;\
    $(BASEDIR)\private\ntos\dd\pci;\
    $(BASEDIR)\private\ntos\dd\usb\inc;\
    $(BASEDIR)\private\ntos\dd\usb\usbd;\
    $(BASEDIR)\private\ntos\dd\usb\ohcd;\
    $(BASEDIR)\private\ntos\nthals\inc;\
    $(DDK_INC_PATH);\
    $(SDK_INC_PATH)

MSC_WARNING_LEVEL=/W3 /WX

TARGETLIBS=\
    $(LIBRARY_PATH)\kernel32.lib

USE_CRTDLL=1

DLLDEF=obj\$(TARGET_DIRECTORY)\$(TARGETNAME).def

UMTYPE=windows

NTTARGETFILE0=$(DLLDEF)

SOURCES_USED=..\sources.inc

C_DEFINES=$(C_DEFINES) -D_XBOX
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\kdexts\time.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    time.c

Abstract:

    WinDbg Extension Api

Author:

    Ramon J San Andres (ramonsa) 8-Nov-1993

Environment:

    User Mode.

Revision History:

--*/


#include "precomp.h"
#pragma hdrstop


typedef struct _ETIMER {
    KTIMER KeTimer;
    KAPC TimerApc;
    KDPC TimerDpc;
    LIST_ENTRY ActiveTimerListEntry;
    KSPIN_LOCK Lock;
    LONG Period;
    BOOLEAN ApcAssociated;
    BOOLEAN WakeTimer;
    LIST_ENTRY WakeTimerListEntry;
} ETIMER, *PETIMER;

VOID
FileTimeToString(
    IN LARGE_INTEGER Time,
    IN BOOLEAN TimeZone,
    OUT PCHAR Buffer
    );

DECLARE_API( time )

/*++

Routine Description:



Arguments:

    args -

Return Value:

    None

--*/

{
    struct {
        ULONG   Low;
        ULONG   High;
    } rate;

    struct {
        ULONG   Low;
        ULONG   High;
    } diff;

    ULONG   rateaddr;
    ULONG   diffaddr;
    ULONG   result;
    ULONG   TicksPerNs;

    rateaddr = GetExpression( "xboxkrnl!KdPerformanceCounterRate" );
    if ( !rateaddr ||
         !ReadMemory( (DWORD)rateaddr, &rate, sizeof(rate), &result) ) {
        dprintf("%08lx: Unable to get value of KdPerformanceCounterRate\n",rateaddr);
        return;
    }

    diffaddr = GetExpression( "xboxkrnl!KdTimerDifference" );
    if ( !diffaddr ||
         !ReadMemory( (DWORD)diffaddr, &diff, sizeof(diff), &result) ) {
        dprintf("%08lx: Unable to get value of KdTimerDifference\n",diffaddr);
        return;
    }

    TicksPerNs = 1000000000L / rate.Low;

    if (diff.High == 0L) {
        dprintf("%ld ticks at %ld ticks/second (%ld ns)\n",
                diff.Low,
                rate.Low,
                diff.Low * TicksPerNs);
    } else {
        dprintf("%08lx:%08lx ticks at %ld ticks/second\n",
                diff.High, diff.Low, rate.Low);
    }
}

PLIST_ENTRY
DumpKTimer(
    IN PKTIMER pTimer,
    IN ULONGLONG InterruptTimeOffset,
    IN OPTIONAL PLIST_ENTRY Blink
    )
{
    KTIMER KTimer;
    ULONG           Displacement;
    KDPC Dpc;
    CHAR            Buff[256];
    ULONG           Result;
    PLIST_ENTRY     NextThread;
    LIST_ENTRY      ListEntry;
    PKTHREAD        Thread;
    KWAIT_BLOCK     WaitBlock;
    LARGE_INTEGER   SystemTime;

    if ( !ReadMemory( (DWORD)pTimer,
                      &KTimer,
                      sizeof(KTIMER),
                      &Result) ) {
        dprintf("Unable to get contents of Timer @ %lx\n", pTimer );
        return(NULL);
    }

    SystemTime.QuadPart = KTimer.DueTime.QuadPart + InterruptTimeOffset;
    if (SystemTime.QuadPart < 0) {
        strcpy(Buff, "         NEVER         ");
    } else {
        FileTimeToString(SystemTime, FALSE, Buff);
    }

    dprintf("%c %08lx %08lx [%s]  ", 
            (KTimer.Period != 0) ? 'P' : ' ',
            KTimer.DueTime.LowPart,
            KTimer.DueTime.HighPart,
            Buff);

    if (KTimer.Dpc != NULL) {
        if (!ReadMemory((DWORD)(KTimer.Dpc),
                        &Dpc,
                        sizeof(KDPC),
                        &Result)) {
            dprintf("Unable to get contents of DPC @ %lx\n", KTimer.Dpc);
            return(NULL);
        }
        GetSymbol(Dpc.DeferredRoutine,
                  Buff,
                  &Displacement);
        dprintf("%s",Buff);
        if (Displacement != 0) {
            dprintf("+%lx ", Displacement);
        } else {
            dprintf(" ");
        }
    }

    NextThread = KTimer.Header.WaitListHead.Flink;
    while (NextThread != &pTimer->Header.WaitListHead) {
        if (!ReadMemory((DWORD)NextThread,
                        &WaitBlock,
                        sizeof(WaitBlock),
                        &Result)) {
            dprintf("Unable to get contents of waitblock @ %lx\n",NextThread);
        } else {
            dprintf("thread %lx ",WaitBlock.Thread);
        }

        if (!ReadMemory((DWORD)NextThread,
                        &ListEntry,
                        sizeof(ListEntry),
                        &Result)) {
            dprintf("Unable to read next WaitListEntry @ %lx\n",NextThread);
            break;
        }
        NextThread = ListEntry.Flink;
    }
    dprintf("\n");

    if (Blink &&
        (KTimer.TimerListEntry.Blink != Blink)) {
        dprintf("   Timer at %lx has wrong Blink! (Blink %08lx, should be %08lx)\n",
                pTimer,
                KTimer.TimerListEntry.Blink,
                Blink);
    }

    if (KTimer.TimerListEntry.Flink == NULL) {
        dprintf("   Timer at %lx has been zeroed! (Flink %08lx, Blink %08lx)\n",
                pTimer,
                KTimer.TimerListEntry.Flink,
                KTimer.TimerListEntry.Blink);
    }

    return(KTimer.TimerListEntry.Flink);

}



DECLARE_API( timer )

/*++

Routine Description:

    Dumps all timers in the system.

Arguments:

    args -

Return Value:

    None

--*/

{
    ULONG           CurrentList;
    KTIMER          CurrentTimer;
    ULONG           Index;
    LARGE_INTEGER   InterruptTime;
    LARGE_INTEGER   SystemTime;
    ULONG           MaximumList;
    ULONG           MaximumSearchCount;
    ULONG           MaximumTimerCount;
    PLIST_ENTRY     NextEntry;
    PLIST_ENTRY     LastEntry;
    PLIST_ENTRY     p;
    PKTIMER         NextTimer;
    ULONG_PTR           KeTickCount;
    ULONG           KiMaximumSearchCount;
    ULONG           Result;
    ULONG           TickCount;
    PLIST_ENTRY     TimerTable;
    ULONG           TotalTimers;
    KSYSTEM_TIME    _SystemTime;
    KSYSTEM_TIME    _InterruptTime;
    LIST_ENTRY      ListEntry;
    ULONG_PTR     WakeTimerList;
    ETIMER          ETimer;
    ETIMER          *pETimer;
    CHAR            Buffer[256];
    ULONGLONG       InterruptTimeOffset;

    //
    // Get the system time and print the header banner.
    //
    if (!ReadMemory( GetNtDebuggerData( KeSystemTime ),
                     &_SystemTime,
                     sizeof(_SystemTime),
                     &Result) ) {
        dprintf("Unable to get system time\n");
        return;
    }
    if (!ReadMemory( GetNtDebuggerData( KeInterruptTime ),
                     &_InterruptTime,
                     sizeof(_InterruptTime),
                     &Result) ) {
        dprintf("Unable to get interrupt time\n");
        return;
    }

#ifdef TARGET_ALPHA
    InterruptTime.QuadPart = SharedData.InterruptTime;
    SystemTime.QuadPart = SharedData.SystemTime;
#else
    InterruptTime.HighPart = _InterruptTime.High1Time;
    InterruptTime.LowPart = _InterruptTime.LowPart;
    SystemTime.HighPart = _SystemTime.High1Time;
    SystemTime.LowPart = _SystemTime.LowPart;
#endif
    InterruptTimeOffset = SystemTime.QuadPart - InterruptTime.QuadPart;
    FileTimeToString(SystemTime, TRUE, Buffer);

    dprintf("Dump system timers\n\n");
    dprintf("Interrupt time: %08lx %08lx [%s]\n\n",
            InterruptTime.LowPart,
            InterruptTime.HighPart,
            Buffer);

    //
    // Get the address of the timer table list head array and scan each
    // list for timers.
    //

    dprintf("List Timer    Interrupt Low/High     Fire Time              DPC/thread\n");
    MaximumList = 0;

    TimerTable = (PLIST_ENTRY)GetNtDebuggerData( KiTimerTableListHead );
    if ( !TimerTable ) {
        dprintf("Unable to get value of KiTimerTableListHead\n");
        return;
    }

    TotalTimers = 0;
    for (Index = 0; Index < TIMER_TABLE_SIZE; Index += 1) {

        //
        // Read the forward link in the next timer table list head.
        //

        if ( !ReadMemory( (DWORD)TimerTable,
                          &NextEntry,
                          sizeof(PLIST_ENTRY),
                          &Result) ) {
            dprintf("Unable to get contents of next entry @ %lx\n", TimerTable );
            continue;
        }

        //
        // Scan the current timer list and display the timer values.
        //

        LastEntry = TimerTable;
        CurrentList = 0;
        while (NextEntry != TimerTable) {
            CurrentList += 1;
            NextTimer = CONTAINING_RECORD(NextEntry, KTIMER, TimerListEntry);
            TotalTimers += 1;

            if (CurrentList == 1) {
                dprintf("%3ld %08lx ", Index, NextTimer);
            } else {
                dprintf("    %08lx ", NextTimer);
            }

            p = LastEntry;
            LastEntry = NextEntry;
            NextEntry = DumpKTimer(NextTimer, InterruptTimeOffset, p);
            if (NextEntry==NULL) {
                break;
            }
        }

        TimerTable += 1;
        if (CurrentList > MaximumList) {
            MaximumList = CurrentList;
        }
    }

    dprintf("\n\nTotal Timers: %d, Maximum List: %d\n",
            TotalTimers,
            MaximumList);

    //
    // Get the current tick count and convert to the hand value.
    //

    KeTickCount = GetExpression( "xboxkrnl!KeTickCount" );
    if ( KeTickCount &&
         ReadMemory( (DWORD)KeTickCount,
                      &TickCount,
                      sizeof(ULONG),
                      &Result) ) {
        dprintf("Current Hand: %d", TickCount & (TIMER_TABLE_SIZE - 1));
    }

    //
    // Get the maximum search count if the target system is a checked
    // build and display the count.
    //

    KiMaximumSearchCount = GetExpression( "xboxkrnl!KiMaximumSearchCount" );
    if ( KiMaximumSearchCount &&
         ReadMemory( (DWORD)KiMaximumSearchCount,
                     &MaximumSearchCount,
                     sizeof(ULONG),
                     &Result) ) {
        dprintf(", Maximum Search: %d", MaximumSearchCount);
    }

    dprintf("\n\n");

    return;
}

VOID
FileTimeToString(
    IN LARGE_INTEGER Time,
    IN BOOLEAN TimeZone,
    OUT PCHAR Buffer
    )
{
    TIME_FIELDS TimeFields;
    TIME_ZONE_INFORMATION TimeZoneInfo;
    PWCHAR pszTz;
    ULONGLONG TzBias;
    DWORD Result;

    //
    // Get the local (to the debugger) timezone bias
    //
    Result = GetTimeZoneInformation(&TimeZoneInfo);
    if (Result == 0xffffffff) {
        pszTz = L"UTC";
    } else {
        //
        // Bias is in minutes, convert to 100ns units
        //
        TzBias = (ULONGLONG)TimeZoneInfo.Bias * 60 * 10000000;
        switch (Result) {
            case TIME_ZONE_ID_UNKNOWN:
                pszTz = L"unknown";
                break;
            case TIME_ZONE_ID_STANDARD:
                pszTz = TimeZoneInfo.StandardName;
                break;
            case TIME_ZONE_ID_DAYLIGHT:
                pszTz = TimeZoneInfo.DaylightName;
                break;
        }

        Time.QuadPart -= TzBias;
    }

    RtlTimeToTimeFields(&Time, &TimeFields);
    if (TimeZone) {
        sprintf(Buffer, "%2d/%2d/%d %02d:%02d:%02d.%03d (%ws)",
                TimeFields.Month,
                TimeFields.Day,
                TimeFields.Year,
                TimeFields.Hour,
                TimeFields.Minute,
                TimeFields.Second,
                TimeFields.Milliseconds,
                pszTz);
    } else {
        sprintf(Buffer, "%2d/%2d/%d %02d:%02d:%02d.%03d",
                TimeFields.Month,
                TimeFields.Day,
                TimeFields.Year,
                TimeFields.Hour,
                TimeFields.Minute,
                TimeFields.Second,
                TimeFields.Milliseconds);
    }

}


DECLARE_API( filetime )
    
/*++

Routine Description:

    Reformats a 64-bit NT time (FILETIME) as something a human
    being can understand

Arguments:

    args - 64-bit filetime to reformat

Return Value:

    None

--*/

{
    LARGE_INTEGER Time;
    CHAR Buffer[256];

    Time.QuadPart = 0;
    sscanf(args, "%I64X", &Time);

    if (Time.QuadPart == 0) {
        dprintf("!filetime <64-bit FILETIME>\n");
    } else {
        FileTimeToString(Time,TRUE, Buffer);
        dprintf("%s\n",Buffer);
    }
}

// BUGBUG: In order to avoid any references to ntdll (even those that will
// later be discarded, define ZwQuerySystemInformation below so the reference
// in ntos\rtl\time.c will be resolved.

NTSYSAPI
NTSTATUS
NTAPI
ZwQuerySystemInformation (
    IN SYSTEM_INFORMATION_CLASS SystemInformationClass,
    OUT PVOID SystemInformation,
    IN ULONG SystemInformationLength,
    OUT PULONG ReturnLength OPTIONAL
    ) {
        return((NTSTATUS)-1);
}

// BUGBUG: Similarly, implement RtlRaiseStatus for the largeint code on X86.  Make
// it call through Kernel32..

VOID
RtlRaiseStatus (
    IN NTSTATUS Status
    )
{
    RaiseException((DWORD) Status, EXCEPTION_NONCONTINUABLE, (DWORD) 0, (DWORD *) NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\kdexts\stacks.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    stacks.h

Abstract:

    This file contains the stack walking scripts for !stacks

Author:

    Adrian J. Oney (adriao) 07-28-1998

Environment:

    User Mode.

Revision History:

--*/

//
// This tree describes a tree of functions that will be "drilled" through when
// !stacks is used to give a summary of what each thread is currently doing...
//
BEGIN_TREE() ;
  DECLARE_ENTRY("ntoskrnl!KiSwapThread") ;
  BEGIN_LIST() ;   
    DECLARE_ENTRY("ntoskrnl!KeRemoveQueue") ;
    DECLARE_ENTRY("ntoskrnl!KeWaitForSingleObject") ;
    BEGIN_LIST() ;
      DECLARE_ENTRY("ntoskrnl!NtReplyWaitReceivePort") ;
      BEGIN_LIST() ;
        DECLARE_ENTRY("ntoskrnl!KiSystemService") ;
        BEGIN_LIST() ;
          DECLARE_ENTRY("ntoskrnl!ZwReplyWaitReceivePort") ;
        END_LIST() ;      
      END_LIST() ;      
      DECLARE_ENTRY("ntoskrnl!ExpWaitForResource") ;
      BEGIN_LIST() ;
        DECLARE_ENTRY("ntoskrnl!ExAcquireResourceSharedLite") ;
        DECLARE_ENTRY("ntoskrnl!ExpAcquireResourceExclusiveLite") ;
        BEGIN_LIST() ;
          DECLARE_ENTRY("ntoskrnl!ExAcquireResourceExclusiveLite") ;
        END_LIST() ;
      END_LIST() ;
      DECLARE_ENTRY("ntoskrnl!NtWaitForSingleObject") ;
      BEGIN_LIST() ;
        DECLARE_ENTRY("ntoskrnl!KiSystemService") ;
      END_LIST() ;      
    END_LIST() ;
    DECLARE_ENTRY("ntoskrnl!KeWaitForMultipleObjects") ;
    BEGIN_LIST() ;
      DECLARE_ENTRY("ntoskrnl!NtWaitForMultipleObjects") ;
      BEGIN_LIST() ;
        DECLARE_ENTRY("ntoskrnl!KiSystemService") ;
      END_LIST() ;      
    END_LIST() ;
  END_LIST() ;
  
  DECLARE_ENTRY("ntoskrnl!KiSwapThreadExit") ;
  BEGIN_LIST() ;   
    DECLARE_ENTRY("ntoskrnl!KeRemoveQueue") ;
    DECLARE_ENTRY("ntoskrnl!KeWaitForSingleObject") ;
    BEGIN_LIST() ;
      DECLARE_ENTRY("ntoskrnl!NtReplyWaitReceivePort") ;
      BEGIN_LIST() ;
        DECLARE_ENTRY("ntoskrnl!KiSystemService") ;
        BEGIN_LIST() ;
          DECLARE_ENTRY("ntoskrnl!ZwReplyWaitReceivePort") ;
        END_LIST() ;      
      END_LIST() ;      
      DECLARE_ENTRY("ntoskrnl!ExpWaitForResource") ;
      BEGIN_LIST() ;
        DECLARE_ENTRY("ntoskrnl!ExAcquireResourceSharedLite") ;
        DECLARE_ENTRY("ntoskrnl!ExpAcquireResourceExclusiveLite") ;
        BEGIN_LIST() ;
          DECLARE_ENTRY("ntoskrnl!ExAcquireResourceExclusiveLite") ;
        END_LIST() ;
      END_LIST() ;
      DECLARE_ENTRY("ntoskrnl!NtWaitForSingleObject") ;
      BEGIN_LIST() ;
        DECLARE_ENTRY("ntoskrnl!KiSystemService") ;
      END_LIST() ;      
    END_LIST() ;
    DECLARE_ENTRY("ntoskrnl!KeWaitForMultipleObjects") ;
    BEGIN_LIST() ;
      DECLARE_ENTRY("ntoskrnl!NtWaitForMultipleObjects") ;
      BEGIN_LIST() ;
        DECLARE_ENTRY("ntoskrnl!KiSystemService") ;
      END_LIST() ;      
    END_LIST() ;
  END_LIST() ;
  
  DECLARE_ENTRY("ntoskrnl!KiUnlockDispatcherDatabase") ;  
  BEGIN_LIST() ;   
    DECLARE_ENTRY("ntoskrnl!KeSetEvent") ;
  END_LIST() ;

  DECLARE_ENTRY("ntkrnlmp!KiSwapThread") ;
  BEGIN_LIST() ;   
    DECLARE_ENTRY("ntkrnlmp!KeRemoveQueue") ;
    DECLARE_ENTRY("ntkrnlmp!KeWaitForSingleObject") ;
    BEGIN_LIST() ;
      DECLARE_ENTRY("ntkrnlmp!NtReplyWaitReceivePort") ;
      BEGIN_LIST() ;
        DECLARE_ENTRY("ntkrnlmp!KiSystemService") ;
        BEGIN_LIST() ;
          DECLARE_ENTRY("ntkrnlmp!ZwReplyWaitReceivePort") ;
        END_LIST() ;      
      END_LIST() ;      
      DECLARE_ENTRY("ntkrnlmp!ExpWaitForResource") ;
      BEGIN_LIST() ;
        DECLARE_ENTRY("ntkrnlmp!ExAcquireResourceSharedLite") ;
        DECLARE_ENTRY("ntkrnlmp!ExpAcquireResourceExclusiveLite") ;
        BEGIN_LIST() ;
          DECLARE_ENTRY("ntkrnlmp!ExAcquireResourceExclusiveLite") ;
        END_LIST() ;
      END_LIST() ;
      DECLARE_ENTRY("ntkrnlmp!NtWaitForSingleObject") ;
      BEGIN_LIST() ;
        DECLARE_ENTRY("ntkrnlmp!KiSystemService") ;
      END_LIST() ;      
    END_LIST() ;
    DECLARE_ENTRY("ntkrnlmp!KeWaitForMultipleObjects") ;
    BEGIN_LIST() ;
      DECLARE_ENTRY("ntkrnlmp!NtWaitForMultipleObjects") ;
      BEGIN_LIST() ;
        DECLARE_ENTRY("ntkrnlmp!KiSystemService") ;
      END_LIST() ;      
    END_LIST() ;
  END_LIST() ;
  
  DECLARE_ENTRY("ntkrnlmp!KiSwapThreadExit") ;
  BEGIN_LIST() ;   
    DECLARE_ENTRY("ntkrnlmp!KeRemoveQueue") ;
    DECLARE_ENTRY("ntkrnlmp!KeWaitForSingleObject") ;
    BEGIN_LIST() ;
      DECLARE_ENTRY("ntkrnlmp!NtReplyWaitReceivePort") ;
      BEGIN_LIST() ;
        DECLARE_ENTRY("ntkrnlmp!KiSystemService") ;
        BEGIN_LIST() ;
          DECLARE_ENTRY("ntkrnlmp!ZwReplyWaitReceivePort") ;
        END_LIST() ;      
      END_LIST() ;      
      DECLARE_ENTRY("ntkrnlmp!ExpWaitForResource") ;
      BEGIN_LIST() ;
        DECLARE_ENTRY("ntkrnlmp!ExAcquireResourceSharedLite") ;
        DECLARE_ENTRY("ntkrnlmp!ExpAcquireResourceExclusiveLite") ;
        BEGIN_LIST() ;
          DECLARE_ENTRY("ntkrnlmp!ExAcquireResourceExclusiveLite") ;
        END_LIST() ;
      END_LIST() ;
      DECLARE_ENTRY("ntkrnlmp!NtWaitForSingleObject") ;
      BEGIN_LIST() ;
        DECLARE_ENTRY("ntkrnlmp!KiSystemService") ;
      END_LIST() ;      
    END_LIST() ;
    DECLARE_ENTRY("ntkrnlmp!KeWaitForMultipleObjects") ;
    BEGIN_LIST() ;
      DECLARE_ENTRY("ntkrnlmp!NtWaitForMultipleObjects") ;
      BEGIN_LIST() ;
        DECLARE_ENTRY("ntkrnlmp!KiSystemService") ;
      END_LIST() ;      
    END_LIST() ;
  END_LIST() ;
  
  DECLARE_ENTRY("ntkrnlmp!KiUnlockDispatcherDatabase") ;  
  BEGIN_LIST() ;   
    DECLARE_ENTRY("ntkrnlmp!KeSetEvent") ;
  END_LIST() ;

END_TREE() ;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\kdexts\uhcd.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    UHCD.c

Abstract:

    WinDbg Extension Api

Author:

    Kenneth D. Ray (kenray) June 1997

Environment:

    User Mode.

Revision History:

--*/

#include "precomp.h"
#define _WDMDDK_
#include <pci.h>
#include <usbdi.h>
#include <hcdi.h>
#if DBG
   #include ".\usb\hcd\uhcd\uhcd.h"
#else
   #undef DBG
   #define DBG 1
   #include ".\usb\hcd\uhcd\uhcd.h"
   #undef DBG
#endif

typedef union _USB_FLAGS {
    struct {
        ULONG   FullListing         : 1;
        ULONG   Reserved            : 31;
    };
    ULONG Flags;
} USB_FLAGS;

#define PRINT_FLAGS(value, flag) \
    if ((value) & (flag)) { \
        dprintf (#flag " "); \
    }

VOID
UhciPortRegister(
    ULONG   PortNumber,
    ULONG   Value
);

VOID
DevExtUHCD(
    PVOID MemLocPtr
    )
{
    ULONG             MemLoc = (ULONG) MemLocPtr; // BUGBUG ??
    ULONG             result;
    ULONG             i;
    USBD_EXTENSION    usbd;
    DEVICE_EXTENSION  uhcd;

    dprintf ("Dump UHCD Extension: %x\n", MemLoc);

    if (!ReadMemory (MemLoc, &usbd, sizeof (usbd), &result)) {
        dprintf ("Could not read Usbd Extension\n");
        return;
    }

    if (NULL != usbd.TrueDeviceExtension) {
        MemLoc = (ULONG) usbd.TrueDeviceExtension;
    }

    if (!ReadMemory (MemLoc, &uhcd, sizeof (uhcd), &result)) {
        dprintf ("Could not read UHCD Extension\n");
        return;
    }

    dprintf("\n");
    dprintf("PhysicalDO:   %8x  TopOfStackDO: %8x  InterruptObject: %8x\n"
            "FrameListVA:  %8x  FrameListLA:  %8x  ",
            uhcd.PhysicalDeviceObject,
            uhcd.TopOfStackDeviceObject,
            uhcd.InterruptObject,
            uhcd.FrameListVirtualAddress,
            uhcd.FrameListLogicalAddress);

    dprintf("FrameListCopyVA: %08x\n",
             uhcd.FrameListCopyVirtualAddress);

    dprintf("\n");
    dprintf("PersistantQH: %8x  PQH_DescriptorList: %8x\n"
            "EndpointList          & %x = (%x %x) \n"
            "EndpointLookAsideList & %x = (%x %x) \n"
            "ClosedEndpointList    & %x = (%x %x) \n",
            uhcd.PersistantQueueHead,
            uhcd.PQH_DescriptorList,
            &(uhcd.EndpointList),
            uhcd.EndpointList.Flink,
            uhcd.EndpointList.Blink,
            &(uhcd.EndpointLookAsideList),
            uhcd.EndpointLookAsideList.Flink,
            uhcd.EndpointLookAsideList.Blink,
            &(uhcd.ClosedEndpointList),
            uhcd.ClosedEndpointList.Flink,
            uhcd.ClosedEndpointList.Blink);

    dprintf("\n");
    dprintf("InterruptSchedule: ");

    for (i = 0; i < MAX_INTERVAL; i++) 
    {
        dprintf("%8x  ", uhcd.InterruptSchedule[i]);

        if (3 == i % 4) 
        {
            dprintf("\n");
            dprintf("                   ");
        }
    }

    dprintf("\n");
    dprintf("PageList & %x = (%x %x) \n",
            &( uhcd.PageList),
            uhcd.PageList.Flink,
            uhcd.PageList.Blink);

    dprintf("\n");
    dprintf("BwTable: ");

    for (i = 0; i < MAX_INTERVAL; i++) 
    {
   
        dprintf("%5d   ", uhcd.BwTable[i]);

        if (7 == i % 8) 
        {
            dprintf("\n");
            dprintf("         ");
        }
    }

    dprintf("\n");
    dprintf("LastFrame:             %8x  FrameHighPart:       %8x\n"
            "LastIdleTime.High:     %8x  LastIdleTime.Low     %8x\n",
            "LastXferIdleTime.High: %8x  LastXferIdleTime.Low %8x\n",
            "IdleTime:              %8x  XferIdleTime         %8x\n",
            uhcd.LastFrame,
            uhcd.FrameHighPart,
            uhcd.LastIdleTime.HighPart,
            uhcd.LastIdleTime.LowPart,
            uhcd.LastXferIdleTime.HighPart,
            uhcd.LastXferIdleTime.LowPart,
            uhcd.IdleTime,
            uhcd.XferIdleTime);

    dprintf("\n");
    dprintf("TriggerList:      %08x\n"
            "LargeBufferPool:  %08x\n"
            "MediumBufferPool: %08x\n"
            "SmallBufferPool:  %08x\n",
            &(uhcd.TriggerTDList),
            & (uhcd.LargeBufferPool), 
            & (uhcd.MediumBufferPool), 
            & (uhcd.SmallBufferPool));

    dprintf("\nRootHub Variables\n");
    dprintf("DeviceAddress: %3d  RootHub:           %8x\n"  
            "TimersActive:  %3d  InterruptEndpoint: %8x\n",
            uhcd.RootHubDeviceAddress,
            uhcd.RootHub,
            uhcd.RootHubTimersActive,
            uhcd.RootHubInterruptEndpoint);

    dprintf("\n");
    dprintf("LastFrameProcessed:   %x\n"
            "AdapterObject:        %8x\n"
            "MapRegisters:         %d\n"
            "DeviceNameHandle:     %x\n"
            "FrameBabbleRecoverTD: %8x\n",
            uhcd.LastFrameProcessed,
            uhcd.AdapterObject,
            uhcd.NumberOfMapRegisters,
            uhcd.DeviceNameHandle,
            uhcd.FrameBabbleRecoverTD);

    dprintf("\nSaved Bios Info\n");
    dprintf("Cmd:             %x  IntMask:              %x\n"
            "FrameListBase:   %x  LegacySuppReg:        %x\n"
            "DeviceRegisters: %x  SavedInterruptEnable: %x\n"
            "SavedCommandReg: %x\n",
            uhcd.BiosCmd,
            uhcd.BiosIntMask,
            uhcd.BiosFrameListBase,
            uhcd.LegacySupportRegister,
            uhcd.DeviceRegisters[0],
            uhcd.SavedInterruptEnable,
            uhcd.SavedCommandReg);

    dprintf("\n");
    dprintf("PowerState: %x\n"
            "HcFlags %x: ",
            uhcd.CurrentDevicePowerState,
            uhcd.HcFlags);
            PRINT_FLAGS(uhcd.HcFlags, HCFLAG_GOT_IO);
            PRINT_FLAGS(uhcd.HcFlags, HCFLAG_UNMAP_REGISTERS);
            PRINT_FLAGS(uhcd.HcFlags, HCFLAG_USBBIOS);
            PRINT_FLAGS(uhcd.HcFlags, HCFLAG_BWRECLIMATION_ENABLED);
            PRINT_FLAGS(uhcd.HcFlags, HCFLAG_NEED_CLEANUP);
            PRINT_FLAGS(uhcd.HcFlags, HCFLAG_IDLE);
            PRINT_FLAGS(uhcd.HcFlags, HCFLAG_ROLLOVER_IDLE);
            PRINT_FLAGS(uhcd.HcFlags, HCFLAG_HCD_STOPPED);
            PRINT_FLAGS(uhcd.HcFlags, HCFLAG_DISABLE_IDLE);
            PRINT_FLAGS(uhcd.HcFlags, HCFLAG_WORK_ITEM_QUEUED);
            PRINT_FLAGS(uhcd.HcFlags, HCFLAG_HCD_SHUTDOWN);
            PRINT_FLAGS(uhcd.HcFlags, HCFLAG_LOST_POWER);
            PRINT_FLAGS(uhcd.HcFlags, HCFLAG_RH_OFF);
            PRINT_FLAGS(uhcd.HcFlags, HCFLAG_MAP_SX_TO_D3);
    dprintf("\n");

    dprintf("\n");
    dprintf("SavedFrameNumber:     %8x  SavedFRBaseAdd: %8x\n"
            "Port:                 %8x  HcDma:          %8x\n"
            "RegRecClocksPerFrame: %8x  Piix4EP         %8x\n"
            "EndpointListBusy:     %8d  SteppingVer:    %8x\n"
            "SavedSOFModify:       %8x  ControllerType: %8x\n",
            uhcd.SavedFRNUM,
            uhcd.SavedFRBASEADD,
            uhcd.Port,
            uhcd.HcDma,
            uhcd.RegRecClocksPerFrame,
            uhcd.Piix4EP,
            uhcd.EndpointListBusy,
            uhcd.SteppingVersion,
            uhcd.SavedSofModify,
            uhcd.ControllerType);

    return;
}

VOID
UHCD_HCRegisters(
    ULONG   MemLoc
)
{
    PDEVICE_OBJECT      hcObject;
    USBD_EXTENSION      usbd;
    ULONG               devExtAddr;
    DEVICE_EXTENSION    uhcd;

    ULONG               result;
    ULONG               regValue;
    ULONG               size;

    //
    // In this case, MemLoc points the the device object for the given
    //   host controller.
    //

    hcObject = (PDEVICE_OBJECT) MemLoc;

    //
    // Get the address of the device extension
    //

    devExtAddr = (ULONG) hcObject -> DeviceExtension;

    //
    // Read the USBD extension
    //

    if (!ReadMemory (devExtAddr, &usbd, sizeof (usbd), &result)) {
        dprintf ("Could not read Usbd Extension\n");
        return;
    }

    if (NULL != usbd.TrueDeviceExtension) {
        devExtAddr = (ULONG) usbd.TrueDeviceExtension;
    }

    if (!ReadMemory (devExtAddr, &uhcd, sizeof (uhcd), &result)) {
        dprintf ("Could not read UHCD Extension\n");
        return;
    }

    //
    // Get and display the command register (USBCMD)
    //

    size = 2;
    ReadIoSpace((ULONG) COMMAND_REG((&uhcd)), &regValue, &size);

    dprintf("\n");
    dprintf("Command Register: Run/Stop:       %x  HC reset:      %x  Global reset: %x\n"
            "                  Global Suspend: %x  Global Resume: %x  SW Debug:     %x\n"
            "                  Configure Flag: %x  Max Packet:    %x\n",
                               regValue & UHCD_CMD_RUN,
                               regValue & UHCD_CMD_RESET,
                               regValue & UHCD_CMD_GLOBAL_RESET,
                               regValue & UHCD_CMD_SUSPEND,
                               regValue & UHCD_CMD_FORCE_RESUME,
                               regValue & UHCD_CMD_SW_DEBUG,
                               regValue & UHCD_CMD_SW_CONFIGURED,
                               regValue & UHCD_CMD_MAXPKT_64);

    //
    // Get and display the status register (USBSTS)
    //

    ReadIoSpace((ULONG) STATUS_REG((&uhcd)), &regValue, &size);

    dprintf("\n");
    dprintf("Status Register:  Transfer Int: %x  Error Int: %x  Resume Detect: %x\n",
            "                  Host Error:   %x  HC Error:  %x  HC Halted: %x\n",
            regValue & UHCD_STATUS_USBINT,
            regValue & UHCD_STATUS_USBERR,
            regValue & UHCD_STATUS_RESUME,
            regValue & UHCD_STATUS_PCIERR,
            regValue & UHCD_STATUS_HCERR,
            regValue & UHCD_STATUS_HCHALT);

    //
    // Get and display the interrupt enable register (USBINTR)
    //

    ReadIoSpace((ULONG) INTERRUPT_MASK_REG((&uhcd)), &regValue, &size);

    dprintf("\n");
    dprintf("Interrupt Register: ");
    PRINT_FLAGS(regValue, UHCD_INT_MASK_TIMEOUT);
    PRINT_FLAGS(regValue, UHCD_INT_MASK_RESUME);
    PRINT_FLAGS(regValue, UHCD_INT_MASK_IOC);
    PRINT_FLAGS(regValue, UHCD_INT_MASK_SHORT);
    dprintf("\n");

    //
    // Get and display the frame number (FRNUM)
    //

    ReadIoSpace((ULONG) FRAME_LIST_CURRENT_INDEX_REG((&uhcd)), &regValue, &size);

    dprintf("\n");
    dprintf("Frame Number: %4x  ", regValue);

    //
    // Get and display the frame list base address (FRBASEADD)
    //

    size = 4;
    ReadIoSpace((ULONG) FRAME_LIST_BASE_REG((&uhcd)), &regValue, &size);

    dprintf("Frame List Base Address: %8x\n", regValue);
    
    //
    // Get and display the SOF Modify register (SOFMOD)
    //

    size = 2;
    ReadIoSpace((ULONG) SOF_MODIFY_REG((&uhcd)), &regValue, &size);

    dprintf("\n");
    dprintf("SOF Modify (%2x) --> Frame Length = %d\n",
            regValue,
            regValue + UHCD_12MHZ_SOF);

    //
    // Get and display the port status register for port 1
    //

    ReadIoSpace((ULONG) PORT1_REG((&uhcd)), &regValue, &size);

    UhciPortRegister(1, regValue);

    //
    // Get and display the port status register for port 2
    //

    ReadIoSpace((ULONG) PORT2_REG((&uhcd)), &regValue, &size);

    UhciPortRegister(2, regValue);

    return;
}

VOID
UhciPortRegister(
    ULONG   PortNumber,
    ULONG   Value
)
{
    dprintf("\n");
    dprintf("Port %2d: Device Connected: %1x  Connect Status Change: %1x\n"
            "          Port Enabled:     %1x  Port Enabled Changed:  %1x\n"
            "          Line Status D+:   %1x  Line Status D-         %1x\n"
            "          Resume Detect:    %1x  LS Device Attached:    %1x\n"
            "          Suspended (%1x):  ",
            PortNumber,
            Value & 0x01,
            Value & 0x02,
            Value & 0x04,
            Value & 0x08,
            Value & 0x10,
            Value & 0x20,
            Value & 0x40,
            Value & 0x100,
            Value & 0x400,
            Value & 0x1800);

    switch (Value & 0x1800)
    {
        case (0x00008000):
            dprintf("Enabled");
            break;

        case (0x00018000):
            dprintf("Suspend");
            break;

        default:
            dprintf("Disabled");
            break;
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\kdexts\util.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    util.c

Abstract:

    WinDbg Extension Api

Author:

    Wesley Witt (wesw) 15-Aug-1993

Environment:

    User Mode.

Revision History:

--*/


#include "precomp.h"
#pragma hdrstop


ULONG
GetUlongFromAddress (
    ULONG Location
    )
{
    ULONG Value;
    ULONG result;

    if ((!ReadMemory((DWORD)Location,&Value,sizeof(ULONG),&result)) ||
        (result < sizeof(ULONG))) {
        dprintf("unable to read from %08x\n",Location);
        return 0;
    }

    return Value;
}

ULONG
GetUlongValue (
    PCHAR String
    )
{
    ULONG Location;
    ULONG Value;
    ULONG result;


    Location = GetExpression( String );
    if (!Location) {
        dprintf("unable to get %s\n",String);
        return 0;
    }

    return GetUlongFromAddress(Location);
}


VOID
DumpImageName(
    IN PKPROCESS ProcessContents
    )
{
    dprintf("%ws",L"System Process");
}

ULONG
DumpSplayTree(
    IN PVOID pSplayLinks,
    IN PDUMP_SPLAY_NODE_FN DumpNodeFn
    )
/*++
    Purpose:

        Perform an in-order iteration across a splay tree, calling a
        user supplied function with a pointer to each RTL_SPLAY_LINKS
        structure encountered in the tree, and the level in the tree
        at which it was encountered (zero based).

    Arguments:

        pSplayLinks     - pointer to root of a splay tree

        DumpNodeFn      - user supplied dumping function

   Returns:

        Count of nodes encountered in the tree.

   Notes:

        Errors reading memory do not terminate the iteration if more
        work is possible.

        Consumes the Control-C flag to terminate possible loops in
        corrupt structures.

--*/
{
    RTL_SPLAY_LINKS SplayLinks, Parent;
    ULONG Level = 0;
    ULONG NodeCount = 0;

    if (pSplayLinks) {

        //
        //  Retrieve the root links, find the leftmost node in the tree
        //

        if (!ReadAtAddress(pSplayLinks,
                            &SplayLinks,
                            sizeof(RTL_SPLAY_LINKS),
                            &pSplayLinks)) {

            return NodeCount;
        }

        while (DbgRtlLeftChild(SplayLinks) != NULL) {

            if ( CheckControlC() ) {

                return NodeCount;
            }

            if (!ReadAtAddress(DbgRtlLeftChild(SplayLinks),
                                &SplayLinks,
                                sizeof(RTL_SPLAY_LINKS),
                                &pSplayLinks)) {

                //
                //  We can try to continue from this
                //

                break;
            }

            Level++;
        }

        while (TRUE) {

            if ( CheckControlC() ) {

                return NodeCount;
            }

            NodeCount++;
            (*DumpNodeFn)(pSplayLinks, Level);

            /*
                first check to see if there is a right subtree to the input link
                if there is then the real successor is the left most node in
                the right subtree.  That is find and return P in the following diagram

                      Links
                         \
                          .
                         .
                        .
                       /
                      P
                       \
            */

            if (DbgRtlRightChild(SplayLinks) != NULL) {

                if (!ReadAtAddress(DbgRtlRightChild(SplayLinks),
                                    &SplayLinks,
                                    sizeof(RTL_SPLAY_LINKS),
                                    &pSplayLinks)) {

                    //
                    //  We've failed to step through to a successor, so
                    //  there is no more to do
                    //

                    return NodeCount;
                }

                Level++;

                while (DbgRtlLeftChild(SplayLinks) != NULL) {

                    if ( CheckControlC() ) {

                        return NodeCount;
                    }

                    if (!ReadAtAddress(DbgRtlLeftChild(SplayLinks),
                                        &SplayLinks,
                                        sizeof(RTL_SPLAY_LINKS),
                                        &pSplayLinks)) {

                        //
                        //  We can continue from this
                        //

                        break;
                    }

                    Level++;
                }

            } else {

                /*
                    we do not have a right child so check to see if have a parent and if
                    so find the first ancestor that we are a left decendent of. That
                    is find and return P in the following diagram

                               P
                              /
                             .
                              .
                               .
                              Links
                */

                //
                //  If the IsLeft or IsRight functions fail to read through a parent
                //  pointer, then we will quickly exit through the break below
                //

                while (DbgRtlIsRightChild(SplayLinks, pSplayLinks, &Parent)) {

                    if ( CheckControlC() ) {

                        return NodeCount;
                    }

                    Level--;
                    pSplayLinks = DbgRtlParent(SplayLinks);
                    SplayLinks = Parent;
                }

                if (!DbgRtlIsLeftChild(SplayLinks, pSplayLinks, &Parent)) {

                    //
                    //  we do not have a real successor so we break out
                    //

                    break;

                } else {

                    Level--;
                    pSplayLinks = DbgRtlParent(SplayLinks);
                    SplayLinks = Parent;
                }
            }
        }
    }

    return NodeCount;
}


VOID
DumpUnicode(
    UNICODE_STRING u
    )
{
    UNICODE_STRING v;
    DWORD BytesRead;

    if ((u.Length <= u.MaximumLength) &&
        (u.Buffer) &&
        (u.Length > 0)) {

        v.Buffer = LocalAlloc(LPTR, u.MaximumLength);
        if (v.Buffer != NULL) {
            v.MaximumLength = u.MaximumLength;
            v.Length = u.Length;
            if (ReadAtAddress(u.Buffer,
                              v.Buffer,
                              u.Length,
                              &u.Buffer)) {
                dprintf("%wZ", &v);
            } else {
                dprintf("<???>");
            }
            LocalFree(v.Buffer);

            return;
        }
    }
}

BOOLEAN
IsHexNumber(
   const char *szExpression
   )
{
   if (!szExpression[0]) {
      return FALSE ;
   }

   for(;*szExpression; szExpression++) {
      
      if      ((*szExpression)< '0') { return FALSE ; } 
      else if ((*szExpression)> 'f') { return FALSE ; }
      else if ((*szExpression)>='a') { continue ;     }
      else if ((*szExpression)> 'F') { return FALSE ; }
      else if ((*szExpression)<='9') { continue ;     }
      else if ((*szExpression)>='A') { continue ;     }
      else                           { return FALSE ; }
   }
   return TRUE ;
}


BOOLEAN
IsDecNumber(
   const char *szExpression
   )
{
   if (!szExpression[0]) {
      return FALSE ;
   }

   while(*szExpression) {
      
      if      ((*szExpression)<'0') { return FALSE ; } 
      else if ((*szExpression)>'9') { return FALSE ; }
      szExpression ++ ;
   }
   return TRUE ;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\kdexts\vad.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    vad.c

Abstract:

    WinDbg Extension Api

Author:

    Lou Perazzoli (loup) 12-Jun-1992

Environment:

    User Mode.

Revision History:

    Converted to WinDbg extension:
    Ramon J San Andres (ramonsa) 8-Nov-1993

--*/

#include "precomp.h"
#pragma hdrstop

DECLARE_API( vad )

/*++

Routine Description:

    Dumps all vads for process.

Arguments:

    args - Address Flags

Return Value:

    None

--*/

{
    ULONG   Result;
    PMMADDRESS_NODE  Next;
    PMMADDRESS_NODE  VadToDump;
    PMMADDRESS_NODE  Parent;
    PMMADDRESS_NODE  First;
    PMMADDRESS_NODE  Left;
    MMVAD   CurrentVad;
    ULONG   Flags;
    ULONG   Done;
    ULONG   Level = 0;
    ULONG   Count = 0;
    ULONG   AverageLevel = 0;
    ULONG   MaxLevel = 0;

    VadToDump = (PVOID)0xFFFFFFFF;
    Flags     = 0;
    sscanf(args,"%lx %lx",&VadToDump,&Flags);

    if (VadToDump == (PVOID)0xFFFFFFFF) {
        VadToDump = (PMMADDRESS_NODE)GetNtDebuggerDataValue(MmVadRoot);
    }

    First = VadToDump;
    if (First == NULL) {
        return;
    }

    RtlZeroMemory (&CurrentVad, sizeof(MMVAD));

    if ( !ReadMemory( (DWORD)First,
                      &CurrentVad,
                      sizeof(MMVAD),
                      &Result) ) {
        dprintf("%08lx: Unable to get contents of VAD\n",First );
        return;
    }

    if (Flags) {

        //
        // Dump only this vad.
        //

        dprintf("\nVAD @ %8lx\n",VadToDump);
        dprintf("  Start VPN:      %8lx  End VPN: %8lx\n",
            CurrentVad.StartingVpn,
            CurrentVad.EndingVpn);

        dprintf ("\n\n");

        return;
    }

    while (CurrentVad.LeftChild != NULL) {
        if ( CheckControlC() ) {
            return;
        }
        First = CurrentVad.LeftChild;
        Level += 1;
        if (Level > MaxLevel) {
            MaxLevel = Level;
        }
        if ( !ReadMemory( (DWORD)First,
                          &CurrentVad,
                          sizeof(MMVAD),
                          &Result) ) {
            dprintf("%08lx:%lx Unable to get contents of VAD\n",First, CurrentVad );
            return;
        }
    }

    dprintf("VAD     level      start      end\n");
    dprintf("%lx (%2ld)   %8lx %8lx\n",
            First,
            Level,
            CurrentVad.StartingVpn,
            CurrentVad.EndingVpn
            );
    Count += 1;
    AverageLevel += Level;

    Next = First;
    while (Next != NULL) {

        if ( CheckControlC() ) {
            return;
        }

        if (CurrentVad.RightChild == NULL) {

            Done = TRUE;
            while ((Parent = CurrentVad.Parent) != NULL) {
                if ( CheckControlC() ) {
                    return;
                }

                Level -= 1;

                //
                // Locate the first ancestor of this node of which this
                // node is the left child of and return that node as the
                // next element.
                //

                if ( !ReadMemory( (DWORD)Parent,
                                  &CurrentVad,
                                  sizeof(MMVAD),
                                  &Result) ) {
                    dprintf("%08lx:%lx Unable to get contents of VAD\n",Parent, CurrentVad);
                    return;
                }

                if (CurrentVad.LeftChild == Next) {
                    Next = Parent;
                    dprintf("%lx (%2ld)   %8lx %8lx\n",
                            Next,
                            Level,
                            CurrentVad.StartingVpn,
                            CurrentVad.EndingVpn
                           );
                    Done = FALSE;
                    Count += 1;
                    AverageLevel += Level;
                    break;
                }
                Next = Parent;
            }
            if (Done) {
                Next = NULL;
                break;
            }
        } else {

            //
            // A right child exists, locate the left most child of that right child.
            //

            Next = CurrentVad.RightChild;
            Level += 1;
            if (Level > MaxLevel) {
                MaxLevel = Level;
            }

            if ( !ReadMemory( (DWORD)Next,
                              &CurrentVad,
                              sizeof(MMVAD),
                              &Result) ) {
                dprintf("%08lx:%lx Unable to get contents of VAD\n",Next, CurrentVad);
                return;
            }

            while ((Left = CurrentVad.LeftChild) != NULL) {
                if ( CheckControlC() ) {
                    return;
                }
                Level += 1;
                if (Level > MaxLevel) {
                    MaxLevel = Level;
                }
                Next = Left;
                if ( !ReadMemory( (DWORD)Next,
                                  &CurrentVad,
                                  sizeof(MMVAD),
                                  &Result) ) {
                    dprintf("%08lx:%lx Unable to get contents of VAD\n",Next, CurrentVad);
                    return;
                }
            }

            dprintf("%lx (%2ld)   %8lx %8lx\n",
                      Next,
                      Level,
                      CurrentVad.StartingVpn,
                      CurrentVad.EndingVpn
                   );
                    Count += 1;
                    AverageLevel += Level;
        }
    }
    dprintf("\nTotal VADs: %5ld  average level: %4ld  maximum depth: %ld\n",
            Count, 1+(AverageLevel/Count),MaxLevel);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\kdexts\p_i386\apic.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    apic.c

Abstract:

    WinDbg Extension Api

Author:

    Ken Reneris (kenr) 06-June-1994

Environment:

    User Mode.

Revision History:

--*/

#include "precomp.h"
#include "apic.h"
#include <ntapic.inc>

#pragma hdrstop

#define LU_SIZE     0x400

#define LU_ID_REGISTER          0x00000020
#define LU_VERS_REGISTER        0x00000030
#define LU_TPR                  0x00000080
#define LU_APR                  0x00000090
#define LU_PPR                  0x000000A0
#define LU_EOI                  0x000000B0
#define LU_REMOTE_REGISTER      0x000000C0

#define LU_DEST                 0x000000D0
#define LU_DEST_FORMAT          0x000000E0

#define LU_SPURIOUS_VECTOR      0x000000F0
#define LU_FAULT_VECTOR         0x00000370

#define LU_ISR_0                0x00000100
#define LU_TMR_0                0x00000180
#define LU_IRR_0                0x00000200
#define LU_ERROR_STATUS         0x00000280
#define LU_INT_CMD_LOW          0x00000300
#define LU_INT_CMD_HIGH         0x00000310
#define LU_TIMER_VECTOR         0x00000320
#define LU_INT_VECTOR_0         0x00000350
#define LU_INT_VECTOR_1         0x00000360
#define LU_INITIAL_COUNT        0x00000380
#define LU_CURRENT_COUNT        0x00000390
#define LU_DIVIDER_CONFIG       0x000003E0


#define IO_REGISTER_SELECT      0x00000000
#define IO_REGISTER_WINDOW      0x00000010

#define IO_ID_REGISTER          0x00000000
#define IO_VERS_REGISTER        0x00000001
#define IO_ARB_ID_REGISTER      0x00000002
#define IO_REDIR_BASE           0x00000010



ApicRead (
    ULONG   Address,
    ULONG   Offset
    )
{
    ULONG   Data, result;

    ReadMemory((DWORD)Address + Offset, &Data, sizeof (ULONG), &result);
    return Data;
}

IoApicRead (
    ULONG64 PhysAddress,
    ULONG   Offset
    )
{
    ULONG   Data, result;

    PhysAddress += IO_REGISTER_SELECT;
    WritePhysical(PhysAddress, &Offset, sizeof(ULONG), &result);

    PhysAddress += IO_REGISTER_WINDOW - IO_REGISTER_SELECT;
    ReadPhysical (PhysAddress, &Data, sizeof (ULONG), &result);
    return Data;
}


ULONG
ApicDumpSetBits (
    PUCHAR  Desc,
    ULONG   Address,
    ULONG   Offset
    )
{
    ULONG   Bits [0x80 / sizeof (ULONG)];
    PULONG  p;
    ULONG   i, result;
    BOOLEAN FoundOne;

    ReadMemory((DWORD)Address + Offset, Bits, 0x80, &result);

    dprintf (Desc);

    i = 0;
    p = Bits;
    FoundOne = FALSE;
    for (; ;) {
        if (*p & 1) {
            if (FoundOne) {
                dprintf (", %x", i);
            } else {
                FoundOne = TRUE;
                dprintf ("%x", i);
            }
        }

        *p >>= 1;
        i++;
        if (i >= 0x100) {
            break;
        }

        if ((i % 32) == 0) {
            p += 4;
        }

    }

    dprintf ("\n");
    return 0;
}

ULONG
ApicDumpRedir (
    PUCHAR      Desc,
    BOOLEAN     CommandReg,
    BOOLEAN     DestSelf,
    ULONG       lh,
    ULONG       ll
    )
{
    static PUCHAR DelMode[] = {
        "FixedDel",
        "LowestDl",
        "res010  ",
        "remoterd",
        "NMI     ",
        "RESET   ",
        "res110  ",
        "ExtINTA "
        };

    static PUCHAR DesShDesc[] = { "",
        "  Dest=Self",
        "   Dest=ALL",
        " Dest=Othrs"
        };

    ULONG   del, dest, delstat, rirr, trig, masked, destsh, pol;

    del     = (ll >> 8)  & 0x7;
    dest    = (ll >> 11) & 0x1;
    delstat = (ll >> 12) & 0x1;
    pol     = (ll >> 13) & 0x1;
    rirr    = (ll >> 14) & 0x1;
    trig    = (ll >> 15) & 0x1;
    masked  = (ll >> 16) & 0x1;
    destsh  = (ll >> 18) & 0x3;

    if (CommandReg) {
        // command reg's don't have a mask
        masked = 0;
    }

    dprintf ("%s: %08x  Vec:%02X  %s  ",
            Desc,
            ll,
            ll & 0xff,
            DelMode [ del ]
            );

    if (DestSelf) {
        dprintf (DesShDesc[1]);
    } else if (CommandReg  &&  destsh) {
        dprintf (DesShDesc[destsh]);
    } else {
        if (dest) {
            dprintf ("Lg:%08x", lh);
        } else {
            dprintf ("PhysDest:%02X", (lh >> 56) & 0xFF);
        }
    }

    dprintf ("%s %s  %s  %s %s\n",
            delstat ? "-Pend"   : "     ",
            trig    ? "lvl"     : "edg",
            pol     ? "low "    : "high",
            rirr    ? "rirr"    : "    ",
            masked  ? "masked"  : "      "
            );

    return 0;
}


DECLARE_API( apic )

/*++

Routine Description:

    Dumps local apic

Arguments:

    args - Supplies the address in hex.

Return Value:

    None

--*/
{
    static PUCHAR divbase[] = { "2", "4", "8", "f" };
    static PUCHAR clktype[] = { "clk", "tmbase", "%s/%s", "??%s/%s" };
    ULONG       Address;
    ULONG       result, junk, l, ll, lh, clkvec;
    UCHAR       s[40];


    if (sscanf(args,"%lX",&Address) != 1) {

        //
        // Default Apic address
        //

        Address = 0xfffe0000;
    }

    if (Address == 0) {

        //
        // Use default for MPS systems.
        //

        Address = 0xfffe0000;
    }

    if ( !ReadMemory(
                (DWORD)Address,
                (PVOID)&junk,
                1,
                &result
                ) ) {
        dprintf("Unable to read lapic\n");
        return;
    }

    if ( !ReadMemory(
                (DWORD)Address + LU_SIZE - 1,
                (PVOID)&junk,
                1,
                &result
                ) ) {
        dprintf("Unable to read lapic\n");
        return;
    }

    dprintf ("Apic @ %08x  ID:%x (%x)  LogDesc:%08x  DestFmt:%08x  TPR %02X\n",
        Address,
        ApicRead (Address, LU_ID_REGISTER) >> 24,
        ApicRead (Address, LU_VERS_REGISTER),
        ApicRead (Address, LU_DEST),
        ApicRead (Address, LU_DEST_FORMAT),
        ApicRead (Address, LU_TPR)
        );

    l  = ApicRead (Address, LU_SPURIOUS_VECTOR);
    ll = ApicRead (Address, LU_DIVIDER_CONFIG);
    clkvec = ApicRead (Address, LU_TIMER_VECTOR);
    sprintf (s, clktype[ (clkvec >> 18) & 0x3 ],
        clktype [ (ll >> 2) & 0x1 ],
        divbase [ ll & 0x3]
        );

    dprintf ("TimeCnt: %08x%s%s  SpurVec:%02x  FaultVec:%02x  error:%x%s\n",
        ApicRead (Address, LU_INITIAL_COUNT),
        s,
        ((clkvec >> 17) & 1) ? "" : "-oneshot",
        l & 0xff,
        ApicRead (Address, LU_FAULT_VECTOR),
        ApicRead (Address, LU_ERROR_STATUS),
        l & 0x100 ? "" : "  DISABLED"
        );

    ll = ApicRead (Address, LU_INT_CMD_LOW);
    lh = ApicRead (Address, LU_INT_CMD_HIGH);
    ApicDumpRedir ("Ipi Cmd", TRUE,  FALSE, lh, ll);
    ApicDumpRedir ("Timer..", FALSE, TRUE, 0, clkvec);
    ApicDumpRedir ("Linti0.", FALSE, TRUE, 0, ApicRead (Address, LU_INT_VECTOR_0));
    ApicDumpRedir ("Linti1.", FALSE, TRUE, 0, ApicRead (Address, LU_INT_VECTOR_1));

    ApicDumpSetBits ("TMR: ", Address, LU_TMR_0);
    ApicDumpSetBits ("IRR: ", Address, LU_IRR_0);
    ApicDumpSetBits ("ISR: ", Address, LU_ISR_0);
}



DECLARE_API( ioapic )

/*++

Routine Description:

    Dumps io apic

Arguments:

    args - Supplies the address in hex, if no address is specified, all IOApics will be dumped.

Return Value:

    None

--*/
{
    ULONG64     PhysAddress;
    ULONG       Address;
    ULONG       i, ll, lh, max, IOApicCount;
    UCHAR       s[40];
    BOOLEAN     Converted;
    MP_INFO     HalpMpInfoTable;
    PVOID       addr;
    UCHAR       count;

    
    sscanf(args,"%lX",&Address);

    Converted = MiGetPhysicalAddress ((PVOID) Address, &PhysAddress);
    
    if (Converted) {
        IOApicCount = 1;
    } else {
        
        //
        // Get a copy of the global data structure Hal!HalpMpInfoTable.
        //
    
        addr = (PVOID)GetExpression("Hal!HalpMpInfoTable");
    
        if (addr == NULL) {
            dprintf ("Error retrieving address of HalpMpInfoTable\n");
            return;
        }
    
        if (!xReadMemory(addr, &HalpMpInfoTable, sizeof(MP_INFO))){
            dprintf ("Error reading HalpMpInfoTable\n");
            return;
        }
    
        IOApicCount = HalpMpInfoTable.IOApicCount;
        Address =  (ULONG) HalpMpInfoTable.IoApicBase[0];
        Converted = MiGetPhysicalAddress ((PVOID) Address, &PhysAddress);
    }

    for (count = 0; count < IOApicCount; count++) {

        ll = IoApicRead (PhysAddress, IO_VERS_REGISTER),
        max = (ll >> 16) & 0xff;
        dprintf ("IoApic @ %08x  ID:%x (%x)  Arb:%x\n",
            Address,
            IoApicRead (PhysAddress, IO_ID_REGISTER) >> 24,
            ll & 0xFF,
            IoApicRead (PhysAddress, IO_ARB_ID_REGISTER)
        );
    
        //
        // Dump inti table
        //
    
        max *= 2;
        for (i=0; i <= max; i += 2) {
            ll = IoApicRead (PhysAddress, IO_REDIR_BASE+i+0);
            lh = IoApicRead (PhysAddress, IO_REDIR_BASE+i+1);
            sprintf (s, "Inti%02X.", i/2);
            ApicDumpRedir (s, FALSE, FALSE, lh, ll);
        }

        //
        // Get the next IoApic Virtual Address, convert it to Physical
        // and break if this conversion fails.
        //

        Address =  (ULONG) HalpMpInfoTable.IoApicBase[count+1];
        Converted = MiGetPhysicalAddress ((PVOID) Address, &PhysAddress);
        
        if (!Converted) {
            break;
        }

        dprintf ("\n");
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\kdexts\p_i386\cpuinfo.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    mps.c

Abstract:

    WinDbg Extension Api

Author:

    Peter Johnston (peterj) 19-April-1999

Environment:

    User Mode.

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

//
// xReadMemory is easier to use than ReadMemory and is
// defined in ..\devnode.c
//

BOOLEAN
xReadMemory(
    PVOID S,
    PVOID D,
    ULONG Len
    );


VOID
DumpCpuInfo(
    IN ULONG StartCpu,
    IN BOOLEAN DoMultipleCpus
)
{
    KPCR    pcr;
    KPRCB   prcb;
    ULONG   addr;
    ULONG   processor = StartCpu;
    BOOLEAN doNext = DoMultipleCpus;
    BOOLEAN doHead = TRUE;
    UCHAR   sigWarn1, sigWarn2;
    LARGE_INTEGER updateSignature;
    PROCESSORINFO pi;

    if (!Ioctl(IG_KD_CONTEXT, &pi, sizeof(pi))) {
        dprintf("Unable to get processor info, quitting\n");
        return;
    }

    do {
        if (!ReadPcr((USHORT)processor, &pcr, &addr, (HANDLE)0)) {
            if (doNext == FALSE) {

                //
                // if not doing a bunch of processors, user must have
                // asked for this one,... so we should tell them we
                // couldn't get to it.
                //

                dprintf("Unable to read PCR for Processor %u, quitting\n",
                        processor);
            }
            return;
        }

        //
        // Got the PCR, what we really want is the PRCB.
        //
        // Sanity?
        //

        if ((ULONG)pcr.Prcb != ((ULONG)pcr.SelfPcr + FIELD_OFFSET(KPCR, PrcbData))) {
            dprintf(
                "!sanity: PCR->Prcb (%p) != &PCR->PrcbData (%p), quitting.\n",
                pcr.Prcb,
                pcr.SelfPcr + FIELD_OFFSET(KPCR, PrcbData)
                );
            return;
        }

        if (!xReadMemory(pcr.Prcb, &prcb, sizeof(prcb))) {
            dprintf("Unable to read PRCB for processor %u, quitting.\n",
                    processor);
            return;
        }

        if ((ULONG)prcb.Number != processor) {

            //
            // Processor number isn't what I expected.  Bail out.
            // This will need revisiting at some stage in the future
            // when we support a discontiguous set of processor numbers.
            //

            dprintf("Processor %d mismatch with processor number in PRCB %d, quitting\n",
                    processor,
                    prcb.Number);
            return;
        }

        if (prcb.CpuID == 0) {

            //
            // This processor doesn't support CPUID,... not likely in
            // an MP environment but also means we don't have anything
            // useful to say.
            //

            dprintf("Processor %d doesn't support CPUID, quitting.\n",
                    processor);
        }

        //
        // If this is an Intel processor, family 6 (or, presumably
        // above family 6) read the current UpdateSignature from 
        // the processor rather than using what was there when we
        // booted,... it may have been updated.
        //
        // Actually, this can't be done unless we can switch processors
        // from within an extension.   So, mark the processor we did
        // it for (unless there's only one processor).
        //

        updateSignature = prcb.UpdateSignature;
        sigWarn1 = sigWarn2 = ' ';

        if ((!strcmp(prcb.VendorString, "GenuineIntel")) &&
            (prcb.CpuType >= 6)) {

            if (prcb.Number == pi.Processor) {
                READ_WRITE_MSR msr;

                msr.Msr = 0x8b;
                msr.Value = 0;

                if (Ioctl(IG_READ_MSR, &msr, sizeof(msr))) {
                    updateSignature.QuadPart = msr.Value;
                }
                if (pi.NumberProcessors != 1) {
                    sigWarn1 = '>';
                    sigWarn2 = '<';
                }
            }
        }

        //
        // This extension could pretty much be !PRCB but it's a 
        // subset,... perhaps we should have a !PRCB?
        //

        if (doHead) {

            //
            // Be pretty.
            //

            dprintf("CP F/M/S Manufacturer  MHz Update Signature Features\n");
            doHead = FALSE;
        }

        dprintf("%2d %d,%d,%d %12s%5d%c%08x%08x%c%08x\n",
                prcb.Number,
                prcb.CpuType,
                (prcb.CpuStep >> 8) & 0xff,
                prcb.CpuStep & 0xff,
                prcb.VendorString,
                prcb.MHz,
                sigWarn1,
                updateSignature.u.HighPart,
                updateSignature.u.LowPart,
                sigWarn2,
                prcb.FeatureBits);

        //
        // Done with this processor,... advance.  (Sanity check too,...
        // this is an x86 extension, we'll never support more than 32
        // processors on x86).
        //

        if (++processor > 31) {
            doNext = FALSE;
        }
    } while (doNext == TRUE);
}

DECLARE_API( cpuinfo )

/*++

Routine Description:

    Gather up any info we know is still in memory that we gleaned
    using the CPUID instruction,.... and a few other interesting
    tidbits as well.

Arguments:

    None

Return Value:

    None

--*/

{
    ULONG   processor;
    BOOLEAN doNext = FALSE;

#if 0

    //
    // Apply to whichever processor user asks for
    //

    if (strlen(args)) {
        if (strchr(args, '?')) {

            //
            // User wants to know the rules.
            //

            dprintf("usage: !cpuinfo      print cpuinfo info for current cpu.\n");
            dprintf("       !cpuinfo n    print cpuinfo info for cpu n.\n");
            dprintf("       !cpuinfo all  print cpuinfo for all processors.\n");
            return;
        }
        if (!strcmp(args, "all")) {
            doNext = TRUE;
            processor = 0;
        } else {
            processor = strtoul(args, NULL, 16);
        }
    } else {
        processor = dwProcessor;
    }

#else

    //
    // Default to all CPUs, always (ie no options).
    //

    doNext = TRUE;
    processor = 0;

#endif

    DumpCpuInfo(processor, doNext);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\kdexts\usbtree.cpp ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    USBD.c

Abstract:

    WinDbg Extension Api

Author:

    Mitchell Dernis (mitchd) 8/11/2000

Environment:

    User Mode.

Revision History:

--*/

#define _NTSYSTEM_
#include "api.h"
#include "x86api.h"

#include <usbd.h>

void DumpCurrentlyEnumerating(CDeviceTree *pTree,IUsbDevice *pDevices);
void DumpPendingEnumerationList(CDeviceTree *pTree, IUsbDevice *pDevices);
void DumpActiveNode(CDeviceTree *pTree, IUsbDevice *pDevices, UCHAR ParentNode, UCHAR Node, PUSBD_HOST_CONTROLLER pHostController, int Depth);
void DumpFunctionNode(CDeviceTree *pTree, IUsbDevice *pDevice, PUSBD_HOST_CONTROLLER pHostController, int Depth);
void DumpInterfaceFunctionNode(CDeviceTree *pTree, IUsbDevice *pDevice, PUSBD_HOST_CONTROLLER pHostController, int Depth);
void DumpHubNode(CDeviceTree *pTree, IUsbDevice *pDevice, PUSBD_HOST_CONTROLLER pHostController, int Depth);
void DumpCompositeFunctionNode(CDeviceTree *pTree, IUsbDevice *pDevice, PUSBD_HOST_CONTROLLER pHostController, int Depth);
void DumpInterfaceNode(CDeviceTree *pTree, IUsbDevice *pDevice, PUSBD_HOST_CONTROLLER pHostController, int Depth);
void DumpPendingEnumerationNode(CDeviceTree *pTree, IUsbDevice *pDevice, PUSBD_HOST_CONTROLLER pHostController, int Depth);
void DumpEnumeratingNode(CDeviceTree *pTree, IUsbDevice *pDevice, PUSBD_HOST_CONTROLLER pHostController, int Depth);
void DumpPendingRemoved(CDeviceTree *pTree, IUsbDevice *pDevices);
void DumpFreeNodes(CDeviceTree *pTree, IUsbDevice *pDevices);

CHAR *EnumStageString(UCHAR Stage);
PNP_CLASS_ID GetPnpClassId(IUsbDevice *pDevice);
BOOL CheckMarkAccessed(UCHAR Node, PULONG Bitfield, BOOL fCheckOnly);

struct DepthStrings
{
    PCHAR DepthString;
};

DepthStrings g_DepthString[4] = 
{
    "1__",
    "2____",
    "3______",
    "4________"
};

//
//  The a 64 bits used to keep track
//  of Nodes that are already in use.
//  Used to check for corruption.
//
ULONG g_ActiveNodes[4];
ULONG g_PendingEnum[4];
ULONG g_FreeNodes[4];

//
// USBD function definitions
//

DECLARE_API( xpptree )

/*++

Routine Description:

   Dumps the Xbox Peripheral Port Tree

Arguments:

    args - flags

Return Value:

    None

--*/

{
    UNREFERENCED_PARAMETER (dwProcessor);
    UNREFERENCED_PARAMETER (dwCurrentPc);
    UNREFERENCED_PARAMETER (hCurrentThread);
    UNREFERENCED_PARAMETER (hCurrentProcess);
    UNREFERENCED_PARAMETER (args);
    
    UCHAR DeviceTreeBuffer[sizeof(CDeviceTree)];
    ULONG ulDeviceTreeAddress;
    CDeviceTree *pDeviceTree;
    IUsbDevice *pDevices;
    
    ulDeviceTreeAddress = GetExpression( "g_DeviceTree" );
    
    if(!ulDeviceTreeAddress)
    {
        dprintf("Could not find Xbox Peripheral Port Tree\n");
        return;
    }
    //
    //  Dump Tree Header
    //
    dprintf("Xbox Peripheral Port Tree @0x%0.8x--------------\n", ulDeviceTreeAddress);
    //
    //  Read in the device tree
    //
    if(FALSE == ReadMemory(ulDeviceTreeAddress, (PVOID)DeviceTreeBuffer, sizeof(CDeviceTree), NULL))
    {
       dprintf("Error reading device tree.\n");
       return;
    }
    pDeviceTree = (CDeviceTree *)DeviceTreeBuffer;
    //
    //  Display node count.
    //
    ULONG NodeCount = pDeviceTree->m_NodeCount;
    dprintf("Static Node Count = %d\n", NodeCount);
    dprintf("Device nodes @0x%0.8x\n", pDeviceTree->m_Devices);
    //
    //  Read in the devices.
    //
    pDevices = (IUsbDevice *) new UCHAR[NodeCount*sizeof(IUsbDevice)];

    if(FALSE == ReadMemory((ULONG)pDeviceTree->m_Devices, (PVOID)pDevices, NodeCount*sizeof(IUsbDevice), NULL))
    {
       dprintf("Error reading devices.\n");
       return;
    }

    //
    //  Clear used nodes
    //
    memset(g_ActiveNodes, 0, sizeof(g_ActiveNodes));
    memset(g_PendingEnum, 0, sizeof(g_PendingEnum));
    memset(g_FreeNodes, 0, sizeof(g_FreeNodes));

    //
    //  Dump information on enumerating nodes.
    //
    if(pDeviceTree->m_InProgress)
    {
        DumpCurrentlyEnumerating(pDeviceTree, pDevices);
        DumpPendingEnumerationList(pDeviceTree, pDevices);
    } else
    {
        dprintf("--Not Currently Enumerating------------------------\n");
    }
    //
    //  Dump active node tree under host controller 1
    //
    if(UDN_TYPE_ROOT_HUB == pDevices[0].m_Type)
    {
        dprintf("--Host Controller 1--------------------------------\n");
        if(CheckMarkAccessed(0, g_PendingEnum, TRUE))
        {
            dprintf("CORRUPT TREE: Root Hub for HostController 1 in pending enum list!\n");    
        }
        if(CheckMarkAccessed(0, g_FreeNodes, TRUE))
        {
            dprintf("CORRUPT TREE: Root Hub for HostController 1 in free node list!\n");    
        }
        CheckMarkAccessed(0, g_ActiveNodes, FALSE);
        dprintf("Host Controller: 0x%0.8x\n", pDevices[0].m_HostController);
        DumpActiveNode(pDeviceTree, pDevices, 0, pDevices[0].m_FirstChild, pDevices[0].m_HostController, 0);
    }
    //
    //  Dump active node tree under host controller 2
    //
    if(UDN_TYPE_ROOT_HUB == pDevices[1].m_Type)
    {
        dprintf("---------------------------------------------------\n");
        dprintf("--Host Controller 2--------------------------------\n");
        if(CheckMarkAccessed(1, g_PendingEnum, TRUE))
        {
            dprintf("CORRUPT TREE: Root Hub for HostController 2 in pending enum list!\n");    
        }
        if(CheckMarkAccessed(1, g_FreeNodes, TRUE))
        {
            dprintf("CORRUPT TREE: Root Hub for HostController 2 in free node list!\n");    
        }
        CheckMarkAccessed(1, g_ActiveNodes, FALSE);
        dprintf("Host Controller: 0x%0.8x", pDevices[1].m_HostController);
        DumpActiveNode(pDeviceTree, pDevices, 1, pDevices[1].m_FirstChild, pDevices[1].m_HostController, 0);
    }
    //
    //  Dump removed nodes.
    //
    DumpPendingRemoved(pDeviceTree, pDevices);

    //
    //  Dump free nodes.
    //
    DumpFreeNodes(pDeviceTree, pDevices);

    //
    //  Clean Up
    //
    delete pDevices;
}

void DumpCurrentlyEnumerating(CDeviceTree *pTree,IUsbDevice *pDevices)
{
    dprintf("--Currently Enumerating ---------------------------\n");    
    dprintf("Node %d.\n", pTree->m_CurrentEnum - pTree->m_Devices);
    if(pTree->m_DeviceRemoved)
    {
        dprintf("Device has been removed.\n");
    }
    dprintf("Stage %s.\n", EnumStageString(pTree->m_EnumStage));
    dprintf("Remaining retires: %d.\n", pTree->m_RetryCount);
}

void DumpPendingEnumerationList(CDeviceTree *pTree, IUsbDevice *pDevices)
{
   if(!pTree->m_FirstPendingEnum) return;
   dprintf("--Pending Enumeration -----------------------------\n");
   UCHAR PendingNode =  pTree->m_FirstPendingEnum - pTree->m_Devices;
   IUsbDevice *pPendingDevice = pDevices + PendingNode;
   while(pPendingDevice)
   {
       dprintf("Node: %d(0x%0.8x)\n", PendingNode, pTree->m_Devices + PendingNode);
       if(CheckMarkAccessed(PendingNode, g_PendingEnum, FALSE))
       {
         dprintf("CORRUPT TREE: Circular Pending Enumeration List\n");
         return;
       }
       if(pDevices->m_NextPending)
       {
            PendingNode = pDevices->m_NextPending - pTree->m_Devices;
            pPendingDevice = pDevices + PendingNode;
       } else
       {
         pPendingDevice = NULL;
       }
   }
}


void DumpActiveNode(CDeviceTree *pTree, IUsbDevice *pDevices, UCHAR ParentNode, UCHAR Node, PUSBD_HOST_CONTROLLER pHostController, int Depth)
{
    CHAR *pDepth = g_DepthString[Depth].DepthString;
    //
    //  Once we hit the end return.
    //  
    if(UDN_INVALID_NODE_INDEX == Node) return;
    //
    //  Print out the node we are dumping
    //
    dprintf("---------------------------------------------------\n");
    dprintf("%sNode %d(0x%0.8x)\n", pDepth, Node, pTree->m_Devices + Node);
    //
    //  Check for illegal depth
    //
    if(3 == Depth)
    {
        dprintf("%sCORRUPT TREE: maximum node depth exceeded.\n", pDepth);
    }
    //
    //  Check for corruption
    //
    if(pTree->m_NodeCount <= Node)
    {
        dprintf("%sCORRUPT TREE: Illegal Node\n", pDepth);
        return;
    }
    //  
    //  Check for circular tree error
    //
    if(CheckMarkAccessed(Node, g_ActiveNodes, FALSE))
    {
        dprintf("%sCORRUPT TREE: Circular Node Reference.\n", pDepth);
        return;
    }
    //
    //  Node is presumably reasonable
    //
    IUsbDevice *pDevice = pDevices+Node;
    //
    //  Check for problems with respect to pending enum list.
    //
    if(CheckMarkAccessed(Node, g_PendingEnum, TRUE))
    {
        if(UDN_TYPE_PENDING_ENUM != pDevice->m_Type)
        {
            dprintf("%sCORRUPT TREE: Active or Enumerating Node is also in  pending enumeration list.\n", pDepth);
        }
    } else
    {
        if(UDN_TYPE_PENDING_ENUM == pDevice->m_Type)
        {
            dprintf("%sCORRUPT TREE: Node is pending enumeration, but not in the pending enumeration list.\n", pDepth);
        }
    }
    //
    //  Check that the parent is correct
    //
    if(pDevice->m_Parent != ParentNode)
    {
        dprintf("%sCORRUPT TREE: Parent (0x%0.8x) incorrect.\n", pDepth, (ULONG)pDevice->m_Parent);
    }
    //
    //  switch on the device type
    //
    switch(pDevice->m_Type)
    {
        case UDN_TYPE_ROOT_HUB:
            dprintf("%sCORRUPT TREE: ROOT HUB as child.\n", pDepth);
            break;
        case UDN_TYPE_HUB:
            DumpHubNode(pTree, pDevice, pHostController, Depth);
            // Recurse children
            DumpActiveNode(pTree, pDevices, Node, pDevice->m_FirstChild, pHostController, Depth + 1);
            // Recurse siblings
            DumpActiveNode(pTree, pDevices, ParentNode, pDevice->m_Sibling, pHostController, Depth);
            break;            
        case UDN_TYPE_FUNCTION:
            DumpFunctionNode(pTree, pDevice, pHostController, Depth);
            // Recurse siblings
            DumpActiveNode(pTree, pDevices, ParentNode, pDevice->m_Sibling, pHostController, Depth);
            break;
        case UDN_TYPE_INTERFACE_FUNCTION:
            DumpInterfaceFunctionNode(pTree, pDevice, pHostController, Depth);
            // Recurse siblings
            DumpActiveNode(pTree, pDevices, ParentNode, pDevice->m_Sibling, pHostController, Depth);
            break;
        case UDN_TYPE_COMPOSITE_FUNCTION:
            DumpCompositeFunctionNode(pTree, pDevice, pHostController, Depth);
            // Recurse children
            DumpActiveNode(pTree, pDevices, Node, pDevice->m_FirstChild, pHostController, Depth + 1);
            // Recurse siblings
            DumpActiveNode(pTree, pDevices, ParentNode, pDevice->m_Sibling, pHostController, Depth);
            break;
        case UDN_TYPE_INTERFACE:
            DumpInterfaceNode(pTree, pDevice, pHostController, Depth);
            // Recurse siblings
            DumpActiveNode(pTree, pDevices, ParentNode, pDevice->m_Sibling, pHostController, Depth);
            break;
        case UDN_TYPE_UNUSED:
            dprintf("%sCORRUPT TREE: Unused node, found in active node tree.\n", pDepth);
            break;
        case UDN_TYPE_PENDING_ENUM:
            DumpPendingEnumerationNode(pTree, pDevice, pHostController, Depth);
            // Recurse siblings
            DumpActiveNode(pTree, pDevices, ParentNode, pDevice->m_Sibling, pHostController, Depth);
            break;
        case UDN_TYPE_ENUMERATING:
            DumpEnumeratingNode(pTree, pDevice, pHostController, Depth);
            // Recurse siblings
            DumpActiveNode(pTree, pDevices, ParentNode, pDevice->m_Sibling, pHostController, Depth);
            break;
        default:
            dprintf("%sCORRUPT TREE: Illegal Node Type = 0x%0.8x.\n", pDepth, pDevice->m_Type);
            break;
    };
    return;
}

void DumpHubNode(CDeviceTree *pTree, IUsbDevice *pDevice, PUSBD_HOST_CONTROLLER pHostController, int Depth)
{
    CHAR *pDepth = g_DepthString[Depth].DepthString;
    dprintf("%sNode Type: Hub\n", pDepth);
    //
    //  Only print the host controller if it is wrong, since
    //  you can look to the top of the dump.
    if(pHostController != pDevice->m_HostController)
    {
        dprintf("%sCORRUPT TREE: Host Controller invalid (0x%0.8x)\n", pDepth, pDevice->m_HostController);
    }
    dprintf("%sSpeed: %s\n", pDepth,  (pDevice->m_PortNumber&UDN_LOWSPEED_PORT) ? "Lowspeed" : "Fullspeed");
    dprintf("%sPort in parent hub: %d\n", pDepth,  pDevice->m_PortNumber&~UDN_LOWSPEED_PORT);
    dprintf("%sFunction Address: %d\n", pDepth, pDevice->m_Address);
    dprintf("%sDefault Endpoint: 0x%0.8x\n", pDepth, pDevice->m_DefaultEndpoint);
    dprintf("%sMaxPacket0: 0x%0.8x\n", pDepth, pDevice->m_MaxPacket0);
    dprintf("%sPnpClassId: 0x%0.8x\n", pDepth, GetPnpClassId(pDevice).AsLong);
    dprintf("%sHub Extension: 0x%0.8x\n", pDepth, pDevice->m_ClassDriverExtension);
}


void DumpFunctionNode(CDeviceTree *pTree, IUsbDevice *pDevice, PUSBD_HOST_CONTROLLER pHostController, int Depth)
{
    CHAR *pDepth = g_DepthString[Depth].DepthString;
    dprintf("%sNode Type: Function\n", pDepth);
    dprintf("%sPort Bit Position(ala XGetDevices): %d\n", pDepth, pDevice->m_ExternalPort);
    //
    //  Only print the host controller if it is wrong, since
    //  you can look to the top of the dump.
    if(pHostController != pDevice->m_HostController)
    {
        dprintf("%sCORRUPT TREE: Host Controller invalid (0x%0.8x)\n", pDepth, pDevice->m_HostController);
    }
    dprintf("%sSpeed: %s\n", pDepth,  (pDevice->m_PortNumber&UDN_LOWSPEED_PORT) ? "Lowspeed" : "Fullspeed");
    dprintf("%sPort in parent hub: %d\n", pDepth,  pDevice->m_PortNumber&~UDN_LOWSPEED_PORT);
    dprintf("%sFunction Address: %d\n", pDepth, pDevice->m_Address);
    dprintf("%sDefault Endpoint: 0x%0.8x\n", pDepth, pDevice->m_DefaultEndpoint);
    dprintf("%sMaxPacket0: 0x%0.8x\n", pDepth, pDevice->m_MaxPacket0);
    dprintf("%sPnpClassId: 0x%0.8x\n", pDepth, GetPnpClassId(pDevice).AsLong);
    dprintf("%sClass Driver Extension: 0x%0.8x\n", pDepth, pDevice->m_ClassDriverExtension);
    dprintf("%sData Toggle Bits (for closed endpoints): 0x%0.8x\n", pDepth, pDevice->m_DataToggleBits);
}

void DumpInterfaceFunctionNode(CDeviceTree *pTree, IUsbDevice *pDevice, PUSBD_HOST_CONTROLLER pHostController, int Depth)
{
    CHAR *pDepth = g_DepthString[Depth].DepthString;
    dprintf("%sNode Type: Interface Function\n", pDepth);
    dprintf("%sPort Bit Position(ala XGetDevices): %d\n", pDepth, pDevice->m_ExternalPort);
    //
    //  Only print the host controller if it is wrong, since
    //  you can look to the top of the dump.
    if(pHostController != pDevice->m_HostController)
    {
        dprintf("%sCORRUPT TREE: Host Controller invalid (0x%0.8x)\n", pDepth, pDevice->m_HostController);
    }
    dprintf("%sSpeed: %s\n", pDepth,  (pDevice->m_PortNumber&UDN_LOWSPEED_PORT) ? "Lowspeed" : "Fullspeed");
    dprintf("%sPort in parent hub: %d\n", pDepth,  pDevice->m_PortNumber&~UDN_LOWSPEED_PORT);
    dprintf("%sFunction Address: %d\n", pDepth, pDevice->m_Address);
    dprintf("%sInterfaceNumber: %d\n", pDepth, pDevice->m_bInterfaceNumber);
    dprintf("%sDefault Endpoint: 0x%0.8x\n", pDepth, pDevice->m_DefaultEndpoint);
    dprintf("%sMaxPacket0: 0x%0.8x\n", pDepth, pDevice->m_MaxPacket0);
    dprintf("%sPnpClassId: 0x%0.8x\n", pDepth, GetPnpClassId(pDevice).AsLong);
    dprintf("%sClass Driver Extension: 0x%0.8x\n", pDepth, pDevice->m_ClassDriverExtension);
    dprintf("%sData Toggle Bits (for closed endpoints): 0x%0.8x\n", pDepth, pDevice->m_DataToggleBits);
}

void DumpCompositeFunctionNode(CDeviceTree *pTree, IUsbDevice *pDevice, PUSBD_HOST_CONTROLLER pHostController, int Depth)
{
    CHAR *pDepth = g_DepthString[Depth].DepthString;
    dprintf("%sNode Type: Composite Function\n", pDepth);
    //
    //  Only print the host controller if it is wrong, since
    //  you can look to the top of the dump.
    if(pHostController != pDevice->m_HostController)
    {
        dprintf("%sCORRUPT TREE: Host Controller invalid (0x%0.8x)\n", pDepth, pDevice->m_HostController);
    }
    dprintf("%sSpeed: %s\n", pDepth,  (pDevice->m_PortNumber&UDN_LOWSPEED_PORT) ? "Lowspeed" : "Fullspeed");
    dprintf("%sPort in parent hub: %d\n", pDepth,  pDevice->m_PortNumber&~UDN_LOWSPEED_PORT);
    dprintf("%sFunction Address: %d\n", pDepth, pDevice->m_Address);
    dprintf("%sDefault Endpoint: 0x%0.8x\n", pDepth, pDevice->m_DefaultEndpoint);
    dprintf("%sMaxPacket0: 0x%0.8x\n", pDepth, pDevice->m_MaxPacket0);
}

void DumpInterfaceNode(CDeviceTree *pTree, IUsbDevice *pDevice, PUSBD_HOST_CONTROLLER pHostController, int Depth)
{
    CHAR *pDepth = g_DepthString[Depth].DepthString;
    dprintf("%sNode Type: Interface\n", pDepth);
    dprintf("%sPort Bit Position(ala XGetDevices): %d\n", pDepth, pDevice->m_ExternalPort);
    //
    //  Only print the host controller if it is wrong, since
    //  you can look to the top of the dump.
    if(pHostController != pDevice->m_HostController)
    {
        dprintf("%sCORRUPT TREE: Host Controller invalid (0x%0.8x)\n", pDepth, pDevice->m_HostController);
    }
    dprintf("%sSpeed: %s\n", pDepth,  (pDevice->m_PortNumber&UDN_LOWSPEED_PORT) ? "Lowspeed" : "Fullspeed");
    dprintf("%sPort in parent hub: %d\n", pDepth,  pDevice->m_PortNumber&~UDN_LOWSPEED_PORT);
    dprintf("%sFunction Address: %d\n", pDepth, pDevice->m_Address);
    dprintf("%sInterfaceNumber: %d\n", pDepth, pDevice->m_bInterfaceNumber);
    dprintf("%sDefault Endpoint: 0x%0.8x\n", pDepth, pDevice->m_DefaultEndpoint);
    dprintf("%sMaxPacket0: 0x%0.8x\n", pDepth, pDevice->m_MaxPacket0);
    dprintf("%sPnpClassId: 0x%0.8x\n", pDepth, GetPnpClassId(pDevice).AsLong);
    dprintf("%sClass Driver Extension: 0x%0.8x\n", pDepth, pDevice->m_ClassDriverExtension);
    dprintf("%sData Toggle Bits (for closed endpoints): 0x%0.8x\n", pDepth, pDevice->m_DataToggleBits);
}

void DumpEnumeratingNode(CDeviceTree *pTree, IUsbDevice *pDevice, PUSBD_HOST_CONTROLLER pHostController, int Depth)
{
    CHAR *pDepth = g_DepthString[Depth].DepthString;
    dprintf("%sNode Type: Enumerating - not known yet\n", pDepth);
    dprintf("%sMore information on node was presented at top.\n", pDepth);
    //
    //  Only print the host controller if it is wrong, since
    //  you can look to the top of the dump.
    if(pHostController != pDevice->m_HostController)
    {
        dprintf("%sCORRUPT TREE: Host Controller invalid (0x%0.8x)\n", pDepth, pDevice->m_HostController);
    }
    dprintf("%sSpeed: %s\n", pDepth,  (pDevice->m_PortNumber&UDN_LOWSPEED_PORT) ? "Lowspeed" : "Fullspeed");
    dprintf("%sPort in parent hub: %d\n", pDepth,  pDevice->m_PortNumber&~UDN_LOWSPEED_PORT);
    dprintf("%sFunction Address: %d\n", pDepth, pDevice->m_Address);
    dprintf("%sDefault Endpoint: 0x%0.8x\n", pDepth, pDevice->m_DefaultEndpoint);
    dprintf("%sMaxPacket0: 0x%0.8x\n", pDepth, pDevice->m_MaxPacket0);
}

void DumpPendingEnumerationNode(CDeviceTree *pTree, IUsbDevice *pDevice, PUSBD_HOST_CONTROLLER pHostController, int Depth)
{
    CHAR *pDepth = g_DepthString[Depth].DepthString;
    dprintf("%sNode Type: Pending Enumeration\n", pDepth);
    //
    //  Only print the host controller if it is wrong, since
    //  you can look to the top of the dump.
    if(pHostController != pDevice->m_HostController)
    {
        dprintf("%sCORRUPT TREE: Host Controller invalid (0x%0.8x)\n", pDepth, pDevice->m_HostController);
    }
    dprintf("%sSpeed: %s\n", pDepth,  (pDevice->m_PortNumber&UDN_LOWSPEED_PORT) ? "Lowspeed" : "Fullspeed");
    dprintf("%sPort in parent hub: %d\n", pDepth,  pDevice->m_PortNumber&~UDN_LOWSPEED_PORT);
    dprintf("%sRemaining Retries: %d\n", pDepth, pDevice->m_RetryCount);
    dprintf("%sNextPendingEnum: 0x%0.8x\n", pDepth, pDevice->m_NextPending);
}
//
//  Nodes pending remove are not of type UDN_TYPE_UNUSED or UDN_TYPE_ROOT_HUB, and
//  never have a parent.  They should not appear in any other
//  list.  It may have children iff it is a composite device, or
//  a hub.
//
void DumpPendingRemoved(CDeviceTree *pTree, IUsbDevice *pDevices)
{
    dprintf("--Pending Removal----------------------------------\n");
    UCHAR Node;
    for(Node = 0; Node < pTree->m_NodeCount; Node++)
    {
        IUsbDevice *pDevice = pDevices + Node;
        if(
            (pDevice->m_Type != UDN_TYPE_ROOT_HUB) && 
            (pDevice->m_Type != UDN_TYPE_UNUSED) &&
            (pDevice->m_Parent == UDN_INVALID_NODE_INDEX)
        )
        {
            //reuse dump active node
            DumpActiveNode(pTree, pDevices, UDN_INVALID_NODE_INDEX, Node, pDevice->m_HostController, 0);
        }
    }
}
void DumpFreeNodes(CDeviceTree *pTree, IUsbDevice *pDevices)
{
    dprintf("--Free Nodes---------------------------------------\n");
    if(UDN_INVALID_NODE_INDEX == pTree->m_FirstFree) return;
    ULONG FreeNodeCount = 0;
    UCHAR FreeNode =  pTree->m_FirstFree;
    IUsbDevice *pFreeDevice = pDevices + FreeNode;
    
    while(pFreeDevice)
    {
       FreeNodeCount++;
       dprintf("Node: %d(0x%0.8x)\n", FreeNode, pTree->m_Devices + FreeNode);
       if(CheckMarkAccessed(FreeNode, g_FreeNodes, FALSE))
       {
         dprintf("CORRUPT TREE: Circular Free Node List\n");
         dprintf("CORRUPT TREE: Free Nodes in circular list: %d\n", FreeNodeCount-1);
         return;
       }
       //
       //   Make sure nodes is not in use.
       //
       if(CheckMarkAccessed(FreeNode, g_ActiveNodes, TRUE))
       {
          dprintf("CORRUPT TREE: Active Node is in free list\n");
       }
       //
       //   Make sure it is marked unused.
       //
       if(pFreeDevice->m_Type != UDN_TYPE_UNUSED)
       {
           dprintf("CORRUPT TREE: Node n free list is not marked unused.\n");
       }
       //iterate to next free node.
       if(UDN_INVALID_NODE_INDEX != pFreeDevice->m_NextFree)
       {
            FreeNode = pFreeDevice->m_NextFree;
            pFreeDevice = pDevices + FreeNode;
       } else
       {
            pFreeDevice = NULL;
       }
    }
    dprintf("Total Free Nodes: %d\n", FreeNodeCount);
}

PNP_CLASS_ID GetPnpClassId(IUsbDevice *pDevice)
{
    USB_CLASS_DRIVER_DESCRIPTION ClassDriverDescription;
    ReadMemory((ULONG)pDevice->m_ClassDriver, (PVOID)&ClassDriverDescription, sizeof(ClassDriverDescription), NULL);
    PNP_CLASS_ID PnPClassID;
    PnPClassID.AsLong = ClassDriverDescription.ClassId.AsLong;
    PnPClassID.USB.bClassSpecificType = pDevice->m_ClassSpecificType;
    return PnPClassID;
}


CHAR *EnumStageString(UCHAR Stage)
{
    switch(Stage)
    {
    case USBD_ENUM_DEVICE_CONNECTED: return "Connected - Waiting for power up";
    case USBD_ENUM_STAGE_0: return "0 - Reseting Port";
    case USBD_ENUM_STAGE_PRE1: return "Pre1 - Waiting 10 ms after reset";
    case USBD_ENUM_STAGE_1: return "1 - Getting Device Descriptor";
    case USBD_ENUM_STAGE_2: return "2 - Setting Address";
    case USBD_ENUM_STAGE_3: return "3 - Closing Default Endpoint";
    case USBD_ENUM_STAGE_PRE4: return "Pre4 - 2 ms after Set Address";
    case USBD_ENUM_STAGE_4: return "4 - Get Config Descriptor, or load function driver";
    case USBD_ENUM_STAGE_5: return "5 - Set Config";
    case USBD_ENUM_STAGE_6: return "6 - Load interface driver";
    case USBD_ENUM_STAGE_ADD_COMPLETE: return "Class Driver Enum Complete";
    case USBD_ENUM_STAGE_ABORT1: return "Abort Enumeration 1";
    case USBD_ENUM_STAGE_DISABLE_COMPLETE: return "Complete Disabling Aborted Device";
    case USBD_ENUM_STAGE_ABORT2: return "Abort Enumeration 2";
    }
    return "Invalid Stage";
}


BOOL CheckMarkAccessed(UCHAR Node, PULONG Bitfield, BOOL fCheckOnly)
{
    BOOL fPreviousAccess = FALSE;
    ULONG ulIndex = 0;
    while(Node >= 32)
    {
        ulIndex++;
        Node -= 32;
    }
    ULONG ulMask = (1 << Node);
    if(Bitfield[ulIndex]&ulMask) fPreviousAccess = TRUE;
    if(!fCheckOnly) Bitfield[ulIndex] |= ulMask;
    return fPreviousAccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\kdexts\p_i386\dumpstru.c ===
/*** dumpstru.c - Dump Structure services
 *
 *  This module contains format services for converting binary data into format
 *  text strings according to the format record.
 *
 *  Copyright (c) 1995,1996 Microsoft Corporation
 *  Author:     Michael Tsang (MikeTs)
 *  Created     11/06/95
 *
 *  MODIFICATION HISTORY
 */

#include "precomp.h"

char cszNull[] = "";
char cszDecFmt[] = SZ_FMT_DEC;
char cszHexFmt[] = SZ_FMT_HEX;
char cszByteFmt[] = SZ_FMT_HEX_BYTE;
char cszWordFmt[] = SZ_FMT_HEX_WORD;
char cszDWordFmt[] = SZ_FMT_HEX_DWORD;
char cszLabelReserved[] = "Reserved=";
char cszReserved[] = "Reserved";
char cszUndefined[] = "Undefined";
char cszLabelFmt[] = "%04x:%s";

FMTNUM fmtHexByteNoEOL =
{
    {FMT_NUMBER, UNIT_BYTE, 1, FMTF_NO_PRINT_DATA | FMTF_NO_EOL, 1, NULL, NULL,
     NULL},
    0xff, 0, cszByteFmt
};

FMTNUM fmtHexByte =
{
    {FMT_NUMBER, UNIT_BYTE, 1, FMTF_NO_PRINT_DATA, 1, NULL, NULL, NULL},
    0xff, 0, cszByteFmt
};

FMTNUM fmtHexWord =
{
    {FMT_NUMBER, UNIT_WORD, 1, FMTF_NO_PRINT_DATA, 1, NULL, NULL, NULL},
    0xffff, 0, cszWordFmt
};

FMTNUM fmtHexDWord =
{
    {FMT_NUMBER, UNIT_DWORD, 1, FMTF_NO_PRINT_DATA, 1, NULL, NULL, NULL},
    0xffffffff, 0, cszDWordFmt
};

FMTNUM fmt2HexDWord =
{
    {FMT_NUMBER, UNIT_DWORD, 2, FMTF_NO_PRINT_DATA, 1, NULL, NULL, NULL},
    0xffffffff, 0, cszDWordFmt
};

FMTNUM fmt4HexDWord =
{
    {FMT_NUMBER, UNIT_DWORD, 4, FMTF_NO_PRINT_DATA, 1, NULL, NULL, NULL},
    0xffffffff, 0, cszDWordFmt
};

FMTNUM fmt6HexDWord =
{
    {FMT_NUMBER, UNIT_DWORD, 6, FMTF_NO_PRINT_DATA, 1, NULL, NULL, NULL},
    0xffffffff, 0, cszDWordFmt
};

FMTNUM fmt8HexDWord =
{
    {FMT_NUMBER, UNIT_DWORD, 8, FMTF_NO_PRINT_DATA, 1, NULL, NULL, NULL},
    0xffffffff, 0, cszDWordFmt
};

FMTNUM fmtDecNum =
{
    {FMT_NUMBER, UNIT_BYTE, 1, FMTF_NO_PRINT_DATA, 1, NULL, NULL, NULL},
    0xff, 0, cszDecFmt
};

typedef int (*PFNFMT)(char *, PFMTHDR, BYTE *, DWORD *);

//Local function prototypes
int FormatNum(PSZ pszBuffer, PFMTHDR pfmt, PBYTE pb, PDWORD pdwOffset);
int FormatEnum(PSZ pszBuffer, PFMTHDR pfmt, PBYTE pb, PDWORD pdwOffset);
int FormatBits(PSZ pszBuffer, PFMTHDR pfmt, PBYTE pb, PDWORD pdwOffset);
int FormatString(PSZ pszBuffer, PFMTHDR pfmt, PBYTE pb, PDWORD pdwOffset);
int GetData(BYTE bUnitSize, PBYTE pb, DWORD dwOffset, PDWORD pdwData);
int PrintData(PSZ pszBuffer, BYTE bUnitSize, DWORD dwData, BOOL fPadSpace);

char szDefSep[] = SZ_SEP_SPACE;
char szDefOffsetFmt[] = SZ_FMT_WORDOFFSET;
PFNFMT FmtFuncTable[] =
{
    FormatNum,          //0: FMT_NUMBER
    FormatEnum,         //1: FMT_ENUM
    FormatBits,         //2: FMT_BITS
    FormatString,       //3: FMT_STRING
};
#define NUM_FMT_FUNCS   (sizeof(FmtFuncTable)/sizeof(PFNFMT))

#ifdef _PRINTF
/***EP  BinPrintf - Binary printf
 *
 *  ENTRY
 *      pszBuffer -> buffer to hold the formatted string
 *                   (if NULL, use internal buffer)
 *      pfmt -> format record array
 *      pb -> binary data buffer
 *      pdwOffset -> offset to binary data buffer (if NULL, use internal)
 *      pszOffsetFormat -> offset format string (can be NULL)
 *
 *  EXIT-SUCCESS
 *      returns FERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int BinPrintf(PSZ pszBuffer, PFMT pfmt, PBYTE pb, PDWORD pdwOffset,
              PSZ pszOffsetFormat)
{
    TRACENAME("BINPRINTF")
    int rc = FERR_NONE;
    DWORD dwOffset = 0, dwOldOffset;
    DWORD dwData;
    char szBuff[256];
    char *psz = pszBuffer? pszBuffer: szBuff;
    DWORD *pdw = pdwOffset? pdwOffset: &dwOffset;

    ENTER(4, ("BinPrintf(pszBuff=%lx,pfmt=%lx,pdwOffset=%lx,Offset=%lx)\n",
              pszBuffer, pfmt, pdwOffset, pdwOffset? *pdwOffset: 0));

    if (pfmt != NULL)
    {
        BYTE i, j;

        for (i = 0; pfmt[i].pfmtType != NULL; ++i)
        {
            if (pfmt[i].pszLabel != NULL)
            {
                if (pszOffsetFormat != NULL)
                {
                    _PRINTF(pszOffsetFormat, *pdw);
                    if (GetData(pfmt[i].pfmtType->bUnitSize, pb, *pdw, &dwData)
                        == FERR_NONE)
                    {
                        PrintData(psz, pfmt[i].pfmtType->bUnitSize, dwData,
                                  TRUE);
                        _PRINTF(psz);
                    }

                    for (j = 1; j < pfmt[i].pfmtType->bUnitCnt; ++j)
                    {
                        if (GetData(pfmt[i].pfmtType->bUnitSize, pb,
                                    *pdw + j*pfmt[i].pfmtType->bUnitSize,
                                    &dwData) == FERR_NONE)
                        {
                            _PRINTF(",");
                            PrintData(psz, pfmt[i].pfmtType->bUnitSize, dwData,
                                      FALSE);
                            _PRINTF(psz);
                        }
                    }
                }

                if (pfmt[i].pszLabel[0] != '\0')
                {
                    _PRINTF(";%s", pfmt[i].pszLabel);
                }
                else
                {
                    _PRINTF("\n");
                }
            }

            dwOldOffset = *pdw;
            if ((pfmt[i].pszLabel != NULL) && (pfmt[i].pszLabel[0] == '\0'))
            {
                *pdw += pfmt[i].pfmtType->bUnitCnt*pfmt[i].pfmtType->bUnitSize;
            }
            else
            {
                if (pfmt[i].pszLabel == NULL)
                {
                    _PRINTF(",");
                }

                if ((rc = BinSprintf(psz, pfmt[i].pfmtType, pb, pdw)) ==
                    FERR_NONE)
                {
                    PSZ psz1, psz2;
                    BOOL fSpace = FALSE;
                    //
                    // Compress multiple spaces into a single comma.
                    //
                    for (psz1 = psz2 = psz; *psz2 != '\0'; ++psz2)
                    {
                        if (*psz2 == ' ')
                        {
                            if (!fSpace && (psz1 != psz))
                            {
                                *psz1 = ',';
                                psz1++;
                            }
                            fSpace = TRUE;
                        }
                        else
                        {
                            fSpace = FALSE;
                            *psz1 = *psz2;
                            psz1++;
                        }
                    }

                    if ((psz1 > psz) && (*(psz1 - 1) == ','))
                    {
                        *(psz1 - 1) = '\0';
                    }
                    else if ((psz1 > psz) && (*(psz1 - 1) == '\n') &&
                             (*(psz1 - 2) == ','))
                    {
                        *(psz1 - 2) = '\n';
                        *(psz1 - 1) = '\0';
                    }
                    else
                    {
                        *psz1 = '\0';
                    }

                    _PRINTF(psz);
                }

            }

            if (pfmt[i].lpfn != NULL)
            {
                pfmt[i].lpfn(pb, dwOldOffset);
            }
        }
    }

    EXIT(4, ("BinPrintf=%d (Offset=%lx,Buff=%s)\n", rc, *pdwOffset, pszBuffer));
    return rc;
}       //BinPrintf
#endif  //ifdef _PRINTF

/***EP  BinSprintf - Binary sprintf
 *
 *  ENTRY
 *      pszBuffer -> buffer to hold the formatted string
 *      pfmt -> format record
 *      pb -> binary data buffer
 *      pdwOffset -> offset to binary data buffer
 *
 *  EXIT-SUCCESS
 *      returns FERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int BinSprintf(PSZ pszBuffer, PFMTHDR pfmt, PBYTE pb, PDWORD pdwOffset)
{
    TRACENAME("BINSPRINTF")
    int rc = FERR_NONE;

    ENTER(4, ("BinSprintf(fmt=%d,Offset=%lx)\n", pfmt->bFmtType, *pdwOffset));

    if (pfmt->bFmtType >= NUM_FMT_FUNCS)
        rc = FERR_INVALID_FORMAT;
    else
    {
        int i;
        BYTE j;
        DWORD dwData;

        *pszBuffer = '\0';
        for (i = 0; (rc == FERR_NONE) && (i < pfmt->iRepeatCnt); ++i)
        {
            if (pfmt->dwfFormat & FMTF_PRINT_OFFSET)
            {
                _SPRINTF(pszBuffer,
                         pfmt->pszOffsetFmt? pfmt->pszOffsetFmt: szDefOffsetFmt,
                         *pdwOffset);
            }

            if (!(pfmt->dwfFormat & FMTF_NO_PRINT_DATA) &&
                (GetData(pfmt->bUnitSize, pb, *pdwOffset, &dwData) ==
                 FERR_NONE))
            {
                PrintData(pszBuffer, pfmt->bUnitSize, dwData, FALSE);
                _STRCAT(pszBuffer, ";");
            }

            if (pfmt->pszLabel)
                _STRCAT(pszBuffer, pfmt->pszLabel);

            for (j = 0; (rc == FERR_NONE) && (j < pfmt->bUnitCnt); ++j)
            {
                rc = FmtFuncTable[pfmt->bFmtType]
                        (&pszBuffer[_STRLEN(pszBuffer)], pfmt, pb, pdwOffset);

                if (rc == FERR_NONE)
                {
                    if (!(pfmt->dwfFormat & FMTF_NO_SEP))
                    {
                        _STRCAT(pszBuffer,
                                pfmt->pszFieldSep? pfmt->pszFieldSep: szDefSep);
                    }

                    if (!(pfmt->dwfFormat & FMTF_NO_INC_OFFSET))
                        *pdwOffset += pfmt->bUnitSize;
                }
            }

            if ((rc == FERR_NONE) && !(pfmt->dwfFormat & FMTF_NO_EOL))
            {
                _STRCAT(pszBuffer, "\n");
            }
        }
    }

    EXIT(4, ("BinSprintf=%d (Offset=%lx,Buff=%s)\n",
             rc, *pdwOffset, pszBuffer));
    return rc;
}       //BinSprintf

/***LP  FormatNum - Format numbers
 *
 *  ENTRY
 *      pszBuffer -> buffer to hold formatted string
 *      pfmt -> format record
 *      pb -> binary data buffer
 *      pdwOffset -> offset to binary data buffer
 *
 *  EXIT-SUCCESS
 *      returns FERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int FormatNum(PSZ pszBuffer, PFMTHDR pfmt, PBYTE pb, PDWORD pdwOffset)
{
    TRACENAME("FORMATNUM")
    int rc;
    PFMTNUM pfmtNum = (PFMTNUM)pfmt;
    DWORD dwData;

    ENTER(5, ("FormatNum(Offset=%lx)\n", *pdwOffset));

    if ((rc = GetData(pfmt->bUnitSize, pb, *pdwOffset, &dwData)) == FERR_NONE)
    {
        dwData &= pfmtNum->dwMask;
        dwData >>= pfmtNum->bShiftCnt;

        _SPRINTF(&pszBuffer[_STRLEN(pszBuffer)], pfmtNum->pszNumFmt, dwData);
    }

    EXIT(5, ("FormatNum=%d (Offset=%lx,Buff=%s)\n",
         rc, *pdwOffset, pszBuffer));
    return rc;
}       //FormatNum

/***LP  FormatEnum - Format enumerated values
 *
 *  ENTRY
 *      pszBuffer -> buffer to hold formatted string
 *      pfmt -> format record
 *      pb -> binary data buffer
 *      pdwOffset -> offset to binary data buffer
 *
 *  EXIT-SUCCESS
 *      returns FERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int FormatEnum(PSZ pszBuffer, PFMTHDR pfmt, PBYTE pb, PDWORD pdwOffset)
{
    TRACENAME("FORMATENUM")
    int rc = FERR_NONE;
    PFMTENUM pfmtEnum = (PFMTENUM)pfmt;
    DWORD dwData;

    ENTER(5, ("FormatEnum(Offset=%lx)\n", *pdwOffset));

    if ((rc = GetData(pfmt->bUnitSize, pb, *pdwOffset, &dwData)) == FERR_NONE)
    {
        dwData &= pfmtEnum->dwMask;
        dwData >>= pfmtEnum->bShiftCnt;

        if ((dwData < pfmtEnum->dwStartEnum) || (dwData > pfmtEnum->dwEndEnum))
            _STRCAT(pszBuffer, pfmtEnum->pszOutOfRange);
        else
        {
            dwData -= pfmtEnum->dwStartEnum;
            _STRCAT(pszBuffer, pfmtEnum->ppszEnumNames[dwData]);
        }
    }

    EXIT(5, ("FormatEnum=%d (Offset=%lx,Buff=%s)\n",
             rc, *pdwOffset, pszBuffer));
    return rc;
}       //FormatEnum

/***LP  FormatBits - Format bit values
 *
 *  ENTRY
 *      pszBuffer -> buffer to hold formatted string
 *      pfmt -> format record
 *      pb -> binary data buffer
 *      pdwOffset -> offset to binary data buffer
 *
 *  EXIT-SUCCESS
 *      returns FERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int FormatBits(PSZ pszBuffer, PFMTHDR pfmt, PBYTE pb, PDWORD pdwOffset)
{
    TRACENAME("FORMATBITS")
    int rc = FERR_NONE;
    PFMTBITS pfmtBits = (PFMTBITS)pfmt;
    DWORD dwData;

    ENTER(5, ("FormatBits(Offset=%lx)\n", *pdwOffset));

    if ((rc = GetData(pfmt->bUnitSize, pb, *pdwOffset, &dwData)) == FERR_NONE)
    {
        int i, j;
        DWORD dw;

        for (i = 31, j = 0; i >= 0; --i)
        {
            dw = 1L << i;
            if (pfmtBits->dwMask & dw)
            {
                if (dwData & dw)
                {
                    if ((pfmtBits->ppszOnNames != NULL) &&
                        (pfmtBits->ppszOnNames[j] != NULL))
                    {
                        _STRCAT(pszBuffer, pfmtBits->ppszOnNames[j]);
                    }
                }
                else
                {
                    if ((pfmtBits->ppszOffNames != NULL) &&
                        (pfmtBits->ppszOffNames[j] != NULL))
                    {
                        _STRCAT(pszBuffer, pfmtBits->ppszOffNames[j]);
                    }
                }

                if (!(pfmt->dwfFormat & FMTF_NO_SEP))
                {
                    _STRCAT(pszBuffer,
                            pfmt->pszFieldSep? pfmt->pszFieldSep: szDefSep);
                }

                j++;
            }
        }
    }

    EXIT(5, ("FormatBits=%d (Offset=%lx,Buff=%s)\n",
             rc, *pdwOffset, pszBuffer));
    return rc;
}       //FormatBits

/***LP  FormatString - Format string data
 *
 *  ENTRY
 *      pszBuffer -> buffer to hold formatted string
 *      pfmt -> format record
 *      pb -> binary data buffer
 *      pdwOffset -> offset to binary data buffer
 *
 *  EXIT-SUCCESS
 *      returns FERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int FormatString(PSZ pszBuffer, PFMTHDR pfmt, PBYTE pb, PDWORD pdwOffset)
{
    TRACENAME("FORMATSTRING")
    int rc = FERR_NONE;

    ENTER(5, ("FormatString(Offset=%lx)\n", *pdwOffset));

    pb += *pdwOffset;
    if (pfmt->dwfFormat & FMTF_STR_ASCIIZ)
    {
        _STRCPY(pszBuffer, (char *)pb);
        if ((pfmt->bUnitSize == 0) && !(pfmt->dwfFormat & FMTF_NO_INC_OFFSET))
            *pdwOffset += _STRLEN((char *)pb) + 1;
    }
    else if (pfmt->bUnitSize != 0)
    {
        _STRCPYN(pszBuffer, (char *)pb, pfmt->bUnitSize);
        pszBuffer[pfmt->bUnitSize] = '\0';
    }

    EXIT(5, ("FormatString=%d (Offset=%lx,Buff=%s)\n",
             rc, *pdwOffset, pszBuffer));
    return rc;
}       //FormatString

/***LP  GetData - Get data of appropriate size from the binary buffer
 *
 *  ENTRY
 *      bUnitSize - size of data unit
 *      pb -> data buffer
 *      dwOffset - offset into data buffer
 *      pdwData -> to hold data
 *
 *  EXIT-SUCCESS
 *      returns FERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int GetData(BYTE bUnitSize, PBYTE pb, DWORD dwOffset, PDWORD pdwData)
{
    TRACENAME("GETDATA")
    int rc = FERR_NONE;

    ENTER(6, ("GetData(UnitSize=%d,Data=%lx,Offset=%lx)\n",
              bUnitSize, *(DWORD *)pb, dwOffset));

    pb += dwOffset;
    switch (bUnitSize)
    {
        case UNIT_BYTE:
            *pdwData = (DWORD)(*pb);
            break;
        case UNIT_WORD:
            *pdwData = (DWORD)(*((WORD *)pb));
            break;
        case UNIT_DWORD:
            *pdwData = *(DWORD *)pb;
            break;
        default:
            rc = FERR_INVALID_UNITSIZE;

    }

    EXIT(6, ("GetData=%d (Data=%lx)\n", rc, *pdwData));
    return rc;
}       //GetData

/***LP  PrintData - Print data value according to its size
 *
 *  ENTRY
 *      pszBuffer -> buffer to hold formatted string
 *      bUnitSize - size of data unit
 *      dwData - number
 *      fPadSpace - if TRUE, pad space to 8 chars
 *
 *  EXIT-SUCCESS
 *      returns FERR_NONE
 *  EXIT-FAILURE
 *      returns negative error code
 */

int PrintData(PSZ pszBuffer, BYTE bUnitSize, DWORD dwData, BOOL fPadSpace)
{
    TRACENAME("PRINTDATA")
    int rc = FERR_NONE;

    ENTER(6, ("PrintData(UnitSize=%d,Data=%lx,fPadSpace=%x)\n",
              bUnitSize, dwData, fPadSpace));

    switch (bUnitSize)
    {
        case UNIT_BYTE:
            _SPRINTF(pszBuffer, "%02x", (BYTE)dwData);
            if (fPadSpace)
            {
                _STRCAT(pszBuffer, "      ");
            }
            break;
        case UNIT_WORD:
            _SPRINTF(pszBuffer, "%04x", (WORD)dwData);
            if (fPadSpace)
            {
                _STRCAT(pszBuffer, "    ");
            }
            break;
        case UNIT_DWORD:
            _SPRINTF(pszBuffer, "%08x", dwData);
            break;
        default:
            rc = FERR_INVALID_UNITSIZE;

    }

    EXIT(6, ("PrintData=%d (Buff=%s)\n", rc, pszBuffer));
    return rc;
}       //PrintData
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\kdexts\p_i386\cxr.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    cxr.c

Abstract:

    WinDbg Extension Api

Author:

    Ramon J San Andres (ramonsa) 8-Nov-1993

Environment:

    User Mode.

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop


DECLARE_API( cxr )

/*++

Routine Description:

    Dumps an exception record

Arguments:

    args - Supplies the address in hex.

Return Value:

    None

--*/

{
    ULONG       Address;
    ULONG       result;
    CONTEXT     Cxr;

    sscanf(args,"%lX",&Address);

    if ( !ReadMemory(
                (DWORD)Address,
                (PVOID)&Cxr,
                sizeof(CONTEXT),
                &result
                ) ) {
        dprintf("Unable to get context record\n");
        return;
    }

    dprintf("\n");
    DumpCxr(&Cxr);

}

VOID
DumpCxr(
    PCONTEXT Cxr
    )
{
    KTRAP_FRAME TrapFrame;
    dprintf("CtxFlags: %08lx\n", Cxr->ContextFlags);

    TrapFrame.Eip    = Cxr->Eip;
    TrapFrame.EFlags = Cxr->EFlags;
    TrapFrame.Eax    = Cxr->Eax;
    TrapFrame.Ecx    = Cxr->Ecx;
    TrapFrame.Edx    = Cxr->Edx;
    TrapFrame.Ebx    = Cxr->Ebx;
    TrapFrame.Ebp    = Cxr->Ebp;
    TrapFrame.Esi    = Cxr->Esi;
    TrapFrame.Edi    = Cxr->Edi;
    TrapFrame.SegCs  = Cxr->SegCs;
    TrapFrame.HardwareEsp = Cxr->Esp;
    TrapFrame.HardwareSegSs = Cxr->SegSs;

    DisplayTrapFrame (&TrapFrame, 0);
    return;
}

VOID
GetStackTraceRegs(
    ULONG   Processor,
    PULONG  ProgramCounter,
    PULONG  FramePointer,
    PULONG  StackPointer
    )
{
    X86_NT5_CONTEXT     Context;

    GetContext( Processor, (PCONTEXT)&Context, sizeof(X86_NT5_CONTEXT) );
    *ProgramCounter = Context.Eip;
    *FramePointer   = Context.Ebp;
    *StackPointer   = Context.Esp;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\kdexts\p_i386\apic.h ===
/*
;++
;
;   Module Name:
;
;       apic.h
;
;   Abstract:
;
;       include file for apic.c.
;
;
;   Author:
;
;
;--
;
*/


//
// The next structures are defined so that ntapic.h is 
// satisfied.  They are dummied up here so that halacpi
// can share code with halmps more easily.
//

typedef PVOID PPCMPPROCESSOR;
typedef PVOID PPCMPBUS;
typedef PVOID PPCMPIOAPIC;
typedef PVOID PPCMPINTI;
typedef PVOID PPCMPLINTI;
typedef PVOID PMPS_EXTENTRY;
typedef PVOID ADDRESS_USAGE;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\kdexts\p_i386\dumpstru.h ===
/*** dumpstru.h - Dump Structure services definitions
 *
 *  Copyright (c) 1995,1996 Microsoft Corporation
 *  Author:     Michael Tsang (MikeTs)
 *  Created     11/06/95
 *
 *  MODIFICATION HISTORY
 */

#ifndef _DUMPSTRU_H
#define _DUMPSTRU_H

#ifndef ENTER
  #define ENTER(n,p)
#endif

#ifndef EXIT
  #define EXIT(n,p)
#endif

#ifndef TRACENAME
  #define TRACENAME(s)
#endif

#ifdef USE_CRUNTIME
    #define _PRINTF             dprintf
    #define _SPRINTF            sprintf
    #define _STRCPY             strcpy
    #define _STRCPYN            strncpy
    #define _STRCAT             strcat
    #define _STRLEN             strlen
#else
  #ifdef WINAPP
    #define _SPRINTF            wsprintf
    #define _STRCPY             lstrcpy
    #define _STRCPYN            lstrcpyn
    #define _STRCAT             lstrcat
    #define _STRLEN             lstrlen
  #else         //assume VxD
    #define _SPRINTF            _Sprintf
    #define _STRCPY(s1,s2)      _lstrcpyn(s1,s2,(DWORD)(-1))
    #define _STRCPYN(s1,s2,n)   _lstrcpyn(s1,s2,(n)+1)
    #define _STRCAT(s1,s2)      _lstrcpyn((s1)+_lstrlen(s1),s2,(DWORD)(-1))
    #define _STRLEN             _lstrlen
  #endif
#endif

//Error codes
#define FERR_NONE               0
#define FERR_INVALID_FORMAT     -1
#define FERR_INVALID_UNITSIZE   -2

//String constants
#define SZ_SEP_SPACE            " "
#define SZ_SEP_TAB              "\t"
#define SZ_SEP_COMMA            ","
#define SZ_SEP_SEMICOLON        ";"
#define SZ_SEP_COLON            ":"
#define SZ_FMT_DEC              "%d"
#define SZ_FMT_HEX              "%x"
#define SZ_FMT_HEX_BYTE         "%02x"
#define SZ_FMT_HEX_WORD         "%04x"
#define SZ_FMT_HEX_DWORD        "%08lx"
#define SZ_FMT_WORDOFFSET       SZ_FMT_HEX_WORD SZ_SEP_COLON
#define SZ_FMT_DWORDOFFSET      SZ_FMT_HEX_DWORD SZ_SEP_COLON

//bFmtType values
#define FMT_NUMBER              0
#define FMT_ENUM                1
#define FMT_BITS                2
#define FMT_STRING              3

//bUnitSize values
#define UNIT_BYTE               sizeof(BYTE)
#define UNIT_WORD               sizeof(WORD)
#define UNIT_DWORD              sizeof(DWORD)

//dwfFormat flags
#define FMTF_NO_EOL             0x80000000
#define FMTF_NO_INC_OFFSET      0x40000000
#define FMTF_NO_SEP             0x20000000
#define FMTF_NO_PRINT_DATA      0x10000000
#define FMTF_PRINT_OFFSET       0x08000000
#define FMTF_STR_ASCIIZ         0x00000001
#define FMTF_FIRST_FIELD        (FMTF_NO_EOL | FMTF_NO_INC_OFFSET | \
                                 FMTF_NO_PRINT_DATA)
#define FMTF_MIDDLE_FIELD       (FMTF_NO_EOL | FMTF_NO_INC_OFFSET | \
                                 FMTF_NO_PRINT_DATA)
#define FMTF_LAST_FIELD         FMTF_NO_PRINT_DATA

typedef VOID (*LPFN)(PBYTE, DWORD);

typedef struct fmthdr_s
{
    BYTE bFmtType;              //Format type: see FMT_*
    BYTE bUnitSize;             //Data unit size: see UNIT_*
    BYTE bUnitCnt;              //Data unit count for a format record
    DWORD dwfFormat;            //Format flags: see FMTF_*
    int iRepeatCnt;             //Repeat count for this format record
    PSZ pszOffsetFmt;           //Offset format
    PSZ pszFieldSep;            //Field separator between bUnitCnt of data
    PSZ pszLabel;               //LHS label
} FMTHDR;
typedef FMTHDR *PFMTHDR;

typedef struct fmt_s
{
    PSZ pszLabel;
    PFMTHDR pfmtType;
    LPFN lpfn;
} FMT;
typedef FMT *PFMT;

typedef struct fmtnum_s
{
    FMTHDR hdr;
    DWORD dwMask;
    BYTE bShiftCnt;
    PSZ pszNumFmt;
} FMTNUM;
typedef FMTNUM *PFMTNUM;

typedef struct fmtenum_s
{
    FMTHDR hdr;
    DWORD dwMask;
    BYTE bShiftCnt;
    DWORD dwStartEnum;
    DWORD dwEndEnum;
    PSZ *ppszEnumNames;
    PSZ pszOutOfRange;
} FMTENUM;
typedef FMTENUM *PFMTENUM;

typedef struct fmtbits_s
{
    FMTHDR hdr;
    DWORD dwMask;
    PSZ *ppszOnNames;
    PSZ *ppszOffNames;
} FMTBITS;
typedef FMTBITS *PFMTBITS;

typedef struct fmtstr_s
{
    FMTHDR hdr;
} FMTSTR;
typedef FMTSTR *PFMTSTR;

/*** Exported data
 */

extern FMTNUM fmtHexByteNoEOL, fmtHexByte, fmtHexWord, fmtHexDWord,
              fmt2HexDWord, fmt4HexDWord, fmt6HexDWord, fmt8HexDWord, fmtDecNum;
extern char cszDecFmt[], cszHexFmt[], cszByteFmt[], cszWordFmt[], cszDWordFmt[];
extern char cszLabelReserved[], cszReserved[], cszUndefined[], cszLabelFmt[],
            cszNull[];

/*** Exported API Prototypes
 */

#ifdef _PRINTF
int BinPrintf(PSZ pszBuffer, PFMT pfmt, PBYTE pb, PDWORD pdwOffset,
              PSZ pszOffsetFormat);
#endif
int BinSprintf(PSZ pszBuffer, PFMTHDR pfmt, PBYTE pb, PDWORD pdwOffset);

#endif	//ifndef _DUMPSTRU_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\kdexts\p_i386\mtrr.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    mtrr.c

Abstract:

    WinDbg Extension Api

Author:

    Ken Reneris (kenr) 06-June-1994

Environment:

    User Mode.

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

//
// MTRR MSR architecture definitions
//

#define MTRR_MSR_CAPABILITIES       0x0fe
#define MTRR_MSR_DEFAULT            0x2ff
#define MTRR_MSR_VARIABLE_BASE      0x200
#define MTRR_MSR_VARIABLE_MASK     (MTRR_MSR_VARIABLE_BASE+1)

#define MTRR_PAGE_SIZE              4096
#define MTRR_PAGE_MASK              (MTRR_PAGE_SIZE-1)

//
// Memory range types
//

#define MTRR_TYPE_UC            0
#define MTRR_TYPE_USWC          1
#define MTRR_TYPE_WT            4
#define MTRR_TYPE_WP            5
#define MTRR_TYPE_WB            6
#define MTRR_TYPE_MAX           7


#include "pshpack1.h"

typedef struct _MTRR_CAPABILITIES {
    union {
        struct {
            ULONG VarCnt:8;
            ULONG FixSupported:1;
            ULONG Reserved_0:1;
            ULONG UswcSupported:1;
        } hw;
        ULONGLONG   QuadPart;
    } u;
} MTRR_CAPABILITIES;


typedef struct _MTRR_DEFAULT {
    union {
        struct {
            ULONG Type:8;
            ULONG Reserved_0:2;
            ULONG FixedEnabled:1;
            ULONG MtrrEnabled:1;
        } hw;
        ULONGLONG   QuadPart;
    } u;
} MTRR_DEFAULT;

typedef struct _MTRR_VARIABLE_BASE {
    union {
        struct {
            ULONGLONG   Type:8;
            ULONGLONG   Reserved_0:4;
            ULONGLONG   PhysBase:52;
        } hw;
        ULONGLONG   QuadPart;
    } u;
} MTRR_VARIABLE_BASE;

#define MTRR_MASK_BASE  (~0xfff)

typedef struct _MTRR_VARIABLE_MASK {
    union {
        struct {
            ULONGLONG   Reserved_0:11;
            ULONGLONG   Valid:1;
            ULONGLONG   PhysMask:52;
        } hw;
        ULONGLONG   QuadPart;
    } u;
} MTRR_VARIABLE_MASK;

#define MTRR_MASK_MASK  (~0xfff)


#include "poppack.h"

//
// ----------------------------------------------------------------
//

PUCHAR
MtrrType (
    IN ULONG    Type
    )
{
    PUCHAR  p;
    static  UCHAR s[20];

    switch (Type) {
        case 0:     p = "UC";     break;
        case 1:     p = "USWC";     break;
        case 4:     p = "WT";     break;
        case 5:     p = "WP";     break;
        case 6:     p = "WB";     break;
        default:
            sprintf (s, "%02x??", Type & 0xff);
            p = s;
            break;
    }
    return p;
}

VOID
MtrrDumpFixed (
    IN ULONG    Base,
    IN ULONG    Size,
    IN ULONG    Msr
    )
{
    ULONG       x;
    ULONGLONG   li;

    ReadMsr(Msr, &li);

    for (x=0; x < 8; x++) {
        dprintf ("%s:%05x-%05x  ",
            MtrrType ( ((ULONG) li) & 0xff ),
            Base,
            Base + Size - 1
            );

        li >>= 8;
        Base += Size;

        if (x == 3) {
            dprintf ("\n");
        }
    }

    dprintf ("\n");
}



DECLARE_API( mtrr )

/*++

Routine Description:

    Dumps processors mtrr

Arguments:

    args - none

Return Value:

    None

--*/
{
    MTRR_CAPABILITIES   Capabilities;
    MTRR_DEFAULT        Default;
    MTRR_VARIABLE_BASE  Base;
    MTRR_VARIABLE_MASK  Mask;
    ULONG               Index;
    ULONG               i;
    PUCHAR              p;
    ULONG               fb;

    //
    // Dump MTRR
    //

    ReadMsr(MTRR_MSR_CAPABILITIES, &Capabilities.u.QuadPart);
    ReadMsr(MTRR_MSR_DEFAULT, &Default.u.QuadPart);

    dprintf ("MTTR: %s Var %d, Fixed-%s %s, USWC-%s, Default: %s\n",
        Default.u.hw.MtrrEnabled ? "" : "disabled",
        Capabilities.u.hw.VarCnt,
        Capabilities.u.hw.FixSupported ? "support" : "none",
        Default.u.hw.FixedEnabled ? "enabled" : "disabled",
        Capabilities.u.hw.UswcSupported ? "supported" : "none",
        MtrrType (Default.u.hw.Type)
        );

    MtrrDumpFixed (0x00000, 64*1024, 0x250);
    MtrrDumpFixed (0x80000, 16*1024, 0x258);
    MtrrDumpFixed (0xA0000, 16*1024, 0x259);
    MtrrDumpFixed (0xC0000,  4*1024, 0x268);
    MtrrDumpFixed (0xC8000,  4*1024, 0x269);
    MtrrDumpFixed (0xD0000,  4*1024, 0x26A);
    MtrrDumpFixed (0xD8000,  4*1024, 0x26B);
    MtrrDumpFixed (0xE0000,  4*1024, 0x26C);
    MtrrDumpFixed (0xE8000,  4*1024, 0x26D);
    MtrrDumpFixed (0xF0000,  4*1024, 0x26E);
    MtrrDumpFixed (0xE8000,  4*1024, 0x26F);

    dprintf ("Varible:                Base               Mask\n");
    for (Index=0; Index < (ULONG) Capabilities.u.hw.VarCnt; Index++) {
        ReadMsr(MTRR_MSR_VARIABLE_BASE+2*Index, &Base.u.QuadPart);
        ReadMsr(MTRR_MSR_VARIABLE_MASK+2*Index, &Mask.u.QuadPart);

        dprintf (" %2d. ", Index);
        if (Mask.u.hw.Valid) {
            dprintf ("%4s: %08x:%08x  %08x:%08x\n",
                MtrrType ((ULONG) Base.u.hw.Type),
                (ULONG) (Base.u.QuadPart >> 32), ((ULONG) Base.u.QuadPart) & MTRR_MASK_BASE,
                (ULONG) (Mask.u.QuadPart >> 32), ((ULONG) Mask.u.QuadPart) & MTRR_MASK_MASK
                );
        } else {
            dprintf ("\n");
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\kdexts\p_i386\mps.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    mps.c

Abstract:

    WinDbg Extension Api

Author:

    Peter Johnston (peterj) 30-September-1997

Environment:

    User Mode.

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

//
// Get needed MPS definitions right from the horse itself.
//

#include "..\..\ntos\nthals\inc\pcmp.inc"
#include "..\..\ntos\nthals\inc\apic.inc"

//
// xReadMemory is easier to use than ReadMemory and is
// defined in ..\devnode.c
//

BOOLEAN
xReadMemory(
    PVOID S,
    PVOID D,
    ULONG Len
    );

PUCHAR
mpsGetIntTypeDesc(
    UCHAR IntType
    )
{
    switch (IntType) {
    case INT_TYPE_INTR:
        return "intr  ";
    case INT_TYPE_NMI:
        return "nmi   ";
    case INT_TYPE_SMI:
        return "smi   ";
    case INT_TYPE_EXTINT:
        return "extint";
    default:
        return "unknwn";
    }
}

PUCHAR
mpsExtAddrTypeToText(
    UCHAR AddressType
    )
{
    switch (AddressType) {
    case MPS_ADDRESS_MAP_IO:
        return "io port     ";
    case MPS_ADDRESS_MAP_MEMORY:
        return "memory      ";
    case MPS_ADDRESS_MAP_PREFETCH_MEMORY:
        return "prefetch mem";
    case MPS_ADDRESS_MAP_UNDEFINED:
        return "mps undef   ";
    default:
        return "unknown type";
    }
}

PUCHAR
mpsExtCompatibleListToText(
    ULONG List
    )
{
    switch (List) {
    case 0:
        return "ISA";
    case 1:
        return "VGA";
    default:
        return "unknown predefined range";
    }
}


BOOLEAN
mpsBaseTable(
    PUCHAR BaseTableAddress,
    ULONG  EntryCount
    )

/*++

Routine Description:

    Dumps entries from the MPS BASE table.

Arguments:

    BaseTableAddress    Address (in local memory) of the Base Entry Table
    EntryCount          Number of entries in this table.

Return Value:

    TRUE    is all is well
    FALSE   if execution cannot continue (ie we encountered an unknown
            entry type.  Can't continue because we don't know how big
            it is.

--*/

{
    PUCHAR bp = BaseTableAddress;

    while (EntryCount--) {
        dprintf("  ");
        switch (*bp) {
        case ENTRY_PROCESSOR:
            {
                PPCMPPROCESSOR p = (PPCMPPROCESSOR)bp;
                bp += sizeof(*p);

                dprintf(
                    "processor. %s%sL.APIC ID %02x Vers %02x\n",
                    p->CpuFlags & CPU_ENABLED ? "EN " : "",
                    p->CpuFlags & BSP_CPU     ? "BP " : "",
                    p->LocalApicId,
                    p->LocalApicVersion
                    );
                dprintf(
                    "             Family %x, Model %x, Stepping %x, CPUID Flags %04x\n",
                    p->CpuIdentification.Family,
                    p->CpuIdentification.Model,
                    p->CpuIdentification.Stepping,
                    p->FeatureFlags
                    );
            }
            break;
        case ENTRY_BUS:
            {
                PPCMPBUS bus = (PPCMPBUS)bp;
                bp += sizeof(*bus);

                dprintf(
                    "bus.       id %02x, type %6.6s\n",
                    bus->BusId,
                    bus->BusType
                    );
            }
            break;
        case ENTRY_IOAPIC:
            {
                PPCMPIOAPIC ioapic = (PPCMPIOAPIC)bp;
                bp += sizeof(*ioapic);

                dprintf(
                    "io apic.   %s id %02x vers %02x @ %08x\n",
                    ioapic->IoApicFlag & IO_APIC_ENABLED ? "EN" : "DI",
                    ioapic->IoApicId,
                    ioapic->IoApicVersion,
                    ioapic->IoApicAddress
                    );
            }
            break;
        case ENTRY_INTI:
            {
                PPCMPINTI inti = (PPCMPINTI)bp;
                bp += sizeof(*inti);

                dprintf(
                    "io int.    %s po=%x el=%x, srcbus %02x irq %02x dst apic %02x intin %02x\n",
                    mpsGetIntTypeDesc(inti->IntType),
                    inti->Signal.Polarity,
                    inti->Signal.Level,
                    inti->SourceBusId,
                    inti->SourceBusIrq,
                    inti->IoApicId,
                    inti->IoApicInti
                    );
            }
            break;
        case ENTRY_LINTI:
            {
                PPCMPLINTI linti = (PPCMPLINTI)bp;
                bp += sizeof(*linti);

                dprintf(
                    "lcl int.   %s po=%x el=%x, srcbus %02x irq %02x dst apic %02x intin %02x\n",
                    mpsGetIntTypeDesc(linti->IntType),
                    linti->Signal.Polarity,
                    linti->Signal.Level,
                    linti->SourceBusId,
                    linti->SourceBusIrq,
                    linti->DestLocalApicId,
                    linti->DestLocalApicInti
                    );
            }
            break;
        default:
            dprintf(
                "Unknown MPS base type 0x%02x, cannot continue.\n",
                *bp
                );
            return FALSE;
        }
    }
    return TRUE;
}


BOOLEAN
mpsExtendedTable(
    PUCHAR ExtendedTableAddress,
    PUCHAR ExtendedTableAddressEnd
    )

/*++

Routine Description:

    Dumps entries from the MPS Extended table.

Arguments:

    BaseTableAddress    Address (in local memory) of the Base Entry Table
    EntryCount          Number of entries in this table.

Return Value:

    TRUE    is all is well
    FALSE   if execution cannot continue (ie we encountered an unknown
            entry type.  Can't continue because we don't know how big
            it is.

--*/

{
    PUCHAR bp = ExtendedTableAddress;

    if (!bp) {
        return TRUE;
    }
    dprintf("  extended table entries\n");

    while (bp < ExtendedTableAddressEnd) {

        PMPS_EXTENTRY extent = (PMPS_EXTENTRY)bp;

        if (extent->Length == 0) {
            dprintf("Malformed extended entry, length = 0, cannot continue.\n");
            return FALSE;
        }

        dprintf("  ");

        switch (extent->Type) {
        case EXTTYPE_BUS_ADDRESS_MAP:
            dprintf(
                "address.   bus %02x %s % 16I64x len %-I64x\n",
                extent->u.AddressMap.BusId,
                mpsExtAddrTypeToText(extent->u.AddressMap.Type),
                extent->u.AddressMap.Base,
                extent->u.AddressMap.Length
                );
            break;
        case EXTTYPE_BUS_HIERARCHY:
            dprintf(
                "child bus. bus %02x is child of bus %02x%s\n",
                extent->u.BusHierarchy.BusId,
                extent->u.BusHierarchy.ParentBusId,
                extent->u.BusHierarchy.SubtractiveDecode ? " subtractive" : ""
                );
            break;
        case EXTTYPE_BUS_COMPATIBLE_MAP:
            dprintf(
                "bus comp.  bus %02x %s %s ranges\n",
                extent->u.CompatibleMap.BusId,
                extent->u.CompatibleMap.Modifier ? "exclude" : "include",
                mpsExtCompatibleListToText(extent->u.CompatibleMap.List)
                );
            break;
        case EXTTYPE_PERSISTENT_STORE:
            dprintf(
                "persist.   % 16I64x len %-I64x\n",
                extent->u.PersistentStore.Address,
                extent->u.PersistentStore.Length
                );
            break;
        default:
            dprintf(
                "Unknown MPS extended type 0x%02x, cannot continue.\n",
                extent->Type
                );
            return FALSE;
        }

        //
        // Advance to the next entry.
        //

        bp += extent->Length;
    }
    return TRUE;
}


DECLARE_API( mps )

/*++

Routine Description:

    Dumps the MPS (Multi Processor Specification) BIOS Tables.

Arguments:

    None

Return Value:

    None

--*/

{
    PVOID addr;
    UCHAR halName[32];
    struct PcMpTable * PcMpTablePtr;
    struct PcMpTable PcMpCfgTable;
    ULONG entryCount;
    PUCHAR bp;
    UCHAR c;
    ULONG i;

    PUCHAR MpsBaseTable = NULL;
    PUCHAR MpsExtendedTable = NULL;
    PUCHAR MpsExtendedTableEnd;

    BOOLEAN halNameKnown = FALSE;

    //
    // Check to see if user entered the address of the MPS tables.
    // If not, try to obtain it using HAL symbols.
    //

    PcMpTablePtr = NULL;
    sscanf(args, "%lx", &PcMpTablePtr);
    if (PcMpTablePtr == NULL) {

        //
        // Get address of PC+MP structure from the HAL.
        // N.B. Should add code to allow hunting for the floating pointer.
        //

        addr = (PVOID)GetExpression("hal!HalName");

        if (addr == NULL) {
            dprintf(
                "Unable to use HAL symbols (hal!HalName), please verify symbols.\n"
                );
            return;
        }

        if (!xReadMemory(addr, &halName, sizeof(halName))) {
            dprintf(
                "Failed to read HalName from host memory, quitting.\n"
                );
            return;
        }

        halName[sizeof(halName)-1] = '\0';
        if (strstr(halName, "MPS ") == NULL) {
            dprintf("HAL = \"%s\".\n", halName);
            dprintf("HAL does not appear to be an MPS HAL, quitting.\n");
            return;
        }
        halNameKnown = TRUE;

        addr = (PVOID)GetExpression("hal!PcMpTablePtr");

        if (addr == NULL) {
            dprintf(
                "Unable to get address of hal!PcMpTablePtr, cannot continue.\n"
                );
            return;
        }

        if (!xReadMemory(addr, &PcMpTablePtr, sizeof(PcMpTablePtr))) {
            dprintf(
                "Failed to read PcMpTablePtr from host memory, cannot continue.\n"
                );
            return;
        }
    }

    if (!xReadMemory(PcMpTablePtr, &PcMpCfgTable, sizeof(PcMpCfgTable))) {
        dprintf(
            "Failed to read MP Configuration Table Header @%08x\n"
            "Cannot continue.\n",
            PcMpTablePtr
            );
        return;
    }

    if (PcMpCfgTable.Signature != PCMP_SIGNATURE) {
        dprintf(
            "MP Config Table Signature doesn't match.  Cannot continue.\n"
            );
        return;
    }

    dprintf("  BIOS Revision ");

    switch (PcMpCfgTable.Revision) {
    case 1:
        dprintf(
            "MPS 1.1 (WARNING: This BIOS might not support NT 5 depending\n"
            "                  upon system configuration.)\n"
            );
        break;
    case 4:
        dprintf(
            "MPS 1.4       "
            );
        break;
    default:
        dprintf(
            "Unknown MPS revision byte 0x%2x, dumped values\n"
            "  may be incorrect.\n"
            );
        break;
    }

    if (halNameKnown) {
        dprintf("  HAL = %s", halName);
    }
    dprintf("\n");

    bp = PcMpCfgTable.OemId + sizeof(PcMpCfgTable.OemId);
    c = *bp;
    *bp = '\0';
    dprintf(
        "  OEM ID         :%s\n",
        PcMpCfgTable.OemId
        );
    *bp = c;

    bp = PcMpCfgTable.OemProductId + sizeof(PcMpCfgTable.OemProductId);
    c = *bp;
    *bp = '\0';
    dprintf(
        "  OEM Product ID :%s\n",
        PcMpCfgTable.OemProductId
        );
    *bp = c;

    if (PcMpCfgTable.TableLength <= sizeof(PcMpCfgTable)) {
        dprintf(
            "MPS Base Table length (%d) is too small to be reasonable,\n",
            PcMpCfgTable.TableLength
            );
        dprintf(
            "Must be >= sizeof(fixed table header) (%d bytes).  "
            "Cannot continue.\n",
            sizeof(PcMpCfgTable)
            );
        return;
    }

    //
    // Get memory for the base and extended tables and read them from
    // memory.
    //

    MpsBaseTable = malloc( PcMpCfgTable.TableLength - sizeof(PcMpCfgTable));
    if (!MpsBaseTable) {
        dprintf(
            "Could not allocate %d bytes local memory, quitting.\n",
            PcMpCfgTable.TableLength - sizeof(PcMpCfgTable)
            );
        return;
    }

    if (!xReadMemory(((PUCHAR)PcMpTablePtr) + sizeof(PcMpCfgTable),
                     MpsBaseTable,
                     PcMpCfgTable.TableLength - sizeof(PcMpCfgTable))) {
        dprintf("Failed to read MPS Base Table from host memory.  Quitting.\n");
        goto cleanup;
    }

    if (PcMpCfgTable.ExtTableLength) {
        MpsExtendedTable = malloc(PcMpCfgTable.ExtTableLength);
        if (!MpsExtendedTable) {
            dprintf(
                "Could not allocate %d bytes local memory for extended MPS Table, quitting.\n",
            PcMpCfgTable.ExtTableLength
            );
            goto cleanup;
        }

        if (!xReadMemory(((PUCHAR)PcMpTablePtr) + PcMpCfgTable.TableLength,
                         MpsExtendedTable,
                         PcMpCfgTable.ExtTableLength)) {
            dprintf(
                "Could not read MPS Extended table from host memory.\n"
                "Will attempt to dump base structures.\n"
                );
            free(MpsExtendedTable);
            MpsExtendedTable = NULL;
        }
        MpsExtendedTableEnd = MpsExtendedTable + PcMpCfgTable.ExtTableLength;
    }

    //
    // Validate checksums.
    //
    // Base checksum is the sum of all bytes (inc checksum) in the
    // base table (including the fixed header).
    //

    c = 0;

    //
    // Sum fixed header.
    //

    bp = (PUCHAR)&PcMpCfgTable;
    for (i = 0; i < sizeof(PcMpCfgTable); i++) {
        c += *bp++;
    }

    //
    // Add rest of base table.
    //

    bp = MpsBaseTable;
    for (i = 0; i < PcMpCfgTable.TableLength - sizeof(PcMpCfgTable); i++) {
        c += *bp++;
    }

    //
    // The result should be zero.
    //

    if (c) {
        dprintf(
            "MPS Base Table checksum is in error.\n"
            "Found 0x%02x, Computed 0x%02x (Total 0x%02x).\n",
            PcMpCfgTable.Checksum,
            (UCHAR)(c - PcMpCfgTable.Checksum),
            c
            );
    }

    //
    // Now do the extended table checksum.  This one doesn't include
    // itself so we should just match (rather than end up with zero).
    //

    if (MpsExtendedTable) {
        c = 0;
        bp = MpsExtendedTable;
        for (i = 0; i < PcMpCfgTable.ExtTableLength; i++) {
            c += *bp++;
        }

        //
        // To sum to zero it needs to end up being it's opposite.
        //

        c = -c;

        if (c != PcMpCfgTable.ExtTableChecksum) {
            dprintf(
                "MPS Extended Table checksum is in error.\n"
                "Found 0x%02x, Computed 0x%02x.\n",
                PcMpCfgTable.ExtTableChecksum,
                c
                );
        }
    }

    //
    // Dump the base table.
    //

    if (!mpsBaseTable(MpsBaseTable, PcMpCfgTable.NumOfEntries)) {
        goto cleanup;
    }


    //
    // Dump the extended table.
    //

    if (!mpsExtendedTable(MpsExtendedTable, MpsExtendedTableEnd)) {
        goto cleanup;
    }

cleanup:
    if (MpsBaseTable) {
        free(MpsBaseTable);
    }
    if (MpsExtendedTable) {
        free(MpsExtendedTable);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\kdexts\p_i386\makefile.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    makefile.inc

Abstract:

    This file tells nmake the correct dependency relationships
    for objects created from c files in this directory which are
    wrappers for c files in another directory.


Author:

    Kent Forschmiedt


!ENDIF

SRCDIR=..

!INCLUDE $(SRCDIR)\common.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\kdexts\p_i386\mts.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    mts.c

Abstract:

    MikeTs's little KD extension.

Author:

    Michael Tsang (mikets) 18-November-1997

Environment:

    User Mode.

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

VOID ReadPci (
    IN PPCI_TYPE1_CFG_BITS      PciCfg1,
    OUT PUCHAR                  Buffer,
    IN ULONG                    Offset,
    IN ULONG                    Length
    );

#define CSOFFSET(x)     ((DWORD)(&((PPCI_COMMON_CONFIG)0)->x))

/*** PCI ConfigSpace Registers
 */

//PCI Command Register
char *ppszCmdRegNames[] = {"FB2BEnable", "SERREnable", "WaitCycle",
                           "PERREnable", "VGASnoop", "MemWriteEnable",
                           "SpecialCycle", "BusInitiate", "MemSpaceEnable",
                           "IOSpaceEnable"};
FMTBITS fmtCmdReg =
{
    {FMT_BITS, UNIT_WORD, 1, FMTF_NO_PRINT_DATA, 1, NULL, NULL, NULL},
    0x03ff, ppszCmdRegNames, NULL
};

//PCI Status Register
char *ppszStatusRegNames[] = {"PERR", "SERR", "InitiatorAbort", "TargetAbort",
                              "TargetDevAbort", "DataPERR", "FB2BCapable",
                              "UDFSupported", "66MHzCapable",
                              "CapList"};
FMTBITS fmt1StatusReg =
{
    {FMT_BITS, UNIT_WORD, 1, FMTF_FIRST_FIELD, 1, NULL, NULL, NULL},
    0xf9f0, ppszStatusRegNames, NULL
};

FMTNUM fmt2StatusReg =
{
    {FMT_NUMBER, UNIT_WORD, 1, FMTF_LAST_FIELD, 1, NULL, NULL, "DEVSELTiming:"},
    0x0600, 9, cszHexFmt
};

//Cache Line Size Register
char szBurstDisabled[] = "BurstDisabled";
char szBurst4DW[] = "Burst4DW";
char *ppszCacheSizeRegNames[] = {szBurstDisabled, szBurstDisabled,
                                 szBurstDisabled, szBurstDisabled,
                                 szBurst4DW, szBurst4DW, szBurst4DW, szBurst4DW};
char szBurst8DW[] = "Burst8DW";
FMTENUM fmtCacheSizeReg =
{
    {FMT_ENUM, UNIT_BYTE, 1, FMTF_NO_PRINT_DATA, 1, NULL, NULL, NULL},
    0xff, 0, 0, 0x07, ppszCacheSizeRegNames, szBurst8DW
};

char *ppszBridgeCtrlRegNames[] = {"WritePostEnable", "Mem1Prefetch",
                                  "Mem0Prefectch", "IRQRoutingEnable", "CBRst",
                                  "MasterAbort", "VGAEnable", "ISAEnable",
                                  "SERREnable", "PERREnable"};
FMTBITS fmtBridgeCtrlReg =
{
    {FMT_BITS, UNIT_WORD, 1, FMTF_NO_PRINT_DATA, 1, NULL, NULL, NULL},
    0x07ef, ppszBridgeCtrlRegNames, NULL
};

VOID PrintClassInfo(PBYTE pb, DWORD dwReg);

FMT afmtCfgSpaceCommon[] =
{
    {"VendorID=",      (PFMTHDR)&fmtHexWord,       NULL},
    {"DeviceID=",      (PFMTHDR)&fmtHexWord,       NULL},
    {"Command=",       (PFMTHDR)&fmtCmdReg,        NULL},
    {"Status=",        (PFMTHDR)&fmt1StatusReg,    NULL},
    {NULL,             (PFMTHDR)&fmt2StatusReg,    NULL},
    {"RevisionID=",    (PFMTHDR)&fmtHexByte,       NULL},
    {"ProgIF=",        (PFMTHDR)&fmtHexByteNoEOL,  PrintClassInfo},
    {"SubClass=",      (PFMTHDR)&fmtHexByteNoEOL,  PrintClassInfo},
    {"BaseClass=",     (PFMTHDR)&fmtHexByteNoEOL,  PrintClassInfo},
    {"CacheLineSize=", (PFMTHDR)&fmtCacheSizeReg,  NULL},
    {"LatencyTimer=",  (PFMTHDR)&fmtHexByte,       NULL},
    {"HeaderType=",    (PFMTHDR)&fmtHexByte,       NULL},
    {"BIST=",          (PFMTHDR)&fmtHexByte,       NULL},
    {NULL,             NULL,                       NULL}
};

FMT afmtCfgSpaceType0[] =
{
    {"BAR0=",          (PFMTHDR)&fmtHexDWord,      NULL},
    {"BAR1=",          (PFMTHDR)&fmtHexDWord,      NULL},
    {"BAR2=",          (PFMTHDR)&fmtHexDWord,      NULL},
    {"BAR3=",          (PFMTHDR)&fmtHexDWord,      NULL},
    {"BAR4=",          (PFMTHDR)&fmtHexDWord,      NULL},
    {"BAR5=",          (PFMTHDR)&fmtHexDWord,      NULL},
    {"CBCISPtr=",      (PFMTHDR)&fmtHexDWord,      NULL},
    {"SubSysVenID=",   (PFMTHDR)&fmtHexWord,       NULL},
    {"SubSysID=",      (PFMTHDR)&fmtHexWord,       NULL},
    {"ROMBAR=",        (PFMTHDR)&fmtHexDWord,      NULL},
    {"CapPtr=",        (PFMTHDR)&fmtHexByte,       NULL},
    {cszLabelReserved, (PFMTHDR)&fmtHexByte,       NULL},
    {cszLabelReserved, (PFMTHDR)&fmtHexWord,       NULL},
    {cszLabelReserved, (PFMTHDR)&fmtHexDWord,      NULL},
    {"IntLine=",       (PFMTHDR)&fmtHexByte,       NULL},
    {"IntPin=",        (PFMTHDR)&fmtHexByte,       NULL},
    {"MinGnt=",        (PFMTHDR)&fmtHexByte,       NULL},
    {"MaxLat=",        (PFMTHDR)&fmtHexByte,       NULL},
    {NULL,             NULL,                       NULL}
};

FMT afmtCfgSpaceType1[] =
{
    {"BAR0=",          (PFMTHDR)&fmtHexDWord,      NULL},
    {"BAR1=",          (PFMTHDR)&fmtHexDWord,      NULL},
    {"PriBusNum=",     (PFMTHDR)&fmtHexByte,       NULL},
    {"SecBusNum=",     (PFMTHDR)&fmtHexByte,       NULL},
    {"SubBusNum=",     (PFMTHDR)&fmtHexByte,       NULL},
    {"SecLatencyTmr=", (PFMTHDR)&fmtHexByte,       NULL},
    {"IOBase=",        (PFMTHDR)&fmtHexByte,       NULL},
    {"IOLimit=",       (PFMTHDR)&fmtHexByte,       NULL},
    {"SecStatus=",     (PFMTHDR)&fmt1StatusReg,    NULL},
    {NULL,             (PFMTHDR)&fmt2StatusReg,    NULL},
    {"MemBase=",       (PFMTHDR)&fmtHexWord,       NULL},
    {"MemLimit=",      (PFMTHDR)&fmtHexWord,       NULL},
    {"PrefMemBase=",   (PFMTHDR)&fmtHexWord,       NULL},
    {"PrefMemLimit=",  (PFMTHDR)&fmtHexWord,       NULL},
    {"PrefBaseHi=",    (PFMTHDR)&fmtHexDWord,      NULL},
    {"PrefLimitHi=",   (PFMTHDR)&fmtHexDWord,      NULL},
    {"IOBaseHi=",      (PFMTHDR)&fmtHexWord,       NULL},
    {"IOLimitHi=",     (PFMTHDR)&fmtHexWord,       NULL},
    {"CapPtr=",        (PFMTHDR)&fmtHexByte,       NULL},
    {cszLabelReserved, (PFMTHDR)&fmtHexByte,       NULL},
    {cszLabelReserved, (PFMTHDR)&fmtHexWord,       NULL},
    {"ROMBAR=",        (PFMTHDR)&fmtHexDWord,      NULL},
    {"IntLine=",       (PFMTHDR)&fmtHexByte,       NULL},
    {"IntPin=",        (PFMTHDR)&fmtHexByte,       NULL},
    {"BridgeCtrl=",    (PFMTHDR)&fmtBridgeCtrlReg, NULL},
    {NULL,             NULL,                       NULL}
};

FMT afmtCfgSpaceType2[] =
{
    {"RegBaseAddr=",   (PFMTHDR)&fmtHexDWord,      NULL},
    {"CapPtr=",        (PFMTHDR)&fmtHexByte,       NULL},
    {cszLabelReserved, (PFMTHDR)&fmtHexByte,       NULL},
    {"SecStatus=",     (PFMTHDR)&fmt1StatusReg,    NULL},
    {NULL,             (PFMTHDR)&fmt2StatusReg,    NULL},
    {"PCIBusNum=",     (PFMTHDR)&fmtHexByte,       NULL},
    {"CBBusNum=",      (PFMTHDR)&fmtHexByte,       NULL},
    {"SubBusNum=",     (PFMTHDR)&fmtHexByte,       NULL},
    {"CBLatencyTimer=",(PFMTHDR)&fmtHexByte,       NULL},
    {"MemBase0=",      (PFMTHDR)&fmtHexDWord,      NULL},
    {"MemLimit0=",     (PFMTHDR)&fmtHexDWord,      NULL},
    {"MemBase1=",      (PFMTHDR)&fmtHexDWord,      NULL},
    {"MemLimit1=",     (PFMTHDR)&fmtHexDWord,      NULL},
    {"IOBase0=",       (PFMTHDR)&fmtHexDWord,      NULL},
    {"IOLimit0=",      (PFMTHDR)&fmtHexDWord,      NULL},
    {"IOBase1=",       (PFMTHDR)&fmtHexDWord,      NULL},
    {"IOLimit1=",      (PFMTHDR)&fmtHexDWord,      NULL},
    {"IntLine=",       (PFMTHDR)&fmtHexByte,       NULL},
    {"IntPin=",        (PFMTHDR)&fmtHexByte,       NULL},
    {"BridgeCtrl=",    (PFMTHDR)&fmtBridgeCtrlReg, NULL},
    {"SubSysVenID=",   (PFMTHDR)&fmtHexWord,       NULL},
    {"SubSysID=",      (PFMTHDR)&fmtHexWord,       NULL},
    {"LegacyBaseAddr=",(PFMTHDR)&fmtHexDWord,      NULL},
    {cszNull,          (PFMTHDR)&fmt6HexDWord,     NULL},
    {NULL,             NULL,                       NULL}
};

FMT afmtCfgSpaceUnknown[] =
{
    {cszNull,          (PFMTHDR)&fmt4HexDWord,     NULL},       //0x10-0x1f
    {cszNull,          (PFMTHDR)&fmt8HexDWord,     NULL},       //0x20-0x3f
    {NULL,             NULL,                       NULL}
};

FMT afmtCfgSpace40[] =
{
    {cszNull,          (PFMTHDR)&fmt8HexDWord,     NULL},
    {NULL,             NULL,                       NULL}
};

FMT afmtCfgSpace60[] =
{
    {cszNull,          (PFMTHDR)&fmt8HexDWord,     NULL},       //0x60-0x7f
    {cszNull,          (PFMTHDR)&fmt8HexDWord,     NULL},       //0x80-0x9f
    {cszNull,          (PFMTHDR)&fmt8HexDWord,     NULL},       //0xa0-0xbf
    {cszNull,          (PFMTHDR)&fmt8HexDWord,     NULL},       //0xc0-0xdf
    {cszNull,          (PFMTHDR)&fmt8HexDWord,     NULL},       //0xe0-0xff
    {NULL,             NULL,                       NULL}
};

char szUnknown[] = "Unknown";
char *ppszCapIDNames[] = {"PwrMgmt", "AGP", szUnknown, szUnknown, "MSI"};
FMTENUM fmtCapID =
{
    {FMT_ENUM, UNIT_BYTE, 1, FMTF_NO_PRINT_DATA, 1, NULL, NULL, NULL},
    0xff, 0, 0x01, 0x05, ppszCapIDNames, szUnknown
};

FMT afmtCapHeader[] =
{
    {"CapID=",         (PFMTHDR)&fmtCapID,         NULL},
    {"NextPtr=",       (PFMTHDR)&fmtHexByte,       NULL},
    {NULL,             NULL,                       NULL}
};

char *ppszPwrMgmtCaps[] = {"PMED3Cold", "PMED3Hot", "PMED2", "PMED1",
                           "PMED0", "D2Support", "D1Support", "DSI",
                           "AUXPWR", "PMECLK"};
FMTBITS fmtPwrMgmtCaps =
{
    {FMT_BITS, UNIT_WORD, 1, FMTF_FIRST_FIELD, 1, NULL, NULL, NULL},
    0xfe38, ppszPwrMgmtCaps, NULL
};

FMTNUM fmtPwrMgmtVer =
{
    {FMT_NUMBER, UNIT_WORD, 1, FMTF_LAST_FIELD, 1, NULL, NULL, "Ver:"},
    0x0007, 0, cszHexFmt
};

char *ppszPwrMgmtCtrl1[] = {"PMESTAT", "PMEEnable"};
FMTBITS fmtPwrMgmtCtrl1 =
{
    {FMT_BITS, UNIT_WORD, 1, FMTF_FIRST_FIELD, 1, NULL, NULL, NULL},
    0x8100, ppszPwrMgmtCtrl1, NULL
};

FMTNUM fmtPwrMgmtCtrl2 =
{
    {FMT_NUMBER, UNIT_WORD, 1, FMTF_MIDDLE_FIELD, 1, NULL, NULL, "DataScale:"},
    0x6000, 13, cszHexFmt
};

FMTNUM fmtPwrMgmtCtrl3 =
{
    {FMT_NUMBER, UNIT_WORD, 1, FMTF_MIDDLE_FIELD, 1, NULL, NULL, "DataSel:"},
    0x1e00, 9, cszHexFmt
};

char *ppszDStateNames[] = {"D0", "D1", "D2", "D3Hot"};
FMTENUM fmtPwrMgmtCtrl4 =
{
    {FMT_ENUM, UNIT_WORD, 1, FMTF_LAST_FIELD, 1, NULL, NULL, NULL},
    0x0003, 0, 0x00, 0x03, ppszDStateNames, szUnknown
};

char *ppszPwrMgmtBridge[] = {"BPCCEnable", "D3HotStopClock"};
FMTBITS fmtPwrMgmtBridge =
{
    {FMT_BITS, UNIT_BYTE, 1, FMTF_NO_PRINT_DATA, 1, NULL, NULL, NULL},
    0xc0, ppszPwrMgmtBridge, NULL
};

FMT afmtPwrMgmt[] =
{
    {"PwrMgmtCap=",    (PFMTHDR)&fmtPwrMgmtCaps,   NULL},
    {NULL,             (PFMTHDR)&fmtPwrMgmtVer,    NULL},
    {"PwrMgmtCtrl=",   (PFMTHDR)&fmtPwrMgmtCtrl1,  NULL},
    {NULL,             (PFMTHDR)&fmtPwrMgmtCtrl2,  NULL},
    {NULL,             (PFMTHDR)&fmtPwrMgmtCtrl3,  NULL},
    {NULL,             (PFMTHDR)&fmtPwrMgmtCtrl4,  NULL},
    {"PwrMgmtBridge=", (PFMTHDR)&fmtPwrMgmtBridge, NULL},
    {NULL,             NULL,                       NULL}
};

FMTNUM fmtAGPVerMajor =
{
    {FMT_NUMBER, UNIT_WORD, 1, FMTF_FIRST_FIELD, 1, NULL, NULL, "Major:"},
    0x00f0, 4, cszHexFmt
};

FMTNUM fmtAGPVerMinor =
{
    {FMT_NUMBER, UNIT_WORD, 1, FMTF_LAST_FIELD, 1, NULL, NULL, "Minor:"},
    0x000f, 0, cszHexFmt
};

FMTNUM fmtAGPStatus1 =
{
    {FMT_NUMBER, UNIT_DWORD, 1, FMTF_FIRST_FIELD, 1, NULL, NULL, "MaxRQDepth:"},
    0xff000000, 24, cszHexFmt
};

char *ppszAGPStatus2[] = {"SBA"};
FMTBITS fmtAGPStatus2 =
{
    {FMT_BITS, UNIT_DWORD, 1, FMTF_MIDDLE_FIELD, 1, NULL, NULL, NULL},
    0x00000200, ppszAGPStatus2, NULL
};

FMTNUM fmtAGPStatus3 =
{
    {FMT_NUMBER, UNIT_DWORD, 1, FMTF_LAST_FIELD, 1, NULL, NULL, "Rate:"},
    0x00000003, 0, cszHexFmt
};

FMTNUM fmtAGPCommand1 =
{
    {FMT_NUMBER, UNIT_DWORD, 1, FMTF_FIRST_FIELD, 1, NULL, NULL, "RQDepth:"},
    0xff000000, 24, cszHexFmt
};

char *ppszAGPCommand2[] = {"SBAEnable", "AGPEnable"};
FMTBITS fmtAGPCommand2 =
{
    {FMT_BITS, UNIT_DWORD, 1, FMTF_MIDDLE_FIELD, 1, NULL, NULL, NULL},
    0x00000300, ppszAGPCommand2, NULL
};

FMTNUM fmtAGPCommand3 =
{
    {FMT_NUMBER, UNIT_DWORD, 1, FMTF_LAST_FIELD, 1, NULL, NULL, "Rate:"},
    0x00000007, 0, cszHexFmt
};

FMT afmtAGP[] =
{
    {"Version=",       (PFMTHDR)&fmtAGPVerMajor,   NULL},
    {NULL,             (PFMTHDR)&fmtAGPVerMinor,   NULL},
    {"Status=",        (PFMTHDR)&fmtAGPStatus1,    NULL},
    {NULL,             (PFMTHDR)&fmtAGPStatus2,    NULL},
    {NULL,             (PFMTHDR)&fmtAGPStatus3,    NULL},
    {"Command=",       (PFMTHDR)&fmtAGPCommand1,   NULL},
    {NULL,             (PFMTHDR)&fmtAGPCommand2,   NULL},
    {NULL,             (PFMTHDR)&fmtAGPCommand3,   NULL},
    {NULL,             NULL,                       NULL}
};

char *ppszMsgCtrl1[] = {"64BitCapable", "MSIEnable"};
FMTBITS fmtMSIMsgCtrl1 =
{
    {FMT_BITS, UNIT_WORD, 1, FMTF_FIRST_FIELD, 1, NULL, NULL, NULL},
    0x0081, ppszMsgCtrl1, NULL
};

FMTNUM fmtMSIMsgCtrl2 =
{
    {FMT_NUMBER, UNIT_WORD, 1, FMTF_MIDDLE_FIELD, 1, NULL, NULL, "MultipleMsgEnable:"},
    0x0070, 4, cszHexFmt
};

FMTNUM fmtMSIMsgCtrl3 =
{
    {FMT_NUMBER, UNIT_WORD, 1, FMTF_LAST_FIELD, 1, NULL, NULL, "MultipleMsgCapable:"},
    0x000e, 1, cszHexFmt
};

FMT afmtMSI[] =
{
    {"MsgCtrl=",       (PFMTHDR)&fmtMSIMsgCtrl1,   NULL},
    {NULL,             (PFMTHDR)&fmtMSIMsgCtrl2,   NULL},
    {NULL,             (PFMTHDR)&fmtMSIMsgCtrl3,   NULL},
    {"MsgAddr=",       (PFMTHDR)&fmtHexDWord,      NULL},
    {NULL,             NULL,                       NULL}
};

FMT afmtMSI32[] =
{
    {"MsgData=",       (PFMTHDR)&fmtHexWord,       NULL},
    {NULL,             NULL,                       NULL}
};

FMT afmtMSI64[] =
{
    {"MsgAddrHi=",     (PFMTHDR)&fmtHexDWord,      NULL},
    {"MsgData=",       (PFMTHDR)&fmtHexWord,       NULL},
    {NULL,             NULL,                       NULL}
};

/*** CardBus Registers
 */

//Socket Event Register
char szPowerCycle[] = "PowerCycle";
char szCSTSCHG[] = "CSTSCHG";
char *ppszEventRegNames[] = {szPowerCycle, "/CCD2", "/CCD1", szCSTSCHG};
FMTBITS fmtSktEventReg =
{
    {FMT_BITS, UNIT_DWORD, 1, 0, 1, NULL, NULL, NULL},
    SKTEVENT_MASK, ppszEventRegNames, NULL
};

//Socket Mask Register
char *ppszMaskRegNames1[] = {szPowerCycle, szCSTSCHG};
char *ppszMaskRegNames2[] = {"CSCDisabled", cszUndefined, cszUndefined,
                             "CSCEnabled"};
FMTBITS fmt1SktMaskReg =
{
    {FMT_BITS, UNIT_DWORD, 1, FMTF_FIRST_FIELD, 1, NULL, NULL, NULL},
    SKTMSK_POWERCYCLE | SKTMSK_CSTSCHG, ppszMaskRegNames1, NULL
};
FMTENUM fmt2SktMaskReg =
{
    {FMT_ENUM, UNIT_DWORD, 1, FMTF_LAST_FIELD, 1, NULL, NULL, NULL},
    SKTMSK_CCD, 1, 0, 3, ppszMaskRegNames2, NULL
};

//Socket Present State Register
char szCardMayPresent[] = "CardMayPresent";
char *ppszStateRegNames1[] = {"YVSkt", "XVSkt", "3VSkt", "5VSkt", "YVCard",
                              "XVCard", "3VCard", "5VCard", "BadVccReq",
                              "DataLoss", "NotACard", "CardInt", "CBCard",
                              "R2Card", szPowerCycle, szCSTSCHG};
char *ppszStateRegNames2[] = {"CardPresent", szCardMayPresent, szCardMayPresent,
                              "NoCard"};
FMTBITS fmt1SktStateReg =
{
    {FMT_BITS, UNIT_DWORD, 1, FMTF_FIRST_FIELD, 1, NULL, NULL, NULL},
    0xf0003ff9, ppszStateRegNames1, NULL
};
FMTENUM fmt2SktStateReg =
{
    {FMT_ENUM, UNIT_DWORD, 1, FMTF_LAST_FIELD, 1, NULL, NULL, NULL},
    0x00000006, 1, 0, 3, ppszStateRegNames2, NULL
};

//Socket Force Event Register
FMTNUM fmtSktForceReg =
{
    {FMT_NUMBER, UNIT_DWORD, 1, 0, 1, NULL, NULL, NULL},
    0xffffffff, 0, cszDWordFmt
};

//Socket Control Register
char *ppszCtrlRegNames1[] = {"ClockStopEnabled"};
char *ppszCtrlRegNames2[] = {"Vcc:Off", cszReserved, "Vcc:5V", "Vcc:3.3V",
                             "Vcc:X.XV", "Vcc:Y.YV"};
char *ppszCtrlRegNames3[] = {"Vpp:Off", "Vpp:12V", "Vpp:5V", "Vpp:3.3V",
                             "Vpp:X.XV", "Vpp:Y.YV"};
FMTBITS fmt1SktCtrlReg =
{
    {FMT_BITS, UNIT_DWORD, 1, FMTF_FIRST_FIELD, 1, NULL, NULL, NULL},
    SKTPOWER_STOPCLOCK, ppszCtrlRegNames1, NULL
};
FMTENUM fmt2SktCtrlReg =
{
    {FMT_ENUM, UNIT_DWORD, 1, FMTF_MIDDLE_FIELD, 1, NULL, NULL, NULL},
    SKTPOWER_VCC_CONTROL, 4, 0, 5, ppszCtrlRegNames2, cszReserved
};
FMTENUM fmt3SktCtrlReg =
{
    {FMT_ENUM, UNIT_DWORD, 1, FMTF_LAST_FIELD, 1, NULL, NULL, NULL},
    SKTPOWER_VPP_CONTROL, 0, 0, 5, ppszCtrlRegNames3, cszReserved
};

FMT afmtCBRegs[] =
{
    {"SktEvent=", (PFMTHDR)&fmtSktEventReg,  NULL},
    {"SktMask=",  (PFMTHDR)&fmt1SktMaskReg,  NULL},
    {NULL,        (PFMTHDR)&fmt2SktMaskReg,  NULL},
    {"SktState=", (PFMTHDR)&fmt1SktStateReg, NULL},
    {NULL,        (PFMTHDR)&fmt2SktStateReg, NULL},
    {"SktForce=", (PFMTHDR)&fmtSktForceReg,  NULL},
    {"SktCtrl=",  (PFMTHDR)&fmt1SktCtrlReg,  NULL},
    {NULL,        (PFMTHDR)&fmt2SktCtrlReg,  NULL},
    {NULL,        (PFMTHDR)&fmt3SktCtrlReg,  NULL},
    {NULL,        NULL,                      NULL}
};

/*** ExCA Registers
 */

//ID/Revision Register
char *ppszIDRegNames[] = {"IOOnly", "MemOnly", "IO&Mem"};
FMTENUM fmt1IDRevReg =
{
    {FMT_ENUM, UNIT_BYTE, 1, FMTF_FIRST_FIELD, 1, NULL, NULL, NULL},
    0xc0, 6, 0, 2, ppszIDRegNames, cszReserved
};
FMTNUM fmt2IDRevReg =
{
    {FMT_NUMBER, UNIT_BYTE, 1, FMTF_LAST_FIELD, 1, NULL, NULL, "Rev:"},
    0x0f, 0, "%x"
};

//Interface Status Register
char *ppszISRegNames[] = {"VppValid", "PowerActive", "Ready", "WP", "CD2",
                          "CD1", "BVD2", "BVD1"};
FMTBITS fmtISReg =
{
    {FMT_BITS, UNIT_BYTE, 1, 0, 1, NULL, NULL, NULL},
    0xff, ppszISRegNames, NULL
};

//Power and RESETDRV Control Register
char *ppszPwrRegNames1[] = {"OutputEnable", "RESETDRVDisabled",
                            "AutoPwrEnabled", "PwrEnable"};
char *ppszPwrRegNames2[] = {"Vpp2=Off", "Vpp2=Vcc", "Vpp2=Vpp"};
char *ppszPwrRegNames3[] = {"Vpp1=Off", "Vpp1=Vcc", "Vpp1=Vpp"};
FMTBITS fmt1PwrReg =
{
    {FMT_BITS, UNIT_BYTE, 1, FMTF_FIRST_FIELD, 1, NULL, NULL, NULL},
    0xf0, ppszPwrRegNames1, NULL
};
FMTENUM fmt2PwrReg =
{
    {FMT_ENUM, UNIT_BYTE, 1, FMTF_MIDDLE_FIELD, 1, NULL, NULL, NULL},
    0x0c, 2, 0, 2, ppszPwrRegNames2, cszReserved
};
FMTENUM fmt3PwrReg =
{
    {FMT_ENUM, UNIT_BYTE, 1, FMTF_LAST_FIELD, 1, NULL, NULL, NULL},
    0x03, 0, 0, 2, ppszPwrRegNames3, cszReserved
};

//Interrupt and General Control Register
char *ppszIntCtrlRegNames[] = {"RingIndEnable", "ResetOff", "IOCard",
                               "INTREnable"};
FMTBITS fmt1IntCtrlReg =
{
    {FMT_BITS, UNIT_BYTE, 1, FMTF_FIRST_FIELD, 1, NULL, NULL, NULL},
    0xf0, ppszIntCtrlRegNames, NULL
};
FMTNUM fmt2IntCtrlReg =
{
    {FMT_NUMBER, UNIT_BYTE, 1, FMTF_LAST_FIELD, 1, NULL, NULL, "CardIRQ:"},
    0x0f, 0, cszHexFmt
};

//Card Status Change Register
char *ppszCSCRegNames[] = {"CDC", "RDYC", "BATTWARN", "BATTDEAD"};
FMTBITS fmtCSCReg =
{
    {FMT_BITS, UNIT_BYTE, 1, 0, 1, NULL, NULL, NULL},
    0x0f, ppszCSCRegNames, NULL
};

//Card Status Change Interrupt Configuration Register
char *ppszCSCIntCfgRegNames[] = {"CDEnable", "RDYEnable", "BattWarnEnable",
                                 "BattDeadEnable"};
FMTNUM fmt1CSCIntCfgReg =
{
    {FMT_NUMBER, UNIT_BYTE, 1, FMTF_FIRST_FIELD, 1, NULL, NULL, "CSCIRQ:"},
    0xf0, 4, cszHexFmt
};
FMTBITS fmt2CSCIntCfgReg =
{
    {FMT_BITS, UNIT_BYTE, 1, FMTF_LAST_FIELD, 1, NULL, NULL, NULL},
    0x0f, ppszCSCIntCfgRegNames, NULL
};

//Address Window Enable Register
char *ppszWinEnableRegNames[] = {"IO1Enable", "IO0Enable", "DecodeA23-A12",
                                 "Mem4Enable", "Mem3Enable", "Mem2Enable",
                                 "Mem1Enable", "Mem0Enable"};
FMTBITS fmtWinEnableReg =
{
    {FMT_BITS, UNIT_BYTE, 1, 0, 1, NULL, NULL, NULL},
    0xff, ppszWinEnableRegNames, NULL
};

//I/O Control Register
char *ppszIOCtrlRegNames[] = {"IO1WS", "IO1ZeroWS", "IO1CardIOCS", "IO116Bit",
                              "IO0WS", "IO0ZeroWS", "IO0CardIOCS", "IO016Bit"};
FMTBITS fmtIOCtrlReg =
{
    {FMT_BITS, UNIT_BYTE, 1, 0, 1, NULL, NULL, NULL},
    0xff, ppszIOCtrlRegNames, NULL
};

//Memory Address Registers
char *ppszMemStartNames[] = {"16Bit", "ZeroWS"};
char *ppszMemOffsetNames[] = {"WP", "RegActive"};
FMTNUM fmtMemAddr =
{
    {FMT_NUMBER, UNIT_WORD, 1, FMTF_FIRST_FIELD, 1, NULL, NULL, NULL},
    0x0fff, 0, cszWordFmt
};

FMTBITS fmtMemStartReg =
{
    {FMT_BITS, UNIT_WORD, 1, FMTF_LAST_FIELD, 1, NULL, NULL, NULL},
    0xc000, ppszMemStartNames, NULL
};

FMTNUM fmtMemEndReg =
{
    {FMT_NUMBER, UNIT_WORD, 1, FMTF_LAST_FIELD, 1, NULL, NULL, "WaitState:"},
    0xc000, 14, cszDecFmt
};

FMTNUM fmt1MemOffsetReg =
{
    {FMT_NUMBER, UNIT_WORD, 1, FMTF_FIRST_FIELD, 1, NULL, NULL, NULL},
    0x3fff, 0, cszWordFmt
};

FMTBITS fmt2MemOffsetReg =
{
    {FMT_BITS, UNIT_WORD, 1, FMTF_LAST_FIELD, 1, NULL, NULL, NULL},
    0xc000, ppszMemOffsetNames, NULL
};

FMT afmtExCARegs[] =
{
    {"IDRev=",            (PFMTHDR)&fmt1IDRevReg,     NULL},
    {NULL,                (PFMTHDR)&fmt2IDRevReg,     NULL},
    {"IFStatus=",         (PFMTHDR)&fmtISReg,         NULL},
    {"PwrCtrl=",          (PFMTHDR)&fmt1PwrReg,       NULL},
    {NULL,                (PFMTHDR)&fmt2PwrReg,       NULL},
    {NULL,                (PFMTHDR)&fmt3PwrReg,       NULL},
    {"IntGenCtrl=",       (PFMTHDR)&fmt1IntCtrlReg,   NULL},
    {NULL,                (PFMTHDR)&fmt2IntCtrlReg,   NULL},
    {"CardStatusChange=", (PFMTHDR)&fmtCSCReg,        NULL},
    {"IntConfig=",        (PFMTHDR)&fmt1CSCIntCfgReg, NULL},
    {NULL,                (PFMTHDR)&fmt2CSCIntCfgReg, NULL},
    {"WinEnable=",        (PFMTHDR)&fmtWinEnableReg,  NULL},
    {"IOWinCtrl=",        (PFMTHDR)&fmtIOCtrlReg,     NULL},
    {"IOWin0Start=",      (PFMTHDR)&fmtHexWord,       NULL},
    {"IOWin0End=",        (PFMTHDR)&fmtHexWord,       NULL},
    {"IOWin1Start=",      (PFMTHDR)&fmtHexWord,       NULL},
    {"IOWin1End=",        (PFMTHDR)&fmtHexWord,       NULL},
    {"MemWin0Start=",     (PFMTHDR)&fmtMemAddr,       NULL},
    {NULL,                (PFMTHDR)&fmtMemStartReg,   NULL},
    {"MemWin0End=",       (PFMTHDR)&fmtMemAddr,       NULL},
    {NULL,                (PFMTHDR)&fmtMemEndReg,     NULL},
    {"MemWin0Offset=",    (PFMTHDR)&fmt1MemOffsetReg, NULL},
    {NULL,                (PFMTHDR)&fmt2MemOffsetReg, NULL},
    {cszLabelReserved,    (PFMTHDR)&fmtHexWord,       NULL},
    {"MemWin1Start=",     (PFMTHDR)&fmtMemAddr,       NULL},
    {NULL,                (PFMTHDR)&fmtMemStartReg,   NULL},
    {"MemWin1End=",       (PFMTHDR)&fmtMemAddr,       NULL},
    {NULL,                (PFMTHDR)&fmtMemEndReg,     NULL},
    {"MemWin1Offset=",    (PFMTHDR)&fmt1MemOffsetReg, NULL},
    {NULL,                (PFMTHDR)&fmt2MemOffsetReg, NULL},
    {cszLabelReserved,    (PFMTHDR)&fmtHexWord,       NULL},
    {"MemWin2Start=",     (PFMTHDR)&fmtMemAddr,       NULL},
    {NULL,                (PFMTHDR)&fmtMemStartReg,   NULL},
    {"MemWin2End=",       (PFMTHDR)&fmtMemAddr,       NULL},
    {NULL,                (PFMTHDR)&fmtMemEndReg,     NULL},
    {"MemWin2Offset=",    (PFMTHDR)&fmt1MemOffsetReg, NULL},
    {NULL,                (PFMTHDR)&fmt2MemOffsetReg, NULL},
    {cszLabelReserved,    (PFMTHDR)&fmtHexWord,       NULL},
    {"MemWin3Start=",     (PFMTHDR)&fmtMemAddr,       NULL},
    {NULL,                (PFMTHDR)&fmtMemStartReg,   NULL},
    {"MemWin3End=",       (PFMTHDR)&fmtMemAddr,       NULL},
    {NULL,                (PFMTHDR)&fmtMemEndReg,     NULL},
    {"MemWin3Offset=",    (PFMTHDR)&fmt1MemOffsetReg, NULL},
    {NULL,                (PFMTHDR)&fmt2MemOffsetReg, NULL},
    {cszLabelReserved,    (PFMTHDR)&fmtHexWord,       NULL},
    {"MemWin4Start=",     (PFMTHDR)&fmtMemAddr,       NULL},
    {NULL,                (PFMTHDR)&fmtMemStartReg,   NULL},
    {"MemWin4End=",       (PFMTHDR)&fmtMemAddr,       NULL},
    {NULL,                (PFMTHDR)&fmtMemEndReg,     NULL},
    {"MemWin4Offset=",    (PFMTHDR)&fmt1MemOffsetReg, NULL},
    {NULL,                (PFMTHDR)&fmt2MemOffsetReg, NULL},
    {cszLabelReserved,    (PFMTHDR)&fmtHexWord,       NULL},
    {cszLabelReserved,    (PFMTHDR)&fmtHexWord,       NULL},
    {cszLabelReserved,    (PFMTHDR)&fmtHexWord,       NULL},
    {cszLabelReserved,    (PFMTHDR)&fmtHexWord,       NULL},
    {cszLabelReserved,    (PFMTHDR)&fmtHexWord,       NULL},
    {NULL,                NULL,                       NULL}
};

FMT afmtExCAHiRegs[] =
{
    {"MemWin0High=",      (PFMTHDR)&fmtHexByte,       NULL},
    {"MemWin1High=",      (PFMTHDR)&fmtHexByte,       NULL},
    {"MemWin2High=",      (PFMTHDR)&fmtHexByte,       NULL},
    {"MemWin3High=",      (PFMTHDR)&fmtHexByte,       NULL},
    {"MemWin4High=",      (PFMTHDR)&fmtHexByte,       NULL},
    {"CLIOWin0High=",     (PFMTHDR)&fmtHexByte,       NULL},
    {"CLIOWin1High=",     (PFMTHDR)&fmtHexByte,       NULL},
    {NULL,                NULL,                       NULL}
};

/***LP  ReadExCAByte - Read ExCA byte register
 *
 *  ENTRY
 *      dwBaseAddr - Base port address
 *      dwReg - register offset
 *
 *  EXIT
 *      returns data read
 */

BYTE ReadExCAByte(DWORD dwBaseAddr, DWORD dwReg)
{
    BYTE bData;
    ULONG ulSize;

    ulSize = sizeof(BYTE);
    WriteIoSpace(dwBaseAddr, dwReg, &ulSize);
    ulSize = sizeof(BYTE);
    ReadIoSpace(dwBaseAddr + 1, (PULONG)&bData, &ulSize);

    return bData;
}       //ReadExCAByte

/***LP  GetClassDesc - Get class description string
 *
 *  ENTRY
 *      bBaseClass - Base Class code
 *      bSubClass - Sub Class code
 *      bProgIF - Program Interface code
 *
 *  EXIT-SUCCESS
 *      returns pointer to description string
 *  EXIT-FAILURE
 *      returns NULL
 */

PSZ GetClassDesc(BYTE bBaseClass, BYTE bSubClass, BYTE bProgIF)
{
    char *psz = NULL;
    int i;
    static struct classtab_s
    {
        BYTE bBaseClass;
        BYTE bSubClass;
        BYTE bProgIF;
        PSZ  pszDesc;
    } ClassTable[] =
        {
            {0x00, 0xff, 0xff, "Legacy controller"},
            {0x00, 0x00, 0x00, "All legacy controller except VGA"},
            {0x00, 0x01, 0x00, "All legacy VGA device"},

            {0x01, 0xff, 0xff, "Mass storage controller"},
            {0x01, 0x00, 0x00, "SCSI bus controller"},
            {0x01, 0x01, 0xff, "IDE controller"},
            {0x01, 0x02, 0x00, "Floppy disk controller"},
            {0x01, 0x03, 0x00, "IPI bus controller"},
            {0x01, 0x04, 0x00, "RAID controller"},
            {0x01, 0x80, 0x00, "Other mass storage controller"},

            {0x02, 0xff, 0xff, "Network controller"},
            {0x02, 0x00, 0x00, "Ethernet controller"},
            {0x02, 0x01, 0x00, "Token ring controller"},
            {0x02, 0x02, 0x00, "FDDI controller"},
            {0x02, 0x03, 0x00, "ATM controller"},
            {0x02, 0x80, 0x00, "Other network controller"},

            {0x03, 0xff, 0xff, "Display controller"},
            {0x03, 0x00, 0x00, "VGA compatible controller"},
            {0x03, 0x00, 0x01, "8514 compatible controller"},
            {0x03, 0x01, 0x00, "XGA controller"},
            {0x03, 0x80, 0x00, "Other display controller"},

            {0x04, 0xff, 0xff, "Multimedia device"},
            {0x04, 0x00, 0x00, "Video device"},
            {0x04, 0x01, 0x00, "Audio device"},
            {0x04, 0x80, 0x00, "Other multimedia device"},

            {0x05, 0xff, 0xff, "Memory controller"},
            {0x05, 0x00, 0x00, "RAM controller"},
            {0x05, 0x01, 0x00, "Flash controller"},
            {0x05, 0x80, 0x00, "Other memory controller"},

            {0x06, 0xff, 0xff, "Bridge device"},
            {0x06, 0x00, 0x00, "Host bridge"},
            {0x06, 0x01, 0x00, "ISA bridge"},
            {0x06, 0x02, 0x00, "EISA bridge"},
            {0x06, 0x03, 0x00, "MCA bridge"},
            {0x06, 0x04, 0x00, "PCI-PCI bridge"},
            {0x06, 0x05, 0x00, "PCMCIA bridge"},
            {0x06, 0x06, 0x00, "NuBus bridge"},
            {0x06, 0x07, 0x00, "CardBus bridge"},
            {0x06, 0x80, 0x00, "Other bridge device"},

            {0x07, 0xff, 0xff, "Simple com device"},
            {0x07, 0x00, 0x00, "Generic XT compatible serial controller"},
            {0x07, 0x00, 0x01, "16450 compatible serial controller"},
            {0x07, 0x00, 0x02, "16550 compatible serial controller"},
            {0x07, 0x01, 0x00, "Parallel port"},
            {0x07, 0x01, 0x01, "Bidirectional parallel port"},
            {0x07, 0x01, 0x02, "ECP 1.X compliant parallel port"},
            {0x07, 0x80, 0x00, "Other communication device"},

            {0x08, 0xff, 0xff, "Base system peripherals"},
            {0x08, 0x00, 0x00, "Generic 8259 PIC"},
            {0x08, 0x00, 0x01, "ISA PIC"},
            {0x08, 0x00, 0x02, "EISA PIC"},
            {0x08, 0x01, 0x00, "Generic 8237 DMA controller"},
            {0x08, 0x01, 0x01, "ISA DMA controller"},
            {0x08, 0x01, 0x02, "EISA DMA controller"},
            {0x08, 0x02, 0x00, "Generic 8254 system timer"},
            {0x08, 0x02, 0x01, "ISA system timer"},
            {0x08, 0x02, 0x02, "EISA system timer"},
            {0x08, 0x03, 0x00, "Generic RTC controller"},
            {0x08, 0x03, 0x01, "ISA RTC controller"},
            {0x08, 0x80, 0x00, "Other system peripheral"},

            {0x09, 0xff, 0xff, "Input device"},
            {0x09, 0x00, 0x00, "Keyboard controller"},
            {0x09, 0x01, 0x00, "Digitizer (pen)"},
            {0x09, 0x02, 0x00, "Mouse controller"},
            {0x09, 0x80, 0x00, "Other input controller"},

            {0x0a, 0xff, 0xff, "Docking station"},
            {0x0a, 0x00, 0x00, "Generic docking station"},
            {0x0a, 0x80, 0x00, "Other type of docking station"},

            {0x0b, 0xff, 0xff, "Processor"},
            {0x0b, 0x00, 0x00, "386"},
            {0x0b, 0x01, 0x00, "486"},
            {0x0b, 0x02, 0x00, "Pentium"},
            {0x0b, 0x10, 0x00, "Alpha"},
            {0x0b, 0x20, 0x00, "PowerPC"},
            {0x0b, 0x40, 0x00, "Co-processor"},

            {0x0c, 0xff, 0xff, "Serial bus controller"},
            {0x0c, 0x00, 0x00, "FireWire (IEEE 1394)"},
            {0x0c, 0x01, 0x00, "ACCESS bus"},
            {0x0c, 0x02, 0x00, "SSA"},
            {0x0c, 0x03, 0x00, "Universal Serial Bus (USB)"},
            {0x0c, 0x04, 0x00, "Fibre Channel"},

            {0xff, 0xff, 0xff, "Unknown"},
            {0x00, 0x00, 0x00, NULL}
        };

    for (i = 0; ClassTable[i].pszDesc != NULL; ++i)
    {
        if ((ClassTable[i].bBaseClass == bBaseClass) &&
            (ClassTable[i].bSubClass == bSubClass) &&
            (ClassTable[i].bProgIF == bProgIF))
        {
            psz = ClassTable[i].pszDesc;
        }
    }

    return psz;
}       //GetClassDesc

/***LP  PrintClassInfo - Print device class info.
 *
 *  ENTRY
 *      pb -> ConfigSpace
 *      dwReg - ConfigSpace register
 *
 *  EXIT
 *      None
 */

VOID PrintClassInfo(PBYTE pb, DWORD dwReg)
{
    BYTE bBaseClass, bSubClass, bProgIF;
    PSZ psz;

    if (dwReg == CSOFFSET(BaseClass))
    {
        bBaseClass = pb[CSOFFSET(BaseClass)];
        bSubClass = 0xff;
        bProgIF = 0xff;
    }
    else if (dwReg == CSOFFSET(SubClass))
    {
        bBaseClass = pb[CSOFFSET(BaseClass)];
        bSubClass = pb[CSOFFSET(SubClass)];
        bProgIF = 0xff;
    }
    else        //must be CFGSPACE_CLASSCODE_PI
    {
        bBaseClass = pb[CSOFFSET(BaseClass)];
        bSubClass = pb[CSOFFSET(SubClass)];
        bProgIF = pb[CSOFFSET(ProgIf)];
    }

    if ((psz = GetClassDesc(bBaseClass, bSubClass, bProgIF)) != NULL)
        dprintf(" (%s)", psz);
    else if ((bBaseClass == 0x01) && (bSubClass == 0x01) && (bProgIF != 0xff) &&
             (bProgIF != 0x00))
    {
        dprintf(" (");
        if (bProgIF & 0x80)
            dprintf("MasterIDE ");
        if (bProgIF & 0x02)
            dprintf("PriNativeCapable ");
        if (bProgIF & 0x01)
            dprintf("PriNativeMode ");
        if (bProgIF & 0x08)
            dprintf("SecNativeCapable ");
        if (bProgIF & 0x04)
            dprintf("SecNativeMode");
        dprintf(")");
    }

    dprintf("\n");
}       //PrintClassInfo

VOID
DumpCfgSpace (
    IN PPCI_COMMON_CONFIG pcs
    )
{
    int rc = FERR_NONE;
    BYTE bHeaderType = pcs->HeaderType & ~PCI_MULTIFUNCTION;
    PFMT pafmt;
    DWORD dwOffset;
    PSZ pszDataFmt = "%02x: ";

    switch (bHeaderType)
    {
        case PCI_DEVICE_TYPE:
            pafmt = afmtCfgSpaceType0;
            break;

        case PCI_BRIDGE_TYPE:
            pafmt = afmtCfgSpaceType1;
            break;

        case PCI_CARDBUS_BRIDGE_TYPE:
            pafmt = afmtCfgSpaceType2;
            break;

        default:
            pafmt = afmtCfgSpaceUnknown;
    }

    dwOffset = 0;
    if (((rc = BinPrintf(NULL, afmtCfgSpaceCommon, (PBYTE)pcs, &dwOffset,
                         pszDataFmt)) == FERR_NONE) &&
        ((rc = BinPrintf(NULL, pafmt, (PBYTE)pcs, &dwOffset, pszDataFmt)) ==
         FERR_NONE))
    {
        if (bHeaderType != PCI_CARDBUS_BRIDGE_TYPE)
        {
            rc = BinPrintf(NULL, afmtCfgSpace40, (PBYTE)pcs, &dwOffset,
                           pszDataFmt);
        }

        if (rc == FERR_NONE)
        {
            rc = BinPrintf(NULL, afmtCfgSpace60, (PBYTE)pcs, &dwOffset,
                           pszDataFmt);
        }

        if ((rc == FERR_NONE) && (pcs->Status & PCI_STATUS_CAPABILITIES_LIST))
        {
            if (bHeaderType == PCI_DEVICE_TYPE)
            {
                dwOffset = pcs->u.type0.CapabilitiesPtr;
            }
            else if (bHeaderType == PCI_BRIDGE_TYPE)
            {
                dwOffset = pcs->u.type1.CapabilitiesPtr;
            }
            else if (bHeaderType == PCI_CARDBUS_BRIDGE_TYPE)
            {
                dwOffset = pcs->u.type2.CapabilitiesPtr;
            }
            else
            {
                dwOffset = 0;
            }

            while ((rc == FERR_NONE) && (dwOffset != 0))
            {
                PPCI_CAPABILITIES_HEADER pCap;

                pCap = (PPCI_CAPABILITIES_HEADER)&((PBYTE)pcs)[dwOffset];

                rc = BinPrintf(NULL,
                               afmtCapHeader,
                               (PBYTE)pcs,
                               &dwOffset,
                               pszDataFmt);

                if (rc == FERR_NONE)
                {
                    switch (pCap->CapabilityID)
                    {
                        case PCI_CAPABILITY_ID_POWER_MANAGEMENT:
                            rc = BinPrintf(NULL,
                                           afmtPwrMgmt,
                                           (PBYTE)pcs,
                                           &dwOffset,
                                           pszDataFmt);
                            break;

                        case PCI_CAPABILITY_ID_AGP:
                            rc = BinPrintf(NULL,
                                           afmtAGP,
                                           (PBYTE)pcs,
                                           &dwOffset,
                                           pszDataFmt);
                            break;

                        case PCI_CAPABILITY_ID_MSI:
                            rc = BinPrintf(NULL,
                                           afmtMSI,
                                           (PBYTE)pcs,
                                           &dwOffset,
                                           pszDataFmt);
                            if (rc == FERR_NONE)
                            {
                                PFMT pfmt;

                                if (((PCI_MSI_CAPABILITY *)pCap)->MessageControl.CapableOf64Bits)
                                {
                                    pfmt = afmtMSI64;
                                }
                                else
                                {
                                    pfmt = afmtMSI32;
                                }
                                rc = BinPrintf(NULL,
                                               pfmt,
                                               (PBYTE)pcs,
                                               &dwOffset,
                                               pszDataFmt);

                            }
                            break;
                    }

                    dwOffset = pCap->Next;
                }
            }
        }
    }

    if (rc != FERR_NONE)
    {
        dprintf("dump PCI ConfigSpace failed\n");
    }
}

/***LP  DumpCBRegs - Dump CardBus registers
 *
 *  ENTRY
 *      pbBuff -> register base
 *
 *  EXIT
 *      None
 */

VOID DumpCBRegs(PBYTE pbBuff)
{
    PSZ pszDataFmt = "%02x: ";

    if (BinPrintf(NULL, afmtCBRegs, pbBuff, NULL, pszDataFmt) != FERR_NONE)
    {
        dprintf("dump CardBus registers failed\n");
    }
}       //DumpCBRegs

/***LP  DumpExCARegs - Dump ExCA registers
 *
 *  ENTRY
 *      pbBuff -> buffer
 *      dwSize - size of buffer
 *
 *  EXIT
 *      None
 */

VOID DumpExCARegs(PBYTE pbBuff, DWORD dwSize)
{
    DWORD dwOffset = 0;
    char *pszDataFmt = "%02x: ";

    if (BinPrintf(NULL, afmtExCARegs, pbBuff, &dwOffset, pszDataFmt) !=
        FERR_NONE)
    {
        dprintf("dump ExCA registers failed\n");
    }
    else if ((dwSize > 0x40) &&
             (BinPrintf(NULL, afmtExCAHiRegs, pbBuff, &dwOffset, pszDataFmt) !=
              FERR_NONE))
    {
        dprintf("dump ExCA high registers failed\n");
    }
}       //DumpExCARegs

DECLARE_API( dcs )
/*++

Routine Description:

    Dumps PCI ConfigSpace

Arguments:

    args - Supplies the Bus.Dev.Fn numbers

Return Value:

    None

--*/
{
    LONG lcArgs;
    DWORD dwBus = 0;
    DWORD dwDev = 0;
    DWORD dwFn = 0;

    lcArgs = sscanf(args, "%lx.%lx.%lx", &dwBus, &dwDev, &dwFn);
    if (lcArgs != 3)
    {
        dprintf("invalid command syntax\n"
                "Usage: dcs <Bus>.<Dev>.<Func>\n");
    }
    else
    {
        PCI_TYPE1_CFG_BITS PciCfg1;
        PCI_COMMON_CONFIG  cs;

        PciCfg1.u.AsULONG = 0;
        PciCfg1.u.bits.BusNumber = dwBus;
        PciCfg1.u.bits.DeviceNumber = dwDev;
        PciCfg1.u.bits.FunctionNumber = dwFn;
        PciCfg1.u.bits.Enable = TRUE;

        ReadPci(&PciCfg1, (PUCHAR)&cs, 0, sizeof(cs));
        DumpCfgSpace(&cs);
    }
}

DECLARE_API( cbreg )
/*++

Routine Description:

    Dumps CardBus registers

Arguments:

    args - Supplies the address in hex.

Return Value:

    None

--*/
{
    BOOL rc = TRUE;
    LONG lcArgs;
    BOOL fPhysical = FALSE;
    DWORD dwAddr = 0;

    if (args == NULL)
    {
        dprintf("invalid command syntax\n"
                "Usage: cbreg <RegBaseAddr>\n");
        rc = FALSE;
    }
    else if ((args[0] == '%') && (args[1] == '%'))
    {
        lcArgs = sscanf(&args[2], "%lx", &dwAddr);
        fPhysical = TRUE;
    }
    else
    {
        lcArgs = sscanf(args, "%lx", &dwAddr);
    }

    if ((rc == TRUE) && (lcArgs == 1))
    {
        BYTE abCBRegs[0x14];
        BYTE abExCARegs[0x47];
        DWORD dwSize;

        if (fPhysical)
        {
            ULONG64 phyaddr = 0;

            phyaddr = dwAddr;
            ReadPhysical(phyaddr, abCBRegs, sizeof(abCBRegs), &dwSize);
            if (dwSize != sizeof(abCBRegs))
            {
                dprintf("failed to read physical CBRegs (SizeRead=%x)\n",
                        dwSize);
                rc = FALSE;
            }
            else
            {
                phyaddr += 0x800;
                ReadPhysical(phyaddr, abExCARegs, sizeof(abExCARegs), &dwSize);
                if (dwSize != sizeof(abExCARegs))
                {
                    dprintf("failed to read physical ExCARegs (SizeRead=%x)\n",
                            dwSize);
                    rc = FALSE;
                }
            }
        }
        else if (!ReadMemory(dwAddr, abCBRegs, sizeof(abCBRegs), &dwSize) ||
                 (dwSize != sizeof(abCBRegs)))
        {
            dprintf("failed to read CBRegs (SizeRead=%x)\n", dwSize);
            rc = FALSE;
        }
        else if (!ReadMemory(dwAddr + 0x800, abExCARegs, sizeof(abExCARegs),
                             &dwSize) ||
                 (dwSize != sizeof(abExCARegs)))
        {
            dprintf("failed to read CBRegs (SizeRead=%x)\n", dwSize);
            rc = FALSE;
        }

        if (rc == TRUE)
        {
            dprintf("\nCardBus Registers:\n");
            DumpCBRegs(abCBRegs);
            dprintf("\nExCA Registers:\n");
            DumpExCARegs(abExCARegs, sizeof(abExCARegs));
        }
    }
}

DECLARE_API( exca )
/*++

Routine Description:

    Dumps CardBus ExCA registers

Arguments:

    args - Supplies <BasePort>.<SktNum>

Return Value:

    None

--*/
{
    LONG lcArgs;
    DWORD dwBasePort = 0;
    DWORD dwSktNum = 0;

    lcArgs = sscanf(args, "%lx.%lx", &dwBasePort, &dwSktNum);
    if (lcArgs != 2)
    {
        dprintf("invalid command syntax\n"
                "Usage: exca <BasePort>.<SocketNum>\n");
    }
    else
    {
        int i;
        BYTE abExCARegs[0x40];

        for (i = 0; i < sizeof(abExCARegs); ++i)
        {
            abExCARegs[i] = ReadExCAByte(dwBasePort,
                                         (ULONG)(dwSktNum*0x40 + i));
        }

        DumpExCARegs(abExCARegs, sizeof(abExCARegs));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\kdexts\p_i386\help.c ===
#include "precomp.h"
#pragma hdrstop

#include "..\help.c"



VOID
SpecificHelp (
    VOID
    )
{
    dprintf("\n");
    dprintf("X86-specific:\n\n");
    dprintf("callback <address> [num]       - Dump callback frames for specified thread\n");
    dprintf("cxr                            - Dump context record at specified address\n");
    dprintf("dcs <Bus>.<Dev>.<Fn>           - Dump PCI ConfigSpace of device\n");
    dprintf("exca <BasePort>.<SktNum>       - Dump ExCA registers\n");
    dprintf("mtrr                           - Dumps MTTR\n");
    dprintf("npx [base]                     - Dumps NPX save area\n");
    dprintf("pci [flag] [bus] [device] [function] [rawdump:minaddr] [maxaddr] - Dumps pci type1 config\n");
    dprintf("    flag: 0x01 - verbose\n");
    dprintf("          0x02 - from bus 0 to 'bus'\n");
    dprintf("          0x04 - dump raw bytes\n");
    dprintf("          0x08 - dump raw dwords\n");
    dprintf("          0x10 - do not skip invalid devices\n");
    dprintf("          0x20 - do not skip invalid functions\n");
    dprintf("          0x40 - dump Capabilities if found\n");
    dprintf("          0x80 - dump device specific on VendorID:8086\n");
    dprintf("pcr                            - Dumps the PCR\n");
    dprintf("pic                            - Dumps PIC(8259) information\n");
    dprintf("pte                            - Dumps the corresponding PDE and PTE for the entered address\n");
    dprintf("sel [selector]                 - Examine selector values\n");
    dprintf("trap [base]                    - Dump trap frame\n");
    dprintf("tss [register]                 - Dump TSS\n");
    dprintf("\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\kdexts\p_i386\npx.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    trap.c

Abstract:

    WinDbg Extension Api

Author:

    Ken Reneris

Environment:

    User Mode.

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

typedef struct {
    ULONG   Mask;
    PUCHAR  String;
} BITENCODING, *PBITENCODING;

typedef unsigned __int64 ULONGLONG;

void  DumpNpxULongLong (PUCHAR s, ULONGLONG  l);
void  DumpNpxExtended  (PUCHAR str, PUCHAR Value);
void  DumpNpxBits      (ULONG, PUCHAR, PBITENCODING);

PUCHAR NpxPrecisionControl[] = { "24Bits", "?1?", "53Bits", "64Bits" };
PUCHAR NpxRoundingControl[]  = { "Nearest", "Down", "Up", "Chop" };
PUCHAR NpxTagWord[]          = { "  ", "ZR", "SP", "  " };

BITENCODING NpxStatusBits[]  = {
        1 <<  8,    "C0",
        1 <<  9,    "C1",
        1 << 10,    "C2",
        1 << 14,    "C3",
        0x8000,     "Busy",
        0x0001,     "InvalidOp",
        0x0002,     "Denormal",
        0x0004,     "ZeroDivide",
        0x0008,     "Overflow",
        0x0010,     "Underflow",
        0x0020,     "Precision",
        0x0040,     "StackFault",
        0x0080,     "Summary",
        0,          0
        };

PUCHAR  NpxOpD8[] = {
        "fadd",  "fmul",  "fcom",  "fcomp",  "fsub",   "fsubr",  "fdiv",   "fdivr"
        };

PUCHAR  NpxOpD9[] = {
        "fld",   "??3",   "fst",   "fstp",   "fldenv", "fldcw",  "fstenv", "fstcw"
        };

PUCHAR  NpxOpDA[] = {
        "fiadd", "fimul", "ficom", "ficomp", "fisub",  "fisubr", "fidiv",  "fidivr"
        };

PUCHAR  NpxOpDB[] = {
        "fild",  "??4",   "fist",  "fistp",  "??5",    "fld",    "??6",    "fstp"
        };

PUCHAR  NpxOpDF[] = {
        "fild",  "??4",   "fist",  "fistp",  "fbld",   "fild",   "fbstp",  "fstp"
        };

PUCHAR *NpxSmOpTable[] = {
    NpxOpD8,
    NpxOpD9,
    NpxOpDA,
    NpxOpDB,
    NpxOpD8,    // DC
    NpxOpD9,    // DD
    NpxOpDA,    // DE
    NpxOpDF
    };






DECLARE_API( npx )

/*++

Routine Description:

    Dumps FNSAVE area format of NPX state

Arguments:

    args -

Return Value:

    None

--*/

{
    ULONG               Address, bytesread;
    FLOATING_SAVE_AREA  FloatSave;
    UCHAR               s[300];
    PUCHAR              Stack, p;
    ULONG               i, j, t, tos, Tag;

    sscanf(args,"%lX", &Address);

    if ( !ReadMemory(
            Address,
            &FloatSave,
            sizeof (FloatSave),
            &bytesread ) ||
          bytesread < sizeof (FloatSave)) {

        dprintf("unable to read floating save area\n");
        return ;
    }

    dprintf ("EIP.......: %08x  ControlWord: %s-%s mask: %02x   Cr0NpxState: %08x\n",
        FloatSave.ErrorOffset,
        NpxPrecisionControl [(FloatSave.ControlWord >> 8)  & 0x3],
        NpxRoundingControl  [(FloatSave.ControlWord >> 10) & 0x3],
        FloatSave.ControlWord & 0x3f,
        FloatSave.Cr0NpxState
        );

    DumpNpxBits (FloatSave.StatusWord, s, NpxStatusBits);
    tos = (FloatSave.StatusWord >> 11) & 7,

    dprintf ("StatusWord: %04x TOS:%x %s  (tagword: %04x)\n",
        FloatSave.StatusWord & 0xffff,
        tos,
        s,
        FloatSave.TagWord & 0xffff
        );

    Stack = FloatSave.RegisterArea;
    Tag   = FloatSave.TagWord;
    for (i=0; i < 8; i++) {
        j = (tos + i) & 7;
        t = (Tag >> (j*2)) & 3;

        if (t != 3) {
            sprintf (s, "%x%c%s",
                j,
                j == tos ? '>' : '.',
                NpxTagWord [t]
                );

            DumpNpxExtended (s, Stack);
        }

        Stack += 10;    // next stack location
    }

    dprintf ("\n");
}


void  DumpNpxBits (
        ULONG           Value,
        PUCHAR          Str,
        PBITENCODING    Bits
    )
{
    BOOLEAN     Flag;

    Flag = FALSE;
    *Str = 0;

    while (Bits->Mask) {
        if (Bits->Mask & Value) {
            if (Flag) {
                Str += sprintf (Str, ", %s", Bits->String);
            } else {
                Str += sprintf (Str, "%s", Bits->String);
                Flag = TRUE;
            }
        }

        Bits += 1;
    }
}


void
DumpNpxULongLong (
    PUCHAR      s,
    ULONGLONG   l
    )
{
    UCHAR   c;
    UCHAR   t[80], *p;

    if (l == 0) {
        *(s++)= '0';
    }

    p = t;
    while (l) {
        c = (UCHAR) ((ULONGLONG) l % 10);
        *(p++) = c + '0';
        l /= 10;
    }

    while (p != t) {
        *(s++) = *(--p);
    }
    *(s++) = 0;
}

void
DumpNpxExtended (
    PUCHAR  str,
    PUCHAR  Value
    )
{
    UCHAR       *p, *o, c, out[100], t[100], ssig[100], ExponSign, SigSign;
    ULONG       i, indent, mag, scale;
    LONG        expon, delta;
    ULONGLONG   sig;

    p = Value;
    c = 0;
    o = out+90;
    indent = strlen (str) + 1;

    dprintf ("%s ", str);

    //
    // Build string of bits
    //

    *(--o) = 0;
    while (c < 80) {
        *(--o) = (*p & 0x01) + '0';
        *p >>= 1;
        c += 1;
        if ((c % 8) == 0) {
            p += 1;
        }
    }
    p = o;


    //dprintf (" %s\n", o);
    //dprintf ("%*s", indent, "");


    //
    // print bit string seperated into fields
    //

    p = o;
    //dprintf ("%c %15.15s 1%c%s\n", p[0], p+1, '.', p+1+15);
    //dprintf ("%*s", indent, "");

    //
    // Pull out exponent
    //

    expon = 0;
    p = o + 1;
    for (i=0; i < 15; i++) {
        expon *= 2;
        if (p[i] == '1') {
            expon += 1;
        }
    }

    expon -= 16383;                     // take out exponent bias

    //
    // Build sig into big #
    //

    p = o + 1+15;
    scale = 0;
    for (i=0; p[i]; i++) {
        if (p[i] == '1') {
            scale = i+1;
        }
    }
    SigSign = p[i-1] == '0' ? '+' : '-';

    sig = 0;
    for (i=0; i < scale; i++) {
        sig <<= 1;
        if (p[i] == '1') {
            sig += 1;
        }
    }

    delta = expon - (scale - 1);
    //dprintf ("delta %d, expon %d, scale %d\n", delta, expon, scale);

    //
    // Print values of each field
    //

    DumpNpxULongLong (ssig, sig);

    p = o;
    ExponSign = p[0] == '0' ? '+' : '-';
    dprintf ("%c %15.15s (%+5d) %c%c%s\n",
        ExponSign,
        p + 1,
        expon,
        p[1+15], '.', p+1+15+1
        );
    dprintf ("%*s", indent, "");

    if (expon == -16383) {
        if (SigSign == '+') {
            dprintf ("Denormal\n\n");
        } else {
            dprintf ("Pseudodenormal\n\n");
        }
        return ;
    }

    if (expon == 1024) {
        if (scale == 1) {
            dprintf ("%c Infinity\n", ExponSign);
        } else {

            p = o + 1+15;
            c = 0;
            for (i=0; p[i]; i++) {
                if (p[i] == '1') {
                    c++;
                }
            }

            if (SigSign == '+') {
                dprintf ("Signaling NaN\n");
            } else {
                if (c == 1) {
                    dprintf ("Indefinite - quite NaN\n");
                } else {
                    dprintf ("Quite NaN\n");
                }
            }
        }

        dprintf ("%*s", indent, "");
    }


    //dprintf ("%*s%c %15d %s    (delta %d)\n",
    //    indent, "",                     // indent
    //    p[0]    == '0' ? '+' : '-',     // sign of exponent
    //    expon, ssig,
    //    delta
    //    );
    //dprintf ("%*s", indent, "");

    t[0] = 0;
    p = t;
    if (delta < 0) {
        p += sprintf (p, "/ ");
        delta = -delta;
    } else if (delta > 0) {
        p += sprintf (p, "* ");
    }

    if (delta) {
        if (delta < 31) {
            p += sprintf (p, "%d", 1 << delta);
        } else {
            p += sprintf (p, "2^%d", delta);
        }
    }

    dprintf ("%s %s\n",
        ssig,
        t
        );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\kdexts\p_i386\mca.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    mca.c

Abstract:

    WinDbg Extension Api

Author:

    Shiv Kaushik

Environment:

    User Mode.

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

//
// External functions (debugger extensions) used here.
//

VOID
DumpCpuInfo(
    ULONG Processor,
    BOOLEAN DoMultiple
    );

//
// MCA MSR architecture definitions
//

//
// MSR addresses for Pentium Style Machine Check Exception
//

#define MCE_MSR_MC_ADDR                 0x0
#define MCE_MSR_MC_TYPE                 0x1

//
// MSR addresses for Pentium Pro Style Machine Check Architecture
// 

//
// Global capability, status and control register addresses
//

#define MCA_MSR_MCG_CAP             0x179     
#define MCA_MSR_MCG_STATUS          0x17a
#define MCA_MSR_MCG_CTL             0x17b

//
// Control, Status, Address, and Misc register address for 
// bank 0. Other bank registers are at a stride of MCA_NUM_REGS
// from corresponding bank 0 register.
//

#define MCA_NUM_REGS                4

#define MCA_MSR_MC0_CTL             0x400
#define MCA_MSR_MC0_STATUS          0x401
#define MCA_MSR_MC0_ADDR            0x402
#define MCA_MSR_MC0_MISC            0x403

//
// Flags used to determine if the MCE or MCA feature is 
// available. Used with HalpFeatureBits.
//

#define HAL_MCA_PRESENT         0x4
#define HAL_MCE_PRESENT         0x8

//
// Flags to decode errors in MCI_STATUS register of MCA banks
//

#define MCA_EC_NO_ERROR          0x0000
#define MCA_EC_UNCLASSIFIED      0x0001
#define MCA_EC_ROMPARITY         0x0002
#define MCA_EC_EXTERN            0x0003
#define MCA_EC_FRC               0x0004

#include "pshpack1.h"

//                              
// Global Machine Check Capability Register
//

typedef struct _MCA_MCG_CAPABILITY {
    union {
        struct {
            ULONG       McaCnt:8;
            ULONG       McaCntlPresent:1;
            ULONG       Reserved_1: 23;
            ULONG       Reserved_2;
        } hw;
        ULONGLONG       QuadPart;
    } u; 
} MCA_MCG_CAPABILITY, *PMCA_MCG_CAPABILITY;

//                              
// Global Machine Check Status Register
//

typedef struct _MCA_MCG_STATUS {
    union {
        struct {
            ULONG       RestartIPValid:1;
            ULONG       ErrorIPValid:1;
            ULONG       McCheckInProgress:1;
            ULONG       Reserved_1:29;
            ULONG       Reserved_2;
        } hw;

        ULONGLONG       QuadPart;
    } u; 
} MCA_MCG_STATUS, *PMCA_MCG_STATUS;

// 
// MCA COD field in status register for interpreting errors
//

typedef struct _MCA_COD {
    union {
        struct {
            USHORT  Level:2;
            USHORT  Type:2;
            USHORT  Request:4;
            USHORT  BusErrInfo:4;
            USHORT  Other:4;
        } hw;

        USHORT ShortPart;
    } u;
} MCA_COD, *PMCA_COD;

//                              
// STATUS register for each MCA bank.
//

typedef struct _MCA_MCI_STATUS {
    union {
        struct {
            MCA_COD     McaCod;
            USHORT      MsCod;
            ULONG       OtherInfo:25;
            ULONG       Damage:1;
            ULONG       AddressValid:1;
            ULONG       MiscValid:1;
            ULONG       Enabled:1;
            ULONG       UnCorrected:1;
            ULONG       OverFlow:1;
            ULONG       Valid:1;
        } hw;
        ULONGLONG       QuadPart;
    } u; 
} MCA_MCI_STATUS, *PMCA_MCI_STATUS;

//
// ADDR register for each MCA bank
//

typedef struct _MCA_MCI_ADDR{
    union {
        struct {
            ULONG Address;
            ULONG Reserved;
        } hw;
        ULONGLONG       QuadPart;
    } u;
} MCA_MCI_ADDR, *PMCA_MCI_ADDR;
    
#include "poppack.h"

//
// Machine Check Error Description
//

// Any Reserved/Generic entry

CHAR Reserved[] = "Reserved";
CHAR Generic[] = "Generic";

// Transaction Types

CHAR TransInstruction[] = "Instruction";
CHAR TransData[] = "Data";

static CHAR *TransType[] = {TransInstruction,
                            TransData,
                            Generic,
                            Reserved
                            };

// Level Encodings

CHAR Level0[] = "Level 0";
CHAR Level1[] = "Level 1";
CHAR Level2[] = "Level 2";

static CHAR *Level[] = { 
                        Level0,
                        Level1,
                        Level2,
                        Generic
                        };
                        
// Request Encodings

CHAR ReqGenericRead[]  = "Generic Read";
CHAR ReqGenericWrite[] = "Generic Write";
CHAR ReqDataRead[]     = "Data Read";
CHAR ReqDataWrite[]    = "Data Write";
CHAR ReqInstrFetch[]   = "Instruction Fetch";
CHAR ReqPrefetch[]     = "Prefetch";
CHAR ReqEviction[]     = "Eviction";
CHAR ReqSnoop[]        = "Snoop";

static CHAR *Request[] = {
                          Generic,
                          ReqGenericRead,
                          ReqGenericWrite,
                          ReqDataRead,
                          ReqDataWrite,
                          ReqInstrFetch,
                          ReqPrefetch,
                          ReqEviction,
                          ReqSnoop,
                          Reserved,
                          Reserved,
                          Reserved,
                          Reserved,
                          Reserved,
                          Reserved,
                          Reserved
                          };

// Memory Hierarchy Error Encodings

CHAR MemHierMemAccess[] = "Memory Access";
CHAR MemHierIO[]        = "I/O";
CHAR MemHierOther[]     = "Other Transaction";

static CHAR *MemoryHierarchy[] = {
                                  MemHierMemAccess,
                                  Reserved,
                                  MemHierIO,
                                  MemHierOther
                                };

// Time Out Status 

CHAR TimeOut[] = "Timed Out";
CHAR NoTimeOut[] = "Did Not Time Out";

static CHAR *TimeOutCode[] = {
                          NoTimeOut,
                          TimeOut
                          };      

// Participation Status

CHAR PartSource[] = "Source";
CHAR PartResponds[] = "Responds";
CHAR PartObserver[] = "Observer";

static CHAR *ParticipCode[] = {
                                PartSource,
                                PartResponds,
                                PartObserver,
                                Generic
                              };

VOID
DecodeError (
    IN MCA_MCI_STATUS MciStatus
    )
/*++

Routine Description:

    Decode the machine check error logged to the status register
    Model specific errors are not decoded.

Arguments:

    MciStatus: Contents of Machine Check Status register

Return Value:

    None

--*/
{
    MCA_COD McaCod;

    McaCod = MciStatus.u.hw.McaCod;

    //
    // Decode Errors: First identify simple errors and then 
    // handle compound errors as default case
    //

    switch(McaCod.u.ShortPart) {
        case MCA_EC_NO_ERROR: 
            dprintf("\t\tNo Error\n");
            break;

        case MCA_EC_UNCLASSIFIED:
            dprintf("\t\tUnclassified Error\n");
            break;

        case MCA_EC_ROMPARITY:
            dprintf("\t\tMicrocode ROM Parity Error\n");
            break;

        case MCA_EC_EXTERN:
            dprintf("\t\tExternal Error\n");
            break;

        case MCA_EC_FRC:
            dprintf("\t\tFRC Error\n");
            break;

        default:        // check for complex error conditions
        
            if (McaCod.u.hw.BusErrInfo == 0x4) {
                dprintf("\t\tInternal Unclassified Error\n");
            } else if (McaCod.u.hw.BusErrInfo == 0) {
                
                // TLB Unit Error

                dprintf("\t\t%s TLB %s Error\n",
                         TransType[McaCod.u.hw.Type],
                         Level[McaCod.u.hw.Level]);
                                 
            } else if (McaCod.u.hw.BusErrInfo == 1) {

                // Memory Unit Error

                dprintf("\t\t%s Cache %s %s Error\n",
                        TransType[McaCod.u.hw.Type],
                        Level[McaCod.u.hw.Level],
                        Request[McaCod.u.hw.Request]);
            } else if (McaCod.u.hw.BusErrInfo >= 8) {
                
                // Bus/Interconnect Error

                dprintf("\t\tBus %s, Local Processor: %s, %s Error\n",
                        Level[McaCod.u.hw.Level],
                        ParticipCode[((McaCod.u.hw.BusErrInfo & 0x6)>>1)],
                        Request[McaCod.u.hw.Request]);
                dprintf("%s Request %s\n",
                        MemoryHierarchy[McaCod.u.hw.Type],
                        TimeOutCode[McaCod.u.hw.BusErrInfo & 0x1]);
            } else {
                dprintf("\t\tUnresolved compound error code\n");
            }
            break;
    }
}


DECLARE_API( mca )
/*++

Routine Description:

    Dumps processors machine check architecture registers
    and interprets any logged errors

Arguments:

    args - none

Return Value:

    None

--*/
{
    MCA_MCG_CAPABILITY  Capabilities;
    MCA_MCG_STATUS      McgStatus;
    MCA_MCI_STATUS      MciStatus;
    MCA_MCI_ADDR        MciAddress;
    ULONGLONG           MciControl;
    ULONGLONG           MciMisc;
    ULONG               Index,i;
    PUCHAR              p;
    ULONG               FeatureBits;
    ULONG               Cr4Value;
    BOOLEAN             Cr4MCEnabled = FALSE;
    ULONGLONG           MachineCheckAddress, MachineCheckType;
    
    //
    // Quick sanity check for Machine Check availability.
    // Support included for both Pentium Style MCE and Pentium
    // Pro Style MCA.
    //

    i = 0;
    sscanf(args,"%lX",&i);

    if (i != 1) {
        i = (ULONG) GetExpression("hal!HalpFeatureBits");
        if (!i) {
            dprintf ("HalpFeatureBits not found\n");
            return;
        }

        FeatureBits = 0;
        ReadMemory(i, &FeatureBits, sizeof(i), &i);
        if (FeatureBits == -1  ||  
            (!(FeatureBits & HAL_MCA_PRESENT) && 
             !(FeatureBits & HAL_MCE_PRESENT))) {
            dprintf ("Machine Check feature not present\n");
            return;
        }
    }

    //
    // Read cr4 to determine if CR4.MCE is enabled. 
    // This enables the Machine Check exception reporting
    //

    Cr4Value = GetExpression("@Cr4");
    if (Cr4Value & CR4_MCE) {
        Cr4MCEnabled = TRUE;
    }

    if (FeatureBits & HAL_MCE_PRESENT) {
        
        // Read P5_MC_ADDR Register and P5_MC_TYPE Register

        ReadMsr(MCE_MSR_MC_ADDR, &MachineCheckAddress);
        ReadMsr(MCE_MSR_MC_TYPE, &MachineCheckType);
        
        dprintf ("MCE: %s, Cycle Address: 0x%.8x%.8x, Type: 0x%.8x%.8x\n\n",
                (Cr4MCEnabled ? "Enabled" : "Disabled"),
                (ULONG)(MachineCheckAddress >> 32),
                (ULONG)(MachineCheckAddress),
                (ULONG)(MachineCheckType >> 32),
                (ULONG)(MachineCheckType));
    }
    
    if (FeatureBits & HAL_MCA_PRESENT) {

        //
        // Dump MCA registers
        //

        ReadMsr(MCA_MSR_MCG_CAP, &Capabilities.u.QuadPart);
        ReadMsr(MCA_MSR_MCG_STATUS, &McgStatus.u.QuadPart);

        dprintf ("MCA: %s, Banks %d, Control Reg: %s, Machine Check: %s.\n",
                 (Cr4MCEnabled ? "Enabled" : "Disabled"),
                 Capabilities.u.hw.McaCnt,
                 Capabilities.u.hw.McaCntlPresent ? "Supported" : "Not Supported",
                 McgStatus.u.hw.McCheckInProgress ? "In Progress" : "None"
        );

       if (McgStatus.u.hw.McCheckInProgress && McgStatus.u.hw.ErrorIPValid) {
        dprintf ("MCA: Error IP Valid\n");
        }
   
       if (McgStatus.u.hw.McCheckInProgress && McgStatus.u.hw.RestartIPValid) {
        dprintf ("MCA: Restart IP Valid\n");
        }

        //
        // Scan all the banks to check if any machines checks have been
        // logged and decode the errors if any.
        //
    
        dprintf ("Bank  Error  Control Register     Status Register\n");
        for (Index=0; Index < (ULONG) Capabilities.u.hw.McaCnt; Index++) {

            ReadMsr(MCA_MSR_MC0_CTL+MCA_NUM_REGS*Index, &MciControl);
            ReadMsr(MCA_MSR_MC0_STATUS+MCA_NUM_REGS*Index, &MciStatus.u.QuadPart);

            dprintf (" %2d.  %s  0x%.8x%.8x   0x%.8x%.8x\n", 
                        Index,
                        (MciStatus.u.hw.Valid ? "Valid" : "None "),
                        (ULONG) (MciControl >> 32),
                        (ULONG) (MciControl),
                        (ULONG) (MciStatus.u.QuadPart>>32),
                        (ULONG) (MciStatus.u.QuadPart)
                        );

            if (MciStatus.u.hw.Valid) {
                DecodeError(MciStatus);
            }

            if (MciStatus.u.hw.AddressValid) {
                ReadMsr(MCA_MSR_MC0_ADDR+MCA_NUM_REGS*Index, &MciAddress.u.QuadPart);
                dprintf ("\t\tAddress Reg 0x%.8x%.8x ", 
                            (ULONG) (MciAddress.u.QuadPart>>32),
                            (ULONG) (MciAddress.u.QuadPart)
                        );
            }

            if (MciStatus.u.hw.MiscValid) {
                ReadMsr(MCA_MSR_MC0_MISC+MCA_NUM_REGS*Index, &MciMisc);
                dprintf ("\t\tMisc Reg 0x%.8x%.8x ", 
                            (ULONG) (MciMisc >> 32),
                            (ULONG) (MciMisc)
                        );
                }
            dprintf("\n");
        }
    }

    //
    // Display stepping information for all processors.
    //

    DumpCpuInfo(0, TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\kdexts\p_i386\exsup.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    exsup.c

Abstract:

    x86 specific exception handler interpreter functions for
    WinDbg Extension Api

Author:

    Kent Forschmiedt (kentf)

Environment:

    User Mode.

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

VOID
InterpretExceptionData(
    PLAST_EXCEPTION_LOG LogRecord,
    PVOID *Terminator,
    PVOID *Filter,
    PVOID *Handler
    )
/*++

Routine Description:

    This will examine the exception handler data from an exception
    log entry, and find the address of the handler.  If it is a C or
    C++ handler, it will find the scope table for the frame and
    return the filter and handler values for scope that was active
    at the time the exception was dispatched.  The log data are from
    the frame based handler, so we cannot tell what happened within
    the frame, we can only see the entry scope and the final disposition
    from the frame.

Arguments:

    LogRecord - Supplies a record as logged by the exception dispatcher.

    Terminator - Returns the address of the termination or "finally"
        clause for a C/C++ try/finally construct.

    Filter - Returns the address of the filter clause from a C/C++ try/except.

    Handler - Returns the address of the handler.  If the frame-based handler
        is the C/C++ handler, this is the address of the except clause.  If
        it was not the C/C++ handler, the address of the frame-based handler
        is returned, and Filter will return -1.

Return Value:


--*/
{
    ULONG HandlerAddress;
    ULONG ScopeIndex;
    UCHAR Buffer[100];
    ULONG ScopeTable;
    PVOID ScopeTableEntry[3];
    ULONG cb;

    // record 0 points to the next chain entry
    HandlerAddress = LogRecord->HandlerData[1];
    ScopeTable = LogRecord->HandlerData[2];
    ScopeIndex = LogRecord->HandlerData[3];


    //
    // if the handler is the c or c++ exception handler,
    // there is a scope table of a known format.  Otherwise,
    // this is probably a handler in some assembly code,
    // and we have no idea what the data might be.  In that
    // case, just show the handler address and be done with it.
    //

    // Magic!!
    if (ReadMemory(HandlerAddress-8, Buffer, 8, &cb) && cb == 8) {

        if ( strncmp(Buffer+4, "XC00", 4) == 0 ) {

            if ( strncmp(Buffer, "VC10", 4) == 0 ||
                 strncmp(Buffer, "VC20", 4) == 0 ) {

                if (ScopeIndex == 0xffffffff) {
                    *Terminator = (PVOID)-1;
                    *Filter = (PVOID)-1;
                    *Handler = (PVOID)-1;
                    return;
                } else if (ReadMemory(ScopeTable + 3*ScopeIndex*sizeof(ULONG),
                                     ScopeTableEntry,
                                     3 * sizeof(ULONG),
                                     &cb) &&
                            cb == (3 * sizeof(ULONG))) {
                    *Terminator = ScopeTableEntry[0];
                    *Filter = ScopeTableEntry[1];
                    *Handler = ScopeTableEntry[2];
                    return;
                }
            }
        }
    }

    *Terminator = (PVOID)-1;
    *Filter = (PVOID)-1;
    *Handler = (PVOID)HandlerAddress;

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\kdexts\p_i386\pic.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    pic.c

Abstract:

    WinDbg Extension Api

Author:

    Santosh Jodh (santoshj) 29-June-1998

Environment:

    User Mode.

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#define PIC_MASTER_PORT0    0x20
#define PIC_MASTER_PORT1    0x21

#define PIC_SLAVE_PORT0     0xA0
#define PIC_SLAVE_PORT1     0xA1


VOID
ShowMask (
    ULONG  Mask
    )
{
    ULONG interrupt;
    
    for (   interrupt = 0;
            interrupt <= 0x0F;
            interrupt++)
    {
        if (Mask & (1 << interrupt))        
            dprintf("  Y");                    
        else
            dprintf("  .");
    }
    
    dprintf("\n");
}

BOOLEAN
GetPICStatus (
    UCHAR   Type,
    PULONG  Status
    )
{
    ULONG   size;
    ULONG   data;
    ULONG   mask;
    
    //
    // Send OCW3 to master.
    //
    
    size = 1;
    WriteIoSpace(PIC_MASTER_PORT0, Type, &size);

    //
    // Read master's status.
    //
    
    data = 0;
    size = 1;
    ReadIoSpace(PIC_MASTER_PORT0, &data, &size);
    if (size == 1)
    {
        //
        // Send OCW3 to slave.
        //
        
        mask = data;
        size = 1;
        WriteIoSpace(PIC_SLAVE_PORT0, Type, &size);

        //
        // Get the slave's status.
        //
        
        data = 0;
        size = 1;
        ReadIoSpace(PIC_SLAVE_PORT0, &data, &size);
        if (size == 1)
        {
            mask |= (data << 8);
            *Status = mask;

            return (TRUE);
        }
    }

    *Status = 0;
    
    return (FALSE);
}

DECLARE_API(pic)

/*++

Routine Description:

    Dumps PIC information.

Input Parameters:

    args - Supplies the options.

Return Value:

    None

--*/

{
    ULONG   data;
    ULONG   size;
    ULONG   mask;
    
    //
    // Display the title.
    //

    dprintf("----- IRQ Number ----- 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F\n");

    //
    // Dump the Interrupt Service Register information.
    //

    dprintf("Physically in service:");
    
    if (GetPICStatus(0x0B, &mask))
    {
        ShowMask(mask);
    }
    else
    {
        dprintf("Error reading PIC!\n");
    }
    

    //
    // Dump the Interrupt Mask Register information.
    //

    dprintf("Physically masked:    ");

    data = 0;
    size = 1;
    ReadIoSpace(PIC_MASTER_PORT1, &data, &size);
    if (size == 1)
    {
        mask = data;
        data = 0;
        size = 1;
        ReadIoSpace(PIC_SLAVE_PORT1, &data, &size);
        if (size == 1)
        {
            mask |= (data << 8);
            ShowMask(mask);    
        }
        else
        {
            dprintf("Error reading PIC!\n");    
        }
    }
    else
    {
        dprintf("Error reading PIC!\n");    
    }

    
    //
    // Dump the Interrupt Request Register information.
    //

    dprintf("Physically requested: ");

    if (GetPICStatus(0x0A, &mask))
    {
        ShowMask(mask);
    }
    else
    {
        dprintf("Error reading PIC!\n");
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\kdexts\p_i386\precomp.h ===
#define _NTSYSTEM_
#include "api.h"
#include "x86api.h"
#include <pci.h>
#define USE_CRUNTIME
#include "dumpstru.h"
#define CARDBUS
#include "pcskthw.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\kdexts\p_i386\pci.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    pci.c

Abstract:

    WinDbg Extension Api

Author:

    Ken Reneris (kenr) 18-August-1997

Environment:

    User Mode.

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop


#define DUMP_VERBOSE                    0x01
#define DUMP_TO_MAX_BUS                 0x02        // from 0 to max
#define DUMP_RAW_BYTES                  0x04        // hex dump dump raw bytes
#define DUMP_RAW_DWORDS                 0x08        // hex dump dump raw dwords

#define DUMP_ALLOW_INVALID_DEVICE       0x10
#define DUMP_ALLOW_INVALID_FUNCTION     0x20
#define DUMP_CAPABILITIES               0x40
#define DUMP_INTEL                      0x80




#define ANY                 0xFF

struct {
    UCHAR   BaseClass;
    UCHAR   SubClass;
    UCHAR   ProgIf;
    PUCHAR  Desc;
} ClassCode[] = {
    0,      1,      ANY,    "VGA controller",

    1,      0,      ANY,    "SCSI controller",
    1,      1,      ANY,    "IDE controller",
    1,      2,      ANY,    "Floppy controller",
    1,      2,      ANY,    "IPI controller",
    1,      4,      ANY,    "RAID controller",
    1,      0x80,   ANY,    "Mass storage controller",

    2,      0,      ANY,    "Ethernet",
    2,      1,      ANY,    "Token Ring controller",
    2,      2,      ANY,    "FDDI controller",
    2,      3,      ANY,    "ATM controller",
    2,      0x80,   ANY,    "Network controller",

    3,      0,      0,      "VGA compatible controller",
    3,      0,      1,      "8514 compatible controller",
    3,      0,      ANY,    "Video controller",
    3,      1,      ANY,    "XGA controller",
    3,      0x80,   ANY,    "Display controller",

    4,      0,      ANY,    "Video device",
    4,      1,      ANY,    "Audio device",
    4,      0x80,   ANY,    "Multimedia device",

    5,      0,      ANY,    "RAM",
    5,      1,      ANY,    "Flash",
    5,      0x80,   ANY,    "Memory controller",

    6,      0,      ANY,    "Host bridge",
    6,      1,      ANY,    "ISA bridge",
    6,      2,      ANY,    "EISA bridge",
    6,      3,      ANY,    "MCA bridge",
    6,      4,      ANY,    "PCI-PCI bridge",
    6,      5,      ANY,    "PCMCIA bridge",
    6,      6,      ANY,    "NuBus bridge",
    6,      7,      ANY,    "Cardbus bridge",
    6,      8,      ANY,    "Bridge device",

    7,      0,      0,      "XT serial controller",
    7,      0,      1,      "16540 serial controller",
    7,      0,      2,      "16540 serial controller",
    7,      1,      0,      "Parrallel port",
    7,      1,      1,      "Bi-directional parallel port",
    7,      1,      2,      "ECP 1.x parallel port",

    0xA,    0,      ANY,    "Generic docking station",

    0xC,    0,      ANY,    "1394 host controller",
    0xC,    1,      ANY,    "Access bus host controller",
    0xC,    2,      ANY,    "SSA host controller",
    0xC,    3,      ANY,    "USB host controller",
    0xC,    4,      ANY,    "Fibre Channel host controller",

    ANY,    ANY,    ANY,     NULL
};

UCHAR PCIDeref[4][4] = { {4,1,2,2},{1,1,1,1},{2,1,2,2},{1,1,1,1} };

VOID
HexDump (
    IN ULONG    indent,
    IN ULONG    va,
    IN ULONG    len,
    IN ULONG    width,
    IN PUCHAR   buf
    )
{
    UCHAR   s[80], t[80];
    PUCHAR  ps, pt;
    ULONG   i;
    static  UCHAR rgHexDigit[] = "0123456789abcdef";

    i = 0;

    //
    // If width = 4, dull dump, similar to debugger's dd command.
    //

    if (width == 4) {
        if (len & 3) {
            dprintf("hexdump internal error, dump dword, (len & 3) != 0\n");

            // round up.

            len += 3;
            len &= ~3;
        }
        while (len) {
            if (i == 0) {
                dprintf("%*s%08x: ", indent, "", va);
                va += 16;
            }
            dprintf(" %08x", *(UNALIGNED PULONG)buf);
            len -= 4;
            buf += 4;
            if (i == 3) {
                dprintf("\n");
                i = 0;
            } else {
                i++;
            }
        }
        return;
    }

    if (width != 1) {
        dprintf ("hexdump internal error\n");
        return ;
    }

    //
    // Width = 1, pretty dump, similar to debugger's db command.
    //

    while (len) {
        ps = s;
        pt = t;

        ps[0] = 0;
        pt[0] = '*';
        pt++;

        for (i=0; i < 16; i++) {
            ps[0] = ' ';
            ps[1] = ' ';
            ps[2] = ' ';

            if (len) {
                ps[0] = rgHexDigit[buf[0] >> 4];
                ps[1] = rgHexDigit[buf[0] & 0xf];
                pt[0] = buf[0] < ' ' || buf[0] > 'z' ? '.' : buf[0];

                len -= 1;
                buf += 1;
                pt  += 1;
            }
            ps += 3;
        }

        ps[0] = 0;
        pt[0] = '*';
        pt[1] = 0;
        s[23] = '-';

        if (s[0]) {
            dprintf ("%*s%08lx: %s  %s\n", indent, "", va, s, t);
            va += 16;
        }
    }

}

VOID
ReadPci (
    IN PPCI_TYPE1_CFG_BITS      PciCfg1,
    OUT PUCHAR                  Buffer,
    IN ULONG                    Offset,
    IN ULONG                    Length
    )
{
    ULONG                   InputSize;
    ULONG                   IoSize;
    ULONG                   i;

    //
    // Zap input buffer
    //

    for (i=0; i < Length; i++) {
        Buffer[i] = 0xff;
    }

    //
    // Read it
    //

    while (Length) {
        PciCfg1->u.bits.RegisterNumber = Offset / sizeof(ULONG);
        IoSize = sizeof(ULONG);
        WriteIoSpace ((ULONG) PCI_TYPE1_ADDR_PORT, PciCfg1->u.AsULONG, &IoSize );

        IoSize = PCIDeref[Offset % sizeof(ULONG)][Length % sizeof(ULONG)];
        i = IoSize;

        ReadIoSpace (
            PCI_TYPE1_DATA_PORT + (Offset % sizeof(ULONG)),
            (PULONG) Buffer,
            &i
            );

        Offset += IoSize;
        Buffer += IoSize;
        Length -= IoSize;
    }
}

VOID
DumpPciBar (
    IN ULONG        barno,
    IN ULONG        indent,
    IN ULONG        bar,
    IN OUT PULONG   state
    )
{
    ULONG       type, i;
    UCHAR       m[20], str[80];

    if (bar) {

        if (bar & 1) {
            sprintf (str, "IO[%d]:%x  ", barno, bar);

        } else {
            type = (bar >> 1) & 0x3;

            if (bar & 8) {
                strcpy (m, "MPF");
            } else {
                strcpy (m, "MEM");
            }

            if (type == 0x01) {
                m[1] = '1';         // less then 1M
            }

            sprintf (str, "%s[%d]:%x  ", m, barno, bar);

            if (type == 0x10) {
                dprintf ("bugbug - 64bit bar not decoded\n");
                *state = 0;
            }
            if (type == 0x11) {
                dprintf ("bar type is reserved\n");
                *state = 0;
            }
        }

        if (!*state) {
            dprintf ("%*s", indent, "");
        }

        i = strlen(str);
        dprintf("%s%*s", str, 17-i, "");
        *state += i;
    }
}


VOID
DumpPciType2Bar(
    IN BOOLEAN    barIsIo,
    IN BOOLEAN    barIsBase,
    IN ULONG      barno,
    IN ULONG      indent,
    IN ULONG      bar,
    IN OUT PULONG state
    )
{
   ULONG      i;
   UCHAR      str[80];
   if (bar) {
     if (barIsIo) {
          sprintf (str, "IO[%d].%s:%x  ", barno, (barIsBase?"base":"limit"), bar);
     } else {
          sprintf (str, "MEM[%d].%s:%x  ", barno, (barIsBase?"base":"limit"), bar);
     }
     if (!*state) {
          dprintf("%*s", indent, "");
     }
     i = strlen(str);
     dprintf("%s%*s", str, 17-i, "");
     *state += i;
   }
}
    
               
VOID
DumpPciBarComplete(
    IN OUT PULONG   state
    )
{
    if (*state) {
        dprintf ("\n");
        *state = 0;
    }
}


VOID
DumpCapabilities(
    IN UCHAR                    CapPtr,
    IN PPCI_TYPE1_CFG_BITS      PciCfg1
    )
{
    union _cap_buffer {
        PCI_CAPABILITIES_HEADER header;
        PCI_PM_CAPABILITY       pm;
        PCI_AGP_CAPABILITY      agp;
    } cap;

    PUCHAR ts;
    ULONG  t;

    do {
        if (CapPtr < PCI_COMMON_HDR_LENGTH) {

            dprintf("       Error: Capability pointer 0x%02x points to common header (invalid).\n",
                CapPtr
                );
            break;
        }

        if (CapPtr & 0x3) {

            dprintf("       Error: Capability pointer 0x%02x not DWORD aligned (invalid).\n",
                CapPtr
                );
            break;
        }

        ReadPci (
            PciCfg1,
            (PUCHAR)&cap,
            CapPtr,
            sizeof(cap.header)
            );

        switch (cap.header.CapabilityID) {
            case PCI_CAPABILITY_ID_POWER_MANAGEMENT:

                ReadPci (
                    PciCfg1,
                    (PUCHAR)&cap,
                    CapPtr,
                    sizeof(cap.pm)
                    );
                t = cap.pm.PMC.AsUSHORT;
                dprintf("      Cap[%02x] ID %02x \n",
                    CapPtr,
                    cap.header.CapabilityID
                    );
                dprintf("          PMC   %04x (%s%s%s%s%s%s %s%s%s%s%s%sv%x)\n",
                    t,
                    t & 0xf800 ? "PME from D" : "<No PME>",
                    t & 0x8000 ? "3C" : "",
                    t & 0x4000 ? "3H" : "",
                    t & 0x2000 ? "2" : "",
                    t & 0x1000 ? "1" : "",
                    t & 0x0800 ? "0" : "",
                    t & 0x0600 ? "Supports D" : "",
                    cap.pm.PMC.Capabilities.Support.D2 ? "2" : "",
                    cap.pm.PMC.Capabilities.Support.D1 ? "1" : "",
                    t & 0x0600 ? " " : "",
                    cap.pm.PMC.Capabilities.DeviceSpecificInitialization ?
                        "DSI " : "",
                    cap.pm.PMC.Capabilities.PMEClock ? "PME needs Clock, " : "",
                    cap.pm.PMC.Capabilities.Version
                    );
                        
                t &= 0x01d0;
                if (t) {
                    dprintf("                         WARNING PMC non-zero reserved fields %04x\n",
                        t
                        );
                }

                t = cap.pm.PMCSR.AsUSHORT;
                dprintf("          PMCSR %04x (PME_Status=%d PME_En=%d State=D%d%s)\n",
                    t,
                    cap.pm.PMCSR.ControlStatus.PMEStatus,
                    cap.pm.PMCSR.ControlStatus.PMEEnable,
                    cap.pm.PMCSR.ControlStatus.PowerState,
                    cap.pm.PMCSR.ControlStatus.PowerState == 3 ?
                        "hot" : ""
                    );

                //
                // Here would be a good time to run
                // run down the data registers if
                // they exist.
                //

                break;

            case PCI_CAPABILITY_ID_AGP:

                ReadPci (
                    PciCfg1,
                    (PUCHAR)&cap,
                    CapPtr,
                    sizeof(cap.agp)
                    );

                switch (cap.agp.AGPStatus.Rate) {
                    case 1:
                        ts = "1X";
                        break;
                    case 2:
                        ts = "2X";
                        break;
                    case 3:
                        ts = "1,2X";
                        break;
                    default:
                        ts = "<inv>";
                        break;
                }
                t = *(PULONG)&cap.agp.AGPStatus;

                dprintf("      Cap[%02x] ID %02x AGP mj/mn=%x/%x\n",
                    CapPtr,
                    cap.header.CapabilityID,
                    cap.agp.Major,
                    cap.agp.Minor
                    );

                dprintf("          Status  %08x (Rq:%02x SBA:%x Rate:%x (%s))\n",
                    t,
                    cap.agp.AGPStatus.RequestQueueDepthMaximum,
                    cap.agp.AGPStatus.SideBandAddressing,
                    cap.agp.AGPStatus.Rate,
                    ts
                    );

                switch (cap.agp.AGPCommand.Rate) {
                    case 1:
                        ts = "1X";
                        break;
                    case 2:
                        ts = "2X";
                        break;
                    case 4:
                        ts = "4X";
                        break;
                    default:
                        ts = "<not set>";
                        break;
                }
                t = *(PULONG)&cap.agp.AGPCommand;

                dprintf("          Command %08x (Rq:%02x SBA:%x AGP:%x Rate:%x (%s)\n",
                    t,
                    cap.agp.AGPCommand.RequestQueueDepth,
                    cap.agp.AGPCommand.SBAEnable,
                    cap.agp.AGPCommand.AGPEnable,
                    cap.agp.AGPCommand.Rate,
                    ts
                    );

                break;

            default:

                break;
        }
        CapPtr = cap.header.Next;
    } while (CapPtr != 0);
}

VOID
pcidump (
    IN ULONG        Flags,
    IN ULONG        MinBus,
    IN ULONG        MaxBus,
    IN ULONG        MinDevice,
    IN ULONG        MaxDevice,
    IN ULONG        MinFunction,
    IN ULONG        MaxFunction,
    IN ULONG        MinAddr,
    IN ULONG        MaxAddr
    )
{
    ULONG                   Bus, Device, Function;
    PCI_TYPE1_CFG_BITS      PciCfg1;
    PCI_COMMON_CONFIG       PciHdr;
    BOOLEAN                 BusHeader, SkipLine, BarIsIo;
    ULONG                   Type, Len, i;
    UCHAR                   s[40];
    PUCHAR                  Buf;
    ULONG                   state;
    ULONG                   bar, barno;

    if (MinBus > 0xFF || MaxBus > 0xFF ||
        MinDevice > PCI_MAX_DEVICES || MaxDevice > PCI_MAX_DEVICES ||
        MinFunction > PCI_MAX_FUNCTION || MaxFunction > PCI_MAX_FUNCTION ||
        MinAddr > 0xFF || MaxAddr > 0x100 || MinAddr > MaxAddr) {

        dprintf ("Bad pci dump parameter\n");

        //dprintf ("Flags %d  MinBus %d  MaxBus %d\n", Flags, MinBus, MaxBus);
        //dprintf ("MinDev %d  MaxDev %d  MinFnc %d MinFnc %d\n", MinDevice, MaxDevice, MinFunction, MaxFunction);

        return ;
    }

    //dprintf ("Flags %d  MinAddr %d  MaxAddr %d\n", Flags, MinAddr, MaxAddr);

    for (Bus=MinBus; Bus <= MaxBus; Bus++) {

        BusHeader = FALSE;

        for (Device=MinDevice; Device <= MaxDevice; Device++) {

            if (CheckControlC()) {
                return;
            }

            //
            // Read the device ID
            //

            PciCfg1.u.AsULONG = 0;
            PciCfg1.u.bits.BusNumber = Bus;
            PciCfg1.u.bits.DeviceNumber = Device;
            PciCfg1.u.bits.FunctionNumber = 0;
            PciCfg1.u.bits.Enable = TRUE;

            ReadPci (&PciCfg1, (PUCHAR) &PciHdr, 0, sizeof(ULONG));

            //
            // If not a valid ID, skip to next device

            if (PciHdr.VendorID == PCI_INVALID_VENDORID) {
                if (!(Flags & DUMP_ALLOW_INVALID_DEVICE)) {
                    dprintf ("%02x\r", Device);
                    continue;
                }
            }


            for (Function=MinFunction; Function <= MaxFunction; Function++) {

                if (CheckControlC()) {
                    return;
                }

                PciCfg1.u.bits.FunctionNumber = Function;

                //
                // Read device ID
                //

                if (Function) {
                    ReadPci (&PciCfg1, (PUCHAR) &PciHdr, 0, sizeof(ULONG));
                }

                if (PciHdr.VendorID == PCI_INVALID_VENDORID) {
                    if (!(Flags & DUMP_ALLOW_INVALID_DEVICE)) {
                        break;
                    }
                }

                //
                // Dump ID
                //

                if (!BusHeader) {
                    dprintf ("PCI Bus %d\n", Bus);
                    BusHeader = TRUE;
                }

                dprintf ("%02x:%x  %04x:%04x",
                        Device,
                        Function,
                        PciHdr.VendorID,
                        PciHdr.DeviceID
                        );

                //
                // Read the rest of the common header
                //

                ReadPci (
                    &PciCfg1,
                    ((PUCHAR) &PciHdr)  + sizeof(ULONG),
                    0                   + sizeof(ULONG),
                    PCI_COMMON_HDR_LENGTH
                    );

                Type = PciHdr.HeaderType & ~PCI_MULTIFUNCTION;

                if (Type == 0x7f && PciHdr.BaseClass == 0xff && PciHdr.SubClass == 0xff) {
                    if (!(Flags & DUMP_ALLOW_INVALID_FUNCTION)) {
                        dprintf ("  bogus, skipping rest of device\n");
                        break;
                    }
                }

                //
                // Dump it
                //

                s[0] = PciHdr.Command & PCI_ENABLE_IO_SPACE                 ? 'i' : '.';
                s[1] = PciHdr.Command & PCI_ENABLE_MEMORY_SPACE             ? 'm' : '.';
                s[2] = PciHdr.Command & PCI_ENABLE_BUS_MASTER               ? 'b' : '.';
                s[3] = PciHdr.Command & PCI_ENABLE_VGA_COMPATIBLE_PALETTE   ? 'v' : '.';
                s[4] = PciHdr.Command & PCI_ENABLE_PARITY                   ? 'p' : '.';
                s[5] = PciHdr.Command & PCI_ENABLE_SERR                     ? 's' : '.';
                s[6] = 0;
                dprintf (".%02x  Cmd[%04x:%s]  ", PciHdr.RevisionID, PciHdr.Command, s);

                s[0] = PciHdr.Status & PCI_STATUS_CAPABILITIES_LIST        ? 'c' : '.';
                s[1] = PciHdr.Status & PCI_STATUS_66MHZ_CAPABLE            ? '6' : '.';
                s[2] = PciHdr.Status & PCI_STATUS_DATA_PARITY_DETECTED     ? 'P' : '.';
                s[3] = PciHdr.Status & PCI_STATUS_SIGNALED_TARGET_ABORT    ? 'A' : '.';
                s[4] = PciHdr.Status & PCI_STATUS_SIGNALED_SYSTEM_ERROR    ? 'S' : '.';
                s[5] = 0;
                dprintf ("Sts[%04x:%s]  ", PciHdr.Status, s);


                switch (Type) {
                    case PCI_DEVICE_TYPE:
                        dprintf ("Device");

                        if (PciHdr.u.type0.SubVendorID || PciHdr.u.type0.SubSystemID) {
                            dprintf ("  SubID:%04x:%04x",
                                PciHdr.u.type0.SubVendorID,
                                PciHdr.u.type0.SubSystemID
                                );
                        }
                        break;

                    case PCI_BRIDGE_TYPE:
                        dprintf ("PciBridge %d->%d-%d",
                            PciHdr.u.type1.PrimaryBus,
                            PciHdr.u.type1.SecondaryBus,
                            PciHdr.u.type1.SubordinateBus
                            );
                        break;

                    case PCI_CARDBUS_BRIDGE_TYPE:
                        dprintf ("CardbusBridge  %d->%d-%d",
                            PciHdr.u.type2.PrimaryBus,
                            PciHdr.u.type2.SecondaryBus,
                            PciHdr.u.type2.SubordinateBus
                            );
                        break;

                    default:
                        dprintf ("type %x", Type);
                        break;
                }

                //
                // Search for a class code match
                //

                for (i=0; ClassCode[i].Desc; i++) {
                    if (PciHdr.BaseClass == ClassCode[i].BaseClass &&
                        PciHdr.SubClass == ClassCode[i].SubClass &&
                        (PciHdr.ProgIf == ClassCode[i].ProgIf ||
                         ClassCode[i].ProgIf == ANY) ) {

                        //
                        // Found it
                        //
                        break;
                    }
                }

                if (ClassCode[i].Desc) {
                    dprintf ("  %s", ClassCode[i].Desc);
                } else {
                    dprintf ("  Class:%x:%x:%x",
                        PciHdr.BaseClass,
                        PciHdr.SubClass,
                        PciHdr.ProgIf
                        );
                }

                dprintf ("\n");
                SkipLine = FALSE;

                if (Flags & DUMP_VERBOSE) {
                    SkipLine = TRUE;
                    PciCfg1.u.bits.RegisterNumber = 0;
                    switch (Type) {
                        case PCI_DEVICE_TYPE:
                            dprintf ("      cf8:%x  IntPin:%x  IntLine:%x  Rom:%x  cis:%x  cap:%x\n",
                                PciCfg1.u.AsULONG,
                                PciHdr.u.type0.InterruptPin,
                                PciHdr.u.type0.InterruptLine,
                                PciHdr.u.type0.ROMBaseAddress,
                                PciHdr.u.type0.CIS,
                                PciHdr.u.type0.CapabilitiesPtr
                            );

                            state = 0;
                            for (i=0; i < PCI_TYPE0_ADDRESSES; i++) {
                                bar = PciHdr.u.type0.BaseAddresses[i];
                                DumpPciBar(i, 6, bar, &state);
                            }
                            DumpPciBarComplete(&state);
                            break;

                        case PCI_BRIDGE_TYPE:
                            i = PciHdr.u.type1.BridgeControl;
                            dprintf ("      cf8:%x  IntPin:%x  IntLine:%x  Rom:%x  cap:%x  2sts:%x  BCtrl:%x%s%s%s\n",
                                PciCfg1.u.AsULONG,
                                PciHdr.u.type1.InterruptPin,
                                PciHdr.u.type1.InterruptLine,
                                PciHdr.u.type1.ROMBaseAddress,
                                PciHdr.u.type1.CapabilitiesPtr,
                                PciHdr.u.type1.SecondaryStatus,
                                PciHdr.u.type1.BridgeControl,
                                i & PCI_ENABLE_BRIDGE_VGA   ? " VGA" : "",
                                i & PCI_ENABLE_BRIDGE_ISA   ? " ISA" : "",
                                i & PCI_ASSERT_BRIDGE_RESET ? " RESET" : ""
                                );

                            dprintf ("      IO:%x-%x  Mem:%x-%x  PMem:%x-%x\n",
                                PciBridgeIO2Base (PciHdr.u.type1.IOBase,  PciHdr.u.type1.IOBaseUpper16),
                                PciBridgeIO2Limit(PciHdr.u.type1.IOLimit, PciHdr.u.type1.IOLimitUpper16),
                                PciBridgeMemory2Base (PciHdr.u.type1.MemoryBase),
                                PciBridgeMemory2Limit(PciHdr.u.type1.MemoryLimit),
                                PciBridgeMemory2Base (PciHdr.u.type1.PrefetchBase),
                                PciBridgeMemory2Limit(PciHdr.u.type1.PrefetchLimit)
                                );

                            state = 0;
                            for (i=0; i < PCI_TYPE1_ADDRESSES; i++) {
                                bar = PciHdr.u.type1.BaseAddresses[i];
                                DumpPciBar(i, 6, bar, &state);
                            }
                            DumpPciBarComplete(&state);
                            break;

                        case PCI_CARDBUS_BRIDGE_TYPE:
                            i = PciHdr.u.type2.BridgeControl;
                            dprintf ("      cf8:%x  IntPin:%x  IntLine:%x  SocketRegBase:%x  cap:%x  2sts:%x  BCtrl:%x%s%s%s\n",
                                PciCfg1.u.AsULONG,
                                PciHdr.u.type2.InterruptPin,
                                PciHdr.u.type2.InterruptLine,
                                PciHdr.u.type2.SocketRegistersBaseAddress,
                                PciHdr.u.type2.CapabilitiesPtr,
                                PciHdr.u.type2.SecondaryStatus,
                                PciHdr.u.type2.BridgeControl,
                                i & PCI_ENABLE_BRIDGE_VGA   ? " VGA" : "",
                                i & PCI_ENABLE_BRIDGE_ISA   ? " ISA" : "",
                                i & PCI_ASSERT_BRIDGE_RESET ? " RESET" : ""
                                );
                            dprintf("\n");
                            state=0;
                            for (i = 0; i < (PCI_TYPE2_ADDRESSES - 1); i++) {
                                bar = PciHdr.u.type2.Range[i].Base;
                                //
                                // First 2 BARs (base+limit) are memory
                                //
                                BarIsIo =  (i > 1);
                                barno =  i;
                                if (BarIsIo) {
                                      barno -= 2;
                                }
                                DumpPciType2Bar(BarIsIo,TRUE, barno, 6, bar, &state);

                                bar = PciHdr.u.type2.Range[i].Limit;
                                DumpPciType2Bar(BarIsIo, FALSE, i, 6, bar, &state);
                            }
                            DumpPciBarComplete(&state);
                            break;
                    }
                }

                //
                // Dump CAPABILITIES if any.
                //

                if (Flags & DUMP_CAPABILITIES) {
                    if (PciHdr.Status & PCI_STATUS_CAPABILITIES_LIST) {
                        UCHAR capPtr = 0;

                        SkipLine = TRUE;

                        switch (Type) {
                            case PCI_DEVICE_TYPE:
                                capPtr = PciHdr.u.type0.CapabilitiesPtr;
                                break;
        
                            case PCI_BRIDGE_TYPE:
                                capPtr = PciHdr.u.type1.CapabilitiesPtr;
                                break;
        
                            case PCI_CARDBUS_BRIDGE_TYPE:
                                capPtr = PciHdr.u.type2.CapabilitiesPtr;
                                break;
                        }

                        if (capPtr != 0) {
                            DumpCapabilities(capPtr, &PciCfg1);
                        } else {

                            //
                            // Capabilities flag is set in Status but
                            // pointer is 0???  Something's broken.
                            //

                            dprintf("       Warning: Capability bit set in Status but capability pointer is 0.\n");
                        }
                    }
                }

                //
                // Dump hex bytes
                //

                if (Flags & DUMP_RAW_BYTES) {

                    ULONG w;

                    //
                    // Raw dump requested, if no range default to common
                    // config.
                    //

                    if (!MinAddr && !MaxAddr) {
                        MaxAddr = PCI_COMMON_HDR_LENGTH - 1;
                    }

                    //
                    // Default width to 1.  If dumping dwords, set width
                    // width to 4 and round min and max accordingly.
                    //

                    w = 1;
                    if (Flags & DUMP_RAW_DWORDS) {
                        w = 4;
                        MinAddr &= ~3;
                        MaxAddr &= ~3;
                        MaxAddr += 3;
                    }
                    Buf = ((PUCHAR) &PciHdr) + MinAddr;
                    Len = MaxAddr - MinAddr + 1;

                    if (MinAddr <= PCI_COMMON_HDR_LENGTH) {
                        if (MaxAddr > PCI_COMMON_HDR_LENGTH) {
                            ReadPci (
                                &PciCfg1,
                                PciHdr.DeviceSpecific,
                                PCI_COMMON_HDR_LENGTH,
                                MaxAddr - PCI_COMMON_HDR_LENGTH
                                );
                        }

                    } else {
                        ReadPci (&PciCfg1, Buf, MinAddr, Len);
                    }

                    HexDump (w == 4 ? 6 : 1, MinAddr, Len, w, Buf);
                    SkipLine = TRUE;

                } else if ((Flags & DUMP_INTEL) && PciHdr.VendorID == 0x8086) {

                    Buf = PciHdr.DeviceSpecific;
                    Len = sizeof (PciHdr) - PCI_COMMON_HDR_LENGTH;

                    ReadPci (&PciCfg1, Buf, PCI_COMMON_HDR_LENGTH, Len);
                    HexDump (1, PCI_COMMON_HDR_LENGTH,  Len, 1, Buf);
                    SkipLine = TRUE;
                }


                if (SkipLine) {
                    dprintf ("\n");
                }

                //
                // If no more functions on this device, skip the rest
                // of the functions
                //

                if (Function == 0 && !(PciHdr.HeaderType & PCI_MULTIFUNCTION)) {
                    if (!(Flags & DUMP_ALLOW_INVALID_FUNCTION)) {
                        break;
                    }
                }

            }
        }
    }
}


DECLARE_API( pci )

/*++

Routine Description:

    Dumps pci type2 config data

Arguments:

    args - Supplies the address in hex.

Return Value:

    None

--*/
{
    LONG        noargs;
    ULONG       Flags;
    ULONG       MinBus, MaxBus;
    ULONG       Device, MinDevice, MaxDevice;
    ULONG       Function, MinFunction, MaxFunction;
    ULONG       MinAddr, MaxAddr;

    MinBus = 0;
    MaxBus = 0;
    MinDevice = 0;
    MaxDevice = PCI_MAX_DEVICES - 1;
    MinFunction = 0;
    MaxFunction = PCI_MAX_FUNCTION - 1;
    MinAddr = 0;
    MaxAddr = 0;
    Flags = 0;

    noargs = sscanf(args,"%lX %lX %lX %lX %lX %lX",
                    &Flags,         // 1
                    &MaxBus,        // 2
                    &Device,        // 3
                    &Function,      // 4
                    &MinAddr,       // 5
                    &MaxAddr        // 6
                    );

    MinBus = MaxBus;
    if (Flags & DUMP_TO_MAX_BUS) {
        MinBus = 0;
    }

    if (noargs >= 3) {
        Flags |= DUMP_ALLOW_INVALID_DEVICE;
        MinDevice = Device;
        MaxDevice = Device;
    }

    if (noargs >= 4) {
        MinFunction = Function;
        MaxFunction = Function;
    }

    if (MinAddr || MaxAddr) {
        Flags |= DUMP_RAW_BYTES;
    }

    if (Flags & DUMP_RAW_DWORDS) {
        Flags |= DUMP_RAW_BYTES;
    }

    pcidump (
        Flags,
        MinBus,        MaxBus,
        MinDevice,     MaxDevice,
        MinFunction,   MaxFunction,
        MinAddr,       MaxAddr
        );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\kdexts\p_i386\pat.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    pat.c

Abstract:

    WinDbg Extension Api

Author:

    Shivnandan Kaushik Aug 1997

Environment:

    User Mode.

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

//
// PAT MSR architecture definitions
//

//
// PAT model specific register
//

#define PAT_MSR       0x277

//
// PAT memory attributes
//

#define PAT_TYPE_STRONG_UC  0       // corresponds to PPro PCD=1,PWT=1
#define PAT_TYPE_USWC       1
#define PAT_TYPE_WT         4
#define PAT_TYPE_WP         5
#define PAT_TYPE_WB         6
#define PAT_TYPE_WEAK_UC    7       // corresponds to PPro PCD=1,PWT=0
#define PAT_TYPE_MAX        8       

#include "pshpack1.h"

typedef union _PAT {
    struct {
        UCHAR Pat[8];
    } hw;
    ULONGLONG   QuadPart;
} PAT, *PPAT;

#include "poppack.h"

//
// ----------------------------------------------------------------
//

DECLARE_API( pat )

/*++

Routine Description:

    Dumps processors pat

Arguments:

    args - none

Return Value:

    None

--*/
{
    static PUCHAR Type[] = {
    //  0         1           2            3            4       
    "STRONG_UC","USWC     ","????     ","????     ","WT       ",
    //  5         6           7
    "WP       ","WB       ","WEAK_UC  "};
    PAT     Attributes;
    ULONG   i;
    PUCHAR  p;
    ULONG   fb;
    ULONG   Index;

    //
    // Dump PAT
    //

    ReadMsr(PAT_MSR, &Attributes.QuadPart);

    dprintf("PAT_Index PCD PWT     Memory Type\n");
    for (Index = 0; Index < 8; Index++) {
        p = "????";
        if (Attributes.hw.Pat[Index] < PAT_TYPE_MAX) {
            p = Type[Attributes.hw.Pat[Index]];
        }
        dprintf("%d         %d   %d       %s\n",(Index/4)%2,
            (Index/2)%2,Index%2,p);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\kdexts\p_i386\pcr.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    pcr.c

Abstract:

    This module provides access to the pcr and a bang command to dump the pcr.

Author:

    Wesley Witt (wesw)  26-Aug-1993  (ported to WinDbg)

Revision History:


--*/

#include "precomp.h"
#pragma hdrstop



/*++

Routine Description:

    Print out the current values in interesting fields of the PCR
    for the specified processor.

Arguments:

    args - provides pointer to argument string, expect to be empty
            or to contain a positive decimal integer specifing which
            processor's pcr to dump

--*/

DECLARE_API( pcr )

{
    KPCR  Pcr;
    ULONG Address;
    PKPCR pp;
    USHORT processor;
    PROCESSORINFO pi;
    ULONG Result;
    KDPC  Dpc;

    //
    // Apply to whichever processor user asks for
    //

    if (strlen(args)) {
        processor = (USHORT)strtoul(args, NULL, 16);
        }
    else {
        processor = (USHORT)dwProcessor;
        }
    pp = &Pcr;
    if (!ReadPcr(processor, pp, &Address, hCurrentThread)) {
        dprintf("Unable to read PCR for Processor %u\n", processor);
        return;
    }

    //
    // Print out the PCR up through PrcbData, let dumpprcb print that.
    //

    dprintf("PCR Processor %ld @%08lx\n", processor, Address);
    dprintf("\tNtTib.ExceptionList: %08lx\n", pp->NtTib.ExceptionList);
    dprintf("\t    NtTib.StackBase: %08lx\n", pp->NtTib.StackBase);
    dprintf("\t   NtTib.StackLimit: %08lx\n", pp->NtTib.StackLimit);
    dprintf("\t NtTib.SubSystemTib: %08lx\n", pp->NtTib.SubSystemTib);
    dprintf("\t      NtTib.Version: %08lx\n", pp->NtTib.Version);
    dprintf("\t  NtTib.UserPointer: %08lx\n", pp->NtTib.ArbitraryUserPointer);
    dprintf("\t      NtTib.SelfTib: %08lx\n", pp->NtTib.Self);
    dprintf("\n");
    dprintf("\t            SelfPcr: %08lx\n", pp->SelfPcr);
    dprintf("\t               Prcb: %08lx\n", pp->Prcb);
    dprintf("\t               Irql: %08lx\n", (ULONG)pp->Irql);
    dprintf("\n");
    dprintf("\t      CurrentThread: %08lx\n", pp->PrcbData.CurrentThread);
    dprintf("\t         NextThread: %08lx\n", pp->PrcbData.NextThread);
    dprintf("\t         IdleThread: %08lx\n", pp->PrcbData.IdleThread);

    GetKdContext( &pi );

    dprintf("\n");

    dprintf( "\t          DpcQueue: ");

    Dpc.DpcListEntry.Flink = pp->PrcbData.DpcListHead.Flink;
    while ((DWORD)(Dpc.DpcListEntry.Flink) != (DWORD)pp->Prcb + FIELD_OFFSET( KPRCB, DpcListHead )) {

        UCHAR Name[0x100];
        ULONG_PTR Displacement;

        Name[0] = 0;
        dprintf(" 0x%x ", (ULONG)(Dpc.DpcListEntry.Flink) - 4 );

        if (!ReadMemory( (ULONG)(Dpc.DpcListEntry.Flink) - 4, &Dpc, sizeof( KDPC ), &Result )) {
            dprintf( "Failed to read DPC at 0x%x\n", (ULONG)(Dpc.DpcListEntry.Flink) - 4 );
            break;
        }

        GetSymbol( Dpc.DeferredRoutine, Name, &Displacement );
        dprintf("0x%x %s\n\t                    ", Dpc.DeferredRoutine, Name );

        if (CheckControlC()) {
            break;
        }
    
    }

    dprintf("\n");

}


BOOL
ReadPcr(
    USHORT  Processor,
    PVOID   Pcr,
    PULONG  AddressOfPcr,
    HANDLE  hThread
    )
{
    DESCRIPTOR_TABLE_ENTRY Entry;
    ULONG Result;
    ULONG Address;


    Entry.Selector=KGDT_R0_PCR;

    Result = LookupSelector( Processor, &Entry );
    if (Result != STATUS_SUCCESS) {
        return FALSE;
    }

    Address =
        ((ULONG)Entry.Descriptor.BaseLow & 0xffff) |
        (((ULONG)Entry.Descriptor.HighWord.Bytes.BaseMid << 16) & 0xff0000) |
        (((ULONG)Entry.Descriptor.HighWord.Bytes.BaseHi << 24) & 0xff000000);

    //
    // Address -> base of the pcr, read the PCR in.
    //

    if (!ReadMemory((DWORD)Address, Pcr, sizeof(KPCR), &Result)) {
        return FALSE;
    }

    *AddressOfPcr = Address;
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\kdexts\p_i386\pcskthw.h ===
/*** pcskthw.h - PC Card Socket Hardware Definitions
 *
 *  Copyright (c) 1995,1996 Microsoft Corporation
 *  Author:     Michael Tsang (MikeTs)
 *  Created     08/28/95
 *
 *  MODIFICATION HISTORY
 */


#ifndef _PCSKTHW_H
#define _PCSKTHW_H


#ifdef CARDBUS

/*** CardBus Constants
 */

//PCI IDs
#define PCIID_TI_PCI1130                0xac12104c
#define PCIID_TI_PCI1131		0xac15104c
#define PCIID_TI_PCI1031		0xac13104c
#define PCIID_OPTI_82C824		0xc8241045
#define PCIID_OPTI_82C814		0xc8141045	//Docking chip
//#define PCIID_TO_TOPIC95                0x06031179	//Seattle2
#define PCIID_TO_TOPIC95		0x060a1179	//SeattleX
#define PCIID_CL_PD6832			0x11101013
#define PCIID_DBK_DB87144		0x310610b3
#define PCIID_RICOH_RL5C466		0x04661180

//ConfigSpace Registers
#define CFGSPACE_VENDOR_ID              0x00
#define CFGSPACE_DEVICE_ID              0x02
#define CFGSPACE_COMMAND                0x04
#define CFGSPACE_STATUS                 0x06
#define CFGSPACE_REV_ID                 0x08
#define CFGSPACE_CLASS_CODE             0x09
#define CFGSPACE_CLASSCODE_PI           0x09
#define CFGSPACE_CLASSCODE_SUBCLASS     0x0a
#define CFGSPACE_CLASSCODE_BASECLASS    0x0b
#define CFGSPACE_CACHE_LINESIZE         0x0c
#define CFGSPACE_LATENCY_TIMER          0x0d
#define CFGSPACE_HEADER_TYPE            0x0e
#define CFGSPACE_BIST                   0x0f
#define CFGSPACE_REGBASE_ADDR           0x10
#define CFGSPACE_SECOND_STATUS          0x16
#define CFGSPACE_PCI_BUSNUM             0x18
#define CFGSPACE_CARDBUS_BUSNUM         0x19
#define CFGSPACE_SUB_BUSNUM             0x1a
#define CFGSPACE_CB_LATENCY_TIMER       0x1b
#define CFGSPACE_MEMBASE_0              0x1c
#define CFGSPACE_MEMLIMIT_0             0x20
#define CFGSPACE_MEMBASE_1              0x24
#define CFGSPACE_MEMLIMIT_1             0x28
#define CFGSPACE_IOBASE_0               0x2c
#define CFGSPACE_IOLIMIT_0              0x30
#define CFGSPACE_IOBASE_1               0x34
#define CFGSPACE_IOLIMIT_1              0x38
#define CFGSPACE_INT_LINE               0x3c
#define CFGSPACE_INT_PIN                0x3d
#define CFGSPACE_BRIDGE_CTRL            0x3e
#define CFGSPACE_SUBSYS_VENDOR_ID       0x40
#define CFGSPACE_SUBSYS_ID              0x42
#define CFGSPACE_LEGACY_MODE_BASE_ADDR	0x44

//Command Register bits
#define CMD_IOSPACE_ENABLE		0x0001
#define CMD_MEMSPACE_ENABLE		0x0002
#define CMD_BUSMASTER_ENABLE		0x0004
#define CMD_SPECIALCYCLE_ENABLE		0x0008
#define CMD_MEMWR_INVALIDATE_ENABLE	0x0010
#define CMD_VGA_PALETTE_SNOOP		0x0020
#define CMD_PARITY_ERROR_ENABLE		0x0040
#define CMD_WAIT_CYCLE_CTRL		0x0080
#define CMD_SYSTEM_ERROR_ENABLE		0x0100
#define CMD_FAST_BACKTOBACK_ENABLE	0x0200

//Bridge Control Register bits
#define BCTRL_PERR_RESPONSE_ENABLE	0x0001
#define BCTRL_SERR_ENABLE		0x0002
#define BCTRL_ISA_ENABLE		0x0004
#define BCTRL_VGA_ENABLE		0x0008
#define BCTRL_MASTER_ABORT_MODE		0x0020
#define BCTRL_CRST			0x0040
#define BCTRL_IRQROUTING_ENABLE		0x0080
#define BCTRL_MEMWIN0_PREFETCH_ENABLE	0x0100
#define BCTRL_MEMWIN1_PREFETCH_ENABLE	0x0200
#define BCTRL_WRITE_POSTING_ENABLE	0x0400
#define BCTRL_CL_CSCIRQROUTING_ENABLE	0x0800

//ConfigSpace Registers (TI PCI1130)
#define CFGSPACE_TI_SYSTEM_CTRL		0x80
#define CFGSPACE_TI_RETRY_STATUS        0x90
#define CFGSPACE_TI_CARD_CTRL           0x91
#define CFGSPACE_TI_DEV_CTRL            0x92
#define CFGSPACE_TI_BUFF_CTRL           0x93

//ConfigSpace Registers (TOPIC95)
#define CFGSPACE_TO_PC16_SKTCTRL	0x90
#define CFGSPACE_TO_SLOT_CTRL		0xa0
#define CFGSPACE_TO_CARD_CTRL		0xa1
#define CFGSPACE_TO_CD_CTRL		0xa3
#define CFGSPACE_TO_CBREG_CTRL		0xa4

//ConfigSpace Registers (OPTi 82C824)
#define CFGSPACE_OPTI_HF_CTRL           0x50
#define HFC_ZV_SUPPORT                  0x80

//ConfigSpace Registers (RICOH RL5C466)
#define CFGSPACE_RICOH_MISC_CTRL        0x82
#define CFGSPACE_RICOH_IF16_CTRL        0x84
#define CFGSPACE_RICOH_IO16_TIMING0     0x88
#define CFGSPACE_RICOH_MEM16_TIMING0    0x8a
#define CFGSPACE_RICOH_DMA_SLAVE_CFG    0x90

//RICOH 16-bit Interface Control Register bits
#define IF16_INDEX_RANGE_SELECT         0x0008
#define IF16_LEGACY_LEVEL_1             0x0010
#define IF16_LEGACY_LEVEL_2             0x0020
#define IF16_IO16_ENHANCE_TIMING        0x0100
#define IF16_MEM16_ENHANCE_TIMING       0x0200

//PC Card-16 Socket Control Register bits (TOPIC95)
#define S16CTRL_CSC_ISAIRQ		0x00000001

//Card Control Register bits (TOPIC95)
#define CARDCTRL_INTPIN_ASSIGNMASK	0x30
#define CARDCTRL_INTPIN_NONE		0x00
#define CARDCTRL_INTPIN_INTA		0x01
#define CARDCTRL_INTPIN_INTB		0x02

//Card Detect Control Register bits (TOPIC95)
#define CDCTRL_SW_DETECT		0x01
#define CDCTRL_VS_MASK			0x06
#define CDCTRL_PCCARD_16_32		0x80

//System Control Register bits (TI PCI1130)
#define SYSCTRL_PCICLKRUN_ENABLE	0x00000001
#define SYSCTRL_KEEPCLK_ENABLE		0x00000002
#define SYSCTRL_ASYNC_INTMODE		0x00000004
#define SYSCTRL_PCPCI_DMA_ENABLE	0x00000008
#define SYSCTRL_CBDATAPARITY_SERR	0x00000010
#define SYSCTRL_EXCAIDREV_READONLY	0x00000020
#define SYSCTRL_INTERROGATING		0x00000100
#define SYSCTRL_POWERING_UP		0x00000200
#define SYSCTRL_POWERING_DOWN		0x00000400
#define SYSCTRL_POWER_STREAMING		0x00000800
#define SYSCTRL_SOCKET_ACTIVITY		0x00001000
#define SYSCTRL_PCPCI_DMA_CHAN_MASK	0x00070000
#define SYSCTRL_PCPCI_DMA_CARD_ENABLE	0x00080000
#define SYSCTRL_REDUCED_ZV_ENABLE	0x00100000
#define SYSCTRL_VCC_PROTECT_OVERRIDE	0x00200000
#define SYSCTRL_SMI_INT_ENABLE		0x01000000
#define SYSCTRL_SMI_INT_ROUTING_SELECT	0x02000000

//Retry Status Register bits (TI PCI1130)
#define RETRY_PCIM_RETRY_EXPIRED	0x01
#define RETRY_PCI_RETRY_EXPIRED		0x02
#define RETRY_CBMA_RETRY_EXPIRED	0x04
#define RETRY_CBA_RETRY_EXPIRED		0x08
#define RETRY_CBMB_RETRY_EXPIRED	0x10
#define RETRY_CBB_RETRY_EXPIRED		0x20
#define RETRY_CBRETRY_TIMEOUT_ENABLE	0x40
#define RETRY_PCIRETRY_TIMEOUT_ENABLE	0x80

//Card Control Register bits (TI PCI1130)
#define CARDCTRL_PCCARD_INTFLAG         0x01
#define CARDCTRL_SPKR_ENABLE            0x02
#define CARDCTRL_CSCINT_ENABLE          0x08
#define CARDCTRL_FUNCINT_ENABLE         0x10
#define CARDCTRL_PCIINT_ENABLE          0x20
#define CARDCTRL_ZV_ENABLE		0x40
#define CARDCTRL_RIOUT_ENABLE           0x80

//Device Control Register bits (TI PCI1130)
#define DEVCTRL_INTMODE_MASK            0x06
#define DEVCTRL_INTMODE_DISABLED        0x00
#define DEVCTRL_INTMODE_ISA             0x02
#define DEVCTRL_INTMODE_COMPAQ          0x04
#define DEVCTRL_INTMODE_SERIAL		0x06
#define DEVCTRL_ALWAYS_ONE              0x10
#define DEVCTRL_3V_ENABLE               0x20
#define DEVCTRL_5V_ENABLE               0x40

//CardBus Registers
#define CBREG_SKTEVENT                  0x00
#define CBREG_SKTMASK                   0x04
#define CBREG_SKTSTATE                  0x08
#define CBREG_SKTFORCE                  0x0c
#define CBREG_SKTPOWER                  0x10

//Socket Event Register bits
#define SKTEVENT_CSTSCHG                0x00000001L
#define SKTEVENT_CCD1                   0x00000002L
#define SKTEVENT_CCD2                   0x00000004L
#define SKTEVENT_CCD_MASK		(SKTEVENT_CCD1 | SKTEVENT_CCD2)
#define SKTEVENT_POWERCYCLE             0x00000008L
#define SKTEVENT_MASK                   0x0000000fL

//Socket Mask Register bits
#define SKTMSK_CSTSCHG                  0x00000001L
#define SKTMSK_CCD                      0x00000006L
#define SKTMSK_CCD1                     0x00000002L
#define SKTMSK_CCD2                     0x00000004L
#define SKTMSK_POWERCYCLE               0x00000008L

//Socket Present State Register bits
#define SKTSTATE_CSTSCHG                0x00000001L
#define SKTSTATE_CCD1                   0x00000002L
#define SKTSTATE_CCD2                   0x00000004L
#define SKTSTATE_CCD_MASK               (SKTSTATE_CCD1 | SKTSTATE_CCD2)
#define SKTSTATE_POWERCYCLE             0x00000008L
#define SKTSTATE_CARDTYPE_MASK		0x00000030L
#define SKTSTATE_R2CARD                 0x00000010L
#define SKTSTATE_CBCARD                 0x00000020L
#define SKTSTATE_OPTI_DOCK		0x00000030L
#define CARDTYPE(dw)			((dw) & SKTSTATE_CARDTYPE_MASK)
#define SKTSTATE_CARDINT                0x00000040L
#define SKTSTATE_NOTACARD               0x00000080L
#define SKTSTATE_DATALOST               0x00000100L
#define SKTSTATE_BADVCCREQ              0x00000200L
#define SKTSTATE_5VCARD                 0x00000400L
#define SKTSTATE_3VCARD                 0x00000800L
#define SKTSTATE_XVCARD                 0x00001000L
#define SKTSTATE_YVCARD                 0x00002000L
#define SKTSTATE_CARDVCC_MASK		(SKTSTATE_5VCARD | SKTSTATE_3VCARD | \
					 SKTSTATE_XVCARD | SKTSTATE_YVCARD)
#define SKTSTATE_5VSOCKET               0x10000000L
#define SKTSTATE_3VSOCKET               0x20000000L
#define SKTSTATE_XVSOCKET               0x40000000L
#define SKTSTATE_YVSOCKET               0x80000000L
#define SKTSTATE_SKTVCC_MASK		(SKTSTATE_5VSOCKET | \
					 SKTSTATE_3VSOCKET | \
					 SKTSTATE_XVSOCKET | \
					 SKTSTATE_YVSOCKET)

//Socket Froce Register bits
#define SKTFORCE_CSTSCHG                0x00000001L
#define SKTFORCE_CCD1                   0x00000002L
#define SKTFORCE_CCD2                   0x00000004L
#define SKTFORCE_POWERCYCLE             0x00000008L
#define SKTFORCE_R2CARD                 0x00000010L
#define SKTFORCE_CBCARD                 0x00000020L
#define SKTFORCE_NOTACARD               0x00000080L
#define SKTFORCE_DATALOST               0x00000100L
#define SKTFORCE_BADVCCREQ              0x00000200L
#define SKTFORCE_5VCARD                 0x00000400L
#define SKTFORCE_3VCARD                 0x00000800L
#define SKTFORCE_XVCARD                 0x00001000L
#define SKTFORCE_YVCARD                 0x00002000L
#define SKTFORCE_CVSTEST                0x00004000L
#define SKTFORCE_5VSOCKET		0x10000000L
#define SKTFORCE_3VSOCKET		0x20000000L
#define SKTFORCE_XVSOCKET		0x40000000L
#define SKTFORCE_YVSOCKET		0x80000000L

//Power Control Register bits
#define SKTPOWER_VPP_CONTROL            0x00000007L
#define SKTPOWER_VPP_OFF                0x00000000L
#define SKTPOWER_VPP_120V               0x00000001L
#define SKTPOWER_VPP_050V               0x00000002L
#define SKTPOWER_VPP_033V               0x00000003L
#define SKTPOWER_VPP_0XXV               0x00000004L
#define SKTPOWER_VPP_0YYV               0x00000005L
#define SKTPOWER_VCC_CONTROL            0x00000070L
#define SKTPOWER_VCC_OFF                0x00000000L
#define SKTPOWER_VCC_050V               0x00000020L
#define SKTPOWER_VCC_033V               0x00000030L
#define SKTPOWER_VCC_0XXV               0x00000040L
#define SKTPOWER_VCC_0YYV               0x00000050L
#define SKTPOWER_STOPCLOCK              0x00000080L

//Misc. CardBus Constants
#define NUMWIN_BRIDGE                   4       //2 Mem + 2 IO
#define EXCAREG_OFFSET                  0x0800


/*** CardBus Type and Structure Definitions
 */

typedef struct cfgspace_s {
    WORD  wVendorID;
    WORD  wDeviceID;
    WORD  wCommand;
    WORD  wStatus;
    BYTE  bRevID;
    BYTE  bClassCodePI;
    BYTE  bClassCodeSubClass;
    BYTE  bClassCodeBaseClass;
    BYTE  bCacheLineSize;
    BYTE  bLatencyTimer;
    BYTE  bHeaderType;
    BYTE  bBIST;
    DWORD dwRegBaseAddr;
    BYTE  bPCIBusNum;
    BYTE  bCBBusNum;
    BYTE  bSubBusNum;
    BYTE  bCBLatencyTimer;
    DWORD dwMemBase0;
    DWORD dwMemLimit0;
    DWORD dwMemBase1;
    DWORD dwMemLimit1;
    DWORD dwIOBase0;
    DWORD dwIOLimit0;
    DWORD dwIOBase1;
    DWORD dwIOLimit1;
    BYTE  bIntLine;
    BYTE  bIntPin;
    BYTE  bBridgeCtrl;
    WORD  wSubSysVendorID;
    WORD  wSubSysID;
} CFGSPACE;
typedef CFGSPACE *PCFGSPACE;

typedef struct cbregs_s {
    DWORD dwSktEvent;
    DWORD dwSktMask;
    DWORD dwSktState;
    DWORD dwSktForce;
    DWORD dwSktPower;
} CBREGS;
typedef CBREGS *PCBREGS;

#endif  //ifdef CARDBUS


/*** 16-Bit Socket Constants
 */

//Device IDs for various controllers
#define DEVID_VALID_LO			0x82
#define DEVID_CL			0x82
#define DEVID_VADEM			0x83
#define DEVID_RICOH			0x83
#define DEVID_GEN_PCIC			0x84
#define DEVID_IBM_KING			0x8a
#define DEVID_OPTI_82C824		0x87
#define DEVID_OPTI_82C852		0x8f

//ExCA Registers
#define EXCAREG_IDREV                   0x00
#define EXCAREG_VLSI_EA0		0x00
#define EXCAREG_INTERFACE_STATUS        0x01
#define EXCAREG_VLSI_EA1		0x01
#define EXCAREG_POWER_CTRL              0x02
#define EXCAREG_VLSI_EA2		0x02
#define EXCAREG_INT_GENCTRL             0x03
#define EXCAREG_VLSI_EXT_CHIPCTRL	0x03
#define EXCAREG_CARD_STATUS             0x04
#define EXCAREG_CSC_CFG                 0x05
#define EXCAREG_WIN_ENABLE              0x06
#define EXCAREG_IO_CTRL                 0x07
#define EXCAREG_IOWIN0_START            0x08
#define EXCAREG_IOWIN0_END              0x0a
#define EXCAREG_IOWIN1_START            0x0c
#define EXCAREG_IOWIN1_END              0x0e
#define EXCAREG_MEMWIN0_START           0x10
#define EXCAREG_MEMWIN0_END             0x12
#define EXCAREG_MEMWIN0_OFFSET          0x14
#define EXCAREG_CARDDET_GENCTRL		0x16
#define EXCAREG_CL_MISC_CTRL1		0x16
#define EXCAREG_TO_ADDITIONAL_GENCTRL	0x16
#define EXCAREG_CL_FIFO_CTRL		0x17
#define EXCAREG_KING_CVS		0x17
#define EXCAREG_MEMWIN1_START           0x18
#define EXCAREG_MEMWIN1_END             0x1a
#define EXCAREG_MEMWIN1_OFFSET          0x1c
#define EXCAREG_GLOBAL_CTRL		0x1e
#define EXCAREG_CL_MISC_CTRL2		0x1e
#define EXCAREG_CL_CHIP_INFO		0x1f
#define EXCAREG_VADEM_VSENSE		0x1f
#define EXCAREG_MEMWIN2_START           0x20
#define EXCAREG_MEMWIN2_END             0x22
#define EXCAREG_MEMWIN2_OFFSET          0x24
#define EXCAREG_CL_ATA_CTRL		0x26
#define EXCAREG_MEMWIN3_START           0x28
#define EXCAREG_MEMWIN3_END             0x2a
#define EXCAREG_MEMWIN3_OFFSET          0x2c
#define EXCAREG_CL_EXT_INDEX		0x2e
#define EXCAREG_CL_EXT_DATA		0x2f
#define EXCAREG_VADEM_VSEL		0x2f
#define EXCAREG_RICOH_MISC_CTRL1        0x2f
#define EXCAREG_MEMWIN4_START           0x30
#define EXCAREG_MEMWIN4_END             0x32
#define EXCAREG_MEMWIN4_OFFSET          0x34
#define EXCAREG_CL_IOWIN0_OFFSET	0x36
#define EXCAREG_CL_IOWIN1_OFFSET	0x38
#define EXCAREG_CL_SETUP_TIMING0	0x3a
#define EXCAREG_VADEM_MISC		0x3a
#define EXCAREG_CL_COMMAND_TIMING0	0x3b
#define EXCAREG_DBK_ZV_ENABLE		0x3b
#define EXCAREG_TO_MMI_CTRL		0x3c
#define EXCAREG_CL_RECOVERY_TIMING0	0x3c
#define EXCAREG_CL_SETUP_TIMING1	0x3d
#define EXCAREG_CL_COMMAND_TIMING1	0x3e
#define EXCAREG_TO_FUNC_CTRL		0x3e
#define EXCAREG_CL_RECOVERY_TIMING1	0x3f
#define EXCAREG_MEMWIN0_HI              0x40
#define EXCAREG_MEMWIN1_HI              0x41
#define EXCAREG_MEMWIN2_HI              0x42
#define EXCAREG_MEMWIN3_HI              0x43
#define EXCAREG_MEMWIN4_HI              0x44
#define EXCAREG_CL_IOWIN0_HI            0x45
#define EXCAREG_CL_IOWIN1_HI            0x46
#define EXCAREG_CL_EXT_CTRL1            0x103
#define EXCAREG_CL_EXTERNAL_DATA        0x10a
#define EXCAREG_CL_EXT_CTRL2            0x10b
#define EXCAREG_CL_MISC_CTRL3           0x125
#define EXCAREG_CL_MASK_REV		0x134
#define EXCAREG_CL_PRODUCT_ID		0x135
#define EXCAREG_CL_DEV_CAP_A		0x136
#define EXCAREG_CL_DEV_CAP_B		0x137
#define EXCAREG_CL_DEV_IMP_A		0x138
#define EXCAREG_CL_DEV_IMP_B		0x139
#define EXCAREG_CL_DEV_IMP_C		0x13a
#define EXCAREG_CL_DEV_IMP_D		0x13b

//TI PCI-1130 specific registers
#define EXCAREG_TI_MEMWIN_PAGE		0x40

//ID and Revision Register bits
#define IDREV_REV_MASK                  0x0f
#define IDREV_IFID_MASK                 0xc0
#define IDREV_IFID_IO                   0x00
#define IDREV_IFID_MEM                  0x40
#define IDREV_IFID_IOMEM                0x80

//Interface Status Register bits
#define IFS_BVD_MASK                    0x03
#define IFS_BVD1                        0x01
#define IFS_BVD2                        0x02
#define IFS_CD_MASK                     0x0c
#define IFS_CD1                         0x04
#define IFS_CD2                         0x08
#define IFS_WP                          0x10
#define IFS_RDYBSY                      0x20
#define IFS_CARDPWR_ACTIVE              0x40
#define IFS_VPP_VALID                   0x80

//Power and RESETDRV Control Register bits
#define PC_VPP1_MASK                    0x03
#define PC_VPP2_MASK                    0x0c
#define PC_CARDPWR_ENABLE               0x10
#define PC_AUTOPWR_ENABLE               0x20
#define PC_RESETDRV_DISABLE             0x40
#define PC_OUTPUT_ENABLE                0x80

#define PC_VPP_NO_CONNECT		0x00
#define PC_VPP_SETTO_VCC		0x01
#define PC_VPP_SETTO_VPP		0x02
#define PC_VPP_RESERVED			0x03

#define PC_VPP_VLSI_MASK		0x03
#define PC_VPP_VLSI_NO_CONNECT		0x00
#define PC_VPP_VLSI_050V		0x01
#define PC_VPP_VLSI_120V		0x02
#define PC_VPP_VLSI_RESERVED		0x03

#define PC_VCC_TOPIC_033V		0x08

#define PC_VCC_VLSI_MASK		0x18
#define PC_VCC_VLSI_NO_CONNECT		0x00
#define PC_VCC_VLSI_RESERVED		0x08
#define PC_VCC_VLSI_050V		0x10
#define PC_VCC_VLSI_033V		0x18

#define PC_VPP_KING_MASK		0x03
#define PC_VPP_KING_NO_CONNECT		0x00
#define PC_VPP_KING_050V		0x01
#define PC_VPP_KING_120V		0x02
#define PC_VPP_KING_SETTO_VCC		0x03

#define PC_VCC_KING_MASK		0x0c
#define PC_VCC_KING_NO_CONNECT		0x00
#define PC_VCC_KING_050V		0x04
#define PC_VCC_KING_RESERVED		0x08
#define PC_VCC_KING_033V		0x0c

#define PC_VPP_OPTI_MASK		0x03
#define PC_VPP_OPTI_NO_CONNECT		0x00
#define PC_VPP_OPTI_SETTO_VCC		0x01
#define PC_VPP_OPTI_120V		0x02
#define PC_VPP_OPTI_0V			0x03

#define PC_VCC_OPTI_MASK		0x18
#define PC_VCC_OPTI_NO_CONNECT		0x00
#define PC_VCC_OPTI_033V		0x08
#define PC_VCC_OPTI_050V		0x10
#define PC_VCC_OPTI_0XXV		0x18

//Interrupt and General Control Register bits
#define IGC_IRQ_MASK                    0x0f
#define IGC_INTR_ENABLE                 0x10
#define IGC_PCCARD_IO                   0x20
#define IGC_PCCARD_RESETLO              0x40
#define IGC_RINGIND_ENABLE              0x80

//Card Status Change Register bits
#define CSC_CHANGE_MASK                 0x0f
#define CSC_BATT_DEAD                   0x01
#define CSC_BATT_WARNING                0x02
#define CSC_BATT_MASK			(CSC_BATT_DEAD | CSC_BATT_WARNING)
#define CSC_READY_CHANGE                0x04
#define CSC_CD_CHANGE                   0x08

//Card Status Change Interrupt Configuration Register bits
#define CSCFG_ENABLE_MASK               0x0f
#define CSCFG_BATT_DEAD                 0x01
#define CSCFG_BATT_WARNING              0x02
#define CSCFG_BATT_MASK			(CSCFG_BATT_DEAD | CSCFG_BATT_WARNING)
#define CSCFG_READY_ENABLE              0x04
#define CSCFG_CD_ENABLE                 0x08
#define CSCFG_IRQ_MASK                  0xf0

//Address Window Enable Register bits
#define WE_MEM0_ENABLE                  0x01
#define WE_MEM1_ENABLE                  0x02
#define WE_MEM2_ENABLE                  0x04
#define WE_MEM3_ENABLE                  0x08
#define WE_MEM4_ENABLE                  0x10
#define WE_MEMWIN_MASK			(WE_MEM0_ENABLE | WE_MEM1_ENABLE | \
					 WE_MEM2_ENABLE | WE_MEM3_ENABLE | \
					 WE_MEM4_ENABLE)
#define WE_MEMCS16_DECODE               0x20
#define WE_IO0_ENABLE                   0x40
#define WE_IO1_ENABLE                   0x80
#define WE_IOWIN_MASK			(WE_IO0_ENABLE | WE_IO1_ENABLE)

//I/O Control Register bits
#define IOC_IO0_MASK                    0x0f
#define IOC_IO0_DATASIZE                0x01
#define IOC_IO0_IOCS16                  0x02
#define IOC_IO0_ZEROWS                  0x04
#define IOC_IO0_WAITSTATE               0x08
#define IOC_IO1_MASK                    0xf0
#define IOC_IO1_DATASIZE                0x10
#define IOC_IO1_IOCS16                  0x20
#define IOC_IO1_ZEROWS                  0x40
#define IOC_IO1_WAITSTATE               0x80

//Card Detection and General Control Register
#define CDGC_SW_DET_INT			0x20

//Memory Window Start Register bits
#define MEMBASE_ADDR_MASK               0x0fff
#define MEMBASE_ZEROWS                  0x4000
#define MEMBASE_16BIT                   0x8000

//Memory Window Stop Register bits
#define MEMEND_ADDR_MASK                0x0fff
#define MEMEND_WS_MASK                  0xc000

//Memory Window Offset Register bits
#define MEMOFF_ADDR_MASK                0x3fff
#define MEMOFF_REG_ACTIVE               0x4000
#define MEMOFF_WP                       0x8000

//Cirrus Logic Miscellaneous Control 1 Register bits
#define CL_MC1_5V_DETECT		0x01
#define CL_MC1_MM_ENABLE		0x01
#define CL_MC1_VCC_33V			0x02
#define CL_MC1_PULSE_MGMT_INT		0x04
#define CL_MC1_PULSE_SYSTEM_IRQ		0x08
#define CL_MC1_SPKR_ENABLE		0x10
#define CL_MC1_INPACK_ENABLE		0x80

//Cirrus Logic Miscellaneous Control 2 Register bits
#define CL_MC2_BFS			0x01
#define CL_MC2_LPDYNAMIC_MODE		0x02
#define CL_MC2_SUSPEND			0x04
#define CL_MC2_5VCORE			0x08
#define CL_MC2_DRIVELED_ENABLE		0x10
#define CL_MC2_TIMERCLK_DIVIDE		0x10
#define CL_MC2_3STATE_BIT7		0x20
#define CL_MC2_DMA_SYSTEM		0x40
#define CL_MC2_IRQ15_RIOUT		0x80

//Cirrus Logic Miscellaneous Control 3 Register bits
#define CL_MC3_INTMODE_MASK             0x03
#define CL_MC3_INTMODE_SERIAL           0x00
#define CL_MC3_INTMODE_EXTHW            0x01
#define CL_MC3_INTMODE_PCIWAY           0x02
#define CL_MC3_INTMODE_PCI              0x03    //default
#define CL_MC3_PWRMODE_MASK             0x0c
#define CL_MC3_HWSUSPEND_ENABLE         0x10
#define CL_MC3_MM_ARM			0x80

//Cirrus Logic Chip Info Register bits
#define CL_CI_REV_MASK			0x1e
#define CL_CI_DUAL_SOCKET		0x20
#define CL_CI_CHIP_ID			0xc0

//Cirrus Logic Mask Revision Register bits
#define CL_MSKREV_MASK			0x0f

//Cirrus Logic Product ID Register bits
#define CL_PID_PRODUCT_CODE_MASK	0x0f
#define CL_PID_FAMILY_CODE_MASK		0xf0

//Cirrus Logic Device Capability Register A bits
#define CL_CAPA_NUMSKT_MASK		0x03
#define CL_CAPA_IDE_INTERFACE		0x04
#define CL_CAPA_SLAVE_DMA		0x08
#define CL_CAPA_CPSTB_CAPABLE		0x20
#define CL_CAPA_PER_SKT_LED		0x80

//Cirrus Logic Device Capability Register B bits
#define CL_CAPB_CARDBUS_CAPABLE		0x01
#define CL_CAPB_LOCK_SUPPORT		0x02
#define CL_CAPB_CLKRUN_SUPPORT		0x04
#define CL_CAPB_EXT_DEF			0x80

//Cirrus Logic Device Implementation Register A bits
#define CL_IMPA_NUMSKT_MASK		0x03
#define CL_IMPA_SLAVE_DMA		0x04
#define CL_IMPA_VS1_VS2			0x08
#define CL_IMPA_GPSTB_A			0x10
#define CL_IMPA_GPSTB_B			0x20
#define CL_IMPA_HW_SUSPEND		0x40
#define CL_IMPA_RI_OUT			0x80

//Cirrus Logic Device Implementation Register B bits
#define CL_IMPB_033_VCC			0x01
#define CL_IMPB_050_VCC			0x02
#define CL_IMPB_0YY_VCC			0x04
#define CL_IMPB_0XX_VCC			0x08
#define CL_IMPB_120_VPP			0x10
#define CL_IMPB_VPP_VCC_1A		0x20
#define CL_IMPB_RFRATED_SKT		0x40

//Cirrus Logic Device Implementation Register C bits
#define CL_IMPC_LED			0x01
#define CL_IMPC_PER_SKT_LED		0x02
#define CL_IMPC_SPK			0x04
#define CL_IMPC_ZVP_A			0x08
#define CL_IMPC_ZVP_B			0x10

//Cirrus Logic Device Implementation Register D bits
#define CL_IMPD_CLKRUN			0x01
#define CL_IMPD_LOCK			0x02
#define CL_IMPD_EXT_CLK			0x40

//Cirrus Logic Extension Registers
#define CLEXTREG_EXTCTRL_1		0x03
#define CLEXTREG_MEMWIN0_HIADDR		0x05
#define CLEXTREG_MEMWIN1_HIADDR		0x06
#define CLEXTREG_MEMWIN2_HIADDR		0x07
#define CLEXTREG_MEMWIN3_HIADDR		0x08
#define CLEXTREG_MEMWIN4_HIADDR		0x09
#define CLEXTREG_EXT_DATA		0x0a
#define CLEXTREG_EXTCTRL_2		0x0b

//Cirrus Logic External Data Register bits (Index=0x6f,ExtIndex=0x0a)
#define CL_EDATA_A_VS1			0x01
#define CL_EDATA_A_VS2			0x02
#define CL_EDATA_A_5V			(CL_EDATA_A_VS1 | CL_EDATA_A_VS2)
#define CL_EDATA_B_VS1			0x04
#define CL_EDATA_B_VS2			0x08
#define CL_EDATA_B_5V			(CL_EDATA_B_VS1 | CL_EDATA_B_VS2)

//Toshiba TOPIC95 Function Control Register bits
#define TO_FCTRL_CARDPWR_ENABLE		0x01
#define TO_FCTRL_VSSTATUS_ENABLE	0x02
#define TO_FCTRL_PPEC_TIMING_ENABLE	0x04
#define TO_FCTRL_CARD_TIMING_ENABLE	0x08
#define TO_FCTRL_CARD_MEMPAGE_ENABLE	0x10
#define TO_FCTRL_DMA_ENABLE		0x20
#define TO_FCTRL_PWRCTRL_BUFFER_ENABLE	0x40

//Toshiba TOPIC95 Multimedia Interface Control Register bits
#define TO_MMI_VIDEO_CTRL		0x01
#define TO_MMI_AUDIO_CTRL		0x02
#define TO_MMI_REV_BIT			0x80

//Toshiba TOPIC95 Addition General Control Register bits
#define TO_GCTRL_CARDREMOVAL_RESET	0x02
#define TO_GCTRL_SWCD_INT		0x20

//Databook DB87144 Zoom Video Port Enable Register
#define DBK_ZVE_MODE_MASK		0x03
#define DBK_ZVE_STANDARD_MODE		0x00
#define DBK_ZVE_MM_MODE			0x03

//OPTi Global Control Register bits
#define OPTI_ZV_ENABLE                  0x20

//VLSI ELC Constants
#define VLSI_ELC_ALIAS			0x8000
#define VLSI_EA2_EA_ENABLE		0x10
#define VLSI_CC_VS1			0x04

//VADEM Constants
#define VADEM_UNLOCK_SEQ1		0x0e
#define VADEM_UNLOCK_SEQ2		0x37
#define VADEM_MISC_UNLOCK_VADEMREV	0xc0
#define VADEM_IDREV_VG469_REV		0x0c
#define VADEM_VSEL_VCC_MASK		0x03
#define VADEM_VSEL_VCC_050V		0x00
#define VADEM_VSEL_VCC_033V		0x01
#define VADEM_VSEL_VCC_XXXV		0x02
#define VADEM_VSEL_VCC_033VB		0x03
#define VADEM_VSEL_SKT_MIXEDVOLT	0x40
#define VADEM_VSENSE_A_VS1		0x01
#define VADEM_VSENSE_A_VS2		0x02
#define VADEM_VSENSE_B_VS1		0x04
#define VADEM_VSENSE_B_VS2		0x08
#define VADEM_VSENSE_050V_ONLY		0x03

//IBM King Constants
#define KING_CVS_VS1			0x01
#define KING_CVS_VS2			0x02
#define KING_CVS_VS_MASK		(KING_CVS_VS1 | KING_CVS_VS2)
#define KING_CVS_5V			(KING_CVS_VS1 | KING_CVS_VS2)
#define KING_CVS_GPI			0x80

//Ricoh RL5C466 Miscellaneous Control 1 Register bits
#define RICOH_MC1_VS                    0x01
#define RICOH_MC1_IREQ_SENSE_SEL        0x02
#define RICOH_MC1_INPACK_ENABLE         0x04
#define RICOH_MC1_ZV_ENABLE             0x08
#define RICOH_MC1_DMA_ENABLE_MASK       0x30
#define RICOH_MC1_DMA_DISABLE           0x00
#define RICOH_MC1_DMA_INPACK            0x10
#define RICOH_MC1_DMA_IOIS16            0x20
#define RICOH_MC1_DMA_SPKR              0x30

//Misc. Constants
#define EXCAREGBASE_SPACE		0x40
#define NUMWIN_PCCARD16                 7       //5 mem + 2 io per socket
#define NUMWIN_PC16_MEM                 5
#define NUMWIN_PC16_IO                  2
#define PCCARD_IOWIN_START              5

//These are default values for the slowest and fastest memory speeds supported.
//It may be necessary to change the actual values with arguments, if the bus
//speed is not the default 8MHz/8.33MHz, which gives 120ns-125ns per cycle.
//Note that the SLOW_MEM_SPEED should be the same as the default
//WaitToSpeed[3], and FAST_MEM_SPEED might as well be 1ns, since the socket
//will support arbitrarily fast memory.
#define SLOW_MEM_SPEED                  0x72    //700ns
#define FAST_MEM_SPEED                  0x08    //1ns

#define RESET_DELAY                     2000    //2ms
#define PWRON_DELAY                     300000  //300ms

//I/O Control Register default nibble values
//The Xircom net PC cards fails with a 16-bit wait on the AcerNote which
//has a Cirrus Logic controller.  Why the addition of a wait state causes
//this to fail is a mystery.  The Socket EA PC card fails on the IBM ThinkPad
//755 if the 16-bit wait state is not set.
#define DEF_IOC_8BIT                    0x00
#define DEF_IOC_16BIT                   (IOC_IO0_DATASIZE | IOC_IO0_IOCS16 | \
                                         IOC_IO0_WAITSTATE)


/*** ExCA Type and Structure Definitions
 */

typedef struct excaregs_s {
    BYTE  bIDRev;                       //0x00
    BYTE  bInterfaceStatus;             //0x01
    BYTE  bPowerControl;                //0x02
    BYTE  bIntGenControl;               //0x03
    BYTE  bCardStatusChange;            //0x04
    BYTE  bCardStatusIntConfig;         //0x05
    BYTE  bWindowEnable;                //0x06
    BYTE  bIOControl;                   //0x07
    BYTE  bIO0StartLo;                  //0x08
    BYTE  bIO0StartHi;                  //0x09
    BYTE  bIO0StopLo;                   //0x0a
    BYTE  bIO0StopHi;                   //0x0b
    BYTE  bIO1StartLo;                  //0x0c
    BYTE  bIO1StartHi;                  //0x0d
    BYTE  bIO1StopLo;                   //0x0e
    BYTE  bIO1StopHi;                   //0x0f
    BYTE  bMem0StartLo;                 //0x10
    BYTE  bMem0StartHi;                 //0x11
    BYTE  bMem0StopLo;                  //0x12
    BYTE  bMem0StopHi;                  //0x13
    BYTE  bMem0OffsetLo;                //0x14
    BYTE  bMem0OffsetHi;                //0x15
    WORD  wReserved0;                   //0x16
    BYTE  bMem1StartLo;                 //0x18
    BYTE  bMem1StartHi;                 //0x19
    BYTE  bMem1StopLo;                  //0x1a
    BYTE  bMem1StopHi;                  //0x1b
    BYTE  bMem1OffsetLo;                //0x1c
    BYTE  bMem1OffsetHi;                //0x1d
    WORD  wReserved1;                   //0x1e
    BYTE  bMem2StartLo;                 //0x20
    BYTE  bMem2StartHi;                 //0x21
    BYTE  bMem2StopLo;                  //0x22
    BYTE  bMem2StopHi;                  //0x23
    BYTE  bMem2OffsetLo;                //0x24
    BYTE  bMem2OffsetHi;                //0x25
    WORD  wReserved2;                   //0x26
    BYTE  bMem3StartLo;                 //0x28
    BYTE  bMem3StartHi;                 //0x29
    BYTE  bMem3StopLo;                  //0x2a
    BYTE  bMem3StopHi;                  //0x2b
    BYTE  bMem3OffsetLo;                //0x2c
    BYTE  bMem3OffsetHi;                //0x2d
    WORD  wReserved3;                   //0x2e
    BYTE  bMem4StartLo;                 //0x30
    BYTE  bMem4StartHi;                 //0x31
    BYTE  bMem4StopLo;                  //0x32
    BYTE  bMem4StopHi;                  //0x33
    BYTE  bMem4OffsetLo;                //0x34
    BYTE  bMem4OffsetHi;                //0x35
    WORD  wReserved4;                   //0x36
    DWORD dgReserved5;                  //0x38
    DWORD dgReserved6;                  //0x3c
} EXCAREGS;
typedef EXCAREGS *PEXCAREGS;


#endif  //ifndef _PCSKTHW_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\kdexts\p_i386\selector.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    selector.c

Abstract:

    This module allows the host side of the kernel debugger to look up
    selector values in the GDT and LDT of the target machine.

Author:

    John Vert   (jvert) 10-Jun-1991

Revision History:

    Wesley Witt (wesw)  26-Aug-1993  (ported to WinDbg)

--*/

#include "precomp.h"
#pragma hdrstop


#define  SELECTOR_CACHE_LENGTH          6

typedef struct _sc {
        struct _sc            *nextYoungest;
        struct _sc            *nextOldest;
        USHORT                 processor;
        DESCRIPTOR_TABLE_ENTRY desc;
} SELCACHEENTRY;

SELCACHEENTRY SelectorCache[SELECTOR_CACHE_LENGTH], *selYoungest, *selOldest;

BOOL fInitialized = FALSE;

void
InitSelCache(void)
{
    int     i;

    for(i=0;i<SELECTOR_CACHE_LENGTH;i++){
        SelectorCache[i].nextYoungest = &SelectorCache[i+1];
        SelectorCache[i].nextOldest   = &SelectorCache[i-1];
        SelectorCache[i].processor    = (USHORT)-1;
        SelectorCache[i].desc.Selector = 0;
    }

    SelectorCache[--i].nextYoungest = NULL;
    SelectorCache[0].nextOldest     = NULL;
    selYoungest = &SelectorCache[i];
    selOldest   = &SelectorCache[0];
}

BOOLEAN
FindSelector(USHORT Processor, PDESCRIPTOR_TABLE_ENTRY pdesc)
{
    int     i;


    for(i=0;i<SELECTOR_CACHE_LENGTH;i++) {
        if (SelectorCache[i].desc.Selector == pdesc->Selector &&
            SelectorCache[i].processor == Processor) {
                *pdesc = SelectorCache[i].desc;
                return TRUE;
        }
    }

    return FALSE;
}

void
PutSelector(USHORT Processor, PDESCRIPTOR_TABLE_ENTRY pdesc)
{
    selOldest->desc = *pdesc;
    selOldest->processor = Processor;
    (selOldest->nextYoungest)->nextOldest = NULL;
    selOldest->nextOldest    = selYoungest;
    selYoungest->nextYoungest= selOldest;
    selYoungest = selOldest;
    selOldest   = selOldest->nextYoungest;
}


NTSTATUS
LookupSelector(
    IN USHORT Processor,
    IN OUT PDESCRIPTOR_TABLE_ENTRY pDescriptorTableEntry
    )

/*++

Routine Description:

    Looks up a selector in the GDT or LDT on the host machine.

Arguments:

    Processor - Supplies the processor whose selector is desired.

    pDescriptorTableEntry->Selector - Supplies value of the selector to
                                      be looked up.

    pDescriptorTableEntry->Descriptor - Returns descriptor

Return Value:

    STATUS_SUCCESS - The selector was found in the GDT or LDT, and the
                     Descriptor field pointed to by pDescriptorTableEntry
                     has been filled in with valid data.

    STATUS_UNSUCCESSFUL - The selector's descriptor could not be read from
                     virtual memory.  (Page is invalid or not present)

    STATUS_INVALID_PARAMETER - The selector was not in the GDT or LDT,
                               and the Descriptor field is invalid.

--*/
{
    ULONG Address;
    PVOID TableBase;
    USHORT TableLimit;
    ULONG Result;
    ULONG Index;

    LDT_ENTRY Descriptor;

    if (!fInitialized) {
        fInitialized = TRUE;
        InitSelCache();
    }

    if (FindSelector(Processor, pDescriptorTableEntry)) {
        return(STATUS_SUCCESS);
    }

    //
    // Fetch the address and limit of the GDT
    //

    Address = (ULONG)&(((PX86_NT5_KPROCESSOR_STATE)0)->SpecialRegisters.Gdtr.Base);
    ReadControlSpace((USHORT)Processor, Address,
                     &TableBase, sizeof(TableBase));
    Address = (ULONG)&(((PX86_NT5_KPROCESSOR_STATE)0)->SpecialRegisters.Gdtr.Limit);
    ReadControlSpace((USHORT)Processor, Address,
                     &TableLimit, sizeof(TableLimit));

    Index = (USHORT)(pDescriptorTableEntry->Selector) & ~0x7;
                                                    // Irrelevant bits
    //
    // Check to make sure that the selector is within the table bounds
    //
    if (Index >= TableLimit) {

        //
        // Selector is out of table's bounds
        //

        return(STATUS_INVALID_PARAMETER);
    }
    ReadMemory((DWORD)TableBase+Index,
               &(pDescriptorTableEntry->Descriptor),
               sizeof(pDescriptorTableEntry->Descriptor),
               &Result);
    if(Result != sizeof(pDescriptorTableEntry->Descriptor)) {
        return(STATUS_UNSUCCESSFUL);
    }

    PutSelector(Processor, pDescriptorTableEntry);
    return(STATUS_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\kdexts\p_i386\sel.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    sel.c

Abstract:

    WinDbg Extension Api

Author:

    Ramon J San Andres (ramonsa) 5-Nov-1993

Environment:

    User Mode.

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

DECLARE_API( sel )

/*++

Routine Description:

    Dumps a selector (or range of selectors) from the GDT or LDT and displays
    relevant information about that selector.

Arguments:

    arg - Supplies the selector to examine.  If this is NULL, it dumps a
          range of selectors.

Return Value:

    None

--*/

{
    DESCRIPTOR_TABLE_ENTRY  Entry;
    static ULONG            StartSelector=8;
    static ULONG            EndSelector;
    NTSTATUS                Result;

    if (*args != '\0') {
        sscanf(args,"%lx",&(Entry.Selector));
        StartSelector=EndSelector=Entry.Selector;
    } else {
        EndSelector=StartSelector+0x80;
        Entry.Selector=StartSelector;
    }
    do {
        Result=LookupSelector((USHORT)dwProcessor,&Entry);
        dprintf("%04x  ",(USHORT)Entry.Selector);
        if (Result == STATUS_SUCCESS) {
            dprintf("Bas=%08lx ", (ULONG)Entry.Descriptor.BaseLow +
                        ((ULONG)Entry.Descriptor.HighWord.Bytes.BaseMid << 16) +
                        ((ULONG)Entry.Descriptor.HighWord.Bytes.BaseHi  << 24) );
            dprintf("Lim=%08lx ", (ULONG)Entry.Descriptor.LimitLow +
                        (ULONG)(Entry.Descriptor.HighWord.Bits.LimitHi << 16) );
            dprintf((Entry.Descriptor.HighWord.Bits.Granularity) ? "Pages" : "Bytes");
            dprintf(" DPL=%i ",Entry.Descriptor.HighWord.Bits.Dpl);
            dprintf((Entry.Descriptor.HighWord.Bits.Pres) ? " P " : "NP ");

            if (Entry.Descriptor.HighWord.Bits.Type & 0x10) {
                //
                // Code or Data segment descriptor
                //
                if (Entry.Descriptor.HighWord.Bits.Type & 0x8) {
                    //
                    // Code segment descriptor
                    //
                    dprintf("Code  ");
                    if (Entry.Descriptor.HighWord.Bits.Type & 0x2) {
                        //
                        // Read/Execute
                        //
                        dprintf("RE ");
                    } else {
                        dprintf("EO ");
                    }
                } else {
                    //
                    // Data segment descriptor
                    //
                    dprintf("Data  ");
                    if (Entry.Descriptor.HighWord.Bits.Type & 0x2) {
                        //
                        // Read/Write
                        //
                        dprintf("RW ");
                    } else {
                        dprintf("RO ");
                    }
                }
                if (Entry.Descriptor.HighWord.Bits.Type & 0x1) {
                    //
                    // Accessed
                    //
                    dprintf("A ");
                }
            } else {
                //
                // System Segment or Gate Descriptor
                //
                switch (Entry.Descriptor.HighWord.Bits.Type) {
                    case 2:
                        //
                        // LDT
                        //
                        dprintf("LDT  ");
                        break;
                    case 1:
                    case 3:
                    case 9:
                    case 0xB:
                        //
                        // TSS
                        //
                        if (Entry.Descriptor.HighWord.Bits.Type & 0x8) {
                            dprintf("TSS32    ");
                        } else {
                            dprintf("TSS16    ");
                        }
                        if (Entry.Descriptor.HighWord.Bits.Type & 0x2) {
                            dprintf("B ");
                        } else {
                            dprintf("A ");
                        }
                        break;

                    case 4:
                        dprintf("C-GATE16   ");
                        break;
                    case 5:
                        dprintf("TSK-GATE   ");
                        break;
                    case 6:
                        dprintf("I-GATE16   ");
                        break;
                    case 7:
                        dprintf("TRP-GATE16 ");
                        break;
                    case 0xC:
                        dprintf("C-GATE32   ");
                        break;
                    case 0xF:
                        dprintf("T-GATE32   ");
                        break;

                }

            }

            dprintf("\n");

        } else {
            if (Result == STATUS_UNSUCCESSFUL) {
                dprintf("LDT page is invalid\n");
            } else {
                dprintf("Selector is invalid\n");
            }
        }

        Entry.Selector += 8;
    } while ( Entry.Selector < EndSelector );
    StartSelector = EndSelector;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\kdexts\p_i386\tss.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    tss.c

Abstract:

    WinDbg Extension Api

Author:

    Ramon J San Andres (ramonsa) 5-Nov-1993

    Peter L Johnston   (peterj) 28-Jan-1999
        Pulled TaskGate2TrapFrame inline and made it dump the rest of
        the TSS.

Environment:

    User Mode.

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop


ULONG_PTR
Selector2Address(
    USHORT      Processor,
    USHORT      TaskRegister
    )
{
    DESCRIPTOR_TABLE_ENTRY desc;

    //
    // Lookup task register
    //

    desc.Selector = TaskRegister;
    if (!NT_SUCCESS(LookupSelector(Processor, &desc))) {

        //
        // Can't do it.
        //

        return 0;
    }

    if (desc.Descriptor.HighWord.Bits.Type != 9  &&
        desc.Descriptor.HighWord.Bits.Type != 0xb) {

        //
        // not a 32bit task descriptor
        //

        return 0;
    }

    //
    // Read in Task State Segment
    //

    return ((ULONG)desc.Descriptor.BaseLow +
           ((ULONG)desc.Descriptor.HighWord.Bytes.BaseMid << 16) +
           ((ULONG)desc.Descriptor.HighWord.Bytes.BaseHi  << 24) );

}

DECLARE_API( tss )

/*++

Routine Description:



Arguments:

    args -

Return Value:

    None

--*/

{

#define MAX_RING 3

    ULONG       taskRegister;
    KTRAP_FRAME trapFrame;
    PUCHAR      buf;
    ULONG_PTR   hostAddress;
    BOOLEAN     extendedDump;
    ULONG       i;
    char ExprBuf[256] ;

    struct  {       // intel's TSS format
        ULONG   Previous;
        struct {
            ULONG   Esp;
            ULONG   Ss;
        } Ring[MAX_RING];
        ULONG   Cr3;
        ULONG   Eip;
        ULONG   EFlags;
        ULONG   Eax;
        ULONG   Ecx;
        ULONG   Edx;
        ULONG   Ebx;
        ULONG   Esp;
        ULONG   Ebp;
        ULONG   Esi;
        ULONG   Edi;
        ULONG   Es;
        ULONG   Cs;
        ULONG   Ss;
        ULONG   Ds;
        ULONG   Fs;
        ULONG   Gs;
        ULONG   Ldt;
        USHORT  T;
        USHORT  IoMapBase;
    } TSS;

    buf = (PUCHAR)&TSS;
    *buf = '\0';

    sscanf(args,"%s %s", ExprBuf, buf);

    if (ExprBuf[0]) {
        if (IsHexNumber(ExprBuf)) {
            sscanf(ExprBuf, "%lx", &taskRegister) ;
        } else {
            taskRegister = GetExpression(ExprBuf);
            if (taskRegister==0) {
                dprintf("An error occured trying to evaluate the expression\n") ;
                return;
            }
        }
    }

    //
    // If user specified a 2nd parameter, doesn't matter what it is,
    // dump the portions of the TSS not covered by the trap frame dump.
    //

    extendedDump = *buf != '\0';

    if (HIWORD(taskRegister) == 0) {

        hostAddress = Selector2Address((USHORT)dwProcessor, (USHORT)taskRegister);

        if (!hostAddress) {
            dprintf("unable to get Task State Segment address from selector %lX\n",
                    taskRegister);
            return;
        }

    } else {
        hostAddress = taskRegister;
    }

    if (!xReadMemory((PVOID)hostAddress,
                     &TSS,
                     sizeof(TSS))) {
        dprintf("unable to read Task State Segment from host address %p\n",
                hostAddress);
        return;
    }

    //
    // Display it.
    //

    if (extendedDump) {
        dprintf("\nTask State Segment at 0x%p\n\n", hostAddress);
        dprintf("Previous Task Link   = %4x\n", TSS.Previous);
        for (i = 0 ; i < MAX_RING ; i++) {
            dprintf("Esp%d = %8x  SS%d = %4x\n",
                    i, TSS.Ring[i].Esp,
                    i, TSS.Ring[i].Ss);
        }
        dprintf("CR3 (PDBR)           = %08x\n", TSS.Cr3);
        dprintf("I/O Map Base Address = %4x, Debug Trap (T) = %s\n",
                TSS.IoMapBase,
                TSS.T == 0 ? "False" : "True");
        dprintf("\nSaved General Purpose Registers\n\n");
    }

    //
    // Move fields from Task State Segment to TrapFrame and display
    // the registers in the familiar format.
    //

    trapFrame.Eip    = TSS.Eip;
    trapFrame.EFlags = TSS.EFlags;
    trapFrame.Eax    = TSS.Eax;
    trapFrame.Ecx    = TSS.Ecx;
    trapFrame.Edx    = TSS.Edx;
    trapFrame.Ebx    = TSS.Ebx;
    trapFrame.Ebp    = TSS.Ebp;
    trapFrame.Esi    = TSS.Esi;
    trapFrame.Edi    = TSS.Edi;
    trapFrame.SegCs  = TSS.Cs;
    trapFrame.HardwareEsp = TSS.Esp;
    trapFrame.HardwareSegSs = TSS.Ss;

    DisplayTrapFrame (&trapFrame, 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\kdexts\p_i386\trap.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    trap.c

Abstract:

    WinDbg Extension Api

Author:

    Ramon J San Andres (ramonsa) 5-Nov-1993

Environment:

    User Mode.

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

extern ULONG   STeip, STebp, STesp;
extern ULONG ThreadLastDump;


BOOL
ReadTrapFrame (
    IN ULONG          VirtualAddress,
    OUT PKTRAP_FRAME  TrapFrame
    );





DECLARE_API( trap )

/*++

Routine Description:



Arguments:

    args -

Return Value:

    None

--*/

{
    ULONG           Address;
    KTRAP_FRAME     TrapFrame;

    sscanf(args,"%lX", &Address);
    if ( !ReadTrapFrame (Address, &TrapFrame) ) {
        dprintf("unable to get trap frame contents\n");
        return;
    }

    DisplayTrapFrame (&TrapFrame, Address);
}




VOID
DoStackTrace(
    LPSTR args,
    ULONG ulType,
    ULONG Thread
    )
{
    ULONG           Count;
    ULONG           Frames;
    ULONG           i;
    PEXTSTACKTRACE  stk;
    CHAR            Buffer[80];
    ULONG           displacement;

    if (STebp == 0 && STeip == 0 && STesp == 0) {
        dprintf("no frame displayed\n");
        return;
    }

    Count = 100;
    sscanf(args,"%lX",&Count);

    stk = (PEXTSTACKTRACE) LocalAlloc( LPTR, Count * sizeof(EXTSTACKTRACE) );
    if (!stk) {
        dprintf("no frame displayed\n");
        return;
    }

    stk[0].FramePointer = ulType;

    SetThreadForOperation( &Thread );
    Frames = StackTrace( STebp, STesp, STeip, stk, Count );

    for (i=0; i<Frames; i++) {
        if (i==0) {
            dprintf( "ChildEBP RetAddr  Args to Child\n" );
        }

        Buffer[0] = '!';
        GetSymbol((LPVOID)stk[i].ProgramCounter, Buffer, &displacement);

        dprintf( "%08x %08x %08x %08x %08x %s",
                 stk[i].FramePointer,
                 stk[i].ReturnAddress,
                 stk[i].Args[0],
                 stk[i].Args[1],
                 stk[i].Args[2],
                 Buffer
               );

        if (displacement) {
            dprintf( "+0x%x", displacement );
        }

        dprintf( "\n" );
    }

    LocalFree( stk );
}


DECLARE_API( kb )

/*++

Routine Description:



Arguments:

    args -

Return Value:

    None

--*/

{
    DoStackTrace( (PSTR)args, 1, ThreadLastDump );
}


DECLARE_API( kv )

/*++

Routine Description:



Arguments:

    args -

Return Value:

    None

--*/

{
    DoStackTrace( (PSTR)args, 2, ThreadLastDump );
}


BOOL
ReadTrapFrame (
    IN ULONG          VirtualAddress,
    OUT PKTRAP_FRAME  TrapFrame
    )
{
    ULONG       bytesread;

    if ( !ReadMemory(
                 VirtualAddress,
                 TrapFrame,
                 sizeof (*TrapFrame),
                 &bytesread ) ) {
        return FALSE;
    }

    if (bytesread < sizeof(*TrapFrame)) {
        if (bytesread < sizeof(*TrapFrame) - 20) {
            //
            // shorter then the smallest possible frame type
            //

            return FALSE;
        }

        if ((TrapFrame->SegCs & 1) &&  bytesread < sizeof(*TrapFrame) - 16 ) {
            //
            // too small for inter-ring frame
            //

            return FALSE;
        }

        if (TrapFrame->EFlags & EFLAGS_V86_MASK) {
            //
            // too small for V86 frame
            //

            return FALSE;
        }
    }

    return TRUE;
}


VOID
DisplayTrapFrame (
    IN PKTRAP_FRAME TrapFrame,
    ULONG           FrameAddress
    )
{
    USHORT SegSs;
    UCHAR Buffer[200];
    DESCRIPTOR_TABLE_ENTRY Descriptor;
    ULONG Esp;
    ULONG DisasmAddr;
    CONTEXT Context;

    dprintf("eax=%08lx ebx=%08lx ecx=%08lx edx=%08lx esi=%08lx edi=%08lx\n",
                TrapFrame->Eax,
                TrapFrame->Ebx,
                TrapFrame->Ecx,
                TrapFrame->Edx,
                TrapFrame->Esi,
                TrapFrame->Edi);

    //
    // Figure out ESP
    //

    if (((TrapFrame->SegCs & MODE_MASK) != KernelMode) ||
        (TrapFrame->EFlags & EFLAGS_V86_MASK) ||
        FrameAddress == 0) {

        // User-mode frame, real value of Esp is in HardwareEsp
        Esp = TrapFrame->HardwareEsp;

    } else {

        //
        // We ignore if Esp has been edited for now, and we will print a
        // separate line indicating this later.
        //
        // Calculate kernel Esp
        //

        Esp = (ULONG)(&(((PKTRAP_FRAME)FrameAddress)->HardwareEsp));

    }

    dprintf("eip=%08lx esp=%08lx ebp=%08lx iopl=%1lx         "
        "%s %s %s %s %s %s %s %s\n",
                TrapFrame->Eip,
                Esp,
                TrapFrame->Ebp,
                ((TrapFrame->EFlags >> 12) & 3),
        (TrapFrame->EFlags & 0x800) ? "ov" : "nv",
        (TrapFrame->EFlags & 0x400) ? "dn" : "up",
        (TrapFrame->EFlags & 0x200) ? "ei" : "di",
        (TrapFrame->EFlags & 0x80) ? "ng" : "pl",
        (TrapFrame->EFlags & 0x40) ? "zr" : "nz",
        (TrapFrame->EFlags & 0x10) ? "ac" : "na",
        (TrapFrame->EFlags & 0x4) ? "po" : "pe",
        (TrapFrame->EFlags & 0x1) ? "cy" : "nc");

    // Check whether P5 Virtual Mode Extensions are enabled, for display
    // of new EFlags values.

    if ( GetExpression("@Cr4") != 0) {
        dprintf("vip=%1lx    vif=%1lx\n",
        (TrapFrame->EFlags & 0x00100000L) >> 20,
        (TrapFrame->EFlags & 0x00080000L) >> 19);
    }

    //
    // Find correct SS
    //

    if (TrapFrame->EFlags & EFLAGS_V86_MASK){
        SegSs = (USHORT)(TrapFrame->HardwareSegSs & 0xffff);
    } else if ((TrapFrame->SegCs & MODE_MASK) != KernelMode) {

        //
        // It's user mode.  The HardwareSegSs contains R3 data selector.
        //

        SegSs = (USHORT)(TrapFrame->HardwareSegSs | RPL_MASK) & 0xffff;
    } else {
        SegSs = KGDT_R0_DATA;
    }


    dprintf("cs=%04x  ss=%04x                                    "
            "             efl=%08lx\n",
                (USHORT)(TrapFrame->SegCs & 0xffff),
                (USHORT)(SegSs & 0xffff),
                TrapFrame->EFlags);

    //
    // Check to see if Esp has been edited, and dump new value if it has
    //
    if ( (!(TrapFrame->EFlags & EFLAGS_V86_MASK)) &&
         ((TrapFrame->SegCs & MODE_MASK) == KernelMode)) {

        if ((TrapFrame->SegCs & FRAME_EDITED) == 0) {

            dprintf("ESP EDITED! New esp=%08lx\n",TrapFrame->TempEsp);
        }
    }

    if (FrameAddress) {
        dprintf("ErrCode = %08lx\n", TrapFrame->ErrCode);
    }

    if (TrapFrame->EFlags & EFLAGS_V86_MASK) {

        DisasmAddr = ((ULONG)((USHORT)TrapFrame->SegCs & 0xffff) << 4) +
                     (TrapFrame->Eip & 0xffff);

    } else {

        Descriptor.Selector = TrapFrame->SegCs;
        LookupSelector(0, &Descriptor);

        if (Descriptor.Descriptor.HighWord.Bits.Default_Big) {
            DisasmAddr = TrapFrame->Eip;
        } else {
            DisasmAddr = TrapFrame->Eip & 0xffff;
        }

    }

    if (Disasm(&DisasmAddr, Buffer, FALSE)) {

        dprintf(Buffer);

    } else {

        dprintf("%08lx ???????????????\n", TrapFrame->Eip);

    }

    dprintf("\n");

    //
    // Save eip, esp, ebp for quick backtrace from this frame
    //

    STeip = TrapFrame->Eip;
    STesp = Esp;
    STebp = TrapFrame->Ebp;

    return;
}


NTSTATUS
TaskGate2TrapFrame(
    DWORD           Processor,
    USHORT          TaskRegister,
    PKTRAP_FRAME    TrapFrame,
    PULONG          off
    )
{
    DESCRIPTOR_TABLE_ENTRY desc;
    ULONG    bytesread;
    NTSTATUS status;
    struct  {       // intel's TSS format
        ULONG   r1[8];
        ULONG   Eip;
        ULONG   EFlags;
        ULONG   Eax;
        ULONG   Ecx;
        ULONG   Edx;
        ULONG   Ebx;
        ULONG   Esp;
        ULONG   Ebp;
        ULONG   Esi;
        ULONG   Edi;
        ULONG   Es;
        ULONG   Cs;
        ULONG   Ss;
        ULONG   Ds;
        ULONG   Fs;
        ULONG   Gs;
    } TaskState;

    //
    // Lookup task register
    //

    desc.Selector = TaskRegister;
    status =  LookupSelector((USHORT)Processor, &desc);
    if (status != STATUS_SUCCESS) {
        return status;
    }

    if (desc.Descriptor.HighWord.Bits.Type != 9  &&
        desc.Descriptor.HighWord.Bits.Type != 0xb) {

        // not a 32bit task descriptor
        return(STATUS_UNSUCCESSFUL);
    }

    //
    // Read in Task State Segment
    //

    *off = ((ULONG)desc.Descriptor.BaseLow +
           ((ULONG)desc.Descriptor.HighWord.Bytes.BaseMid << 16) +
           ((ULONG)desc.Descriptor.HighWord.Bytes.BaseHi  << 24) );

    if ( !ReadMemory(
                 *off,
                 &TaskState,
                 sizeof (TaskState),
                 &bytesread) ) {
        return(STATUS_UNSUCCESSFUL);
    }

    //
    // Move fields from Task State Segment to TrapFrame
    //

    TrapFrame->Eip    = TaskState.Eip;
    TrapFrame->EFlags = TaskState.EFlags;
    TrapFrame->Eax    = TaskState.Eax;
    TrapFrame->Ecx    = TaskState.Ecx;
    TrapFrame->Edx    = TaskState.Edx;
    TrapFrame->Ebx    = TaskState.Ebx;
    TrapFrame->Ebp    = TaskState.Ebp;
    TrapFrame->Esi    = TaskState.Esi;
    TrapFrame->Edi    = TaskState.Edi;
    TrapFrame->SegCs  = TaskState.Cs;
    TrapFrame->HardwareEsp = TaskState.Esp;
    TrapFrame->HardwareSegSs = TaskState.Ss;

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\libver\libver.cpp ===
/*++

Copyright (c) 2002  Microsoft Corporation

Module Name:

    libver.cpp

Abstract:

    This module implements a program to dump the version of an Xbox library.

--*/

#include "libverp.h"

CHAR g_szCurFilePath[MAX_PATH];
PSTR g_pszCurFilename;
XBEIMAGE_LIBRARY_VERSION g_LibVer = { 0 };
UINT g_cLibVers = 0;

const CHAR* LibvApprovedStatus[] = {
    "unapproved",
    "possibly approved",
    "approved"
};

DECLSPEC_NORETURN
VOID
LibvExitProcess(
    int ExitCode
    )
{
    exit(ExitCode);
}


VOID
LibvFormatVersion(
    PSTR pszVersion,
    PXBEIMAGE_LIBRARY_VERSION pLibVer
    )
{
    wsprintf(pszVersion,
             "%8.8s.LIB %d.%d.%d.%d%s [%s]",
             pLibVer->LibraryName,
             pLibVer->MajorVersion,
             pLibVer->MinorVersion,
             pLibVer->BuildVersion,
             pLibVer->QFEVersion,
             pLibVer->DebugBuild ? " (Debug)" : "",
             LibvApprovedStatus[pLibVer->ApprovedLibrary]);
}


VOID
LibvParseOutputLine(
    PSTR pszLine
    )
{
    DWORD dwAddr;
    UINT rgbVerData[16];
    BYTE rgbyteVerData[16];
    PXBEIMAGE_LIBRARY_VERSION pLibVer = (PXBEIMAGE_LIBRARY_VERSION) rgbyteVerData;
    CHAR szTextData[17];
    
    if (18 != sscanf(pszLine,
                     "  %08x: %02x %02x %02x %02x %02x %02x %02x %02x "
                     "%02x %02x %02x %02x %02x %02x %02x %02x %s",
                     &dwAddr,
                     &(rgbVerData[0]), &(rgbVerData[1]),
                     &(rgbVerData[2]), &(rgbVerData[3]),
                     &(rgbVerData[4]), &(rgbVerData[5]),
                     &(rgbVerData[6]), &(rgbVerData[7]),
                     &(rgbVerData[8]), &(rgbVerData[9]),
                     &(rgbVerData[10]), &(rgbVerData[11]),
                     &(rgbVerData[12]), &(rgbVerData[13]),
                     &(rgbVerData[14]), &(rgbVerData[15]),
                     szTextData))
    {
        //
        // Not a rawdata dump line
        //
        
        return;
    }

    for (int i = 0; i < ARRAYSIZE(rgbyteVerData); i++)
    {
        rgbyteVerData[i] = (BYTE) rgbVerData[i];
    }

    if (0 == g_cLibVers)
    {
        g_LibVer = *pLibVer;
    }
    else
    {
        if (0 != memcmp(&g_LibVer, pLibVer, sizeof(g_LibVer)))
        {
            CHAR szVersion[64];
            LibvFormatVersion(szVersion, pLibVer);
            LibvResourcePrintWarning(IDS_MULTIPLE_VERSIONS, g_pszCurFilename, szVersion);
        }
    }

    g_cLibVers++;
}

void
__cdecl
main(
    int argc,
    char *argv[]
    )
{
    if ((argc != 2) ||
        (0 == lstrcmp(argv[1], "/?")) ||
        (0 == lstrcmp(argv[1], "-?")) ||
        (0 == lstrcmpi(argv[1], "/help")) ||
        (0 == lstrcmpi(argv[1], "-help")))
    {
        LibvResourcePrintLogoBanner();
        LibvResourcePrintRange(stderr, IDS_LIBVER_USAGE);
        LibvExitProcess(0);
    }

    HANDLE hFind;
    WIN32_FIND_DATA wfd;
    CHAR szPath[MAX_PATH];

    lstrcpyn(szPath, argv[1], ARRAYSIZE(szPath));
    if (PathIsDirectory(szPath))
    {
        PathAppend(szPath, "*");
    }
    
    hFind = FindFirstFile(szPath, &wfd);
    
    PathRemoveFileSpec(szPath);

    if (INVALID_HANDLE_VALUE == hFind)
    {
        LibvResourcePrintErrorAndExit(IDS_CANNOT_OPEN_INPUT_FILE, argv[1]);
    }

    while (INVALID_HANDLE_VALUE != hFind)
    {
        if (0 == (wfd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
        {
            PathCombine(g_szCurFilePath, szPath, wfd.cFileName);
            g_pszCurFilename = wfd.cFileName;

            CHAR szLinkCmdLine[MAX_PATH * 2];
            wsprintf(szLinkCmdLine, "link /dump /rawdata /section:.XBLD$A /section:.XBLD$V %s", g_szCurFilePath);

            HANDLE hReadPipe, hWritePipe;
            SECURITY_ATTRIBUTES sa;
            sa.nLength = sizeof(sa);
            sa.lpSecurityDescriptor = NULL;
            sa.bInheritHandle = TRUE;
            
            if (!CreatePipe(&hReadPipe, &hWritePipe, &sa, 0))
            {
                LibvResourcePrintErrorAndExit(IDS_NO_MEMORY);
            }

            PROCESS_INFORMATION pi;
            STARTUPINFO si;
            ZeroMemory(&si, sizeof(si));
            si.cb = sizeof(si);
            si.dwFlags = STARTF_USESTDHANDLES;
            si.hStdInput = GetStdHandle(STD_INPUT_HANDLE);
            si.hStdOutput = hWritePipe;
            si.hStdError = hWritePipe;

            if (!CreateProcess(NULL,
                               szLinkCmdLine,
                               NULL,
                               NULL,
                               TRUE,
                               0,
                               NULL,
                               NULL,
                               &si,
                               &pi))
            {
                LibvResourcePrintErrorAndExit(IDS_COULD_NOT_INVOKE_LINK);
            }

            CloseHandle(hWritePipe);
            CloseHandle(pi.hProcess);
            CloseHandle(pi.hThread);

            DWORD dwBytesRead;
            CHAR szBuffer[2048];
            CHAR szLineBuffer[256];
            DWORD dwCurBufferPos = 0;

            while (ReadFile(hReadPipe,
                            &(szBuffer[dwCurBufferPos]),
                            ARRAYSIZE(szBuffer) - dwCurBufferPos - 1,
                            &dwBytesRead,
                            NULL) && (0 != dwBytesRead))
            {
                DWORD dwCurLinePos = 0;

                szBuffer[dwCurBufferPos + dwBytesRead] = '\0';
                PSTR pszLastGoodLine = szBuffer;
                PSTR pszCRLF = strstr(szBuffer, "\r\n");

                if (NULL == pszCRLF)
                {
                    LibvResourcePrintErrorAndExit(IDS_INTERNAL_TOOL_ERROR, __LINE__);
                }

                while (pszCRLF)
                {
                    DWORD dwLineLength = (pszCRLF - szBuffer) - dwCurLinePos;

                    if (dwLineLength > (ARRAYSIZE(szLineBuffer) - 1))
                    {
                        printf("Line length = %d\n", dwLineLength);
                        LibvResourcePrintErrorAndExit(IDS_INTERNAL_TOOL_ERROR, __LINE__);
                    }
                    
                    if (dwLineLength != 0)
                    {
                        CopyMemory(szLineBuffer,
                                   &(szBuffer[dwCurLinePos]),
                                   dwLineLength);

                        szLineBuffer[dwLineLength] = '\0';

                        LibvParseOutputLine(szLineBuffer);
                    }

                    //
                    // Skip past this line and the CRLF pair
                    //
                    
                    dwCurLinePos += (dwLineLength + 2);
                    
                    pszLastGoodLine = pszCRLF + 2;
                    pszCRLF = strstr(&(szBuffer[dwCurLinePos]), "\r\n");
                }

                //
                // Shift the remaining buffer back to the beginning of the buffer and
                // then read the next chunk
                //
                
                dwCurBufferPos = (dwCurBufferPos + dwBytesRead) - (pszLastGoodLine - szBuffer);

                RtlMoveMemory(szBuffer,
                              pszLastGoodLine,
                              dwCurBufferPos);
            }

            CloseHandle(hReadPipe);

            if (0 != g_cLibVers)
            {
                CHAR szVersion[64];
                LibvFormatVersion(szVersion, &g_LibVer);
                LibvResourcePrintf(stdout, IDS_VERSION_OUTPUT, g_pszCurFilename, szVersion, g_cLibVers);
                fputs("\n", stdout);
            }
            else
            {
                LibvResourcePrintWarning(IDS_NO_VERSION_DETECTED, g_pszCurFilename);
            }

            g_cLibVers = 0;
        }

        if (!FindNextFile(hFind, &wfd))
        {
            FindClose(hFind);
            hFind = INVALID_HANDLE_VALUE;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\kdexts\p_i386\x86api.h ===
/////////////////////////////////////////////
//
//  Memory.c
//
/////////////////////////////////////////////

BOOLEAN
MiGetPhysicalAddress (
    IN PVOID Address,
    OUT PULONG64 PhysAddress
    );



/////////////////////////////////////////////
//
//  Selector.c
//
/////////////////////////////////////////////

NTSTATUS
LookupSelector(
    IN USHORT Processor,
    IN OUT PDESCRIPTOR_TABLE_ENTRY pDescriptorTableEntry
    );



/////////////////////////////////////////////
//
//  Trap.c
//
/////////////////////////////////////////////

VOID
DisplayTrapFrame (
    IN PKTRAP_FRAME TrapFrame,
    ULONG           FrameAddress
    );

NTSTATUS
TaskGate2TrapFrame(
    DWORD           Processor,
    USHORT          TaskRegister,
    PKTRAP_FRAME    TrapFrame,
    PULONG          off
    );
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\mapdiff\mapdiff.c ===
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <dbghelp.h>

void Usage()
{
    fprintf(stderr, "\n");
    fprintf(stderr, "Usage: mapdiff [-v] <mapfile1.map> { <mapfile2.map> }\n\n");
    fprintf(stderr, "  mapdiff reads a .map file and outputs a friendly report\n");
    fprintf(stderr, "  showing the sizes of sections and symbols.\n\n");
    fprintf(stderr, "  When two .map files are given, mapdiff computes a delta\n");
    fprintf(stderr, "  between the two and reports on the differences.  This is\n");
    fprintf(stderr, "  useful when comparing a new version of a program to a previous\n");
    fprintf(stderr, "  version to see the effect of the changes.  Only sections and\n");
    fprintf(stderr, "  symbols which have changed size are shown by default.  Use\n");
    fprintf(stderr, "  the -v switch to force all sections and symbols to be shown.\n");
    exit(1);
}

typedef struct SECINFO {
    UINT        iSeg;               // Segment number of section
    DWORD       dwOffset;           // Offset into segment where section begins
    DWORD       dwLength;           // Length of section
    char *      pszName;            // Name of section
    BOOL        fIsData;            // TRUE if this is a data section
} SECINFO;

typedef struct SECDIFF {
    SECINFO *   psi1;               // Pointer to section in first map (may be NULL)
    SECINFO *   psi2;               // Pointer to section in second map (may be NULL)
} SECDIFF;

typedef struct FUNINFO {
    UINT        iSeg;               // Segment number of function
    DWORD       dwOffset;           // Offset into segment where function begins
    DWORD       dwLength;           // Length of function
    DWORD       dwAddress;          // Absolute address of function
    char *      pszName;            // Name of function
    char *      pszModule;          // Name of lib:object containing function
    SECINFO *   psi;                // The section that this function belongs to
    BOOL        fIsStatic;          // TRUE if static function
} FUNINFO;

typedef struct FUNDIFF {
    FUNINFO *   pfi1;               // Pointer to function in first map (may be NULL)
    FUNINFO *   pfi2;               // Pointer to function in second map (may be NULL)
} FUNDIFF;

typedef struct MAPINFO {
    char *      pszFile;            // File name of map file
    char *      pszName;            // Map name from first line of map file
    char *      pszTimestamp;       // Timestamp for map file
    DWORD       dwBase;             // Preferred load address
    UINT        iSegEntry;          // Entry point segment
    DWORD       dwEntry;            // Entry point offset
    DWORD       cbSecCode;          // Size of all code sections
    DWORD       cbSecData;          // Size of all data sections
    DWORD       cbFunCode;          // Size of all functions in code sections
    DWORD       cbFunData;          // Size of all functions in data sections
    UINT        cSecInfo;           // Count of sections in section array
    UINT        cSecCode;           // Count of sections of code
    DWORD       cSecData;           // Count of sections of data
    SECINFO **  ppSecInfo;          // Array of sections
    UINT        cFunInfo;           // Count of functions in function array
    UINT        cFunCode;           // Count of functions in code sections
    UINT        cFunData;           // Count of functions in data sections
    FUNINFO **  ppFunInfo;          // Array of functions
} MAPINFO;

static DWORD dwStatic = 0;

char *
Undecorate(char * pszName)
{
    char szOrig[512];
    char szUndec[512];

    memset(szOrig, 0, sizeof(szOrig));
    memset(szUndec, 0, sizeof(szUndec));
    
    strcpy(szOrig, pszName);

    UnDecorateSymbolName(pszName, szUndec, sizeof(szUndec), 
                         UNDNAME_NAME_ONLY | UNDNAME_NO_ALLOCATION_MODEL | UNDNAME_NO_ALLOCATION_LANGUAGE);

    if (szUndec[0] && !lstrcmpi(szUndec, "`string'") == 0)
    {
        char * pch = szUndec;
        while (*pch && !isspace(*pch)) ++pch;
        *pch = 0;
        return(_strdup(szUndec));
    }

    return(pszName);
}

void *
MemAlloc(size_t size, BOOL fZero)
{
    void * pv = malloc(size);

    if (pv == NULL)
    {
        fprintf(stderr, "Out of memory allocating %d bytes\n", size);
        exit(1);
    }

    memset(pv, 0, size);

    return(pv);
}

void
ReadTextFile(char * pszFile, UINT * pcLines, char *** pppszLines)
{
    HANDLE  hFile;
    DWORD   dwSize;
    DWORD   dwRead;
    char *  pchBuf;
    char *  pch;
    char *  pchEnd;
    char ** ppszLines;
    UINT    cLines;

    hFile = CreateFile(pszFile, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN, NULL);
    if (hFile == INVALID_HANDLE_VALUE)
    {
        fprintf(stderr, "Error opening '%s' (%d)\n", pszFile, GetLastError());
        exit(1);
    }
    
    dwSize = GetFileSize(hFile, NULL);

    if (dwSize == 0xFFFFFFFF)
    {
        fprintf(stderr, "Error getting size of '%s' (%d)\n", pszFile, GetLastError());
        exit(1);
    }

    pchBuf = MemAlloc(dwSize + 1, FALSE);

    if (ReadFile(hFile, pchBuf, dwSize, &dwRead, NULL) == 0)
    {
        fprintf(stderr, "Error reading contents of '%s' (%d)\n", pszFile, GetLastError());
        exit(1);
    }

    CloseHandle(hFile);

    // Scan the counting the number of lines.  The last line might not end with a
    // '\r\n', so the minimum number of lines will always be one.

    cLines = 1;
    pch = pchBuf;
    pchEnd = pchBuf + dwSize;

    for (; pch < pchEnd; ++pch)
    {
        if (*pch == '\n' || *pch == '\r')
        {
            cLines += 1;

            // Allow '\n', '\r\n', or '\n\r'

            if (    (pch + 1) < pchEnd
                &&  (   (*pch == '\n' && *(pch + 1) == '\r')
                     || (*pch == '\r' && *(pch + 1) == '\n')))
            {
                ++pch;
            }
        }
    }

    *pcLines = cLines;
    ppszLines = *pppszLines = MemAlloc(cLines * sizeof(char *), FALSE);

    pch = pchBuf;
    *ppszLines++ = pch;

    for (; pch < pchEnd; ++pch)
    {
        if (*pch == '\n' || *pch == '\r')
        {
            // Allow '\n', '\r\n', or '\n\r'

            if (    (pch + 1) < pchEnd
                &&  (   (*pch == '\n' && *(pch + 1) == '\r')
                     || (*pch == '\r' && *(pch + 1) == '\n')))
            {
                *pch = 0;
                *++pch = 0;
            }
            else
            {
                *pch = 0;
            }

            if ((pch + 1) <= pchEnd)
            {
                *ppszLines++ = pch + 1;
            }
        }
    }

    *pchEnd = 0;

    if (ppszLines - *pppszLines != (int)cLines)
    {
        fprintf(stderr, "Assert: ReadTextFile screwed up the line array\n");
        exit(1);
    }
}

static void
ParseError(char * pszFile, UINT iLine, char * pszError)
{
    fprintf(stderr, "Error parsing map file '%s':\n", pszFile);
    fprintf(stderr, "  Line %d: %s\n", iLine + 1, pszError);
    exit(1);
}

char *
skipspace(char * psz)
{
    while (*psz && isspace(*psz))
        ++psz;
    return(psz);
}

char *
skipnonspace(char * psz)
{
    while (*psz && !isspace(*psz))
        ++psz;
    return(psz);
}

char *
skiptochar(char * psz, char c)
{
    while (*psz && *psz != c)
        ++psz;
    return(psz);
}

char *
prefixmatch(char * psz, char * pszPrefix)
{
    int len1 = lstrlen(pszPrefix);
    int len2 = lstrlen(psz);

    if (len1 <= len2 && memcmp(pszPrefix, psz, len1) == 0)
    {
        return(psz + len1);
    }

    return(NULL);
}

DWORD
parsehex(char * psz)
{
    DWORD dw = 0;

    for (; *psz && !isspace(*psz); ++psz)
    {
        if (*psz >= '0' && *psz <= '9')
        {
            dw = (dw << 4) | (*psz - '0');
        }
        else if (*psz >= 'A' && *psz <= 'F')
        {
            dw = (dw << 4) | ((*psz - 'A') + 10);
        }
        else if (*psz >= 'a' && *psz <= 'f')
        {
            dw = (dw << 4) | ((*psz - 'a') + 10);
        }
        else
        {
            break;
        }
    }

    return(dw);
}

char *
nextline(char * pszFile, UINT * piLine, UINT * pcLines, char *** pppsz, BOOL fEofOk)
{
    if (*piLine >= *pcLines || (*piLine == *pcLines && !fEofOk))
    {
        ParseError(pszFile, *piLine, "unexpected enf of file");
    }

    if (*piLine == *pcLines)
        return(NULL);

    *piLine += 1;
    *pppsz += 1;
    return(**pppsz);
}

char *
skipblanklines(char * pszFile, UINT * piLine, UINT * pcLines, char *** pppsz, BOOL fEofOk)
{
    do
    {
        *piLine += 1;
        *pppsz += 1;

        if (*piLine >= *pcLines)
        {
            if (fEofOk)
            {
                return(NULL);
            }

            ParseError(pszFile, *piLine, "unexpected end of file");
        }
    }
    while (*skipspace(**pppsz) == 0);
        
    return(**pppsz);
}

int __cdecl
comparefuninfosegoffset(const void * pv1, const void * pv2)
{
    FUNINFO * pfi1 = *(FUNINFO **)pv1;
    FUNINFO * pfi2 = *(FUNINFO **)pv2;

    if (pfi1->iSeg < pfi2->iSeg)
        return(-1);
    else if (pfi1->iSeg > pfi2->iSeg)
        return(+1);
    else if (pfi1->dwOffset < pfi2->dwOffset)
        return(-1);
    else if (pfi1->dwOffset > pfi2->dwOffset)
        return(+1);
    else
        return(0);
}

int __cdecl
comparefuninfoname(const void * pv1, const void * pv2)
{
    FUNINFO * pfi1 = *(FUNINFO **)pv1;
    FUNINFO * pfi2 = *(FUNINFO **)pv2;
    int i;

    i = lstrcmpi(pfi1->pszName, pfi2->pszName);

    if (i == 0)
    {
        i = lstrcmpi(pfi1->pszModule, pfi2->pszModule);

        if (i == 0)
        {
            i = lstrcmpi(pfi1->psi->pszName, pfi2->psi->pszName);

            if (i == 0)
            {
                i = comparefuninfosegoffset(pv1, pv2);
            }
        }
    }

    return(i);
}

int __cdecl
comparefuninfodiff(FUNINFO * pfi1, FUNINFO * pfi2)
{
    if (pfi2 == NULL)
        return(-1);
    else if (pfi1 == NULL)
        return(+1);
    else
        return(lstrcmpi(pfi1->pszName, pfi2->pszName));
}

int __cdecl
comparefundiff(const void * pv1, const void * pv2)
{
    FUNDIFF * pfd1 = (FUNDIFF *)pv1;
    FUNDIFF * pfd2 = (FUNDIFF *)pv2;
    char * psz1;
    char * psz2;
    int iCmp = 0;

    // Sort first by the segment name of the first map

    psz1 = pfd1->pfi1 ? pfd1->pfi1->psi->pszName : "";
    psz2 = pfd2->pfi1 ? pfd2->pfi1->psi->pszName : "";
    iCmp = lstrcmpi(psz1, psz2);

    if (iCmp == 0)
    {
        // Sort next by the segment name of the second map
        
        psz1 = pfd1->pfi2 ? pfd1->pfi2->psi->pszName : "";
        psz2 = pfd2->pfi2 ? pfd2->pfi2->psi->pszName : "";
        iCmp = lstrcmpi(psz1, psz2);

        if (iCmp == 0)
        {
            // Sort by the name of the function

            FUNINFO * pfi1 = pfd1->pfi1 ? pfd1->pfi1 : pfd1->pfi2;
            FUNINFO * pfi2 = pfd2->pfi1 ? pfd2->pfi1 : pfd2->pfi2;

            iCmp = comparefuninfoname(&pfi1, &pfi2);
        }
    }

    return(iCmp);
}

int __cdecl
comparesecinfosegoffset(const void * pv1, const void * pv2)
{
    SECINFO * psi1 = *(SECINFO **)pv1;
    SECINFO * psi2 = *(SECINFO **)pv2;

    if (psi1->iSeg < psi2->iSeg)
        return(-1);
    else if (psi1->iSeg > psi2->iSeg)
        return(+1);
    else if (psi1->dwOffset < psi2->dwOffset)
        return(-1);
    else if (psi1->dwOffset > psi2->dwOffset)
        return(+1);
    else
        return(0);
}

int __cdecl
comparesecinfoname(const void * pv1, const void * pv2)
{
    SECINFO * psi1 = *(SECINFO **)pv1;
    SECINFO * psi2 = *(SECINFO **)pv2;
    int i;

    i = lstrcmpi(psi1->pszName, psi2->pszName);

    if (i == 0)
    {
        i = comparesecinfosegoffset(pv1, pv2);
    }

    return(i);
}

int __cdecl
comparesecinfodiff(SECINFO * psi1, SECINFO * psi2)
{
    if (psi2 == NULL)
        return(-1);
    else if (psi1 == NULL)
        return(+1);
    else
        return(lstrcmpi(psi1->pszName, psi2->pszName));
}

int __cdecl
comparesecdiff(const void * pv1, const void * pv2)
{
    SECDIFF * psd1 = (SECDIFF *)pv1;
    SECDIFF * psd2 = (SECDIFF *)pv2;
    SECINFO * psi1 = psd1->psi1 ? psd1->psi1 : psd1->psi2;
    SECINFO * psi2 = psd2->psi1 ? psd2->psi1 : psd2->psi2;
    
    return(comparesecinfoname(&psi1, &psi2));
}

char *
commaize(char * pszBuf, LONG l)
{
    int cch = sprintf(pszBuf, "%ld", l);
    int n = (cch - 1 - (l < 0)) / 3;
    int i;
    char * psz;

    for (i = 0; i < n; ++i)
    {
        psz = &pszBuf[cch - (4 * i) - 3];
        memmove(psz + 1, psz, (4 * i) + 3 + 1);
        *psz = ',';
        cch += 1;
    }

    return(pszBuf);
}    

void
MapInfoAddSecFun(MAPINFO * pmi, UINT * pcCount, void *** pppv, void * pvItem, int cbItem)
{
    void * pvCopy = MemAlloc(cbItem, FALSE);
    memcpy(pvCopy, pvItem, cbItem);

    if ((*pcCount % 100) == 0)
    {
        void ** ppvNew = MemAlloc((*pcCount + 100) * sizeof(void *), FALSE);
        memcpy(ppvNew, *pppv, (*pcCount) * sizeof(void *));
        *pppv = ppvNew;
    }

    (*pppv)[(*pcCount)++] = pvCopy;
}

MAPINFO *
MapRead(char * pszFile)
{
    UINT        cLines;
    char **     ppszLines;
    UINT        iLine;
    char **     ppsz;
    char *      psz;
    char *      psz2;
    MAPINFO *   pmi;
    SECINFO     si;
    FUNINFO     fi;
    SECINFO *   psi;
    SECINFO *   psiNext;
    FUNINFO *   pfi;
    FUNINFO *   pfiNext;
    UINT        ifi;
    UINT        isi;
    BOOL        fIsStatic;

    ReadTextFile(pszFile, &cLines, &ppszLines);

    pmi = MemAlloc(sizeof(MAPINFO), TRUE);

    pmi->pszFile = _strdup(pszFile);

    iLine = 0;
    ppsz = ppszLines;

    if (cLines == 0)
    {
        ParseError(pszFile, 0, "file is empty");
    }

    psz = skipspace(*ppsz);
    pmi->pszName = psz;
    psz = skipnonspace(psz);
    *psz = 0;
    if (psz == pmi->pszName || *skipspace(psz) != 0)
    {
        ParseError(pszFile, iLine, "expected single token on first line");
    }

    skipblanklines(pszFile, &iLine, &cLines, &ppsz, FALSE);

    psz = skipspace(*ppsz);

    if (!prefixmatch(psz, "Timestamp is "))
    {
        ParseError(pszFile, iLine, "can't find timestamp");
    }

    psz  = skiptochar(psz, '(');
    psz2 = skiptochar(psz, ')');
    if (*psz != '(' || *psz2 != ')')
    {
        ParseError(pszFile, iLine, "can't find timestamp date string");
    }
    
    pmi->pszTimestamp = psz + 1;
    *psz2 = 0;

    skipblanklines(pszFile, &iLine, &cLines, &ppsz, FALSE);

    psz = prefixmatch(skipspace(*ppsz), "Preferred load address is ");
    if (psz == NULL)
    {
        ParseError(pszFile, iLine, "can't find preferred load address");
    }
    
    pmi->dwBase = parsehex(psz);

    skipblanklines(pszFile, &iLine, &cLines, &ppsz, FALSE);

    if (!prefixmatch(skipspace(*ppsz), "Start         Length     Name                   Class"))
    {
        ParseError(pszFile, iLine, "can't find start of section map");
    }

    psz = skipblanklines(pszFile, &iLine, &cLines, &ppsz, FALSE);

    while (1)
    {
        psz = skipspace(psz);
        if (*psz == 0)
            break;

        // printf("'%s'\n", psz);
        // 0001:00000000 0000040cH .rdata                  CODE

        memset(&si, 0, sizeof(si));

        psz2 = skiptochar(psz, ':');

        if (psz2 - psz != 4)
        {
            ParseError(pszFile, iLine, "malformed section map line (segnum)");
        }

        *psz2 = 0;

        si.iSeg = atoi(psz);

        psz += 5;
        psz2 = skipnonspace(psz);

        if (psz2 - psz != 8)
        {
            ParseError(pszFile, iLine, "malformed section map line (offset)");
        }

        si.dwOffset = parsehex(psz);

        psz = skipspace(psz2);
        psz2 = skiptochar(psz, 'H');
        if (*psz2 != 'H' || psz2 - psz != 8)
        {
            ParseError(pszFile, iLine, "malformed section map line (length)");
        }

        si.dwLength = parsehex(psz);

        psz = skipspace(psz2 + 1);
        psz2 = skipnonspace(psz);

        if (psz == psz2)
        {
            ParseError(pszFile, iLine, "malformed section map line (name)");
        }

        si.pszName = psz;

        psz = skipspace(psz2);
        *psz2 = 0;
        psz2 = skipnonspace(psz);

        if (psz == psz2)
        {
            ParseError(pszFile, iLine, "malformed section map line (class)");
        }

        *psz2 = 0;

        if (lstrcmpi(psz, "DATA") == 0)
        {
            si.fIsData = TRUE;
            pmi->cSecData += 1;
        }
        else
        {
            pmi->cSecCode += 1;
        }

        MapInfoAddSecFun(pmi, &pmi->cSecInfo, &pmi->ppSecInfo, &si, sizeof(SECINFO));

        psz = nextline(pszFile, &iLine, &cLines, &ppsz, FALSE);
    }

    psz = skipblanklines(pszFile, &iLine, &cLines, &ppsz, FALSE);

    if (!prefixmatch(skipspace(*ppsz), "Address         Publics by Value              Rva+Base     Lib:Object"))
    {
        ParseError(pszFile, iLine, "can't find start of publics map");
    }

    psz = skipblanklines(pszFile, &iLine, &cLines, &ppsz, FALSE);

    fIsStatic = FALSE;

    while (1)
    {
        while (1)
        {
            psz = skipspace(psz);
            if (*psz == 0)
                break;

            // printf("'%s'\n", psz);
            // 0001:00001518       _memset                    00402518 f   msvcrtd:MSVCRTD.dll
            // 0002:00000000       ___xc_a                    00403000     msvcrtd:cinitexe.obj

            memset(&fi, 0, sizeof(fi));

            fi.fIsStatic = fIsStatic;

            psz2 = skiptochar(psz, ':');

            if (psz2 - psz != 4)
            {
                ParseError(pszFile, iLine, "malformed publics map line (segnum)");
            }

            *psz2 = 0;

            fi.iSeg = atoi(psz);

            psz += 5;
            psz2 = skipnonspace(psz);

            if (psz2 - psz != 8)
            {
                ParseError(pszFile, iLine, "malformed publics map line (offset)");
            }

            fi.dwOffset = parsehex(psz);

            psz = skipspace(psz2);
            psz2 = skipnonspace(psz);

            if (psz == psz2)
            {
                ParseError(pszFile, iLine, "malformed publics map line (name)");
            }

            fi.pszName = Undecorate(psz);

            psz = skipspace(psz2);
            *psz2 = 0;
            psz2 = skipnonspace(psz);

            if (psz2 - psz != 8)
            {
                ParseError(pszFile, iLine, "malformed publics map line (address)");
            }

            fi.dwAddress = parsehex(psz);

            while (1)
            {
                psz = skipspace(psz2);
                psz2 = skipnonspace(psz);

                if (*skipspace(psz2) == 0)
                    break;
            }

            if (psz == psz2)
            {
                ParseError(pszFile, iLine, "malformed publics map line (lib:obj)");
            }

            fi.pszModule = psz;
            *psz2 = 0;

            MapInfoAddSecFun(pmi, &pmi->cFunInfo, &pmi->ppFunInfo, &fi, sizeof(FUNINFO));

            psz = nextline(pszFile, &iLine, &cLines, &ppsz, FALSE);
        }

        if (fIsStatic)
            break;

        fIsStatic = TRUE;

        psz = skipblanklines(pszFile, &iLine, &cLines, &ppsz, FALSE);
        psz = prefixmatch(skipspace(psz), "entry point at");

        if (psz == NULL)
        {
            ParseError(pszFile, iLine, "can't find entry point line");
        }

        psz = skipspace(psz);
        psz2 = skiptochar(psz, ':');

        if (psz2 - psz != 4 || *psz2 != ':')
        {
            ParseError(pszFile, iLine, "malformed entry point line (segnum)");
        }

        *psz2 = 0;

        pmi->iSegEntry = atoi(psz);

        psz += 5;
        psz2 = skipnonspace(psz);

        if (psz2 - psz != 8 || *skipspace(psz2) != 0)
        {
            ParseError(pszFile, iLine, "malformed entry point line (offset)");
        }

        pmi->dwEntry = parsehex(psz);

        psz = skipblanklines(pszFile, &iLine, &cLines, &ppsz, FALSE);

        if (!prefixmatch(skipspace(psz), "Static symbols"))
        {
            ParseError(pszFile, iLine, "can't find static symbols section");
        }

        psz = skipblanklines(pszFile, &iLine, &cLines, &ppsz, FALSE);
    }

    // Verify that the sections in a segment don't overlap.  There may be holes due to alignment.

secverify:

    qsort((void *)pmi->ppSecInfo, (size_t)pmi->cSecInfo, sizeof(SECINFO *), comparesecinfosegoffset);

    for (isi = 0; isi < pmi->cSecInfo; ++isi)
    {
        psi = pmi->ppSecInfo[isi];

        // If this section is the first in a new segment, make sure it has an offset of zero

        if (    isi == 0
            ||  psi->iSeg != pmi->ppSecInfo[isi - 1]->iSeg)
        {
            if (psi->dwOffset != 0)
            {
                char szName[32];

                fprintf(stderr, "warning: section %s is first in segment but doesn't have zero offset\n", psi->pszName);

                // Add a fake section to make up for it, then restart the verification process
                // because the array could have been reallocated.

                memset(&si, 0, sizeof(si));

                sprintf(szName, ".segfill%d", psi->iSeg);

                si.iSeg = psi->iSeg;
                si.dwOffset = 0;
                si.dwLength = psi->dwOffset;
                si.pszName = _strdup(szName);
                si.fIsData = FALSE;

                pmi->cSecCode += 1;

                MapInfoAddSecFun(pmi, &pmi->cSecInfo, &pmi->ppSecInfo, &si, sizeof(SECINFO));

                goto secverify;
            }
        }

        // If this section is not the last in its segment, make sure its offset plus length
        // is less than or equal to the offset of the next section.

        if ((isi + 1) < pmi->cSecInfo)
        {
            psiNext = pmi->ppSecInfo[isi + 1];
                
            if (    psi->iSeg == psiNext->iSeg
                &&  psi->dwOffset + psi->dwLength > psiNext->dwOffset)
            {
                fprintf(stderr, "warning: section %s overlaps section %s; truncating.", psi->pszName, psiNext->pszName);
                psi->dwLength = psiNext->dwOffset - psi->dwOffset;
            }
        }
    }

    // Sort the function array by seg:offset to get the static symbols mixed
    // into the public symbols.

    qsort((void *)pmi->ppFunInfo, (size_t)pmi->cFunInfo, sizeof(FUNINFO *), comparefuninfosegoffset);

    // For each section, make sure there is a function which starts at its segment offset.  If not,
    // make one up to backfill.

    for (isi = 0; isi < pmi->cSecInfo; ++isi)
    {
        psi = pmi->ppSecInfo[isi];

        if (psi->dwLength == 0)
            continue;

        for (ifi = 0; ifi < pmi->cFunInfo; ++ifi)
        {
            pfi = pmi->ppFunInfo[ifi];

            if (pfi->iSeg < psi->iSeg)
                continue;

            if (pfi->iSeg > psi->iSeg)
                break;

            if (pfi->dwOffset < psi->dwOffset)
                continue;

            if (pfi->dwOffset >= psi->dwOffset)
                break;
        }

        if (    ifi == pmi->cFunInfo
            ||  pfi->iSeg > psi->iSeg
            ||  pfi->dwOffset > psi->dwOffset)
        {
            memset(&fi, 0, sizeof(fi));
            fi.iSeg = psi->iSeg;
            fi.dwOffset = psi->dwOffset;
            fi.pszName = Undecorate(psi->pszName);
            fi.pszModule = psi->pszName;
            fi.fIsStatic = TRUE;

            MapInfoAddSecFun(pmi, &pmi->cFunInfo, &pmi->ppFunInfo, &fi, sizeof(FUNINFO));

            // Sort the function array by seg:offset

            qsort((void *)pmi->ppFunInfo, (size_t)pmi->cFunInfo, sizeof(FUNINFO *), comparefuninfosegoffset);
        }
    }

    // Assign each function to a section.  If a function starts in a hole between sections,
    // emit a warning, delete the function, and restart the verification.

funverify:

    isi = 0;
    psi = (pmi->cSecInfo > 0) ? pmi->ppSecInfo[isi] : NULL;

    for (ifi = 0; ifi < pmi->cFunInfo; ++ifi)
    {
        pfi = pmi->ppFunInfo[ifi];

        if (pfi->psi)
            continue;

        // Advance to the section that owns or is just past this function's seg:offset

        while (psi)
        {
            if (psi->iSeg > pfi->iSeg)
                break;

            if (    psi->iSeg == pfi->iSeg
                &&  psi->dwOffset + psi->dwLength > pfi->dwOffset)
                break;

            isi += 1;
            psi = (pmi->cSecInfo > isi) ? pmi->ppSecInfo[isi] : NULL;
        }

        // If the section we are on is past this function, then delete the function because
        // it lives "between" sections and we have no way of knowing how big it is.

        if (    psi == NULL
            ||  psi->iSeg != pfi->iSeg
            ||  psi->dwOffset > pfi->dwOffset)
        {
            if (pfi->iSeg != 0)
            {
                fprintf(stderr, "warning: function %04X:%08lX '%s' is not contained by any section\n",
                        pfi->iSeg, pfi->dwOffset, pfi->pszName);
            }
            memmove(&pmi->ppFunInfo[ifi], &pmi->ppFunInfo[ifi + 1],
                    (pmi->cFunInfo - ifi - 1) * sizeof(FUNINFO *));
            pmi->cFunInfo -= 1;
            goto funverify;
        }

        // Otherwise, match this function with its section

        pfi->psi = psi;
    }

    // Compute the length of each function by subtracting next function's offset from the
    // current function's offset.  If this is the last function in a section, however,
    // then subtract the length of the section from the current function's offset.

    for (ifi = 0; ifi < pmi->cFunInfo; ++ifi)
    {
        pfi     = pmi->ppFunInfo[ifi];
        pfiNext = (ifi + 1) == pmi->cFunInfo ? NULL : pmi->ppFunInfo[ifi + 1];

        if (!pfiNext || pfiNext->psi != pfi->psi)
        {
            pfi->dwLength = (pfi->psi->dwOffset + pfi->psi->dwLength) - pfi->dwOffset;
        }
        else
        {
            pfi->dwLength = pfiNext->dwOffset - pfi->dwOffset;
        }
    }

    // Compute the total size of all sections and functions

    for (isi = 0; isi < pmi->cSecInfo; ++isi)
    {
        DWORD dwSum = 0;

        psi = pmi->ppSecInfo[isi];

        if (psi->fIsData)
            pmi->cbSecData += psi->dwLength;
        else
            pmi->cbSecCode += psi->dwLength;

        for (ifi = 0; ifi < pmi->cFunInfo; ++ifi)
        {
            pfi = pmi->ppFunInfo[ifi];

            if (pfi->psi == psi)
            {
                dwSum += pfi->dwLength;
            }
        }

        if (dwSum != psi->dwLength)
        {
            fprintf(stderr, "warning: mismatch verifying length of section %s (sections map says %d, functions say %d)\n",
                    psi->pszName, psi->dwLength, dwSum);
        }
    }

    for (ifi = 0; ifi < pmi->cFunInfo; ++ifi)
    {
        pfi = pmi->ppFunInfo[ifi];

        if (pfi->psi->fIsData)
        {
            pmi->cbFunData += pfi->dwLength;
            pmi->cFunData += 1;
        }
        else
        {
            pmi->cbFunCode += pfi->dwLength;
            pmi->cFunCode += 1;
        }
    }

    return(pmi);
}

void
MapReportStats(MAPINFO * pmi, BOOL fVerbose)
{
    UINT        isi;
    SECINFO *   psi;
    UINT        ifi;
    FUNINFO *   pfi;
    char        szBuf[16];
    
    printf("\nMap File: %s (%s)\n\n", pmi->pszFile, pmi->pszTimestamp);
    printf("  %8s bytes of code in %d sections and %d symbols\n", commaize(szBuf, pmi->cbSecCode), pmi->cSecCode, pmi->cFunCode);
    printf("  %8s bytes of data in %d sections and %d symbols\n", commaize(szBuf, pmi->cbSecData), pmi->cSecData, pmi->cFunData);
    printf("  --------\n");
    printf("  %8s bytes of both in %d sections and %d symbols\n", commaize(szBuf, pmi->cbSecCode + pmi->cbSecData), pmi->cSecInfo, pmi->cFunInfo);
    printf("\n\n\n");

    printf("      Size d Section\n");
    printf("  -------- - ------------\n");

    for (isi = 0; isi < pmi->cSecInfo; ++isi)
    {
        psi = pmi->ppSecInfo[isi];

        printf("  %8s %c %.12s\n", commaize(szBuf, (LONG)psi->dwLength),
               psi->fIsData ? 'd' : ' ', psi->pszName);
    }
    printf("  -------- - ------------------------\n");
    printf("  %8s\n\n\n", commaize(szBuf, (LONG)pmi->cbSecCode + (LONG)pmi->cbSecData));

    printf("      Size sd Section      Module                   Symbol\n");
    printf("  -------- -- ------------ ------------------------ ----------------------------------------------------------------\n");
    
    for (ifi = 0; ifi < pmi->cFunInfo; ++ifi)
    {
        pfi = pmi->ppFunInfo[ifi];

        printf("  %8s %c%c %-12s %-24s %.64s\n", commaize(szBuf, (LONG)pfi->dwLength),
               pfi->fIsStatic ? 's' : ' ', pfi->psi->fIsData ? 'd' : ' ',
               pfi->psi->pszName, pfi->pszModule, pfi->pszName);
    }

    printf("  -------- -- ------------ ------------------------ ----------------------------------------------------------------\n");
    printf("  %8s\n", commaize(szBuf, (LONG)pmi->cbFunCode + (LONG)pmi->cbFunData));
}

void
MapReportDelta(MAPINFO * pmi1, MAPINFO * pmi2, BOOL fVerbose)
{
    UINT        cSecDiff = 0;
    SECDIFF *   pSecDiff;
    SECDIFF *   psd;
    UINT        isi1, csi1, isi2, csi2, isd;
    SECINFO *   psi1;
    SECINFO *   psi2;
    UINT        cFunDiff = 0;
    FUNDIFF *   pFunDiff;
    FUNDIFF *   pfd;
    UINT        ifi1, cfi1, ifi2, cfi2, ifd;
    FUNINFO *   pfi1;
    FUNINFO *   pfi2;
    int         iCmp;
    char        szBuf1[16];
    char        szBuf2[16];
    char        szBuf3[16];
    LONG        lSum1, lSum2;

    printf("\nMap File 1: %s (%s)\n\n", pmi1->pszFile, pmi1->pszTimestamp);
    printf("  %8s bytes of code in %d sections and %d symbols\n", commaize(szBuf1, pmi1->cbSecCode), pmi1->cSecCode, pmi1->cFunCode);
    printf("  %8s bytes of data in %d sections and %d symbols\n", commaize(szBuf1, pmi1->cbSecData), pmi1->cSecData, pmi1->cFunData);
    printf("  --------\n");
    printf("  %8s bytes of both in %d sections and %d symbols\n", commaize(szBuf1, pmi1->cbSecCode + pmi1->cbSecData), pmi1->cSecInfo, pmi1->cFunInfo);
    printf("\n");
    printf("Map File 2: %s (%s)\n\n", pmi2->pszFile, pmi2->pszTimestamp);
    printf("  %8s bytes of code in %d sections and %d symbols\n", commaize(szBuf1, pmi2->cbSecCode), pmi2->cSecCode, pmi2->cFunCode);
    printf("  %8s bytes of data in %d sections and %d symbols\n", commaize(szBuf1, pmi2->cbSecData), pmi2->cSecData, pmi2->cFunData);
    printf("  --------\n");
    printf("  %8s bytes of both in %d sections and %d symbols\n", commaize(szBuf1, pmi2->cbSecCode + pmi2->cbSecData), pmi2->cSecInfo, pmi1->cFunInfo);
    printf("\n\n");

    pSecDiff = psd = MemAlloc((pmi1->cSecInfo + pmi2->cSecInfo) * sizeof(SECDIFF), TRUE);
    pFunDiff = pfd = MemAlloc((pmi1->cFunInfo + pmi2->cFunInfo) * sizeof(FUNDIFF), TRUE);

    // Sort each of the map's section info by name

    qsort((void *)pmi1->ppSecInfo, (size_t)pmi1->cSecInfo, sizeof(SECINFO *), comparesecinfoname);
    qsort((void *)pmi2->ppSecInfo, (size_t)pmi2->cSecInfo, sizeof(SECINFO *), comparesecinfoname);

    isi1 = 0;
    csi1 = pmi1->cSecInfo;
    isi2 = 0;
    csi2 = pmi2->cSecInfo;

    while (isi1 < csi1 || isi2 < csi2)
    {
        psi1 = (isi1 < csi1) ? pmi1->ppSecInfo[isi1] : NULL;
        psi2 = (isi2 < csi2) ? pmi2->ppSecInfo[isi2] : NULL;
        iCmp = comparesecinfodiff(psi1, psi2);

        if (iCmp == 0)
        {
            psd->psi1 = psi1; ++isi1;
            psd->psi2 = psi2; ++isi2;
        }
        else if (iCmp < 0)
        {
            psd->psi1 = psi1; ++isi1;
        }
        else
        {
            psd->psi2 = psi2; ++isi2;
        }

        psd += 1;
        cSecDiff += 1;
    }

    printf("Section Differences%s\n\n", fVerbose ? "" : " (Unchanged Sections Not Shown)");
    printf("     Map 1    Map 2    Delta Section\n");
    printf("  -------- -------- -------- ------------\n");

    qsort((void *)pSecDiff, (size_t)cSecDiff, sizeof(SECDIFF), comparesecdiff);

    lSum1 = lSum2 = 0;

    for (isd = 0, psd = pSecDiff; isd < cSecDiff; ++isd, ++psd)
    {
        LONG l1, l2;

        psi1 = psd->psi1;
        psi2 = psd->psi2;

        l1 = psi1 ? (LONG)psi1->dwLength : 0;
        l2 = psi2 ? (LONG)psi2->dwLength : 0;

        if (l1 == l2 && !fVerbose)
            continue;

        printf("  %8s %8s %8s %s\n",
               commaize(szBuf1, l1), commaize(szBuf2, l2),
               l1 == l2 ? "" : commaize(szBuf3, l1 - l2),
               (psi1 ? psi1 : psi2)->pszName);

        lSum1 += l1;
        lSum2 += l2;
    }

    printf("  -------- -------- -------- ------------\n");
    printf("  %8s %8s %8s\n\n",
           fVerbose ? commaize(szBuf1, (LONG)lSum1) : "",
           fVerbose ? commaize(szBuf2, (LONG)lSum2) : "",
           commaize(szBuf3, (LONG)lSum1 - (LONG)lSum2));

    // Sort each of the map's function info by name

    qsort((void *)pmi1->ppFunInfo, (size_t)pmi1->cFunInfo, sizeof(FUNINFO *), comparefuninfoname);
    qsort((void *)pmi2->ppFunInfo, (size_t)pmi2->cFunInfo, sizeof(FUNINFO *), comparefuninfoname);

    ifi1 = 0;
    cfi1 = pmi1->cFunInfo;
    ifi2 = 0;
    cfi2 = pmi2->cFunInfo;

    while (ifi1 < cfi1 || ifi2 < cfi2)
    {
        pfi1 = (ifi1 < cfi1) ? pmi1->ppFunInfo[ifi1] : NULL;
        pfi2 = (ifi2 < cfi2) ? pmi2->ppFunInfo[ifi2] : NULL;
        iCmp = comparefuninfodiff(pfi1, pfi2);

        if (iCmp == 0)
        {
            pfd->pfi1 = pfi1; ++ifi1;
            pfd->pfi2 = pfi2; ++ifi2;
        }
        else if (iCmp < 0)
        {
            pfd->pfi1 = pfi1; ++ifi1;
        }
        else
        {
            pfd->pfi2 = pfi2; ++ifi2;
        }

        pfd += 1;
        cFunDiff += 1;
    }

    printf("\nSymbol Differences%s\n\n", fVerbose ? "": " (Unchanged Symbols Not Shown)");
    printf("     Map 1    Map 2    Delta Section 1    Section 2    Symbol\n");
    printf("  -------- -------- -------- ------------ ------------ ----------------------------------------------------------------\n");

    qsort((void *)pFunDiff, (size_t)cFunDiff, sizeof(FUNDIFF), comparefundiff);

    lSum1 = lSum2 = 0;

    for (ifd = 0, pfd = pFunDiff; ifd < cFunDiff; ++ifd, ++pfd)
    {
        LONG l1, l2;

        pfi1 = pfd->pfi1;
        pfi2 = pfd->pfi2;

        l1 = pfi1 ? (LONG)pfi1->dwLength : 0;
        l2 = pfi2 ? (LONG)pfi2->dwLength : 0;

        if (l1 == l2 && !fVerbose)
            continue;

        printf("  %8s %8s %8s %-12s %-12s %.64s\n",
               pfi1 ? commaize(szBuf1, l1) : "", pfi2 ? commaize(szBuf2, l2) : "",
               l1 == l2 ? "" : commaize(szBuf3, l1 - l2),
               pfi1 ? pfi1->psi->pszName : "",
               pfi2 ? pfi2->psi->pszName : "",
               (pfi1 ? pfi1 : pfi2)->pszName);

        lSum1 += l1;
        lSum2 += l2;
    }

    printf("  -------- -------- -------- ------------ ------------ ----------------------------------------------------------------\n");
    printf("  %8s %8s %8s\n\n",
           fVerbose ? commaize(szBuf1, (LONG)lSum1) : "",
           fVerbose ? commaize(szBuf2, (LONG)lSum2) : "",
           commaize(szBuf3, (LONG)lSum1 - (LONG)lSum2));
}

int __cdecl main(int argc, char * argv[])
{
    BOOL        fVerbose    = FALSE;
    int         argi        = 1;
    int         cMap        = 0;
    MAPINFO *   rgpmi[2]    = { 0, 0 };

    if (argc < 2)
    {
        Usage();
    }

    for (; argi < argc; ++argi)
    {
        if (argv[argi][0] == '-')
        {
            if (lstrcmpi(argv[argi], "-v") == 0)
            {
                fVerbose = TRUE;
            }
            else
            {
                Usage();
            }
        }
        else if (cMap == 2)
        {
            Usage();
        }
        else
        {
            rgpmi[cMap++] = MapRead(argv[argi]);
        }
    }

    if (cMap == 1)
    {
        MapReportStats(rgpmi[0], fVerbose);
    }
    else
    {
        MapReportDelta(rgpmi[0], rgpmi[1], fVerbose);
    }

    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\libver\libverrc.h ===
/*++

Copyright (c) 1989-2002  Microsoft Corporation

Module Name:

    libverrc.h

Abstract:

    This module contains the resource compiler constants for the program
    to dump the version of an Xbox library.

--*/

#ifndef _LIBVERRC_
#define _LIBVERRC_

#include <xboxverp.h>

#define IDS_CANNOT_OPEN_INPUT_FILE                      1000
#define IDS_CANNOT_READ_INPUT_FILE                      1001
#define IDS_NO_MEMORY                                   1002
#define IDS_MISSING_OPTION_ARGUMENT                     1003
#define IDS_UNRECOGNIZED_OPTION                         1004
#define IDS_MISSING_REQUIRED_OPTION                     1005
#define IDS_INVALID_NUMBER_OPTION                       1006
#define IDS_INVALID_STRING_OPTION                       1007
#define IDS_CANNOT_CREATE_OUTPUT_FILE                   1008
#define IDS_CANNOT_WRITE_OUTPUT_FILE                    1009
#define IDS_INVALID_CORRUPT_INPUT_FILE                  1010
#define IDS_COULD_NOT_INVOKE_LINK                       1011
#define IDS_INTERNAL_TOOL_ERROR                         1012

#define IDS_NO_VERSION_DETECTED                         1017
#define IDS_POSSIBLY_UNAPPROVED                         1028
#define IDS_UNAPPROVED                                  1029
#define IDS_MULTIPLE_VERSIONS                           1030
#define IDS_VERSION_OUTPUT                              1031

#define IDS_LOGO_NAME_AND_VERSION                       2000
#define IDS_LOGO_COPYRIGHT                              2001

#define IDS_LIBVER_USAGE                                2200

#endif // LIBVERRC
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\libver\libverp.h ===
/*++

Copyright (c) 1989-2002  Microsoft Corporation

Module Name:

    libverp.h

Abstract:

    This module contains the private data structures and procedure prototypes
    for the program to dump the version of an Xbox library.

--*/

#ifndef _LIBVERP_
#define _LIBVERP_

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <shlwapi.h>
#include <stdio.h>
#include <stdlib.h>
#include <malloc.h>
#include <time.h>
#include <errno.h>
#include <xbeimage.h>
#include <cklibver.h>
#include "libverrc.h"

#define ARRAYSIZE(a) (sizeof(a) / sizeof(a[0]))

//
// General support functions.
//

DECLSPEC_NORETURN
VOID
LibvExitProcess(
    int ExitCode
    );

//
// String resource support functions.
//

VOID
LibvResourcePrintfV(
    FILE *file,
    UINT uStringID,
    va_list args
    );

VOID
LibvResourcePrintf(
    FILE *file,
    UINT uStringID,
    ...
    );

VOID
LibvResourcePrintErrorAndExit(
    UINT uStringID,
    ...
    );

VOID
LibvResourcePrintWarning(
    UINT uStringID,
    ...
    );

VOID
LibvResourcePrintRange(
    FILE *file,
    UINT uStartingStringID
    );

VOID
LibvResourcePrintLogoBanner(
    VOID
    );

#endif  // _LIBVERP_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\libver\stringrc.cpp ===
/*++

Copyright (c) 2002  Microsoft Corporation

Module Name:

    stringrc.cpp

Abstract:

    This module implements miscellaneous utility routines for the 
    program to dump the version of an Xbox library.

--*/

#include "libverp.h"

VOID
LibvResourcePrintfV(
    FILE *file,
    UINT uStringID,
    va_list args
    )
{
    CHAR szResource[256];
    CHAR szMessage[1024];

    if (LoadString(NULL, uStringID, szResource, sizeof(szResource)) > 0) {

        FormatMessage(FORMAT_MESSAGE_FROM_STRING, szResource, 0, 0, szMessage,
            sizeof(szMessage), &args);

        fputs(szMessage, file);
    }
}

VOID
LibvResourcePrintf(
    FILE *file,
    UINT uStringID,
    ...
    )
{
    va_list args;

    va_start(args, uStringID);

    LibvResourcePrintfV(file, uStringID, args);

    va_end(args);
}

VOID
LibvResourcePrintLogoBanner(
    VOID
    )
{
    LibvResourcePrintf(stderr, IDS_LOGO_NAME_AND_VERSION, VER_PRODUCTVERSION_STR);
    fputs("\n", stderr);
    LibvResourcePrintf(stderr, IDS_LOGO_COPYRIGHT);
    fputs("\n\n", stderr);
}

VOID
LibvResourcePrintErrorAndExit(
    UINT uStringID,
    ...
    )
{
    va_list args;

    fprintf(stderr, "LIBVER : error IM%04d: ", uStringID);

    va_start(args, uStringID);

    LibvResourcePrintfV(stderr, uStringID, args);
    fputs("\n", stderr);

    va_end(args);

    LibvExitProcess(1);
}

VOID
LibvResourcePrintWarning(
    UINT uStringID,
    ...
    )
{
    va_list args;

    fprintf(stderr, "LIBVER : warning IM%04d: ", uStringID);

    va_start(args, uStringID);

    LibvResourcePrintfV(stderr, uStringID, args);
    fputs("\n", stderr);

    va_end(args);
}

VOID
LibvResourcePrintRange(
    FILE *file,
    UINT uStartingStringID
    )
{
    UINT uStringID;
    CHAR szResource[256];

    uStringID = uStartingStringID;

    for (;;) {

        if (LoadString(NULL, uStringID, szResource, sizeof(szResource)) == 0) {
            break;
        }

        if (szResource[0] == '~') {
            break;
        }

        fputs(szResource, file);
        fputs("\n", file);

        uStringID++;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\ntsdexts\crt.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    crt.c

Abstract:

    This file implements certain crt apis that are not present in
    libcntpr.lib. This implementation is NOT multi-thread safe.

Author:

    Wesley Witt (wesw) 6-Feb-1994

Environment:

    User Mode

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <time.h>
#include <stdio.h>


typedef VOID     (NTAPI *PRtlSecondsSince1970ToTime)(ULONG,PLARGE_INTEGER);
typedef NTSTATUS (NTAPI *PRtlSystemTimeToLocalTime)(PLARGE_INTEGER,PLARGE_INTEGER);
typedef VOID     (NTAPI *PRtlTimeToTimeFields)(PLARGE_INTEGER,PTIME_FIELDS);

HINSTANCE                  hModNtdll;
PRtlSecondsSince1970ToTime pRtlSecondsSince1970ToTime;
PRtlSystemTimeToLocalTime  pRtlSystemTimeToLocalTime;
PRtlTimeToTimeFields       pRtlTimeToTimeFields;


void * __cdecl
malloc(
    size_t sz
    )
{

    return LocalAlloc( LPTR, sz );

}

void __cdecl
free(
    void * ptr
    )
{

    LocalFree( ptr );

}

char * __cdecl
strtok(
    char * string,
    const char * control
    )
{
        unsigned char *str = string;
        const unsigned char *ctrl = control;

        unsigned char map[32];
        int count;
        char *token;

        static char *nextoken;


        /* Clear control map */
        for (count = 0; count < 32; count++)
                map[count] = 0;

        /* Set bits in delimiter table */
        do {
                map[*ctrl >> 3] |= (1 << (*ctrl & 7));
        } while (*ctrl++);

        /* If string==NULL, continue with previous string */
        if (!str) {
            str = nextoken;
        }

        /* Find beginning of token (skip over leading delimiters). Note that
         * there is no token iff this loop sets string to point to the terminal
         * null (*string == '\0') */
        while ( (map[*str >> 3] & (1 << (*str & 7))) && *str )
                str++;

        token = str;

        /* Find the end of the token. If it is not the end of the string,
         * put a null there. */
        for ( ; *str ; str++ )
                if ( map[*str >> 3] & (1 << (*str & 7)) ) {
                        *str++ = '\0';
                        break;
                }

        /* Update nextoken (or the corresponding field in the per-thread data
         * structure */

        nextoken = str;

        /* Determine if a token has been found. */
        if ( token == str )
                return NULL;
        else
                return token;
}


char * __cdecl
ctime(
    const time_t *timp
    )
{
    static char    mnames[] = { "JanFebMarAprMayJunJulAugSepOctNovDec" };
    static char    buf[32];

    LARGE_INTEGER  MyTime;
    TIME_FIELDS    TimeFields;



    if (!hModNtdll) {
        hModNtdll = GetModuleHandle( "ntdll.dll" );
        if (!hModNtdll) {
            sprintf( buf, "0x%08x", (ULONG)*timp );
            return buf;
        }
        pRtlSecondsSince1970ToTime = (PRtlSecondsSince1970ToTime)GetProcAddress( hModNtdll, "RtlSecondsSince1970ToTime" );
        pRtlSystemTimeToLocalTime  = (PRtlSystemTimeToLocalTime)GetProcAddress( hModNtdll, "RtlSystemTimeToLocalTime" );
        pRtlTimeToTimeFields       = (PRtlTimeToTimeFields)GetProcAddress( hModNtdll, "RtlTimeToTimeFields" );
    }
    if (pRtlSecondsSince1970ToTime == NULL ||
        pRtlSystemTimeToLocalTime  == NULL ||
        pRtlTimeToTimeFields       == NULL  ) {
        sprintf( buf, "0x%08x", (ULONG)*timp );
        return buf;
    }

    pRtlSecondsSince1970ToTime( (ULONG)*timp, &MyTime );
    pRtlSystemTimeToLocalTime( &MyTime, &MyTime );
    pRtlTimeToTimeFields( &MyTime, &TimeFields );

    strncpy( buf, &mnames[(TimeFields.Month - 1) * 3], 3 );
    sprintf( &buf[3], " %02d %02d:%02d:%02d %04d",
             TimeFields.Day, TimeFields.Hour, TimeFields.Minute,
             TimeFields.Second, TimeFields.Year );

    return buf;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\ntsdexts\heapext.c ===
#if defined(TARGET_i386) && !defined(_XBOX)
#define STACK_TRACE_DATABASE_SUPPORT 1
#elif defined(TARGET_ALPHA)
#define STACK_TRACE_DATABASE_SUPPORT 0
#elif i386
#define STACK_TRACE_DATABASE_SUPPORT 1
#else
#define STACK_TRACE_DATABASE_SUPPORT 0
#endif

#ifdef HOST_i386
ULONG
xRtlCompareMemoryUlong(
    PVOID Source,
    ULONG Length,
    ULONG Pattern
    )
{
    ULONG CountLongs;
    PULONG p = (PULONG)Source;
    PCHAR p1, p2;

    if (((ULONG)p & (sizeof( ULONG )-1)) ||
        (Length & (sizeof( ULONG )-1))
       ) {
        return( 0 );
        }

    CountLongs = Length / sizeof( ULONG );
    while (CountLongs--) {
        if (*p++ != Pattern) {
            p1 = (PCHAR)(p - 1);
            p2 = (PCHAR)&Pattern;
            Length = p1 - (PCHAR)Source;
            while (*p1++ == *p2++) {
                if (p1 > (PCHAR)p) {
                    break;
                    }

                Length++;
                }
            }
        }

    return( Length );
}

#define RtlCompareMemoryUlong  xRtlCompareMemoryUlong
#define RtlCompareMemory       memcmp

#endif

#define STOP_ON_ALLOC 1
#define STOP_ON_REALLOC 2
#define STOP_ON_FREE 3

typedef struct _HEAP_STATE {
    BOOLEAN ShowHelp;
    BOOLEAN ExitDumpLoop;
    BOOLEAN ComputeSummary;
    BOOLEAN ValidateHeap;
    BOOLEAN DumpHeapEntries;
    BOOLEAN DumpHeapTags;
    BOOLEAN DumpHeapPseudoTags;
    BOOLEAN DumpGlobalTags;
    BOOLEAN DumpHeapSegments;
    BOOLEAN DumpHeapFreeLists;
    BOOLEAN DumpStackBackTrace;
    BOOLEAN SetStopOnBreakPoint;
    BOOLEAN RemoveStopOnBreakPoint;
    BOOLEAN EnableHeapChecking;
    BOOLEAN EnableHeapValidateOnCall;
    BOOLEAN DisableHeapChecking;
    BOOLEAN DisableHeapValidateOnCall;
    BOOLEAN ToggleAPICallTracing;
    ULONG_PTR HeapToDump;
    ULONG_PTR HeapEntryToDump;
    SIZE_T ReservedSize;
    SIZE_T CommittedSize;
    SIZE_T AllocatedSize;
    SIZE_T FreeSize;
    SIZE_T OverheadSize;
    ULONG  NumberOfHeaps;
    ULONG  HeapIndex;
    PHEAP *HeapsList;
    ULONG  StopOnOperation;
    PVOID  StopOnAddress;
    HEAP_STOP_ON_TAG StopOnTag;
    WCHAR  StopOnTagName[ 24 ];

    ULONG  FreeListCounts[ HEAP_MAXIMUM_FREELISTS ];
    SIZE_T TotalFreeSize;
    PHEAP  HeapAddress;
    HEAP   Heap;
    ULONG  SegmentNumber;
    PHEAP_SEGMENT SegmentAddress;
    HEAP_SEGMENT Segments[ HEAP_MAXIMUM_SEGMENTS ];
} HEAP_STATE, *PHEAP_STATE;


BOOL
ConvertTagNameToIndex(
    IN PHEAP_STATE State
    );

BOOL
GetHeapTagEntry(
    IN PHEAP Heap,
    IN USHORT TagIndex,
    OUT PHEAP_TAG_ENTRY TagEntry
    );

VOID
WalkHEAP(
    IN PHEAP_STATE State
    );

VOID
WalkHEAP_SEGMENT(
    IN PHEAP_STATE State
    );

BOOL
ValidateHeapHeader(
    IN PVOID HeapAddress,
    IN PHEAP Heap
    );

BOOL
ValidateHeapEntry(
    IN PHEAP_STATE State,
    IN PHEAP_ENTRY PrevEntryAddress,
    IN PHEAP_ENTRY PrevEntry,
    IN PHEAP_ENTRY EntryAddress,
    IN PHEAP_ENTRY Entry
    );

VOID
DumpHeapEntry(
    IN PHEAP_STATE State,
    IN PHEAP_ENTRY EntryAddress,
    IN PHEAP_ENTRY Entry
    );


#if STACK_TRACE_DATABASE_SUPPORT
VOID
DumpStackBackTraceIndex(
    IN PHEAP_STATE State,
    IN USHORT BackTraceIndex
    );
#endif // STACK_TRACE_DATABASE_SUPPORT

BOOLEAN HeapExtInitialized;

PULONG pNtGlobalFlag;

PBOOLEAN pRtlpHeapInvalidBreakPoint;
PVOID *pRtlpHeapInvalidBadAddress;

PHEAP pRtlpGlobalTagHeap;
HEAP MyLocalRtlpGlobalTagHeap;

#if STACK_TRACE_DATABASE_SUPPORT
PSTACK_TRACE_DATABASE *pRtlpStackTraceDataBase;
PSTACK_TRACE_DATABASE RtlpStackTraceDataBase;
STACK_TRACE_DATABASE StackTraceDataBase;
BOOLEAN HaveCopyOfStackTraceDataBase;
#endif // STACK_TRACE_DATABASE_SUPPORT

PHEAP_STOP_ON_VALUES pRtlpHeapStopOn;

BOOLEAN RtlpHeapInvalidBreakPoint;
PVOID RtlpHeapInvalidBadAddress;

BOOL
IsValidHeap(
    ULONG_PTR Va
    )
{
    HEAP Heap;
    ULONG Result;

    if ( !ReadMemory((DWORD)Va, &Heap, sizeof(HEAP), &Result) ) {
        return FALSE;
    }

    return Heap.Signature == HEAP_SIGNATURE;
}

PVOID
EnumerateHeaps(
    OUT PULONG NumberOfHeaps
    )
{
    BOOL Done;
    ULONG Result;
    MMVAD CurrentVad;
    ULONG MaxHeaps = 1024;
    PVOID *p, *Heaps, *CurrentHeap;
    PMMADDRESS_NODE VadRoot, First, Parent, Next, Left;

    dprintf( "Searching for heap(s) from all VADs...\n" );

    *NumberOfHeaps = 0;

    VadRoot = (PMMADDRESS_NODE)GetNtDebuggerDataValue( MmVadRoot );
    First = VadRoot;

    if ( First == NULL || \
         !ReadMemory((DWORD)First, &CurrentVad, sizeof(MMVAD), &Result) ) {
        dprintf( "%08lx Unable to get content of VAD\n", First );
        return NULL;
    }

    while ( CurrentVad.LeftChild != NULL ) {
        First = CurrentVad.LeftChild;
        if ( !ReadMemory((DWORD)First, &CurrentVad, sizeof(MMVAD), &Result) ) {
            dprintf( "%08lx:%x Unable to get content of VAD\n", First, CurrentVad );
            return NULL;
        }
    }

    Heaps = LocalAlloc( LPTR, sizeof(PVOID) * MaxHeaps );
    if ( !Heaps ) {
        dprintf( "Unable to allocate memory\n" );
        return NULL;
    }

    CurrentHeap = Heaps;

    if ( IsValidHeap(CurrentVad.StartingVpn << 12) ) {
        (*NumberOfHeaps)++;
        *CurrentHeap++ = (PVOID)(CurrentVad.StartingVpn << 12);
    }

    Next = First;
    while ( Next != NULL ) {
        if ( CurrentVad.RightChild == NULL ) {

            Done = TRUE;
            while ((Parent = CurrentVad.Parent) != NULL) {

                //
                // Locate the first ancestor of this node of which this
                // node is the left child of and return that node as the
                // next element.
                //

                if ( !ReadMemory( (DWORD)Parent,
                                  &CurrentVad,
                                  sizeof(MMVAD),
                                  &Result) ) {
                    dprintf("%08lx:%lx Unable to get contents of VAD\n",Parent, CurrentVad);
                    return Heaps;
                }

                if (CurrentVad.LeftChild == Next) {
                    Next = Parent;
                    if ( IsValidHeap(CurrentVad.StartingVpn << 12) ) {
                        if ( *NumberOfHeaps >= MaxHeaps ) {
                            MaxHeaps += 1024;
                            p = LocalReAlloc( Heaps, sizeof(PVOID) * MaxHeaps, LPTR );
                            if ( !p ) {
                                return Heaps;
                            }
                            Heaps = p;
                            CurrentHeap = &Heaps[*NumberOfHeaps];
                        }
                        (*NumberOfHeaps)++;
                        *CurrentHeap++ = (PVOID)(CurrentVad.StartingVpn << 12);
                    }
                    Done = FALSE;
                    break;
                }
                Next = Parent;
            }
            if (Done) {
                Next = NULL;
                break;
            }
        } else {

            //
            // A right child exists, locate the left most child of that right child.
            //

            Next = CurrentVad.RightChild;

            if ( !ReadMemory( (DWORD)Next,
                              &CurrentVad,
                              sizeof(MMVAD),
                              &Result) ) {
                dprintf("%08lx:%lx Unable to get contents of VAD\n",Next, CurrentVad);
                return Heaps;
            }

            while ((Left = CurrentVad.LeftChild) != NULL) {
                Next = Left;
                if ( !ReadMemory( (DWORD)Next,
                                  &CurrentVad,
                                  sizeof(MMVAD),
                                  &Result) ) {
                    dprintf("%08lx:%lx Unable to get contents of VAD\n",Next, CurrentVad);
                    return Heaps;
                }
            }

            if ( IsValidHeap(CurrentVad.StartingVpn << 12) ) {
                if ( *NumberOfHeaps >= MaxHeaps ) {
                    MaxHeaps += 1024;
                    p = LocalReAlloc( Heaps, sizeof(PVOID) * MaxHeaps, LPTR );
                    if ( !p ) {
                        return Heaps;
                    }
                    Heaps = p;
                    CurrentHeap = &Heaps[*NumberOfHeaps];
                }
                (*NumberOfHeaps)++;
                *CurrentHeap++ = (PVOID)(CurrentVad.StartingVpn << 12);
            }
        }
    }

    return Heaps;
}

VOID
HeapExtension(
    IN PCSTR lpArgumentString,
    IN ULONG_PTR SystemRangeStart
    )
{
    BOOL b, GotHeapsList, ArgumentsSpecified;
    PHEAP *pHeapsList;
    ULONG NtGlobalFlag;
    LPSTR p;
    ULONG i;
    ULONG DashBArgumentState;
    ULONG_PTR AddressToDump;
    HEAP_STATE State;
    UCHAR ArgumentBuffer[ 16 ];
    ULONG TagIndex;
    PHEAP_TAG_ENTRY pTagEntry;
    HEAP_TAG_ENTRY TagEntry;
    PHEAP_PSEUDO_TAG_ENTRY pPseudoTagEntry;
    HEAP_PSEUDO_TAG_ENTRY PseudoTagEntry;
    BOOLEAN HeapHeaderModified;
    BOOLEAN RtlpHeapInvalidBreakPoint;
    PVOID RtlpHeapInvalidBadAddress;

    if (!HeapExtInitialized) {
        pNtGlobalFlag = (PULONG)GetExpression( "xboxkrnl!NtGlobalFlag" );
        if (pNtGlobalFlag == NULL) {
            dprintf( "HEAPEXT: Unable to get address of xboxkrnl!NtGlobalFlag.\n" );
            }

#if 0
        pRtlpHeapInvalidBreakPoint = (PBOOLEAN)GetExpression( "NTDLL!RtlpHeapInvalidBreakPoint" );
        if (pRtlpHeapInvalidBreakPoint == NULL) {
            dprintf( "HEAPEXT: Unable to get address of NTDLL!RtlpHeapInvalidBreakPoint.\n" );
            }

        pRtlpHeapInvalidBadAddress = (PVOID *)GetExpression( "NTDLL!RtlpHeapInvalidBadAddress" );
        if (pRtlpHeapInvalidBadAddress == NULL) {
            dprintf( "HEAPEXT: Unable to get address of NTDLL!RtlpHeapInvalidBadAddress.\n" );
            }

        pRtlpGlobalTagHeap = (PHEAP)GetExpression( "NTDLL!RtlpGlobalTagHeap" );
        if (pRtlpGlobalTagHeap == NULL) {
            dprintf( "HEAPEXT: Unable to get address of NTDLL!RtlpGlobalTagHeap.\n" );
            }
        if (!ReadMemory( (ULONG_PTR)pRtlpGlobalTagHeap,
                         &pRtlpGlobalTagHeap,
                         sizeof( pRtlpGlobalTagHeap ),
                         NULL
                         )) {
            dprintf( "HEAPEXT: Unable to get address of *NTDLL!RtlpGlobalTagHeap.\n" );
        }

        pRtlpHeapStopOn = (PHEAP_STOP_ON_VALUES)GetExpression( "NTDLL!RtlpHeapStopOn" );
        if (pRtlpHeapStopOn == NULL) {
            dprintf( "HEAPEXT: Unable to get address of NTDLL!RtlpHeapStopOn\n" );
            }

#if STACK_TRACE_DATABASE_SUPPORT
        pRtlpStackTraceDataBase = (PSTACK_TRACE_DATABASE *)GetExpression( "NTDLL!RtlpStackTraceDataBase" );
        if (pRtlpStackTraceDataBase == NULL) {
            dprintf( "HEAPEXT: Unable to get address of NTDLL!RtlpStackTraceDataBase\n" );
            }
#endif // STACK_TRACE_DATABASE_SUPPORT

#endif

        HeapExtInitialized = TRUE;
        }
    MyLocalRtlpGlobalTagHeap.Signature = 0;
#if STACK_TRACE_DATABASE_SUPPORT
    HaveCopyOfStackTraceDataBase = FALSE;
#endif // STACK_TRACE_DATABASE_SUPPORT

    memset( &State, 0, FIELD_OFFSET( HEAP_STATE, FreeListCounts ) );
    AddressToDump = (ULONG)-1;
    ArgumentsSpecified = FALSE;
    p = (LPSTR)lpArgumentString;
    if (p != NULL)
    while (*p) {
        if (*p == '-') {
            ArgumentsSpecified = TRUE;
            p += 1;
            while (*p && *p != ' ') {
                switch (*p) {
                case 'v':
                case 'V':
                    State.ValidateHeap = TRUE;
                    break;

                case 'a':
                case 'A':
                    State.DumpHeapEntries = TRUE;
                    State.DumpHeapFreeLists = TRUE;
                    State.DumpHeapSegments = TRUE;
                    break;

                case 'h':
                case 'H':
                    State.DumpHeapEntries = TRUE;
                    break;

                case 'f':
                case 'F':
                    State.DumpHeapFreeLists = TRUE;
                    break;

                case 'm':
                case 'M':
                    State.DumpHeapSegments = TRUE;
                    break;

                case 't':
                    State.DumpHeapTags = TRUE;
                    break;

                case 'T':
                    State.DumpHeapPseudoTags = TRUE;
                    break;

                case 'g':
                case 'G':
                    State.DumpGlobalTags = TRUE;
                    break;

                case 'k':
                case 'K':
                    State.DumpStackBackTrace = TRUE;
                    break;

                case 's':
                case 'S':
                    State.ComputeSummary = TRUE;
                    break;

                case 'd':
                    State.DisableHeapChecking = TRUE;
                    break;

                case 'D':
                    State.DisableHeapValidateOnCall = TRUE;
                    break;

                case 'e':
                    State.EnableHeapChecking = TRUE;
                    break;

                case 'E':
                    State.EnableHeapValidateOnCall = TRUE;
                    break;

                case 'B':
                    State.RemoveStopOnBreakPoint = TRUE;
                    DashBArgumentState = 0;
                    State.StopOnOperation = 0;
                    State.StopOnAddress = 0;
                    State.StopOnTag.HeapIndex = 0;
                    State.StopOnTag.TagIndex = 0;
                    State.StopOnTagName[ 0 ] = UNICODE_NULL;
                    break;

                case 'b':
                    State.SetStopOnBreakPoint = TRUE;
                    DashBArgumentState = 0;
                    State.StopOnOperation = 0;
                    State.StopOnAddress = 0;
                    State.StopOnTag.HeapIndex = 0;
                    State.StopOnTag.TagIndex = 0;
                    State.StopOnTagName[ 0 ] = UNICODE_NULL;
                    break;

                default:
                    dprintf( "HEAPEXT: !heap invalid option flag '-%c'\n", *p );
                case '?':
                    State.ShowHelp = TRUE;
                    break;
                }

                p += 1;
                }
            }
        else
        if (*p != ' ') {
            if (State.SetStopOnBreakPoint) {
                switch (DashBArgumentState) {
                    case 0:
                        DashBArgumentState += 1;
                        if (sscanf( p, "%s", ArgumentBuffer ) == 1) {
                            if (!_stricmp( ArgumentBuffer, "alloc" )) {
                                State.StopOnOperation = STOP_ON_ALLOC;
                                }
                            else
                            if (!_stricmp( ArgumentBuffer, "realloc" )) {
                                State.StopOnOperation = STOP_ON_REALLOC;
                                }
                            else
                            if (!_stricmp( ArgumentBuffer, "free" )) {
                                State.StopOnOperation = STOP_ON_FREE;
                                }
                            }

                        if (State.StopOnOperation == 0) {
                            dprintf( "HEAPEXT: Invalid first argument to -b switch.\n" );
                            State.ShowHelp = TRUE;
                            }
                        break;

                    case 1:
                        if (sscanf( p, "%ws", &State.StopOnTagName ) != 1) {
                            State.StopOnTagName[ 0 ] = UNICODE_NULL;
                            dprintf( "HEAPEXT: Invalid second argument to -b switch.\n" );
                            State.ShowHelp = TRUE;
                            }
                        break;

                    default:
                        dprintf( "HEAPEXT: Too many parameters specified to -b switch\n" );
                        State.ShowHelp = TRUE;
                        break;
                    }
                }
            else
            if (State.RemoveStopOnBreakPoint) {
                switch (DashBArgumentState) {
                    case 0:
                        DashBArgumentState += 1;
                        if (sscanf( p, "%s", ArgumentBuffer ) == 1) {
                            if (!_stricmp( ArgumentBuffer, "alloc" )) {
                                State.StopOnOperation = STOP_ON_ALLOC;
                                }
                            else
                            if (!_stricmp( ArgumentBuffer, "realloc" )) {
                                State.StopOnOperation = STOP_ON_REALLOC;
                                }
                            else
                            if (!_stricmp( ArgumentBuffer, "free" )) {
                                State.StopOnOperation = STOP_ON_FREE;
                                }
                            }
                        break;

                    default:
                        dprintf( "HEAPEXT: Too many parameters specified to -B switch\n" );
                        State.ShowHelp = TRUE;
                        break;
                    }
                }
            else {
                ArgumentsSpecified = TRUE;
                sscanf( p, "%lx", &AddressToDump );
                }

            if ((p = strpbrk( p, " " )) == NULL) {
                p = "";
                }
            }
        else {
            p++;
            }
        }


    GotHeapsList = FALSE;
    pHeapsList = (PHEAP *)EnumerateHeaps( &State.NumberOfHeaps );

    if (AddressToDump == (ULONG_PTR)-1) {
        if ( pHeapsList ) {
            AddressToDump = (ULONG_PTR)*pHeapsList;
            }
        else {
            AddressToDump = 0x10000;
            }
        }

    if (State.NumberOfHeaps == 0) {
        dprintf( "No heaps to display.\n" );
        }
    else
    if (!pHeapsList) {
        dprintf( "Unable to get address of ProcessHeaps array\n" );
        }
    else {
        State.HeapsList = malloc( State.NumberOfHeaps * sizeof( PHEAP ) );
        if (State.HeapsList == NULL) {
            dprintf( "Unable to allocate memory to hold ProcessHeaps array\n" );
            }
        else {
            //
            // Read the array of heap pointers
            //

            memcpy( State.HeapsList, pHeapsList, State.NumberOfHeaps * sizeof(PHEAP) );
            GotHeapsList = TRUE;
            LocalFree( pHeapsList );
            }
        }

    if (GotHeapsList) {
retryArgs:
        if (!ArgumentsSpecified) {
            if (pRtlpHeapInvalidBreakPoint != NULL) {
                b = ReadMemory( (ULONG_PTR)pRtlpHeapInvalidBreakPoint,
                                &RtlpHeapInvalidBreakPoint,
                                sizeof( RtlpHeapInvalidBreakPoint ),
                                NULL
                              );
                if (b && RtlpHeapInvalidBreakPoint) {
                    RtlpHeapInvalidBadAddress = NULL;
                    if (pRtlpHeapInvalidBadAddress != NULL) {
                        b = ReadMemory( (ULONG_PTR)pRtlpHeapInvalidBadAddress,
                                        &RtlpHeapInvalidBadAddress,
                                        sizeof( RtlpHeapInvalidBadAddress ),
                                        NULL
                                      );
                        if (b) {
                            AddressToDump = (ULONG_PTR)RtlpHeapInvalidBadAddress;
                            }
                        }

                    dprintf( "Stop inside heap manager...validating heap address 0x%x\n", AddressToDump );
                    State.ValidateHeap = TRUE;
                    State.DumpStackBackTrace = TRUE;
                    ArgumentsSpecified = TRUE;
                    goto retryArgs;
                    }
                }
            }
        else
        if (AddressToDump != 0) {
            for (State.HeapIndex=0;
                 State.HeapIndex<State.NumberOfHeaps;
                 State.HeapIndex++
                ) {
                if (AddressToDump-1 == State.HeapIndex ||
                    AddressToDump == (ULONG_PTR)State.HeapsList[ State.HeapIndex ]
                   ) {
                    State.HeapToDump = (ULONG_PTR)State.HeapsList[ State.HeapIndex ];
                    break;
                    }
                }

            if (State.HeapToDump == 0) {
                if (AddressToDump >= SystemRangeStart) {
                    State.HeapToDump = AddressToDump;
                    }
                else {
                    State.HeapToDump = (ULONG)-1;
                    }
                }
            }

        State.HeapIndex = 0;
        }
    else {
        if (!ArgumentsSpecified || AddressToDump < 0x10000) {
            dprintf( "You must specify the actual heap address since\n" );
            dprintf( "array of process heaps is inaccessable\n" );
            State.ExitDumpLoop = TRUE;
            }
        else {
            State.HeapToDump = AddressToDump;
            }
        }

    i = (ULONG)State.EnableHeapChecking + (ULONG)State.EnableHeapValidateOnCall +
        (ULONG)State.DisableHeapChecking + (ULONG)State.DisableHeapValidateOnCall +
        (ULONG)State.ToggleAPICallTracing;
    if (i > 1) {
        dprintf( "HEAPEXT: -d, -D, -e, -E and -C flags are mutually exclusive\n" );
        if (State.HeapsList != NULL) {
            free( State.HeapsList );
            }
        return;
        }

    if (State.SetStopOnBreakPoint || State.RemoveStopOnBreakPoint) {
        if (pRtlpHeapStopOn == NULL) {
            dprintf( "HEAPEXT: Unable to %s heap breakpoint due to missing or invalid NTDLL symbols.\n",
                     State.SetStopOnBreakPoint ? "set" : "remove"
                   );
            if (State.HeapsList != NULL) {
                free( State.HeapsList );
                }
            return;
            }

        if (State.HeapToDump == 0) {
            dprintf( "HEAPEXT: Must specify either heap index or heap address to -b command.\n" );
            if (State.HeapsList != NULL) {
                free( State.HeapsList );
                }
            return;
            }
        }

    if (pNtGlobalFlag == NULL ||
        !ReadMemory( (ULONG_PTR)pNtGlobalFlag,
                     &NtGlobalFlag,
                     sizeof( NtGlobalFlag ),
                     NULL
                   )
       ) {
        if (i == 1) {
            dprintf( "HEAPEXT: Unable to access value of xboxkrnl!NtGlobalFlag.\n" );
            if (State.HeapsList != NULL) {
                free( State.HeapsList );
                }
            return;
            }
        }

    if (State.ShowHelp) {
        dprintf( "usage: !heap [address] [-? | -h] [-v] [[-a] | [-h] [-f] [-m]] [-t] [-s]\n" );
        dprintf( "                       [-d | -D | -e | -E]\n" );
        dprintf( "                       [-b [alloc | realloc | free] [tag]]\n" );
        dprintf( "                       [-B [alloc | realloc | free]]\n" );
        dprintf( "  address - specifies either a heap number (1-n), or a heap address.\n" );
        dprintf( "            Zero specifies all heaps in the process.\n" );
        dprintf( "            -1 is the default and specifies the process heap.\n" );
        dprintf( "  -?        displays this help message.\n" );
        dprintf( "  -v        validates the specified heap(s).\n" );
        dprintf( "  -a        displays all the information for the specified heap(s).\n" );
        dprintf( "            This can take a long time.\n" );
        dprintf( "  -h        displays all the entries for the specified heap(s).\n" );
        dprintf( "  -f        displays all the free list entries for the specified heap(s).\n" );
        dprintf( "  -k        displays any associated stack back trace for each entry (x86 only).\n" );
        dprintf( "  -m        displays all the segment entries for the specified heap(s).\n" );
        dprintf( "  -t        displays the tag information for the specified heap(s).\n" );
        dprintf( "  -T        displays the pseudo tag information for the specified heap(s).\n" );
        dprintf( "  -g        displays the global tag information generated by tag by DLL\n" );
        dprintf( "  -s        displays summary information for the specified heap(s).\n" );
        dprintf( "  -e        enables heap checking for the specified heap(s).\n" );
        dprintf( "  -d        disables heap checking for the specified heap(s).\n" );
        dprintf( "  -E        enables validate on call for the specified heap(s).\n" );
        dprintf( "  -D        disables validate on call for the specified heap(s).\n" );
        dprintf( "  -b        creates a conditional breakpoint in the heap manager.\n" );
        dprintf( "            alloc | realloc | free specifies which action to stop.\n" );
        dprintf( "            address either specifies the address of a block to stop on.\n" );
        dprintf( "            or a heap, in which case the tag argument is required,\n" );
        dprintf( "            and is the tag name within the heap specified by address.\n" );
        dprintf( "  -B        removes a conditional breakpoint in the heap manager.\n" );
        dprintf( "            if the type is not specified then all breakpoints are removed.\n" );
        if (State.HeapsList != NULL) {
            free( State.HeapsList );
            }
        return;
        }

    if (!ArgumentsSpecified) {
        if ((NtGlobalFlag & (FLG_HEAP_ENABLE_TAIL_CHECK |
                             FLG_HEAP_ENABLE_FREE_CHECK |
                             FLG_HEAP_VALIDATE_PARAMETERS |
                             FLG_HEAP_VALIDATE_ALL |
                             FLG_HEAP_ENABLE_TAGGING |
                             FLG_USER_STACK_TRACE_DB |
                             FLG_HEAP_DISABLE_COALESCING
                            )
            ) != 0
           ) {
            dprintf( "NtGlobalFlag enables following debugging aids for new heaps:" );
            if (NtGlobalFlag & FLG_HEAP_ENABLE_TAIL_CHECK) {
                dprintf( "    tail checking\n" );
                }

            if (NtGlobalFlag & FLG_HEAP_ENABLE_FREE_CHECK) {
                dprintf( "    free checking\n" );
                }

            if (NtGlobalFlag & FLG_HEAP_VALIDATE_PARAMETERS) {
                dprintf( "    validate parameters\n" );
                }

            if (NtGlobalFlag & FLG_HEAP_VALIDATE_ALL) {
                dprintf( "    validate on call\n" );
                }

            if (NtGlobalFlag & FLG_HEAP_ENABLE_TAGGING) {
                dprintf( "    heap tagging\n" );
                }

            if (NtGlobalFlag & FLG_USER_STACK_TRACE_DB) {
                dprintf( "    stack back traces\n" );
                }

            if (NtGlobalFlag & FLG_HEAP_DISABLE_COALESCING) {
                dprintf( "    disable coalescing of free blocks\n" );
                }
            }
        }

    if (State.DumpGlobalTags) {
        dprintf( "Global Tags defined for each DLL that makes an untagged allocation.\n" );
        if (MyLocalRtlpGlobalTagHeap.Signature != HEAP_SIGNATURE) {
            b = ReadMemory( (ULONG_PTR)pRtlpGlobalTagHeap,
                            &MyLocalRtlpGlobalTagHeap,
                            sizeof( MyLocalRtlpGlobalTagHeap ),
                            NULL
                          );
            if (!b) {
                dprintf( "HEAPEXT: Unable to read RtlpGlobalTagHeap\n" );
                if (State.HeapsList != NULL) {
                    free( State.HeapsList );
                    }
                return;
                }
            }

        pTagEntry = MyLocalRtlpGlobalTagHeap.TagEntries;
        if (pTagEntry == NULL) {
            dprintf( "    no global tags currently defined.\n" );
            }
        else {
            dprintf( " Tag  Name                   Allocs    Frees   Diff  Allocated\n" );
            for (TagIndex=1; TagIndex<MyLocalRtlpGlobalTagHeap.NextAvailableTagIndex; TagIndex++) {
                pTagEntry += 1;
                b = ReadMemory( (ULONG_PTR)pTagEntry,
                                &TagEntry,
                                sizeof( TagEntry ),
                                NULL
                              );
                if (!b) {
                    dprintf( "%04x: unable to read HEAP_TAG_ENTRY at %x\n", TagIndex, pTagEntry );
                    break;
                    }
                else
                if (TagEntry.Allocs != 0 ||
                    TagEntry.Frees != 0 ||
                    TagEntry.Size != 0
                   ) {
                    dprintf( "%04x: %-20.20ws %8d %8d %6d %8d\n",
                             TagEntry.TagIndex,
                             TagEntry.TagName,
                             TagEntry.Allocs,
                             TagEntry.Frees,
                             TagEntry.Allocs - TagEntry.Frees,
                             TagEntry.Size << HEAP_GRANULARITY_SHIFT
                           );
                    }
                }
            }
        }

    //
    // Walk the list of heaps
    //
    while (!State.ExitDumpLoop &&
           !CheckControlC() &&
           (!GotHeapsList || (State.HeapIndex < State.NumberOfHeaps ))
          ) {
        memset( &State.FreeListCounts, 0, sizeof( State.FreeListCounts ) );
        State.TotalFreeSize = 0;
        if (!GotHeapsList) {
            State.HeapAddress = (PHEAP)State.HeapToDump;
            State.ExitDumpLoop = TRUE;
            }
        else {
            State.HeapAddress = State.HeapsList[ State.HeapIndex ];
            }

        b = ReadMemory( (ULONG_PTR)(State.HeapAddress), &State.Heap, sizeof( State.Heap ), NULL );
        if (State.HeapIndex == 0) {
            dprintf( "Index   Address  Name      Debugging options enabled\n" );
            }

        dprintf( "%3u:   %08x ", State.HeapIndex + 1, State.HeapAddress );
        if (!b) {
            dprintf( " - heap headers inaccessable, skipping\n" );
            }
        else
        if (!ArgumentsSpecified) {
            if (!GetHeapTagEntry( &State.Heap, 0, &TagEntry )) {
                TagEntry.TagName[ 0 ] = UNICODE_NULL;
                }
            dprintf( " %-14.14ws", TagEntry.TagName );

            if (State.Heap.Flags & HEAP_TAIL_CHECKING_ENABLED) {
                dprintf( " tail checking" );
                }

            if (State.Heap.Flags & HEAP_FREE_CHECKING_ENABLED) {
                dprintf( " free checking" );
                }

            if (State.Heap.Flags & HEAP_VALIDATE_PARAMETERS_ENABLED) {
                dprintf( " validate parameters" );
                }

            if (State.Heap.Flags & HEAP_VALIDATE_ALL_ENABLED) {
                dprintf( " validate on call" );
                }

            dprintf( "\n" );
            }
        else
        if ((ULONG_PTR)State.HeapAddress == State.HeapToDump ||
            State.HeapToDump == 0 ||
            State.HeapToDump == (ULONG_PTR)-1
           ) {
            dprintf( "\n" );
            for (i=0; i<HEAP_MAXIMUM_SEGMENTS; i++) {
                if (State.Heap.Segments[ i ] != NULL) {
                    b = ReadMemory( (ULONG_PTR)(State.Heap.Segments[ i ]),
                                    &State.Segments[ i ],
                                    sizeof( HEAP_SEGMENT ),
                                    NULL
                                  );
                    if (!b) {
                        dprintf( "    Unabled to read HEAP_SEGMENT structure at %p\n", State.Heap.Segments[ i ] );
                        }
                    else {
                        dprintf( "    Segment at %p to %p (%08x bytes committed)\n",
                                 i == 0 ? (PVOID)State.HeapAddress : (PVOID)State.Heap.Segments[ i ],
                                 State.Segments[ i ].LastValidEntry,
                                 (DWORD_PTR)(State.Segments[ i ].LastValidEntry) -
                                    (DWORD_PTR)(i == 0 ? (DWORD_PTR)State.HeapAddress : (DWORD_PTR)State.Heap.Segments[ i ]) -
                                    (State.Segments[ i ].NumberOfUnCommittedPages * PAGE_SIZE)
                               );

                        if (State.HeapToDump == (ULONG)-1) {
                            if (AddressToDump >= (ULONG_PTR)State.Heap.Segments[ i ] &&
                                AddressToDump < (ULONG_PTR)State.Segments[ i ].LastValidEntry
                               ) {
                                State.HeapToDump = (ULONG_PTR)State.HeapAddress;
                                if (State.SetStopOnBreakPoint || State.RemoveStopOnBreakPoint) {
                                    State.StopOnAddress = (PVOID)AddressToDump;
                                    }
                                else {
                                    State.HeapEntryToDump = AddressToDump;
                                    }
                                }
                            }
                        }
                    }
                }

            if (State.HeapToDump == (ULONG)-1) {
                State.HeapIndex += 1;
                continue;
                }

            if (State.SetStopOnBreakPoint || State.RemoveStopOnBreakPoint) {
                PVOID pul;

                switch( State.StopOnOperation) {
                    case STOP_ON_ALLOC:
                        if (State.StopOnTagName[0] == UNICODE_NULL) {
                            pul = &pRtlpHeapStopOn->AllocAddress;
                            }
                        else {
                            pul = &pRtlpHeapStopOn->AllocTag.HeapAndTagIndex;
                            }
                        break;

                    case STOP_ON_REALLOC:
                        if (State.StopOnTagName[0] == UNICODE_NULL) {
                            pul = &pRtlpHeapStopOn->ReAllocAddress;
                            }
                        else {
                            pul = &pRtlpHeapStopOn->ReAllocTag.HeapAndTagIndex;
                            }
                        break;

                    case STOP_ON_FREE:
                        if (State.StopOnTagName[0] == UNICODE_NULL) {
                            pul = &pRtlpHeapStopOn->FreeAddress;
                            }
                        else {
                            pul = &pRtlpHeapStopOn->FreeTag.HeapAndTagIndex;
                            }
                        break;
                    default:
                        pul = NULL;
                        break;
                    }

                if (pul != NULL) {
                    if (State.StopOnTagName[0] == UNICODE_NULL) {
                        if (State.RemoveStopOnBreakPoint) {
                            State.StopOnAddress = 0;
                            }
                        b = WriteMemory( (ULONG_PTR)pul,
                                         &State.StopOnAddress,
                                         sizeof( State.StopOnAddress ),
                                         NULL
                                       );
                        }
                    else {
                        if (!ConvertTagNameToIndex( &State )) {
                            dprintf( "HEAPEXT: Unable to convert tag name %ws to an index\n", State.StopOnTagName );
                            b = TRUE;
                            }
                        else {
                            b = WriteMemory( (ULONG_PTR)pul,
                                             &State.StopOnTag.HeapAndTagIndex,
                                             sizeof( State.StopOnTag.HeapAndTagIndex ),
                                             NULL
                                           );
                            }
                        }

                    if (!b) {
                        dprintf( "HEAPEXT: Unable to set heap breakpoint - write memory to %x failed\n", pul );
                        }
                    else {
                        if (State.SetStopOnBreakPoint) {
                            if (State.StopOnTagName[0] == UNICODE_NULL) {
                                dprintf( "HEAPEXT: Enabled heap breakpoint for %s of block %x\n",
                                         State.StopOnOperation == STOP_ON_ALLOC ? "Alloc" :
                                         State.StopOnOperation == STOP_ON_REALLOC ? "ReAlloc" :
                                         "Free",
                                         State.StopOnAddress
                                       );
                                }
                            else {
                                dprintf( "HEAPEXT: Enabled heap breakpoint for %s of block with tag %ws\n",
                                         State.StopOnOperation == STOP_ON_ALLOC ? "Alloc" :
                                         State.StopOnOperation == STOP_ON_REALLOC ? "ReAlloc" :
                                         "Free",
                                         State.StopOnTagName
                                       );
                                }
                            }
                        else {
                            dprintf( "HEAPEXT: Disabled heap breakpoint for %s\n",
                                     State.StopOnOperation == STOP_ON_ALLOC ? "Alloc" :
                                     State.StopOnOperation == STOP_ON_REALLOC ? "ReAlloc" :
                                     "Free"
                                   );
                            }
                        }
                    }
                }

            if (State.ValidateHeap) {
                ValidateHeapHeader( State.HeapAddress, &State.Heap );
                }

            HeapHeaderModified = FALSE;
            if (State.EnableHeapChecking || State.EnableHeapValidateOnCall) {
                if (!(State.Heap.Flags & HEAP_TAIL_CHECKING_ENABLED)) {
                    State.Heap.AlignRound += CHECK_HEAP_TAIL_SIZE;
                    b = WriteMemory( (ULONG_PTR)(&State.HeapAddress->AlignRound),
                                     &State.Heap.AlignRound,
                                     sizeof( State.Heap.AlignRound ),
                                     NULL
                                   );
                    }
                else {
                    b = TRUE;
                    }


                if (b) {
                    HeapHeaderModified = TRUE;
                    State.Heap.Flags |= HEAP_VALIDATE_PARAMETERS_ENABLED |
                                        HEAP_TAIL_CHECKING_ENABLED |
                                        HEAP_FREE_CHECKING_ENABLED;
                    if (State.EnableHeapValidateOnCall) {
                        State.Heap.Flags |= HEAP_VALIDATE_ALL_ENABLED;
                        }

                    b = WriteMemory( (ULONG_PTR)&State.HeapAddress->Flags,
                                     (LPCVOID)&State.Heap.Flags,
                                     sizeof( State.Heap.Flags ),
                                     NULL
                                   );
                    }

                if (!b) {
                    dprintf( "HEAPEXT: Unable to enable heap checking for heap %p\n", State.HeapAddress );
                    ReadMemory( (ULONG_PTR)(State.HeapAddress), &State.Heap, sizeof( State.Heap ), NULL );
                    }
                else {
                    if (State.EnableHeapValidateOnCall) {
                        dprintf( "HEAPEXT: Enabled validate on call heap checking for heap %p\n", State.HeapAddress );
                        }
                    else {
                        dprintf( "HEAPEXT: Enabled heap checking for heap %p\n", State.HeapAddress );
                        }
                    }
                }
            else
            if (State.DisableHeapChecking || State.DisableHeapValidateOnCall) {
                if (State.DisableHeapValidateOnCall) {
                    if (State.Heap.Flags & HEAP_VALIDATE_ALL_ENABLED) {
                        State.Heap.Flags &= ~HEAP_VALIDATE_ALL_ENABLED;
                        b = WriteMemory( (ULONG_PTR)&State.HeapAddress->Flags,
                                         (LPCVOID)&State.Heap.Flags,
                                         sizeof( State.Heap.Flags ),
                                         NULL
                                       );
                        }
                    else {
                        b = TRUE;
                        }
                    }
                else {
                    if (State.Heap.Flags & HEAP_TAIL_CHECKING_ENABLED) {
                        HeapHeaderModified = TRUE;
                        State.Heap.AlignRound -= CHECK_HEAP_TAIL_SIZE;
                        b = WriteMemory( (ULONG_PTR)&State.HeapAddress->AlignRound,
                                         (LPCVOID)&State.Heap.AlignRound,
                                         sizeof( State.Heap.AlignRound ),
                                         NULL
                                       );
                        }
                    else {
                        b = TRUE;
                        }

                    if (b) {
                        State.Heap.Flags &= ~(HEAP_VALIDATE_PARAMETERS_ENABLED |
                                              HEAP_VALIDATE_ALL_ENABLED |
                                              HEAP_TAIL_CHECKING_ENABLED |
                                              HEAP_FREE_CHECKING_ENABLED
                                             );
                        b = WriteMemory( (ULONG_PTR)&State.HeapAddress->Flags,
                                         (LPCVOID)&State.Heap.Flags,
                                         sizeof( State.Heap.Flags ),
                                         NULL
                                       );
                        }
                    }

                if (!b) {
                    dprintf( "HEAPEXT: Unable to disable heap checking for heap %p\n", State.HeapAddress );
                    ReadMemory( (ULONG_PTR)(State.HeapAddress), &State.Heap, sizeof( State.Heap ), NULL );
                    }
                else {
                    if (State.DisableHeapValidateOnCall) {
                        dprintf( "HEAPEXT: Disabled validate on call heap checking for heap %p\n", State.HeapAddress );
                        }
                    else {
                        dprintf( "HEAPEXT: Disabled heap checking for heap %p\n", State.HeapAddress );
                        }
                    }
                }
            else
            if (State.ToggleAPICallTracing) {
                State.Heap.Flags ^= HEAP_CREATE_ENABLE_TRACING;
                b = WriteMemory( (ULONG_PTR)&State.HeapAddress->Flags,
                                 (LPCVOID)&State.Heap.Flags,
                                 sizeof( State.Heap.Flags ),
                                 NULL
                               );
                if (!b) {
                    dprintf( "HEAPEXT: Unable to toggle API call tracing for heap %p\n", State.HeapAddress );
                    ReadMemory( (ULONG_PTR)(State.HeapAddress), &State.Heap, sizeof( State.Heap ), NULL );
                    }
                else {
                    HeapHeaderModified = TRUE;
                    if (State.Heap.Flags & HEAP_CREATE_ENABLE_TRACING) {
                        dprintf( "HEAPEXT: Enabled API call tracing for heap %p\n", State.HeapAddress );
                        }
                    else {
                        dprintf( "HEAPEXT: Disabled API call tracing for heap %p\n", State.HeapAddress );
                        }
                    }
                }
            else
            if (State.DumpHeapTags) {
                pTagEntry = State.Heap.TagEntries;
                if (pTagEntry == NULL) {
                    dprintf( "    no tags currently defined for this heap.\n" );
                    }
                else {
                    dprintf( " Tag  Name                   Allocs    Frees   Diff  Allocated\n" );
                    for (TagIndex=1; TagIndex<State.Heap.NextAvailableTagIndex; TagIndex++) {
                        pTagEntry += 1;
                        b = ReadMemory( (ULONG_PTR)pTagEntry,
                                        &TagEntry,
                                        sizeof( TagEntry ),
                                        NULL
                                      );
                        if (!b) {
                            dprintf( "%04x: unable to read HEAP_TAG_ENTRY at %p\n", TagIndex, pTagEntry );
                            }
                        else
                        if (TagEntry.Allocs != 0 ||
                            TagEntry.Frees != 0 ||
                            TagEntry.Size != 0
                           ) {
                            dprintf( "%04x: %-20.20ws %8d %8d %6d %8d\n",
                                     TagEntry.TagIndex,
                                     TagEntry.TagName,
                                     TagEntry.Allocs,
                                     TagEntry.Frees,
                                     TagEntry.Allocs - TagEntry.Frees,
                                     TagEntry.Size << HEAP_GRANULARITY_SHIFT
                                   );
                            }
                        }
                    }
                }
            else
            if (State.DumpHeapPseudoTags) {
                pPseudoTagEntry = State.Heap.PseudoTagEntries;
                if (pPseudoTagEntry == NULL) {
                    dprintf( "    no pseudo tags currently defined for this heap.\n" );
                    }
                else {
                    dprintf( " Tag Name            Allocs    Frees   Diff  Allocated\n" );
                    for (TagIndex=1; TagIndex<HEAP_NUMBER_OF_PSEUDO_TAG; TagIndex++) {
                        pPseudoTagEntry += 1;
                        b = ReadMemory( (ULONG_PTR)pPseudoTagEntry,
                                        &PseudoTagEntry,
                                        sizeof( PseudoTagEntry ),
                                        NULL
                                      );
                        if (!b) {
                            dprintf( "%04x: unable to read HEAP_PSEUDO_TAG_ENTRY at %p\n", TagIndex, pPseudoTagEntry );
                            }
                        else
                        if (PseudoTagEntry.Allocs != 0 ||
                            PseudoTagEntry.Frees != 0 ||
                            PseudoTagEntry.Size != 0
                           ) {
                            if (TagIndex == 0) {
                                dprintf( "%04x: Objects>%4u",
                                         TagIndex | HEAP_PSEUDO_TAG_FLAG,
                                         HEAP_MAXIMUM_FREELISTS << HEAP_GRANULARITY_SHIFT
                                       );
                                }
                            else
                            if (TagIndex < HEAP_MAXIMUM_FREELISTS) {
                                dprintf( "%04x: Objects=%4u",
                                         TagIndex | HEAP_PSEUDO_TAG_FLAG,
                                         TagIndex << HEAP_GRANULARITY_SHIFT
                                       );
                                }
                            else {
                                dprintf( "%04x: VirtualAlloc", TagIndex | HEAP_PSEUDO_TAG_FLAG );
                                }
                            dprintf( " %8d %8d %6d %8d\n",
                                     PseudoTagEntry.Allocs,
                                     PseudoTagEntry.Frees,
                                     PseudoTagEntry.Allocs - PseudoTagEntry.Frees,
                                     PseudoTagEntry.Size << HEAP_GRANULARITY_SHIFT
                                   );
                            }
                        }
                    }
                }

            if (HeapHeaderModified && (State.Heap.HeaderValidateCopy != NULL)) {
                b = WriteMemory( (ULONG_PTR)State.Heap.HeaderValidateCopy,
                                 &State.Heap,
                                 sizeof( State.Heap ),
                                 NULL
                               );
                if (!b) {
                    dprintf( "HEAPEXT: Unable to update header validation copy at %p\n", State.Heap.HeaderValidateCopy );
                    }
                }

            if (State.HeapEntryToDump != 0 ||
                State.DumpHeapEntries ||
                State.DumpHeapSegments ||
                State.DumpHeapFreeLists
               ) {
                WalkHEAP( &State );
                }
            }
        else {
            dprintf( "\n" );
            }

        State.HeapIndex += 1;
        }

    if (State.HeapsList != NULL) {
        free( State.HeapsList );
        }

    return;
}

BOOL
ConvertTagNameToIndex(
    IN PHEAP_STATE State
    )
{
    ULONG TagIndex;
    PHEAP_TAG_ENTRY pTagEntry;
    HEAP_TAG_ENTRY TagEntry;
    PHEAP_PSEUDO_TAG_ENTRY pPseudoTagEntry;
    HEAP_PSEUDO_TAG_ENTRY PseudoTagEntry;
    BOOL b;
    PWSTR s;

    if (State->RemoveStopOnBreakPoint) {
        State->StopOnTag.HeapAndTagIndex = 0;
        return TRUE;
        }

    if (!_wcsnicmp( State->StopOnTagName, L"Objects", 7 )) {
        pPseudoTagEntry = State->Heap.PseudoTagEntries;
        if (pPseudoTagEntry == NULL) {
            return FALSE;
            }

        s = &State->StopOnTagName[ 7 ];
        if (*s == L'>') {
            State->StopOnTag.HeapIndex = State->Heap.ProcessHeapsListIndex;
            State->StopOnTag.TagIndex = HEAP_PSEUDO_TAG_FLAG;
            return TRUE;
            }
        else
        if (*s == L'=') {
            while (*++s == L' ') ;
            State->StopOnTag.TagIndex = (USHORT)_wtoi( s );
            if (State->StopOnTag.TagIndex > 0 &&
                State->StopOnTag.TagIndex < (HEAP_MAXIMUM_FREELISTS >> HEAP_GRANULARITY_SHIFT)
               ) {
                State->StopOnTag.HeapIndex = State->Heap.ProcessHeapsListIndex;
                State->StopOnTag.TagIndex = (State->StopOnTag.TagIndex >> HEAP_GRANULARITY_SHIFT) |
                                             HEAP_PSEUDO_TAG_FLAG;
                return TRUE;
                }
            }
        }

    pTagEntry = State->Heap.TagEntries;
    if (pTagEntry == NULL) {
        return FALSE;
        }

    for (TagIndex=1; TagIndex<State->Heap.NextAvailableTagIndex; TagIndex++) {
        pTagEntry += 1;
        b = ReadMemory( (ULONG_PTR)pTagEntry,
                        &TagEntry,
                        sizeof( TagEntry ),
                        NULL
                      );
        if (b && !_wcsicmp( State->StopOnTagName, TagEntry.TagName )) {
            State->StopOnTag.TagIndex = TagEntry.TagIndex;
            return TRUE;
            }
        }

    return FALSE;
}


BOOL
GetHeapTagEntry(
    IN PHEAP Heap,
    IN USHORT TagIndex,
    OUT PHEAP_TAG_ENTRY TagEntry
    )
{
    BOOL b;
    PHEAP_TAG_ENTRY pTagEntries;
    PHEAP_PSEUDO_TAG_ENTRY pPseudoTagEntries;

    b = FALSE;
    if (TagIndex & HEAP_PSEUDO_TAG_FLAG) {
        TagIndex &= ~HEAP_PSEUDO_TAG_FLAG;
        pPseudoTagEntries = Heap->PseudoTagEntries;
        if (pPseudoTagEntries == 0) {
            return FALSE;
            }
        if (TagIndex == 0) {
            swprintf( TagEntry->TagName, L"Objects>%4u",
                      HEAP_MAXIMUM_FREELISTS << HEAP_GRANULARITY_SHIFT
                    );
            }
        else
        if (TagIndex < HEAP_MAXIMUM_FREELISTS) {
            swprintf( TagEntry->TagName, L"Objects=%4u", TagIndex << HEAP_GRANULARITY_SHIFT );
            }
        else {
            swprintf( TagEntry->TagName, L"VirtualAlloc" );
            }
        TagEntry->TagIndex = TagIndex;
        TagEntry->CreatorBackTraceIndex = 0;
        b = ReadMemory( (ULONG_PTR)(pPseudoTagEntries + TagIndex),
                        TagEntry,
                        sizeof( *pPseudoTagEntries ),
                        NULL
                      );
        }
    else
    if (TagIndex & HEAP_GLOBAL_TAG) {
        if (MyLocalRtlpGlobalTagHeap.Signature != HEAP_SIGNATURE) {
            b = ReadMemory( (ULONG_PTR)pRtlpGlobalTagHeap,
                            &MyLocalRtlpGlobalTagHeap,
                            sizeof( MyLocalRtlpGlobalTagHeap ),
                            NULL
                          );
            if (!b) {
                return b;
                }
            }
        TagIndex &= ~HEAP_GLOBAL_TAG;
        if (TagIndex < MyLocalRtlpGlobalTagHeap.NextAvailableTagIndex) {
            pTagEntries = MyLocalRtlpGlobalTagHeap.TagEntries;
            if (pTagEntries == 0) {
                return FALSE;
                }

            b = ReadMemory( (ULONG_PTR)(pTagEntries + TagIndex),
                            TagEntry,
                            sizeof( *TagEntry ),
                            NULL
                          );
            }
        }
    else
    if (TagIndex < Heap->NextAvailableTagIndex) {
        pTagEntries = Heap->TagEntries;
        if (pTagEntries == 0) {
            return FALSE;
            }

        b = ReadMemory( (ULONG_PTR)(pTagEntries + TagIndex),
                        TagEntry,
                        sizeof( *TagEntry ),
                        NULL
                      );
        }

    return b;
}


VOID
WalkHEAP(
    IN PHEAP_STATE State
    )
{
    BOOL b;
    PVOID FreeListHead;
    ULONG i;
    PLIST_ENTRY Head, Next;
    HEAP_VIRTUAL_ALLOC_ENTRY VirtualAllocEntry;
    HEAP_TAG_ENTRY TagEntry;
    PHEAP_FREE_ENTRY FreeEntryAddress;
    HEAP_FREE_ENTRY FreeEntry;
    PHEAP_UCR_SEGMENT UCRSegment;
    HEAP_UCR_SEGMENT CapturedUCRSegment;
    ULONG AlignRound;

    AlignRound = State->Heap.AlignRound - sizeof( HEAP_ENTRY );
    if (State->Heap.Flags & HEAP_TAIL_CHECKING_ENABLED) {
        AlignRound -= CHECK_HEAP_TAIL_SIZE;
        }

    dprintf( "    Flags:               %08x\n", State->Heap.Flags );
    dprintf( "    ForceFlags:          %08x\n", State->Heap.ForceFlags );
    dprintf( "    Granularity:         %u bytes\n", AlignRound + 1 );
    dprintf( "    Segment Reserve:     %08x\n", State->Heap.SegmentReserve );
    dprintf( "    Segment Commit:      %08x\n", State->Heap.SegmentCommit );
    dprintf( "    DeCommit Block Thres:%08x\n", State->Heap.DeCommitFreeBlockThreshold );
    dprintf( "    DeCommit Total Thres:%08x\n", State->Heap.DeCommitTotalFreeThreshold );
    dprintf( "    Total Free Size:     %08x\n", State->Heap.TotalFreeSize );
    dprintf( "    Max. Allocation Size:%08x\n", State->Heap.MaximumAllocationSize );
    dprintf( "    Lock Variable at:    %08x\n", State->Heap.LockVariable );
    dprintf( "    Next TagIndex:       %04x\n", State->Heap.NextAvailableTagIndex );
    dprintf( "    Maximum TagIndex:    %04x\n", State->Heap.MaximumTagIndex );
    dprintf( "    Tag Entries:         %08x\n", State->Heap.TagEntries );
    dprintf( "    PsuedoTag Entries:   %08x\n", State->Heap.PseudoTagEntries );
    dprintf( "    Virtual Alloc List:  %08x\n", &State->HeapAddress->VirtualAllocdBlocks );

    Head = &State->HeapAddress->VirtualAllocdBlocks;
    Next = State->Heap.VirtualAllocdBlocks.Flink;
    while (Next != Head) {
        if (!ReadMemory( (ULONG_PTR)Next,
                         &VirtualAllocEntry,
                         sizeof( VirtualAllocEntry ),
                         NULL
                       )
           ) {
            dprintf( "    Unable to read _HEAP_VIRTUAL_ALLOC_ENTRY structure at %p\n", Next );
            break;
            }

        if (State->DumpHeapEntries) {
            dprintf( "        %08x: %08x [%02x] - busy (%x)",
                     Next,
                     VirtualAllocEntry.CommitSize,
                     VirtualAllocEntry.CommitSize - VirtualAllocEntry.BusyBlock.Size,
                     VirtualAllocEntry.BusyBlock.Flags
                   );

            if (VirtualAllocEntry.BusyBlock.Flags & HEAP_ENTRY_FILL_PATTERN) {
                dprintf( ", tail fill" );
                }
            if (VirtualAllocEntry.ExtraStuff.Settable) {
                dprintf( " (Handle %08x)", VirtualAllocEntry.ExtraStuff.Settable );
                }

            if (VirtualAllocEntry.ExtraStuff.TagIndex) {
                if (GetHeapTagEntry( &State->Heap, VirtualAllocEntry.ExtraStuff.TagIndex, &TagEntry )) {
                    dprintf( " (%ws)", TagEntry.TagName );
                    }
                else {
                    dprintf( " (Tag %x)", VirtualAllocEntry.ExtraStuff.TagIndex );
                    }
                }

            if (VirtualAllocEntry.BusyBlock.Flags & HEAP_ENTRY_SETTABLE_FLAGS) {
                dprintf( ", user flags (%x)", (VirtualAllocEntry.BusyBlock.Flags & HEAP_ENTRY_SETTABLE_FLAGS) >> 5 );
                }

            dprintf( "\n" );
#if STACK_TRACE_DATABASE_SUPPORT
            DumpStackBackTraceIndex( State, VirtualAllocEntry.ExtraStuff.AllocatorBackTraceIndex );
#endif // STACK_TRACE_DATABASE_SUPPORT
            }

        if (VirtualAllocEntry.Entry.Flink == Next) {
            dprintf( "        **** List is hosed\n");
            break;
            }

        Next = VirtualAllocEntry.Entry.Flink;
        }

    dprintf( "    UCR FreeList:        %p\n", State->Heap.UnusedUnCommittedRanges );
    UCRSegment = State->Heap.UCRSegments;
    while (UCRSegment != NULL) {
        b = ReadMemory( (ULONG_PTR)UCRSegment,
                        &CapturedUCRSegment,
                        sizeof( CapturedUCRSegment ),
                        NULL
                      );
        if (!b) {
            dprintf( "    Unabled to read HEAP_UCR_SEGMENT structure at %08x\n", UCRSegment );
            break;
            }
        else {
            dprintf( "    UCRSegment - %08x: %08x . %08x\n",
                     UCRSegment,
                     CapturedUCRSegment.CommittedSize,
                     CapturedUCRSegment.ReservedSize
                   );
            }

        if (State->ComputeSummary) {
            State->OverheadSize += CapturedUCRSegment.CommittedSize;
            }

        UCRSegment = CapturedUCRSegment.Next;
        }

    dprintf( "    FreeList Usage:      %08x %08x %08x %08x\n",
             State->Heap.u.FreeListsInUseUlong[0],
             State->Heap.u.FreeListsInUseUlong[1],
             State->Heap.u.FreeListsInUseUlong[2],
             State->Heap.u.FreeListsInUseUlong[3]
           );

    if (State->ComputeSummary) {
        State->OverheadSize += sizeof( State->Heap );
        dprintf( "Committed   Allocated     Free      OverHead\n" );
        dprintf( "% 8x    % 8x      % 8x  % 8x\r",
                 State->CommittedSize,
                 State->AllocatedSize,
                 State->FreeSize,
                 State->OverheadSize
               );
        }

    for (i=0; i<HEAP_MAXIMUM_FREELISTS; i++) {
        FreeListHead = &State->HeapAddress->FreeLists[ i ];
        if (State->Heap.FreeLists[ i ].Flink != State->Heap.FreeLists[ i ].Blink ||
            State->Heap.FreeLists[ i ].Flink != FreeListHead
           ) {
            dprintf( "    FreeList[ %02x ] at %08x: %08x . %08x\n",
                     i,
                     FreeListHead,
                     State->Heap.FreeLists[ i ].Blink,
                     State->Heap.FreeLists[ i ].Flink
                   );

            Next = State->Heap.FreeLists[ i ].Flink;
            while (Next != FreeListHead) {
                FreeEntryAddress = CONTAINING_RECORD( Next, HEAP_FREE_ENTRY, FreeList );
                b = ReadMemory( (ULONG_PTR)FreeEntryAddress,
                                &FreeEntry,
                                sizeof( FreeEntry ),
                                NULL
                              );
                if (!b) {
                    dprintf( "    Unabled to read HEAP_ENTRY structure at %08x\n", FreeEntryAddress );
                    break;
                    }

                if (State->DumpHeapFreeLists) {
                    dprintf( "        %08x: %05x . %05x [%02x] - free\n",
                             FreeEntryAddress,
                             FreeEntry.PreviousSize << HEAP_GRANULARITY_SHIFT,
                             FreeEntry.Size << HEAP_GRANULARITY_SHIFT,
                             FreeEntry.Flags
                           );
                    }

                Next = FreeEntry.FreeList.Flink;

                if (CheckControlC()) {
                    return;
                    }
                }
            }

        }

    for (i=0; i<HEAP_MAXIMUM_SEGMENTS; i++) {
        if (State->Heap.Segments[ i ] != NULL) {
            State->SegmentNumber = i;
            State->SegmentAddress = State->Heap.Segments[ i ];
            WalkHEAP_SEGMENT( State );
            }

        if (State->ExitDumpLoop || CheckControlC()) {
            break;
            }
        }

    if (State->HeapAddress == (PHEAP)State->HeapToDump) {
        State->ExitDumpLoop = TRUE;
        }

    return;
}

VOID
WalkHEAP_SEGMENT(
    IN PHEAP_STATE State
    )
{
    PHEAP_SEGMENT Segment;
    BOOL b;
    BOOLEAN DumpEntry;
    PHEAP_ENTRY EntryAddress, PrevEntryAddress, NextEntryAddress;
    HEAP_ENTRY Entry, PrevEntry;
    PHEAP_UNCOMMMTTED_RANGE UnCommittedRanges;
    PHEAP_UNCOMMMTTED_RANGE Buffer, UnCommittedRange, UnCommittedRangeEnd;

    Segment = &State->Segments[ State->SegmentNumber ];
    if (State->ComputeSummary) {
        State->OverheadSize += sizeof( *Segment );
        dprintf( "% 8x    % 8x      % 8x  % 8x\r",
                 State->CommittedSize,
                 State->AllocatedSize,
                 State->FreeSize,
                 State->OverheadSize
               );
        }

    if (State->DumpHeapSegments) {
        dprintf( "    Segment%02u at %08x:\n", State->SegmentNumber, State->SegmentAddress );
        dprintf( "        Flags:           %08x\n", Segment->Flags );
        dprintf( "        Base:            %08x\n", Segment->BaseAddress );
        dprintf( "        First Entry:     %08x\n", Segment->FirstEntry );
        dprintf( "        Last Entry:      %08x\n", Segment->LastValidEntry );
        dprintf( "        Total Pages:     %08x\n", Segment->NumberOfPages );
        dprintf( "        Total UnCommit:  %08x\n", Segment->NumberOfUnCommittedPages );
        dprintf( "        Largest UnCommit:%08x\n", Segment->LargestUnCommittedRange );
        dprintf( "        UnCommitted Ranges: (%u)\n", Segment->NumberOfUnCommittedRanges );
        }

    Buffer = malloc( Segment->NumberOfUnCommittedRanges * sizeof( *UnCommittedRange ) );
    if (Buffer == NULL) {
        dprintf( "            unable to allocate memory for reading uncommitted ranges\n" );
        return;
        }

    UnCommittedRanges = Segment->UnCommittedRanges;
    UnCommittedRange = Buffer;
    while (UnCommittedRanges != NULL) {
        b = ReadMemory( (ULONG_PTR)UnCommittedRanges,
                        UnCommittedRange,
                        sizeof( *UnCommittedRange ),
                        NULL
                      );
        if (!b) {
            dprintf( "            unable to read uncommited range structure at %x\n",
                     UnCommittedRanges
                   );
            free( Buffer );
            return;
            }

        if (State->DumpHeapSegments) {
            dprintf( "            %08x: %08x\n", UnCommittedRange->Address, UnCommittedRange->Size );
            }

        UnCommittedRanges = UnCommittedRange->Next;
        UnCommittedRange->Next = (UnCommittedRange+1);
        UnCommittedRange += 1;

        if (CheckControlC()) {
            break;
            }
        }

    if (State->DumpHeapSegments) {
        dprintf( "\n" );
        }

    State->CommittedSize += ( Segment->NumberOfPages -
                                    Segment->NumberOfUnCommittedPages
                                  ) * PAGE_SIZE;
    if (State->ComputeSummary) {
        dprintf( "% 8x    % 8x      % 8x  % 8x\r",
                 State->CommittedSize,
                 State->AllocatedSize,
                 State->FreeSize,
                 State->OverheadSize
               );
        }

    if (State->DumpHeapEntries) {
        dprintf( "    Heap entries for Segment%02u in Heap %x\n", State->SegmentNumber, State->HeapAddress );
        }

    UnCommittedRangeEnd = UnCommittedRange;
    UnCommittedRange = Buffer;
    if (Segment->BaseAddress == State->HeapAddress) {
        EntryAddress = &((PHEAP)State->HeapAddress)->Entry;
        }
    else {
        EntryAddress = &State->Heap.Segments[ State->SegmentNumber ]->Entry;
        }

    PrevEntryAddress = NULL;
    while (EntryAddress < Segment->LastValidEntry) {
        b = ReadMemory( (ULONG_PTR)EntryAddress, &Entry, sizeof( Entry ), NULL );
        if (!b) {
            dprintf( "            unable to read heap entry at %08x\n", EntryAddress );
            break;
            }

        NextEntryAddress = EntryAddress + Entry.Size;
        if (State->DumpHeapEntries) {
           DumpEntry = TRUE;
           }
        else
        if (PrevEntryAddress != NULL &&
            (State->HeapEntryToDump == (ULONG_PTR)PrevEntryAddress ||
             (State->HeapEntryToDump > (ULONG_PTR)PrevEntryAddress &&
              State->HeapEntryToDump <= (ULONG_PTR)NextEntryAddress
             )
            )
           ) {
           DumpEntry = TRUE;
           }
        else {
           DumpEntry = FALSE;
           }

        if (DumpEntry) {
            DumpHeapEntry( State, EntryAddress, &Entry );
            }

        if (!(Entry.Flags & HEAP_ENTRY_BUSY)) {
            State->TotalFreeSize += Entry.Size;
            }

        if (State->ComputeSummary) {
            if (Entry.Flags & HEAP_ENTRY_BUSY) {
                State->AllocatedSize += Entry.Size << HEAP_GRANULARITY_SHIFT;
                State->AllocatedSize -= Entry.UnusedBytes;
                State->OverheadSize += Entry.UnusedBytes;
                }
            else {
                State->FreeSize += Entry.Size << HEAP_GRANULARITY_SHIFT;
                }
            }

        if (State->ValidateHeap) {
            if (!ValidateHeapEntry( State,
                                    PrevEntryAddress,
                                    &PrevEntry,
                                    EntryAddress,
                                    &Entry
                                  )
               ) {
                if (State->DumpHeapEntries) {
                    break;
                    }
                }
            }

        if (Entry.Size == 0 || CheckControlC()) {
            break;
            }

        PrevEntryAddress = EntryAddress;
        PrevEntry = Entry;
        EntryAddress = NextEntryAddress;
        if (Entry.Flags & HEAP_ENTRY_LAST_ENTRY) {
            if (State->ComputeSummary) {
                dprintf( "% 8x    % 8x      % 8x  % 8x\r",
                         State->CommittedSize,
                         State->AllocatedSize,
                         State->FreeSize,
                         State->OverheadSize
                       );
                }

            if ((ULONG_PTR)EntryAddress == UnCommittedRange->Address) {
                if (DumpEntry) {
                    dprintf( "        %p:      %08x      - uncommitted bytes.\n",
                             UnCommittedRange->Address,
                             UnCommittedRange->Size
                           );
                    }

                PrevEntryAddress = NULL;
                EntryAddress = (PHEAP_ENTRY)
                    ((PCHAR)UnCommittedRange->Address + UnCommittedRange->Size);

                UnCommittedRange += 1;
                }
            else {
                break;
                }
            }
        }

    free( Buffer );
    if (State->ComputeSummary) {
        dprintf( "% 8x    % 8x      % 8x  % 8x\r",
                 State->CommittedSize,
                 State->AllocatedSize,
                 State->FreeSize,
                 State->OverheadSize
               );
        }

    return;
}

struct {
    ULONG Offset;
    LPSTR Description;
} FieldOffsets[] = {
    FIELD_OFFSET( HEAP, Entry ),                        "Entry",
    FIELD_OFFSET( HEAP, Signature ),                    "Signature",
    FIELD_OFFSET( HEAP, Flags ),                        "Flags",
    FIELD_OFFSET( HEAP, ForceFlags ),                   "ForceFlags",
    FIELD_OFFSET( HEAP, VirtualMemoryThreshold ),       "VirtualMemoryThreshold",
    FIELD_OFFSET( HEAP, SegmentReserve ),               "SegmentReserve",
    FIELD_OFFSET( HEAP, SegmentCommit ),                "SegmentCommit",
    FIELD_OFFSET( HEAP, DeCommitFreeBlockThreshold ),   "DeCommitFreeBlockThreshold",
    FIELD_OFFSET( HEAP, DeCommitTotalFreeThreshold ),   "DeCommitTotalFreeThreshold",
    FIELD_OFFSET( HEAP, TotalFreeSize ),                "TotalFreeSize",
    FIELD_OFFSET( HEAP, MaximumAllocationSize ),        "MaximumAllocationSize",
    FIELD_OFFSET( HEAP, ProcessHeapsListIndex ),        "ProcessHeapsListIndex",
    FIELD_OFFSET( HEAP, HeaderValidateLength ),         "HeaderValidateLength",
    FIELD_OFFSET( HEAP, HeaderValidateCopy ),           "HeaderValidateCopy",
    FIELD_OFFSET( HEAP, NextAvailableTagIndex ),        "NextAvailableTagIndex",
    FIELD_OFFSET( HEAP, MaximumTagIndex ),              "MaximumTagIndex",
    FIELD_OFFSET( HEAP, TagEntries ),                   "TagEntries",
    FIELD_OFFSET( HEAP, UCRSegments ),                  "UCRSegments",
    FIELD_OFFSET( HEAP, UnusedUnCommittedRanges ),      "UnusedUnCommittedRanges",
    FIELD_OFFSET( HEAP, AlignRound ),                   "AlignRound",
    FIELD_OFFSET( HEAP, AlignMask ),                    "AlignMask",
    FIELD_OFFSET( HEAP, VirtualAllocdBlocks ),          "VirtualAllocdBlocks",
    FIELD_OFFSET( HEAP, Segments ),                     "Segments",
    FIELD_OFFSET( HEAP, u ),                            "FreeListsInUse",
    FIELD_OFFSET( HEAP, FreeListsInUseTerminate ),      "FreeListsInUseTerminate",
    FIELD_OFFSET( HEAP, AllocatorBackTraceIndex ),      "AllocatorBackTraceIndex",
    FIELD_OFFSET( HEAP, Reserved1 ),                    "Reserved1",
    FIELD_OFFSET( HEAP, PseudoTagEntries ),             "PseudoTagEntries",
    FIELD_OFFSET( HEAP, FreeLists ),                    "FreeLists",
    FIELD_OFFSET( HEAP, LockVariable ),                 "LockVariable",
    sizeof( HEAP ),                                     "Uncommitted Ranges",
    0xFFFF, NULL
};

BOOL
ValidateHeapHeader(
    IN PVOID HeapAddress,
    IN PHEAP Heap
    )
{
    PVOID CurrentHeaderValidate;
    PVOID PreviousHeaderValidate;
    ULONG i, n, nEqual;
    BOOL b;

    if (Heap->Signature != HEAP_SIGNATURE) {
        dprintf( "Heap at %p contains invalid signature.\n" );
        return FALSE;
        }

    n = Heap->HeaderValidateLength;
    if (n == 0 || Heap->HeaderValidateCopy == NULL) {
        return TRUE;
        }

    b = FALSE;
    CurrentHeaderValidate = malloc( n );
    if (CurrentHeaderValidate != NULL) {
        PreviousHeaderValidate = malloc( n );
        if (PreviousHeaderValidate != NULL) {
            b = ReadMemory( (ULONG_PTR)HeapAddress,
                            CurrentHeaderValidate,
                            n,
                            NULL
                          );
            if (b) {
                b = ReadMemory( (ULONG_PTR)(Heap->HeaderValidateCopy),
                                PreviousHeaderValidate,
                                n,
                                NULL
                              );
                if (b) {
                    nEqual = (ULONG)RtlCompareMemory( CurrentHeaderValidate,
                                               PreviousHeaderValidate,
                                               n
                                             );
                    if (nEqual != n) {
                        dprintf( "HEAPEXT: Heap %p - headers modified (%p is %x instead of %x)\n",
                                 HeapAddress,
                                 (PCHAR)HeapAddress + nEqual,
                                 *(PULONG)((PCHAR)CurrentHeaderValidate  + nEqual),
                                 *(PULONG)((PCHAR)PreviousHeaderValidate + nEqual)
                               );
                        for (i=0; FieldOffsets[ i ].Description != NULL; i++) {
                            if (nEqual >= FieldOffsets[ i ].Offset &&
                                nEqual < FieldOffsets[ i+1 ].Offset
                               ) {
                                dprintf( "    This is located in the %s field of the heap header.\n",
                                         FieldOffsets[ i ].Description
                                       );
                                }
                            }

                        b = FALSE;
                        }
                    }
                else {
                    dprintf( "HEAPEXT: Unable to read copy of heap headers.\n" );
                    }
                }
            else {
                dprintf( "HEAPEXT: Unable to read heap headers.\n" );
                }
            }
        else {
            dprintf( "HEAPEXT: Unable to allocate memory for heap header copy.\n" );
            }
        }
    else {
        dprintf( "HEAPEXT: Unable to allocate memory for heap header.\n" );
        }

    return b;
}

UCHAR CheckHeapFillPattern[ CHECK_HEAP_TAIL_SIZE ] = {
    CHECK_HEAP_TAIL_FILL,
    CHECK_HEAP_TAIL_FILL,
    CHECK_HEAP_TAIL_FILL,
    CHECK_HEAP_TAIL_FILL,
    CHECK_HEAP_TAIL_FILL,
    CHECK_HEAP_TAIL_FILL,
    CHECK_HEAP_TAIL_FILL,
    CHECK_HEAP_TAIL_FILL
};

BOOL
ValidateHeapEntry(
    IN PHEAP_STATE State,
    IN PHEAP_ENTRY PrevEntryAddress,
    IN PHEAP_ENTRY PrevEntry,
    IN PHEAP_ENTRY EntryAddress,
    IN PHEAP_ENTRY Entry
    )
{
    UCHAR EntryTail[ CHECK_HEAP_TAIL_SIZE ];
    ULONG FreeFill[ 256 ];
    PVOID FreeAddress;
    ULONG Size, cb, cbEqual;
    BOOL b;

    if (PrevEntryAddress == NULL && Entry->PreviousSize != 0) {
        dprintf( "    PreviousSize field is non-zero when it should be zero to mark first entry\n" );
        return FALSE;
        }

    if (PrevEntryAddress != NULL && Entry->PreviousSize != PrevEntry->Size) {
        dprintf( "    PreviousSize field does not match size in previous entry\n" );
        return FALSE;
        }

    if (Entry->Flags & HEAP_ENTRY_BUSY) {
        if (Entry->Flags & HEAP_ENTRY_FILL_PATTERN) {
            Size = (Entry->Size << HEAP_GRANULARITY_SHIFT) - Entry->UnusedBytes;
            b = ReadMemory( (ULONG_PTR)((PCHAR)(EntryAddress+1) + Size),
                            EntryTail,
                            sizeof( EntryTail ),
                            NULL
                          );
            if (b) {
                cbEqual = (ULONG)RtlCompareMemory( EntryTail,
                                            CheckHeapFillPattern,
                                            CHECK_HEAP_TAIL_SIZE
                                          );
                if (cbEqual != CHECK_HEAP_TAIL_SIZE) {
                    dprintf( "    Heap block at %p modified at %x past requested size of %x (%x * 8 - %x)\n",
                             EntryAddress,
                             (PCHAR)(EntryAddress + 1) + Size + cbEqual,
                             Size, Entry->Size, Entry->UnusedBytes
                           );
                    return FALSE;
                    }
                }
            else {
                dprintf( "    Unable to read tail of heap block at %p\n", EntryAddress );
                return FALSE;
                }
            }
        }
    else {
        if (Entry->Flags & HEAP_ENTRY_FILL_PATTERN) {
            Size = (Entry->Size - 2) << HEAP_GRANULARITY_SHIFT;
            if (Entry->Flags & HEAP_ENTRY_EXTRA_PRESENT &&
                Size > sizeof( HEAP_FREE_ENTRY_EXTRA )
               ) {
                Size -= sizeof( HEAP_FREE_ENTRY_EXTRA );
                }
            FreeAddress = (PHEAP_FREE_ENTRY)EntryAddress + 1;
            while (Size != 0) {
                if (Size > sizeof( FreeFill )) {
                    cb = sizeof( FreeFill );
                    }
                else {
                    cb = Size;
                    }
                b = ReadMemory( (ULONG_PTR)FreeAddress,
                                FreeFill,
                                cb,
                                NULL
                              );
                if (b) {
                    cbEqual = (ULONG)RtlCompareMemoryUlong( FreeFill, cb, FREE_HEAP_FILL );
                    if (cbEqual != cb) {                                                            \
                        dprintf( "    Free Heap block %p modified at %p after it was freed\n",
                                 EntryAddress,
                                 (PCHAR)FreeAddress + cbEqual
                               );

                        return FALSE;
                        }
                    }
                else {
                    dprintf( "    Unable to portion of free heap block at %p\n", EntryAddress );
                    return FALSE;
                    }

                Size -= cb;
                }
            }
        }

    return TRUE;
}


VOID
DumpHeapEntry(
    IN PHEAP_STATE State,
    IN PHEAP_ENTRY EntryAddress,
    IN PHEAP_ENTRY Entry
    )
{
    BOOL b;
    HEAP_ENTRY_EXTRA EntryExtra;
    HEAP_TAG_ENTRY TagEntry;
    HEAP_FREE_ENTRY_EXTRA FreeExtra;
    PVOID p;
    USHORT BackTraceIndex;

    dprintf( "        %p: %05x . %05x [%02x]",
             EntryAddress,
             Entry->PreviousSize << HEAP_GRANULARITY_SHIFT,
             Entry->Size << HEAP_GRANULARITY_SHIFT,
             Entry->Flags
           );
    BackTraceIndex = 0;
    if (Entry->Flags & HEAP_ENTRY_BUSY) {
        dprintf( " - busy (%x)",
                 (Entry->Size << HEAP_GRANULARITY_SHIFT) - Entry->UnusedBytes
               );
        if (Entry->Flags & HEAP_ENTRY_FILL_PATTERN) {
            dprintf( ", tail fill" );
            }
        if (Entry->Flags & HEAP_ENTRY_EXTRA_PRESENT) {
            p = (EntryAddress + Entry->Size - 1);
            b = ReadMemory( (ULONG_PTR)p, &EntryExtra, sizeof( EntryExtra ), NULL );
            if (!b) {
                dprintf( " - unable to read heap entry extra at %p", p );
                }
            else {
                BackTraceIndex = EntryExtra.AllocatorBackTraceIndex;
                if (EntryExtra.Settable) {
                    dprintf( " (Handle %08x)", EntryExtra.Settable );
                    }
                if (EntryExtra.TagIndex) {
                    if (GetHeapTagEntry( &State->Heap, EntryExtra.TagIndex, &TagEntry )) {
                        dprintf( " (%ws)", TagEntry.TagName );
                        }
                    else {
                        dprintf( " (Tag %x)", EntryExtra.TagIndex );
                        }
                    }
                }
            }
        else
        if (Entry->SmallTagIndex) {
            if (GetHeapTagEntry( &State->Heap, Entry->SmallTagIndex, &TagEntry )) {
                dprintf( " (%ws)", TagEntry.TagName );
                }
            else {
                dprintf( " (Tag %x)", Entry->SmallTagIndex );
                }
            }

        if (Entry->Flags & HEAP_ENTRY_SETTABLE_FLAGS) {
            dprintf( ", user flags (%x)", (Entry->Flags & HEAP_ENTRY_SETTABLE_FLAGS) >> 5 );
            }

        dprintf( "\n" );
        }
    else {
        if (Entry->Flags & HEAP_ENTRY_FILL_PATTERN) {
            dprintf( " free fill" );
            }

        if (Entry->Flags & HEAP_ENTRY_EXTRA_PRESENT) {
            p = ((PHEAP_FREE_ENTRY_EXTRA)(EntryAddress + Entry->Size)) - 1;
            b = ReadMemory( (ULONG_PTR)p, &FreeExtra, sizeof( FreeExtra ), NULL );
            if (!b) {
                dprintf( " - unable to read heap free extra at %p", p );
                }
            else {
                BackTraceIndex = FreeExtra.FreeBackTraceIndex;
                if (GetHeapTagEntry( &State->Heap, FreeExtra.TagIndex, &TagEntry )) {
                    dprintf( " (%ws)", TagEntry.TagName );
                    }
                else {
                    dprintf( " (Tag %x at %p)", FreeExtra.TagIndex, p );
                    }
                }
            }

        dprintf( "\n" );
        }

#if STACK_TRACE_DATABASE_SUPPORT
    DumpStackBackTraceIndex( State, BackTraceIndex );
#endif // STACK_TRACE_DATABASE_SUPPORT
    return;
}


#if STACK_TRACE_DATABASE_SUPPORT
VOID
DumpStackBackTraceIndex(
    IN PHEAP_STATE State,
    IN USHORT BackTraceIndex
    )
{
    BOOL b;
    PRTL_STACK_TRACE_ENTRY pBackTraceEntry;
    RTL_STACK_TRACE_ENTRY BackTraceEntry;
    ULONG i;
    CHAR Symbol[ 1024 ];
    ULONG_PTR Displacement;

    ULONG NumberOfEntriesAdded;
    PRTL_STACK_TRACE_ENTRY *EntryIndexArray;    // Indexed by [-1 .. -NumberOfEntriesAdded]

    if (State->DumpStackBackTrace &&
        BackTraceIndex != 0 &&
        pRtlpStackTraceDataBase != NULL
       ) {
        if (!HaveCopyOfStackTraceDataBase) {
            b = ReadMemory( (ULONG_PTR)pRtlpStackTraceDataBase,
                            &RtlpStackTraceDataBase,
                            sizeof( RtlpStackTraceDataBase ),
                            NULL
                          );
            if (!b || RtlpStackTraceDataBase == NULL) {
                State->DumpStackBackTrace = FALSE;
                return;
                }

            b = ReadMemory( (ULONG_PTR)RtlpStackTraceDataBase,
                            &StackTraceDataBase,
                            sizeof( StackTraceDataBase ),
                            NULL
                          );
            if (!b) {
                State->DumpStackBackTrace = FALSE;
                return;
                }

            HaveCopyOfStackTraceDataBase = TRUE;
            }

        if (BackTraceIndex < StackTraceDataBase.NumberOfEntriesAdded) {
            b = ReadMemory( (ULONG_PTR)(StackTraceDataBase.EntryIndexArray - BackTraceIndex),
                            &pBackTraceEntry,
                            sizeof( pBackTraceEntry ),
                            NULL
                          );
            if (!b) {
                dprintf( "    unable to read stack back trace index (%x) entry at %p\n",
                         BackTraceIndex,
                         (StackTraceDataBase.EntryIndexArray - BackTraceIndex)
                       );
                return;
                }

            b = ReadMemory( (ULONG_PTR)pBackTraceEntry,
                            &BackTraceEntry,
                            sizeof( BackTraceEntry ),
                            NULL
                          );
            if (!b) {
                dprintf( "    unable to read stack back trace entry at %p\n",
                         BackTraceIndex,
                         pBackTraceEntry
                       );
                return;
                }

            dprintf( "            Stack trace (%u) at %x:\n", BackTraceIndex, pBackTraceEntry );
            for (i=0; i<BackTraceEntry.Depth; i++) {
                GetSymbol( (LPVOID)BackTraceEntry.BackTrace[ i ],
                           Symbol,
                           &Displacement
                         );
                dprintf( "                %08x: %s", BackTraceEntry.BackTrace[ i ], Symbol );
                if (Displacement != 0) {
                    dprintf( "+0x%p", Displacement );
                    }
                dprintf( "\n" );
                }
            }
        }
}
#endif // STACK_TRACE_DATABASE_SUPPORT

#if 0
int
__cdecl
_wtoi(
    const wchar_t *nptr
    )
{
    NTSTATUS Status;
    ULONG Value;
    UNICODE_STRING UnicodeString;

    RtlInitUnicodeString( &UnicodeString, nptr );
    Status = RtlUnicodeStringToInteger( &UnicodeString, 10, &Value );
    if (NT_SUCCESS( Status )) {
        return (int)Value;
        }
    else {
        return 0;
        }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\ntsdexts\heappagx.c ===
#define DEBUG_PAGE_HEAP 1

#include "..\..\ntos\rtl\heappagi.h"

__inline
BOOLEAN
CheckInterrupted(
    VOID
    )
    {
    if ( CheckControlC() ) {
        dprintf( "\nInterrupted\n\n" );
        return TRUE;
        }
    return FALSE;
    }


__inline
PVOID
FetchRemotePVOID(
    PVOID Address
    )
    {
    PVOID RemoteValue = NULL;
    ReadMemory( Address, &RemoteValue, sizeof( PVOID ), NULL );
    return RemoteValue;
    }

__inline
ULONG
FetchRemoteULONG(
    PVOID Address
    )
    {
    ULONG RemoteValue = 0;
    ReadMemory( Address, &RemoteValue, sizeof( ULONG ), NULL );
    return RemoteValue;
    }


__inline
BOOL
WriteRemotePVOID(
    PVOID Address,
    PVOID Value
    )
    {
    return WriteMemory( Address, &Value, sizeof( PVOID ), NULL );
    }

__inline
BOOL
WriteRemoteULONG(
    PVOID Address,
    ULONG Value
    )
    {
    return WriteMemory( Address, &Value, sizeof( ULONG ), NULL );
    }



#define FETCH_REMOTE_FIELD_PTR( StructBase, StructType, FieldName ) \
            FetchRemotePVOID((PCHAR)(StructBase) + FIELD_OFFSET( StructType, FieldName ))

#define FETCH_REMOTE_FIELD_INT( StructBase, StructType, FieldName ) \
            FetchRemoteULONG((PCHAR)(StructBase) + FIELD_OFFSET( StructType, FieldName ))

#define WRITE_REMOTE_FIELD_PTR( StructBase, StructType, FieldName, Value ) \
            WriteRemotePVOID((PCHAR)(StructBase) + FIELD_OFFSET( StructType, FieldName ), (Value));

#define WRITE_REMOTE_FIELD_INT( StructBase, StructType, FieldName, Value ) \
            WriteRemoteULONG((PCHAR)(StructBase) + FIELD_OFFSET( StructType, FieldName ), (Value));

#define DUMP_REMOTE_FIELD_INT( DumpName, StructBase, StructType, FieldName ) \
            dprintf( "%s%08X\n", (DumpName), FETCH_REMOTE_FIELD_INT( StructBase, StructType, FieldName ))

#define DUMP_REMOTE_FIELD_PTR( DumpName, StructBase, StructType, FieldName ) \
            dprintf( "%s%p\n", (DumpName), FETCH_REMOTE_FIELD_PTR( StructBase, StructType, FieldName ))

VOID
DebugPageHeapLocateFaultAllocation(
    PVOID RemoteHeap,
    PVOID AddressOfFault
    );

VOID
DebugPageHeapReportAllocation(
    PVOID RemoteHeap,
    PVOID RemoteHeapNode,
    PCHAR NodeType,
    PVOID AddressOfFault
    );

BOOLEAN
DebugPageHeapExtensionShowHeapList(
    VOID
    );

#ifdef DPH_CAPTURE_STACK_TRACE

VOID
DebugPageHeapReportStackTrace(
    ULONG StackTraceLength,
    PVOID StackTraceBuffer[]
    );

ULONG
DebugPageHeapFetchRemoteStackTrace(
    PVOID RemoteStackNode,
    PVOID StackBuffer[]
    );

#endif // DPH_CAPTURE_STACK_TRACE


VOID
DebugPageHeapExtensionFind(
    PCSTR ArgumentString
    )
    {
    PVOID RemoteHeapList;
    PVOID RemoteHeap;
    PVOID RemoteVirtualNode;
    PVOID RemoteVirtualBase;
    ULONG RemoteVirtualSize;
    PVOID AddressOfFault;

    AddressOfFault = (PVOID) strtoul( ArgumentString, NULL, 16 );
    RemoteHeapList = (PVOID) GetExpression( "NTDLL!RtlpDebugPageHeapListHead" );
    RemoteHeap     = FetchRemotePVOID( RemoteHeapList );

    if ( RemoteHeap == NULL ) {
        dprintf( "\nNo debug page heaps active in process (or bad symbols)\n\n" );
        AddressOfFault = NULL;
        }

    if (( AddressOfFault == NULL ) || ( strchr( ArgumentString, '?' ))) {
        dprintf( "\nUsage: !dphfind <address>\n\n"
                 "       where <address> is typically the address of\n"
                 "       a fault attemping to reference heap memory\n"
                 "       from a debug page heap allocation\n\n"
               );
        return;
        }

    //
    //  Find the heap that contains the range of virtual addresses that
    //  contain the AddressOfFault.
    //

    for (;;) {

        //
        //  The heap header contains a linked list of virtual memory
        //  allocations.
        //

        RemoteVirtualNode = FETCH_REMOTE_FIELD_PTR( RemoteHeap, DPH_HEAP_ROOT, pVirtualStorageListHead );

        while ( RemoteVirtualNode != NULL ) {

            RemoteVirtualBase = FETCH_REMOTE_FIELD_PTR( RemoteVirtualNode, DPH_HEAP_ALLOCATION, pVirtualBlock );
            RemoteVirtualSize = FETCH_REMOTE_FIELD_INT( RemoteVirtualNode, DPH_HEAP_ALLOCATION, nVirtualBlockSize );

            if (( RemoteVirtualBase == NULL ) || ( RemoteVirtualSize == 0 )) {
                dprintf( "\nPAGEHEAP: Heap 0x%p appears to have an invalid\n"
                         "          virtual allocation list\n\n",
                         RemoteHeap
                       );
                }

            if (((PCHAR) AddressOfFault >= ((PCHAR) RemoteVirtualBase )) &&
                ((PCHAR) AddressOfFault <= ((PCHAR) RemoteVirtualBase + RemoteVirtualSize ))) {

                //
                //  The fault appears to have occurred in the range of this
                //  heap, so we'll search the busy and free lists for the
                //  closest match and report it.  Then exit.
                //

                DebugPageHeapLocateFaultAllocation( RemoteHeap, AddressOfFault );
                return;
                }

            if ( CheckInterrupted() ) {
                return;
                }

            RemoteVirtualNode = FETCH_REMOTE_FIELD_PTR( RemoteVirtualNode, DPH_HEAP_ALLOCATION, pNextAlloc );

            }


        //
        //  Not found in this heap.  Continue with next heap or end
        //  of heap list.
        //

        if ( CheckInterrupted() ) {
            return;
            }

        RemoteHeap = FETCH_REMOTE_FIELD_PTR( RemoteHeap, DPH_HEAP_ROOT, pNextHeapRoot );

        if ( RemoteHeap == NULL ) {
            dprintf( "\nPAGEHEAP: Could not find a debug heap containing\n"
                     "          the virtual address 0x%p\n\n",
                     AddressOfFault
                   );
            return;
            }
        }
    }


VOID
DebugPageHeapLocateFaultAllocation(
    PVOID RemoteHeap,
    PVOID AddressOfFault
    )
    {
    PVOID ClosestHeapNode;
    PVOID ClosestDifference;
    PVOID RemoteHeapNode;
    PVOID RemoteAllocBase;
    ULONG RemoteAllocSize;
    ULONG RemoteFreeListSize;

    ClosestHeapNode = NULL;

    //
    //  First search the busy list for the containing allocation, if any.
    //

    RemoteHeapNode = FETCH_REMOTE_FIELD_PTR( RemoteHeap, DPH_HEAP_ROOT, pBusyAllocationListHead );

    while ( RemoteHeapNode != NULL ) {

        RemoteAllocBase = FETCH_REMOTE_FIELD_PTR( RemoteHeapNode, DPH_HEAP_ALLOCATION, pVirtualBlock );
        RemoteAllocSize = FETCH_REMOTE_FIELD_INT( RemoteHeapNode, DPH_HEAP_ALLOCATION, nVirtualBlockSize );

        if (((PCHAR) AddressOfFault >= ((PCHAR) RemoteAllocBase )) &&
            ((PCHAR) AddressOfFault <  ((PCHAR) RemoteAllocBase + RemoteAllocSize ))) {

            //
            //  The fault appears to have occurred in this allocation's
            //  memory (which includes the NO_ACCESS page beyond the user
            //  portion of the allocation).
            //

            DebugPageHeapReportAllocation( RemoteHeap, RemoteHeapNode, "allocated", AddressOfFault );
            return;
            }

        if ( CheckInterrupted() ) {
            return;
            }

        RemoteHeapNode = FETCH_REMOTE_FIELD_PTR( RemoteHeapNode, DPH_HEAP_ALLOCATION, pNextAlloc );
        }

    //
    //  Failed to find containing allocation on busy list, so search free.
    //

    RemoteHeapNode = FETCH_REMOTE_FIELD_PTR( RemoteHeap, DPH_HEAP_ROOT, pFreeAllocationListHead );

    while ( RemoteHeapNode != NULL ) {

        RemoteAllocBase = FETCH_REMOTE_FIELD_PTR( RemoteHeapNode, DPH_HEAP_ALLOCATION, pVirtualBlock );
        RemoteAllocSize = FETCH_REMOTE_FIELD_INT( RemoteHeapNode, DPH_HEAP_ALLOCATION, nVirtualBlockSize );

        if (((PCHAR) AddressOfFault >= ((PCHAR) RemoteAllocBase )) &&
            ((PCHAR) AddressOfFault <  ((PCHAR) RemoteAllocBase + RemoteAllocSize ))) {

            //
            //  The fault appears to have occurred in this freed alloc's
            //  memory.
            //

            DebugPageHeapReportAllocation( RemoteHeap, RemoteHeapNode, "freed", AddressOfFault );
            return;
            }

        if ( CheckInterrupted() ) {
            return;
            }

        RemoteHeapNode = FETCH_REMOTE_FIELD_PTR( RemoteHeapNode, DPH_HEAP_ALLOCATION, pNextAlloc );
        }

    //
    //  Failed to find containing allocation in free list, but we wouldn't
    //  have gotten this far if the debug heap did not contain the virtual
    //  address range of the fault.  So, report it as a wild pointer that
    //  could have been freed memory.
    //

    RemoteFreeListSize = FETCH_REMOTE_FIELD_INT( RemoteHeap, DPH_HEAP_ROOT, nFreeAllocations );

    dprintf( "\nPAGEHEAP: %p references memory contained in the heap %p,\n"
               "          but does not reference an existing allocated or\n"
               "          recently freed heap block.  It is possible that\n"
               "          the memory at %p could previously have been\n"
               "          allocated and freed, but it must have been freed\n"
               "          prior to the most recent %d frees.\n\n",
             AddressOfFault,
             RemoteHeap,
             AddressOfFault,
             RemoteFreeListSize
           );

    }


VOID
DebugPageHeapReportAllocation(
    PVOID RemoteHeap,
    PVOID RemoteHeapNode,
    PCHAR NodeType,
    PVOID AddressOfFault
    )
    {
    PVOID RemoteUserBase;
    ULONG RemoteUserSize;
    PVOID EndOfBlock;
    SIZE_T PastTheBlock;
    SIZE_T BeforeTheBlock;

    RemoteUserBase = FETCH_REMOTE_FIELD_PTR( RemoteHeapNode, DPH_HEAP_ALLOCATION, pUserAllocation );
    RemoteUserSize = FETCH_REMOTE_FIELD_INT( RemoteHeapNode, DPH_HEAP_ALLOCATION, nUserRequestedSize );

    EndOfBlock = (PCHAR) RemoteUserBase + RemoteUserSize - 1;

    if ( AddressOfFault > EndOfBlock ) {

        PastTheBlock = (PCHAR) AddressOfFault - (PCHAR) EndOfBlock;

        dprintf( "\nPAGEHEAP: %p is 0x%x bytes beyond the end of %s heap block at\n"
                   "          %p of 0x%x bytes",
                 AddressOfFault,
                 PastTheBlock,
                 NodeType,
                 RemoteUserBase,
                 RemoteUserSize
               );

        }

    else if ( AddressOfFault >= RemoteUserBase ) {

        dprintf( "\nPAGEHEAP: %p references %s heap block at\n"
                   "          %p of 0x%x bytes",
                 AddressOfFault,
                 NodeType,
                 RemoteUserBase,
                 RemoteUserSize
               );

        }

    else {

        BeforeTheBlock = (PCHAR) RemoteUserBase - (PCHAR) AddressOfFault;

        dprintf( "\nPAGEHEAP: %p is 0x%x bytes before the %s heap block at\n"
                   "          %p of 0x%x bytes",
                 AddressOfFault,
                 BeforeTheBlock,
                 NodeType,
                 RemoteUserBase,
                 RemoteUserSize
               );

        }

#ifdef DPH_CAPTURE_STACK_TRACE

    {
    PVOID RemoteStackTraceBuffer[ DPH_MAX_STACK_LENGTH ];
    ULONG RemoteStackTraceLength;
    PVOID RemoteStackNode;

    RemoteStackNode = FETCH_REMOTE_FIELD_PTR( RemoteHeapNode, DPH_HEAP_ALLOCATION, pStackTrace );

    RemoteStackTraceLength = DebugPageHeapFetchRemoteStackTrace(
                                 RemoteStackNode,
                                 RemoteStackTraceBuffer
                                 );

    if ( RemoteStackTraceLength ) {

        dprintf( ", %s by:\n\n", NodeType );

        DebugPageHeapReportStackTrace(
            RemoteStackTraceLength,
            RemoteStackTraceBuffer
            );

        }

    else {
        dprintf( "(stack trace not available)\n\n" );
        }
    }

#else  // ! DPH_CAPTURE_STACK_TRACE

    dprintf( "\n\n" );

#endif // DPH_CAPTURE_STACK_TRACE

    }


#ifdef DPH_CAPTURE_STACK_TRACE

VOID
DebugPageHeapReportStackTrace(
    ULONG StackTraceLength,
    PVOID StackTraceBuffer[]
    )
    {
    CHAR  SymbolName[ 1024 ];
    ULONG_PTR Displacement;
    ULONG i;

    for ( i = 0; i < StackTraceLength; i++ ) {

        GetSymbol( StackTraceBuffer[ i ], SymbolName, &Displacement );
        GetSymbol( StackTraceBuffer[ i ], SymbolName, &Displacement );

        dprintf( "          %p %s+0x%p\n",
                 StackTraceBuffer[ i ],
                 SymbolName,
                 Displacement
               );

        }

    dprintf( "\n" );

    }


ULONG
DebugPageHeapFetchRemoteStackTrace(
    PVOID RemoteStackNode,
    PVOID StackBuffer[]
    )
    {
    ULONG RemoteStackLength;

    if ( RemoteStackNode == NULL )
        return 0;

    RemoteStackLength = FETCH_REMOTE_FIELD_INT( RemoteStackNode, DPH_STACK_TRACE_NODE, Length );

    if ( RemoteStackLength > 0 ) {

        ZeroMemory( StackBuffer, RemoteStackLength * sizeof( PVOID ));

        ReadMemory(
            (PCHAR) RemoteStackNode + FIELD_OFFSET( DPH_STACK_TRACE_NODE, Address ),
            StackBuffer,
            RemoteStackLength * sizeof( PVOID ),
            NULL
            );

        while (( RemoteStackLength > 0 ) && ( StackBuffer[ RemoteStackLength ] == NULL ))
            --RemoteStackLength;

        }

    return RemoteStackLength;
    }

#endif // DPH_CAPTURE_STACK_TRACE


#define FORMAT_TYPE_BUSY_LIST 0
#define FORMAT_TYPE_FREE_LIST 1
#define FORMAT_TYPE_VIRT_LIST 2

BOOLEAN
DebugPageHeapDumpThisList(
    PVOID RemoteList,
    PCH   ListName,
    ULONG FormatType
    )
    {
    PVOID RemoteNode = RemoteList;
    PVOID RemoteBase;
    ULONG RemoteSize;
    PVOID RemoteUser;
    ULONG RemoteUsiz;
    ULONG RemoteFlag;
    PVOID RemoteValu;

    dprintf( "\n%s:\n", ListName );

    switch ( FormatType ) {
        case FORMAT_TYPE_BUSY_LIST:
            dprintf( "UserAddr  UserSize  VirtAddr  VirtSize  UserFlag  UserValu\n" );
            break;
        case FORMAT_TYPE_FREE_LIST:
            dprintf( "UserAddr  UserSize  VirtAddr  VirtSize\n" );
            break;
        }

    while ( RemoteNode ) {

        RemoteBase = FETCH_REMOTE_FIELD_PTR( RemoteNode, DPH_HEAP_ALLOCATION, pVirtualBlock );
        RemoteSize = FETCH_REMOTE_FIELD_INT( RemoteNode, DPH_HEAP_ALLOCATION, nVirtualBlockSize );
        RemoteUser = FETCH_REMOTE_FIELD_PTR( RemoteNode, DPH_HEAP_ALLOCATION, pUserAllocation );
        RemoteUsiz = FETCH_REMOTE_FIELD_INT( RemoteNode, DPH_HEAP_ALLOCATION, nUserRequestedSize );
        RemoteFlag = FETCH_REMOTE_FIELD_INT( RemoteNode, DPH_HEAP_ALLOCATION, UserFlags );
        RemoteValu = FETCH_REMOTE_FIELD_PTR( RemoteNode, DPH_HEAP_ALLOCATION, UserValue );
        RemoteNode = FETCH_REMOTE_FIELD_PTR( RemoteNode, DPH_HEAP_ALLOCATION, pNextAlloc );

        switch ( FormatType ) {

            case FORMAT_TYPE_BUSY_LIST:

                dprintf(( RemoteFlag || RemoteValu ) ?
                         "%08X  %08X  %08X  %08X  %08X  %08X\n" :
                         "%08X  %08X  %08X  %08X\n",
                         RemoteUser,
                         RemoteUsiz,
                         RemoteBase,
                         RemoteSize,
                         RemoteFlag,
                         RemoteValu
                       );
                break;

            case FORMAT_TYPE_FREE_LIST:

                dprintf( "%p  %08X  %p  %08X\n",
                         RemoteUser,
                         RemoteUsiz,
                         RemoteBase,
                         RemoteSize
                       );
                break;

            case FORMAT_TYPE_VIRT_LIST:

                dprintf( "%p - %p (%08X)\n",
                         RemoteBase,
                         (PCH)RemoteBase + RemoteSize,
                         RemoteSize
                       );
                break;

            }

        if ( CheckInterrupted() ) {
            return FALSE;
            }
        }

    return TRUE;
    }


BOOLEAN
DebugPageHeapDumpThisHeap(
    PVOID RemoteHeap
    )
    {
    PVOID RemoteNode;

    dprintf( "\nDPH Heap at %p:\n\n", RemoteHeap );

    DUMP_REMOTE_FIELD_INT( "Signature:     ", RemoteHeap, DPH_HEAP_ROOT, Signature );
    DUMP_REMOTE_FIELD_INT( "HeapFlags:     ", RemoteHeap, DPH_HEAP_ROOT, HeapFlags );
    DUMP_REMOTE_FIELD_INT( "VirtualRanges: ", RemoteHeap, DPH_HEAP_ROOT, nVirtualStorageRanges );
    DUMP_REMOTE_FIELD_PTR( "VirtualCommit: ", RemoteHeap, DPH_HEAP_ROOT, nVirtualStorageBytes );
    DUMP_REMOTE_FIELD_INT( "BusyAllocs:    ", RemoteHeap, DPH_HEAP_ROOT, nBusyAllocations );
    DUMP_REMOTE_FIELD_PTR( "BusyVirtual:   ", RemoteHeap, DPH_HEAP_ROOT, nBusyAllocationBytesCommitted );
    DUMP_REMOTE_FIELD_PTR( "BusyReadWrite: ", RemoteHeap, DPH_HEAP_ROOT, nBusyAllocationBytesAccessible );
    DUMP_REMOTE_FIELD_INT( "FreeAllocs:    ", RemoteHeap, DPH_HEAP_ROOT, nFreeAllocations );
    DUMP_REMOTE_FIELD_PTR( "FreeVirtual:   ", RemoteHeap, DPH_HEAP_ROOT, nFreeAllocationBytesCommitted );
    DUMP_REMOTE_FIELD_INT( "AvailAllocs:   ", RemoteHeap, DPH_HEAP_ROOT, nAvailableAllocations );
    DUMP_REMOTE_FIELD_PTR( "AvailVirtual:  ", RemoteHeap, DPH_HEAP_ROOT, nAvailableAllocationBytesCommitted );
    DUMP_REMOTE_FIELD_INT( "NodePools:     ", RemoteHeap, DPH_HEAP_ROOT, nNodePools );
    DUMP_REMOTE_FIELD_PTR( "NodeVirtual:   ", RemoteHeap, DPH_HEAP_ROOT, nNodePoolBytes );
    DUMP_REMOTE_FIELD_INT( "AvailNodes:    ", RemoteHeap, DPH_HEAP_ROOT, nUnusedNodes );
    DUMP_REMOTE_FIELD_INT( "ExtraFlags:    ", RemoteHeap, DPH_HEAP_ROOT, ExtraFlags );
    DUMP_REMOTE_FIELD_INT( "NormalHeap:    ", RemoteHeap, DPH_HEAP_ROOT, NormalHeap );
    DUMP_REMOTE_FIELD_INT( "Seed:          ", RemoteHeap, DPH_HEAP_ROOT, Seed );
    DUMP_REMOTE_FIELD_INT( "Counter[0]:    ", RemoteHeap, DPH_HEAP_ROOT, Counter[0] );
    DUMP_REMOTE_FIELD_INT( "Counter[1]:    ", RemoteHeap, DPH_HEAP_ROOT, Counter[1] );
    DUMP_REMOTE_FIELD_INT( "Counter[2]:    ", RemoteHeap, DPH_HEAP_ROOT, Counter[2] );
    DUMP_REMOTE_FIELD_INT( "Counter[3]:    ", RemoteHeap, DPH_HEAP_ROOT, Counter[3] );
    DUMP_REMOTE_FIELD_INT( "Counter[4]:    ", RemoteHeap, DPH_HEAP_ROOT, Counter[4] );

#ifdef DPH_CAPTURE_STACK_TRACE

    {
    PVOID RemoteStackTraceBuffer[ DPH_MAX_STACK_LENGTH ];
    ULONG RemoteStackTraceLength;
    PVOID RemoteStackNode;

    DUMP_REMOTE_FIELD_INT( "StackTraces:   ", RemoteHeap, DPH_HEAP_ROOT, nStackTraceBNodes );
    DUMP_REMOTE_FIELD_INT( "StackBytes:    ", RemoteHeap, DPH_HEAP_ROOT, nStackTraceBytesCommitted );
    DUMP_REMOTE_FIELD_INT( "StackAvail:    ", RemoteHeap, DPH_HEAP_ROOT, nStackTraceStorage );
    DUMP_REMOTE_FIELD_INT( "StackWasted:   ", RemoteHeap, DPH_HEAP_ROOT, nStackTraceBytesWasted );
    DUMP_REMOTE_FIELD_INT( "StackBDepth:   ", RemoteHeap, DPH_HEAP_ROOT, nStackTraceBDepth );
    DUMP_REMOTE_FIELD_INT( "StackBCollide: ", RemoteHeap, DPH_HEAP_ROOT, nStackTraceBHashCollisions );

    RemoteStackNode = FETCH_REMOTE_FIELD_PTR( RemoteHeap, DPH_HEAP_ROOT, pStackTraceCreator );

    RemoteStackTraceLength = DebugPageHeapFetchRemoteStackTrace(
                                 RemoteStackNode,
                                 RemoteStackTraceBuffer
                                 );

    if ( RemoteStackTraceLength ) {

        dprintf( "\nHeap created by:\n\n" );

        DebugPageHeapReportStackTrace(
            RemoteStackTraceLength,
            RemoteStackTraceBuffer
            );

        }
    }

#endif // DPH_CAPTURE_STACK_TRACE

    if ( ! DebugPageHeapDumpThisList(
                FETCH_REMOTE_FIELD_PTR( RemoteHeap, DPH_HEAP_ROOT, pVirtualStorageListHead ),
                "VirtualList",
                FORMAT_TYPE_VIRT_LIST )) {
        return FALSE;
        }

    if ( ! DebugPageHeapDumpThisList(
                FETCH_REMOTE_FIELD_PTR( RemoteHeap, DPH_HEAP_ROOT, pNodePoolListHead ),
                "NodePoolList",
                FORMAT_TYPE_VIRT_LIST )) {
        return FALSE;
        }

    if ( ! DebugPageHeapDumpThisList(
                FETCH_REMOTE_FIELD_PTR( RemoteHeap, DPH_HEAP_ROOT, pAvailableAllocationListHead ),
                "AvailableList",
                FORMAT_TYPE_VIRT_LIST )) {
        return FALSE;
        }

    if ( ! DebugPageHeapDumpThisList(
                FETCH_REMOTE_FIELD_PTR( RemoteHeap, DPH_HEAP_ROOT, pFreeAllocationListHead ),
                "FreeList",
                FORMAT_TYPE_FREE_LIST )) {
        return FALSE;
        }

    if ( ! DebugPageHeapDumpThisList(
                FETCH_REMOTE_FIELD_PTR( RemoteHeap, DPH_HEAP_ROOT, pBusyAllocationListHead ),
                "BusyList",
                FORMAT_TYPE_BUSY_LIST )) {
        return FALSE;
        }

    dprintf( "\n" );
    return TRUE;
    }



VOID
DebugPageHeapExtensionDump(
    PCSTR ArgumentString
    )
    {
    PVOID   RemoteHeapList;
    PVOID   RemoteHeap;
    PVOID   RemoteHeapToDump;
    BOOLEAN AnyDumps = FALSE;

    RemoteHeapToDump = (PVOID) strtoul( ArgumentString, NULL, 16 );
    RemoteHeapList   = (PVOID) GetExpression( "NTDLL!RtlpDebugPageHeapListHead" );
    RemoteHeap       = FetchRemotePVOID( RemoteHeapList );

    if (( RemoteHeap       == NULL ) ||
        ( RemoteHeapToDump == NULL ) ||
        ( strchr( ArgumentString, '?' ))) {

        dprintf( "\nUsage: !dphdump <address>\n\n"
                 "       where <address> is the heap base address or heap handle\n\n"
               );

        DebugPageHeapExtensionShowHeapList();
        return;
        }

    while ( RemoteHeap != NULL ) {

        if ((((LONG_PTR)RemoteHeapToDump & 0xFFFF0000 ) == ((LONG_PTR)RemoteHeap & 0xFFFF0000 )) ||
            ((LONG_PTR)RemoteHeapToDump == -1 )) {

            AnyDumps = TRUE;

            if ( ! DebugPageHeapDumpThisHeap( RemoteHeap ))
                return;

            }

        if ( CheckInterrupted() ) {
            return;
            }

        RemoteHeap = FETCH_REMOTE_FIELD_PTR( RemoteHeap, DPH_HEAP_ROOT, pNextHeapRoot );
        }

    if ( ! AnyDumps ) {
        dprintf( "\nDebug page heap \"0x%p\" not found in process\n\n", RemoteHeapToDump );
        DebugPageHeapExtensionShowHeapList();
        }

    }



BOOLEAN
DebugPageHeapExtensionShowHeapList(
    VOID
    )
    {
    PVOID RemoteHeapList = (PVOID)GetExpression( "NTDLL!RtlpDebugPageHeapListHead" );
    PVOID RemoteHeap     = FetchRemotePVOID( RemoteHeapList );

    if ( RemoteHeap == NULL ) {
        dprintf( "\nNo debug page heaps active in process (or bad symbols)\n" );
        return FALSE;
        }
    else {
        dprintf( "\nDebug page heaps active in process:\n\n" );
        do  {
            dprintf( "0x%p\n", RemoteHeap );
            RemoteHeap = FETCH_REMOTE_FIELD_PTR( RemoteHeap, DPH_HEAP_ROOT, pNextHeapRoot );
            }
        while ( RemoteHeap );
        dprintf( "\n" );
        return TRUE;
        }
    }


#ifdef DPH_CAPTURE_STACK_TRACE

typedef struct _LOCAL_STACK_NODE LOCAL_STACK_NODE, *PLOCAL_STACK_NODE;

struct _LOCAL_STACK_NODE {

    PLOCAL_STACK_NODE Left;
    PLOCAL_STACK_NODE Right;

    PVOID RemoteStackNode;
    ULONG RemoteBusyCount;
    ULONG RemoteBusyBytes;
    };


BOOLEAN DebugPageHeapSortByCount;


BOOLEAN
DebugPageHeapReportStackNode(
    PLOCAL_STACK_NODE LocalStackNode
    )
    {
    PVOID RemoteStackTraceBuffer[ DPH_MAX_STACK_LENGTH ];
    ULONG RemoteStackTraceLength;

    RemoteStackTraceLength = DebugPageHeapFetchRemoteStackTrace(
                                 LocalStackNode->RemoteStackNode,
                                 RemoteStackTraceBuffer
                                 );

    if ( RemoteStackTraceLength ) {

        ULONG Count = LocalStackNode->RemoteBusyCount;
        ULONG Bytes = LocalStackNode->RemoteBusyBytes;
        ULONG Average;

        if ( Count > 0 ) {

            Average = ( Bytes + ( Count / 2 )) / Count;

            if ( Count > 1 ) {

                dprintf(
                    "%7d bytes in %d allocations (avg %d bytes/alloc):\n\n",
                    Bytes,
                    Count,
                    Average
                    );

                }

            else {

                dprintf(
                    "%7d bytes in 1 allocation:\n\n",
                    Bytes,
                    Average
                    );

                }

            DebugPageHeapReportStackTrace(
                RemoteStackTraceLength,
                RemoteStackTraceBuffer
                );

            dprintf( "\n" );

            }
        }

    else {

        dprintf( "Error retrieving remote stack trace\n\n" );

        }

    return TRUE;
    }


BOOLEAN
DebugPageHeapReportStackTree(
    PLOCAL_STACK_NODE StackTree
    )
    {

    if ( CheckInterrupted() )
        return FALSE;

    if ( StackTree->Left )
        if ( ! DebugPageHeapReportStackTree( StackTree->Left ))
            return FALSE;

    if ( StackTree->RemoteStackNode )
        if ( ! DebugPageHeapReportStackNode( StackTree ))
            return FALSE;

    if ( StackTree->Right )
        if ( ! DebugPageHeapReportStackTree( StackTree->Right ))
            return FALSE;

    return TRUE;
    }


INT
DebugPageHeapCompareStackNodeToValues(
    PLOCAL_STACK_NODE Node,
    PVOID             RemoteStackNode,
    ULONG             RemoteBusyCount,
    ULONG             RemoteBusyBytes
    )
    {
    INT Difference;

    if ( DebugPageHeapSortByCount ) {

        Difference = ( Node->RemoteBusyCount - RemoteBusyCount );

        if ( Difference == 0 )
             Difference = ( Node->RemoteBusyBytes - RemoteBusyBytes );

        }

    else {

        Difference = ( Node->RemoteBusyBytes - RemoteBusyBytes );

        if ( Difference == 0 )
             Difference = ( Node->RemoteBusyCount - RemoteBusyCount );

        }

    if ( Difference == 0 )
         Difference = PtrToInt ((PVOID)((SIZE_T)Node->RemoteStackNode - (SIZE_T)RemoteStackNode ));

    return Difference;
    }


PLOCAL_STACK_NODE
DebugPageHeapFindOrInsertStackNodeInBtree(
    PLOCAL_STACK_NODE Node,
    PVOID             RemoteStackNode,
    ULONG             RemoteBusyCount,
    ULONG             RemoteBusyBytes
    )
    {
    PLOCAL_STACK_NODE NewNode;
    INT Difference;

    for (;;) {

        Difference = DebugPageHeapCompareStackNodeToValues(
                         Node,
                         RemoteStackNode,
                         RemoteBusyCount,
                         RemoteBusyBytes
                         );

        if ( Difference < 0 ) {         // go left
            if ( Node->Left )
                Node = Node->Left;
            else
                break;
            }
        else if ( Difference > 0 ) {    // go right
            if ( Node->Right )
                Node = Node->Right;
            else
                break;
            }
        else {                          // equal
            return Node;
            }
        }

    NewNode = HeapAlloc( GetProcessHeap(), 0, sizeof( LOCAL_STACK_NODE ));

    if ( NewNode != NULL ) {

        NewNode->Left            = NULL;
        NewNode->Right           = NULL;
        NewNode->RemoteStackNode = RemoteStackNode;
        NewNode->RemoteBusyCount = RemoteBusyCount;
        NewNode->RemoteBusyBytes = RemoteBusyBytes;

        if ( Difference < 0 )
            Node->Left  = NewNode;
        else
            Node->Right = NewNode;

        }

    return NewNode;
    }


VOID
DebugPageHeapFreeBtree(
    PLOCAL_STACK_NODE Tree
    )
    {
    if ( Tree->Left )
        DebugPageHeapFreeBtree( Tree->Left );

    if ( Tree->Right )
        DebugPageHeapFreeBtree( Tree->Right );

    HeapFree( GetProcessHeap(), 0, Tree );
    }


BOOLEAN
DebugPageHeapDumpThisHeapHogs(
    PVOID RemoteHeap
    )
    {
    ULONG RemoteBusyCount;
    ULONG RemoteBusyBytes;
    PVOID RemoteStackNode;
    PVOID RemoteBusyNode;
    PLOCAL_STACK_NODE TreeRoot;
    PVOID LocalNode;
    BOOLEAN Success;

    dprintf( "\nDPH Heap at %p, hogs:\n\n", RemoteHeap );

    //
    //  Walk busy list and build sorted list of stack traces
    //  by total busy size, descending.  Note that we expect
    //  multiple references to the same stack trace in the
    //  busy list.  Would be nice to verify that busy counts
    //  in stack trace nodes agree with number found in busy
    //  list.
    //

    TreeRoot = HeapAlloc( GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof( LOCAL_STACK_NODE ));

    if ( TreeRoot == NULL )
        return FALSE;

    RemoteBusyNode = FETCH_REMOTE_FIELD_PTR( RemoteHeap, DPH_HEAP_ROOT, pBusyAllocationListHead );

    while ( RemoteBusyNode ) {

        RemoteStackNode = FETCH_REMOTE_FIELD_PTR( RemoteBusyNode,  DPH_HEAP_ALLOCATION,  pStackTrace );
        RemoteBusyCount = FETCH_REMOTE_FIELD_INT( RemoteStackNode, DPH_STACK_TRACE_NODE, BusyCount );
        RemoteBusyBytes = FETCH_REMOTE_FIELD_INT( RemoteStackNode, DPH_STACK_TRACE_NODE, BusyBytes );

        LocalNode = DebugPageHeapFindOrInsertStackNodeInBtree(
                        TreeRoot,
                        RemoteStackNode,
                        RemoteBusyCount,
                        RemoteBusyBytes
                        );

        if (( ! LocalNode ) || ( CheckInterrupted() )) {
            DebugPageHeapFreeBtree( TreeRoot );
            return FALSE;
            }

        RemoteBusyNode = FETCH_REMOTE_FIELD_PTR( RemoteBusyNode, DPH_HEAP_ALLOCATION, pNextAlloc );

        }

    //
    //  Now walk btree left to right and dump traces.  Empty tree root
    //  has NULL for RemoteStackNode, so skip that case.
    //

    Success = DebugPageHeapReportStackTree( TreeRoot );

    dprintf( "\n" );
    DebugPageHeapFreeBtree( TreeRoot );
    return Success;
    }


BOOLEAN
DebugPageHeapResetStackNode(
    PVOID RemoteStackNode
    )
    {
    PVOID Left, Right;

    if ( CheckInterrupted() )
        return FALSE;

    WRITE_REMOTE_FIELD_PTR( RemoteStackNode, DPH_STACK_TRACE_NODE, BusyCount, NULL );
    WRITE_REMOTE_FIELD_PTR( RemoteStackNode, DPH_STACK_TRACE_NODE, BusyBytes, NULL );

    Left  = FETCH_REMOTE_FIELD_PTR( RemoteStackNode, DPH_STACK_TRACE_NODE, Left  );
    Right = FETCH_REMOTE_FIELD_PTR( RemoteStackNode, DPH_STACK_TRACE_NODE, Right );

    if ( Left )
        if ( ! DebugPageHeapResetStackNode( Left ))
            return FALSE;

    if ( Right )
        if ( ! DebugPageHeapResetStackNode( Right ))
            return FALSE;

    return TRUE;
    }


BOOLEAN
DebugPageHeapResetHeapHogs(
    PVOID RemoteHeap
    )
    {
    PVOID RemoteStackNode;

    dprintf( "\nDPH Heap at %p, reset hogs to zero...", RemoteHeap );

    //
    //  Walk remote stack trace btree, reset all counts to zero.
    //

    RemoteStackNode = FETCH_REMOTE_FIELD_PTR( RemoteHeap, DPH_HEAP_ROOT, pStackTraceRoot );

    if ( RemoteStackNode != NULL ) {
        if ( ! DebugPageHeapResetStackNode( RemoteStackNode ))
            return FALSE;
        }

    dprintf( "done\n\n" );
    return TRUE;
    }


BOOLEAN
DebugPageHeapExtensionShowHogs(
    PCSTR ArgumentString
    )
    {
    PVOID   RemoteHeapList;
    PVOID   RemoteHeap;
    PVOID   RemoteHeapToDump;
    BOOLEAN AnyDumps = FALSE;
    BOOLEAN Success;

    RemoteHeapToDump = (PVOID) strtoul( ArgumentString, NULL, 16 );
    RemoteHeapList   = (PVOID) GetExpression( "NTDLL!RtlpDebugPageHeapListHead" );
    RemoteHeap       = FetchRemotePVOID( RemoteHeapList );

    if (( RemoteHeap       == NULL ) ||
        ( RemoteHeapToDump == NULL ) ||
        ( strchr( ArgumentString, '?' ))) {

#ifndef DPH_EXTENSION_BUILT_AS_SEPARATE_PROCESS

        dprintf( "\nUsage: !dphhogs <address> [count] [reset]\n\n"
                 "       where <address> is the heap base address or heap handle,\n"
                 "       [count] changes sort order to count versus bytes, or\n"
                 "       [reset] will force all allocation counts to zero.\n\n"
               );

#endif // DPH_EXTENSION_BUILT_AS_SEPARATE_PROCESS

        return DebugPageHeapExtensionShowHeapList();
        }

    if ( strstr( ArgumentString, "count" ))
        DebugPageHeapSortByCount = TRUE;
    else
        DebugPageHeapSortByCount = FALSE;

    while ( RemoteHeap != NULL ) {

        if ((((SIZE_T)RemoteHeapToDump & 0xFFFF0000 ) == ((SIZE_T)RemoteHeap & 0xFFFF0000 )) ||
            ((SIZE_T)RemoteHeapToDump == 0xFFFFFFFF )) {

            Success = FALSE;

#ifdef DPH_EXTENSION_BUILT_AS_SEPARATE_PROCESS

            if ( DebugPageHeapExtensionLockRemoteHeap( RemoteHeap )) {

#endif // DPH_EXTENSION_BUILT_AS_SEPARATE_PROCESS

                if ( strstr( ArgumentString, "reset" )) {
                    Success = DebugPageHeapResetHeapHogs( RemoteHeap );
                    }
                else {
                    Success = DebugPageHeapDumpThisHeapHogs( RemoteHeap );
                    }

#ifdef DPH_EXTENSION_BUILT_AS_SEPARATE_PROCESS

                DebugPageHeapExtensionUnlockRemoteHeap( RemoteHeap );

                }

#endif // DPH_EXTENSION_BUILT_AS_SEPARATE_PROCESS

            if ( ! Success ) {
                return FALSE;
                }
            else {
                AnyDumps = TRUE;
                }

            }

        if ( CheckInterrupted() ) {
            return FALSE;
            }

        RemoteHeap = FETCH_REMOTE_FIELD_PTR( RemoteHeap, DPH_HEAP_ROOT, pNextHeapRoot );
        }

    if ( ! AnyDumps ) {
        dprintf( "\nDebug page heap \"0x%p\" not found in process\n\n", RemoteHeapToDump );
        DebugPageHeapExtensionShowHeapList();
        return FALSE;
        }

    return TRUE;
    }


#endif // DPH_CAPTURE_STACK_TRACE


VOID
DebugPageHeapExtensionHogs(
    PCSTR ArgumentString
    )
    {
#ifdef DPH_CAPTURE_STACK_TRACE
    DebugPageHeapExtensionShowHogs( ArgumentString );
#else
    dprintf( "\n!dphhogs only available on x86 checked builds\n\n" );
#endif
    }

VOID
DebugPageHeapExtensionFlags(
    PCSTR ArgumentString
    )
{
    PVOID   RemoteHeapList;
    PVOID   RemoteHeap;
    PVOID   RemoteHeapToDump;
    BOOLEAN AnyDumps = FALSE;

    BOOLEAN Success;

    PVOID FlagsAddress;
    ULONG NewFlags, OldFlags;

    FlagsAddress = (PVOID) GetExpression ("NTDLL!RtlpDebugPageHeapGlobalFlags" );
    OldFlags = FetchRemoteULONG (FlagsAddress);
    NewFlags = strtoul (ArgumentString, NULL, 16 );

    if (FlagsAddress == NULL) {
        dprintf ("Cannot read page heap global flags variable. \n"
                 "Make sure you have the right ntdll.dll sysmbols. \n");
        return;
    }

    //
    // Detect a help request.
    //

    if (ArgumentString != NULL
        && strchr (ArgumentString, '?')) {

        dprintf ("\nUsage: !dphfind [FLAGS] \n\n"
                 "Sets the global page heap flags. The value has the following structure:\n\n"
            TEXT("                                                                     \n")
            TEXT("    B7-B0   Bit flags    1 - enable page heap                        \n")
            TEXT("                                                                     \n")
            TEXT("         01 - enable page heap. If zero normal heap is used.         \n")
            TEXT("              In 99%% of the cases you will want this to be set.      \n")
            TEXT("         02 - collect stack traces (default on checked builds)       \n")
            TEXT("         04 - minimize memory impact                                 \n")
            TEXT("         08 - minimize randomly(1)/based on size range(0)            \n")
            TEXT("         10 - catch backward overruns                                \n")
            TEXT("                                                                     \n")
            TEXT("    B15-B8  Percentage of available memory from total memory below   \n")
            TEXT("            which allocations will be made from normal heap. Used    \n")
            TEXT("            in conjuction with bit flag 04.                          \n")
            TEXT("                                                                     \n")
            TEXT("    B31-B24 Probability for page heap allocation. Bit 4 and 8 must   \n")
            TEXT("            be set.                                                  \n")
            TEXT("                                                                     \n")
            TEXT("    B31-B24 Size range start                                         \n")
            TEXT("    B23-B16 Size range end                                           \n")
            TEXT("            Allocations in this size range will be made in page heap.\n")
            TEXT("            Bit 4 must be set and bit 8 must be reset.               \n")
            TEXT("                                                                     \n")
            TEXT(" Examples:                                                           \n")
            TEXT("                                                                     \n")
            TEXT("    !dphflags 0x03                                                   \n")
            TEXT("                                                                     \n")
            TEXT("        Enable stack trace collection on free builds where it is not \n")
            TEXT("        the default.                                                 \n")
            TEXT("                                                                     \n")
            TEXT("    !dphflags 0x13                                                   \n")
            TEXT("                                                                     \n")
            TEXT("        Put the not accessible page at the begining of the allocation\n")
            TEXT("        and enable stack traces.                                     \n")
            TEXT("                                                                     \n")
            TEXT("    !dphflags 0x3000300F                                             \n")
            TEXT("                                                                     \n")
            TEXT("        With 48%% probability allocate in page heap. If memory gets  \n")
            TEXT("        below 48%% then all allocations are done in normal heap.     \n")
            TEXT("                                                                     \n"));

        return;
    }

    dprintf ("Current flags: %08X \n\n", OldFlags);

    if (OldFlags & PAGE_HEAP_ENABLE_PAGE_HEAP) {
        dprintf ("EnablePageHeap \n");
    }

    if (OldFlags & PAGE_HEAP_COLLECT_STACK_TRACES) {
        dprintf ("CollectStackTraces \n");
    }

    if (OldFlags & PAGE_HEAP_MINIMIZE_MEMORY_IMPACT) {

        dprintf ("MinimizeMemoryImpact (criteria %u)\n",
                 ((OldFlags >> 8) & 0xFF));

        if (OldFlags & PAGE_HEAP_VERIFY_RANDOMLY) {
            dprintf ("VerifyRandomly (%u)\n", (OldFlags >> 24));
        }
        else {
            dprintf ("VerifyRange (%u - %u)\n",
                     (OldFlags >> 24), ((OldFlags >> 16) & 0xFF));
        }
    }

    if (OldFlags & PAGE_HEAP_CATCH_BACKWARD_OVERRUNS) {
        dprintf ("CatchBackwardOverruns \n");
    }

    //
    // Figure out if we have to write back something. If the guy really
    // wants to set the value zero then we are hosed. Although this can be
    // workaround by using a value like 0x2 (disables page heap) I need to
    // fix this in the future.
    //

    if (NewFlags != 0) {
        if (! WriteRemoteULONG (FlagsAddress, NewFlags)) {
            dprintf ("Failed to write back the flags value %08X !\n", NewFlags);
        }

        dprintf ("New flags: %08X \n", NewFlags);
    }

    return;
}


=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\mapsize\mapsize.cpp ===
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <dbghelp.h>

// We need to manually define this crt method because it does not exist in the XBOX version
// of the crt and therefore does not exist in the headers this method includes.  
//
extern "C" _CRTIMP void __cdecl exit(int);


PVOID 
ReadFileToMemZ(LPCSTR pszFN, DWORD* pdwSize)
{
    HANDLE hFile;
    PVOID pMem = NULL;
    DWORD dwSize = 0;
    DWORD dwBytes;

    hFile = CreateFile(pszFN, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if (hFile != INVALID_HANDLE_VALUE)
    {
        dwSize = GetFileSize(hFile, NULL) + 1;

        if (dwSize > 0)
        {
            pMem = malloc(dwSize);
            if (pMem != NULL)
            {
                if (!ReadFile(hFile, pMem, dwSize - 1, &dwBytes, NULL))
                {
                    free(pMem);
                    pMem = NULL;
                }

                ((char*)pMem)[dwSize - 1] = '\0';
            }
        }
        CloseHandle(hFile);
    }
    *pdwSize = dwSize;
    return pMem;
}


BOOL
IsBlank(char* str)
{
    return str[0] == '\0';
}


ULONG
GetHexNum(char* str, ULONG ofs, ULONG len)
{
    char* begptr = (str + ofs);
    char* endptr = (str + ofs + len - 1);

    return strtoul(begptr, &endptr, 16);
}


enum States  
{
    Starting, Table1, Table2Hdr, Table2HdrBlank, Table2, EntryPoint, EntryPointBlank, Ending
};

struct SecInfo
{
    ULONG Seg;
    ULONG Start;
    ULONG Length;
};


struct StaticInfo
{
    ULONG Seg;
    ULONG Start;
    char FuncName[256];
};

#define MAX_STATICS     2048

SecInfo* Sec;
ULONG SecCount = 0;
char* StaticPtr = NULL;
StaticInfo* Stat;
ULONG StatCount = 0;
char Filter[512];
ULONG TotalSize;


ULONG
GetSecLimit(ULONG Seg, ULONG rva)
{
    for (ULONG i = 0; i < SecCount; i++)
    {
        ULONG Limit = Sec[i].Start + Sec[i].Length;
        if (Seg == Sec[i].Seg &&
            rva >= Sec[i].Start &&
            rva <= Limit)
        {
            return Limit;
        }
    }
    return 0;
}


VOID
BuildStatics()
{

    char* Line; 
    char* EPtr;
    char FuncName[512];
    char OrgName[512];


    Line = StaticPtr;    
    for (;;)
    {
        EPtr = strchr(Line, '\r');
        if (EPtr != NULL)
        {
            *EPtr = '\0';
            if (*(EPtr + 1) == '\n')
            {
                EPtr++;                
            }
        }

        if (IsBlank(Line))
        {
            break;            
        }
    
        Stat[StatCount].Seg = GetHexNum(Line, 1, 4);
        Stat[StatCount].Start = GetHexNum(Line, 6, 8);

        char* p = (Line + 21);
        char* ep = strchr(p, ' ');
        if (ep == NULL)
        {
            printf("Error parsing\n");
        }
    
        memset(OrgName, 0, sizeof(OrgName));
        memcpy(OrgName, p, ep - p);
    
        UnDecorateSymbolName(OrgName, FuncName, sizeof(FuncName), 
                             UNDNAME_NAME_ONLY | 
                             UNDNAME_NO_ALLOCATION_MODEL |
                             UNDNAME_NO_ALLOCATION_LANGUAGE);

        strcpy(Stat[StatCount].FuncName, FuncName);

        if (StatCount < MAX_STATICS) 
        {
            StatCount++;
        }


        if (EPtr == NULL)
        {
            break;            
        }
        Line = EPtr + 1;
    }
}



VOID
CheckStatics(ULONG ChkFuncSeg, ULONG ChkFuncStart, ULONG ChkFuncLength, char* buf)
{

    buf[0] = '\0';
    for (ULONG i = 0; i < StatCount; i++)
    {

        if (Stat[i].Seg == ChkFuncSeg &&
            Stat[i].Start >= ChkFuncStart &&
            Stat[i].Start <= (ChkFuncStart + ChkFuncLength))
        {

            strcat(buf, Stat[i].FuncName);
            strcat(buf, " ");
        }
    }
}



VOID
Out(ULONG FuncLength, char* FuncModule, char* FuncName, ULONG FuncStart, ULONG FuncSeg)
{

    char buf[32 * 1024];

    if (Filter[0] != '\0')
    {
        strcpy(buf, FuncName);
        strcat(buf, " ");
        strcat(buf, FuncModule);
        _strupr(buf);

        if (strstr(buf, Filter) == NULL)
        {
            return;
        }
    }

    TotalSize += FuncLength;

    CheckStatics(FuncSeg, FuncStart, FuncLength, buf);

    printf("%6d, %-40s, %-20s", FuncLength, FuncName, FuncModule);

    if (buf[0] != '\0')
    {
        printf(",\"Includes Statics: %s\"", buf);        
    }
    printf("\n");

        
}


extern "C"
int
_cdecl
main(
    int argc,
    char** argv
    )
{
    ULONG Size;
    char* Data;
    char* Line; 
    char* EPtr;
    char* LineU;

    States State = Starting;
    char OrgName[512];

    ULONG FuncSeg = 0;
    ULONG FuncStart = 0;
    char FuncName[512];
    char FuncModule[512];
    ULONG FuncLength;
    ULONG SecLimit;
    
    ULONG CurrentFuncStart;
    ULONG CurrentFuncSeg;

    BOOL PrevFuncValid = FALSE;

    if (argc < 2)
    {
        printf("Usage: mapsize file.map [filter]\n");
        return -1;
    }

    Filter[0] = '\0';
    TotalSize = 0;

    if (argc >= 3)
    {
        strcpy(Filter, argv[2]);
        _strupr(Filter);
    }

    Data = (char*)ReadFileToMemZ(argv[1], &Size);

    if (Data == NULL)
    {
        printf("Cannot read map file %s\n", argv[1]);
        return -1;
    }

    printf("%6s, %-40s, %-20s\n", "[SIZE]", "[FUNCTION]", "[MODULE]");


    Sec = (SecInfo*)malloc(1024 * sizeof(SecInfo));
    Stat = (StaticInfo*)malloc(MAX_STATICS * sizeof(StaticInfo));
    LineU = (char*)malloc(8192);


    StaticPtr = strstr(Data, "Static symbols\r");
    if (StaticPtr != NULL)
    {
        StaticPtr += 18;

        BuildStatics();
    }

    Line = Data;    
    for (;;)
    {
        EPtr = strchr(Line, '\r');
        if (EPtr != NULL)
        {
            *EPtr = '\0';
            if (*(EPtr + 1) == '\n')
            {
                EPtr++;                
            }
        }

        switch (State)
        {
        
            case Starting:
                strcpy(LineU, Line);
                _strupr(LineU);

                if ((strstr(LineU, "START ") != NULL) && 
                    (strstr(LineU, "   CLASS") != NULL))
                {
                    State = Table1;
                }
                break;

            case Table1:
                if (!IsBlank(Line))
                {
                    Sec[SecCount].Seg = GetHexNum(Line, 1, 4);
                    Sec[SecCount].Start = GetHexNum(Line, 6, 8);
                    Sec[SecCount].Length = GetHexNum(Line, 15, 8);
                    SecCount++;
                
                }
                else
                {
                    State = Table2Hdr;
                }
                break;

            case Table2Hdr:
                State = Table2HdrBlank;
                break;

            case Table2HdrBlank:
                State = Table2;
                break;

            case Table2:

                if (!IsBlank(Line))
                {

                    CurrentFuncSeg = GetHexNum(Line, 1, 4);
                    CurrentFuncStart = GetHexNum(Line, 6, 8);

                    if (PrevFuncValid)
                    {
                        if (CurrentFuncStart == 0)
                        {
                            SecLimit = GetSecLimit(FuncSeg, FuncStart);

                            FuncLength = SecLimit - FuncStart;
                        }
                        else
                        {
                            FuncLength = CurrentFuncStart - FuncStart;
                        }


                        Out(FuncLength, FuncModule, FuncName, FuncStart, FuncSeg);                    
                    }
                    
                    FuncSeg = GetHexNum(Line, 1, 4);
                    FuncStart = GetHexNum(Line, 6, 8);

                    char* p = (Line + 21);
                    char* ep = strchr(p, ' ');
                    if (ep == NULL)
                    {
                        printf("Error parsing\n");
                        return -1;
                    }
                
                    memset(OrgName, 0, sizeof(OrgName));
                    memcpy(OrgName, p, ep - p);

                    while (*ep == ' ')
                    {
                        ep++;
                    }
                    ep += 13;

                    strcpy(FuncModule, ep);

                    UnDecorateSymbolName(OrgName, FuncName, sizeof(FuncName), 
                                         UNDNAME_NAME_ONLY | 
                                         UNDNAME_NO_ALLOCATION_MODEL |
                                         UNDNAME_NO_ALLOCATION_LANGUAGE);



                    PrevFuncValid = TRUE;

                }
                else
                {

                    if (PrevFuncValid)
                    {
                        SecLimit = GetSecLimit(FuncSeg, FuncStart);

                        FuncLength = SecLimit - FuncStart;
                        
                        Out(FuncLength, FuncModule, FuncName, FuncStart, FuncSeg);                    
                        
                    }
                    State = Ending;

                    PrevFuncValid = FALSE;
                }
                break;

        }
       
        if (EPtr == NULL)
        {
            break;            
        }
        Line = EPtr + 1;
    }

    printf("\n\nTotal=%d\n", TotalSize);


    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\ntsdexts\hleak.c ===
#define REASONABLE_NUMBER   8


typedef BOOL (_ID_MATCH_FN)(
    PVOID   A,
    PVOID   B);
typedef _ID_MATCH_FN * PID_MATCH_FN;

typedef VOID (_ID_BANNER_FN)(
    PVOID   Id
    );
typedef _ID_BANNER_FN * PID_BANNER_FN;

typedef VOID (_HANDLE_CALLBACK_FN)(
    PVOID Context,
    HANDLE Here,
    HANDLE There
    );
typedef _HANDLE_CALLBACK_FN * PHANDLE_CALLBACK_FN;


#define MATCH_LARGE_INT     ((PID_MATCH_FN)1)

typedef struct _HANDLE_TRACK {
    LIST_ENTRY  List ;
    ULONG       Flags ;
    ULONG       Count ;
    ULONG       Size ;
    PHANDLE     Handles ;
    HANDLE      HandleList[ REASONABLE_NUMBER ];
    UCHAR       IdData[ 1 ];
} HANDLE_TRACK, * PHANDLE_TRACK ;

typedef struct _HANDLE_TRACK_ARRAY {
    ULONG       Count ;
    ULONG       Size ;
    ULONG       IdDataSize ;
    PID_MATCH_FN MatchFunc ;
    LIST_ENTRY  List ;
} HANDLE_TRACK_ARRAY, * PHANDLE_TRACK_ARRAY ;

typedef struct _THREAD_TRACK_INFO {
    CLIENT_ID   Id ;
    PVOID       Win32StartAddress ;
    DWORD       Status ;
} THREAD_TRACK_INFO ;

typedef struct _HANDLE_LEAK_HELPER {
    PWSTR               Type ;
    PID_BANNER_FN       Banner ;
    PHANDLE_CALLBACK_FN Filter ;
    ULONG               ArraySize ;
    PID_MATCH_FN        Match ;
} HANDLE_LEAK_HELPER, * PHANDLE_LEAK_HELPER ;

_ID_BANNER_FN       ThreadBanner ;
_ID_BANNER_FN       TokenBanner ;
_HANDLE_CALLBACK_FN ThreadCallback ;
_HANDLE_CALLBACK_FN TokenCallback ;

HANDLE_LEAK_HELPER HandleLeakHelpers[] = {
    { L"Thread", ThreadBanner, ThreadCallback, sizeof( THREAD_TRACK_INFO ), MATCH_LARGE_INT },
    { L"Token", TokenBanner, TokenCallback, sizeof( TOKEN_CONTROL ), MATCH_LARGE_INT }
};


PHANDLE_TRACK_ARRAY
CreateArray(
    ULONG   IdDataSize,
    PID_MATCH_FN MatchFn
    )
{
    PHANDLE_TRACK_ARRAY    Array ;

    Array = RtlAllocateHeap( RtlProcessHeap(), 0, sizeof( HANDLE_TRACK_ARRAY ) );

    if ( Array )
    {
        Array->Count = 0 ;
        Array->Size = 0;
        Array->IdDataSize = IdDataSize ;
        Array->MatchFunc = MatchFn ;

        InitializeListHead( &Array->List );

        return Array ;
    }

    return NULL ;
}

VOID
DeleteArray(
    PHANDLE_TRACK_ARRAY Array
    )
{
    ULONG i ;
    PHANDLE_TRACK Track ;

    while ( !IsListEmpty( &Array->List ) )
    {
        Track = (PHANDLE_TRACK) RemoveHeadList( &Array->List );

        if ( Track->Handles != Track->HandleList )
        {
            RtlFreeHeap( RtlProcessHeap(), 0, Track->Handles );
        }

        RtlFreeHeap( RtlProcessHeap(), 0, Track );
    }

    RtlFreeHeap( RtlProcessHeap(), 0, Array );
}


VOID
ExtendTrack(
    PHANDLE_TRACK Track
    )
{
    PHANDLE NewHandle ;

    NewHandle = RtlAllocateHeap( RtlProcessHeap(), 0, (Track->Size + REASONABLE_NUMBER ) *
                        sizeof( HANDLE ) );

    if ( NewHandle )
    {
        CopyMemory( NewHandle,
                    Track->Handles,
                    Track->Count * sizeof( HANDLE ) );

        if ( Track->Handles != Track->HandleList )
        {
            RtlFreeHeap( RtlProcessHeap(), 0, Track->Handles );
        }

        Track->Handles = NewHandle ;
        Track->Size += REASONABLE_NUMBER ;
    }
}

VOID
AddHandleToArray(
    PHANDLE_TRACK_ARRAY Array,
    PVOID IdData,
    HANDLE Handle
    )
{
    ULONG i;
    ULONG j;
    BOOL Match ;
    PHANDLE_TRACK Track ;
    PLIST_ENTRY Scan ;

    Scan = Array->List.Flink ;

    while ( Scan != &Array->List )
    {
        Track = (PHANDLE_TRACK) Scan ;

        if ( Array->MatchFunc == MATCH_LARGE_INT )
        {
            Match = ((PLARGE_INTEGER) Track->IdData)->QuadPart ==
                    ((PLARGE_INTEGER) IdData)->QuadPart ;
        }
        else
        {
            Match = Array->MatchFunc( Track->IdData, IdData );
        }

        if ( Match )
        {
            //
            // We have a match:
            //

            if ( Track->Count == Track->Size )
            {
                ExtendTrack( Track );
            }

            if ( Track->Count < Track->Size )
            {
                Track->Handles[
                        Track->Count ] = Handle ;

                Track->Count++;
            }

            return ;
        }

        Scan = Scan->Flink ;
    }

    //
    // No match, gotta add a new tid
    //

    Track = RtlAllocateHeap( RtlProcessHeap(), 0,
                sizeof( HANDLE_TRACK ) + Array->IdDataSize );

    if ( Track )
    {
        Track->Size = REASONABLE_NUMBER ;
        Track->Count = 1 ;
        Track->Handles = Track->HandleList ;
        Track->HandleList[0] = Handle ;

        CopyMemory( Track->IdData, IdData, Array->IdDataSize );

        InsertTailList( &Array->List, &Track->List );
    }

}

VOID
DumpArray(
    PHANDLE_TRACK_ARRAY Array,
    PID_BANNER_FN   Banner
    )
{
    ULONG j;
    PHANDLE_TRACK Track ;
    PLIST_ENTRY Scan ;

    Scan = Array->List.Flink ;

    while ( Scan != &Array->List )
    {
        Track = (PHANDLE_TRACK) Scan ;

        Banner( Track->IdData );

        dprintf("  Handles  \t%d:  ", Track->Count );
        for ( j = 0 ; j < Track->Count ; j++ )
        {
            dprintf("%x, ", Track->Handles[j] );
        }

        dprintf("\n");

        Scan = Scan->Flink ;
    }

}

VOID
HandleScanner(
    HANDLE  hCurrentProcess,
    PWSTR   Type,
    PVOID   Context,
    PHANDLE_CALLBACK_FN Callback
    )
{
    DWORD   HandleCount;
    NTSTATUS Status;
    DWORD   Total;
    DWORD   Handle;
    DWORD   Hits;
    DWORD   Matches;
    HANDLE  hHere ;
    PHANDLE_TRACK_ARRAY Array ;
    POBJECT_TYPE_INFORMATION    pTypeInfo;
    UCHAR   Buffer[1024];

    Status = NtQueryInformationProcess( hCurrentProcess,
                                        ProcessHandleCount,
                                        &HandleCount,
                                        sizeof( HandleCount ),
                                        NULL );

    if ( !NT_SUCCESS( Status ) )
    {
        return;
    }

    Hits = 0;
    Handle = 0;
    Matches = 0;

    while ( Hits < HandleCount )
    {
        Status = NtDuplicateObject( hCurrentProcess, (HANDLE) Handle,
                                    NtCurrentProcess(), &hHere,
                                    0, 0,
                                    DUPLICATE_SAME_ACCESS );

        if ( NT_SUCCESS( Status ) )
        {

            pTypeInfo = (POBJECT_TYPE_INFORMATION) Buffer;

            ZeroMemory( Buffer, 1024 );

            Status = NtQueryObject( hHere, ObjectTypeInformation, pTypeInfo, 1024, NULL );

            if (NT_SUCCESS(Status))
            {
                if ( wcscmp( pTypeInfo->TypeName.Buffer, Type ) == 0 )
                {
                    //
                    // Score!
                    //

                    Callback( Context, hHere, (HANDLE) Handle );

                    Matches++ ;

                }
            }

            Hits++ ;

            NtClose( hHere );

        }

        Handle += 4;
    }

    dprintf("%d handles to objects of type %ws\n", Matches, Type );
}


VOID
ThreadBanner(
    PVOID Id
    )
{
    UCHAR Symbol[ MAX_PATH ];
    DWORD_PTR Disp ;
    THREAD_TRACK_INFO * Info ;
    UCHAR ExitStatus[ 32 ];

    Info = (THREAD_TRACK_INFO *) Id ;

    Symbol[0] = '\0';

    GetSymbol( Info->Win32StartAddress, Symbol, &Disp );

    if ( Info->Status != STILL_ACTIVE )
    {
        sprintf(ExitStatus, " Stopped, %#x", Info->Status );
    }
    else
    {
        strcpy( ExitStatus, "<Running>");
    }

    if ( Symbol[0] )
    {
        dprintf("Thread %x.%x (%s) %s\n", Info->Id.UniqueProcess,
                        Info->Id.UniqueThread,
                        Symbol,
                        ExitStatus );
    }
    else
    {
        dprintf("Thread %x.%x %s\n", Info->Id.UniqueProcess,
                        Info->Id.UniqueThread,
                        ExitStatus );

    }
}

VOID
ThreadCallback(
    PVOID Context,
    HANDLE Here,
    HANDLE There
    )
{
    NTSTATUS Status ;
    THREAD_BASIC_INFORMATION Info;

    THREAD_TRACK_INFO ThdInfo ;

    ZeroMemory( &ThdInfo, sizeof( ThdInfo ) );

    Status = NtQueryInformationThread( Here,
                                       ThreadBasicInformation,
                                       &Info,
                                       sizeof( Info ),
                                       NULL );

    if ( NT_SUCCESS( Status ) )
    {
        ThdInfo.Id = Info.ClientId ;
        ThdInfo.Status = Info.ExitStatus ;

        Status = NtQueryInformationThread( Here,
                                           ThreadQuerySetWin32StartAddress,
                                           &ThdInfo.Win32StartAddress,
                                           sizeof( PVOID ),
                                           NULL );

        AddHandleToArray( Context, &ThdInfo , There );
    }
}

VOID
TokenCallback(
    PVOID Context,
    HANDLE Here,
    HANDLE There
    )
{
    NTSTATUS Status ;
    TOKEN_CONTROL Control ;
    TOKEN_STATISTICS Stats ;
    ULONG Size ;

    Status = NtQueryInformationToken(   Here,
                                        TokenStatistics,
                                        &Stats,
                                        sizeof( Stats ),
                                        &Size );

    if ( NT_SUCCESS( Status ) )
    {
        Control.TokenId = Stats.TokenId ;
        Control.AuthenticationId = Stats.AuthenticationId ;
        Control.ModifiedId = Stats.ModifiedId ;
        NtQueryInformationToken( Here, TokenSource, &Control.TokenSource, sizeof( TOKEN_SOURCE ), &Size );

        AddHandleToArray( Context, &Control, There );
    }
    else
    {
        dprintf("Unable to query token information, %x\n", Status );
    }
}

VOID
TokenBanner(
    PVOID Id
    )
{
    PTOKEN_CONTROL Control ;

    Control = (PTOKEN_CONTROL) Id ;

    dprintf("Token   Id %x:%x, LogonId = %x:%x, Source = %s\n",
                Control->TokenId.HighPart, Control->TokenId.LowPart,
                Control->AuthenticationId.HighPart, Control->AuthenticationId.LowPart,
                Control->TokenSource.SourceName );
}


DECLARE_API( hleak )
{
    UNICODE_STRING String ;
    PHANDLE_LEAK_HELPER Helper = NULL ;
    PHANDLE_TRACK_ARRAY Array ;
    int i ;

    INIT_API();

    if ( !lpArgumentString || 
         (*lpArgumentString == '\0' ) )
    {
        dprintf( "!hleak <typename>\n" );
        return;
    }

    while ( *lpArgumentString == ' ' )
    {
        lpArgumentString++ ;
    }

    if ( !RtlCreateUnicodeStringFromAsciiz( &String, lpArgumentString ) )
    {
        return;
    }

    for ( i = 0 ; 
          i < sizeof( HandleLeakHelpers ) / sizeof( HANDLE_LEAK_HELPER ) ; 
          i++ )
    {
        if ( _wcsicmp( String.Buffer, HandleLeakHelpers[ i ].Type ) == 0 )
        {
            Helper = &HandleLeakHelpers[ i ];
            break;
        }
    }

    if ( Helper == NULL )
    {
        dprintf( "The type '%ws' was not recognized.  Valid types are:\n", String.Buffer );
        for ( i = 0 ; 
              i < sizeof( HandleLeakHelpers ) / sizeof( HANDLE_LEAK_HELPER ) ; 
              i++ )
        {
            dprintf( "\t%ws\n", HandleLeakHelpers[ i ].Type );
        }
        RtlFreeUnicodeString( &String );
        return ;
    }

    RtlFreeUnicodeString( &String );

    Array = CreateArray( Helper->ArraySize, Helper->Match );

    if ( !Array )
    {
        dprintf( "not enough memory\n" );
    }

    HandleScanner( hCurrentProcess,
                   Helper->Type,
                   Array,
                   Helper->Filter );

    DumpArray( Array, Helper->Banner );

    DeleteArray( Array );

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\ntsdexts\atomext.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    ntsdexts.c

Abstract:

    This function contains the default ntsd debugger extensions

Author:

    Mark Lucovsky (markl) 09-Apr-1991

Revision History:

--*/

CHAR szBaseLocalAtomTable[] = "kernel32!BaseLocalAtomTable";

VOID DumpAtomTable(
    PRTL_ATOM_TABLE *ppat,
    ATOM a
    )
{
    RTL_ATOM_TABLE at, *pat;
    RTL_ATOM_TABLE_ENTRY ate, *pate;
    int iBucket;
    LPWSTR pwsz;
    BOOL fFirst;

    move(pat, ppat);
    if (pat == NULL) {
        dprintf("is not initialized.\n");
        return;
    }
    move(at, pat);
    if (a) {
        dprintf("\n");
    } else {
        dprintf("at %x\n", pat);
    }
    for (iBucket = 0; iBucket < (int)at.NumberOfBuckets; iBucket++) {
        move(pate, &pat->Buckets[iBucket]);
        if (pate != NULL && !a) {
            dprintf("Bucket %2d:", iBucket);
        }
        fFirst = TRUE;
        while (pate != NULL) {
            if (!fFirst && !a) {
                dprintf("          ");
            }
            fFirst = FALSE;
            move(ate, pate);
            pwsz = (LPWSTR)LocalAlloc(LPTR, (ate.NameLength + 1) * sizeof(WCHAR));
            moveBlock(*pwsz, &pate->Name, ate.NameLength * sizeof(WCHAR));
            pwsz[ate.NameLength ] = L'\0';
            if (a == 0 || a == (ATOM)(ate.HandleIndex | MAXINTATOM)) {
                dprintf("%hx(%2d) = %ls (%d)%s\n",
                        (ATOM)(ate.HandleIndex | MAXINTATOM),
                        ate.ReferenceCount,
                        pwsz, ate.NameLength,
                        ate.Flags & RTL_ATOM_PINNED ? " pinned" : "");

                if (a) {
                    LocalFree(pwsz);
                    return;
                }
            }
            LocalFree(pwsz);
            if (pate == ate.HashLink) {
                dprintf("Bogus hash link at %x\n", pate);
                break;
            }
            pate = ate.HashLink;
        }
    }
    if (a)
        dprintf("\n");
}


VOID
AtomExtension(
    PCSTR lpArgumentString
    )
{
    PRTL_ATOM_TABLE *ppat;
    ATOM a;

    try {
        while (*lpArgumentString == ' ') {
            lpArgumentString++;
        }

        if (*lpArgumentString && *lpArgumentString != 0xa) {
            a = (ATOM)GetExpression((LPSTR)lpArgumentString);
        } else {
            a = 0;
        }

        ppat = (PRTL_ATOM_TABLE *)GetExpression(szBaseLocalAtomTable);
        if (ppat != NULL) {
            dprintf("\nLocal atom table ");
            DumpAtomTable(ppat, a);
        }

    } except (EXCEPTION_EXECUTE_HANDLER) {
        ;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\ntsdexts\gflagext.c ===
#include <ntexapi.dbg>

VOID
GFlagExtension(
    PVOID pNtGlobalFlag,
    ULONG ValidBits,
    PCSTR lpArgumentString
    )
{
    ULONG i;
    ULONG OldGlobalFlags;
    ULONG NewGlobalFlagsClear;
    ULONG NewGlobalFlagsSet;
    ULONG NewGlobalFlags;
    LPSTR s, Arg;

    if (pNtGlobalFlag == NULL) {
        dprintf( "Unable to get address of NtGlobalFlag variable" );
        return;
        }

    if (!ReadMemory( (ULONG_PTR) pNtGlobalFlag,
                     &OldGlobalFlags,
                     sizeof( OldGlobalFlags ),
                     NULL
                   )
       ) {
        dprintf( "Unable to read contents of NtGlobalFlag variable at 0x%x", pNtGlobalFlag );
        return;
        }
    OldGlobalFlags &= ValidBits;

    s = (LPSTR)lpArgumentString;
    if (!s)
        s = "";

    NewGlobalFlagsClear = 0;
    NewGlobalFlagsSet = 0;
    while (*s) {
        while (*s && *s <= ' ')
            s += 1;

        Arg = s;
        if (!*s)
            break;

        while (*s && *s > ' ')
            s += 1;


        if (*s)
            *s++ = '\0';

        if (!strcmp( Arg, "-?" )) {
            dprintf( "usage: !gflag [-? | flags]\n" );
            dprintf( "Flags may either be a single hex number that specifies all\n" );
            dprintf( "32-bits of the GlobalFlags value, or it can be one or more\n" );
            dprintf( "arguments, each beginning with a + or -, where the + means\n" );
            dprintf( "to set the corresponding bit(s) in the GlobalFlags and a -\n" );
            dprintf( "means to clear the corresponding bit(s).  After the + or -\n" );
            dprintf( "may be either a hex number or a three letter abbreviation\n" );
            dprintf( "for a GlobalFlag.  Valid abbreviations are:\n" );
            for (i=0; i<32; i++) {
                if ((GlobalFlagInfo[i].Flag & ValidBits) &&
                    GlobalFlagInfo[i].Abbreviation != NULL
                   ) {
                    dprintf( "    %s - %s\n", GlobalFlagInfo[i].Abbreviation,
                                                      GlobalFlagInfo[i].Description
                           );
                    }
                }

            return;
            }

        if (*Arg == '+' || *Arg == '-') {
            if (strlen(Arg+1) == 3) {
                for (i=0; i<32; i++) {
                    if ((GlobalFlagInfo[i].Flag & ValidBits) &&
                        !_stricmp( GlobalFlagInfo[i].Abbreviation, Arg+1 )
                       ) {
                        if (*Arg == '-') {
                            NewGlobalFlagsClear |= GlobalFlagInfo[i].Flag;
                            }
                        else {
                            NewGlobalFlagsSet |= GlobalFlagInfo[i].Flag;
                            }

                        Arg += 4;
                        break;
                        }
                    }

                if (*Arg != '\0') {
                    dprintf( "Invalid flag abbreviation - '%s'\n", Arg );
                    return;
                    }
                }

            if (*Arg != '\0') {
                if (*Arg++ == '-') {
                    NewGlobalFlagsClear |= strtoul( Arg, &Arg, 16 );
                    }
                else {
                    NewGlobalFlagsSet |= strtoul( Arg, &Arg, 16 );
                    }
                }
            }
        else {
            NewGlobalFlagsSet = strtoul( Arg, &Arg, 16 );
            break;
            }
        }

    NewGlobalFlags = (OldGlobalFlags & ~NewGlobalFlagsClear) | NewGlobalFlagsSet;
    NewGlobalFlags &= ValidBits;
    if (NewGlobalFlags != OldGlobalFlags) {
        if (!WriteMemory( (ULONG_PTR)pNtGlobalFlag,
                          &NewGlobalFlags,
                          sizeof( NewGlobalFlags ),
                          NULL
                        )
           ) {
            dprintf( "Unable to store new global flag settings.\n" );
            return;
            }

        dprintf( "New NtGlobalFlag contents: 0x%08x\n", NewGlobalFlags );
        OldGlobalFlags = NewGlobalFlags;
        }
    else {
        dprintf( "Current NtGlobalFlag contents: 0x%08x\n", OldGlobalFlags );
        }
    for (i=0; i<32; i++) {
        if (OldGlobalFlags & GlobalFlagInfo[i].Flag) {
            dprintf( "    %s - %s\n", GlobalFlagInfo[i].Abbreviation, GlobalFlagInfo[i].Description );
            }
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\mkeeprom\mkeeprom.c ===
#include <windows.h>
typedef ULONG NTSTATUS;
#include <xcrypt.h>
#include <init.h>
#include <xconfig.h>
#include <stdio.h>
#include <conio.h>
#include <stdlib.h>
#include <string.h>
#include <sha.h>
#include <rc4.h>
#include "av.h"

#define XC_ENCFILE_SIG              'k2ne'
#define RC4_CONFOUNDER_LEN          8
#define HMAC_K_PADSIZE              64

typedef struct _RC4_SHA1_HEADER {
    UCHAR Checksum[A_SHA_DIGEST_LEN];
    UCHAR Confounder[RC4_CONFOUNDER_LEN];
} RC4_SHA1_HEADER, *PRC4_SHA1_HEADER;

typedef struct _XC_ENCFILE_HEADER
{
    DWORD Sig;
    RC4_SHA1_HEADER CryptHeader;
    DWORD MsgLen;
    UCHAR MsgDigest[A_SHA_DIGEST_LEN];
} XC_ENCFILE_HEADER, *PXC_ENCFILE_HEADER;

const UCHAR g_rgbDefEepromKey[] = {
    0x7b, 0x35, 0xa8, 0xb7, 0x27, 0xed, 0x43, 0x7a,
    0xa0, 0xba, 0xfb, 0x8f, 0xa4, 0x38, 0x61, 0x80,
};

void GetPasswd(LPSTR sz, int cchMax)
{
    char ch;
    int ich = 0;

    _cputs("Enter password:");
    for(;;) {
        ch = (char)_getch();
        switch(ch) {
        case 8:
            if(ich)
                --ich;
            break;
        case 10:
        case 13:
            sz[ich] = 0;
            _putch('\r');
            _putch('\n');
            return;
        default:
            if(ich < cchMax)
                sz[ich++] = ch;
            break;
        }
    }
}


void 
shaHmac(
    IN PBYTE pbKeyMaterial,
    IN ULONG cbKeyMaterial,
    IN PBYTE pbData,
    IN ULONG cbData,
    IN PBYTE pbData2,
    IN ULONG cbData2,
    OUT PBYTE HmacData // length must be A_SHA_DIGEST_LEN
    )
{
    BYTE Kipad[HMAC_K_PADSIZE];
    BYTE Kopad[HMAC_K_PADSIZE];
    BYTE HMACTmp[HMAC_K_PADSIZE+A_SHA_DIGEST_LEN];
    ULONG dwBlock;
    A_SHA_CTX shaHash;

    // truncate
    if (cbKeyMaterial > HMAC_K_PADSIZE)
        cbKeyMaterial = HMAC_K_PADSIZE;

    RtlZeroMemory(Kipad, HMAC_K_PADSIZE);
    RtlCopyMemory(Kipad, pbKeyMaterial, cbKeyMaterial);

    RtlZeroMemory(Kopad, HMAC_K_PADSIZE);
    RtlCopyMemory(Kopad, pbKeyMaterial, cbKeyMaterial);

    //
    // Kipad, Kopad are padded sMacKey. Now XOR across...
    //
    for(dwBlock=0; dwBlock<HMAC_K_PADSIZE/sizeof(DWORD); dwBlock++)
    {
        ((DWORD*)Kipad)[dwBlock] ^= 0x36363636;
        ((DWORD*)Kopad)[dwBlock] ^= 0x5C5C5C5C;
    }

    //
    // prepend Kipad to data, Hash to get H1
    //

    A_SHAInit(&shaHash);
    A_SHAUpdate(&shaHash, Kipad, HMAC_K_PADSIZE);
    if (cbData != 0)
    {
        A_SHAUpdate(&shaHash, pbData, cbData);
    }
    if (cbData2 != 0)
    {
        A_SHAUpdate(&shaHash, pbData2, cbData2);
    }

    // Finish off the hash
    A_SHAFinal(&shaHash,HMACTmp+HMAC_K_PADSIZE);

    // prepend Kopad to H1, hash to get HMAC
    RtlCopyMemory(HMACTmp, Kopad, HMAC_K_PADSIZE);

    // final hash: output value into passed-in buffer
    A_SHAInit(&shaHash);
    A_SHAUpdate(&shaHash,HMACTmp, sizeof(HMACTmp));
    A_SHAFinal(&shaHash,HmacData);
}


void 
rc4HmacEncrypt(
    IN PUCHAR confounder, // RC4_CONFOUNDER_LEN bytes
    IN PUCHAR pbKey,
    IN ULONG cbKey,
    IN PUCHAR pbInput,
    IN ULONG cbInput,
    OUT PUCHAR pbHeader // XC_SERVICE_DIGEST_SIZE + RC4_CONFOUNDER_LEN bytes
    )
{
    PRC4_SHA1_HEADER CryptHeader = (PRC4_SHA1_HEADER) pbHeader;
    BYTE LocalKey[A_SHA_DIGEST_LEN];
    RC4_KEYSTRUCT Rc4KeyStruct;

    //
    // Create the header - the confounder & checksum
    //
    RtlZeroMemory( CryptHeader->Checksum, A_SHA_DIGEST_LEN );
    RtlCopyMemory( CryptHeader->Confounder, confounder, RC4_CONFOUNDER_LEN );

    //
    // Checksum everything but the checksum
    //
    shaHmac( pbKey, cbKey,
             CryptHeader->Confounder, RC4_CONFOUNDER_LEN,
             pbInput, cbInput,
             CryptHeader->Checksum );

    //
    // HMAC the checksum into the key
    //
    shaHmac( pbKey, cbKey,
             CryptHeader->Checksum, A_SHA_DIGEST_LEN,
             NULL, 0,
             LocalKey );

    //
    // Use the generated key as the RC4 encryption key
    //
    rc4_key( &Rc4KeyStruct, A_SHA_DIGEST_LEN, LocalKey );

    //
    // Encrypt everything but the checksum
    //
    rc4( &Rc4KeyStruct, RC4_CONFOUNDER_LEN, CryptHeader->Confounder );
    rc4( &Rc4KeyStruct, cbInput, pbInput );
}


BOOL 
rc4HmacDecrypt(
    IN PUCHAR pbKey,
    IN ULONG cbKey,
    IN PUCHAR pbInput,
    IN ULONG cbInput,
    IN PUCHAR pbHeader // XC_SERVICE_DIGEST_SIZE + RC4_CONFOUNDER_LEN bytes
    )
{
    PRC4_SHA1_HEADER CryptHeader = (PRC4_SHA1_HEADER) pbHeader;
    RC4_SHA1_HEADER TempHeader;
    BYTE LocalKey[A_SHA_DIGEST_LEN];
    RC4_KEYSTRUCT Rc4KeyStruct;

    RtlCopyMemory( TempHeader.Confounder, CryptHeader->Confounder, RC4_CONFOUNDER_LEN );

    //
    // HMAC the checksum into the key
    //
    shaHmac( pbKey, cbKey,
             CryptHeader->Checksum, A_SHA_DIGEST_LEN,
             NULL, 0,
             LocalKey );

    //
    // Use the generated key as the RC4 encryption key
    //
    rc4_key( &Rc4KeyStruct, A_SHA_DIGEST_LEN, LocalKey );

    //
    // Decrypt confounder and data
    //
    rc4( &Rc4KeyStruct, RC4_CONFOUNDER_LEN, TempHeader.Confounder );
    rc4( &Rc4KeyStruct, cbInput, pbInput );

    //
    // Now verify the checksum.
    //
    shaHmac( pbKey, cbKey,
             TempHeader.Confounder, RC4_CONFOUNDER_LEN,
             pbInput, cbInput,
             TempHeader.Checksum );

    //
    // Decrypt is successful only if checksum matches
    //
    return ( RtlEqualMemory(
                 TempHeader.Checksum,
                 CryptHeader->Checksum,
                 A_SHA_DIGEST_LEN) );
}

#if 0
BOOL FGetKey(LPCSTR pszFN, PUCHAR pData, PULONG pLen)
{
    HANDLE hFile;
    DWORD dwBytes;
    DWORD dwEncSize;
    BOOL bRet = FALSE;
    char szPassword[128];

    hFile = CreateFile(pszFN, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if (hFile != INVALID_HANDLE_VALUE)
    {
        PBYTE pEncBuffer;
        BYTE PasswordDigest[XC_DIGEST_LEN];
        BYTE MessageDigest[XC_DIGEST_LEN];

        GetPasswd(szPassword, sizeof szPassword);

        dwEncSize = GetFileSize(hFile, NULL);

        if (dwEncSize > (4 + XC_DIGEST_LEN))
        {
            if(*pLen < dwEncSize - (4 + XC_DIGEST_LEN))
                goto done;
            *pLen = dwEncSize - (4 + XC_DIGEST_LEN);

            //
            // Allocate memory for encryption buffer
            //
            pEncBuffer = (PBYTE)malloc(dwEncSize);

            //
            // Read the file data into the encryption buffer
            //
            if (ReadFile(hFile, pEncBuffer, dwEncSize, &dwBytes, NULL))
            {
                //
                // Check signature
                //
                if (*((DWORD*)pEncBuffer) == KEYFILE_ENCFILE_SIG)
                {
                    //
                    // Calculate a digest from the password
                    //
                    XCCalcDigest((PBYTE)szPassword, strlen(szPassword), PasswordDigest);

                    //
                    // Decrypt the message (includeding message digest) with the password digest
                    //
                    XCSymmetricEncDec((pEncBuffer + 4), *pLen + XC_DIGEST_LEN,
                        PasswordDigest, XC_DIGEST_LEN);

                    //
                    // Copy the plain text message
                    //
                    memcpy(pData, (pEncBuffer + 4 + XC_DIGEST_LEN), *pLen);

                    //
                    // Calculate message digest
                    //
                    XCCalcDigest(pData, *pLen, MessageDigest);

                    //
                    // Compare the calculated message digest with the decrypted digest
                    //
                    bRet = memcmp(MessageDigest, (pEncBuffer + 4),
                        XC_DIGEST_LEN) == 0;
                }
            }

            //
            // Free memory for encryption buffer
            free(pEncBuffer);
        }
done:
        CloseHandle(hFile);
    }

    return bRet;
}
#endif

BOOL FGetKey(LPCSTR pszFN, PUCHAR pMsgBuf, PULONG pLen)
{
    HANDLE hFile = INVALID_HANDLE_VALUE;
    DWORD dwBytes;
    BOOL bRet = FALSE;
    DWORD dwEncSize;
    PBYTE pEncBuffer = FALSE;
    PXC_ENCFILE_HEADER pEncHead;
    BYTE CalcDigest[XC_DIGEST_LEN];
    char szPassword[128];

    hFile = CreateFile(pszFN, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    
    if (hFile == INVALID_HANDLE_VALUE) {
//        ERROR_OUT("Cannot open from encrypted file %s", pszFN);
        goto CleanupAndExit;
    }

    GetPasswd(szPassword, sizeof szPassword);

    dwEncSize = GetFileSize(hFile, NULL);
    if (dwEncSize < sizeof(XC_ENCFILE_HEADER)) {
//        ERROR_OUT("Invalid encrypted file format %s", pszFN);
        goto CleanupAndExit;
    }

    pEncBuffer = (PBYTE)malloc(dwEncSize);
    pEncHead = (PXC_ENCFILE_HEADER)pEncBuffer;

    if (!ReadFile(hFile, pEncBuffer, dwEncSize, &dwBytes, NULL)) {
//        ERROR_OUT("Cannot read from file %s", pszFN);
        goto CleanupAndExit;
    }

    if (pEncHead->Sig != XC_ENCFILE_SIG || pEncHead->MsgLen != (dwEncSize - sizeof(XC_ENCFILE_HEADER))) {
//        ERROR_OUT("File %s is not an encrypted file", pszFN);
        goto CleanupAndExit;
    }
            
    
    if (*pLen < pEncHead->MsgLen) {
//        ERROR_OUT("Not enough space allocated to load the file");                        
        goto CleanupAndExit;
    }
    *pLen = pEncHead->MsgLen;
    
    //
    // Decrypt it
    //
    if (rc4HmacDecrypt((PBYTE)szPassword, strlen(szPassword), (pEncBuffer + sizeof(XC_ENCFILE_HEADER)), 
        pEncHead->MsgLen, (PBYTE)&(pEncHead->CryptHeader))) {

        //
        // Copy the plain text message
        //
        memcpy(pMsgBuf, (pEncBuffer + sizeof(XC_ENCFILE_HEADER)), pEncHead->MsgLen);

        //
        // Calculate message digest
        //
        XCCalcDigest(pMsgBuf, *pLen, CalcDigest);

        //
        // Compare the calculated message digest with the decrypted digest
        //
        if (memcmp(CalcDigest, pEncHead->MsgDigest, XC_DIGEST_LEN) == 0) {

            bRet = TRUE;
        
        } 
    }
    
    if (bRet == FALSE) {
//        ERROR_OUT("Decryption of file %s failed--invalid password", pszFN);
    }
    


CleanupAndExit:
    if (hFile != INVALID_HANDLE_VALUE) {
        CloseHandle(hFile);        
    }

    if (pEncBuffer != NULL) {
        free(pEncBuffer);
    }

    if (bRet) {
//        TRACE_OUT(TRACE_ALWAYS, "Successfully read encrypted file %s", pszFN);
    }

    return bRet;
}



int __cdecl main(int argc, char **argv)
{
    FILE *pfl;
    FILE *DecryptSrcFile;
    EEPROM_LAYOUT eep;
    XBOX_ENCRYPTED_SETTINGS *penc;
    XBOX_FACTORY_SETTINGS *pfac;
    XBOX_USER_SETTINGS *pusr;
    UCHAR rgbKey[XBOX_KEY_LENGTH];
    UCHAR rgbkey2[XC_SERVICE_DIGEST_SIZE];
    UCHAR rgbBigKey[76];
    ULONG cb;
    FILETIME ft;
    BOOL fLockHD = FALSE;
    BOOL fLockHDZeroKey = FALSE;
    BOOL fUseDefEepromKey = FALSE;
    ULONG ulGameRegion = XC_GAME_REGION_NA;
    LPCSTR szMACAddr = NULL;
    LPCSTR szDecryptFileName = NULL;
    int i;
    ULONG ul;
    ULONG ulAVRegion = AV_STANDARD_NTSC_M | AV_FLAGS_60Hz;
        

    if(argc < 2) {
        fprintf(stderr, "usage: mkeeprom [-na] [-namanuf] [-lockhd] [-lockhdz] [-defkey] [-mac addr] [-dec srcfile.bin] eeprom.bin [key.xck]\n\n\n");
        fprintf(stderr, " -na        North American game region\n");
        fprintf(stderr, " -namanuf   North American + Manufacturing game regions\n");
        fprintf(stderr, " -ja        Japan game region + NTSC-J\n");
        fprintf(stderr, " -row       Rest of the world game region + PAL-I + 50Hz\n");
        fprintf(stderr, " -lockhd    Lock HD with sequential key\n");
        fprintf(stderr, " -lockhdz   Lock HD with zero key\n");
        fprintf(stderr, " -defkey    Lock EEPROM with default devkit key\n");
        fprintf(stderr, " -mac       Embed the specified MAC address 'addr'\n");
        fprintf(stderr, " -dec       Decrypt the EEPROM file 'srcfile.bin' and write as 'eeprom.bin'\n");

        return 1;
    }

    while(argc >= 2 && argv[1][0] == '-') {
        ++argv;
        --argc;
        if(0 == _stricmp(*argv, "-na"))
            ulGameRegion = XC_GAME_REGION_NA;
        if(0 == _stricmp(*argv, "-ja")) {
            ulGameRegion = XC_GAME_REGION_JAPAN;
            ulAVRegion = AV_STANDARD_NTSC_J | AV_FLAGS_60Hz;
        } else if(0 == _stricmp(*argv, "-row")) {
            ulGameRegion = XC_GAME_REGION_RESTOFWORLD;
            ulAVRegion = AV_STANDARD_PAL_I | AV_FLAGS_50Hz;
        } else if(0 == _stricmp(*argv, "-testrgn"))
            ulGameRegion = XC_GAME_REGION_INTERNAL_TEST;
        else if(0 == _stricmp(*argv, "-namanuf"))
            ulGameRegion = XC_GAME_REGION_MANUFACTURING | XC_GAME_REGION_NA;
        else if(0 == _stricmp(*argv, "-lockhd"))
            fLockHD = TRUE;
        else if(0 == _stricmp(*argv, "-lockhdz"))
            fLockHDZeroKey = TRUE;
        else if(0 == _stricmp(*argv, "-mac")) {
            if(argc < 2) {
badmac:
                fprintf(stderr, "MAC address is invalid\n");
                return 1;
            }
            szMACAddr = *++argv;
            --argc;
        } else if(0 == _stricmp(*argv, "-dec")) {
            szDecryptFileName = *++argv;
            --argc;
                
        } else if(0 == _stricmp(*argv, "-defkey"))
            ++fUseDefEepromKey;
    }

    //
    // Print out some current settings
    //
    printf("Game Region: 0x%08x\n", ulGameRegion);
    printf("AV Region:   0x%08x\n", ulAVRegion);


    memset(&eep, 0, sizeof eep);
    penc = (XBOX_ENCRYPTED_SETTINGS *)eep.EncryptedSection;
    penc->GameRegion = ulGameRegion;
    if(fLockHD)
        memcpy(penc->HDKey, "\000\001\002\003\004\005\006\007\010\011\012\013\014\015\016\017", 16);

    if (fLockHDZeroKey) {
        memset(penc->HDKey, 0, 16);
        fLockHD = TRUE;
    }

    pfac = (XBOX_FACTORY_SETTINGS *)eep.FactorySection;
    pfac->AVRegion = ulAVRegion;
    if(szMACAddr) {
        for(i = 0; i < sizeof pfac->EthernetAddr; ++i) {
            if(!szMACAddr[0] || !szMACAddr[1])
                goto badmac;
            if(0 == sscanf(szMACAddr, "%02X", &ul))
                goto badmac;
            pfac->EthernetAddr[i] = (UCHAR)ul;
            szMACAddr += 2;
        }
    }
    pfac->Checksum = ~XConfigChecksum(pfac, sizeof *pfac);
    
    
    pusr = (XBOX_USER_SETTINGS *)eep.UserConfigSection;



    pusr->Checksum = ~XConfigChecksum(pusr, sizeof *pusr);

    pfl = fopen(argv[1], "wb");
    if(!pfl) {
        fprintf(stderr, "could not open %s\n", argv[1]);
        return 1;
    }

    if(argc > 2) {
        cb = sizeof rgbBigKey;
        if(!FGetKey(argv[2], rgbBigKey, &cb) || cb != sizeof rgbBigKey ||
            *(PUSHORT)rgbBigKey != 3)
        {
            fprintf(stderr, "unable to read key\n");
            return 1;
        }
        memcpy(rgbKey, rgbBigKey + 52, 16);
        cb = 16;
    } else if(fUseDefEepromKey) {
        memcpy(rgbKey, g_rgbDefEepromKey, 16);
        cb = 16;
    } else
        cb = 0;

    if(cb) {
        GetSystemTimeAsFileTime(&ft);
        XCSymmetricEncDec(penc->Confounder, sizeof penc->Confounder,
            (PUCHAR)&ft, sizeof ft);
        
        XcHMAC(rgbKey, XBOX_KEY_LENGTH, penc->Confounder,
            sizeof penc->Confounder, penc->HDKey, sizeof penc->HDKey +
            sizeof penc->GameRegion, penc->Checksum);
        
        XcHMAC(rgbKey, XBOX_KEY_LENGTH, penc->Checksum,
            XC_SERVICE_DIGEST_SIZE, NULL, 0, rgbkey2);
        
        XCSymmetricEncDec(penc->Confounder, sizeof *penc -
            sizeof penc->Checksum, rgbkey2, sizeof rgbkey2);
    }

    if (szDecryptFileName != NULL) {
        //
        // Open and read the contents of the source file
        //

        DecryptSrcFile = fopen(szDecryptFileName, "rb");
        
        if(!DecryptSrcFile) {
            fprintf(stderr, "could not open %s\n", szDecryptFileName);
            return 1;
        }

        fread(&eep, sizeof(eep), 1, DecryptSrcFile);

        //
        // Decrypt the section
        //

        if (!rc4HmacDecrypt(rgbKey, XBOX_KEY_LENGTH, penc->HDKey, sizeof(penc->HDKey) + sizeof(penc->GameRegion), penc->Checksum)) {
            fprintf(stderr, "could not decrypt %s\n", szDecryptFileName);
        }
        
        fclose(DecryptSrcFile);
    } 

    memset(rgbKey, 0, sizeof rgbKey);
    memset(rgbkey2, 0, sizeof rgbkey2);

    fwrite(&eep, sizeof eep, 1, pfl);
    fclose(pfl);

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\ntsdexts\dllsext.c ===
VOID DumpImage(
    ULONG_PTR xBase,
    BOOL DoHeaders,
    BOOL DoSections
    );

typedef enum {
    Memory = 1,
    Load = 2,
    Init = 3
} ELOAD_ORDER;

VOID
DllsExtension(
    PCSTR lpArgumentString,
    PPEB ProcessPeb
    )
{
    BOOL b;
    PLDR_DATA_TABLE_ENTRY pLdrEntry;
    LDR_DATA_TABLE_ENTRY LdrEntry;
    PEB_LDR_DATA PebLdrData;
    PLIST_ENTRY Next;
    WCHAR StringData[MAX_PATH+1];
    BOOL SingleEntry;
    BOOL DoHeaders;
    BOOL DoSections;
    BOOL DoAll;
    PSTR lpArgs = (PSTR)lpArgumentString;
    PSTR p;
    INT_PTR addrContaining = 0;
    ELOAD_ORDER OrderList = Load;
    PLIST_ENTRY OrderModuleListStart;

    SingleEntry = FALSE;
    DoAll = FALSE;
    DoHeaders = FALSE;
    DoSections = FALSE;

#if 0
    while ( lpArgumentString != NULL && *lpArgumentString ) {
        if (*lpArgumentString != ' ') {
            sscanf(lpArgumentString,"%lx",&pLdrEntry);
            SingleEntry = TRUE;
            goto dumpsingleentry;
            }

        lpArgumentString++;
        }
#endif

    while (*lpArgs) {

        while (isspace(*lpArgs)) {
            lpArgs++;
            }

        if (*lpArgs == '/' || *lpArgs == '-') {

            // process switch

            switch (*++lpArgs) {

                case 'a':   // dump everything we can
                case 'A':
                    ++lpArgs;
                    DoAll = TRUE;
                    break;

                case 'c':   // dump only the dll containing the specified address
                case 'C':
                    lpArgs += 2;    // step over the c and the space.
                    addrContaining = GetExpression(lpArgs);

                    while (*lpArgs && (!isspace(*lpArgs))) {
                        lpArgs++;
                    }

                    if (addrContaining != 0) {
                        dprintf("Dump dll containing 0x%p:\n", addrContaining);
                    } else {
                        dprintf("-c flag requires and address arguement\n");
                        return;
                    }
                    break;

                default: // invalid switch

                case 'h':   // help
                case 'H':
                case '?':

                    dprintf("Usage: dlls [options] [address]\n");
                    dprintf("\n");
                    dprintf("Displays loader table entries.  Optionally\n");
                    dprintf("dumps image and section headers.\n");
                    dprintf("\n");
                    dprintf("Options:\n");
                    dprintf("\n");
                    dprintf("   -a      Dump everything\n");
                    dprintf("   -c nnn  Dump dll containing address nnn\n");
                    dprintf("   -f      Dump file headers\n");
                    dprintf("   -i      Dump dll's in Init order\n");
                    dprintf("   -l      Dump dll's in Load order (the default)\n");
                    dprintf("   -m      Dump dll's in Memory order\n");
                    dprintf("   -s      Dump section headers\n");
                    dprintf("\n");

                    return;

                case 'f':
                case 'F':
                    ++lpArgs;
                    DoAll = FALSE;
                    DoHeaders = TRUE;
                    break;

                case 'm':   // dump in memory order
                case 'M':
                    ++lpArgs;
                    OrderList = Memory;
                    break;

                case 'i':   // dump in init order
                case 'I':
                    ++lpArgs;
                    OrderList = Init;
                    break;

                case 'l':   // dump in load order
                case 'L':
                    ++lpArgs;
                    OrderList = Load;
                    break;

                case 's':
                case 'S':
                    ++lpArgs;
                    DoAll = FALSE;
                    DoSections = TRUE;
                    break;

                }

            }
        else if (*lpArgs) {
            CHAR c;

            if (SingleEntry) {
                dprintf("Invalid extra argument\n");
                return;
                }

            p = lpArgs;
            while (*p && !isspace(*p)) {
                p++;
                }
            c = *p;
            *p = 0;

            pLdrEntry = (PLDR_DATA_TABLE_ENTRY)GetExpression(lpArgs);
            SingleEntry = TRUE;

            *p = c;
            lpArgs=p;

            }

        }

    if (SingleEntry) {
        goto dumpsingleentry;
        }

    //
    // Capture PebLdrData
    //

    b = ReadMemory( (ULONG_PTR)(ProcessPeb->Ldr),
                    &PebLdrData,
                    sizeof( PebLdrData ),
                    NULL
                  );
    if (!b) {
        dprintf( "    Unabled to read PebLdrData\n" );
        return;
        }

    //
    // Walk through the loaded module table and display all ldr data
    //

    switch (OrderList) {
        case Memory:
            OrderModuleListStart = &ProcessPeb->Ldr->InMemoryOrderModuleList;
            Next = (PLIST_ENTRY)PebLdrData.InMemoryOrderModuleList.Flink;
            break;

        case Init:
            OrderModuleListStart = &ProcessPeb->Ldr->InInitializationOrderModuleList;
            Next = (PLIST_ENTRY)PebLdrData.InInitializationOrderModuleList.Flink;
            break;

        default:
        case Load:
            OrderModuleListStart = &ProcessPeb->Ldr->InLoadOrderModuleList;
            Next = (PLIST_ENTRY)PebLdrData.InLoadOrderModuleList.Flink;
            break;
    }

    while (Next != OrderModuleListStart) {
        if (CheckControlC()) {
            return;
            }

        switch (OrderList) {
            case Memory:
                pLdrEntry = CONTAINING_RECORD(Next,LDR_DATA_TABLE_ENTRY,InMemoryOrderLinks);
                break;

            case Init:
                pLdrEntry = CONTAINING_RECORD(Next,LDR_DATA_TABLE_ENTRY,InInitializationOrderLinks);
                break;

            default:
            case Load:
                pLdrEntry = CONTAINING_RECORD(Next,LDR_DATA_TABLE_ENTRY,InLoadOrderLinks);
                break;
        }

        //
        // Capture LdrEntry
        //
dumpsingleentry:

        b = ReadMemory( (ULONG_PTR)pLdrEntry,
                        &LdrEntry,
                        sizeof( LdrEntry ),
                        NULL
                      );

        if (!b) {
            dprintf( "    Unabled to read Ldr Entry at %x\n", pLdrEntry );
            return;
        }

        ZeroMemory( StringData, sizeof( StringData ) );
        b = ReadMemory( (ULONG_PTR)(LdrEntry.FullDllName.Buffer),
                        StringData,
                        LdrEntry.FullDllName.Length,
                        NULL
                      );
        if (!b) {
            dprintf( "    Unabled to read Module Name\n" );
            ZeroMemory( StringData, sizeof( StringData ) );
        }

        //
        // Dump the ldr entry data
        // (dump all the entries if no containing address specified)
        //
        if ((addrContaining == 0) ||
            (((DWORD_PTR)LdrEntry.DllBase <= (DWORD_PTR)addrContaining) &&
             ((DWORD_PTR)addrContaining <= ((DWORD_PTR)LdrEntry.DllBase + (DWORD_PTR)LdrEntry.SizeOfImage))
            )
           ) {
            dprintf( "\n" );
            dprintf( "0x%08x: %ws\n", pLdrEntry, StringData[0] ? StringData : L"Unknown Module" );
            dprintf( "      Base   0x%08x  EntryPoint  0x%08x  Size        0x%08x\n",
                     LdrEntry.DllBase,
                     LdrEntry.EntryPoint,
                     LdrEntry.SizeOfImage
                   );
            dprintf( "      Flags  0x%08x  LoadCount   0x%08x  TlsIndex    0x%08x\n",
                     LdrEntry.Flags,
                     LdrEntry.LoadCount,
                     LdrEntry.TlsIndex
                   );

            if (LdrEntry.Flags & LDRP_STATIC_LINK) {
                dprintf( "             LDRP_STATIC_LINK\n" );
                }
            if (LdrEntry.Flags & LDRP_IMAGE_DLL) {
                dprintf( "             LDRP_IMAGE_DLL\n" );
                }
            if (LdrEntry.Flags & LDRP_LOAD_IN_PROGRESS) {
                dprintf( "             LDRP_LOAD_IN_PROGRESS\n" );
                }
            if (LdrEntry.Flags & LDRP_UNLOAD_IN_PROGRESS) {
                dprintf( "             LDRP_UNLOAD_IN_PROGRESS\n" );
                }
            if (LdrEntry.Flags & LDRP_ENTRY_PROCESSED) {
                dprintf( "             LDRP_ENTRY_PROCESSED\n" );
                }
            if (LdrEntry.Flags & LDRP_ENTRY_INSERTED) {
                dprintf( "             LDRP_ENTRY_INSERTED\n" );
                }
            if (LdrEntry.Flags & LDRP_CURRENT_LOAD) {
                dprintf( "             LDRP_CURRENT_LOAD\n" );
                }
            if (LdrEntry.Flags & LDRP_FAILED_BUILTIN_LOAD) {
                dprintf( "             LDRP_FAILED_BUILTIN_LOAD\n" );
                }
            if (LdrEntry.Flags & LDRP_DONT_CALL_FOR_THREADS) {
                dprintf( "             LDRP_DONT_CALL_FOR_THREADS\n" );
                }
            if (LdrEntry.Flags & LDRP_PROCESS_ATTACH_CALLED) {
                dprintf( "             LDRP_PROCESS_ATTACH_CALLED\n" );
                }
            if (LdrEntry.Flags & LDRP_DEBUG_SYMBOLS_LOADED) {
                dprintf( "             LDRP_DEBUG_SYMBOLS_LOADED\n" );
                }
            if (LdrEntry.Flags & LDRP_IMAGE_NOT_AT_BASE) {
                dprintf( "             LDRP_IMAGE_NOT_AT_BASE\n" );
                }
            if (LdrEntry.Flags & LDRP_WX86_IGNORE_MACHINETYPE) {
                dprintf( "             LDRP_WX86_IGNORE_MACHINETYPE\n" );
                }
        }

        if (DoAll || DoHeaders || DoSections) {
            DumpImage( (ULONG_PTR)LdrEntry.DllBase,
                       DoAll || DoHeaders,
                       DoAll || DoSections );
        }

        if (SingleEntry) {
            return;
        }

        switch (OrderList) {
            case Memory:
                Next = LdrEntry.InMemoryOrderLinks.Flink;
                break;

            case Init:
                Next = LdrEntry.InInitializationOrderLinks.Flink;
                break;

            default:
            case Load:
                Next = LdrEntry.InLoadOrderLinks.Flink;
                break;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\ntsdexts\makefile.inc ===
ntsdexts.c: ntsdextp.h \
            heapext.c  \
	    heappagx.c \
            atomext.c  \
            gflagext.c \
            kuserext.c \
            pebext.c   \
            dllsext.c  \
            imageext.c \
            secexts.c  \
            leak.c
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\ntsdexts\leak.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    ntsdexts.c

Abstract:

    This function contains the default ntsd debugger extensions

Author:


Revision History:

--*/


//
// Lists threads sorted by CPU time consumed, in order to 
// track runaway threads
//

typedef struct _INTERESTING_THREAD_INFO {
    ULONG_PTR       ThreadId ;
    ULONG_PTR       Flags ;
    LARGE_INTEGER   UserTime ;
    LARGE_INTEGER   KernelTime ;
    LARGE_INTEGER   ElapsedTime ;
} INTERESTING_THREAD_INFO, * PINTERESTING_THREAD_INFO ;

#define ITI_USER_DONE       0x00000001
#define ITI_KERNEL_DONE     0x00000002
#define ITI_ELAPSED_DONE    0x00000004

DECLARE_API( runaway )
{
    PROCESS_BASIC_INFORMATION ProcessInfo ;
    PSYSTEM_PROCESS_INFORMATION SystemInfo ;
    PSYSTEM_PROCESS_INFORMATION Walk ;
    PSYSTEM_THREAD_INFORMATION ThreadInfo ;
    PINTERESTING_THREAD_INFO Threads ;
    NTSTATUS Status ;
    ULONG Flags = 1 ;
    ULONG i, j, Found ;
    LARGE_INTEGER Now ;
    LARGE_INTEGER Compare ;
    TIME_FIELDS Time ;

    INIT_API();

    sscanf( lpArgumentString, "%x", &Flags );

    Status = NtQueryInformationProcess(
                    hCurrentProcess,
                    ProcessBasicInformation,
                    &ProcessInfo,
                    sizeof( ProcessInfo ),
                    NULL );

    if ( !NT_SUCCESS( Status ) )
    {
        dprintf( "could not get process information, %d\n",
                 RtlNtStatusToDosError( Status ) );
        return;
    }

    SystemInfo = RtlAllocateHeap(
                    RtlProcessHeap(),
                    0,
                    1024 * sizeof( SYSTEM_PROCESS_INFORMATION ) );

    if ( !SystemInfo )
    {
        dprintf( "not enough memory\n" );
        return;
    }

    Status = NtQuerySystemInformation(
                    SystemProcessInformation,
                    SystemInfo,
                    1024 * sizeof( SYSTEM_PROCESS_INFORMATION ),
                    NULL );

    if ( !NT_SUCCESS( Status ) )
    {
        dprintf( "unable to get system information\n" );

        RtlFreeHeap(
                RtlProcessHeap(),
                0,
                SystemInfo );

        return ;
    }

    //
    // First, find the process:
    //
    
    Walk = SystemInfo ;

    while ( HandleToUlong( Walk->UniqueProcessId ) != ProcessInfo.UniqueProcessId )
    {
        if ( Walk->NextEntryOffset == 0 )
        {
            Walk = NULL ;
            break;
        }

        Walk = (PSYSTEM_PROCESS_INFORMATION) ((PUCHAR) Walk + Walk->NextEntryOffset );

    }

    if ( !Walk )
    {
        dprintf( "unable to find process\n" );

        RtlFreeHeap( RtlProcessHeap(), 0, SystemInfo );

        return ;
    }

    //
    // Now, walk the threads
    //

    ThreadInfo = (PSYSTEM_THREAD_INFORMATION) (Walk + 1);

    Threads = RtlAllocateHeap( 
                    RtlProcessHeap(),
                    0,
                    sizeof( INTERESTING_THREAD_INFO ) * Walk->NumberOfThreads );

    if ( !Threads )
    {
        dprintf( "not enough memory\n" );

        RtlFreeHeap(
                RtlProcessHeap(),
                0,
                SystemInfo );

        return ;
    }

    GetSystemTimeAsFileTime( (LPFILETIME) &Now );

    for ( i = 0 ; i < Walk->NumberOfThreads ; i++ )
    {
        Threads[ i ].Flags = 0 ;
        Threads[ i ].ThreadId = HandleToUlong( ThreadInfo[ i ].ClientId.UniqueThread );
        Threads[ i ].ElapsedTime.QuadPart = Now.QuadPart - ThreadInfo[ i ].CreateTime.QuadPart ;
        Threads[ i ].KernelTime = ThreadInfo[ i ].KernelTime ;
        Threads[ i ].UserTime = ThreadInfo[ i ].UserTime ;

    }

    //
    // Scan through the list of threads (in an ugly, bubble-ish sort
    // of way), and display the threads in order of time, once per time
    // field, by way of the flags:
    //

    if ( Flags & ITI_USER_DONE )
    {
        j = Walk->NumberOfThreads ;

        Found = 0 ;
        
        dprintf( " User Mode Time\n" );
        dprintf( " Thread    Time\n" );

        while ( j-- )
        {
            Compare.QuadPart = 0 ;
            for ( i = 0 ; i < Walk->NumberOfThreads ; i++ )
            {
                if ( ( ( Threads[ i ].Flags & ITI_USER_DONE ) == 0 ) && 
                     ( Threads[ i ].UserTime.QuadPart >= Compare.QuadPart ) )
                {
                    Compare.QuadPart = Threads[ i ].UserTime.QuadPart ;
                    Found = i ;
                }
            }

            Threads[ Found ].Flags |= ITI_USER_DONE ;

            RtlTimeToElapsedTimeFields( &Compare, &Time );

            dprintf( " %-3x      %3ld:%02ld:%02ld.%04ld\n",
                        Threads[ Found ].ThreadId,
                        Time.Hour,
                        Time.Minute,
                        Time.Second,
                        Time.Milliseconds );

        }

    }

    if ( Flags & ITI_KERNEL_DONE )
    {
        j = Walk->NumberOfThreads ;

        Found = 0 ;
        
        dprintf( " Kernel Mode Time\n" );
        dprintf( " Thread    Time\n" );

        while ( j-- )
        {
            Compare.QuadPart = 0 ;
            for ( i = 0 ; i < Walk->NumberOfThreads ; i++ )
            {
                if ( ( ( Threads[ i ].Flags & ITI_KERNEL_DONE ) == 0 ) && 
                     ( Threads[ i ].KernelTime.QuadPart >= Compare.QuadPart ) )
                {
                    Compare.QuadPart = Threads[ i ].KernelTime.QuadPart ;
                    Found = i ;
                }
            }

            Threads[ Found ].Flags |= ITI_KERNEL_DONE ;

            RtlTimeToElapsedTimeFields( &Compare, &Time );

            dprintf( " %-3x      %3ld:%02ld:%02ld.%04ld\n",
                        Threads[ Found ].ThreadId,
                        Time.Hour,
                        Time.Minute,
                        Time.Second,
                        Time.Milliseconds );

        }

    }

    if ( Flags & ITI_ELAPSED_DONE )
    {
        j = Walk->NumberOfThreads ;

        Found = 0 ;
        
        dprintf( " Elapsed Time\n" );
        dprintf( " Thread    Time\n" );

        while ( j-- )
        {
            Compare.QuadPart = 0 ;
            for ( i = 0 ; i < Walk->NumberOfThreads ; i++ )
            {
                if ( ( ( Threads[ i ].Flags & ITI_ELAPSED_DONE ) == 0 ) && 
                     ( Threads[ i ].ElapsedTime.QuadPart >= Compare.QuadPart ) )
                {
                    Compare.QuadPart = Threads[ i ].ElapsedTime.QuadPart ;
                    Found = i ;
                }
            }

            Threads[ Found ].Flags |= ITI_ELAPSED_DONE ;

            RtlTimeToElapsedTimeFields( &Compare, &Time );

            dprintf( " %-3x      %3ld:%02ld:%02ld.%04ld\n",
                        Threads[ Found ].ThreadId,
                        Time.Hour,
                        Time.Minute,
                        Time.Second,
                        Time.Milliseconds );

        }

    }

    if ( SystemInfo )
    {
        RtlFreeHeap( RtlProcessHeap(), 0, SystemInfo );
    }


}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\ntsdexts\ntsdextp.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    ntsdextp.h

Abstract:

    Common header file for NTSDEXTS component source files.

Author:

    Steve Wood (stevewo) 21-Feb-1995

Revision History:

--*/

#include <ntos.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
//#include <ntsdexts.h>

#define NOEXTAPI
#include <wdbgexts.h>
#undef DECLARE_API

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <wchar.h>
#include <heap.h>
#include <atom.h>
#include <stktrace.h>
#include <winsock2.h>
#include <lmerr.h>

#include <ntcsrsrv.h>

#define move(dst, src)\
try {\
    ReadMemory((LPVOID) (src), &(dst), sizeof(dst), NULL);\
} except (EXCEPTION_EXECUTE_HANDLER) {\
    return;\
}
#define moveBlock(dst, src, size)\
try {\
    ReadMemory((LPVOID) (src), &(dst), (size), NULL);\
} except (EXCEPTION_EXECUTE_HANDLER) {\
    return;\
}

CHAR igrepLastPattern[256];
DWORD_PTR igrepSearchStartAddress;
DWORD_PTR igrepLastPc;

#ifdef __cplusplus
#define CPPMOD extern "C"
#else
#define CPPMOD
#endif

#define DECLARE_API(s)                          \
    CPPMOD VOID                                 \
    s(                                          \
        HANDLE hCurrentProcess,                 \
        HANDLE hCurrentThread,                  \
        DWORD_PTR dwCurrentPc,                  \
        PWINDBG_EXTENSION_APIS lpExtensionApis, \
        LPSTR lpArgumentString                  \
     )

#define INIT_API() {                            \
    ExtensionApis = *lpExtensionApis;           \
    ExtensionCurrentProcess = hCurrentProcess;  \
    }

#define dprintf                 (ExtensionApis.lpOutputRoutine)
#define GetExpression           (ExtensionApis.lpGetExpressionRoutine)
#define GetSymbol               (ExtensionApis.lpGetSymbolRoutine)
#define Disasm                  (ExtensionApis.lpDisasmRoutine)
#define CheckControlC           (ExtensionApis.lpCheckControlCRoutine)
#define ReadMemory(a,b,c,d) \
    ((ExtensionApis.nSize == sizeof(WINDBG_OLD_EXTENSION_APIS)) ? \
    ReadProcessMemory( ExtensionCurrentProcess, (LPCVOID)(a), (b), (c), (d) ) \
  : ExtensionApis.lpReadProcessMemoryRoutine( (ULONG_PTR)(a), (b), (c), (d) ))

#define WriteMemory(a,b,c,d) \
    ((ExtensionApis.nSize == sizeof(WINDBG_OLD_EXTENSION_APIS)) ? \
    WriteProcessMemory( ExtensionCurrentProcess, (LPVOID)(a), (LPVOID)(b), (c), (d) ) \
  : ExtensionApis.lpWriteProcessMemoryRoutine( (ULONG_PTR)(a), (LPVOID)(b), (c), (d) ))

#define Ioctl                   (ExtensionApis.lpIoctlRoutine)

#ifndef malloc
#define malloc( n ) HeapAlloc( GetProcessHeap(), 0, (n) )
#endif
#ifndef free
#define free( p ) HeapFree( GetProcessHeap(), 0, (p) )
#endif

extern WINDBG_EXTENSION_APIS ExtensionApis;
extern HANDLE ExtensionCurrentProcess;

__inline VOID
GetTebAddress(
    PULONGLONG Address
    )
{
    GET_TEB_ADDRESS gpt;
    gpt.Address = 0;
    Ioctl(IG_GET_TEB_ADDRESS, (PVOID)&gpt, sizeof(gpt));
    *Address = gpt.Address;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\ntsdexts\ntsdexts.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    ntsdexts.c

Abstract:

    This function contains the default ntsd debugger extensions

Author:

    Mark Lucovsky (markl) 09-Apr-1991

Revision History:

--*/

#include "ntsdextp.h"

WINDBG_EXTENSION_APIS ExtensionApis;
HANDLE ExtensionCurrentProcess;


NTSTATUS
QueryTebAddress(
    HANDLE hCurrentThread,
    PULONGLONG Teb
    )
{
    NTSTATUS Status = STATUS_UNSUCCESSFUL;
    THREAD_BASIC_INFORMATION ThreadInformation;
    ULONGLONG Address;

    if (ExtensionApis.nSize >= FIELD_OFFSET(WINDBG_EXTENSION_APIS, lpIoctlRoutine)) {
        Address = 0;
        GetTebAddress(&Address);
        if (Address) {
            *Teb = Address;
            Status = STATUS_SUCCESS;
        }
    }

    if (!NT_SUCCESS(Status)) {
        Status = NtQueryInformationThread( hCurrentThread,
                                           ThreadBasicInformation,
                                           &ThreadInformation,
                                           sizeof( ThreadInformation ),
                                           NULL
                                         );

        if (NT_SUCCESS( Status )) {
            *Teb = (ULONGLONG)ThreadInformation.TebBaseAddress;
        }
    }
    return Status;
}

NTSTATUS
QueryPebAddress(
    HANDLE hCurrentThread,
    PULONGLONG Peb
    )
{
    PROCESS_BASIC_INFORMATION ProcessInformation;
    ULONGLONG Address;
    NTSTATUS Status = STATUS_UNSUCCESSFUL;
    DWORD cb;
    TEB Teb;

    if (ExtensionApis.nSize >= FIELD_OFFSET(WINDBG_EXTENSION_APIS, lpIoctlRoutine)) {
        //
        // query the debugger instead of the system
        //
        Address = 0;
        QueryTebAddress(hCurrentThread, &Address);
        if (Address) {
            ReadMemory(Address, &Teb, sizeof(Teb), &cb);
            *Peb = (ULONGLONG)Teb.ProcessEnvironmentBlock;
            Status = STATUS_SUCCESS;
        }
    }

    if (!NT_SUCCESS(Status)) {

        Status = NtQueryInformationProcess( ExtensionCurrentProcess,
                                            ProcessBasicInformation,
                                            &ProcessInformation,
                                            sizeof( ProcessInformation ),
                                            NULL
                                          );
        if (NT_SUCCESS( Status )) {
            *Peb = (ULONGLONG)ProcessInformation.PebBaseAddress;
        }

    }
    return Status;
}

BOOL
QueryPeb(
    HANDLE hCurrentThread,
    PPEB ThePeb
    )
{
    BOOL b;
    NTSTATUS Status;
    PROCESS_BASIC_INFORMATION ProcessInformation;
    ULONGLONG PebAddress;

    Status = QueryPebAddress(hCurrentThread, &PebAddress);

    if (!NT_SUCCESS( Status )) {
        b = FALSE;
    } else {
        b = ReadMemory( PebAddress,
                        ThePeb,
                        sizeof(*ThePeb),
                        NULL
                      );
    }

    if ( !b ) {
        dprintf("    Unable to read Process PEB\n" );
        memset( ThePeb, 0, sizeof( *ThePeb ) );
    }

    return b;
}


VOID
DecodeError(
    PSTR    Banner,
    ULONG   Code,
    BOOL    TreatAsStatus
    )
{
    HANDLE Dll ;
    PSTR Source ;
    UCHAR Message[ 512 ];
    PUCHAR s;

    if ( !TreatAsStatus )
    {
        //
        // The value "type" is not known.  Try and figure out what it
        // is.
        //

        if ( (Code & 0xC0000000) == 0xC0000000 )
        {
            //
            // Easy:  NTSTATUS failure case
            //

            Dll = GetModuleHandle( "NTDLL.DLL" );

            Source = "NTSTATUS" ;

            TreatAsStatus = TRUE ;

        }
        else if ( ( Code & 0xF0000000 ) == 0xD0000000 )
        {
            //
            // HRESULT from NTSTATUS
            //

            Dll = GetModuleHandle( "NTDLL.DLL" );

            Source = "NTSTATUS" ;

            Code &= 0xCFFFFFFF ;

            TreatAsStatus = TRUE ;

        }
        else if ( ( Code & 0x80000000 ) == 0x80000000 )
        {
            //
            // Note, this can overlap with NTSTATUS warning area.  In that
            // case, force the NTSTATUS.
            //

            Dll = GetModuleHandle( "KERNEL32.DLL" );

            Source = "HRESULT" ;

        }
        else
        {
            //
            // Sign bit is off.  Explore some known ranges:
            //

            if ( (Code >= WSABASEERR) && (Code <= WSABASEERR + 1000 ))
            {
                Dll = LoadLibrary( "wsock32.dll" );

                Source = "Winsock" ;
            }
            else if ( ( Code >= NERR_BASE ) && ( Code <= MAX_NERR ) )
            {
                Dll = LoadLibrary( "netmsg.dll" );

                Source = "NetAPI" ;
            }
            else
            {
                Dll = GetModuleHandle( "KERNEL32.DLL" );

                Source = "Win32" ;
            }

        }
    }
    else
    {
        Dll = GetModuleHandle( "NTDLL.DLL" );

        Source = "NTSTATUS" ;
    }

    if (!FormatMessage(  FORMAT_MESSAGE_IGNORE_INSERTS |
                    FORMAT_MESSAGE_FROM_HMODULE,
                    Dll,
                    Code,
                    0,
                    Message,
                    sizeof( Message ),
                    NULL ) )
    {
        strcpy( Message, "No mapped error code" );
    }

    s = Message ;

    while (*s) {
        if (*s < ' ') {
            *s = ' ';
            }
        s++;
        }

    if ( !TreatAsStatus )
    {
        dprintf( "%s: (%s) %#x (%u) - %s\n",
                    Banner,
                    Source,
                    Code,
                    Code,
                    Message );

    }
    else
    {
        dprintf( "%s: (%s) %#x - %s\n",
                    Banner,
                    Source,
                    Code,
                    Message );

    }

}

DECLARE_API( error )
{
    ULONG err ;

    INIT_API();

    err = (ULONG) GetExpression( lpArgumentString );

    DecodeError( "Error code", err, FALSE );

}


DECLARE_API( gle )
{
    NTSTATUS Status;
    THREAD_BASIC_INFORMATION ThreadInformation;
    ULONGLONG Address;
    TEB Teb;

    INIT_API();

    Status = QueryTebAddress(hCurrentThread, &Address);

    if (NT_SUCCESS( Status )) {
        if (ReadMemory( Address,
                        &Teb,
                        sizeof(Teb),
                        NULL
                      )
           ) {

            DecodeError( "LastErrorValue", Teb.LastErrorValue, FALSE );

            DecodeError( "LastStatusValue", Teb.LastStatusValue, TRUE );

            return ;

            }

        }

    dprintf("Unable to read current thread's TEB\n" );
    return;
}

DECLARE_API( version )
{
    OSVERSIONINFOA VersionInformation;
    HKEY hkey;
    DWORD cb, dwType;
    CHAR szCurrentType[128];
    CHAR szCSDString[3+128];

    INIT_API();

    VersionInformation.dwOSVersionInfoSize = sizeof(VersionInformation);
    if (!GetVersionEx( &VersionInformation )) {
        dprintf("GetVersionEx failed - %u\n", GetLastError());
        return;
        }

    szCurrentType[0] = '\0';
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                     "Software\\Microsoft\\Windows NT\\CurrentVersion",
                     0,
                     KEY_READ,
                     &hkey
                    ) == NO_ERROR
       ) {
        cb = sizeof(szCurrentType);
        if (RegQueryValueEx(hkey, "CurrentType", NULL, &dwType, szCurrentType, &cb ) != 0) {
            szCurrentType[0] = '\0';
            }
        }
    RegCloseKey(hkey);

    if (VersionInformation.szCSDVersion[0]) {
        sprintf(szCSDString, ": %s", VersionInformation.szCSDVersion);
        }
    else {
        szCSDString[0] = '\0';
        }

    dprintf("Version %d.%d (Build %d%s) %s\n",
          VersionInformation.dwMajorVersion,
          VersionInformation.dwMinorVersion,
          VersionInformation.dwBuildNumber,
          szCSDString,
          szCurrentType
         );
    return;
}

DECLARE_API( help )
{
    INIT_API();

    while (*lpArgumentString == ' ')
        lpArgumentString++;

    if (*lpArgumentString == '\0') {
        dprintf("ntsdexts help:\n\n");
        dprintf("!atom [atom]                 - Dump the atom or table(s) for the process\n");
        dprintf("!critSec csAddress           - Dump a critical section\n");
        dprintf("!cxr address                 - Dump a context record\n");
        dprintf("!dh [image base address]     - Dump image header\n");
        dprintf("!dlls [-h]                   - Dump loaded DLLS\n");
        dprintf("!dp [v] [pid | pcsr_process] - Dump CSR process\n");
        dprintf("!dreg -[d|w] <keyPath>[![<valueName> | *]]  - Dump registry information\n");
        dprintf("!dt [v] pcsr_thread          - Dump CSR thread\n");
        dprintf("!error value                 - Decode error value\n");
        dprintf("!exr address                 - Dump an exception record\n");
        dprintf("!gatom                       - Dump the global atom table\n");
        dprintf("!gflag [value]               - Dump the global atom table\n");
        dprintf("!gle                         - Dump GetLastError value for current thread\n");
        dprintf("!handle [handle]             - Dump handle information\n");
        dprintf("!heap [address]              - Dump heap\n");
        dprintf("!help [cmd]                  - Displays this list or gives details on command\n");
        dprintf("!igrep [pattern [addr]]      - Grep for disassembled pattern starting at addr\n");
        dprintf("!locks [-v]                  - Dump all Critical Sections in process\n");
        dprintf("!obja ObjectAddress          - Dump an object's attributes\n");
        dprintf("!peb [peb addr to dump]      - Dump the PEB structure\n");
        dprintf("!str AnsiStringAddress       - Dump an ANSI string\n");
        dprintf("!teb [teb addr to dump]      - Dump the TEB structure\n");
        dprintf("!ustr UnicodeStringAddress   - Dump a UNICODE string\n");
        dprintf("!version                     - Dump system version and build number\n");
        dprintf("!vprot [address]             - Dump the virtual protect settings\n");

    } else {
        if (*lpArgumentString == '!')
            lpArgumentString++;
        if (strcmp(lpArgumentString, "igrep") == 0) {
            dprintf("!igrep [pattern [addr]]     - Grep for disassembled pattern starting at addr\n");
            dprintf("       If no pattern, last pattern is used, if no address, last hit is used\n");
        } else if (strcmp( lpArgumentString, "handle") == 0) {
            dprintf("!handle [handle [flags [type]]] - Dump handle information\n");
            dprintf("       If no handle specified, all handles are dumped.\n");
            dprintf("       Flags are bits indicating greater levels of detail.\n");
            dprintf("If the handle is 0 or -1, all handles are scanned.  If the handle is not\n");
            dprintf("zero, that particular handle is examined.  The flags are as follows:\n");
            dprintf("    1   - Get type information (default)\n");
            dprintf("    2   - Get basic information\n");
            dprintf("    4   - Get name information\n");
            dprintf("    8   - Get object specific info (where available)\n");
            dprintf("\n");
            dprintf("If Type is specified, only object of that type are scanned.  Type is a\n");
            dprintf("standard NT type name, e.g. Event, Semaphore, etc.  Case sensitive, of\n");
            dprintf("course.\n");
            dprintf("\n");
            dprintf("Examples:\n");
            dprintf("\n");
            dprintf("    !handle     -- dumps the types of all the handles, and a summary table\n");
            dprintf("    !handle 0 0 -- dumps a summary table of all the open handles\n");
            dprintf("    !handle 0 f -- dumps everything we can find about a handle.\n");
            dprintf("    !handle 0 f Event\n");
            dprintf("                -- dumps everything we can find about open events\n");
        } else if (strcmp( lpArgumentString, "gflag") == 0) {
            dprintf("If a value is not given then displays the current bits set in\n");
            dprintf("NTDLL!NtGlobalFlag variable.  Otherwise value can be one of the\n");
            dprintf("following:\n");
            dprintf("\n");
            dprintf("    -? - displays a list of valid flag abbreviations\n");
            dprintf("    number - 32-bit number that becomes the new value stored into\n");
            dprintf("             NtGlobalFlag\n");
            dprintf("    +number - specifies one or more bits to set in NtGlobalFlag\n");
            dprintf("    +abbrev - specifies a single bit to set in NtGlobalFlag\n");
            dprintf("    -number - specifies one or more bits to clear in NtGlobalFlag\n");
            dprintf("    -abbrev - specifies a single bit to clear in NtGlobalFlag\n");
        } else {
            dprintf("Invalid command.  No help available\n");
        }
    }
}



PLIST_ENTRY
DumpCritSec(
    DWORD_PTR dwAddrCritSec,
    BOOLEAN bDumpIfUnowned
    )

/*++

Routine Description:

    This function is called as an NTSD extension to format and dump
    the contents of the specified critical section.

Arguments:

    hCurrentProcess - Supplies a handle to the current process (at the
        time the extension was called).

    hCurrentThread - Supplies a handle to the current thread (at the
        time the extension was called).

    CurrentPc - Supplies the current pc at the time the extension is
        called.

    lpExtensionApis - Supplies the address of the functions callable
        by this extension.

    dwAddrCritSec - Supplies the address of the critical section to
        be dumped

    bDumpIfUnowned - TRUE means to dump the critical section even if
        it is currently unowned.

Return Value:

    Pointer to the next critical section in the list for the process or
    NULL if no more critical sections.

--*/

{
    USHORT i;
    CHAR Symbol[1024];
    DWORD_PTR Displacement;
    CRITICAL_SECTION CriticalSection;
    CRITICAL_SECTION_DEBUG DebugInfo;
    BOOL b;

    //
    // Read the critical section from the debuggees address space into our
    // own.

    b = ReadMemory( dwAddrCritSec,
                    &CriticalSection,
                    sizeof(CriticalSection),
                    NULL
                  );
    if ( !b ) {
        return NULL;
        }

    DebugInfo.ProcessLocksList.Flink = NULL;
    if (CriticalSection.DebugInfo != NULL) {
        b = ReadMemory( CriticalSection.DebugInfo,
                        &DebugInfo,
                        sizeof(DebugInfo),
                        NULL
                      );
        if ( !b ) {
            CriticalSection.DebugInfo = NULL;
            }
        }

    //
    // Dump the critical section
    //

    if ( CriticalSection.LockCount == -1 && !bDumpIfUnowned) {
        return DebugInfo.ProcessLocksList.Flink;
        }

    //
    // Get the symbolic name of the critical section
    //

    dprintf("\n");
    GetSymbol((LPVOID)dwAddrCritSec,Symbol,&Displacement);
    dprintf(
        "CritSec %s+%lx at %p\n",
        Symbol,
        Displacement,
        dwAddrCritSec
        );

    if ( CriticalSection.LockCount == -1) {
        dprintf("LockCount          NOT LOCKED\n");
        }
    else {
        dprintf("LockCount          %ld\n",CriticalSection.LockCount);
        }

    dprintf("RecursionCount     %ld\n",CriticalSection.RecursionCount);
    dprintf("OwningThread       %lx\n",CriticalSection.OwningThread);
    dprintf("EntryCount         %lx\n",DebugInfo.EntryCount);
    if (CriticalSection.DebugInfo != NULL) {
        dprintf("ContentionCount    %lx\n",DebugInfo.ContentionCount);
        if ( CriticalSection.LockCount != -1) {
            dprintf("*** Locked\n");
            }

        return DebugInfo.ProcessLocksList.Flink;
        }

    return NULL;
}

DECLARE_API( critsec )
{
    DWORD_PTR dwAddrCritSec;

    INIT_API();

    //
    // Evaluate the argument string to get the address of
    // the critical section to dump.
    //

    dwAddrCritSec = GetExpression(lpArgumentString);
    if ( !dwAddrCritSec ) {
        return;
        }

    DumpCritSec(dwAddrCritSec,TRUE);
}

DECLARE_API( igrep )
/*++

Routine Description:

    This function is called as an NTSD extension to grep the instruction
    stream for a particular pattern.

    Called as:

        !igrep [pattern [expression]]

    If a pattern is not given, the last pattern is used.  If expression
    is not given, the last hit address is used.

Arguments:

    hCurrentProcess - Supplies a handle to the current process (at the
        time the extension was called).

    hCurrentThread - Supplies a handle to the current thread (at the
        time the extension was called).

    CurrentPc - Supplies the current pc at the time the extension is
        called.

    lpExtensionApis - Supplies the address of the functions callable
        by this extension.

    lpArgumentString - Supplies the pattern and expression for this
        command.


Return Value:

    None.

--*/

{
    DWORD_PTR dwNextGrepAddr;
    DWORD_PTR dwCurrGrepAddr;
    CHAR SourceLine[256];
    BOOL NewPc;
    DWORD d;
    LPSTR pc;
    LPSTR Pattern;
    LPSTR Expression;
    CHAR Symbol[1024];
    DWORD_PTR Displacement;

    INIT_API();

    if ( igrepLastPc && igrepLastPc == dwCurrentPc ) {
        NewPc = FALSE;
        }
    else {
        igrepLastPc = dwCurrentPc;
        NewPc = TRUE;
        }

    //
    // check for pattern.
    //

    pc = lpArgumentString;
    Pattern = NULL;
    Expression = NULL;
    if ( *pc ) {
        Pattern = pc;
        while (*pc > ' ') {
                pc++;
            }

        //
        // check for an expression
        //

        if ( *pc != '\0' ) {
            *pc = '\0';
            pc++;
            if ( *pc <= ' ') {
                while (*pc <= ' '){
                    pc++;
                    }
                }
            if ( *pc ) {
                Expression = pc;
                }
            }
        }

    if ( Pattern ) {
        strcpy(igrepLastPattern,Pattern);

        if ( Expression ) {
            igrepSearchStartAddress = GetExpression(Expression);
            if ( !igrepSearchStartAddress ) {
                igrepSearchStartAddress = igrepLastPc;
                return;
                }
            }
        else {
            igrepSearchStartAddress = igrepLastPc;
            }
        }

    dwNextGrepAddr = igrepSearchStartAddress;
    dwCurrGrepAddr = dwNextGrepAddr;
    d = Disasm(&dwNextGrepAddr,SourceLine,FALSE);
    while(d) {
        if (strstr(SourceLine,igrepLastPattern)) {
            igrepSearchStartAddress = dwNextGrepAddr;
            GetSymbol((LPVOID)dwCurrGrepAddr,Symbol,&Displacement);
            dprintf("%s",SourceLine);
            return;
            }
        if ((CheckControlC)()) {
            return;
            }
        dwCurrGrepAddr = dwNextGrepAddr;
        d = Disasm(&dwNextGrepAddr,SourceLine,FALSE);
        }
}

DECLARE_API( str )

/*++

Routine Description:

    This function is called as an NTSD extension to format and dump
    counted (ansi) string.

Arguments:

    hCurrentProcess - Supplies a handle to the current process (at the
        time the extension was called).

    hCurrentThread - Supplies a handle to the current thread (at the
        time the extension was called).

    CurrentPc - Supplies the current pc at the time the extension is
        called.

    lpExtensionApis - Supplies the address of the functions callable
        by this extension.

    lpArgumentString - Supplies the asciiz string that describes the
        ansi string to be dumped.

Return Value:

    None.

--*/

{
    ANSI_STRING AnsiString;
    DWORD_PTR dwAddrString;
    CHAR Symbol[1024];
    LPSTR StringData;
    DWORD_PTR Displacement;
    BOOL b;

    INIT_API();

    //
    // Evaluate the argument string to get the address of
    // the string to dump.
    //

    dwAddrString = GetExpression(lpArgumentString);
    if ( !dwAddrString ) {
        return;
        }


    //
    // Get the symbolic name of the string
    //

    GetSymbol((LPVOID)dwAddrString,Symbol,&Displacement);

    //
    // Read the string from the debuggees address space into our
    // own.

    b = ReadMemory( dwAddrString,
                    &AnsiString,
                    sizeof(AnsiString),
                    NULL
                  );
    if ( !b ) {
        return;
        }

    StringData = (LPSTR)LocalAlloc(LMEM_ZEROINIT,AnsiString.Length+1);

    b = ReadMemory( AnsiString.Buffer,
                    StringData,
                    AnsiString.Length,
                    NULL
                  );
    if ( !b ) {
        LocalFree(StringData);
        return;
        }

    dprintf(
        "String(%d,%d) %s+%p at %p: %s\n",
        AnsiString.Length,
        AnsiString.MaximumLength,
        Symbol,
        Displacement,
        dwAddrString,
        StringData
        );

    LocalFree(StringData);
}

DECLARE_API( ustr )

/*++

Routine Description:

    This function is called as an NTSD extension to format and dump
    counted unicode string.

Arguments:

    hCurrentProcess - Supplies a handle to the current process (at the
        time the extension was called).

    hCurrentThread - Supplies a handle to the current thread (at the
        time the extension was called).

    CurrentPc - Supplies the current pc at the time the extension is
        called.

    lpExtensionApis - Supplies the address of the functions callable
        by this extension.

    lpArgumentString - Supplies the asciiz string that describes the
        ansi string to be dumped.

Return Value:

    None.

--*/

{
    ANSI_STRING AnsiString;
    UNICODE_STRING UnicodeString;
    DWORD_PTR dwAddrString;
    CHAR Symbol[1024];
    LPSTR StringData;
    DWORD_PTR Displacement;
    BOOL b;

    INIT_API();

    //
    // Evaluate the argument string to get the address of
    // the string to dump.
    //

    dwAddrString = GetExpression(lpArgumentString);
    if ( !dwAddrString ) {
        return;
        }


    //
    // Get the symbolic name of the string
    //

    GetSymbol((LPVOID)dwAddrString,Symbol,&Displacement);

    //
    // Read the string from the debuggees address space into our
    // own.

    b = ReadMemory( dwAddrString,
                    &UnicodeString,
                    sizeof(UnicodeString),
                    NULL
                  );
    if ( !b ) {
        return;
        }

    StringData = (LPSTR)LocalAlloc(LMEM_ZEROINIT,UnicodeString.Length+sizeof(UNICODE_NULL));

    b = ReadMemory( UnicodeString.Buffer,
                    StringData,
                    UnicodeString.Length,
                    NULL
                  );
    if ( !b ) {
        LocalFree(StringData);
        return;
        }
    UnicodeString.Buffer = (PWSTR)StringData;
    UnicodeString.MaximumLength = UnicodeString.Length+(USHORT)sizeof(UNICODE_NULL);

    RtlUnicodeStringToAnsiString(&AnsiString,&UnicodeString,TRUE);
    LocalFree(StringData);

    dprintf(
        "String(%d,%d) %s+%p at %p: %s\n",
        UnicodeString.Length,
        UnicodeString.MaximumLength,
        Symbol,
        Displacement,
        dwAddrString,
        AnsiString.Buffer
        );

    RtlFreeAnsiString(&AnsiString);
}

DECLARE_API( obja )

/*++

Routine Description:

    This function is called as an NTSD extension to format and dump
    an object attributes structure.

Arguments:

    hCurrentProcess - Supplies a handle to the current process (at the
        time the extension was called).

    hCurrentThread - Supplies a handle to the current thread (at the
        time the extension was called).

    CurrentPc - Supplies the current pc at the time the extension is
        called.

    lpExtensionApis - Supplies the address of the functions callable
        by this extension.

    lpArgumentString - Supplies the asciiz string that describes the
        ansi string to be dumped.

Return Value:

    None.

--*/

{
    UNICODE_STRING UnicodeString;
    DWORD_PTR dwAddrObja;
    OBJECT_ATTRIBUTES Obja;
    DWORD_PTR dwAddrString;
    CHAR Symbol[1024];
    LPSTR StringData;
    DWORD_PTR Displacement;
    BOOL b;

    INIT_API();

    //
    // Evaluate the argument string to get the address of
    // the Obja to dump.
    //

    dwAddrObja = GetExpression(lpArgumentString);
    if ( !dwAddrObja ) {
        return;
        }


    //
    // Get the symbolic name of the Obja
    //

    GetSymbol((LPVOID)dwAddrObja,Symbol,&Displacement);

    //
    // Read the obja from the debuggees address space into our
    // own.

    b = ReadMemory( dwAddrObja,
                    &Obja,
                    sizeof(Obja),
                    NULL
                  );
    if ( !b ) {
        return;
        }
    StringData = NULL;
    if ( Obja.ObjectName ) {
        dwAddrString = (DWORD_PTR)Obja.ObjectName;
        b = ReadMemory( dwAddrString,
                        &UnicodeString,
                        sizeof(UnicodeString),
                        NULL
                      );
        if ( !b ) {
            return;
            }

        StringData = (LPSTR)LocalAlloc(
                        LMEM_ZEROINIT,
                        UnicodeString.Length+sizeof(UNICODE_NULL)
                        );

        b = ReadMemory( UnicodeString.Buffer,
                        StringData,
                        UnicodeString.Length,
                        NULL
                      );
        if ( !b ) {
            LocalFree(StringData);
            return;
            }
        UnicodeString.Buffer = (PWSTR)StringData;
        UnicodeString.MaximumLength = UnicodeString.Length+(USHORT)sizeof(UNICODE_NULL);
    }

    //
    // We got the object name in UnicodeString. StringData is NULL if no name.
    //

    dprintf(
        "Obja %s+%p at %p:\n",
        Symbol,
        Displacement,
        dwAddrObja
        );
    if ( StringData ) {
        dprintf("\t%s is %ws\n",
            Obja.RootDirectory ? "Relative Name" : "Full Name",
            UnicodeString.Buffer
            );
        LocalFree(StringData);
        }
    if ( Obja.Attributes ) {
            if ( Obja.Attributes & OBJ_INHERIT ) {
                dprintf("\tOBJ_INHERIT\n");
                }
            if ( Obja.Attributes & OBJ_PERMANENT ) {
                dprintf("\tOBJ_PERMANENT\n");
                }
            if ( Obja.Attributes & OBJ_EXCLUSIVE ) {
                dprintf("\tOBJ_EXCLUSIVE\n");
                }
            if ( Obja.Attributes & OBJ_CASE_INSENSITIVE ) {
                dprintf("\tOBJ_CASE_INSENSITIVE\n");
                }
            if ( Obja.Attributes & OBJ_OPENIF ) {
                dprintf("\tOBJ_OPENIF\n");
                }
        }
}


DECLARE_API( locks )

/*++

Routine Description:

    This function is called as an NTSD extension to display all
    critical sections in the target process.

Arguments:

    hCurrentProcess - Supplies a handle to the current process (at the
        time the extension was called).

    hCurrentThread - Supplies a handle to the current thread (at the
        time the extension was called).

    CurrentPc - Supplies the current pc at the time the extension is
        called.

    lpExtensionApis - Supplies the address of the functions callable
        by this extension.

    lpArgumentString - tbd.

Return Value:

    None.

--*/

{
    BOOL b;
    CRITICAL_SECTION_DEBUG DebugInfo;
    PVOID AddrListHead;
    LIST_ENTRY ListHead;
    PLIST_ENTRY Next;
    BOOLEAN Verbose;
    LPSTR p;

    INIT_API();

    Verbose = FALSE;
    p = lpArgumentString;
    while ( p != NULL && *p ) {
        if ( *p == '-' ) {
            p++;
            switch ( *p ) {
                case 'V':
                case 'v':
                    Verbose = TRUE;
                    p++;
                    break;

                case ' ':
                    goto gotBlank;

                default:
                    dprintf( "NTSDEXTS: !locks invalid option flag '-%c'\n", *p );
                    break;

                }
            }
        else {
gotBlank:
            p++;
            }
        }

    //
    // Locate the address of the list head.
    //

    AddrListHead = (PVOID)GetExpression("&ntdll!RtlCriticalSectionList");
    if ( !AddrListHead ) {
        return;
        }

    //
    // Read the list head
    //

    b = ReadMemory( AddrListHead,
                    &ListHead,
                    sizeof(ListHead),
                    NULL
                  );
    if ( !b ) {
        return;
        }

    Next = ListHead.Flink;

    //
    // Walk the list of critical sections
    //
    while ( Next != AddrListHead ) {
        b = ReadMemory( CONTAINING_RECORD( Next,
                                           RTL_CRITICAL_SECTION_DEBUG,
                                           ProcessLocksList
                                         ),
                        &DebugInfo,
                        sizeof(DebugInfo),
                        NULL
                      );
        if ( !b ) {
            return;
            }

        Next = DumpCritSec((DWORD_PTR)DebugInfo.CriticalSection, Verbose);
        if (Next == NULL) {
            break;
            }

        if ((CheckControlC)()) {
            break;
            }

        }

    return;
}


//
// Simple routine to convert from hex into a string of characters.
// Used by debugger extensions.
//
// by scottlu
//

char *
HexToString(
    ULONG_PTR dw,
    CHAR *pch
    )
{
    if (dw > 0xf) {
        pch = HexToString(dw >> 4, pch);
        dw &= 0xf;
    }

    *pch++ = ((dw >= 0xA) ? ('A' - 0xA) : '0') + (CHAR)dw;
    *pch = 0;

    return pch;
}


//
// dt == dump thread
//
// dt [v] pcsr_thread
// v == verbose (structure)
//
// by scottlu
//

DECLARE_API( dt )
{
    char chVerbose;
    CSR_THREAD csrt;
    ULONG dw;

    INIT_API();

    while (*lpArgumentString == ' ')
        lpArgumentString++;

    chVerbose = ' ';
    if (*lpArgumentString == 'v')
        chVerbose = *lpArgumentString++;

    dw = (ULONG)GetExpression(lpArgumentString);
    move(csrt, dw);

    //
    // Print simple thread info if the user did not ask for verbose.
    //
    if (chVerbose == ' ') {
        dprintf("Thread %08lx, Process %08lx, ClientId %lx.%lx, Flags %lx, Ref Count %lx\n",
                dw,
                csrt.Process,
                csrt.ClientId.UniqueProcess,
                csrt.ClientId.UniqueThread,
                csrt.Flags,
                csrt.ReferenceCount);
        return;
    }

    dprintf("PCSR_THREAD @ %08lx:\n"
            "\t+%04lx Link.Flink                %08lx\n"
            "\t+%04lx Link.Blink                %08lx\n"
            "\t+%04lx Process                   %08lx\n",
            dw,
            FIELD_OFFSET(CSR_THREAD, Link.Flink), csrt.Link.Flink,
            FIELD_OFFSET(CSR_THREAD, Link.Blink), csrt.Link.Blink,
            FIELD_OFFSET(CSR_THREAD, Process), csrt.Process);

    dprintf(
            "\t+%04lx WaitBlock                 %08lx\n"
            "\t+%04lx ClientId.UniqueProcess    %08lx\n"
            "\t+%04lx ClientId.UniqueThread     %08lx\n"
            "\t+%04lx ThreadHandle              %08lx\n",
            FIELD_OFFSET(CSR_THREAD, WaitBlock), csrt.WaitBlock,
            FIELD_OFFSET(CSR_THREAD, ClientId.UniqueProcess), csrt.ClientId.UniqueProcess,
            FIELD_OFFSET(CSR_THREAD, ClientId.UniqueThread), csrt.ClientId.UniqueThread,
            FIELD_OFFSET(CSR_THREAD, ThreadHandle), csrt.ThreadHandle);

    dprintf(
            "\t+%04lx Flags                     %08lx\n"
            "\t+%04lx ReferenceCount            %08lx\n"
            "\t+%04lx HashLinks.Flink           %08lx\n"
            "\t+%04lx HashLinks.Blink           %08lx\n",
            FIELD_OFFSET(CSR_THREAD, Flags), csrt.Flags,
            FIELD_OFFSET(CSR_THREAD, ReferenceCount), csrt.ReferenceCount,
            FIELD_OFFSET(CSR_THREAD, HashLinks.Flink), csrt.HashLinks.Flink,
            FIELD_OFFSET(CSR_THREAD, HashLinks.Blink), csrt.HashLinks.Blink);

    return;
}

//
// dp == dump process
//
// dp [v] [pid | pcsr_process]
//      v == verbose (structure + thread list)
//      no process == dump process list
//
// by scottlu
//

DECLARE_API( dp )
{
    PLIST_ENTRY ListHead, ListNext;
    char ach[80];
    char chVerbose;
    PCSR_PROCESS pcsrpT;
    CSR_PROCESS csrp;
    PCSR_PROCESS pcsrpRoot;
    PCSR_THREAD pcsrt;
    ULONG_PTR dwProcessId;
    ULONG_PTR dw;
    DWORD_PTR dwRootProcess;

    INIT_API();

    while (*lpArgumentString == ' ')
        lpArgumentString++;

    chVerbose = ' ';
    if (*lpArgumentString == 'v')
        chVerbose = *lpArgumentString++;

    dwRootProcess = GetExpression("&csrsrv!CsrRootProcess");
    if ( !dwRootProcess ) {
        return;
        }

    move(pcsrpRoot, dwRootProcess);

    //
    // See if user wants all processes. If so loop through them.
    //
    if (*lpArgumentString == 0) {
        ListHead = &pcsrpRoot->ListLink;
        move(ListNext, &ListHead->Flink);

        while (ListNext != ListHead) {
            pcsrpT = CONTAINING_RECORD(ListNext, CSR_PROCESS, ListLink);

            ach[0] = chVerbose;
            ach[1] = ' ';
            HexToString((ULONG_PTR)pcsrpT, &ach[2]);

            dp(hCurrentProcess, hCurrentThread, dwCurrentPc, lpExtensionApis,
                    ach);

            move(ListNext, &ListNext->Flink);
        }

        dprintf("---\n");
        return;
    }

    //
    // User wants specific process structure. Evaluate to find id or process
    // pointer.
    //
    dw = (ULONG)GetExpression(lpArgumentString);

    ListHead = &pcsrpRoot->ListLink;
    move(ListNext, &ListHead->Flink);

    while (ListNext != ListHead) {
        pcsrpT = CONTAINING_RECORD(ListNext, CSR_PROCESS, ListLink);
        move(ListNext, &ListNext->Flink);

        move(dwProcessId, &pcsrpT->ClientId.UniqueProcess);
        if (dw == dwProcessId) {
            dw = (ULONG_PTR)pcsrpT;
            break;
        }
    }

    pcsrpT = (PCSR_PROCESS)dw;
    move(csrp, pcsrpT);

    //
    // If not verbose, print simple process info.
    //
    if (chVerbose == ' ') {
        dprintf("Process %08lx, Id %p, Seq# %lx, Flags %lx, Ref Count %lx\n",
                pcsrpT,
                csrp.ClientId.UniqueProcess,
                csrp.SequenceNumber,
                csrp.Flags,
                csrp.ReferenceCount);
        return;
    }

    dprintf("PCSR_PROCESS @ %08lx:\n"
            "\t+%04lx ListLink.Flink            %08lx\n"
            "\t+%04lx ListLink.Blink            %08lx\n"
            "\t+%04lx Parent                    %08lx\n",
            pcsrpT,
            FIELD_OFFSET(CSR_PROCESS, ListLink.Flink), csrp.ListLink.Flink,
            FIELD_OFFSET(CSR_PROCESS, ListLink.Blink), csrp.ListLink.Blink,
            FIELD_OFFSET(CSR_PROCESS, Parent), csrp.Parent);

    dprintf(
            "\t+%04lx ThreadList.Flink          %08lx\n"
            "\t+%04lx ThreadList.Blink          %08lx\n"
            "\t+%04lx NtSession                 %08lx\n"
            "\t+%04lx ExpectedVersion           %08lx\n",
            FIELD_OFFSET(CSR_PROCESS, ThreadList.Flink), csrp.ThreadList.Flink,
            FIELD_OFFSET(CSR_PROCESS, ThreadList.Blink), csrp.ThreadList.Blink,
            FIELD_OFFSET(CSR_PROCESS, NtSession), csrp.NtSession,
            FIELD_OFFSET(CSR_PROCESS, ExpectedVersion), csrp.ExpectedVersion);

    dprintf(
            "\t+%04lx ClientPort                %08lx\n"
            "\t+%04lx ClientViewBase            %08lx\n"
            "\t+%04lx ClientViewBounds          %08lx\n"
            "\t+%04lx ClientId.UniqueProcess    %08lx\n",
            FIELD_OFFSET(CSR_PROCESS, ClientPort), csrp.ClientPort,
            FIELD_OFFSET(CSR_PROCESS, ClientViewBase), csrp.ClientViewBase,
            FIELD_OFFSET(CSR_PROCESS, ClientViewBounds), csrp.ClientViewBounds,
            FIELD_OFFSET(CSR_PROCESS, ClientId.UniqueProcess), csrp.ClientId.UniqueProcess);

    dprintf(
            "\t+%04lx ProcessHandle             %08lx\n"
            "\t+%04lx SequenceNumber            %08lx\n"
            "\t+%04lx Flags                     %08lx\n"
            "\t+%04lx DebugFlags                %08lx\n",
            FIELD_OFFSET(CSR_PROCESS, ProcessHandle), csrp.ProcessHandle,
            FIELD_OFFSET(CSR_PROCESS, SequenceNumber), csrp.SequenceNumber,
            FIELD_OFFSET(CSR_PROCESS, Flags), csrp.Flags,
            FIELD_OFFSET(CSR_PROCESS, DebugFlags), csrp.DebugFlags);

    dprintf(
            "\t+%04lx DebugUserInterface        %08lx\n"
            "\t+%04lx ReferenceCount            %08lx\n"
            "\t+%04lx ProcessGroupId            %08lx\n"
            "\t+%04lx ProcessGroupSequence      %08lx\n",
            FIELD_OFFSET(CSR_PROCESS, DebugUserInterface.UniqueProcess), csrp.DebugUserInterface.UniqueProcess,
            FIELD_OFFSET(CSR_PROCESS, ReferenceCount), csrp.ReferenceCount,
            FIELD_OFFSET(CSR_PROCESS, ProcessGroupId), csrp.ProcessGroupId,
            FIELD_OFFSET(CSR_PROCESS, ProcessGroupSequence), csrp.ProcessGroupSequence);

    dprintf(
            "\t+%04lx fVDM                      %08lx\n"
            "\t+%04lx ThreadCount               %08lx\n"
            "\t+%04lx PriorityClass             %08lx\n"
            "\t+%04lx ShutdownLevel             %08lx\n"
            "\t+%04lx ShutdownFlags             %08lx\n",
            FIELD_OFFSET(CSR_PROCESS, fVDM), csrp.fVDM,
            FIELD_OFFSET(CSR_PROCESS, ThreadCount), csrp.ThreadCount,
            FIELD_OFFSET(CSR_PROCESS, PriorityClass), csrp.PriorityClass,
            FIELD_OFFSET(CSR_PROCESS, ShutdownLevel), csrp.ShutdownLevel,
            FIELD_OFFSET(CSR_PROCESS, ShutdownFlags), csrp.ShutdownFlags);

    //
    // Now dump simple thread info for this processes' threads.
    //

    ListHead = &pcsrpT->ThreadList;
    move(ListNext, &ListHead->Flink);

    dprintf("Threads:\n");

    while (ListNext != ListHead) {
        pcsrt = CONTAINING_RECORD(ListNext, CSR_THREAD, Link);

        //
        // Make sure this pcsrt is somewhat real so we don't loop forever.
        //
        move(dwProcessId, &pcsrt->ClientId.UniqueProcess);
        if (dwProcessId != (DWORD_PTR)csrp.ClientId.UniqueProcess) {
            dprintf("Invalid thread. Probably invalid argument to this extension.\n");
            return;
        }

        HexToString((ULONG_PTR)pcsrt, ach);
        dt(hCurrentProcess, hCurrentThread, dwCurrentPc, lpExtensionApis, ach);

        move(ListNext, &ListNext->Flink);
    }

    return;
}

VOID
Reg64(
    LPSTR   Name,
    ULONG   HiPart,
    ULONG   LoPart,
    BOOL    ForceHi
    )
{
    dprintf("%4s=", Name);
    if (ForceHi || HiPart) {
        dprintf("%08lx", HiPart);
    }
    dprintf("%08lx   ", LoPart);
}

CONTEXT LastContext;
BOOL HaveContext = 0;

DECLARE_API( cxr )

/*++

Routine Description:

    This function is called as an NTSD extension to dump a context record

    Called as:

        !cxr address

Arguments:

    hCurrentProcess - Supplies a handle to the current process (at the
        time the extension was called).

    hCurrentThread - Supplies a handle to the current thread (at the
        time the extension was called).

    CurrentPc - Supplies the current pc at the time the extension is
        called.

    lpExtensionApis - Supplies the address of the functions callable
        by this extension.

    lpArgumentString - Supplies the pattern and expression for this
        command.


Return Value:

    None.

--*/
{
    CONTEXT Context;
    DWORD_PTR Address;

    INIT_API();

    Address = GetExpression(lpArgumentString);
    if (!Address) {
        return;
    }

    move(Context, Address);

    LastContext = Context;
    HaveContext = TRUE;



#if i386

    dprintf("eax=%08lx ebx=%08lx ecx=%08lx edx=%08lx esi=%08lx edi=%08lx\n",
                Context.Eax,
                Context.Ebx,
                Context.Ecx,
                Context.Edx,
                Context.Esi,
                Context.Edi);
    dprintf("eip=%08lx esp=%08lx ebp=%08lx iopl=%1lx         "
        "%s %s %s %s %s %s %s %s\n",
                Context.Eip,
                Context.Esp,
                Context.Ebp,
                ((Context.EFlags >> 12) & 3),
        (Context.EFlags & 0x800) ? "ov" : "nv",
        (Context.EFlags & 0x400) ? "dn" : "up",
        (Context.EFlags & 0x200) ? "ei" : "di",
        (Context.EFlags & 0x80) ? "ng" : "pl",
        (Context.EFlags & 0x40) ? "zr" : "nz",
        (Context.EFlags & 0x10) ? "ac" : "na",
        (Context.EFlags & 0x4) ? "po" : "pe",
        (Context.EFlags & 0x1) ? "cy" : "nc");

    dprintf("cs=%04x  ss=%04x  ds=%04x  es=%04x  fs=%04x  gs=%04x"
            "             efl=%08lx\n",
                (USHORT)(Context.SegCs & 0xffff),
                (USHORT)(Context.SegSs & 0xffff),
                (USHORT)(Context.SegDs & 0xffff),
                (USHORT)(Context.SegEs & 0xffff),
                (USHORT)(Context.SegFs & 0xffff),
                (USHORT)(Context.SegGs & 0xffff),
                Context.EFlags);

#elif MIPS

    if (Context.ContextFlags & CONTEXT_EXTENDED_INTEGER) {
        dprintf("at=%08I64x v0=%08I64x v1=%08I64x\n",
                    Context.XIntAt,
                    Context.XIntV0,
                    Context.XIntV1);
        dprintf("a0=%08I64x a1=%08I64x a2=%08I64x\n",
                    Context.XIntA0,
                    Context.XIntA1,
                    Context.XIntA2);
        dprintf("a3=%08I64x t0=%08I64x t1=%08I64x\n",
                    Context.XIntA3,
                    Context.XIntT0,
                    Context.XIntT1);
        dprintf("t2=%08I64x t3=%08I64x t4=%08I64x\n",
                    Context.XIntT2,
                    Context.XIntT3,
                    Context.XIntT4);
        dprintf("t5=%08I64x t6=%08I64x t7=%08I64x\n",
                    Context.XIntT5,
                    Context.XIntT6,
                    Context.XIntT7);
        dprintf("s0=%08I64x s1=%08I64x s2=%08I64x\n",
                    Context.XIntS0,
                    Context.XIntS1,
                    Context.XIntS2);
        dprintf("s3=%08I64x s4=%08I64x s5=%08I64x\n",
                    Context.XIntS3,
                    Context.XIntS4,
                    Context.XIntS5);
        dprintf("s6=%08I64x s7=%08I64x t8=%08I64x\n",
                    Context.XIntS6,
                    Context.XIntS7,
                    Context.XIntT8);
        dprintf("t9=%08I64x k0=%08I64x k1=%08I64x\n",
                    Context.XIntT9,
                    Context.XIntK0,
                    Context.XIntK1);
        dprintf("gp=%08I64x sp=%08I64x s8=%08I64x\n",
                    Context.XIntGp,
                    Context.XIntSp,
                    Context.XIntS8);
        dprintf("ra=%08I64x lo=%08I64x hi=%08I64x\n",
                    Context.XIntRa,
                    Context.XIntLo,
                    Context.XIntHi);
        dprintf("fir=%08lx psr=%08lx\n",
                    Context.XFir,
                    Context.XPsr);
        dprintf("cu=%1lx%1lx%1lx%1lx intr(5:0)=%1lx%1lx%1lx%1lx%1lx%1lx sw(1:0)=%1lx%1lx ksu=%1lx erl=%1lx exl=%1lx ie=%1lx\n",
                    (Context.XPsr >> 31) & 0x1,
                    (Context.XPsr >> 30) & 0x1,
                    (Context.XPsr >> 29) & 0x1,
                    (Context.XPsr >> 28) & 0x1,

                    (Context.XPsr >> 15) & 0x1,
                    (Context.XPsr >> 14) & 0x1,
                    (Context.XPsr >> 13) & 0x1,
                    (Context.XPsr >> 12) & 0x1,
                    (Context.XPsr >> 11) & 0x1,
                    (Context.XPsr >> 10) & 0x1,

                    (Context.XPsr >> 9) & 0x1,
                    (Context.XPsr >> 8) & 0x1,

                    (Context.XPsr >> 3) & 0x3,
                    (Context.XPsr >> 2) & 0x1,
                    (Context.XPsr >> 1) & 0x1,
                    (Context.XPsr & 0x1));

    } else {
        dprintf("at=%08lx v0=%08lx v1=%08lx a0=%08lx a1=%08lx a2=%08lx\n",
                    Context.IntAt,
                    Context.IntV0,
                    Context.IntV1,
                    Context.IntA0,
                    Context.IntA1,
                    Context.IntA2);
        dprintf("a3=%08lx t0=%08lx t1=%08lx t2=%08lx t3=%08lx t4=%08lx\n",
                    Context.IntA3,
                    Context.IntT0,
                    Context.IntT1,
                    Context.IntT2,
                    Context.IntT3,
                    Context.IntT4);
        dprintf("t5=%08lx t6=%08lx t7=%08lx s0=%08lx s1=%08lx s2=%08lx\n",
                    Context.IntT5,
                    Context.IntT6,
                    Context.IntT7,
                    Context.IntS0,
                    Context.IntS1,
                    Context.IntS2);
        dprintf("s3=%08lx s4=%08lx s5=%08lx s6=%08lx s7=%08lx t8=%08lx\n",
                    Context.IntS3,
                    Context.IntS4,
                    Context.IntS5,
                    Context.IntS6,
                    Context.IntS7,
                    Context.IntT8);
        dprintf("t9=%08lx k0=%08lx k1=%08lx gp=%08lx sp=%08lx s8=%08lx\n",
                    Context.IntT9,
                    Context.IntK0,
                    Context.IntK1,
                    Context.IntGp,
                    Context.IntSp,
                    Context.IntS8);
        dprintf("ra=%08lx lo=%08lx hi=%08lx           fir=%08lx psr=%08lx\n",
                    Context.IntRa,
                    Context.IntLo,
                    Context.IntHi,
                    Context.Fir,
                    Context.Psr);

        dprintf("cu=%1lx%1lx%1lx%1lx intr(5:0)=%1lx%1lx%1lx%1lx%1lx%1lx sw(1:0)=%1lx%1lx ksu=%1lx erl=%1lx exl=%1lx ie=%1lx\n",
                    (Context.Psr >> 31) & 0x1,
                    (Context.Psr >> 30) & 0x1,
                    (Context.Psr >> 29) & 0x1,
                    (Context.Psr >> 28) & 0x1,

                    (Context.Psr >> 15) & 0x1,
                    (Context.Psr >> 14) & 0x1,
                    (Context.Psr >> 13) & 0x1,
                    (Context.Psr >> 12) & 0x1,
                    (Context.Psr >> 11) & 0x1,
                    (Context.Psr >> 10) & 0x1,

                    (Context.Psr >> 9) & 0x1,
                    (Context.Psr >> 8) & 0x1,

                    (Context.Psr >> 3) & 0x3,
                    (Context.Psr >> 2) & 0x1,
                    (Context.Psr >> 1) & 0x1,
                    (Context.Psr & 0x1));
    }

#elif ALPHA

#define R(N,R)  Reg64(N,(ULONG)(Context.R>>32),(ULONG)(Context.R&0xffffffff),0)
#define NL()    dprintf("\n")

    R("v0", IntV0); R("t0", IntT0); R("t1", IntT1); R("t2", IntT2); NL();
    R("t3", IntT3); R("t4", IntT4); R("t5", IntT5); R("t6", IntT6); NL();
    R("t7", IntT7); R("s0", IntS0); R("s1", IntS1); R("s2", IntS2); NL();
    R("s3", IntS3); R("s4", IntS4); R("s5", IntS5); R("fp", IntFp); NL();
    R("a0", IntA0); R("a1", IntA1); R("a2", IntA2); R("a3", IntA3); NL();
    R("a4", IntA4); R("a5", IntA5); R("t8", IntT8); R("t9", IntT9); NL();
    R("t10", IntT10); R("t11", IntT11); R("ra", IntRa); R("t12", IntT12); NL();
    R("at", IntAt); R("gp", IntGp); R("sp", IntSp); R("zero", IntZero); NL();

    Reg64("fpcr", (ULONG)(Context.Fpcr>>32), (ULONG)(Context.Fpcr&0xffffffff), 1);
    Reg64("softfpcr", (ULONG)(Context.SoftFpcr>>32), (ULONG)(Context.SoftFpcr&0xffffffff), 1);
    R("fir", Fir);
    NL();

    dprintf(" psr=%08lx\n", Context.Psr);
    dprintf("mode=%1x ie=%1x irql=%1x\n",
                        Context.Psr & 0x1,
                        (Context.Psr>>1) & 0x1,
                        (Context.Psr>>2) & 0x7);


#undef R
#undef NL

#elif PPC

#define R(N,R)  dprintf("%4s=%08lx", N, Context.R)
#define NL()    dprintf("\n")

    R("r0", Gpr0); R("r1", Gpr1); R("r2", Gpr2); R("r3", Gpr3); R("r4", Gpr4); R("r5", Gpr5); NL();
    R("r6", Gpr6); R("r7", Gpr7); R("r8", Gpr8); R("r9", Gpr9); R("r10", Gpr10); R("r11", Gpr11); NL();
    R("r12", Gpr12); R("r13", Gpr13); R("r14", Gpr14); R("r15", Gpr15); R("r16", Gpr16); R("r17", Gpr17); NL();
    R("r18", Gpr18); R("r19", Gpr19); R("r20", Gpr20); R("r21", Gpr21); R("r22", Gpr22); R("r23", Gpr23); NL();
    R("r24", Gpr24); R("r25", Gpr25); R("r26", Gpr26); R("r27", Gpr27); R("r28", Gpr28); R("r29", Gpr29); NL();
    R("r30", Gpr30); R("r31", Gpr31); R("cr", Cr); R("xer", Xer); R("msr", Msr); R("iar", Iar); NL();
    R("lr", Lr); R("ctr", Ctr); NL();

#undef R
#undef NL

#else
    dprintf("cxr code needed for cpu\n");
#endif

    return;

}


VOID
DumpExr(
    PEXCEPTION_RECORD Exr
    )
{
    ULONG   i;
    CHAR Buffer[80];
    DWORD_PTR displacement;

    GetSymbol((LPVOID)Exr->ExceptionAddress, Buffer, &displacement);

    if (*Buffer) {
        dprintf("ExceptionAddress: %08lx (%s+0x%x)\n",
                 Exr->ExceptionAddress,
                 Buffer,
                 displacement);
    } else {
        dprintf("ExceptionAddress: %08lx\n", Exr->ExceptionAddress);
    }
    //dprintf("   ExceptionCode: %08lx", Exr->ExceptionCode);
    DecodeError( "   ExceptionCode", Exr->ExceptionCode, TRUE );
    dprintf("  ExceptionFlags: %08lx\n", Exr->ExceptionFlags);

    dprintf("NumberParameters: %d\n", Exr->NumberParameters);
    if (Exr->NumberParameters > EXCEPTION_MAXIMUM_PARAMETERS) {
        Exr->NumberParameters = EXCEPTION_MAXIMUM_PARAMETERS;
    }
    for (i = 0; i < Exr->NumberParameters; i++) {
        dprintf("   Parameter[%d]: %08lx\n", i, Exr->ExceptionInformation[i]);
    }

    //
    // Known Exception processing:
    //

    switch ( Exr->ExceptionCode )
    {
        case STATUS_ACCESS_VIOLATION:
            if ( Exr->NumberParameters == 2 )
            {
                dprintf("Attempt to %s address %x\n",
                          (Exr->ExceptionInformation[0] ? "write to" : "read from"),
                          Exr->ExceptionInformation[1] );

            }
            break;

        case STATUS_IN_PAGE_ERROR:
            if ( Exr->NumberParameters == 3 )
            {
                dprintf("Inpage operation failed at %#x, due to I/O error %x\n",
                          Exr->ExceptionInformation[1],
                          Exr->ExceptionInformation[2] );
            }
            break;

        case STATUS_INVALID_HANDLE:
        case STATUS_HANDLE_NOT_CLOSABLE:
            dprintf( "Thread tried to close a handle that was invalid or illegal to close\n");
            break;

        case STATUS_POSSIBLE_DEADLOCK:
            if ( Exr->NumberParameters == 1 )
            {
                RTL_CRITICAL_SECTION CritSec ;
                ULONG Result ;

                GetSymbol( (LPVOID) Exr->ExceptionInformation[0], Buffer, &displacement );

                if ( *Buffer )
                {
                    dprintf("Critical section at %#x (%s+%#x)",
                            Exr->ExceptionInformation[0],
                            Buffer,
                            displacement );
                }
                else
                {
                    dprintf("Critical section at %#x",
                            Exr->ExceptionInformation[0] );

                }
                if ( ReadMemory( Exr->ExceptionInformation[0],
                                 &CritSec,
                                 sizeof( RTL_CRITICAL_SECTION ),
                                 &Result ) )
                {
                    if ( Result == sizeof( CritSec ))
                    {
                        dprintf("is owned by thread %x,\ncausing this thread to raise an exception",
                                CritSec.OwningThread );

                    }
                }
                dprintf("\n");

            }
            break;

        default:
            break;

    }
    return;
}

DECLARE_API( exr )

/*++

Routine Description:

    This function is called as an NTSD extension to dump an exception record

    Called as:

        !exr address

Arguments:

    hCurrentProcess - Supplies a handle to the current process (at the
        time the extension was called).

    hCurrentThread - Supplies a handle to the current thread (at the
        time the extension was called).

    CurrentPc - Supplies the current pc at the time the extension is
        called.

    lpExtensionApis - Supplies the address of the functions callable
        by this extension.

    lpArgumentString - Supplies the pattern and expression for this
        command.


Return Value:

    None.

--*/

{
    ULONG_PTR Address;
    ULONG result;
    NTSTATUS status=0;
    EXCEPTION_RECORD    Exr;
    ULONG   i;

    INIT_API();

    Address = GetExpression(lpArgumentString);
    if (!Address) {
        return;
    }

    move(Exr, Address);

    DumpExr( &Exr );

    return;
}


VOID
DllsExtension(
    PCSTR lpArgumentString,
    PPEB ProcessPeb
    );

DECLARE_API( dlls )

/*++

Routine Description:

    This function is called as an NTSD extension to dump the loaded module data
    base for the debugged process.


Arguments:

    hCurrentProcess - Supplies a handle to the current process (at the
        time the extension was called).

    hCurrentThread - Supplies a handle to the current thread (at the
        time the extension was called).

    CurrentPc - Supplies the current pc at the time the extension is
        called.

    lpExtensionApis - Supplies the address of the functions callable
        by this extension.

    lpArgumentString - Supplies the pattern and expression for this
        command.


Return Value:

    None.

--*/

{
    BOOL b;
    NTSTATUS Status;
    PROCESS_BASIC_INFORMATION ProcessInformation;
    PEB ThePeb;

    INIT_API();

    QueryPeb(hCurrentThread, &ThePeb);

    DllsExtension( (PCSTR)lpArgumentString, &ThePeb );
}

#include "dllsext.c"

VOID
HeapExtension(
    IN PCSTR lpArgumentString,
    IN PPEB ProcessPeb,
    IN ULONG_PTR SystemRangeStart
    );

DECLARE_API( heap )

/*++

Routine Description:

    This function is called as an NTSD extension to dump a user mode heap

    Called as:

        !heap [address [detail]]

    If an address if not given or an address of 0 is given, then the
    process heap is dumped.  If the address is -1, then all the heaps of
    the process are dumped.  If detail is specified, it defines how much
    detail is shown.  A detail of 0, just shows the summary information
    for each heap.  A detail of 1, shows the summary information, plus
    the location and size of all the committed and uncommitted regions.
    A detail of 3 shows the allocated and free blocks contained in each
    committed region.  A detail of 4 includes all of the above plus
    a dump of the free lists.

Arguments:

    hCurrentProcess - Supplies a handle to the current process (at the
        time the extension was called).

    hCurrentThread - Supplies a handle to the current thread (at the
        time the extension was called).

    CurrentPc - Supplies the current pc at the time the extension is
        called.

    lpExtensionApis - Supplies the address of the functions callable
        by this extension.

    lpArgumentString - Supplies the pattern and expression for this
        command.


Return Value:

    None.

--*/

{
    BOOL b;
    NTSTATUS Status;
    PROCESS_BASIC_INFORMATION ProcessInformation;
    ULONG_PTR SystemRangeStart;
    PEB ThePeb;

    INIT_API();

    QueryPeb(hCurrentThread, &ThePeb);

    Status = NtQuerySystemInformation(SystemRangeStartInformation,
                                      &SystemRangeStart,
                                      sizeof(SystemRangeStart),
                                      NULL
                                      );
    if (!NT_SUCCESS( Status )) {
        dprintf("    Unable to fetch SystemRangeStart\n" );
        SystemRangeStart = 0;
    }

    HeapExtension( (PCSTR)lpArgumentString, &ThePeb, SystemRangeStart );
}

#include "heapext.c"


VOID
AtomExtension(
    PCSTR lpArgumentString
    );



DECLARE_API( atom )

/*++

Routine Description:

    This function is called as an NTSD extension to dump a user mode atom table

    Called as:

        !atom [address]

    If an address if not given or an address of 0 is given, then the
    process atom table is dumped.

Arguments:

    hCurrentProcess - Supplies a handle to the current process (at the
        time the extension was called).

    hCurrentThread - Supplies a handle to the current thread (at the
        time the extension was called).

    CurrentPc - Supplies the current pc at the time the extension is
        called.

    lpExtensionApis - Supplies the address of the functions callable
        by this extension.

    lpArgumentString - Supplies the pattern and expression for this
        command.


Return Value:

    None.

--*/

{
    INIT_API();

    AtomExtension( (PCSTR)lpArgumentString );
}

#include "atomext.c"

DECLARE_API( gatom )

/*++

Routine Description:

    This function is called as an NTSD extension to dump the global atom table
    kept in kernel mode

    Called as:

        !gatom

Arguments:

    hCurrentProcess - Supplies a handle to the current process (at the
        time the extension was called).

    hCurrentThread - Supplies a handle to the current thread (at the
        time the extension was called).

    CurrentPc - Supplies the current pc at the time the extension is
        called.

    lpExtensionApis - Supplies the address of the functions callable
        by this extension.

    lpArgumentString - Supplies the pattern and expression for this
        command.


Return Value:

    None.

--*/

{
    NTSTATUS Status;
    ATOM_TABLE_INFORMATION TableInfo;
    PATOM_TABLE_INFORMATION pTableInfo;
    PATOM_BASIC_INFORMATION pBasicInfo;
    ULONG RequiredLength, MaxLength, i;

    INIT_API();

    dprintf("\nGlobal atom table ");
    Status = NtQueryInformationAtom( RTL_ATOM_INVALID_ATOM,
                                     AtomTableInformation,
                                     &TableInfo,
                                     sizeof( TableInfo ),
                                     &RequiredLength
                                   );
    if (Status != STATUS_INFO_LENGTH_MISMATCH) {
        dprintf( " - cant get information - %x\n", Status );
        return;
        }

    RequiredLength += 100 * sizeof( RTL_ATOM );
    pTableInfo = LocalAlloc( 0, RequiredLength );
    if (pTableInfo == NULL) {
        dprintf( " - cant allocate memory for %u atoms\n", RequiredLength / sizeof( RTL_ATOM ) );
        return;
        }

    Status = NtQueryInformationAtom( RTL_ATOM_INVALID_ATOM,
                                     AtomTableInformation,
                                     pTableInfo,
                                     RequiredLength,
                                     &RequiredLength
                                   );
    if (!NT_SUCCESS( Status )) {
        dprintf( " - cant get information about %x atoms - %x\n", RequiredLength / sizeof( RTL_ATOM ), Status );
        LocalFree( pTableInfo );
        return;
        }

    MaxLength = sizeof( *pBasicInfo ) + RTL_ATOM_MAXIMUM_NAME_LENGTH;
    pBasicInfo = LocalAlloc( 0, MaxLength );
    for (i=0; i<pTableInfo->NumberOfAtoms; i++) {
        Status = NtQueryInformationAtom( pTableInfo->Atoms[ i ],
                                         AtomBasicInformation,
                                         pBasicInfo,
                                         MaxLength,
                                         &RequiredLength
                                       );
        if (!NT_SUCCESS( Status )) {
            dprintf( "%hx *** query failed (%x)\n", Status );
            }
        else {
            dprintf( "%hx(%2d) = %ls (%d)%s\n",
                     pTableInfo->Atoms[ i ],
                     pBasicInfo->UsageCount,
                     pBasicInfo->Name,
                     pBasicInfo->NameLength,
                     pBasicInfo->Flags & RTL_ATOM_PINNED ? " pinned" : ""
                   );
            }
        }
}


VOID
KUserExtension(
    PCSTR lpArgumentString,
    KUSER_SHARED_DATA * const SharedData
    );


DECLARE_API( kuser )

/*++

Routine Description:

    This function is called as an NTSD extension to dump the shared user mode
    page (KUSER_SHARED_DATA)

    Called as:

        !kuser

Arguments:

    None

Return Value:

    None

--*/

{
    INIT_API();

    KUserExtension( (PCSTR)lpArgumentString, USER_SHARED_DATA );
}

#include "kuserext.c"

VOID
PebExtension(
    PCSTR lpArgumentString,
    PPEB pPeb
    );

DECLARE_API( peb )

/*++

Routine Description:

    This function is called as an NTSD extension to dump the PEB

    Called as:

        !peb

--*/

{
    NTSTATUS Status;
    ULONGLONG Address;

    INIT_API();

    Status = QueryPebAddress(hCurrentThread, &Address);
    if (!NT_SUCCESS(Status)) {
        dprintf("    Unable to query process PEB address (%x)\n", Status );
        return;
    }

    PebExtension( (PCSTR)lpArgumentString, (PPEB)Address );
}

VOID
TebExtension(
    PCSTR lpArgumentString,
    PTEB pTeb
    );

DECLARE_API( teb )

/*++

Routine Description:

    This function is called as an NTSD extension to dump the TEB

    Called as:

        !teb

--*/

{
    NTSTATUS Status;
    THREAD_BASIC_INFORMATION ThreadInformation;
    ULONGLONG Address;

    INIT_API();

    Status = QueryTebAddress(hCurrentThread, &Address);

    if (!NT_SUCCESS( Status )) {
        dprintf("    Unable to query thread TEB address (%x)\n", Status );
        return;
        }

    TebExtension( (PCSTR)lpArgumentString, (PTEB)Address);
}

#include "pebext.c"

VOID
ImageExtension(
    PSTR lpArgs
    );

DECLARE_API( dh )
{
    INIT_API();

    ImageExtension((PSTR)lpArgumentString);
    return;
}

#include "imageext.c"

///////////////////////////////////////////////////////////////////////////////

VOID
DebugPageHeapExtensionFind(
    PCSTR ArgumentString
    );

DECLARE_API( dphfind )
{
    INIT_API();
    DebugPageHeapExtensionFind( (PCSTR)lpArgumentString );
}

VOID
DebugPageHeapExtensionDump(
    PCSTR ArgumentString
    );

DECLARE_API( dphdump )
{
    INIT_API();
    DebugPageHeapExtensionDump( (PCSTR)lpArgumentString );
}

VOID
DebugPageHeapExtensionHogs(
    PCSTR ArgumentString
    );

DECLARE_API( dphhogs )
{
    INIT_API();
    DebugPageHeapExtensionHogs( (PCSTR)lpArgumentString );
}

VOID
DebugPageHeapExtensionFlags(
    PCSTR ArgumentString
    );

DECLARE_API( dphflags )
{
    INIT_API();
    DebugPageHeapExtensionFlags( (PCSTR)lpArgumentString );
}

#include "heappagx.c"

#include "hleak.c"

#include "secexts.c"



/*++

Routine Description:

    This function is called as an NTSD extension to mimic the !handle
    kd command.  This will walk through the debuggee's handle table
    and duplicate the handle into the ntsd process, then call NtQueryobjectInfo
    to find out what it is.

    Called as:

        !handle [handle [flags [Type]]]

    If the handle is 0 or -1, all handles are scanned.  If the handle is not
    zero, that particular handle is examined.  The flags are as follows
    (corresponding to secexts.c):
        1   - Get type information (default)
        2   - Get basic information
        4   - Get name information
        8   - Get object specific info (where available)

    If Type is specified, only object of that type are scanned.  Type is a
    standard NT type name, e.g. Event, Semaphore, etc.  Case sensitive, of
    course.

    Examples:

        !handle     -- dumps the types of all the handles, and a summary table
        !handle 0 0 -- dumps a summary table of all the open handles
        !handle 0 f -- dumps everything we can find about a handle.
        !handle 0 f Event
                    -- dumps everything we can find about open events

--*/
DECLARE_API( handle )
{
    HANDLE  hThere;
    DWORD   Type;
    PSTR    Args;
    DWORD   Mask;
    DWORD   HandleCount;
    NTSTATUS Status;
    DWORD   Total;
    DWORD   TypeCounts[TYPE_MAX];
    DWORD   Handle;
    DWORD   Hits;
    DWORD   Matches;
    DWORD   ObjectType;

    INIT_API();

    Mask = GHI_TYPE ;
    hThere = INVALID_HANDLE_VALUE;
    Type = 0;

    while (*lpArgumentString == ' ') {
        lpArgumentString++;
    }

    if ( strcmp( lpArgumentString, "-?" ) == 0 )
    {
        help(hCurrentProcess, hCurrentThread, dwCurrentPc,
                    lpExtensionApis, "handle" );

        return ;
    }

    hThere = (PVOID) GetExpression( lpArgumentString );

    while (*lpArgumentString && (*lpArgumentString != ' ') ) {
        lpArgumentString++;
    }
    while (*lpArgumentString == ' ') {
        lpArgumentString++;
    }

    if (*lpArgumentString) {
        Mask = (DWORD)GetExpression( lpArgumentString );
    }

    while (*lpArgumentString && (*lpArgumentString != ' ') ) {
        lpArgumentString++;
    }
    while (*lpArgumentString == ' ') {
        lpArgumentString++;
    }

    if (*lpArgumentString) {
        Type = GetObjectTypeIndex( lpArgumentString );
        if (Type == (DWORD) -1 ) {
            dprintf("Unknown type '%s'\n", lpArgumentString );
            return;
        }
    }

    //
    // if they specified 0, they just want the summary.  Make sure nothing
    // sneaks out.
    //

    if ( Mask == 0 ) {
        Mask = GHI_SILENT;
    }
    //
    // hThere of 0 indicates all handles.
    //
    if ((hThere == 0) || (hThere == INVALID_HANDLE_VALUE)) {
        Status = NtQueryInformationProcess( hCurrentProcess,
                                            ProcessHandleCount,
                                            &HandleCount,
                                            sizeof( HandleCount ),
                                            NULL );

        if ( !NT_SUCCESS( Status ) ) {
            return;
        }

        Hits = 0;
        Handle = 0;
        Matches = 0;
        ZeroMemory( TypeCounts, sizeof(TypeCounts) );

        while ( Hits < HandleCount ) {
            if ( Type ) {
                if (GetHandleInfo( hCurrentProcess,
                                   (HANDLE) Handle,
                                   GHI_TYPE | GHI_SILENT,
                                   &ObjectType ) ) {
                    Hits++;
                    if ( ObjectType == Type ) {
                        GetHandleInfo( hCurrentProcess,
                                        (HANDLE) Handle,
                                        Mask,
                                        &ObjectType );
                        Matches ++;
                    }

                }
            } else {
                if (GetHandleInfo(  hCurrentProcess,
                                    (HANDLE) Handle,
                                    GHI_TYPE | GHI_SILENT,
                                    &ObjectType) ) {
                    Hits++;
                    TypeCounts[ ObjectType ] ++;

                    GetHandleInfo(  hCurrentProcess,
                                    (HANDLE) Handle,
                                    Mask,
                                    &ObjectType );

                }
            }

            Handle += 4;
        }

        if ( Type == 0 ) {
            dprintf( "%d Handles\n", Hits );
            dprintf( "Type           \tCount\n");
            for (Type = 0; Type < TYPE_MAX ; Type++ ) {
                if (TypeCounts[Type]) {
                    dprintf("%-15ws\t%d\n", pszTypeNames[Type], TypeCounts[Type]);
                }
            }
        } else {
            dprintf("%d handles of type %ws\n", Matches, pszTypeNames[Type] );
        }


    } else {
        GetHandleInfo( hCurrentProcess, hThere, Mask, &Type );
    }

}


DECLARE_API( threadtoken )
{
    HANDLE hToken ;
    NTSTATUS Status ;

    INIT_API();

    Status = NtOpenThreadToken(
                    hCurrentThread,
                    TOKEN_READ,
                    TRUE,
                    &hToken );

    if ( !NT_SUCCESS( Status ) )
    {
        if ( Status == STATUS_ACCESS_DENIED )
        {
            //
            // Try to get around the ACL:
            //
        }

        if ( Status != STATUS_NO_TOKEN )
        {
            dprintf( "Can't open token, %d\n", RtlNtStatusToDosError( Status ) );
            return;
        }

        Status = NtOpenProcessToken(
                    hCurrentProcess,
                    TOKEN_READ,
                    &hToken );

        if ( !NT_SUCCESS( Status ) )
        {
            dprintf( "Can't open any token, %d\n", RtlNtStatusToDosError( Status ) );
            return ;
        }

        dprintf( "\n***Thread is not impersonating, using process token***\n" );
    }

    TokenInfo( hToken, 0xFFF );

    NtClose( hToken );

}



#define PAGE_ALL (PAGE_READONLY|\
                  PAGE_READWRITE|\
                  PAGE_WRITECOPY|\
                  PAGE_EXECUTE|\
                  PAGE_EXECUTE_READ|\
                  PAGE_EXECUTE_READWRITE|\
                  PAGE_EXECUTE_WRITECOPY|\
                  PAGE_NOACCESS)

VOID
printflags(
    DWORD Flags
    )
{
    switch (Flags & PAGE_ALL) {
        case PAGE_READONLY:
            dprintf("PAGE_READONLY");
            break;
        case PAGE_READWRITE:
            dprintf("PAGE_READWRITE");
            break;
        case PAGE_WRITECOPY:
            dprintf("PAGE_WRITECOPY");
            break;
        case PAGE_EXECUTE:
            dprintf("PAGE_EXECUTE");
            break;
        case PAGE_EXECUTE_READ:
            dprintf("PAGE_EXECUTE_READ");
            break;
        case PAGE_EXECUTE_READWRITE:
            dprintf("PAGE_EXECUTE_READWRITE");
            break;
        case PAGE_EXECUTE_WRITECOPY:
            dprintf("PAGE_EXECUTE_WRITECOPY");
            break;
        case PAGE_NOACCESS:
            if ((Flags & ~PAGE_NOACCESS) == 0) {
                dprintf("PAGE_NOACCESS");
                break;
            } // else fall through
        default:
            dprintf("*** Invalid page protection ***\n");
            return;
            break;
    }

    if (Flags & PAGE_NOCACHE) {
        dprintf(" + PAGE_NOCACHE");
    }
    if (Flags & PAGE_GUARD) {
        dprintf(" + PAGE_GUARD");
    }
    dprintf("\n");
}



DECLARE_API( vprot )
/*++

Routine Description:

    This debugger extension dumps the virtual memory info for the
    address specified.

Arguments:


Return Value:

--*/
{
    PVOID Address;
    DWORD ReturnLength;
    MEMORY_BASIC_INFORMATION mbi;

    INIT_API();

    while (*lpArgumentString == ' ') {
        lpArgumentString++;
    }

    Address = (PVOID)GetExpression( lpArgumentString );


    ReturnLength = VirtualQueryEx( hCurrentProcess, Address, &mbi, sizeof(mbi) );

    if (ReturnLength == 0) {
        dprintf("vprot: VirtualQueryEx failed, error = %d\n", GetLastError());
        return;
    }

    dprintf("BaseAddress:       %p\n",   mbi.BaseAddress);
    dprintf("AllocationBase:    %08x\n", mbi.AllocationBase);
    dprintf("AllocationProtect: %08x  ", mbi.AllocationProtect);
    printflags(mbi.AllocationProtect);

    dprintf("RegionSize:        %08x\n", mbi.RegionSize);
    dprintf("State:             %08x  ", mbi.State);
    switch (mbi.State) {
        case MEM_COMMIT:
            dprintf("MEM_COMMIT\n");
            break;
        case MEM_FREE:
            dprintf("MEM_FREE\n");
            break;
        case MEM_RESERVE:
            dprintf("MEM_RESERVE\n");
            break;
        default:
            dprintf("*** Invalid page state ***\n");
            break;
    }

    dprintf("Protect:           %08x  ", mbi.Protect);
    printflags(mbi.Protect);

    dprintf("Type:              %08x  ", mbi.Type);
    switch(mbi.Type) {
        case MEM_IMAGE:
            dprintf("MEM_IMAGE\n");
            break;
        case MEM_MAPPED:
            dprintf("MEM_MAPPED\n");
            break;
        case MEM_PRIVATE:
            dprintf("MEM_PRIVATE\n");
            break;
        default:
            dprintf("*** Invalid page type ***\n");
            break;
    }

}

VOID
GFlagExtension(
    PVOID pNtGlobalFlag,
    ULONG ValidBits,
    PCSTR lpArgumentString
    );


DECLARE_API( gflag )

/*++

Routine Description:

    This function is called as an NTSD extension to dump or modify
    the contents of the NtGlobalFlag variable in NTDLL

    Called as:

        !gflag [value]

    If a value is not given then displays the current bits set in
    NTDLL!NtGlobalFlag variable.  Otherwise value can be one of the
    following:

        -? - displays a list of valid flag abbreviations
        number - 32-bit number that becomes the new value stored into
                 NtGlobalFlag
        +number - specifies one or more bits to set in NtGlobalFlag
        +abbrev - specifies a single bit to set in NtGlobalFlag
        -number - specifies one or more bits to clear in NtGlobalFlag
        -abbrev - specifies a single bit to clear in NtGlobalFlag

Arguments:

    hCurrentProcess - Supplies a handle to the current process (at the
        time the extension was called).

    hCurrentThread - Supplies a handle to the current thread (at the
        time the extension was called).

    CurrentPc - Supplies the current pc at the time the extension is
        called.

    lpExtensionApis - Supplies the address of the functions callable
        by this extension.

    lpArgumentString - Supplies the pattern and expression for this
        command.


Return Value:

    None.

--*/

{
    NTSTATUS Status;
    PROCESS_BASIC_INFORMATION ProcessInformation;
    ULONGLONG Address;

    INIT_API();

    Status = NtQueryInformationProcess( ExtensionCurrentProcess,
                                        ProcessBasicInformation,
                                        &ProcessInformation,
                                        sizeof( ProcessInformation ),
                                        NULL
                                      );

    Status = QueryPebAddress(hCurrentThread, &Address);

    if (!NT_SUCCESS( Status )) {
        dprintf("    Unable to query process PEB address (%x)\n", Status );
        return;
    }

    GFlagExtension( (PVOID)(Address + FIELD_OFFSET(PEB, NtGlobalFlag)),
                    FLG_USERMODE_VALID_BITS,
                    (PCSTR)lpArgumentString
                  );
}

#include "gflagext.c"

#include "leak.c"


#include "regexts.c"
/*++

Routine Description:

    This function is called as an NTSD extension to dump registry information

    Called as:

        !dreg -[d|w] <keyPath>[![<valueName> | *]]

Arguments:

    hCurrentProcess - Supplies a handle to the current process (at the
        time the extension was called).

    hCurrentThread - Supplies a handle to the current thread (at the
        time the extension was called).

    CurrentPc - Supplies the current pc at the time the extension is
        called.

    lpExtensionApis - Supplies the address of the functions callable
        by this extension.

    lpArgumentString - Supplies the pattern and expression for this
        command.


Return Value:

    None.

--*/

DECLARE_API( dreg )
{
    DWORD    opts = 1;

    INIT_API();


    // Skip past leading spaces
    while (*lpArgumentString == ' ')
    {
        lpArgumentString++;
    }

    if (*lpArgumentString == '-')
    {
        lpArgumentString++;
        switch (*lpArgumentString)
        {
        case 'd':
            opts = 4;
            break;
        case 'w':
            opts = 2;
            break;
        default:
            opts = 1;
            break;
        }

        if (*lpArgumentString)
        {
            // expect a space between options
            lpArgumentString++;

            // Skip past leading spaces
            while (*lpArgumentString == ' ')
            {
                lpArgumentString++;
            }
        }
    }

    Idreg(opts, lpArgumentString);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\ntsdexts\pebext.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    pebext.c

Abstract:

    This function contains the peb ntsd debugger extension

Author:

    Mark Lucovsky (markl) 09-Apr-1991

Revision History:

--*/

void
Fixup(
    PVOID Base,
    PUNICODE_STRING String
    )
{
    if (String->Buffer != NULL) {
        String->Buffer = (PWSTR)((PCHAR)String->Buffer + (ULONG_PTR)Base);
        }

    return;
}

static UNICODE_STRING GetUString;
static WCHAR GetUStringBuffer[ 1024 ];

#ifdef HOST_i386
VOID
xRtlInitUnicodeString(
    OUT PUNICODE_STRING DestinationString,
    IN PCWSTR SourceString OPTIONAL
    )
{
    ULONG Length;

    DestinationString->Buffer = (PWSTR)SourceString;
    if (ARGUMENT_PRESENT( SourceString )) {
        Length = wcslen( SourceString ) * sizeof( WCHAR );
        DestinationString->Length = (USHORT)Length;
        DestinationString->MaximumLength = (USHORT)(Length + sizeof(UNICODE_NULL));
        }
    else {
        DestinationString->MaximumLength = 0;
        DestinationString->Length = 0;
        }
}

#define RtlInitUnicodeString xRtlInitUnicodeString

#endif

PUNICODE_STRING
GetUS(
    PUNICODE_STRING String
    )
{
    RtlInitUnicodeString(&GetUString, NULL);
    if (String->Buffer != NULL && String->Length > 0) {
        GetUString = *String;
        if (GetUString.Length >= sizeof( GetUStringBuffer )) {
            GetUString.Length = sizeof( GetUStringBuffer ) - sizeof( UNICODE_NULL );
            }
        GetUString.Buffer = GetUStringBuffer;
        if (!ReadMemory( (ULONG_PTR)String->Buffer,
                         GetUStringBuffer,
                         GetUString.Length,
                         NULL
                       )
           ) {
            wcscpy( GetUStringBuffer, L"*** unable to read string" );
            GetUString.Length = wcslen( GetUStringBuffer ) * sizeof( WCHAR );
            }
        else {
            GetUStringBuffer[ GetUString.Length / sizeof( WCHAR ) ] = UNICODE_NULL;
            }
        }

    return &GetUString;
}

VOID
PebExtension(
    PCSTR lpArgumentString,
    PPEB pPeb
    )
{
    PEB Peb;
    PPEB_LDR_DATA pLdr;
    PEB_LDR_DATA Ldr;
    PLIST_ENTRY pHead, pNext;
    LDR_DATA_TABLE_ENTRY Entry;
    WCHAR DllNameBuffer[ 256 ];
    RTL_USER_PROCESS_PARAMETERS ProcessParameters;

    if (*lpArgumentString) {
        sscanf( lpArgumentString, "%lx", &pPeb );
        }
    dprintf( "PEB at %p\n", pPeb );

    if (!ReadMemory( (ULONG_PTR)pPeb,
                     &Peb,
                     sizeof( Peb ),
                     NULL
                   )
       ) {
        dprintf( "    *** unable to read PEB\n" );
        return;
        }

    dprintf( "    InheritedAddressSpace:    %s\n", Peb.InheritedAddressSpace ? "Yes" : "No" );
    dprintf( "    ReadImageFileExecOptions: %s\n", Peb.ReadImageFileExecOptions ? "Yes" : "No" );
    dprintf( "    BeingDebugged:            %s\n", Peb.BeingDebugged ? "Yes" : "No" );
    dprintf( "    ImageBaseAddress:         %p\n", Peb.ImageBaseAddress );
    if (ReadMemory( (ULONG_PTR)Peb.Ldr,
                    &Ldr,
                    sizeof( Ldr ),
                    NULL
                  )
       ) {
        dprintf( "    Ldr.Initialized: %s\n", Ldr.Initialized ? "Yes" : "No" );
        dprintf( "    Ldr.InInitializationOrderModuleList: %x . %x\n",
                 Ldr.InInitializationOrderModuleList.Flink,
                 Ldr.InInitializationOrderModuleList.Blink
               );
        dprintf( "    Ldr.InLoadOrderModuleList: %x . %x\n",
                 Ldr.InLoadOrderModuleList.Flink,
                 Ldr.InLoadOrderModuleList.Blink
               );
        dprintf( "    Ldr.InMemoryOrderModuleList: %x . %x\n",
                 Ldr.InMemoryOrderModuleList.Flink,
                 Ldr.InMemoryOrderModuleList.Blink
               );

        pHead = &Peb.Ldr->InMemoryOrderModuleList;
        pNext = Ldr.InMemoryOrderModuleList.Flink;
        while (pNext != pHead) {
            if (ReadMemory( (ULONG_PTR) CONTAINING_RECORD( pNext, LDR_DATA_TABLE_ENTRY, InMemoryOrderLinks ),
                            &Entry,
                            sizeof( Entry ),
                            NULL
                          )
               ) {
                if (ReadMemory( (ULONG_PTR)(Entry.FullDllName.Buffer),
                                DllNameBuffer,
                                Entry.FullDllName.Length + sizeof( UNICODE_NULL ),
                                NULL
                              )
                   ) {
                    Entry.FullDllName.Buffer = DllNameBuffer;
                    }
                else {
                    RtlInitUnicodeString( &Entry.FullDllName, L"*** unable to read name ***" );
                    }

                dprintf( "        %p %wZ\n", Entry.DllBase, &Entry.FullDllName );
                }
            else {
                dprintf( "        *** unable to read LDR entry at %p\n",
                         CONTAINING_RECORD( pNext, LDR_DATA_TABLE_ENTRY, InMemoryOrderLinks )
                       );
                break;
                }

            pNext = Entry.InMemoryOrderLinks.Flink;
            }
        }
    else {
        dprintf( "    *** unable to read Ldr table at %p\n", Peb.Ldr );
        }

    dprintf( "    SubSystemData:     %x\n", Peb.SubSystemData );
    dprintf( "    ProcessHeap:       %x\n", Peb.ProcessHeap );
    dprintf( "    ProcessParameters: %x\n", Peb.ProcessParameters );
    if (ReadMemory( (ULONG_PTR)Peb.ProcessParameters,
                    &ProcessParameters,
                    sizeof( ProcessParameters ),
                    NULL
                  )
       ) {
        if (!(ProcessParameters.Flags & RTL_USER_PROC_PARAMS_NORMALIZED)) {
            Fixup( Peb.ProcessParameters, &ProcessParameters.DllPath );
            Fixup( Peb.ProcessParameters, &ProcessParameters.ImagePathName );
            Fixup( Peb.ProcessParameters, &ProcessParameters.CommandLine );
            Fixup( Peb.ProcessParameters, &ProcessParameters.WindowTitle );
            }


        dprintf( "        WindowTitle:  '%wZ'\n", GetUS( &ProcessParameters.WindowTitle ) );
        dprintf( "        ImageFile:    '%wZ'\n", GetUS( &ProcessParameters.ImagePathName ) );
        dprintf( "        CommandLine:  '%wZ'\n", GetUS( &ProcessParameters.CommandLine ) );
        dprintf( "        DllPath:      '%wZ'\n", GetUS( &ProcessParameters.DllPath ) );
        dprintf( "        Environment:  0x%x\n", ProcessParameters.Environment );
        }
    else {
        dprintf( "    *** unable to read process parameters\n" );
        }
    return;
}


VOID
TebExtension(
    PCSTR lpArgumentString,
    PTEB pTeb
    )
{
    TEB Teb;

    if (*lpArgumentString) {
        sscanf( lpArgumentString, "%lx", &pTeb );
        }
    dprintf( "TEB at %p\n", pTeb );

    if (!ReadMemory( (ULONG_PTR)pTeb,
                     &Teb,
                     sizeof( Teb ),
                     NULL
                   )
       ) {
        dprintf( "    *** unable to read TEB\n" );
        return;
        }

    dprintf( "    ExceptionList:    %x\n", Teb.NtTib.ExceptionList );
    dprintf( "    Stack Base:       %x\n", Teb.NtTib.StackBase );
    dprintf( "    Stack Limit:      %x\n", Teb.NtTib.StackLimit );
    dprintf( "    SubSystemTib:     %x\n", Teb.NtTib.SubSystemTib );
    dprintf( "    FiberData:        %x\n", Teb.NtTib.FiberData );
    dprintf( "    ArbitraryUser:    %x\n", Teb.NtTib.ArbitraryUserPointer );
    dprintf( "    Self:             %x\n", Teb.NtTib.Self );
    dprintf( "    EnvironmentPtr:   %x\n", Teb.EnvironmentPointer );
    dprintf( "    ClientId:         %x.%x\n", Teb.ClientId.UniqueProcess, Teb.ClientId.UniqueThread );
    if (Teb.ClientId.UniqueProcess != Teb.RealClientId.UniqueProcess ||
        Teb.ClientId.UniqueThread != Teb.RealClientId.UniqueThread
       ) {
        dprintf( "    Real ClientId:    %x.%x\n", Teb.RealClientId.UniqueProcess, Teb.RealClientId.UniqueThread );
        }
    dprintf( "    Real ClientId:    %x.%x\n", Teb.RealClientId.UniqueProcess, Teb.RealClientId.UniqueThread );
    dprintf( "    RpcHandle:        %x\n", Teb.ActiveRpcHandle );
    dprintf( "    Tls Storage:      %x\n", Teb.ThreadLocalStoragePointer );
    dprintf( "    PEB Address:      %x\n", Teb.ProcessEnvironmentBlock );
    dprintf( "    LastErrorValue:   %u\n", Teb.LastErrorValue );
    dprintf( "    LastStatusValue:  %x\n", Teb.LastStatusValue );
    dprintf( "    Count Owned Locks:%u\n", Teb.CountOfOwnedCriticalSections );
    dprintf( "    HardErrorsMode:   %u\n", Teb.HardErrorsAreDisabled );

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\ntsdexts\kuserext.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    kuserext.c

Abstract:

    This function contains the kuser ntsd debugger extension

Author:

    Mark Lucovsky (markl) 09-Apr-1991

Revision History:

--*/

char *DriveTypes[] = {
    "DOSDEVICE_DRIVE_UNKNOWN",
    "DOSDEVICE_DRIVE_CALCULATE",
    "DOSDEVICE_DRIVE_REMOVABLE",
    "DOSDEVICE_DRIVE_FIXED",
    "DOSDEVICE_DRIVE_REMOTE",
    "DOSDEVICE_DRIVE_CDROM",
    "DOSDEVICE_DRIVE_RAMDISK"
};


VOID
KUserExtension(
    PCSTR lpArgumentString,
    KUSER_SHARED_DATA * const SharedData
    )
{
    KUSER_SHARED_DATA p;
    BOOLEAN fFirst;
    ULONG i;

    try {
        moveBlock(p, SharedData, sizeof(p));
        dprintf( "KUSER_SHARED_DATA at %x\n", SharedData ),
        dprintf( "TickCount:    %x * %08x\n",
                 p.TickCountMultiplier,
                 p.TickCountLow
               );


#if 0
        dprintf( "Interrupt Time: %x:%08x:%08x\n",
                 p.InterruptTime.High2Time,
                 p.InterruptTime.High1Time,
                 p.InterruptTime.LowPart
               );
        dprintf( "System Time: %x:%08x:%08x\n",
                 p.SystemTime.High2Time,
                 p.SystemTime.High1Time,
                 p.SystemTime.LowPart
               );
        dprintf( "TimeZone Bias: %x:%08x:%08x\n",
                 p.TimeZoneBias.High2Time,
                 p.TimeZoneBias.High1Time,
                 p.TimeZoneBias.LowPart
               );
#endif
        dprintf( "TimeZone Id: %x\n", p.TimeZoneId );

        dprintf( "ImageNumber Range: [%x .. %x]\n",
                 p.ImageNumberLow,
                 p.ImageNumberHigh
               );
        dprintf( "Crypto Exponent: %x\n", p.CryptoExponent );

        dprintf( "SystemRoot: '%ws'\n",
                 p.NtSystemRoot
               );


#if 0
        dprintf( "DosDeviceMap: %08x", p.DosDeviceMap );
        fFirst = TRUE;
        for (i=0; i<32; i++) {
            if (p.DosDeviceMap & (1 << i)) {
                if (fFirst) {
                    dprintf( " (" );
                    fFirst = FALSE;
                    }
                else {
                    dprintf( " " );
                    }
                dprintf( "%c:", 'A'+i );
                }
            }
        if (!fFirst) {
            dprintf( ")" );
            }
        dprintf( "\n" );

        for (i=0; i<32; i++) {
            if (p.DosDeviceDriveType[ i ] > DOSDEVICE_DRIVE_UNKNOWN &&
                p.DosDeviceDriveType[ i ] <= DOSDEVICE_DRIVE_RAMDISK
               ) {
                dprintf( "DriveType[ %02i ] (%c:) == %s\n",
                         i, 'A'+i,
                         DriveTypes[ p.DosDeviceDriveType[ i ] ]
                       );
                }
            }
#endif

    } except (EXCEPTION_EXECUTE_HANDLER) {
        ;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\rdbld\ldrreloc.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

   ldrreloc.c

Abstract:

    This module contains the code to relocate an image when
    the preferred base isn't available. This is called by the
    boot loader, device driver loader, and system loader.

Author:

    Mike O'Leary (mikeol) 03-Feb-1992

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

ULONG
xxxLdrRelocateImage (
    IN PVOID ImageToRelocate,
    IN PVOID LoadAddress,
    IN PUCHAR LoaderName,
    IN ULONG Success,
    IN ULONG Conflict,
    IN ULONG Invalid
    )

/*++

Routine Description:

    This routine relocates an image file that was not loaded into memory
    at the preferred address.

Arguments:

    NewBase - Supplies a pointer to the image base.

    LoaderName - Indicates which loader routine is being called from.

    Success - Value to return if relocation successful.

    Conflict - Value to return if can't relocate.

    Invalid - Value to return if relocations are invalid.

Return Value:

    Success if image is relocated.
    Conflict if image can't be relocated.
    Invalid if image contains invalid fixups.

--*/

{
    LONG_PTR Diff;
    ULONG TotalCountBytes;
    ULONG_PTR VA;
    ULONG_PTR OldBase;
    ULONG SizeOfBlock;
    PUCHAR FixupVA;
    USHORT Offset;
    PUSHORT NextOffset;
    PIMAGE_NT_HEADERS NtHeaders;
    PIMAGE_BASE_RELOCATION NextBlock;

    NtHeaders = RtlImageNtHeader( ImageToRelocate );
    if ( NtHeaders ) {
        OldBase = NtHeaders->OptionalHeader.ImageBase;
        }
    else {
        return Invalid;
        }

    //
    // Locate the relocation section.
    //

    NextBlock = (PIMAGE_BASE_RELOCATION)RtlImageDirectoryEntryToData(
            ImageToRelocate, TRUE, IMAGE_DIRECTORY_ENTRY_BASERELOC, &TotalCountBytes);

    if (!NextBlock || !TotalCountBytes) {

        //
        // The image does not contain a relocation table, and therefore
        // cannot be relocated.
        //
#if DBG
        DbgPrint("%s: Image can't be relocated, no fixup information.\n", LoaderName);
#endif // DBG
        return Conflict;
    }

    //
    // If the image has a relocation table, then apply the specified fixup
    // information to the image.
    //

    while (TotalCountBytes) {
        SizeOfBlock = NextBlock->SizeOfBlock;
        TotalCountBytes -= SizeOfBlock;
        SizeOfBlock -= sizeof(IMAGE_BASE_RELOCATION);
        SizeOfBlock /= sizeof(USHORT);
        NextOffset = (PUSHORT)((PCHAR)NextBlock + sizeof(IMAGE_BASE_RELOCATION));

        VA = (ULONG_PTR)ImageToRelocate + NextBlock->VirtualAddress;
        Diff = (PCHAR)LoadAddress - (PCHAR)OldBase;

        if ( !(NextBlock = LdrProcessRelocationBlock(VA,SizeOfBlock,NextOffset,Diff)) ) {
#if DBG
            DbgPrint("%s: Unknown base relocation type\n", LoaderName);
#endif
            return Invalid;
        }
    }

    return Success;
}

PIMAGE_BASE_RELOCATION
LdrProcessRelocationBlock(
    IN ULONG_PTR VA,
    IN ULONG SizeOfBlock,
    IN PUSHORT NextOffset,
    IN LONG_PTR Diff
    )
{
    PUCHAR FixupVA;
    USHORT Offset;
    LONG Temp;

    while (SizeOfBlock--) {

       Offset = *NextOffset & (USHORT)0xfff;
       FixupVA = (PUCHAR)(VA + Offset);

       //
       // Apply the fixups.
       //

       switch ((*NextOffset) >> 12) {

            case IMAGE_REL_BASED_HIGHLOW :
                //
                // HighLow - (32-bits) relocate the high and low half
                //      of an address.
                //
                *(LONG UNALIGNED *)FixupVA += (ULONG) Diff;
                break;

            case IMAGE_REL_BASED_HIGH :
                //
                // High - (16-bits) relocate the high half of an address.
                //
                Temp = *(PUSHORT)FixupVA << 16;
                Temp += (ULONG) Diff;
                *(PUSHORT)FixupVA = (USHORT)(Temp >> 16);
                break;

            case IMAGE_REL_BASED_HIGHADJ :
                //
                // Adjust high - (16-bits) relocate the high half of an
                //      address and adjust for sign extension of low half.
                //

                Temp = *(PUSHORT)FixupVA << 16;
                ++NextOffset;
                --SizeOfBlock;
                Temp += (LONG)(*(PSHORT)NextOffset);
                Temp += (ULONG) Diff;
                Temp += 0x8000;
                *(PUSHORT)FixupVA = (USHORT)(Temp >> 16);

                break;

            case IMAGE_REL_BASED_LOW :
                //
                // Low - (16-bit) relocate the low half of an address.
                //
                Temp = *(PSHORT)FixupVA;
                Temp += (ULONG) Diff;
                *(PUSHORT)FixupVA = (USHORT)Temp;
                break;

            case IMAGE_REL_BASED_ABSOLUTE :
                //
                // Absolute - no fixup required.
                //
                break;

            case IMAGE_REL_BASED_SECTION :
                //
                // Section Relative reloc.  Ignore for now.
                //
                break;

            case IMAGE_REL_BASED_REL32 :
                //
                // Relative intrasection. Ignore for now.
                //
                break;

            default :
                //
                // Illegal - illegal relocation type.
                //

                return (PIMAGE_BASE_RELOCATION)NULL;
       }
       ++NextOffset;
    }
    return (PIMAGE_BASE_RELOCATION)NextOffset;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\ntsdexts\imageext.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    peext.c

Abstract:

    This module contains the PE dump extensions

Author:

    Kent Forschmiedt (kentf) 10-May-1995

Revision History:

--*/

#include <time.h>


// STYP_ flags values for MIPS ROM images

#define STYP_REG      0x00000000
#define STYP_TEXT     0x00000020
#define STYP_INIT     0x80000000
#define STYP_RDATA    0x00000100
#define STYP_DATA     0x00000040
#define STYP_LIT8     0x08000000
#define STYP_LIT4     0x10000000
#define STYP_SDATA    0x00000200
#define STYP_SBSS     0x00000080
#define STYP_BSS      0x00000400
#define STYP_LIB      0x40000000
#define STYP_UCODE    0x00000800
#define S_NRELOC_OVFL 0x20000000

#define IMAGE_SCN_MEM_SYSHEAP       0x00010000  // Obsolete
#define IMAGE_SCN_MEM_PROTECTED     0x00004000  // Obsolete


const static char * const MachineName[] = {
    "Unknown",
    "i386",
    "Alpha AXP",
    "Alpha AXP64",
    "Intel IA64",
};

const static char * const SubsystemName[] = {
    "Unknown",
    "Native",
    "Windows GUI",
    "Windows CUI",
    "Posix CUI",
};

const static char * const DirectoryEntryName[] = {
    "Export",
    "Import",
    "Resource",
    "Exception",
    "Security",
    "Base Relocation",
    "Debug",
    "Description",
    "Special",
    "Thread Storage",
    "Load Configuration",
    "Bound Import",
    "Import Address Table",
    "Reserved",
    "Reserved",
    "Reserved",
    0
};

typedef enum DFT
{
   dftUnknown,
   dftObject,
   dftPE,
   dftROM,
   dftDBG,
   dftPEF,
} DFT;

typedef struct NB10I                   // NB10 debug info
{
    DWORD   nb10;                      // NB10
    DWORD   off;                       // offset, always 0
    DWORD   sig;
    DWORD   age;
} NB10I;

IMAGE_NT_HEADERS ImageNtHeaders;
PIMAGE_FILE_HEADER ImageFileHdr;
PIMAGE_OPTIONAL_HEADER ImageOptionalHdr;
PIMAGE_SECTION_HEADER SectionHdrs;
ULONG_PTR Base;
DFT dft;


VOID
DumpHeaders (
    VOID
    );

VOID
DumpSections(
    VOID
    );

BOOL
TranslateFilePointerToVirtualAddress(
    IN ULONG FilePointer,
    OUT PULONG VirtualAddress
    );

VOID
DumpImage(
    ULONG_PTR xBase,
    BOOL DoHeaders,
    BOOL DoSections
    );

VOID
ImageExtension(
    IN PSTR lpArgs
    )
{
    BOOL DoAll;
    BOOL DoSections;
    BOOL DoHeaders;
    CHAR c;
    PCHAR p;
    ULONG_PTR xBase;

    //
    // Evaluate the argument string to get the address of the
    // image to dump.
    //

    DoAll = TRUE;
    DoHeaders = FALSE;
    DoSections = FALSE;

    xBase = 0;

    while (*lpArgs) {

        while (isspace(*lpArgs)) {
            lpArgs++;
        }

        if (*lpArgs == '/' || *lpArgs == '-') {

            // process switch

            switch (*++lpArgs) {

                case 'a':   // dump everything we can
                case 'A':
                    ++lpArgs;
                    DoAll = TRUE;
                    break;

                default: // invalid switch

                case 'h':   // help
                case 'H':
                case '?':

                    dprintf("Usage: dh [options] address\n");
                    dprintf("\n");
                    dprintf("Dumps headers from an image based at address.\n");
                    dprintf("\n");
                    dprintf("Options:\n");
                    dprintf("\n");
                    dprintf("   -a      Dump everything\n");
                    dprintf("   -f      Dump file headers\n");
                    dprintf("   -s      Dump section headers\n");
                    dprintf("\n");

                    return;

                case 'f':
                case 'F':
                    ++lpArgs;
                    DoAll = FALSE;
                    DoHeaders = TRUE;
                    break;

                case 's':
                case 'S':
                    ++lpArgs;
                    DoAll = FALSE;
                    DoSections = TRUE;
                    break;

            }

        } else if (*lpArgs) {

            if (xBase != 0) {
                dprintf("Invalid extra argument\n");
                return;
            }

            p = lpArgs;
            while (*p && !isspace(*p)) {
                p++;
            }
            c = *p;
            *p = 0;

            xBase = GetExpression(lpArgs);

            *p = c;
            lpArgs=p;

        }

    }

    if ( !xBase ) {
        return;
    }

    DumpImage(xBase, DoAll || DoHeaders, DoAll || DoSections);
}

VOID
DumpImage(
    ULONG_PTR xBase,
    BOOL DoHeaders,
    BOOL DoSections
    )
{
    IMAGE_DOS_HEADER DosHeader;
    ULONG cb;
    ULONG_PTR Offset;
    BOOL Ok;

    Base = xBase;

    Ok = ReadMemory(Base, &DosHeader, sizeof(DosHeader), &cb);

    if (!Ok) {
        dprintf("Can't read file header: error == %d\n", GetLastError());
        return;
    }

    if (cb != sizeof(DosHeader) || DosHeader.e_magic != IMAGE_DOS_SIGNATURE) {
        dprintf("No file header.\n");
        return;
    }

    Offset = Base + DosHeader.e_lfanew;

    Ok = ReadMemory(Offset, &ImageNtHeaders, sizeof(ImageNtHeaders), &cb);

    if (!Ok) {
        dprintf("Can't read optional header: error == %d\n", GetLastError());
        return;
    }

    if (cb != sizeof(ImageNtHeaders)) {
        dprintf("Bad file header.\n");
        return;
    }

    ImageFileHdr = &ImageNtHeaders.FileHeader;
    ImageOptionalHdr = &ImageNtHeaders.OptionalHeader;


    if (ImageFileHdr->SizeOfOptionalHeader == sizeof(IMAGE_ROM_OPTIONAL_HEADER)) {
        dft = dftROM;
    } else if (ImageFileHdr->Characteristics & IMAGE_FILE_DLL) {
        dft = dftPE;
    } else if (ImageFileHdr->Characteristics & IMAGE_FILE_EXECUTABLE_IMAGE) {
        dft = dftPE;
    } else if (ImageFileHdr->SizeOfOptionalHeader == 0) {
        dft = dftObject;
    } else {
        dft = dftUnknown;
    }

    if (DoHeaders) {
        DumpHeaders();
    }

    if (DoSections) {

        SectionHdrs = (PIMAGE_SECTION_HEADER) malloc(ImageFileHdr->NumberOfSections * sizeof(IMAGE_SECTION_HEADER));
        try {

            Ok = ReadMemory(
                            Offset + sizeof(IMAGE_NT_HEADERS) + ImageFileHdr->SizeOfOptionalHeader - sizeof(IMAGE_OPTIONAL_HEADER),
                            SectionHdrs,
                            ImageFileHdr->NumberOfSections * sizeof(IMAGE_SECTION_HEADER),
                            &cb);

            if (!Ok) {
                dprintf("Can't read section headers.\n");
            } else {

                if (cb != ImageFileHdr->NumberOfSections * sizeof(IMAGE_SECTION_HEADER)) {
                    dprintf("\n***\n*** Some section headers may be missing ***\n***\n\n");
                    ImageFileHdr->NumberOfSections = (USHORT)(cb / sizeof(IMAGE_SECTION_HEADER));
                }

                DumpSections( );

            }

        }
        finally {

            if (SectionHdrs) {
                free(SectionHdrs);
                SectionHdrs = 0;
            }

        }

    }

}

VOID
DumpHeaders (
    VOID
    )

/*++

Routine Description:

    Formats the file header and optional header.

Arguments:

    None.

Return Value:

    None.

--*/

{
    int i, j;
    const char *time;
    const char *name;
    DWORD dw;

    // Print out file type

    switch (dft) {
        case dftObject :
            dprintf("\nFile Type: COFF OBJECT\n");
            break;

        case dftPE :
            if (ImageFileHdr->Characteristics & IMAGE_FILE_DLL) {
                dprintf("\nFile Type: DLL\n");
            } else {
                dprintf("\nFile Type: EXECUTABLE IMAGE\n");
            }
            break;

        case dftROM :
            dprintf("\nFile Type: ROM IMAGE\n");
            break;

        default :
            dprintf("\nFile Type: UNKNOWN\n");
            break;

    }

    switch (ImageFileHdr->Machine) {
        case IMAGE_FILE_MACHINE_I386     : i = 1; break;
        case IMAGE_FILE_MACHINE_ALPHA    : i = 2; break;
        case IMAGE_FILE_MACHINE_ALPHA64  : i = 3; break;
        case IMAGE_FILE_MACHINE_IA64     : i = 4; break;
        default : i = 0;
    }

    dprintf(
           "FILE HEADER VALUES\n"
           "%8hX machine (%s)\n"
           "%8hX number of sections\n"
           "%8lX time date stamp",
           ImageFileHdr->Machine,
           MachineName[i],
           ImageFileHdr->NumberOfSections,
           ImageFileHdr->TimeDateStamp);

    if ((time = ctime((time_t *) &ImageFileHdr->TimeDateStamp)) != NULL) {
        dprintf( " %s", time);
    }
    dprintf("\n");

    dprintf(
           "%8lX file pointer to symbol table\n"
           "%8lX number of symbols\n"
           "%8hX size of optional header\n"
           "%8hX characteristics\n",
           ImageFileHdr->PointerToSymbolTable,
           ImageFileHdr->NumberOfSymbols,
           ImageFileHdr->SizeOfOptionalHeader,
           ImageFileHdr->Characteristics);

    for (dw = ImageFileHdr->Characteristics, j = 0; dw; dw >>= 1, j++) {
        if (dw & 1) {
            switch (1 << j) {
                case IMAGE_FILE_RELOCS_STRIPPED     : name = "Relocations stripped"; break;
                case IMAGE_FILE_EXECUTABLE_IMAGE    : name = "Executable"; break;
                case IMAGE_FILE_LINE_NUMS_STRIPPED  : name = "Line numbers stripped"; break;
                case IMAGE_FILE_LOCAL_SYMS_STRIPPED : name = "Symbols stripped"; break;
                case IMAGE_FILE_BYTES_REVERSED_LO   : name = "Bytes reversed"; break;
                case IMAGE_FILE_32BIT_MACHINE       : name = "32 bit word machine"; break;
                case IMAGE_FILE_DEBUG_STRIPPED      : name = "Debug information stripped"; break;
                case IMAGE_FILE_SYSTEM              : name = "System"; break;
                case IMAGE_FILE_DLL                 : name = "DLL"; break;
                case IMAGE_FILE_BYTES_REVERSED_HI   : name = ""; break;
                default : name = "RESERVED - UNKNOWN";
            }

            if (*name) {
                dprintf( "            %s\n", name);
            }
        }
    }

    if (ImageFileHdr->SizeOfOptionalHeader != 0) {
        char szLinkerVersion[30];

        sprintf(szLinkerVersion,
                "%u.%02u",
                ImageOptionalHdr->MajorLinkerVersion,
                ImageOptionalHdr->MinorLinkerVersion);

        dprintf(
                "\n"
                "OPTIONAL HEADER VALUES\n"
                "%8hX magic #\n"
                "%8s linker version\n"
                "%8lX size of code\n"
                "%8lX size of initialized data\n"
                "%8lX size of uninitialized data\n"
                "%8lX address of entry point\n"
                "%8lX base of code\n"
#ifndef _WIN64
                "%8lX base of data\n"
#endif
                ,
                ImageOptionalHdr->Magic,
                szLinkerVersion,
                ImageOptionalHdr->SizeOfCode,
                ImageOptionalHdr->SizeOfInitializedData,
                ImageOptionalHdr->SizeOfUninitializedData,
                ImageOptionalHdr->AddressOfEntryPoint,
                ImageOptionalHdr->BaseOfCode
#ifndef _WIN64
                ,
                ImageOptionalHdr->BaseOfData
#endif
                );
    }

    if (dft == dftROM) {
        PIMAGE_ROM_OPTIONAL_HEADER romOptionalHdr;

        romOptionalHdr = (PIMAGE_ROM_OPTIONAL_HEADER) &ImageOptionalHdr;
        dprintf(
               "         ----- rom -----\n"
               "%8lX base of bss\n"
               "%8lX gpr mask\n"
               "         cpr mask\n"
               "         %08lX %08lX %08lX %08lX\n"
               "%8hX gp value\n",
               romOptionalHdr->BaseOfBss,
               romOptionalHdr->GprMask,
               romOptionalHdr->CprMask[0],
               romOptionalHdr->CprMask[1],
               romOptionalHdr->CprMask[2],
               romOptionalHdr->CprMask[3],
               romOptionalHdr->GpValue);
    }

    if (ImageFileHdr->SizeOfOptionalHeader == sizeof(IMAGE_OPTIONAL_HEADER)) {
        char szOSVersion[30];
        char szImageVersion[30];
        char szSubsystemVersion[30];

        switch (ImageOptionalHdr->Subsystem) {
            case IMAGE_SUBSYSTEM_POSIX_CUI   : i = 4; break;
            case IMAGE_SUBSYSTEM_WINDOWS_CUI : i = 3; break;
            case IMAGE_SUBSYSTEM_WINDOWS_GUI : i = 2; break;
            case IMAGE_SUBSYSTEM_NATIVE      : i = 1; break;
            default : i = 0;
        }

        sprintf(szOSVersion,
                "%hu.%02hu",
                ImageOptionalHdr->MajorOperatingSystemVersion,
                ImageOptionalHdr->MinorOperatingSystemVersion);

        sprintf(szImageVersion,
                "%hu.%02hu",
                ImageOptionalHdr->MajorImageVersion,
                ImageOptionalHdr->MinorImageVersion);

        sprintf(szSubsystemVersion,
                "%hu.%02hu",
                ImageOptionalHdr->MajorSubsystemVersion,
                ImageOptionalHdr->MinorSubsystemVersion);

        dprintf(
                "         ----- new -----\n"
                "%p image base\n"
                "%8lX section alignment\n"
                "%8lX file alignment\n"
                "%8hX subsystem (%s)\n"
                "%8s operating system version\n"
                "%8s image version\n"
                "%8s subsystem version\n"
                "%8lX size of image\n"
                "%8lX size of headers\n"
                "%8lX checksum\n"
                "%p size of stack reserve\n"
                "%p size of stack commit\n"
                "%p size of heap reserve\n"
                "%p size of heap commit\n",
                ImageOptionalHdr->ImageBase,
                ImageOptionalHdr->SectionAlignment,
                ImageOptionalHdr->FileAlignment,
                ImageOptionalHdr->Subsystem,
                SubsystemName[i],
                szOSVersion,
                szImageVersion,
                szSubsystemVersion,
                ImageOptionalHdr->SizeOfImage,
                ImageOptionalHdr->SizeOfHeaders,
                ImageOptionalHdr->CheckSum,
                ImageOptionalHdr->SizeOfStackReserve,
                ImageOptionalHdr->SizeOfStackCommit,
                ImageOptionalHdr->SizeOfHeapReserve,
                ImageOptionalHdr->SizeOfHeapCommit);

        for (i = 0; i < IMAGE_NUMBEROF_DIRECTORY_ENTRIES; i++) {
            if (!DirectoryEntryName[i]) {
                break;
            }

            dprintf( "%8lX [%8lX] address [size] of %s Directory\n",
                    ImageOptionalHdr->DataDirectory[i].VirtualAddress,
                    ImageOptionalHdr->DataDirectory[i].Size,
                    DirectoryEntryName[i]
                   );
        }

        dprintf( "\n" );
    }
}


VOID
DumpSectionHeader (
    IN DWORD i,
    IN PIMAGE_SECTION_HEADER Sh
    )
{
    const char *name;
    char *szUnDName;
    DWORD li, lj;
    WORD memFlags;

    dprintf("\nSECTION HEADER #%hX\n%8.8s name", i, Sh->Name);

#if 0
    if (Sh->Name[0] == '/') {
        name = SzObjSectionName((char *) Sh->Name, (char *) DumpStringTable);

        dprintf(" (%s)", name);
    }
#endif
    dprintf( "\n");

    dprintf( "%8lX %s\n"
             "%8lX virtual address\n"
             "%8lX size of raw data\n"
             "%8lX file pointer to raw data\n"
             "%8lX file pointer to relocation table\n",
           Sh->Misc.PhysicalAddress,
           (dft == dftObject) ? "physical address" : "virtual size",
           Sh->VirtualAddress,
           Sh->SizeOfRawData,
           Sh->PointerToRawData,
           Sh->PointerToRelocations);

    dprintf( "%8lX file pointer to line numbers\n"
                        "%8hX number of relocations\n"
                        "%8hX number of line numbers\n"
                        "%8lX flags\n",
           Sh->PointerToLinenumbers,
           Sh->NumberOfRelocations,
           Sh->NumberOfLinenumbers,
           Sh->Characteristics);

    memFlags = 0;

    li = Sh->Characteristics;

    if (dft == dftROM) {
       for (lj = 0L; li; li = li >> 1, lj++) {
            if (li & 1) {
                switch ((li & 1) << lj) {
                    case STYP_REG   : name = "Regular"; break;
                    case STYP_TEXT  : name = "Text"; memFlags = 1; break;
                    case STYP_INIT  : name = "Init Code"; memFlags = 1; break;
                    case STYP_RDATA : name = "Data"; memFlags = 2; break;
                    case STYP_DATA  : name = "Data"; memFlags = 6; break;
                    case STYP_LIT8  : name = "Literal 8"; break;
                    case STYP_LIT4  : name = "Literal 4"; break;
                    case STYP_SDATA : name = "GP Init Data"; memFlags = 6; break;
                    case STYP_SBSS  : name = "GP Uninit Data"; memFlags = 6; break;
                    case STYP_BSS   : name = "Uninit Data"; memFlags = 6; break;
                    case STYP_LIB   : name = "Library"; break;
                    case STYP_UCODE : name = "UCode"; break;
                    case S_NRELOC_OVFL : name = "Non-Relocatable overlay"; memFlags = 1; break;
                    default : name = "RESERVED - UNKNOWN";
                }

                dprintf( "         %s\n", name);
            }
        }
    } else {
        // Clear the padding bits

        li &= ~0x00700000;

        for (lj = 0L; li; li = li >> 1, lj++) {
            if (li & 1) {
                switch ((li & 1) << lj) {
                    case IMAGE_SCN_TYPE_NO_PAD  : name = "No Pad"; break;

                    case IMAGE_SCN_CNT_CODE     : name = "Code"; break;
                    case IMAGE_SCN_CNT_INITIALIZED_DATA : name = "Initialized Data"; break;
                    case IMAGE_SCN_CNT_UNINITIALIZED_DATA : name = "Uninitialized Data"; break;

                    case IMAGE_SCN_LNK_OTHER    : name = "Other"; break;
                    case IMAGE_SCN_LNK_INFO     : name = "Info"; break;
                    case IMAGE_SCN_LNK_REMOVE   : name = "Remove"; break;
                    case IMAGE_SCN_LNK_COMDAT   : name = "Communal"; break;

                    case IMAGE_SCN_MEM_DISCARDABLE: name = "Discardable"; break;
                    case IMAGE_SCN_MEM_NOT_CACHED: name = "Not Cached"; break;
                    case IMAGE_SCN_MEM_NOT_PAGED: name = "Not Paged"; break;
                    case IMAGE_SCN_MEM_SHARED   : name = "Shared"; break;
                    case IMAGE_SCN_MEM_EXECUTE  : name = ""; memFlags |= 1; break;
                    case IMAGE_SCN_MEM_READ     : name = ""; memFlags |= 2; break;
                    case IMAGE_SCN_MEM_WRITE    : name = ""; memFlags |= 4; break;

                    case IMAGE_SCN_MEM_FARDATA  : name = "Far Data"; break;
                    case IMAGE_SCN_MEM_SYSHEAP  : name = "Sys Heap"; break;
                    case IMAGE_SCN_MEM_PURGEABLE: name = "Purgeable or 16-Bit"; break;
                    case IMAGE_SCN_MEM_LOCKED   : name = "Locked"; break;
                    case IMAGE_SCN_MEM_PRELOAD  : name = "Preload"; break;
                    case IMAGE_SCN_MEM_PROTECTED: name = "Protected"; break;

                    default : name = "RESERVED - UNKNOWN";
                }

                if (*name) {
                    dprintf( "         %s\n", name);
                }
            }
        }

        // print alignment

        switch (Sh->Characteristics & 0x00700000) {
            default:                      name = "(no align specified)"; break;
            case IMAGE_SCN_ALIGN_1BYTES:  name = "1 byte align";  break;
            case IMAGE_SCN_ALIGN_2BYTES:  name = "2 byte align";  break;
            case IMAGE_SCN_ALIGN_4BYTES:  name = "4 byte align";  break;
            case IMAGE_SCN_ALIGN_8BYTES:  name = "8 byte align";  break;
            case IMAGE_SCN_ALIGN_16BYTES: name = "16 byte align"; break;
            case IMAGE_SCN_ALIGN_32BYTES: name = "32 byte align"; break;
            case IMAGE_SCN_ALIGN_64BYTES: name = "64 byte align"; break;
        }

        dprintf( "         %s\n", name);
    }

    if (memFlags) {
        switch(memFlags) {
            case 1 : name = "Execute Only"; break;
            case 2 : name = "Read Only"; break;
            case 3 : name = "Execute Read"; break;
            case 4 : name = "Write Only"; break;
            case 5 : name = "Execute Write"; break;
            case 6 : name = "Read Write"; break;
            case 7 : name = "Execute Read Write"; break;
            default : name = "Unknown Memory Flags"; break;
        }
        dprintf( "         %s\n", name);
    }
}

VOID
DumpDebugDirectory (
    IN PIMAGE_DEBUG_DIRECTORY DebugDir
    )
{
    BOOL Ok;
    DWORD cb;
    NB10I nb10i;
    PIMAGE_DEBUG_MISC miscData;
    PIMAGE_DEBUG_MISC miscDataCur;
    ULONG VirtualAddress;
    DWORD len;

    switch (DebugDir->Type){
        case IMAGE_DEBUG_TYPE_COFF:
            dprintf( "\tcoff   ");
            break;
        case IMAGE_DEBUG_TYPE_CODEVIEW:
            dprintf( "\tcv     ");
            break;
        case IMAGE_DEBUG_TYPE_FPO:
            dprintf( "\tfpo    ");
            break;
        case IMAGE_DEBUG_TYPE_MISC:
            dprintf( "\tmisc   ");
            break;
        case IMAGE_DEBUG_TYPE_FIXUP:
            dprintf( "\tfixup  ");
            break;
        case IMAGE_DEBUG_TYPE_OMAP_TO_SRC:
            dprintf( "\t-> src ");
            break;
        case IMAGE_DEBUG_TYPE_OMAP_FROM_SRC:
            dprintf( "\tsrc -> ");
            break;
        case IMAGE_DEBUG_TYPE_EXCEPTION:
            dprintf( "\tpdata  ");
            break;
        default:
            dprintf( "\t(%6lu)", DebugDir->Type);
            break;
    }
    dprintf( "%8x    %8x %8x",
                DebugDir->SizeOfData,
                DebugDir->AddressOfRawData,
                DebugDir->PointerToRawData);

    if (DebugDir->PointerToRawData &&
        DebugDir->Type == IMAGE_DEBUG_TYPE_MISC)
    {

        if (!TranslateFilePointerToVirtualAddress(DebugDir->PointerToRawData, &VirtualAddress)) {
            dprintf(" [Debug data not mapped]\n");
        } else {

            len = DebugDir->SizeOfData;
            miscData = (PIMAGE_DEBUG_MISC) malloc(len);
            try {
                Ok = ReadMemory(Base + VirtualAddress, miscData, len, &cb);

                if (!Ok || cb != len) {
                    dprintf("Can't read debug data\n");
                } else {

                    miscDataCur = miscData;
                    do {
                        if (miscDataCur->DataType == IMAGE_DEBUG_MISC_EXENAME) {
                            if (ImageOptionalHdr->MajorLinkerVersion == 2 &&
                                ImageOptionalHdr->MinorLinkerVersion < 37) {
                                dprintf( "\tImage Name: %s", miscDataCur->Reserved);
                            } else {
                                dprintf( "\tImage Name: %s", miscDataCur->Data);
                            }
                            break;
                        }
                        len -= miscDataCur->Length;
                        miscDataCur = (PIMAGE_DEBUG_MISC) ((PCHAR) miscDataCur + miscData->Length);
                    } while (len > 0);

                }

            }
            finally {
                if (miscData) {
                    free(miscData);
                }
            }
        }
    }

    if (DebugDir->PointerToRawData &&
        DebugDir->Type == IMAGE_DEBUG_TYPE_CODEVIEW)
    {
        if (!TranslateFilePointerToVirtualAddress(DebugDir->PointerToRawData, &VirtualAddress)) {
            dprintf(" [Debug data not mapped]\n");
        } else {

            len = DebugDir->SizeOfData;

            Ok = ReadMemory(Base + VirtualAddress, &nb10i, sizeof(nb10i), &cb);

            if (!Ok || cb != sizeof(&nb10i)) {
                dprintf("Can't read debug data\n");
            } else {
                dprintf( "\tFormat: %4.4s", &nb10i.nb10);

                if (nb10i.nb10 == '01BN') {
                    CHAR PdbName[MAX_PATH];
                    //Assert(len - sizeof(nb10i) <= MAX_PATH);

                    Ok = ReadMemory(Base + VirtualAddress + sizeof(nb10i), PdbName, len-sizeof(nb10i), &cb);
                    if (!Ok || cb != len-sizeof(nb10i)) {
                        strcpy(PdbName, "<pdb name unavailable>");
                    }
                    dprintf( ", %x, %x, %s", nb10i.sig, nb10i.age, PdbName);
                }
            }
        }

    }

    dprintf( "\n");
}



VOID
DumpDebugDirectories (
    PIMAGE_SECTION_HEADER sh
    )

/*++

Routine Description:

    Print out the contents of all debug directories

Arguments:

    sh - Section header for section that contains debug dirs

Return Value:

    None.

--*/
{
    int                numDebugDirs;
    IMAGE_DEBUG_DIRECTORY      debugDir;
    PCHAR              DebugDirAddr;
    PCHAR              pc;
    DWORD              cb;
    BOOL               Ok;

    if (dft == dftROM) {
        DebugDirAddr = (PCHAR)(Base + sh->VirtualAddress);
        pc = DebugDirAddr;
        Ok = ReadMemory((ULONG_PTR)pc, &debugDir, sizeof(IMAGE_DEBUG_DIRECTORY), &cb);

        if (!Ok || cb != sizeof(IMAGE_DEBUG_DIRECTORY)) {
            dprintf("Can't read debug dir\n");
            return;
        }

        numDebugDirs = 0;
        while (debugDir.Type != 0) {
            numDebugDirs++;
            pc += sizeof(IMAGE_DEBUG_DIRECTORY);
            Ok = ReadMemory((ULONG_PTR)pc, &debugDir, sizeof(IMAGE_DEBUG_DIRECTORY), &cb);
            if (!Ok || cb != sizeof(IMAGE_DEBUG_DIRECTORY)) {
                break;
            }
        }
    } else {
        DebugDirAddr = (PCHAR)(Base + ImageOptionalHdr->DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].VirtualAddress);
        numDebugDirs = ImageOptionalHdr->DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].Size / sizeof(IMAGE_DEBUG_DIRECTORY);
    }

    dprintf("\n\nDebug Directories(%d)\n",numDebugDirs);
    dprintf("\tType       Size     Address  Pointer\n\n");
    pc = DebugDirAddr;
    while (numDebugDirs) {
        Ok = ReadMemory((ULONG_PTR)pc, &debugDir, sizeof(IMAGE_DEBUG_DIRECTORY), &cb);
        if (!Ok || cb != sizeof(IMAGE_DEBUG_DIRECTORY)) {
            dprintf("Can't read debug dir\n");
            break;
        }
        pc += sizeof(IMAGE_DEBUG_DIRECTORY);
        DumpDebugDirectory(&debugDir);
        numDebugDirs--;
    }
}



VOID
DumpSections(
    VOID
    )
{
    IMAGE_SECTION_HEADER sh;
    const char *p;
    DWORD li;
    DWORD cb;
    BOOL Ok;
    int i, j;
    CHAR szName[IMAGE_SIZEOF_SHORT_NAME + 1];


    for (i = 1; i <= ImageFileHdr->NumberOfSections; i++) {

        sh = SectionHdrs[i-1];

        //szName = SzObjSectionName((char *) sh.Name, (char *) DumpStringTable);
        strncpy(szName, (char *) sh.Name, IMAGE_SIZEOF_SHORT_NAME);
        szName[IMAGE_SIZEOF_SHORT_NAME] = 0;

        DumpSectionHeader(i, &sh);

        if (dft == dftROM) {

            if (!(ImageFileHdr->Characteristics & IMAGE_FILE_DEBUG_STRIPPED)) {

                // If we're looking at the .rdata section and the symbols
                // aren't stripped, the debug directory must be here.

                if (!strcmp(szName, ".rdata")) {

                    DumpDebugDirectories(&sh);

                    //DumpDebugData(&sh);
                }
            }

        } else if (dft == dftPE) {

            if ((li = ImageOptionalHdr->DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].VirtualAddress) != 0) {
                if (li >= sh.VirtualAddress && li < sh.VirtualAddress+sh.SizeOfRawData) {
                    DumpDebugDirectories(&sh);

                    //DumpDebugData(&sh);
                }
            }


#if 0
            if (Switch.Dump.PData) {
                li = ImageOptionalHdr->DataDirectory[IMAGE_DIRECTORY_ENTRY_EXCEPTION].VirtualAddress;

                if ((li != 0) && (li >= sh.VirtualAddress) && (li < sh.VirtualAddress+sh.SizeOfRawData)) {
                    DumpFunctionTable(pimage, rgsym, (char *) DumpStringTable, &sh);
                }
            }

            if (Switch.Dump.Imports) {
                li = ImageOptionalHdr->DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress;

                if ((li != 0) && (li >= sh.VirtualAddress) && (li < sh.VirtualAddress+sh.SizeOfRawData)) {
                    DumpImports(&sh);
                }
            }

            if (Switch.Dump.Exports) {
                li = ImageOptionalHdr->DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;

                if ((li != 0) && (li >= sh.VirtualAddress) && (li < sh.VirtualAddress+sh.SizeOfRawData)) {
                    // UNDONE: Is this check really necessary?

                    if (ImageFileHdr->Machine != IMAGE_FILE_MACHINE_MPPC_601) {
                        DumpExports(&sh);
                    }
                }
            }

#endif

        }

    }
}

BOOL
TranslateFilePointerToVirtualAddress(
    IN ULONG FilePointer,
    OUT PULONG VirtualAddress
    )
{
    int i;
    PIMAGE_SECTION_HEADER sh;

    for (i = 1; i <= ImageFileHdr->NumberOfSections; i++) {
        sh = &SectionHdrs[i-1];

        if (sh->PointerToRawData <= FilePointer &&
            FilePointer < sh->PointerToRawData + sh->SizeOfRawData) {

            *VirtualAddress = FilePointer - sh->PointerToRawData + sh->VirtualAddress;
            return TRUE;
        }
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\ntsdexts\secexts.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:


Abstract:

    This function contains the default ntsd debugger extensions

Author:


Revision History:

--*/


char * AccessMask[] = { "Delete", "ReadControl", "WriteDac", "WriteOwner",
                        "Synch", "", "", "",
                        "Sacl", "MaxAllowed", "", "",
                        "GenericAll", "GenericExec", "GenericWrite", "GenericRead"};

char * TokenRights[] = {"AssignPrimary", "Duplicate", "Impersonate", "Query",
                        "QuerySource", "AdjustPriv", "AdjustGroup", "AdjustDef"};

char * KeyRights[] = {  "QueryValue", "SetValue", "CreateSubKey", "EnumSubKey",
                        "Notify", "CreateLink", "", "" };

char * EventRights[] = {"QueryState", "ModifyState" };

char * MutantRights[]={ "QueryState" };

char * SemaphoreRights[] = { "QueryState", "ModifyState" };

char * TimerRights[] = {"QueryState", "ModifyState" };

char * ProfileRights[]={"Control"};

char * ProcessRights[]={"Terminate", "CreateThread", "", "VMOp",
                        "VMRead", "VMWrite", "DupHandle", "CreateProcess",
                        "SetQuota", "SetInfo", "QueryInfo", "SetPort" };

char * ThreadRights[] ={"Terminate", "Suspend", "Alert", "GetContext",
                        "SetContext", "SetInfo", "QueryInfo", "SetToken",
                        "Impersonate", "DirectImpersonate" };

char * SectionRights[]={"Query", "MapWrite", "MapRead", "MapExecute",
                        "Extend"};

char * FileRights[] = { "Read/List", "Write/Add", "Append/SubDir/CreatePipe", "ReadEA",
                        "WriteEA", "Execute/Traverse", "DelChild", "ReadAttr",
                        "WriteAttr"};

char * PortRights[] = { "Connect" };

char * DirRights[]  = { "Query", "Traverse", "Create", "CreateSubdir" };

char * SymLinkRights[]={"Query" };

char * WinstaRights[]={ "EnumDesktops", "ReadAttr", "Clipboard", "CreateDesktop",
                        "WriteAttr", "GlobalAtom", "ExitWindows", "",
                        "Enumerate", "ReadScreen" };

char * DesktopRights[]={"ReadObjects", "CreateWindow", "CreateMenu", "HookControl",
                        "JournalRecord", "JournalPlayback", "Enumerate", "WriteObjects",
                        "SwitchDesktop" };

char * CompletionRights[] = { "Query", "Modify" };

char * ChannelRights[] = { "ReadMessage", "WriteMessage", "Query", "SetInfo" };

char * JobRights[] = { "AssignProcess", "SetAttr", "Query", "Terminate", "SetSecAttr" };

TCHAR * PrivNames[] = {
            TEXT("Invalid"),
            TEXT("Invalid"),
            SE_CREATE_TOKEN_NAME,
            SE_ASSIGNPRIMARYTOKEN_NAME,
            SE_LOCK_MEMORY_NAME,
            SE_MACHINE_ACCOUNT_NAME,
            SE_TCB_NAME,
            SE_SECURITY_NAME,
            SE_TAKE_OWNERSHIP_NAME,
            SE_LOAD_DRIVER_NAME,
            SE_SYSTEM_PROFILE_NAME,
            SE_PROF_SINGLE_PROCESS_NAME,
            SE_INC_BASE_PRIORITY_NAME,
            SE_CREATE_PAGEFILE_NAME,
            SE_CREATE_PERMANENT_NAME,
            SE_BACKUP_NAME,
            SE_RESTORE_NAME,
            SE_SHUTDOWN_NAME,
            SE_DEBUG_NAME,
            SE_AUDIT_NAME,
            SE_SYSTEM_ENVIRONMENT_NAME,
            SE_CHANGE_NOTIFY_NAME,
            SE_REMOTE_SHUTDOWN_NAME,
            SE_UNDOCK_NAME,
            SE_SYNC_AGENT_NAME,
            SE_ENABLE_DELEGATION_NAME
        };

///////////////////////////////

char *  TokenImpLevels[] = { "Anonymous", "Identification", "Impersonation", "Delegation" };
#define GetTokenImpersonationLevel( x ) \
                ( x <= SecurityDelegation ? TokenImpLevels[ x ] : "Invalid" )


#define GHI_TYPE        0x00000001
#define GHI_BASIC       0x00000002
#define GHI_NAME        0x00000004
#define GHI_SPECIFIC    0x00000008
#define GHI_VERBOSE     0x00000010
#define GHI_NOLOOKUP    0x00000020
#define GHI_SILENT      0x00000100

#define TYPE_NONE       0
#define TYPE_EVENT      1
#define TYPE_SECTION    2
#define TYPE_FILE       3
#define TYPE_PORT       4
#define TYPE_DIRECTORY  5
#define TYPE_LINK       6
#define TYPE_MUTANT     7
#define TYPE_WINSTA     8
#define TYPE_SEM        9
#define TYPE_KEY        10
#define TYPE_TOKEN      11
#define TYPE_PROCESS    12
#define TYPE_THREAD     13
#define TYPE_DESKTOP    14
#define TYPE_COMPLETE   15
#define TYPE_CHANNEL    16
#define TYPE_TIMER      17
#define TYPE_JOB        18
#define TYPE_WPORT      19
#define TYPE_MAX        20

LPWSTR   pszTypeNames[TYPE_MAX] = { L"None", L"Event", L"Section", L"File",
                                L"Port", L"Directory", L"SymbolicLink",
                                L"Mutant", L"WindowStation", L"Semaphore",
                                L"Key", L"Token", L"Process", L"Thread",
                                L"Desktop", L"IoCompletion", L"Channel",
                                L"Timer", L"Job", L"WaitablePort" };

typedef VOID
( * TYPEINFOFN)(HANDLE hObject, DWORD Flags);

VOID EventInfo(HANDLE, ULONG);
VOID MutantInfo(HANDLE, ULONG);
VOID SemaphoreInfo(HANDLE, ULONG);
VOID TimerInfo(HANDLE, ULONG);
VOID SectionInfo(HANDLE, ULONG);
VOID KeyInfo(HANDLE, ULONG);
VOID ProcessInfo(HANDLE, ULONG);
VOID ThreadInfo(HANDLE, ULONG);
VOID TokenInfo(HANDLE, ULONG);
VOID IoCompleteInfo(HANDLE, ULONG);
VOID JobInfo( HANDLE, ULONG );

typedef struct _TYPEINFO {
    PWSTR       pszName;
    char * *    AccessRights;
    DWORD       NumberRights;
    TYPEINFOFN  Func;
} TYPEINFO, * PTYPEINFO;

TYPEINFO TypeNames[TYPE_MAX] = {
    { L"None", NULL, 0, 0 },
    { L"Event", EventRights, 2, EventInfo },
    { L"Section", SectionRights, 5, SectionInfo },
    { L"File", FileRights, 9, 0 },
    { L"Port", PortRights, 1, 0 },
    { L"Directory", DirRights, 4, 0 },
    { L"SymbolicLink", SymLinkRights, 1, 0 },
    { L"Mutant", MutantRights, 2, MutantInfo },
    { L"WindowStation", WinstaRights, 10, 0 },
    { L"Semaphore", SemaphoreRights, 2, SemaphoreInfo },
    { L"Key", KeyRights, 6, KeyInfo },
    { L"Token", TokenRights, 8, TokenInfo },
    { L"Process", ProcessRights, 12, ProcessInfo },
    { L"Thread", ThreadRights, 10, ThreadInfo },
    { L"Desktop", DesktopRights, 10, 0 },
    { L"IoCompletion", CompletionRights, 2, IoCompleteInfo },
    { L"Channel", ChannelRights, 4, 0},
    { L"Timer", TimerRights, 2, TimerInfo },
    { L"Job", JobRights, 5, JobInfo },
    { L"WaitablePort", PortRights, 1, 0 }
    };

void DisplayFlags(  DWORD       Flags,
                    DWORD       FlagLimit,
                    char        *flagset[],
                    UCHAR *      buffer)
{
   char *         offset;
   DWORD          mask, test, i;
   DWORD          scratch;

   if (!Flags) {
      strcpy((CHAR *)buffer, "None");
      return;
   }

   mask = 0;
   offset = (CHAR *) buffer;
   test = 1;
   for (i = 0 ; i < FlagLimit ; i++ ) {
      if (Flags & test) {
         scratch = sprintf(offset, "%s", flagset[i]);
         offset += scratch;
         mask |= test;
         if (Flags & (~mask)) {
            *offset++ = ',';
         }
      }
      test <<= 1;
   }
}

VOID
EventInfo(
    HANDLE  hEvent,
    DWORD   Flags)
{
    EVENT_BASIC_INFORMATION Info;
    NTSTATUS Status;

    Status = NtQueryEvent(  hEvent,
                            EventBasicInformation,
                            &Info,
                            sizeof( Info ),
                            NULL );

    if (NT_SUCCESS( Status ) )
    {
        dprintf("    Event Type %s\n", Info.EventType == SynchronizationEvent ?
                                    "Auto Reset" : "Manual Reset" );
        dprintf("    Event is %s\n", Info.EventState ? "Set" : "Waiting" );
    }
}

VOID
SemaphoreInfo(
    HANDLE  hSem,
    DWORD   Flags)
{
    SEMAPHORE_BASIC_INFORMATION Info;
    NTSTATUS Status;

    Status = NtQuerySemaphore(  hSem,
                                SemaphoreBasicInformation,
                                &Info,
                                sizeof( Info ),
                                NULL );

    if (NT_SUCCESS( Status ) )
    {
        dprintf("    Semaphore Count %d\n", Info.CurrentCount );
        dprintf("    Semaphore Limit %d\n", Info.MaximumCount );
    }

}

VOID
MutantInfo(
    HANDLE  hMutant,
    DWORD   Flags)
{
    MUTANT_BASIC_INFORMATION    Info;
    NTSTATUS Status;

    Status = NtQueryMutant( hMutant,
                            MutantBasicInformation,
                            &Info,
                            sizeof( Info ),
                            NULL );

    if (NT_SUCCESS( Status ) )
    {
        dprintf("    Mutex is %s\n", Info.CurrentCount ? "Free" : "Owned" );
        if ( Info.AbandonedState )
        {
            dprintf("    Mutex is abandoned\n");
        }
    }
}

VOID
TimerInfo(
    HANDLE  hTimer,
    DWORD   Flags)
{
    TIMER_BASIC_INFORMATION Info;
    NTSTATUS    Status;

    Status = NtQueryTimer( hTimer,
                           TimerBasicInformation,
                           &Info,
                           sizeof( Info ),
                           NULL );

    if (NT_SUCCESS( Status ) )
    {
        dprintf("    Timer is %s\n", Info.TimerState ? "signalled" : "waiting" );
        dprintf("    Remaining time %d\n", (DWORD) Info.RemainingTime.QuadPart );
    }
}

VOID
SectionInfo(
    HANDLE  hSection,
    DWORD   Flags)
{
    SECTION_BASIC_INFORMATION Info;
    NTSTATUS Status;

    Status = NtQuerySection(    hSection,
                                SectionBasicInformation,
                                &Info,
                                sizeof( Info ),
                                NULL );

    if ( NT_SUCCESS( Status ) )
    {
        dprintf("    Section base address %#x\n", Info.BaseAddress );
        dprintf("    Section attributes %#x\n", Info.AllocationAttributes );
        dprintf("    Section max size %#x\n", (DWORD) Info.MaximumSize.QuadPart );
    }
}

VOID
KeyInfo(
    HANDLE  hKey,
    DWORD   Flags)
{
    PKEY_BASIC_INFORMATION  pInfo;
    NTSTATUS Status;
    SYSTEMTIME st;
    FILETIME lft;
    ULONG   Length;

    pInfo = LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, 1024);
    if ( pInfo )
    {
        Status = NtQueryKey( hKey,
                             KeyBasicInformation,
                             pInfo,
                             1024,
                             &Length );

        if ( NT_SUCCESS( Status ) )
        {
            FileTimeToLocalFileTime( (FILETIME *) &pInfo->LastWriteTime,
                                     & lft );
            FileTimeToSystemTime( &lft, &st );

            dprintf("    Key last write time:  %02d:%02d:%02d. %d/%d/%d\n",
                    st.wHour, st.wMinute, st.wSecond, st.wMonth,
                    st.wDay, st.wYear );

            dprintf("    Key name %ws\n", pInfo->Name );
        }

        LocalFree( pInfo );
    }
}

VOID
ProcessInfo(
    HANDLE  hProcess,
    DWORD   Flags)
{
    PROCESS_BASIC_INFORMATION Info;
    NTSTATUS Status;

    Status = NtQueryInformationProcess( hProcess,
                                        ProcessBasicInformation,
                                        &Info,
                                        sizeof( Info ),
                                        NULL );

    if ( NT_SUCCESS( Status ) )
    {
        dprintf("    Process Id  %d\n", Info.UniqueProcessId );
        dprintf("    Parent Process  %d\n", Info.InheritedFromUniqueProcessId );
        dprintf("    Base Priority %d\n", Info.BasePriority );
    }

}

VOID
ThreadInfo(
    HANDLE hThread,
    DWORD   Flags)
{
    THREAD_BASIC_INFORMATION Info;
    NTSTATUS Status;
    PVOID StartAddr ;
    CHAR Buffer[ 128 ];
    DWORD_PTR Offset ;

    Status = NtQueryInformationThread( hThread,
                                       ThreadBasicInformation,
                                       &Info,
                                       sizeof( Info ),
                                       NULL );

    if ( NT_SUCCESS( Status ) )
    {
        dprintf("    Thread Id  %d.%d\n", Info.ClientId.UniqueProcess, Info.ClientId.UniqueThread );
        dprintf("    Priority %d\n", Info.Priority );
        dprintf("    Base Priority %d\n", Info.BasePriority );
    }

    Status = NtQueryInformationThread( hThread,
                                       ThreadQuerySetWin32StartAddress,
                                       &StartAddr,
                                       sizeof( PVOID ),
                                       NULL );

    if ( NT_SUCCESS( Status ) )
    {
        Buffer[0] = '\0';
        GetSymbol( StartAddr, Buffer, &Offset );
        dprintf("    Start Address %x %s\n",
                StartAddr, Buffer[0] ? Buffer : "" );
    }
}

VOID
IoCompleteInfo(
    HANDLE  hIoCompletionPort,
    DWORD   Flags)
{
    IO_COMPLETION_BASIC_INFORMATION Info;
    NTSTATUS Status;

    Status = NtQueryIoCompletion(   hIoCompletionPort,
                                    IoCompletionBasicInformation,
                                    &Info,
                                    sizeof( Info ),
                                    NULL );

    if ( NT_SUCCESS( Status ) )
    {
        dprintf("    Depth  %d\n", Info.Depth );
    }

}

VOID
TokenInfo(
    HANDLE  hToken,
    DWORD   Flags)
{
    TOKEN_STATISTICS    Stats;
    UCHAR               Buffer[ 1024 ];
    PTOKEN_USER         pUser;
    PTOKEN_GROUPS       pGroups;
    PTOKEN_PRIVILEGES   pPrivs ;
    ULONG               Size;
    NTSTATUS            Status;
    UNICODE_STRING      s;
    WCHAR               Name[ 64 ];
    WCHAR               Domain[ 64 ];
    DWORD               NameSize;
    DWORD               DomainSize;
    SID_NAME_USE        Use;
    BOOL                FoundName;
    ULONG               Index;



    Status = NtQueryInformationToken(   hToken,
                                        TokenStatistics,
                                        &Stats,
                                        sizeof(Stats),
                                        &Size );

    if ( NT_SUCCESS( Status ) )
    {
        dprintf("    Auth Id    %#x : %#x\n", Stats.AuthenticationId.HighPart, Stats.AuthenticationId.LowPart );
        dprintf("    Type       %s\n", Stats.TokenType == TokenPrimary ? "Primary" : "Impersonation" );
        dprintf("    Imp Level  %s\n", GetTokenImpersonationLevel( Stats.ImpersonationLevel ) );

        if ( Flags & GHI_VERBOSE )
        {
            dprintf("     Token Id  %#x : %#x \n", Stats.TokenId.HighPart, Stats.TokenId.LowPart );
            dprintf("     Mod Id    %#x : %#x \n", Stats.ModifiedId.HighPart, Stats.ModifiedId.LowPart );
            dprintf("     Dyn Chg   %#x\n", Stats.DynamicCharged );
            dprintf("     Dyn Avail %#x\n", Stats.DynamicAvailable );
            dprintf("     Groups    %d\n",  Stats.GroupCount );
            dprintf("     Privs     %d\n",  Stats.PrivilegeCount );

            pUser = (PTOKEN_USER) Buffer;
            Status = NtQueryInformationToken(   hToken,
                                                TokenUser,
                                                Buffer,
                                                sizeof(Buffer),
                                                &Size );

            if (NT_SUCCESS( Status ) )
            {
                if ( !(Flags & GHI_NOLOOKUP) )
                {
                    NameSize = 64 ;
                    DomainSize = 64 ;

                    if ( LookupAccountSidW( NULL,
                                            pUser->User.Sid,
                                            Name,
                                            &NameSize,
                                            Domain,
                                            &DomainSize,
                                            &Use ) )
                    {
                        dprintf("     User      %ws\\%ws\n", Domain, Name );
                        FoundName = TRUE;
                    }
                    else
                    {
                        FoundName = FALSE ;
                    }

                }

                if ( (Flags & GHI_NOLOOKUP) || (!FoundName) )
                {
                    RtlConvertSidToUnicodeString( &s, pUser->User.Sid, TRUE );
                    dprintf("     User      %ws\n", s.Buffer );
                    RtlFreeUnicodeString( &s );
                }
            }

            pGroups = (PTOKEN_GROUPS) Buffer;
            Status = NtQueryInformationToken(   hToken,
                                                TokenGroups,
                                                Buffer,
                                                sizeof(Buffer),
                                                &Size );

            if ( NT_SUCCESS( Status ) )
            {
                dprintf("     Groups    %d\n", pGroups->GroupCount );
                for ( Index = 0 ; Index < pGroups->GroupCount ; Index++ )
                {
                    if ( !(Flags & GHI_NOLOOKUP) )
                    {
                        NameSize = 64 ;
                        DomainSize = 64 ;

                        if ( LookupAccountSidW( NULL,
                                                pGroups->Groups[Index].Sid,
                                                Name,
                                                &NameSize,
                                                Domain,
                                                &DomainSize,
                                                &Use ) )
                        {
                            dprintf("               %ws\\%ws\n", Domain, Name );
                            FoundName = TRUE;
                        }
                        else
                        {
                            FoundName = FALSE;
                        }

                    }
                    if ( ( Flags & GHI_NOLOOKUP ) || ( !FoundName ) )
                    {
                        RtlConvertSidToUnicodeString( &s,
                                                    pGroups->Groups[Index].Sid,
                                                    TRUE );

                        dprintf("               %ws\n", s.Buffer );

                        RtlFreeUnicodeString( &s );
                        
                    }
                }

            }

            pPrivs = (PTOKEN_PRIVILEGES) Buffer ;
            Status = NtQueryInformationToken(   hToken,
                                                TokenPrivileges,
                                                Buffer,
                                                sizeof(Buffer),
                                                &Size );

            if ( NT_SUCCESS( Status ) )
            {
                dprintf("     Privileges    %d\n", pPrivs->PrivilegeCount );
                for ( Index = 0 ; Index < pPrivs->PrivilegeCount ; Index++ )
                {
                    dprintf("               %s (%s%s)\n", 
                            PrivNames[ pPrivs->Privileges[ Index ].Luid.LowPart ], 
                            pPrivs->Privileges[ Index ].Attributes & SE_PRIVILEGE_ENABLED ? " Enabled " : " ",
                            pPrivs->Privileges[ Index ].Attributes & SE_PRIVILEGE_ENABLED_BY_DEFAULT ? "Default " : "" 
                            );
                }

            }
        }
    }

}

VOID
JobInfo(
    HANDLE Job,
    ULONG Flags 
    )
{
    JOBOBJECT_BASIC_ACCOUNTING_INFORMATION BasicInfo ;
    UCHAR Buffer[ 128 * sizeof( ULONG_PTR ) ];
    PJOBOBJECT_BASIC_PROCESS_ID_LIST ProcList ;
    NTSTATUS Status ;
    ULONG Size ;
    TIME_FIELDS Time ;

    Status = NtQueryInformationJobObject(
                    Job,
                    JobObjectBasicAccountingInformation,
                    &BasicInfo,
                    sizeof( BasicInfo ),
                    &Size );

    if ( NT_SUCCESS( Status ) )
    {
        RtlTimeToElapsedTimeFields( &BasicInfo.TotalUserTime, &Time );
        dprintf( "    TotalUserTime     \t%3ld:%02ld:%02ld.%04ld\n",
                 Time.Hour,
                 Time.Minute,
                 Time.Second,
                 Time.Milliseconds );
        RtlTimeToElapsedTimeFields( &BasicInfo.TotalKernelTime, &Time );
        dprintf( "    TotalKernelTime   \t%3ld:%02ld:%02ld.%04ld\n",
                 Time.Hour,
                 Time.Minute,
                 Time.Second,
                 Time.Milliseconds );

        dprintf( "    TotalProcesses    \t%x\n", 
                 BasicInfo.TotalProcesses );
        dprintf( "    ActiveProcesses   \t%x\n",
                 BasicInfo.ActiveProcesses );
        dprintf( "    TotalPageFaultCount\t%x\n",
                 BasicInfo.TotalPageFaultCount );

        if ( BasicInfo.ActiveProcesses )
        {
            ProcList = (PJOBOBJECT_BASIC_PROCESS_ID_LIST) Buffer ;

            Status = NtQueryInformationJobObject(
                            Job,
                            JobObjectBasicProcessIdList,
                            ProcList,
                            sizeof( Buffer ),
                            &Size );

            if ( NT_SUCCESS( Status ) )
            {
                ULONG i ;

                dprintf( "    Processes:\n" );

                for (i = 0 ; i < ProcList->NumberOfProcessIdsInList ; i++ )
                {
                    dprintf( "    %x\n", ProcList->ProcessIdList[ i ] );
                }
            }
        }

    }

}

DWORD
GetObjectTypeIndex(
    PSTR    pszTypeName )
{
    WCHAR   TypeName[ MAX_PATH ];
    DWORD   i;

    mbstowcs( TypeName, pszTypeName, strlen( pszTypeName ) + 1 );

    for ( i = 1 ; i < TYPE_MAX ; i++ )
    {
        if (_wcsicmp( TypeNames[i].pszName, TypeName ) == 0 )
        {
            return( i );
        }
    }

    return( (DWORD) -1 );
}

DWORD
GetHandleInfo(
    HANDLE  hProcess,
    HANDLE  hThere,
    DWORD   Flags,
    DWORD * Type)
{
    HANDLE  hHere;
    NTSTATUS    Status;
    POBJECT_TYPE_INFORMATION    pTypeInfo;
    POBJECT_NAME_INFORMATION    pNameInfo;
    POBJECT_BASIC_INFORMATION   pBasicInfo;
    UCHAR   Buffer[1024];
    DWORD   SuccessCount = 0;
    DWORD   i;
    UCHAR   szBuf[256];


    if (!DuplicateHandle(   hProcess, hThere,
                            GetCurrentProcess(), &hHere,
                            0, FALSE,
                            DUPLICATE_SAME_ACCESS) )
    {
        if ( (Flags & GHI_SILENT) == 0)
        {
            dprintf("Could not duplicate handle %x, error %d\n",
                            hThere, GetLastError() );
        }
        return( 0 );
    }


    pTypeInfo = (POBJECT_TYPE_INFORMATION) Buffer;
    pNameInfo = (POBJECT_NAME_INFORMATION) Buffer;
    pBasicInfo = (POBJECT_BASIC_INFORMATION) Buffer;

    if ( (Flags & GHI_SILENT) == 0)
    {
        dprintf("Handle %x\n", hThere );
    }

    if (Flags & GHI_TYPE)
    {
        ZeroMemory( Buffer, 1024 );
        Status = NtQueryObject( hHere, ObjectTypeInformation, pTypeInfo, 1024, NULL );

        if (NT_SUCCESS(Status))
        {
            if ((Flags & GHI_SILENT) == 0)
            {
                dprintf("  Type         \t%ws\n", pTypeInfo->TypeName.Buffer );
            }
            for (i = 1; i < TYPE_MAX ; i++ )
            {
                if (wcscmp(pTypeInfo->TypeName.Buffer, TypeNames[i].pszName) == 0)
                {
                    *Type = i;
                    break;
                }
            }
            if (i == TYPE_MAX)
            {
                *Type = 0;
            }
            SuccessCount++;
        }
    }

    if (Flags & GHI_BASIC)
    {
        ZeroMemory( Buffer, 1024 );

        Status = NtQueryObject(hHere, ObjectBasicInformation, pBasicInfo,
                        sizeof( OBJECT_BASIC_INFORMATION), NULL);
        if (NT_SUCCESS(Status))
        {
            dprintf("  Attributes   \t%#x\n", pBasicInfo->Attributes );
            dprintf("  GrantedAccess\t%#x:\n", pBasicInfo->GrantedAccess );
            DisplayFlags( pBasicInfo->GrantedAccess >> 16,
                          16,
                          AccessMask,
                          szBuf);
            dprintf("         %s\n", szBuf);
            DisplayFlags( pBasicInfo->GrantedAccess & 0xFFFF,
                          TypeNames[ *Type ].NumberRights,
                          TypeNames[ *Type ].AccessRights,
                          szBuf);
            dprintf("         %s\n", szBuf);
            dprintf("  HandleCount  \t%d\n", pBasicInfo->HandleCount );
            dprintf("  PointerCount \t%d\n", pBasicInfo->PointerCount );
            SuccessCount++;
        }
        else
        {
            if ( Status != STATUS_INVALID_HANDLE )
            {
                dprintf("unable to query object information\n");
            }
        }
    }

    if ( (Flags & GHI_NAME) &&
         (*Type != TYPE_FILE ) )
    {
        ZeroMemory( Buffer, 1024 );
        Status = NtQueryObject( hHere, ObjectNameInformation, pNameInfo, 1024, NULL );

        if (NT_SUCCESS(Status))
        {
            dprintf("  Name         \t%ws\n", pNameInfo->Name.Buffer ?
                                        pNameInfo->Name.Buffer : L"<none>" );
            SuccessCount++;
        }
        else
        {
            if ( Status != STATUS_INVALID_HANDLE )
            {
                dprintf("unable to query object information\n");
            }
        }
    }

    if ( Flags & GHI_SPECIFIC )
    {
        if ( TypeNames[ *Type ].Func )
        {
            dprintf("  Object Specific Information\n");
            TypeNames[ *Type ].Func( hHere, Flags );
        }
    }

    NtClose( hHere );

    return( SuccessCount );

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\nuke\nuke.c ===
// ----------------------------------------------------------------------------
// nuke.c
//
// Copyright (C) Microsoft Corporation
// ----------------------------------------------------------------------------

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <stddef.h>

// ----------------------------------------------------------------------------
// Type definitions
// ----------------------------------------------------------------------------

typedef struct {
    UINT    cEnt;
    char *  rgpsz[1];
} PATHINFO;

typedef struct {
    char *      psz;
    DWORD       dwFlags;
} PATENTRY;

#define PATENTRYF_DIRWILD   0x00000001
#define PATENTRYF_HASWILD   0x00000002
#define PATENTRYF_ALLWILD   0x00000004

typedef struct {
    char *      psz;
    DWORD       dwFlags;
    UINT        cSpec;
    UINT        cWild;
    UINT        cEnt;
    PATENTRY    rgpe[1];
} PAT;

#define PATF_HASDIRWILD     0x00000001

// ----------------------------------------------------------------------------
// Forward declarations
// ----------------------------------------------------------------------------

BOOL MatchItem(PATENTRY * ppe, char * psz);

// ----------------------------------------------------------------------------
// Globals
// ----------------------------------------------------------------------------

BOOL    g_fStartAtRoot      = TRUE;
BOOL    g_fDisplayOnly      = FALSE;
BOOL    g_fDisplayDeletes   = FALSE;
BOOL    g_fDisplayArchives  = FALSE;
BOOL    g_fDisplayRemain    = TRUE;
BOOL    g_fDisplayRestores  = FALSE;

BOOL    g_fUndo             = FALSE;
BOOL    g_fVerbose          = FALSE;

char *  g_pszCurDir         = NULL;
char *  g_pszIniDir         = NULL;
char *  g_pszArcDir         = NULL;

UINT    g_cpatDel           = 0;
PAT **  g_rgppatDel         = NULL;
UINT    g_cpatNoDel         = 0;
PAT **  g_rgppatNoDel       = NULL;
UINT    g_cpatArc           = 0;
PAT **  g_rgppatArc         = NULL;
UINT    g_cpatNoArc         = 0;
PAT **  g_rgppatNoArc       = NULL;
UINT    g_cpatUndo          = 0;
PAT **  g_rgppatUndo        = NULL;

UINT    g_cFile             = 0;
char ** g_rgpszFile         = NULL;
UINT    g_cDel              = 0;
char ** g_rgpszDel          = NULL;
UINT    g_cArc              = 0;
char ** g_rgpszArc          = NULL;
UINT    g_cRem              = 0;
char ** g_rgpszRem          = NULL;

static PAT *** g_rgpppat[]   = { &g_rgppatDel, &g_rgppatNoDel, &g_rgppatArc, &g_rgppatNoArc };
static UINT * g_rgcpat[]     = { &g_cpatDel, &g_cpatNoDel, &g_cpatArc, &g_cpatNoArc };
static char * g_rgpszSect[]  = { "delete", "dont_delete", "archive", "dont_archive" };

#define ARRAYSIZE(a)        (sizeof(a)/sizeof(*a))

// ----------------------------------------------------------------------------
// Program
// ----------------------------------------------------------------------------

void Usage()
{
    fprintf(stderr, "Usage:\n");
    fprintf(stderr, "\n");
    fprintf(stderr, "    nuke [options] { ... }\n");
    fprintf(stderr, "\n");
    fprintf(stderr, "    Nuke searches from the current directory to the root for a nuke.ini file\n");
    fprintf(stderr, "    and follows the instructions there to remove generated files from a\n");
    fprintf(stderr, "    project.  Depending on the instructions, a generated file may be deleted\n");
    fprintf(stderr, "    outright, moved into a parallel archive tree, or left alone.\n");
    fprintf(stderr, "\n");
    fprintf(stderr, "    Archived files may be restored by using the -u (undo) switch.  Selective\n");
    fprintf(stderr, "    undo is possible by specifying a file pattern to the undo switch.\n");
    fprintf(stderr, "\n");
    fprintf(stderr, "    By default all operations occur from the directory where nuke.ini is found.\n");
    fprintf(stderr, "    To limit operations to the current directory and its children, add '...' to\n");
    fprintf(stderr, "    the command line.\n");
    fprintf(stderr, "\n");
    fprintf(stderr, "Options:\n");
    fprintf(stderr, "\n");
    fprintf(stderr, "    -?,-h           print this message\n");
    fprintf(stderr, "    -n              print out what would have happened instead of doing it\n");
    fprintf(stderr, "    -u [pattern]    restore files from the archive which match the pattern,\n");
    fprintf(stderr, "                    or all files if no pattern is given\n");
    fprintf(stderr, "    -v              print out verbose descriptions\n");
    fprintf(stderr, "\n");

    exit(1);
}

void __cdecl Fatal(char * pszFormat, ...)
{
    char szBuf[1024];
    va_list va;

    va_start(va, pszFormat);
    vsprintf(szBuf, pszFormat, va);
    va_end(va);

    fprintf(stderr, "%s\n", szBuf);
    exit(1);
}

void Win32Error(char * pszFunc)
{
    char szBuf[512];

    szBuf[0] = 0;
    FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, NULL, GetLastError(), 0, szBuf, sizeof(szBuf), NULL);
    Fatal("%s failed.  %s", pszFunc, szBuf);
}

BOOL FileExists(char * pszFile)
{
    DWORD dw = GetFileAttributes(pszFile);

    if (dw == 0xFFFFFFFF)
    {
        if (GetLastError() == ERROR_FILE_NOT_FOUND)
            return(FALSE);

        Win32Error("FileExists --> GetFileAttributes");
    }

    return((dw & FILE_ATTRIBUTE_DIRECTORY) == 0);
}

PATHINFO * ParsePath(char * pszPath)
{
    PATHINFO * ppi;
    char * pch;
    int iItem, cEnt = 1;

    for (pch = pszPath; *pch; ++pch)
        if (*pch == '\\')
            cEnt += 1;

    ppi = (PATHINFO *)malloc(offsetof(PATHINFO, rgpsz) + cEnt * sizeof(char *));
    if (ppi == NULL)
        Fatal("Out of memory");

    ppi->cEnt = cEnt;

    for (iItem = 0, pch = pszPath; iItem < cEnt; ++iItem)
    {
        ppi->rgpsz[iItem] = pch;
        while (*pch && *pch != '\\')
            pch++;
        *pch++ = 0;
    }

    return(ppi);
}

BOOL ParsePatternItem(char * psz, PATENTRY * ppe, UINT * pcSpec, UINT * pcWild)
{
    char * pch = psz;

    ppe->psz = psz;
    ppe->dwFlags = 0;

    if (pch[0] == '*' && pch[1] == '*' && pch[2] == 0)
    {
        ppe->dwFlags |= PATENTRYF_DIRWILD;
        (*pcWild) += 1;
        return(TRUE);
    }

    if (pch[0] == '*' && pch[1] == 0)
    {
        ppe->dwFlags |= PATENTRYF_ALLWILD;
        (*pcWild) += 1;
        return(TRUE);
    }

    for (; *pch; ++pch)
    {
        if (*pch == '*')
        {
            if (pch[1] == '*')
                return(FALSE);
            ppe->dwFlags |= PATENTRYF_HASWILD;
            (*pcWild) += 1;
        }
        else
        {
            (*pcSpec) += 1;
        }
    }

    return(TRUE);
}

int __cdecl
comparepatspec(const void * pv1, const void * pv2)
{
    PAT * ppat1 = *(PAT **)pv1;
    PAT * ppat2 = *(PAT **)pv2;

    if (ppat1->cSpec < ppat2->cSpec)
        return(+1);
    else if (ppat1->cSpec > ppat2->cSpec)
        return(-1);
    else if (ppat1->cWild < ppat2->cWild)
        return(-1);
    else if (ppat1->cWild > ppat2->cWild)
        return(+1);
    else
        return(0);
}

void DumpPattern(PAT * ppat)
{
    UINT i;

    printf("pattern=\"%s\" (cSpec=%d.%d) %s\n",
           ppat->psz, ppat->cSpec, ppat->cWild,
           (ppat->dwFlags & PATF_HASDIRWILD) ? "HASDIRWILD" : "");

    for (i = 0; i < ppat->cEnt; ++i)
    {
        printf("  \"%s\" %s%s%s\n", ppat->rgpe[i].psz,
               (ppat->rgpe[i].dwFlags & PATENTRYF_DIRWILD) ? "DIRWILD" : "",
               (ppat->rgpe[i].dwFlags & PATENTRYF_HASWILD) ? "HASWILD" : "",
               (ppat->rgpe[i].dwFlags & PATENTRYF_ALLWILD) ? "ALLWILD" : "");
    }
}

void DumpPatternList(UINT cpat, PAT ** pppat)
{
    for (; cpat > 0; --cpat, ++pppat)
    {
        DumpPattern(*pppat);
    }
}

void DumpAllPatterns()
{
    UINT i, j;

    for (i = 0; i < ARRAYSIZE(g_rgpszSect); ++i)
    {
        printf("[%s] (cPat=%d)\n", g_rgpszSect[i], *g_rgcpat[i]);
        DumpPatternList(*g_rgcpat[i], *g_rgpppat[i]);
    }
}

PAT * ParsePattern(char * pszPattern)
{
    PATHINFO *  ppi;
    PAT *       ppat;
    char        szBuf[MAX_PATH];
    char *      pszPat;
    char *      pszBuf;
    UINT        i;
    
    if (*pszPattern == '\\')
    {
        pszPattern += 1;
    }

    strcpy(szBuf, pszPattern);

    pszPat = _strdup(szBuf);
    pszBuf = _strdup(szBuf);
    ppi    = ParsePath(pszBuf);

    ppat = (PAT *)malloc(offsetof(PAT, rgpe) + ppi->cEnt * sizeof(PATENTRY));
    if (ppat == NULL)
        Fatal("Out of memory");

    ppat->psz     = pszPat;
    ppat->dwFlags = 0;
    ppat->cSpec   = 0;
    ppat->cWild   = 0;
    ppat->cEnt    = ppi->cEnt;

    for (i = 0; i < ppi->cEnt; ++i)
    {
        if (!ParsePatternItem(ppi->rgpsz[i], &ppat->rgpe[i], &ppat->cSpec, &ppat->cWild))
            return(NULL);

        if (ppat->rgpe[i].dwFlags & PATENTRYF_DIRWILD)
        {
            if (ppat->dwFlags & PATF_HASDIRWILD)
                return(NULL);
            ppat->dwFlags |= PATF_HASDIRWILD;
        }
    }

    if (ppat->rgpe[ppat->cEnt - 1].dwFlags & PATENTRYF_DIRWILD)
        return(NULL);

    return(ppat);
}

void AddPatternToList(PAT * ppat, UINT * pcpat, PAT *** ppppat)
{
    if ((*pcpat % 16) == 0)
    {
        PAT ** pppatNew = (PAT **)malloc((*pcpat + 16) * sizeof(PAT **));
        if (pppatNew == NULL)
            Fatal("Out of memory");
        if (*pcpat > 0)
        {
            memcpy(pppatNew, *ppppat, *pcpat * sizeof(PAT **));
            free(*ppppat);
        }
        *ppppat = pppatNew;
    }

    (*ppppat)[*pcpat] = ppat;
    (*pcpat) += 1;
}

void ParseAddPattern(char * pszIniFile, int iSection, char * pszPattern)
{
    PAT *       ppat;
    UINT *      pcpat;
    PAT **      pppat;

    ppat  = ParsePattern(pszPattern);

    if (ppat == NULL)
    {
        Fatal("File %s:\n  Syntax error in [%s] section:\n  Pattern \"%s\"\n",
              pszIniFile, g_rgpszSect[iSection], pszPattern);
    }

    AddPatternToList(ppat, g_rgcpat[iSection], g_rgpppat[iSection]);
}

void ParseError(char * pszFile, int iSection, char * pszLine)
{
    char * pch = pszLine;

    while (*pch && *pch != '\r' && *pch != '\n')
        ++pch;

    *pch = 0;

    Fatal("File %s:\n  Syntax error in [%s] section:\n  \"%s\"\n",
          pszFile, g_rgpszSect[iSection], pszLine);
}

void ParseIniFile(char * pszFile)
{
    char szBuf[4096];
    char * pch, * pch2, * pch3, *pch4;
    int i;
    DWORD dw;

    for (i = 0; i < 4; ++i)
    {
        szBuf[0] = 0;
        szBuf[1] = 0;
        dw = GetPrivateProfileSection(g_rgpszSect[i], szBuf, sizeof(szBuf), pszFile);

        pch = szBuf;

        while (*pch)
        {
            pch2 = pch;

            while (*pch2 && isspace(*pch2))
                ++pch2;

            if (*pch2 == ';')
            {
                while (*pch2 && *pch2 != '\r' && *pch2 != '\n')
                    ++pch2;
            }

            if (*pch2 == 0 || *pch2 == '\r' || *pch2 == '\n')
            {
                // Blank lines are ok.  Just go on to the next one.
                
                if (*pch2)
                {
                    pch2++;
                    if (*pch2 == '\r' || *pch2 == '\n')
                        pch2++;
                }
                pch = pch2;
            }
            else
            {
                if (CompareString(0, NORM_IGNORECASE, pch2, 7, "pattern", 7) != CSTR_EQUAL)
                    goto parse_error;

                pch2 += 7;

                while (*pch2 && isspace(*pch2))
                    ++pch2;

                if (*pch2++ != '=')
                    goto parse_error;

                while (*pch2 && isspace(*pch2))
                    ++pch2;

                pch3 = pch2;

                while (*pch3 && !isspace(*pch3))
                    ++pch3;

                pch4 = pch3;

                while (*pch4 && isspace(*pch4))
                    ++pch4;

                if (*pch4 == ';')
                {
                    while (*pch4 && *pch4 != '\r' && *pch4 != '\n')
                        ++pch4;
                }

                if (*pch4 && *pch4 != '\r' && *pch4 != '\n')
                    goto parse_error;

                if (pch3 - pch2 == 0)
                    goto parse_error;

                *pch3 = 0;

                ParseAddPattern(pszFile, i, pch2);

                if (*pch4 && (*pch4 == '\r' || *pch4 == '\n'))
                    ++pch4;

                pch = pch4 + 1;
            }
        }
    }

    return;

parse_error:

    ParseError(pszFile, i, pch);

}

void ParseIniFiles()
{
    char szDir[MAX_PATH];
    char szFile[MAX_PATH];
    char * pch;
    UINT i;

    if (!GetCurrentDirectory(sizeof(szDir), szDir))
    {
        Win32Error("ParseIniFiles --> GetCurrentDirectory");
    }

    g_pszCurDir = _strdup(szDir);
    strcpy(szDir, g_pszCurDir);

    while (1)
    {
        strcpy(szFile, szDir);
        strcat(szFile, "\\nuke.ini");

        if (FileExists(szFile))
        {
            g_pszIniDir = _strdup(szDir);
            ParseIniFile(szFile);

            strcpy(szFile, szDir);
            strcat(szFile, "\\nukemore.ini");

            if (FileExists(szFile))
            {
                ParseIniFile(szFile);
            }
            break;
        }

        pch = &szDir[lstrlen(szDir) - 1];

        while (pch >= szDir && *pch != '\\' && *pch != ':')
            *pch-- = 0;

        if (*pch == 0 || *pch == ':')
        {
            Fatal("Can't find nuke.ini in any directory up to the root of the current drive");
        }

        *pch = 0;
    }

    for (i = 0; i < ARRAYSIZE(g_rgpszSect); ++i)
    {
        qsort((void *)(*g_rgpppat[i]), (size_t)(*g_rgcpat[i]), sizeof(PAT **), comparepatspec);
    }

#ifdef DEBUG_PATTERN_MATCH
    DumpAllPatterns();
#endif
}

void SetupArchiveDir()
{
    char szDir[MAX_PATH];
    HANDLE hFind;
    WIN32_FIND_DATA fd;

    strcpy(szDir, g_pszIniDir);
    szDir[2] = 0; // Drive letter and colon only
    strcat(szDir, "\\$nuke");
    g_pszArcDir = _strdup(szDir);

    hFind = FindFirstFile(g_pszArcDir, &fd);

    if (hFind == INVALID_HANDLE_VALUE)
    {
        if (GetLastError() != ERROR_FILE_NOT_FOUND)
            Win32Error("SetupArchiveDir --> FindFirstFile");
        if (!CreateDirectory(g_pszArcDir, NULL))
            Win32Error("SetupArchiveDir --> CreateDirectory");
        if (!SetFileAttributes(g_pszArcDir, FILE_ATTRIBUTE_HIDDEN))
            Win32Error("SetupArchiveDir --> SetFileAttributes");
    }
    else
    {
        if ((fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0)
        {
            Fatal("Cannot create archive root because a file with the same\n"
                  "name already exists there.%s", g_pszArcDir);
        }
        FindClose(hFind);
    }
}

void PushScanList(char *** pppszScan, UINT * pcScanAlloc, UINT * pcScan, UINT iIns, char * psz)
{
    psz = _strdup(psz);
    if (psz == NULL)
        Fatal("Out of memory");

    if (*pcScan == *pcScanAlloc)
    {
        char ** ppszNew = (char **)malloc((*pcScanAlloc + 128) * sizeof(char *));
        if (ppszNew == NULL)
            Fatal("Out of memory");
        if (*pcScan)
        {
            memcpy(ppszNew, *pppszScan, *pcScan * sizeof(char *));
            free(*pppszScan);
        }
        *pppszScan = ppszNew;
        *pcScanAlloc += 128;
    }

    if (iIns < *pcScan)
    {
        memmove((*pppszScan) + iIns + 1, (*pppszScan) + iIns, (*pcScan - iIns) * sizeof(char *));
    }

    (*pppszScan)[iIns] = psz;
    (*pcScan) += 1;
}

char * PopScanList(char ** ppszScan, UINT * pcScan)
{
    char * psz = ppszScan[0];

    if (*pcScan > 1)
    {
        memmove(ppszScan, ppszScan + 1, (*pcScan - 1) * sizeof(char *));
    }

    (*pcScan) -= 1;
    
    return(psz);
}

void AddToFileList(char *** pppszFile, UINT * pcFile, char * psz)
{
    psz = _strdup(psz);
    if (psz == NULL)
        Fatal("Out of memory");

    if ((*pcFile % 256) == 0)
    {
        char ** ppszNew = (char **)malloc((*pcFile + 256) * sizeof(char *));
        if (ppszNew == NULL)
            Fatal("Out of memory");
        if (*pcFile)
        {
            memcpy(ppszNew, *pppszFile, *pcFile * sizeof(char *));
            free(*pppszFile);
        }
        *pppszFile = ppszNew;
    }
    (*pppszFile)[*pcFile] = psz;
    (*pcFile) += 1;
}

void GenerateFileList()
{
    HANDLE hFind;
    WIN32_FIND_DATA fd;
    char ** ppszScan = NULL;
    UINT cScanAlloc = 0;
    UINT cScan = 0;
    char * pszDir, * pszFile;
    UINT iDir;
    UINT cPrefix;
    UINT cpat;
    PAT ** ppat;
    char szBuf[MAX_PATH];

    fprintf(stderr, "nuke: %4d files found\r", 0);

    szBuf[0] = 0;

    if (g_fUndo)
    {
        strcpy(szBuf, g_pszArcDir);

        if (g_fStartAtRoot)
            strcat(szBuf, g_pszIniDir + 2);
        else
            strcat(szBuf, g_pszCurDir + 2);

        cPrefix = lstrlen(g_pszArcDir) + lstrlen(g_pszIniDir) - 1;
    }
    else
    {
        if (g_fStartAtRoot)
            strcpy(szBuf, g_pszIniDir);
        else
            strcpy(szBuf, g_pszCurDir);

        cPrefix = lstrlen(g_pszIniDir) + 1;
    }

    strcat(szBuf, "\\*");

    PushScanList(&ppszScan, &cScanAlloc, &cScan, 0, szBuf);

    while (cScan > 0)
    {
        pszDir = PopScanList(ppszScan, &cScan);
        iDir = 0;

        hFind = FindFirstFile(pszDir, &fd);

        if (hFind == INVALID_HANDLE_VALUE)
        {
            if (g_fUndo && GetLastError() == ERROR_PATH_NOT_FOUND)
                continue;
            Win32Error("GenerateFileList --> FindFirstFile");
        }

        do
        {
            if (fd.dwFileAttributes & (FILE_ATTRIBUTE_READONLY|FILE_ATTRIBUTE_SYSTEM|FILE_ATTRIBUTE_HIDDEN))
                continue;

            strcpy(szBuf, pszDir);
            szBuf[lstrlen(szBuf) - 1] = 0;
            strcat(szBuf, fd.cFileName);

            if (fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
            {
                if (lstrcmpi(szBuf, g_pszArcDir) == 0)
                    continue;
                if (lstrcmp(fd.cFileName, ".") == 0)
                    continue;
                if (lstrcmp(fd.cFileName, "..") == 0)
                    continue;

                strcat(szBuf, "\\*");

                PushScanList(&ppszScan, &cScanAlloc, &cScan, iDir, szBuf);
                iDir += 1;
            }
            else
            {
                if (g_fUndo)
                {
                    for (cpat = g_cpatUndo, ppat = g_rgppatUndo; cpat > 0; --cpat, ++ppat)
                    {
                        if (MatchItem(&(*ppat)->rgpe[0], fd.cFileName))
                            break;
                    }

                    if (cpat == 0)
                        continue;
                }

                AddToFileList(&g_rgpszFile, &g_cFile, szBuf + cPrefix);
                fprintf(stderr, "nuke: %4d file%s found\r", g_cFile, g_cFile == 1 ? "" : "s");
            }
        }
        while (FindNextFile(hFind, &fd));
        FindClose(hFind);
    }

    fprintf(stderr, "nuke: %4ld file%s found \n", g_cFile, g_cFile == 1 ? "" : "s");
}

BOOL MatchWild(char * pszPat, char * pszItem)
{
    while (*pszPat)
    {
        if (*pszPat == '*')
        {
            ++pszPat;

            if (*pszPat == 0)
                return(TRUE);
            else if (*pszItem == 0)
                return(FALSE);

            while (*pszItem)
            {
                if (MatchWild(pszPat, pszItem))
                    return(TRUE);
                ++pszItem;
            }
            return(FALSE);
        }
        else if (*pszItem == 0)
            return(FALSE);
        else if (_tolower(*pszPat) != _tolower(*pszItem))
            return(FALSE);

        ++pszPat;
        ++pszItem;
    }

    return(*pszPat == 0 && *pszItem == 0);
}

BOOL MatchItem(PATENTRY * ppe, char * psz)
{
    if (ppe->dwFlags & PATENTRYF_ALLWILD)
        return(TRUE);

    if (ppe->dwFlags & PATENTRYF_DIRWILD)
        Fatal("Internal error (DIRWILD)");

    if (ppe->dwFlags & PATENTRYF_HASWILD)
        return(MatchWild(ppe->psz, psz));

    return(lstrcmpi(ppe->psz, psz) == 0);
}

BOOL MatchPattern(PAT * ppat, PATHINFO * ppi)
{
    PATENTRY * ppe;
    char ** ppsz;
    int i;

    if ((ppat->dwFlags & PATF_HASDIRWILD) == 0)
    {
        if (ppi->cEnt != ppat->cEnt)
            return(FALSE);
    }
    else if (ppi->cEnt < ppat->cEnt - 1)
    {
        return(FALSE);
    }

    // Match filenames first

    if (!MatchItem(&ppat->rgpe[ppat->cEnt - 1], ppi->rgpsz[ppi->cEnt - 1]))
        return(FALSE);

    // Now match directory paths starting from the end.  If we encounter a DIRWILD
    // entry, we just break out and continue scaning from the beginning.

    i    = (int)ppat->cEnt - 2;
    ppe  = &ppat->rgpe[ppat->cEnt - 2];
    ppsz = &ppi->rgpsz[ppi->cEnt - 2];

    for (; i >= 0; --i, --ppe, --ppsz)
    {
        if (ppe->dwFlags & PATENTRYF_DIRWILD)
        {
            int iStop = i;

            i    = 0;
            ppe  = &ppat->rgpe[0];
            ppsz = &ppi->rgpsz[0];

            for (; i < iStop; ++i, ++ppe, ++ppsz)
            {
                if (!MatchItem(ppe, *ppsz))
                    return(FALSE);
            }
        }
        else if (!MatchItem(ppe, *ppsz))
            return(FALSE);
    }

    return(TRUE);
}

PAT * FindPattern(UINT cpat, PAT ** pppat, PATHINFO * ppi)
{
    PAT * ppat;

    for (; cpat > 0; --cpat, ++pppat)
    {
        ppat = *pppat;

        if (MatchPattern(ppat, ppi))
            return(ppat);
    }

    return(NULL);
}

BOOL IsMoreSpecific(PAT * ppat1, PAT * ppat2)
{
    // Is ppat1 more specific than ppat2?

    if (ppat1 == NULL)
        return(FALSE);
    else if (ppat2 == NULL)
        return(TRUE);
    else if (ppat1->cSpec < ppat2->cSpec)
        return(FALSE);
    else if (ppat1->cSpec > ppat2->cSpec)
        return(TRUE);
    else if (ppat1->cWild >= ppat2->cWild)
        return(FALSE);
    else
        return(TRUE);
}

void ClassifyFileList()
{
    PATHINFO *  ppi;
    PAT *       ppatDel;
    PAT *       ppatNoDel;
    PAT *       ppatArc;
    PAT *       ppatNoArc;
    UINT        iFile;
    char *      pszFile;
    char        szBuf[MAX_PATH];

    for (iFile = 0; iFile < g_cFile; ++iFile)
    {
        pszFile = g_rgpszFile[iFile];

        strcpy(szBuf, pszFile);

        ppi = ParsePath(szBuf);

        ppatDel   = FindPattern(g_cpatDel, g_rgppatDel, ppi);
        ppatNoDel = FindPattern(g_cpatNoDel, g_rgppatNoDel, ppi);
        ppatArc   = FindPattern(g_cpatArc, g_rgppatArc, ppi);
        ppatNoArc = FindPattern(g_cpatNoArc, g_rgppatNoArc, ppi);

        free(ppi);

#ifdef DEBUG_PATTERN_MATCH
        printf("%s\n", pszFile);
        if (ppatDel)
            printf("  Del   = %2d.%d %s\n", ppatDel->cSpec, ppatDel->cWild, ppatDel->psz);
        if (ppatNoDel)
            printf("  NoDel = %2d.%d %s\n", ppatNoDel->cSpec, ppatNoDel->cWild, ppatNoDel->psz);
        if (ppatArc)
            printf("  Arc   = %2d.%d %s\n", ppatArc->cSpec, ppatArc->cWild, ppatArc->psz);
        if (ppatNoArc)
            printf("  NoArc = %2d.%d %s\n", ppatNoArc->cSpec, ppatNoArc->cWild, ppatNoArc->psz);
#endif

        if (ppatDel && !IsMoreSpecific(ppatNoDel, ppatDel) && !IsMoreSpecific(ppatArc, ppatDel))
        {
            AddToFileList(&g_rgpszDel, &g_cDel, pszFile);
        }
        else if (ppatArc && !IsMoreSpecific(ppatNoArc, ppatArc))
        {
            AddToFileList(&g_rgpszArc, &g_cArc, pszFile);
        }
        else
        {
            AddToFileList(&g_rgpszRem, &g_cRem, pszFile);
        }
    }
}

void DisplayOperations()
{
    UINT i;

    printf("nuke: %4d file%s would be deleted\n", g_cDel, g_cDel == 1 ? "" : "s");
    printf("nuke: %4d file%s would be archived\n", g_cArc, g_cArc == 1 ? "" : "s");
    printf("nuke: %4d file%s would remain\n", g_cRem, g_cRem == 1 ? "" : "s");

    if (g_fDisplayDeletes && g_cDel > 0)
    {
        printf("\n");
        for (i = 0; i < g_cDel; ++i)
        {
            printf("[del] %s\\%s\n", g_pszIniDir, g_rgpszDel[i]);
        }
    }

    if (g_fDisplayArchives && g_cArc > 0)
    {
        printf("\n");
        for (i = 0; i < g_cArc; ++i)
        {
            printf("[arc] %s\\%s\n", g_pszIniDir, g_rgpszArc[i]);
        }
    }

    if (g_fDisplayRemain && g_cRem > 0)
    {
        printf("\n");
        for (i = 0; i < g_cRem; ++i)
        {
            printf("[rem] %s\\%s\n", g_pszIniDir, g_rgpszRem[i]);
        }
    }
}

BOOL ArchiveFile(char * psz)
{
    char szBufSrc[MAX_PATH];
    char szBufDst[MAX_PATH];

    strcpy(szBufSrc, g_pszIniDir);
    strcat(szBufSrc, "\\");
    strcat(szBufSrc, psz);

    strcpy(szBufDst, g_pszArcDir);
    strcat(szBufDst, szBufSrc + 2);

    if (!MoveFileEx(szBufSrc, szBufDst, MOVEFILE_REPLACE_EXISTING))
    {
        PATHINFO *  ppi;
        char        szBuf1[MAX_PATH];
        char        szBuf2[MAX_PATH];
        int         i;

        if (GetLastError() != ERROR_PATH_NOT_FOUND)
        {
            char szErr[512];
            FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, NULL, GetLastError(), 0, szErr, sizeof(szErr), NULL);
            fprintf(stderr, "                                           \n");
            fprintf(stderr, "nuke: warning: Could not archive %s\n", szBufSrc);
            fprintf(stderr, "               %s\n", szErr);
            return(FALSE);
        }

        strcpy(szBuf1, szBufDst);
        ppi = ParsePath(szBuf1);

        strcpy(szBuf2, ppi->rgpsz[0]);

        for (i = 1; i < (int)ppi->cEnt - 1; ++i)
        {
            strcat(szBuf2, "\\");
            strcat(szBuf2, ppi->rgpsz[i]);

            if (!CreateDirectory(szBuf2, NULL))
            {
                if (GetLastError() != ERROR_ALREADY_EXISTS)
                    Win32Error("ArchiveFile --> CreateDirectory");
            }
        }

        if (!MoveFileEx(szBufSrc, szBufDst, MOVEFILE_REPLACE_EXISTING))
        {
            char szErr[512];
            FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, NULL, GetLastError(), 0, szErr, sizeof(szErr), NULL);
            fprintf(stderr, "                                           \n");
            fprintf(stderr, "nuke: warning: Could not archive %s\n", szBufSrc);
            fprintf(stderr, "               %s\n", szErr);
            return(FALSE);
        }
    }

    return(TRUE);
}

void ExecuteOperations()
{
    char * psz;
    char szBuf[MAX_PATH];
    UINT i;
    UINT iDel = 0;
    UINT iArc = 0;

    if (!g_fVerbose)
        fprintf(stderr, "nuke: %4d files deleted \r", 0);

    for (i = 0; i < g_cDel; ++i)
    {
        strcpy(szBuf, g_pszIniDir);
        strcat(szBuf, "\\");
        strcat(szBuf, g_rgpszDel[i]);
        
        if (!DeleteFile(szBuf))
        {
            char szErr[512];
            FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, NULL, GetLastError(), 0, szErr, sizeof(szErr), NULL);
            fprintf(stderr, "                                   \n");
            fprintf(stderr, "nuke: warning: Could not delete %s\n", szBuf);
            fprintf(stderr, "               %s\n", szErr);
            AddToFileList(&g_rgpszRem, &g_cRem, g_rgpszDel[i]);
        }
        else if (g_fVerbose)
        {
            iDel += 1;
            if (i == 0)
                printf("\n");
            printf("[del] %s\n", szBuf);
        }
        else
        {
            iDel += 1;
            fprintf(stderr, "nuke: %4d file%s deleted \r", iDel, iDel == 1 ? "" : "s");
        }
    }

    if (!g_fVerbose)
    {
        fprintf(stderr, "nuke: %4d file%s deleted \n", iDel, iDel == 1 ? "" : "s");
        fprintf(stderr, "nuke: %4d files archived \r", 0);
    }

    for (i = 0; i < g_cArc; ++i)
    {
        if (ArchiveFile(g_rgpszArc[i]))
        {
            iArc += 1;

            if (g_fVerbose)
            {
                if (i == 0)
                    printf("\n");
                printf("[arc] %s\\%s\n", g_pszIniDir, g_rgpszArc[i]);
            }
            else
            {
                fprintf(stderr, "nuke: %4d file%s archived \r", iArc, iArc == 1 ? "" : "s");
            }
        }
        else
        {
            AddToFileList(&g_rgpszRem, &g_cRem, g_rgpszArc[i]);
        }
    }

    if (g_fVerbose)
    {
        if (iDel || iArc)
            printf("\n");
        fprintf(stderr, "nuke: %4d file%s deleted    \n", iDel, iDel == 1 ? "" : "s");
    }
    fprintf(stderr, "nuke: %4d file%s archived \n", iArc, iArc == 1 ? "" : "s");
    fprintf(stderr, "nuke: %4d file%s remain%s \n", g_cRem, g_cRem == 1 ? "" : "s", g_cRem == 1 ? "s" : "");

    if (g_fDisplayRemain && g_cRem > 0)
    {
        printf("\n");
        for (i = 0; i < g_cRem; ++i)
        {
            printf("[rem] %s\\%s\n", g_pszIniDir, g_rgpszRem[i]);
        }
    }
}

void RestoreFromArchive()
{
    UINT i;
    char * psz;
    char szBufSrc[MAX_PATH];
    char szBufDst[MAX_PATH];
    BOOL fDisp = FALSE;

    for (i = 0; i < g_cFile; ++i)
    {
        psz = g_rgpszFile[i];

        strcpy(szBufSrc, g_pszArcDir);
        strcat(szBufSrc, g_pszIniDir + 2);
        strcat(szBufSrc, "\\");
        strcat(szBufSrc, psz);

        strcpy(szBufDst, g_pszIniDir);
        strcat(szBufDst, "\\");
        strcat(szBufDst, psz);

        if (FileExists(szBufDst))
            AddToFileList(&g_rgpszRem, &g_cRem, szBufDst);
        else
        {
            if (!g_fDisplayOnly)
            {
                if (!MoveFileEx(szBufSrc, szBufDst, 0))
                {
                    Win32Error("RestoreFromArchive --> MoveFileEx");
                }
            }

            if (g_fDisplayRestores)
            {
                if (i == 0)
                    printf("\n");
                printf("[restored] %s\n", szBufDst);
                fDisp = TRUE;
            }
        }
    }
    
    if (g_cRem > 0 && g_fDisplayRestores)
    {
        printf("\n");

        for (i = 0; i < g_cRem; ++i)
            printf("[NOCLOBBER] %s\n", g_rgpszRem[i]);

        fDisp = TRUE;
    }

    if (fDisp)
        printf("\n");

    printf("nuke: %4d file%s %srestored \n",
           g_cFile - g_cRem, g_cFile - g_cRem == 1 ? "" : "s", g_fDisplayOnly ? "would be " : "");

    if (g_cRem > 0)
    {
        printf("nuke: %4d file%s %s clobbered\n",
               g_cRem, g_cRem == 1 ? "" : "s", g_fDisplayOnly ? "would not be" : "not");
    }
}

int __cdecl main(int argc, char * argv[])
{
    int i;

    for (i = 1; i < argc; ++i)
    {
        char * pch = argv[i];

        if (lstrcmp(pch, "...") == 0)
            g_fStartAtRoot = FALSE;
        else if (*pch == '-')
        {
            ++pch;

            if (*pch == 0 || pch[1] != 0)
                Usage();

            if (*pch == 'n')
                g_fDisplayOnly = TRUE;
            else if (*pch == 'v')
            {
                g_fVerbose = TRUE;
                g_fDisplayDeletes = TRUE;
                g_fDisplayArchives = TRUE;
                g_fDisplayRemain = TRUE;
                g_fDisplayRestores = TRUE;
            }
            else if (*pch == 'u')
            {
                g_fUndo = TRUE;
            }
            else
                Usage();
        }
        else if (g_fUndo)
        {
            PAT * ppat = ParsePattern(pch);

            if (ppat == NULL || ppat->cEnt > 1)
                Fatal("Syntax error in undo pattern - \"%s\"", pch);

            AddPatternToList(ppat, &g_cpatUndo, &g_rgppatUndo);
        }
        else
            Usage();
    }

    if (g_fUndo && g_cpatUndo == 0)
    {
        AddPatternToList(ParsePattern("*"), &g_cpatUndo, &g_rgppatUndo);
    }

    ParseIniFiles();
    SetupArchiveDir();
    GenerateFileList();
    
    if (g_fUndo)
    {
        RestoreFromArchive();
    }
    else
    {
        ClassifyFileList();

        if (g_fDisplayOnly)
            DisplayOperations();
        else
            ExecuteOperations();
    }

    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\objref\objref.cpp ===
/*
 *
 * objref.cpp
 *
 * Scan a list of obj files to compute the symbolic closure -- defined &
 * undefined symbols
 *
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <io.h>
#include <ctype.h>

typedef int BOOL;
typedef unsigned long DWORD;

typedef struct {
	char *szSym;
	char *szObj;
	BOOL fData;
	BOOL fDef;
} SOM;

SOM **rgpsom;
DWORD isomMax;
DWORD csom;

BOOL fVerbose = 0;

DWORD key(char *sz)
{
	int i;

	for(i = 0; *sz; ++sz)
		i = (i * 17) ^ *sz;
	return i;
}

void hashadd(SOM *psom)
{
	if(csom >= isomMax / 2) {
		if(rgpsom) {
			SOM **rgpsomOld = rgpsom;
			int isomOld = isomMax;
			rgpsom = new SOM *[isomMax += 128];
			memset(rgpsom, 0, sizeof(SOM *) * isomMax);
			csom = 0;
			while(isomOld--)
				if(rgpsomOld[isomOld] && rgpsomOld[isomOld] != (SOM *)rgpsomOld)
					hashadd(rgpsomOld[isomOld]);
			delete rgpsomOld;
		} else {
			rgpsom = new SOM *[isomMax = 128];
			memset(rgpsom, 0, sizeof(SOM *) * isomMax);
		}
	}

	DWORD isom = key(psom->szSym) % isomMax;
	SOM **ppsomKeep = NULL;

	for(;;) {
		if(rgpsom[isom] == NULL) {
			if(!ppsomKeep)
				ppsomKeep = &rgpsom[isom];
			break;
		} else if(rgpsom[isom] == (SOM *)rgpsom) {
			if(!ppsomKeep)
				ppsomKeep = &rgpsom[isom];
		} else if(!strcmp(psom->szSym, rgpsom[isom]->szSym))
			return;
		isom = (isom + 1) % isomMax;
	}

	++csom;
	*ppsomKeep = new SOM(*psom);
	(*ppsomKeep)->szSym = strdup((*ppsomKeep)->szSym);
	(*ppsomKeep)->szObj = strdup((*ppsomKeep)->szObj);
}

SOM *hashfind(char *szSym)
{
	if(!isomMax)
		return NULL;

	DWORD isom = key(szSym) % isomMax;

	for(;;) {
		if(rgpsom[isom] == NULL)
			return NULL;
		else if(rgpsom[isom] != (SOM *)rgpsom && !strcmp(szSym,
				rgpsom[isom]->szSym))
			return rgpsom[isom];
		isom = (isom + 1) % isomMax;
	}
}

void readbss(const char *szName)
{
	FILE *pfl;

	pfl = fopen(szName, "r");
	if(pfl) {
		char sz[256];
		while(fgets(sz, sizeof sz, pfl)) {
			char *pchFirst;
			char *pchLast;
			for(pchFirst = sz; *pchFirst && isspace(*pchFirst); ++pchFirst);
			for(pchLast = pchFirst; *pchLast && !isspace(*pchLast); ++pchLast);
			*pchLast = 0;

			SOM *psom = hashfind(pchFirst);
			if(psom)
				fprintf(stderr, "warning: %s already defined in bss\n",
					pchFirst);
			else {
				SOM som;
				som.szSym = pchFirst;
				som.szObj = "<common>";
				som.fData = 0;
				som.fDef = 1;
				hashadd(&som);
			}
		}
		fclose(pfl);
	}
}

int __cdecl main(int argc, char **argv)
{
	if(argc > 1 && _strnicmp(argv[1], "-bss:", 5) == 0) {
		readbss(argv[1] + 5);
		++argv;
		--argc;
	}
	for(; ++argv, --argc; ) {
		struct _finddata_t fd;
		long fi;

		fi = _findfirst(*argv, &fd);
		if(fi == -1)
			fprintf(stderr, "error on %s\n", *argv);
		while(fi != -1) {
			FILE *pfl;
			char sz[256];

			sprintf(sz, "link -dump -symbols %s", fd.name);
			pfl = _popen(sz, "r");
			if(!pfl)
				fprintf(stderr, "error with dump on %s\n", fd.name);
			else {
				BOOL fDataSection = 0;

				if(fVerbose)
					printf("Processing %s\n", fd.name);
				while(fgets(sz, sizeof sz, pfl)) {
					if(sz[0] != ' ') {
						char *szSect;
						char *szType;
						char *szSym;
						char *pchMac = sz + strlen(sz);
						/* We have a valid line.  We only care about the
						 * section number, type, and symbol name */
						szSect = sz + 13;
						szType = sz + 33;
						szSym = sz + 46;
						if(szSect >= pchMac || szType >= pchMac || szSym >=
								pchMac)
							/* Not valid */
							continue;
						/* The symbol may start later; we look for the '|'
						 * character */
						while(*szSym && *szSym != '|')
							++szSym;
						if(*szSym == '|')
							++szSym;
						while(*szSym && isspace(*szSym))
							++szSym;
						if(!*szSym)
							continue;

						BOOL fExtern;
						if(strncmp(szSect, "UNDEF", 5) == 0)
							/* Undefined symbols in a data section we treat
							 * like bss data because we don't know any
							 * better */
							//fExtern = !fDataSection;
							// too bad we can't identify bss data
							fExtern = 1;
						else if(strncmp(szSect, "SECT", 4) == 0)
							fExtern = 0;
						else
							/* Invalid section */
							continue;

						BOOL fSectionMark;

						if(strncmp(szType, "Static", 6) == 0)
							fSectionMark = 1;
						else if(strncmp(szType, "External", 8) == 0)
							fSectionMark = 0;
						else
							/* Uninteresting data */
							continue;

						for(pchMac = szSym; *pchMac && !isspace(*pchMac);
							++pchMac);
						*pchMac = 0;

						if(fSectionMark) {
							/* Section marker */
							if(strcmp(szSym, ".data") == 0 ||
									strcmp(szSym, ".rdata") == 0)
								fDataSection = 1;
							else
								fDataSection = 0;
							continue;
						}

						SOM *psom;
						/* We've parsed this line.  See if we can find this
						 * symbol anywhere else */
						if(fVerbose)
							printf("  sym:%s %s\n", szSym, fExtern ? "referenced" : "defined");
						psom = hashfind(szSym);
						if(psom) {
							if(psom->fDef && !fExtern)
								/* Multiply defined */
								fprintf(stderr, "warning: %s defined in both "
									"%s and %s\n", szSym, psom->szObj,
									fd.name);
							else if(!psom->fDef && !fExtern) {
								/* Here's our definition */
								free(psom->szObj);
								psom->szObj = strdup(fd.name);
								psom->fDef = 1;
							}
						} else {
							/* First reference to this symbol, so add it */
							SOM som;
							som.fData = 0;
							som.fDef = !fExtern;
							som.szObj = fd.name;
							som.szSym = szSym;
							hashadd(&som);
						}
					}
				}
				_pclose(pfl);
			}
			if(0 != _findnext(fi, &fd))
				fi = -1;
		}
	}

    DWORD isom;
#if 0
    /* Now print all of our defined symbols */
	printf("\nSymbols defined:\n\n");

	for(isom = 0; isom < isomMax; ++isom)
		if(rgpsom[isom] && rgpsom[isom] != (SOM *)rgpsom && rgpsom[isom]->fDef)
			printf(" %s (%s)\n", rgpsom[isom]->szSym, rgpsom[isom]->szObj);

	/* Now print all of our undefined symbols */
	printf("\nUndefined symbols:\n\n");
#endif // 0
    for(isom = 0; isom < isomMax; ++isom)
		if(rgpsom[isom] && rgpsom[isom] != (SOM *)rgpsom && !rgpsom[isom]->fDef &&
		    (0 != strncmp("__imp_", rgpsom[isom]->szSym, 6)))
			printf(" %s (%s)\n", rgpsom[isom]->szSym, rgpsom[isom]->szObj);

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\rdbld\rdbld.c ===
/*++

Copyright (c) 1989-2000  Microsoft Corporation

Module Name:

    RDBLD.c

Abstract:

    This module implements a utility program to extract the code out of romdec32.exe

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <xcrypt.h>
#include <sha.h>
#include <bldr.h>
#include <conio.h>

_CRTIMP void __cdecl exit(int);

void
RomdecCalcHash(
    PUCHAR DataToHash,
    ULONG HashSize,
    PUCHAR Hash
)
{}
//#include "romhash.h"

void GetPasswd(LPCSTR szPrompt, LPSTR sz, int cchMax)
{
    char ch;
    int ich = 0;

    _cputs(szPrompt);
    for(;;) {
        ch = (char)_getch();
        switch(ch) {
        case 8:
            if(ich)
                --ich;
            break;
        case 10:
        case 13:
            sz[ich] = 0;
            _putch('\r');
            _putch('\n');
            return;
        default:
            if(ich < cchMax)
                sz[ich++] = ch;
            break;
        }
    }
}

ULONG
xxxLdrRelocateImage (
    IN PVOID ImageToRelocate,
    IN PVOID LoadAddress,
    IN PUCHAR LoaderName,
    IN ULONG Success,
    IN ULONG Conflict,
    IN ULONG Invalid
    );

VOID
ReadFileIntoMemory(
    LPCSTR lpFileName,
    LPVOID *ppvFileContents,
    DWORD *pdwFileSize
    )
{
    HANDLE hFile;
    DWORD dwBytesRead;

    hFile = CreateFile(lpFileName, GENERIC_READ, FILE_SHARE_READ, NULL,
        OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

    if (hFile == INVALID_HANDLE_VALUE) {
        fprintf(stderr, "RDBLD : Error : unable to open %s\n", lpFileName);
        exit(1);
    }

    *pdwFileSize = GetFileSize(hFile, NULL);
    *ppvFileContents = LocalAlloc(LMEM_FIXED, *pdwFileSize);

    if (*ppvFileContents == NULL) {
        fprintf(stderr, "RDBLD : Error : cannot allocate buffer for %s\n", lpFileName);
        exit(1);
    }

    if (!ReadFile(hFile, *ppvFileContents, *pdwFileSize, &dwBytesRead, NULL) ||
        (dwBytesRead != *pdwFileSize)) {
        fprintf(stderr, "RDBLD : Error : cannot read from %s\n", lpFileName);
        exit(1);
    }

    CloseHandle(hFile);
}

int
__cdecl
main(
    int argc,
    char *argv[]
    )
{
    LPVOID RomDecFileContents;
    DWORD RomDecFileSize;
    PIMAGE_NT_HEADERS NtHeader;
    PIMAGE_SECTION_HEADER SectionHeader;
    ULONG RomDecBaseAddress;
    NTSTATUS status;
    HANDLE hOutputFile;
    DWORD dwBytesWritten;
    DWORD SectionSize;
    LPVOID RStartupFileContents;
    DWORD RStartupFileSize;
    PVOID PadBuffer;
    DWORD PadSize;
    HANDLE hPreldrFile = INVALID_HANDLE_VALUE;
    BYTE rgbPreldr[PRELDR_BLOCK_SIZE - 0x180];
    BYTE rgbRomdec[ROM_DEC_SIZE];
    DWORD cb;
    PBYTE pbEncryptedRomdec;
    BOOL fXM3P = FALSE;
    A_SHA_CTX SHAHash;
    FILETIME ft;
    BYTE rgbHash[XC_DIGEST_LEN];
    PBYTE pbPreldrKey;
    char ch;
    char szPasswd1[64];
    char szPasswd2[64];

    //
    // See whether we're doing an XM3P build
    //
    if(argc >= 2 && 0 == _stricmp(argv[1], "-xm3p")) {
        if(argc < 4)
            goto badcmdline;
        argc -= 3;
        argv += 3;
        hPreldrFile = CreateFile(argv[-1], GENERIC_READ, 0, NULL,
            OPEN_EXISTING, 0, NULL);
        if(INVALID_HANDLE_VALUE == hPreldrFile) {
noreadpreldr:
            fprintf(stderr, "RDBLD: cannot read %s\n", argv[-1]);
            exit(1);
        }
        memset(rgbPreldr, 0, sizeof rgbPreldr);
        if(!ReadFile(hPreldrFile, rgbPreldr, sizeof rgbPreldr, &cb, 0) ||
                cb != GetFileSize(hPreldrFile, NULL))
            goto noreadpreldr;
        CloseHandle(hPreldrFile);
        hPreldrFile = CreateFile(argv[0], GENERIC_WRITE, 0, NULL,
            CREATE_ALWAYS, 0, NULL);
        if(INVALID_HANDLE_VALUE == hPreldrFile) {
nowritepreldr:
            fprintf(stderr, "RDBLD: cannot write %s\n", argv[0]);
            exit(1);
        }
        fXM3P = TRUE;
    }

    //
    // Verify that we have the correct number of command line arguments.
    //

    if (argc != 4) {
badcmdline:
        fprintf(stderr, "RDBLD : Error : invalid command line\n");
        exit(1);
    }

    //
    // Read the input images into memory.
    //
    ReadFileIntoMemory(argv[1], &RomDecFileContents, &RomDecFileSize);
    printf("RDBLD - Reading file %s (%d bytes)\n", argv[1], RomDecFileSize);

    ReadFileIntoMemory(argv[2], &RStartupFileContents, &RStartupFileSize);
    printf("RDBLD - Reading file %s (%d bytes)\n", argv[2], RStartupFileSize);


    //
    // Go find the NT header.
    //

    NtHeader = RtlImageNtHeader(RomDecFileContents);

    if (NtHeader == NULL) {
        fprintf(stderr, "RDBLD : Error : corrupt image\n");
        exit(1);
    }

    //
    // Go find the .text section header.  For now, we assume this is the first
    // section in the image.
    //

    SectionHeader = IMAGE_FIRST_SECTION(NtHeader);

    if (strcmp(SectionHeader->Name, ".text") != 0) {
        fprintf(stderr, "RDBLD : Error : .text section isn't first section\n");
        exit(1);
    }

    //
    // Compute the base address for the RomDec.  It will reside at highest 512 bytes of the 
    // address space plus the PE headers are stripped off.
    //
    RomDecBaseAddress = 0xFFFFFFFF - 0x1FF - SectionHeader->VirtualAddress;

    printf("RDBLD - Rebasing to %08X, code will start at %08X\n", RomDecBaseAddress, 0xFFFFFFFF - 0x1FF);

    //
    // Relocate 
    //

    __try {
        status = (NTSTATUS)xxxLdrRelocateImage((PVOID)RomDecFileContents,
            (PVOID)RomDecBaseAddress, "RDBLD", (ULONG)STATUS_SUCCESS,
            (ULONG)STATUS_CONFLICTING_ADDRESSES, (ULONG)STATUS_INVALID_IMAGE_FORMAT);
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        status = GetExceptionCode();
    }

    if (!NT_SUCCESS(status)) {
        fprintf(stderr, "RDBLD : Error : error %08x while relocating 32-bit image\n",
            status);
        exit(1);
    }

    SectionSize = SectionHeader->Misc.VirtualSize;
    if (SectionSize + RStartupFileSize > ROM_DEC_SIZE) {
        fprintf(stderr, "RDBLD : Error : Total size (%d + %d) exceeds %d bytes\n",
            SectionSize, RStartupFileSize, ROM_DEC_SIZE);
        exit(1);
    }
    printf("RDBLD: 32-bit size is %d bytes\n", SectionSize);
    printf("RDBLD: 16-bit size is %d bytes\n", RStartupFileSize);

    //
    // Initialize our buffer to NOP padding
    //
    memset(rgbRomdec, 0x90, sizeof rgbRomdec);

    //
    // Assemble the romdec contents
    //
    memcpy(rgbRomdec, (PUCHAR)RomDecFileContents +
        SectionHeader->PointerToRawData, SectionSize);
    memcpy(rgbRomdec + sizeof rgbRomdec - RStartupFileSize,
        RStartupFileContents, RStartupFileSize);

    //
    // If we're building XM3P, we need to hash the preldr into the romdec
    // and generate a random key
    //
    if(fXM3P) {

        //
        // Make sure everything will fit
        //
        if(ROMDEC_N < RStartupFileSize + 12 || SectionSize >
            ROM_DEC_SIZE - ROMDEC_N)
        {
            fprintf(stderr, "RDBLD: XM3P nonce won't fit\n");
            exit(1);
        }
        if(ROMDEC_HASH < RStartupFileSize + 16 || SectionSize >
            ROM_DEC_SIZE - ROMDEC_HASH)
        {
            fprintf(stderr, "RDBLD: XM3P hash won't fit\n");
            exit(1);
        }

        //
        // We'll be encrypting the romdec, so get a password first
        //

        GetPasswd("Enter password:", szPasswd1, sizeof szPasswd1);
        if(strlen(szPasswd1) < 8) {
            fprintf(stderr, "Password must be >= 8 chars\n");
            exit(1);
        }
        GetPasswd("Enter it again:", szPasswd2, sizeof szPasswd2);
        if(strcmp(szPasswd1, szPasswd2)) {
            fprintf(stderr, "Passwords do not match\n");
            exit(1);
        }
        memset(szPasswd2, 0, sizeof szPasswd2);

        //
        // The random key comes first
        //

        A_SHAInit(&SHAHash);
        GetSystemTimeAsFileTime(&ft);
        A_SHAUpdate(&SHAHash, (PBYTE)&ft, sizeof ft);
        _cputs("Enter random data:");
        do {
            ch = (char)_getch();
            _asm {
                lea ecx, ft
                rdtsc
                mov [ecx], eax
                mov [ecx+4], edx
            }
            A_SHAUpdate(&SHAHash, (PBYTE)&ft, sizeof ft);
        } while(ch != 10 && ch != 13);
        _putch('\r');
        _putch('\n');
        GetSystemTimeAsFileTime(&ft);
        A_SHAUpdate(&SHAHash, (PBYTE)&ft, sizeof ft);
        A_SHAFinal(&SHAHash, rgbHash);
        XCSymmetricEncDec(rgbRomdec + ROM_DEC_SIZE - ROMDEC_N,
            ROMDEC_N - RStartupFileSize, rgbHash, sizeof rgbHash);

        //
        // Now that we have the random key, we encrypt the preldr's public
        // key with it
        //
        pbPreldrKey = (PBYTE)((PULONG)rgbPreldr)[3];
        ((PULONG)rgbPreldr)[3] = 0;
        pbPreldrKey = pbPreldrKey - (PUCHAR)(0UL - ROM_DEC_SIZE -
            PRELDR_BLOCK_SIZE) + rgbPreldr;
        XCSymmetricEncDec(pbPreldrKey, XC_PUBLIC_KEYDATA_SIZE,
            rgbRomdec + ROM_DEC_SIZE - ROMDEC_N, 12);

        //
        // Now we hash the preldr into the romdec
        //

        RomdecCalcHash(rgbPreldr, sizeof rgbPreldr, rgbRomdec + ROM_DEC_SIZE -
            ROMDEC_HASH);

        //
        // Finally, we write the updated preloader
        //

        printf("RDBLD: Wrote new preldr file %s\n", argv[0]);
        if(!WriteFile(hPreldrFile, rgbPreldr, sizeof rgbPreldr,
                &dwBytesWritten, NULL) || dwBytesWritten != sizeof rgbPreldr)
            goto nowritepreldr;
        CloseHandle(hPreldrFile);

        //
        // Now we have to encrypt the romdec.  Format is 8-byte confounder +
        // encrypt(20 bytes digest + data).  Confounder is RC4 stream from the
        // romdec hash (which is random by virtue of the key we generated
        // above).  RC4 key for the encryption stream is the nonce encrypted
        // with the password hash
        //

        pbEncryptedRomdec = malloc(cb = sizeof rgbRomdec + 28);
        memcpy(pbEncryptedRomdec + 28, rgbRomdec, sizeof rgbRomdec);
        A_SHAInit(&SHAHash);
        A_SHAUpdate(&SHAHash, rgbRomdec, sizeof rgbRomdec);
        A_SHAFinal(&SHAHash, pbEncryptedRomdec + 8);
        XCSymmetricEncDec(pbEncryptedRomdec, 8, pbEncryptedRomdec + 8, 8);

        A_SHAInit(&SHAHash);
        A_SHAUpdate(&SHAHash, szPasswd1, strlen(szPasswd1));
        A_SHAFinal(&SHAHash, rgbHash);
        XCSymmetricEncDec(pbEncryptedRomdec, 8, rgbHash, sizeof rgbHash);
        XCSymmetricEncDec(pbEncryptedRomdec + 8, sizeof rgbRomdec + 20,
            pbEncryptedRomdec, 8);
        XCSymmetricEncDec(pbEncryptedRomdec, 8, rgbHash, sizeof rgbHash);
        memset(szPasswd1, 0, sizeof szPasswd1);
    } else {
        pbEncryptedRomdec = rgbRomdec;
        cb = sizeof rgbRomdec;
    }

    //
    // Create the output file.
    //
    printf("RDBLD - Writing output file %s\n", argv[3]);

    hOutputFile = CreateFile(argv[3], GENERIC_WRITE, FILE_SHARE_READ, NULL,
        CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

    if (hOutputFile == INVALID_HANDLE_VALUE) {
        fprintf(stderr, "RDBLD : Error : cannot write to %s\n", argv[3]);
        exit(1);
    }

    //
    // write out text section
    //
    printf("RDBLD - Writing data (%d bytes)\n", ROM_DEC_SIZE);

    if (!WriteFile(hOutputFile, pbEncryptedRomdec, cb,
        &dwBytesWritten, NULL) || (cb != dwBytesWritten)) {
        fprintf(stderr, "RDBLD : Error : cannot write to %s\n", argv[3]);

        CloseHandle(hOutputFile);
        exit(1);
    }


    CloseHandle(hOutputFile);

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\rombld\enc.h ===
/*++

Copyright (c) 1989-2000  Microsoft Corporation

Module Name:

    enc.h

Abstract:


--*/

#ifndef _ENC_H
#define _ENC_H

#include <windows.h>
 
#define XC_ENCFILE_SIG             'k2ne' // signature dword in the encrypted file


#define RC4_CONFOUNDER_LEN          8
#define HMAC_K_PADSIZE              64

typedef struct _RC4_SHA1_HEADER {
    UCHAR Checksum[A_SHA_DIGEST_LEN];
    UCHAR Confounder[RC4_CONFOUNDER_LEN];
} RC4_SHA1_HEADER, *PRC4_SHA1_HEADER;



typedef struct _XC_ENCFILE_HEADER
{
    DWORD Sig;
    RC4_SHA1_HEADER CryptHeader;
    DWORD MsgLen;
    UCHAR MsgDigest[A_SHA_DIGEST_LEN];
} XC_ENCFILE_HEADER, *PXC_ENCFILE_HEADER;



BOOL
XcWriteEncryptedFile(
    PBYTE pMessage,
    DWORD cbMsgLen,
    LPCSTR pszFN,
    LPCSTR pszPassword,
    PBYTE pConfounder  // RC4_CONFOUNDER_LEN bytes
    );
 
BOOL 
XcReadEncryptedFile(
    LPCSTR pszFN, 
    LPCSTR pszPassword,
    PBYTE pMsgBuf,
    DWORD cbMsgBufLen
    );

BOOL 
XcGetEncryptedFileMsgLen(
    LPCSTR pszFN,
    PDWORD pdwSize
    );


#endif // _ENC_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\ntsdexts\regexts.c ===
/*******************************************************************
*
*    Copyright (c) 1999  Microsoft Corporation
*
*    DESCRIPTION: an extension to dump the contents of registry keys and values
*
*    AUTHOR:
*         Based on Code by : danielwe (Dan Weisman)
*         ntsd addition by : kksharma (Kshitiz K. Sharma)
*
*    DATE:4/20/1999
*
*******************************************************************/


#ifndef KERNEL

#ifndef Print
#define Print dprintf
#endif


#define OFLAG(l)        (1L << ((DWORD)#@l - (DWORD)'a'))
#define LINE_NUMBER     0
#define NUM_ASCII_CHARS 16
#define NUM_HEX_CHARS   (NUM_ASCII_CHARS * 3)
#define SPACE           7
#define PB_BUFFER_SIZE  (NUM_ASCII_CHARS * 50)

VOID dregHelp() {
   dprintf("!dreg -[d|w] <keyPath>[![<valueName> | *]]  - Dumps registry information\n");
   dprintf("!dreg -d ...                                - Prints binary values as DWORDs\n");
   dprintf("!dreg -w ...                                - Prints binary values as WORDs\n");
   dprintf("!dreg <keyPath>!*                           - Prints all values under <keyPath>\n");
   dprintf("!dreg <keyPath>                             - Prints all subkeys of <keyPath>\n");
   dprintf("\n");
   dprintf("<keypath> can begin with any of the following:\n");
   dprintf("\thklm - HKEY_LOCAL_MACHINE\n");
   dprintf("\thkcu - HKEY_CURRENT_USER\n");
   dprintf("\thkcr - HKEY_CLASSES_ROOT\n");
   dprintf("\thku  - HKEY_USERS\n");
   dprintf("\tif absent, hklm is assumed\n");
   dprintf("\n");
   dprintf("Ex:\n");
   dprintf("!dreg hkcu\\Software\\Microsoft\n");
   dprintf("!dreg System\\CurrentControlSet\\Services\\Tcpip!*\n");
   dprintf("!dreg System\\CurrentControlSet\\Services\\Tcpip!Start\n");
}

VOID PrintBinary(PBYTE pbData, DWORD cbData, USHORT uWidth)
{
    CHAR    line[80];
    INT     i;
    INT     ascii = 0;
    PBYTE   temp = pbData;
    BOOL    fDone = FALSE;
    DWORD   cbCount = 0;

    CHAR hex_digits[] = "0123456789ABCDEF";

    while (!fDone)
    {
        DWORD   cb;

        memset(line, 0x20, sizeof(line));
        Print("%04X:  ", cbCount);
        for (ascii = 0,i = LINE_NUMBER, cb = 0;
             ascii < NUM_ASCII_CHARS;
             ascii++, temp++)
        {
            if ((DWORD)(temp - pbData) >= cbData)
            {
                if (cbData < PB_BUFFER_SIZE)
                {
                    fDone = TRUE;
                    break;
                }
                else
                    return;
            }
            line[i] = hex_digits[(*temp & 0xF0) >> 4];
            line[i + 1] = hex_digits[(*temp & 0x0F)];
            cb++;
            if ((ascii + 1) % uWidth == 0)
            {
                line[i + 2] = 0x20;
                i++;
                if (uWidth > 1)
                {
                    line[i + 3] = 0x20;
                    i++;
                }
                else if (uWidth == 1 && (!(cb % 4)))
                {
                    line[i + 3] = 0x20;
                    line[i + 4] = 0x20;
                    i += 2;
                }
            }
            i += 2;
            line[ascii + NUM_HEX_CHARS + SPACE + LINE_NUMBER] =
                (isprint(*temp) ? *temp : '.');
            cbCount++;
        }

        line[79] = 0;
        Print("%s\n", line);
    }
}

VOID PrintMultiSz(PBYTE pbData)
{
    LPSTR   sz = (LPSTR)pbData;
    DWORD   csz = 0;

    while (*sz)
    {
        Print("%d: \"%s\"\n", csz, *sz ? sz : "<empty>");
        csz++;
        sz += lstrlenA(sz) + 1;
    }
}

VOID PrintRegistryValue(DWORD dwType, PBYTE pbData, DWORD cbData, USHORT uWidth)
{
    switch (dwType)
    {
    case REG_SZ:
        Print("REG_SZ: \"%s\"\n", *pbData ? pbData : "<empty>");
        break;

    case REG_EXPAND_SZ:
        {
            CHAR    szExpanded[MAX_PATH + 1];

            Print("REG_EXPAND_SZ: \"%s\"\n", pbData);
            ExpandEnvironmentStringsA((LPCSTR)pbData, (LPSTR)&szExpanded,
                                      MAX_PATH);
            Print("expanded = \"%s\"\n", szExpanded);
            break;
        }

    case REG_DWORD:
        {
            DWORD   dwData = * ((DWORD *)pbData);

            Print("REG_DWORD: %lu = 0x%08X\n", dwData, dwData);
            break;
        }

    case REG_BINARY:
        {
            Print("REG_BINARY:\n");
            PrintBinary(pbData, cbData, uWidth);
            break;
        }

    case REG_MULTI_SZ:
        {
            Print("REG_MULTI_SZ:\n");
            PrintMultiSz(pbData);
            break;
        }
    }
}

VOID EnumSubKeys(HKEY hkeyRoot, LPSTR szKey)
{
    HKEY    hkey;
    LONG    l;
    BOOL    fFound = FALSE;

    l = RegOpenKeyExA(hkeyRoot, szKey, 0, KEY_READ, &hkey);
    if (ERROR_SUCCESS == l)
    {
        FILETIME    ft;
        DWORD       cbName;
        CHAR        szName[MAX_PATH + 1];
        DWORD       dwIndex;

        for (dwIndex = 0; l == ERROR_SUCCESS; dwIndex++)
        {
            cbName = MAX_PATH;
            l = RegEnumKeyExA(hkey, dwIndex, szName, &cbName, NULL,
                              NULL, NULL,&ft);
            if (ERROR_SUCCESS == l)
            {
                Print("Subkey: %s\n", szName);
                fFound = TRUE;
            }
        }

        RegCloseKey(hkey);
    }
    else
    {
        Print("Could not open subkey %s. Error (%d).\n", szKey, l);
    }

    if (!fFound)
    {
        Print("No subkeys\n");
    }
}

VOID EnumValues(HKEY hkeyRoot, LPSTR szKey, USHORT uWidth)
{
    HKEY    hkey;
    LONG    l;
    BOOL    fFound = FALSE;

    l = RegOpenKeyExA(hkeyRoot, szKey, 0, KEY_READ, &hkey);
    if (ERROR_SUCCESS == l)
    {
        DWORD   cbMax;

        l = RegQueryInfoKeyA(hkey, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
                             NULL, &cbMax, NULL, NULL);
        if (ERROR_SUCCESS == l)
        {
            DWORD       cbName;
            CHAR        szName[MAX_PATH + 1];
            DWORD       dwIndex;
            PBYTE       pbData;
            DWORD       dwType;
            DWORD       cbData;

            pbData = (PBYTE)LocalAlloc(LPTR, cbMax);

            if (pbData)
            {
                for (dwIndex = 0; l == ERROR_SUCCESS; dwIndex++)
                {
                    cbName = MAX_PATH;
                    cbData = cbMax;
                    l = RegEnumValueA(hkey, dwIndex, szName, &cbName, NULL,
                                      &dwType, pbData, &cbData);
                    if (ERROR_SUCCESS == l)
                    {
                        Print("Value: \"%s\" - ", szName);
                        PrintRegistryValue(dwType, pbData, cbData, uWidth);
                        Print("------------------------------------------------------------------------\n");
                        fFound = TRUE;
                    }
                }

                LocalFree(pbData);
            }
        }

        RegCloseKey(hkey);
    }
    else
    {
        Print("Could not open subkey %s. Error (%d).\n", szKey, l);
    }

    if (!fFound)
    {
        Print("No values\n");
    }
}

/************************************************************************\
* Procedure: Idreg
*
* Description: Dumps registry value
*
* Returns: fSuccess
*
* 4/14/1999 Created DanielWe
*
\************************************************************************/
BOOL Idreg(
DWORD opts,
LPSTR lpas)
{
    LONG    l;
    HKEY    hkey;
    DWORD   cbData = 0;
    DWORD   dwType;
    LPBYTE  pbData = NULL;
    LPSTR   szKey = NULL;
    LPSTR   szValue = NULL;
    LPSTR   lpasOrig = lpas;
    HKEY    hkeyRoot;

    // Eat leading spaces first
    while (*lpas && *lpas == ' ')
    {
        lpas++;
    }

    while (*lpas && *lpas != '\\')
    {
        lpas++;
    }

    if (!*lpas)
    {
        // Corner case.. no backslash at all. Assume HKLM and start over
        hkeyRoot = HKEY_LOCAL_MACHINE;
        lpas = lpasOrig;
    }
    else
    {
        // Figure out which hive they want to open
        *lpas = 0;
        if (!lstrcmpiA(lpasOrig, "hkcu"))
        {
            hkeyRoot = HKEY_CURRENT_USER;
            lpas++;
        }
        else if (!lstrcmpiA(lpasOrig, "hklm"))
        {
            hkeyRoot = HKEY_LOCAL_MACHINE;
            lpas++;
        }
        else if (!lstrcmpiA(lpasOrig, "hku"))
        {
            hkeyRoot = HKEY_USERS;
            lpas++;
        }
        else if (!lstrcmpiA(lpasOrig, "hkcr"))
        {
            hkeyRoot = HKEY_CLASSES_ROOT;
            lpas++;
        }
        else if (!lstrcmpiA(lpasOrig, "help"))
        {
           dregHelp();
           return FALSE;
        }
        else
        {
            hkeyRoot = HKEY_LOCAL_MACHINE;

            // Restore the backslash because we assume if they don't use these
            // keywords, then they want HKLM
            *lpas = '\\';
            lpas = lpasOrig;
        }
    }

    szKey = (LPSTR)lpas;

    while (*lpas && *lpas != '!')
    {
        lpas++;
    }

    if (*lpas)
    {
        // Null terminate the !
        *lpas++ = 0;

        // mark beginning of new string
        szValue = (LPSTR)lpas;
    }

    if (szKey == NULL || *szKey == 0)
    {
        Print("Expected subkey name\n");
        dregHelp();
        return FALSE;
    }
    if (szValue == NULL || *szValue == 0)
    {
        EnumSubKeys(hkeyRoot, szKey);
    }
    else if (!lstrcmpA(szValue, "*"))
    {
        EnumValues(hkeyRoot, szKey, (USHORT)opts);
    }
    else
    {
        l = RegOpenKeyExA(hkeyRoot, (LPCSTR)szKey, 0, KEY_READ, &hkey);
        if (ERROR_SUCCESS == l)
        {
            l = RegQueryValueExA(hkey, (LPCSTR)szValue, NULL, &dwType, NULL,
                                &cbData);
            if (ERROR_SUCCESS == l)
            {
                pbData = (LPBYTE)LocalAlloc(LPTR, cbData);
                l = RegQueryValueExA(hkey, (LPCSTR)szValue, NULL, &dwType, pbData,
                                    &cbData);
                if (ERROR_SUCCESS == l)
                {
                    PrintRegistryValue(dwType, pbData, cbData, (USHORT)opts);
                }

                LocalFree(pbData);
            }
            else
            {
                Print("Could not query value %s!%s. Error (%d).\n", szKey, szValue, l);
            }
            RegCloseKey(hkey);
        }
        else
        {
            Print("Could not open subkey %s. Error (%d).\n", szKey, l);
        }
    }

    return TRUE;
}

#endif // !KERNEL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\rombld\enc.cpp ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    enc.cpp

Abstract:


--*/

#include <windows.h>
#include <stdlib.h>
#include <conio.h>
#include <rsa.h>
#include <sha.h>
#include <rc4.h>
#include <xcrypt.h>
#include "rombld.h"
#include "enc.h"



void 
shaHmac(
    IN PBYTE pbKeyMaterial,
    IN ULONG cbKeyMaterial,
    IN PBYTE pbData,
    IN ULONG cbData,
    IN PBYTE pbData2,
    IN ULONG cbData2,
    OUT PBYTE HmacData // length must be A_SHA_DIGEST_LEN
    )
{
    BYTE Kipad[HMAC_K_PADSIZE];
    BYTE Kopad[HMAC_K_PADSIZE];
    BYTE HMACTmp[HMAC_K_PADSIZE+A_SHA_DIGEST_LEN];
    ULONG dwBlock;
    A_SHA_CTX shaHash;

    // truncate
    if (cbKeyMaterial > HMAC_K_PADSIZE)
        cbKeyMaterial = HMAC_K_PADSIZE;

    RtlZeroMemory(Kipad, HMAC_K_PADSIZE);
    RtlCopyMemory(Kipad, pbKeyMaterial, cbKeyMaterial);

    RtlZeroMemory(Kopad, HMAC_K_PADSIZE);
    RtlCopyMemory(Kopad, pbKeyMaterial, cbKeyMaterial);

    //
    // Kipad, Kopad are padded sMacKey. Now XOR across...
    //
    for(dwBlock=0; dwBlock<HMAC_K_PADSIZE/sizeof(DWORD); dwBlock++)
    {
        ((DWORD*)Kipad)[dwBlock] ^= 0x36363636;
        ((DWORD*)Kopad)[dwBlock] ^= 0x5C5C5C5C;
    }

    //
    // prepend Kipad to data, Hash to get H1
    //

    A_SHAInit(&shaHash);
    A_SHAUpdate(&shaHash, Kipad, HMAC_K_PADSIZE);
    if (cbData != 0)
    {
        A_SHAUpdate(&shaHash, pbData, cbData);
    }
    if (cbData2 != 0)
    {
        A_SHAUpdate(&shaHash, pbData2, cbData2);
    }

    // Finish off the hash
    A_SHAFinal(&shaHash,HMACTmp+HMAC_K_PADSIZE);

    // prepend Kopad to H1, hash to get HMAC
    RtlCopyMemory(HMACTmp, Kopad, HMAC_K_PADSIZE);

    // final hash: output value into passed-in buffer
    A_SHAInit(&shaHash);
    A_SHAUpdate(&shaHash,HMACTmp, sizeof(HMACTmp));
    A_SHAFinal(&shaHash,HmacData);
}


void 
rc4HmacEncrypt(
    IN PUCHAR confounder, // RC4_CONFOUNDER_LEN bytes
    IN PUCHAR pbKey,
    IN ULONG cbKey,
    IN PUCHAR pbInput,
    IN ULONG cbInput,
    OUT PUCHAR pbHeader // XC_SERVICE_DIGEST_SIZE + RC4_CONFOUNDER_LEN bytes
    )
{
    PRC4_SHA1_HEADER CryptHeader = (PRC4_SHA1_HEADER) pbHeader;
    BYTE LocalKey[A_SHA_DIGEST_LEN];
    RC4_KEYSTRUCT Rc4KeyStruct;

    //
    // Create the header - the confounder & checksum
    //
    RtlZeroMemory( CryptHeader->Checksum, A_SHA_DIGEST_LEN );
    RtlCopyMemory( CryptHeader->Confounder, confounder, RC4_CONFOUNDER_LEN );

    //
    // Checksum everything but the checksum
    //
    shaHmac( pbKey, cbKey,
             CryptHeader->Confounder, RC4_CONFOUNDER_LEN,
             pbInput, cbInput,
             CryptHeader->Checksum );

    //
    // HMAC the checksum into the key
    //
    shaHmac( pbKey, cbKey,
             CryptHeader->Checksum, A_SHA_DIGEST_LEN,
             NULL, 0,
             LocalKey );

    //
    // Use the generated key as the RC4 encryption key
    //
    rc4_key( &Rc4KeyStruct, A_SHA_DIGEST_LEN, LocalKey );

    //
    // Encrypt everything but the checksum
    //
    rc4( &Rc4KeyStruct, RC4_CONFOUNDER_LEN, CryptHeader->Confounder );
    rc4( &Rc4KeyStruct, cbInput, pbInput );
}


BOOL 
rc4HmacDecrypt(
    IN PUCHAR pbKey,
    IN ULONG cbKey,
    IN PUCHAR pbInput,
    IN ULONG cbInput,
    IN PUCHAR pbHeader // XC_SERVICE_DIGEST_SIZE + RC4_CONFOUNDER_LEN bytes
    )
{
    PRC4_SHA1_HEADER CryptHeader = (PRC4_SHA1_HEADER) pbHeader;
    RC4_SHA1_HEADER TempHeader;
    BYTE LocalKey[A_SHA_DIGEST_LEN];
    RC4_KEYSTRUCT Rc4KeyStruct;

    RtlCopyMemory( TempHeader.Confounder, CryptHeader->Confounder, RC4_CONFOUNDER_LEN );

    //
    // HMAC the checksum into the key
    //
    shaHmac( pbKey, cbKey,
             CryptHeader->Checksum, A_SHA_DIGEST_LEN,
             NULL, 0,
             LocalKey );

    //
    // Use the generated key as the RC4 encryption key
    //
    rc4_key( &Rc4KeyStruct, A_SHA_DIGEST_LEN, LocalKey );

    //
    // Decrypt confounder and data
    //
    rc4( &Rc4KeyStruct, RC4_CONFOUNDER_LEN, TempHeader.Confounder );
    rc4( &Rc4KeyStruct, cbInput, pbInput );

    //
    // Now verify the checksum.
    //
    shaHmac( pbKey, cbKey,
             TempHeader.Confounder, RC4_CONFOUNDER_LEN,
             pbInput, cbInput,
             TempHeader.Checksum );

    //
    // Decrypt is successful only if checksum matches
    //
    return ( RtlEqualMemory(
                 TempHeader.Checksum,
                 CryptHeader->Checksum,
                 A_SHA_DIGEST_LEN) );
}



BOOL
XcWriteEncryptedFile(
    PBYTE pMessage,
    DWORD cbMsgLen,
    LPCSTR pszFN,
    LPCSTR pszPassword,
    PBYTE pConfounder  // RC4_CONFOUNDER_LEN bytes
    )
{
    HANDLE hFile;
    DWORD dwBytes;
    BOOL bRet = FALSE;

    hFile = CreateFile(pszFN, GENERIC_WRITE, FILE_SHARE_READ, NULL, OPEN_ALWAYS, 
        FILE_ATTRIBUTE_NORMAL, NULL);
    
    if (hFile != INVALID_HANDLE_VALUE) {
        
        DWORD dwEncSize = sizeof(XC_ENCFILE_HEADER) + cbMsgLen;
        PBYTE pEncBuffer = (PBYTE)malloc(dwEncSize);
        PXC_ENCFILE_HEADER pEncHead = (PXC_ENCFILE_HEADER)pEncBuffer;

        pEncHead->Sig = XC_ENCFILE_SIG;
        pEncHead->MsgLen = cbMsgLen;

        XCCalcDigest(pMessage, cbMsgLen, pEncHead->MsgDigest);

        //
        // Copy the message data in
        //
        memcpy((pEncBuffer + sizeof(XC_ENCFILE_HEADER)), pMessage, cbMsgLen);

        //
        // Encrypt it
        //
        rc4HmacEncrypt(pConfounder, (PBYTE)pszPassword, strlen(pszPassword), 
            (pEncBuffer + sizeof(XC_ENCFILE_HEADER)), cbMsgLen, (PBYTE)&(pEncHead->CryptHeader)); 

        //
        // Write the buffer out
        //
        if (WriteFile(hFile, pEncBuffer, dwEncSize, &dwBytes, NULL)) {
            bRet = TRUE;
        } else {
            ERROR_OUT("Cannot write to key file %s", pszFN);
        }

        CloseHandle(hFile);

        //
        // Free the buffer used for encryption
        //
        free(pEncBuffer);
    
    } else {
        ERROR_OUT("Cannot create encrypted file %s", pszFN);
    }

    if (bRet) {
        TRACE_OUT(TRACE_ALWAYS, "Encrypted file %s created successfully", pszFN);
    }

    return bRet;
}



BOOL 
XcReadEncryptedFile(
    LPCSTR pszFN, 
    LPCSTR pszPassword,
    PBYTE pMsgBuf,
    DWORD cbMsgBufLen
    )
{
    HANDLE hFile = INVALID_HANDLE_VALUE;
    DWORD dwBytes;
    BOOL bRet = FALSE;
    DWORD dwEncSize;
    PBYTE pEncBuffer = FALSE;
    PXC_ENCFILE_HEADER pEncHead;
    BYTE CalcDigest[XC_DIGEST_LEN];

    hFile = CreateFile(pszFN, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    
    if (hFile == INVALID_HANDLE_VALUE) {
        ERROR_OUT("Cannot open from encrypted file %s", pszFN);
        goto CleanupAndExit;
    }

    dwEncSize = GetFileSize(hFile, NULL);
    if (dwEncSize < sizeof(XC_ENCFILE_HEADER)) {
        ERROR_OUT("Invalid encrypted file format %s", pszFN);
        goto CleanupAndExit;
    }

    pEncBuffer = (PBYTE)malloc(dwEncSize);
    pEncHead = (PXC_ENCFILE_HEADER)pEncBuffer;

    if (!ReadFile(hFile, pEncBuffer, dwEncSize, &dwBytes, NULL)) {
        ERROR_OUT("Cannot read from file %s", pszFN);
        goto CleanupAndExit;
    }

    if (pEncHead->Sig != XC_ENCFILE_SIG || pEncHead->MsgLen != (dwEncSize - sizeof(XC_ENCFILE_HEADER))) {
        ERROR_OUT("File %s is not an encrypted file", pszFN);
        goto CleanupAndExit;
    }
            
    
    if (cbMsgBufLen != pEncHead->MsgLen) {
        ERROR_OUT("Not enough space allocated to load the file");                        
        goto CleanupAndExit;
    }
    
    //
    // Decrypt it
    //
    if (rc4HmacDecrypt((PBYTE)pszPassword, strlen(pszPassword), (pEncBuffer + sizeof(XC_ENCFILE_HEADER)), 
        pEncHead->MsgLen, (PBYTE)&(pEncHead->CryptHeader))) {

        //
        // Copy the plain text message
        //
        memcpy(pMsgBuf, (pEncBuffer + sizeof(XC_ENCFILE_HEADER)), pEncHead->MsgLen);

        //
        // Calculate message digest
        //
        XCCalcDigest(pMsgBuf, cbMsgBufLen, CalcDigest);

        //
        // Compare the calculated message digest with the decrypted digest
        //
        if (memcmp(CalcDigest, pEncHead->MsgDigest, XC_DIGEST_LEN) == 0) {

            bRet = TRUE;
        
        } 
    }
    
    if (bRet == FALSE) {
        ERROR_OUT("Decryption of file %s failed--invalid password", pszFN);
    }
    


CleanupAndExit:
    if (hFile != INVALID_HANDLE_VALUE) {
        CloseHandle(hFile);        
    }

    if (pEncBuffer != NULL) {
        free(pEncBuffer);
    }

    if (bRet) {
        TRACE_OUT(TRACE_ALWAYS, "Successfully read encrypted file %s", pszFN);
    }

    return bRet;
}


BOOL 
XcGetEncryptedFileMsgLen(
    LPCSTR pszFN,
    PDWORD pdwSize
    )
{
    HANDLE hFile = INVALID_HANDLE_VALUE;
    BOOL bRet = FALSE;
    DWORD dwBytes;
    XC_ENCFILE_HEADER EncHead;

    hFile = CreateFile(pszFN, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    
    if (hFile == INVALID_HANDLE_VALUE) {
        goto CleanupAndExit;
    }

    if (!ReadFile(hFile, &EncHead, sizeof(EncHead), &dwBytes, NULL) || dwBytes != sizeof(EncHead)) {
        goto CleanupAndExit;
    }

    if (EncHead.Sig == XC_ENCFILE_SIG) {
        bRet = TRUE;
        *pdwSize = EncHead.MsgLen;
    }


CleanupAndExit:
    if (hFile != INVALID_HANDLE_VALUE) {
        CloseHandle(hFile);        
    }

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\rombld\enckey.h ===
//
// NOTE: Following keys are used unless other keys are provided from
// the commandline
//

//
// Encryption key used to encrypt the boot loader.  This key is used
// by romdec32 to decrypt the boot loader.  If the key in romdec32 portion
// of the ROM (xm2) or internal ROM (xm3) does not match this, the rom 
// decryption will fail
// 
static BYTE g_KeyToEncryptBldr[] = 
{
    0x57,0x42,0x29,0x0C,0x30,0x1E,0xD3,0x01,
    0xB3,0xE5,0x5D,0x28,0x50,0x31,0xE1,0xCE
};
 


//
// Encryption key used to encrypt the padding used to fill out the ROM
// image.  This is done just to create a random stream of data instead of
// a constant.  No one ever tries to decrypt or use this information
//
static BYTE g_KeyToEncryptPadding[] = 
{
    0x4B,0x58,0xD7,0x31,0xD2,0x4E,0xAC,0x51,
    0x84,0x16,0x7D,0xCD,0xD4,0x80,0x85,0xB6
};

//
// Encryption key used to sign the ROM hash.  This is the same as the XBE
// key.
//

static BYTE g_KeyToSignROM[] = {
    0x52,0x53,0x41,0x32,0x08,0x01,0x00,0x00,
    0x00,0x08,0x00,0x00,0xFF,0x00,0x00,0x00,
    0x01,0x00,0x01,0x00,0x9B,0x83,0xD4,0xD5,
    0xDE,0x16,0x25,0x8E,0xE5,0x15,0xF2,0x18,
    0x9D,0x19,0x1C,0xF8,0xFE,0x91,0xA5,0x83,
    0xAE,0xA5,0xA8,0x95,0x3F,0x01,0xB2,0xC9,
    0x34,0xFB,0xC7,0x51,0x2D,0xAC,0xFF,0x38,
    0xE6,0xB6,0x7B,0x08,0x4A,0xDF,0x98,0xA3,
    0xFD,0x31,0x81,0xBF,0xAA,0xD1,0x62,0x58,
    0xC0,0x6C,0x8F,0x8E,0xCD,0x96,0xCE,0x6D,
    0x03,0x44,0x59,0x93,0xCE,0xEA,0x8D,0xF4,
    0xD4,0x6F,0x6F,0x34,0x5D,0x50,0xF1,0xAE,
    0x99,0x7F,0x1D,0x92,0x15,0xF3,0x6B,0xDB,
    0xF9,0x95,0x8B,0x3F,0x54,0xAD,0x37,0xB5,
    0x4F,0x0A,0x58,0x7B,0x48,0xA2,0x9F,0x9E,
    0xA3,0x16,0xC8,0xBD,0x37,0xDA,0x9A,0x37,
    0xE6,0x3F,0x10,0x1B,0xA8,0x4F,0xA3,0x14,
    0xFA,0xBE,0x12,0xFB,0xD7,0x19,0x4C,0xED,
    0xAD,0xA2,0x95,0x8F,0x39,0x8C,0xC4,0x69,
    0x0F,0x7D,0xB8,0x84,0x0A,0x99,0x5C,0x53,
    0x2F,0xDE,0xF2,0x1B,0xC5,0x1D,0x4C,0x43,
    0x3C,0x97,0xA7,0xBA,0x8F,0xC3,0x22,0x67,
    0x39,0xC2,0x62,0x74,0x3A,0x0C,0xB5,0x57,
    0x01,0x3A,0x67,0xC6,0xDE,0x0C,0x0B,0xF6,
    0x08,0x01,0x64,0xDB,0xBD,0x81,0xE4,0xDC,
    0x09,0x2E,0xD0,0xF1,0xD0,0xD6,0x1E,0xBA,
    0x38,0x36,0xF4,0x4A,0xDD,0xCA,0x39,0xEB,
    0x76,0xCF,0x95,0xDC,0x48,0x4C,0xF2,0x43,
    0x8C,0xD9,0x44,0x26,0x7A,0x9E,0xEB,0x99,
    0xA3,0xD8,0xFB,0x30,0xA8,0x14,0x42,0x82,
    0x8D,0xB4,0x31,0xB3,0x1A,0xD5,0x2B,0xF6,
    0x32,0xBC,0x62,0xC0,0xFE,0x81,0x20,0x49,
    0xE7,0xF7,0x58,0x2F,0x2D,0xA6,0x1B,0x41,
    0x62,0xC7,0xE0,0x32,0x02,0x5D,0x82,0xEC,
    0xA3,0xE4,0x6C,0x9B,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0xCD,0xE1,0xAD,0xFB,
    0x97,0x2B,0x02,0xF8,0xC9,0xB4,0xFF,0xF7,
    0x81,0x6C,0xC1,0x91,0x11,0xB8,0x44,0x5A,
    0xF9,0x18,0x6C,0x20,0xB5,0xBC,0xA9,0x17,
    0xD7,0x21,0x76,0x50,0x65,0xA0,0xB5,0x7B,
    0x70,0x57,0x19,0x3C,0xA0,0x03,0x59,0x27,
    0x5D,0xBA,0xE1,0x66,0xEE,0xAF,0xB1,0xFE,
    0x59,0xCE,0x9A,0x80,0x96,0xA8,0x8A,0x0A,
    0x96,0x05,0x92,0x1D,0x43,0xF9,0xB5,0x10,
    0x22,0xE8,0xB7,0xFC,0x93,0x40,0x85,0x63,
    0xF9,0x96,0xEC,0x24,0xE8,0xDE,0xAC,0x65,
    0x17,0xA7,0xD7,0x6C,0xFB,0x0A,0x6E,0x0C,
    0xFA,0xCC,0xF3,0xB1,0xC9,0x13,0x6A,0xB0,
    0x99,0x10,0x1B,0x69,0x7B,0xB0,0x1E,0x36,
    0x9E,0xDD,0x67,0xD4,0xD2,0xE3,0xB1,0x11,
    0xE7,0xEB,0x8C,0x14,0x6F,0xCC,0xCE,0x71,
    0xA5,0x29,0xA2,0xCE,0x00,0x00,0x00,0x00,
    0x07,0xB3,0xF5,0x5E,0x12,0x32,0x0D,0x07,
    0x28,0x09,0x10,0xCB,0x78,0xFD,0xDA,0x92,
    0xB3,0xCB,0x54,0xBF,0x66,0x5F,0x0E,0xCB,
    0x0B,0x66,0x94,0xDA,0x03,0xCB,0xBA,0x05,
    0xA5,0xE6,0x4B,0xBD,0x28,0xC8,0x12,0xB1,
    0x6C,0x6B,0x2A,0x9D,0x86,0xE1,0x57,0xAC,
    0xC1,0x8F,0x1B,0xF7,0x26,0x39,0x3E,0x44,
    0x9E,0x53,0x12,0x25,0x88,0x0A,0x3F,0xE0,
    0xF7,0xA5,0xB8,0xCD,0xF7,0xE3,0x63,0xA8,
    0xF3,0xBD,0x78,0xFE,0x5C,0xB2,0x73,0x84,
    0xE3,0x25,0x9A,0x28,0xE2,0x35,0x55,0xC3,
    0x4B,0xD4,0x17,0x96,0xBE,0xC8,0xC6,0x26,
    0x40,0x2C,0xEC,0x2E,0x54,0x28,0x0E,0xBC,
    0x6B,0xE0,0x0F,0x58,0xB7,0xAB,0x93,0x84,
    0x78,0x47,0x53,0x06,0xD1,0x84,0xBE,0x79,
    0x35,0x13,0xA6,0x75,0x76,0xCF,0x8E,0xC0,
    0x00,0x00,0x00,0x00,0x95,0xAE,0xEA,0x78,
    0x33,0xBB,0x54,0x92,0x45,0xE4,0xA6,0xD1,
    0xFA,0x5E,0xE0,0x94,0x1E,0xAC,0xFA,0x4D,
    0x06,0x48,0xEE,0x92,0x4F,0x19,0x2A,0xD3,
    0xE6,0x45,0x75,0x4E,0x24,0x6B,0xDB,0x18,
    0xF0,0xD0,0x42,0xEA,0x8E,0x2D,0x3F,0xC8,
    0x40,0xB1,0x30,0x59,0x0B,0x3C,0x94,0x6A,
    0x91,0xD8,0x3C,0xDC,0xC5,0xE7,0x84,0xB1,
    0x1D,0x01,0x38,0x62,0x38,0x0E,0x23,0x1E,
    0xCF,0x69,0x7C,0xAD,0xC5,0xA3,0xE2,0x97,
    0x57,0x72,0x65,0x66,0xD2,0x76,0x74,0x58,
    0x1C,0x58,0x6D,0x70,0x18,0x43,0x8D,0x83,
    0x45,0x29,0x23,0xC6,0xA0,0xB8,0x06,0x96,
    0x0E,0xCA,0x2B,0x16,0xF4,0x62,0x48,0x77,
    0x0B,0x1A,0x89,0xA8,0x41,0xB8,0xD6,0xFF,
    0x3A,0x76,0x4B,0xF4,0x2D,0x52,0x96,0xF8,
    0xC6,0x69,0xA9,0x31,0x00,0x00,0x00,0x00,
    0xB3,0xC9,0x4D,0xCE,0x69,0xEF,0x44,0x70,
    0x7E,0x77,0x52,0x14,0x0E,0x71,0x52,0xED,
    0x48,0x6D,0x2C,0xFA,0x77,0x6A,0xA0,0x78,
    0xC8,0x05,0x24,0xB7,0xD3,0x00,0x2E,0x44,
    0x36,0x73,0xE1,0x87,0x1A,0x75,0x4D,0x7F,
    0x62,0xA4,0x0D,0xB2,0x6C,0xB9,0x07,0x5E,
    0xF7,0x9E,0x21,0x42,0xDD,0xC9,0xA2,0x6A,
    0x62,0x96,0xD6,0x4B,0xF2,0x25,0x87,0x75,
    0x4B,0xE4,0x21,0x5F,0x59,0xCD,0x76,0x40,
    0x6D,0x35,0xC1,0xBD,0x6A,0x12,0xED,0x12,
    0x89,0xB5,0xA8,0x58,0xF4,0x15,0x95,0x47,
    0x84,0xFA,0xF1,0xD8,0xE2,0x85,0x9C,0x52,
    0x81,0xDD,0x0B,0x64,0x48,0xF0,0xFC,0x1F,
    0x9A,0x31,0x12,0xA1,0x08,0xD8,0x0C,0xF9,
    0x64,0xAE,0x36,0x04,0x2E,0x1D,0xCE,0xBD,
    0x3F,0xFC,0xEE,0x62,0xB2,0x8B,0x4E,0x4C,
    0x00,0x00,0x00,0x00,0xA3,0x67,0xDF,0xAE,
    0xF0,0x4B,0x5F,0xF5,0x46,0xB1,0x67,0x39,
    0x24,0x29,0xD6,0xE2,0xDF,0x78,0xB1,0x05,
    0x63,0x3F,0x03,0xB0,0xEF,0x01,0x14,0xD8,
    0x42,0x69,0x4D,0x1D,0x87,0xB2,0x4C,0x3B,
    0x21,0xD6,0xA2,0xA1,0xBD,0x5E,0xCB,0xB2,
    0x97,0xBB,0x23,0xD8,0xB6,0x0B,0x68,0x94,
    0x25,0x6F,0x2B,0xFD,0xAD,0x6F,0x33,0x58,
    0xB1,0x77,0x1E,0x77,0x0D,0xF3,0xFC,0xCE,
    0x32,0x58,0x9A,0x15,0xC7,0xCE,0x29,0x5A,
    0x8A,0x0F,0x94,0xF9,0xBD,0x3C,0xAC,0x45,
    0xC3,0x6E,0x3C,0x72,0x95,0x2D,0xDD,0x16,
    0x30,0x5F,0x9D,0xD7,0x1C,0x76,0xA2,0x6C,
    0xCE,0xF0,0x7B,0x35,0xDC,0xD4,0x7E,0xEF,
    0x8E,0x01,0x53,0xE8,0x43,0xF8,0x18,0xDF,
    0xBD,0x25,0x6C,0xBC,0x5E,0x42,0x5D,0xA1,
    0x75,0xC9,0x76,0x7E,0x00,0x00,0x00,0x00,
    0xA9,0x91,0x2B,0xBF,0x27,0x08,0x55,0xC3,
    0xDE,0xC9,0x11,0xF1,0x37,0xCC,0xAA,0xC9,
    0x81,0xC8,0x1D,0xD1,0x12,0xA4,0xB0,0xD6,
    0x65,0xAB,0xBB,0x92,0xD5,0x37,0x6F,0x70,
    0x8C,0xAC,0x30,0xF7,0xA7,0x79,0x10,0xEC,
    0x46,0xA3,0x08,0x2A,0xC4,0x9A,0xD0,0x49,
    0x3A,0x77,0x23,0xF2,0x86,0xEF,0x82,0xE5,
    0xE5,0x7B,0x50,0xED,0xD5,0x43,0xA7,0x33,
    0xED,0xD7,0xA4,0x7A,0xB6,0x35,0x60,0x9D,
    0xB9,0xAD,0x93,0xB4,0xD6,0x3C,0x3D,0xCE,
    0xDF,0x43,0x00,0xC2,0xFC,0xE1,0x5A,0x98,
    0x3A,0x07,0x7B,0xCE,0xA1,0x2F,0xEE,0x01,
    0x70,0x83,0x8B,0xC1,0x3F,0xB7,0x79,0x5E,
    0x3D,0x2F,0xBD,0x9F,0x7D,0xD9,0xBE,0x66,
    0xE2,0x32,0xD4,0x92,0x3D,0xD5,0xE1,0x9F,
    0xE7,0x2F,0x22,0x52,0xCA,0xD1,0xFB,0xBC,
    0x6F,0x80,0x82,0x34,0x1D,0x13,0x07,0x39,
    0x24,0xC7,0x83,0x7D,0x61,0x9A,0x73,0x84,
    0x6B,0x30,0x79,0x10,0xE6,0x1F,0xC7,0xC1,
    0x0F,0x22,0x09,0xAA,0x15,0xB7,0x00,0x1D,
    0x6E,0x1A,0x93,0x4D,0x34,0xC7,0x1B,0x75,
    0x56,0xAF,0x48,0x14,0x6D,0x66,0x9A,0xB6,
    0x8E,0x69,0xFA,0x67,0x95,0x78,0xEC,0xE6,
    0x9E,0xAF,0x43,0xA0,0x3D,0x43,0x6F,0xD1,
    0x49,0x4F,0x35,0x6A,0x9C,0x83,0xB3,0x03,
    0x50,0x40,0x2C,0x4A,0x63,0x2B,0x15,0x43,
    0x6C,0x1E,0xDD,0x9D,0x61,0xA3,0x04,0xBB,
    0x87,0xB6,0x35,0x1A,0x32,0x48,0x0F,0x87,
    0xF3,0xE9,0x32,0x38,0x8B,0x7A,0x5F,0x74,
    0x87,0x47,0x5A,0xEE,0x65,0x5C,0xBC,0x9F,
    0xAF,0xB5,0x88,0xA6,0x77,0x5B,0xA5,0x3A,
    0xB7,0xDB,0x54,0xB4,0xF5,0x78,0x32,0x1E,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\rombld\property.cpp ===
//  PROPERTY.CPP
//
//		Text property handling
//
//	Created 15-Mar-2000 [JonT]

#include "rombld.h"

//---------------------------------------------------------------------
//  CPropertyBundle - public

//  CPropertyBundle::GetProperty
//		Returns the value for a given property.
//		Note that properties can come from different places:
//			*from command line switches: imgbld /d1 makes a property 'd' with value '1'
//			*from a configuration file
//			*from a previous call to SetProp
//		Properties are returned as constant strings.
//		NULL means property does not exist.

LPCTSTR
CPropertyBundle::Get(
	LPCTSTR lpszName
	)
{
	CProperty* pp;

	if ((pp = Find(lpszName)) == NULL)
		return NULL;
	else
		return pp->GetValue();
}


//  CPropertyBundle::SetProperty
//		Sets a value for the given property, creates the property if necessary.

void
CPropertyBundle::Set(
	LPCTSTR lpszName,
	LPCTSTR lpszValue
	)
{
	CProperty* pp;
	int nHashBucket;

	// See if we need to create it
	if ((pp = Find(lpszName)) == NULL)
	{
		// Create the new property
		pp = new CProperty;
		if (!pp)
			g_ib.Exit(-1, "Error: Out of Memory");
		pp->SetName(lpszName);
		pp->SetValue(lpszValue);

		// Create a list node to link it into
		//pnode = new CNode;
		//pnode->SetData(pp);

		// Find the hash bucket to link it into
		nHashBucket = HashNameToIndex(lpszName);

		// Link the node into the end of the bucket list
		pp->Link(&m_lhHashTable[nHashBucket], NULL);
	}

	// Already exists, so just replace the value
	else
	{
		pp->SetValue(lpszValue);
	}
}


//---------------------------------------------------------------------
//  CPropertyBundle - private

CProperty*
CPropertyBundle::Find(
	LPCTSTR lpszName
	)
{
	int nBucket;
	CNode* pnode;

	// Get the bucket number
	nBucket = HashNameToIndex(lpszName);

	// Search this bucket for the name
	for (pnode = m_lhHashTable[nBucket].GetHead() ; pnode ; pnode = pnode->Next())
		if (_stricmp(lpszName, ((CProperty*)pnode)->GetName()) == 0)
			break;

	if (pnode)
		return (CProperty*)pnode;
	else
		return NULL;
}


int
CPropertyBundle::HashNameToIndex(
	LPCTSTR lpszName
	)
{
	DWORD dwHash = 0;
	TCHAR ch;
	int i;
	int nIncr = strlen(lpszName) / 3;

	ASSERT(lpszName != NULL && *lpszName != '\0');

	for (i = 0 ; i < 3 ; i++)
	{
		// Get the next character
		if ((ch = *lpszName) == 0)
			break;
		lpszName += nIncr;

		// Compute next random number in sequence using character to modify
		dwHash =  1664525 * (dwHash ^ ch) + 1013904223;
	}

	dwHash = dwHash % TABLE_SIZE;

	return (int)dwHash;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\rombld\list.h ===
//  LIST.H
//
//		Doubly-linked lists
//
//	Created 15-Mar-2000 [JonT]


#ifndef __LIST_H__
#define __LIST_H__

// To use this very simple list package, create a CListHead object then add CNode objects to it

class CListHead;

class CNode
{
private:
	CNode* m_pNext;
	CNode* m_pPrev;

public:
	CNode() 
    { 
        m_pNext = m_pPrev = NULL;
    }
	virtual ~CNode();
	
    CNode* Next() { return m_pNext; }
	CNode* Prev() { return m_pPrev; }

    void Link(CListHead* pList, CNode* pBefore);
	void Unlink(CListHead* pList);

    virtual void Dump();
};

class CListHead
{
private:
	CNode* m_pHead;
	CNode* m_pTail;

public:
	CListHead() { m_pHead = m_pTail = NULL; }
	~CListHead();
	CNode* GetHead(void) { return m_pHead; }
	CNode* GetTail(void) { return m_pTail; }

    void Dump(LPCSTR pszTitle, int nLevel);

    DWORD Count();

friend CNode;
};


#endif // #ifndef __LIST_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\rombld\property.h ===
//  PROPERTY.H
//
//		Text property handling
//
//	Created 15-Mar-2000 [JonT]

#ifndef __PROPERTY_H__
#define __PROPERTY_H__

class CProperty;

#define TABLE_SIZE 4001		// prime number

class CPropertyBundle
{
private:
	CListHead m_lhHashTable[TABLE_SIZE];
	int HashNameToIndex(LPCTSTR lpszName);
	CProperty* Find(LPCTSTR lpszName);

public:
	LPCTSTR Get(LPCTSTR lpszName);
	void Set(LPCTSTR lpszName, LPCTSTR lpszValue);
};


// CProperty
//	Handles storage for property values. This is a private class, it's never handed back.
//	It's just used for CPropertyBundle's use.

class CProperty : public CNode
{
public:
    CProperty()
        : m_lpszName(NULL),
          m_lpszValue(NULL)
    {
    }

    ~CProperty()
    {
        if (m_lpszName != NULL)
            free(m_lpszName);
        if (m_lpszValue != NULL)
            free(m_lpszValue);
    }

    void SetName(LPCSTR pszName)
    {
        if (m_lpszName != NULL)
            free(m_lpszName);
        m_lpszName = _strdup(pszName);
    }
    LPCSTR GetName()
    {
        return m_lpszName;
    }

    void SetValue(LPCSTR pszValue)
    {
        if (m_lpszValue != NULL)
            free(m_lpszValue);
        m_lpszValue = _strdup(pszValue);
    }
    LPCSTR GetValue()
    {
        return m_lpszValue;
    }


private:
	LPTSTR m_lpszName;
	LPTSTR m_lpszValue;
};


#endif // #ifndef __PROPERTY_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\rombld\list.cpp ===
//  LIST.CPP
//
//		Doubly-linked lists
//
//	Created 15-Mar-2000 [JonT]

#include "rombld.h"

//---------------------------------------------------------------------
//  CListHead class

CListHead::~CListHead()
{
	CNode* pNode;

	// Nuke all remaining nodes in the list
	while (m_pHead)
	{
		pNode = m_pHead;
		m_pHead = m_pHead->Next();
		delete pNode;
	}
}


void
CListHead::Dump(
    LPCSTR pszTitle, 
    int nLevel                
    )
{

    if (nLevel > g_ib.m_nTraceLevel)
    {
        return;
    }

//    g_ib.m_dwDumpVar = 0;

    if (pszTitle != NULL && pszTitle[0] != '\0')
    {
        TRACE_OUT(nLevel, "\n%s:", pszTitle);
    }

    for (CNode* pNode = m_pHead; pNode != NULL; pNode = pNode->Next())
    {
        pNode->Dump();
    }
}


DWORD
CListHead::Count()
{
    DWORD dwCnt = 0;

    for (CNode* pNode = m_pHead; pNode != NULL; pNode = pNode->Next())
    {
        dwCnt++;
    }
    return dwCnt;
}


//---------------------------------------------------------------------
//  CNode class
//		Using this class is very simple: Start by doing a 'new CNode.' or a derived class
//		Once you have a new CNode, link it into a list by passing to CNode::Link
//		pointing to the list head already created and to the node to insert after.
//		Pass in NULL to link to the end of the list.
//		Don't delete a CNode before Unlink'ing it!

CNode::~CNode()
{
    // derived class should clean up in its own destructor
}


//  CNode::Link
//		Links in an element to the list before the node passed in.
//		Pass in NULL to link at end of list.

void
CNode::Link(
	CListHead* pList,
	CNode* pBefore
	)
{
    if (!pList->m_pHead)
    {
        m_pPrev = m_pNext = NULL;
        pList->m_pHead = pList->m_pTail = this;
    }
    else if (pBefore == NULL)
    {
        m_pPrev = pList->m_pTail;
        m_pNext = NULL;
        pList->m_pTail->m_pNext = this;
        pList->m_pTail = this;
    }
    else
    {
        m_pPrev = pBefore->m_pPrev;
        m_pNext = pBefore;
        if (pBefore->m_pPrev == NULL)
            pList->m_pHead = this;
        else
            pBefore->m_pPrev->m_pNext = this;
        pBefore->m_pPrev = this;
    }
}


//  CNode::Unlink
//		Removed the current element from the list. The memory is not reclaimed
//		until the node is delete'ed.

void
CNode::Unlink(
	CListHead* pList
	)
{
    // Check the previous element
    if (!m_pPrev)
        pList->m_pHead = m_pNext;
    else
        m_pPrev->m_pNext = m_pNext;

    // Check the next element
    if (!m_pNext)
        pList->m_pTail = m_pPrev;
    else
        m_pNext->m_pPrev = m_pPrev;
}


void
CNode::Dump()
{
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\rombld\rombld.h ===
#ifndef __ROMBLD_H__
#define __ROMBLD_H__

#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#include <stdarg.h>
#include <time.h>
#include "list.h"
#include "property.h"
#include "util.h"

#define ARRAYSIZE(a) (sizeof(a) / sizeof(a[0]))

#if DBG == 1
    #define DEBUG
#else
    #undef DEBUG
#endif



// Debug defines. Note that we could completely remove in retail, but since this
// is a tool, it's quite useful to be able to optionally turn on debug spew.
#define TRACE_ALWAYS    0       // Always display
#define TRACE_VERBOSE   1       // Display if verbose logging turned on
#define TRACE_DEBUG     2       // Display if debug-level logging turned on
#define TRACE_SPEW      3       // Display only if very chatty logging turned on


class CMemFile;

enum { ROMBLD_XDK, ROMBLD_XM3, ROMBLD_XM3P };


class CRomBuilder
{

public:
    CPropertyBundle m_prop;
    int             m_nTraceLevel;
    CListHead       m_Warnings;         // Warnings to be displayed at the end--list of CStrNode
    CListHead       m_MiscRomFileList;
    int             m_nRomSize;
    int             m_HackInitTable;
    int             m_nBuildFor;
    char            m_szPassword[PASSWORD_MAXSIZE];
    char            m_szRomEncKeyFN[MAX_PATH];
    char            m_szEEPROMKeyFN[MAX_PATH];
    char            m_szCERTKeyFN[MAX_PATH];
    char            m_szPubKeyFN[MAX_PATH];
    BOOL            m_UseSpecifiedKeys;

    CRomBuilder()
        : m_nTraceLevel(TRACE_VERBOSE),
          m_nRomSize(256),
          m_pszExitMsg(NULL),
          m_HackInitTable(0),
          m_UseSpecifiedKeys(FALSE)
    {
        m_szPassword[0] = '\0';
        m_szRomEncKeyFN[0] = '\0';
        m_szEEPROMKeyFN[0] = '\0';
        m_szCERTKeyFN[0] = '\0';
        m_szPubKeyFN[0] = '\0';
    }

    ~CRomBuilder()
    {
        // Global object, everything should be cleaned up by Exit()
    }

    void Initialize(int argc, char** argv);
    void ReadSwitchesFromFile(LPCSTR pszFN);
    void Exit(int nReturnCode, LPCSTR lpszFatalError);
    void SetExitMsg(HRESULT hr, LPCSTR pszExitMsg);
    void SetExitMsg(LPCSTR pszExitMsg);
    void AddWarning(LPCSTR pszFormat, ...);

    void BuildImage(BOOL External);
    void UpdateKeys(PBYTE rgbRandomHash, PBYTE rgbRandomKey,
        PBYTE rgbKernelKey, PBYTE rgbBldrEncKey, PBYTE pBldrKeyData);

    BOOL LocateDataSection(CMemFile &PEFile, LPVOID *ppvDataSectionStart,
        DWORD *pdwDataSectionSize);
    PVOID LocateExportOrdinal(CMemFile& PEFile, ULONG Ordinal);

    void PrintUsage();

    // static functions
    static void TraceOut(int nLevel, LPCSTR lpszFormat, va_list vararg); // Use TRACE_OUT inline
    static void ErrorOut(BOOL bErr, LPCSTR lpszFormat, va_list vararg);  // use ERROR_OUT or WARNING_OUT inlines


private:
    void ParseSwitch(LPCTSTR pszArg);

    LPSTR m_pszExitMsg;
};



// Global class
extern CRomBuilder g_ib;

#define BLOCK

inline void TRACE_OUT(int nLevel, LPCSTR lpszFormat, ...)
{
    va_list vararg;
    va_start(vararg, lpszFormat);
    CRomBuilder::TraceOut(nLevel, lpszFormat, vararg);
    va_end(vararg);
}


inline void ERROR_OUT(LPCSTR lpszFormat, ...)
{
    va_list vararg;
    va_start(vararg, lpszFormat);
    CRomBuilder::ErrorOut(TRUE, lpszFormat, vararg);
    va_end(vararg);
}


inline void WARNING_OUT(LPCSTR lpszFormat, ...)
{
    va_list vararg;
    va_start(vararg, lpszFormat);
    CRomBuilder::ErrorOut(FALSE, lpszFormat, vararg);
    va_end(vararg);
}


inline void DEBUG_STOP_FORMAT(LPCSTR lpszFormat, ...)
{
    va_list vararg;
    va_start(vararg, lpszFormat);
    TRACE_OUT(TRACE_VERBOSE, TEXT("DebugStop:"));
    CRomBuilder::TraceOut(TRACE_ALWAYS, lpszFormat, vararg);
    va_end(vararg);
}

#ifdef DEBUG
#ifdef _M_IX86
#define DEBUG_STOP_HERE { __asm int 3 }
#else
#define DEBUG_STOP_HERE { DebugBreak(); }
#endif
#else
#define DEBUG_STOP_HERE
#endif
    
#define DEBUG_STOP(x)   \
{                       \
    TRACE_OUT(TRACE_VERBOSE, TEXT("DebugStop in %s at line %d (message follows):"), TEXT(__FILE__), __LINE__); \
    TRACE_OUT(TRACE_ALWAYS, x); \
    DEBUG_STOP_HERE \
}

#define ASSERT(x)   \
    (void)((x) || (TRACE_OUT(TRACE_VERBOSE, TEXT("Assert: failed [%s] in %s(%d)"), #x, \
        TEXT(__FILE__), __LINE__),0))


#endif // #ifndef __ROMBLD_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\rombld\util.cpp ===
/*++

Copyright (c) 1989-2000  Microsoft Corporation

Module Name:

    util.cpp

Abstract:

    Contains utility classes and routines

--*/

#include "rombld.h"
#include "util.h"
#include "conio.h"
#include <rsa.h>
#include <sha.h>
#include <xcrypt.h>
#include "enc.h"


extern "C" {
#include <lci.h>
}

#include <bldr.h>



HRESULT 
TempFileName(LPSTR szFN)
{
    char szTempPath[MAX_PATH];

    if (GetTempPath(sizeof(szTempPath), szTempPath) != 0)
    {
        if (GetTempFileName(szTempPath, "ROM", 0, szFN) != 0)
        {
            return S_OK;
        }
    }
    return HRESULT_FROM_WIN32(GetLastError());
    
}



HRESULT 
CMemFile::Open(
    IN LPCSTR pszFN,
    IN BOOL CopyOnWrite
    )
/*++

Routine Description:

    Opens a file by creating a file mapping

Arguments:

    pszFN - supplies the file name to open

Return Value:

    HRESULT

--*/
{
    HRESULT hr = NOERROR;

    m_hFile = CreateFile(pszFN, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);
    if (m_hFile == INVALID_HANDLE_VALUE)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        return hr;
    }

    m_hFileMapping = CreateFileMapping(m_hFile, NULL, CopyOnWrite ? PAGE_WRITECOPY : PAGE_READONLY, 0, 0, NULL);
    if (m_hFileMapping == NULL)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());

        CloseHandle(m_hFile);
        m_hFile = INVALID_HANDLE_VALUE;

        return hr;
    }

    m_pBase = MapViewOfFile(m_hFileMapping, CopyOnWrite ? FILE_MAP_COPY : FILE_MAP_READ, 0, 0, 0);
    if (m_pBase == NULL)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());

        CloseHandle(m_hFileMapping);
        m_hFileMapping = NULL;

        CloseHandle(m_hFile);
        m_hFile = INVALID_HANDLE_VALUE;

        return hr;
    }

    m_pHeader = (PIMAGE_NT_HEADERS)PtrFromBase(((PIMAGE_DOS_HEADER)m_pBase)->e_lfanew);

    return hr;
}


void
CMemFile::Close()
/*++

Routine Description:

    Closes the file

Arguments:

Return Value:

    None

--*/
{
    if (m_pWriteCopy != NULL)
    {
        free(m_pWriteCopy);
        m_pWriteCopy = NULL;
    }
    else
    {
        if (m_pBase != NULL)
        {
            UnmapViewOfFile(m_pBase);
            m_pBase = NULL;
        }
    }

    if (m_hFileMapping != NULL)
    {
        CloseHandle(m_hFileMapping);
        m_hFileMapping = NULL;
    }

    if (m_hFile != INVALID_HANDLE_VALUE)
    {
        CloseHandle(m_hFile);
        m_hFile = INVALID_HANDLE_VALUE;
    }
}



HRESULT 
CMemFile::MakeWriteCopy()
{
    if (m_hFileMapping == NULL || m_hFile == INVALID_HANDLE_VALUE)
        return E_FAIL;

    m_dwSize = GetFileSize(m_hFile, NULL);

    m_pWriteCopy = malloc(m_dwSize);

    if (NULL == m_pWriteCopy)
    {
        return E_OUTOFMEMORY;
    }
    
    memcpy(m_pWriteCopy, m_pBase, m_dwSize);

    UnmapViewOfFile(m_pBase);
    m_pBase = m_pWriteCopy;
    m_pHeader = (PIMAGE_NT_HEADERS)PtrFromBase(((PIMAGE_DOS_HEADER)m_pBase)->e_lfanew);

    CloseHandle(m_hFileMapping);
    m_hFileMapping = NULL;

    CloseHandle(m_hFile);
    m_hFile = INVALID_HANDLE_VALUE;

    return NOERROR;
}


DWORD
CMemFile::Size()
{
    if (m_hFileMapping == NULL || m_hFile == INVALID_HANDLE_VALUE)
        return m_dwSize;

    return GetFileSize(m_hFile, NULL);
}



int
_cdecl
CMDTABLE::Compare(
    const void* p1, 
    const void* p2
    )
{
    char** pkey = (char**)p1;
    CMDTABLE* ptab = (CMDTABLE*)p2;

    return _strnicmp(*pkey, ptab->lpCmdLine, strlen(ptab->lpCmdLine));
}



 
void
CStrNode::Dump()
{
    TRACE_OUT(TRACE_ALWAYS, m_pszValue);
}




LPCSTR 
strcpystr(
    IN  LPCSTR pszStr, 
    IN  LPCSTR pszSep, 
    OUT LPSTR pszTokOut)
/*++

Routine Description:

    Called multiple times to parse out tokens from a string

Arguments:

    pszStr - Supplies the string to parse out.  This can be return value
             of this function for subsequent calls.

    pszSep - Supplies a string that is the separator between tokens

    pszTokOut - Returns the token.  The caller must allocate enough space for the token

Return Value:

    Returns a pointer to the next token or NULL

--*/
{
    
    if (pszStr == NULL || *pszStr == '\0')
    {
        pszTokOut[0] = '\0';
        return NULL;
    }

    LPCSTR p = strstr(pszStr, pszSep);
    if (p != NULL)
    {
        strncpy(pszTokOut, pszStr, p - pszStr);
        pszTokOut[p - pszStr] = '\0';       
        return p + strlen(pszSep);
    }
    else
    {
        strcpy(pszTokOut, pszStr);
        return NULL;
    }
}


LPSTR
strncpyz(
    OUT LPSTR pszDest, 
    IN  LPCSTR pszSource, 
    IN  size_t count
    )
/*++

Routine Description:

    Copies characters from source to destination similar to strncpy but ensures that a NULL 
    character is always copied even if the source length is greater or equal to the count

Arguments:

    pszDest - Supplies the destination string
    
    pszSource - Supplies the source string

    count - Supplies the number of characters to be copied (size of buffer)

Return Value:

    Pointer to the destination string

--*/
{
    strncpy(pszDest, pszSource, count);
    pszDest[count - 1] = 0;              

    return pszDest;
}



static
MI_MEMORY 
DIAMONDAPI LzxAlloc(
    ULONG amount
    )
{
    return(malloc((int) amount));
}


static
void DIAMONDAPI LzxFree(
    MI_MEMORY pointer
    )
{
    free(pointer);
}


static HANDLE s_hWriteFile = INVALID_HANDLE_VALUE;


static
int
DIAMONDAPI
CompressCallback(
    void* ,
    unsigned char* compressed_data,
    long compressed_size,
    long uncompressed_size
    )
{
    ULONG BytesWritten;
    LZXBOX_BLOCK Block;

    TRACE_OUT(TRACE_SPEW, "Writing compressed data: was=%d is=%d", uncompressed_size, compressed_size);


    //
    // write block header
    //
    Block.CompressedSize = (USHORT)compressed_size;
    Block.UncompressedSize = (USHORT)uncompressed_size;

    if (!WriteFile(s_hWriteFile, &Block, sizeof(Block), &BytesWritten, NULL)) {
        ERROR_OUT("Cannot write size to file");
        return -1;
    }

    //
    // write compressed data
    //
    if (!WriteFile(s_hWriteFile, compressed_data, compressed_size, &BytesWritten, NULL)) {
        ERROR_OUT("Cannot write data to file");
        return -1;
    }

    return 0;
}


BOOL CompressFile(
    CMemFile &SourceFile,
    LPCSTR pszCompressName
    )
{
    BOOL bRet = FALSE;
    UINT SourceSize = LZX_CHUNK_SIZE;
    LCI_CONTEXT_HANDLE Handle = NULL;
    PVOID Source = NULL;
    LZXCONFIGURATION cfg;
    UINT DestSize;
    ULONG BytesRead;
    ULONG BytesCompressed;
    int LCIRet;
    ULONG BytesRemaining;
    LPBYTE FilePointer;

    //
    // initialize the compression engine
    //
    cfg.WindowSize = LZX_WINDOW_SIZE;
    cfg.SecondPartitionSize = 65536;

    LCIRet = LCICreateCompression(&SourceSize, &cfg, LzxAlloc, LzxFree, &DestSize, &Handle,
        CompressCallback, NULL);
    if (LCIRet != MCI_ERROR_NO_ERROR)
    {
        ERROR_OUT("Cannot create compression %d", LCIRet);
        Handle = NULL;
        goto Cleanup;
    }

    Source = LzxAlloc(SourceSize);

    //
    // open files
    //
    s_hWriteFile = CreateFile(pszCompressName, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
    if (s_hWriteFile == INVALID_HANDLE_VALUE) {
        ERROR_OUT("Cannot open %s for writing", pszCompressName);
        goto Cleanup;
    }

    //
    // perform the compression
    //
    BytesRemaining = SourceFile.Size();
    FilePointer = (LPBYTE)SourceFile.Ptr();
    (void)LCIFlushCompressorOutput(Handle);
    while (BytesRemaining > 0) {

        BytesRead = (BytesRemaining > SourceSize) ? SourceSize : BytesRemaining;

        CopyMemory(Source, FilePointer, BytesRead);

        BytesRemaining -= BytesRead;
        FilePointer += BytesRead;

        LCIRet = LCICompress(Handle, Source, BytesRead, NULL, DestSize, &BytesCompressed);
        if (LCIRet != MCI_ERROR_NO_ERROR)
        {
            ERROR_OUT("Compression failed %d", LCIRet);
            goto Cleanup;
        }

    }
    (void)LCIFlushCompressorOutput(Handle);

    bRet = TRUE;
    // fall through

Cleanup:

    if (Handle != NULL)
    {
        (void)LCIDestroyCompression(Handle);
    }

    if (s_hWriteFile != INVALID_HANDLE_VALUE)
    {
        CloseHandle(s_hWriteFile);
        s_hWriteFile = INVALID_HANDLE_VALUE;
    }

    if (Source != NULL)
    {
        LzxFree(Source);
    }
    
    return bRet;
}


BOOL
ReadPassword(
    LPCSTR pszPrompt, 
    LPSTR pszPassword
    )
{
    int c;
    int n = 0;

    printf(pszPrompt);

    for (;;)
    {
         c = _getch();

         //
         // ^C
         //
         if (c == 0x3)
         {
             putchar('\n');
             ExitProcess(0);
         }

         //
         // Backspace
         //
         if (c == 0x8)
         {
             if (n)
             {
                n--;
                _putch(0x8);
                _putch(' ');
                _putch(0x8);
             }
             continue;
         }

         //
         // Return
         //
         if (c == '\r')
             break;

         if ((n + 1) < PASSWORD_MAXSIZE) 
         {
             pszPassword[n++] = (char)c;
             _putch('*');
         }
    }

    pszPassword[n] = 0;
    putchar('\n');

    if (strlen(pszPassword) < PASSWORD_MINLEN) 
    {
        ERROR_OUT("Password must at least be %d characters", PASSWORD_MINLEN);
        pszPassword[0] = 0;
        return FALSE;        
    }

    return TRUE;
} 


BOOL 
ReadKeyFromEncFile(
    LPCSTR pszFN, 
    LPCSTR pszPassword,
    PBYTE  pKeyBuffer,
    DWORD  cbKeyBuffer,
    BOOL   SymKey
    )
{
    BOOL bRet = FALSE;
    DWORD MsgLen;
    PBYTE pKeyData;
    PXBOX_KEYFILE_HEADER pKeyHeader;

    if (XcGetEncryptedFileMsgLen(pszFN, &MsgLen)) {

        //
        // Allocate memory for the plain text message
        //
        pKeyData = (PBYTE)malloc(MsgLen);


        //
        // Read the message from encrypted file
        //

        if (XcReadEncryptedFile(pszFN, pszPassword, pKeyData, MsgLen) == TRUE) {
        
            pKeyHeader = (PXBOX_KEYFILE_HEADER)pKeyData;
    
            if (SymKey) 
            {
                //
                // We are interested in Symmetric keys
                //
    
                if (pKeyHeader->KeyType != KEYFILE_SYM) 
                {
                    ERROR_OUT("Key file does not have a symmetric key");
                }
                else if ((DWORD)(pKeyHeader->KeyBits / 8) > cbKeyBuffer) 
                {
                    ERROR_OUT("Symmetric Key is too large for ROMBLD");
                }
                else
                {
                    //
                    // Copy the symmetric key out of the XCK file
                    //
                    memcpy(pKeyBuffer, 
                           pKeyData + sizeof(XBOX_KEYFILE_HEADER) + sizeof(BSAFE_PUB_KEY),
                           pKeyHeader->KeyBits / 8);

                    bRet = TRUE;
                }
            }
            else
            {     
                //
                // We are interested in public key portion of pub/prv key
                //
                if (pKeyHeader->KeyType != KEYFILE_PUBPAIR && pKeyHeader->KeyType != KEYFILE_PUBONLY) 
                {
                    ERROR_OUT("Key file does not have a public key");
                }
                else if ((DWORD)(pKeyHeader->PublicKeyBytes) > cbKeyBuffer) 
                {
                    ERROR_OUT("Public Key is too large for ROMBLD");
                }
                else
                {
                    //
                    // Copy the public key out of the XCK file
                    //
                    memcpy(pKeyBuffer, 
                           pKeyData + sizeof(XBOX_KEYFILE_HEADER),
                           pKeyHeader->PublicKeyBytes);
    
                    bRet = TRUE;
                }
    
            }

        }

        free(pKeyData);
    }
    else {
        ERROR_OUT("File %s is not an encrypted file", pszFN);
    }


    return bRet;
}


BOOL 
IsEncKeyFile(
    LPCSTR pszFN
    )
{
    DWORD MsgLen;

    return XcGetEncryptedFileMsgLen(pszFN, &MsgLen);
}


VOID
BuildFilename(
    LPSTR pszFullFN,
    LPCSTR pszPath,
    LPCSTR pszFN
    )
{
    int len;

    strcpy(pszFullFN, pszPath);
    
    len = strlen(pszFullFN);
    if (pszFullFN[len - 1] != '\\') 
    {
        pszFullFN[len] = '\\';
        pszFullFN[len + 1] = '\0';
    }
    strcat(pszFullFN, pszFN);
}


VOID
DumpBytes(
    LPCSTR pszLabel, 
    PBYTE pbData, 
    DWORD dwDataLen
    )
{
    DWORD i;

    printf("    %s (%d bytes):\n", pszLabel, dwDataLen);
    printf("    {\n");

    for (i = 0; i < dwDataLen; i++) {
        if (i % 8 == 0) {
           printf("           ");
        }

        printf("0x%02X", pbData[i]);

        if ((i + 1) != dwDataLen)
            printf(",");
        if ((i + 1) % 8 == 0)
            printf("\n");
    }
    printf("\n    }\n\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\rombld\rombld.cpp ===
/*++

Copyright (c) 1989-2001  Microsoft Corporation

Module Name:

    rombld.cpp

Abstract:


--*/


#include <string.h>
#include "rombld.h"
#include "util.h"
#include <bldr.h>
#include <xcrypt.h>
#include <sha.h>
#include <conio.h>

#include "enckey.h"

void RomHash(PBYTE pbStart, PBYTE pbEnd, PBYTE pbHash);

//
// Main object for tracking global state
//
CRomBuilder g_ib;

//
// Property names
//
#define PROP_HELP            TEXT("Help")
#define PROP_CONFIG          TEXT("Config")
#define PROP_OUTPUT          TEXT("Output")
#define PROP_OUTPUTEXT       TEXT("OutputExt")
#define PROP_BOOTLDR         TEXT("Bldr")
#define PROP_KERNEL          TEXT("Kernel")
#define PROP_INITTBL         TEXT("InitTbl")
#define PROP_ROMDEC          TEXT("RomDec")
#define PROP_ENCROM          TEXT("EncRomDec")
#define PROP_PRELDR          TEXT("PreLdr")
#define PROP_KEYPATH         TEXT("KeyPath")
#define PROP_SYS             TEXT("Sys")

//
// Command table. NOTE: Must be sorted by lpCmdLine
//
CMDTABLE CmdTable[] =
{
    {"?",            PROP_HELP,         CMDTABLE::VAR_NONE,       NULL},
    {"BLDR:",        PROP_BOOTLDR,      CMDTABLE::VAR_NONE,       NULL},
    {"CONFIG:",      PROP_CONFIG,       CMDTABLE::VAR_NONE,       NULL},
    {"ENCROM:",      PROP_ENCROM,       CMDTABLE::VAR_NONE,       NULL},
    {"HACKINITTBL:", "",                CMDTABLE::VAR_INT,        &g_ib.m_HackInitTable},
    {"INITTBL:",     PROP_INITTBL,      CMDTABLE::VAR_NONE,       NULL},
    {"KERNEL:",      PROP_KERNEL,       CMDTABLE::VAR_NONE,       NULL},
    {"KEYPATH:",     PROP_KEYPATH,      CMDTABLE::VAR_NONE,       NULL},
    {"OUT:",         PROP_OUTPUT,       CMDTABLE::VAR_NONE,       NULL},
    {"OUTEXT:",      PROP_OUTPUTEXT,    CMDTABLE::VAR_NONE,       NULL},
    {"PRELDR:",      PROP_PRELDR,       CMDTABLE::VAR_NONE,       NULL},
    {"ROMDEC:",      PROP_ROMDEC,       CMDTABLE::VAR_NONE,       NULL},
    {"SIZEK:",       "",                CMDTABLE::VAR_INT,        &g_ib.m_nRomSize},
    {"SYS:",         PROP_SYS,          CMDTABLE::VAR_NONE,       NULL},
    {"V:",           "",                CMDTABLE::VAR_INT,        &g_ib.m_nTraceLevel}
};


#define ROM_VERSION_OFFSET          30 // In DWORDs (0x78 is the absolute offset)
#define ROM_VERSION_BYTE_OFFSET     0x78
#define ROM_VERSION_KDDELAY_FLAG    0x80000000


//
// Interim public key
//
UCHAR g_PublicKeyData[XC_PUBLIC_KEYDATA_SIZE] = {
    0x52,0x53,0x41,0x31,0x08,0x01,0x00,0x00,
    0x00,0x08,0x00,0x00,0xFF,0x00,0x00,0x00,
    0x01,0x00,0x01,0x00,0xE5,0xEC,0x86,0x9B,
    0x50,0x89,0x3B,0xB3,0xEB,0x41,0x30,0x8A,
    0x13,0x6E,0xAD,0xE9,0x7D,0xCA,0x9B,0xB4,
    0xF1,0x89,0x58,0xCE,0xAE,0xE1,0x9A,0x66,
    0xE9,0x1C,0x3C,0x04,0x39,0x2E,0xF7,0xA1,
    0x13,0xE8,0xFB,0x66,0x1C,0x59,0xC1,0xCE,
    0x18,0x7C,0x71,0xB8,0x5D,0x25,0xBB,0x5F,
    0x21,0x30,0x59,0xF7,0xDC,0x3B,0x24,0x13,
    0x42,0x69,0x30,0xF6,0x88,0x3D,0x99,0x89,
    0xCC,0xEB,0xFB,0x16,0x7C,0x78,0xEB,0x05,
    0x6B,0x41,0x8F,0xE0,0xB3,0x55,0x5F,0xEB,
    0x74,0xCA,0xB4,0x31,0x04,0xA2,0xB2,0x5A,
    0xF0,0x03,0x8E,0xDC,0x27,0x1A,0x61,0xF8,
    0x90,0x45,0xFE,0x20,0xD4,0x29,0x1C,0x58,
    0xAF,0xE9,0xFD,0x77,0x37,0x90,0xEC,0xBD,
    0x19,0xD0,0x8F,0x06,0x56,0x3C,0x95,0xC8,
    0xA0,0xA9,0x5A,0x07,0x62,0x4E,0xE8,0x35,
    0xCB,0xCF,0xA5,0xAE,0x27,0x94,0xE5,0x1C,
    0x4F,0xA6,0x18,0x5E,0xD3,0x5C,0xE9,0x06,
    0x24,0x93,0x57,0x38,0x91,0xC7,0x98,0x17,
    0x81,0x3B,0xD3,0x39,0xC7,0xD6,0xEC,0x6D,
    0xFC,0xB1,0xE1,0x52,0xAB,0x82,0x90,0x40,
    0x7B,0xC9,0x1D,0xD4,0x45,0x87,0xAC,0x94,
    0xD6,0x9D,0xB1,0x40,0xB3,0x19,0xE5,0xAD,
    0x18,0xF2,0xB8,0x9C,0xB0,0x54,0xE5,0x07,
    0x4C,0x74,0x4C,0xBD,0x9F,0xCC,0xDF,0xEC,
    0x7C,0xFF,0xAD,0x19,0x2A,0x44,0x03,0xD4,
    0xAA,0xA2,0x79,0x23,0xF9,0x1A,0xDD,0x46,
    0x05,0xF1,0x11,0xB0,0x89,0xC0,0xEB,0xBC,
    0xD7,0x3D,0x94,0xFC,0x04,0x9E,0x67,0x01,
    0x4C,0x10,0x00,0x70,0x2A,0x3F,0x5A,0xD0,
    0x68,0xCF,0xC7,0x59,0xA9,0x01,0x7B,0x07,
    0x34,0x26,0x54,0xA6,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00
};



//
// CRomBuilder class
//

void
CRomBuilder::PrintUsage()
{
        fprintf(stderr,
        "Usage: rombld [switches] [cfgfile]\n\n"
        "  /OUT:outfile\t\tOutput ROM image file (Required)\n"
        "  /OUTEXT:outfile2\tAlso output external ROM image file\n"
        "  /BLDR:file\t\t16-bit boot loader file (Required)\n"
        "  /PRELDR:file\t\tboot preloader file (Required)\n"
        "  /KERNEL:file\t\tNtoskrnl file (Required)\n"
        "  /INITTBL:file\t\tInittbl file (Required)\n"
        "  /SYS:{XDK|XM3|XM3P}\tType of system (Required)\n"
        "  /ROMDEC:file\t\tRomdec file (Required)\n"
        "  /ENCROM:file\t\tEncrypted romdec file (Required for XM3P)\n"
        "  /KEYPATH:dir\t\tPath to keys\n"
        "  /HACKINITTBL:{0|1}\tAllow manually editing init table\n"
        "  /SIZEK:size\t\tTotal ROM size (default=256)\n"
        "  /CONFIG:cfgfile\tConfiguration file (read switches from file)\n"
        "  /V:{0|1|2|3}\t\tVerbose level (0=quiet, default=1)\n"
        "  /?\t\t\tDisplay this message\n"
        "\n");
}



void
CRomBuilder::Initialize(
    int argc,
    char** argv
    )
{
    printf("Microsoft (R) ROMBLD - MICROSOFT CONFIDENTIAL\n"
        "Copyright (C) Microsoft Corporation 2000-2001. All rights reserved.\n\n");

    //
    // Read switches from command line
    //
    for (int i = 1 ; i < argc ; i++)
    {
        if (*argv[i] == '-' || *argv[i] == '/')
        {
           ParseSwitch(argv[i]);
        }
        else
        {
            //
            // not a switch. See if we already have an exe file. If we do, this is an error
            //
            if (g_ib.m_prop.Get(PROP_CONFIG))
            {
                    g_ib.PrintUsage();
                    g_ib.Exit(-1, "Only one config file can be specified at a time");
            }
            g_ib.m_prop.Set(PROP_CONFIG, argv[i]);

        }
    }

    //
    // If a config file is specified, read switches from it
    //
    if (g_ib.m_prop.Get(PROP_CONFIG))
    {
        ReadSwitchesFromFile(g_ib.m_prop.Get(PROP_CONFIG));
    }

}


void
CRomBuilder::ParseSwitch(
    LPCTSTR pszArg
    )
{
    LPCTSTR lpKey;
    CMDTABLE* lpCommand;


    // Search for the command in the command table, bail if we don't find it
    lpKey = pszArg + 1;
    lpCommand = (CMDTABLE*)bsearch((char*)&lpKey, (char*)&CmdTable[0],
        ARRAYSIZE(CmdTable), sizeof (CMDTABLE),
        CMDTABLE::Compare);
    if (!lpCommand)
    {
        g_ib.PrintUsage();
        ERROR_OUT("Invalid switch '%s'", lpKey);
        g_ib.Exit(-1, NULL);
    }

    // Note that the CRT handles quoted (")
    // command line arguments and puts them in argv correctly and strips the quotes
    lpKey = pszArg + strlen(lpCommand->lpCmdLine) + 1;

    //
    // If a property name is specified, add the command and value as a property.
    //
    if (lpCommand->lpPropName[0] != '\0')
    {
        g_ib.m_prop.Set(lpCommand->lpPropName, lpKey);
    }

    // 
    // If there's a variable, set it
    //
    if (lpCommand->lpVar && lpCommand->vartype != CMDTABLE::VAR_NONE)
    {
        switch (lpCommand->vartype)
        {
            case CMDTABLE::VAR_STRING:
                *(char**)lpCommand->lpVar = (char*)lpKey;
                break;

            case CMDTABLE::VAR_INT:
                *(int*)lpCommand->lpVar = atoi(lpKey);
                break;

            case CMDTABLE::VAR_STRINGLIST:
                {
                    CStrNode* pStrNode;

                    pStrNode = new CStrNode;
                    pStrNode->SetValue(lpKey);

                    // 
                    // Add it to the list
                    //
                    pStrNode->Link((CListHead*)(lpCommand->lpVar), NULL);
                }
                break;
        } 
    }
}



void
CRomBuilder::ReadSwitchesFromFile(
    LPCSTR pszFN
    )
{
    FILE* f;
    char szLine[255];
    int ret;

    f = fopen(pszFN, "r");
    if (f != NULL)
    {
        while (!feof(f))
                {
            ret = fscanf(f, "%s", szLine);
            if (ret == 0 || ret == EOF)
                break;

                    if (szLine[0] == '-' || szLine[0] == '/')
                    {
                ParseSwitch(szLine);
                    }
            else
            {
                g_ib.Exit(-1, "Invalid entry in config file");
            }
        }
        fclose(f);
    }
    else
    {
        g_ib.Exit(-1, "Could not open config file");
    }

}



void
CRomBuilder::Exit(
    int nReturnCode,
    LPCSTR lpszFatalError
    )
{
    //
    // Spew the final messages if any
    //

    TRACE_OUT(TRACE_ALWAYS, "");

    for (CNode* pNode = m_Warnings.GetHead(); pNode != NULL; pNode = pNode->Next())
    {
        CStrNode* pStr = (CStrNode*)pNode;

        WARNING_OUT(pStr->GetValue());
    }

    if (lpszFatalError)
    {
        ERROR_OUT(lpszFatalError);
    }
        if (m_pszExitMsg)
    {
        ERROR_OUT(m_pszExitMsg);

        // 
        // If exit msg was specified, force return code to be -1
        //
        nReturnCode = -1;
    }


    if (nReturnCode == -1)
    {
        //
        // We had a fatal error, delete the out files because it is invalid
        //
        if (m_prop.Get(PROP_OUTPUT) != NULL)
        {
            DeleteFile(m_prop.Get(PROP_OUTPUT));
        }
        if (m_prop.Get(PROP_OUTPUTEXT) != NULL)
        {
            DeleteFile(m_prop.Get(PROP_OUTPUTEXT));
        }
    }


    exit(nReturnCode);
}


void
CRomBuilder::SetExitMsg(
    HRESULT hr,
    LPCSTR pszExitMsg
    )
{
    LPSTR pszMsg;
    char szMsg[512];
    const char szNULL[] = "NULL";
    int l;

    if (pszExitMsg == NULL)
    {
        pszExitMsg = szNULL;
    }

    if (hr == E_UNEXPECTED)
    {
        sprintf(szMsg, "%s (Unexpected error occurred)", pszExitMsg);
    }
    else
    {
        if (FormatMessage(
                FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
                NULL,
                hr,
                MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                (LPSTR)&pszMsg,
                0,
                NULL) != 0)
        {
            sprintf(szMsg, "%s (%s", pszExitMsg, pszMsg);

            LocalFree(pszMsg);

            // strip the end of line characters
            l = strlen(szMsg);
            if (l >= 2 && szMsg[l - 2] == '\r')
            {
                        szMsg[l - 2] = '\0';
            }

            strcat(szMsg, ")");
        }
        else
        {
            sprintf(szMsg, "%s", pszExitMsg);
        }
    }

    SetExitMsg(szMsg);
}


void
CRomBuilder::SetExitMsg(
    LPCSTR pszMsg
    )
{
    m_pszExitMsg = _strdup(pszMsg);
}



void
CRomBuilder::TraceOut(
    int nLevel,
    LPCSTR lpszFormat,
    va_list vararg
    )
{
    char szOutput[4096];

    if (nLevel > g_ib.m_nTraceLevel)
        return;

    vsprintf((char*)szOutput, (char*)lpszFormat, vararg);

    printf(TEXT("%s\n"), szOutput);
}


void
CRomBuilder::ErrorOut(
    BOOL bErr,
        LPCSTR lpszFormat,
        va_list vararg
        )
{
        char szOutput[4096];

        vsprintf((char*)szOutput, (char*)lpszFormat, vararg);

    if (bErr)
    {
        fprintf(stderr, "ROMBLD : Error : %s\n", szOutput);
    }
    else
    {
        fprintf(stderr, "ROMBLD : Warning : %s\n", szOutput);
    }
}


void
CRomBuilder::AddWarning(
    LPCSTR pszFormat, ...
    )
{
    CStrNode* pStrNode;
        char szBuf[512];
        va_list ArgList;

        va_start(ArgList, pszFormat);
        wvsprintf(szBuf, pszFormat, ArgList);
        va_end(ArgList);

    pStrNode = new CStrNode;
    pStrNode->SetValue(szBuf);

    // add it to the list
    pStrNode->Link(&m_Warnings, NULL);

}


BOOL
CRomBuilder::LocateDataSection(
    CMemFile &PEFile,
    LPVOID *ppvDataSectionStart,
    DWORD *pdwDataSectionSize
    )
{
    LPVOID ImageBase;
    PIMAGE_NT_HEADERS NtHeader;
    ULONG SectionIndex;
    PIMAGE_SECTION_HEADER SectionHeader;
    LPBYTE pbDataSectionStart;
    DWORD dwDataSectionSize;
    DWORD dwUninitializedDataSectionSize;
    PXDATA_SECTION_HEADER DataSectionHeader;

    ImageBase = PEFile.Ptr();
    NtHeader = PEFile.NtHeaders();

    for (SectionIndex = 0; SectionIndex < NtHeader->FileHeader.NumberOfSections;
        SectionIndex++) {

        SectionHeader = IMAGE_FIRST_SECTION(NtHeader) + SectionIndex;

        if (((*(PULONG)SectionHeader->Name) == 'tad.') &&
            (SectionHeader->SizeOfRawData >= SectionHeader->Misc.VirtualSize)) {

            pbDataSectionStart = (LPBYTE)ImageBase + SectionHeader->PointerToRawData;
            dwDataSectionSize = SectionHeader->Misc.VirtualSize;

            //
            // The linker ends up merging .bss at the end of the .data section.
            // The ROM doesn't need to hold this zero space, so figure out the
            // last non-zero byte in the section.
            //
            // If we end up taking more bytes than were actually in the original
            // .bss, then great, the .data section had some initialized zero
            // bytes that we were able to strip out.
            //

            while (dwDataSectionSize > 0) {
                if (pbDataSectionStart[dwDataSectionSize - 1] != 0) {
                    break;
                }
                dwDataSectionSize--;
            }

            //
            // Round up to a DWORD boundary.
            //

            dwDataSectionSize = (dwDataSectionSize + sizeof(DWORD) - 1) & (~(sizeof(DWORD) - 1));

            dwUninitializedDataSectionSize = SectionHeader->Misc.VirtualSize - dwDataSectionSize;
            dwUninitializedDataSectionSize = (dwUninitializedDataSectionSize + sizeof(DWORD) - 1) & (~(sizeof(DWORD) - 1));

            //
            // We've got 10 reserved WORDs in the old DOS header that we'll take
            // over to pass the relative offset to the .data section, its size,
            // and the size of the .data section.
            //

            DataSectionHeader = (PXDATA_SECTION_HEADER)&((PIMAGE_DOS_HEADER)ImageBase)->e_res2;
            DataSectionHeader->SizeOfInitializedData = dwDataSectionSize;
            DataSectionHeader->SizeOfUninitializedData = dwUninitializedDataSectionSize;
            DataSectionHeader->PointerToRawData = 0 - ROM_DEC_SIZE - BLDR_BLOCK_SIZE - dwDataSectionSize;
            DataSectionHeader->VirtualAddress = NtHeader->OptionalHeader.ImageBase + SectionHeader->VirtualAddress;

            *ppvDataSectionStart = pbDataSectionStart;
            *pdwDataSectionSize = dwDataSectionSize;

            return TRUE;
        }
    }

    return FALSE;
}


PVOID
CRomBuilder::LocateExportOrdinal(
    CMemFile& PEFile,
    ULONG Ordinal
    )
{
    PULONG Addr;
    ULONG i;
    ULONG DirectoryAddress;
    PIMAGE_SECTION_HEADER NtSection = 0;
    PVOID Func = NULL;
    PIMAGE_EXPORT_DIRECTORY ExportDirectory = NULL;
    USHORT DirectoryEntry = IMAGE_DIRECTORY_ENTRY_EXPORT;
    ULONG ExportSize = 0;
    PVOID DllBase = PEFile.Ptr();
    PIMAGE_NT_HEADERS NtHeaders = PEFile.NtHeaders();

    DirectoryAddress = NtHeaders->OptionalHeader.DataDirectory[DirectoryEntry].VirtualAddress;

    if (DirectoryAddress != NULL) {
    
        ExportSize = NtHeaders->OptionalHeader.DataDirectory[DirectoryEntry].Size;
        
        NtSection = (PIMAGE_SECTION_HEADER)((ULONG)NtHeaders + sizeof(ULONG) + sizeof(IMAGE_FILE_HEADER) +
            NtHeaders->FileHeader.SizeOfOptionalHeader);
    
        for (i = 0; i < (ULONG)NtHeaders->FileHeader.NumberOfSections; i++) {
            if (DirectoryAddress >= NtSection->VirtualAddress &&
                DirectoryAddress <= NtSection->VirtualAddress + NtSection->SizeOfRawData) {
                
                ExportDirectory = (PIMAGE_EXPORT_DIRECTORY)
                    ((ULONG)DllBase + (DirectoryAddress - NtSection->VirtualAddress) + NtSection->PointerToRawData);
                break;
            }
            ++NtSection;
        }
    }


    if (ExportDirectory) {

        Addr = (PULONG)((PCHAR)DllBase + (ULONG)ExportDirectory->AddressOfFunctions - 
            NtSection->VirtualAddress + NtSection->PointerToRawData);
        
        Ordinal -= ExportDirectory->Base;

        if (Ordinal < ExportDirectory->NumberOfFunctions) {
            Func = (PVOID)((ULONG_PTR)DllBase + Addr[Ordinal]);
        }
    }

    return Func;
}





static void GetPasswd(LPCSTR szPrompt, LPSTR sz, int cchMax)
{
    char ch;
    int ich = 0;

    _cputs(szPrompt);
    for(;;) {
        ch = (char)_getch();
        switch(ch) {
        case 8:
            if(ich)
                --ich;
            break;
        case 10:
        case 13:
            sz[ich] = 0;
            _putch('\r');
            _putch('\n');
            return;
        default:
            if(ich < cchMax)
                sz[ich++] = ch;
            break;
        }
    }
}

void
CRomBuilder::BuildImage(
    BOOL External
    )
{

    char szCompKernelFile[MAX_PATH];
    CMemFile LdrFile;
    CMemFile PreldrFile;
    CMemFile UncompressedKernelFile;
    LPCSTR szOutputName;
    LPVOID pvDataSectionStart;
    DWORD dwDataSectionSize;
    CMemFile KernelFile;
    CMemFile RomDec;
    CMemFile EncRomDec;
    CMemFile InitTbl;
    PUSHORT pwKernelVer;
    PBYTE pbRomdec = NULL;
    XBOOT_PARAM BootParam;
    HANDLE hWriteFile = INVALID_HANDLE_VALUE;
    HANDLE hWriteMap = NULL;
    PBYTE pbOutput = NULL;
    PBYTE pbOutputBldr;
    PBYTE pbOutputData;
    PBYTE pbOutputKernel;
    PBYTE pbOutputPadding;
    DWORD dwBytes;
    HRESULT hr = S_OK;
    DWORD dwHashTemp;
    A_SHA_CTX SHAHash;
    CTimer Timer;
    DWORD dwMainEntry;
    DWORD dwMediaEntry;
    DWORD DesiredPreldrSize;
    DWORD dwMaxBldrSize;
    PBYTE pKeyDataInBldr;
    DWORD dwKeyEntry;
    PDWORD rgdwHashDataSizes;
    BYTE rgbTemp[8192];
    BYTE rgbKeyToEncryptKernel[16];
    BYTE rgbKeyForRandomData[16];
    BYTE rgbBldrNonce[16];
    FILETIME ft;
    int i;
    BOOL fSuccess = FALSE;

    szCompKernelFile[0] = '\0';
    memset(&BootParam, 0, sizeof(BootParam));
    BootParam.Signature = BLDR_SIGNATURE;

    if (External) 
    {
        TRACE_OUT(TRACE_VERBOSE, "Output external \t%s", g_ib.m_prop.Get(PROP_OUTPUTEXT));
    }
    else
    {
        TRACE_OUT(TRACE_VERBOSE, "Output filename \t%s", g_ib.m_prop.Get(PROP_OUTPUT));
    }
    TRACE_OUT(TRACE_VERBOSE, "System          \t%s", g_ib.m_prop.Get(PROP_SYS));

    //
    // Create the output file
    //
    if (External) 
    {
        szOutputName = g_ib.m_prop.Get(PROP_OUTPUTEXT);
        hWriteFile = CreateFile(szOutputName, GENERIC_READ | GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        if (hWriteFile == INVALID_HANDLE_VALUE) {
            g_ib.SetExitMsg(HRESULT_FROM_WIN32(GetLastError()), "Failed to create external output file");
            goto Cleanup;
        }
    }
    else
    {
        szOutputName = g_ib.m_prop.Get(PROP_OUTPUT);
        hWriteFile = CreateFile(szOutputName, GENERIC_READ | GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        if (hWriteFile == INVALID_HANDLE_VALUE) {
            g_ib.SetExitMsg(HRESULT_FROM_WIN32(GetLastError()), "Failed to create output file");
            goto Cleanup;
        }
    }

    //
    // Fill the output file with 1 MB of zeroes
    //
    memset(rgbTemp, 0, sizeof rgbTemp);
    for(i = 0; i < 128; ++i) {
        if(!WriteFile(hWriteFile, rgbTemp, sizeof rgbTemp, &dwBytes, NULL) ||
            dwBytes != sizeof rgbTemp)
        {
WriteError:
            g_ib.SetExitMsg(HRESULT_FROM_WIN32(GetLastError()), "Failed to create output file");
            goto Cleanup;
        }
    }

    //
    // Map in the output file
    //
    hWriteMap = CreateFileMapping(hWriteFile, NULL, PAGE_READWRITE, 0,
        0x100000, NULL);
    if(!hWriteMap)
        goto WriteError;
    pbOutput = (PBYTE)MapViewOfFile(hWriteMap, FILE_MAP_WRITE, 0, 0, 0x100000);
    if(!pbOutput)
        goto WriteError;

    //
    // Get temporary file name for compressed kernel file
    //
    if (FAILED(hr = TempFileName(szCompKernelFile)))
    {
        g_ib.SetExitMsg(hr, "Failed to get temp file name");
        goto Cleanup;
    }

    //
    // Read the uncompressed kernel
    //
    if (FAILED(hr = UncompressedKernelFile.Open(g_ib.m_prop.Get(PROP_KERNEL), TRUE)))
    {
        g_ib.SetExitMsg(hr, "Failed to open uncompressed kernel file");
        goto Cleanup;
    }

    //
    // We hash the current system time plus the kernel contents to use as a
    // seed to generate random encryption keys
    //

    A_SHAInit(&SHAHash);
    GetSystemTimeAsFileTime(&ft);
    A_SHAUpdate(&SHAHash, (PUCHAR)&ft, sizeof ft);
    A_SHAUpdate(&SHAHash, (PUCHAR)UncompressedKernelFile.Ptr(),
        UncompressedKernelFile.Size());
    A_SHAFinal(&SHAHash, rgbTemp);

    //
    // Find the pointer to the start of the kernel's .data section and its size.
    //
    if (!LocateDataSection(UncompressedKernelFile, &pvDataSectionStart, &dwDataSectionSize))
    {
        g_ib.SetExitMsg("Could not locate the kernel's data section");
        goto Cleanup;
    }

    //
    // Figure out where we're going to put things
    //
    pbOutputBldr = pbOutput + g_ib.m_nRomSize - ROM_DEC_SIZE - BLDR_BLOCK_SIZE;
    pbOutputData = pbOutputBldr - dwDataSectionSize;

    if(pbOutputData < pbOutput) {
        g_ib.SetExitMsg("Kernel data section exceeds available size");
        goto Cleanup;
    }

    //
    // Copy the kernel's data into the output file
    //
    memcpy(pbOutputData, pvDataSectionStart, dwDataSectionSize);

    //
    // Replace the public key
    //
    if (m_UseSpecifiedKeys) {
        
        if (m_szPubKeyFN[0] != '\0') {
            if (!ReadKeyFromEncFile(g_ib.m_szPubKeyFN, g_ib.m_szPassword, g_PublicKeyData, XC_PUBLIC_KEYDATA_SIZE, FALSE))             {
                g_ib.Exit(-1, "Bad public key file");
            }
            TRACE_OUT(TRACE_VERBOSE, "Public Key Injected\t%s", g_ib.m_szPubKeyFN);
        } else {
            TRACE_OUT(TRACE_VERBOSE, "Public Key Injected\t(Interim)");
        }

        //
        // Find XePublicKeyData with ordinal
        //
        PBYTE pKeyInBinary = (PBYTE)LocateExportOrdinal(UncompressedKernelFile, 355);

        if (pKeyInBinary == NULL) {
            g_ib.Exit(-1, "XePublicKeyData(355) export not found in kernel binary to inject public key");
        }
        
        //
        // Verify that we found the right place by checking for RSA1 signature
        //
        if (*(DWORD*)pKeyInBinary != 0x31415352) {
            g_ib.Exit(-1, "XePublicKeyData(355) in kernel binary does not point to a valid key place holder");
        }

        //
        // Inject the public key into the binary
        //
        memcpy(pKeyInBinary, g_PublicKeyData, XC_PUBLIC_KEYDATA_SIZE);
    }


    //
    // Compress the kernel
    //
    Timer.Start();
    if (!CompressFile(UncompressedKernelFile, szCompKernelFile))
    {
        g_ib.SetExitMsg("Could not compress the kernel");
        goto Cleanup;
    }
    Timer.Stop();
    TRACE_OUT(TRACE_VERBOSE, "Uncompressed kernel \t%d bytes", UncompressedKernelFile.Size());
    TRACE_OUT(TRACE_VERBOSE, "Time to compress \t%0.4f ms", Timer.getTime());

    //
    // Read the compressed kernel
    //
    if (FAILED(hr = KernelFile.Open(szCompKernelFile)))
    {
        g_ib.SetExitMsg(hr, "Failed to open compressed kernel file");
        goto Cleanup;
    }

    //
    // Copy the compressed kernel into the output file
    //
    pbOutputKernel = pbOutputData - KernelFile.Size();
    if(pbOutputKernel < pbOutput) {
        g_ib.SetExitMsg("Compressed kernel exceeds available size");
        goto Cleanup;
    }
    memcpy(pbOutputKernel, KernelFile.Ptr(), KernelFile.Size());

    //
    // Read the boot loader
    //
    if (m_nBuildFor == ROMBLD_XM3)
    {
        DesiredPreldrSize = 2 * 1024;
        dwMaxBldrSize = BLDR_BLOCK_SIZE - DesiredPreldrSize;
    }
    else
    {
        DesiredPreldrSize = PRELDR_BLOCK_SIZE;
        dwMaxBldrSize = BLDR_BLOCK_SIZE - DesiredPreldrSize;
    }
    if (FAILED(hr = LdrFile.Open(g_ib.m_prop.Get(PROP_BOOTLDR))))
    {
        g_ib.SetExitMsg(hr, "Failed to open boot loader file");
        goto Cleanup;
    }

    if (LdrFile.Size() > BLDR_BLOCK_SIZE - DesiredPreldrSize)
    {
        ERROR_OUT("Boot loader block is too big (%d).  Maxsize=%d", 
            LdrFile.Size(), dwMaxBldrSize);
        goto Cleanup;
    }

    TRACE_OUT(TRACE_VERBOSE, "Boot Loader \t\t%d bytes", LdrFile.Size());

    //
    // Copy the boot loader into the output
    //
    memcpy(pbOutputBldr, LdrFile.Ptr(), LdrFile.Size());

    //
    // A pointer to the start of keys in boot loader is stored a DWORD found two DWORDs 
    // before the entry point.  Entry point is the first DWORD in the binary.
    //

    dwKeyEntry = (*(DWORD*)pbOutputBldr) - BLDR_BOOT_ORIGIN - 8;
    dwKeyEntry = *(DWORD*)((BYTE*)pbOutputBldr + dwKeyEntry);
    dwKeyEntry -= BLDR_RELOCATED_ORIGIN; 
    pKeyDataInBldr = (BYTE*)pbOutputBldr + dwKeyEntry;

    //
    // Inject keys in the boot loader image and reterieve encryption keys
    //
    UpdateKeys(rgbTemp, rgbKeyForRandomData, rgbKeyToEncryptKernel,
        rgbBldrNonce, pKeyDataInBldr);

    if (m_nBuildFor != ROMBLD_XM3)
    {
        //
        // Move the entry points around
        //
        dwMainEntry = *(PDWORD)pbOutputBldr;
        dwMainEntry -= BLDR_BOOT_ORIGIN;
        dwMediaEntry = *(PDWORD)(pbOutputBldr + dwMainEntry - 4);
        *(PDWORD)pbOutputBldr = (BLDR_BOOT_ORIGIN + BLDR_BLOCK_SIZE - DesiredPreldrSize);
        *(PDWORD)(pbOutputBldr + BLDR_BLOCK_SIZE - DesiredPreldrSize - 4) = dwMediaEntry;
        *(PDWORD)(pbOutputBldr + BLDR_BLOCK_SIZE - DesiredPreldrSize - 8) = dwMainEntry;
    }

    //
    // Encrypt the kernel in place
    //
    Timer.Start();
    XCSymmetricEncDec(pbOutputKernel, KernelFile.Size(), rgbKeyToEncryptKernel, 16); 
    Timer.Stop();
    TRACE_OUT(TRACE_VERBOSE, "Time to encrypt\t\t%0.4f ms", Timer.getTime());


    //
    // Read the inittbl
    //
    if (FAILED(hr = InitTbl.Open(g_ib.m_prop.Get(PROP_INITTBL))))
    {
        g_ib.SetExitMsg(hr, "Failed to open InitTbl file");
        goto Cleanup;
    }
    if(pbOutput + InitTbl.Size() > pbOutputKernel) {
        g_ib.SetExitMsg("Init table exceeds available size");
        goto Cleanup;
    }

    //
    // Copy it into the output
    //
    memcpy(pbOutput, InitTbl.Ptr(), InitTbl.Size());

    //
    // Set the kernel build number
    //
    pwKernelVer = (PUSHORT)LocateExportOrdinal(UncompressedKernelFile, 324);
    if(pwKernelVer) {
        ((PUSHORT)pbOutput)[ROM_VERSION_OFFSET * 2 + 1] =
            pwKernelVer[2];
    }

    //
    // For external images modify the init table to add the KD delay flag
    //
    if (External) 
    {
        ((PDWORD)pbOutput)[ROM_VERSION_OFFSET] |= ROM_VERSION_KDDELAY_FLAG;
    }

    //
    // Save the sizes into the boot param
    //
    BootParam.CompressedKernelSize = KernelFile.Size();
    BootParam.UncompressedKernelDataSize = dwDataSectionSize;
    BootParam.InitTableSize = InitTbl.Size();

    if(m_nBuildFor == ROMBLD_XM3) {

        //
        // Calculate a SHA1 digest with the following components
        //     1. Size and contents of compressed and encrypted kernel 
        //     2. Size and contents of uncompressed data
        //     3. Size and contents of init table
        //
        Timer.Start();
        A_SHAInit(&SHAHash);
        A_SHAUpdate(&SHAHash, rgbKeyToEncryptKernel, 16);
    
        dwHashTemp = KernelFile.Size();
        A_SHAUpdate(&SHAHash, (PBYTE)&dwHashTemp, sizeof(DWORD));
        A_SHAUpdate(&SHAHash, (PUCHAR)pbOutputKernel, dwHashTemp);
    
        dwHashTemp = dwDataSectionSize;
        A_SHAUpdate(&SHAHash, (PBYTE)&dwHashTemp, sizeof(DWORD));
        A_SHAUpdate(&SHAHash, (PUCHAR)pbOutputData, dwHashTemp);

        //
        // When /HACKINITTABLE:1 is specified, we don't digest the
        // the init table.  This is indicated by InitTableSize set to 0
        //
        if (m_HackInitTable == 0) 
        {
            dwHashTemp = InitTbl.Size();
            A_SHAUpdate(&SHAHash, (PBYTE)&dwHashTemp, sizeof(DWORD));
            A_SHAUpdate(&SHAHash, (PUCHAR)pbOutput, dwHashTemp);
        
            TRACE_OUT(TRACE_VERBOSE, "Manual editing\t\tNot Allowed");
        }
        else
        {
            BootParam.InitTableSize = 0;
            TRACE_OUT(TRACE_VERBOSE, "Manual editing\tAllowed");
        }

        //
        // Save the digest in the boot param
        //
        A_SHAFinal(&SHAHash, &(BootParam.MainRomDigest[0]));

        A_SHAInit(&SHAHash);
        A_SHAUpdate(&SHAHash, rgbKeyToEncryptKernel, 16);
        A_SHAUpdate(&SHAHash, &(BootParam.MainRomDigest[0]), XC_DIGEST_LEN);
        A_SHAFinal(&SHAHash, &(BootParam.MainRomDigest[0]));
    
        Timer.Stop();
        TRACE_OUT(TRACE_VERBOSE, "Digest calculation\t%0.4f ms", Timer.getTime());
    }

    //
    // And save away the boot params
    //
    memcpy(pbOutputBldr + BLDR_BLOCK_SIZE - sizeof BootParam, &BootParam, sizeof(BootParam));

    //
    // Encrypt the boot loader using the key that will be used by romdec32
    //
    if(m_nBuildFor == ROMBLD_XM3P) {
        //
        // Read the encrypted romdec
        //
        if (FAILED(hr = EncRomDec.Open(g_ib.m_prop.Get(PROP_ENCROM))))
        {
            g_ib.SetExitMsg(hr, "Failed to open EncRomDec file");
            goto Cleanup;
        }
        if(EncRomDec.Size() != ROM_DEC_SIZE + 28) {
            ERROR_OUT("Encrypted romdec size is incorrect (%d).  Should be %d", 
                EncRomDec.Size(), ROM_DEC_SIZE + 28);
            goto Cleanup;
        }
        pbRomdec = (PBYTE)malloc(ROM_DEC_SIZE);

        //
        // Decrypt it
        //
        GetPasswd("Enter romdec password:", (LPSTR)rgbTemp, sizeof rgbTemp);
        A_SHAInit(&SHAHash);
        A_SHAUpdate(&SHAHash, rgbTemp, strlen((LPSTR)rgbTemp));
        A_SHAFinal(&SHAHash, rgbTemp);
        memcpy(rgbTemp + 20, EncRomDec.Ptr(), EncRomDec.Size());
        XCSymmetricEncDec(rgbTemp + 20, 8, rgbTemp, 20);
        XCSymmetricEncDec(rgbTemp + 28, EncRomDec.Size() - 8, rgbTemp + 20, 8);
        memcpy(pbRomdec, rgbTemp + 48, ROM_DEC_SIZE);
        A_SHAInit(&SHAHash);
        A_SHAUpdate(&SHAHash, pbRomdec, ROM_DEC_SIZE);
        A_SHAFinal(&SHAHash, rgbTemp);
        if(memcmp(rgbTemp, rgbTemp + 28, 20)) {
            ERROR_OUT("Romdec password is incorrect");
            goto Cleanup;
        }
        memset(rgbTemp, 0, 1024);

        //
        // The actual bldr encryption key is a cross of a nonce and the SB
        // key
        //
        A_SHAInit(&SHAHash);
        A_SHAUpdate(&SHAHash, pbRomdec + ROM_DEC_SIZE - ROMDEC_N, 16);
        A_SHAUpdate(&SHAHash, rgbBldrNonce, 16);
        for(i = 0; i < 16; ++i)
            rgbTemp[i] = (BYTE)((pbRomdec + ROM_DEC_SIZE - ROMDEC_N)[i] ^
                0x5C);
        A_SHAUpdate(&SHAHash, rgbTemp, 16);
        A_SHAFinal(&SHAHash, rgbTemp);

        XCSymmetricEncDec(pbOutputBldr, BLDR_BLOCK_SIZE, rgbTemp,
            XC_DIGEST_LEN);
        memcpy(pbOutputBldr + BLDR_BLOCK_SIZE - 16, rgbBldrNonce, 16);
        memset(rgbTemp, 0, 16);

        //
        // Take out the first 16 bytes of the bldr (we know they're unused
        // to minimze the chance of the "resolved key" RC4 attack
        //
        memset(pbOutputBldr, 0, 16);
    } else
        XCSymmetricEncDec(pbOutputBldr, BLDR_BLOCK_SIZE, g_KeyToEncryptBldr, 16); 

    //
    // Read the preloader
    //
    if(FAILED(hr = PreldrFile.Open(g_ib.m_prop.Get(PROP_PRELDR))))
    {
        g_ib.SetExitMsg(hr, "Failed to open preloader file");
        goto Cleanup;
    }
    if ((PreldrFile.Size() + 0x180) > DesiredPreldrSize)
    {
        ERROR_OUT("Preloader block is too big (%d).  Maxsize=%d", 
            PreldrFile.Size(), DesiredPreldrSize - 0x180);
        goto Cleanup;
    }

    TRACE_OUT(TRACE_VERBOSE, "Preloader\t\t%d bytes", PreldrFile.Size());

    //
    // Insert the preloader
    //
    memset(pbOutputBldr + BLDR_BLOCK_SIZE - DesiredPreldrSize, 0,
        DesiredPreldrSize - 0x180);
    memcpy(pbOutputBldr + BLDR_BLOCK_SIZE - DesiredPreldrSize, PreldrFile.Ptr(),
        PreldrFile.Size());

    //
    // Read the romdec
    //
    if (FAILED(hr = RomDec.Open(g_ib.m_prop.Get(PROP_ROMDEC))))
    {
        if(!pbRomdec) {
            g_ib.SetExitMsg(hr, "Failed to open RomDec file");
            goto Cleanup;
        }
    } else if(RomDec.Size() != ROM_DEC_SIZE) {
        ERROR_OUT("Romdec block is incorrect (%d).  Should be %d", 
            RomDec.Size(), ROM_DEC_SIZE);
        goto Cleanup;
    } else {
        if(pbRomdec) {
            memset(pbRomdec, 0, ROM_DEC_SIZE);
            free(pbRomdec);
        }
        pbRomdec = (PBYTE)RomDec.Ptr();
    }

    memcpy(pbOutputBldr + BLDR_BLOCK_SIZE, pbRomdec, ROM_DEC_SIZE);
    if(pbRomdec != RomDec.Ptr()) {
        memset(pbRomdec, 0, ROM_DEC_SIZE);
        free(pbRomdec);
    }
    pbRomdec = NULL;

    if(m_nBuildFor == ROMBLD_XDK) {
        //
        // Find the preloader's public key and encrypt it
        //
        pKeyDataInBldr = (PBYTE)((PULONG)(pbOutputBldr + BLDR_BLOCK_SIZE -
            DesiredPreldrSize))[3];
        pKeyDataInBldr = pKeyDataInBldr - (PUCHAR)(0UL - ROM_DEC_SIZE -
            BLDR_BLOCK_SIZE) + pbOutputBldr;
        XCSymmetricEncDec(pKeyDataInBldr, XC_PUBLIC_KEYDATA_SIZE,
            pbOutputBldr + BLDR_BLOCK_SIZE + ROM_DEC_SIZE - ROMDEC_N, 12);
    }

    //
    // Generate a random sequence to fill in the padding.
    //
    pbOutputPadding = pbOutput + InitTbl.Size();
    XCSymmetricEncDec(pbOutputPadding, pbOutputKernel - pbOutputPadding,
        rgbKeyForRandomData, sizeof rgbKeyForRandomData);

    //
    // Mark this ROM's sizes
    //
    rgdwHashDataSizes = (PDWORD)(pbOutput + g_ib.m_nRomSize - ROM_DEC_SIZE -
        0x80);
    rgdwHashDataSizes[0] = 0UL - g_ib.m_nRomSize;
    rgdwHashDataSizes[1] = BootParam.InitTableSize;
    rgdwHashDataSizes[2] = pbOutputKernel - pbOutput + rgdwHashDataSizes[0];

    //
    // Last step is to PK sign the whole thing.  First comes the top 128
    // bytes, which includes the sizes, then the init table, then the rest
    // of the ROM up to the signature
    //
    A_SHAInit(&SHAHash);
    A_SHAUpdate(&SHAHash, pbOutput + g_ib.m_nRomSize - ROM_DEC_SIZE - 0x80,
        0x80);
    A_SHAUpdate(&SHAHash, pbOutput, BootParam.InitTableSize);
    A_SHAUpdate(&SHAHash, pbOutputKernel, (pbOutput + g_ib.m_nRomSize -
        ROM_DEC_SIZE - 0x180) - pbOutputKernel);
    A_SHAFinal(&SHAHash, rgbTemp);
    XCSignDigest(rgbTemp, g_KeyToSignROM, pbOutput + g_ib.m_nRomSize - 
        ROM_DEC_SIZE - 0x180);

    //
    // Replicate the data up to 1 MB size
    //

    if(g_ib.m_nRomSize < 0x80000)
        memcpy(pbOutput + 0x40000, pbOutput, g_ib.m_nRomSize);
    if(g_ib.m_nRomSize < 0x100000)
        memcpy(pbOutput + 0x80000, pbOutput, 0x80000);

    fSuccess = TRUE;

Cleanup:
    if(pbRomdec) {
        memset(pbRomdec, 0, ROM_DEC_SIZE);
        free(pbRomdec);
    }
    if(pbOutput)
        fSuccess = UnmapViewOfFile(pbOutput) && fSuccess;
    if(hWriteMap)
        CloseHandle(hWriteMap);
    if (hWriteFile != INVALID_HANDLE_VALUE)
    {
        CloseHandle(hWriteFile);
    }
    if(!fSuccess)
        DeleteFile(szOutputName);

    if (szCompKernelFile[0] != '\0')
    {
        KernelFile.Close();
        DeleteFile(szCompKernelFile);
    }
}


void 
CRomBuilder::UpdateKeys(
    PBYTE rgbRandomHash,
    PBYTE rgbRandomKey,
    PBYTE rgbKernelKey,
    PBYTE rgbBldrEncKey,
    PBYTE rgbBldrKeys
    )
{
    BYTE rgbKeys[48];
    BYTE EEPROMKey[16];
    BYTE CERTKey[16];

    /* Use the random hash as an rc4 key to encrypt a stream of zeroes -- this
     * will be our random set of key bytes */
    memset(rgbKeys, 0, sizeof rgbKeys);
    XCSymmetricEncDec(rgbKeys, sizeof rgbKeys, rgbRandomHash, XC_DIGEST_LEN);

    /* We'll use the first 16 bytes as a random number key */
    memcpy(rgbRandomKey, rgbKeys, 16);

    /* The next 16 bytes will be the key to encrypt the kernel */
    memcpy(rgbKernelKey, rgbKeys + 16, 16);

    /* The kernel key is also the third of the bldr's keys */
    memcpy(rgbBldrKeys + 32, rgbKernelKey, 16);

    /* The last 16 bytes are a nonce to encrypt the bldr */
    memcpy(rgbBldrEncKey, rgbKeys + 32, 16);

    //
    // Read the EEPROM key
    //
    if (m_szEEPROMKeyFN[0] != '\0') 
    {
        if (!ReadKeyFromEncFile(m_szEEPROMKeyFN, m_szPassword, EEPROMKey, 16, TRUE))
        {
            g_ib.Exit(-1, "Bad EEPROM key file");
        }
        
        memcpy(rgbBldrKeys, EEPROMKey, 16);
    }
    
    //
    // Read the CERT key
    //
    if (m_szCERTKeyFN[0] != '\0') 
    {
        if (!ReadKeyFromEncFile(m_szCERTKeyFN, m_szPassword, CERTKey, 16, TRUE))
        {
            g_ib.Exit(-1, "Bad CERT key file");
        }

        memcpy(rgbBldrKeys + 16, CERTKey, 16);
    }
}


extern "C"
int
_cdecl
main(
    int argc,
    char** argv
    )
{

    g_ib.Initialize(argc, argv);

    if (g_ib.m_prop.Get(PROP_HELP))
    {
        g_ib.PrintUsage();
    }
    else
    {
        //
        // Build image
        //

        if (g_ib.m_prop.Get(PROP_OUTPUT) == NULL ||
            g_ib.m_prop.Get(PROP_BOOTLDR) == NULL ||
            g_ib.m_prop.Get(PROP_INITTBL) == NULL ||
            g_ib.m_prop.Get(PROP_PRELDR) == NULL ||
            g_ib.m_prop.Get(PROP_SYS) == NULL ||
            g_ib.m_prop.Get(PROP_KERNEL) == NULL

            )
        {
usage:
            g_ib.PrintUsage();
            g_ib.Exit(-1, "Required switches were not supplied");
        }

        if (_stricmp(g_ib.m_prop.Get(PROP_SYS), "XDK") == 0)
            g_ib.m_nBuildFor = ROMBLD_XDK;
        else if(_stricmp(g_ib.m_prop.Get(PROP_SYS), "XM3") == 0)
            g_ib.m_nBuildFor = ROMBLD_XM3;
        else if(_stricmp(g_ib.m_prop.Get(PROP_SYS), "XM3P") == 0)
            g_ib.m_nBuildFor = ROMBLD_XM3P;
        else {
            g_ib.PrintUsage();
            g_ib.Exit(-1, "/SYS has an invalid value");
        }

        /* Make sure we have an appropriate romdec */
        if(g_ib.m_prop.Get(g_ib.m_nBuildFor == ROMBLD_XM3P ? PROP_ENCROM :
                PROP_ROMDEC) == NULL)
            goto usage;

        /* Only support 256k, 512k, 1MB ROMs */
        switch(g_ib.m_nRomSize) {
            case 256:
            case 512:
            case 1024:
                // convert to byte count
                g_ib.m_nRomSize *= 1024;
                break;
            default:
                g_ib.Exit(-1, "ROM size must be 256, 512, or 1024");
                break;
        }

        if (g_ib.m_prop.Get(PROP_KEYPATH) != NULL) 
        {
            g_ib.m_UseSpecifiedKeys = TRUE;

            printf("Using following encrypted key files:\n");
            
            g_ib.m_szRomEncKeyFN[0] = '\0';
            g_ib.m_szEEPROMKeyFN[0] = '\0';
            g_ib.m_szCERTKeyFN[0] = '\0';

            //
            // Build file names and verify key files
            //
            BuildFilename(g_ib.m_szRomEncKeyFN, g_ib.m_prop.Get(PROP_KEYPATH), "bldrenc.key");
            printf("   %s => ", g_ib.m_szRomEncKeyFN);
            if (!IsEncKeyFile(g_ib.m_szRomEncKeyFN))
            {
                printf("*** Not found or invalid\n");
                g_ib.m_szRomEncKeyFN[0] = '\0';
            }
            else
            {
                printf("Found\n");
            }


            BuildFilename(g_ib.m_szEEPROMKeyFN, g_ib.m_prop.Get(PROP_KEYPATH), "eeprom.key");
            printf("   %s => ", g_ib.m_szEEPROMKeyFN);
            if (!IsEncKeyFile(g_ib.m_szEEPROMKeyFN))
            {
                printf("*** Not found or invalid\n");
                g_ib.m_szEEPROMKeyFN[0] = '\0';
            }
            else
            {
                printf("Found\n");
            }

            BuildFilename(g_ib.m_szCERTKeyFN, g_ib.m_prop.Get(PROP_KEYPATH), "cert.key");
            printf("   %s => ", g_ib.m_szCERTKeyFN);
            if (!IsEncKeyFile(g_ib.m_szCERTKeyFN))
            {
                printf("*** Not found or invalid\n");
                g_ib.m_szCERTKeyFN[0] = '\0';
            }
            else
            {
                printf("Found\n");
            }

            BuildFilename(g_ib.m_szPubKeyFN, g_ib.m_prop.Get(PROP_KEYPATH), "pub.key");
            printf("   %s => ", g_ib.m_szPubKeyFN);
            if (!IsEncKeyFile(g_ib.m_szPubKeyFN))
            {
                printf("*** Not found or invalid--interim key will be used\n");
                g_ib.m_szPubKeyFN[0] = '\0';
            }
            else
            {
                printf("Found\n");
            }



            //
            // Read passwords
            //
            if (!ReadPassword("Enter password to decrypt: ", g_ib.m_szPassword))
            {
                g_ib.Exit(-1, "Password is required with /KEYPATH");
            }

            //
            // Read the key to encrypt the boot loader
            //
            if (g_ib.m_szRomEncKeyFN[0] != '\0') 
            {
                if (!ReadKeyFromEncFile(g_ib.m_szRomEncKeyFN, g_ib.m_szPassword, g_KeyToEncryptBldr, 16, TRUE))
                {
                    g_ib.Exit(-1, "Bad bldrenc key file");
                }
            }

        }


        g_ib.BuildImage(FALSE);
    
        if (g_ib.m_prop.Get(PROP_OUTPUTEXT) != NULL)
        {
            g_ib.BuildImage(TRUE);
        }
    }

    g_ib.Exit(0, NULL);

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\vctools\pdb6\langapi\include\bld_version.h ===
//
// Define the build revision number.  Default is zero.
//
//  Typical use is to use a -D define to override this one
//  so you do not need to update this file.
//
//  example:  cl ... -Drbld=1 ...
//
//
#if !defined(_build_version_h)
#define _build_version_h
#pragma once

#if !defined(rbld)
#define rbld 0
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\vctools\pdb6\langapi\include\clstypes.h ===
//------------------------------------------------------------------------------
// CLSTYPES.H
//
// Structures and typedefs to ease the life of a class file data reader...
//------------------------------------------------------------------------------
#ifndef _CLSTYPES_INCLUDED
#define _CLSTYPES_INCLUDED

//------------------------------------------------------------------------------
// Access flags, taken directly from Sun's Java VM Specification (Aug 21 1995)
//------------------------------------------------------------------------------
#define ACC_PUBLIC          0x0001
#define ACC_PRIVATE         0x0002
#define ACC_PROTECTED       0x0004
#define ACC_STATIC          0x0008
#define ACC_FINAL           0x0010
#define ACC_SYNCHRONIZED    0x0020
#define ACC_VOLATILE        0x0040
#define ACC_TRANSIENT       0x0080
#define ACC_NATIVE          0x0100
#define ACC_INTERFACE       0x0200
#define ACC_ABSTRACT        0x0400

//------------------------------------------------------------------------------
// Constant tags, also taken from the VM spec
//------------------------------------------------------------------------------
#define CONSTANT_Class                  7
#define CONSTANT_Fieldref               9
#define CONSTANT_Methodref              10
#define CONSTANT_InterfaceMethodref     11
#define CONSTANT_String                 8
#define CONSTANT_Integer                3
#define CONSTANT_Float                  4
#define CONSTANT_Long                   5
#define CONSTANT_Double                 6
#define CONSTANT_NameAndType            12
#define CONSTANT_Utf8                   1
#define CONSTANT_Unicode                2

//------------------------------------------------------------------------------
// Basic types
//------------------------------------------------------------------------------
typedef unsigned char       U1;
typedef unsigned short      U2;
typedef unsigned long       U4;
typedef unsigned __int64    U8;

//------------------------------------------------------------------------------
// Helper structs
//------------------------------------------------------------------------------
struct longdbl
{
    union
    {
        U8      iValue;
        double  fValue;
        struct
        {
            U4  iLow;
            U4  iHigh;
        };
    };
};

//------------------------------------------------------------------------------
// CPINFO -- constant pool entry structure (union).  Note that all values are
// swapped into little-endian for you, but strings are still UTF8...
//------------------------------------------------------------------------------
struct cp_info
{
    U1      iTag;       // CONSTANT_* tag
    union
    {
        struct
        {
            U2      iName;
        } Class;                // CONSTANT_Class;
        struct
        {
            U2      iClass;
            U2      iNameAndType;
        } Fieldref;             // CONSTANT_Fieldref
        struct
        {
            U2      iClass;
            U2      iNameAndType;
        } Methodref;            // CONSTANT_Methodref
        struct
        {
            U2      iClass;
            U2      iNameAndType;
        } InterfaceMethodref;   // CONSTANT_InterfaceMethodref
        struct
        {
            U2      iIndex;
        } String;               // CONSTANT_String
        struct
        {
            U4      iValue;
        } Integer;              // CONSTANT_Integer
        struct
        {
            float   fValue;
        } Float;                // CONSTANT_Float
        struct
        {
            longdbl *pVal;
        } Long;                 // CONSTANT_Long
        struct _DoubleStruct
        {
            longdbl *pVal;
        } Double;               // CONSTANT_Double
        struct
        {
            U2      iName;
            U2      iSignature;
        } NameAndType;          // CONSTANT_NameAndType
        struct
        {
            U2      iLength;
            U1      *pBytes;
        } Utf8;                 // CONSTANT_Utf8
        struct
        {
            U2      iLength;
            U2      *pBytes;
        } Unicode;              // CONSTANT_Unicode
    };
};

typedef cp_info CPOOLINFO, *LPCPOOLINFO;

//------------------------------------------------------------------------------
// ATTRINFO -- attribute information
//------------------------------------------------------------------------------
struct attribute_info
{
    struct attribute_info   *pNext;
    U2                      iName;
    U4                      iLength;
    U1                      rgBytes[1];
};

typedef attribute_info ATTRINFO, *LPATTRINFO;

//------------------------------------------------------------------------------
// MEMBERINFO -- member information
//------------------------------------------------------------------------------
struct member_info
{
    U2          iAccessFlags;
    U2          iName;
    U2          iSignature;
    LPATTRINFO  pAttrList;
};

typedef member_info MEMBERINFO, *LPMEMBERINFO;


//------------------------------------------------------------------------------
// METHODINFO -- method information
//------------------------------------------------------------------------------
struct method_info : public member_info
{
};

typedef method_info METHODINFO, *LPMETHODINFO;

//------------------------------------------------------------------------------
// FIELDINFO -- field information
//------------------------------------------------------------------------------
struct field_info : public member_info
{
};

typedef field_info FIELDINFO, *LPFIELDINFO;


#endif // #ifndef _CLSTYPES_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\rombld\util.h ===
/*++

Copyright (c) 1989-2000  Microsoft Corporation

Module Name:

    util.h

Abstract:

    Contains utility classes and routines


--*/

#ifndef _UTIL_H
#define _UTIL_H

#include <windows.h>
#include <winnt.h>
#include <stdlib.h>
#include "list.h"
#include "rombld.h"


//
// Key file format copied from sdktools\xcrypt
//
#define KEYFILE_PUBPAIR      1      // public and private keys
#define KEYFILE_PUBONLY      2      // public key only
#define KEYFILE_SYM          3      // symmetric key

#define KEYFILE_ENCFILE_SIG  'kcne' // signature dword in the encrypted key file


typedef struct _XBOX_KEYFILE_HEADER
{
    USHORT KeyType;                 // KEYFILE_ defines
    USHORT KeyBits;                 // number of bits in the key
    GUID   KeyGUID;                 // unique guid genereted at the time the key file was created
    ULONG  KeyNumber;               // a number assigned key
    ULONG  PublicKeyBytes;          // bytes used by public key structure
    ULONG  PrivateKeyBytes;         // bytes used by private key structure

} XBOX_KEYFILE_HEADER, *PXBOX_KEYFILE_HEADER;


#define PASSWORD_MAXSIZE     21
#define PASSWORD_MINLEN      8


class CMemFile
{
public:
    CMemFile() 
        : m_hFile(INVALID_HANDLE_VALUE),
          m_hFileMapping(NULL),
          m_pBase(NULL),
          m_pHeader(NULL),
          m_pWriteCopy(NULL),
          m_dwSize(0)
    {
    }

    ~CMemFile()
    {
        Close();
    }
    HRESULT Open(LPCSTR pszFN, BOOL CopyOnWrite = FALSE);
    HRESULT MakeWriteCopy();
    void Close();
    DWORD Size();
    PVOID Ptr() 
    {
        return m_pBase;
    }

    //
    // for PE Files
    //
    DWORD GetDirectoryEntryVA(USHORT uDirectoryEntry)
    {
        return m_pHeader->OptionalHeader.DataDirectory[uDirectoryEntry].VirtualAddress;
    }
    DWORD GetDirectoryEntrySize(USHORT uDirectoryEntry)
    {
        return m_pHeader->OptionalHeader.DataDirectory[uDirectoryEntry].Size;
    }
    PVOID PtrFromBase(DWORD dwOfs)
    {
        return (PVOID)((PBYTE)m_pBase + dwOfs);
    }
    PIMAGE_NT_HEADERS NtHeaders()
    {
        return m_pHeader;
    }

private:
    HANDLE m_hFile;
    HANDLE m_hFileMapping;
    PVOID m_pWriteCopy;

    //
    // for PE files
    //
    PIMAGE_NT_HEADERS m_pHeader;
    PVOID m_pBase;
    DWORD m_dwSize;   
};




class CStrNode : public CNode
{
public:
    CStrNode() 
        : m_pszValue(NULL)
    {
    }
    ~CStrNode()
    {
        if (m_pszValue != NULL)
            free(m_pszValue);
    }
    void SetValue(LPCSTR pszValue)
    {
        if (m_pszValue != NULL)
            free(m_pszValue);
        m_pszValue = _strdup(pszValue);
    }
    LPCSTR GetValue()
    {
        return m_pszValue;
    }

    virtual void Dump();

private:
    LPSTR m_pszValue;
};


class CTimer
{
public:
    // constructor
    CTimer()
    {
        QueryPerformanceFrequency((LARGE_INTEGER*)&ticksPerSecond);
        ticksPerSecond /= 1000;
    }

    ~CTimer() {};

    void Start()
        { frunning = true; QueryPerformanceCounter((LARGE_INTEGER *)&ticksstart); }

    void Stop()
        { frunning = false; QueryPerformanceCounter((LARGE_INTEGER *)&ticksend); }

    float getTime()
        {
            if(frunning)
                QueryPerformanceCounter((LARGE_INTEGER *)&ticksend);
            return ((ticksend - ticksstart) * 1.0f / ticksPerSecond);
        }

    bool frunning;
    _int64 ticksstart;
    _int64 ticksend;
    _int64 ticksPerSecond;
};



typedef struct
{
    enum VARTYPE {VAR_NONE, VAR_INT, VAR_STRING, VAR_STRINGLIST};

    LPCTSTR lpCmdLine;
    LPCTSTR lpPropName;
    VARTYPE vartype;
    void* lpVar;

    static int _cdecl Compare(const void*, const void*);
} CMDTABLE;


LPCSTR strcpystr(LPCSTR pszStr, LPCSTR pszSep, LPSTR pszTokOut);

LPSTR strncpyz(LPSTR pszDest, LPCSTR pszSource, size_t count);

HRESULT TempFileName(LPSTR szFN);

BOOL CompressFile(CMemFile &SourceFile, LPCSTR pszCompressName);

BOOL ReadKeyFromEncFile(LPCSTR pszFN, LPCSTR pszPassword, PBYTE  pKeyBuffer, DWORD cbKeyBuffer, BOOL SymKey);

BOOL ReadPassword(LPCSTR pszPrompt, LPSTR pszPassword);

BOOL IsEncKeyFile(LPCSTR pszFN);

VOID BuildFilename(LPSTR pszFullFN, LPCSTR pszPath, LPCSTR pszFN);

VOID DumpBytes(LPCSTR pszLabel, PBYTE pbData, DWORD dwDataLen);


#endif // _UTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\vctools\pdb6\langapi\include\bsc.h ===
//
// bsc.h
//
// interface to browser information in a .PDB file
//

#ifndef __BSC_INCLUDED__
#define __BSC_INCLUDED__

#include <pdb.h>

typedef ULONG  IINST;
typedef ULONG  IREF;
typedef ULONG  IDEF;
typedef USHORT IMOD;

#define irefNil  ((IREF)-1)
#define idefNil  ((IDEF)-1)
#define iinstNil ((IINST)-1)

#define HTARGET ULONG

// The constant IINST value for the "Globals" class
#define IINST_GLOBALS	0xFFFF0001
#define isTheGlobalIinst(iinst) ((iinst) == IINST_GLOBALS)

typedef USHORT LINE;
typedef BYTE   TYP;
typedef USHORT ATR;
typedef ULONG MBF;

enum OPERATION
{
	addOp,
	delOp,
	changeOp,
	changeIinstOp,
	refreshAllOp,
	noOp
};

struct IinstInfo
{
	IINST m_iinst;
	SZ_CONST m_szName; // REVIEW: must be deleted (use Ni instead)!
	NI	m_ni; 
};

struct NiQ
{
    IINST m_iinstOld;
	IinstInfo m_iInfoNew;
	OPERATION m_op;
	TYP		m_typ;
};

typedef BOOL (*pfnNotifyChange) (NiQ * rgQ, ULONG cQ, HTARGET hTarget);

#define OUT

PdbInterface Bsc
{
	// open by name or by .pdb 
	static  PDBAPI(BOOL) open(PDB* ppdb, OUT Bsc** ppbsc);
	static 	PDBAPI(BOOL) open(SZ szName, OUT Bsc** ppbsc);
	virtual BOOL close() pure;

	// primitives for getting the information that underlies a handle
	virtual BOOL iinstInfo(IINST iinst, OUT SZ *psz, OUT TYP *ptyp, OUT ATR *patr) pure;
	virtual BOOL irefInfo(IREF iref, OUT SZ *pszModule, OUT LINE *piline) pure;
	virtual BOOL idefInfo(IDEF idef, OUT SZ *pszModule, OUT LINE *piline) pure;
	virtual BOOL imodInfo(IMOD imod, OUT SZ *pszModule) pure;
	virtual SZ   szFrTyp(TYP typ) pure;
	virtual SZ   szFrAtr(ATR atr) pure;

	// primitives for managing object instances (iinst)
	virtual BOOL getIinstByvalue(SZ sz, TYP typ, ATR atr, OUT IINST *piinst) pure;
	virtual BOOL getOverloadArray(SZ sz, MBF mbf, OUT IINST **ppiinst, OUT ULONG *pciinst) pure;	
	virtual BOOL getUsedByArray(IINST iinst, MBF mbf, OUT IINST **ppiinst, OUT ULONG *pciinst) pure;
	virtual BOOL getUsesArray(IINST iinst, MBF mbf, OUT IINST **ppiinst, OUT ULONG *pciinst) pure;
	virtual BOOL getBaseArray(IINST iinst, OUT IINST **ppiinst, OUT ULONG *pciinst) pure;
	virtual BOOL getDervArray(IINST iinst, OUT IINST **ppiinst, OUT ULONG *pciinst)  pure;
	virtual BOOL getMembersArray(IINST iinst, MBF mbf, OUT IINST **ppiinst, OUT ULONG *pciinst) pure;

	// primitives for getting definition and reference information	
	virtual BOOL getDefArray(IINST iinst, OUT IREF **ppidef, OUT ULONG *pciidef) pure;
	virtual BOOL getRefArray(IINST iinst, OUT IREF **ppiref, OUT ULONG *pciiref) pure;

	// primitives for managing source module contents
	virtual BOOL getModuleContents(IMOD imod, MBF mbf, OUT IINST **ppiinst, OUT ULONG *pciinst) pure;
	virtual BOOL getModuleByName(SZ sz, OUT IMOD *pimod) pure;
	virtual BOOL getAllModulesArray(OUT IMOD **ppimod, OUT ULONG *pcimod) pure;
	
	// call this when a computed array is no longer required
	virtual void disposeArray(void *pAnyArray) pure;

	// call this to get a pretty form of a decorated name	
	virtual SZ  formatDname(SZ szDecor) pure;
	
	// call this to do category testing on instances
	virtual BOOL fInstFilter(IINST iinst, MBF mbf) pure;

	// primitives for converting index types
	virtual IINST iinstFrIref(IREF) pure;
	virtual IINST iinstFrIdef(IDEF) pure;
	virtual IINST iinstContextIref(IREF) pure;

	// general size information
	virtual	BOOL getStatistics(struct BSC_STAT *) pure;
	virtual	BOOL getModuleStatistics(IMOD, struct BSC_STAT *) pure;

	// case sensitivity functions
	virtual BOOL fCaseSensitive() pure;
	virtual BOOL setCaseSensitivity(BOOL) pure;

	// handy common queries which can be optimized
	virtual BOOL getAllGlobalsArray(MBF mbf, OUT IINST **ppiinst, OUT ULONG *pciinst) pure;
	virtual BOOL getAllGlobalsArray(MBF mbf, OUT IinstInfo **ppiinstinfo, OUT ULONG *pciinst) pure;

	// needed for no compile browser
	// get parameters (iinst must be a function type)
	virtual SZ  getParams (IINST iinst) pure;
	virtual USHORT getNumParam (IINST iinst) pure;
	virtual SZ getParam (IINST iinst, USHORT index) pure;
	// get return type/variable type
	virtual SZ  getType (IINST iinst) pure;
	// register call back for notification
	// THIS SHOULD BE DELETED SOON!
	virtual BOOL regNotify (pfnNotifyChange pNotify) pure;
	// register to make sure that NCB will create change queue
	virtual BOOL regNotify () pure;
	virtual BOOL getQ (OUT NiQ ** ppQ, OUT ULONG * pcQ) pure;
	virtual BOOL checkParams (IINST iinst, SZ * pszParam, ULONG cParam) pure;
	virtual BOOL fHasMembers (IINST iinst, MBF mbf) pure;
	
	// needed for class view for optimization
	virtual SZ szFrNi (NI ni) pure;
	virtual BOOL niFrIinst (IINST iinst, NI *ni) pure;
	virtual BOOL lock() pure;
	virtual BOOL unlock() pure;
};

struct BSC_STAT
{
	ULONG	cDef;
	ULONG	cRef;
	ULONG	cInst;
	ULONG	cMod;
	ULONG	cUseLink;
	ULONG	cBaseLink;
};


// CBSCLock
//
// Note, Bsc::lock returns BOOL, however, from current usage, the result is never tested, so
// this class assumes it need not be tested.
//

class CBSCLock
{
private :

	Bsc * const m_pBsc;

public :

	CBSCLock(Bsc * const pBsc) : m_pBsc(pBsc)	{ m_pBsc->lock();	}
	~CBSCLock(void)								{ m_pBsc->unlock();	}
};


// these are the bit values for Bsc::instInfo()

// this is the type part of the result, it describes what sort of object
// we are talking about.  Note the values are sequential -- the item will
// be exactly one of these things
//

#define INST_TYP_FUNCTION       0x01
#define INST_TYP_LABEL          0x02
#define INST_TYP_PARAMETER      0x03
#define INST_TYP_VARIABLE       0x04
#define INST_TYP_CONSTANT       0x05
#define INST_TYP_MACRO          0x06
#define INST_TYP_TYPEDEF        0x07
#define INST_TYP_STRUCNAM       0x08
#define INST_TYP_ENUMNAM        0x09
#define INST_TYP_ENUMMEM        0x0A
#define INST_TYP_UNIONNAM       0x0B
#define INST_TYP_SEGMENT        0x0C
#define INST_TYP_GROUP          0x0D
#define INST_TYP_PROGRAM        0x0E
#define INST_TYP_CLASSNAM       0x0F
#define INST_TYP_MEMFUNC        0x10
#define INST_TYP_MEMVAR         0x11
#define INST_TYP_INCL           0x12
#define INST_TYP_MSGMAP         0x13
#define INST_TYP_MSGITEM        0x14
#define INST_TYP_DIALOGID       0x15 // dialog ID for MFC
// idl stuff
#define INST_TYP_IDL_ATTR       0x16 // idl attributes are stored as iinst
#define INST_TYP_IDL_COCLASS    0x17
#define INST_TYP_IDL_IFACE      0x18
#define INST_TYP_IDL_DISPIFACE  0x19
#define INST_TYP_IDL_LIBRARY    0x1A
#define	INST_TYP_IDL_MODULE     0x1B
#define INST_TYP_IDL_IMPORT     0x1C
#define INST_TYP_IDL_IMPORTLIB  0x1D
#define INST_TYP_IDL_MFCCOMMENT 0x1E // idl interface/dispinterface can have mfc comment
// java stuff
#define INST_TYP_JAVA_IFACE     0x1F // java (NOT COM) interfaces
// 0x20 to 0x30 left for Java
// some more C++ stuff
#define INST_TYP_TEMPLATE       0x31
#define INST_TYP_NAMESPACE      0x32
#define INST_TYP_IMPORT         0x33
#define INST_TYP_BASECLASS      0x34
#define INST_TYP_ATTRIBUTE      0x35

// these are the attributes values, they describes the storage
// class and/or scope of the instance.  Any combination of the bits
// might be set by some language compiler, but there are some combinations
// that don't make sense.

#define INST_ATR_LOCAL       0x001
#define INST_ATR_STATIC      0x002
#define INST_ATR_SHARED      0x004
#define INST_ATR_NEAR        0x008
#define INST_ATR_COMMON      0x010
#define INST_ATR_DECL_ONLY   0x020
#define INST_ATR_PUBLIC      0x040
#define INST_ATR_NAMED       0x080
#define INST_ATR_MODULE      0x100
#define INST_ATR_VIRTUAL     0x200
#define INST_ATR_PRIVATE     0x400
#define INST_ATR_PROTECT     0x800

#define IMODE_VIRTUAL        0x001
#define IMODE_PRIVATE        0x002
#define IMODE_PUBLIC         0x004
#define IMODE_PROTECT        0x008

#define mbfNil       0x000
#define mbfVars      0x001
#define mbfFuncs     0x002
#define mbfMacros    0x004
#define mbfTypes     0x008
#define mbfClass     0x010
#define mbfIncl      0x020
#define mbfMsgMap    0x040
#define mbfDialogID  0x080
#define mbfLibrary   0x100
#define mbfImport    0x200
#define mbfTemplate  0x400
#define mbfNamespace 0x800
#define mbfAll       0xFFF

// BOB = browser object, general index holder 

typedef ULONG BOB;

#define bobNil 0L

typedef USHORT CLS;

#define clsMod  1
#define clsInst 2
#define clsRef  3
#define clsDef  4

#define BobFrClsIdx(cls, idx)  ((((ULONG)(cls)) << 28) | (idx))
#define ClsOfBob(bob)	(CLS)((bob) >> 28)

#define ImodFrBob(bob)	((IMOD) ((bob) & 0xfffffffL))
#define IinstFrBob(bob)	((IINST)((bob) & 0xfffffffL))
#define IrefFrBob(bob)	((IREF) ((bob) & 0xfffffffL))
#define IdefFrBob(bob)	((IDEF) ((bob) & 0xfffffffL))

#define BobFrMod(x)  (BobFrClsIdx(clsMod,  (x)))
#define BobFrInst(x) (BobFrClsIdx(clsInst, (x)))
#define BobFrRef(x)  (BobFrClsIdx(clsRef,  (x)))
#define BobFrDef(x)  (BobFrClsIdx(clsDef,  (x)))

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\vctools\pdb6\langapi\include\compsym.h ===
#pragma once
#ifndef _COMPSYM_H_
#define _COMPSYM_H_

#if !defined(PdbInterface)
#define PdbInterface struct
#endif

#ifndef IMPORT_EXPORT
#ifndef OBJFILE_IMPL
#define IMPORT_EXPORT __declspec(dllimport)
PdbInterface   ObjectCode;
typedef PdbInterface ObjectCode        ObjectCode;
#else
#define IMPORT_EXPORT __declspec(dllexport)
#endif
#endif

PdbInterface   FunctionSymbols;
PdbInterface   EnumStackSyms;
PdbInterface   StackVariable;

typedef PdbInterface FunctionSymbols   FunctionSymbols;
typedef PdbInterface EnumStackSyms     EnumStackSyms;
typedef PdbInterface StackVariable     StackVariable;

#define COMPSYMAPI __cdecl

#ifdef __cplusplus

// C++ Binding

PdbInterface FunctionSymbols {
    IMPORT_EXPORT static bool COMPSYMAPI
    get( char* szName, ObjectCode* pobj, FunctionSymbols** ppfsyms );

    IMPORT_EXPORT static bool COMPSYMAPI
    get( RefSec& rsec, FunctionSymbols** ppfsyms );

    virtual bool  FGetEnumLocals ( EnumStackSyms ** ) const pure;
    virtual bool  FGetEnumParams ( EnumStackSyms ** ) const pure;
    virtual bool  FGetFrameInfo(  
        unsigned long*  cbFrame, 
        unsigned long*  cbPad,
        unsigned long*  offPad ) const pure;
    virtual void release() pure;
    virtual void Dump() const pure;
};

// stack variable enumerator
PdbInterface EnumStackSyms : public Enum {
    virtual void get( StackVariable ** const ) pure;
};

PdbInterface StackVariable
{
    virtual long offBP() const pure;
    virtual unsigned long typeIndex() const pure;
    virtual unsigned long name( char* szName ) const pure;// if szName ==0 return length, then call again with buffer
    virtual void release() pure;
    virtual void Dump() const pure;
};

#endif  // __cplusplus

// ANSI C Binding

#ifdef __cplusplus
extern "C" {
#endif

IMPORT_EXPORT
BOOL COMPSYMAPI ObjectCodeGet(ObjectCode** ppobj, 
                              DWORD dwMachineTypeExpected, 
                              char* szFileName );
IMPORT_EXPORT
void COMPSYMAPI OCRelease( ObjectCode* pobj );

IMPORT_EXPORT 
BOOL COMPSYMAPI FuncSymsGet(char* szName, ObjectCode* pobj, FunctionSymbols** ppfsyms );
IMPORT_EXPORT 
BOOL COMPSYMAPI FSGetFrameInfo(FunctionSymbols* pfuncs, 
                               unsigned long*  cbFrame, 
                               unsigned long*  cbPad,
                               unsigned long*  offPad);
IMPORT_EXPORT 
BOOL COMPSYMAPI FSGetEnumParams(FunctionSymbols* pfuncs, 
                                EnumStackSyms** ppesv);
IMPORT_EXPORT 
BOOL COMPSYMAPI FSGetEnumLocals(FunctionSymbols* pfuncs, 
                                EnumStackSyms** ppesv);
IMPORT_EXPORT 
void COMPSYMAPI FSRelease(FunctionSymbols* pfuncs);

IMPORT_EXPORT 
void COMPSYMAPI ESVRelease(EnumStackSyms* pesv);
IMPORT_EXPORT 
void COMPSYMAPI ESVReset(EnumStackSyms* pesv);
IMPORT_EXPORT 
BOOL COMPSYMAPI ESVNext(EnumStackSyms* pesv);
IMPORT_EXPORT 
void COMPSYMAPI ESVGet(EnumStackSyms* pesv, 
            StackVariable **ppsv);

IMPORT_EXPORT 
long COMPSYMAPI SVOffBP(StackVariable * psv);
IMPORT_EXPORT 
unsigned long COMPSYMAPI SVTypeIndex(StackVariable * psv);
IMPORT_EXPORT 
unsigned long COMPSYMAPI SVName(StackVariable * psv, 
                                char* szName ); // if szName ==0 return length, then call again with buffer
IMPORT_EXPORT 
void COMPSYMAPI SVRelease(StackVariable * psv);

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\vctools\pdb6\langapi\include\crefobj.h ===
/*
 * CRefCountedObj
 *
 */

#pragma once

#if !defined(_CRefCountedObj_h)
#define _CRefCountedObj_h

#if defined(_DEBUG)
#define	Debug(x)	x
#else
#define	Debug(x)
#endif

// handles ref counted garbage collection and dyncasting

class CRefCountedObj {
private:
    unsigned	_cUses;

public:

    CRefCountedObj() {
        _cUses = 0;
        }

	// copy ctor, does not copy usage count of object being copied from
	CRefCountedObj ( const CRefCountedObj & ) {
		_cUses = 0;
		}

    // virtual dtor should cause all descendents of CRefCountedObj have to have a virtual dtor
    virtual ~CRefCountedObj() { }

	CRefCountedObj & operator= ( const CRefCountedObj & ) {
		return *this;
		}

	unsigned CUses() {
		return _cUses;
		}

    void Use() {
        _cUses++;
        }

    bool FUnUse() {
        return !(--_cUses);
        }
    };

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\vctools\pdb6\langapi\include\comenvi.h ===
#ifndef __COMENVI_H__
#define __COMENVI_H__

//
// Class to interpret a buffer containing a list of null
// strings. List is terminated with a 0.
//

template <class T>
inline const T* EndStr( const T* sz );

template <class T>
class StrList   // input must be formatted correctly
{
public:
    StrList( const T* pStart )
        : m_first( pStart )
    {
        for ( m_end = pStart; m_end != 0 && *m_end != 0; m_end = EndStr( m_end ) )
            ;
    }

    unsigned long Count() const {
        unsigned long i=0;
        for ( iterator it = begin(); it != end(); ++it )
            ++i;
        return i;
    }

    typedef const T* _Nodeptr;

    class iterator  // based on STL forward iterator
    {
    public:
	    iterator()
		    {}
	    iterator(_Nodeptr _P)
		    : _Ptr(_P) {}
	    const T& operator*() const
		    {return *_Ptr; }
//	    const T* operator->() const
//		    {return (&**this); }
	    iterator& operator++()
		    {_Ptr = EndStr( _Ptr );
		    return (*this); }
	    iterator operator++(int)
		    {iterator _Tmp = *this;
		    ++*this;
		    return (_Tmp); }
	    bool operator==(const iterator& _X) const
		    {return (_Ptr == _X._Ptr); }
	    bool operator!=(const iterator& _X) const
		    {return (!(*this == _X)); }
	    _Nodeptr _Mynode() const
		    {return (_Ptr); }
    private:
        _Nodeptr _Ptr;
    };

    iterator begin() { return iterator( m_first ); }
    iterator end() { return iterator( m_end ); }
    iterator begin() const { return iterator( m_first ); }
    iterator end() const { return iterator( m_end ); }

    bool empty() const { return begin() == end(); }

private:

    const T* m_first;
    const T* m_end;
};

typedef StrList<_TCHAR> tcStrList;
inline const _TCHAR* EndStr( const _TCHAR* sz ) { return sz+_tcslen(sz)+1; }

//
//	Class to interpret a buffer containing environment data
//
//  Format:
//			[<tag>'\0'<value>'\0']*
//			'\0'
//
//	The environ contains a list of 0 or more tag-value pairs,
//  each of which is a '\0' terminated string. A '\0' terminates
//  the entire list. Thus the trivial environ is a single '\0'.
//
class StrEnviron
{
public:
    StrEnviron( const _TCHAR* pStart, const _TCHAR* pEnd = 0 )
        : m_strlist( pStart )
    {
        assert( pEnd == 0 || &*m_strlist.end() <= pEnd );
        assert( m_strlist.Count() % 2 == 0 );
        // REVIEW: how about some way to test these in release?
    }
    
    const _TCHAR* szValueForTag( const _TCHAR* szTag ) const {
        if ( szTag != 0 ) {
            tcStrList::iterator itEnd = m_strlist.end();
            for ( tcStrList::iterator it = m_strlist.begin(); it != itEnd; ++it )
            {
                assert( *it != 0 );
                if ( _tcscmp( &*it++, szTag ) == 0 ) {
                    return &*(it);
                }
            }
        }
        return 0;
    }

    bool empty() const { return m_strlist.empty(); }
    unsigned long Count() const { return m_strlist.Count()/2; }
#ifdef _OSTREAM_
    void Dump( ostream& o )
    {
        tcStrList::iterator itEnd = m_strlist.end();
        for ( tcStrList::iterator it = m_strlist.begin(); it != itEnd; ++it ) {
            o << &*it++ << " " << &*it << '\n';
        }
    }
#endif
private:
    tcStrList m_strlist;
};

//
// Class to interpret the environment data in a COMPILESYM record
//
// This field contains an ST followed by an environment
//
class CompEnviron: public StrEnviron
{
public:
    CompEnviron( const unsigned char* st, const unsigned char* pEnd ) 
        : StrEnviron( st + *st + 1 < pEnd  
        ? reinterpret_cast< const char* >( st ) + *st + 1 
        : 0 )
    {}
};

#define ENC_CWD "cwd" /* <the current working directory>*/
#define ENC_CL  "cl"  /*<full pathname to cl.exe> */
#define ENC_SRC "src" /*<full pathname to the source file>*/
#define ENC_CMD "cmd" /*<command line to reinvoke cl.exe with for an edit-n-continue recompile> */



#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\vctools\pdb6\langapi\include\cpdguid.h ===
//------------------------------------------------------------------------------
// CPDGUID.H
//------------------------------------------------------------------------------

// {DD669B20-BF1D-11cf-A45D-00A0C905428A}
DEFINE_GUID(IID_ICPDatabase, 0xdd669b20, 0xbf1d, 0x11cf, 0xa4, 0x5d, 0x0, 0xa0, 0xc9, 0x5, 0x42, 0x8a);

// {DD669B21-BF1D-11cf-A45D-00A0C905428A}
DEFINE_GUID(IID_IPackage, 0xdd669b21, 0xbf1d, 0x11cf, 0xa4, 0x5d, 0x0, 0xa0, 0xc9, 0x5, 0x42, 0x8a);

// {DD669B22-BF1D-11cf-A45D-00A0C905428A}
DEFINE_GUID(IID_IClass, 0xdd669b22, 0xbf1d, 0x11cf, 0xa4, 0x5d, 0x0, 0xa0, 0xc9, 0x5, 0x42, 0x8a);

// {DD669B23-BF1D-11cf-A45D-00A0C905428A}
DEFINE_GUID(IID_IInputStream, 0xdd669b23, 0xbf1d, 0x11cf, 0xa4, 0x5d, 0x0, 0xa0, 0xc9, 0x5, 0x42, 0x8a);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\vctools\pdb6\langapi\include\cpdbase.h ===
//------------------------------------------------------------------------------
// CPDBASE.H
//
// Definitions of classes and interfaces used for the "Class Path Database"
//------------------------------------------------------------------------------
#ifndef _CPDBASE_INCLUDED
#define _CPDBASE_INCLUDED

#include "clstypes.h"
#include "cpdguid.h"

interface   ICPDatabase;
interface   IPackage;
interface   IClass;
interface   IInputStream;

typedef ICPDatabase     *LPCPDATABASE;
typedef IPackage        *LPPACKAGE;
typedef IClass          *LPCLASS;
typedef IInputStream    *LPINPUTSTREAM;


//------------------------------------------------------------------------------
// ICPDatabase
//
// This interface is the "entry point" to the class database.  It is used to
// configure the classpath, and to find specific classes/packages (or get the
// entire list of them) in the "root" of the CLASSPATH.  It also holds central
// functionality such as releasing arrays/memory allocated by this and other
// interfaces dealing with the class path database.
//------------------------------------------------------------------------------
#undef INTERFACE
#define INTERFACE ICPDatabase

DECLARE_INTERFACE_(ICPDatabase, IUnknown)
{
	// IUnknown methods
	
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;

	// ICPDatabase methods
	
	// CLASSPATH management (note:  GetClassPath returns allocated data -- use FreeMemory to release)
	STDMETHOD(SetClassPath)(THIS_ PCSTR pszClassPath) PURE;
	STDMETHOD(AppendClassPath)(THIS_ PCSTR pszAppendPath) PURE;
	STDMETHOD(PrependClassPath)(THIS_ PCSTR pszPrependPath) PURE;
	STDMETHOD(RemoveClassPath)(THIS_ PCSTR pszRemovePath) PURE;
	STDMETHOD(GetClassPath)(THIS_ PSTR *ppszClassPath) PURE;
	
	// Archive locking means speed improvement.  It also means any .ZIP or other
	// single-file archives that are classpath roots will remain open throughout
	// use of the database, or until unlocked
	STDMETHOD_(VOID, LockArchives)(THIS) PURE;
	STDMETHOD_(VOID, UnlockArchives)(THIS) PURE;
	
	// Find specific packages or classes.  Note that the IPackage or IClass pointers returned
	// here should be Release()'d
	STDMETHOD(FindPackage)(THIS_ PCSTR pszPackageName, LPPACKAGE *ppPackage) PURE;
	STDMETHOD(FindClass)(THIS_ PCSTR pszClassName, LPCLASS *ppClass) PURE;
	
	// Given a file name, create a class interface
	STDMETHOD(GetClass)(THIS_ PCSTR pszClassFileName, LPCLASS *ppClass) PURE;
	
	// Package/class array access.  Release these arrays with appropriate Release*Array()
	// members below -- do NOT call Release() on each element!
	STDMETHOD(GetPackageArray)(THIS_ LPPACKAGE **pppPackages, LPINT piCount) PURE;
	STDMETHOD(GetClassArray)(THIS_ LPCLASS **pppClasses, LPINT piCount) PURE;
	
	// Find all occurances of a specific class name, searching all packages.  Note that
	// an array is returned, which must also be freed using ReleaseClassArray().
	STDMETHOD(GetClassArray)(THIS_ PCSTR pszClassName, LPCLASS **pppClasses, LPINT piCount) PURE;
	
	// Array release mechanism.  Note:  These release functions should be used to
	// release arrays obtained thru IPackage::GetPackageArray/GetClassArray as well.
	// Elements of these arrays should NOT be Release()'d individually unless they
	// are AddRef()'d first (for individual extension of their lifetimes)
	STDMETHOD(ReleasePackageArray)(THIS_ LPPACKAGE *ppPackages) PURE;
	STDMETHOD(ReleaseClassArray)(THIS_ LPCLASS *ppClasses) PURE;
	
    // Allocated memory release mechanism -- note that this should be used to
    // free memory returned by members of this interface as well as IPackage and
    // IClass that are noted as returning allocated memory
    STDMETHOD(FreeMemory)(THIS_ PVOID pData) PURE;
};


//------------------------------------------------------------------------------
// IPackage
//
// This interface is used to represent a package on the CLASSPATH, and its
// primary purpose is to provide subpackage and class finding/iteration.
//------------------------------------------------------------------------------
#undef INTERFACE
#define INTERFACE IPackage

DECLARE_INTERFACE_(IPackage, IUnknown)
{
	// IUnknown methods
	
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;

    // IPackage methods

	// Find specific packages or classes.  Note that the IPackage or IClass pointers returned
	// here should be Release()'d
	STDMETHOD(FindPackage)(THIS_ PCSTR pszPackageName, LPPACKAGE *ppPackage) PURE;
	STDMETHOD(FindClass)(THIS_ PCSTR pszClassName, LPCLASS *ppClass) PURE;

	// Package/class array access.  Release these arrays with appropriate Release*Array()
	// members in ICPDatabase -- do NOT call Release() on each element!
	STDMETHOD(GetPackageArray)(THIS_ LPPACKAGE **pppPackages, LPINT piCount) PURE;
	STDMETHOD(GetClassArray)(THIS_ LPCLASS **pppClasses, LPINT piCount) PURE;
	
    // Package name
    STDMETHOD_(PCSTR, GetName)(THIS) PURE;

    // Full name (i.e. if this is package lang, full name is "java.lang")
    // (allocated -- use ICPDatabase::FreeMemory to release)
    STDMETHOD(GetFullName)(THIS_ PSTR *pszFullName) PURE;
};

//------------------------------------------------------------------------------
// IClass
//
// This interface represents a class found on the CLASSPATH.  Provides access to
// all information about the class.
//------------------------------------------------------------------------------
#undef INTERFACE
#define INTERFACE IClass

DECLARE_INTERFACE_(IClass, IUnknown)
{
	// IUnknown methods
	
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;

    // IClass methods

    // Class name
    STDMETHOD_(PCSTR, GetName)(THIS) PURE;

    // Qualified (dotted) name.  Includes package name.
    // (allocated -- use ICPDatabase::FreeMemory to release)
    STDMETHOD(GetQualifiedName)(THIS_ PSTR *pszQualifiedName) PURE;

    // File name.  If this class is represented by a physical file on disk
    // (as opposed to one found in an archive or elsewhere) the full path name
    // of that file can be obtained here.  E_FAIL is returned if not.
    // (allocated -- use ICPDatabase::FreeMemory to release)
    STDMETHOD(GetFileName)(THIS_ PSTR *pszFileName) PURE;

    // Source file name.  If this class is represented by a physical file on
    // disk, the full path name of its source file can be obtained here.  E_FAIL
    // is returned if the class doesn't have a source that is represented by
    // a single disk file (i.e. the source might be in an archive as well, in
    // which case a full path to it doesn't make sense).  Note:  The class
    // information itself is opened and the attributes are searched to determine
    // the source file name.  In the interesting case where only the .java file
    // is found along the class path (.class file doesn't exist), the full path
    // to that .java file is returned, even though it *might not* necessarily
    // generate an output with the same name.  Note also that the file does not
    // have to exist for this to succeed.
    // (allocated -- use ICPDatabase::FreeMemory to release)
    STDMETHOD(GetSourceFileName)(THIS_ PSTR *pszSourceName) PURE;

    // "Moniker" -- a somewhat-human-readable name that describes where this
    // class originates.  Disk files are just the absolute file name (same as
    // GetFileName), archive files might be something that looks like
    // "archive.zip(dir1\dir2\file.ext)", etc...
    // (allocated -- use ICPDatabase::FreeMemory to release)
    STDMETHOD(GetMoniker)(THIS_ PSTR *pszMoniker) PURE;

    // Ditto for source
    // (allocated -- use ICPDatabase::FreeMemory to release)
    STDMETHOD(GetSourceMoniker)(THIS_ PSTR *pszMoniker) PURE;

    // Dependency checking between source and output.  This method returns TRUE
    // only if the class's source file is available as a single disk file, and
    // either:
    //  1) The .class file doesn't exist, or
    //  2) The .class file is older than the .java file
    // Returns FALSE in all other cases.
    STDMETHOD_(BOOL, IsOutOfDate)(THIS) PURE;

    // Direct class data access.  If this class is represented by a stream of
    // bytes in the class file format, an input stream interface is returned
    // for direct access to that stream.  E_FAIL is returned if no such file
    // exists.
    STDMETHOD(GetClassInputStream)(THIS_ LPINPUTSTREAM *ppStream) PURE;

    // Source file stream access.  Note that this may succeed when
    // GetSourceFileName() may not, since the source may be found in an archive
    STDMETHOD(GetSourceInputStream)(THIS_ LPINPUTSTREAM *ppStream) PURE;

    // Class data access.  Availability of class data depends on "completeness"
    // of the Open() call.  If fFullOpen is TRUE, all data is available; if
    // FALSE, you can get the version info and access flags, and queries for
    // other data will return 0/NULL.
    //
    // NOTE:  Everything returned from these methods is maintained by the class,
    // and does NOT need to be released or freed.  Happens automatically on Close().
    STDMETHOD(Open)(THIS_ BOOL fFullOpen = TRUE) PURE;
    STDMETHOD_(VOID, Close)(THIS) PURE;
    STDMETHOD_(U2, GetMajorVersion)(THIS) PURE;
    STDMETHOD_(U2, GetMinorVersion)(THIS) PURE;
    STDMETHOD_(U2, GetCPCount)(THIS) PURE;
    STDMETHOD_(LPCPOOLINFO, GetCPArray)(THIS) PURE;
    STDMETHOD_(U2, GetAccessFlags)(THIS) PURE;
    STDMETHOD_(U2, GetThisClass)(THIS) PURE;
    STDMETHOD_(U2, GetSuperClass)(THIS) PURE;
    STDMETHOD_(U2, GetInterfaceCount)(THIS) PURE;
    STDMETHOD_(U2 *, GetInterfaceArray)(THIS) PURE;
    STDMETHOD_(U2, GetFieldCount)(THIS) PURE;
    STDMETHOD_(LPFIELDINFO, GetFieldArray)(THIS) PURE;
    STDMETHOD_(U2, GetMethodCount)(THIS) PURE;
    STDMETHOD_(LPMETHODINFO, GetMethodArray)(THIS) PURE;
    STDMETHOD_(U2, GetAttributeCount)(THIS) PURE;
    STDMETHOD_(LPATTRINFO, GetAttributeList)(THIS) PURE;
};

//------------------------------------------------------------------------------
// IInputStream
//
// Abstraction over a file, or a section of an archive file, or anything else
// that needs to "look like" a stream of bytes w/ random access capability.
//------------------------------------------------------------------------------
#undef INTERFACE
#define INTERFACE IInputStream

typedef enum { SCP_FROMSTART = FILE_BEGIN, SCP_FROMCURRENT = FILE_CURRENT, SCP_FROMEND = FILE_END } POSRELATION;

DECLARE_INTERFACE_(IInputStream, IUnknown)
{
	// IUnknown methods
	
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;
	
	// IInputStream methods
	
	// Size of stream
	STDMETHOD_(LONG, GetSize)(THIS) PURE;
	
	// Current position (offset of next byte to be read)
	STDMETHOD_(LONG, GetCurrentPosition)(THIS) PURE;
	STDMETHOD(SetCurrentPosition)(THIS_ LONG iPos, POSRELATION iRel = SCP_FROMSTART) PURE;
	STDMETHOD_(BOOL, EndOfStream)(THIS) PURE;
	
	// Read from current position (piRead:  in=size of pDest, out=bytes read)
	STDMETHOD(Read)(THIS_ PVOID pDest, LONG *piRead) PURE;
	
	// Big-Endian number readers
	STDMETHOD(ReadU2)(THIS_ U2 *piValue) PURE;
	STDMETHOD(ReadU4)(THIS_ U4 *piValue) PURE;
};	


#endif // #ifndef _CPDBASE_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\vctools\pdb6\langapi\include\cvinfo.h ===
/***    cvinfo.h - Generic CodeView information definitions
 *
 *      Structures, constants, etc. for accessing and interpreting
 *      CodeView information.
 *
 */


/***    The master copy of this file resides in the langapi project.
 *      All Microsoft projects are required to use the master copy without
 *      modification.  Modification of the master version or a copy
 *      without consultation with all parties concerned is extremely
 *      risky.
 *
 *      When this file is modified, the corresponding documentation file
 *      omfdeb.doc in the langapi project must be updated.
 */

#ifndef _VC_VER_INC
#include "..\include\vcver.h"
#endif

#ifndef _CV_INFO_INCLUDED
#define _CV_INFO_INCLUDED

#ifdef  __cplusplus
#pragma warning ( disable: 4200 )
#endif

#ifndef __INLINE
#ifdef  __cplusplus
#define __INLINE inline
#else
#define __INLINE __inline
#endif
#endif

#pragma pack ( push, 1 )
typedef unsigned long   CV_uoff32_t;
typedef          long   CV_off32_t;
typedef unsigned short  CV_uoff16_t;
typedef          short  CV_off16_t;
typedef unsigned short  CV_typ16_t;
typedef unsigned long   CV_typ_t;
typedef unsigned short  _2BYTEPAD;

#if !defined (CV_ZEROLEN)
#define CV_ZEROLEN
#endif

#if !defined (FLOAT10)
#if defined(_M_I86)                    // 16 bit x86 supporting long double
typedef long double FLOAT10;
#else                                  // 32 bit w/o long double support
typedef struct FLOAT10
{
    char b[10];
} FLOAT10;
#endif
#endif


#define CV_SIGNATURE_C6         0L  // Actual signature is >64K
#define CV_SIGNATURE_C7         1L  // First explicit signature
#define CV_SIGNATURE_C11        2L  // C11 (vc5.x) 32-bit types
#if CC_LAZYSYMS
#define CV_SIGNATURE_LAZY       3L  // used only in PDB: see obj file for actual symbols
#define CV_SIGNATURE_RESERVED   4L  // All signatures from 4 to 64K are reserved
#else
#define CV_SIGNATURE_RESERVED   3L  // All signatures from 3 to 64K are reserved
#endif

#define CV_MAXOFFSET   0xffffffff

/**     CodeView Symbol and Type OMF type information is broken up into two
 *      ranges.  Type indices less than 0x1000 describe type information
 *      that is frequently used.  Type indices above 0x1000 are used to
 *      describe more complex features such as functions, arrays and
 *      structures.
 */




/**     Primitive types have predefined meaning that is encoded in the
 *      values of the various bit fields in the value.
 *
 *      A CodeView primitive type is defined as:
 *
 *      1 1
 *      1 089  7654  3  210
 *      r mode type  r  sub
 *
 *      Where
 *          mode is the pointer mode
 *          type is a type indicator
 *          sub  is a subtype enumeration
 *          r    is a reserved field
 *
 *      See Microsoft Symbol and Type OMF (Version 4.0) for more
 *      information.
 */


#define CV_MMASK        0x700       // mode mask
#define CV_TMASK        0x0f0       // type mask

// can we use the reserved bit ??
#define CV_SMASK        0x00f       // subtype mask

#define CV_MSHIFT       8           // primitive mode right shift count
#define CV_TSHIFT       4           // primitive type right shift count
#define CV_SSHIFT       0           // primitive subtype right shift count

// macros to extract primitive mode, type and size

#define CV_MODE(typ)    (((typ) & CV_MMASK) >> CV_MSHIFT)
#define CV_TYPE(typ)    (((typ) & CV_TMASK) >> CV_TSHIFT)
#define CV_SUBT(typ)    (((typ) & CV_SMASK) >> CV_SSHIFT)

// macros to insert new primitive mode, type and size

#define CV_NEWMODE(typ, nm)     ((CV_typ_t)(((typ) & ~CV_MMASK) | ((nm) << CV_MSHIFT)))
#define CV_NEWTYPE(typ, nt)     (((typ) & ~CV_TMASK) | ((nt) << CV_TSHIFT))
#define CV_NEWSUBT(typ, ns)     (((typ) & ~CV_SMASK) | ((ns) << CV_SSHIFT))



//     pointer mode enumeration values

typedef enum CV_prmode_e {
    CV_TM_DIRECT = 0,       // mode is not a pointer
    CV_TM_NPTR   = 1,       // mode is a near pointer
    CV_TM_FPTR   = 2,       // mode is a far pointer
    CV_TM_HPTR   = 3,       // mode is a huge pointer
    CV_TM_NPTR32 = 4,       // mode is a 32 bit near pointer
    CV_TM_FPTR32 = 5,       // mode is a 32 bit far pointer
    CV_TM_NPTR64 = 6,       // mode is a 64 bit near pointer
    CV_TM_NPTR128 = 7,      // mode is a 128 bit near pointer
} CV_prmode_e;




//      type enumeration values


typedef enum CV_type_e {
    CV_SPECIAL      = 0x00,         // special type size values
    CV_SIGNED       = 0x01,         // signed integral size values
    CV_UNSIGNED     = 0x02,         // unsigned integral size values
    CV_BOOLEAN      = 0x03,         // Boolean size values
    CV_REAL         = 0x04,         // real number size values
    CV_COMPLEX      = 0x05,         // complex number size values
    CV_SPECIAL2     = 0x06,         // second set of special types
    CV_INT          = 0x07,         // integral (int) values
    CV_CVRESERVED   = 0x0f,
} CV_type_e;




//      subtype enumeration values for CV_SPECIAL


typedef enum CV_special_e {
    CV_SP_NOTYPE    = 0x00,
    CV_SP_ABS       = 0x01,
    CV_SP_SEGMENT   = 0x02,
    CV_SP_VOID      = 0x03,
    CV_SP_CURRENCY  = 0x04,
    CV_SP_NBASICSTR = 0x05,
    CV_SP_FBASICSTR = 0x06,
    CV_SP_NOTTRANS  = 0x07,
    CV_SP_HRESULT   = 0x08,
} CV_special_e;




//      subtype enumeration values for CV_SPECIAL2


typedef enum CV_special2_e {
    CV_S2_BIT       = 0x00,
    CV_S2_PASCHAR   = 0x01          // Pascal CHAR
} CV_special2_e;





//      subtype enumeration values for CV_SIGNED, CV_UNSIGNED and CV_BOOLEAN


typedef enum CV_integral_e {
    CV_IN_1BYTE     = 0x00,
    CV_IN_2BYTE     = 0x01,
    CV_IN_4BYTE     = 0x02,
    CV_IN_8BYTE     = 0x03,
    CV_IN_16BYTE    = 0x04
} CV_integral_e;





//      subtype enumeration values for CV_REAL and CV_COMPLEX


typedef enum CV_real_e {
    CV_RC_REAL32    = 0x00,
    CV_RC_REAL64    = 0x01,
    CV_RC_REAL80    = 0x02,
    CV_RC_REAL128   = 0x03,
    CV_RC_REAL48    = 0x04
} CV_real_e;




//      subtype enumeration values for CV_INT (really int)


typedef enum CV_int_e {
    CV_RI_CHAR      = 0x00,
    CV_RI_INT1      = 0x00,
    CV_RI_WCHAR     = 0x01,
    CV_RI_UINT1     = 0x01,
    CV_RI_INT2      = 0x02,
    CV_RI_UINT2     = 0x03,
    CV_RI_INT4      = 0x04,
    CV_RI_UINT4     = 0x05,
    CV_RI_INT8      = 0x06,
    CV_RI_UINT8     = 0x07,
    CV_RI_INT16     = 0x08,
    CV_RI_UINT16    = 0x09
} CV_int_e;




// macros to check the type of a primitive

#define CV_TYP_IS_DIRECT(typ)   (CV_MODE(typ) == CV_TM_DIRECT)
#define CV_TYP_IS_PTR(typ)      (CV_MODE(typ) != CV_TM_DIRECT)
#define CV_TYP_IS_NPTR(typ)     (CV_MODE(typ) == CV_TM_NPTR)
#define CV_TYP_IS_FPTR(typ)     (CV_MODE(typ) == CV_TM_FPTR)
#define CV_TYP_IS_HPTR(typ)     (CV_MODE(typ) == CV_TM_HPTR)
#define CV_TYP_IS_NPTR32(typ)   (CV_MODE(typ) == CV_TM_NPTR32)
#define CV_TYP_IS_FPTR32(typ)   (CV_MODE(typ) == CV_TM_FPTR32)

#define CV_TYP_IS_SIGNED(typ)   (((CV_TYPE(typ) == CV_SIGNED) && CV_TYP_IS_DIRECT(typ)) || \
                                 (typ == T_INT1)  || \
                                 (typ == T_INT2)  || \
                                 (typ == T_INT4)  || \
                                 (typ == T_INT8)  || \
                                 (typ == T_INT16) || \
                                 (typ == T_RCHAR))

#define CV_TYP_IS_UNSIGNED(typ) (((CV_TYPE(typ) == CV_UNSIGNED) && CV_TYP_IS_DIRECT(typ)) || \
                                 (typ == T_UINT1) || \
                                 (typ == T_UINT2) || \
                                 (typ == T_UINT4) || \
                                 (typ == T_UINT8) || \
                                 (typ == T_UINT16))

#define CV_TYP_IS_REAL(typ)     ((CV_TYPE(typ) == CV_REAL)  && CV_TYP_IS_DIRECT(typ))

#define CV_FIRST_NONPRIM 0x1000
#define CV_IS_PRIMITIVE(typ)    ((typ) < CV_FIRST_NONPRIM)
#define CV_TYP_IS_COMPLEX(typ)  ((CV_TYPE(typ) == CV_COMPLEX)   && CV_TYP_IS_DIRECT(typ))
#define CV_IS_INTERNAL_PTR(typ) (CV_IS_PRIMITIVE(typ) && \
                                 CV_TYPE(typ) == CV_CVRESERVED && \
                                 CV_TYP_IS_PTR(typ))






// selected values for type_index - for a more complete definition, see
// Microsoft Symbol and Type OMF document




//      Special Types

typedef enum TYPE_ENUM_e {
    T_NOTYPE        = 0x0000,   // uncharacterized type (no type)
    T_ABS           = 0x0001,   // absolute symbol
    T_SEGMENT       = 0x0002,   // segment type
    T_VOID          = 0x0003,   // void
    T_HRESULT       = 0x0008,   // OLE/COM HRESULT
    T_PVOID         = 0x0103,   // near pointer to void
    T_PFVOID        = 0x0203,   // far pointer to void
    T_PHVOID        = 0x0303,   // huge pointer to void
    T_32PVOID       = 0x0403,   // 16:32 near pointer to void
    T_32PFVOID      = 0x0503,   // 16:32 far pointer to void
    T_64PVOID       = 0x0603,   // 64 bit pointer to void
    T_CURRENCY      = 0x0004,   // BASIC 8 byte currency value
    T_NBASICSTR     = 0x0005,   // Near BASIC string
    T_FBASICSTR     = 0x0006,   // Far BASIC string
    T_NOTTRANS      = 0x0007,   // type not translated by cvpack
    T_BIT           = 0x0060,   // bit
    T_PASCHAR       = 0x0061,   // Pascal CHAR


//      Character types


    T_CHAR          = 0x0010,   // 8 bit signed
    T_UCHAR         = 0x0020,   // 8 bit unsigned
    T_PCHAR         = 0x0110,   // near pointer to 8 bit signed
    T_PUCHAR        = 0x0120,   // near pointer to 8 bit unsigned
    T_PFCHAR        = 0x0210,   // far pointer to 8 bit signed
    T_PFUCHAR       = 0x0220,   // far pointer to 8 bit unsigned
    T_PHCHAR        = 0x0310,   // huge pointer to 8 bit signed
    T_PHUCHAR       = 0x0320,   // huge pointer to 8 bit unsigned
    T_32PCHAR       = 0x0410,   // 16:32 near pointer to 8 bit signed
    T_32PUCHAR      = 0x0420,   // 16:32 near pointer to 8 bit unsigned
    T_32PFCHAR      = 0x0510,   // 16:32 far pointer to 8 bit signed
    T_32PFUCHAR     = 0x0520,   // 16:32 far pointer to 8 bit unsigned
    T_64PCHAR       = 0x0610,   // 64 bit pointer to 8 bit signed
    T_64PUCHAR      = 0x0620,   // 64 bit pointer to 8 bit unsigned




//      really a character types

    T_RCHAR         = 0x0070,   // really a char
    T_PRCHAR        = 0x0170,   // 16:16 near pointer to a real char
    T_PFRCHAR       = 0x0270,   // 16:16 far pointer to a real char
    T_PHRCHAR       = 0x0370,   // 16:16 huge pointer to a real char
    T_32PRCHAR      = 0x0470,   // 16:32 near pointer to a real char
    T_32PFRCHAR     = 0x0570,   // 16:32 far pointer to a real char
    T_64PRCHAR      = 0x0670,   // 64 bit pointer to a real char



//      really a wide character types

    T_WCHAR         = 0x0071,   // wide char
    T_PWCHAR        = 0x0171,   // 16:16 near pointer to a wide char
    T_PFWCHAR       = 0x0271,   // 16:16 far pointer to a wide char
    T_PHWCHAR       = 0x0371,   // 16:16 huge pointer to a wide char
    T_32PWCHAR      = 0x0471,   // 16:32 near pointer to a wide char
    T_32PFWCHAR     = 0x0571,   // 16:32 far pointer to a wide char
    T_64PWCHAR      = 0x0671,   // 64 bit pointer to a wide char


//      8 bit int types


    T_INT1          = 0x0068,   // 8 bit signed int
    T_UINT1         = 0x0069,   // 8 bit unsigned int
    T_PINT1         = 0x0168,   // near pointer to 8 bit signed int
    T_PUINT1        = 0x0169,   // near pointer to 8 bit unsigned int
    T_PFINT1        = 0x0268,   // far pointer to 8 bit signed int
    T_PFUINT1       = 0x0269,   // far pointer to 8 bit unsigned int
    T_PHINT1        = 0x0368,   // huge pointer to 8 bit signed int
    T_PHUINT1       = 0x0369,   // huge pointer to 8 bit unsigned int

    T_32PINT1       = 0x0468,   // 16:32 near pointer to 8 bit signed int
    T_32PUINT1      = 0x0469,   // 16:32 near pointer to 8 bit unsigned int
    T_32PFINT1      = 0x0568,   // 16:32 far pointer to 8 bit signed int
    T_32PFUINT1     = 0x0569,   // 16:32 far pointer to 8 bit unsigned int
    T_64PINT1       = 0x0668,   // 64 bit pointer to 8 bit signed int
    T_64PUINT1      = 0x0669,   // 64 bit pointer to 8 bit unsigned int


//      16 bit short types


    T_SHORT         = 0x0011,   // 16 bit signed
    T_USHORT        = 0x0021,   // 16 bit unsigned
    T_PSHORT        = 0x0111,   // near pointer to 16 bit signed
    T_PUSHORT       = 0x0121,   // near pointer to 16 bit unsigned
    T_PFSHORT       = 0x0211,   // far pointer to 16 bit signed
    T_PFUSHORT      = 0x0221,   // far pointer to 16 bit unsigned
    T_PHSHORT       = 0x0311,   // huge pointer to 16 bit signed
    T_PHUSHORT      = 0x0321,   // huge pointer to 16 bit unsigned

    T_32PSHORT      = 0x0411,   // 16:32 near pointer to 16 bit signed
    T_32PUSHORT     = 0x0421,   // 16:32 near pointer to 16 bit unsigned
    T_32PFSHORT     = 0x0511,   // 16:32 far pointer to 16 bit signed
    T_32PFUSHORT    = 0x0521,   // 16:32 far pointer to 16 bit unsigned
    T_64PSHORT      = 0x0611,   // 64 bit pointer to 16 bit signed
    T_64PUSHORT     = 0x0621,   // 64 bit pointer to 16 bit unsigned




//      16 bit int types


    T_INT2          = 0x0072,   // 16 bit signed int
    T_UINT2         = 0x0073,   // 16 bit unsigned int
    T_PINT2         = 0x0172,   // near pointer to 16 bit signed int
    T_PUINT2        = 0x0173,   // near pointer to 16 bit unsigned int
    T_PFINT2        = 0x0272,   // far pointer to 16 bit signed int
    T_PFUINT2       = 0x0273,   // far pointer to 16 bit unsigned int
    T_PHINT2        = 0x0372,   // huge pointer to 16 bit signed int
    T_PHUINT2       = 0x0373,   // huge pointer to 16 bit unsigned int

    T_32PINT2       = 0x0472,   // 16:32 near pointer to 16 bit signed int
    T_32PUINT2      = 0x0473,   // 16:32 near pointer to 16 bit unsigned int
    T_32PFINT2      = 0x0572,   // 16:32 far pointer to 16 bit signed int
    T_32PFUINT2     = 0x0573,   // 16:32 far pointer to 16 bit unsigned int
    T_64PINT2       = 0x0672,   // 64 bit pointer to 16 bit signed int
    T_64PUINT2      = 0x0673,   // 64 bit pointer to 16 bit unsigned int




//      32 bit long types


    T_LONG          = 0x0012,   // 32 bit signed
    T_ULONG         = 0x0022,   // 32 bit unsigned
    T_PLONG         = 0x0112,   // near pointer to 32 bit signed
    T_PULONG        = 0x0122,   // near pointer to 32 bit unsigned
    T_PFLONG        = 0x0212,   // far pointer to 32 bit signed
    T_PFULONG       = 0x0222,   // far pointer to 32 bit unsigned
    T_PHLONG        = 0x0312,   // huge pointer to 32 bit signed
    T_PHULONG       = 0x0322,   // huge pointer to 32 bit unsigned

    T_32PLONG       = 0x0412,   // 16:32 near pointer to 32 bit signed
    T_32PULONG      = 0x0422,   // 16:32 near pointer to 32 bit unsigned
    T_32PFLONG      = 0x0512,   // 16:32 far pointer to 32 bit signed
    T_32PFULONG     = 0x0522,   // 16:32 far pointer to 32 bit unsigned
    T_64PLONG       = 0x0612,   // 64 bit pointer to 32 bit signed
    T_64PULONG      = 0x0622,   // 64 bit pointer to 32 bit unsigned




//      32 bit int types


    T_INT4          = 0x0074,   // 32 bit signed int
    T_UINT4         = 0x0075,   // 32 bit unsigned int
    T_PINT4         = 0x0174,   // near pointer to 32 bit signed int
    T_PUINT4        = 0x0175,   // near pointer to 32 bit unsigned int
    T_PFINT4        = 0x0274,   // far pointer to 32 bit signed int
    T_PFUINT4       = 0x0275,   // far pointer to 32 bit unsigned int
    T_PHINT4        = 0x0374,   // huge pointer to 32 bit signed int
    T_PHUINT4       = 0x0375,   // huge pointer to 32 bit unsigned int

    T_32PINT4       = 0x0474,   // 16:32 near pointer to 32 bit signed int
    T_32PUINT4      = 0x0475,   // 16:32 near pointer to 32 bit unsigned int
    T_32PFINT4      = 0x0574,   // 16:32 far pointer to 32 bit signed int
    T_32PFUINT4     = 0x0575,   // 16:32 far pointer to 32 bit unsigned int
    T_64PINT4       = 0x0674,   // 64 bit pointer to 32 bit signed int
    T_64PUINT4      = 0x0675,   // 64 bit pointer to 32 bit unsigned int




//      64 bit quad types


    T_QUAD          = 0x0013,   // 64 bit signed
    T_UQUAD         = 0x0023,   // 64 bit unsigned
    T_PQUAD         = 0x0113,   // near pointer to 64 bit signed
    T_PUQUAD        = 0x0123,   // near pointer to 64 bit unsigned
    T_PFQUAD        = 0x0213,   // far pointer to 64 bit signed
    T_PFUQUAD       = 0x0223,   // far pointer to 64 bit unsigned
    T_PHQUAD        = 0x0313,   // huge pointer to 64 bit signed
    T_PHUQUAD       = 0x0323,   // huge pointer to 64 bit unsigned
    T_32PQUAD       = 0x0413,   // 16:32 near pointer to 64 bit signed
    T_32PUQUAD      = 0x0423,   // 16:32 near pointer to 64 bit unsigned
    T_32PFQUAD      = 0x0513,   // 16:32 far pointer to 64 bit signed
    T_32PFUQUAD     = 0x0523,   // 16:32 far pointer to 64 bit unsigned
    T_64PQUAD       = 0x0613,   // 64 bit pointer to 64 bit signed
    T_64PUQUAD      = 0x0623,   // 64 bit pointer to 64 bit unsigned



//      64 bit int types


    T_INT8          = 0x0076,   // 64 bit signed int
    T_UINT8         = 0x0077,   // 64 bit unsigned int
    T_PINT8         = 0x0176,   // near pointer to 64 bit signed int
    T_PUINT8        = 0x0177,   // near pointer to 64 bit unsigned int
    T_PFINT8        = 0x0276,   // far pointer to 64 bit signed int
    T_PFUINT8       = 0x0277,   // far pointer to 64 bit unsigned int
    T_PHINT8        = 0x0376,   // huge pointer to 64 bit signed int
    T_PHUINT8       = 0x0377,   // huge pointer to 64 bit unsigned int

    T_32PINT8       = 0x0476,   // 16:32 near pointer to 64 bit signed int
    T_32PUINT8      = 0x0477,   // 16:32 near pointer to 64 bit unsigned int
    T_32PFINT8      = 0x0576,   // 16:32 far pointer to 64 bit signed int
    T_32PFUINT8     = 0x0577,   // 16:32 far pointer to 64 bit unsigned int
    T_64PINT8       = 0x0676,   // 64 bit pointer to 64 bit signed int
    T_64PUINT8      = 0x0677,   // 64 bit pointer to 64 bit unsigned int


//      128 bit octet types


    T_OCT           = 0x0014,   // 128 bit signed
    T_UOCT          = 0x0024,   // 128 bit unsigned
    T_POCT          = 0x0114,   // near pointer to 128 bit signed
    T_PUOCT         = 0x0124,   // near pointer to 128 bit unsigned
    T_PFOCT         = 0x0214,   // far pointer to 128 bit signed
    T_PFUOCT        = 0x0224,   // far pointer to 128 bit unsigned
    T_PHOCT         = 0x0314,   // huge pointer to 128 bit signed
    T_PHUOCT        = 0x0324,   // huge pointer to 128 bit unsigned

    T_32POCT        = 0x0414,   // 16:32 near pointer to 128 bit signed
    T_32PUOCT       = 0x0424,   // 16:32 near pointer to 128 bit unsigned
    T_32PFOCT       = 0x0514,   // 16:32 far pointer to 128 bit signed
    T_32PFUOCT      = 0x0524,   // 16:32 far pointer to 128 bit unsigned
    T_64POCT        = 0x0614,   // 64 bit pointer to 128 bit signed
    T_64PUOCT       = 0x0624,   // 64 bit pointer to 128 bit unsigned

//      128 bit int types


    T_INT16         = 0x0078,   // 128 bit signed int
    T_UINT16        = 0x0079,   // 128 bit unsigned int
    T_PINT16        = 0x0178,   // near pointer to 128 bit signed int
    T_PUINT16       = 0x0179,   // near pointer to 128 bit unsigned int
    T_PFINT16       = 0x0278,   // far pointer to 128 bit signed int
    T_PFUINT16      = 0x0279,   // far pointer to 128 bit unsigned int
    T_PHINT16       = 0x0378,   // huge pointer to 128 bit signed int
    T_PHUINT16      = 0x0379,   // huge pointer to 128 bit unsigned int

    T_32PINT16      = 0x0478,   // 16:32 near pointer to 128 bit signed int
    T_32PUINT16     = 0x0479,   // 16:32 near pointer to 128 bit unsigned int
    T_32PFINT16     = 0x0578,   // 16:32 far pointer to 128 bit signed int
    T_32PFUINT16    = 0x0579,   // 16:32 far pointer to 128 bit unsigned int
    T_64PINT16      = 0x0678,   // 64 bit pointer to 128 bit signed int
    T_64PUINT16     = 0x0679,   // 64 bit pointer to 128 bit unsigned int





//      32 bit real types


    T_REAL32        = 0x0040,   // 32 bit real
    T_PREAL32       = 0x0140,   // near pointer to 32 bit real
    T_PFREAL32      = 0x0240,   // far pointer to 32 bit real
    T_PHREAL32      = 0x0340,   // huge pointer to 32 bit real
    T_32PREAL32     = 0x0440,   // 16:32 near pointer to 32 bit real
    T_32PFREAL32    = 0x0540,   // 16:32 far pointer to 32 bit real
    T_64PREAL32     = 0x0640,   // 64 bit pointer to 32 bit real



//      48 bit real types


    T_REAL48        = 0x0044,   // 48 bit real
    T_PREAL48       = 0x0144,   // near pointer to 48 bit real
    T_PFREAL48      = 0x0244,   // far pointer to 48 bit real
    T_PHREAL48      = 0x0344,   // huge pointer to 48 bit real
    T_32PREAL48     = 0x0444,   // 16:32 near pointer to 48 bit real
    T_32PFREAL48    = 0x0544,   // 16:32 far pointer to 48 bit real
    T_64PREAL48     = 0x0644,   // 64 bit pointer to 48 bit real




//      64 bit real types


    T_REAL64        = 0x0041,   // 64 bit real
    T_PREAL64       = 0x0141,   // near pointer to 64 bit real
    T_PFREAL64      = 0x0241,   // far pointer to 64 bit real
    T_PHREAL64      = 0x0341,   // huge pointer to 64 bit real
    T_32PREAL64     = 0x0441,   // 16:32 near pointer to 64 bit real
    T_32PFREAL64    = 0x0541,   // 16:32 far pointer to 64 bit real
    T_64PREAL64     = 0x0641,   // 64 bit pointer to 64 bit real




//      80 bit real types


    T_REAL80        = 0x0042,   // 80 bit real
    T_PREAL80       = 0x0142,   // near pointer to 80 bit real
    T_PFREAL80      = 0x0242,   // far pointer to 80 bit real
    T_PHREAL80      = 0x0342,   // huge pointer to 80 bit real
    T_32PREAL80     = 0x0442,   // 16:32 near pointer to 80 bit real
    T_32PFREAL80    = 0x0542,   // 16:32 far pointer to 80 bit real
    T_64PREAL80     = 0x0642,   // 64 bit pointer to 80 bit real




//      128 bit real types


    T_REAL128       = 0x0043,   // 128 bit real
    T_PREAL128      = 0x0143,   // near pointer to 128 bit real
    T_PFREAL128     = 0x0243,   // far pointer to 128 bit real
    T_PHREAL128     = 0x0343,   // huge pointer to 128 bit real
    T_32PREAL128    = 0x0443,   // 16:32 near pointer to 128 bit real
    T_32PFREAL128   = 0x0543,   // 16:32 far pointer to 128 bit real
    T_64PREAL128    = 0x0643,   // 64 bit pointer to 128 bit real




//      32 bit complex types


    T_CPLX32        = 0x0050,   // 32 bit complex
    T_PCPLX32       = 0x0150,   // near pointer to 32 bit complex
    T_PFCPLX32      = 0x0250,   // far pointer to 32 bit complex
    T_PHCPLX32      = 0x0350,   // huge pointer to 32 bit complex
    T_32PCPLX32     = 0x0450,   // 16:32 near pointer to 32 bit complex
    T_32PFCPLX32    = 0x0550,   // 16:32 far pointer to 32 bit complex
    T_64PCPLX32     = 0x0650,   // 64 bit pointer to 32 bit complex




//      64 bit complex types


    T_CPLX64        = 0x0051,   // 64 bit complex
    T_PCPLX64       = 0x0151,   // near pointer to 64 bit complex
    T_PFCPLX64      = 0x0251,   // far pointer to 64 bit complex
    T_PHCPLX64      = 0x0351,   // huge pointer to 64 bit complex
    T_32PCPLX64     = 0x0451,   // 16:32 near pointer to 64 bit complex
    T_32PFCPLX64    = 0x0551,   // 16:32 far pointer to 64 bit complex
    T_64PCPLX64     = 0x0651,   // 64 bit pointer to 64 bit complex




//      80 bit complex types


    T_CPLX80        = 0x0052,   // 80 bit complex
    T_PCPLX80       = 0x0152,   // near pointer to 80 bit complex
    T_PFCPLX80      = 0x0252,   // far pointer to 80 bit complex
    T_PHCPLX80      = 0x0352,   // huge pointer to 80 bit complex
    T_32PCPLX80     = 0x0452,   // 16:32 near pointer to 80 bit complex
    T_32PFCPLX80    = 0x0552,   // 16:32 far pointer to 80 bit complex
    T_64PCPLX80     = 0x0652,   // 64 bit pointer to 80 bit complex




//      128 bit complex types


    T_CPLX128       = 0x0053,   // 128 bit complex
    T_PCPLX128      = 0x0153,   // near pointer to 128 bit complex
    T_PFCPLX128     = 0x0253,   // far pointer to 128 bit complex
    T_PHCPLX128     = 0x0353,   // huge pointer to 128 bit real
    T_32PCPLX128    = 0x0453,   // 16:32 near pointer to 128 bit complex
    T_32PFCPLX128   = 0x0553,   // 16:32 far pointer to 128 bit complex
    T_64PCPLX128    = 0x0653,   // 64 bit pointer to 128 bit complex




//      boolean types


    T_BOOL08        = 0x0030,   // 8 bit boolean
    T_BOOL16        = 0x0031,   // 16 bit boolean
    T_BOOL32        = 0x0032,   // 32 bit boolean
    T_BOOL64        = 0x0033,   // 64 bit boolean
    T_PBOOL08       = 0x0130,   // near pointer to  8 bit boolean
    T_PBOOL16       = 0x0131,   // near pointer to 16 bit boolean
    T_PBOOL32       = 0x0132,   // near pointer to 32 bit boolean
    T_PBOOL64       = 0x0133,   // near pointer to 64 bit boolean
    T_PFBOOL08      = 0x0230,   // far pointer to  8 bit boolean
    T_PFBOOL16      = 0x0231,   // far pointer to 16 bit boolean
    T_PFBOOL32      = 0x0232,   // far pointer to 32 bit boolean
    T_PFBOOL64      = 0x0233,   // far pointer to 64 bit boolean
    T_PHBOOL08      = 0x0330,   // huge pointer to  8 bit boolean
    T_PHBOOL16      = 0x0331,   // huge pointer to 16 bit boolean
    T_PHBOOL32      = 0x0332,   // huge pointer to 32 bit boolean
    T_PHBOOL64      = 0x0333,   // huge pointer to 64 bit boolean

    T_32PBOOL08     = 0x0430,   // 16:32 near pointer to 8 bit boolean
    T_32PFBOOL08    = 0x0530,   // 16:32 far pointer to 8 bit boolean
    T_32PBOOL16     = 0x0431,   // 16:32 near pointer to 18 bit boolean
    T_32PFBOOL16    = 0x0531,   // 16:32 far pointer to 16 bit boolean
    T_32PBOOL32     = 0x0432,   // 16:32 near pointer to 32 bit boolean
    T_32PFBOOL32    = 0x0532,   // 16:32 far pointer to 32 bit boolean
    T_32PBOOL64     = 0x0433,   // 16:32 near pointer to 64 bit boolean
    T_32PFBOOL64    = 0x0533,   // 16:32 far pointer to 64 bit boolean

    T_64PBOOL08     = 0x0630,   // 64 bit pointer to 8 bit boolean
    T_64PBOOL16     = 0x0631,   // 64 bit pointer to 18 bit boolean
    T_64PBOOL32     = 0x0632,   // 64 bit pointer to 32 bit boolean
    T_64PBOOL64     = 0x0633,   // 64 bit pointer to 64 bit boolean


    T_NCVPTR        = 0x01f0,   // CV Internal type for created near pointers
    T_FCVPTR        = 0x02f0,   // CV Internal type for created far pointers
    T_HCVPTR        = 0x03f0,   // CV Internal type for created huge pointers
    T_32NCVPTR      = 0x04f0,   // CV Internal type for created near 32-bit pointers
    T_32FCVPTR      = 0x05f0,   // CV Internal type for created far 32-bit pointers
    T_64NCVPTR      = 0x06f0,   // CV Internal type for created near 64-bit pointers

} TYPE_ENUM_e;

/**     No leaf index can have a value of 0x0000.  The leaf indices are
 *      separated into ranges depending upon the use of the type record.
 *      The second range is for the type records that are directly referenced
 *      in symbols. The first range is for type records that are not
 *      referenced by symbols but instead are referenced by other type
 *      records.  All type records must have a starting leaf index in these
 *      first two ranges.  The third range of leaf indices are used to build
 *      up complex lists such as the field list of a class type record.  No
 *      type record can begin with one of the leaf indices. The fourth ranges
 *      of type indices are used to represent numeric data in a symbol or
 *      type record. These leaf indices are greater than 0x8000.  At the
 *      point that type or symbol processor is expecting a numeric field, the
 *      next two bytes in the type record are examined.  If the value is less
 *      than 0x8000, then the two bytes contain the numeric value.  If the
 *      value is greater than 0x8000, then the data follows the leaf index in
 *      a format specified by the leaf index. The final range of leaf indices
 *      are used to force alignment of subfields within a complex type record..
 */


typedef enum LEAF_ENUM_e {
    // leaf indices starting records but referenced from symbol records

    LF_MODIFIER_16t     = 0x0001,
    LF_POINTER_16t      = 0x0002,
    LF_ARRAY_16t        = 0x0003,
    LF_CLASS_16t        = 0x0004,
    LF_STRUCTURE_16t    = 0x0005,
    LF_UNION_16t        = 0x0006,
    LF_ENUM_16t         = 0x0007,
    LF_PROCEDURE_16t    = 0x0008,
    LF_MFUNCTION_16t    = 0x0009,
    LF_VTSHAPE          = 0x000a,
    LF_COBOL0_16t       = 0x000b,
    LF_COBOL1           = 0x000c,
    LF_BARRAY_16t       = 0x000d,
    LF_LABEL            = 0x000e,
    LF_NULL             = 0x000f,
    LF_NOTTRAN          = 0x0010,
    LF_DIMARRAY_16t     = 0x0011,
    LF_VFTPATH_16t      = 0x0012,
    LF_PRECOMP_16t      = 0x0013,       // not referenced from symbol
    LF_ENDPRECOMP       = 0x0014,       // not referenced from symbol
    LF_OEM_16t          = 0x0015,       // oem definable type string
    LF_TYPESERVER       = 0x0016,       // not referenced from symbol

    // leaf indices starting records but referenced only from type records

    LF_SKIP_16t         = 0x0200,
    LF_ARGLIST_16t      = 0x0201,
    LF_DEFARG_16t       = 0x0202,
    LF_LIST             = 0x0203,
    LF_FIELDLIST_16t    = 0x0204,
    LF_DERIVED_16t      = 0x0205,
    LF_BITFIELD_16t     = 0x0206,
    LF_METHODLIST_16t   = 0x0207,
    LF_DIMCONU_16t      = 0x0208,
    LF_DIMCONLU_16t     = 0x0209,
    LF_DIMVARU_16t      = 0x020a,
    LF_DIMVARLU_16t     = 0x020b,
    LF_REFSYM           = 0x020c,

    LF_BCLASS_16t       = 0x0400,
    LF_VBCLASS_16t      = 0x0401,
    LF_IVBCLASS_16t     = 0x0402,
    LF_ENUMERATE        = 0x0403,
    LF_FRIENDFCN_16t    = 0x0404,
    LF_INDEX_16t        = 0x0405,
    LF_MEMBER_16t       = 0x0406,
    LF_STMEMBER_16t     = 0x0407,
    LF_METHOD_16t       = 0x0408,
    LF_NESTTYPE_16t     = 0x0409,
    LF_VFUNCTAB_16t     = 0x040a,
    LF_FRIENDCLS_16t    = 0x040b,
    LF_ONEMETHOD_16t    = 0x040c,
    LF_VFUNCOFF_16t     = 0x040d,

// 32-bit type index versions of leaves, all have the 0x1000 bit set
//
    LF_TI16_MAX         = 0x1000,

    LF_MODIFIER         = 0x1001,
    LF_POINTER          = 0x1002,
    LF_ARRAY            = 0x1003,
    LF_CLASS            = 0x1004,
    LF_STRUCTURE        = 0x1005,
    LF_UNION            = 0x1006,
    LF_ENUM             = 0x1007,
    LF_PROCEDURE        = 0x1008,
    LF_MFUNCTION        = 0x1009,
    LF_COBOL0           = 0x100a,
    LF_BARRAY           = 0x100b,
    LF_DIMARRAY         = 0x100c,
    LF_VFTPATH          = 0x100d,
    LF_PRECOMP          = 0x100e,       // not referenced from symbol
    LF_OEM              = 0x100f,       // oem definable type string
    LF_ALIAS            = 0x1010,       // alias (typedef) type

    // leaf indices starting records but referenced only from type records

    LF_SKIP             = 0x1200,
    LF_ARGLIST          = 0x1201,
    LF_DEFARG           = 0x1202,
    LF_FIELDLIST        = 0x1203,
    LF_DERIVED          = 0x1204,
    LF_BITFIELD         = 0x1205,
    LF_METHODLIST       = 0x1206,
    LF_DIMCONU          = 0x1207,
    LF_DIMCONLU         = 0x1208,
    LF_DIMVARU          = 0x1209,
    LF_DIMVARLU         = 0x120a,

    LF_BCLASS           = 0x1400,
    LF_VBCLASS          = 0x1401,
    LF_IVBCLASS         = 0x1402,
    LF_FRIENDFCN        = 0x1403,
    LF_INDEX            = 0x1404,
    LF_MEMBER           = 0x1405,
    LF_STMEMBER         = 0x1406,
    LF_METHOD           = 0x1407,
    LF_NESTTYPE         = 0x1408,
    LF_VFUNCTAB         = 0x1409,
    LF_FRIENDCLS        = 0x140a,
    LF_ONEMETHOD        = 0x140b,
    LF_VFUNCOFF         = 0x140c,
    LF_NESTTYPEEX       = 0x140d,
    LF_MEMBERMODIFY     = 0x140e,




    LF_NUMERIC          = 0x8000,
    LF_CHAR             = 0x8000,
    LF_SHORT            = 0x8001,
    LF_USHORT           = 0x8002,
    LF_LONG             = 0x8003,
    LF_ULONG            = 0x8004,
    LF_REAL32           = 0x8005,
    LF_REAL64           = 0x8006,
    LF_REAL80           = 0x8007,
    LF_REAL128          = 0x8008,
    LF_QUADWORD         = 0x8009,
    LF_UQUADWORD        = 0x800a,
    LF_REAL48           = 0x800b,
    LF_COMPLEX32        = 0x800c,
    LF_COMPLEX64        = 0x800d,
    LF_COMPLEX80        = 0x800e,
    LF_COMPLEX128       = 0x800f,
    LF_VARSTRING        = 0x8010,

    LF_OCTWORD          = 0x8017,
    LF_UOCTWORD         = 0x8018,

    LF_PAD0             = 0xf0,
    LF_PAD1             = 0xf1,
    LF_PAD2             = 0xf2,
    LF_PAD3             = 0xf3,
    LF_PAD4             = 0xf4,
    LF_PAD5             = 0xf5,
    LF_PAD6             = 0xf6,
    LF_PAD7             = 0xf7,
    LF_PAD8             = 0xf8,
    LF_PAD9             = 0xf9,
    LF_PAD10            = 0xfa,
    LF_PAD11            = 0xfb,
    LF_PAD12            = 0xfc,
    LF_PAD13            = 0xfd,
    LF_PAD14            = 0xfe,
    LF_PAD15            = 0xff,

} LEAF_ENUM_e;

// end of leaf indices




//      Type enum for pointer records
//      Pointers can be one of the following types


typedef enum CV_ptrtype_e {
    CV_PTR_NEAR         = 0x00, // near pointer
    CV_PTR_FAR          = 0x01, // far pointer
    CV_PTR_HUGE         = 0x02, // huge pointer
    CV_PTR_BASE_SEG     = 0x03, // based on segment
    CV_PTR_BASE_VAL     = 0x04, // based on value of base
    CV_PTR_BASE_SEGVAL  = 0x05, // based on segment value of base
    CV_PTR_BASE_ADDR    = 0x06, // based on address of base
    CV_PTR_BASE_SEGADDR = 0x07, // based on segment address of base
    CV_PTR_BASE_TYPE    = 0x08, // based on type
    CV_PTR_BASE_SELF    = 0x09, // based on self
    CV_PTR_NEAR32       = 0x0a, // 16:32 near pointer
    CV_PTR_FAR32        = 0x0b, // 16:32 far pointer
    CV_PTR_64           = 0x0c, // 64 bit pointer
    CV_PTR_UNUSEDPTR    = 0x0d  // first unused pointer type
} CV_ptrtype_e;





//      Mode enum for pointers
//      Pointers can have one of the following modes


typedef enum CV_ptrmode_e {
    CV_PTR_MODE_PTR     = 0x00, // "normal" pointer
    CV_PTR_MODE_REF     = 0x01, // reference
    CV_PTR_MODE_PMEM    = 0x02, // pointer to data member
    CV_PTR_MODE_PMFUNC  = 0x03, // pointer to member function
    CV_PTR_MODE_RESERVED= 0x04  // first unused pointer mode
} CV_ptrmode_e;




//      Enumeration for function call type


typedef enum CV_call_e {
    CV_CALL_NEAR_C      = 0x00, // near right to left push, caller pops stack
    CV_CALL_FAR_C       = 0x01, // far right to left push, caller pops stack
    CV_CALL_NEAR_PASCAL = 0x02, // near left to right push, callee pops stack
    CV_CALL_FAR_PASCAL  = 0x03, // far left to right push, callee pops stack
    CV_CALL_NEAR_FAST   = 0x04, // near left to right push with regs, callee pops stack
    CV_CALL_FAR_FAST    = 0x05, // far left to right push with regs, callee pops stack
    CV_CALL_SKIPPED     = 0x06, // skipped (unused) call index
    CV_CALL_NEAR_STD    = 0x07, // near standard call
    CV_CALL_FAR_STD     = 0x08, // far standard call
    CV_CALL_NEAR_SYS    = 0x09, // near sys call
    CV_CALL_FAR_SYS     = 0x0a, // far sys call
    CV_CALL_THISCALL    = 0x0b, // this call (this passed in register)
    CV_CALL_MIPSCALL    = 0x0c, // Mips call
    CV_CALL_GENERIC     = 0x0d, // Generic call sequence
    CV_CALL_ALPHACALL   = 0x0e, // Alpha call
    CV_CALL_PPCCALL     = 0x0f, // PPC call
    CV_CALL_SHCALL      = 0x10, // Hitachi SuperH call
    CV_CALL_ARMCALL     = 0x11, // ARM call
    CV_CALL_RESERVED    = 0x12  // first unused call enumeration
} CV_call_e;




//      Values for the access protection of class attributes


typedef enum CV_access_e {
    CV_private   = 1,
    CV_protected = 2,
    CV_public    = 3
} CV_access_e;



//      enumeration for method properties

typedef enum CV_methodprop_e {
    CV_MTvanilla        = 0x00,
    CV_MTvirtual        = 0x01,
    CV_MTstatic         = 0x02,
    CV_MTfriend         = 0x03,
    CV_MTintro          = 0x04,
    CV_MTpurevirt       = 0x05,
    CV_MTpureintro      = 0x06
} CV_methodprop_e;




//      enumeration for virtual shape table entries

typedef enum CV_VTS_desc_e {
    CV_VTS_near         = 0x00,
    CV_VTS_far          = 0x01,
    CV_VTS_thin         = 0x02,
    CV_VTS_outer        = 0x03,
    CV_VTS_meta         = 0x04,
    CV_VTS_near32       = 0x05,
    CV_VTS_far32        = 0x06,
    CV_VTS_unused       = 0x07
} CV_VTS_desc_e;




//      enumeration for LF_LABEL address modes

typedef enum CV_LABEL_TYPE_e {
    CV_LABEL_NEAR = 0,       // near return
    CV_LABEL_FAR  = 4        // far return
} CV_LABEL_TYPE_e;



//      enumeration for LF_MODIFIER values


typedef struct CV_modifier_t {
    unsigned short  MOD_const       :1;
    unsigned short  MOD_volatile    :1;
    unsigned short  MOD_unaligned   :1;
    unsigned short  MOD_unused      :13;
} CV_modifier_t;


//  bit field structure describing class/struct/union/enum properties

typedef struct CV_prop_t {
    unsigned short  packed      :1;     // true if structure is packed
    unsigned short  ctor        :1;     // true if constructors or destructors present
    unsigned short  ovlops      :1;     // true if overloaded operators present
    unsigned short  isnested    :1;     // true if this is a nested class
    unsigned short  cnested     :1;     // true if this class contains nested types
    unsigned short  opassign    :1;     // true if overloaded assignment (=)
    unsigned short  opcast      :1;     // true if casting methods
    unsigned short  fwdref      :1;     // true if forward reference (incomplete defn)
    unsigned short  scoped      :1;     // scoped definition
    unsigned short  reserved    :7;
} CV_prop_t;




//  class field attribute

typedef struct CV_fldattr_t {
    unsigned short  access      :2;     // access protection CV_access_t
    unsigned short  mprop       :3;     // method properties CV_methodprop_t
    unsigned short  pseudo      :1;     // compiler generated fcn and does not exist
    unsigned short  noinherit   :1;     // true if class cannot be inherited
    unsigned short  noconstruct :1;     // true if class cannot be constructed
    unsigned short  compgenx    :1;     // compiler generated fcn and does exist
    unsigned short  unused      :7;     // unused
} CV_fldattr_t;



//  Structures to access to the type records


typedef struct TYPTYPE {
    unsigned short  len;
    unsigned short  leaf;
    unsigned char   data[CV_ZEROLEN];
} TYPTYPE;          // general types record


__INLINE char *NextType (char * pType) {
    return (pType + ((TYPTYPE *)pType)->len + sizeof(unsigned short));
}

typedef enum CV_PMEMBER {
    CV_PDM16_NONVIRT    = 0x00, // 16:16 data no virtual fcn or base
    CV_PDM16_VFCN       = 0x01, // 16:16 data with virtual functions
    CV_PDM16_VBASE      = 0x02, // 16:16 data with virtual bases
    CV_PDM32_NVVFCN     = 0x03, // 16:32 data w/wo virtual functions
    CV_PDM32_VBASE      = 0x04, // 16:32 data with virtual bases

    CV_PMF16_NEARNVSA   = 0x05, // 16:16 near method nonvirtual single address point
    CV_PMF16_NEARNVMA   = 0x06, // 16:16 near method nonvirtual multiple address points
    CV_PMF16_NEARVBASE  = 0x07, // 16:16 near method virtual bases
    CV_PMF16_FARNVSA    = 0x08, // 16:16 far method nonvirtual single address point
    CV_PMF16_FARNVMA    = 0x09, // 16:16 far method nonvirtual multiple address points
    CV_PMF16_FARVBASE   = 0x0a, // 16:16 far method virtual bases

    CV_PMF32_NVSA       = 0x0b, // 16:32 method nonvirtual single address point
    CV_PMF32_NVMA       = 0x0c, // 16:32 method nonvirtual multiple address point
    CV_PMF32_VBASE      = 0x0d  // 16:32 method virtual bases
} CV_PMEMBER;



//  memory representation of pointer to member.  These representations are
//  indexed by the enumeration above in the LF_POINTER record




//  representation of a 16:16 pointer to data for a class with no
//  virtual functions or virtual bases


struct CV_PDMR16_NONVIRT {
    CV_off16_t      mdisp;      // displacement to data (NULL = -1)
};




//  representation of a 16:16 pointer to data for a class with virtual
//  functions


struct CV_PMDR16_VFCN {
    CV_off16_t      mdisp;      // displacement to data ( NULL = 0)
};




//  representation of a 16:16 pointer to data for a class with
//  virtual bases


struct CV_PDMR16_VBASE {
    CV_off16_t      mdisp;      // displacement to data
    CV_off16_t      pdisp;      // this pointer displacement to vbptr
    CV_off16_t      vdisp;      // displacement within vbase table
                                // NULL = (,,0xffff)
};




//  representation of a 16:32 near pointer to data for a class with
//  or without virtual functions and no virtual bases


struct CV_PDMR32_NVVFCN {
    CV_off32_t      mdisp;      // displacement to data (NULL = 0x80000000)
};




//  representation of a 16:32 near pointer to data for a class
//  with virtual bases


struct CV_PDMR32_VBASE {
    CV_off32_t      mdisp;      // displacement to data
    CV_off32_t      pdisp;      // this pointer displacement
    CV_off32_t      vdisp;      // vbase table displacement
                                // NULL = (,,0xffffffff)
};




//  representation of a 16:16 pointer to near member function for a
//  class with no virtual functions or bases and a single address point


struct CV_PMFR16_NEARNVSA {
    CV_uoff16_t     off;        // near address of function (NULL = 0)
};



//  representation of a 16:16 near pointer to member functions of a
//  class with no virtual bases and multiple address points


struct CV_PMFR16_NEARNVMA {
    CV_uoff16_t     off;        // offset of function (NULL = 0,x)
    signed short    disp;
};




//  representation of a 16:16 near pointer to member function of a
//  class with virtual bases


struct CV_PMFR16_NEARVBASE {
    CV_uoff16_t     off;        // offset of function (NULL = 0,x,x,x)
    CV_off16_t      mdisp;      // displacement to data
    CV_off16_t      pdisp;      // this pointer displacement
    CV_off16_t      vdisp;      // vbase table displacement
};




//  representation of a 16:16 pointer to far member function for a
//  class with no virtual bases and a single address point


struct CV_PMFR16_FARNVSA {
    CV_uoff16_t     off;        // offset of function (NULL = 0:0)
    unsigned short  seg;        // segment of function
};




//  representation of a 16:16 far pointer to member functions of a
//  class with no virtual bases and multiple address points


struct CV_PMFR16_FARNVMA {
    CV_uoff16_t     off;        // offset of function (NULL = 0:0,x)
    unsigned short  seg;
    signed short    disp;
};




//  representation of a 16:16 far pointer to member function of a
//  class with virtual bases


struct CV_PMFR16_FARVBASE {
    CV_uoff16_t     off;        // offset of function (NULL = 0:0,x,x,x)
    unsigned short  seg;
    CV_off16_t      mdisp;      // displacement to data
    CV_off16_t      pdisp;      // this pointer displacement
    CV_off16_t      vdisp;      // vbase table displacement

};




//  representation of a 16:32 near pointer to member function for a
//  class with no virtual bases and a single address point


struct CV_PMFR32_NVSA {
    CV_uoff32_t      off;        // near address of function (NULL = 0L)
};




//  representation of a 16:32 near pointer to member function for a
//  class with no virtual bases and multiple address points


struct CV_PMFR32_NVMA {
    CV_uoff32_t     off;        // near address of function (NULL = 0L,x)
    CV_off32_t      disp;
};




//  representation of a 16:32 near pointer to member function for a
//  class with virtual bases


struct CV_PMFR32_VBASE {
    CV_uoff32_t     off;        // near address of function (NULL = 0L,x,x,x)
    CV_off32_t      mdisp;      // displacement to data
    CV_off32_t      pdisp;      // this pointer displacement
    CV_off32_t      vdisp;      // vbase table displacement
};





//  Easy leaf - used for generic casting to reference leaf field
//  of a subfield of a complex list

typedef struct lfEasy {
    unsigned short  leaf;           // LF_...
} lfEasy;


/**     The following type records are basically variant records of the
 *      above structure.  The "unsigned short leaf" of the above structure and
 *      the "unsigned short leaf" of the following type definitions are the same
 *      symbol.  When the OMF record is locked via the MHOMFLock API
 *      call, the address of the "unsigned short leaf" is returned
 */

/**     Notes on alignment
 *      Alignment of the fields in most of the type records is done on the
 *      basis of the TYPTYPE record base.  That is why in most of the lf*
 *      records that the CV_typ_t (32-bit types) is located on what appears to
 *      be a offset mod 4 == 2 boundary.  The exception to this rule are those
 *      records that are in a list (lfFieldList, lfMethodList), which are
 *      aligned to their own bases since they don't have the length field
 */

/**** Change log for 16-bit to 32-bit type and symbol records

    Record type         Change (f == field arrangement, p = padding added)
    ----------------------------------------------------------------------
    lfModifer           f
    lfPointer           fp
    lfClass             f
    lfStructure         f
    lfUnion             f
    lfEnum              f
    lfVFTPath           p
    lfPreComp           p
    lfOEM               p
    lfArgList           p
    lfDerived           p
    mlMethod            p   (method list member)
    lfBitField          f
    lfDimCon            f
    lfDimVar            p
    lfIndex             p   (field list member)
    lfBClass            f   (field list member)
    lfVBClass           f   (field list member)
    lfFriendCls         p   (field list member)
    lfFriendFcn         p   (field list member)
    lfMember            f   (field list member)
    lfSTMember          f   (field list member)
    lfVFuncTab          p   (field list member)
    lfVFuncOff          p   (field list member)
    lfNestType          p   (field list member)

    DATASYM32           f
    PROCSYM32           f
    VPATHSYM32          f
    REGREL32            f
    THREADSYM32         f
    PROCSYMMIPS         f


*/

//      Type record for LF_MODIFIER

typedef struct lfModifier_16t {
    unsigned short  leaf;           // LF_MODIFIER_16t
    CV_modifier_t   attr;           // modifier attribute modifier_t
    CV_typ16_t      type;           // modified type
} lfModifier_16t;

typedef struct lfModifier {
    unsigned short  leaf;           // LF_MODIFIER
    CV_typ_t        type;           // modified type
    CV_modifier_t   attr;           // modifier attribute modifier_t
} lfModifier;




//      type record for LF_POINTER

#ifndef __cplusplus
typedef struct lfPointer_16t {
#endif
    struct lfPointerBody_16t {
        unsigned short      leaf;           // LF_POINTER_16t
        struct lfPointerAttr_16t {
            unsigned char   ptrtype     :5; // ordinal specifying pointer type (CV_ptrtype_e)
            unsigned char   ptrmode     :3; // ordinal specifying pointer mode (CV_ptrmode_e)
            unsigned char   isflat32    :1; // true if 0:32 pointer
            unsigned char   isvolatile  :1; // TRUE if volatile pointer
            unsigned char   isconst     :1; // TRUE if const pointer
            unsigned char   isunaligned :1; // TRUE if unaligned pointer
            unsigned char   unused      :4;
        } attr;
        CV_typ16_t  utype;          // type index of the underlying type
#if (defined(__cplusplus) || defined(_MSC_VER)) // for C++ and MS compilers that support unnamed unions
    };
#else
    } u;
#endif
#ifdef  __cplusplus
typedef struct lfPointer_16t : public lfPointerBody_16t {
#endif
    union {
        struct {
            CV_typ16_t      pmclass;    // index of containing class for pointer to member
            unsigned short  pmenum;     // enumeration specifying pm format
        } pm;
        unsigned short      bseg;       // base segment if PTR_BASE_SEG
        unsigned char       Sym[1];     // copy of base symbol record (including length)
        struct  {
            CV_typ16_t      index;      // type index if CV_PTR_BASE_TYPE
            unsigned char   name[1];    // name of base type
        } btype;
    } pbase;
} lfPointer_16t;

#ifndef __cplusplus
typedef struct lfPointer {
#endif
    struct lfPointerBody {
        unsigned short      leaf;           // LF_POINTER
        CV_typ_t            utype;          // type index of the underlying type
        struct lfPointerAttr {
            unsigned long   ptrtype     :5; // ordinal specifying pointer type (CV_ptrtype_e)
            unsigned long   ptrmode     :3; // ordinal specifying pointer mode (CV_ptrmode_e)
            unsigned long   isflat32    :1; // true if 0:32 pointer
            unsigned long   isvolatile  :1; // TRUE if volatile pointer
            unsigned long   isconst     :1; // TRUE if const pointer
            unsigned long   isunaligned :1; // TRUE if unaligned pointer
            unsigned long   isrestrict  :1; // TRUE if restricted pointer (allow agressive opts)
            unsigned long   unused      :19;// pad out to 32-bits for following cv_typ_t's
        } attr;
#if (defined(__cplusplus) || defined(_MSC_VER)) // for C++ and MS compilers that support unnamed unions
    };
#else
    } u;
#endif
#ifdef  __cplusplus
typedef struct lfPointer : public lfPointerBody {
#endif
    union {
        struct {
            CV_typ_t        pmclass;    // index of containing class for pointer to member
            unsigned short  pmenum;     // enumeration specifying pm format
        } pm;
        unsigned short      bseg;       // base segment if PTR_BASE_SEG
        unsigned char       Sym[1];     // copy of base symbol record (including length)
        struct  {
            CV_typ_t        index;      // type index if CV_PTR_BASE_TYPE
            unsigned char   name[1];    // name of base type
        } btype;
    } pbase;
} lfPointer;




//      type record for LF_ARRAY


typedef struct lfArray_16t {
    unsigned short  leaf;           // LF_ARRAY_16t
    CV_typ16_t      elemtype;       // type index of element type
    CV_typ16_t      idxtype;        // type index of indexing type
    unsigned char   data[CV_ZEROLEN];         // variable length data specifying
                                    // size in bytes and name
} lfArray_16t;

typedef struct lfArray {
    unsigned short  leaf;           // LF_ARRAY
    CV_typ_t        elemtype;       // type index of element type
    CV_typ_t        idxtype;        // type index of indexing type
    unsigned char   data[CV_ZEROLEN];         // variable length data specifying
                                    // size in bytes and name
} lfArray;




//      type record for LF_CLASS, LF_STRUCTURE


typedef struct lfClass_16t {
    unsigned short  leaf;           // LF_CLASS_16t, LF_STRUCT_16t
    unsigned short  count;          // count of number of elements in class
    CV_typ16_t      field;          // type index of LF_FIELD descriptor list
    CV_prop_t       property;       // property attribute field (prop_t)
    CV_typ16_t      derived;        // type index of derived from list if not zero
    CV_typ16_t      vshape;         // type index of vshape table for this class
    unsigned char   data[CV_ZEROLEN];         // data describing length of structure in
                                    // bytes and name
} lfClass_16t;
typedef lfClass_16t lfStructure_16t;


typedef struct lfClass {
    unsigned short  leaf;           // LF_CLASS, LF_STRUCT
    unsigned short  count;          // count of number of elements in class
    CV_prop_t       property;       // property attribute field (prop_t)
    CV_typ_t        field;          // type index of LF_FIELD descriptor list
    CV_typ_t        derived;        // type index of derived from list if not zero
    CV_typ_t        vshape;         // type index of vshape table for this class
    unsigned char   data[CV_ZEROLEN];         // data describing length of structure in
                                    // bytes and name
} lfClass;
typedef lfClass lfStructure;




//      type record for LF_UNION


typedef struct lfUnion_16t {
    unsigned short  leaf;           // LF_UNION_16t
    unsigned short  count;          // count of number of elements in class
    CV_typ16_t      field;          // type index of LF_FIELD descriptor list
    CV_prop_t       property;       // property attribute field
    unsigned char   data[CV_ZEROLEN];         // variable length data describing length of
                                    // structure and name
} lfUnion_16t;


typedef struct lfUnion {
    unsigned short  leaf;           // LF_UNION
    unsigned short  count;          // count of number of elements in class
    CV_prop_t       property;       // property attribute field
    CV_typ_t        field;          // type index of LF_FIELD descriptor list
    unsigned char   data[CV_ZEROLEN];         // variable length data describing length of
                                    // structure and name
} lfUnion;


//      type record for LF_ALIAS

typedef struct lfAlias {
    unsigned short  leaf;           // LF_ALIAS
    CV_typ_t        utype;          // underlying type
    unsigned char   Name[1];        // alias name
} lfAlias;



//      type record for LF_ENUM


typedef struct lfEnum_16t {
    unsigned short  leaf;           // LF_ENUM_16t
    unsigned short  count;          // count of number of elements in class
    CV_typ16_t      utype;          // underlying type of the enum
    CV_typ16_t      field;          // type index of LF_FIELD descriptor list
    CV_prop_t       property;       // property attribute field
    unsigned char   Name[1];        // length prefixed name of enum
} lfEnum_16t;

typedef struct lfEnum {
    unsigned short  leaf;           // LF_ENUM
    unsigned short  count;          // count of number of elements in class
    CV_prop_t       property;       // property attribute field
    CV_typ_t        utype;          // underlying type of the enum
    CV_typ_t        field;          // type index of LF_FIELD descriptor list
    unsigned char   Name[1];        // length prefixed name of enum
} lfEnum;




//      Type record for LF_PROCEDURE


typedef struct lfProc_16t {
    unsigned short  leaf;           // LF_PROCEDURE_16t
    CV_typ16_t      rvtype;         // type index of return value
    unsigned char   calltype;       // calling convention (CV_call_t)
    unsigned char   reserved;       // reserved for future use
    unsigned short  parmcount;      // number of parameters
    CV_typ16_t      arglist;        // type index of argument list
} lfProc_16t;

typedef struct lfProc {
    unsigned short  leaf;           // LF_PROCEDURE
    CV_typ_t        rvtype;         // type index of return value
    unsigned char   calltype;       // calling convention (CV_call_t)
    unsigned char   reserved;       // reserved for future use
    unsigned short  parmcount;      // number of parameters
    CV_typ_t        arglist;        // type index of argument list
} lfProc;



//      Type record for member function


typedef struct lfMFunc_16t {
    unsigned short  leaf;           // LF_MFUNCTION_16t
    CV_typ16_t      rvtype;         // type index of return value
    CV_typ16_t      classtype;      // type index of containing class
    CV_typ16_t      thistype;       // type index of this pointer (model specific)
    unsigned char   calltype;       // calling convention (call_t)
    unsigned char   reserved;       // reserved for future use
    unsigned short  parmcount;      // number of parameters
    CV_typ16_t      arglist;        // type index of argument list
    long            thisadjust;     // this adjuster (long because pad required anyway)
} lfMFunc_16t;

typedef struct lfMFunc {
    unsigned short  leaf;           // LF_MFUNCTION
    CV_typ_t        rvtype;         // type index of return value
    CV_typ_t        classtype;      // type index of containing class
    CV_typ_t        thistype;       // type index of this pointer (model specific)
    unsigned char   calltype;       // calling convention (call_t)
    unsigned char   reserved;       // reserved for future use
    unsigned short  parmcount;      // number of parameters
    CV_typ_t        arglist;        // type index of argument list
    long            thisadjust;     // this adjuster (long because pad required anyway)
} lfMFunc;




//     type record for virtual function table shape


typedef struct lfVTShape {
    unsigned short  leaf;       // LF_VTSHAPE
    unsigned short  count;      // number of entries in vfunctable
    unsigned char   desc[CV_ZEROLEN];     // 4 bit (CV_VTS_desc) descriptors
} lfVTShape;




//      type record for cobol0


typedef struct lfCobol0_16t {
    unsigned short  leaf;       // LF_COBOL0_16t
    CV_typ16_t      type;       // parent type record index
    unsigned char   data[CV_ZEROLEN];
} lfCobol0_16t;

typedef struct lfCobol0 {
    unsigned short  leaf;       // LF_COBOL0
    CV_typ_t        type;       // parent type record index
    unsigned char   data[CV_ZEROLEN];
} lfCobol0;




//      type record for cobol1


typedef struct lfCobol1 {
    unsigned short  leaf;       // LF_COBOL1
    unsigned char   data[CV_ZEROLEN];
} lfCobol1;




//      type record for basic array


typedef struct lfBArray_16t {
    unsigned short  leaf;       // LF_BARRAY_16t
    CV_typ16_t      utype;      // type index of underlying type
} lfBArray_16t;

typedef struct lfBArray {
    unsigned short  leaf;       // LF_BARRAY
    CV_typ_t        utype;      // type index of underlying type
} lfBArray;

//      type record for assembler labels


typedef struct lfLabel {
    unsigned short  leaf;       // LF_LABEL
    unsigned short  mode;       // addressing mode of label
} lfLabel;



//      type record for dimensioned arrays


typedef struct lfDimArray_16t {
    unsigned short  leaf;       // LF_DIMARRAY_16t
    CV_typ16_t      utype;      // underlying type of the array
    CV_typ16_t      diminfo;    // dimension information
    unsigned char   name[1];    // length prefixed name
} lfDimArray_16t;

typedef struct lfDimArray {
    unsigned short  leaf;       // LF_DIMARRAY
    CV_typ_t        utype;      // underlying type of the array
    CV_typ_t        diminfo;    // dimension information
    unsigned char   name[1];    // length prefixed name
} lfDimArray;



//      type record describing path to virtual function table


typedef struct lfVFTPath_16t {
    unsigned short  leaf;       // LF_VFTPATH_16t
    unsigned short  count;      // count of number of bases in path
    CV_typ16_t      base[1];    // bases from root to leaf
} lfVFTPath_16t;

typedef struct lfVFTPath {
    unsigned short  leaf;       // LF_VFTPATH
    unsigned long   count;      // count of number of bases in path
    CV_typ_t        base[1];    // bases from root to leaf
} lfVFTPath;


//      type record describing inclusion of precompiled types


typedef struct lfPreComp_16t {
    unsigned short  leaf;       // LF_PRECOMP_16t
    unsigned short  start;      // starting type index included
    unsigned short  count;      // number of types in inclusion
    unsigned long   signature;  // signature
    unsigned char   name[CV_ZEROLEN];     // length prefixed name of included type file
} lfPreComp_16t;

typedef struct lfPreComp {
    unsigned short  leaf;       // LF_PRECOMP
    unsigned long   start;      // starting type index included
    unsigned long   count;      // number of types in inclusion
    unsigned long   signature;  // signature
    unsigned char   name[CV_ZEROLEN];     // length prefixed name of included type file
} lfPreComp;



//      type record describing end of precompiled types that can be
//      included by another file


typedef struct lfEndPreComp {
    unsigned short  leaf;       // LF_ENDPRECOMP
    unsigned long   signature;  // signature
} lfEndPreComp;





//      type record for OEM definable type strings


typedef struct lfOEM_16t {
    unsigned short  leaf;       // LF_OEM_16t
    unsigned short  cvOEM;      // MS assigned OEM identified
    unsigned short  recOEM;     // OEM assigned type identifier
    unsigned short  count;      // count of type indices to follow
    CV_typ16_t      index[CV_ZEROLEN];  // array of type indices followed
                                // by OEM defined data
} lfOEM_16t;

typedef struct lfOEM {
    unsigned short  leaf;       // LF_OEM
    unsigned short  cvOEM;      // MS assigned OEM identified
    unsigned short  recOEM;     // OEM assigned type identifier
    unsigned long   count;      // count of type indices to follow
    CV_typ_t        index[CV_ZEROLEN];  // array of type indices followed
                                // by OEM defined data
} lfOEM;

#define OEM_MS_FORTRAN90        0xF090
#define OEM_ODI                 0x0010
#define OEM_THOMSON_SOFTWARE    0x5453
#define OEM_ODI_REC_BASELIST    0x0000


//      type record describing using of a type server

typedef struct lfTypeServer {
    unsigned short  leaf;       // LF_TYPESERVER
    unsigned long   signature;  // signature
    unsigned long   age;        // age of database used by this module
    unsigned char   name[CV_ZEROLEN];     // length prefixed name of PDB
} lfTypeServer;

//      description of type records that can be referenced from
//      type records referenced by symbols



//      type record for skip record


typedef struct lfSkip_16t {
    unsigned short  leaf;       // LF_SKIP_16t
    CV_typ16_t      type;       // next valid index
    unsigned char   data[CV_ZEROLEN];     // pad data
} lfSkip_16t;

typedef struct lfSkip {
    unsigned short  leaf;       // LF_SKIP
    CV_typ_t        type;       // next valid index
    unsigned char   data[CV_ZEROLEN];     // pad data
} lfSkip;



//      argument list leaf


typedef struct lfArgList_16t {
    unsigned short  leaf;           // LF_ARGLIST_16t
    unsigned short  count;          // number of arguments
    CV_typ16_t      arg[CV_ZEROLEN];      // number of arguments
} lfArgList_16t;

typedef struct lfArgList {
    unsigned short  leaf;           // LF_ARGLIST
    unsigned long   count;          // number of arguments
    CV_typ_t        arg[CV_ZEROLEN];      // number of arguments
} lfArgList;




//      derived class list leaf


typedef struct lfDerived_16t {
    unsigned short  leaf;           // LF_DERIVED_16t
    unsigned short  count;          // number of arguments
    CV_typ16_t      drvdcls[CV_ZEROLEN];      // type indices of derived classes
} lfDerived_16t;

typedef struct lfDerived {
    unsigned short  leaf;           // LF_DERIVED
    unsigned long   count;          // number of arguments
    CV_typ_t        drvdcls[CV_ZEROLEN];      // type indices of derived classes
} lfDerived;




//      leaf for default arguments


typedef struct lfDefArg_16t {
    unsigned short  leaf;               // LF_DEFARG_16t
    CV_typ16_t      type;               // type of resulting expression
    unsigned char   expr[CV_ZEROLEN];   // length prefixed expression string
} lfDefArg_16t;

typedef struct lfDefArg {
    unsigned short  leaf;               // LF_DEFARG
    CV_typ_t        type;               // type of resulting expression
    unsigned char   expr[CV_ZEROLEN];   // length prefixed expression string
} lfDefArg;



//      list leaf
//          This list should no longer be used because the utilities cannot
//          verify the contents of the list without knowing what type of list
//          it is.  New specific leaf indices should be used instead.


typedef struct lfList {
    unsigned short  leaf;           // LF_LIST
    char            data[CV_ZEROLEN];         // data format specified by indexing type
} lfList;




//      field list leaf
//      This is the header leaf for a complex list of class and structure
//      subfields.


typedef struct lfFieldList_16t {
    unsigned short  leaf;           // LF_FIELDLIST_16t
    char            data[CV_ZEROLEN];         // field list sub lists
} lfFieldList_16t;


typedef struct lfFieldList {
    unsigned short  leaf;           // LF_FIELDLIST
    char            data[CV_ZEROLEN];         // field list sub lists
} lfFieldList;







//  type record for non-static methods and friends in overloaded method list

typedef struct mlMethod_16t {
    CV_fldattr_t   attr;           // method attribute
    CV_typ16_t     index;          // index to type record for procedure
    unsigned long  vbaseoff[CV_ZEROLEN];    // offset in vfunctable if intro virtual
} mlMethod_16t;

typedef struct mlMethod {
    CV_fldattr_t    attr;           // method attribute
    _2BYTEPAD       pad0;           // internal padding, must be 0
    CV_typ_t        index;          // index to type record for procedure
    unsigned long   vbaseoff[CV_ZEROLEN];    // offset in vfunctable if intro virtual
} mlMethod;


typedef struct lfMethodList_16t {
    unsigned short leaf;
    unsigned char  mList[CV_ZEROLEN];         // really a mlMethod_16t type
} lfMethodList_16t;

typedef struct lfMethodList {
    unsigned short leaf;
    unsigned char  mList[CV_ZEROLEN];         // really a mlMethod type
} lfMethodList;





//      type record for LF_BITFIELD


typedef struct lfBitfield_16t {
    unsigned short  leaf;           // LF_BITFIELD_16t
    unsigned char   length;
    unsigned char   position;
    CV_typ16_t      type;           // type of bitfield

} lfBitfield_16t;

typedef struct lfBitfield {
    unsigned short  leaf;           // LF_BITFIELD
    CV_typ_t        type;           // type of bitfield
    unsigned char   length;
    unsigned char   position;

} lfBitfield;




//      type record for dimensioned array with constant bounds


typedef struct lfDimCon_16t {
    unsigned short  leaf;           // LF_DIMCONU_16t or LF_DIMCONLU_16t
    unsigned short  rank;           // number of dimensions
    CV_typ16_t      typ;            // type of index
    unsigned char   dim[CV_ZEROLEN];          // array of dimension information with
                                    // either upper bounds or lower/upper bound
} lfDimCon_16t;

typedef struct lfDimCon {
    unsigned short  leaf;           // LF_DIMCONU or LF_DIMCONLU
    CV_typ_t        typ;            // type of index
    unsigned short  rank;           // number of dimensions
    unsigned char   dim[CV_ZEROLEN];          // array of dimension information with
                                    // either upper bounds or lower/upper bound
} lfDimCon;




//      type record for dimensioned array with variable bounds


typedef struct lfDimVar_16t {
    unsigned short  leaf;           // LF_DIMVARU_16t or LF_DIMVARLU_16t
    unsigned short  rank;           // number of dimensions
    CV_typ16_t      typ;            // type of index
    CV_typ16_t      dim[CV_ZEROLEN];          // array of type indices for either
                                    // variable upper bound or variable
                                    // lower/upper bound.  The referenced
                                    // types must be LF_REFSYM or T_VOID
} lfDimVar_16t;

typedef struct lfDimVar {
    unsigned short  leaf;           // LF_DIMVARU or LF_DIMVARLU
    unsigned long   rank;           // number of dimensions
    CV_typ_t        typ;            // type of index
    CV_typ_t        dim[CV_ZEROLEN];          // array of type indices for either
                                    // variable upper bound or variable
                                    // lower/upper bound.  The count of type
                                    // indices is rank or rank*2 depending on
                                    // whether it is LFDIMVARU or LF_DIMVARLU.
                                    // The referenced types must be
                                    // LF_REFSYM or T_VOID
} lfDimVar;




//      type record for referenced symbol


typedef struct lfRefSym {
    unsigned short  leaf;           // LF_REFSYM
    unsigned char   Sym[1];         // copy of referenced symbol record
                                    // (including length)
} lfRefSym;





/**     the following are numeric leaves.  They are used to indicate the
 *      size of the following variable length data.  When the numeric
 *      data is a single byte less than 0x8000, then the data is output
 *      directly.  If the data is more the 0x8000 or is a negative value,
 *      then the data is preceeded by the proper index.
 */



//      signed character leaf

typedef struct lfChar {
    unsigned short  leaf;           // LF_CHAR
    signed char     val;            // signed 8-bit value
} lfChar;




//      signed short leaf

typedef struct lfShort {
    unsigned short  leaf;           // LF_SHORT
    short           val;            // signed 16-bit value
} lfShort;




//      unsigned short leaf

typedef struct lfUShort {
    unsigned short  leaf;           // LF_unsigned short
    unsigned short  val;            // unsigned 16-bit value
} lfUShort;




//      signed long leaf

typedef struct lfLong {
    unsigned short  leaf;           // LF_LONG
    long            val;            // signed 32-bit value
} lfLong;




//      unsigned long leaf

typedef struct lfULong {
    unsigned short  leaf;           // LF_ULONG
    unsigned long   val;            // unsigned 32-bit value
} lfULong;




//      signed quad leaf

typedef struct lfQuad {
    unsigned short  leaf;           // LF_QUAD
    unsigned char   val[8];         // signed 64-bit value
} lfQuad;




//      unsigned quad leaf

typedef struct lfUQuad {
    unsigned short  leaf;           // LF_UQUAD
    unsigned char   val[8];         // unsigned 64-bit value
} lfUQuad;


//      signed int128 leaf

typedef struct lfOct {
    unsigned short  leaf;           // LF_OCT
    unsigned char   val[16];        // signed 128-bit value
} lfOct;

//      unsigned int128 leaf

typedef struct lfUOct {
    unsigned short  leaf;           // LF_UOCT
    unsigned char   val[16];        // unsigned 128-bit value
} lfUOct;




//      real 32-bit leaf

typedef struct lfReal32 {
    unsigned short  leaf;           // LF_REAL32
    float           val;            // 32-bit real value
} lfReal32;




//      real 48-bit leaf

typedef struct lfReal48 {
    unsigned short  leaf;           // LF_REAL48
    unsigned char   val[6];         // 48-bit real value
} lfReal48;




//      real 64-bit leaf

typedef struct lfReal64 {
    unsigned short  leaf;           // LF_REAL64
    double          val;            // 64-bit real value
} lfReal64;




//      real 80-bit leaf

typedef struct lfReal80 {
    unsigned short  leaf;           // LF_REAL80
    FLOAT10         val;            // real 80-bit value
} lfReal80;




//      real 128-bit leaf

typedef struct lfReal128 {
    unsigned short  leaf;           // LF_REAL128
    char            val[16];        // real 128-bit value
} lfReal128;




//      complex 32-bit leaf

typedef struct lfCmplx32 {
    unsigned short  leaf;           // LF_COMPLEX32
    float           val_real;       // real component
    float           val_imag;       // imaginary component
} lfCmplx32;




//      complex 64-bit leaf

typedef struct lfCmplx64 {
    unsigned short  leaf;           // LF_COMPLEX64
    double          val_real;       // real component
    double          val_imag;       // imaginary component
} flCmplx64;




//      complex 80-bit leaf

typedef struct lfCmplx80 {
    unsigned short  leaf;           // LF_COMPLEX80
    FLOAT10         val_real;       // real component
    FLOAT10         val_imag;       // imaginary component
} lfCmplx80;




//      complex 128-bit leaf

typedef struct lfCmplx128 {
    unsigned short  leaf;           // LF_COMPLEX128
    char            val_real[16];   // real component
    char            val_imag[16];   // imaginary component
} lfCmplx128;



//  variable length numeric field

typedef struct lfVarString {
    unsigned short  leaf;       // LF_VARSTRING
    unsigned short  len;        // length of value in bytes
    unsigned char   value[CV_ZEROLEN];  // value
} lfVarString;

//***********************************************************************


//      index leaf - contains type index of another leaf
//      a major use of this leaf is to allow the compilers to emit a
//      long complex list (LF_FIELD) in smaller pieces.

typedef struct lfIndex_16t {
    unsigned short  leaf;           // LF_INDEX_16t
    CV_typ16_t      index;          // type index of referenced leaf
} lfIndex_16t;

typedef struct lfIndex {
    unsigned short  leaf;           // LF_INDEX
    _2BYTEPAD       pad0;           // internal padding, must be 0
    CV_typ_t        index;          // type index of referenced leaf
} lfIndex;


//      subfield record for base class field

typedef struct lfBClass_16t {
    unsigned short  leaf;           // LF_BCLASS_16t
    CV_typ16_t      index;          // type index of base class
    CV_fldattr_t    attr;           // attribute
    unsigned char   offset[CV_ZEROLEN];       // variable length offset of base within class
} lfBClass_16t;

typedef struct lfBClass {
    unsigned short  leaf;           // LF_BCLASS
    CV_fldattr_t    attr;           // attribute
    CV_typ_t        index;          // type index of base class
    unsigned char   offset[CV_ZEROLEN];       // variable length offset of base within class
} lfBClass;





//      subfield record for direct and indirect virtual base class field

typedef struct lfVBClass_16t {
    unsigned short  leaf;           // LF_VBCLASS_16t | LV_IVBCLASS_16t
    CV_typ16_t      index;          // type index of direct virtual base class
    CV_typ16_t      vbptr;          // type index of virtual base pointer
    CV_fldattr_t    attr;           // attribute
    unsigned char   vbpoff[CV_ZEROLEN];       // virtual base pointer offset from address point
                                    // followed by virtual base offset from vbtable
} lfVBClass_16t;

typedef struct lfVBClass {
    unsigned short  leaf;           // LF_VBCLASS | LV_IVBCLASS
    CV_fldattr_t    attr;           // attribute
    CV_typ_t        index;          // type index of direct virtual base class
    CV_typ_t        vbptr;          // type index of virtual base pointer
    unsigned char   vbpoff[CV_ZEROLEN];       // virtual base pointer offset from address point
                                    // followed by virtual base offset from vbtable
} lfVBClass;





//      subfield record for friend class


typedef struct lfFriendCls_16t {
    unsigned short  leaf;           // LF_FRIENDCLS_16t
    CV_typ16_t      index;          // index to type record of friend class
} lfFriendCls_16t;

typedef struct lfFriendCls {
    unsigned short  leaf;           // LF_FRIENDCLS
    _2BYTEPAD       pad0;           // internal padding, must be 0
    CV_typ_t        index;          // index to type record of friend class
} lfFriendCls;





//      subfield record for friend function


typedef struct lfFriendFcn_16t {
    unsigned short  leaf;           // LF_FRIENDFCN_16t
    CV_typ16_t      index;          // index to type record of friend function
    unsigned char   Name[1];        // name of friend function
} lfFriendFcn_16t;

typedef struct lfFriendFcn {
    unsigned short  leaf;           // LF_FRIENDFCN
    _2BYTEPAD       pad0;           // internal padding, must be 0
    CV_typ_t        index;          // index to type record of friend function
    unsigned char   Name[1];        // name of friend function
} lfFriendFcn;



//      subfield record for non-static data members

typedef struct lfMember_16t {
    unsigned short  leaf;           // LF_MEMBER_16t
    CV_typ16_t      index;          // index of type record for field
    CV_fldattr_t    attr;           // attribute mask
    unsigned char   offset[CV_ZEROLEN];       // variable length offset of field followed
                                    // by length prefixed name of field
} lfMember_16t;

typedef struct lfMember {
    unsigned short  leaf;           // LF_MEMBER
    CV_fldattr_t    attr;           // attribute mask
    CV_typ_t        index;          // index of type record for field
    unsigned char   offset[CV_ZEROLEN];       // variable length offset of field followed
                                    // by length prefixed name of field
} lfMember;



//  type record for static data members

typedef struct lfSTMember_16t {
    unsigned short  leaf;           // LF_STMEMBER_16t
    CV_typ16_t      index;          // index of type record for field
    CV_fldattr_t    attr;           // attribute mask
    unsigned char   Name[1];        // length prefixed name of field
} lfSTMember_16t;

typedef struct lfSTMember {
    unsigned short  leaf;           // LF_STMEMBER
    CV_fldattr_t    attr;           // attribute mask
    CV_typ_t        index;          // index of type record for field
    unsigned char   Name[1];        // length prefixed name of field
} lfSTMember;



//      subfield record for virtual function table pointer

typedef struct lfVFuncTab_16t {
    unsigned short  leaf;           // LF_VFUNCTAB_16t
    CV_typ16_t      type;           // type index of pointer
} lfVFuncTab_16t;

typedef struct lfVFuncTab {
    unsigned short  leaf;           // LF_VFUNCTAB
    _2BYTEPAD       pad0;           // internal padding, must be 0
    CV_typ_t        type;           // type index of pointer
} lfVFuncTab;



//      subfield record for virtual function table pointer with offset

typedef struct lfVFuncOff_16t {
    unsigned short  leaf;           // LF_VFUNCOFF_16t
    CV_typ16_t      type;           // type index of pointer
    CV_off32_t      offset;         // offset of virtual function table pointer
} lfVFuncOff_16t;

typedef struct lfVFuncOff {
    unsigned short  leaf;           // LF_VFUNCOFF
    _2BYTEPAD       pad0;           // internal padding, must be 0.
    CV_typ_t        type;           // type index of pointer
    CV_off32_t      offset;         // offset of virtual function table pointer
} lfVFuncOff;



//      subfield record for overloaded method list


typedef struct lfMethod_16t {
    unsigned short  leaf;           // LF_METHOD_16t
    unsigned short  count;          // number of occurrences of function
    CV_typ16_t      mList;          // index to LF_METHODLIST record
    unsigned char   Name[1];        // length prefixed name of method
} lfMethod_16t;

typedef struct lfMethod {
    unsigned short  leaf;           // LF_METHOD
    unsigned short  count;          // number of occurrences of function
    CV_typ_t        mList;          // index to LF_METHODLIST record
    unsigned char   Name[1];        // length prefixed name of method
} lfMethod;



//      subfield record for nonoverloaded method


typedef struct lfOneMethod_16t {
    unsigned short leaf;            // LF_ONEMETHOD_16t
    CV_fldattr_t   attr;            // method attribute
    CV_typ16_t     index;           // index to type record for procedure
    unsigned long  vbaseoff[CV_ZEROLEN];    // offset in vfunctable if
                                    // intro virtual followed by
                                    // length prefixed name of method
} lfOneMethod_16t;

typedef struct lfOneMethod {
    unsigned short leaf;            // LF_ONEMETHOD
    CV_fldattr_t   attr;            // method attribute
    CV_typ_t       index;           // index to type record for procedure
    unsigned long  vbaseoff[CV_ZEROLEN];    // offset in vfunctable if
                                    // intro virtual followed by
                                    // length prefixed name of method
} lfOneMethod;


//      subfield record for enumerate

typedef struct lfEnumerate {
    unsigned short  leaf;       // LF_ENUMERATE
    CV_fldattr_t    attr;       // access
    unsigned char   value[CV_ZEROLEN];    // variable length value field followed
                                // by length prefixed name
} lfEnumerate;


//  type record for nested (scoped) type definition

typedef struct lfNestType_16t {
    unsigned short  leaf;       // LF_NESTTYPE_16t
    CV_typ16_t      index;      // index of nested type definition
    unsigned char   Name[1];    // length prefixed type name
} lfNestType_16t;

typedef struct lfNestType {
    unsigned short  leaf;       // LF_NESTTYPE
    _2BYTEPAD       pad0;       // internal padding, must be 0
    CV_typ_t        index;      // index of nested type definition
    unsigned char   Name[1];    // length prefixed type name
} lfNestType;

//  type record for nested (scoped) type definition, with attributes
//  new records for vC v5.0, no need to have 16-bit ti versions.

typedef struct lfNestTypeEx {
    unsigned short  leaf;       // LF_NESTTYPEEX
    CV_fldattr_t    attr;       // member access
    CV_typ_t        index;      // index of nested type definition
    unsigned char   Name[1];    // length prefixed type name
} lfNestTypeEx;

//  type record for modifications to members

typedef struct lfMemberModify {
    unsigned short  leaf;       // LF_MEMBERMODIFY
    CV_fldattr_t    attr;       // the new attributes
    CV_typ_t        index;      // index of base class type definition
    unsigned char   Name[1];    // length prefixed member name
} lfMemberModify;

//  type record for pad leaf

typedef struct lfPad {
    unsigned char   leaf;
} SYM_PAD;



//  Symbol definitions

typedef enum SYM_ENUM_e {
    S_COMPILE       =  0x0001, // Compile flags symbol
    S_REGISTER_16t  =  0x0002, // Register variable
    S_CONSTANT_16t  =  0x0003, // constant symbol
    S_UDT_16t       =  0x0004, // User defined type
    S_SSEARCH       =  0x0005, // Start Search
    S_END           =  0x0006, // Block, procedure, "with" or thunk end
    S_SKIP          =  0x0007, // Reserve symbol space in $$Symbols table
    S_CVRESERVE     =  0x0008, // Reserved symbol for CV internal use
    S_OBJNAME       =  0x0009, // path to object file name
    S_ENDARG        =  0x000a, // end of argument/return list
    S_COBOLUDT_16t  =  0x000b, // special UDT for cobol that does not symbol pack
    S_MANYREG_16t   =  0x000c, // multiple register variable
    S_RETURN        =  0x000d, // return description symbol
    S_ENTRYTHIS     =  0x000e, // description of this pointer on entry

    S_BPREL16       =  0x0100, // BP-relative
    S_LDATA16       =  0x0101, // Module-local symbol
    S_GDATA16       =  0x0102, // Global data symbol
    S_PUB16         =  0x0103, // a public symbol
    S_LPROC16       =  0x0104, // Local procedure start
    S_GPROC16       =  0x0105, // Global procedure start
    S_THUNK16       =  0x0106, // Thunk Start
    S_BLOCK16       =  0x0107, // block start
    S_WITH16        =  0x0108, // with start
    S_LABEL16       =  0x0109, // code label
    S_CEXMODEL16    =  0x010a, // change execution model
    S_VFTABLE16     =  0x010b, // address of virtual function table
    S_REGREL16      =  0x010c, // register relative address

    S_BPREL32_16t   =  0x0200, // BP-relative
    S_LDATA32_16t   =  0x0201, // Module-local symbol
    S_GDATA32_16t   =  0x0202, // Global data symbol
    S_PUB32_16t     =  0x0203, // a public symbol (CV internal reserved)
    S_LPROC32_16t   =  0x0204, // Local procedure start
    S_GPROC32_16t   =  0x0205, // Global procedure start
    S_THUNK32       =  0x0206, // Thunk Start
    S_BLOCK32       =  0x0207, // block start
    S_WITH32        =  0x0208, // with start
    S_LABEL32       =  0x0209, // code label
    S_CEXMODEL32    =  0x020a, // change execution model
    S_VFTABLE32_16t =  0x020b, // address of virtual function table
    S_REGREL32_16t  =  0x020c, // register relative address
    S_LTHREAD32_16t =  0x020d, // local thread storage
    S_GTHREAD32_16t =  0x020e, // global thread storage
    S_SLINK32       =  0x020f, // static link for MIPS EH implementation

    S_LPROCMIPS_16t =  0x0300, // Local procedure start
    S_GPROCMIPS_16t =  0x0301, // Global procedure start

    S_PROCREF       =  0x0400, // Reference to a procedure
    S_DATAREF       =  0x0401, // Reference to data
    S_ALIGN         =  0x0402, // Used for page alignment of symbols
    S_LPROCREF      =  0x0403, // Local Reference to a procedure

    // sym records with 32-bit types embedded instead of 16-bit
    // all have 0x1000 bit set for easy identification
    // only do the 32-bit target versions since we don't really
    // care about 16-bit ones anymore.
S_TI16_MAX          =  0x1000,
    S_REGISTER      =  0x1001, // Register variable
    S_CONSTANT      =  0x1002, // constant symbol
    S_UDT           =  0x1003, // User defined type
    S_COBOLUDT      =  0x1004, // special UDT for cobol that does not symbol pack
    S_MANYREG       =  0x1005, // multiple register variable
    S_BPREL32       =  0x1006, // BP-relative
    S_LDATA32       =  0x1007, // Module-local symbol
    S_GDATA32       =  0x1008, // Global data symbol
    S_PUB32         =  0x1009, // a public symbol (CV internal reserved)
    S_LPROC32       =  0x100a, // Local procedure start
    S_GPROC32       =  0x100b, // Global procedure start
    S_VFTABLE32     =  0x100c, // address of virtual function table
    S_REGREL32      =  0x100d, // register relative address
    S_LTHREAD32     =  0x100e, // local thread storage
    S_GTHREAD32     =  0x100f, // global thread storage

    S_LPROCMIPS     =  0x1010, // Local procedure start
    S_GPROCMIPS     =  0x1011, // Global procedure start

    // new symbol records for edit and continue information

    S_FRAMEPROC     =  0x1012, // extra frame and proc information
    S_COMPILE2      =  0x1013, // extended compile flags and info

    // new symbols necessary for 16-bit enumerates of IA64 registers
    // and IA64 specific symbols

    S_MANYREG2      =  0x1014, // multiple register variable
    S_LPROCIA64     =  0x1015, // Local procedure start (IA64)
    S_GPROCIA64     =  0x1016, // Global procedure start (IA64)

    S_RECTYPE_MAX,             // one greater than last
    S_RECTYPE_LAST  = S_RECTYPE_MAX - 1,

} SYM_ENUM_e;




//  enum describing the compile flag source language


typedef enum CV_CFL_LANG {
    CV_CFL_C        = 0x00,
    CV_CFL_CXX      = 0x01,
    CV_CFL_FORTRAN  = 0x02,
    CV_CFL_MASM     = 0x03,
    CV_CFL_PASCAL   = 0x04,
    CV_CFL_BASIC    = 0x05,
    CV_CFL_COBOL    = 0x06,
    CV_CFL_LINK     = 0x07,
    CV_CFL_CVTRES   = 0x08,
} CV_CFL_LANG;



//  enum describing target processor


typedef enum CV_CPU_TYPE_e {
    CV_CFL_8080         = 0x00,
    CV_CFL_8086         = 0x01,
    CV_CFL_80286        = 0x02,
    CV_CFL_80386        = 0x03,
    CV_CFL_80486        = 0x04,
    CV_CFL_PENTIUM      = 0x05,
    CV_CFL_PENTIUMPRO   = 0x06,
    CV_CFL_MIPSR4000    = 0x10,
    CV_CFL_MIPS16       = 0x11,
    CV_CFL_M68000       = 0x20,
    CV_CFL_M68010       = 0x21,
    CV_CFL_M68020       = 0x22,
    CV_CFL_M68030       = 0x23,
    CV_CFL_M68040       = 0x24,
    CV_CFL_ALPHA        = 0x30,
    CV_CFL_ALPHA_21064  = 0x30,
    CV_CFL_ALPHA_21164  = 0x31,
    CV_CFL_ALPHA_21164A = 0x32,
    CV_CFL_ALPHA_21264  = 0x33,
    CV_CFL_ALPHA_21364  = 0x34,
    CV_CFL_PPC601       = 0x40,
    CV_CFL_PPC603       = 0x41,
    CV_CFL_PPC604       = 0x42,
    CV_CFL_PPC620       = 0x43,
    CV_CFL_SH3          = 0x50,
    CV_CFL_SH3E         = 0x51,
    CV_CFL_SH3DSP       = 0x52,
    CV_CFL_SH4          = 0x53,
    CV_CFL_ARM3         = 0x60,
    CV_CFL_ARM4         = 0x61,
    CV_CFL_ARM4T        = 0x62,
    CV_CFL_OMNI         = 0x70,
    CV_CFL_IA64         = 0x80,
} CV_CPU_TYPE_e;


//  enum describing compile flag ambient data model


typedef enum CV_CFL_DATA {
    CV_CFL_DNEAR    = 0x00,
    CV_CFL_DFAR     = 0x01,
    CV_CFL_DHUGE    = 0x02
} CV_CFL_DATA;




//  enum describing compile flag ambiant code model


typedef enum CV_CFL_CODE_e {
    CV_CFL_CNEAR    = 0x00,
    CV_CFL_CFAR     = 0x01,
    CV_CFL_CHUGE    = 0x02
} CV_CFL_CODE_e;




//  enum describing compile flag target floating point package

typedef enum CV_CFL_FPKG_e {
    CV_CFL_NDP      = 0x00,
    CV_CFL_EMU      = 0x01,
    CV_CFL_ALT      = 0x02
} CV_CFL_FPKG_e;


// enum describing function return method


typedef struct CV_PROCFLAGS {
    union {
        unsigned char   bAll;
        struct {
            unsigned char CV_PFLAG_NOFPO     :1; // frame pointer present
            unsigned char CV_PFLAG_INT       :1; // interrupt return
            unsigned char CV_PFLAG_FAR       :1; // far return
            unsigned char CV_PFLAG_NEVER     :1; // function does not return
            unsigned char CV_PFLAG_NOTREACHED:1; // label isn't fallen into
            unsigned char unused             :3; //
        };
    };
} CV_PROCFLAGS;


// enum describing function data return method

typedef enum CV_GENERIC_STYLE_e {
    CV_GENERIC_VOID   = 0x00,       // void return type
    CV_GENERIC_REG    = 0x01,       // return data is in registers
    CV_GENERIC_ICAN   = 0x02,       // indirect caller allocated near
    CV_GENERIC_ICAF   = 0x03,       // indirect caller allocated far
    CV_GENERIC_IRAN   = 0x04,       // indirect returnee allocated near
    CV_GENERIC_IRAF   = 0x05,       // indirect returnee allocated far
    CV_GENERIC_UNUSED = 0x06        // first unused
} CV_GENERIC_STYLE_e;


typedef struct CV_GENERIC_FLAG {
    unsigned short  cstyle  :1;     // true push varargs right to left
    unsigned short  rsclean :1;     // true if returnee stack cleanup
    unsigned short  unused  :14;    // unused
} CV_GENERIC_FLAG;





typedef struct SYMTYPE {
    unsigned short      reclen;     // Record length
    unsigned short      rectyp;     // Record type
    char                data[CV_ZEROLEN];
} SYMTYPE;

__INLINE SYMTYPE *NextSym (SYMTYPE * pSym) {
    return (SYMTYPE *) ((char *)pSym + pSym->reclen + sizeof(unsigned short));
}

//      non-model specific symbol types



typedef struct REGSYM_16t {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_REGISTER_16t
    CV_typ16_t      typind;     // Type index
    unsigned short  reg;        // register enumerate
    unsigned char   name[1];    // Length-prefixed name
} REGSYM_16t;

typedef struct REGSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_REGISTER
    CV_typ_t        typind;     // Type index
    unsigned short  reg;        // register enumerate
    unsigned char   name[1];    // Length-prefixed name
} REGSYM;



typedef struct MANYREGSYM_16t {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_MANYREG_16t
    CV_typ16_t      typind;     // Type index
    unsigned char   count;      // count of number of registers
    unsigned char   reg[1];     // count register enumerates followed by
                                // length-prefixed name.  Registers are
                                // most significant first.
} MANYREGSYM_16t;

typedef struct MANYREGSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_MANYREG
    CV_typ_t        typind;     // Type index
    unsigned char   count;      // count of number of registers
    unsigned char   reg[1];     // count register enumerates followed by
                                // length-prefixed name.  Registers are
                                // most significant first.
} MANYREGSYM;

typedef struct MANYREGSYM2 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_MANYREG2
    CV_typ_t        typind;     // Type index
    unsigned short  count;      // count of number of registers
    unsigned short  reg[1];     // count register enumerates followed by
                                // length-prefixed name.  Registers are
                                // most significant first.
} MANYREGSYM2;

typedef struct CONSTSYM_16t {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_CONSTANT_16t
    CV_typ16_t      typind;     // Type index (containing enum if enumerate)
    unsigned short  value;      // numeric leaf containing value
    unsigned char   name[CV_ZEROLEN];     // Length-prefixed name
} CONSTSYM_16t;

typedef struct CONSTSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_CONSTANT
    CV_typ_t        typind;     // Type index (containing enum if enumerate)
    unsigned short  value;      // numeric leaf containing value
    unsigned char   name[CV_ZEROLEN];     // Length-prefixed name
} CONSTSYM;


typedef struct UDTSYM_16t {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_UDT_16t | S_COBOLUDT_16t
    CV_typ16_t      typind;     // Type index
    unsigned char   name[1];    // Length-prefixed name
} UDTSYM_16t;

typedef struct UDTSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_UDT | S_COBOLUDT
    CV_typ_t        typind;     // Type index
    unsigned char   name[1];    // Length-prefixed name
} UDTSYM;

typedef struct SEARCHSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_SSEARCH
    unsigned long   startsym;   // offset of the procedure
    unsigned short  seg;        // segment of symbol
} SEARCHSYM;

typedef struct CFLAGSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_COMPILE
    unsigned char   machine;    // target processor
    struct  {
        unsigned char   language    :8; // language index
        unsigned char   pcode       :1; // true if pcode present
        unsigned char   floatprec   :2; // floating precision
        unsigned char   floatpkg    :2; // float package
        unsigned char   ambdata     :3; // ambient data model
        unsigned char   ambcode     :3; // ambient code model
        unsigned char   mode32      :1; // true if compiled 32 bit mode
        unsigned char   pad         :4; // reserved
    } flags;
    unsigned char       ver[1];     // Length-prefixed compiler version string
} CFLAGSYM;


typedef struct COMPILESYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_COMPILE2
    struct {
        unsigned long   iLanguage   :  8;   // language index
        unsigned long   fEC         :  1;   // compiled for E/C
        unsigned long   pad         : 23;   // reserved, must be 0
    } flags;
    unsigned short  machine;    // target processor
    unsigned short  verFEMajor; // front end major version #
    unsigned short  verFEMinor; // front end minor version #
    unsigned short  verFEBuild; // front end build version #
    unsigned short  verMajor;   // back end major version #
    unsigned short  verMinor;   // back end minor version #
    unsigned short  verBuild;   // back end build version #
    unsigned char   verSt[1];   // Length-prefixed compiler version string, followed
                                //  by an optional block of zero terminated strings
                                //  terminated with a double zero.
} COMPILESYM;

typedef struct OBJNAMESYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_OBJNAME
    unsigned long   signature;  // signature
    unsigned char   name[1];    // Length-prefixed name
} OBJNAMESYM;




typedef struct ENDARGSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_ENDARG
} ENDARGSYM;


typedef struct RETURNSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_RETURN
    CV_GENERIC_FLAG flags;      // flags
    unsigned char   style;      // CV_GENERIC_STYLE_e return style
                                // followed by return method data
} RETURNSYM;


typedef struct ENTRYTHISSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_ENTRYTHIS
    unsigned char   thissym;    // symbol describing this pointer on entry
} ENTRYTHISSYM;


//      symbol types for 16:16 memory model


typedef struct BPRELSYM16 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_BPREL16
    CV_off16_t      off;        // BP-relative offset
    CV_typ16_t      typind;     // Type index
    unsigned char   name[1];    // Length-prefixed name
} BPRELSYM16;



typedef struct DATASYM16 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_LDATA or S_GDATA
    CV_uoff16_t     off;        // offset of symbol
    unsigned short  seg;        // segment of symbol
    CV_typ16_t      typind;     // Type index
    unsigned char   name[1];    // Length-prefixed name
} DATASYM16;
typedef DATASYM16 PUBSYM16;


typedef struct PROCSYM16 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_GPROC16 or S_LPROC16
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned long   pNext;      // pointer to next symbol
    unsigned short  len;        // Proc length
    unsigned short  DbgStart;   // Debug start offset
    unsigned short  DbgEnd;     // Debug end offset
    CV_uoff16_t     off;        // offset of symbol
    unsigned short  seg;        // segment of symbol
    CV_typ16_t      typind;     // Type index
    CV_PROCFLAGS    flags;      // Proc flags
    unsigned char   name[1];    // Length-prefixed name
} PROCSYM16;




typedef struct THUNKSYM16 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_THUNK
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned long   pNext;      // pointer to next symbol
    CV_uoff16_t     off;        // offset of symbol
    unsigned short  seg;        // segment of symbol
    unsigned short  len;        // length of thunk
    unsigned char   ord;        // THUNK_ORDINAL specifying type of thunk
    unsigned char   name[1];    // name of thunk
    unsigned char   variant[CV_ZEROLEN]; // variant portion of thunk
} THUNKSYM16;

typedef enum {
    THUNK_ORDINAL_NOTYPE,       // standard thunk
    THUNK_ORDINAL_ADJUSTOR,     // "this" adjustor thunk
    THUNK_ORDINAL_VCALL,        // virtual call thunk
    THUNK_ORDINAL_PCODE,        // pcode thunk
    THUNK_ORDINAL_LOAD,         // thunk which loads the address to jump to
                                //  via unknown means...
} THUNK_ORDINAL;

typedef struct LABELSYM16 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_LABEL16
    CV_uoff16_t     off;        // offset of symbol
    unsigned short  seg;        // segment of symbol
    CV_PROCFLAGS    flags;      // flags
    unsigned char   name[1];    // Length-prefixed name
} LABELSYM16;

typedef struct BLOCKSYM16 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_BLOCK16
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned short  len;        // Block length
    CV_uoff16_t     off;        // offset of symbol
    unsigned short  seg;        // segment of symbol
    unsigned char   name[1];    // Length-prefixed name
} BLOCKSYM16;

typedef struct WITHSYM16 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_WITH16
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned short  len;        // Block length
    CV_uoff16_t     off;        // offset of symbol
    unsigned short  seg;        // segment of symbol
    unsigned char   expr[1];    // Length-prefixed expression
} WITHSYM16;




typedef enum CEXM_MODEL_e {
    CEXM_MDL_table          = 0x00, // not executable
    CEXM_MDL_jumptable      = 0x01, // Compiler generated jump table
    CEXM_MDL_datapad        = 0x02, // Data padding for alignment
    CEXM_MDL_native         = 0x20, // native (actually not-pcode)
    CEXM_MDL_cobol          = 0x21, // cobol
    CEXM_MDL_codepad        = 0x22, // Code padding for alignment
    CEXM_MDL_code           = 0x23, // code
    CEXM_MDL_sql            = 0x30, // sql
    CEXM_MDL_pcode          = 0x40, // pcode
    CEXM_MDL_pcode32Mac     = 0x41, // macintosh 32 bit pcode
    CEXM_MDL_pcode32MacNep  = 0x42, // macintosh 32 bit pcode native entry point
    CEXM_MDL_javaInt        = 0x50,
    CEXM_MDL_unknown        = 0xff
} CEXM_MODEL_e;

// use the correct enumerate name
#define CEXM_MDL_SQL CEXM_MDL_sql

typedef enum CV_COBOL_e {
    CV_COBOL_dontstop,
    CV_COBOL_pfm,
    CV_COBOL_false,
    CV_COBOL_extcall
} CV_COBOL_e;

typedef struct CEXMSYM16 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_CEXMODEL16
    CV_uoff16_t     off;        // offset of symbol
    unsigned short  seg;        // segment of symbol
    unsigned short  model;      // execution model
    union {
        struct  {
            CV_uoff16_t pcdtable;   // offset to pcode function table
            CV_uoff16_t pcdspi;     // offset to segment pcode information
        } pcode;
        struct {
            unsigned short  subtype;   // see CV_COBOL_e above
            unsigned short  flag;
        } cobol;
    };
} CEXMSYM16;




typedef struct VPATHSYM16 {
    unsigned short  reclen;     // record length
    unsigned short  rectyp;     // S_VFTPATH16
    CV_uoff16_t     off;        // offset of virtual function table
    unsigned short  seg;        // segment of virtual function table
    CV_typ16_t      root;       // type index of the root of path
    CV_typ16_t      path;       // type index of the path record
} VPATHSYM16;




typedef struct REGREL16 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_REGREL16
    CV_uoff16_t     off;        // offset of symbol
    unsigned short  reg;        // register index
    CV_typ16_t      typind;     // Type index
    unsigned char   name[1];    // Length-prefixed name
} REGREL16;





typedef struct BPRELSYM32_16t {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_BPREL32_16t
    CV_off32_t      off;        // BP-relative offset
    CV_typ16_t      typind;     // Type index
    unsigned char   name[1];    // Length-prefixed name
} BPRELSYM32_16t;

typedef struct BPRELSYM32 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_BPREL32
    CV_off32_t      off;        // BP-relative offset
    CV_typ_t        typind;     // Type index
    unsigned char   name[1];    // Length-prefixed name
} BPRELSYM32;

typedef struct DATASYM32_16t {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_LDATA32_16t, S_GDATA32_16t or S_PUB32_16t
    CV_uoff32_t     off;
    unsigned short  seg;
    CV_typ16_t      typind;     // Type index
    unsigned char   name[1];    // Length-prefixed name
} DATASYM32_16t;
typedef DATASYM32_16t PUBSYM32_16t;

typedef struct DATASYM32 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_LDATA32, S_GDATA32 or S_PUB32
    CV_typ_t        typind;     // Type index
    CV_uoff32_t     off;
    unsigned short  seg;
    unsigned char   name[1];    // Length-prefixed name
} DATASYM32;
typedef DATASYM32 PUBSYM32;



typedef struct PROCSYM32_16t {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_GPROC32_16t or S_LPROC32_16t
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned long   pNext;      // pointer to next symbol
    unsigned long   len;        // Proc length
    unsigned long   DbgStart;   // Debug start offset
    unsigned long   DbgEnd;     // Debug end offset
    CV_uoff32_t     off;
    unsigned short  seg;
    CV_typ16_t      typind;     // Type index
    CV_PROCFLAGS    flags;      // Proc flags
    unsigned char   name[1];    // Length-prefixed name
} PROCSYM32_16t;

typedef struct PROCSYM32 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_GPROC32 or S_LPROC32
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned long   pNext;      // pointer to next symbol
    unsigned long   len;        // Proc length
    unsigned long   DbgStart;   // Debug start offset
    unsigned long   DbgEnd;     // Debug end offset
    CV_typ_t        typind;     // Type index
    CV_uoff32_t     off;
    unsigned short  seg;
    CV_PROCFLAGS    flags;      // Proc flags
    unsigned char   name[1];    // Length-prefixed name
} PROCSYM32;


typedef struct THUNKSYM32 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_THUNK32
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned long   pNext;      // pointer to next symbol
    CV_uoff32_t     off;
    unsigned short  seg;
    unsigned short  len;        // length of thunk
    unsigned char   ord;        // THUNK_ORDINAL specifying type of thunk
    unsigned char   name[1];    // Length-prefixed name
    unsigned char   variant[CV_ZEROLEN]; // variant portion of thunk
} THUNKSYM32;




typedef struct LABELSYM32 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_LABEL32
    CV_uoff32_t     off;
    unsigned short  seg;
    CV_PROCFLAGS    flags;      // flags
    unsigned char   name[1];    // Length-prefixed name
} LABELSYM32;


typedef struct BLOCKSYM32 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_BLOCK32
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned long   len;        // Block length
    CV_uoff32_t     off;        // Offset in code segment
    unsigned short  seg;        // segment of label
    unsigned char   name[1];    // Length-prefixed name
} BLOCKSYM32;


typedef struct WITHSYM32 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_WITH32
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned long   len;        // Block length
    CV_uoff32_t     off;        // Offset in code segment
    unsigned short  seg;        // segment of label
    unsigned char   expr[1];    // Length-prefixed expression string
} WITHSYM32;



typedef struct CEXMSYM32 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_CEXMODEL32
    CV_uoff32_t     off;        // offset of symbol
    unsigned short  seg;        // segment of symbol
    unsigned short  model;      // execution model
    union {
        struct  {
            CV_uoff32_t pcdtable;   // offset to pcode function table
            CV_uoff32_t pcdspi;     // offset to segment pcode information
        } pcode;
        struct {
            unsigned short  subtype;   // see CV_COBOL_e above
            unsigned short  flag;
        } cobol;
        struct {
            CV_uoff32_t calltableOff; // offset to function table
            unsigned short calltableSeg; // segment of function table
        } pcode32Mac;
    };
} CEXMSYM32;



typedef struct VPATHSYM32_16t {
    unsigned short  reclen;     // record length
    unsigned short  rectyp;     // S_VFTABLE32_16t
    CV_uoff32_t     off;        // offset of virtual function table
    unsigned short  seg;        // segment of virtual function table
    CV_typ16_t      root;       // type index of the root of path
    CV_typ16_t      path;       // type index of the path record
} VPATHSYM32_16t;

typedef struct VPATHSYM32 {
    unsigned short  reclen;     // record length
    unsigned short  rectyp;     // S_VFTABLE32
    CV_typ_t        root;       // type index of the root of path
    CV_typ_t        path;       // type index of the path record
    CV_uoff32_t     off;        // offset of virtual function table
    unsigned short  seg;        // segment of virtual function table
} VPATHSYM32;





typedef struct REGREL32_16t {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_REGREL32_16t
    CV_uoff32_t     off;        // offset of symbol
    unsigned short  reg;        // register index for symbol
    CV_typ16_t      typind;     // Type index
    unsigned char   name[1];    // Length-prefixed name
} REGREL32_16t;

typedef struct REGREL32 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_REGREL32
    CV_uoff32_t     off;        // offset of symbol
    CV_typ_t        typind;     // Type index
    unsigned short  reg;        // register index for symbol
    unsigned char   name[1];    // Length-prefixed name
} REGREL32;



typedef struct THREADSYM32_16t {
    unsigned short  reclen;     // record length
    unsigned short  rectyp;     // S_LTHREAD32_16t | S_GTHREAD32_16t
    CV_uoff32_t     off;        // offset into thread storage
    unsigned short  seg;        // segment of thread storage
    CV_typ16_t      typind;     // type index
    unsigned char   name[1];    // length prefixed name
} THREADSYM32_16t;

typedef struct THREADSYM32 {
    unsigned short  reclen;     // record length
    unsigned short  rectyp;     // S_LTHREAD32 | S_GTHREAD32
    CV_typ_t        typind;     // type index
    CV_uoff32_t     off;        // offset into thread storage
    unsigned short  seg;        // segment of thread storage
    unsigned char   name[1];    // length prefixed name
} THREADSYM32;

typedef struct SLINK32 {
    unsigned short  reclen;     // record length
    unsigned short  rectyp;     // S_SLINK32
    unsigned long   framesize;  // frame size of parent procedure
    CV_off32_t      off;        // signed offset where the static link was saved relative to the value of reg
    unsigned short  reg;
} SLINK32;

typedef struct PROCSYMMIPS_16t {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_GPROCMIPS_16t or S_LPROCMIPS_16t
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned long   pNext;      // pointer to next symbol
    unsigned long   len;        // Proc length
    unsigned long   DbgStart;   // Debug start offset
    unsigned long   DbgEnd;     // Debug end offset
    unsigned long   regSave;    // int register save mask
    unsigned long   fpSave;     // fp register save mask
    CV_uoff32_t     intOff;     // int register save offset
    CV_uoff32_t     fpOff;      // fp register save offset
    CV_uoff32_t     off;        // Symbol offset
    unsigned short  seg;        // Symbol segment
    CV_typ16_t      typind;     // Type index
    unsigned char   retReg;     // Register return value is in
    unsigned char   frameReg;   // Frame pointer register
    unsigned char   name[1];    // Length-prefixed name
} PROCSYMMIPS_16t;

typedef struct PROCSYMMIPS {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_GPROCMIPS or S_LPROCMIPS
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned long   pNext;      // pointer to next symbol
    unsigned long   len;        // Proc length
    unsigned long   DbgStart;   // Debug start offset
    unsigned long   DbgEnd;     // Debug end offset
    unsigned long   regSave;    // int register save mask
    unsigned long   fpSave;     // fp register save mask
    CV_uoff32_t     intOff;     // int register save offset
    CV_uoff32_t     fpOff;      // fp register save offset
    CV_typ_t        typind;     // Type index
    CV_uoff32_t     off;        // Symbol offset
    unsigned short  seg;        // Symbol segment
    unsigned char   retReg;     // Register return value is in
    unsigned char   frameReg;   // Frame pointer register
    unsigned char   name[1];    // Length-prefixed name
} PROCSYMMIPS;


typedef struct PROCSYMIA64 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_GPROCIA64 or S_LPROCIA64
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned long   pNext;      // pointer to next symbol
    unsigned long   len;        // Proc length
    unsigned long   DbgStart;   // Debug start offset
    unsigned long   DbgEnd;     // Debug end offset
    CV_typ_t        typind;     // Type index
    CV_uoff32_t     off;        // Symbol offset
    unsigned short  seg;        // Symbol segment
    unsigned short  retReg;     // Register return value is in
    CV_PROCFLAGS    flags;      // Proc flags
    unsigned char   name[1];    // Length-prefixed name
} PROCSYMIA64;


typedef struct REFSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_PROCREF, S_DATAREF, or S_LPROCREF
    unsigned long   sumName;    // SUC of the name
    unsigned long   ibSym;      // Offset of actual symbol in $$Symbols
    unsigned short  imod;       // Module containing the actual symbol
    unsigned short  usFill;     // align this record
} REFSYM;

typedef struct ALIGNSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_ALIGN
} ALIGNSYM;

//  generic block definition symbols
//  these are similar to the equivalent 16:16 or 16:32 symbols but
//  only define the length, type and linkage fields

typedef struct PROCSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_GPROC16 or S_LPROC16
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned long   pNext;      // pointer to next symbol
} PROCSYM;


typedef struct THUNKSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_THUNK
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned long   pNext;      // pointer to next symbol
} THUNKSYM;

typedef struct BLOCKSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_BLOCK16
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
} BLOCKSYM;


typedef struct WITHSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_WITH16
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
} WITHSYM;

typedef struct FRAMEPROCSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_FRAMEPROC
    unsigned long   cbFrame;    // count of bytes of total frame of procedure
    unsigned long   cbPad;      // count of bytes of padding in the frame
    CV_uoff32_t     offPad;     // offset (relative to frame poniter) to where
                                //  padding starts
    unsigned long   cbSaveRegs; // count of bytes of callee save registers
    CV_uoff32_t     offExHdlr;  // offset of exception handler
    unsigned short  sectExHdlr; // section id of exception handler

    struct {
        unsigned long   fHasAlloca  :  1;   // function uses _alloca()
        unsigned long   fHasSetJmp  :  1;   // function uses setjmp()
        unsigned long   fHasLongJmp :  1;   // function uses longjmp()
        unsigned long   fHasInlAsm  :  1;   // function uses inline asm
        unsigned long   fHasEH      :  1;   // function has EH states
        unsigned long   fInlSpec    :  1;   // function was speced as inline
        unsigned long   fHasSEH     :  1;   // function has SEH
        unsigned long   pad         : 25;   // must be zero
    } flags;
} FRAMEPROCSYM;

typedef enum CV_HREG_e {
    // Register subset shared by all processor types,
    // must not overlap with any of the ranges below and yet must fit
    // in a byte

    CV_ALLREG_ERR   =   250,
    CV_ALLREG_TEB   =   251,
    CV_ALLREG_TIMER =   252,
	CV_ALLREG_EFAD1	=	253,
	CV_ALLREG_EFAD2	=	254,
	CV_ALLREG_EFAD3	=	255,


    //  Register set for the Intel 80x86 and ix86 processor series
    //  (plus PCODE registers)

    CV_REG_NONE     =   0,
    CV_REG_AL       =   1,
    CV_REG_CL       =   2,
    CV_REG_DL       =   3,
    CV_REG_BL       =   4,
    CV_REG_AH       =   5,
    CV_REG_CH       =   6,
    CV_REG_DH       =   7,
    CV_REG_BH       =   8,
    CV_REG_AX       =   9,
    CV_REG_CX       =  10,
    CV_REG_DX       =  11,
    CV_REG_BX       =  12,
    CV_REG_SP       =  13,
    CV_REG_BP       =  14,
    CV_REG_SI       =  15,
    CV_REG_DI       =  16,
    CV_REG_EAX      =  17,
    CV_REG_ECX      =  18,
    CV_REG_EDX      =  19,
    CV_REG_EBX      =  20,
    CV_REG_ESP      =  21,
    CV_REG_EBP      =  22,
    CV_REG_ESI      =  23,
    CV_REG_EDI      =  24,
    CV_REG_ES       =  25,
    CV_REG_CS       =  26,
    CV_REG_SS       =  27,
    CV_REG_DS       =  28,
    CV_REG_FS       =  29,
    CV_REG_GS       =  30,
    CV_REG_IP       =  31,
    CV_REG_FLAGS    =  32,
    CV_REG_EIP      =  33,
    CV_REG_EFLAGS   =  34,
    CV_REG_TEMP     =  40,          // PCODE Temp
    CV_REG_TEMPH    =  41,          // PCODE TempH
    CV_REG_QUOTE    =  42,          // PCODE Quote
    CV_REG_PCDR3    =  43,          // PCODE reserved
    CV_REG_PCDR4    =  44,          // PCODE reserved
    CV_REG_PCDR5    =  45,          // PCODE reserved
    CV_REG_PCDR6    =  46,          // PCODE reserved
    CV_REG_PCDR7    =  47,          // PCODE reserved
    CV_REG_CR0      =  80,          // CR0 -- control registers
    CV_REG_CR1      =  81,
    CV_REG_CR2      =  82,
    CV_REG_CR3      =  83,
    CV_REG_CR4      =  84,          // Pentium
    CV_REG_DR0      =  90,          // Debug register
    CV_REG_DR1      =  91,
    CV_REG_DR2      =  92,
    CV_REG_DR3      =  93,
    CV_REG_DR4      =  94,
    CV_REG_DR5      =  95,
    CV_REG_DR6      =  96,
    CV_REG_DR7      =  97,
    CV_REG_GDTR     =  110,
    CV_REG_GDTL     =  111,
    CV_REG_IDTR     =  112,
    CV_REG_IDTL     =  113,
    CV_REG_LDTR     =  114,
    CV_REG_TR       =  115,

    CV_REG_PSEUDO1  =  116,
    CV_REG_PSEUDO2  =  117,
    CV_REG_PSEUDO3  =  118,
    CV_REG_PSEUDO4  =  119,
    CV_REG_PSEUDO5  =  120,
    CV_REG_PSEUDO6  =  121,
    CV_REG_PSEUDO7  =  122,
    CV_REG_PSEUDO8  =  123,
    CV_REG_PSEUDO9  =  124,

    CV_REG_ST0      =  128,
    CV_REG_ST1      =  129,
    CV_REG_ST2      =  130,
    CV_REG_ST3      =  131,
    CV_REG_ST4      =  132,
    CV_REG_ST5      =  133,
    CV_REG_ST6      =  134,
    CV_REG_ST7      =  135,
    CV_REG_CTRL     =  136,
    CV_REG_STAT     =  137,
    CV_REG_TAG      =  138,
    CV_REG_FPIP     =  139,
    CV_REG_FPCS     =  140,
    CV_REG_FPDO     =  141,
    CV_REG_FPDS     =  142,
    CV_REG_ISEM     =  143,
    CV_REG_FPEIP    =  144,
    CV_REG_FPEDO    =  145,

    CV_REG_MM0      =  146,
    CV_REG_MM1      =  147,
    CV_REG_MM2      =  148,
    CV_REG_MM3      =  149,
    CV_REG_MM4      =  150,
    CV_REG_MM5      =  151,
    CV_REG_MM6      =  152,
    CV_REG_MM7      =  153,

    // registers for the 68K processors

    CV_R68_D0       =    0,
    CV_R68_D1       =    1,
    CV_R68_D2       =    2,
    CV_R68_D3       =    3,
    CV_R68_D4       =    4,
    CV_R68_D5       =    5,
    CV_R68_D6       =    6,
    CV_R68_D7       =    7,
    CV_R68_A0       =    8,
    CV_R68_A1       =    9,
    CV_R68_A2       =   10,
    CV_R68_A3       =   11,
    CV_R68_A4       =   12,
    CV_R68_A5       =   13,
    CV_R68_A6       =   14,
    CV_R68_A7       =   15,
    CV_R68_CCR      =   16,
    CV_R68_SR       =   17,
    CV_R68_USP      =   18,
    CV_R68_MSP      =   19,
    CV_R68_SFC      =   20,
    CV_R68_DFC      =   21,
    CV_R68_CACR     =   22,
    CV_R68_VBR      =   23,
    CV_R68_CAAR     =   24,
    CV_R68_ISP      =   25,
    CV_R68_PC       =   26,
    //reserved  27
    CV_R68_FPCR     =   28,
    CV_R68_FPSR     =   29,
    CV_R68_FPIAR    =   30,
    //reserved  31
    CV_R68_FP0      =   32,
    CV_R68_FP1      =   33,
    CV_R68_FP2      =   34,
    CV_R68_FP3      =   35,
    CV_R68_FP4      =   36,
    CV_R68_FP5      =   37,
    CV_R68_FP6      =   38,
    CV_R68_FP7      =   39,
    //reserved  40
    CV_R68_MMUSR030 =   41,
    CV_R68_MMUSR    =   42,
    CV_R68_URP      =   43,
    CV_R68_DTT0     =   44,
    CV_R68_DTT1     =   45,
    CV_R68_ITT0     =   46,
    CV_R68_ITT1     =   47,
    //reserved  50
    CV_R68_PSR      =   51,
    CV_R68_PCSR     =   52,
    CV_R68_VAL      =   53,
    CV_R68_CRP      =   54,
    CV_R68_SRP      =   55,
    CV_R68_DRP      =   56,
    CV_R68_TC       =   57,
    CV_R68_AC       =   58,
    CV_R68_SCC      =   59,
    CV_R68_CAL      =   60,
    CV_R68_TT0      =   61,
    CV_R68_TT1      =   62,
    //reserved  63
    CV_R68_BAD0     =   64,
    CV_R68_BAD1     =   65,
    CV_R68_BAD2     =   66,
    CV_R68_BAD3     =   67,
    CV_R68_BAD4     =   68,
    CV_R68_BAD5     =   69,
    CV_R68_BAD6     =   70,
    CV_R68_BAD7     =   71,
    CV_R68_BAC0     =   72,
    CV_R68_BAC1     =   73,
    CV_R68_BAC2     =   74,
    CV_R68_BAC3     =   75,
    CV_R68_BAC4     =   76,
    CV_R68_BAC5     =   77,
    CV_R68_BAC6     =   78,
    CV_R68_BAC7     =   79,

     // Register set for the MIPS 4000

    CV_M4_NOREG     =   CV_REG_NONE,

    CV_M4_IntZERO   =   10,      /* CPU REGISTER */
    CV_M4_IntAT     =   11,
    CV_M4_IntV0     =   12,
    CV_M4_IntV1     =   13,
    CV_M4_IntA0     =   14,
    CV_M4_IntA1     =   15,
    CV_M4_IntA2     =   16,
    CV_M4_IntA3     =   17,
    CV_M4_IntT0     =   18,
    CV_M4_IntT1     =   19,
    CV_M4_IntT2     =   20,
    CV_M4_IntT3     =   21,
    CV_M4_IntT4     =   22,
    CV_M4_IntT5     =   23,
    CV_M4_IntT6     =   24,
    CV_M4_IntT7     =   25,
    CV_M4_IntS0     =   26,
    CV_M4_IntS1     =   27,
    CV_M4_IntS2     =   28,
    CV_M4_IntS3     =   29,
    CV_M4_IntS4     =   30,
    CV_M4_IntS5     =   31,
    CV_M4_IntS6     =   32,
    CV_M4_IntS7     =   33,
    CV_M4_IntT8     =   34,
    CV_M4_IntT9     =   35,
    CV_M4_IntKT0    =   36,
    CV_M4_IntKT1    =   37,
    CV_M4_IntGP     =   38,
    CV_M4_IntSP     =   39,
    CV_M4_IntS8     =   40,
    CV_M4_IntRA     =   41,
    CV_M4_IntLO     =   42,
    CV_M4_IntHI     =   43,

    CV_M4_Fir       =   50,
    CV_M4_Psr       =   51,

    CV_M4_FltF0     =   60,      /* Floating point registers */
    CV_M4_FltF1     =   61,
    CV_M4_FltF2     =   62,
    CV_M4_FltF3     =   63,
    CV_M4_FltF4     =   64,
    CV_M4_FltF5     =   65,
    CV_M4_FltF6     =   66,
    CV_M4_FltF7     =   67,
    CV_M4_FltF8     =   68,
    CV_M4_FltF9     =   69,
    CV_M4_FltF10    =   70,
    CV_M4_FltF11    =   71,
    CV_M4_FltF12    =   72,
    CV_M4_FltF13    =   73,
    CV_M4_FltF14    =   74,
    CV_M4_FltF15    =   75,
    CV_M4_FltF16    =   76,
    CV_M4_FltF17    =   77,
    CV_M4_FltF18    =   78,
    CV_M4_FltF19    =   79,
    CV_M4_FltF20    =   80,
    CV_M4_FltF21    =   81,
    CV_M4_FltF22    =   82,
    CV_M4_FltF23    =   83,
    CV_M4_FltF24    =   84,
    CV_M4_FltF25    =   85,
    CV_M4_FltF26    =   86,
    CV_M4_FltF27    =   87,
    CV_M4_FltF28    =   88,
    CV_M4_FltF29    =   89,
    CV_M4_FltF30    =   90,
    CV_M4_FltF31    =   91,
    CV_M4_FltFsr    =   92,


    // Register set for the ALPHA AXP

    CV_ALPHA_NOREG  = CV_REG_NONE,

    CV_ALPHA_FltF0  =   10,   // Floating point registers
    CV_ALPHA_FltF1  =   11,
    CV_ALPHA_FltF2  =   12,
    CV_ALPHA_FltF3  =   13,
    CV_ALPHA_FltF4  =   14,
    CV_ALPHA_FltF5  =   15,
    CV_ALPHA_FltF6  =   16,
    CV_ALPHA_FltF7  =   17,
    CV_ALPHA_FltF8  =   18,
    CV_ALPHA_FltF9  =   19,
    CV_ALPHA_FltF10 =   20,
    CV_ALPHA_FltF11 =   21,
    CV_ALPHA_FltF12 =   22,
    CV_ALPHA_FltF13 =   23,
    CV_ALPHA_FltF14 =   24,
    CV_ALPHA_FltF15 =   25,
    CV_ALPHA_FltF16 =   26,
    CV_ALPHA_FltF17 =   27,
    CV_ALPHA_FltF18 =   28,
    CV_ALPHA_FltF19 =   29,
    CV_ALPHA_FltF20 =   30,
    CV_ALPHA_FltF21 =   31,
    CV_ALPHA_FltF22 =   32,
    CV_ALPHA_FltF23 =   33,
    CV_ALPHA_FltF24 =   34,
    CV_ALPHA_FltF25 =   35,
    CV_ALPHA_FltF26 =   36,
    CV_ALPHA_FltF27 =   37,
    CV_ALPHA_FltF28 =   38,
    CV_ALPHA_FltF29 =   39,
    CV_ALPHA_FltF30 =   40,
    CV_ALPHA_FltF31 =   41,

    CV_ALPHA_IntV0  =   42,   // Integer registers
    CV_ALPHA_IntT0  =   43,
    CV_ALPHA_IntT1  =   44,
    CV_ALPHA_IntT2  =   45,
    CV_ALPHA_IntT3  =   46,
    CV_ALPHA_IntT4  =   47,
    CV_ALPHA_IntT5  =   48,
    CV_ALPHA_IntT6  =   49,
    CV_ALPHA_IntT7  =   50,
    CV_ALPHA_IntS0  =   51,
    CV_ALPHA_IntS1  =   52,
    CV_ALPHA_IntS2  =   53,
    CV_ALPHA_IntS3  =   54,
    CV_ALPHA_IntS4  =   55,
    CV_ALPHA_IntS5  =   56,
    CV_ALPHA_IntFP  =   57,
    CV_ALPHA_IntA0  =   58,
    CV_ALPHA_IntA1  =   59,
    CV_ALPHA_IntA2  =   60,
    CV_ALPHA_IntA3  =   61,
    CV_ALPHA_IntA4  =   62,
    CV_ALPHA_IntA5  =   63,
    CV_ALPHA_IntT8  =   64,
    CV_ALPHA_IntT9  =   65,
    CV_ALPHA_IntT10 =   66,
    CV_ALPHA_IntT11 =   67,
    CV_ALPHA_IntRA  =   68,
    CV_ALPHA_IntT12 =   69,
    CV_ALPHA_IntAT  =   70,
    CV_ALPHA_IntGP  =   71,
    CV_ALPHA_IntSP  =   72,
    CV_ALPHA_IntZERO =  73,


    CV_ALPHA_Fpcr   =   74,   // Control registers
    CV_ALPHA_Fir    =   75,
    CV_ALPHA_Psr    =   76,
    CV_ALPHA_FltFsr =   77,
    CV_ALPHA_SoftFpcr =   78,

    // Register Set for Motorola/IBM PowerPC

    /*
    ** PowerPC General Registers ( User Level )
    */
    CV_PPC_GPR0     =  1,
    CV_PPC_GPR1     =  2,
    CV_PPC_GPR2     =  3,
    CV_PPC_GPR3     =  4,
    CV_PPC_GPR4     =  5,
    CV_PPC_GPR5     =  6,
    CV_PPC_GPR6     =  7,
    CV_PPC_GPR7     =  8,
    CV_PPC_GPR8     =  9,
    CV_PPC_GPR9     = 10,
    CV_PPC_GPR10    = 11,
    CV_PPC_GPR11    = 12,
    CV_PPC_GPR12    = 13,
    CV_PPC_GPR13    = 14,
    CV_PPC_GPR14    = 15,
    CV_PPC_GPR15    = 16,
    CV_PPC_GPR16    = 17,
    CV_PPC_GPR17    = 18,
    CV_PPC_GPR18    = 19,
    CV_PPC_GPR19    = 20,
    CV_PPC_GPR20    = 21,
    CV_PPC_GPR21    = 22,
    CV_PPC_GPR22    = 23,
    CV_PPC_GPR23    = 24,
    CV_PPC_GPR24    = 25,
    CV_PPC_GPR25    = 26,
    CV_PPC_GPR26    = 27,
    CV_PPC_GPR27    = 28,
    CV_PPC_GPR28    = 29,
    CV_PPC_GPR29    = 30,
    CV_PPC_GPR30    = 31,
    CV_PPC_GPR31    = 32,

    /*
    ** PowerPC Condition Register ( User Level )
    */
    CV_PPC_CR       = 33,
    CV_PPC_CR0      = 34,
    CV_PPC_CR1      = 35,
    CV_PPC_CR2      = 36,
    CV_PPC_CR3      = 37,
    CV_PPC_CR4      = 38,
    CV_PPC_CR5      = 39,
    CV_PPC_CR6      = 40,
    CV_PPC_CR7      = 41,

    /*
    ** PowerPC Floating Point Registers ( User Level )
    */
    CV_PPC_FPR0     = 42,
    CV_PPC_FPR1     = 43,
    CV_PPC_FPR2     = 44,
    CV_PPC_FPR3     = 45,
    CV_PPC_FPR4     = 46,
    CV_PPC_FPR5     = 47,
    CV_PPC_FPR6     = 48,
    CV_PPC_FPR7     = 49,
    CV_PPC_FPR8     = 50,
    CV_PPC_FPR9     = 51,
    CV_PPC_FPR10    = 52,
    CV_PPC_FPR11    = 53,
    CV_PPC_FPR12    = 54,
    CV_PPC_FPR13    = 55,
    CV_PPC_FPR14    = 56,
    CV_PPC_FPR15    = 57,
    CV_PPC_FPR16    = 58,
    CV_PPC_FPR17    = 59,
    CV_PPC_FPR18    = 60,
    CV_PPC_FPR19    = 61,
    CV_PPC_FPR20    = 62,
    CV_PPC_FPR21    = 63,
    CV_PPC_FPR22    = 64,
    CV_PPC_FPR23    = 65,
    CV_PPC_FPR24    = 66,
    CV_PPC_FPR25    = 67,
    CV_PPC_FPR26    = 68,
    CV_PPC_FPR27    = 69,
    CV_PPC_FPR28    = 70,
    CV_PPC_FPR29    = 71,
    CV_PPC_FPR30    = 72,
    CV_PPC_FPR31    = 73,

    /*
    ** PowerPC Floating Point Status and Control Register ( User Level )
    */
    CV_PPC_FPSCR    = 74,

    /*
    ** PowerPC Machine State Register ( Supervisor Level )
    */
    CV_PPC_MSR      = 75,

    /*
    ** PowerPC Segment Registers ( Supervisor Level )
    */
    CV_PPC_SR0      = 76,
    CV_PPC_SR1      = 77,
    CV_PPC_SR2      = 78,
    CV_PPC_SR3      = 79,
    CV_PPC_SR4      = 80,
    CV_PPC_SR5      = 81,
    CV_PPC_SR6      = 82,
    CV_PPC_SR7      = 83,
    CV_PPC_SR8      = 84,
    CV_PPC_SR9      = 85,
    CV_PPC_SR10     = 86,
    CV_PPC_SR11     = 87,
    CV_PPC_SR12     = 88,
    CV_PPC_SR13     = 89,
    CV_PPC_SR14     = 90,
    CV_PPC_SR15     = 91,

    /*
    ** For all of the special purpose registers add 100 to the SPR# that the
    ** Motorola/IBM documentation gives with the exception of any imaginary
    ** registers.
    */

    /*
    ** PowerPC Special Purpose Registers ( User Level )
    */
    CV_PPC_PC       = 99,     // PC (imaginary register)

    CV_PPC_MQ       = 100,    // MPC601
    CV_PPC_XER      = 101,
    CV_PPC_RTCU     = 104,    // MPC601
    CV_PPC_RTCL     = 105,    // MPC601
    CV_PPC_LR       = 108,
    CV_PPC_CTR      = 109,

    CV_PPC_COMPARE  = 110,    // part of XER (internal to the debugger only)
    CV_PPC_COUNT    = 111,    // part of XER (internal to the debugger only)

    /*
    ** PowerPC Special Purpose Registers ( Supervisor Level )
    */
    CV_PPC_DSISR    = 118,
    CV_PPC_DAR      = 119,
    CV_PPC_DEC      = 122,
    CV_PPC_SDR1     = 125,
    CV_PPC_SRR0     = 126,
    CV_PPC_SRR1     = 127,
    CV_PPC_SPRG0    = 372,
    CV_PPC_SPRG1    = 373,
    CV_PPC_SPRG2    = 374,
    CV_PPC_SPRG3    = 375,
    CV_PPC_ASR      = 280,    // 64-bit implementations only
    CV_PPC_EAR      = 382,
    CV_PPC_PVR      = 287,
    CV_PPC_BAT0U    = 628,
    CV_PPC_BAT0L    = 629,
    CV_PPC_BAT1U    = 630,
    CV_PPC_BAT1L    = 631,
    CV_PPC_BAT2U    = 632,
    CV_PPC_BAT2L    = 633,
    CV_PPC_BAT3U    = 634,
    CV_PPC_BAT3L    = 635,
    CV_PPC_DBAT0U   = 636,
    CV_PPC_DBAT0L   = 637,
    CV_PPC_DBAT1U   = 638,
    CV_PPC_DBAT1L   = 639,
    CV_PPC_DBAT2U   = 640,
    CV_PPC_DBAT2L   = 641,
    CV_PPC_DBAT3U   = 642,
    CV_PPC_DBAT3L   = 643,

    /*
    ** PowerPC Special Purpose Registers Implementation Dependent ( Supervisor Level )
    */

    /*
    ** Doesn't appear that IBM/Motorola has finished defining these.
    */

    CV_PPC_PMR0     = 1044,   // MPC620,
    CV_PPC_PMR1     = 1045,   // MPC620,
    CV_PPC_PMR2     = 1046,   // MPC620,
    CV_PPC_PMR3     = 1047,   // MPC620,
    CV_PPC_PMR4     = 1048,   // MPC620,
    CV_PPC_PMR5     = 1049,   // MPC620,
    CV_PPC_PMR6     = 1050,   // MPC620,
    CV_PPC_PMR7     = 1051,   // MPC620,
    CV_PPC_PMR8     = 1052,   // MPC620,
    CV_PPC_PMR9     = 1053,   // MPC620,
    CV_PPC_PMR10    = 1054,   // MPC620,
    CV_PPC_PMR11    = 1055,   // MPC620,
    CV_PPC_PMR12    = 1056,   // MPC620,
    CV_PPC_PMR13    = 1057,   // MPC620,
    CV_PPC_PMR14    = 1058,   // MPC620,
    CV_PPC_PMR15    = 1059,   // MPC620,

    CV_PPC_DMISS    = 1076,   // MPC603
    CV_PPC_DCMP     = 1077,   // MPC603
    CV_PPC_HASH1    = 1078,   // MPC603
    CV_PPC_HASH2    = 1079,   // MPC603
    CV_PPC_IMISS    = 1080,   // MPC603
    CV_PPC_ICMP     = 1081,   // MPC603
    CV_PPC_RPA      = 1082,   // MPC603

    CV_PPC_HID0     = 1108,   // MPC601, MPC603, MPC620
    CV_PPC_HID1     = 1109,   // MPC601
    CV_PPC_HID2     = 1110,   // MPC601, MPC603, MPC620 ( IABR )
    CV_PPC_HID3     = 1111,   // Not Defined
    CV_PPC_HID4     = 1112,   // Not Defined
    CV_PPC_HID5     = 1113,   // MPC601, MPC604, MPC620 ( DABR )
    CV_PPC_HID6     = 1114,   // Not Defined
    CV_PPC_HID7     = 1115,   // Not Defined
    CV_PPC_HID8     = 1116,   // MPC620 ( BUSCSR )
    CV_PPC_HID9     = 1117,   // MPC620 ( L2CSR )
    CV_PPC_HID10    = 1118,   // Not Defined
    CV_PPC_HID11    = 1119,   // Not Defined
    CV_PPC_HID12    = 1120,   // Not Defined
    CV_PPC_HID13    = 1121,   // MPC604 ( HCR )
    CV_PPC_HID14    = 1122,   // Not Defined
    CV_PPC_HID15    = 1123,   // MPC601, MPC604, MPC620 ( PIR )

    //
    // JAVA VM registers
    //

    CV_JAVA_PC      = 1,

    //
    // Register set for the Hitachi SH3
    //

    CV_SH3_NOREG    =   CV_REG_NONE,

    CV_SH3_IntR0    =   10,   // CPU REGISTER
    CV_SH3_IntR1    =   11,
    CV_SH3_IntR2    =   12,
    CV_SH3_IntR3    =   13,
    CV_SH3_IntR4    =   14,
    CV_SH3_IntR5    =   15,
    CV_SH3_IntR6    =   16,
    CV_SH3_IntR7    =   17,
    CV_SH3_IntR8    =   18,
    CV_SH3_IntR9    =   19,
    CV_SH3_IntR10   =   20,
    CV_SH3_IntR11   =   21,
    CV_SH3_IntR12   =   22,
    CV_SH3_IntR13   =   23,
    CV_SH3_IntFp    =   24,
    CV_SH3_IntSp    =   25,
    CV_SH3_Gbr      =   38,
    CV_SH3_Pr       =   39,
    CV_SH3_Mach     =   40,
    CV_SH3_Macl     =   41,

    CV_SH3_Pc       =   50,
    CV_SH3_Sr       =   51,

    CV_SH3_BarA     =   60,
    CV_SH3_BasrA    =   61,
    CV_SH3_BamrA    =   62,
    CV_SH3_BbrA     =   63,
    CV_SH3_BarB     =   64,
    CV_SH3_BasrB    =   65,
    CV_SH3_BamrB    =   66,
    CV_SH3_BbrB     =   67,
    CV_SH3_BdrB     =   68,
    CV_SH3_BdmrB    =   69,
    CV_SH3_Brcr     =   70,

    //
    // Additional registers for Hitachi SH processors
    //

    CV_SH_Fpscr    =   75,    // floating point status/control register
    CV_SH_Fpul     =   76,    // floating point communication register

    CV_SH_FpR0     =   80,    // Floating point registers
    CV_SH_FpR1     =   81,
    CV_SH_FpR2     =   82,
    CV_SH_FpR3     =   83,
    CV_SH_FpR4     =   84,
    CV_SH_FpR5     =   85,
    CV_SH_FpR6     =   86,
    CV_SH_FpR7     =   87,
    CV_SH_FpR8     =   88,
    CV_SH_FpR9     =   89,
    CV_SH_FpR10    =   90,
    CV_SH_FpR11    =   91,
    CV_SH_FpR12    =   92,
    CV_SH_FpR13    =   93,
    CV_SH_FpR14    =   94,
    CV_SH_FpR15    =   95,

    CV_SH_XFpR0    =   96,
    CV_SH_XFpR1    =   97,
    CV_SH_XFpR2    =   98,
    CV_SH_XFpR3    =   99,
    CV_SH_XFpR4    =  100,
    CV_SH_XFpR5    =  101,
    CV_SH_XFpR6    =  102,
    CV_SH_XFpR7    =  103,
    CV_SH_XFpR8    =  104,
    CV_SH_XFpR9    =  105,
    CV_SH_XFpR10   =  106,
    CV_SH_XFpR11   =  107,
    CV_SH_XFpR12   =  108,
    CV_SH_XFpR13   =  109,
    CV_SH_XFpR14   =  110,
    CV_SH_XFpR15   =  111,

    //
    // Register set for the ARM processor.
    //

    CV_ARM_NOREG    =   CV_REG_NONE,

    CV_ARM_R0       =   10,
    CV_ARM_R1       =   11,
    CV_ARM_R2       =   12,
    CV_ARM_R3       =   13,
    CV_ARM_R4       =   14,
    CV_ARM_R5       =   15,
    CV_ARM_R6       =   16,
    CV_ARM_R7       =   17,
    CV_ARM_R8       =   18,
    CV_ARM_R9       =   19,
    CV_ARM_R10      =   20,
    CV_ARM_R11      =   21, // Frame pointer, if allocated
    CV_ARM_R12      =   22,
    CV_ARM_SP       =   23, // Stack pointer
    CV_ARM_LR       =   24, // Link Register
    CV_ARM_PC       =   25, // Program counter
    CV_ARM_CPSR     =   26, // Current program status register

    //
    // Register set for Intel IA64
    //

    CV_IA64_NOREG   =   CV_REG_NONE,

    // Branch Registers

    CV_IA64_BrRp     =   512,
    CV_IA64_BrS0     =   513,
    CV_IA64_BrS1     =   514,
    CV_IA64_BrS2     =   515,
    CV_IA64_BrS3     =   516,
    CV_IA64_BrS4     =   517,
    CV_IA64_BrT0     =   518,
    CV_IA64_BrT1     =   519,

    // Predicate Registers

    CV_IA64_Preds     =   768,

    // Banked General Registers

    CV_IA64_IntH0    =   832,
    CV_IA64_IntH1    =   833,
    CV_IA64_IntH2    =   834,
    CV_IA64_IntH3    =   835,
    CV_IA64_IntH4    =   836,
    CV_IA64_IntH5    =   837,
    CV_IA64_IntH6    =   838,
    CV_IA64_IntH7    =   839,
    CV_IA64_IntH8    =   840,
    CV_IA64_IntH9    =   841,
    CV_IA64_IntH10    =   842,
    CV_IA64_IntH11    =   843,
    CV_IA64_IntH12    =   844,
    CV_IA64_IntH13    =   845,
    CV_IA64_IntH14    =   846,
    CV_IA64_IntH15    =   847,

    // Special Registers

    CV_IA64_Ip     =   1016,
    CV_IA64_Umask  =   1017,
    CV_IA64_Cfm    =   1018,
    CV_IA64_Psr    =   1019,

    // Banked General Registers

    CV_IA64_Nats     =   1020,
    CV_IA64_Nats2    =   1021,
    CV_IA64_Nats3    =   1022,

    // General-Purpose Registers

    // INTEGER REGISTER
    CV_IA64_IntZero  =   1024,
    CV_IA64_IntGp    =   1025,
    CV_IA64_IntT0    =   1026,
    CV_IA64_IntT1    =   1027,
    CV_IA64_IntS0    =   1028,
    CV_IA64_IntS1    =   1029,
    CV_IA64_IntS2    =   1030,
    CV_IA64_IntS3    =   1031,
    CV_IA64_IntV0    =   1032,
    CV_IA64_IntAp    =   1033,
    CV_IA64_IntT2    =   1034,
    CV_IA64_IntT3    =   1035,
    CV_IA64_IntSp    =   1036,
    CV_IA64_IntT4    =   1037,
    CV_IA64_IntT5    =   1038,
    CV_IA64_IntT6    =   1039,
    CV_IA64_IntT7    =   1040,
    CV_IA64_IntT8    =   1041,
    CV_IA64_IntT9    =   1042,
    CV_IA64_IntT10   =   1043,
    CV_IA64_IntT11   =   1044,
    CV_IA64_IntT12   =   1045,
    CV_IA64_IntT13   =   1046,
    CV_IA64_IntT14   =   1047,
    CV_IA64_IntT15   =   1048,
    CV_IA64_IntT16   =   1049,
    CV_IA64_IntT17   =   1050,
    CV_IA64_IntT18   =   1051,
    CV_IA64_IntT19   =   1052,
    CV_IA64_IntT20   =   1053,
    CV_IA64_IntT21   =   1054,
    CV_IA64_IntT22   =   1055,

    // Register Stack
    CV_IA64_IntR32   =   1056,
    CV_IA64_IntR33   =   1057,
    CV_IA64_IntR34   =   1058,
    CV_IA64_IntR35   =   1059,
    CV_IA64_IntR36   =   1060,
    CV_IA64_IntR37   =   1061,
    CV_IA64_IntR38   =   1062,
    CV_IA64_IntR39   =   1063,
    CV_IA64_IntR40   =   1064,
    CV_IA64_IntR41   =   1065,
    CV_IA64_IntR42   =   1066,
    CV_IA64_IntR43   =   1067,
    CV_IA64_IntR44   =   1068,
    CV_IA64_IntR45   =   1069,
    CV_IA64_IntR46   =   1070,
    CV_IA64_IntR47   =   1071,
    CV_IA64_IntR48   =   1072,
    CV_IA64_IntR49   =   1073,
    CV_IA64_IntR50   =   1074,
    CV_IA64_IntR51   =   1075,
    CV_IA64_IntR52   =   1076,
    CV_IA64_IntR53   =   1077,
    CV_IA64_IntR54   =   1078,
    CV_IA64_IntR55   =   1079,
    CV_IA64_IntR56   =   1080,
    CV_IA64_IntR57   =   1081,
    CV_IA64_IntR58   =   1082,
    CV_IA64_IntR59   =   1083,
    CV_IA64_IntR60   =   1084,
    CV_IA64_IntR61   =   1085,
    CV_IA64_IntR62   =   1086,
    CV_IA64_IntR63   =   1087,
    CV_IA64_IntR64   =   1088,
    CV_IA64_IntR65   =   1089,
    CV_IA64_IntR66   =   1090,
    CV_IA64_IntR67   =   1091,
    CV_IA64_IntR68   =   1092,
    CV_IA64_IntR69   =   1093,
    CV_IA64_IntR70   =   1094,
    CV_IA64_IntR71   =   1095,
    CV_IA64_IntR72   =   1096,
    CV_IA64_IntR73   =   1097,
    CV_IA64_IntR74   =   1098,
    CV_IA64_IntR75   =   1099,
    CV_IA64_IntR76   =   1100,
    CV_IA64_IntR77   =   1101,
    CV_IA64_IntR78   =   1102,
    CV_IA64_IntR79   =   1103,
    CV_IA64_IntR80   =   1104,
    CV_IA64_IntR81   =   1105,
    CV_IA64_IntR82   =   1106,
    CV_IA64_IntR83   =   1107,
    CV_IA64_IntR84   =   1108,
    CV_IA64_IntR85   =   1109,
    CV_IA64_IntR86   =   1110,
    CV_IA64_IntR87   =   1111,
    CV_IA64_IntR88   =   1112,
    CV_IA64_IntR89   =   1113,
    CV_IA64_IntR90   =   1114,
    CV_IA64_IntR91   =   1115,
    CV_IA64_IntR92   =   1116,
    CV_IA64_IntR93   =   1117,
    CV_IA64_IntR94   =   1118,
    CV_IA64_IntR95   =   1119,
    CV_IA64_IntR96   =   1120,
    CV_IA64_IntR97   =   1121,
    CV_IA64_IntR98   =   1122,
    CV_IA64_IntR99   =   1123,
    CV_IA64_IntR100   =   1124,
    CV_IA64_IntR101   =   1125,
    CV_IA64_IntR102   =   1126,
    CV_IA64_IntR103   =   1127,
    CV_IA64_IntR104   =   1128,
    CV_IA64_IntR105   =   1129,
    CV_IA64_IntR106   =   1130,
    CV_IA64_IntR107   =   1131,
    CV_IA64_IntR108   =   1132,
    CV_IA64_IntR109   =   1133,
    CV_IA64_IntR110   =   1134,
    CV_IA64_IntR111   =   1135,
    CV_IA64_IntR112   =   1136,
    CV_IA64_IntR113   =   1137,
    CV_IA64_IntR114   =   1138,
    CV_IA64_IntR115   =   1139,
    CV_IA64_IntR116   =   1140,
    CV_IA64_IntR117   =   1141,
    CV_IA64_IntR118   =   1142,
    CV_IA64_IntR119   =   1143,
    CV_IA64_IntR120   =   1144,
    CV_IA64_IntR121   =   1145,
    CV_IA64_IntR122   =   1146,
    CV_IA64_IntR123   =   1147,
    CV_IA64_IntR124   =   1148,
    CV_IA64_IntR125   =   1149,
    CV_IA64_IntR126   =   1150,
    CV_IA64_IntR127   =   1151,

    // Floating-Point Registers

    // Low Floating Point Registers
    CV_IA64_FltZero  =   2048,
    CV_IA64_FltOne   =   2049,
    CV_IA64_FltS0    =   2050,
    CV_IA64_FltS1    =   2051,
    CV_IA64_FltS2    =   2052,
    CV_IA64_FltS3    =   2053,
    CV_IA64_FltT0    =   2054,
    CV_IA64_FltT1    =   2055,
    CV_IA64_FltT2    =   2056,
    CV_IA64_FltT3    =   2057,
    CV_IA64_FltT4    =   2058,
    CV_IA64_FltT5    =   2059,
    CV_IA64_FltT6    =   2060,
    CV_IA64_FltT7    =   2061,
    CV_IA64_FltT8    =   2062,
    CV_IA64_FltT9    =   2063,
    CV_IA64_FltS4    =   2064,
    CV_IA64_FltS5    =   2065,
    CV_IA64_FltS6    =   2066,
    CV_IA64_FltS7    =   2067,
    CV_IA64_FltS8    =   2068,
    CV_IA64_FltS9    =   2069,
    CV_IA64_FltS10   =   2070,
    CV_IA64_FltS11   =   2071,
    CV_IA64_FltS12   =   2072,
    CV_IA64_FltS13   =   2073,
    CV_IA64_FltS14   =   2074,
    CV_IA64_FltS15   =   2075,
    CV_IA64_FltS16   =   2076,
    CV_IA64_FltS17   =   2077,
    CV_IA64_FltS18   =   2078,
    CV_IA64_FltS19   =   2079,

    // High Floating Point Registers
    CV_IA64_FltF32   =   2080,
    CV_IA64_FltF33   =   2081,
    CV_IA64_FltF34   =   2082,
    CV_IA64_FltF35   =   2083,
    CV_IA64_FltF36   =   2084,
    CV_IA64_FltF37   =   2085,
    CV_IA64_FltF38   =   2086,
    CV_IA64_FltF39   =   2087,
    CV_IA64_FltF40   =   2088,
    CV_IA64_FltF41   =   2089,
    CV_IA64_FltF42   =   2090,
    CV_IA64_FltF43   =   2091,
    CV_IA64_FltF44   =   2092,
    CV_IA64_FltF45   =   2093,
    CV_IA64_FltF46   =   2094,
    CV_IA64_FltF47   =   2095,
    CV_IA64_FltF48   =   2096,
    CV_IA64_FltF49   =   2097,
    CV_IA64_FltF50   =   2098,
    CV_IA64_FltF51   =   2099,
    CV_IA64_FltF52   =   2100,
    CV_IA64_FltF53   =   2101,
    CV_IA64_FltF54   =   2102,
    CV_IA64_FltF55   =   2103,
    CV_IA64_FltF56   =   2104,
    CV_IA64_FltF57   =   2105,
    CV_IA64_FltF58   =   2106,
    CV_IA64_FltF59   =   2107,
    CV_IA64_FltF60   =   2108,
    CV_IA64_FltF61   =   2109,
    CV_IA64_FltF62   =   2110,
    CV_IA64_FltF63   =   2111,
    CV_IA64_FltF64   =   2112,
    CV_IA64_FltF65   =   2113,
    CV_IA64_FltF66   =   2114,
    CV_IA64_FltF67   =   2115,
    CV_IA64_FltF68   =   2116,
    CV_IA64_FltF69   =   2117,
    CV_IA64_FltF70   =   2118,
    CV_IA64_FltF71   =   2119,
    CV_IA64_FltF72   =   2120,
    CV_IA64_FltF73   =   2121,
    CV_IA64_FltF74   =   2122,
    CV_IA64_FltF75   =   2123,
    CV_IA64_FltF76   =   2124,
    CV_IA64_FltF77   =   2125,
    CV_IA64_FltF78   =   2126,
    CV_IA64_FltF79   =   2127,
    CV_IA64_FltF80   =   2128,
    CV_IA64_FltF81   =   2129,
    CV_IA64_FltF82   =   2130,
    CV_IA64_FltF83   =   2131,
    CV_IA64_FltF84   =   2132,
    CV_IA64_FltF85   =   2133,
    CV_IA64_FltF86   =   2134,
    CV_IA64_FltF87   =   2135,
    CV_IA64_FltF88   =   2136,
    CV_IA64_FltF89   =   2137,
    CV_IA64_FltF90   =   2138,
    CV_IA64_FltF91   =   2139,
    CV_IA64_FltF92   =   2140,
    CV_IA64_FltF93   =   2141,
    CV_IA64_FltF94   =   2142,
    CV_IA64_FltF95   =   2143,
    CV_IA64_FltF96   =   2144,
    CV_IA64_FltF97   =   2145,
    CV_IA64_FltF98   =   2146,
    CV_IA64_FltF99   =   2147,
    CV_IA64_FltF100   =   2148,
    CV_IA64_FltF101   =   2149,
    CV_IA64_FltF102   =   2150,
    CV_IA64_FltF103   =   2151,
    CV_IA64_FltF104   =   2152,
    CV_IA64_FltF105   =   2153,
    CV_IA64_FltF106   =   2154,
    CV_IA64_FltF107   =   2155,
    CV_IA64_FltF108   =   2156,
    CV_IA64_FltF109   =   2157,
    CV_IA64_FltF110   =   2158,
    CV_IA64_FltF111   =   2159,
    CV_IA64_FltF112   =   2160,
    CV_IA64_FltF113   =   2161,
    CV_IA64_FltF114   =   2162,
    CV_IA64_FltF115   =   2163,
    CV_IA64_FltF116   =   2164,
    CV_IA64_FltF117   =   2165,
    CV_IA64_FltF118   =   2166,
    CV_IA64_FltF119   =   2167,
    CV_IA64_FltF120   =   2168,
    CV_IA64_FltF121   =   2169,
    CV_IA64_FltF122   =   2170,
    CV_IA64_FltF123   =   2171,
    CV_IA64_FltF124   =   2172,
    CV_IA64_FltF125   =   2173,
    CV_IA64_FltF126   =   2174,
    CV_IA64_FltF127   =   2175,

    // Application Registers

    CV_IA64_ApKR0    =   3072,
    CV_IA64_ApKR1    =   3073,
    CV_IA64_ApKR2    =   3074,
    CV_IA64_ApKR3    =   3075,
    CV_IA64_ApKR4    =   3076,
    CV_IA64_ApKR5    =   3077,
    CV_IA64_ApKR6    =   3078,
    CV_IA64_ApKR7    =   3079,
    CV_IA64_AR8      =   3080,
    CV_IA64_AR9      =   3081,
    CV_IA64_AR10     =   3082,
    CV_IA64_AR11     =   3083,
    CV_IA64_AR12     =   3084,
    CV_IA64_AR13     =   3085,
    CV_IA64_AR14     =   3086,
    CV_IA64_AR15     =   3087,
    CV_IA64_RsRSC    =   3088,
    CV_IA64_RsBSP    =   3089,
    CV_IA64_RsBSPSTORE =   3090,
    CV_IA64_RsRNAT   =   3091,
    CV_IA64_AR20     =   3092,
    CV_IA64_AR21     =   3093,
    CV_IA64_AR22     =   3094,
    CV_IA64_AR23     =   3095,
    CV_IA64_AR24     =   3096,
    CV_IA64_AR25     =   3097,
    CV_IA64_AR26     =   3098,
    CV_IA64_AR27     =   3099,
    CV_IA64_AR28     =   3100,
    CV_IA64_AR29     =   3101,
    CV_IA64_AR30     =   3102,
    CV_IA64_AR31     =   3103,
    CV_IA64_ApCCV    =   3104,
    CV_IA64_AR33     =   3105,
    CV_IA64_AR34     =   3106,
    CV_IA64_AR35     =   3107,
    CV_IA64_ApUNAT   =   3108,
    CV_IA64_AR37     =   3109,
    CV_IA64_AR38     =   3110,
    CV_IA64_AR39     =   3111,
    CV_IA64_StFPSR   =   3112,
    CV_IA64_AR41     =   3113,
    CV_IA64_AR42     =   3114,
    CV_IA64_AR43     =   3115,
    CV_IA64_ApITC    =   3116,
    CV_IA64_AR45     =   3117,
    CV_IA64_AR46     =   3118,
    CV_IA64_AR47     =   3119,
    CV_IA64_AR48     =   3120,
    CV_IA64_AR49     =   3121,
    CV_IA64_AR50     =   3122,
    CV_IA64_AR51     =   3123,
    CV_IA64_AR52     =   3124,
    CV_IA64_AR53     =   3125,
    CV_IA64_AR54     =   3126,
    CV_IA64_AR55     =   3127,
    CV_IA64_AR56     =   3128,
    CV_IA64_AR57     =   3129,
    CV_IA64_AR58     =   3130,
    CV_IA64_AR59     =   3131,
    CV_IA64_AR60     =   3132,
    CV_IA64_AR61     =   3133,
    CV_IA64_AR62     =   3134,
    CV_IA64_AR63     =   3135,
    CV_IA64_RsPFS    =   3136,
    CV_IA64_ApLC     =   3137,
    CV_IA64_ApEC     =   3138,
    CV_IA64_AR67   =   3139,
    CV_IA64_AR68   =   3140,
    CV_IA64_AR69   =   3141,
    CV_IA64_AR70   =   3142,
    CV_IA64_AR71   =   3143,
    CV_IA64_AR72   =   3144,
    CV_IA64_AR73   =   3145,
    CV_IA64_AR74   =   3146,
    CV_IA64_AR75   =   3147,
    CV_IA64_AR76   =   3148,
    CV_IA64_AR77   =   3149,
    CV_IA64_AR78   =   3150,
    CV_IA64_AR79   =   3151,
    CV_IA64_AR80   =   3152,
    CV_IA64_AR81   =   3153,
    CV_IA64_AR82   =   3154,
    CV_IA64_AR83   =   3155,
    CV_IA64_AR84   =   3156,
    CV_IA64_AR85   =   3157,
    CV_IA64_AR86   =   3158,
    CV_IA64_AR87   =   3159,
    CV_IA64_AR88   =   3160,
    CV_IA64_AR89   =   3161,
    CV_IA64_AR90   =   3162,
    CV_IA64_AR91   =   3163,
    CV_IA64_AR92   =   3164,
    CV_IA64_AR93   =   3165,
    CV_IA64_AR94   =   3166,
    CV_IA64_AR95   =   3167,
    CV_IA64_AR96   =   3168,
    CV_IA64_AR97   =   3169,
    CV_IA64_AR98   =   3170,
    CV_IA64_AR99   =   3171,
    CV_IA64_AR100   =   3172,
    CV_IA64_AR101   =   3173,
    CV_IA64_AR102   =   3174,
    CV_IA64_AR103   =   3175,
    CV_IA64_AR104   =   3176,
    CV_IA64_AR105   =   3177,
    CV_IA64_AR106   =   3178,
    CV_IA64_AR107   =   3179,
    CV_IA64_AR108   =   3180,
    CV_IA64_AR109   =   3181,
    CV_IA64_AR110   =   3182,
    CV_IA64_AR111   =   3183,
    CV_IA64_AR112   =   3184,
    CV_IA64_AR113   =   3185,
    CV_IA64_AR114   =   3186,
    CV_IA64_AR115   =   3187,
    CV_IA64_AR116   =   3188,
    CV_IA64_AR117   =   3189,
    CV_IA64_AR118   =   3190,
    CV_IA64_AR119   =   3191,
    CV_IA64_AR120   =   3192,
    CV_IA64_AR121   =   3193,
    CV_IA64_AR122   =   3194,
    CV_IA64_AR123   =   3195,
    CV_IA64_AR124   =   3196,
    CV_IA64_AR125   =   3197,
    CV_IA64_AR126   =   3198,
    CV_IA64_AR127   =   3199,

    // Control Registers

    CV_IA64_ApDCR    =   4096,
    CV_IA64_ApITM    =   4097,
    CV_IA64_ApIVA    =   4098,
    CV_IA64_CR3      =   4099,
    CV_IA64_CR4      =   4100,
    CV_IA64_CR5      =   4101,
    CV_IA64_CR6      =   4102,
    CV_IA64_CR7      =   4103,
    CV_IA64_ApPTA    =   4104,
    CV_IA64_CR9      =   4105,
    CV_IA64_CR10     =   4106,
    CV_IA64_CR11     =   4107,
    CV_IA64_CR12     =   4108,
    CV_IA64_CR13     =   4109,
    CV_IA64_CR14     =   4110,
    CV_IA64_CR15     =   4111,
    CV_IA64_StIPSR   =   4112,
    CV_IA64_StISR    =   4113,
    CV_IA64_StIDA    =   4114,
    CV_IA64_StIIP    =   4115,
    CV_IA64_StIDTR   =   4116,
    CV_IA64_StIITR   =   4117,
    CV_IA64_StIIPA   =   4118,
    CV_IA64_StIFS    =   4119,
    CV_IA64_StIIM    =   4120,
    CV_IA64_StIHA    =   4121,
    CV_IA64_CR26     =   4122,
    CV_IA64_CR27     =   4123,
    CV_IA64_CR28     =   4124,
    CV_IA64_CR29     =   4125,
    CV_IA64_CR30     =   4126,
    CV_IA64_CR31     =   4127,
    CV_IA64_CR32     =   4128,
    CV_IA64_CR33     =   4129,
    CV_IA64_CR34     =   4130,
    CV_IA64_CR35     =   4131,
    CV_IA64_CR36     =   4132,
    CV_IA64_CR37     =   4133,
    CV_IA64_CR38     =   4134,
    CV_IA64_CR39     =   4135,
    CV_IA64_CR40     =   4136,
    CV_IA64_CR41     =   4137,
    CV_IA64_CR42     =   4138,
    CV_IA64_CR43     =   4139,
    CV_IA64_CR44     =   4140,
    CV_IA64_CR45     =   4141,
    CV_IA64_CR46     =   4142,
    CV_IA64_CR47     =   4143,
    CV_IA64_CR48     =   4144,
    CV_IA64_CR49     =   4145,
    CV_IA64_CR50     =   4146,
    CV_IA64_CR51     =   4147,
    CV_IA64_CR52     =   4148,
    CV_IA64_CR53     =   4149,
    CV_IA64_CR54     =   4150,
    CV_IA64_CR55     =   4151,
    CV_IA64_CR56     =   4152,
    CV_IA64_CR57     =   4153,
    CV_IA64_CR58     =   4154,
    CV_IA64_CR59     =   4155,
    CV_IA64_CR60     =   4156,
    CV_IA64_CR61     =   4157,
    CV_IA64_CR62     =   4158,
    CV_IA64_CR63     =   4159,
    CV_IA64_CR64     =   4160,
    CV_IA64_CR65     =   4161,
    CV_IA64_SaLID    =   4162,
    CV_IA64_CR67     =   4163,
    CV_IA64_CR68     =   4164,
    CV_IA64_CR69     =   4165,
    CV_IA64_CR70     =   4166,
    CV_IA64_SaIVR    =   4167,
    CV_IA64_SaTPR    =   4168,
    CV_IA64_CR73     =   4169,
    CV_IA64_CR74     =   4170,
    CV_IA64_SaEOI    =   4171,
    CV_IA64_CR76     =   4172,
    CV_IA64_CR77     =   4173,
    CV_IA64_CR78     =   4174,
    CV_IA64_CR79     =   4175,
    CV_IA64_CR80     =   4176,
    CV_IA64_CR81     =   4177,
    CV_IA64_CR82     =   4178,
    CV_IA64_CR83     =   4179,
    CV_IA64_CR84     =   4180,
    CV_IA64_CR85     =   4181,
    CV_IA64_CR86     =   4182,
    CV_IA64_CR87     =   4183,
    CV_IA64_CR88     =   4184,
    CV_IA64_CR89     =   4185,
    CV_IA64_CR90     =   4186,
    CV_IA64_CR91     =   4187,
    CV_IA64_CR92     =   4188,
    CV_IA64_CR93     =   4189,
    CV_IA64_CR94     =   4190,
    CV_IA64_CR95     =   4191,
    CV_IA64_SaIRR0   =   4192,
    CV_IA64_CR97     =   4193,
    CV_IA64_SaIRR1   =   4194,
    CV_IA64_CR99     =   4195,
    CV_IA64_SaIRR2   =   4196,
    CV_IA64_CR101    =   4197,
    CV_IA64_SaIRR3   =   4198,
    CV_IA64_CR103    =   4199,
    CV_IA64_CR104    =   4200,
    CV_IA64_CR105    =   4201,
    CV_IA64_CR106    =   4202,
    CV_IA64_CR107    =   4203,
    CV_IA64_CR108    =   4204,
    CV_IA64_CR109    =   4205,
    CV_IA64_CR110    =   4206,
    CV_IA64_CR111    =   4207,
    CV_IA64_CR112    =   4208,
    CV_IA64_CR113    =   4209,
    CV_IA64_SaITV    =   4210,
    CV_IA64_CR115    =   4211,
    CV_IA64_SaPMV    =   4212,
    CV_IA64_SaLRR0   =   4213,
    CV_IA64_SaLRR1   =   4214,
    CV_IA64_SaCMCV   =   4215,
    CV_IA64_CR120    =   4216,
    CV_IA64_CR121    =   4217,
    CV_IA64_CR122    =   4218,
    CV_IA64_CR123    =   4219,
    CV_IA64_CR124    =   4220,
    CV_IA64_CR125    =   4221,
    CV_IA64_CR126    =   4222,
    CV_IA64_CR127    =   4223,

    // Protection Key Registers

    CV_IA64_Pkr0     =   5120,
    CV_IA64_Pkr1     =   5121,
    CV_IA64_Pkr2     =   5122,
    CV_IA64_Pkr3     =   5123,
    CV_IA64_Pkr4     =   5124,
    CV_IA64_Pkr5     =   5125,
    CV_IA64_Pkr6     =   5126,
    CV_IA64_Pkr7     =   5127,
    CV_IA64_Pkr8     =   5128,
    CV_IA64_Pkr9     =   5129,
    CV_IA64_Pkr10    =   5130,
    CV_IA64_Pkr11    =   5131,
    CV_IA64_Pkr12    =   5132,
    CV_IA64_Pkr13    =   5133,
    CV_IA64_Pkr14    =   5134,
    CV_IA64_Pkr15    =   5135,

    // Region Registers

    CV_IA64_Rr0      =   6144,
    CV_IA64_Rr1      =   6145,
    CV_IA64_Rr2      =   6146,
    CV_IA64_Rr3      =   6147,
    CV_IA64_Rr4      =   6148,
    CV_IA64_Rr5      =   6149,
    CV_IA64_Rr6      =   6150,
    CV_IA64_Rr7      =   6151,

    // Performance Monitor Data Registers

    CV_IA64_PFD0     =   7168,
    CV_IA64_PFD1     =   7169,
    CV_IA64_PFD2     =   7170,
    CV_IA64_PFD3     =   7171,
    CV_IA64_PFD4     =   7172,
    CV_IA64_PFD5     =   7173,
    CV_IA64_PFD6     =   7174,
    CV_IA64_PFD7     =   7175,

    // Performance Monitor Config Registers

    CV_IA64_PFC0     =   7424,
    CV_IA64_PFC1     =   7425,
    CV_IA64_PFC2     =   7426,
    CV_IA64_PFC3     =   7427,
    CV_IA64_PFC4     =   7428,
    CV_IA64_PFC5     =   7429,
    CV_IA64_PFC6     =   7430,
    CV_IA64_PFC7     =   7431,

    // Instruction Translation Registers

    CV_IA64_TrI0     =   8192,
    CV_IA64_TrI1     =   8193,
    CV_IA64_TrI2     =   8194,
    CV_IA64_TrI3     =   8195,
    CV_IA64_TrI4     =   8196,
    CV_IA64_TrI5     =   8197,
    CV_IA64_TrI6     =   8198,
    CV_IA64_TrI7     =   8199,

    // Data Translation Registers

    CV_IA64_TrD0     =   8320,
    CV_IA64_TrD1     =   8321,
    CV_IA64_TrD2     =   8322,
    CV_IA64_TrD3     =   8323,
    CV_IA64_TrD4     =   8324,
    CV_IA64_TrD5     =   8325,
    CV_IA64_TrD6     =   8326,
    CV_IA64_TrD7     =   8327,

    // Instruction Breakpoint Registers

    CV_IA64_DbI0     =   8448,
    CV_IA64_DbI1     =   8449,
    CV_IA64_DbI2     =   8450,
    CV_IA64_DbI3     =   8451,
    CV_IA64_DbI4     =   8452,
    CV_IA64_DbI5     =   8453,
    CV_IA64_DbI6     =   8454,
    CV_IA64_DbI7     =   8455,

    // Data Breakpoint Registers

    CV_IA64_DbD0     =   8576,
    CV_IA64_DbD1     =   8577,
    CV_IA64_DbD2     =   8578,
    CV_IA64_DbD3     =   8579,
    CV_IA64_DbD4     =   8580,
    CV_IA64_DbD5     =   8581,
    CV_IA64_DbD6     =   8582,
    CV_IA64_DbD7     =   8583,

} CV_HREG_e;

#pragma pack ( pop )

#endif /* CV_INFO_INCLUDED */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\vctools\pdb6\langapi\include\cvinfo16.h ===
/***    cvinfo.h - Generic CodeView information definitions
 *
 *      Structures, constants, etc. for accessing and interpreting
 *      CodeView information.
 *
 */


/***    The master copy of this file resides in the langapi project.
 *      All Microsoft projects are required to use the master copy without
 *      modification.  Modification of the master version or a copy
 *      without consultation with all parties concerned is extremely
 *      risky.
 *
 *      When this file is modified, the corresponding documentation file
 *      omfdeb.doc in the langapi project must be updated.
 */

#ifndef _VC_VER_INC
#include "..\include\vcver.h"
#endif

#if CC_CVTYPE32
#include "./cvinfo32.h"
#else

#ifndef _CV_INFO_INCLUDED
#define _CV_INFO_INCLUDED

#ifdef  __cplusplus
#pragma warning ( disable: 4200 )
#endif

#ifndef __INLINE
#ifdef  __cplusplus
#define __INLINE inline
#else
#define __INLINE __inline
#endif
#endif

#pragma pack ( push, 1 )
typedef unsigned long   CV_uoff32_t;
typedef          long   CV_off32_t;
typedef unsigned short  CV_uoff16_t;
typedef          short  CV_off16_t;
typedef unsigned short  CV_typ_t;
typedef CV_typ_t        CV_typ16_t;

#if !defined (CV_ZEROLEN)
#define CV_ZEROLEN
#endif

#if !defined (FLOAT10)
#if defined(_M_I86)                    // 16 bit x86 supporting long double
typedef long double FLOAT10;
#else                                  // 32 bit w/o long double support
typedef struct FLOAT10
{
    char b[10];
} FLOAT10;
#endif
#endif


#define CV_SIGNATURE_C6         0L  // Actual signature is >64K
#define CV_SIGNATURE_C7         1L  // First explicit signature
#define CV_SIGNATURE_RESERVED   2L  // All signatures from 2 to 64K are reserved

#define CV_MAXOFFSET   0xffffffff

/**     CodeView Symbol and Type OMF type information is broken up into two
 *      ranges.  Type indices less than 0x1000 describe type information
 *      that is frequently used.  Type indices above 0x1000 are used to
 *      describe more complex features such as functions, arrays and
 *      structures.
 */




/**     Primitive types have predefined meaning that is encoded in the
 *      values of the various bit fields in the value.
 *
 *      A CodeView primitive type is defined as:
 *
 *      1 1
 *      1 089  7654  3  210
 *      r mode type  r  sub
 *
 *      Where
 *          mode is the pointer mode
 *          type is a type indicator
 *          sub  is a subtype enumeration
 *          r    is a reserved field
 *
 *      See Microsoft Symbol and Type OMF (Version 4.0) for more
 *      information.
 */


#define CV_MMASK        0x700       // mode mask
#define CV_TMASK        0x0f0       // type mask

// can we use the reserved bit ??
#define CV_SMASK        0x00f       // subtype mask

#define CV_MSHIFT       8           // primitive mode right shift count
#define CV_TSHIFT       4           // primitive type right shift count
#define CV_SSHIFT       0           // primitive subtype right shift count

// macros to extract primitive mode, type and size

#define CV_MODE(typ)    (((typ) & CV_MMASK) >> CV_MSHIFT)
#define CV_TYPE(typ)    (((typ) & CV_TMASK) >> CV_TSHIFT)
#define CV_SUBT(typ)    (((typ) & CV_SMASK) >> CV_SSHIFT)

// macros to insert new primitive mode, type and size

#define CV_NEWMODE(typ, nm)     ((CV_typ_t)(((typ) & ~CV_MMASK) | ((nm) << CV_MSHIFT)))
#define CV_NEWTYPE(typ, nt)     (((typ) & ~CV_TMASK) | ((nt) << CV_TSHIFT))
#define CV_NEWSUBT(typ, ns)     (((typ) & ~CV_SMASK) | ((ns) << CV_SSHIFT))



//     pointer mode enumeration values

typedef enum CV_prmode_e {
    CV_TM_DIRECT = 0,       // mode is not a pointer
    CV_TM_NPTR   = 1,       // mode is a near pointer
    CV_TM_FPTR   = 2,       // mode is a far pointer
    CV_TM_HPTR   = 3,       // mode is a huge pointer
    CV_TM_NPTR32 = 4,       // mode is a 32 bit near pointer
    CV_TM_FPTR32 = 5,       // mode is a 32 bit far pointer
    CV_TM_NPTR64 = 6,       // mode is a 64 bit near pointer
    CV_TM_NPTR128 = 7       // mode is a 128 bit near pointer
} CV_prmode_e;




//      type enumeration values


typedef enum CV_type_e {
    CV_SPECIAL      = 0x00,         // special type size values
    CV_SIGNED       = 0x01,         // signed integral size values
    CV_UNSIGNED     = 0x02,         // unsigned integral size values
    CV_BOOLEAN      = 0x03,         // Boolean size values
    CV_REAL         = 0x04,         // real number size values
    CV_COMPLEX      = 0x05,         // complex number size values
    CV_SPECIAL2     = 0x06,         // second set of special types
    CV_INT          = 0x07,         // integral (int) values
    CV_CVRESERVED   = 0x0f
} CV_type_e;




//      subtype enumeration values for CV_SPECIAL


typedef enum CV_special_e {
    CV_SP_NOTYPE    = 0x00,
    CV_SP_ABS       = 0x01,
    CV_SP_SEGMENT   = 0x02,
    CV_SP_VOID      = 0x03,
    CV_SP_CURRENCY  = 0x04,
    CV_SP_NBASICSTR = 0x05,
    CV_SP_FBASICSTR = 0x06,
    CV_SP_NOTTRANS  = 0x07
} CV_special_e;




//      subtype enumeration values for CV_SPECIAL2


typedef enum CV_special2_e {
    CV_S2_BIT       = 0x00,
    CV_S2_PASCHAR   = 0x01          // Pascal CHAR
} CV_special2_e;





//      subtype enumeration values for CV_SIGNED, CV_UNSIGNED and CV_BOOLEAN


typedef enum CV_integral_e {
    CV_IN_1BYTE     = 0x00,
    CV_IN_2BYTE     = 0x01,
    CV_IN_4BYTE     = 0x02,
    CV_IN_8BYTE     = 0x03,
    CV_IN_16BYTE    = 0x04
} CV_integral_e;





//      subtype enumeration values for CV_REAL and CV_COMPLEX


typedef enum CV_real_e {
    CV_RC_REAL32    = 0x00,
    CV_RC_REAL64    = 0x01,
    CV_RC_REAL80    = 0x02,
    CV_RC_REAL128   = 0x03,
    CV_RC_REAL48    = 0x04
} CV_real_e;




//      subtype enumeration values for CV_INT (really int)


typedef enum CV_int_e {
    CV_RI_CHAR      = 0x00,
    CV_RI_INT1      = 0x00,
    CV_RI_WCHAR     = 0x01,
    CV_RI_UINT1     = 0x01,
    CV_RI_INT2      = 0x02,
    CV_RI_UINT2     = 0x03,
    CV_RI_INT4      = 0x04,
    CV_RI_UINT4     = 0x05,
    CV_RI_INT8      = 0x06,
    CV_RI_UINT8     = 0x07,
    CV_RI_INT16     = 0x08,
    CV_RI_UINT16    = 0x09
} CV_int_e;




// macros to check the type of a primitive

#define CV_TYP_IS_DIRECT(typ)   (CV_MODE(typ) == CV_TM_DIRECT)
#define CV_TYP_IS_PTR(typ)      (CV_MODE(typ) != CV_TM_DIRECT)
#define CV_TYP_IS_NPTR(typ)     (CV_MODE(typ) == CV_TM_NPTR)
#define CV_TYP_IS_FPTR(typ)     (CV_MODE(typ) == CV_TM_FPTR)
#define CV_TYP_IS_HPTR(typ)     (CV_MODE(typ) == CV_TM_HPTR)
#define CV_TYP_IS_NPTR32(typ)   (CV_MODE(typ) == CV_TM_NPTR32)
#define CV_TYP_IS_FPTR32(typ)   (CV_MODE(typ) == CV_TM_FPTR32)

#define CV_TYP_IS_SIGNED(typ)   (((CV_TYPE(typ) == CV_SIGNED) && CV_TYP_IS_DIRECT(typ)) || \
                                 (typ == T_INT1)  || \
                                 (typ == T_INT2)  || \
                                 (typ == T_INT4)  || \
                                 (typ == T_INT8)  || \
                                 (typ == T_INT16) || \
                                 (typ == T_RCHAR))

#define CV_TYP_IS_UNSIGNED(typ) (((CV_TYPE(typ) == CV_UNSIGNED) && CV_TYP_IS_DIRECT(typ)) || \
                                 (typ == T_UINT1) || \
                                 (typ == T_UINT2) || \
                                 (typ == T_UINT4) || \
                                 (typ == T_UINT8) || \
                                 (typ == T_UINT16))

#define CV_TYP_IS_REAL(typ)     ((CV_TYPE(typ) == CV_REAL)  && CV_TYP_IS_DIRECT(typ))

#define CV_FIRST_NONPRIM 0x1000
#define CV_IS_PRIMITIVE(typ)    ((typ) < CV_FIRST_NONPRIM)
#define CV_TYP_IS_COMPLEX(typ)  ((CV_TYPE(typ) == CV_COMPLEX)   && CV_TYP_IS_DIRECT(typ))




// selected values for type_index - for a more complete definition, see
// Microsoft Symbol and Type OMF document




//      Special Types


#define T_NOTYPE        0x0000      // uncharacterized type (no type)
#define T_ABS           0x0001      // absolute symbol
#define T_SEGMENT       0x0002      // segment type
#define T_VOID          0x0003      // void
#define T_PVOID         0x0103      // near pointer to void
#define T_PFVOID        0x0203      // far pointer to void
#define T_PHVOID        0x0303      // huge pointer to void
#define T_32PVOID       0x0403      // 16:32 near pointer to void
#define T_32PFVOID      0x0503      // 16:32 far pointer to void
#define T_CURRENCY      0x0004      // BASIC 8 byte currency value
#define T_NBASICSTR     0x0005      // Near BASIC string
#define T_FBASICSTR     0x0006      // Far BASIC string
#define T_NOTTRANS      0x0007      // type not translated by cvpack
#define T_BIT           0x0060      // bit
#define T_PASCHAR       0x0061      // Pascal CHAR



//      Character types


#define T_CHAR          0x0010      // 8 bit signed
#define T_UCHAR         0x0020      // 8 bit unsigned
#define T_PCHAR         0x0110      // near pointer to 8 bit signed
#define T_PUCHAR        0x0120      // near pointer to 8 bit unsigned
#define T_PFCHAR        0x0210      // far pointer to 8 bit signed
#define T_PFUCHAR       0x0220      // far pointer to 8 bit unsigned
#define T_PHCHAR        0x0310      // huge pointer to 8 bit signed
#define T_PHUCHAR       0x0320      // huge pointer to 8 bit unsigned
#define T_32PCHAR       0x0410      // 16:32 near pointer to 8 bit signed
#define T_32PUCHAR      0x0420      // 16:32 near pointer to 8 bit unsigned
#define T_32PFCHAR      0x0510      // 16:32 far pointer to 8 bit signed
#define T_32PFUCHAR     0x0520      // 16:32 far pointer to 8 bit unsigned




//      really a character types

#define T_RCHAR         0x0070      // really a char
#define T_PRCHAR        0x0170      // 16:16 near pointer to a real char
#define T_PFRCHAR       0x0270      // 16:16 far pointer to a real char
#define T_PHRCHAR       0x0370      // 16:16 huge pointer to a real char
#define T_32PRCHAR      0x0470      // 16:32 near pointer to a real char
#define T_32PFRCHAR     0x0570      // 16:32 far pointer to a real char




//      really a wide character types

#define T_WCHAR         0x0071      // wide char
#define T_PWCHAR        0x0171      // 16:16 near pointer to a wide char
#define T_PFWCHAR       0x0271      // 16:16 far pointer to a wide char
#define T_PHWCHAR       0x0371      // 16:16 huge pointer to a wide char
#define T_32PWCHAR      0x0471      // 16:32 near pointer to a wide char
#define T_32PFWCHAR     0x0571      // 16:32 far pointer to a wide char


//      8 bit int types


#define T_INT1          0x0068      // 8 bit signed int
#define T_UINT1         0x0069      // 8 bit unsigned int
#define T_PINT1         0x0168      // near pointer to 8 bit signed int
#define T_PUINT1        0x0169      // near pointer to 8 bit unsigned int
#define T_PFINT1        0x0268      // far pointer to 8 bit signed int
#define T_PFUINT1       0x0269      // far pointer to 8 bit unsigned int
#define T_PHINT1        0x0368      // huge pointer to 8 bit signed int
#define T_PHUINT1       0x0369      // huge pointer to 8 bit unsigned int

#define T_32PINT1       0x0468      // 16:32 near pointer to 8 bit signed int
#define T_32PUINT1      0x0469      // 16:32 near pointer to 8 bit unsigned int
#define T_32PFINT1      0x0568      // 16:32 far pointer to 8 bit signed int
#define T_32PFUINT1     0x0569      // 16:32 far pointer to 8 bit unsigned int


//      16 bit short types


#define T_SHORT         0x0011      // 16 bit signed
#define T_USHORT        0x0021      // 16 bit unsigned
#define T_PSHORT        0x0111      // near pointer to 16 bit signed
#define T_PUSHORT       0x0121      // near pointer to 16 bit unsigned
#define T_PFSHORT       0x0211      // far pointer to 16 bit signed
#define T_PFUSHORT      0x0221      // far pointer to 16 bit unsigned
#define T_PHSHORT       0x0311      // huge pointer to 16 bit signed
#define T_PHUSHORT      0x0321      // huge pointer to 16 bit unsigned

#define T_32PSHORT      0x0411      // 16:32 near pointer to 16 bit signed
#define T_32PUSHORT     0x0421      // 16:32 near pointer to 16 bit unsigned
#define T_32PFSHORT     0x0511      // 16:32 far pointer to 16 bit signed
#define T_32PFUSHORT    0x0521      // 16:32 far pointer to 16 bit unsigned




//      16 bit int types


#define T_INT2          0x0072      // 16 bit signed int
#define T_UINT2         0x0073      // 16 bit unsigned int
#define T_PINT2         0x0172      // near pointer to 16 bit signed int
#define T_PUINT2        0x0173      // near pointer to 16 bit unsigned int
#define T_PFINT2        0x0272      // far pointer to 16 bit signed int
#define T_PFUINT2       0x0273      // far pointer to 16 bit unsigned int
#define T_PHINT2        0x0372      // huge pointer to 16 bit signed int
#define T_PHUINT2       0x0373      // huge pointer to 16 bit unsigned int

#define T_32PINT2       0x0472      // 16:32 near pointer to 16 bit signed int
#define T_32PUINT2      0x0473      // 16:32 near pointer to 16 bit unsigned int
#define T_32PFINT2      0x0572      // 16:32 far pointer to 16 bit signed int
#define T_32PFUINT2     0x0573      // 16:32 far pointer to 16 bit unsigned int




//      32 bit long types


#define T_LONG          0x0012      // 32 bit signed
#define T_ULONG         0x0022      // 32 bit unsigned
#define T_PLONG         0x0112      // near pointer to 32 bit signed
#define T_PULONG        0x0122      // near pointer to 32 bit unsigned
#define T_PFLONG        0x0212      // far pointer to 32 bit signed
#define T_PFULONG       0x0222      // far pointer to 32 bit unsigned
#define T_PHLONG        0x0312      // huge pointer to 32 bit signed
#define T_PHULONG       0x0322      // huge pointer to 32 bit unsigned

#define T_32PLONG       0x0412      // 16:32 near pointer to 32 bit signed
#define T_32PULONG      0x0422      // 16:32 near pointer to 32 bit unsigned
#define T_32PFLONG      0x0512      // 16:32 far pointer to 32 bit signed
#define T_32PFULONG     0x0522      // 16:32 far pointer to 32 bit unsigned




//      32 bit int types


#define T_INT4          0x0074      // 32 bit signed int
#define T_UINT4         0x0075      // 32 bit unsigned int
#define T_PINT4         0x0174      // near pointer to 32 bit signed int
#define T_PUINT4        0x0175      // near pointer to 32 bit unsigned int
#define T_PFINT4        0x0274      // far pointer to 32 bit signed int
#define T_PFUINT4       0x0275      // far pointer to 32 bit unsigned int
#define T_PHINT4        0x0374      // huge pointer to 32 bit signed int
#define T_PHUINT4       0x0375      // huge pointer to 32 bit unsigned int

#define T_32PINT4       0x0474      // 16:32 near pointer to 32 bit signed int
#define T_32PUINT4      0x0475      // 16:32 near pointer to 32 bit unsigned int
#define T_32PFINT4      0x0574      // 16:32 far pointer to 32 bit signed int
#define T_32PFUINT4     0x0575      // 16:32 far pointer to 32 bit unsigned int




//      64 bit quad types


#define T_QUAD          0x0013      // 64 bit signed
#define T_UQUAD         0x0023      // 64 bit unsigned
#define T_PQUAD         0x0113      // near pointer to 64 bit signed
#define T_PUQUAD        0x0123      // near pointer to 64 bit unsigned
#define T_PFQUAD        0x0213      // far pointer to 64 bit signed
#define T_PFUQUAD       0x0223      // far pointer to 64 bit unsigned
#define T_PHQUAD        0x0313      // huge pointer to 64 bit signed
#define T_PHUQUAD       0x0323      // huge pointer to 64 bit unsigned
#define T_32PQUAD       0x0413      // 16:32 near pointer to 64 bit signed
#define T_32PUQUAD      0x0423      // 16:32 near pointer to 64 bit unsigned
#define T_32PFQUAD      0x0513      // 16:32 far pointer to 64 bit signed
#define T_32PFUQUAD     0x0523      // 16:32 far pointer to 64 bit unsigned



//      64 bit int types


#define T_INT8          0x0076      // 64 bit signed int
#define T_UINT8         0x0077      // 64 bit unsigned int
#define T_PINT8         0x0176      // near pointer to 64 bit signed int
#define T_PUINT8        0x0177      // near pointer to 64 bit unsigned int
#define T_PFINT8        0x0276      // far pointer to 64 bit signed int
#define T_PFUINT8       0x0277      // far pointer to 64 bit unsigned int
#define T_PHINT8        0x0376      // huge pointer to 64 bit signed int
#define T_PHUINT8       0x0377      // huge pointer to 64 bit unsigned int

#define T_32PINT8       0x0476      // 16:32 near pointer to 64 bit signed int
#define T_32PUINT8      0x0477      // 16:32 near pointer to 64 bit unsigned int
#define T_32PFINT8      0x0576      // 16:32 far pointer to 64 bit signed int
#define T_32PFUINT8     0x0577      // 16:32 far pointer to 64 bit unsigned int


//      128 bit octet types


#define T_OCT           0x0014      // 128 bit signed
#define T_UOCT          0x0024      // 128 bit unsigned
#define T_POCT          0x0114      // near pointer to 128 bit signed
#define T_PUOCT         0x0124      // near pointer to 128 bit unsigned
#define T_PFOCT         0x0214      // far pointer to 128 bit signed
#define T_PFUOCT        0x0224      // far pointer to 128 bit unsigned
#define T_PHOCT         0x0314      // huge pointer to 128 bit signed
#define T_PHUOCT        0x0324      // huge pointer to 128 bit unsigned

#define T_32POCT        0x0414      // 16:32 near pointer to 128 bit signed
#define T_32PUOCT       0x0424      // 16:32 near pointer to 128 bit unsigned
#define T_32PFOCT       0x0514      // 16:32 far pointer to 128 bit signed
#define T_32PFUOCT      0x0524      // 16:32 far pointer to 128 bit unsigned

//      128 bit int types


#define T_INT16         0x0078      // 128 bit signed int
#define T_UINT16        0x0079      // 128 bit unsigned int
#define T_PINT16        0x0178      // near pointer to 128 bit signed int
#define T_PUINT16       0x0179      // near pointer to 128 bit unsigned int
#define T_PFINT16       0x0278      // far pointer to 128 bit signed int
#define T_PFUINT16      0x0279      // far pointer to 128 bit unsigned int
#define T_PHINT16       0x0378      // huge pointer to 128 bit signed int
#define T_PHUINT16      0x0379      // huge pointer to 128 bit unsigned int

#define T_32PINT16      0x0478      // 16:32 near pointer to 128 bit signed int
#define T_32PUINT16     0x0479      // 16:32 near pointer to 128 bit unsigned int
#define T_32PFINT16     0x0578      // 16:32 far pointer to 128 bit signed int
#define T_32PFUINT16    0x0579      // 16:32 far pointer to 128 bit unsigned int





//      32 bit real types


#define T_REAL32        0x0040      // 32 bit real
#define T_PREAL32       0x0140      // near pointer to 32 bit real
#define T_PFREAL32      0x0240      // far pointer to 32 bit real
#define T_PHREAL32      0x0340      // huge pointer to 32 bit real
#define T_32PREAL32     0x0440      // 16:32 near pointer to 32 bit real
#define T_32PFREAL32    0x0540      // 16:32 far pointer to 32 bit real



//      48 bit real types


#define T_REAL48        0x0044      // 48 bit real
#define T_PREAL48       0x0144      // near pointer to 48 bit real
#define T_PFREAL48      0x0244      // far pointer to 48 bit real
#define T_PHREAL48      0x0344      // huge pointer to 48 bit real
#define T_32PREAL48     0x0444      // 16:32 near pointer to 48 bit real
#define T_32PFREAL48    0x0544      // 16:32 far pointer to 48 bit real




//      64 bit real types


#define T_REAL64        0x0041      // 64 bit real
#define T_PREAL64       0x0141      // near pointer to 64 bit real
#define T_PFREAL64      0x0241      // far pointer to 64 bit real
#define T_PHREAL64      0x0341      // huge pointer to 64 bit real
#define T_32PREAL64     0x0441      // 16:32 near pointer to 64 bit real
#define T_32PFREAL64    0x0541      // 16:32 far pointer to 64 bit real




//      80 bit real types


#define T_REAL80        0x0042      // 80 bit real
#define T_PREAL80       0x0142      // near pointer to 80 bit real
#define T_PFREAL80      0x0242      // far pointer to 80 bit real
#define T_PHREAL80      0x0342      // huge pointer to 80 bit real
#define T_32PREAL80     0x0442      // 16:32 near pointer to 80 bit real
#define T_32PFREAL80    0x0542      // 16:32 far pointer to 80 bit real




//      128 bit real types


#define T_REAL128       0x0043      // 128 bit real
#define T_PREAL128      0x0143      // near pointer to 128 bit real
#define T_PFREAL128     0x0243      // far pointer to 128 bit real
#define T_PHREAL128     0x0343      // huge pointer to 128 bit real
#define T_32PREAL128    0x0443      // 16:32 near pointer to 128 bit real
#define T_32PFREAL128   0x0543      // 16:32 far pointer to 128 bit real




//      32 bit complex types


#define T_CPLX32        0x0050      // 32 bit complex
#define T_PCPLX32       0x0150      // near pointer to 32 bit complex
#define T_PFCPLX32      0x0250      // far pointer to 32 bit complex
#define T_PHCPLX32      0x0350      // huge pointer to 32 bit complex
#define T_32PCPLX32     0x0450      // 16:32 near pointer to 32 bit complex
#define T_32PFCPLX32    0x0550      // 16:32 far pointer to 32 bit complex




//      64 bit complex types


#define T_CPLX64        0x0051      // 64 bit complex
#define T_PCPLX64       0x0151      // near pointer to 64 bit complex
#define T_PFCPLX64      0x0251      // far pointer to 64 bit complex
#define T_PHCPLX64      0x0351      // huge pointer to 64 bit complex
#define T_32PCPLX64     0x0451      // 16:32 near pointer to 64 bit complex
#define T_32PFCPLX64    0x0551      // 16:32 far pointer to 64 bit complex




//      80 bit complex types


#define T_CPLX80        0x0052      // 80 bit complex
#define T_PCPLX80       0x0152      // near pointer to 80 bit complex
#define T_PFCPLX80      0x0252      // far pointer to 80 bit complex
#define T_PHCPLX80      0x0352      // huge pointer to 80 bit complex
#define T_32PCPLX80     0x0452      // 16:32 near pointer to 80 bit complex
#define T_32PFCPLX80    0x0552      // 16:32 far pointer to 80 bit complex




//      128 bit complex types


#define T_CPLX128       0x0053      // 128 bit complex
#define T_PCPLX128      0x0153      // near pointer to 128 bit complex
#define T_PFCPLX128     0x0253      // far pointer to 128 bit complex
#define T_PHCPLX128     0x0353      // huge pointer to 128 bit real
#define T_32PCPLX128    0x0453      // 16:32 near pointer to 128 bit complex
#define T_32PFCPLX128   0x0553      // 16:32 far pointer to 128 bit complex




//      boolean types


#define T_BOOL08        0x0030      // 8 bit boolean
#define T_BOOL16        0x0031      // 16 bit boolean
#define T_BOOL32        0x0032      // 32 bit boolean
#define T_BOOL64        0x0033      // 64 bit boolean
#define T_PBOOL08       0x0130      // near pointer to  8 bit boolean
#define T_PBOOL16       0x0131      // near pointer to 16 bit boolean
#define T_PBOOL32       0x0132      // near pointer to 32 bit boolean
#define T_PBOOL64       0x0133      // near pointer to 64 bit boolean
#define T_PFBOOL08      0x0230      // far pointer to  8 bit boolean
#define T_PFBOOL16      0x0231      // far pointer to 16 bit boolean
#define T_PFBOOL32      0x0232      // far pointer to 32 bit boolean
#define T_PFBOOL64      0x0233      // far pointer to 64 bit boolean
#define T_PHBOOL08      0x0330      // huge pointer to  8 bit boolean
#define T_PHBOOL16      0x0331      // huge pointer to 16 bit boolean
#define T_PHBOOL32      0x0332      // huge pointer to 32 bit boolean
#define T_PHBOOL64      0x0333      // huge pointer to 64 bit boolean

#define T_32PBOOL08     0x0430      // 16:32 near pointer to 8 bit boolean
#define T_32PFBOOL08    0x0530      // 16:32 far pointer to 8 bit boolean
#define T_32PBOOL16     0x0431      // 16:32 near pointer to 18 bit boolean
#define T_32PFBOOL16    0x0531      // 16:32 far pointer to 16 bit boolean
#define T_32PBOOL32     0x0432      // 16:32 near pointer to 32 bit boolean
#define T_32PFBOOL32    0x0532      // 16:32 far pointer to 32 bit boolean
#define T_32PBOOL64     0x0433      // 16:32 near pointer to 64 bit boolean
#define T_32PFBOOL64    0x0533      // 16:32 far pointer to 64 bit boolean


#define T_NCVPTR        0x01f0      // CV Internal type for created near pointers
#define T_FCVPTR        0x02f0      // CV Internal type for created far pointers
#define T_HCVPTR        0x03f0      // CV Internal type for created huge pointers
#define T_32NCVPTR      0x04f0      // CV Internal type for created near 32-bit pointers
#define T_32FCVPTR      0x05f0      // CV Internal type for created far 32-bit pointers
#define T_64NCVPTR      0x06f0      // CV Internal type for created near 64-bit pointers

#define CV_IS_INTERNAL_PTR(typ) (CV_IS_PRIMITIVE(typ) && \
                                 CV_TYPE(typ) == CV_CVRESERVED && \
                                 CV_TYP_IS_PTR(typ))


/**     No leaf index can have a value of 0x0000.  The leaf indices are
 *      separated into ranges depending upon the use of the type record.
 *      The second range is for the type records that are directly referenced
 *      in symbols. The first range is for type records that are not
 *      referenced by symbols but instead are referenced by other type
 *      records.  All type records must have a starting leaf index in these
 *      first two ranges.  The third range of leaf indices are used to build
 *      up complex lists such as the field list of a class type record.  No
 *      type record can begin with one of the leaf indices. The fourth ranges
 *      of type indices are used to represent numeric data in a symbol or
 *      type record. These leaf indices are greater than 0x8000.  At the
 *      point that type or symbol processor is expecting a numeric field, the
 *      next two bytes in the type record are examined.  If the value is less
 *      than 0x8000, then the two bytes contain the numeric value.  If the
 *      value is greater than 0x8000, then the data follows the leaf index in
 *      a format specified by the leaf index. The final range of leaf indices
 *      are used to force alignment of subfields within a complex type record..
 */



    // leaf indices starting records but referenced from symbol records

#define LF_MODIFIER     0x0001
#define LF_POINTER      0x0002
#define LF_ARRAY        0x0003
#define LF_CLASS        0x0004
#define LF_STRUCTURE    0x0005
#define LF_UNION        0x0006
#define LF_ENUM         0x0007
#define LF_PROCEDURE    0x0008
#define LF_MFUNCTION    0x0009
#define LF_VTSHAPE      0x000a
#define LF_COBOL0       0x000b
#define LF_COBOL1       0x000c
#define LF_BARRAY       0x000d
#define LF_LABEL        0x000e
#define LF_NULL         0x000f
#define LF_NOTTRAN      0x0010
#define LF_DIMARRAY     0x0011
#define LF_VFTPATH      0x0012
#define LF_PRECOMP      0x0013      // not referenced from symbol
#define LF_ENDPRECOMP   0x0014      // not referenced from symbol
#define LF_OEM          0x0015      // oem definable type string
#define LF_TYPESERVER   0x0016      // not referenced from symbol

    // leaf indices starting records but referenced only from type records

#define LF_SKIP         0x0200
#define LF_ARGLIST      0x0201
#define LF_DEFARG       0x0202
#define LF_LIST         0x0203
#define LF_FIELDLIST    0x0204
#define LF_DERIVED      0x0205
#define LF_BITFIELD     0x0206
#define LF_METHODLIST   0x0207
#define LF_DIMCONU      0x0208
#define LF_DIMCONLU     0x0209
#define LF_DIMVARU      0x020a
#define LF_DIMVARLU     0x020b
#define LF_REFSYM       0x020c

#define LF_BCLASS       0x0400
#define LF_VBCLASS      0x0401
#define LF_IVBCLASS     0x0402
#define LF_ENUMERATE    0x0403
#define LF_FRIENDFCN    0x0404
#define LF_INDEX        0x0405
#define LF_MEMBER       0x0406
#define LF_STMEMBER     0x0407
#define LF_METHOD       0x0408
#define LF_NESTTYPE     0x0409
#define LF_VFUNCTAB     0x040a
#define LF_FRIENDCLS    0x040b
#define LF_ONEMETHOD    0x040c
#define LF_VFUNCOFF     0x040d
#define LF_NESTTYPEEX   0x040e
#define LF_MEMBERMODIFY 0x040f

#define LF_NUMERIC      0x8000
#define LF_CHAR         0x8000
#define LF_SHORT        0x8001
#define LF_USHORT       0x8002
#define LF_LONG         0x8003
#define LF_ULONG        0x8004
#define LF_REAL32       0x8005
#define LF_REAL64       0x8006
#define LF_REAL80       0x8007
#define LF_REAL128      0x8008
#define LF_QUADWORD     0x8009
#define LF_UQUADWORD    0x800a
#define LF_REAL48       0x800b
#define LF_COMPLEX32    0x800c
#define LF_COMPLEX64    0x800d
#define LF_COMPLEX80    0x800e
#define LF_COMPLEX128   0x800f
#define LF_VARSTRING    0x8010

#define LF_OCTWORD      0x8017
#define LF_UOCTWORD     0x8018

#define LF_PAD0         0xf0
#define LF_PAD1         0xf1
#define LF_PAD2         0xf2
#define LF_PAD3         0xf3
#define LF_PAD4         0xf4
#define LF_PAD5         0xf5
#define LF_PAD6         0xf6
#define LF_PAD7         0xf7
#define LF_PAD8         0xf8
#define LF_PAD9         0xf9
#define LF_PAD10        0xfa
#define LF_PAD11        0xfb
#define LF_PAD12        0xfc
#define LF_PAD13        0xfd
#define LF_PAD14        0xfe
#define LF_PAD15        0xff

// end of leaf indices




//      Type enum for pointer records
//      Pointers can be one of the following types


typedef enum CV_ptrtype_e {
    CV_PTR_NEAR         = 0x00, // near pointer
    CV_PTR_FAR          = 0x01, // far pointer
    CV_PTR_HUGE         = 0x02, // huge pointer
    CV_PTR_BASE_SEG     = 0x03, // based on segment
    CV_PTR_BASE_VAL     = 0x04, // based on value of base
    CV_PTR_BASE_SEGVAL  = 0x05, // based on segment value of base
    CV_PTR_BASE_ADDR    = 0x06, // based on address of base
    CV_PTR_BASE_SEGADDR = 0x07, // based on segment address of base
    CV_PTR_BASE_TYPE    = 0x08, // based on type
    CV_PTR_BASE_SELF    = 0x09, // based on self
    CV_PTR_NEAR32       = 0x0a, // 16:32 near pointer
    CV_PTR_FAR32        = 0x0b, // 16:32 far pointer
    CV_PTR_UNUSEDPTR    = 0x0c  // first unused pointer type
} CV_ptrtype_e;





//      Mode enum for pointers
//      Pointers can have one of the following modes


typedef enum CV_ptrmode_e {
    CV_PTR_MODE_PTR     = 0x00, // "normal" pointer
    CV_PTR_MODE_REF     = 0x01, // reference
    CV_PTR_MODE_PMEM    = 0x02, // pointer to data member
    CV_PTR_MODE_PMFUNC  = 0x03, // pointer to member function
    CV_PTR_MODE_RESERVED= 0x04  // first unused pointer mode
} CV_ptrmode_e;




//      Enumeration for function call type


typedef enum CV_call_e {
    CV_CALL_NEAR_C      = 0x00, // near right to left push, caller pops stack
    CV_CALL_FAR_C       = 0x01, // far right to left push, caller pops stack
    CV_CALL_NEAR_PASCAL = 0x02, // near left to right push, callee pops stack
    CV_CALL_FAR_PASCAL  = 0x03, // far left to right push, callee pops stack
    CV_CALL_NEAR_FAST   = 0x04, // near left to right push with regs, callee pops stack
    CV_CALL_FAR_FAST    = 0x05, // far left to right push with regs, callee pops stack
    CV_CALL_SKIPPED     = 0x06, // skipped (unused) call index
    CV_CALL_NEAR_STD    = 0x07, // near standard call
    CV_CALL_FAR_STD     = 0x08, // far standard call
    CV_CALL_NEAR_SYS    = 0x09, // near sys call
    CV_CALL_FAR_SYS     = 0x0a, // far sys call
    CV_CALL_THISCALL    = 0x0b, // this call (this passed in register)
    CV_CALL_MIPSCALL    = 0x0c, // Mips call
    CV_CALL_GENERIC     = 0x0d, // Generic call sequence
    CV_CALL_ALPHACALL   = 0x0e, // Alpha call
    CV_CALL_PPCCALL     = 0x0f, // PPC call
    CV_CALL_RESERVED    = 0x10  // first unused call enumeration
} CV_call_e;




//      Values for the access protection of class attributes


typedef enum CV_access_e {
    CV_private   = 1,
    CV_protected = 2,
    CV_public    = 3
} CV_access_e;



//      enumeration for method properties

typedef enum CV_methodprop_e {
    CV_MTvanilla        = 0x00,
    CV_MTvirtual        = 0x01,
    CV_MTstatic         = 0x02,
    CV_MTfriend         = 0x03,
    CV_MTintro          = 0x04,
    CV_MTpurevirt       = 0x05,
    CV_MTpureintro      = 0x06
} CV_methodprop_e;




//      enumeration for virtual shape table entries

typedef enum CV_VTS_desc_e {
    CV_VTS_near         = 0x00,
    CV_VTS_far          = 0x01,
    CV_VTS_thin         = 0x02,
    CV_VTS_outer        = 0x03,
    CV_VTS_meta         = 0x04,
    CV_VTS_near32       = 0x05,
    CV_VTS_far32        = 0x06,
    CV_VTS_unused       = 0x07
} CV_VTS_desc_e;




//      enumeration for LF_LABEL address modes

typedef enum CV_LABEL_TYPE_e {
    CV_LABEL_NEAR = 0,       // near return
    CV_LABEL_FAR  = 4        // far return
} CV_LABEL_TYPE_e;



//      enumeration for LF_MODIFIER values


typedef struct CV_modifier_t {
    unsigned short  MOD_const       :1;
    unsigned short  MOD_volatile    :1;
    unsigned short  MOD_unaligned   :1;
    unsigned short  MOD_unused      :13;
} CV_modifier_t;


//  bit field structure describing class/struct/union/enum properties

typedef struct CV_prop_t {
    unsigned short  packed      :1;     // true if structure is packed
    unsigned short  ctor        :1;     // true if constructors or destructors present
    unsigned short  ovlops      :1;     // true if overloaded operators present
    unsigned short  isnested    :1;     // true if this is a nested class
    unsigned short  cnested     :1;     // true if this class contains nested types
    unsigned short  opassign    :1;     // true if overloaded assignment (=)
    unsigned short  opcast      :1;     // true if casting methods
    unsigned short  fwdref      :1;     // true if forward reference (incomplete defn)
    unsigned short  scoped      :1;     // scoped definition
    unsigned short  reserved    :7;
} CV_prop_t;




//  class field attribute

typedef struct CV_fldattr_t {
    unsigned short  access      :2;     // access protection CV_access_t
    unsigned short  mprop       :3;     // method properties CV_methodprop_t
    unsigned short  pseudo      :1;     // compiler generated fcn and does not exist
    unsigned short  noinherit   :1;     // true if class cannot be inherited
    unsigned short  noconstruct :1;     // true if class cannot be constructed
    unsigned short  compgenx    :1;     // compiler generated fcn and does exist
    unsigned short  unused      :7;     // unused
} CV_fldattr_t;



//  Structures to access to the type records


typedef struct TYPTYPE {
    unsigned short  len;
    unsigned short  leaf;
    unsigned char   data[CV_ZEROLEN];
} TYPTYPE;          // general types record


__INLINE char *NextType (char * pType) {
    return (pType + ((TYPTYPE *)pType)->len + sizeof(unsigned short));
}

typedef enum CV_PMEMBER {
    CV_PDM16_NONVIRT    = 0x00, // 16:16 data no virtual fcn or base
    CV_PDM16_VFCN       = 0x01, // 16:16 data with virtual functions
    CV_PDM16_VBASE      = 0x02, // 16:16 data with virtual bases
    CV_PDM32_NVVFCN     = 0x03, // 16:32 data w/wo virtual functions
    CV_PDM32_VBASE      = 0x04, // 16:32 data with virtual bases

    CV_PMF16_NEARNVSA   = 0x05, // 16:16 near method nonvirtual single address point
    CV_PMF16_NEARNVMA   = 0x06, // 16:16 near method nonvirtual multiple address points
    CV_PMF16_NEARVBASE  = 0x07, // 16:16 near method virtual bases
    CV_PMF16_FARNVSA    = 0x08, // 16:16 far method nonvirtual single address point
    CV_PMF16_FARNVMA    = 0x09, // 16:16 far method nonvirtual multiple address points
    CV_PMF16_FARVBASE   = 0x0a, // 16:16 far method virtual bases

    CV_PMF32_NVSA       = 0x0b, // 16:32 method nonvirtual single address point
    CV_PMF32_NVMA       = 0x0c, // 16:32 method nonvirtual multiple address point
    CV_PMF32_VBASE      = 0x0d  // 16:32 method virtual bases
} CV_PMEMBER;



//  memory representation of pointer to member.  These representations are
//  indexed by the enumeration above in the LF_POINTER record




//  representation of a 16:16 pointer to data for a class with no
//  virtual functions or virtual bases


struct CV_PDMR16_NONVIRT {
    CV_off16_t      mdisp;      // displacement to data (NULL = -1)
};




//  representation of a 16:16 pointer to data for a class with virtual
//  functions


struct CV_PMDR16_VFCN {
    CV_off16_t      mdisp;      // displacement to data ( NULL = 0)
};




//  representation of a 16:16 pointer to data for a class with
//  virtual bases


struct CV_PDMR16_VBASE {
    CV_off16_t      mdisp;      // displacement to data
    CV_off16_t      pdisp;      // this pointer displacement to vbptr
    CV_off16_t      vdisp;      // displacement within vbase table
                                // NULL = (,,0xffff)
};




//  representation of a 16:32 near pointer to data for a class with
//  or without virtual functions and no virtual bases


struct CV_PDMR32_NVVFCN {
    CV_off32_t      mdisp;      // displacement to data (NULL = 0x80000000)
};




//  representation of a 16:32 near pointer to data for a class
//  with virtual bases


struct CV_PDMR32_VBASE {
    CV_off32_t      mdisp;      // displacement to data
    CV_off32_t      pdisp;      // this pointer displacement
    CV_off32_t      vdisp;      // vbase table displacement
                                // NULL = (,,0xffffffff)
};




//  representation of a 16:16 pointer to near member function for a
//  class with no virtual functions or bases and a single address point


struct CV_PMFR16_NEARNVSA {
    CV_uoff16_t     off;        // near address of function (NULL = 0)
};



//  representation of a 16:16 near pointer to member functions of a
//  class with no virtual bases and multiple address points


struct CV_PMFR16_NEARNVMA {
    CV_uoff16_t     off;        // offset of function (NULL = 0,x)
    signed short    disp;
};




//  representation of a 16:16 near pointer to member function of a
//  class with virtual bases


struct CV_PMFR16_NEARVBASE {
    CV_uoff16_t     off;        // offset of function (NULL = 0,x,x,x)
    CV_off16_t      mdisp;      // displacement to data
    CV_off16_t      pdisp;      // this pointer displacement
    CV_off16_t      vdisp;      // vbase table displacement
};




//  representation of a 16:16 pointer to far member function for a
//  class with no virtual bases and a single address point


struct CV_PMFR16_FARNVSA {
    CV_uoff16_t     off;        // offset of function (NULL = 0:0)
    unsigned short  seg;        // segment of function
};




//  representation of a 16:16 far pointer to member functions of a
//  class with no virtual bases and multiple address points


struct CV_PMFR16_FARNVMA {
    CV_uoff16_t     off;        // offset of function (NULL = 0:0,x)
    unsigned short  seg;
    signed short    disp;
};




//  representation of a 16:16 far pointer to member function of a
//  class with virtual bases


struct CV_PMFR16_FARVBASE {
    CV_uoff16_t     off;        // offset of function (NULL = 0:0,x,x,x)
    unsigned short  seg;
    CV_off16_t      mdisp;      // displacement to data
    CV_off16_t      pdisp;      // this pointer displacement
    CV_off16_t      vdisp;      // vbase table displacement

};




//  representation of a 16:32 near pointer to member function for a
//  class with no virtual bases and a single address point


struct CV_PMFR32_NVSA {
    CV_uoff32_t      off;        // near address of function (NULL = 0L)
};




//  representation of a 16:32 near pointer to member function for a
//  class with no virtual bases and multiple address points


struct CV_PMFR32_NVMA {
    CV_uoff32_t     off;        // near address of function (NULL = 0L,x)
    CV_off32_t      disp;
};




//  representation of a 16:32 near pointer to member function for a
//  class with virtual bases


struct CV_PMFR32_VBASE {
    CV_uoff32_t     off;        // near address of function (NULL = 0L,x,x,x)
    CV_off32_t      mdisp;      // displacement to data
    CV_off32_t      pdisp;      // this pointer displacement
    CV_off32_t      vdisp;      // vbase table displacement
};





//  Easy leaf - used for generic casting to reference leaf field
//  of a subfield of a complex list

typedef struct lfEasy {
    unsigned short  leaf;           // LF_...
} lfEasy;


/**     The following type records are basically variant records of the
 *      above structure.  The "unsigned short leaf" of the above structure and
 *      the "unsigned short leaf" of the following type definitions are the same
 *      symbol.  When the OMF record is locked via the MHOMFLock API
 *      call, the address of the "unsigned short leaf" is returned
 */


//      Type record for LF_MODIFIER


typedef struct lfModifier {
    unsigned short  leaf;           // LF_MODIFIER
    CV_modifier_t   attr;           // modifier attribute modifier_t
    CV_typ_t        type;           // modified type
} lfModifier;




//      type record for LF_POINTER

#ifndef __cplusplus
typedef struct lfPointer {
#endif
    struct lfPointerBody {
        unsigned short      leaf;           // LF_POINTER
        struct lfPointerAttr {
            unsigned char   ptrtype     :5; // ordinal specifying pointer type (ptrtype-t)
            unsigned char   ptrmode     :3; // ordinal specifying pointer mode (ptrmode_t)
            unsigned char   isflat32    :1; // true if 0:32 pointer
            unsigned char   isvolatile  :1; // TRUE if volatile pointer
            unsigned char   isconst     :1; // TRUE if const pointer
            unsigned char   isunaligned :1; // TRUE if unaligned pointer
            unsigned char   unused      :4;
        } attr;
        CV_typ_t    utype;          // type index of the underlying type
#if (defined(__cplusplus) || defined(_MSC_VER)) // for C++ and MS compilers that support unnamed unions
    };
#else
    } u;
#endif
#ifdef  __cplusplus
typedef struct lfPointer : public lfPointerBody {
#endif
    union  {
        struct {
            CV_typ_t        pmclass;    // index of containing class for pointer to member
            unsigned short  pmenum;     // enumeration specifying pm format
        } pm;
        unsigned short      bseg;       // base segment if PTR_BASE_SEG
        unsigned char       Sym[1];     // copy of base symbol record (including length)
        struct  {
            CV_typ_t        index;      // type index if CV_PTR_BASE_TYPE
            unsigned char   name[1];    // name of base type
        } btype;
    } pbase;
} lfPointer;




//      type record for LF_ARRAY


typedef struct lfArray {
    unsigned short  leaf;           // LF_ARRAY
    CV_typ_t        elemtype;       // type index of element type
    CV_typ_t        idxtype;        // type index of indexing type
    unsigned char   data[CV_ZEROLEN];         // variable length data specifying
                                    // size in bytes and name
} lfArray;




//      type record for LF_CLASS, LF_STRUCTURE


typedef struct lfClass {
    unsigned short  leaf;           // LF_CLASS, LF_STRUCT
    unsigned short  count;          // count of number of elements in class
    CV_typ_t        field;          // type index of LF_FIELD descriptor list
    CV_prop_t       property;       // property attribute field (prop_t)
    CV_typ_t        derived;        // type index of derived from list if not zero
    CV_typ_t        vshape;         // type index of vshape table for this class
    unsigned char   data[CV_ZEROLEN];         // data describing length of structure in
                                    // bytes and name
} lfClass;
typedef lfClass lfStructure;




//      type record for LF_UNION


typedef struct lfUnion {
    unsigned short  leaf;           // LF_UNION
    unsigned short  count;          // count of number of elements in class
    CV_typ_t        field;          // type index of LF_FIELD descriptor list
    CV_prop_t       property;       // property attribute field
    unsigned char   data[CV_ZEROLEN];         // variable length data describing length of
                                    // structure and name
} lfUnion;




//      type record for LF_ENUM


typedef struct lfEnum {
    unsigned short  leaf;           // LF_ENUM
    unsigned short  count;          // count of number of elements in class
    CV_typ_t        utype;          // underlying type of the enum
    CV_typ_t        field;          // type index of LF_FIELD descriptor list
    CV_prop_t       property;       // property attribute field
    unsigned char   Name[1];        // length prefixed name of enum
} lfEnum;




//      Type record for LF_PROCEDURE


typedef struct lfProc {
    unsigned short  leaf;           // LF_PROCEDURE
    CV_typ_t        rvtype;         // type index of return value
    unsigned char   calltype;       // calling convention (CV_call_t)
    unsigned char   reserved;       // reserved for future use
    unsigned short  parmcount;      // number of parameters
    CV_typ_t        arglist;        // type index of argument list
} lfProc;



//      Type record for member function


typedef struct lfMFunc {
    unsigned short  leaf;           // LF_MFUNCTION
    CV_typ_t        rvtype;         // type index of return value
    CV_typ_t        classtype;      // type index of containing class
    CV_typ_t        thistype;       // type index of this pointer (model specific)
    unsigned char   calltype;       // calling convention (call_t)
    unsigned char   reserved;       // reserved for future use
    unsigned short  parmcount;      // number of parameters
    CV_typ_t        arglist;        // type index of argument list
    long            thisadjust;     // this adjuster (long because pad required anyway)
} lfMFunc;




//     type record for virtual function table shape


typedef struct lfVTShape {
    unsigned short  leaf;       // LF_VTSHAPE
    unsigned short  count;      // number of entries in vfunctable
    unsigned char   desc[CV_ZEROLEN];     // 4 bit (CV_VTS_desc) descriptors
} lfVTShape;




//      type record for cobol0


typedef struct lfCobol0 {
    unsigned short  leaf;       // LF_COBOL0
    CV_typ_t        type;       // parent type record index
    unsigned char   data[CV_ZEROLEN];
} lfCobol0;




//      type record for cobol1


typedef struct lfCobol1 {
    unsigned short  leaf;       // LF_COBOL1
    unsigned char   data[CV_ZEROLEN];
} lfCobol1;




//      type record for basic array


typedef struct lfBArray {
    unsigned short  leaf;       // LF_BARRAY
    CV_typ_t        utype;      // type index of underlying type
} lfBArray;

//      type record for assembler labels


typedef struct lfLabel {
    unsigned short  leaf;       // LF_LABEL
    unsigned short  mode;       // addressing mode of label
} lfLabel;



//      type record for dimensioned arrays


typedef struct lfDimArray {
    unsigned short  leaf;       // LF_DIMARRAY
    CV_typ_t        utype;      // underlying type of the array
    CV_typ_t        diminfo;    // dimension information
    unsigned char   name[1];    // length prefixed name
} lfDimArray;



//      type record describing path to virtual function table


typedef struct lfVFTPath {
    unsigned short  leaf;       // LF_VFTPATH
    unsigned short  count;      // count of number of bases in path
    CV_typ_t        base[1];    // bases from root to leaf
} lfVFTPath;


//      type record describing inclusion of precompiled types


typedef struct lfPreComp {
    unsigned short  leaf;       // LF_PRECOMP
    unsigned short  start;      // starting type index included
    unsigned short  count;      // number of types in inclusion
    unsigned long   signature;  // signature
    unsigned char   name[CV_ZEROLEN];     // length prefixed name of included type file
} lfPreComp;


//      type record describing end of precompiled types that can be
//      included by another file


typedef struct lfEndPreComp {
    unsigned short  leaf;       // LF_ENDPRECOMP
    unsigned long   signature;  // signature
} lfEndPreComp;





//      type record for OEM definable type strings


typedef struct lfOEM {
    unsigned short  leaf;       // LF_OEM
    unsigned short  cvOEM;      // MS assigned OEM identified
    unsigned short  recOEM;     // OEM assigned type identifier
    unsigned short  count;      // count of type indices to follow
    CV_typ_t        index[CV_ZEROLEN];  // array of type indices followed
                                // by OEM defined data
} lfOEM;

#define OEM_MS_FORTRAN90        0xF090
#define OEM_ODI                 0x0010
#define OEM_THOMSON_SOFTWARE    0x5453
#define OEM_ODI_REC_BASELIST    0x0000


//      type record describing using of a type server

typedef struct lfTypeServer {
    unsigned short  leaf;       // LF_TYPESERVER
    unsigned long   signature;  // signature
    unsigned long   age;        // age of database used by this module
    unsigned char   name[CV_ZEROLEN];     // length prefixed name of PDB
} lfTypeServer;

//      description of type records that can be referenced from
//      type records referenced by symbols



//      type record for skip record


typedef struct lfSkip {
    unsigned short  leaf;       // LF_SKIP
    CV_typ_t        type;       // next valid index
    unsigned char   data[CV_ZEROLEN];     // pad data
} lfSkip;



//      argument list leaf


typedef struct lfArgList {
    unsigned short  leaf;           // LF_ARGLIST
    unsigned short  count;          // number of arguments
    CV_typ_t        arg[CV_ZEROLEN];      // number of arguments
} lfArgList;




//      derived class list leaf


typedef struct lfDerived {
    unsigned short  leaf;           // LF_DERIVED
    unsigned short  count;          // number of arguments
    CV_typ_t        drvdcls[CV_ZEROLEN];      // type indices of derived classes
} lfDerived;




//      leaf for default arguments


typedef struct lfDefArg {
    unsigned short  leaf;               // LF_DEFARG
    CV_typ_t        type;               // type of resulting expression
    unsigned char   expr[CV_ZEROLEN];             // length prefixed expression string
} lfDefArg;



//      list leaf
//          This list should no longer be used because the utilities cannot
//          verify the contents of the list without knowing what type of list
//          it is.  New specific leaf indices should be used instead.


typedef struct lfList {
    unsigned short  leaf;           // LF_LIST
    char            data[CV_ZEROLEN];         // data format specified by indexing type
} lfList;




//      field list leaf
//      This is the header leaf for a complex list of class and structure
//      subfields.


typedef struct lfFieldList {
    unsigned short  leaf;           // LF_FIELDLIST
    char            data[CV_ZEROLEN];         // field list sub lists
} lfFieldList;







//  type record for non-static methods and friends in overloaded method list

typedef struct mlMethod {
    CV_fldattr_t   attr;           // method attribute
    CV_typ_t       index;          // index to type record for procedure
    unsigned long  vbaseoff[CV_ZEROLEN];    // offset in vfunctable if intro virtual
} mlMethod;


typedef struct lfMethodList {
    unsigned short leaf;
    unsigned char  mList[CV_ZEROLEN];         // really a mlMethod type
} lfMethodList;





//      type record for LF_BITFIELD


typedef struct lfBitfield {
    unsigned short  leaf;           // LF_BITFIELD
    unsigned char   length;
    unsigned char   position;
    CV_typ_t        type;           // type of bitfield

} lfBitfield;




//      type record for dimensioned array with constant bounds


typedef struct lfDimCon {
    unsigned short  leaf;           // LF_DIMCONU or LF_DIMCONLU
    unsigned short  rank;           // number of dimensions
    CV_typ_t        typ;            // type of index
    unsigned char   dim[CV_ZEROLEN];          // array of dimension information with
                                    // either upper bounds or lower/upper bound
} lfDimCon;




//      type record for dimensioned array with variable bounds


typedef struct lfDimVar {
    unsigned short  leaf;           // LF_DIMVARU or LF_DIMVARLU
    unsigned short  rank;           // number of dimensions
    CV_typ_t        typ;            // type of index
    unsigned char   dim[CV_ZEROLEN];          // array of type indices for either
                                    // variable upper bound or variable
                                    // lower/upper bound.  The referenced
                                    // types must be LF_REFSYM or T_VOID
} lfDimVar;




//      type record for referenced symbol


typedef struct lfRefSym {
    unsigned short  leaf;           // LF_REFSYM
    unsigned char   Sym[1];         // copy of referenced symbol record
                                    // (including length)
} lfRefSym;





/**     the following are numeric leaves.  They are used to indicate the
 *      size of the following variable length data.  When the numeric
 *      data is a single byte less than 0x8000, then the data is output
 *      directly.  If the data is more the 0x8000 or is a negative value,
 *      then the data is preceeded by the proper index.
 */



//      signed character leaf

typedef struct lfChar {
    unsigned short  leaf;           // LF_CHAR
    signed char     val;            // signed 8-bit value
} lfChar;




//      signed short leaf

typedef struct lfShort {
    unsigned short  leaf;           // LF_SHORT
    short           val;            // signed 16-bit value
} lfShort;




//      unsigned short leaf

typedef struct lfUShort {
    unsigned short  leaf;           // LF_unsigned short
    unsigned short  val;            // unsigned 16-bit value
} lfUShort;




//      signed long leaf

typedef struct lfLong {
    unsigned short  leaf;           // LF_LONG
    long            val;            // signed 32-bit value
} lfLong;




//      unsigned long leaf

typedef struct lfULong {
    unsigned short  leaf;           // LF_ULONG
    unsigned long   val;            // unsigned 32-bit value
} lfULong;




//      signed quad leaf

typedef struct lfQuad {
    unsigned short  leaf;           // LF_QUAD
    unsigned char   val[8];         // signed 64-bit value
} lfQuad;




//      unsigned quad leaf

typedef struct lfUQuad {
    unsigned short  leaf;           // LF_UQUAD
    unsigned char   val[8];         // unsigned 64-bit value
} lfUQuad;


//      signed int128 leaf

typedef struct lfOct {
    unsigned short  leaf;           // LF_OCT
    unsigned char   val[16];        // signed 128-bit value
} lfOct;

//      unsigned int128 leaf

typedef struct lfUOct {
    unsigned short  leaf;           // LF_UOCT
    unsigned char   val[16];        // unsigned 128-bit value
} lfUOct;




//      real 32-bit leaf

typedef struct lfReal32 {
    unsigned short  leaf;           // LF_REAL32
    float           val;            // 32-bit real value
} lfReal32;




//      real 48-bit leaf

typedef struct lfReal48 {
    unsigned short  leaf;           // LF_REAL48
    unsigned char   val[6];         // 48-bit real value
} lfReal48;




//      real 64-bit leaf

typedef struct lfReal64 {
    unsigned short  leaf;           // LF_REAL64
    double          val;            // 64-bit real value
} lfReal64;




//      real 80-bit leaf

typedef struct lfReal80 {
    unsigned short  leaf;           // LF_REAL80
    FLOAT10         val;            // real 80-bit value
} lfReal80;




//      real 128-bit leaf

typedef struct lfReal128 {
    unsigned short  leaf;           // LF_REAL128
    char            val[16];        // real 128-bit value
} lfReal128;




//      complex 32-bit leaf

typedef struct lfCmplx32 {
    unsigned short  leaf;           // LF_COMPLEX32
    float           val_real;       // real component
    float           val_imag;       // imaginary component
} lfCmplx32;




//      complex 64-bit leaf

typedef struct lfCmplx64 {
    unsigned short  leaf;           // LF_COMPLEX64
    double          val_real;       // real component
    double          val_imag;       // imaginary component
} flCmplx64;




//      complex 80-bit leaf

typedef struct lfCmplx80 {
    unsigned short  leaf;           // LF_COMPLEX80
    FLOAT10         val_real;       // real component
    FLOAT10         val_imag;       // imaginary component
} lfCmplx80;




//      complex 128-bit leaf

typedef struct lfCmplx128 {
    unsigned short  leaf;           // LF_COMPLEX128
    char            val_real[16];   // real component
    char            val_imag[16];   // imaginary component
} lfCmplx128;



//  variable length numeric field

typedef struct lfVarString {
    unsigned short  leaf;       // LF_VARSTRING
    unsigned short  len;        // length of value in bytes
    unsigned char   value[CV_ZEROLEN];  // value
} lfVarString;

//***********************************************************************


//      index leaf - contains type index of another leaf
//      a major use of this leaf is to allow the compilers to emit a
//      long complex list (LF_FIELD) in smaller pieces.

typedef struct lfIndex {
    unsigned short  leaf;           // LF_INDEX
    CV_typ_t        index;          // type index of referenced leaf
} lfIndex;


//      subfield record for base class field

typedef struct lfBClass {
    unsigned short  leaf;           // LF_BCLASS
    CV_typ_t        index;          // type index of base class
    CV_fldattr_t    attr;           // attribute
    unsigned char   offset[CV_ZEROLEN];       // variable length offset of base within class
} lfBClass;





//      subfield record for direct and indirect virtual base class field

typedef struct lfVBClass {
    unsigned short  leaf;           // LF_VBCLASS | LV_IVBCLASS
    CV_typ_t        index;          // type index of direct virtual base class
    CV_typ_t        vbptr;          // type index of virtual base pointer
    CV_fldattr_t    attr;           // attribute
    unsigned char   vbpoff[CV_ZEROLEN];       // virtual base pointer offset from address point
                                    // followed by virtual base offset from vbtable
} lfVBClass;





//      subfield record for friend class


typedef struct lfFriendCls {
    unsigned short  leaf;           // LF_FRIENDCLS
    CV_typ_t        index;          // index to type record of friend class
} lfFriendCls;





//      subfield record for friend function


typedef struct lfFriendFcn {
    unsigned short  leaf;           // LF_FRIENDFCN
    CV_typ_t        index;          // index to type record of friend function
    unsigned char   Name[1];        // name of friend function
} lfFriendFcn;



//      subfield record for non-static data members

typedef struct lfMember {
    unsigned short  leaf;           // LF_MEMBER
    CV_typ_t        index;          // index of type record for field
    CV_fldattr_t    attr;           // attribute mask
    unsigned char   offset[CV_ZEROLEN];       // variable length offset of field followed
                                    // by length prefixed name of field
} lfMember;



//  type record for static data members

typedef struct lfSTMember {
    unsigned short  leaf;           // LF_STMEMBER
    CV_typ_t        index;          // index of type record for field
    CV_fldattr_t    attr;           // attribute mask
    unsigned char   Name[1];        // length prefixed name of field
} lfSTMember;



//      subfield record for virtual function table pointer

typedef struct lfVFuncTab {
    unsigned short  leaf;           // LF_VFUNCTAB
    CV_typ_t        type;           // type index of pointer
} lfVFuncTab;



//      subfield record for virtual function table pointer with offset

typedef struct lfVFuncOff {
    unsigned short  leaf;           // LF_VFUNCTAB
    CV_typ_t        type;           // type index of pointer
    CV_off32_t      offset;         // offset of virtual function table pointer
} lfVFuncOff;



//      subfield record for overloaded method list


typedef struct lfMethod {
    unsigned short  leaf;           // LF_METHOD
    unsigned short  count;          // number of occurances of function
    CV_typ_t        mList;          // index to LF_METHODLIST record
    unsigned char   Name[1];        // length prefixed name of method
} lfMethod;



//      subfield record for nonoverloaded method


typedef struct lfOneMethod {
    unsigned short  leaf;           // LF_ONEMETHOD
    CV_fldattr_t   attr;            // method attribute
    CV_typ_t       index;           // index to type record for procedure
    unsigned long  vbaseoff[CV_ZEROLEN];    // offset in vfunctable if
                                    // intro virtual followed by
                                    // length prefixed name of method
} lfOneMethod;


//      subfield record for enumerate

typedef struct lfEnumerate {
    unsigned short  leaf;       // LF_ENUMERATE
    CV_fldattr_t    attr;       // access
    unsigned char   value[CV_ZEROLEN];    // variable length value field followed
                                // by length prefixed name
} lfEnumerate;


//  type record for nested (scoped) type definition

typedef struct lfNestType {
    unsigned short  leaf;       // LF_NESTTYPE
    CV_typ_t        index;      // index of nested type definition
    unsigned char   Name[1];    // length prefixed type name
} lfNestType;

//  type record for nested (scoped) type definition, with attributes

typedef struct lfNestTypeEx {
    unsigned short  leaf;       // LF_NESTTYPEEX
    CV_typ_t        index;      // index of nested type definition
    CV_fldattr_t    attr;       // member access
    unsigned char   Name[1];    // length prefixed type name
} lfNestTypeEx;

//  type record for modifications to members

typedef struct lfMemberModify {
    unsigned short  leaf;       // LF_MEMBERMODIFY
    CV_typ_t        index;      // index of base class type definition
    CV_fldattr_t    attr;       // the new attributes
    unsigned char   Name[1];    // length prefixed member name
} lfMemberModify;

//  type record for pad leaf

typedef struct lfPad {
    unsigned char   leaf;
} SYM_PAD;



//  Symbol definitions

typedef enum SYM_ENUM_e {
    S_COMPILE    =  0x0001, // Compile flags symbol
    S_REGISTER   =  0x0002, // Register variable
    S_CONSTANT   =  0x0003, // constant symbol
    S_UDT        =  0x0004, // User defined type
    S_SSEARCH    =  0x0005, // Start Search
    S_END        =  0x0006, // Block, procedure, "with" or thunk end
    S_SKIP       =  0x0007, // Reserve symbol space in $$Symbols table
    S_CVRESERVE  =  0x0008, // Reserved symbol for CV internal use
    S_OBJNAME    =  0x0009, // path to object file name
    S_ENDARG     =  0x000a, // end of argument/return list
    S_COBOLUDT   =  0x000b, // special UDT for cobol that does not symbol pack
    S_MANYREG    =  0x000c, // multiple register variable
    S_RETURN     =  0x000d, // return description symbol
    S_ENTRYTHIS  =  0x000e, // description of this pointer on entry

    S_BPREL16    =  0x0100, // BP-relative
    S_LDATA16    =  0x0101, // Module-local symbol
    S_GDATA16    =  0x0102, // Global data symbol
    S_PUB16      =  0x0103, // a public symbol
    S_LPROC16    =  0x0104, // Local procedure start
    S_GPROC16    =  0x0105, // Global procedure start
    S_THUNK16    =  0x0106, // Thunk Start
    S_BLOCK16    =  0x0107, // block start
    S_WITH16     =  0x0108, // with start
    S_LABEL16    =  0x0109, // code label
    S_CEXMODEL16 =  0x010a, // change execution model
    S_VFTABLE16  =  0x010b, // address of virtual function table
    S_REGREL16   =  0x010c, // register relative address

    S_BPREL32    =  0x0200, // BP-relative
    S_LDATA32    =  0x0201, // Module-local symbol
    S_GDATA32    =  0x0202, // Global data symbol
    S_PUB32      =  0x0203, // a public symbol (CV internal reserved)
    S_LPROC32    =  0x0204, // Local procedure start
    S_GPROC32    =  0x0205, // Global procedure start
    S_THUNK32    =  0x0206, // Thunk Start
    S_BLOCK32    =  0x0207, // block start
    S_WITH32     =  0x0208, // with start
    S_LABEL32    =  0x0209, // code label
    S_CEXMODEL32 =  0x020a, // change execution model
    S_VFTABLE32  =  0x020b, // address of virtual function table
    S_REGREL32   =  0x020c, // register relative address
    S_LTHREAD32  =  0x020d, // local thread storage
    S_GTHREAD32  =  0x020e, // global thread storage
    S_SLINK32    =  0x020f, // static link for MIPS EH implementation

    S_LPROCMIPS  =  0x0300, // Local procedure start
    S_GPROCMIPS  =  0x0301, // Global procedure start

    S_PROCREF    =  0x0400, // Reference to a procedure
    S_DATAREF    =  0x0401, // Reference to data
    S_ALIGN      =  0x0402, // Used for page alignment of symbols
    S_LPROCREF    =  0x0403 // Local Reference to a procedure
} SYM_ENUM_e;




//  enum describing the compile flag source language


typedef enum CV_CFL_LANG {
    CV_CFL_C        = 0x00,
    CV_CFL_CXX      = 0x01,
    CV_CFL_FORTRAN  = 0x02,
    CV_CFL_MASM     = 0x03,
    CV_CFL_PASCAL   = 0x04,
    CV_CFL_BASIC    = 0x05,
    CV_CFL_COBOL    = 0x06,
    CV_CFL_LINK     = 0x07,
    CV_CFL_CVTRES   = 0x08,
} CV_CFL_LANG;



//  enum describing target processor


typedef enum CV_CPU_TYPE_e {
    CV_CFL_8080         = 0x00,
    CV_CFL_8086         = 0x01,
    CV_CFL_80286        = 0x02,
    CV_CFL_80386        = 0x03,
    CV_CFL_80486        = 0x04,
    CV_CFL_PENTIUM      = 0x05,
    CV_CFL_MIPSR4000    = 0x10,
    CV_CFL_M68000       = 0x20,
    CV_CFL_M68010       = 0x21,
    CV_CFL_M68020       = 0x22,
    CV_CFL_M68030       = 0x23,
    CV_CFL_M68040       = 0x24,
    CV_CFL_ALPHA        = 0x30,
    CV_CFL_PPC601       = 0x40,
    CV_CFL_PPC603       = 0x41,
    CV_CFL_PPC604       = 0x42,
    CV_CFL_PPC620       = 0x43

} CV_CPU_TYPE_e;




//  enum describing compile flag ambiant data model


typedef enum CV_CFL_DATA {
    CV_CFL_DNEAR    = 0x00,
    CV_CFL_DFAR     = 0x01,
    CV_CFL_DHUGE    = 0x02
} CV_CFL_DATA;




//  enum describing compile flag ambiant code model


typedef enum CV_CFL_CODE_e {
    CV_CFL_CNEAR    = 0x00,
    CV_CFL_CFAR     = 0x01,
    CV_CFL_CHUGE    = 0x02
} CV_CFL_CODE_e;




//  enum describing compile flag target floating point package

typedef enum CV_CFL_FPKG_e {
    CV_CFL_NDP      = 0x00,
    CV_CFL_EMU      = 0x01,
    CV_CFL_ALT      = 0x02
} CV_CFL_FPKG_e;


// enum describing function return method


typedef struct CV_PROCFLAGS {
    union {
        unsigned char   bAll;
        struct {
            unsigned char CV_PFLAG_NOFPO:1; // frame pointer present
            unsigned char CV_PFLAG_INT  :1; // interrupt return
            unsigned char CV_PFLAG_FAR  :1; // far return
            unsigned char CV_PFLAG_NEVER:1; // function does not return
            unsigned char unused        :4; //
        };
    };
} CV_PROCFLAGS;


// enum describing function data return method

typedef enum CV_GENERIC_STYLE_e {
    CV_GENERIC_VOID   = 0x00,       // void return type
    CV_GENERIC_REG    = 0x01,       // return data is in registers
    CV_GENERIC_ICAN   = 0x02,       // indirect caller allocated near
    CV_GENERIC_ICAF   = 0x03,       // indirect caller allocated far
    CV_GENERIC_IRAN   = 0x04,       // indirect returnee allocated near
    CV_GENERIC_IRAF   = 0x05,       // indirect returnee allocated far
    CV_GENERIC_UNUSED = 0x06        // first unused
} CV_GENERIC_STYLE_e;


typedef struct CV_GENERIC_FLAG {
    unsigned short  cstyle  :1;     // true push varargs right to left
    unsigned short  rsclean :1;     // true if returnee stack cleanup
    unsigned short  unused  :14;    // unused
} CV_GENERIC_FLAG;





typedef struct SYMTYPE {
    unsigned short      reclen;     // Record length
    unsigned short      rectyp;     // Record type
    char                data[CV_ZEROLEN];
} SYMTYPE;

__INLINE SYMTYPE *NextSym (SYMTYPE * pSym) {
    return (SYMTYPE *) ((char *)pSym + pSym->reclen + sizeof(unsigned short));
}

//      non-model specific symbol types



typedef struct REGSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_REGISTER
    CV_typ_t        typind;     // Type index
    unsigned short  reg;        // register enumerate
    unsigned char   name[1];    // Length-prefixed name
} REGSYM;



typedef struct MANYREGSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_MANYREG
    CV_typ_t        typind;     // Type index
    unsigned char   count;      // count of number of registers
    unsigned char   reg[1];     // count register enumerates followed by
                                // length-prefixed name.  Registers are
                                // most significant first.
} MANYREGSYM;



typedef struct CONSTSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_CONSTANT
    CV_typ_t        typind;     // Type index (containing enum if enumerate)
    unsigned short  value;      // numeric leaf containing value
    unsigned char   name[CV_ZEROLEN];     // Length-prefixed name
} CONSTSYM;

typedef struct UDTSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_UDT | S_COBOLUDT
    CV_typ_t        typind;     // Type index
    unsigned char   name[1];    // Length-prefixed name
} UDTSYM;

typedef struct SEARCHSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_SSEARCH
    unsigned long   startsym;   // offset of the procedure
    unsigned short  seg;        // segment of symbol
} SEARCHSYM;

typedef struct CFLAGSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_COMPILE
    unsigned char   machine;    // target processor
    struct  {
        unsigned char   language    :8; // language index
        unsigned char   pcode       :1; // true if pcode present
        unsigned char   floatprec   :2; // floating precision
        unsigned char   floatpkg    :2; // float package
        unsigned char   ambdata     :3; // ambiant data model
        unsigned char   ambcode     :3; // ambiant code model
        unsigned char   mode32      :1; // true if compiled 32 bit mode
        unsigned char   pad         :4; // reserved
    } flags;
    unsigned char       ver[1];     // Length-prefixed compiler version string
} CFLAGSYM;





typedef struct OBJNAMESYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_OBJNAME
    unsigned long   signature;  // signature
    unsigned char   name[1];    // Length-prefixed name
} OBJNAMESYM;




typedef struct ENDARGSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_ENDARG
} ENDARGSYM;


typedef struct RETURNSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_RETURN
    CV_GENERIC_FLAG flags;      // flags
    CV_GENERIC_STYLE_e style;   // return style
                                // followed by return method data
} RETURNSYM;


typedef struct ENTRYTHISSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_ENTRYTHIS
    unsigned char   thissym;    // symbol describing this pointer on entry
} ENTRYTHISSYM;


//      symbol types for 16:16 memory model


typedef struct BPRELSYM16 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_BPREL16
    CV_off16_t      off;        // BP-relative offset
    CV_typ_t        typind;     // Type index
    unsigned char   name[1];    // Length-prefixed name
} BPRELSYM16;



typedef struct DATASYM16 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_LDATA or S_GDATA
    CV_uoff16_t     off;        // offset of symbol
    unsigned short  seg;        // segment of symbol
    CV_typ_t        typind;     // Type index
    unsigned char   name[1];    // Length-prefixed name
} DATASYM16;
typedef DATASYM16 PUBSYM16;


typedef struct PROCSYM16 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_GPROC16 or S_LPROC16
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned long   pNext;      // pointer to next symbol
    unsigned short  len;        // Proc length
    unsigned short  DbgStart;   // Debug start offset
    unsigned short  DbgEnd;     // Debug end offset
    CV_uoff16_t     off;        // offset of symbol
    unsigned short  seg;        // segment of symbol
    CV_typ_t        typind;     // Type index
    CV_PROCFLAGS    flags;      // Proc flags
    unsigned char   name[1];    // Length-prefixed name
} PROCSYM16;




typedef struct THUNKSYM16 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_THUNK
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned long   pNext;      // pointer to next symbol
    CV_uoff16_t     off;        // offset of symbol
    unsigned short  seg;        // segment of symbol
    unsigned short  len;        // length of thunk
    unsigned char   ord;        // ordinal specifying type of thunk
    unsigned char   name[1];    // name of thunk
    unsigned char   variant[CV_ZEROLEN]; // variant portion of thunk
} THUNKSYM16;

typedef enum {
    THUNK_ORDINAL_NOTYPE,
    THUNK_ORDINAL_ADJUSTOR,
    THUNK_ORDINAL_VCALL,
    THUNK_ORDINAL_PCODE
} THUNK_ORDINAL;

typedef struct LABELSYM16 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_LABEL16
    CV_uoff16_t     off;        // offset of symbol
    unsigned short  seg;        // segment of symbol
    CV_PROCFLAGS    flags;      // flags
    unsigned char   name[1];    // Length-prefixed name
} LABELSYM16;

typedef struct BLOCKSYM16 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_BLOCK16
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned short  len;        // Block length
    CV_uoff16_t     off;        // offset of symbol
    unsigned short  seg;        // segment of symbol
    unsigned char   name[1];    // Length-prefixed name
} BLOCKSYM16;

typedef struct WITHSYM16 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_WITH16
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned short  len;        // Block length
    CV_uoff16_t     off;        // offset of symbol
    unsigned short  seg;        // segment of symbol
    unsigned char   expr[1];    // Length-prefixed expression
} WITHSYM16;




typedef enum CEXM_MODEL_e {
    CEXM_MDL_table      = 0x00,     // not executable
    CEXM_MDL_jumptable  = 0x01,     // Compiler generated jump table
    CEXM_MDL_datapad    = 0x02,     // Data padding for alignment
    CEXM_MDL_native     = 0x20,     // native (actually not-pcode)
    CEXM_MDL_cobol      = 0x21,     // cobol
    CEXM_MDL_codepad    = 0x22,     // Code padding for alignment
    CEXM_MDL_code       = 0x23,     // code
	CEXM_MDL_SQL		= 0x30,		// SQL
    CEXM_MDL_pcode      = 0x40,     // pcode
    CEXM_MDL_pcode32Mac = 0x41, // macintosh 32 bit pcode
    CEXM_MDL_pcode32MacNep  = 0x42  // macintosh 32 bit pcode native entry point
} CEXM_MODEL_e;

typedef enum CV_COBOL_e {
    CV_COBOL_dontstop,
    CV_COBOL_pfm,
    CV_COBOL_false,
    CV_COBOL_extcall
} CV_COBOL_e;

typedef struct CEXMSYM16 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_CEXMODEL16
    CV_uoff16_t     off;        // offset of symbol
    unsigned short  seg;        // segment of symbol
    unsigned short  model;      // execution model
    union var16 {
        struct  {
            CV_uoff16_t pcdtable;   // offset to pcode function table
            CV_uoff16_t pcdspi;     // offset to segment pcode information
        } pcode;
        struct {
            unsigned short  subtype;   // see CV_COBOL_e above
            unsigned short  flag;
        } cobol;
    };
} CEXMSYM16;




typedef struct VPATHSYM16 {
    unsigned short  reclen;     // record length
    unsigned short  rectyp;     // S_VFTPATH16
    CV_uoff16_t     off;        // offset of virtual function table
    unsigned short  seg;        // segment of virtual function table
    CV_typ_t        root;       // type index of the root of path
    CV_typ_t        path;       // type index of the path record
} VPATHSYM16;




typedef struct REGREL16 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_REGREL16
    CV_uoff16_t     off;        // offset of symbol
    unsigned short  reg;        // register index
    CV_typ_t        typind;     // Type index
    unsigned char   name[1];    // Length-prefixed name
} REGREL16;





typedef struct BPRELSYM32 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_BPREL32
    CV_off32_t      off;        // BP-relative offset
    CV_typ_t        typind;     // Type index
    unsigned char   name[1];    // Length-prefixed name
} BPRELSYM32;

typedef struct DATASYM32 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_LDATA32, S_GDATA32 or S_PUB32
    CV_uoff32_t     off;
    unsigned short  seg;
    CV_typ_t        typind;     // Type index
    unsigned char   name[1];    // Length-prefixed name
} DATASYM32;
typedef DATASYM32 PUBSYM32;



typedef struct PROCSYM32 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_GPROC32 or S_LPROC32
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned long   pNext;      // pointer to next symbol
    unsigned long   len;        // Proc length
    unsigned long   DbgStart;   // Debug start offset
    unsigned long   DbgEnd;     // Debug end offset
    CV_uoff32_t     off;
    unsigned short  seg;
    CV_typ_t        typind;     // Type index
    CV_PROCFLAGS    flags;      // Proc flags
    unsigned char   name[1];    // Length-prefixed name
} PROCSYM32;




typedef struct THUNKSYM32 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_THUNK32
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned long   pNext;      // pointer to next symbol
    CV_uoff32_t     off;
    unsigned short  seg;
    unsigned short  len;        // length of thunk
    unsigned char   ord;        // ordinal specifying type of thunk
    unsigned char   name[1];    // Length-prefixed name
    unsigned char   variant[CV_ZEROLEN]; // variant portion of thunk
} THUNKSYM32;




typedef struct LABELSYM32 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_LABEL32
    CV_uoff32_t     off;
    unsigned short  seg;
    CV_PROCFLAGS    flags;      // flags
    unsigned char   name[1];    // Length-prefixed name
} LABELSYM32;


typedef struct BLOCKSYM32 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_BLOCK32
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned long   len;        // Block length
    CV_uoff32_t     off;        // Offset in code segment
    unsigned short  seg;        // segment of label
    unsigned char   name[1];    // Length-prefixed name
} BLOCKSYM32;


typedef struct WITHSYM32 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_WITH32
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned long   len;        // Block length
    CV_uoff32_t     off;        // Offset in code segment
    unsigned short  seg;        // segment of label
    unsigned char   expr[1];    // Length-prefixed expression string
} WITHSYM32;



typedef struct CEXMSYM32 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_CEXMODEL32
    CV_uoff32_t     off;        // offset of symbol
    unsigned short  seg;        // segment of symbol
    unsigned short  model;      // execution model
    union var32 {
        struct  {
            CV_uoff32_t pcdtable;   // offset to pcode function table
            CV_uoff32_t pcdspi;     // offset to segment pcode information
        } pcode;
        struct {
            unsigned short  subtype;   // see CV_COBOL_e above
            unsigned short  flag;
        } cobol;
        struct {
            CV_uoff32_t calltableOff; // offset to function table
            unsigned short calltableSeg; // segment of function table
        } pcode32Mac;
    };
} CEXMSYM32;



typedef struct VPATHSYM32 {
    unsigned short  reclen;     // record length
    unsigned short  rectyp;     // S_VFTPATH32
    CV_uoff32_t     off;        // offset of virtual function table
    unsigned short  seg;        // segment of virtual function table
    CV_typ_t        root;       // type index of the root of path
    CV_typ_t        path;       // type index of the path record
} VPATHSYM32;





typedef struct REGREL32 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_REGREL32
    CV_uoff32_t     off;        // offset of symbol
    unsigned short  reg;        // register index for symbol
    CV_typ_t        typind;     // Type index
    unsigned char   name[1];    // Length-prefixed name
} REGREL32;



typedef struct THREADSYM32 {
    unsigned short  reclen;     // record length
    unsigned short  rectyp;     // S_LTHREAD32 | S_GTHREAD32
    CV_uoff32_t     off;        // offset into thread storage
    unsigned short  seg;        // segment of thread storage
    CV_typ_t        typind;     // type index
    unsigned char   name[1];    // length prefixed name
} THREADSYM32;

typedef struct SLINK32 {
    unsigned short  reclen;     // record length
    unsigned short  rectyp;     // S_SLINK32
    unsigned long   framesize;  // frame size of parent procedure
    CV_off32_t      off;        // signed offset where the static link was saved relative to the value of reg
    unsigned short  reg;
} SLINK32;

typedef struct PROCSYMMIPS {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_GPROCMIPS or S_LPROCMIPS
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned long   pNext;      // pointer to next symbol
    unsigned long   len;        // Proc length
    unsigned long   DbgStart;   // Debug start offset
    unsigned long   DbgEnd;     // Debug end offset
    unsigned long   regSave;    // int register save mask
    unsigned long   fpSave;     // fp register save mask
    CV_uoff32_t     intOff;     // int register save offset
    CV_uoff32_t     fpOff;      // fp register save offset
    CV_uoff32_t     off;        // Symbol offset
    unsigned short  seg;        // Symbol segment
    CV_typ_t        typind;     // Type index
    unsigned char   retReg;     // Register return value is in
    unsigned char   frameReg;   // Frame pointer register
    unsigned char   name[1];    // Length-prefixed name
} PROCSYMMIPS;


typedef struct REFSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_PROCREF or S_DATAREF
    unsigned long   sumName;    // SUC of the name
    unsigned long   ibSym;      // Offset of actual symbol in $$Symbols
    unsigned short  imod;       // Module containing the actual symbol
    unsigned short  usFill;     // align this record
} REFSYM;

typedef struct ALIGNSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_PROCREF or S_DATAREF
} ALIGNSYM;

//  generic block definition symbols
//  these are similar to the equivalent 16:16 or 16:32 symbols but
//  only define the length, type and linkage fields

typedef struct PROCSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_GPROC16 or S_LPROC16
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned long   pNext;      // pointer to next symbol
} PROCSYM;


typedef struct THUNKSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_THUNK
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned long   pNext;      // pointer to next symbol
} THUNKSYM;

typedef struct BLOCKSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_BLOCK16
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
} BLOCKSYM;


typedef struct WITHSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_WITH16
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
} WITHSYM;


typedef enum CV_HREG_e {
    //  Register set for the Intel 80x86 and ix86 processor series
    //  (plus PCODE registers)

    CV_REG_NONE     =   0,
    CV_REG_AL       =   1,
    CV_REG_CL       =   2,
    CV_REG_DL       =   3,
    CV_REG_BL       =   4,
    CV_REG_AH       =   5,
    CV_REG_CH       =   6,
    CV_REG_DH       =   7,
    CV_REG_BH       =   8,
    CV_REG_AX       =   9,
    CV_REG_CX       =  10,
    CV_REG_DX       =  11,
    CV_REG_BX       =  12,
    CV_REG_SP       =  13,
    CV_REG_BP       =  14,
    CV_REG_SI       =  15,
    CV_REG_DI       =  16,
    CV_REG_EAX      =  17,
    CV_REG_ECX      =  18,
    CV_REG_EDX      =  19,
    CV_REG_EBX      =  20,
    CV_REG_ESP      =  21,
    CV_REG_EBP      =  22,
    CV_REG_ESI      =  23,
    CV_REG_EDI      =  24,
    CV_REG_ES       =  25,
    CV_REG_CS       =  26,
    CV_REG_SS       =  27,
    CV_REG_DS       =  28,
    CV_REG_FS       =  29,
    CV_REG_GS       =  30,
    CV_REG_IP       =  31,
    CV_REG_FLAGS    =  32,
    CV_REG_EIP      =  33,
    CV_REG_EFLAGS   =  34,
    CV_REG_TEMP     =  40,          // PCODE Temp
    CV_REG_TEMPH    =  41,          // PCODE TempH
    CV_REG_QUOTE    =  42,          // PCODE Quote
    CV_REG_PCDR3    =  43,          // PCODE reserved
    CV_REG_PCDR4    =  44,          // PCODE reserved
    CV_REG_PCDR5    =  45,          // PCODE reserved
    CV_REG_PCDR6    =  46,          // PCODE reserved
    CV_REG_PCDR7    =  47,          // PCODE reserved
    CV_REG_CR0      =  80,          // CR0 -- control registers
    CV_REG_CR1      =  81,
    CV_REG_CR2      =  82,
    CV_REG_CR3      =  83,
    CV_REG_CR4      =  84,          // Pentium
    CV_REG_DR0      =  90,          // Debug register
    CV_REG_DR1      =  91,
    CV_REG_DR2      =  92,
    CV_REG_DR3      =  93,
    CV_REG_DR4      =  94,
    CV_REG_DR5      =  95,
    CV_REG_DR6      =  96,
    CV_REG_DR7      =  97,
    CV_REG_GDTR     =  110,
    CV_REG_GDTL     =  111,
    CV_REG_IDTR     =  112,
    CV_REG_IDTL     =  113,
    CV_REG_LDTR     =  114,
    CV_REG_TR       =  115,

    CV_REG_PSEUDO1  =  116,
    CV_REG_PSEUDO2  =  117,
    CV_REG_PSEUDO3  =  118,
    CV_REG_PSEUDO4  =  119,
    CV_REG_PSEUDO5  =  120,
    CV_REG_PSEUDO6  =  121,
    CV_REG_PSEUDO7  =  122,
    CV_REG_PSEUDO8  =  123,
    CV_REG_PSEUDO9  =  124,

    CV_REG_ST0      =  128,
    CV_REG_ST1      =  129,
    CV_REG_ST2      =  130,
    CV_REG_ST3      =  131,
    CV_REG_ST4      =  132,
    CV_REG_ST5      =  133,
    CV_REG_ST6      =  134,
    CV_REG_ST7      =  135,
    CV_REG_CTRL     =  136,
    CV_REG_STAT     =  137,
    CV_REG_TAG      =  138,
    CV_REG_FPIP     =  139,
    CV_REG_FPCS     =  140,
    CV_REG_FPDO     =  141,
    CV_REG_FPDS     =  142,
    CV_REG_ISEM     =  143,
    CV_REG_FPEIP    =  144,
    CV_REG_FPEDO    =  145,

    // registers for the 68K processors

    CV_R68_D0       =    0,
    CV_R68_D1       =    1,
    CV_R68_D2       =    2,
    CV_R68_D3       =    3,
    CV_R68_D4       =    4,
    CV_R68_D5       =    5,
    CV_R68_D6       =    6,
    CV_R68_D7       =    7,
    CV_R68_A0       =    8,
    CV_R68_A1       =    9,
    CV_R68_A2       =   10,
    CV_R68_A3       =   11,
    CV_R68_A4       =   12,
    CV_R68_A5       =   13,
    CV_R68_A6       =   14,
    CV_R68_A7       =   15,
    CV_R68_CCR      =   16,
    CV_R68_SR       =   17,
    CV_R68_USP      =   18,
    CV_R68_MSP      =   19,
    CV_R68_SFC      =   20,
    CV_R68_DFC      =   21,
    CV_R68_CACR     =   22,
    CV_R68_VBR      =   23,
    CV_R68_CAAR     =   24,
    CV_R68_ISP      =   25,
    CV_R68_PC       =   26,
    //reserved  27
    CV_R68_FPCR     =   28,
    CV_R68_FPSR     =   29,
    CV_R68_FPIAR    =   30,
    //reserved  31
    CV_R68_FP0      =   32,
    CV_R68_FP1      =   33,
    CV_R68_FP2      =   34,
    CV_R68_FP3      =   35,
    CV_R68_FP4      =   36,
    CV_R68_FP5      =   37,
    CV_R68_FP6      =   38,
    CV_R68_FP7      =   39,
    //reserved  40
    CV_R68_MMUSR030 =   41,
    CV_R68_MMUSR    =   42,
    CV_R68_URP      =   43,
    CV_R68_DTT0     =   44,
    CV_R68_DTT1     =   45,
    CV_R68_ITT0     =   46,
    CV_R68_ITT1     =   47,
    //reserved  50
    CV_R68_PSR      =   51,
    CV_R68_PCSR     =   52,
    CV_R68_VAL      =   53,
    CV_R68_CRP      =   54,
    CV_R68_SRP      =   55,
    CV_R68_DRP      =   56,
    CV_R68_TC       =   57,
    CV_R68_AC       =   58,
    CV_R68_SCC      =   59,
    CV_R68_CAL      =   60,
    CV_R68_TT0      =   61,
    CV_R68_TT1      =   62,
    //reserved  63
    CV_R68_BAD0     =   64,
    CV_R68_BAD1     =   65,
    CV_R68_BAD2     =   66,
    CV_R68_BAD3     =   67,
    CV_R68_BAD4     =   68,
    CV_R68_BAD5     =   69,
    CV_R68_BAD6     =   70,
    CV_R68_BAD7     =   71,
    CV_R68_BAC0     =   72,
    CV_R68_BAC1     =   73,
    CV_R68_BAC2     =   74,
    CV_R68_BAC3     =   75,
    CV_R68_BAC4     =   76,
    CV_R68_BAC5     =   77,
    CV_R68_BAC6     =   78,
    CV_R68_BAC7     =   79,

     // Register set for the MIPS 4000

    CV_M4_NOREG     =   CV_REG_NONE,

    CV_M4_IntZERO   =   10,      /* CPU REGISTER */
    CV_M4_IntAT     =   11,
    CV_M4_IntV0     =   12,
    CV_M4_IntV1     =   13,
    CV_M4_IntA0     =   14,
    CV_M4_IntA1     =   15,
    CV_M4_IntA2     =   16,
    CV_M4_IntA3     =   17,
    CV_M4_IntT0     =   18,
    CV_M4_IntT1     =   19,
    CV_M4_IntT2     =   20,
    CV_M4_IntT3     =   21,
    CV_M4_IntT4     =   22,
    CV_M4_IntT5     =   23,
    CV_M4_IntT6     =   24,
    CV_M4_IntT7     =   25,
    CV_M4_IntS0     =   26,
    CV_M4_IntS1     =   27,
    CV_M4_IntS2     =   28,
    CV_M4_IntS3     =   29,
    CV_M4_IntS4     =   30,
    CV_M4_IntS5     =   31,
    CV_M4_IntS6     =   32,
    CV_M4_IntS7     =   33,
    CV_M4_IntT8     =   34,
    CV_M4_IntT9     =   35,
    CV_M4_IntKT0    =   36,
    CV_M4_IntKT1    =   37,
    CV_M4_IntGP     =   38,
    CV_M4_IntSP     =   39,
    CV_M4_IntS8     =   40,
    CV_M4_IntRA     =   41,
    CV_M4_IntLO     =   42,
    CV_M4_IntHI     =   43,

    CV_M4_Fir       =   50,
    CV_M4_Psr       =   51,

    CV_M4_FltF0     =   60,      /* Floating point registers */
    CV_M4_FltF1     =   61,
    CV_M4_FltF2     =   62,
    CV_M4_FltF3     =   63,
    CV_M4_FltF4     =   64,
    CV_M4_FltF5     =   65,
    CV_M4_FltF6     =   66,
    CV_M4_FltF7     =   67,
    CV_M4_FltF8     =   68,
    CV_M4_FltF9     =   69,
    CV_M4_FltF10    =   70,
    CV_M4_FltF11    =   71,
    CV_M4_FltF12    =   72,
    CV_M4_FltF13    =   73,
    CV_M4_FltF14    =   74,
    CV_M4_FltF15    =   75,
    CV_M4_FltF16    =   76,
    CV_M4_FltF17    =   77,
    CV_M4_FltF18    =   78,
    CV_M4_FltF19    =   79,
    CV_M4_FltF20    =   80,
    CV_M4_FltF21    =   81,
    CV_M4_FltF22    =   82,
    CV_M4_FltF23    =   83,
    CV_M4_FltF24    =   84,
    CV_M4_FltF25    =   85,
    CV_M4_FltF26    =   86,
    CV_M4_FltF27    =   87,
    CV_M4_FltF28    =   88,
    CV_M4_FltF29    =   89,
    CV_M4_FltF30    =   90,
    CV_M4_FltF31    =   91,
    CV_M4_FltFsr    =   92,


    // Register set for the ALPHA AXP

    CV_ALPHA_NOREG  = CV_REG_NONE,

    CV_ALPHA_FltF0  =   10,   // Floating point registers
    CV_ALPHA_FltF1  =   11,
    CV_ALPHA_FltF2  =   12,
    CV_ALPHA_FltF3  =   13,
    CV_ALPHA_FltF4  =   14,
    CV_ALPHA_FltF5  =   15,
    CV_ALPHA_FltF6  =   16,
    CV_ALPHA_FltF7  =   17,
    CV_ALPHA_FltF8  =   18,
    CV_ALPHA_FltF9  =   19,
    CV_ALPHA_FltF10 =   20,
    CV_ALPHA_FltF11 =   21,
    CV_ALPHA_FltF12 =   22,
    CV_ALPHA_FltF13 =   23,
    CV_ALPHA_FltF14 =   24,
    CV_ALPHA_FltF15 =   25,
    CV_ALPHA_FltF16 =   26,
    CV_ALPHA_FltF17 =   27,
    CV_ALPHA_FltF18 =   28,
    CV_ALPHA_FltF19 =   29,
    CV_ALPHA_FltF20 =   30,
    CV_ALPHA_FltF21 =   31,
    CV_ALPHA_FltF22 =   32,
    CV_ALPHA_FltF23 =   33,
    CV_ALPHA_FltF24 =   34,
    CV_ALPHA_FltF25 =   35,
    CV_ALPHA_FltF26 =   36,
    CV_ALPHA_FltF27 =   37,
    CV_ALPHA_FltF28 =   38,
    CV_ALPHA_FltF29 =   39,
    CV_ALPHA_FltF30 =   40,
    CV_ALPHA_FltF31 =   41,

    CV_ALPHA_IntV0  =   42,   // Integer registers
    CV_ALPHA_IntT0  =   43,
    CV_ALPHA_IntT1  =   44,
    CV_ALPHA_IntT2  =   45,
    CV_ALPHA_IntT3  =   46,
    CV_ALPHA_IntT4  =   47,
    CV_ALPHA_IntT5  =   48,
    CV_ALPHA_IntT6  =   49,
    CV_ALPHA_IntT7  =   50,
    CV_ALPHA_IntS0  =   51,
    CV_ALPHA_IntS1  =   52,
    CV_ALPHA_IntS2  =   53,
    CV_ALPHA_IntS3  =   54,
    CV_ALPHA_IntS4  =   55,
    CV_ALPHA_IntS5  =   56,
    CV_ALPHA_IntFP  =   57,
    CV_ALPHA_IntA0  =   58,
    CV_ALPHA_IntA1  =   59,
    CV_ALPHA_IntA2  =   60,
    CV_ALPHA_IntA3  =   61,
    CV_ALPHA_IntA4  =   62,
    CV_ALPHA_IntA5  =   63,
    CV_ALPHA_IntT8  =   64,
    CV_ALPHA_IntT9  =   65,
    CV_ALPHA_IntT10 =   66,
    CV_ALPHA_IntT11 =   67,
    CV_ALPHA_IntRA  =   68,
    CV_ALPHA_IntT12 =   69,
    CV_ALPHA_IntAT  =   70,
    CV_ALPHA_IntGP  =   71,
    CV_ALPHA_IntSP  =   72,
    CV_ALPHA_IntZERO =  73,


    CV_ALPHA_Fpcr   =   74,   // Control registers
    CV_ALPHA_Fir    =   75,
    CV_ALPHA_Psr    =   76,
    CV_ALPHA_FltFsr =   77,
    CV_ALPHA_SoftFpcr =   78,

    // Register Set for Motorola/IBM PowerPC

    /*
    ** PowerPC General Registers ( User Level )
    */
    CV_PPC_GPR0     =  1,
    CV_PPC_GPR1     =  2,
    CV_PPC_GPR2     =  3,
    CV_PPC_GPR3     =  4,
    CV_PPC_GPR4     =  5,
    CV_PPC_GPR5     =  6,
    CV_PPC_GPR6     =  7,
    CV_PPC_GPR7     =  8,
    CV_PPC_GPR8     =  9,
    CV_PPC_GPR9     = 10,
    CV_PPC_GPR10    = 11,
    CV_PPC_GPR11    = 12,
    CV_PPC_GPR12    = 13,
    CV_PPC_GPR13    = 14,
    CV_PPC_GPR14    = 15,
    CV_PPC_GPR15    = 16,
    CV_PPC_GPR16    = 17,
    CV_PPC_GPR17    = 18,
    CV_PPC_GPR18    = 19,
    CV_PPC_GPR19    = 20,
    CV_PPC_GPR20    = 21,
    CV_PPC_GPR21    = 22,
    CV_PPC_GPR22    = 23,
    CV_PPC_GPR23    = 24,
    CV_PPC_GPR24    = 25,
    CV_PPC_GPR25    = 26,
    CV_PPC_GPR26    = 27,
    CV_PPC_GPR27    = 28,
    CV_PPC_GPR28    = 29,
    CV_PPC_GPR29    = 30,
    CV_PPC_GPR30    = 31,
    CV_PPC_GPR31    = 32,

    /*
    ** PowerPC Condition Register ( User Level )
    */
    CV_PPC_CR       = 33,
    CV_PPC_CR0      = 34,
    CV_PPC_CR1      = 35,
    CV_PPC_CR2      = 36,
    CV_PPC_CR3      = 37,
    CV_PPC_CR4      = 38,
    CV_PPC_CR5      = 39,
    CV_PPC_CR6      = 40,
    CV_PPC_CR7      = 41,

    /*
    ** PowerPC Floating Point Registers ( User Level )
    */
    CV_PPC_FPR0     = 42,
    CV_PPC_FPR1     = 43,
    CV_PPC_FPR2     = 44,
    CV_PPC_FPR3     = 45,
    CV_PPC_FPR4     = 46,
    CV_PPC_FPR5     = 47,
    CV_PPC_FPR6     = 48,
    CV_PPC_FPR7     = 49,
    CV_PPC_FPR8     = 50,
    CV_PPC_FPR9     = 51,
    CV_PPC_FPR10    = 52,
    CV_PPC_FPR11    = 53,
    CV_PPC_FPR12    = 54,
    CV_PPC_FPR13    = 55,
    CV_PPC_FPR14    = 56,
    CV_PPC_FPR15    = 57,
    CV_PPC_FPR16    = 58,
    CV_PPC_FPR17    = 59,
    CV_PPC_FPR18    = 60,
    CV_PPC_FPR19    = 61,
    CV_PPC_FPR20    = 62,
    CV_PPC_FPR21    = 63,
    CV_PPC_FPR22    = 64,
    CV_PPC_FPR23    = 65,
    CV_PPC_FPR24    = 66,
    CV_PPC_FPR25    = 67,
    CV_PPC_FPR26    = 68,
    CV_PPC_FPR27    = 69,
    CV_PPC_FPR28    = 70,
    CV_PPC_FPR29    = 71,
    CV_PPC_FPR30    = 72,
    CV_PPC_FPR31    = 73,

    /*
    ** PowerPC Floating Point Status and Control Register ( User Level )
    */
    CV_PPC_FPSCR    = 74,

    /*
    ** PowerPC Machine State Register ( Supervisor Level )
    */
    CV_PPC_MSR      = 75,

    /*
    ** PowerPC Segment Registers ( Supervisor Level )
    */
    CV_PPC_SR0      = 76,
    CV_PPC_SR1      = 77,
    CV_PPC_SR2      = 78,
    CV_PPC_SR3      = 79,
    CV_PPC_SR4      = 80,
    CV_PPC_SR5      = 81,
    CV_PPC_SR6      = 82,
    CV_PPC_SR7      = 83,
    CV_PPC_SR8      = 84,
    CV_PPC_SR9      = 85,
    CV_PPC_SR10     = 86,
    CV_PPC_SR11     = 87,
    CV_PPC_SR12     = 88,
    CV_PPC_SR13     = 89,
    CV_PPC_SR14     = 90,
    CV_PPC_SR15     = 91,

    /*
    ** For all of the special purpose registers add 100 to the SPR# that the
    ** Motorola/IBM documentation gives with the exception of any imaginary
    ** registers.
    */

    /*
    ** PowerPC Special Purpose Registers ( User Level )
    */
    CV_PPC_PC       = 99,     // PC (imaginary register)

    CV_PPC_MQ       = 100,    // MPC601
    CV_PPC_XER      = 101,
    CV_PPC_RTCU     = 104,    // MPC601
    CV_PPC_RTCL     = 105,    // MPC601
    CV_PPC_LR       = 108,
    CV_PPC_CTR      = 109,

    CV_PPC_COMPARE  = 110,    // part of XER (internal to the debugger only)
    CV_PPC_COUNT    = 111,    // part of XER (internal to the debugger only)

    /*
    ** PowerPC Special Purpose Registers ( Supervisor Level )
    */
    CV_PPC_DSISR    = 118,
    CV_PPC_DAR      = 119,
    CV_PPC_DEC      = 122,
    CV_PPC_SDR1     = 125,
    CV_PPC_SRR0     = 126,
    CV_PPC_SRR1     = 127,
    CV_PPC_SPRG0    = 372,
    CV_PPC_SPRG1    = 373,
    CV_PPC_SPRG2    = 374,
    CV_PPC_SPRG3    = 375,
    CV_PPC_ASR      = 280,    // 64-bit implementations only
    CV_PPC_EAR      = 382,
    CV_PPC_PVR      = 287,
    CV_PPC_BAT0U    = 628,
    CV_PPC_BAT0L    = 629,
    CV_PPC_BAT1U    = 630,
    CV_PPC_BAT1L    = 631,
    CV_PPC_BAT2U    = 632,
    CV_PPC_BAT2L    = 633,
    CV_PPC_BAT3U    = 634,
    CV_PPC_BAT3L    = 635,
    CV_PPC_DBAT0U   = 636,
    CV_PPC_DBAT0L   = 637,
    CV_PPC_DBAT1U   = 638,
    CV_PPC_DBAT1L   = 639,
    CV_PPC_DBAT2U   = 640,
    CV_PPC_DBAT2L   = 641,
    CV_PPC_DBAT3U   = 642,
    CV_PPC_DBAT3L   = 643,

    /*
    ** PowerPC Special Purpose Registers Implementation Dependent ( Supervisor Level )
    */

    /*
    ** Doesn't appear that IBM/Motorola has finished defining these.
    */

    CV_PPC_PMR0     = 1044,   // MPC620,
    CV_PPC_PMR1     = 1045,   // MPC620,
    CV_PPC_PMR2     = 1046,   // MPC620,
    CV_PPC_PMR3     = 1047,   // MPC620,
    CV_PPC_PMR4     = 1048,   // MPC620,
    CV_PPC_PMR5     = 1049,   // MPC620,
    CV_PPC_PMR6     = 1050,   // MPC620,
    CV_PPC_PMR7     = 1051,   // MPC620,
    CV_PPC_PMR8     = 1052,   // MPC620,
    CV_PPC_PMR9     = 1053,   // MPC620,
    CV_PPC_PMR10    = 1054,   // MPC620,
    CV_PPC_PMR11    = 1055,   // MPC620,
    CV_PPC_PMR12    = 1056,   // MPC620,
    CV_PPC_PMR13    = 1057,   // MPC620,
    CV_PPC_PMR14    = 1058,   // MPC620,
    CV_PPC_PMR15    = 1059,   // MPC620,

    CV_PPC_DMISS    = 1076,   // MPC603
    CV_PPC_DCMP     = 1077,   // MPC603
    CV_PPC_HASH1    = 1078,   // MPC603
    CV_PPC_HASH2    = 1079,   // MPC603
    CV_PPC_IMISS    = 1080,   // MPC603
    CV_PPC_ICMP     = 1081,   // MPC603
    CV_PPC_RPA      = 1082,   // MPC603

    CV_PPC_HID0     = 1108,   // MPC601, MPC603, MPC620
    CV_PPC_HID1     = 1109,   // MPC601
    CV_PPC_HID2     = 1110,   // MPC601, MPC603, MPC620 ( IABR )
    CV_PPC_HID3     = 1111,   // Not Defined
    CV_PPC_HID4     = 1112,   // Not Defined
    CV_PPC_HID5     = 1113,   // MPC601, MPC604, MPC620 ( DABR )
    CV_PPC_HID6     = 1114,   // Not Defined
    CV_PPC_HID7     = 1115,   // Not Defined
    CV_PPC_HID8     = 1116,   // MPC620 ( BUSCSR )
    CV_PPC_HID9     = 1117,   // MPC620 ( L2CSR )
    CV_PPC_HID10    = 1118,   // Not Defined
    CV_PPC_HID11    = 1119,   // Not Defined
    CV_PPC_HID12    = 1120,   // Not Defined
    CV_PPC_HID13    = 1121,   // MPC604 ( HCR )
    CV_PPC_HID14    = 1122,   // Not Defined
    CV_PPC_HID15    = 1123,   // MPC601, MPC604, MPC620 ( PIR )


	//
	// JAVA VM registers
	//

	CV_JAVA_PC		= 1,


} CV_HREG_e;

#pragma pack ( pop )

#endif	/* CC_CVTYPE32 */

#endif /* CV_INFO_INCLUDED */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\vctools\pdb6\langapi\include\cvexefmt.h ===
/***    cvexefmt.h - format of CodeView information in exe
 *
 *      Structures, constants, etc. for reading CodeView information
 *      from the executable.
 *
 */


/***    The master copy of this file resides in the LANGAPI project.
 *      All Microsoft projects are required to use the master copy without
 *      modification.  Modification of the master version or a copy
 *      without consultation with all parties concerned is extremely
 *      risky.
 *
 */


#ifndef _VC_VER_INC
#include "..\include\vcver.h"
#endif



//  The following structures and constants describe the format of the
//  CodeView Debug OMF for that will be accepted by CodeView 4.0 and
//  later.  These are executables with signatures of NB05, NB06 and NB08.
//  There is some confusion about the signatures NB03 and NB04 so none
//  of the utilites will accept executables with these signatures.  NB07 is
//  the signature for QCWIN 1.0 packed executables.

//  All of the structures described below must start on a long word boundary
//  to maintain natural alignment.  Pad space can be inserted during the
//  write operation and the addresses adjusted without affecting the contents
//  of the structures.

#ifndef _CV_INFO_INCLUDED
#include "cvinfo.h"
#endif

#ifndef FAR
#if _M_IX86 >= 300
#define FAR
#else
#define FAR far
#endif
#endif


//  Type of subsection entry.

#define sstModule           0x120
#define sstTypes            0x121
#define sstPublic           0x122
#define sstPublicSym        0x123   // publics as symbol (waiting for link)
#define sstSymbols          0x124
#define sstAlignSym         0x125
#define sstSrcLnSeg         0x126   // because link doesn't emit SrcModule
#define sstSrcModule        0x127
#define sstLibraries        0x128
#define sstGlobalSym        0x129
#define sstGlobalPub        0x12a
#define sstGlobalTypes      0x12b
#define sstMPC              0x12c
#define sstSegMap           0x12d
#define sstSegName          0x12e
#define sstPreComp          0x12f   // precompiled types
#define sstPreCompMap       0x130   // map precompiled types in global types
#define sstOffsetMap16      0x131
#define sstOffsetMap32      0x132
#define sstFileIndex        0x133   // Index of file names
#define sstStaticSym        0x134

typedef enum OMFHash {
    OMFHASH_NONE,           // no hashing
    OMFHASH_SUMUC16,        // upper case sum of chars in 16 bit table
    OMFHASH_SUMUC32,        // upper case sum of chars in 32 bit table
    OMFHASH_ADDR16,         // sorted by increasing address in 16 bit table
    OMFHASH_ADDR32          // sorted by increasing address in 32 bit table
} OMFHASH;

//  CodeView Debug OMF signature.  The signature at the end of the file is
//  a negative offset from the end of the file to another signature.  At
//  the negative offset (base address) is another signature whose filepos
//  field points to the first OMFDirHeader in a chain of directories.
//  The NB05 signature is used by the link utility to indicated a completely
//  unpacked file.  The NB06 signature is used by ilink to indicate that the
//  executable has had CodeView information from an incremental link appended
//  to the executable.  The NB08 signature is used by cvpack to indicate that
//  the CodeView Debug OMF has been packed.  CodeView will only process
//  executables with the NB08 signature.


typedef struct OMFSignature {
    char            Signature[4];   // "NBxx"
    long            filepos;        // offset in file
} OMFSignature;



//  directory information structure
//  This structure contains the information describing the directory.
//  It is pointed to by the signature at the base address or the directory
//  link field of a preceeding directory.  The directory entries immediately
//  follow this structure.


typedef struct OMFDirHeader {
    unsigned short  cbDirHeader;    // length of this structure
    unsigned short  cbDirEntry;     // number of bytes in each directory entry
    unsigned long   cDir;           // number of directorie entries
    long            lfoNextDir;     // offset from base of next directory
    unsigned long   flags;          // status flags
} OMFDirHeader;




//  directory structure
//  The data in this structure is used to reference the data for each
//  subsection of the CodeView Debug OMF information.  Tables that are
//  not associated with a specific module will have a module index of
//  oxffff.  These tables are the global types table, the global symbol
//  table, the global public table and the library table.


typedef struct OMFDirEntry {
    unsigned short  SubSection;     // subsection type (sst...)
    unsigned short  iMod;           // module index
    long            lfo;            // large file offset of subsection
    unsigned long   cb;             // number of bytes in subsection
} OMFDirEntry;



//  information decribing each segment in a module

typedef struct OMFSegDesc {
    unsigned short  Seg;            // segment index
    unsigned short  pad;            // pad to maintain alignment
    unsigned long   Off;            // offset of code in segment
    unsigned long   cbSeg;          // number of bytes in segment
} OMFSegDesc;




//  per module information
//  There is one of these subsection entries for each module
//  in the executable.  The entry is generated by link/ilink.
//  This table will probably require padding because of the
//  variable length module name.

typedef struct OMFModule {
    unsigned short  ovlNumber;      // overlay number
    unsigned short  iLib;           // library that the module was linked from
    unsigned short  cSeg;           // count of number of segments in module
    char            Style[2];       // debugging style "CV"
    OMFSegDesc      SegInfo[1];     // describes segments in module
    char            Name[];         // length prefixed module name padded to
                                    // long word boundary
} OMFModule;



//  Symbol hash table format
//  This structure immediately preceeds the global publics table
//  and global symbol tables.

typedef struct  OMFSymHash {
    unsigned short  symhash;        // symbol hash function index
    unsigned short  addrhash;       // address hash function index
    unsigned long   cbSymbol;       // length of symbol information
    unsigned long   cbHSym;         // length of symbol hash data
    unsigned long   cbHAddr;        // length of address hashdata
} OMFSymHash;



//  Global types subsection format
//  This structure immediately preceeds the global types table.
//  The offsets in the typeOffset array are relative to the address
//  of ctypes.  Each type entry following the typeOffset array must
//  begin on a long word boundary.

typedef struct OMFTypeFlags {
    unsigned long   sig     :8;
    unsigned long   unused  :24;
} OMFTypeFlags;


typedef struct OMFGlobalTypes {
    OMFTypeFlags    flags;
    unsigned long   cTypes;         // number of types
    unsigned long   typeOffset[];   // array of offsets to types
} OMFGlobalTypes;




//  Precompiled types mapping table
//  This table should be ignored by all consumers except the incremental
//  packer.


typedef struct OMFPreCompMap {
    CV_typ_t        FirstType;      // first precompiled type index
    CV_typ_t        cTypes;         // number of precompiled types
    unsigned long   signature;      // precompiled types signature
    CV_typ_t        map[];          // mapping of precompiled types
} OMFPreCompMap;



//  Source line to address mapping table.
//  This table is generated by the link/ilink utility from line number
//  information contained in the object file OMF data.  This table contains
//  only the code contribution for one segment from one source file.


typedef struct OMFSourceLine {
    unsigned short  Seg;            // linker segment index
    unsigned short  cLnOff;         // count of line/offset pairs
    unsigned long   offset[1];      // array of offsets in segment
    unsigned short  lineNbr[1];     // array of line lumber in source
} OMFSourceLine;

typedef OMFSourceLine * LPSL;


//  Source file description
//  This table is generated by the linker


typedef struct OMFSourceFile {
    unsigned short  cSeg;           // number of segments from source file
    unsigned short  reserved;       // reserved
    unsigned long   baseSrcLn[1];   // base of OMFSourceLine tables
                                    // this array is followed by array
                                    // of segment start/end pairs followed by
                                    // an array of linker indices
                                    // for each segment in the file
    unsigned short  cFName;         // length of source file name
    char            Name;           // name of file padded to long boundary
} OMFSourceFile;

typedef OMFSourceFile * LPSF;


//  Source line to address mapping header structure
//  This structure describes the number and location of the
//  OMFAddrLine tables for a module.  The offSrcLine entries are
//  relative to the beginning of this structure.


typedef struct OMFSourceModule {
    unsigned short  cFile;          // number of OMFSourceTables
    unsigned short  cSeg;           // number of segments in module
    unsigned long   baseSrcFile[1]; // base of OMFSourceFile table
                                    // this array is followed by array
                                    // of segment start/end pairs followed
                                    // by an array of linker indices
                                    // for each segment in the module
} OMFSourceModule;

typedef OMFSourceModule * LPSM;

//  sstLibraries

typedef struct OMFLibrary {
    unsigned char   cbLibs;     // count of library names
    char            Libs[1];    // array of length prefixed lib names (first entry zero length)
} OMFLibrary;


// sstFileIndex - An index of all of the files contributing to an
//  executable.

typedef struct OMFFileIndex {
    unsigned short  cmodules;       // Number of modules
    unsigned short  cfilerefs;      // Number of file references
    unsigned short  modulelist[1];  // Index to beginning of list of files
                                    // for module i. (0 for module w/o files)
    unsigned short  cfiles[1];      // Number of file names associated
                                    // with module i.
    unsigned long   ulNames[1];     // Offsets from the beginning of this
                                    // table to the file names
    char            Names[];        // The length prefixed names of files
} OMFFileIndex;


//  Offset mapping table
//  This table provides a mapping from logical to physical offsets.
//  This mapping is applied between the logical to physical mapping
//  described by the seg map table.

typedef struct OMFOffsetMap16 {
    unsigned long   csegment;       // Count of physical segments

    // The next six items are repeated for each segment

    unsigned long   crangeLog;      // Count of logical offset ranges
    unsigned short  rgoffLog[1];    // Array of logical offsets
    short           rgbiasLog[1];   // Array of logical->physical bias
    unsigned long   crangePhys;     // Count of physical offset ranges
    unsigned short  rgoffPhys[1];   // Array of physical offsets
    short           rgbiasPhys[1];  // Array of physical->logical bias
} OMFOffsetMap16;

typedef struct OMFOffsetMap32 {
    unsigned long   csection;       // Count of physical sections

    // The next six items are repeated for each section

    unsigned long   crangeLog;      // Count of logical offset ranges
    unsigned long   rgoffLog[1];    // Array of logical offsets
    long            rgbiasLog[1];   // Array of logical->physical bias
    unsigned long   crangePhys;     // Count of physical offset ranges
    unsigned long   rgoffPhys[1];   // Array of physical offsets
    long            rgbiasPhys[1];  // Array of physical->logical bias
} OMFOffsetMap32;

//  Pcode support.  This subsection contains debug information generated
//  by the MPC utility used to process Pcode executables.  Currently
//  it contains a mapping table from segment index (zero based) to
//  frame paragraph.  MPC converts segmented exe's to non-segmented
//  exe's for DOS support.  To avoid backpatching all CV info, this
//  table is provided for the mapping.  Additional info may be provided
//  in the future for profiler support.

typedef struct OMFMpcDebugInfo {
    unsigned short  cSeg;       // number of segments in module
    unsigned short  mpSegFrame[1];  // map seg (zero based) to frame
} OMFMpcDebugInfo;

//  The following structures and constants describe the format of the
//  CodeView Debug OMF for linkers that emit executables with the NB02
//  signature.  Current utilities with the exception of cvpack and cvdump
//  will not accept or emit executables with the NB02 signature.  Cvdump
//  will dump an unpacked executable with the NB02 signature.  Cvpack will
//  read an executable with the NB02 signature but the packed executable
//  will be written with the table format, contents and signature of NB08.





//  subsection type constants

#define SSTMODULE       0x101   // Basic info. about object module
#define SSTPUBLIC       0x102   // Public symbols
#define SSTTYPES        0x103   // Type information
#define SSTSYMBOLS      0x104   // Symbol Data
#define SSTSRCLINES     0x105   // Source line information
#define SSTLIBRARIES    0x106   // Names of all library files used
#define SSTIMPORTS      0x107   // Symbols for DLL fixups
#define SSTCOMPACTED    0x108   // Compacted types section
#define SSTSRCLNSEG     0x109   // Same as source lines, contains segment


typedef struct DirEntry{
    unsigned short  SubSectionType;
    unsigned short  ModuleIndex;
    long            lfoStart;
    unsigned short  Size;
} DirEntry;


//  information decribing each segment in a module

typedef struct oldnsg {
    unsigned short  Seg;            // segment index
    unsigned short  Off;            // offset of code in segment
    unsigned short  cbSeg;          // number of bytes in segment
} oldnsg;


//   old subsection module information

typedef struct oldsmd {
    oldnsg          SegInfo;        // describes first segment in module
    unsigned short  ovlNbr;         // overlay number
    unsigned short  iLib;
    unsigned char   cSeg;           // Number of segments in module
    char            reserved;
    unsigned char   cbName[1];      // length prefixed name of module
    oldnsg          arnsg[];        // cSeg-1 structures exist for alloc text or comdat code
} oldsmd;

typedef struct{
    unsigned short  Seg;
    unsigned long   Off;
    unsigned long   cbSeg;
} oldnsg32;

typedef struct {
    oldnsg32        SegInfo;        // describes first segment in module
    unsigned short  ovlNbr;         // overlay number
    unsigned short  iLib;
    unsigned char   cSeg;           // Number of segments in module
    char            reserved;
    unsigned char   cbName[1];      // length prefixed name of module
    oldnsg32        arnsg[];        // cSeg-1 structures exist for alloc text or comdat code
} oldsmd32;


// OMFSegMap - This table contains the mapping between the logical segment indices
// used in the symbol table and the physical segments where the program is loaded

typedef struct OMFSegMapFlags {
    union {
        struct {
            unsigned short      fRead   :1;
            unsigned short      fWrite  :1;
            unsigned short      fExecute:1;
            unsigned short      f32Bit  :1;
            unsigned short      res1    :4;
            unsigned short      fSel    :1;
            unsigned short      fAbs    :1;
            unsigned short      res2    :2;
            unsigned short      fGroup  :1;  // OBSOLETE - do not use, debugger will assert
            unsigned short      res3    :3;
        };
        unsigned short fAll;
    };
} OMFSegMapFlags;

typedef struct OMFSegMapDesc {
    OMFSegMapFlags  flags;          // descriptor flags bit field.
    unsigned short  ovl;            // the logical overlay number
    unsigned short  group;          // group index into the descriptor array
    unsigned short  frame;          // logical segment index - interpreted via flags
    unsigned short  iSegName;       // segment or group name - index into sstSegName
    unsigned short  iClassName;     // class name - index into sstSegName
    unsigned long   offset;         // byte offset of the logical within the physical segment
    unsigned long   cbSeg;          // byte count of the logical segment or group
} OMFSegMapDesc;

typedef struct OMFSegMap {
    unsigned short  cSeg;           // total number of segment descriptors
    unsigned short  cSegLog;        // number of logical segment descriptors
    OMFSegMapDesc   rgDesc[0];      // array of segment descriptors
} OMFSegMap;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\vctools\pdb6\langapi\include\csymbuf.h ===
#ifndef _CSYMBUF_H_
#define _CSYMBUF_H_

#pragma warning( disable: 4786 )

class FuncBuffer;
typedef PROCSYM* PPROCSYM;
typedef PROCSYM32* PPROCSYM32;

//
// SymBuffer
//  understands the representation of cv symbolic information
//  as stored in an object file section. This object supplies
//  an interpretation of an existing buffer, it does not manage
//  the memory itself.
//

class SymBuffer 
{
public:
    typedef unsigned long ULONG;
    typedef ULONG SigType;
    SymBuffer( PB pbFirst = 0, CB cb = 0 ) : m_first( 0 ), m_last( 0 ), m_start( 0 )
    {
        Reset( pbFirst, cb );
    }
    void Reset( PB pbFirst, CB cb ) // set new buffer extent
    {
        m_sigSymsT = 0;
        assert( cb >= 0 );
        if ( pbFirst > 0 ) {
      	    m_sigSymsT = *reinterpret_cast<SigType*>(pbFirst);
            if ( m_sigSymsT == CV_SIGNATURE_C11 ) {
                m_first = reinterpret_cast<PSYM>(pbFirst+sizeof(SigType));
            } else {
                m_first = reinterpret_cast<PSYM>(pbFirst);
            }
        }
        m_last = reinterpret_cast<PSYM>(pbFirst+cb);
        m_start = pbFirst;
    }

    typedef PSYM _Nodeptr;

    class iterator  // based on STL forward iterator
    {
    public:
	    iterator()
		    {}
	    iterator(_Nodeptr _P)
		    : _Ptr(_P) {}
	    SYMTYPE& operator*() const
		    {return *_Ptr; }
	    SYMTYPE* operator->() const
		    {return (&**this); }
	    iterator& operator++()
		    {_Ptr = NextSym(_Ptr);
		    return (*this); }
	    iterator operator++(int)
		    {iterator _Tmp = *this;
		    ++*this;
		    return (_Tmp); }
	    bool operator==(const iterator& _X) const
		    {return (_Ptr == _X._Ptr); }
	    bool operator!=(const iterator& _X) const
		    {return (!(*this == _X)); }
	    _Nodeptr _Mynode() const
		    {return (_Ptr); }
    private:
        _Nodeptr _Ptr;
    };

    iterator findNextProcSyms( iterator it, FuncBuffer& rfb );
    iterator findNextFileSym( iterator it );

    iterator begin() { return iterator( m_first ); }
    iterator end() { return iterator( m_last ); }
    iterator begin() const { return iterator( m_first ); }
    iterator end() const { return iterator( m_last ); }

    bool empty() const { return begin() == end(); }
    
    CB offSym( PSYM psym ) 
    { 
        return asPb(psym)-pbfirst(); 
    }
    PSYM cvsymOff( CB off )
    {
        return asPsym( pbfirst()+off );
    }
    SigType signature() { return m_sigSymsT; }

    template <class T> 
    bool findSym( int s, T** t )
    {
        for ( iterator it = begin(); it != end(); ++it ) {
            if ( it->rectyp == s ) {
                if ( t ) *t = reinterpret_cast<T*>(&*it);
                return true;
            }
        }
        return false;
    }

    template <class T> 
    bool findNextSym( int s, T** t, iterator& it )
    {
        for ( ; it != end(); ++it ) {
            if ( it->rectyp == s ) {
                if ( t ) *t = reinterpret_cast<T*>(&*it);
                return true;
            }
        }
        return false;
    }
    CB Count() { return PB( m_last ) - m_start; }
    PB Base() { return m_start; }
    virtual PB pbStart() { return m_start; }
    void updateOffsets();
    void updateTypeServer( USHORT itsm );

protected:
     _Nodeptr first() const { return m_first; }
     _Nodeptr last() const { return m_last; }
     PB pbfirst() const { return asPb(m_first); }
    static inline PB asPb( PSYM psym ) { return reinterpret_cast<PB>( psym ); }
    static inline PSYM asPsym( PB pb ) { return reinterpret_cast<PSYM>( pb ); }
   
private:
    friend FuncBuffer;
    PB m_start;
    _Nodeptr m_first;
    _Nodeptr m_last;  // actually, one past the last byte of the buffer
    SigType m_sigSymsT;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\vctools\pdb6\langapi\include\cvr.h ===
// CVR: CodeView Record utilities

#ifndef _VC_VER_INC
#include "..\include\vcver.h"
#endif

#ifndef __CVR_INCLUDED__
#define __CVR_INCLUDED__

#ifndef __PDB_INCLUDED__
#include <pdb.h>
#endif
#ifndef _CV_INFO_INCLUDED
#include <cvinfo.h>
#endif
#ifndef _INC_STDDEF
#include <stddef.h>
#endif
#ifndef _WINDOWS_
// get rid of baggage we don't need from windows.h
#if !defined(WIN32_LEAN_AND_MEAN)
#define WIN32_LEAN_AND_MEAN
#endif
//#define NOGDI
#define NOUSER
#define NONLS
#include "windows.h"
#endif

typedef BYTE* PB;
typedef long CB;
typedef char* SZ;		// zero terminated string
typedef char* ST;		// length prefixed string
typedef SYMTYPE* PSYM;
typedef SYMTYPE UNALIGNED * PSYMUNALIGNED;
typedef TYPTYPE* PTYPE;

//////////////////////////////////////////////////////////////////////////////
// TII (type index iterator) implementation declarations

typedef ptrdiff_t IB;
typedef TI*		(*PfnTyti)(PTYPE, int, PB*, PB);
typedef TI16*	(*PfnTyti16)(PTYPE, int, PB*, PB);

struct TYTI { // position of type indices within a type record with the given leaf
	unsigned leaf;
	SZ sz;						// leaf type name
	int cib;
	const IB* rgibTI;
	union {						// fn to call if cib == cibFunction
		PfnTyti 	pfn;
		PfnTyti16	pfn16;
	};
	PB  (*pfnPbAfter)(void* pv);	  // end of record fn to call for elements of a field list
};

// all pointers to a TYTI are pointing to const TYTIs
typedef const TYTI *	PTYTI;

struct SYTI { // position of symbol indices within a symbol recoord with the given rectyp
	unsigned rectyp;
	SZ sz;						// symbol rectyp name
	IB	ibName;					// position of symbol name
	ST (*pfnstName)(PSYM psym);	// function to call if name offset variable
	BOOL isGlobal;				// symbol is global
	int cib;
	const IB* rgibTI;
};

// all pointers to a SYTI are pointing to const SYTIs
typedef const SYTI *	PSYTI;

#if	defined(PDB_LIBRARY)
#define CVR_EXPORT 
#else
#if defined(CVR_IMP)
#define CVR_EXPORT	__declspec(dllexport)
#else
#define CVR_EXPORT	__declspec(dllimport)
#endif
#endif

#ifndef CVRAPI
#define CVRAPI	 __cdecl
#endif

// functions that are in widenti.cpp
unsigned __fastcall
MapLeaf16To32 ( unsigned leaf16 );

unsigned __fastcall 
MapSymRec16To32 ( unsigned rectyp16 );

// utility functions for determining if type/symbol records may/must be
// converted from 16 to 32 bits.
inline bool fIs16bitTypRec(unsigned leaf)
{
	return leaf < LF_TI16_MAX;
}

inline bool fIs16bitSymRec(unsigned rectyp)
{
	return rectyp < S_TI16_MAX;
}

inline bool fIs16bitRec(PTYPE ptype)
{
	return fIs16bitTypRec ( ptype->leaf );
}

inline bool fIs16bitRec(PSYM psym)
{
	return psym->rectyp < S_TI16_MAX;
}

inline bool fNeeds16bitConversion(PSYM psym)
{
	unsigned rectyp = psym->rectyp;
    return
		rectyp < S_TI16_MAX &&
		MapSymRec16To32(rectyp) != rectyp;
}

inline bool fNeeds16bitConversion(PTYPE ptype)
{
    unsigned leaf = ptype->leaf;
    if (leaf < LF_TI16_MAX) {
		if (leaf == LF_REFSYM) {
			return fNeeds16bitConversion(PSYM(((lfRefSym*)(&ptype->leaf))->Sym));
		}
        return MapLeaf16To32(leaf) != leaf;
    }
    return false;
}

class SymTiIter { // type indices within symbol record iterator
public:
	CVR_EXPORT	SymTiIter(PSYM psym_);
	inline TI&  rti();
	inline BOOL next();

	inline TI16& rti16();
	inline BOOL f16Ti();
	inline unsigned cti();
	inline PB pbEndRecordSansPad();

private:
	PSYM psym;			// current symbol
	int  iib;			// index of current TI in this symbol record
	PSYTI psyti;		// address of symbol->ti-info for current symbol record
};

inline TI& SymTiIter::rti()
{
	return *(TI*)((PB)psym + psyti->rgibTI[iib]);
}

inline TI16& SymTiIter::rti16()
{
	return *(TI16*)((PB)psym + psyti->rgibTI[iib]);
}

inline BOOL	SymTiIter::f16Ti()
{
	return psyti->rectyp < S_TI16_MAX;
}

inline unsigned SymTiIter::cti()
{
	return psyti->cib;
}


inline BOOL SymTiIter::next()
{
	return ++iib < psyti->cib;
}

inline PB SymTiIter::pbEndRecordSansPad()
{
	if (psyti->ibName) {
		PB	pbT = PB(psym) + psyti->ibName;
		return pbT + *pbT + 1;
	}
	else if (psyti->pfnstName) {
		PB	pbT = PB((psyti->pfnstName)(psym));
		return pbT + *pbT + 1;
	}
	else
		return 0;
}

class TypeTiIter { // type indices within type record iterator
public:
	CVR_EXPORT	TypeTiIter(TYPTYPE* ptype);

	inline TI&
	rti();
	
	CVR_EXPORT	BOOL
	next();
	
	PB
	pbFindField(unsigned leaf);

	inline TI16&
	rti16();
	
	inline BOOL
	f16Ti();

	inline PB
	pbCurField();

	inline void
	leafChanged();
	
	CVR_EXPORT	BOOL
	nextField();

	CB
	cbPadForCurField();

	PB
	pbEndCurFieldSansPad();

	CVR_EXPORT	PB
	pbEndRecordSansPad();

private:
	void
	init();

	PTYPE ptype;		// current type
	USHORT* pleaf;		// leaf part of current type
	unsigned	leaf;	// cached, aligned, no op-size override version of leaf
	PB   pbFnState;		// private state of current iterating fn (iff ptyti->cib == cibFunction)
	PB   pbEnd;			// pointer just past end of type record
	int  iib;  			// index of current TI in this type record
	BOOL isFieldList;	// TRUE if this type record is a LF_FIELDLIST
	TI*  pti;			// address of current TI
	PTYTI ptyti;		// address of type->ti-info for current type record
};

inline TI& TypeTiIter::rti()
{
	return *pti;
}

inline TI16& TypeTiIter::rti16()
{
	return *PTi16(pti);
}

inline BOOL TypeTiIter::f16Ti()
{
	return ptyti->leaf < LF_TI16_MAX;
}

inline PB TypeTiIter::pbCurField()
{
    if (isFieldList && PB(pleaf) < pbEnd)
        return PB(pleaf);
    return 0;
}

// when we widen types, we need to reset the data since we change the
// leaf value of field lists out from under the iterator
inline void TypeTiIter::leafChanged()
{
	leaf = *pleaf;
	init();
}


// utility function protos
CVR_EXPORT BOOL CVRAPI fGetSymName(PSYM psym, OUT ST* pst);
		   BOOL fSymIsGlobal(PSYM psym);
           bool fSymIsData(PSYM);
		   BOOL fGetTypeLeafName(PTYPE ptype, OUT SZ* psz);
CVR_EXPORT BOOL CVRAPI fGetSymRecTypName(PSYM psym, OUT SZ* psz);

////////////////////////////////////////////////////////////////////////////////
// Inline utility functions.

// Return the number of bytes in an ST
inline CB cbForSt(ST st)
{
	return *(PB)st + 1;
}

// Return the number of bytes the type record occupies.
//
inline CB cbForType(PTYPE ptype)
{
	return ptype->len + sizeof(ptype->len);
}

// Return a pointer to the byte just past the end of the type record.
//
inline PB pbEndType(PTYPE ptype)
{
	return (PB)ptype + cbForType(ptype);
}

// Return the number of bytes the symbol record occupies.
//
#define MDALIGNTYPE_	DWORD

inline CB cbAlign_(CB cb)
{
	return ((cb + sizeof(MDALIGNTYPE_) - 1)) & ~(sizeof(MDALIGNTYPE_) - 1);
}

inline bool fIsRefSym(PSYM psym)
{
    unsigned    rectyp = psym->rectyp;
    return rectyp == S_PROCREF || rectyp == S_DATAREF || rectyp == S_LPROCREF;
}

inline CB cbForSym(PSYMUNALIGNED psym)
{
	CB cb = psym->reclen + sizeof(psym->reclen);
	// procrefs also have a hidden length preceeded name following the record
	if (fIsRefSym(psym))
		cb += cbAlign_(cbForSt((ST)((PB)psym + cb)));
	return cb;
}

// Return a pointer to the byte just past the end of the symbol record.
//
inline PB pbEndSym(PSYM psym)
{
	return (PB)psym + cbForSym(psym);
}

inline BOOL fIntroducingVirtual ( CV_methodprop_e mprop )
{
    return mprop == CV_MTintro || mprop == CV_MTpureintro;
}

inline BOOL fVirtual ( CV_methodprop_e mprop )
{
    return
        fIntroducingVirtual ( mprop ) ||
        mprop == CV_MTvirtual ||
        mprop == CV_MTpurevirt
        ;
}


#endif // __CVR_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\vctools\pdb6\langapi\include\cvr16.h ===
// CVR: CodeView Record utilities

#if CC_CVTYPE32
#include "./cvr32.h"
#else

#ifndef _VC_VER_INC
#include "..\include\vcver.h"
#endif

#ifndef __CVR_INCLUDED__
#define __CVR_INCLUDED__

#ifndef __PDB_INCLUDED__
#include <pdb.h>
#endif
#ifndef _CV_INFO_INCLUDED
#include <cvinfo.h>
#endif
#ifndef _INC_STDDEF
#include <stddef.h>
#endif
#ifndef _WINDOWS_
// get rid of baggage we don't need from windows.h
#define WIN32_LEAN_AND_MEAN
//#define NOGDI
#define NOUSER
#define NONLS
#include "windows.h"
#endif

typedef BYTE* PB;
typedef long CB;
typedef char* SZ;		// zero terminated string
typedef char* ST;		// length prefixed string
typedef SYMTYPE* PSYM;
typedef SYMTYPE UNALIGNED * PSYMUNALIGNED;
typedef TYPTYPE* PTYPE;

//////////////////////////////////////////////////////////////////////////////
// TII (type index iterator) implementation declarations

typedef ptrdiff_t IB;

struct TYTI { // position of type indices within a type record with the given leaf
	USHORT leaf;
	SZ sz;						// leaf type name
	short cib;
	const IB* rgibTI;
	TI* (*pfn)(PTYPE ptype, int iib, PB* ppb, PB pbEnd); // fn to call if cib == cibFunction
	PB  (*pfnPbAfter)(void* pv);	  // end of record fn to call for elements of a field list
};

// all pointers to a TYTI are pointing to const TYTIs
typedef const TYTI *	PTYTI;

struct SYTI { // position of symbol indices within a symbol recoord with the given rectyp
	USHORT rectyp;
	SZ sz;						// symbol rectyp name
	IB	ibName;					// position of symbol name
	ST (*pfnstName)(PSYM psym);	// function to call if name offset variable
	BOOL  isGlobal;				// symbol is global
	short cib;
	const IB* rgibTI;
};

// all pointers to a SYTI are pointing to const SYTIs
typedef const SYTI *	PSYTI;


#if	defined(PDB_LIBRARY)
#define CVR_EXPORT
#else
#if defined(CVR_IMP)
#define CVR_EXPORT	__declspec(dllexport)
#else
#define CVR_EXPORT	__declspec(dllimport)
#endif
#endif

#ifndef CVRAPI
#define CVRAPI	 __cdecl
#endif

class SymTiIter { // type indices within symbol record iterator
public:
	CVR_EXPORT	SymTiIter(PSYM psym_);
	inline TI&  rti();
	inline BOOL next();
private:
	PSYM psym;			// current symbol
	int  iib;			// index of curren TI in this symbol record
	PSYTI psyti;		// address of symbol->ti-info for current symbol record
};

inline TI& SymTiIter::rti()
{
	return *(TI*)((PB)psym + psyti->rgibTI[iib]);
}

inline BOOL SymTiIter::next()
{
	return ++iib < psyti->cib;
}

class TypeTiIter { // type indices within type record iterator
public:
	TypeTiIter(TYPTYPE* ptype);
	inline TI& rti();
	BOOL next();
	PB pbFindField(unsigned leaf);
private:
	void init();
	BOOL nextField();

	PTYPE ptype;		// current type
	USHORT* pleaf;		// leaf part of current type
	unsigned	leaf;	// cached, aligned, no op-size override version of leaf
	PB   pbFnState;		// private state of current iterating fn (iff ptyti->cib == cibFunction)
	PB   pbEnd;			// pointer just past end of type record
	int  iib;  			// index of current TI in this type record
	BOOL isFieldList;	// TRUE if this type record is a LF_FIELDLIST
	TI*  pti;			// address of current TI
	PTYTI ptyti;		// address of type->ti-info for current type record
};

inline TI& TypeTiIter::rti()
{
	return *pti;
}

// utility function protos
CVR_EXPORT BOOL CVRAPI fGetSymName(PSYM psym, OUT ST* pst);
		   BOOL fSymIsGlobal(PSYM psym);
		   BOOL fGetTypeLeafName(PTYPE ptype, OUT SZ* psz);
CVR_EXPORT BOOL CVRAPI fGetSymRecTypName(PSYM psym, OUT SZ* psz);

////////////////////////////////////////////////////////////////////////////////
// Inline utility functions.

// Return the number of bytes in an ST
inline CB cbForSt(ST st)
{
	return *(PB)st + 1;
}

// Return the number of bytes the type record occupies.
//
inline CB cbForType(PTYPE ptype)
{
	return ptype->len + sizeof(ptype->len);
}

// Return a pointer to the byte just past the end of the type record.
//
inline PB pbEndType(PTYPE ptype)
{
	return (PB)ptype + cbForType(ptype);
}

// Return the number of bytes the symbol record occupies.
//
#define MDALIGNTYPE_	DWORD

inline CB cbAlign_(CB cb)
{
	return ((cb + sizeof(MDALIGNTYPE_) - 1)) & ~(sizeof(MDALIGNTYPE_) - 1);
}

inline CB cbForSym(PSYMUNALIGNED psym)
{
	CB cb = psym->reclen + sizeof(psym->reclen);
	// procrefs also have a hidden length preceeded name following the record
	if ((psym->rectyp == S_PROCREF) || (psym->rectyp == S_LPROCREF))
		cb += cbAlign_(cbForSt((ST)((PB)psym + cb)));
	return cb;
}

// Return a pointer to the byte just past the end of the symbol record.
//
inline PB pbEndSym(PSYM psym)
{
	return (PB)psym + cbForSym(psym);
}

#endif // CC_CVTYPE32
#endif // __CVR_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\vctools\pdb6\langapi\include\dbgoledb.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 5.01.0158 */
/* at Thu Jun 25 16:10:02 1998
 */
/* Compiler settings for dbgoledb.idl:
    Os (OptLev=s), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __dbgoledb_h__
#define __dbgoledb_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __DbgOleDB_FWD_DEFINED__
#define __DbgOleDB_FWD_DEFINED__

#ifdef __cplusplus
typedef class DbgOleDB DbgOleDB;
#else
typedef struct DbgOleDB DbgOleDB;
#endif /* __cplusplus */

#endif 	/* __DbgOleDB_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/* interface __MIDL_itf_dbgoledb_0000 */
/* [local] */ 

			/* size is 2 */

enum DBPROP_SESS
    {	DBPROP_INIT_EXE_TIMESTAMP	= 0x100L,
	DBPROP_INIT_SEARCHPATH	= DBPROP_INIT_EXE_TIMESTAMP + 1,
	DBPROP_SESS_LOADADDRESS	= DBPROP_INIT_SEARCHPATH + 1
    };
			/* size is 2 */

enum __MIDL___MIDL_itf_dbgoledb_0000_0001
    {	E_PDB_OK	= ( HRESULT  )(( unsigned long  )1 << 31 | ( unsigned long  )( LONG  )0x6d << 16 | ( unsigned long  )1),
	E_PDB_USAGE	= E_PDB_OK + 1,
	E_PDB_FILE_SYSTEM	= E_PDB_USAGE + 1,
	E_PDB_NOT_FOUND	= E_PDB_FILE_SYSTEM + 1,
	E_PDB_INVALID_SIG	= E_PDB_NOT_FOUND + 1,
	E_PDB_INVALID_AGE	= E_PDB_INVALID_SIG + 1,
	E_PDB_PRECOMP_REQUIRED	= E_PDB_INVALID_AGE + 1,
	E_PDB_OUT_OF_TI	= E_PDB_PRECOMP_REQUIRED + 1,
	E_PDB_V1_PDB	= E_PDB_OUT_OF_TI + 1,
	E_PDB_FORMAT	= E_PDB_V1_PDB + 1,
	E_PDB_LIMIT	= E_PDB_FORMAT + 1,
	E_PDB_CORRUPT	= E_PDB_LIMIT + 1,
	E_PDB_TI16	= E_PDB_CORRUPT + 1,
	E_PDB_ILLEGAL_TYPE_EDIT	= E_PDB_TI16 + 1,
	E_PDB_INVALID_EXECUTABLE	= E_PDB_ILLEGAL_TYPE_EDIT + 1,
	E_PDB_DBG_NOT_FOUND	= E_PDB_INVALID_EXECUTABLE + 1,
	E_PDB_NO_DEBUG_INFO	= E_PDB_DBG_NOT_FOUND + 1,
	E_PDB_INVALID_EXE_TIMESTAMP	= E_PDB_NO_DEBUG_INFO + 1,
	E_PDB_DEBUG_INFO_NOT_IN_PDB	= E_PDB_INVALID_EXE_TIMESTAMP + 1
    };
			/* size is 2 */

enum SymTagEnum
    {	SymTagNull	= 0,
	SymTagExe	= SymTagNull + 1,
	SymTagCompiland	= SymTagExe + 1,
	SymTagFunctionSymbol	= SymTagCompiland + 1,
	SymTagBlockBegin	= SymTagFunctionSymbol + 1,
	SymTagBlockEnd	= SymTagBlockBegin + 1,
	SymTagData	= SymTagBlockEnd + 1,
	SymTagConstant	= SymTagData + 1,
	SymTagLabel	= SymTagConstant + 1,
	SymTagPublicSymbol	= SymTagLabel + 1,
	SymTagUDT	= SymTagPublicSymbol + 1,
	SymTagEnum	= SymTagUDT + 1,
	SymTagFunctionType	= SymTagEnum + 1,
	SymTagPointerType	= SymTagFunctionType + 1,
	SymTagArrayType	= SymTagPointerType + 1,
	SymTagBaseType	= SymTagArrayType + 1,
	SymTagTypedef	= SymTagBaseType + 1,
	SymTagFunctionArgType	= SymTagTypedef + 1,
	SymTagFuncDebugStart	= SymTagFunctionArgType + 1,
	SymTagFuncDebugEnd	= SymTagFuncDebugStart + 1,
	SymTagCustom	= SymTagFuncDebugEnd + 1,
	SymTagMax	= SymTagCustom + 1
    };
			/* size is 2 */

enum LocationType
    {	LocIsStatic	= 0,
	LocIsTLS	= LocIsStatic + 1,
	LocIsRegRel	= LocIsTLS + 1,
	LocIsThisRel	= LocIsRegRel + 1,
	LocIsEnregistered	= LocIsThisRel + 1,
	LocIsBitField	= LocIsEnregistered + 1,
	LocTypeMax	= LocIsBitField + 1
    };
			/* size is 2 */

enum AccessSpecifier
    {	ASPublic	= 0,
	ASPrivate	= ASPublic + 1,
	ASProtect	= ASPrivate + 1
    };
			/* size is 2 */

enum FuncLanguageEnum
    {	FuncLanguageC	= 0,
	FuncLanguageCPlus	= FuncLanguageC + 1,
	FuncLanguageBasic	= FuncLanguageCPlus + 1,
	FuncLanguageFortran	= FuncLanguageBasic + 1,
	FuncLanguagePascal	= FuncLanguageFortran + 1,
	FuncLanguageJava	= FuncLanguagePascal + 1
    };
			/* size is 2 */

enum FuncThunkOrdinal
    {	FuncTONotAThunk	= 0,
	FuncTONoType	= FuncTONotAThunk + 1,
	FuncTOAdjustor	= FuncTONoType + 1,
	FuncTOVCall	= FuncTOAdjustor + 1,
	FuncTOPcode	= FuncTOVCall + 1,
	FuncTODelayLoad	= FuncTOPcode + 1
    };
			/* size is 2 */

enum BasicType
    {	btNoType	= 0,
	btVoid	= btNoType + 1,
	btChar	= btVoid + 1,
	btWChar	= btChar + 1,
	btSChar	= btWChar + 1,
	btUChar	= btSChar + 1,
	btInt	= btUChar + 1,
	btUInt	= btInt + 1,
	btFloat	= btUInt + 1,
	btBCD	= btFloat + 1,
	btBool	= btBCD + 1,
	btShort	= btBool + 1,
	btUShort	= btShort + 1,
	btLong	= btUShort + 1,
	btULong	= btLong + 1,
	btInt8	= btULong + 1,
	btInt16	= btInt8 + 1,
	btInt32	= btInt16 + 1,
	btInt64	= btInt32 + 1,
	btInt128	= btInt64 + 1,
	btUInt8	= btInt128 + 1,
	btUInt16	= btUInt8 + 1,
	btUInt32	= btUInt16 + 1,
	btUInt64	= btUInt32 + 1,
	btUInt128	= btUInt64 + 1,
	btCurrency	= btUInt128 + 1,
	btDate	= btCurrency + 1,
	btVariant	= btDate + 1,
	btComplex	= btVariant + 1,
	btBit	= btComplex + 1,
	btBSTR	= btBit + 1
    };
			/* size is 2 */

enum FunctionCallingConvention
    {	fccCdecl	= 0,
	fccStdcall	= fccCdecl + 1,
	fccFastcall	= fccStdcall + 1,
	fccThiscall	= fccFastcall + 1,
	fccPascal	= fccThiscall + 1,
	fccSyscall	= fccPascal + 1,
	fccCorcall	= fccSyscall + 1,
	fccMipsCall	= fccCorcall + 1,
	fccGeneric	= fccMipsCall + 1,
	fccAlpha	= fccGeneric + 1,
	fccPPC	= fccAlpha + 1,
	fccSHcall	= fccPPC + 1,
	fccArmcall	= fccSHcall + 1,
	fccUnknown	= fccArmcall + 1
    };


extern RPC_IF_HANDLE __MIDL_itf_dbgoledb_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dbgoledb_0000_v0_0_s_ifspec;


#ifndef __DBGOLEDBLib_LIBRARY_DEFINED__
#define __DBGOLEDBLib_LIBRARY_DEFINED__

/* library DBGOLEDBLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_DBGOLEDBLib;

EXTERN_C const CLSID CLSID_DbgOleDB;

#ifdef __cplusplus

class DECLSPEC_UUID("4072ED30-BEA4-11D1-AC7E-00A0C90D2884")
DbgOleDB;
#endif
#endif /* __DBGOLEDBLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\vctools\pdb6\langapi\include\ehdata.h ===
/***
*ehdata.h -
*
*	Copyright (c) 1993-1995, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	Declare misc. types, macros, etc. for implementation
*	of C++ Exception Handling for the run-time and the compiler.
*	Hardware independent, assumes Windows NT.
*
* Portions of this header file can be disabled by defining the following
* macros:
*	_EHDATA_NOHEADERS - suppresses inclusion of standard header files
*		If this is specified, then appropriate typedefs or macros must
*		be provided by some other means.
*	_EHDATA_NOTHROW - suppresses definitions used only to describe a throw
*	_EHDATA_NOFUNCINFO - suppresses definitions for the frame descriptor
*	_EHDATA_NONT - suppresses definitions of our version of NT's stuff
*
* Other conditional compilation macros:
*    CC_EXPLICITFRAME - if true, representation of registration node includes
*	the value of the frame-pointer for that frame, making the location
*	of the registration node on the frame flexible.  This is intended
*	primarily for early testing.
*
*       [Internal]
*
*Revision History:
*       05-20-93  BS	Module Created.
*	03-01-94  CFW	Remove CONTEXT def for x86 for TiborL.
*	03-03-94  TL	Mips (_M_MRX000 >= 4000) changes
*	09-02-94  SKS	This header file added.
*	09-12-94  GJF	Merged in changes from/for DEC (Al Doser, dated 6/20,
*			and Bill Baxter, dated 6/28).
*	11-06-94  GJF	Changed pack pragma to 8 byte alignment.
*       02-14-95  CFW   Clean up Mac merge.
*       03-22-95  PML   Add const for read-only structs
*       03-29-95  CFW   Add error message to internal headers.
*	04-14-95  JWM	Added EH_ABORT_FRAME_UNWIND_PART for EH/SEH exception handling.
*	04-20-95  TGL	Added iFrameNestLevel field to MIPS FuncInfo
*	04-27-95  JWM	EH_ABORT_FRAME_UNWIND_PART now #ifdef ALLOW_UNWIND_ABORT.
*	06-08-95  JWM	Merged CRT version of ehdata.h into langapi source.
*
****/

#ifndef _INC_EHDATA
#define _INC_EHDATA

#ifndef _CRTBLD
#ifndef _VC_VER_INC
#ifdef _M_ALPHA
#include "vcver.h"
#else
#include "..\include\vcver.h"
#endif
#endif
#endif /* _CRTBLD */


#if _M_IX86 >= 300 /*IFSTRIP=IGN*/
# ifndef CC_EXPLICITFRAME
#  define CC_EXPLICITFRAME	0	// If non-zero, we're using a hack version of the
								// registration node.
# endif
#endif

#ifndef _EHDATA_NOHEADERS
#include <stddef.h>
#include <excpt.h>
#if defined(_WIN32)
#include <windows.h>
#else
#include <nowin.h>
#endif
#endif /* _EHDATA_NOHEADERS */

#pragma pack(push, ehdata, 4)

#define EH_EXCEPTION_NUMBER	('msc' | 0xE0000000)	// The NT Exception # that we use
#define EH_MAGIC_NUMBER1	0x19930520		// The magic # identifying this version
							// As magic numbers increase, we have to keep track of
							// the versions that we are backwards compatible with.
#define EH_EXCEPTION_PARAMETERS 3			// Number of parameters in exception record

#ifdef ALLOW_UNWIND_ABORT
#define EH_ABORT_FRAME_UNWIND_PART EH_EXCEPTION_NUMBER+1
#endif

//
// PMD - Pointer to Member Data: generalized pointer-to-member descriptor
//

typedef struct PMD
{
	ptrdiff_t	mdisp;		// Offset of intended data within base
	ptrdiff_t	pdisp;		// Displacement to virtual base pointer
	ptrdiff_t	vdisp;		// Index within vbTable to offset of base
	} PMD;

//
// PMFN - Pointer to Member Function
//			M00REVIEW: we may need something more than this, but this will do for now.
//

#if defined(_M_IA64)	 /*IFSTRIP=IGN*/
typedef void (*PMFN)(void*);
#else
typedef void (*PMFN)(void);
#endif

//
// TypeDescriptor - per-type record which uniquely identifies the type.
//
// Each type has a decorated name which uniquely identifies it, and a hash
// value which is computed by the compiler.  The hash function used is not
// important; the only thing which is essential is that it be the same for
// all time.
//
// The special type '...' (ellipsis) is represented by a null name.
//
#pragma warning(disable:4200)		// get rid of obnoxious nonstandard extension warning

typedef struct TypeDescriptor
{
#if _RTTI
	const void *	pVFTable;	// Field overloaded by RTTI
#else
	DWORD	hash;			// Hash value computed from type's decorated name
#endif
	void *	spare;			// reserved, possible for RTTI
	char	name[];			// The decorated name of the type; 0 terminated.
	} TypeDescriptor;
#pragma warning(default:4200)

#define TD_HASH(td)		((td).hash)
#define TD_NAME(td)		((td).name)

#define TD_IS_TYPE_ELLIPSIS(td) ((td == NULL) || (TD_NAME(*td)[0] == '\0'))


#ifndef _EHDATA_NOTHROW

/////////////////////////////////////////////////////////////////////////////
//
// Description of the thrown object.  (M00REVIEW: not final)
//
// This information is broken down into three levels, to allow for maximum
// comdat folding (at the cost of some extra pointers).
//
// ThrowInfo is the head of the description, and contains information about
// 				the particular variant thrown.
// CatchableTypeArray is an array of pointers to type descriptors.  It will
//				be shared between objects thrown by reference but with varying
//				qualifiers.
// CatchableType is the description of an individual type, and how to effect
//				the conversion from a given type.
//
//---------------------------------------------------------------------------


//
// CatchableType - description of a type that can be caught.
//
// Note:  although isSimpleType can be part of ThrowInfo, it is more
//		  convenient for the run-time to have it here.
//

typedef const struct _s_CatchableType {
	unsigned int	properties;				// Catchable Type properties (Bit field)
	TypeDescriptor *pType;					// Pointer to the type descriptor for this type
	PMD 			thisDisplacement;		// Pointer to instance of catch type within
											//		thrown object.
	int				sizeOrOffset;			// Size of simple-type object or offset into
											//  buffer of 'this' pointer for catch object
	PMFN			copyFunction;			// Copy constructor or CC-closure
} CatchableType;

#define CT_IsSimpleType			0x00000001		// type is a simple type
#define CT_ByReferenceOnly		0x00000002		// type must be caught by reference
#define CT_HasVirtualBase		0x00000004		// type is a class with virtual bases

#define CT_PROPERTIES(ct)	((ct).properties)
#define CT_PTD(ct)			((ct).pType)
#define CT_THISDISP(ct)		((ct).thisDisplacement)
#define CT_SIZE(ct)			((ct).sizeOrOffset)
#define CT_COPYFUNC(ct)		((ct).copyFunction)
#define CT_OFFSET(ct)		((ct).sizeOrOffset)
#define CT_HASH(ct)			(TD_HASH(*CT_PTD(ct)))
#define CT_NAME(ct)			(TD_NAME(*CT_PTD(ct)))

#define SET_CT_ISSIMPLETYPE(ct)		(CT_PROPERTIES(ct) |= CT_IsSimpleType)
#define SET_CT_BYREFONLY(ct)		(CT_PROPERTIES(ct) |= CT_ByReferenceOnly)
#define SET_CT_HASVB(ct)			(CT_PROPERTIES(ct) |= CT_HasVirtualBase)

#define CT_ISSIMPLETYPE(ct)			(CT_PROPERTIES(ct) & CT_IsSimpleType)		// Is it a simple type?
#define CT_BYREFONLY(ct)			(CT_PROPERTIES(ct) & CT_ByReferenceOnly)	// Must it be caught by reference?
#define CT_HASVB(ct)				(CT_PROPERTIES(ct) & CT_HasVirtualBase)		// Is this type a class with virtual bases?

//
// CatchableTypeArray - array of pointers to catchable types, with length
//
#pragma warning(disable:4200)		// get rid of obnoxious nonstandard extension warning
typedef const struct _s_CatchableTypeArray {
	int	nCatchableTypes;
	CatchableType	*arrayOfCatchableTypes[];
	} CatchableTypeArray;
#pragma warning(default:4200)

//
// ThrowInfo - information describing the thrown object, staticly built
// at the throw site.
//
// pExceptionObject (the dynamic part of the throw; see below) is always a
// reference, whether or not it is logically one.  If 'isSimpleType' is true,
// it is a reference to the simple type, which is 'size' bytes long.  If
// 'isReference' and 'isSimpleType' are both false, then it's a UDT or
// a pointer to any type (ie pExceptionObject points to a pointer).  If it's
// a pointer, copyFunction is NULL, otherwise it is a pointer to a copy
// constructor or copy constructor closure.
//
// The pForwardCompat function pointer is intended to be filled in by future
// versions, so that if say a DLL built with a newer version (say C10) throws,
// and a C9 frame attempts a catch, the frame handler attempting the catch (C9)
// can let the version that knows all the latest stuff do the work.
//

typedef const struct _s_ThrowInfo {
	unsigned int	attributes;			// Throw Info attributes (Bit field)
	PMFN			pmfnUnwind;			// Destructor to call when exception
										// has been handled or aborted.

	int	(__cdecl*pForwardCompat)(...);	// Forward compatibility frame handler

	CatchableTypeArray	*pCatchableTypeArray;	// Pointer to list of pointers to types.
} ThrowInfo;

#define TI_IsConst			0x00000001		// thrown object has const qualifier
#define TI_IsVolatile		0x00000002		// thrown object has volatile qualifier
#define TI_IsUnaligned		0x00000004		// thrown object has unaligned qualifier

#define THROW_ATTRS(t)			((t).attributes)
#define THROW_UNWINDFUNC(t)		((t).pmfnUnwind)
#define THROW_FORWARDCOMPAT(t)	((t).pForwardCompat)
#define THROW_COUNT(t)			((t).pCatchableTypeArray->nCatchableTypes)
#define THROW_CTLIST(t)			((t).pCatchableTypeArray->arrayOfCatchableTypes)
#define THROW_PCTLIST(t)		(&THROW_CTLIST(t))
#define THROW_CT(t, n)			(*THROW_CTLIST(t)[n])
#define THROW_PCT(t, n)			(THROW_CTLIST(t)[n])

#define SET_TI_ISCONST(t)		(THROW_ATTRS(t) |= TI_IsConst)		// Is the object thrown 'const' qualified
#define SET_TI_ISVOLATILE(t)	(THROW_ATTRS(t) |= TI_IsVolatile)	// Is the object thrown 'volatile' qualified
#define SET_TI_ISUNALIGNED(t)	(THROW_ATTRS(t) |= TI_IsUnaligned)	// Is the object thrown 'unaligned' qualified

#define THROW_ISCONST(t)		(THROW_ATTRS(t) & TI_IsConst)
#define THROW_ISVOLATILE(t)		(THROW_ATTRS(t) & TI_IsVolatile)
#define THROW_ISUNALIGNED(t)	(THROW_ATTRS(t) & TI_IsUnaligned)

//
// Here's how to throw:
// M00HACK: _ThrowInfo is the name of the type that is 'pre-injected' into the
// compiler; since this prototype is known to the FE along with the pre-injected
// types, it has to match exactly.
//
#if _MSC_VER >= 900 /*IFSTRIP=IGN*/
extern "C" void __stdcall _CxxThrowException(void* pExceptionObject, _ThrowInfo* pThrowInfo);
#else
// If we're not self-building, we need to use the name that we defined above.
extern "C" void __stdcall _CxxThrowException(void* pExceptionObject, ThrowInfo* pThrowInfo);
#endif

#endif /* _EHDATA_NOTHROW */


#ifndef _EHDATA_NOFUNCINFO

/////////////////////////////////////////////////////////////////////////////
//
// Describing 'try/catch' blocks:
//
//---------------------------------------------------------------------------

//
// Current state of a function.
// -1 is the 'blank' state, ie there is nothing to unwind, no try blocks active.
//

typedef int __ehstate_t;		// The type of a state index

#define EH_EMPTY_STATE	-1


//
// HandlerType - description of a single 'catch'
//

typedef const struct _s_HandlerType {
	unsigned int	adjectives;			// Handler Type adjectives (bitfield)
#if defined(_M_IA64)	 /*IFSTRIP=IGN*/
	__int32			dispType;			// Image relative offset of the corresponding type descriptor
#else
	TypeDescriptor	*pType;				// Pointer to the corresponding type descriptor
#endif
	ptrdiff_t		dispCatchObj;		// Displacement of catch object from base
										//		of current stack frame.
#if _M_MRX000 >= 4000	 /*IFSTRIP=IGN*/
	ULONG			frameNestLevel;		// The static nesting level of parent function
#endif
#if defined(_M_IA64)	 /*IFSTRIP=IGN*/
	__int32			dispOfHandler;		// Image relative offset of 'catch' code
#else
	void *			addressOfHandler;	// Address of 'catch' code
#endif
} HandlerType;

#define HT_IsConst			0x00000001		// type referenced is 'const' qualified
#define HT_IsVolatile		0x00000002		// type referenced is 'volatile' qualified
#define HT_IsUnaligned		0x00000004		// type referenced is 'unaligned' qualified
#define HT_IsReference		0x00000008		// catch type is by reference
#define HT_IsResumable		0x00000010		// the catch may choose to resume (Reserved)

#define HT_ADJECTIVES(ht)		((ht).adjectives)
#if defined(_M_IA64)	 /*IFSTRIP=IGN*/
#define HT_PTD_IB(ht,ib)		((TypeDescriptor*)((ib) + (ht).dispType))
#define HT_PTD(ht,ib)			((TypeDescriptor*)((ht).dispType? HT_PTD_IB(ht,ib):NULL))
#define HT_HANDLER(ht)			((ht).dispOfHandler)
#else
#define HT_PTD(ht)				((ht).pType)
#define HT_HANDLER(ht)			((ht).addressOfHandler)
#endif
#define HT_DISPCATCH(ht)		((ht).dispCatchObj)
#if _M_MRX000 >= 4000	 /*IFSTRIP=IGN*/
#define HT_FRAMENEST(ht)		((ht).frameNestLevel)
#endif
#define HT_NAME(ht)				(TD_NAME(*HT_PTD(ht)))
#define HT_HASH(ht)				(TD_HASH(*HT_PTD(ht)))
#define HT_IS_TYPE_ELLIPSIS(ht)	TD_IS_TYPE_ELLIPSIS(HT_PTD(ht))

#define SET_HT_ISCONST(ht)		(HT_ADJECTIVES(ht) |= HT_IsConst)
#define SET_HT_ISVOLATILE(ht)	(HT_ADJECTIVES(ht) |= HT_IsVolatile)
#define SET_HT_ISUNALIGNED(ht)	(HT_ADJECTIVES(ht) |= HT_IsUnaligned)
#define SET_HT_ISREFERENCE(ht)	(HT_ADJECTIVES(ht) |= HT_IsReference)
#define SET_HT_ISRESUMABLE(ht)	(HT_ADJECTIVES(ht) |= HT_IsResumable)

#define HT_ISCONST(ht)			(HT_ADJECTIVES(ht) & HT_IsConst)		// Is the type referenced 'const' qualified
#define HT_ISVOLATILE(ht)		(HT_ADJECTIVES(ht) & HT_IsVolatile)		// Is the type referenced 'volatile' qualified
#define HT_ISUNALIGNED(ht)		(HT_ADJECTIVES(ht) & HT_IsUnaligned)	// Is the type referenced 'unaligned' qualified
#define HT_ISREFERENCE(ht)		(HT_ADJECTIVES(ht) & HT_IsReference)	// Is the catch type by reference
#define HT_ISRESUMABLE(ht)		(HT_ADJECTIVES(ht) & HT_IsResumable)	// Might the catch choose to resume (Reserved)

//
// HandlerMapEntry - associates a handler list (sequence of catches) with a
//	range of eh-states.
//

typedef const struct _s_TryBlockMapEntry {
	__ehstate_t	tryLow;				// Lowest state index of try
	__ehstate_t	tryHigh;			// Highest state index of try
#if !defined(_M_ALPHA)
	__ehstate_t	catchHigh;			// Highest state index of any associated catch
#endif
	int			nCatches;			// Number of entries in array
#if defined(_M_IA64)	/*IFSTRIP=IGN*/
	__int32		dispHandlerArray;	// Image relative offset of list of handlers for this try
#else
	HandlerType *pHandlerArray;		// List of handlers for this try
#endif
} TryBlockMapEntry;

#define TBME_LOW(hm)		((hm).tryLow)
#define TBME_HIGH(hm)		((hm).tryHigh)
#define TBME_CATCHHIGH(hm)	((hm).catchHigh)
#define TBME_NCATCHES(hm)	((hm).nCatches)
#if defined(_M_IA64)	/*IFSTRIP=IGN*/
#define TBME_PLIST(hm,ib)	((HandlerType*)((ib) + (hm).dispHandlerArray))
#define TBME_CATCH(hm,n,ib)	(TBME_PLIST(hm,ib)[n])
#define TBME_PCATCH(hm,n,ib)(&(TBME_PLIST(hm,ib)[n]))
#else
#define TBME_PLIST(hm)		((hm).pHandlerArray)
#define TBME_CATCH(hm, n)	(TBME_PLIST(hm)[n])
#define TBME_PCATCH(hm, n)	(&(TBME_PLIST(hm)[n]))
#endif


/////////////////////////////////////////////////////////////////////////////
//
// Description of the function:
//
//---------------------------------------------------------------------------

//
// UnwindMapEntry - Description of each state transition for unwinding
//	the stack (ie destructing objects).
//
// The unwind map is an array, indexed by current state.  Each entry specifies
// the state to go to during unwind, and the action required to get there.
// Note that states are represented by a signed integer, and that the 'blank'
// state is -1 so that the array remains 0-based (because by definition there
// is never any unwind action to be performed from state -1).  It is also
// assumed that state indices will be dense, ie that there will be no gaps of
// unused state indices in a function.
//

typedef const struct _s_UnwindMapEntry {
	__ehstate_t		toState;			// State this action takes us to
#if defined(_M_IA64)	/*IFSTRIP=IGN*/
	__int32			action;				// Image relative offset of funclet
#else
	void			(*action)(void);	// Funclet to call to effect state change
#endif
} UnwindMapEntry;

#define UWE_TOSTATE(uwe)	((uwe).toState)
#define UWE_ACTION(uwe)		((uwe).action)

#if _M_MRX000 >= 4000 || defined(_M_MPPC) || defined(_M_PPC) || defined(_M_IA64)	 /*IFSTRIP=IGN*/
typedef struct IptoStateMapEntry {
#if defined(_M_IA64)	/*IFSTRIP=IGN*/
	__int32		Ip;		// Image relative offset of IP
#else
	ULONG		Ip;
#endif
	__ehstate_t	State;
} IptoStateMapEntry;
#endif

//
// FuncInfo - all the information that describes a function with exception
//	handling information.
//

typedef const struct _s_FuncInfo
{
	unsigned int		magicNumber;		// Identifies version of compiler
	__ehstate_t			maxState;			// Highest state number plus one (thus
											// number of entries in unwind map)
#if defined(_M_IA64)	/*IFSTRIP=IGN*/
	__int32				dispUnwindMap;		// Image relative offset of the unwind map
	unsigned int		nTryBlocks;			// Number of 'try' blocks in this function
	__int32				dispTryBlockMap;	// Image relative offset of the handler map
	unsigned int		nIPMapEntries;		// # entries in the IP-to-state map. NYI (reserved)
	__int32				dispIPtoStateMap;	// Image relative offset of the IP to state map
	ptrdiff_t			dispUwindHelp;		// Displacement of unwind helpers from base
#else
	UnwindMapEntry		*pUnwindMap;		// Where the unwind map is
	unsigned int		nTryBlocks;			// Number of 'try' blocks in this function
	TryBlockMapEntry	*pTryBlockMap;		// Where the handler map is
#if defined(_M_ALPHA)
    signed int          EHContextDelta;     // Frame offset of EHContext record
#endif
	unsigned int		nIPMapEntries;		// # entries in the IP-to-state map. NYI (reserved)
#if _M_MRX000 >= 4000	 /*IFSTRIP=IGN*/
	IptoStateMapEntry	*pIPtoStateMap;     // An IP to state map..
	ptrdiff_t			dispUnwindHelp;		// Displacement of unwind helpers from base
	int					iTryBlockIndex;		// Used by catch functions only
	int					iFrameNestLevel;	// The static nesting level of parent function
#elif defined(_M_MPPC) || defined(_M_PPC)
	IptoStateMapEntry	*pIPtoStateMap;		// An IP to state map..
#else
	void				*pIPtoStateMap;		// An IP to state map.  NYI (reserved).
#endif
#endif
} FuncInfo;

#define FUNC_MAGICNUM(fi)			((fi).magicNumber)
#define FUNC_MAXSTATE(fi)		((fi).maxState)
#define FUNC_NTRYBLOCKS(fi)		((fi).nTryBlocks)
#define FUNC_NIPMAPENT(fi)		((fi).nIPMapEntries)
#if defined(_M_IA64)
#define FUNC_PUNWINDMAP(fi,ib)	((UnwindMapEntry*)((ib) + (fi).dispUnwindMap))
#define FUNC_PHANDLERMAP(fi,ib)	((TryBlockMapEntry*)((ib) + (fi).dispTryBlockMap))
#define FUNC_IPMAP(fi,ib)		((IptoStateMapEntry*)((ib) + (fi).dispIPtoStateMap))
#define FUNC_UNWIND(fi,st,ib)	(FUNC_PUNWINDMAP(fi,ib)[st])
#define FUNC_PUNWIND(fi,st,ib)	(&FUNC_UNWIND(fi,st,ib))
#define FUNC_TRYBLOCK(fi,n,ib)	(FUNC_PHANDLERMAP(fi,ib)[n])
#define FUNC_PTRYBLOCK(fi,n,ib)	(&FUNC_TRYBLOCK(fi,n,ib))
#else
#define FUNC_PUNWINDMAP(fi)		((fi).pUnwindMap)
#define FUNC_PHANDLERMAP(fi)	((fi).pTryBlockMap)
#define FUNC_IPMAP(fi)			((fi).pIPtoStateMap)
#define FUNC_UNWIND(fi, st)		((fi).pUnwindMap[st])
#define FUNC_PUNWIND(fi, st)	(&FUNC_UNWIND(fi, st))
#define FUNC_TRYBLOCK(fi,n)		((fi).pTryBlockMap[n])
#define FUNC_PTRYBLOCK(fi,n)	(&FUNC_TRYBLOCK(fi, n))
#endif
#if defined(_M_ALPHA)
#define FUNC_EHCONTEXTDELTA(fi) ((fi).EHContextDelta)
#endif
#if _M_MRX000 >= 4000		 /*IFSTRIP=IGN*/
#define FUNC_IPTOSTATE(fi,n)	((fi).pIPtoStateMap[n])
#define FUNC_PIPTOSTATE(fi,n)	(&FUNC_IPTOSTATE(fi,n))
#define FUNC_DISPUNWINDHELP(fi)	((fi).dispUnwindHelp)
#define FUNC_TRYBLOCKINDEX(fi)	((fi).iTryBlockIndex)
#define FUNC_FRAMENEST(fi)		((fi).iFrameNestLevel)
#elif defined(_M_MPPC) || defined(_M_PPC)
#define FUNC_IPTOSTATE(fi,n)	((fi).pIPtoStateMap[n])
#define FUNC_PIPTOSTATE(fi,n)	(&FUNC_IPTOSTATE(fi,n))
#elif defined(_M_IA64)
#define FUNC_IPTOSTATE(fi,n,ib)	(FUNC_IPMAP(fi,ib)[n])
#define FUNC_PIPTOSTATE(fi,n,ib)(&FUNC_IPTOSTATE(fi,n,ib))
#define FUNC_DISPUNWINDHELP(fi)	((fi).dispUwindHelp)
#else
#define FUNC_IPTOSTATE(fi,n) 	__ERROR_NYI__
#endif

#endif /* _EHDATA_NOFUNCINFO */

#ifndef _EHDATA_NONT

/////////////////////////////////////////////////////////////////////////////
//
// Data types that are variants of data used by NT (and Chicago) to manage
// exception handling.
//
//---------------------------------------------------------------------------

/////////////////////////////////////////////////////////////////////////////
//
// A stack registration node (i386 only)
//

#if _M_IX86 >= 300 /*IFSTRIP=IGN*/
struct EHRegistrationNode {
	/* void *			stackPtr */		// Stack ptr at entry to try (below address point)
	EHRegistrationNode	*pNext;			// Next node in the chain
	void *				frameHandler;	// The handler function for this frame
	__ehstate_t			state;			// The current state of this function
#if CC_EXPLICITFRAME
	void *				frame;			// Value of ebp for this frame
#endif
};

#if !CC_EXPLICITFRAME
				// Cannonical offset
# define FRAME_OFFSET	sizeof(EHRegistrationNode)
#endif

#define PRN_NEXT(prn)		((prn)->pNext)
#define PRN_HANDLER(prn)	((prn)->frameHandler)
#define PRN_STATE(prn)		((prn)->state)
#define PRN_STACK(prn)		(((void**)(prn))[-1])
#if CC_EXPLICITFRAME
# define PRN_FRAME(prn)		((prn)->frame)
#else
# define PRN_FRAME(prn)		((void*)(((char*)prn) + FRAME_OFFSET))
#endif

typedef void DispatcherContext;		// Meaningless on Intel

#elif _M_MRX000 >= 4000 /*IFSTRIP=IGN*/
//
// On MIPS we don't have a registration node, just a pointer to the stack frame base
//
typedef ULONG EHRegistrationNode;

#define PRN_NEXT(prn)		__ERROR__
#define PRN_HANDLER(prn)	__ERROR__
#define PRN_STATE(prn)		__ERROR__
#define PRN_STACK(prn)		__ERROR__
#define PRN_FRAME(prn)		__ERROR__

#define FRAME_OFFSET		0
#if !defined(_NTSUBSET_)
typedef struct _RUNTIME_FUNCTION {
    ULONG BeginAddress;
    ULONG EndAddress;
    EXCEPTION_DISPOSITION (*ExceptionHandler)();
    PVOID HandlerData;
    ULONG PrologEndAddress;
} RUNTIME_FUNCTION, *PRUNTIME_FUNCTION;
#endif

typedef struct _xDISPATCHER_CONTEXT {
    ULONG ControlPc;
    PRUNTIME_FUNCTION FunctionEntry;
    ULONG EstablisherFrame;
    PCONTEXT ContextRecord;
} DispatcherContext;					// changed the case of the name to conform to EH conventions

#elif defined(_M_IA64) /*IFSTRIP=IGN*/

#define PRN_NEXT(prn)		__ERROR__
#define PRN_HANDLER(prn)	__ERROR__
#define PRN_STATE(prn)		__ERROR__
#define PRN_STACK(prn)		__ERROR__
#define PRN_FRAME(prn)		__ERROR__

#define FRAME_OFFSET		0

typedef struct _FRAME_POINTERS {
    __int64 MemoryStackFp;                     // memory stack frame pointer
    __int64 BackingStoreFp;                    // backing store frame pointer
} FRAME_POINTERS, *PFRAME_POINTERS;

#if !defined(_NTSUBSET_)
typedef struct _UNWIND_INFO {
    unsigned __int16 Version;                  // Version Number
    unsigned __int16 Flags;                    // Flags
    unsigned __int32 DataLength;               // Length of Descriptor Data
} UNWIND_INFO, *PUNWIND_INFO;

typedef struct _RUNTIME_FUNCTION {             
    unsigned __int32 BeginAddress;             // image relative offset to start of function
    unsigned __int32 EndAddress;               // image relative offset to end of function
    unsigned __int32 UnwindInfoAddress;        // image relative offset to unwind info block
} RUNTIME_FUNCTION, *PRUNTIME_FUNCTION;
#endif

typedef struct _xDISPATCHER_CONTEXT {
    FRAME_POINTERS EstablisherFrame;
    __int64 ControlPc;
    __int64 ImageBase;
    PRUNTIME_FUNCTION FunctionEntry;
    PCONTEXT ContextRecord;
} DispatcherContext;					// changed the case of the name to conform to EH conventions


//
// On P7 we don't have a registration node, just a pointer to the stack frame base
//
typedef FRAME_POINTERS EHRegistrationNode;

#elif defined(_M_ALPHA)
//
// On Alpha we don't have a registration node,
//     just a pointer to the stack frame base
//
typedef ULONG EHRegistrationNode;

#define PRN_NEXT(prn)           __ERROR__
#define PRN_HANDLER(prn)        __ERROR__
#define PRN_STATE(prn)          __ERROR__
#define PRN_STACK(prn)          __ERROR__
#define PRN_FRAME(prn)          __ERROR__

#define FRAME_OFFSET            0
#if !defined(_NTSUBSET_)
typedef struct _RUNTIME_FUNCTION {
    ULONG BeginAddress;
    ULONG EndAddress;
    EXCEPTION_DISPOSITION (*ExceptionHandler)();
    PVOID HandlerData;    // ptr to FuncInfo record
    ULONG PrologEndAddress;
} RUNTIME_FUNCTION, *PRUNTIME_FUNCTION;
#endif

typedef struct _xDISPATCHER_CONTEXT {
    ULONG ControlPc;
    PRUNTIME_FUNCTION FunctionEntry;
    ULONG EstablisherFrame;  // Virtual Frame Pointer
    PCONTEXT ContextRecord;
} DispatcherContext;            // changed the case of the name to conform to EH conventions

//
// _EHCONTEXT is a struct built in the frame by the compiler.
// On entry to a function, compiler generated code stores the
// address of the base of the fixed frame area (the so-called
// Real Frame Pointer) into the Rfp. On every state transition,
// compiler generated code stores the current state index into
// the State field.
//
// The FuncInfo record for the function contains the offset of
// the _EHCONTEXT record from the Virtual Frame Pointer - a
// pointer to the highest address of the frame so this offset
// is negative (frames grow down in the address space).
//
typedef struct _EHCONTEXT {
    ULONG State;
    PVOID Rfp;
} EHContext;

#define VIRTUAL_FP(pDC) (pDC->EstablisherFrame)

#define REAL_FP(VirtualFP, pFuncInfo)           \
    (((EHContext *)((char *)VirtualFP           \
     + pFuncInfo->EHContextDelta)) -> Rfp)

#define EH_STATE(VirtualFP, pFuncInfo)          \
    (((EHContext *)((char *)VirtualFP           \
     + pFuncInfo->EHContextDelta)) -> State)

#elif defined(_M_M68K)
struct EHRegistrationNode {
/*	void * 				_sp;			// The stack pointer for the entry of try/catch	*/
	void *				frameHandler;	// The handler function for this frame
	__ehstate_t			state;			// The current state of this function
};

#define PRN_HANDLER(prn)	((prn)->frameHandler)
#define PRN_STATE(prn)		((prn)->state)

typedef void DispatcherContext;		// Meaningless on Mac


#elif defined(_M_PPC) || defined(_M_MPPC)
//
// On PowerPC we don't have a registration node, just a pointer to the stack
// frame base
//
typedef ULONG EHRegistrationNode;

#define PRN_NEXT(prn)		__ERROR__
#define PRN_HANDLER(prn)	__ERROR__
#define PRN_STATE(prn)		__ERROR__
#define PRN_STACK(prn)		__ERROR__
#define PRN_FRAME(prn)		__ERROR__

#define FRAME_OFFSET		0

#if !defined(_NTSUBSET_)
typedef struct _RUNTIME_FUNCTION {
    ULONG BeginAddress;
    ULONG EndAddress;
    EXCEPTION_DISPOSITION (*ExceptionHandler)(...);
    PVOID HandlerData;
    ULONG PrologEndAddress;
} RUNTIME_FUNCTION, *PRUNTIME_FUNCTION;
#endif

typedef struct _xDISPATCHER_CONTEXT {
    ULONG ControlPc;
    PRUNTIME_FUNCTION FunctionEntry;
    ULONG EstablisherFrame;
    PCONTEXT ContextRecord;
} DispatcherContext;
    // changed the case of the name to conform to EH conventions

#if defined(_M_MPPC)
typedef struct _ftinfo {
    ULONG dwMagicNumber;                // magic number
    void *pFrameInfo;			// pointer to runtime frame info
    PRUNTIME_FUNCTION rgFuncTable;	// function table
    ULONG cFuncTable;			// number of function entry
    ULONG dwEntryCF;			// address of starting of the code fragment
    ULONG dwSizeCF;			// size of the code fragment
} FTINFO, *PFTINFO;

#define offsFTINFO              64
#endif

#else
#error "Machine not supported"
#endif


/////////////////////////////////////////////////////////////////////////////
//
// The NT Exception record that we use to pass information from the throw to
// the possible catches.
//
// The constants in the comments are the values we expect.
// This is based on the definition of EXCEPTION_RECORD in winnt.h.
//

typedef struct EHExceptionRecord {
	DWORD		ExceptionCode;			// The code of this exception. (= EH_EXCEPTION_NUMBER)
	DWORD		ExceptionFlags;			// Flags determined by NT
    struct _EXCEPTION_RECORD *ExceptionRecord;	// An extra exception record (not used)
    void * 		ExceptionAddress;		// Address at which exception occurred
    DWORD 		NumberParameters;		// Number of extended parameters. (= EH_EXCEPTION_PARAMETERS)
	struct EHParameters {
		DWORD		magicNumber;		// = EH_MAGIC_NUMBER1
		void *		pExceptionObject;	// Pointer to the actual object thrown
		ThrowInfo	*pThrowInfo;		// Description of thrown object
		} params;
} EHExceptionRecord;

#define PER_CODE(per)		((per)->ExceptionCode)
#define PER_FLAGS(per)		((per)->ExceptionFlags)
#define PER_NEXT(per)		((per)->ExceptionRecord)
#define PER_ADDRESS(per)	((per)->ExceptionAddress)
#define PER_NPARAMS(per)	((per)->NumberParameters)
#define PER_MAGICNUM(per)	((per)->params.magicNumber)
#define PER_PEXCEPTOBJ(per)	((per)->params.pExceptionObject)
#define PER_PTHROW(per)		((per)->params.pThrowInfo)
#define PER_THROW(per)		(*PER_PTHROW(per))

#define PER_ISSIMPLETYPE(t)	(PER_THROW(t).isSimpleType)
#define PER_ISREFERENCE(t)	(PER_THROW(t).isReference)
#define PER_ISCONST(t)		(PER_THROW(t).isConst)
#define PER_ISVOLATILE(t)	(PER_THROW(t).isVolatile)
#define PER_ISUNALIGNED(t)	(PER_THROW(t).isUnaligned)
#define PER_UNWINDFUNC(t)	(PER_THROW(t).pmfnUnwind)
#define PER_PCTLIST(t)		(PER_THROW(t).pCatchable)
#define PER_CTLIST(t)		(*PER_PCTLIST(t))

#define PER_IS_MSVC_EH(per)	((PER_CODE(per) == EH_EXCEPTION_NUMBER) && 			\
		 					 (PER_NPARAMS(per) == EH_EXCEPTION_PARAMETERS) &&	\
		 					 (PER_MAGICNUM(per) == EH_MAGIC_NUMBER1))



/////////////////////////////////////////////////////////////////////////////
//
// NT kernel routines and definitions required to implement exception handling:
//
// (from ntxcapi.h, which is not a public header file)
//
//---------------------------------------------------------------------------

#ifndef _NTXCAPI_

// begin_ntddk
//
// Exception flag definitions.
//

// begin_winnt
#define EXCEPTION_NONCONTINUABLE 0x1    // Noncontinuable exception
// end_winnt

// end_ntddk
#define EXCEPTION_UNWINDING 0x2         // Unwind is in progress
#define EXCEPTION_EXIT_UNWIND 0x4       // Exit unwind is in progress
#define EXCEPTION_STACK_INVALID 0x8     // Stack out of limits or unaligned
#define EXCEPTION_NESTED_CALL 0x10      // Nested exception handler call
#define EXCEPTION_TARGET_UNWIND 0x20    // Target unwind in progress
#define EXCEPTION_COLLIDED_UNWIND 0x40  // Collided exception handler call

#define EXCEPTION_UNWIND (EXCEPTION_UNWINDING | EXCEPTION_EXIT_UNWIND | \
                          EXCEPTION_TARGET_UNWIND | EXCEPTION_COLLIDED_UNWIND)

#define IS_UNWINDING(Flag) ((Flag & EXCEPTION_UNWIND) != 0)
#define IS_DISPATCHING(Flag) ((Flag & EXCEPTION_UNWIND) == 0)
#define IS_TARGET_UNWIND(Flag) (Flag & EXCEPTION_TARGET_UNWIND)
#define IS_EXIT_UNWIND(Flag) (Flag & EXCEPTION_EXIT_UNWIND)

#if !defined(_M_M68K)
#ifdef __cplusplus
extern "C" {
#endif

void WINAPI
RtlUnwind (
    IN void * TargetFrame OPTIONAL,
    IN void * TargetIp OPTIONAL,
    IN PEXCEPTION_RECORD ExceptionRecord OPTIONAL,
    IN void * ReturnValue
    );

#if defined(_M_IA64) /*IFSTRIP=IGN*/
RtlUnwind2 (
    IN FRAME_POINTERS TargetFrame OPTIONAL,
    IN void * TargetIp OPTIONAL,
    IN PEXCEPTION_RECORD ExceptionRecord OPTIONAL,
    IN void * ReturnValue,
    IN PCONTEXT ContextRecord
    );

PRUNTIME_FUNCTION
RtlLookupFunctionEntry (
     unsigned __int64 ControlPc,
     unsigned __int64 *ImageBase,
     unsigned __int64 *TargetGp
    );
#endif

#if defined(_M_ALPHA)
#define STATUS_UNWIND 0xc0000027

void WINAPI
RtlUnwindRfp (
    IN void * TargetRealFrame OPTIONAL,
    IN void * TargetIp OPTIONAL,
    IN PEXCEPTION_RECORD ExceptionRecord OPTIONAL,
    IN void * ReturnValue
    );
#endif

#if defined(_M_PPC)
ULONG WINAPI
RtlVirtualUnwind (
    IN ULONG ControlPc,
    IN PRUNTIME_FUNCTION FunctionEntry,
    IN OUT PCONTEXT ContextRecord,
    OUT PBOOLEAN InFunction,
    OUT PULONG EstablisherFrame,
    IN OUT PVOID ContextPointers OPTIONAL,
    IN ULONG LowStackLimit,
    IN ULONG HighStackLimit
    );

PRUNTIME_FUNCTION
RtlLookupFunctionEntry (
    IN ULONG ControlPc
    );
#endif

#if defined(_M_MPPC)
ULONG WINAPI
RtlVirtualUnwind (
    IN ULONG ControlPc,
    IN PRUNTIME_FUNCTION FunctionEntry,
    IN OUT PCONTEXT ContextRecord,
    OUT PBOOLEAN InFunction,
    OUT PULONG EstablisherFrame,
    IN OUT PVOID ContextPointers OPTIONAL,
    IN ULONG LowStackLimit,
    IN ULONG HighStackLimit
    );

PRUNTIME_FUNCTION
RtlLookupFunctionEntry (
    IN PRUNTIME_FUNCTION RuntimeFunction,
    IN ULONG ControlPc,
    IN ULONG Rtoc
    );

VOID
RtlRaiseException (
    IN PEXCEPTION_RECORD ExceptionRecord
    );
#endif

#ifdef __cplusplus
}
#endif
#endif

#endif /* _NTXCAPI_ */

#endif /* _EHDATA_NONT */

#pragma pack(pop, ehdata)

#endif /* _INC_EHDATA */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\vctools\pdb6\langapi\include\exe_vxd.h ===
/*
 *  Title
 *
 *	exe386.h
 *	Wieslaw Kalkus
 *	(C) Copyright Microsoft Corp 1988-1992
 *	5 August 1988
 *
 *  Description
 *
 *	Data structure definitions for the OS/2
 *	executable file format (flat model).
 *
 *  Modification History
 *
 *	88/08/05	Wieslaw Kalkus	Initial version
 */


#ifndef _VC_VER_INC
#include "..\include\vcver.h"
#endif


    /*_________________________________________________________________*
     |                                                                 |
     |                                                                 |
     |	OS/2 .EXE FILE HEADER DEFINITION - 386 version 0:32	       |
     |                                                                 |
     |_________________________________________________________________|
     *                                                                 */


#define BITPERWORD	16
#define BITPERBYTE	8
#define OBJPAGELEN	4096
#define E32MAGIC1	'L'		/* New magic number  "LE" */
#define E32MAGIC2	'E'		/* New magic number  "LE" */
#define E32MAGIC        0x454c          /* New magic number  "LE" */
#define E32RESBYTES1    0               /* First bytes reserved */
#define E32RESBYTES2	0		/* Second bytes reserved */
#define E32RESBYTES3	24		/* Third bytes reserved */
#define E32LEBO 	0x00		/* Little Endian Byte Order */
#define E32BEBO 	0x01		/* Big Endian Byte Order */
#define E32LEWO 	0x00		/* Little Endian Word Order */
#define E32BEWO 	0x01		/* Big Endian Word Order */
#define E32LEVEL	0L		/* 32-bit EXE format level */
#define E32CPU286	0x001		/* Intel 80286 or upwardly compatibile */
#define E32CPU386	0x002		/* Intel 80386 or upwardly compatibile */
#define E32CPU486	0x003		/* Intel 80486 or upwardly compatibile */



struct e32_exe {			/* New 32-bit .EXE header */
    unsigned char	e32_magic[2];	/* Magic number E32_MAGIC */
    unsigned char	e32_border;	/* The byte ordering for the .EXE */
    unsigned char	e32_worder;	/* The word ordering for the .EXE */
    unsigned long	e32_level;	/* The EXE format level for now = 0 */
    unsigned short	e32_cpu;	/* The CPU type */
    unsigned short	e32_os; 	/* The OS type */
    unsigned long	e32_ver;	/* Module version */
    unsigned long	e32_mflags;	/* Module flags */
    unsigned long	e32_mpages;	/* Module # pages */
    unsigned long	e32_startobj;	/* Object # for instruction pointer */
    unsigned long	e32_eip;	/* Extended instruction pointer */
    unsigned long	e32_stackobj;	/* Object # for stack pointer */
    unsigned long	e32_esp;	/* Extended stack pointer */
    unsigned long	e32_pagesize;	/* .EXE page size */
    unsigned long       e32_lastpagesize;/* Last page size in .EXE */
    unsigned long	e32_fixupsize;	/* Fixup section size */
    unsigned long	e32_fixupsum;	/* Fixup section checksum */
    unsigned long	e32_ldrsize;	/* Loader section size */
    unsigned long	e32_ldrsum;	/* Loader section checksum */
    unsigned long	e32_objtab;	/* Object table offset */
    unsigned long	e32_objcnt;	/* Number of objects in module */
    unsigned long	e32_objmap;	/* Object page map offset */
    unsigned long	e32_itermap;	/* Object iterated data map offset */
    unsigned long	e32_rsrctab;	/* Offset of Resource Table */
    unsigned long	e32_rsrccnt;	/* Number of resource entries */
    unsigned long	e32_restab;	/* Offset of resident name table */
    unsigned long	e32_enttab;	/* Offset of Entry Table */
    unsigned long	e32_dirtab;	/* Offset of Module Directive Table */
    unsigned long	e32_dircnt;	/* Number of module directives */
    unsigned long	e32_fpagetab;	/* Offset of Fixup Page Table */
    unsigned long	e32_frectab;	/* Offset of Fixup Record Table */
    unsigned long	e32_impmod;	/* Offset of Import Module Name Table */
    unsigned long	e32_impmodcnt;	/* Number of entries in Import Module Name Table */
    unsigned long	e32_impproc;	/* Offset of Import Procedure Name Table */
    unsigned long	e32_pagesum;	/* Offset of Per-Page Checksum Table */
    unsigned long	e32_datapage;	/* Offset of Enumerated Data Pages */
    unsigned long	e32_preload;	/* Number of preload pages */
    unsigned long	e32_nrestab;	/* Offset of Non-resident Names Table */
    unsigned long	e32_cbnrestab;	/* Size of Non-resident Name Table */
    unsigned long	e32_nressum;	/* Non-resident Name Table Checksum */
    unsigned long	e32_autodata;	/* Object # for automatic data object */
    unsigned long	e32_debuginfo;	/* Offset of the debugging information */
    unsigned long	e32_debuglen;	/* The length of the debugging info. in bytes */
    unsigned long	e32_instpreload;/* Number of instance pages in preload section of .EXE file */
    unsigned long	e32_instdemand; /* Number of instance pages in demand load section of .EXE file */
    unsigned long	e32_heapsize;	/* Size of heap - for 16-bit apps */
    unsigned char	e32_res3[E32RESBYTES3 - 4 - 8];
					/* Pad structure to 192 bytes */
    unsigned long	e32_winresoff ;
    unsigned long	e32_winreslen ;
    unsigned short	Dev386_Device_ID;
					/* Device ID for VxD */
    unsigned short	Dev386_DDK_Version;
					/* DDK version for VxD */
};



#define E32_MAGIC1(x)	    (x).e32_magic[0]
#define E32_MAGIC2(x)	    (x).e32_magic[1]
#define E32_BORDER(x)	    (x).e32_border
#define E32_WORDER(x)	    (x).e32_worder
#define E32_LEVEL(x)	    (x).e32_level
#define E32_CPU(x)	    (x).e32_cpu
#define E32_OS(x)	    (x).e32_os
#define E32_VER(x)	    (x).e32_ver
#define E32_MFLAGS(x)	    (x).e32_mflags
#define E32_MPAGES(x)	    (x).e32_mpages
#define E32_STARTOBJ(x)     (x).e32_startobj
#define E32_EIP(x)	    (x).e32_eip
#define E32_STACKOBJ(x)     (x).e32_stackobj
#define E32_ESP(x)	    (x).e32_esp
#define E32_PAGESIZE(x)     (x).e32_pagesize
#define E32_LASTPAGESIZE(x) (x).e32_lastpagesize
#define E32_FIXUPSIZE(x)    (x).e32_fixupsize
#define E32_FIXUPSUM(x)     (x).e32_fixupsum
#define E32_LDRSIZE(x)	    (x).e32_ldrsize
#define E32_LDRSUM(x)	    (x).e32_ldrsum
#define E32_OBJTAB(x)	    (x).e32_objtab
#define E32_OBJCNT(x)	    (x).e32_objcnt
#define E32_OBJMAP(x)	    (x).e32_objmap
#define E32_ITERMAP(x)	    (x).e32_itermap
#define E32_RSRCTAB(x)	    (x).e32_rsrctab
#define E32_RSRCCNT(x)	    (x).e32_rsrccnt
#define E32_RESTAB(x)	    (x).e32_restab
#define E32_ENTTAB(x)	    (x).e32_enttab
#define E32_DIRTAB(x)	    (x).e32_dirtab
#define E32_DIRCNT(x)	    (x).e32_dircnt
#define E32_FPAGETAB(x)     (x).e32_fpagetab
#define E32_FRECTAB(x)	    (x).e32_frectab
#define E32_IMPMOD(x)	    (x).e32_impmod
#define E32_IMPMODCNT(x)    (x).e32_impmodcnt
#define E32_IMPPROC(x)	    (x).e32_impproc
#define E32_PAGESUM(x)	    (x).e32_pagesum
#define E32_DATAPAGE(x)     (x).e32_datapage
#define E32_PRELOAD(x)	    (x).e32_preload
#define E32_NRESTAB(x)	    (x).e32_nrestab
#define E32_CBNRESTAB(x)    (x).e32_cbnrestab
#define E32_NRESSUM(x)	    (x).e32_nressum
#define E32_AUTODATA(x)     (x).e32_autodata
#define E32_DEBUGINFO(x)    (x).e32_debuginfo
#define E32_DEBUGLEN(x)     (x).e32_debuglen
#define E32_INSTPRELOAD(x)  (x).e32_instpreload
#define E32_INSTDEMAND(x)   (x).e32_instdemand
#define E32_HEAPSIZE(x)     (x).e32_heapsize



/*
 *  Format of E32_MFLAGS(x):
 *
 *  Low word has the following format:
 *
 *  15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0  - bit no
 *   |	   |	    | | |     | |   |
 *   |	   |	    | | |     | |   +------- Per-Process Library Initialization
 *   |	   |	    | | |     | +----------- No Internal Fixups for Module in .EXE
 *   |	   |	    | | |     +------------- No External Fixups for Module in .EXE
 *   |	   |	    | | +------------------- Incompatible with PM Windowing
 *   |	   |	    | +--------------------- Compatible with PM Windowing
 *   |	   |	    +----------------------- Uses PM Windowing API
 *   |	   +-------------------------------- Module not Loadable
 *   +-------------------------------------- Library Module
 */


#define E32NOTP 	 0x8000L	/* Library Module - used as NENOTP */
#define E32NOLOAD	 0x2000L	/* Module not Loadable */
#define E32PMAPI	 0x0300L	/* Uses PM Windowing API */
#define E32PMW		 0x0200L	/* Compatible with PM Windowing */
#define E32NOPMW	 0x0100L	/* Incompatible with PM Windowing */
#define E32NOEXTFIX	 0x0020L	/* NO External Fixups in .EXE */
#define E32NOINTFIX	 0x0010L	/* NO Internal Fixups in .EXE */
#define E32LIBINIT	 0x0004L	/* Per-Process Library Initialization */
#define E32APPMASK	 0x0700L	/* Aplication Type Mask */


/*
 *  Format of E32_MFLAGS(x):
 *
 *  High word has the following format:
 *
 *  15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0  - bit no
 *				      | |
 *				      | +--- Protected memory library module
 *				      +----- Device driver
 */

#define E32PROTDLL	 0x10000L	// Protected memory library module
#define E32DEVICE	 0x20000L	// Device driver
#define E32MODEXE	 0x00000L	// .EXE module
#define E32MODDLL	 0x08000L	// .DLL module
#define E32MODPROTDLL	 0x18000L	// Protected memory library module
#define E32MODPDEV	 0x20000L	// Physical device driver
#define E32MODVDEV	 0x28000L	// Virtual device driver
#define E32MODVDEVDYN	 0x38000L	// Virtual device driver (dynamic)
#define E32MODMASK	 0x38000L	// Module type mask

/*
 *  RELOCATION DEFINITIONS - RUN-TIME FIXUPS
 */


#pragma pack(1) 			/* This data must be packed */


typedef union _offset
{
    unsigned short offset16;
    unsigned long  offset32;
}
    offset;				/* 16-bit or 32-bit offset */


/***ET+	r32_rlc - Relocation item */

struct r32_rlc {			/* Relocation item */
    unsigned char nr_stype;		/* Source type - shared with new_rlc */
    unsigned char nr_flags;		/* Flag byte - shared with new_rlc */
    short r32_soff;			/* Source page offset */
    unsigned short r32_objmod;		/* Target obj. no. or Module ordinal */

    union targetid {			/* BEGIN UNION */
	unsigned long intref;		/* Internal fixup offset */
	unsigned long proc;		/* Procedure name offset */
	unsigned long ord;	 	/* Procedure ordinal */
    } r32_target;			/* END UNION */
    unsigned long addval;		/* Value added to the address */
    unsigned short r32_srccount;	/* Number of chained fixup records */
    unsigned short r32_chain;		/* Chain head */
};


#pragma pack()				/* Stop packing */


/*
 *  In 32-bit .EXE file run-time relocations are written as varying size
 *  records, so we need many size definitions.
 */

#define RINTSIZE16	8
#define RINTSIZE32	10
#define RORDSIZE	8
#define RNAMSIZE16	8
#define RNAMSIZE32	10
#define RADDSIZE16	10
#define RADDSIZE32	12



#if FALSE
/*
 *  Access macros defined in NEWEXE.H !!!
 */
#define NR_STYPE(x)	 (x).nr_stype
#define NR_FLAGS(x)	 (x).nr_flags
#endif

#define R32_SOFF(x)	 (x).r32_soff
#define R32_OBJNO(x)	 (x).r32_objmod
#define R32_MODORD(x)	 (x).r32_objmod
#define R32_OFFSET(x)    (x).r32_target.intref
#define R32_PROCOFF(x)   (x).r32_target.proc
#define R32_PROCORD(x)	 (x).r32_target.ord
#define R32_ADDVAL(x)    (x).addval
#define R32_SRCCNT(x)	 (x).r32_srccount
#define R32_CHAIN(x)	 (x).r32_chain



/*
 *  Format of NR_STYPE(x)
 *
 *	 7 6 5 4 3 2 1 0  - bit no
 *	     | | | | | |
 *	     | | +-+-+-+--- Source type
 *	     | +----------- Fixup to 16:16 alias
 *	     +------------- List of source offset follows fixup record
 */

#if FALSE

	    /* DEFINED in newexe.h !!! */

#define NRSTYP		0x0f		/* Source type mask */
#define NRSBYT		0x00		/* lo byte (8-bits)*/
#define NRSSEG		0x02		/* 16-bit segment (16-bits) */
#define NRSPTR		0x03		/* 16:16 pointer (32-bits) */
#define NRSOFF		0x05		/* 16-bit offset (16-bits) */
#define NRPTR48 	0x06		/* 16:32 pointer (48-bits) */
#define NROFF32 	0x07		/* 32-bit offset (32-bits) */
#define NRSOFF32	0x08		/* 32-bit self-relative offset (32-bits) */
#endif


#define NRSRCMASK	0x0f		/* Source type mask */
#define NRALIAS 	0x10		/* Fixup to alias */
#define NRCHAIN 	0x20		/* List of source offset follows */
					/* fixup record, source offset field */
					/* in fixup record contains number */
					/* of elements in list */

/*
 *  Format of NR_FLAGS(x) and R32_FLAGS(x):
 *
 *	 7 6 5 4 3 2 1 0  - bit no
 *	 | | | |   | | |
 *	 | | | |   | +-+--- Reference type
 *	 | | | |   +------- Additive fixup
 *	 | | | +----------- 32-bit Target Offset Flag (1 - 32-bit; 0 - 16-bit)
 *	 | | +------------- 32-bit Additive Flag (1 - 32-bit; 0 - 16-bit)
 *	 | +--------------- 16-bit Object/Module ordinal (1 - 16-bit; 0 - 8-bit)
 *	 +----------------- 8-bit import ordinal (1 - 8-bit;
 *						  0 - NR32BITOFF toggles
 *						      between 16 and 32 bit
 *						      ordinal)
 */

#if FALSE

	    /* DEFINED in newexe.h !!! */

#define NRADD		0x04		/* Additive fixup */
#define NRRTYP		0x03		/* Reference type mask */
#define NRRINT		0x00		/* Internal reference */
#define NRRORD		0x01		/* Import by ordinal */
#define NRRNAM		0x02		/* Import by name */
#endif

#define NRRENT		0x03		/* Internal entry table fixup */

#define NR32BITOFF	0x10		/* 32-bit Target Offset */
#define NR32BITADD	0x20		/* 32-bit Additive fixup */
#define NR16OBJMOD	0x40		/* 16-bit Object/Module ordinal */
#define NR8BITORD	0x80		/* 8-bit import ordinal */
/*end*/

/*
 *  Data structures for storing run-time fixups in linker virtual memory.
 *
 *  Each object has a list of Object Page Directories which specify
 *  fixups for given page. Each page has its own hash table which is
 *  used to detect fixups to the same target.
 */

#define PAGEPERDIR	62
#define LG2DIR		7


typedef struct _OBJPAGEDIR
{
    DWORD   next;			/* Virtual pointer to next dir on list */
    WORD    ht[PAGEPERDIR];		/* Pointers to individual hash tables */
}
    OBJPAGEDIR;



/*
 *  OBJECT TABLE
 */

/***ET+	o32_obj Object Table Entry */

struct o32_obj				/* Flat .EXE object table entry */
{
    unsigned long	o32_size;	/* Object virtual size */
    unsigned long	o32_base;	/* Object base virtual address */
    unsigned long	o32_flags;	/* Attribute flags */
    unsigned long	o32_pagemap;	/* Object page map index */
    unsigned long	o32_mapsize;	/* Number of entries in object page map */
    unsigned long	o32_reserved;	/* Reserved */
};


#define O32_SIZE(x)	(x).o32_size
#define O32_BASE(x)	(x).o32_base
#define O32_FLAGS(x)	(x).o32_flags
#define O32_PAGEMAP(x)	(x).o32_pagemap
#define O32_MAPSIZE(x)	(x).o32_mapsize
#define O32_RESERVED(x) (x).o32_reserved



/*
 *  Format of O32_FLAGS(x)
 *
 *  High word of dword flag field is not used for now.
 *  Low word has the following format:
 *
 *  15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0  - bit no
 *   |	|  |  |     | | | | | | | | | | |
 *   |	|  |  |     | | | | | | | | | | +--- Readable Object
 *   |	|  |  |     | | | | | | | | | +----- Writeable Object
 *   |	|  |  |     | | | | | | | | +------- Executable Object
 *   |	|  |  |     | | | | | | | +--------- Resource Object
 *   |	|  |  |     | | | | | | +----------- Object is Discardable
 *   |	|  |  |     | | | | | +------------- Object is Shared
 *   |	|  |  |     | | | | +--------------- Object has preload pages
 *   |	|  |  |     | | | +----------------- Object has invalid pages
 *   |	|  |  |     | | +------------------- Object is permanent and swappable
 *   |	|  |  |     | +--------------------- Object is permanent and resident
 *   |	|  |  |     +----------------------- Object is permanent and long lockable
 *   |	|  |  +----------------------------- 16:16 alias required (80x86 specific)
 *   |	|  +-------------------------------- Big/Default bit setting (80x86 specific)
 *   |	+----------------------------------- Object is conforming for code (80x86 specific)
 *   +-------------------------------------- Object I/O privilege level (80x86 specific)
 *
 */

#define OBJREAD 	0x0001L 	    /* Readable Object	 */
#define OBJWRITE	0x0002L 	    /* Writeable Object  */
#define OBJRSRC 	0x0008L 	    /* Resource Object	 */
#define OBJINVALID	0x0080L 	    /* Object has invalid pages  */
#define OBJNONPERM	0x0600L 	    /* Object is nonpermanent - should be */
					    /* zero in the .EXE but internally we use 6 */
#define OBJPERM 	0x0100L 	    /* Object is permanent and swappable */
#define OBJRESIDENT	0x0200L 	    /* Object is permanent and resident */
#define OBJCONTIG	0x0300L 	    /* Object is resident and contiguous */
#define OBJDYNAMIC	0x0400L 	    /* Object is permanent and long locable */
#define OBJTYPEMASK	0x0700L 	    /* Object type mask */
#define OBJALIAS16	0x1000L 	    /* 16:16 alias required (80x86 specific)	       */
#define OBJBIGDEF	0x2000L 	    /* Big/Default bit setting (80x86 specific)        */
#define OBJIOPL 	0x8000L 	    /* Object I/O privilege level (80x86 specific)     */

#define OBJDISCARD	 0x0010L	    /* Object is Discardable */
#define OBJSHARED	 0x0020L	    /* Object is Shared */
#define OBJPRELOAD	 0x0040L	    /* Object has preload pages  */
#define OBJEXEC 	 0x0004L	    /* Executable Object */
#define OBJCONFORM	 0x4000L	    /* Object is conforming for code (80x86 specific)  */

/*
 *  Life will be easier, if we keep the same names for the following flags:
 */
#define NSDISCARD	OBJDISCARD 	    /* Object is Discardable */
#define NSMOVE		NSDISCARD	    /* Moveable object is for sure Discardable */
#define NSSHARED	OBJSHARED 	    /* Object is Shared */
#define NSPRELOAD	OBJPRELOAD 	    /* Object has preload pages  */
#define NSEXRD		OBJEXEC 	    /* Executable Object */
#define NSCONFORM	OBJCONFORM 	    /* Object is conforming for code (80x86 specific)  */
/*end*/

/***ET+	o32_map - Object Page Map entry */

struct o32_map				    /* Object Page Map entry */
{
    unsigned char   o32_pageidx[3];	    /* 24-bit page # in .EXE file */
    unsigned char   o32_pageflags;	    /* Per-Page attributes */
};


#define GETPAGEIDX(x)	((((unsigned long)((x).o32_pageidx[0])) << BITPERWORD) + \
			 (((x).o32_pageidx[1]) << BITPERBYTE) + \
			   (x).o32_pageidx[2])

#define PUTPAGEIDX(x,i) ((x).o32_pageidx[0] = (unsigned char) ((unsigned long)(i) >> BITPERWORD), \
			 (x).o32_pageidx[1] = (unsigned char) ((i) >> BITPERBYTE), \
			 (x).o32_pageidx[2] = (unsigned char) ((i) &  0xff))

#define PAGEFLAGS(x)	(x).o32_pageflags


#define VALID		0x00		    /* Valid Physical Page in .EXE */
#define ITERDATA	0x01		    /* Iterated Data Page */
#define INVALID 	0x02		    /* Invalid Page */
#define ZEROED		0x03		    /* Zero Filled Page */
#define RANGE		0x04		    /* Range of pages */
/*end*/

/*
 *  RESOURCE TABLE
 */

/***ET+	rsrc32 - Resource Table Entry */

struct rsrc32				    /* Resource Table Entry */
{
    unsigned short	type;		    /* Resource type */
    unsigned short	name;		    /* Resource name */
    unsigned long	cb;		    /* Resource size */
    unsigned short	obj;		    /* Object number */
    unsigned long	offset; 	    /* Offset within object */
};
/*end*/


#pragma pack(1) 			/* This data must be packed */

/*
 *  ENTRY TABLE DEFINITIONS
 */

/***ET+	b32_bundle - Entry Table */

struct b32_bundle
{
    unsigned char	b32_cnt;	/* Number of entries in this bundle */
    unsigned char	b32_type;	/* Bundle type */
    unsigned short	b32_obj;	/* Object number */
};					/* Follows entry types */

struct e32_entry
{
    unsigned char	e32_flags;	/* Entry point flags */
    union entrykind
    {
	offset		e32_offset;	/* 16-bit/32-bit offset entry */
	struct
	{
	    unsigned short offset;	/* Offset in segment */
	    unsigned short callgate;	/* Callgate selector */
	}
			e32_callgate;	/* 286 (16-bit) call gate */
	struct
	{
	    unsigned short  modord;	/* Module ordinal number */
	    unsigned long   value;	/* Proc name offset or ordinal */
	}
			e32_fwd;	/* Forwarder */
    }
			e32_variant;	/* Entry variant */
};

#pragma pack()				/* Stop packing */


#define B32_CNT(x)	(x).b32_cnt
#define B32_TYPE(x)	(x).b32_type
#define B32_OBJ(x)	(x).b32_obj

#define E32_EFLAGS(x)	(x).e32_flags
#define E32_OFFSET16(x) (x).e32_variant.e32_offset.offset16
#define E32_OFFSET32(x) (x).e32_variant.e32_offset.offset32
#define E32_GATEOFF(x)	(x).e32_variant.e32_callgate.offset
#define E32_GATE(x)	(x).e32_variant.e32_callgate.callgate
#define E32_MODORD(x)	(x).e32_variant.e32_fwd.modord
#define E32_VALUE(x)	(x).e32_variant.e32_fwd.value

#define FIXENT16	3
#define FIXENT32	5
#define GATEENT16	5
#define FWDENT		7

/*
 *  BUNDLE TYPES
 */

#define EMPTY	     0x00		/* Empty bundle */
#define ENTRY16      0x01		/* 16-bit offset entry point */
#define GATE16	     0x02		/* 286 call gate (16-bit IOPL) */
#define ENTRY32      0x03		/* 32-bit offset entry point */
#define ENTRYFWD     0x04		/* Forwarder entry point */
#define TYPEINFO     0x80		/* Typing information present flag */


/*
 *  Format for E32_EFLAGS(x)
 *
 *	 7 6 5 4 3 2 1 0  - bit no
 *	 | | | | | | | |
 *	 | | | | | | | +--- exported entry
 *	 | | | | | | +----- uses shared data
 *	 +-+-+-+-+-+------- parameter word count
 */

#define E32EXPORT	0x01		/* Exported entry */
#define E32SHARED	0x02		/* Uses shared data */
#define E32PARAMS	0xf8		/* Parameter word count mask */

/*
 *  Flags for forwarders only:
 */

#define FWD_ORDINAL	0x01		/* Imported by ordinal */
/*end*/


struct VxD_Desc_Block {
    ULONG DDB_Next;         /* VMM RESERVED FIELD */
    USHORT DDB_SDK_Version;     /* INIT <DDK_VERSION> RESERVED FIELD */
    USHORT DDB_Req_Device_Number;   /* INIT <UNDEFINED_DEVICE_ID> */
    UCHAR DDB_Dev_Major_Version;    /* INIT <0> Major device number */
    UCHAR DDB_Dev_Minor_Version;    /* INIT <0> Minor device number */
    USHORT DDB_Flags;           /* INIT <0> for init calls complete */
    UCHAR DDB_Name[8];          /* AINIT <"        "> Device name */
    ULONG DDB_Init_Order;       /* INIT <UNDEFINED_INIT_ORDER> */
    ULONG DDB_Control_Proc;     /* Offset of control procedure */
    ULONG DDB_V86_API_Proc;     /* INIT <0> Offset of API procedure */
    ULONG DDB_PM_API_Proc;      /* INIT <0> Offset of API procedure */
    ULONG DDB_V86_API_CSIP;     /* INIT <0> CS:IP of API entry point */
    ULONG DDB_PM_API_CSIP;      /* INIT <0> CS:IP of API entry point */
    ULONG DDB_Reference_Data;       /* Reference data from real mode */
    ULONG DDB_Service_Table_Ptr;    /* INIT <0> Pointer to service table */
    ULONG DDB_Service_Table_Size;   /* INIT <0> Number of services */
    ULONG DDB_Win32_Service_Table;  /* INIT <0> Pointer to Win32 services */
    ULONG DDB_Prev;         /* INIT <'Prev'> Ptr to prev 4.0 DDB */
    ULONG DDB_Reserved0;        /* INIT <0> Reserved */
    ULONG DDB_Reserved1;        /* INIT <'Rsv1'> Reserved */
    ULONG DDB_Reserved2;        /* INIT <'Rsv2'> Reserved */
    ULONG DDB_Reserved3;        /* INIT <'Rsv3'> Reserved */
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\vctools\pdb6\langapi\include\ilstore.h ===
// ILStore API
// Copyright (C) 1994, Microsoft Corp.  All Rights Reserved.

#ifndef _VC_VER_INC
#include "..\include\vcver.h"
#endif

#ifndef __ILSTORE_INCLUDED__
#define __ILSTORE_INCLUDED__

#ifndef __PDB_INCLUDED__
#include "pdb.h"
#endif

typedef unsigned long KEY;		// temporary
typedef unsigned long ILSig; 	// signature of an ILStream
typedef unsigned char ILSType;	// ILStream type: GL, EX, SY, IN, etc.
typedef unsigned char ILSpace;	// storage domain hint: module, shared, PCH, etc.
typedef unsigned short ILVer;	// version (no. of times changed) of an IL contribution

enum {
	ilstypeNil,
	ilstypeGL,
	ilstypeEX,
	ilstypeSY,
	ilstypeIN,
	ilstypeEEA
};

enum {
	ilspaceNil,
	ilspaceMod,
	ilspaceShared,
};

enum {
	ilverNil,
	ilverNew,
	ilverMax = 65535
};

struct ILStore;
struct ILMod;
struct Buf;
typedef struct ILStore ILStore;
typedef struct ILMod ILMod;
typedef struct Buf Buf;

#if defined(__cplusplus)

PdbInterface ILStore {
	static PDBAPI(BOOL) open(PDB* ppdb, BOOL write, OUT ILStore** pilstore);
	virtual BOOL release() pure;

	virtual BOOL reset() pure;
	virtual BOOL getILMod(const char* szModule, OUT ILMod** ppilmod) pure;
	virtual BOOL getEnumILModNames(OUT EnumNameMap** ppenum) pure;

	virtual BOOL getILSType(const char* szILSType, OUT ILSType* pilstype) pure;
	// virtual BOOL getILSTypeMap(const char* szILSType, OUT const NameMap** ppnmILSType) pure;
	virtual BOOL getILSpace(const char* szILSpace, OUT ILSpace* pilspace) pure;
	// virtual BOOL getILSpaceMap(const char* szILSpace, OUT const NameMap** ppnmILSpace) pure;
#ifdef _DEBUG
	virtual BOOL getInfo( OUT long *pcStreamSz,
		OUT long *pcTotalILU,	OUT ULONG *pnumberOfILU,
		OUT long *pcTotShILU=NULL, OUT ULONG *pNumSharedILU=NULL ) pure;
#endif
};

PdbInterface EnumKeyType : Enum {
	virtual void get(OUT KEY* pkey, OUT ILSType *pilt, OUT ILSpace *pils) pure;
};

PdbInterface ILMod {
	virtual BOOL release() pure;

	virtual BOOL reset() pure;
	virtual BOOL getIL(KEY key, ILSType ilstype, OUT Buf *pbuf, OUT SIG* psig) pure;
	virtual BOOL getILVer(KEY key, OUT ILVer* pilver) pure;
	virtual BOOL putIL(KEY key, ILSType ilstype, Buf buf, ILSpace ilspace) pure;
	virtual BOOL getEnumILKT(OUT EnumKeyType** ppenum) pure;
	// virtual BOOL getEnumILStreams(ILSpace ilspace, OUT EnumStreams** ppenum) pure;
	// gets information and checks for inconsistencies

	// only succeeds in debug builds
	virtual BOOL getInfo( OUT long *pcStreamSz, 
		OUT long *pcTotalILU,	OUT ULONG *pnumberOfILU,
		OUT long *pcTotShILU=NULL, OUT ULONG *pNumSharedILU=NULL ) pure;

	virtual BOOL getAllIL(ILSType ilstype, OUT Buf* pbuf) pure;
	virtual BOOL deleteIL(KEY key, ILSType ilstype) pure;
};
#endif // __cplusplus

struct Buf {
	BYTE* pb;
	long cb;
#ifdef __cplusplus
	Buf() { }
	Buf(BYTE* pb_, long cb_) {
		pb = pb_;
		cb = cb_;
	}
#endif
};

#ifdef __cplusplus
extern "C" {
#endif

PDBAPI(BOOL) ILStoreOpen(PDB* ppdb, BOOL write, OUT ILStore** pilstore);
PDBAPI(BOOL) ILStoreRelease(ILStore* pilstore);
PDBAPI(BOOL) ILStoreReset(ILStore* pilstore);
PDBAPI(BOOL) ILStoreGetILMod(ILStore* pilstore, const char* szModule, OUT ILMod** ppilmod);
PDBAPI(BOOL) ILStoreGetILSType(ILStore* pilstore, const char* szILSType, OUT ILSType* pilstype);
PDBAPI(BOOL) ILStoreGetILSpace(ILStore* pilstore, const char* szILSpace, OUT ILSpace* pilspace);

PDBAPI(BOOL) ILModRelease(ILMod* pilmod);
PDBAPI(BOOL) ILModReset(ILMod* pilmod);
PDBAPI(BOOL) ILModGetIL(ILMod* pilmod, KEY key, ILSType ilstype, OUT Buf *pbuf, OUT SIG* psig);
PDBAPI(BOOL) ILModGetAllIL(ILMod* pilmod, ILSType ilstype, OUT Buf *pbuf);
PDBAPI(BOOL) ILModGetILVer(ILMod* pilmod, KEY key, OUT ILVer* pilver);
PDBAPI(BOOL) ILModPutIL(ILMod* pilmod, KEY key, ILSType ilstype, Buf buf, ILSpace ilspace);

#ifdef __cplusplus
};
#endif

#endif //!__ILSTORE_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\vctools\pdb6\langapi\include\getmsg.h ===
// getmsg.h

#ifndef _VC_VER_INC
#include "..\include\vcver.h"
#endif

#ifndef __GETMSG_H__
#define __GETMSG_H__

#ifdef  __cplusplus
extern "C" {
#endif

char *  get_err(int);
int SetErrorFile(const char *szFilename, const char *szExeName, int fSearchExePath);
long SetHInstace(long hInstModule);

#ifdef  __cplusplus
}
#endif

#endif __GETMSG_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\vctools\pdb6\langapi\include\fbrdbg.h ===
/* fbrdbg.h 
 * 
 * Definitions used for the FIBER DEBUG system service
 *
 * Steven Steiner 
 * 9/26/96
 */

typedef enum _OFBR {
	OFBR_QUERY_LIST_SIZE =0,
	OFBR_GET_LIST,
	OFBR_SET_FBRCNTX,
	OFBR_DISABLE_FBRS,
	OFBR_ENABLE_FBRS
} OFBR;

typedef struct _OFBRS {
	OFBR	op;
	LPVOID	FbrCntx;
} OFBRS;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\vctools\pdb6\langapi\include\macimage.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1989  Microsoft Corporation

Module Name:

    macimage.h

IMAGE_SYM_CLASS_FAR_EXTERNAL

Abstract:

    This is the include file that describes all mac-specific image info

Author:

    Bill Joyce (billjoy)  Oct 1992

Revision History:

--*/

#ifndef _VC_VER_INC
#include "..\include\vcver.h"
#endif

#ifndef _MACIMAGE_
#define _MACIMAGE_

#if defined _MSC_VER && _MSC_VER >= 800
#pragma pack(push, 2)
#else
#pragma pack(2)
#endif

#define IMAGE_FILE_MACHINE_M68K 0x268

// Macintosh relocation types
#define IMAGE_REL_M68K_DTOD16        0   // 16-bit data-to-data reference (patch with offset of A5)
#define IMAGE_REL_M68K_DTOC16        1   // 16-bit data-to-code reference (patch with offset of A5)
#define IMAGE_REL_M68K_DTOD32        2   // 32-bit data-to-data reference (patch with offset of A5)
#define IMAGE_REL_M68K_DTOC32        3   // 32-bit data-to-code reference (patch with offset of A5)
#define IMAGE_REL_M68K_DTOABSD32     4   // 32-bit data-to-code reference (patch with offset of A5 and add to DFIX)
#define IMAGE_REL_M68K_DTOABSC32     5   // 32-bit data-to-code reference (patch with offset of A5 and add to DFIX)
#define IMAGE_REL_M68K_CTOD16        6   // 16-bit code-to-data reference
#define IMAGE_REL_M68K_CTOC16        7   // 16-bit code-to-code reference
#define IMAGE_REL_M68K_CTOT16        8   // 16-bit code-to-thunk reference
#define IMAGE_REL_M68K_CTOD32        9   // 32-bit code-to-data reference
#define IMAGE_REL_M68K_CTOABSD32     10  // 32-bit code-to-absolute data reference
#define IMAGE_REL_M68K_CTOABSC32     11  // 32-bit code-to-absolute code reference
#define IMAGE_REL_M68K_CTOABST32     12  // 32-bit code-to-absolute thunk reference

#define IMAGE_REL_M68K_MACPROF32     19  // Profiler-specific relocation
#define IMAGE_REL_M68K_PCODETOC32    20  // 32-bit PCode-to-code reference
#define IMAGE_REL_M68K_CTOCS16       21  // 16-bit code space data-to-code reference
#define IMAGE_REL_M68K_CTOABSCS32    22  // 32-bit code space data-to-absolute code reference
#define IMAGE_REL_M68K_CV            23  // Direct 32-bit reference to the symbols virtual address, base not included

#define IMAGE_REL_M68K_DTOU16        25  // 16-bit data-to-unknown
#define IMAGE_REL_M68K_DTOU32        26  // 32-bit data-to-unknown
#define IMAGE_REL_M68K_DTOABSU32     27  // 32-bit data-to-unknown absolute
#define IMAGE_REL_M68K_CTOU16        28  // 16-bit code-to-unknown
#define IMAGE_REL_M68K_CTOABSU32     29  // 32-bit code-to-unknown absolute
#define IMAGE_REL_M68K_DIFF8         30  // Computed 8-bit difference between two symbols
#define IMAGE_REL_M68K_DIFF16        31  // Computed 16-bit difference between two symbols
#define IMAGE_REL_M68K_DIFF32        32  // Computed 32-bit difference between two symbols

#define IMAGE_REL_M68K_CSECTABLEB16       35  // Create a table with csnCODE byte-sized entries
#define IMAGE_REL_M68K_CSECTABLEW16       36  // Create a table with csnCODE word-sized entries
#define IMAGE_REL_M68K_CSECTABLEL16       37  // Create a table with csnCODE long-sized entries
#define IMAGE_REL_M68K_CSECTABLEBABS32    38  // Create a table with csnCODE byte-sized entries
#define IMAGE_REL_M68K_CSECTABLEWABS32    39  // Create a table with csnCODE word-sized entries
#define IMAGE_REL_M68K_CSECTABLELABS32    40  // Create a table with csnCODE long-sized entries
#define IMAGE_REL_M68K_DUPCON16           41  // Duplicate the contributor where this symbol is defined and put it in this PE section
#define IMAGE_REL_M68K_DUPCONABS32        42  // Duplicate the contributor where this symbol is defined and put it in this PE section

#define IMAGE_REL_M68K_PCODESN16          45  // Write the section number of the code where the fixup occurs
#define IMAGE_REL_M68K_PCODETOD24         46  // 24-bit code-to-data ref
#define IMAGE_REL_M68K_PCODETOT24         47  // 24-bit code-to-thunk ref
#define IMAGE_REL_M68K_PCODETOCS24        48  // 24-bit code-to-codespacedata ref
#define IMAGE_REL_M68K_PCODENEPE16        49  // 16-bit NEP elimination fixup
#define IMAGE_REL_M68K_PCODETONATIVE32    50  // 32-bit PCode-to-native reference

// MacProf constants
#define MACPROF_MAX_SECTIONS         2047  
#define MACPROF_CBITSINOFF             21
#define MACPROF_SN_MASK        0xFFE00000  // 11 bits for sn (up to 2047 sections)
#define MACPROF_OFF_MASK       0x001FFFFF  // 21 bits for offset (shifted right once to support sections up to 4 Meg)

// Data section header
typedef struct {
    unsigned long cbNearbss;   // size of near uninitialized data
    unsigned long cbNeardata;  // size of near initialized data
    unsigned long cbFarbss;    // size of near uninitialized data
    unsigned long cbFardata;   // size of near initialized data
} DATASECHDR;


// .resmap structure used by MRC to map resources to their type and ID
typedef struct {
    LONG typRes;                // resource type ("CODE", "DATA", etc)
    short iRes;                 // resource index
} RRM;                          // Raw to Resource Map

#define szsecRESMAP ".resmap"
#define szsecJTABLE ".jtable"
#define szsecDFIX   ".dfix"
#define szsecMSCV   ".mscv"
#define szsecSWAP   ".swap"
#define szsecFARBSS ".farbss"

#if 0 // These are defined in ntimage.h and are only included for reference.

#define IMAGE_SCN_TYPE_REGULAR               0x00000000  //
#define IMAGE_SCN_TYPE_DUMMY                 0x00000001  // Reserved.
#define IMAGE_SCN_TYPE_NO_LOAD               0x00000002  // Reserved.
#define IMAGE_SCN_TYPE_GROUPED               0x00000004  // Used for 16-bit offset code.
#define IMAGE_SCN_TYPE_NO_PAD                0x00000008  // Reserved.
#define IMAGE_SCN_TYPE_COPY                  0x00000010  // Reserved.

#define IMAGE_SCN_CNT_CODE                   0x00000020  // Section contains code.
#define IMAGE_SCN_CNT_INITIALIZED_DATA       0x00000040  // Section contains initialized data.
#define IMAGE_SCN_CNT_UNINITIALIZED_DATA     0x00000080  // Section contains uninitialized data.

#define IMAGE_SCN_LNK_OTHER                  0x00000100  // Reserved.
#define IMAGE_SCN_LNK_INFO                   0x00000200  // Section contains comments or some other type of information.
#define IMAGE_SCN_LNK_OVERLAY                0x00000400  // Section contains an overlay.
#define IMAGE_SCN_LNK_REMOVE                 0x00000800  // Section contents will not become part of image.
#define IMAGE_SCN_LNK_COMDAT                 0x00001000  // Section contents comdat.

#define IMAGE_SCN_ALIGN_1BYTES               0x00100000  //
#define IMAGE_SCN_ALIGN_2BYTES               0x00200000  //
#define IMAGE_SCN_ALIGN_4BYTES               0x00300000  //
#define IMAGE_SCN_ALIGN_8BYTES               0x00400000  //
#define IMAGE_SCN_ALIGN_16BYTES              0x00500000  // Default alignment if no others are specified.
#define IMAGE_SCN_ALIGN_32BYTES              0x00600000  //
#define IMAGE_SCN_ALIGN_64BYTES              0x00700000  //

#define IMAGE_SCN_MEM_DISCARDABLE            0x02000000  // Section can be discarded.
#define IMAGE_SCN_MEM_NOT_CACHED             0x04000000  // Section is not cachable.
#define IMAGE_SCN_MEM_NOT_PAGED              0x08000000  // Section is not pageable.
#define IMAGE_SCN_MEM_SHARED                 0x10000000  // Section is shareable.
#define IMAGE_SCN_MEM_EXECUTE                0x20000000  // Section is executable.
#define IMAGE_SCN_MEM_READ                   0x40000000  // Section is readable.
#define IMAGE_SCN_MEM_WRITE                  0x80000000  // Section is writeable.

#endif // 0

#define IMAGE_SCN_MEM_DISCARDABLE            0x02000000  // Section can be discarded.

// MAC section header flags
#define IMAGE_SCN_MEM_PROTECTED              0x00004000  
#define IMAGE_SCN_MEM_FARDATA                0x00008000  
#define IMAGE_SCN_MEM_SYSHEAP                0x00010000  
#define IMAGE_SCN_MEM_PURGEABLE              0x00020000  
#define IMAGE_SCN_MEM_LOCKED                 0x00040000  
#define IMAGE_SCN_MEM_PRELOAD                0x00080000  

// MAC symbol class
// undefine for new win32 headers #define IMAGE_SYM_CLASS_FAR_EXTERNAL		 68
// Now defined in winnt.h

// Misc Symbol Types
// pcode flag currently used only for mac, but can be used easily by anyone
#define IMAGE_SYM_TYPE_PCODE            0x8000

// Data section masks
#define BSS_MASK      (IMAGE_SCN_CNT_UNINITIALIZED_DATA | IMAGE_SCN_MEM_FARDATA)
#define DATA_MASK     (IMAGE_SCN_CNT_INITIALIZED_DATA   | IMAGE_SCN_MEM_FARDATA)

#define NBSS          IMAGE_SCN_CNT_UNINITIALIZED_DATA 
#define NDATA         IMAGE_SCN_CNT_INITIALIZED_DATA   
#define FBSS          (IMAGE_SCN_CNT_UNINITIALIZED_DATA | IMAGE_SCN_MEM_FARDATA)
#define FDATA         (IMAGE_SCN_CNT_INITIALIZED_DATA   | IMAGE_SCN_MEM_FARDATA)

#define BSS_OR_DATA_MASK (IMAGE_SCN_CNT_INITIALIZED_DATA | IMAGE_SCN_CNT_UNINITIALIZED_DATA)

// Mac Finder Information layout

// see pg. 9-37 of Inside Macintosh vol. 6
#define	FINDER_FLAG_INVISIBLE	0x40		// fd_Attr1
#define	FINDER_FLAG_SET			0x01		// fd_Attr1
#define FINDER_FLAG_BNDL		0x20		// ditto

#define FINDER_INFO_SIZE			32
typedef struct {
	unsigned char	fd_Type[4];
	unsigned char	fd_Creator[4];
	unsigned char	fd_Attr1;			// Bits 8-15
	unsigned char	fd_Attr2;			// Bits 0-7
	unsigned char	fd_Location[4];
	unsigned char	fd_FDWindow[2];
	unsigned char	fd_OtherStuff[16];
	} FINDERINFO, *PFINDERINFO;


// Apple-II (ProDOS) information.

// default values for newly discovered items
#define	PRODOS_TYPE_FILE	0x04	// corresponds to finder fdType 'TEXT'
#define PRODOS_TYPE_DIR		0x0F
#define PRODOS_AUX_DIR		0x02	// actually 0x0200

// some other finder fdType to prodos FileType mapping values
#define PRODOS_FILETYPE_PSYS	0xFF
#define PRODOS_FILETYPE_PS16	0xB3

#define PRODOS_INFO_SIZE			6
typedef struct
{
	unsigned char pd_FileType[2];
	unsigned char pd_AuxType[4];
} PRODOSINFO, *PPRODOSINFO;

// Directory Access Permissions
#define	DIR_ACCESS_SEARCH			0x01	// See Folders
#define	DIR_ACCESS_READ				0x02	// See Files
#define	DIR_ACCESS_WRITE			0x04	// Make Changes
#define	DIR_ACCESS_OWNER			0x80	// Only for user
											// if he has owner rights
typedef struct _AfpInfo {
	unsigned long		afpi_Signature;			// Signature
	long				afpi_Version;			// Version
	unsigned long		afpi_Id;				// AFP File or directory Id
	unsigned long		afpi_BackupTime;		// Backup time for the file/dir
										// (Volume backup time is stored
										// in the AFP_IdIndex stream)

	FINDERINFO	afpi_FinderInfo;		// Finder Info (32 bytes)
	PRODOSINFO  afpi_ProDosInfo;		// ProDos Info (6 bytes)

	unsigned short		afpi_Attributes;		// Attributes mask (maps ReadOnly)

	unsigned char		afpi_AccessOwner;		// Access mask (SFI vs. SFO)
	unsigned char		afpi_AccessGroup;		// Directories only
	unsigned char		afpi_AccessWorld;
	} AFPINFO, *PAFPINFO;

#define AFP_SERVER_SIGNATURE		(*(unsigned long *)"AFP")
#define	AFP_SERVER_VERSION			0x00010000
#define	BEGINNING_OF_TIME 			0x80000000

//
// Initialize a AFPINFO structure with default values
//
// VOID
// AfpInitAfpInfo(
//		IN	PAFPINFO	pAfpInfo,
//		IN	DWORD		AfpId OPTIONAL, // 0 if we don't yet know the AFP Id
//		IN	BOOLEAN		IsDir
// )
//
#define AfpInitAfpInfo(pAfpInfo,AfpId,IsDir)	\
	memset(pAfpInfo,0,sizeof(AFPINFO)); \
	(pAfpInfo)->afpi_Signature = AFP_SERVER_SIGNATURE; \
	(pAfpInfo)->afpi_Version = AFP_SERVER_VERSION; \
	(pAfpInfo)->afpi_BackupTime = BEGINNING_OF_TIME; \
	(pAfpInfo)->afpi_Id = AfpId; \
	(pAfpInfo)->afpi_Attributes = 0; \
	if (IsDir) \
	{ \
		(pAfpInfo)->afpi_AccessOwner = DIR_ACCESS_READ | DIR_ACCESS_SEARCH;	\
		(pAfpInfo)->afpi_AccessGroup = DIR_ACCESS_READ | DIR_ACCESS_SEARCH;	\
		(pAfpInfo)->afpi_AccessWorld = DIR_ACCESS_READ | DIR_ACCESS_SEARCH;	\
		(pAfpInfo)->afpi_ProDosInfo.pd_FileType[0] = PRODOS_TYPE_DIR;\
		(pAfpInfo)->afpi_ProDosInfo.pd_AuxType[1] = PRODOS_AUX_DIR;\
	} \
	else \
	{ \
		(pAfpInfo)->afpi_ProDosInfo.pd_FileType[0] = PRODOS_TYPE_FILE; \
	}

#if defined _MSC_VER && _MSC_VER >= 800
#pragma pack(pop)
#else
#pragma pack()
#endif

#endif // _MACIMAGE_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\vctools\pdb6\langapi\include\migrate.h ===
/* 
   Migrate.h
  
   The contain of this file should eventually get merged into the NT hearder
   files.

   Copyright (C) 1997, Microsoft Corp.  All Rights Reserved.
*/

//
// Type values for COR methods
//

#define IMAGE_SYM_TYPE_NEW             0x0010  // cor_new
#define IMAGE_SYM_TYPE_INSTANCEOF      0x0020  // cor_instanceof
#define IMAGE_SYM_TYPE_VIRTUAL         0x0030  // cor_virtual
#define IMAGE_SYM_TYPE_METHOD          0x0040  // cor_[static, special, newnew]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\vctools\pdb6\langapi\include\instrapi.h ===
// Dolphin Performance Team Instrumentation API

#ifndef _VC_VER_INC
#include "..\include\vcver.h"
#endif

typedef char* SZ;
typedef void* LOG;
typedef enum {
	letypeMin,
	letypeBegin = letypeMin,
	letypeEnd,
	letypeEvent,
	letypeMax
} LETYPE; // type of log event

#ifdef __cplusplus
#define C_LINKAGE extern "C"
#else
#define C_LINKAGE
#endif

#ifndef DLLSPEC
#if defined(_X86_) || defined(_MIPS_)
#ifdef __INSTRAPI_DLL__
#define DLLSPEC __declspec(dllexport)
#else
#define DLLSPEC __declspec(dllimport)
#endif
#else
#define DLLSPEC
#endif
#endif

C_LINKAGE LOG DLLSPEC _cdecl LogOpen(void);
// Open a log.  Returns 0 upon failure.  If failure, do not issue diagnostics;
// logging is simply disabled.

C_LINKAGE void DLLSPEC _cdecl LogNoteEvent(LOG log, SZ szComponent, SZ szSubComponent,
							LETYPE letype, SZ szMiscFmt, ...);
// Note some event to the log.  log may be 0, in which case nothing happens.
// szComponent, szSubComponent, letype, and szMisc describe the component,
// subcomponent, log event type, and miscellaneous description of the event
// as described above (all lowercase, please).  Note that if any of the sz*
// parameters are 0, reasonable defaults will be supplied.
//
// Note that szMiscFmt is a sprintf format string and can be followed by
// additional arguments as necessary.  It is not necessary to add a newline,
// however.

C_LINKAGE void DLLSPEC _cdecl LogClose(LOG log);
// Close the log.  log may be 0, in which case nothing happens.

// (Failure strategy: we never assert, but upon errors may silently disable
// logging.)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\vctools\pdb6\langapi\include\miscimage.h ===
#pragma once
#if !defined(_miscimage_h)
#define _miscimage_h 1

#define IMAGE_FILE_MACHINE_IA64     1996

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\vctools\pdb6\langapi\include\mrengine.h ===
// Interface for minimum rebuild engine
//

#if !defined(_mrengine_h)
#define _mrengine_h

// get rid of baggage we don't need from windows.h
#define WIN32_LEAN_AND_MEAN
//#define NOGDI
#define NOUSER
#define NONLS

// include pdb, msf, and nameserver 
#include <pdb.h>
#include <windows.h>
#include <tchar.h>
#include <string.h>
#include <stdio.h>
#include <limits.h>
#include <stddef.h>

//
// Get the calling conventions and declspec stuff out of the way
//
#if defined(_X86_) || defined(_M_IX86)
#define	MRECALL			__stdcall
#else
#define MRECALL			__cdecl
#endif

#if defined(MR_ENGINE_STATIC)
#define MREAPI(rtype)		rtype MRECALL
#elif !defined(MR_ENGINE_IMPL)
#define	MREAPI(rtype)		rtype __declspec(dllimport) MRECALL
#else
#define MREAPI(rtype)		rtype __declspec(dllexport) MRECALL
#endif

//
// Our C++ Interfaces
//
PdbInterface                   MREngine;
typedef PdbInterface MREngine  MREngine;
typedef MREngine *			PMREngine;

PdbInterface                   MREDrv;
typedef PdbInterface MREDrv    MREDrv;
typedef MREDrv *			PMREDrv;

PdbInterface                   MRECmp;
typedef PdbInterface MRECmp    MRECmp;
typedef MRECmp *			PMRECmp;

PdbInterface                   MREUtil;
typedef PdbInterface MREUtil   MREUtil;
typedef MREUtil *			PMREUtil;

PdbInterface                   MREFile;
typedef PdbInterface MREFile   MREFile;
typedef MREFile *			PMREFile;

PdbInterface                   MREBag;
typedef PdbInterface MREBag    MREBag;
typedef MREBag *			PMREBag;

PdbInterface                   MRELog;
typedef PdbInterface MRELog    MRELog;
typedef MRELog *			PMRELog;

//
// other interesting things
//
#if !defined(FALSE)
#define FALSE 0
#define TRUE 1
#endif

#if !defined(fFalse)
#define fFalse FALSE
#define fTrue TRUE
#endif

// compile time assert
#if !defined(CASSERT)
	#if defined(_DEBUG)
		#define CASSERT(x) extern char dummyAssert[ (x) ]
	#else
		#define CASSERT(x)
	#endif
#endif

typedef _TCHAR *			SZ;			// String
typedef const _TCHAR *		SZC;		// const String
typedef DWORD				_CB;

#pragma warning(disable:4200)

typedef struct DepData {
	size_t	cb;
	BYTE	rgb[];
	} DepData, *PDepData;

#pragma warning(default:4200)

#if _INTEGRAL_MAX_BITS >= 64
typedef unsigned __int64	QWORD;		// 64-bit unsigned int
#else
typedef ULARGE_INTEGER		QWORD;
#endif

typedef PDB *				PPDB;
typedef NameMap *			PNMP;

typedef enum DEPON {			// depends on bits
	deponName = 0,					// nothing...requires a name
	deponVtshape = 0x1,				// depon virtual functions/bases
	deponShape = 0x2,				// depon size or offsets of class
	deponAll = -1,					// pseudo deps, not stored, but union
									// 	of all the above...
	} DEPON;

// file out-of-date structure/enumerations/flags
typedef enum YNM {	// Yes No Maybe
	ynmNo,
	ynmMaybe,
	ynmYes
	} YNM;
typedef struct SRCTARG *	PSRCTARG;
typedef struct SRCTARG {
	PSRCTARG	psrctargNext;
	BOOL		fCpp;
	SZC			szSrc;
	SZC			szTarg;
	SZC			szOptions;
	DWORD		dwWeightMaybe;
	} SRCTARG, **PPSRCTARG;

typedef struct CAList {		// Compile Action List
	PSRCTARG	pstDoCompile;
	PSRCTARG	pstMaybeCompile;
	PSRCTARG	pstDontCompile;
	PSRCTARG	pstDone;
	PSRCTARG	pstError;
	} CAList, *PCAList;

typedef enum TrgType {
	trgtypeObject,
	trgtypeSbr
	} TrgType;

// inline functions to manipulate lists of SRCTARGs
//
// Insert at a particular pst location, can be anywhere in the list
__inline PPSRCTARG
InsertSrcTarg ( PPSRCTARG ppstAt, PSRCTARG pst ) {
	pst->psrctargNext = *ppstAt;
	*ppstAt = pst;
	return &pst->psrctargNext;
	}

// Delete does a find on the pst then snips from the list
//
__inline void
DeleteSrcTarg ( PPSRCTARG ppstListHead, PSRCTARG pst ) {
	PPSRCTARG	ppstCur = ppstListHead;
	PPSRCTARG	ppstPrev = ppstCur;

	// find the matching pst
	while ( *ppstCur && *ppstCur != pst ) {
		ppstPrev = ppstCur;
		ppstCur = &(*ppstCur)->psrctargNext;
		}
	if ( *ppstCur ) {
		*ppstPrev = (*ppstCur)->psrctargNext;
		}
	}

// Delete a particular pst, given its pst and a pst whose psrctargNext
//	points to pst.
__inline void
DeleteSrcTargAt ( PSRCTARG pst, PPSRCTARG ppstPrev ) {
	*ppstPrev = pst->psrctargNext;
	}

// NextSrcTarg, so simple, no comment
//
__inline PSRCTARG
PstNext ( PSRCTARG pst ) {
	return pst ? pst->psrctargNext : 0;
	}

// Return the address of the last pst (a PPSRCTARG) in the list
//
__inline PPSRCTARG
PpstLast ( PPSRCTARG ppstHead ) {
	PSRCTARG	pst = *ppstHead;
	PPSRCTARG	ppstRet = ppstHead;

	while ( pst = PstNext ( pst ) ) {
		ppstRet = &pst->psrctargNext;
		}

	return ppstRet;
	}
//
// PDB api required by MRE.  Passed in in cases where the caller is using
// a wide bandwidth api to the PDB already.
//
typedef struct MreToPdb {
	PDB *		ppdb;			// the IDB file pdb api
	NameMap *	pnamemap;		// the namemap in the IDB
	TPI *		ptpi;			// the tpi in the PDB
	PDB *		ppdbPdbFile;	// the PDB file pdb api
	void *		pvReserved1;
	void *		pvReserved2;
	} MreToPdb, *PMreToPdb;

#if defined(__cplusplus)

// C++ bindings

// callback functions and datatypes for enumerating files and dependencies
enum EnumType { etSource, etDep };

enum ChgState { chgstUnknown, chgstClass, chgstRude };

// File Status Masks
enum FSM {
	fsmNil = 0,
	fsmOutOfDate = 0x1,
	fsmHasTarget = 0x2,
	fsmIsTarget = 0x4,
	fsmVisited = 0x8,
	fsmIgnoreDep = 0x10,
	fsmInclByPch = 0x20,
	fsmIsPch = 0x40,
	fsmCreatesPch = 0x80,
    fsmFileType = 0x300,
	fsmIsetPch = 0xffff0000,
	};

// File Type so we can infer what to do with dependencies when compiler changes
// and what is valid to do when checking for dependencies.
enum FileType {
    ftC = 0,
    ftCpp = 1,
    ftUnused = 2,
    ftOther = 3,
    };

union MREFT {			// MRE FileTime
	FILETIME	ft;
	QWORD		qwft;
	};

typedef unsigned long	BldId;
const BldId	bldidMax = ULONG_MAX;

struct FILEINFO {
	NI		niFile;			// main index value
	union {
		DWORD	dwStatus;		// file status bits
		// these are not used, just added for reference during debugging...
		struct {
			unsigned	fOutOfDate		: 1;
			unsigned	fHasTarget		: 1;
			unsigned	fIsTarget		: 1;
			unsigned	fVisited		: 1;
			unsigned	fIgnoreDep		: 1;
			unsigned	fInclByPch		: 1;
			unsigned	fIsPch			: 1;
			unsigned	fCreatesPch		: 1;
            unsigned    ftCompiland     : 2;
            unsigned    fUnused         : 6;
			unsigned	isetPch			: 16;
			};
		};
	MREFT	fiTime;			// time stamp
	QWORD	fiSize;			// file size
	NI		niOptions;		// option string (src only)
	NI		niRelated;		// for src, it is the target, for target, it is src
	BldId	bldid;			// tell when (wrt the pdb) last built (src only)
	DWORD	dwReserved;		// internal padding to 8 byte alignment
	};

// make sure the sizes and offsets are what we expect, as well as 8byte alignment
CASSERT(offsetof(FILEINFO, fiTime) == sizeof(NI)+sizeof(DWORD));
CASSERT((sizeof(FILEINFO) & 0x7) == 0);

struct FILESUMMARYINFO {
	DWORD	cFileDeps;
	DWORD	cClasses;
	};
typedef FILESUMMARYINFO	FSI;

struct EnumFile {
	SZC			szFileSrc;
	SZC			szFileTrg;
	FILEINFO	fiSrc;
	FILEINFO	fiTrg;
	FSI			fsiSrc;
	SZC			szOptions;
	void *		pvContext;
	};

struct EnumClass {
	NI			niClass;
	SZC			szClassName;
	DWORD		depon;
	DWORD		cMembersHit;
	DWORD		cMembersBits;
	TI			tiClass;
	void *		pvContext;
	};

// enumfile source (root) file callback
typedef BOOL (MRECALL * PfnFEFSrcCallBack) ( PMREUtil, EnumFile &, EnumType et =etSource );
// enumfile dep file callback
typedef BOOL (MRECALL * PfnFEFDepCallBack) ( PMREUtil, EnumFile &, EnumType et =etDep );
// enumfile all files callback
typedef BOOL (MRECALL * PfnFEFAllCallBack) ( PMREUtil, EnumFile & );
// enumclass callback
typedef BOOL (MRECALL * PfnFEClassCallBack) ( PMREUtil, EnumClass & );

// status (bytes, sizes, etc.)
struct StreamUtilization {
	DWORD	cbUsed;			// actually used by data we need
	DWORD	cbInternal;		// internal size (maps, sets)
	DWORD	cbExternal;		// external size (stream)

	StreamUtilization &
	operator += ( const StreamUtilization & su ) {
		cbUsed += su.cbUsed;
		cbInternal += su.cbInternal;
		cbExternal += su.cbExternal;
		return *this;
		}
	StreamUtilization
	operator + ( const StreamUtilization & su ) {
		StreamUtilization	suNew = *this;
		return suNew += su;
		}

	};

struct MreStats {
	DWORD				cSrcFiles;
	DWORD				cTrgFiles;
	DWORD				cDepFiles;
	DWORD				cClasses;
	DWORD				cBoringClasses;
	DWORD				cDedicatedStreams;
	DWORD				cbFilesInNamemap;
	DWORD				cbClassesInNamemap;
	StreamUtilization	suFileInfo;
	StreamUtilization	suClassInfo;
	StreamUtilization	suPerFileInfo;
	StreamUtilization	suTotal;
	};

PdbInterface MREDrv {  // compiler driver port
    // release this PdbInterface
	virtual BOOL		FRelease() pure;

	// expensive operation!  the driver will call this once per list of
	//	files to compile.
	virtual BOOL		FRefreshFileSysInfo() pure;

	// called by the driver after each successful compilation, this lets the
	//	mr engine know that a file was successfully compiled or not.
	virtual BOOL		FSuccessfulCompile (
							BOOL	fOk,
							SZC		szFileSrc,
							SZC		szFileTarg
							) pure;

	// To check if a file is really out of date wrt our fine grained deps...
	virtual YNM			YnmFileOutOfDate ( SRCTARG & ) pure;

	// alternate way, batch the files up, will segregate files into the
	//	appropriate lists inside of the CAList structure.
	virtual BOOL		FFilesOutOfDate ( PCAList pst ) pure;
							
	// post pass for files we didn't actually compile, but may need to update
	virtual BOOL		FUpdateTargetFile ( SZC szTrg, TrgType ) pure;

	// one-time driver init function.  called once per driver invocation ONLY.
	virtual void		OneTimeInit() pure;
	};

PdbInterface MRECmp {  // compiler front end port
    // release this PdbInterface
	virtual BOOL		FRelease() pure;

	// this method is used to get things rolling on each compiland.
	virtual BOOL		FOpenCompiland (
							OUT PMREFile * ppmrefile,
							IN SZC szFileSrc,
							IN SZC szFileTarg
							) pure;

	// after all is said and done with the compile, this needs to get called
	//	to do folding, propagation, and flattening, after the compiler
	//	has run successfully.
	virtual BOOL		FCloseCompiland ( PMREFile pmrefile, BOOL fCommit ) pure;

	// called when moving to an #include'ed file
	virtual BOOL		FPushFile (
							OUT PMREFile * ppmrefile,
							IN SZC szFile,
							IN HANDLE hFile =INVALID_HANDLE_VALUE
							) pure;

	// called when leaving an #include'ed file.
	//	returns PMREFile of enclosing (previous) file.
	virtual PMREFile	PmrefilePopFile() pure;

	// save/restore the dependencies (at pch create/restore time).
	//	Call FStoreDepData with a pointer to a DepData structure with a valid
	//	size  (the _cb field needs to be included).  The smallest possible
	//	DepBlob size is sizeof(CB).  A good size to start with is probably 8K. 
	//	This call will fill in the actual size of the data so the 
	//	block of memory can be trimmed back if you like.  Likewise, if the
	//	block is not big enough, this will return false with the size needed
	//	filled into the DepData.  If that size is 0, then there is no DepData
	//	to store.
	virtual BOOL		FStoreDepData ( PDepData ) pure;
	virtual BOOL		FRestoreDepData ( PDepData ) pure;

	// tell me a class in not interesting to store deps for (not changing much?)
	virtual void		ClassIsBoring ( NI niClass ) pure;

	};

PdbInterface MREUtil { // utility port, stats, enumerations, etc.
    // release this PdbInterface
	virtual BOOL		FRelease() pure;

	// support for offline tools to dump and otherwise peruse the
	//	mregine storage
	virtual void		EnumSrcFiles (
                            PfnFEFSrcCallBack,
                            SZC szFileSrc = NULL,
                            void * pvContext = NULL
                            ) pure;
	virtual void		EnumDepFiles ( EnumFile &, PfnFEFDepCallBack ) pure;
	virtual void		EnumAllFiles (
                            PfnFEFAllCallBack,
                            SZC szFileSrc = NULL,
                            void * pvContext = NULL
                            ) pure;
	virtual void		EnumClasses (
                            PfnFEClassCallBack,
                            SZC szFileSrc,
                            void * pvContext = NULL
                            ) pure;
	virtual void		SummaryStats ( MreStats & ) pure;

	};

// basically, we have a hierarchy: an MRE has MREFiles which in turn 
//	have MREBags.
// 
PdbInterface MREngine {
	// open methods by pdb * and pdb name
	static MREAPI(BOOL)	FOpen (
		OUT PMREngine *	ppmre,
		PPDB			ppdb,
		PNMP			pnmp,
		BOOL			fWrite,
		BOOL			fClosePdb = fFalse
		);
	static MREAPI(BOOL)	FOpen (
		OUT PMREngine *	ppmre,
		SZC				szPdb,
		EC &			ec,
		_TCHAR			szErr[ cbErrMax ],
		BOOL			fReproSig,
		BOOL			fWrite
		);
	static MREAPI(BOOL) FOpen (
		OUT PMREngine *	ppmre,
		PMreToPdb		pmretopdb,
		BOOL			fWrite,
		BOOL			fClosePdb = fFalse
		);
		

	// remove all MRE related streams from the PDB.
	virtual BOOL		FDelete() pure;

	// close and optionally commit new data
	virtual BOOL		FClose ( BOOL fCommit ) pure;
	
	// get the pdb api we are using
	virtual void		QueryPdbApi ( PDB *& rppdb, NameMap *& rpnamemap ) pure;

	// get the MreLog api
	virtual void		QueryMreLog ( PMRELog & rpmrelog ) pure;

    // get the various PdbInterface ptrs
	virtual void		QueryMreDrv ( PMREDrv & rpmredrv ) pure;
	virtual void		QueryMreCmp ( PMRECmp & rpmrecmp, TPI * ) pure;
	virtual void		QueryMreUtil ( PMREUtil & rpmreutil ) pure;

	// commit the global portions (actually, just write the streams...
	// a PDB/MSF commit must happen as well)
	virtual BOOL		FCommit() pure;

	};

//
// ClassChanged enumeration types for MREFile PdbInterface
//
typedef BOOL (MREFile::* MfnNoteClassTI) ( NI, TI );
typedef BOOL (__cdecl * PfnEnumClassChange) ( NI, PMREFile, MfnNoteClassTI );

PdbInterface MREFile {

	// icc -> mr flags
	//
	// iccfClassMrEdit implies that the class has a change that is detectable
	//	via cv type info changes downstream from the icc.
	//
	// iccfClassRudeEdit implies that something changed in the class that
	//	is not detectable downstream via type info and that at the very least,
	//	any code dependent in any way on the class needs to be recompiled.
	//
	// iccfFileRudeEdit means that something in the header file is rude,
	//	either added, removed, or continuing to be rude.
	//
	// iccfMethodEdit means that a change to class::method needs to be
	//	generated and any code dependent on class::method compiled.
	//
	// iccfAllCodeCompiled is used to detect when all code in a compiland
	//	has been compiled or not.  the incrememtal compiler may skip functions,
	//	in which case, the MR will merge the previous class deps with the new
	//	class deps in order to not lose dependency information.
	enum {
		iccfClassRudeEdit = 0x1,
		iccfClassMrEdit = 0x2,
		iccfFileRudeEdit = 0x4,
		iccfMethodEdit = 0x8,
		iccfAllCodeCompiled = 0x20,
		iccfAnyRude = iccfClassRudeEdit | iccfFileRudeEdit,
		};

	virtual BOOL		FOpenBag ( OUT PMREBag * ppmrebag, NI niNameBag ) pure;
	virtual BOOL		FnoteEndInclude ( DWORD dwFlags ) pure;
	virtual BOOL		FnoteClassMod ( NI niClass, DWORD dwFlags ) pure;
	virtual BOOL		FnoteInlineMethodMod ( 
							NI		niClass,
							SZC		szMember,
							DWORD	dwFlags
							) pure;
	virtual BOOL		FnoteLineDelta ( DWORD dwLineBase, INT delta ) pure;
	virtual void		EnumerateChangedClasses ( PfnEnumClassChange ) pure;
	virtual BOOL		FnoteClassTI ( NI, TI ) pure;
	virtual BOOL		FIsBoring() pure;
	virtual BOOL		FnotePchCreateUse (
							SZC	szPchCreate,
							SZC szPchUse
							) pure;
	};

PdbInterface MREBag {
	virtual BOOL		FAddDep (
							NI		niDep,				// class name's NI
							TI		tiDep,				// class type index
							SZC		szMemberName,		// member name
							DEPON	deponHow,			// how it depends on it
							DWORD	dwLine =0			// where referenced
							) pure;
	virtual BOOL		FClose() pure;
	};

PdbInterface MRELog {
	virtual void		TranslateToText ( BOOL fClear, _TCHAR ** pptch ) pure ;
	virtual void		TranslateToText ( BOOL fClear, FILE * pfile ) pure;
	};


#endif	// __cpluscplus

#if defined(__cplusplus)
extern "C" {
#endif

// C interfaces for MRE
MREAPI(BOOL)		MREFOpenEx (
						OUT PMREngine *	ppmre,
						PMreToPdb		pmretopdb,
						BOOL			fWrite
						);
MREAPI ( BOOL )		MREFOpen (
						OUT PMREngine * ppmre,
						PPDB			ppdb,
						PNMP			pnmp,
						BOOL			fWrite
						);
MREAPI ( BOOL )		MREFOpenByName (
						OUT PMREngine *	ppmre,
						SZC				szPdb,
						EC *			pec,
						_TCHAR			szErr[ cbErrMax ],
						BOOL			fReproSig,
						BOOL			fWrite
						);
MREAPI ( BOOL )		MREFDelete ( PMREngine );
MREAPI ( BOOL )		MREFClose ( PMREngine, BOOL fCommit ) ;
MREAPI ( void )		MREQueryMreDrv ( PMREngine, OUT PMREDrv *);
MREAPI ( void )		MREQueryMreCmp ( PMREngine, OUT PMRECmp *, IN TPI * );
MREAPI ( void )		MREQueryMreUtil ( PMREngine, OUT PMREUtil * );

// C interfaces for MREDrv
MREAPI ( BOOL )		MREDrvFRelease ( PMREDrv );
MREAPI ( BOOL )		MREDrvFRefreshFileSysInfo ( PMREDrv );
MREAPI ( BOOL )		MREDrvFSuccessfulCompile (
						PMREDrv,
						BOOL fOk,
						SZC szFileSrc,
						SZC szFileTarg
						);
#if !defined(NO_YNM)
MREAPI ( YNM )		MREDrvYnmFileOutOfDate ( PMREDrv, SRCTARG * );
#endif

MREAPI ( BOOL )		MREDrvFFilesOutOfDate ( PMREDrv, PCAList pCAList );
MREAPI ( BOOL )		MREDrvFUpdateTargetFile ( PMREDrv, SZC szTrg, TrgType );
MREAPI ( void )		MREDrvOneTimeInit ( PMREDrv );

// C PdbInterface for MRECmp
MREAPI ( BOOL )		MRECmpFRelease ( PMRECmp );
MREAPI ( BOOL )		MRECmpFOpenCompiland (
						PMRECmp,
						OUT PMREFile *	ppmrefile,
						IN SZC			szFileSrc,
						IN SZC			szFileTarg
						);
MREAPI ( BOOL )		MRECmpFCloseCompiland ( PMRECmp, PMREFile, BOOL fCommit );
MREAPI ( BOOL )		MRECmpFPushFile ( 
						PMRECmp,
						OUT PMREFile *	ppmrefile,
						IN SZC			szFile,
						IN HANDLE		hfile
						);
MREAPI ( PMREFile )	MRECmpPmrefilePopFile ( PMRECmp ) ;
MREAPI ( BOOL )		MRECmpFStoreDepData ( PMRECmp, PDepData );
MREAPI ( BOOL )		MRECmpFRestoreDepData ( PMRECmp, PDepData );
MREAPI ( void )		MRECmpClassIsBoring ( PMRECmp, NI );



// C interfaces for MREFile
MREAPI ( BOOL )		MREFileFOpenBag ( PMREFile, OUT PMREBag *, NI );

// C interfaces for MREBag
MREAPI ( BOOL )		MREBagFAddDep (
						PMREBag,
						NI niDep,
						TI tiDep,
						SZC szMemberName,
						DEPON depon
						);
MREAPI ( BOOL )		MREBagFClose ( PMREBag );

#if defined(__cplusplus)
}	// extern "C"
#endif

#endif	// _mrengine_h
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\vctools\pdb6\langapi\include\nowin.h ===
/***
*nowin.h -
*
*	Copyright (c) 1996, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	Declare misc. types, macros, etc. for non-Windows platforms that would
*       normally be declared in windows.h
*
*Revision History:
*       04-25-96  PNT	Module Created.
*
****/

#if !defined(_NOWIN_INCLUDED)
#define _NOWIN_INCLUDED

typedef unsigned int            UINT;
typedef long                    LONG;
typedef unsigned long           ULONG;
typedef ULONG                   *PULONG;
typedef unsigned short          USHORT;
typedef USHORT                  *PUSHORT;
typedef char                    CHAR;
typedef CHAR                    *PCHAR;
typedef unsigned char           UCHAR;
typedef UCHAR                   *PUCHAR;
typedef char                    *PSZ;
typedef unsigned char           BYTE;
typedef unsigned short          WORD;
typedef unsigned long           DWORD;
typedef int                     BOOL;
typedef unsigned char           BOOLEAN;
typedef BOOLEAN                 *PBOOLEAN;
typedef void                    VOID;
typedef VOID                    *PVOID;

#define FALSE	                0
#define TRUE	                1

#define IN
#define OUT
#define OPTIONAL

#define FAR
#define WINAPI
typedef int                     (FAR WINAPI *FARPROC)();

typedef ULONG                   NTSTATUS;

#ifndef NOMINMAX

#ifndef max
#define max(a, b)               (((a) > (b)) ? (a) : (b))
#endif

#ifndef min
#define min(a, b)               (((a) < (b)) ? (a) : (b))
#endif

#endif  /* NOMINMAX */

// Determine if an argument is present by testing the value of the pointer
// to the argument value.
//

#define ARGUMENT_PRESENT(ArgumentPointer)    (\
    (CHAR *)(ArgumentPointer) != (CHAR *)(NULL) )

//
// Exception record definition.
//

#define EXCEPTION_MAXIMUM_PARAMETERS 15 // maximum number of exception parameters

typedef struct _EXCEPTION_RECORD {
    /*lint -e18 */  // Don't complain about different definitions
    LONG ExceptionCode;
    /*lint +e18 */  // Resume checking for different definitions
    ULONG ExceptionFlags;
    struct _EXCEPTION_RECORD *ExceptionRecord;
    PVOID ExceptionAddress;
    ULONG NumberParameters;
    ULONG ExceptionInformation[EXCEPTION_MAXIMUM_PARAMETERS];
} EXCEPTION_RECORD;

typedef EXCEPTION_RECORD *PEXCEPTION_RECORD;

#if defined(_M_MPPC)
//
// Context Frame
//
//  N.B. This frame must be exactly a multiple of 16 bytes in length.
//
//  This frame has a several purposes: 1) it is used as an argument to
//  NtContinue, 2) it is used to constuct a call frame for APC delivery,
//  3) it is used to construct a call frame for exception dispatching
//  in user mode, and 4) it is used in the user level thread creation
//  routines.
//
//  Requires at least 8-byte alignment (double)
//

typedef struct _CONTEXT {

    //
    // This section is specified/returned if the ContextFlags word contains
    // the flag CONTEXT_FLOATING_POINT.
    //

    double Fpr0;                        // Floating registers 0..31
    double Fpr1;
    double Fpr2;
    double Fpr3;
    double Fpr4;
    double Fpr5;
    double Fpr6;
    double Fpr7;
    double Fpr8;
    double Fpr9;
    double Fpr10;
    double Fpr11;
    double Fpr12;
    double Fpr13;
    double Fpr14;
    double Fpr15;
    double Fpr16;
    double Fpr17;
    double Fpr18;
    double Fpr19;
    double Fpr20;
    double Fpr21;
    double Fpr22;
    double Fpr23;
    double Fpr24;
    double Fpr25;
    double Fpr26;
    double Fpr27;
    double Fpr28;
    double Fpr29;
    double Fpr30;
    double Fpr31;
    double Fpscr;                       // Floating point status/control reg

    //
    // This section is specified/returned if the ContextFlags word contains
    // the flag CONTEXT_INTEGER.
    //

    ULONG Gpr0;                         // General registers 0..31
    ULONG Gpr1;
    ULONG Gpr2;
    ULONG Gpr3;
    ULONG Gpr4;
    ULONG Gpr5;
    ULONG Gpr6;
    ULONG Gpr7;
    ULONG Gpr8;
    ULONG Gpr9;
    ULONG Gpr10;
    ULONG Gpr11;
    ULONG Gpr12;
    ULONG Gpr13;
    ULONG Gpr14;
    ULONG Gpr15;
    ULONG Gpr16;
    ULONG Gpr17;
    ULONG Gpr18;
    ULONG Gpr19;
    ULONG Gpr20;
    ULONG Gpr21;
    ULONG Gpr22;
    ULONG Gpr23;
    ULONG Gpr24;
    ULONG Gpr25;
    ULONG Gpr26;
    ULONG Gpr27;
    ULONG Gpr28;
    ULONG Gpr29;
    ULONG Gpr30;
    ULONG Gpr31;

    ULONG Cr;                           // Condition register
    ULONG Xer;                          // Fixed point exception register

    //
    // This section is specified/returned if the ContextFlags word contains
    // the flag CONTEXT_CONTROL.
    //

    ULONG Msr;                          // Machine status register
    ULONG Iar;                          // Instruction address register
    ULONG Lr;                           // Link register
    ULONG Ctr;                          // Count register

    //
    // The flags values within this flag control the contents of
    // a CONTEXT record.
    //
    // If the context record is used as an input parameter, then
    // for each portion of the context record controlled by a flag
    // whose value is set, it is assumed that that portion of the
    // context record contains valid context. If the context record
    // is being used to modify a thread's context, then only that
    // portion of the threads context will be modified.
    //
    // If the context record is used as an IN OUT parameter to capture
    // the context of a thread, then only those portions of the thread's
    // context corresponding to set flags will be returned.
    //
    // The context record is never used as an OUT only parameter.
    //

    ULONG ContextFlags;

    ULONG Fill[3];                      // Pad out to multiple of 16 bytes

    //
    // This section is specified/returned if CONTEXT_DEBUG_REGISTERS is
    // set in ContextFlags.  Note that CONTEXT_DEBUG_REGISTERS is NOT
    // included in CONTEXT_FULL.
    //
    ULONG Dr0;                          // Breakpoint Register 1
    ULONG Dr1;                          // Breakpoint Register 2
    ULONG Dr2;                          // Breakpoint Register 3
    ULONG Dr3;                          // Breakpoint Register 4
    ULONG Dr4;                          // Breakpoint Register 5
    ULONG Dr5;                          // Breakpoint Register 6
    ULONG Dr6;                          // Debug Status Register
    ULONG Dr7;                          // Debug Control Register

} CONTEXT, *PCONTEXT;

//
// Nonvolatile context pointer record.
//

typedef struct _KNONVOLATILE_CONTEXT_POINTERS {
    PULONG FloatingContext[32];
    PULONG FpscrContext;
    PULONG IntegerContext[32];
    PULONG CrContext;
    PULONG XerContext;
    PULONG MsrContext;
    PULONG IarContext;
    PULONG LrContext;
    PULONG CtrContext;
} KNONVOLATILE_CONTEXT_POINTERS, *PKNONVOLATILE_CONTEXT_POINTERS;
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\vctools\pdb6\langapi\include\objint.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.03.0110 */
/* at Wed Jun 10 17:42:56 1998
 */
/* Compiler settings for ..\idl\objint.idl:
    Os (OptLev=s), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __objint_h__
#define __objint_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __ILinkDataRO_FWD_DEFINED__
#define __ILinkDataRO_FWD_DEFINED__
typedef interface ILinkDataRO ILinkDataRO;
#endif 	/* __ILinkDataRO_FWD_DEFINED__ */


#ifndef __ILinkDataRW_FWD_DEFINED__
#define __ILinkDataRW_FWD_DEFINED__
typedef interface ILinkDataRW ILinkDataRW;
#endif 	/* __ILinkDataRW_FWD_DEFINED__ */


#ifndef __IPublicSym_FWD_DEFINED__
#define __IPublicSym_FWD_DEFINED__
typedef interface IPublicSym IPublicSym;
#endif 	/* __IPublicSym_FWD_DEFINED__ */


#ifndef __IEnumPublics_FWD_DEFINED__
#define __IEnumPublics_FWD_DEFINED__
typedef interface IEnumPublics IEnumPublics;
#endif 	/* __IEnumPublics_FWD_DEFINED__ */


#ifndef __IObjFile_FWD_DEFINED__
#define __IObjFile_FWD_DEFINED__
typedef interface IObjFile IObjFile;
#endif 	/* __IObjFile_FWD_DEFINED__ */


#ifndef __IObjHandler_FWD_DEFINED__
#define __IObjHandler_FWD_DEFINED__
typedef interface IObjHandler IObjHandler;
#endif 	/* __IObjHandler_FWD_DEFINED__ */


#ifndef __IObjectContrib_FWD_DEFINED__
#define __IObjectContrib_FWD_DEFINED__
typedef interface IObjectContrib IObjectContrib;
#endif 	/* __IObjectContrib_FWD_DEFINED__ */


#ifndef __IEnumContrib_FWD_DEFINED__
#define __IEnumContrib_FWD_DEFINED__
typedef interface IEnumContrib IEnumContrib;
#endif 	/* __IEnumContrib_FWD_DEFINED__ */


#ifndef __ICOFFAuxSym_FWD_DEFINED__
#define __ICOFFAuxSym_FWD_DEFINED__
typedef interface ICOFFAuxSym ICOFFAuxSym;
#endif 	/* __ICOFFAuxSym_FWD_DEFINED__ */


#ifndef __IEnumAuxSym_FWD_DEFINED__
#define __IEnumAuxSym_FWD_DEFINED__
typedef interface IEnumAuxSym IEnumAuxSym;
#endif 	/* __IEnumAuxSym_FWD_DEFINED__ */


#ifndef __ICOFFSymRO_FWD_DEFINED__
#define __ICOFFSymRO_FWD_DEFINED__
typedef interface ICOFFSymRO ICOFFSymRO;
#endif 	/* __ICOFFSymRO_FWD_DEFINED__ */


#ifndef __ICOFFSymRW_FWD_DEFINED__
#define __ICOFFSymRW_FWD_DEFINED__
typedef interface ICOFFSymRW ICOFFSymRW;
#endif 	/* __ICOFFSymRW_FWD_DEFINED__ */


#ifndef __IEnumCOFFSymRO_FWD_DEFINED__
#define __IEnumCOFFSymRO_FWD_DEFINED__
typedef interface IEnumCOFFSymRO IEnumCOFFSymRO;
#endif 	/* __IEnumCOFFSymRO_FWD_DEFINED__ */


#ifndef __IEnumCOFFSymRW_FWD_DEFINED__
#define __IEnumCOFFSymRW_FWD_DEFINED__
typedef interface IEnumCOFFSymRW IEnumCOFFSymRW;
#endif 	/* __IEnumCOFFSymRW_FWD_DEFINED__ */


#ifndef __ICOFFSymTabRO_FWD_DEFINED__
#define __ICOFFSymTabRO_FWD_DEFINED__
typedef interface ICOFFSymTabRO ICOFFSymTabRO;
#endif 	/* __ICOFFSymTabRO_FWD_DEFINED__ */


#ifndef __ICOFFSymTabRW_FWD_DEFINED__
#define __ICOFFSymTabRW_FWD_DEFINED__
typedef interface ICOFFSymTabRW ICOFFSymTabRW;
#endif 	/* __ICOFFSymTabRW_FWD_DEFINED__ */


#ifndef __ICOFFObj_FWD_DEFINED__
#define __ICOFFObj_FWD_DEFINED__
typedef interface ICOFFObj ICOFFObj;
#endif 	/* __ICOFFObj_FWD_DEFINED__ */


#ifndef __ILinkError_FWD_DEFINED__
#define __ILinkError_FWD_DEFINED__
typedef interface ILinkError ILinkError;
#endif 	/* __ILinkError_FWD_DEFINED__ */


#ifndef __ILinkNotify_FWD_DEFINED__
#define __ILinkNotify_FWD_DEFINED__
typedef interface ILinkNotify ILinkNotify;
#endif 	/* __ILinkNotify_FWD_DEFINED__ */


/* header files for imported files */
#include "objidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/****************************************
 * Generated header for interface: __MIDL_itf_objint_0000
 * at Wed Jun 10 17:42:56 1998
 * using MIDL 3.03.0110
 ****************************************/
/* [local] */ 


typedef /* [public][public] */ 
enum __MIDL___MIDL_itf_objint_0000_0001
    {	psymtNil	= 0,
	psymtRef	= psymtNil + 1,
	psymtDef	= psymtRef + 1,
	psymtAbs	= psymtDef + 1,
	psymtCom	= psymtAbs + 1,
	psymtAlias	= psymtCom + 1,
	psymtWeak	= psymtAlias + 1,
	psymtLazy	= psymtWeak + 1
    }	PSYMT;

typedef DWORDLONG OBJTK;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_objint_0000_0002
    {	objtktNil	= 0
    }	OBJTKT;

typedef DWORD ISYM;



extern RPC_IF_HANDLE __MIDL_itf_objint_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_objint_0000_v0_0_s_ifspec;

#ifndef __ILinkDataRO_INTERFACE_DEFINED__
#define __ILinkDataRO_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ILinkDataRO
 * at Wed Jun 10 17:42:56 1998
 * using MIDL 3.03.0110
 ****************************************/
/* [unique][uuid][object] */ 


typedef /* [unique] */ ILinkDataRO __RPC_FAR *PLinkDataRO;


EXTERN_C const IID IID_ILinkDataRO;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0CE9B320-AE0F-11d1-A719-0060083E8C78")
    ILinkDataRO : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetDataPointer( 
            /* [out] */ BYTE __RPC_FAR *__RPC_FAR *__MIDL_0008,
            /* [out] */ int __RPC_FAR *__MIDL_0009) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ILinkDataROVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ILinkDataRO __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ILinkDataRO __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ILinkDataRO __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDataPointer )( 
            ILinkDataRO __RPC_FAR * This,
            /* [out] */ BYTE __RPC_FAR *__RPC_FAR *__MIDL_0008,
            /* [out] */ int __RPC_FAR *__MIDL_0009);
        
        END_INTERFACE
    } ILinkDataROVtbl;

    interface ILinkDataRO
    {
        CONST_VTBL struct ILinkDataROVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ILinkDataRO_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ILinkDataRO_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ILinkDataRO_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ILinkDataRO_GetDataPointer(This,__MIDL_0008,__MIDL_0009)	\
    (This)->lpVtbl -> GetDataPointer(This,__MIDL_0008,__MIDL_0009)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ILinkDataRO_GetDataPointer_Proxy( 
    ILinkDataRO __RPC_FAR * This,
    /* [out] */ BYTE __RPC_FAR *__RPC_FAR *__MIDL_0008,
    /* [out] */ int __RPC_FAR *__MIDL_0009);


void __RPC_STUB ILinkDataRO_GetDataPointer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ILinkDataRO_INTERFACE_DEFINED__ */


#ifndef __ILinkDataRW_INTERFACE_DEFINED__
#define __ILinkDataRW_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ILinkDataRW
 * at Wed Jun 10 17:42:56 1998
 * using MIDL 3.03.0110
 ****************************************/
/* [unique][uuid][object] */ 


typedef /* [unique] */ ILinkDataRW __RPC_FAR *PLinkDataRW;


EXTERN_C const IID IID_ILinkDataRW;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("DB97C491-AE41-11d1-A719-0060083E8C78")
    ILinkDataRW : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetDataPointer( 
            /* [out] */ BYTE __RPC_FAR *__RPC_FAR *__MIDL_0010,
            /* [out] */ int __RPC_FAR *__MIDL_0011) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ILinkDataRWVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ILinkDataRW __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ILinkDataRW __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ILinkDataRW __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDataPointer )( 
            ILinkDataRW __RPC_FAR * This,
            /* [out] */ BYTE __RPC_FAR *__RPC_FAR *__MIDL_0010,
            /* [out] */ int __RPC_FAR *__MIDL_0011);
        
        END_INTERFACE
    } ILinkDataRWVtbl;

    interface ILinkDataRW
    {
        CONST_VTBL struct ILinkDataRWVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ILinkDataRW_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ILinkDataRW_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ILinkDataRW_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ILinkDataRW_GetDataPointer(This,__MIDL_0010,__MIDL_0011)	\
    (This)->lpVtbl -> GetDataPointer(This,__MIDL_0010,__MIDL_0011)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ILinkDataRW_GetDataPointer_Proxy( 
    ILinkDataRW __RPC_FAR * This,
    /* [out] */ BYTE __RPC_FAR *__RPC_FAR *__MIDL_0010,
    /* [out] */ int __RPC_FAR *__MIDL_0011);


void __RPC_STUB ILinkDataRW_GetDataPointer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ILinkDataRW_INTERFACE_DEFINED__ */


#ifndef __IPublicSym_INTERFACE_DEFINED__
#define __IPublicSym_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IPublicSym
 * at Wed Jun 10 17:42:56 1998
 * using MIDL 3.03.0110
 ****************************************/
/* [unique][uuid][object] */ 


typedef /* [unique] */ IPublicSym __RPC_FAR *LPPubSym;


EXTERN_C const IID IID_IPublicSym;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("18851AD0-910F-11d1-A712-0060083E8C78")
    IPublicSym : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE FComdat( 
            /* [out] */ BOOL __RPC_FAR *__MIDL_0012,
            /* [out] */ BYTE __RPC_FAR *__MIDL_0013) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ISym( 
            /* [out] */ ISYM __RPC_FAR *__MIDL_0014) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE TkFile( 
            /* [out] */ OBJTK __RPC_FAR *__MIDL_0015) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SzName( 
            /* [out] */ PLinkDataRO __RPC_FAR *__MIDL_0016) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SymType( 
            /* [out] */ PSYMT __RPC_FAR *__MIDL_0017) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SzNameDefaultSym( 
            /* [out] */ PLinkDataRO __RPC_FAR *__MIDL_0018) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPublicSymVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IPublicSym __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IPublicSym __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IPublicSym __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FComdat )( 
            IPublicSym __RPC_FAR * This,
            /* [out] */ BOOL __RPC_FAR *__MIDL_0012,
            /* [out] */ BYTE __RPC_FAR *__MIDL_0013);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ISym )( 
            IPublicSym __RPC_FAR * This,
            /* [out] */ ISYM __RPC_FAR *__MIDL_0014);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *TkFile )( 
            IPublicSym __RPC_FAR * This,
            /* [out] */ OBJTK __RPC_FAR *__MIDL_0015);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SzName )( 
            IPublicSym __RPC_FAR * This,
            /* [out] */ PLinkDataRO __RPC_FAR *__MIDL_0016);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SymType )( 
            IPublicSym __RPC_FAR * This,
            /* [out] */ PSYMT __RPC_FAR *__MIDL_0017);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SzNameDefaultSym )( 
            IPublicSym __RPC_FAR * This,
            /* [out] */ PLinkDataRO __RPC_FAR *__MIDL_0018);
        
        END_INTERFACE
    } IPublicSymVtbl;

    interface IPublicSym
    {
        CONST_VTBL struct IPublicSymVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPublicSym_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPublicSym_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPublicSym_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPublicSym_FComdat(This,__MIDL_0012,__MIDL_0013)	\
    (This)->lpVtbl -> FComdat(This,__MIDL_0012,__MIDL_0013)

#define IPublicSym_ISym(This,__MIDL_0014)	\
    (This)->lpVtbl -> ISym(This,__MIDL_0014)

#define IPublicSym_TkFile(This,__MIDL_0015)	\
    (This)->lpVtbl -> TkFile(This,__MIDL_0015)

#define IPublicSym_SzName(This,__MIDL_0016)	\
    (This)->lpVtbl -> SzName(This,__MIDL_0016)

#define IPublicSym_SymType(This,__MIDL_0017)	\
    (This)->lpVtbl -> SymType(This,__MIDL_0017)

#define IPublicSym_SzNameDefaultSym(This,__MIDL_0018)	\
    (This)->lpVtbl -> SzNameDefaultSym(This,__MIDL_0018)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IPublicSym_FComdat_Proxy( 
    IPublicSym __RPC_FAR * This,
    /* [out] */ BOOL __RPC_FAR *__MIDL_0012,
    /* [out] */ BYTE __RPC_FAR *__MIDL_0013);


void __RPC_STUB IPublicSym_FComdat_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPublicSym_ISym_Proxy( 
    IPublicSym __RPC_FAR * This,
    /* [out] */ ISYM __RPC_FAR *__MIDL_0014);


void __RPC_STUB IPublicSym_ISym_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPublicSym_TkFile_Proxy( 
    IPublicSym __RPC_FAR * This,
    /* [out] */ OBJTK __RPC_FAR *__MIDL_0015);


void __RPC_STUB IPublicSym_TkFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPublicSym_SzName_Proxy( 
    IPublicSym __RPC_FAR * This,
    /* [out] */ PLinkDataRO __RPC_FAR *__MIDL_0016);


void __RPC_STUB IPublicSym_SzName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPublicSym_SymType_Proxy( 
    IPublicSym __RPC_FAR * This,
    /* [out] */ PSYMT __RPC_FAR *__MIDL_0017);


void __RPC_STUB IPublicSym_SymType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPublicSym_SzNameDefaultSym_Proxy( 
    IPublicSym __RPC_FAR * This,
    /* [out] */ PLinkDataRO __RPC_FAR *__MIDL_0018);


void __RPC_STUB IPublicSym_SzNameDefaultSym_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IPublicSym_INTERFACE_DEFINED__ */


#ifndef __IEnumPublics_INTERFACE_DEFINED__
#define __IEnumPublics_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IEnumPublics
 * at Wed Jun 10 17:42:56 1998
 * using MIDL 3.03.0110
 ****************************************/
/* [unique][uuid][object] */ 


typedef /* [unique] */ IEnumPublics __RPC_FAR *LPEnumPub;


EXTERN_C const IID IID_IEnumPublics;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3BFA6690-9113-11d1-A712-0060083E8C78")
    IEnumPublics : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG __MIDL_0019,
            /* [out] */ IPublicSym __RPC_FAR *__RPC_FAR *__MIDL_0020,
            /* [out] */ ULONG __RPC_FAR *__MIDL_0021) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG __MIDL_0022) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumPublics __RPC_FAR *__RPC_FAR *__MIDL_0023) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumPublicsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEnumPublics __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEnumPublics __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEnumPublics __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IEnumPublics __RPC_FAR * This,
            /* [in] */ ULONG __MIDL_0019,
            /* [out] */ IPublicSym __RPC_FAR *__RPC_FAR *__MIDL_0020,
            /* [out] */ ULONG __RPC_FAR *__MIDL_0021);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IEnumPublics __RPC_FAR * This,
            /* [in] */ ULONG __MIDL_0022);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IEnumPublics __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IEnumPublics __RPC_FAR * This,
            /* [out] */ IEnumPublics __RPC_FAR *__RPC_FAR *__MIDL_0023);
        
        END_INTERFACE
    } IEnumPublicsVtbl;

    interface IEnumPublics
    {
        CONST_VTBL struct IEnumPublicsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumPublics_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumPublics_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumPublics_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumPublics_Next(This,__MIDL_0019,__MIDL_0020,__MIDL_0021)	\
    (This)->lpVtbl -> Next(This,__MIDL_0019,__MIDL_0020,__MIDL_0021)

#define IEnumPublics_Skip(This,__MIDL_0022)	\
    (This)->lpVtbl -> Skip(This,__MIDL_0022)

#define IEnumPublics_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumPublics_Clone(This,__MIDL_0023)	\
    (This)->lpVtbl -> Clone(This,__MIDL_0023)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumPublics_Next_Proxy( 
    IEnumPublics __RPC_FAR * This,
    /* [in] */ ULONG __MIDL_0019,
    /* [out] */ IPublicSym __RPC_FAR *__RPC_FAR *__MIDL_0020,
    /* [out] */ ULONG __RPC_FAR *__MIDL_0021);


void __RPC_STUB IEnumPublics_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumPublics_Skip_Proxy( 
    IEnumPublics __RPC_FAR * This,
    /* [in] */ ULONG __MIDL_0022);


void __RPC_STUB IEnumPublics_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumPublics_Reset_Proxy( 
    IEnumPublics __RPC_FAR * This);


void __RPC_STUB IEnumPublics_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumPublics_Clone_Proxy( 
    IEnumPublics __RPC_FAR * This,
    /* [out] */ IEnumPublics __RPC_FAR *__RPC_FAR *__MIDL_0023);


void __RPC_STUB IEnumPublics_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumPublics_INTERFACE_DEFINED__ */


#ifndef __IObjFile_INTERFACE_DEFINED__
#define __IObjFile_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IObjFile
 * at Wed Jun 10 17:42:56 1998
 * using MIDL 3.03.0110
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_IObjFile;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5AEA3330-911D-11d1-A712-0060083E8C78")
    IObjFile : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Characteristics( 
            /* [out] */ DWORD __RPC_FAR *__MIDL_0024) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CloseCache( 
            /* [in] */ BOOL __MIDL_0025) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumPublics( 
            /* [out] */ IEnumPublics __RPC_FAR *__RPC_FAR *__MIDL_0026,
            /* [in] */ OBJTK __MIDL_0027) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FNative( 
            BOOL __RPC_FAR *__MIDL_0028) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Machine( 
            /* [out] */ WORD __RPC_FAR *__MIDL_0029) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PbDirectives( 
            /* [out] */ PLinkDataRO __RPC_FAR *__MIDL_0030) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RgISymForeignRefs( 
            /* [out] */ PLinkDataRO __RPC_FAR *__MIDL_0031) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IObjFileVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IObjFile __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IObjFile __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IObjFile __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Characteristics )( 
            IObjFile __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *__MIDL_0024);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CloseCache )( 
            IObjFile __RPC_FAR * This,
            /* [in] */ BOOL __MIDL_0025);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumPublics )( 
            IObjFile __RPC_FAR * This,
            /* [out] */ IEnumPublics __RPC_FAR *__RPC_FAR *__MIDL_0026,
            /* [in] */ OBJTK __MIDL_0027);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FNative )( 
            IObjFile __RPC_FAR * This,
            BOOL __RPC_FAR *__MIDL_0028);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Machine )( 
            IObjFile __RPC_FAR * This,
            /* [out] */ WORD __RPC_FAR *__MIDL_0029);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PbDirectives )( 
            IObjFile __RPC_FAR * This,
            /* [out] */ PLinkDataRO __RPC_FAR *__MIDL_0030);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RgISymForeignRefs )( 
            IObjFile __RPC_FAR * This,
            /* [out] */ PLinkDataRO __RPC_FAR *__MIDL_0031);
        
        END_INTERFACE
    } IObjFileVtbl;

    interface IObjFile
    {
        CONST_VTBL struct IObjFileVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IObjFile_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IObjFile_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IObjFile_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IObjFile_Characteristics(This,__MIDL_0024)	\
    (This)->lpVtbl -> Characteristics(This,__MIDL_0024)

#define IObjFile_CloseCache(This,__MIDL_0025)	\
    (This)->lpVtbl -> CloseCache(This,__MIDL_0025)

#define IObjFile_EnumPublics(This,__MIDL_0026,__MIDL_0027)	\
    (This)->lpVtbl -> EnumPublics(This,__MIDL_0026,__MIDL_0027)

#define IObjFile_FNative(This,__MIDL_0028)	\
    (This)->lpVtbl -> FNative(This,__MIDL_0028)

#define IObjFile_Machine(This,__MIDL_0029)	\
    (This)->lpVtbl -> Machine(This,__MIDL_0029)

#define IObjFile_PbDirectives(This,__MIDL_0030)	\
    (This)->lpVtbl -> PbDirectives(This,__MIDL_0030)

#define IObjFile_RgISymForeignRefs(This,__MIDL_0031)	\
    (This)->lpVtbl -> RgISymForeignRefs(This,__MIDL_0031)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IObjFile_Characteristics_Proxy( 
    IObjFile __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *__MIDL_0024);


void __RPC_STUB IObjFile_Characteristics_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IObjFile_CloseCache_Proxy( 
    IObjFile __RPC_FAR * This,
    /* [in] */ BOOL __MIDL_0025);


void __RPC_STUB IObjFile_CloseCache_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IObjFile_EnumPublics_Proxy( 
    IObjFile __RPC_FAR * This,
    /* [out] */ IEnumPublics __RPC_FAR *__RPC_FAR *__MIDL_0026,
    /* [in] */ OBJTK __MIDL_0027);


void __RPC_STUB IObjFile_EnumPublics_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IObjFile_FNative_Proxy( 
    IObjFile __RPC_FAR * This,
    BOOL __RPC_FAR *__MIDL_0028);


void __RPC_STUB IObjFile_FNative_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IObjFile_Machine_Proxy( 
    IObjFile __RPC_FAR * This,
    /* [out] */ WORD __RPC_FAR *__MIDL_0029);


void __RPC_STUB IObjFile_Machine_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IObjFile_PbDirectives_Proxy( 
    IObjFile __RPC_FAR * This,
    /* [out] */ PLinkDataRO __RPC_FAR *__MIDL_0030);


void __RPC_STUB IObjFile_PbDirectives_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IObjFile_RgISymForeignRefs_Proxy( 
    IObjFile __RPC_FAR * This,
    /* [out] */ PLinkDataRO __RPC_FAR *__MIDL_0031);


void __RPC_STUB IObjFile_RgISymForeignRefs_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IObjFile_INTERFACE_DEFINED__ */


#ifndef __IObjHandler_INTERFACE_DEFINED__
#define __IObjHandler_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IObjHandler
 * at Wed Jun 10 17:42:56 1998
 * using MIDL 3.03.0110
 ****************************************/
/* [unique][uuid][object] */ 


typedef /* [unique] */ IObjHandler __RPC_FAR *PObjHandler;


EXTERN_C const IID IID_IObjHandler;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5CDF16C0-FFC6-11d1-A740-0060083E8C78")
    IObjHandler : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CodeGen( 
            /* [in] */ int __MIDL_0032,
            /* [in] */ unsigned char __RPC_FAR *__RPC_FAR *__MIDL_0033,
            /* [in] */ PLinkDataRO __MIDL_0034) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Init( 
            /* [in] */ IUnknown __RPC_FAR *__MIDL_0035) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IObjFileForFile( 
            /* [in] */ BSTR __MIDL_0036,
            /* [in] */ WORD __MIDL_0037,
            /* [in] */ DWORD __MIDL_0038,
            /* [in] */ DWORD __MIDL_0039,
            /* [in] */ OBJTK __MIDL_0040,
            /* [out] */ IObjFile __RPC_FAR *__RPC_FAR *__MIDL_0041) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnCtrlC( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IObjHandlerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IObjHandler __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IObjHandler __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IObjHandler __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CodeGen )( 
            IObjHandler __RPC_FAR * This,
            /* [in] */ int __MIDL_0032,
            /* [in] */ unsigned char __RPC_FAR *__RPC_FAR *__MIDL_0033,
            /* [in] */ PLinkDataRO __MIDL_0034);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Init )( 
            IObjHandler __RPC_FAR * This,
            /* [in] */ IUnknown __RPC_FAR *__MIDL_0035);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IObjFileForFile )( 
            IObjHandler __RPC_FAR * This,
            /* [in] */ BSTR __MIDL_0036,
            /* [in] */ WORD __MIDL_0037,
            /* [in] */ DWORD __MIDL_0038,
            /* [in] */ DWORD __MIDL_0039,
            /* [in] */ OBJTK __MIDL_0040,
            /* [out] */ IObjFile __RPC_FAR *__RPC_FAR *__MIDL_0041);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnCtrlC )( 
            IObjHandler __RPC_FAR * This);
        
        END_INTERFACE
    } IObjHandlerVtbl;

    interface IObjHandler
    {
        CONST_VTBL struct IObjHandlerVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IObjHandler_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IObjHandler_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IObjHandler_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IObjHandler_CodeGen(This,__MIDL_0032,__MIDL_0033,__MIDL_0034)	\
    (This)->lpVtbl -> CodeGen(This,__MIDL_0032,__MIDL_0033,__MIDL_0034)

#define IObjHandler_Init(This,__MIDL_0035)	\
    (This)->lpVtbl -> Init(This,__MIDL_0035)

#define IObjHandler_IObjFileForFile(This,__MIDL_0036,__MIDL_0037,__MIDL_0038,__MIDL_0039,__MIDL_0040,__MIDL_0041)	\
    (This)->lpVtbl -> IObjFileForFile(This,__MIDL_0036,__MIDL_0037,__MIDL_0038,__MIDL_0039,__MIDL_0040,__MIDL_0041)

#define IObjHandler_OnCtrlC(This)	\
    (This)->lpVtbl -> OnCtrlC(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IObjHandler_CodeGen_Proxy( 
    IObjHandler __RPC_FAR * This,
    /* [in] */ int __MIDL_0032,
    /* [in] */ unsigned char __RPC_FAR *__RPC_FAR *__MIDL_0033,
    /* [in] */ PLinkDataRO __MIDL_0034);


void __RPC_STUB IObjHandler_CodeGen_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IObjHandler_Init_Proxy( 
    IObjHandler __RPC_FAR * This,
    /* [in] */ IUnknown __RPC_FAR *__MIDL_0035);


void __RPC_STUB IObjHandler_Init_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IObjHandler_IObjFileForFile_Proxy( 
    IObjHandler __RPC_FAR * This,
    /* [in] */ BSTR __MIDL_0036,
    /* [in] */ WORD __MIDL_0037,
    /* [in] */ DWORD __MIDL_0038,
    /* [in] */ DWORD __MIDL_0039,
    /* [in] */ OBJTK __MIDL_0040,
    /* [out] */ IObjFile __RPC_FAR *__RPC_FAR *__MIDL_0041);


void __RPC_STUB IObjHandler_IObjFileForFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IObjHandler_OnCtrlC_Proxy( 
    IObjHandler __RPC_FAR * This);


void __RPC_STUB IObjHandler_OnCtrlC_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IObjHandler_INTERFACE_DEFINED__ */


#ifndef __IObjectContrib_INTERFACE_DEFINED__
#define __IObjectContrib_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IObjectContrib
 * at Wed Jun 10 17:42:56 1998
 * using MIDL 3.03.0110
 ****************************************/
/* [unique][uuid][object] */ 


typedef /* [unique] */ IObjectContrib __RPC_FAR *PObjContrib;


EXTERN_C const IID IID_IObjectContrib;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A461E470-911E-11d1-A712-0060083E8C78")
    IObjectContrib : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CbContents( 
            /* [out] */ DWORD __RPC_FAR *__MIDL_0042) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Characteristics( 
            /* [out] */ DWORD __RPC_FAR *__MIDL_0043) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CLineNo( 
            /* [out] */ DWORD __RPC_FAR *__MIDL_0044) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CRelocs( 
            /* [out] */ DWORD __RPC_FAR *__MIDL_0045) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ISection( 
            /* [out] */ DWORD __RPC_FAR *__MIDL_0046) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PbContents( 
            /* [out] */ BYTE __RPC_FAR *__MIDL_0047,
            /* [in] */ DWORD __MIDL_0048,
            /* [out] */ DWORD __RPC_FAR *__MIDL_0049) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PbContentsRO( 
            /* [out] */ PLinkDataRO __RPC_FAR *__MIDL_0050) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PbContentsRW( 
            /* [out] */ PLinkDataRW __RPC_FAR *__MIDL_0051) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RgLineNo( 
            /* [out] */ PLinkDataRO __RPC_FAR *__MIDL_0052) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RgRelocs( 
            /* [out] */ PLinkDataRO __RPC_FAR *__MIDL_0053) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RgRelocsEx( 
            /* [out] */ BYTE __RPC_FAR *__MIDL_0054,
            /* [in] */ DWORD __MIDL_0055) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SzSectionName( 
            /* [out] */ PLinkDataRO __RPC_FAR *__MIDL_0056) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE TkFile( 
            /* [out] */ OBJTK __RPC_FAR *__MIDL_0057) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE VirtualAddress( 
            /* [out] */ DWORD __RPC_FAR *__MIDL_0058) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IObjectContribVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IObjectContrib __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IObjectContrib __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IObjectContrib __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CbContents )( 
            IObjectContrib __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *__MIDL_0042);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Characteristics )( 
            IObjectContrib __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *__MIDL_0043);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CLineNo )( 
            IObjectContrib __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *__MIDL_0044);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CRelocs )( 
            IObjectContrib __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *__MIDL_0045);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ISection )( 
            IObjectContrib __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *__MIDL_0046);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PbContents )( 
            IObjectContrib __RPC_FAR * This,
            /* [out] */ BYTE __RPC_FAR *__MIDL_0047,
            /* [in] */ DWORD __MIDL_0048,
            /* [out] */ DWORD __RPC_FAR *__MIDL_0049);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PbContentsRO )( 
            IObjectContrib __RPC_FAR * This,
            /* [out] */ PLinkDataRO __RPC_FAR *__MIDL_0050);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PbContentsRW )( 
            IObjectContrib __RPC_FAR * This,
            /* [out] */ PLinkDataRW __RPC_FAR *__MIDL_0051);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RgLineNo )( 
            IObjectContrib __RPC_FAR * This,
            /* [out] */ PLinkDataRO __RPC_FAR *__MIDL_0052);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RgRelocs )( 
            IObjectContrib __RPC_FAR * This,
            /* [out] */ PLinkDataRO __RPC_FAR *__MIDL_0053);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RgRelocsEx )( 
            IObjectContrib __RPC_FAR * This,
            /* [out] */ BYTE __RPC_FAR *__MIDL_0054,
            /* [in] */ DWORD __MIDL_0055);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SzSectionName )( 
            IObjectContrib __RPC_FAR * This,
            /* [out] */ PLinkDataRO __RPC_FAR *__MIDL_0056);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *TkFile )( 
            IObjectContrib __RPC_FAR * This,
            /* [out] */ OBJTK __RPC_FAR *__MIDL_0057);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *VirtualAddress )( 
            IObjectContrib __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *__MIDL_0058);
        
        END_INTERFACE
    } IObjectContribVtbl;

    interface IObjectContrib
    {
        CONST_VTBL struct IObjectContribVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IObjectContrib_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IObjectContrib_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IObjectContrib_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IObjectContrib_CbContents(This,__MIDL_0042)	\
    (This)->lpVtbl -> CbContents(This,__MIDL_0042)

#define IObjectContrib_Characteristics(This,__MIDL_0043)	\
    (This)->lpVtbl -> Characteristics(This,__MIDL_0043)

#define IObjectContrib_CLineNo(This,__MIDL_0044)	\
    (This)->lpVtbl -> CLineNo(This,__MIDL_0044)

#define IObjectContrib_CRelocs(This,__MIDL_0045)	\
    (This)->lpVtbl -> CRelocs(This,__MIDL_0045)

#define IObjectContrib_ISection(This,__MIDL_0046)	\
    (This)->lpVtbl -> ISection(This,__MIDL_0046)

#define IObjectContrib_PbContents(This,__MIDL_0047,__MIDL_0048,__MIDL_0049)	\
    (This)->lpVtbl -> PbContents(This,__MIDL_0047,__MIDL_0048,__MIDL_0049)

#define IObjectContrib_PbContentsRO(This,__MIDL_0050)	\
    (This)->lpVtbl -> PbContentsRO(This,__MIDL_0050)

#define IObjectContrib_PbContentsRW(This,__MIDL_0051)	\
    (This)->lpVtbl -> PbContentsRW(This,__MIDL_0051)

#define IObjectContrib_RgLineNo(This,__MIDL_0052)	\
    (This)->lpVtbl -> RgLineNo(This,__MIDL_0052)

#define IObjectContrib_RgRelocs(This,__MIDL_0053)	\
    (This)->lpVtbl -> RgRelocs(This,__MIDL_0053)

#define IObjectContrib_RgRelocsEx(This,__MIDL_0054,__MIDL_0055)	\
    (This)->lpVtbl -> RgRelocsEx(This,__MIDL_0054,__MIDL_0055)

#define IObjectContrib_SzSectionName(This,__MIDL_0056)	\
    (This)->lpVtbl -> SzSectionName(This,__MIDL_0056)

#define IObjectContrib_TkFile(This,__MIDL_0057)	\
    (This)->lpVtbl -> TkFile(This,__MIDL_0057)

#define IObjectContrib_VirtualAddress(This,__MIDL_0058)	\
    (This)->lpVtbl -> VirtualAddress(This,__MIDL_0058)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IObjectContrib_CbContents_Proxy( 
    IObjectContrib __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *__MIDL_0042);


void __RPC_STUB IObjectContrib_CbContents_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IObjectContrib_Characteristics_Proxy( 
    IObjectContrib __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *__MIDL_0043);


void __RPC_STUB IObjectContrib_Characteristics_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IObjectContrib_CLineNo_Proxy( 
    IObjectContrib __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *__MIDL_0044);


void __RPC_STUB IObjectContrib_CLineNo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IObjectContrib_CRelocs_Proxy( 
    IObjectContrib __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *__MIDL_0045);


void __RPC_STUB IObjectContrib_CRelocs_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IObjectContrib_ISection_Proxy( 
    IObjectContrib __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *__MIDL_0046);


void __RPC_STUB IObjectContrib_ISection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IObjectContrib_PbContents_Proxy( 
    IObjectContrib __RPC_FAR * This,
    /* [out] */ BYTE __RPC_FAR *__MIDL_0047,
    /* [in] */ DWORD __MIDL_0048,
    /* [out] */ DWORD __RPC_FAR *__MIDL_0049);


void __RPC_STUB IObjectContrib_PbContents_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IObjectContrib_PbContentsRO_Proxy( 
    IObjectContrib __RPC_FAR * This,
    /* [out] */ PLinkDataRO __RPC_FAR *__MIDL_0050);


void __RPC_STUB IObjectContrib_PbContentsRO_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IObjectContrib_PbContentsRW_Proxy( 
    IObjectContrib __RPC_FAR * This,
    /* [out] */ PLinkDataRW __RPC_FAR *__MIDL_0051);


void __RPC_STUB IObjectContrib_PbContentsRW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IObjectContrib_RgLineNo_Proxy( 
    IObjectContrib __RPC_FAR * This,
    /* [out] */ PLinkDataRO __RPC_FAR *__MIDL_0052);


void __RPC_STUB IObjectContrib_RgLineNo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IObjectContrib_RgRelocs_Proxy( 
    IObjectContrib __RPC_FAR * This,
    /* [out] */ PLinkDataRO __RPC_FAR *__MIDL_0053);


void __RPC_STUB IObjectContrib_RgRelocs_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IObjectContrib_RgRelocsEx_Proxy( 
    IObjectContrib __RPC_FAR * This,
    /* [out] */ BYTE __RPC_FAR *__MIDL_0054,
    /* [in] */ DWORD __MIDL_0055);


void __RPC_STUB IObjectContrib_RgRelocsEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IObjectContrib_SzSectionName_Proxy( 
    IObjectContrib __RPC_FAR * This,
    /* [out] */ PLinkDataRO __RPC_FAR *__MIDL_0056);


void __RPC_STUB IObjectContrib_SzSectionName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IObjectContrib_TkFile_Proxy( 
    IObjectContrib __RPC_FAR * This,
    /* [out] */ OBJTK __RPC_FAR *__MIDL_0057);


void __RPC_STUB IObjectContrib_TkFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IObjectContrib_VirtualAddress_Proxy( 
    IObjectContrib __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *__MIDL_0058);


void __RPC_STUB IObjectContrib_VirtualAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IObjectContrib_INTERFACE_DEFINED__ */


#ifndef __IEnumContrib_INTERFACE_DEFINED__
#define __IEnumContrib_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IEnumContrib
 * at Wed Jun 10 17:42:56 1998
 * using MIDL 3.03.0110
 ****************************************/
/* [unique][uuid][object] */ 


typedef /* [unique] */ IEnumContrib __RPC_FAR *PEnumContrib;


EXTERN_C const IID IID_IEnumContrib;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6EC1C970-911F-11d1-A712-0060083E8C78")
    IEnumContrib : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG __MIDL_0059,
            /* [out] */ IObjectContrib __RPC_FAR *__RPC_FAR *__MIDL_0060,
            /* [out] */ ULONG __RPC_FAR *__MIDL_0061) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG __MIDL_0062) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ PEnumContrib __RPC_FAR *__MIDL_0063) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumContribVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEnumContrib __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEnumContrib __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEnumContrib __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IEnumContrib __RPC_FAR * This,
            /* [in] */ ULONG __MIDL_0059,
            /* [out] */ IObjectContrib __RPC_FAR *__RPC_FAR *__MIDL_0060,
            /* [out] */ ULONG __RPC_FAR *__MIDL_0061);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IEnumContrib __RPC_FAR * This,
            /* [in] */ ULONG __MIDL_0062);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IEnumContrib __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IEnumContrib __RPC_FAR * This,
            /* [out] */ PEnumContrib __RPC_FAR *__MIDL_0063);
        
        END_INTERFACE
    } IEnumContribVtbl;

    interface IEnumContrib
    {
        CONST_VTBL struct IEnumContribVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumContrib_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumContrib_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumContrib_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumContrib_Next(This,__MIDL_0059,__MIDL_0060,__MIDL_0061)	\
    (This)->lpVtbl -> Next(This,__MIDL_0059,__MIDL_0060,__MIDL_0061)

#define IEnumContrib_Skip(This,__MIDL_0062)	\
    (This)->lpVtbl -> Skip(This,__MIDL_0062)

#define IEnumContrib_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumContrib_Clone(This,__MIDL_0063)	\
    (This)->lpVtbl -> Clone(This,__MIDL_0063)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumContrib_Next_Proxy( 
    IEnumContrib __RPC_FAR * This,
    /* [in] */ ULONG __MIDL_0059,
    /* [out] */ IObjectContrib __RPC_FAR *__RPC_FAR *__MIDL_0060,
    /* [out] */ ULONG __RPC_FAR *__MIDL_0061);


void __RPC_STUB IEnumContrib_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumContrib_Skip_Proxy( 
    IEnumContrib __RPC_FAR * This,
    /* [in] */ ULONG __MIDL_0062);


void __RPC_STUB IEnumContrib_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumContrib_Reset_Proxy( 
    IEnumContrib __RPC_FAR * This);


void __RPC_STUB IEnumContrib_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumContrib_Clone_Proxy( 
    IEnumContrib __RPC_FAR * This,
    /* [out] */ PEnumContrib __RPC_FAR *__MIDL_0063);


void __RPC_STUB IEnumContrib_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumContrib_INTERFACE_DEFINED__ */


#ifndef __ICOFFAuxSym_INTERFACE_DEFINED__
#define __ICOFFAuxSym_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ICOFFAuxSym
 * at Wed Jun 10 17:42:56 1998
 * using MIDL 3.03.0110
 ****************************************/
/* [unique][uuid][object] */ 


typedef /* [unique] */ ICOFFAuxSym __RPC_FAR *PCOFFAuxSym;


EXTERN_C const IID IID_ICOFFAuxSym;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("01B3C321-B2FC-11d1-A71B-0060083E8C78")
    ICOFFAuxSym : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE TkFile( 
            /* [out] */ OBJTK __RPC_FAR *__MIDL_0064) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ImgAuxSym( 
            /* [in] */ BYTE __RPC_FAR *__MIDL_0065) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Length( 
            /* [out] */ DWORD __RPC_FAR *__MIDL_0066) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CRelocs( 
            /* [out] */ DWORD __RPC_FAR *__MIDL_0067) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CLineNo( 
            /* [out] */ DWORD __RPC_FAR *__MIDL_0068) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CheckSum( 
            /* [out] */ DWORD __RPC_FAR *__MIDL_0069) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ISection( 
            /* [out] */ int __RPC_FAR *__MIDL_0070) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SelType( 
            /* [out] */ BYTE __RPC_FAR *__MIDL_0071) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE TagIndex( 
            /* [out] */ DWORD __RPC_FAR *__MIDL_0072) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MiscLineNo( 
            /* [out] */ DWORD __RPC_FAR *__MIDL_0073) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MiscSize( 
            /* [out] */ DWORD __RPC_FAR *__MIDL_0074) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MiscTotalSize( 
            /* [out] */ DWORD __RPC_FAR *__MIDL_0075) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FcnPLineNo( 
            /* [out] */ DWORD __RPC_FAR *__MIDL_0076) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FcnPNextFcn( 
            /* [out] */ DWORD __RPC_FAR *__MIDL_0077) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AryDim( 
            /* [in] */ DWORD __RPC_FAR *__MIDL_0078,
            /* [in] */ DWORD __MIDL_0079) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE NewSymCrc( 
            /* [out] */ DWORD __RPC_FAR *__MIDL_0080) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICOFFAuxSymVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ICOFFAuxSym __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ICOFFAuxSym __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ICOFFAuxSym __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *TkFile )( 
            ICOFFAuxSym __RPC_FAR * This,
            /* [out] */ OBJTK __RPC_FAR *__MIDL_0064);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ImgAuxSym )( 
            ICOFFAuxSym __RPC_FAR * This,
            /* [in] */ BYTE __RPC_FAR *__MIDL_0065);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Length )( 
            ICOFFAuxSym __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *__MIDL_0066);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CRelocs )( 
            ICOFFAuxSym __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *__MIDL_0067);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CLineNo )( 
            ICOFFAuxSym __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *__MIDL_0068);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CheckSum )( 
            ICOFFAuxSym __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *__MIDL_0069);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ISection )( 
            ICOFFAuxSym __RPC_FAR * This,
            /* [out] */ int __RPC_FAR *__MIDL_0070);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SelType )( 
            ICOFFAuxSym __RPC_FAR * This,
            /* [out] */ BYTE __RPC_FAR *__MIDL_0071);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *TagIndex )( 
            ICOFFAuxSym __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *__MIDL_0072);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MiscLineNo )( 
            ICOFFAuxSym __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *__MIDL_0073);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MiscSize )( 
            ICOFFAuxSym __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *__MIDL_0074);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MiscTotalSize )( 
            ICOFFAuxSym __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *__MIDL_0075);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FcnPLineNo )( 
            ICOFFAuxSym __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *__MIDL_0076);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FcnPNextFcn )( 
            ICOFFAuxSym __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *__MIDL_0077);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AryDim )( 
            ICOFFAuxSym __RPC_FAR * This,
            /* [in] */ DWORD __RPC_FAR *__MIDL_0078,
            /* [in] */ DWORD __MIDL_0079);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *NewSymCrc )( 
            ICOFFAuxSym __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *__MIDL_0080);
        
        END_INTERFACE
    } ICOFFAuxSymVtbl;

    interface ICOFFAuxSym
    {
        CONST_VTBL struct ICOFFAuxSymVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICOFFAuxSym_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICOFFAuxSym_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICOFFAuxSym_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICOFFAuxSym_TkFile(This,__MIDL_0064)	\
    (This)->lpVtbl -> TkFile(This,__MIDL_0064)

#define ICOFFAuxSym_ImgAuxSym(This,__MIDL_0065)	\
    (This)->lpVtbl -> ImgAuxSym(This,__MIDL_0065)

#define ICOFFAuxSym_Length(This,__MIDL_0066)	\
    (This)->lpVtbl -> Length(This,__MIDL_0066)

#define ICOFFAuxSym_CRelocs(This,__MIDL_0067)	\
    (This)->lpVtbl -> CRelocs(This,__MIDL_0067)

#define ICOFFAuxSym_CLineNo(This,__MIDL_0068)	\
    (This)->lpVtbl -> CLineNo(This,__MIDL_0068)

#define ICOFFAuxSym_CheckSum(This,__MIDL_0069)	\
    (This)->lpVtbl -> CheckSum(This,__MIDL_0069)

#define ICOFFAuxSym_ISection(This,__MIDL_0070)	\
    (This)->lpVtbl -> ISection(This,__MIDL_0070)

#define ICOFFAuxSym_SelType(This,__MIDL_0071)	\
    (This)->lpVtbl -> SelType(This,__MIDL_0071)

#define ICOFFAuxSym_TagIndex(This,__MIDL_0072)	\
    (This)->lpVtbl -> TagIndex(This,__MIDL_0072)

#define ICOFFAuxSym_MiscLineNo(This,__MIDL_0073)	\
    (This)->lpVtbl -> MiscLineNo(This,__MIDL_0073)

#define ICOFFAuxSym_MiscSize(This,__MIDL_0074)	\
    (This)->lpVtbl -> MiscSize(This,__MIDL_0074)

#define ICOFFAuxSym_MiscTotalSize(This,__MIDL_0075)	\
    (This)->lpVtbl -> MiscTotalSize(This,__MIDL_0075)

#define ICOFFAuxSym_FcnPLineNo(This,__MIDL_0076)	\
    (This)->lpVtbl -> FcnPLineNo(This,__MIDL_0076)

#define ICOFFAuxSym_FcnPNextFcn(This,__MIDL_0077)	\
    (This)->lpVtbl -> FcnPNextFcn(This,__MIDL_0077)

#define ICOFFAuxSym_AryDim(This,__MIDL_0078,__MIDL_0079)	\
    (This)->lpVtbl -> AryDim(This,__MIDL_0078,__MIDL_0079)

#define ICOFFAuxSym_NewSymCrc(This,__MIDL_0080)	\
    (This)->lpVtbl -> NewSymCrc(This,__MIDL_0080)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICOFFAuxSym_TkFile_Proxy( 
    ICOFFAuxSym __RPC_FAR * This,
    /* [out] */ OBJTK __RPC_FAR *__MIDL_0064);


void __RPC_STUB ICOFFAuxSym_TkFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICOFFAuxSym_ImgAuxSym_Proxy( 
    ICOFFAuxSym __RPC_FAR * This,
    /* [in] */ BYTE __RPC_FAR *__MIDL_0065);


void __RPC_STUB ICOFFAuxSym_ImgAuxSym_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICOFFAuxSym_Length_Proxy( 
    ICOFFAuxSym __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *__MIDL_0066);


void __RPC_STUB ICOFFAuxSym_Length_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICOFFAuxSym_CRelocs_Proxy( 
    ICOFFAuxSym __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *__MIDL_0067);


void __RPC_STUB ICOFFAuxSym_CRelocs_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICOFFAuxSym_CLineNo_Proxy( 
    ICOFFAuxSym __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *__MIDL_0068);


void __RPC_STUB ICOFFAuxSym_CLineNo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICOFFAuxSym_CheckSum_Proxy( 
    ICOFFAuxSym __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *__MIDL_0069);


void __RPC_STUB ICOFFAuxSym_CheckSum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICOFFAuxSym_ISection_Proxy( 
    ICOFFAuxSym __RPC_FAR * This,
    /* [out] */ int __RPC_FAR *__MIDL_0070);


void __RPC_STUB ICOFFAuxSym_ISection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICOFFAuxSym_SelType_Proxy( 
    ICOFFAuxSym __RPC_FAR * This,
    /* [out] */ BYTE __RPC_FAR *__MIDL_0071);


void __RPC_STUB ICOFFAuxSym_SelType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICOFFAuxSym_TagIndex_Proxy( 
    ICOFFAuxSym __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *__MIDL_0072);


void __RPC_STUB ICOFFAuxSym_TagIndex_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICOFFAuxSym_MiscLineNo_Proxy( 
    ICOFFAuxSym __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *__MIDL_0073);


void __RPC_STUB ICOFFAuxSym_MiscLineNo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICOFFAuxSym_MiscSize_Proxy( 
    ICOFFAuxSym __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *__MIDL_0074);


void __RPC_STUB ICOFFAuxSym_MiscSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICOFFAuxSym_MiscTotalSize_Proxy( 
    ICOFFAuxSym __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *__MIDL_0075);


void __RPC_STUB ICOFFAuxSym_MiscTotalSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICOFFAuxSym_FcnPLineNo_Proxy( 
    ICOFFAuxSym __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *__MIDL_0076);


void __RPC_STUB ICOFFAuxSym_FcnPLineNo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICOFFAuxSym_FcnPNextFcn_Proxy( 
    ICOFFAuxSym __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *__MIDL_0077);


void __RPC_STUB ICOFFAuxSym_FcnPNextFcn_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICOFFAuxSym_AryDim_Proxy( 
    ICOFFAuxSym __RPC_FAR * This,
    /* [in] */ DWORD __RPC_FAR *__MIDL_0078,
    /* [in] */ DWORD __MIDL_0079);


void __RPC_STUB ICOFFAuxSym_AryDim_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICOFFAuxSym_NewSymCrc_Proxy( 
    ICOFFAuxSym __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *__MIDL_0080);


void __RPC_STUB ICOFFAuxSym_NewSymCrc_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICOFFAuxSym_INTERFACE_DEFINED__ */


#ifndef __IEnumAuxSym_INTERFACE_DEFINED__
#define __IEnumAuxSym_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IEnumAuxSym
 * at Wed Jun 10 17:42:56 1998
 * using MIDL 3.03.0110
 ****************************************/
/* [unique][uuid][object] */ 


typedef /* [unique] */ IEnumAuxSym __RPC_FAR *PEnumAuxSym;


EXTERN_C const IID IID_IEnumAuxSym;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("083DE150-B461-11d1-A71B-0060083E8C78")
    IEnumAuxSym : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG __MIDL_0081,
            /* [out] */ ICOFFAuxSym __RPC_FAR *__RPC_FAR *__MIDL_0082,
            /* [out] */ ULONG __RPC_FAR *__MIDL_0083) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG __MIDL_0084) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumAuxSym __RPC_FAR *__RPC_FAR *__MIDL_0085) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumAuxSymVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEnumAuxSym __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEnumAuxSym __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEnumAuxSym __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IEnumAuxSym __RPC_FAR * This,
            /* [in] */ ULONG __MIDL_0081,
            /* [out] */ ICOFFAuxSym __RPC_FAR *__RPC_FAR *__MIDL_0082,
            /* [out] */ ULONG __RPC_FAR *__MIDL_0083);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IEnumAuxSym __RPC_FAR * This,
            /* [in] */ ULONG __MIDL_0084);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IEnumAuxSym __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IEnumAuxSym __RPC_FAR * This,
            /* [out] */ IEnumAuxSym __RPC_FAR *__RPC_FAR *__MIDL_0085);
        
        END_INTERFACE
    } IEnumAuxSymVtbl;

    interface IEnumAuxSym
    {
        CONST_VTBL struct IEnumAuxSymVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumAuxSym_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumAuxSym_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumAuxSym_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumAuxSym_Next(This,__MIDL_0081,__MIDL_0082,__MIDL_0083)	\
    (This)->lpVtbl -> Next(This,__MIDL_0081,__MIDL_0082,__MIDL_0083)

#define IEnumAuxSym_Skip(This,__MIDL_0084)	\
    (This)->lpVtbl -> Skip(This,__MIDL_0084)

#define IEnumAuxSym_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumAuxSym_Clone(This,__MIDL_0085)	\
    (This)->lpVtbl -> Clone(This,__MIDL_0085)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumAuxSym_Next_Proxy( 
    IEnumAuxSym __RPC_FAR * This,
    /* [in] */ ULONG __MIDL_0081,
    /* [out] */ ICOFFAuxSym __RPC_FAR *__RPC_FAR *__MIDL_0082,
    /* [out] */ ULONG __RPC_FAR *__MIDL_0083);


void __RPC_STUB IEnumAuxSym_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumAuxSym_Skip_Proxy( 
    IEnumAuxSym __RPC_FAR * This,
    /* [in] */ ULONG __MIDL_0084);


void __RPC_STUB IEnumAuxSym_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumAuxSym_Reset_Proxy( 
    IEnumAuxSym __RPC_FAR * This);


void __RPC_STUB IEnumAuxSym_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumAuxSym_Clone_Proxy( 
    IEnumAuxSym __RPC_FAR * This,
    /* [out] */ IEnumAuxSym __RPC_FAR *__RPC_FAR *__MIDL_0085);


void __RPC_STUB IEnumAuxSym_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumAuxSym_INTERFACE_DEFINED__ */


#ifndef __ICOFFSymRO_INTERFACE_DEFINED__
#define __ICOFFSymRO_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ICOFFSymRO
 * at Wed Jun 10 17:42:56 1998
 * using MIDL 3.03.0110
 ****************************************/
/* [unique][uuid][object] */ 


typedef /* [unique] */ ICOFFSymRO __RPC_FAR *PCOFFSymRO;


EXTERN_C const IID IID_ICOFFSymRO;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CBDFD0D1-B21F-11d1-A71B-0060083E8C78")
    ICOFFSymRO : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CAuxSym( 
            /* [out] */ BYTE __RPC_FAR *__MIDL_0086) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ISection( 
            /* [out] */ int __RPC_FAR *__MIDL_0087) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ISym( 
            /* [out] */ ISYM __RPC_FAR *__MIDL_0088) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StorageClass( 
            /* [out] */ BYTE __RPC_FAR *__MIDL_0089) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SzFile( 
            /* [out] */ PLinkDataRO __RPC_FAR *__MIDL_0090) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SzName( 
            /* [out] */ PLinkDataRO __RPC_FAR *__MIDL_0091) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE TkFile( 
            /* [out] */ OBJTK __RPC_FAR *__MIDL_0092) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Type( 
            /* [out] */ WORD __RPC_FAR *__MIDL_0093) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Value( 
            /* [out] */ DWORD __RPC_FAR *__MIDL_0094) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumAuxSym( 
            /* [out] */ IEnumAuxSym __RPC_FAR *__RPC_FAR *__MIDL_0095) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICOFFSymROVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ICOFFSymRO __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ICOFFSymRO __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ICOFFSymRO __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CAuxSym )( 
            ICOFFSymRO __RPC_FAR * This,
            /* [out] */ BYTE __RPC_FAR *__MIDL_0086);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ISection )( 
            ICOFFSymRO __RPC_FAR * This,
            /* [out] */ int __RPC_FAR *__MIDL_0087);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ISym )( 
            ICOFFSymRO __RPC_FAR * This,
            /* [out] */ ISYM __RPC_FAR *__MIDL_0088);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *StorageClass )( 
            ICOFFSymRO __RPC_FAR * This,
            /* [out] */ BYTE __RPC_FAR *__MIDL_0089);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SzFile )( 
            ICOFFSymRO __RPC_FAR * This,
            /* [out] */ PLinkDataRO __RPC_FAR *__MIDL_0090);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SzName )( 
            ICOFFSymRO __RPC_FAR * This,
            /* [out] */ PLinkDataRO __RPC_FAR *__MIDL_0091);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *TkFile )( 
            ICOFFSymRO __RPC_FAR * This,
            /* [out] */ OBJTK __RPC_FAR *__MIDL_0092);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Type )( 
            ICOFFSymRO __RPC_FAR * This,
            /* [out] */ WORD __RPC_FAR *__MIDL_0093);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Value )( 
            ICOFFSymRO __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *__MIDL_0094);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumAuxSym )( 
            ICOFFSymRO __RPC_FAR * This,
            /* [out] */ IEnumAuxSym __RPC_FAR *__RPC_FAR *__MIDL_0095);
        
        END_INTERFACE
    } ICOFFSymROVtbl;

    interface ICOFFSymRO
    {
        CONST_VTBL struct ICOFFSymROVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICOFFSymRO_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICOFFSymRO_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICOFFSymRO_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICOFFSymRO_CAuxSym(This,__MIDL_0086)	\
    (This)->lpVtbl -> CAuxSym(This,__MIDL_0086)

#define ICOFFSymRO_ISection(This,__MIDL_0087)	\
    (This)->lpVtbl -> ISection(This,__MIDL_0087)

#define ICOFFSymRO_ISym(This,__MIDL_0088)	\
    (This)->lpVtbl -> ISym(This,__MIDL_0088)

#define ICOFFSymRO_StorageClass(This,__MIDL_0089)	\
    (This)->lpVtbl -> StorageClass(This,__MIDL_0089)

#define ICOFFSymRO_SzFile(This,__MIDL_0090)	\
    (This)->lpVtbl -> SzFile(This,__MIDL_0090)

#define ICOFFSymRO_SzName(This,__MIDL_0091)	\
    (This)->lpVtbl -> SzName(This,__MIDL_0091)

#define ICOFFSymRO_TkFile(This,__MIDL_0092)	\
    (This)->lpVtbl -> TkFile(This,__MIDL_0092)

#define ICOFFSymRO_Type(This,__MIDL_0093)	\
    (This)->lpVtbl -> Type(This,__MIDL_0093)

#define ICOFFSymRO_Value(This,__MIDL_0094)	\
    (This)->lpVtbl -> Value(This,__MIDL_0094)

#define ICOFFSymRO_EnumAuxSym(This,__MIDL_0095)	\
    (This)->lpVtbl -> EnumAuxSym(This,__MIDL_0095)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICOFFSymRO_CAuxSym_Proxy( 
    ICOFFSymRO __RPC_FAR * This,
    /* [out] */ BYTE __RPC_FAR *__MIDL_0086);


void __RPC_STUB ICOFFSymRO_CAuxSym_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICOFFSymRO_ISection_Proxy( 
    ICOFFSymRO __RPC_FAR * This,
    /* [out] */ int __RPC_FAR *__MIDL_0087);


void __RPC_STUB ICOFFSymRO_ISection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICOFFSymRO_ISym_Proxy( 
    ICOFFSymRO __RPC_FAR * This,
    /* [out] */ ISYM __RPC_FAR *__MIDL_0088);


void __RPC_STUB ICOFFSymRO_ISym_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICOFFSymRO_StorageClass_Proxy( 
    ICOFFSymRO __RPC_FAR * This,
    /* [out] */ BYTE __RPC_FAR *__MIDL_0089);


void __RPC_STUB ICOFFSymRO_StorageClass_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICOFFSymRO_SzFile_Proxy( 
    ICOFFSymRO __RPC_FAR * This,
    /* [out] */ PLinkDataRO __RPC_FAR *__MIDL_0090);


void __RPC_STUB ICOFFSymRO_SzFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICOFFSymRO_SzName_Proxy( 
    ICOFFSymRO __RPC_FAR * This,
    /* [out] */ PLinkDataRO __RPC_FAR *__MIDL_0091);


void __RPC_STUB ICOFFSymRO_SzName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICOFFSymRO_TkFile_Proxy( 
    ICOFFSymRO __RPC_FAR * This,
    /* [out] */ OBJTK __RPC_FAR *__MIDL_0092);


void __RPC_STUB ICOFFSymRO_TkFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICOFFSymRO_Type_Proxy( 
    ICOFFSymRO __RPC_FAR * This,
    /* [out] */ WORD __RPC_FAR *__MIDL_0093);


void __RPC_STUB ICOFFSymRO_Type_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICOFFSymRO_Value_Proxy( 
    ICOFFSymRO __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *__MIDL_0094);


void __RPC_STUB ICOFFSymRO_Value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICOFFSymRO_EnumAuxSym_Proxy( 
    ICOFFSymRO __RPC_FAR * This,
    /* [out] */ IEnumAuxSym __RPC_FAR *__RPC_FAR *__MIDL_0095);


void __RPC_STUB ICOFFSymRO_EnumAuxSym_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICOFFSymRO_INTERFACE_DEFINED__ */


#ifndef __ICOFFSymRW_INTERFACE_DEFINED__
#define __ICOFFSymRW_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ICOFFSymRW
 * at Wed Jun 10 17:42:56 1998
 * using MIDL 3.03.0110
 ****************************************/
/* [unique][uuid][object] */ 


typedef /* [unique] */ ICOFFSymRW __RPC_FAR *PCOFFSymRW;


EXTERN_C const IID IID_ICOFFSymRW;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("01B3C320-B2FC-11d1-A71B-0060083E8C78")
    ICOFFSymRW : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CAuxSym( 
            /* [out] */ BYTE __RPC_FAR *__MIDL_0096) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ISection( 
            /* [out] */ int __RPC_FAR *__MIDL_0097) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ISym( 
            /* [out] */ DWORD __RPC_FAR *__MIDL_0098) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StorageClass( 
            /* [out] */ BYTE __RPC_FAR *__MIDL_0099) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SzFile( 
            /* [out] */ PLinkDataRO __RPC_FAR *__MIDL_0100) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SzName( 
            /* [out] */ PLinkDataRO __RPC_FAR *__MIDL_0101) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE TkFile( 
            /* [out] */ OBJTK __RPC_FAR *__MIDL_0102) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Type( 
            /* [out] */ WORD __RPC_FAR *__MIDL_0103) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Value( 
            /* [out] */ DWORD __RPC_FAR *__MIDL_0104) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumAuxSym( 
            /* [out] */ IEnumAuxSym __RPC_FAR *__RPC_FAR *__MIDL_0105) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetISection( 
            /* [in] */ int __MIDL_0106) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetValue( 
            /* [in] */ DWORD __MIDL_0107) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICOFFSymRWVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ICOFFSymRW __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ICOFFSymRW __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ICOFFSymRW __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CAuxSym )( 
            ICOFFSymRW __RPC_FAR * This,
            /* [out] */ BYTE __RPC_FAR *__MIDL_0096);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ISection )( 
            ICOFFSymRW __RPC_FAR * This,
            /* [out] */ int __RPC_FAR *__MIDL_0097);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ISym )( 
            ICOFFSymRW __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *__MIDL_0098);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *StorageClass )( 
            ICOFFSymRW __RPC_FAR * This,
            /* [out] */ BYTE __RPC_FAR *__MIDL_0099);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SzFile )( 
            ICOFFSymRW __RPC_FAR * This,
            /* [out] */ PLinkDataRO __RPC_FAR *__MIDL_0100);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SzName )( 
            ICOFFSymRW __RPC_FAR * This,
            /* [out] */ PLinkDataRO __RPC_FAR *__MIDL_0101);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *TkFile )( 
            ICOFFSymRW __RPC_FAR * This,
            /* [out] */ OBJTK __RPC_FAR *__MIDL_0102);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Type )( 
            ICOFFSymRW __RPC_FAR * This,
            /* [out] */ WORD __RPC_FAR *__MIDL_0103);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Value )( 
            ICOFFSymRW __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *__MIDL_0104);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumAuxSym )( 
            ICOFFSymRW __RPC_FAR * This,
            /* [out] */ IEnumAuxSym __RPC_FAR *__RPC_FAR *__MIDL_0105);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetISection )( 
            ICOFFSymRW __RPC_FAR * This,
            /* [in] */ int __MIDL_0106);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetValue )( 
            ICOFFSymRW __RPC_FAR * This,
            /* [in] */ DWORD __MIDL_0107);
        
        END_INTERFACE
    } ICOFFSymRWVtbl;

    interface ICOFFSymRW
    {
        CONST_VTBL struct ICOFFSymRWVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICOFFSymRW_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICOFFSymRW_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICOFFSymRW_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICOFFSymRW_CAuxSym(This,__MIDL_0096)	\
    (This)->lpVtbl -> CAuxSym(This,__MIDL_0096)

#define ICOFFSymRW_ISection(This,__MIDL_0097)	\
    (This)->lpVtbl -> ISection(This,__MIDL_0097)

#define ICOFFSymRW_ISym(This,__MIDL_0098)	\
    (This)->lpVtbl -> ISym(This,__MIDL_0098)

#define ICOFFSymRW_StorageClass(This,__MIDL_0099)	\
    (This)->lpVtbl -> StorageClass(This,__MIDL_0099)

#define ICOFFSymRW_SzFile(This,__MIDL_0100)	\
    (This)->lpVtbl -> SzFile(This,__MIDL_0100)

#define ICOFFSymRW_SzName(This,__MIDL_0101)	\
    (This)->lpVtbl -> SzName(This,__MIDL_0101)

#define ICOFFSymRW_TkFile(This,__MIDL_0102)	\
    (This)->lpVtbl -> TkFile(This,__MIDL_0102)

#define ICOFFSymRW_Type(This,__MIDL_0103)	\
    (This)->lpVtbl -> Type(This,__MIDL_0103)

#define ICOFFSymRW_Value(This,__MIDL_0104)	\
    (This)->lpVtbl -> Value(This,__MIDL_0104)

#define ICOFFSymRW_EnumAuxSym(This,__MIDL_0105)	\
    (This)->lpVtbl -> EnumAuxSym(This,__MIDL_0105)

#define ICOFFSymRW_SetISection(This,__MIDL_0106)	\
    (This)->lpVtbl -> SetISection(This,__MIDL_0106)

#define ICOFFSymRW_SetValue(This,__MIDL_0107)	\
    (This)->lpVtbl -> SetValue(This,__MIDL_0107)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICOFFSymRW_CAuxSym_Proxy( 
    ICOFFSymRW __RPC_FAR * This,
    /* [out] */ BYTE __RPC_FAR *__MIDL_0096);


void __RPC_STUB ICOFFSymRW_CAuxSym_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICOFFSymRW_ISection_Proxy( 
    ICOFFSymRW __RPC_FAR * This,
    /* [out] */ int __RPC_FAR *__MIDL_0097);


void __RPC_STUB ICOFFSymRW_ISection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICOFFSymRW_ISym_Proxy( 
    ICOFFSymRW __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *__MIDL_0098);


void __RPC_STUB ICOFFSymRW_ISym_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICOFFSymRW_StorageClass_Proxy( 
    ICOFFSymRW __RPC_FAR * This,
    /* [out] */ BYTE __RPC_FAR *__MIDL_0099);


void __RPC_STUB ICOFFSymRW_StorageClass_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICOFFSymRW_SzFile_Proxy( 
    ICOFFSymRW __RPC_FAR * This,
    /* [out] */ PLinkDataRO __RPC_FAR *__MIDL_0100);


void __RPC_STUB ICOFFSymRW_SzFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICOFFSymRW_SzName_Proxy( 
    ICOFFSymRW __RPC_FAR * This,
    /* [out] */ PLinkDataRO __RPC_FAR *__MIDL_0101);


void __RPC_STUB ICOFFSymRW_SzName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICOFFSymRW_TkFile_Proxy( 
    ICOFFSymRW __RPC_FAR * This,
    /* [out] */ OBJTK __RPC_FAR *__MIDL_0102);


void __RPC_STUB ICOFFSymRW_TkFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICOFFSymRW_Type_Proxy( 
    ICOFFSymRW __RPC_FAR * This,
    /* [out] */ WORD __RPC_FAR *__MIDL_0103);


void __RPC_STUB ICOFFSymRW_Type_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICOFFSymRW_Value_Proxy( 
    ICOFFSymRW __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *__MIDL_0104);


void __RPC_STUB ICOFFSymRW_Value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICOFFSymRW_EnumAuxSym_Proxy( 
    ICOFFSymRW __RPC_FAR * This,
    /* [out] */ IEnumAuxSym __RPC_FAR *__RPC_FAR *__MIDL_0105);


void __RPC_STUB ICOFFSymRW_EnumAuxSym_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICOFFSymRW_SetISection_Proxy( 
    ICOFFSymRW __RPC_FAR * This,
    /* [in] */ int __MIDL_0106);


void __RPC_STUB ICOFFSymRW_SetISection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICOFFSymRW_SetValue_Proxy( 
    ICOFFSymRW __RPC_FAR * This,
    /* [in] */ DWORD __MIDL_0107);


void __RPC_STUB ICOFFSymRW_SetValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICOFFSymRW_INTERFACE_DEFINED__ */


#ifndef __IEnumCOFFSymRO_INTERFACE_DEFINED__
#define __IEnumCOFFSymRO_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IEnumCOFFSymRO
 * at Wed Jun 10 17:42:56 1998
 * using MIDL 3.03.0110
 ****************************************/
/* [unique][uuid][object] */ 


typedef /* [unique] */ IEnumCOFFSymRO __RPC_FAR *PEnumCOFFSymRO;


EXTERN_C const IID IID_IEnumCOFFSymRO;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("33640AD0-B2C6-11d1-A71B-0060083E8C78")
    IEnumCOFFSymRO : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG __MIDL_0108,
            /* [out] */ ICOFFSymRO __RPC_FAR *__RPC_FAR *__MIDL_0109,
            /* [out] */ ULONG __RPC_FAR *__MIDL_0110) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG __MIDL_0111) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumCOFFSymRO __RPC_FAR *__RPC_FAR *__MIDL_0112) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumCOFFSymROVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEnumCOFFSymRO __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEnumCOFFSymRO __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEnumCOFFSymRO __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IEnumCOFFSymRO __RPC_FAR * This,
            /* [in] */ ULONG __MIDL_0108,
            /* [out] */ ICOFFSymRO __RPC_FAR *__RPC_FAR *__MIDL_0109,
            /* [out] */ ULONG __RPC_FAR *__MIDL_0110);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IEnumCOFFSymRO __RPC_FAR * This,
            /* [in] */ ULONG __MIDL_0111);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IEnumCOFFSymRO __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IEnumCOFFSymRO __RPC_FAR * This,
            /* [out] */ IEnumCOFFSymRO __RPC_FAR *__RPC_FAR *__MIDL_0112);
        
        END_INTERFACE
    } IEnumCOFFSymROVtbl;

    interface IEnumCOFFSymRO
    {
        CONST_VTBL struct IEnumCOFFSymROVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumCOFFSymRO_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumCOFFSymRO_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumCOFFSymRO_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumCOFFSymRO_Next(This,__MIDL_0108,__MIDL_0109,__MIDL_0110)	\
    (This)->lpVtbl -> Next(This,__MIDL_0108,__MIDL_0109,__MIDL_0110)

#define IEnumCOFFSymRO_Skip(This,__MIDL_0111)	\
    (This)->lpVtbl -> Skip(This,__MIDL_0111)

#define IEnumCOFFSymRO_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumCOFFSymRO_Clone(This,__MIDL_0112)	\
    (This)->lpVtbl -> Clone(This,__MIDL_0112)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumCOFFSymRO_Next_Proxy( 
    IEnumCOFFSymRO __RPC_FAR * This,
    /* [in] */ ULONG __MIDL_0108,
    /* [out] */ ICOFFSymRO __RPC_FAR *__RPC_FAR *__MIDL_0109,
    /* [out] */ ULONG __RPC_FAR *__MIDL_0110);


void __RPC_STUB IEnumCOFFSymRO_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumCOFFSymRO_Skip_Proxy( 
    IEnumCOFFSymRO __RPC_FAR * This,
    /* [in] */ ULONG __MIDL_0111);


void __RPC_STUB IEnumCOFFSymRO_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumCOFFSymRO_Reset_Proxy( 
    IEnumCOFFSymRO __RPC_FAR * This);


void __RPC_STUB IEnumCOFFSymRO_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumCOFFSymRO_Clone_Proxy( 
    IEnumCOFFSymRO __RPC_FAR * This,
    /* [out] */ IEnumCOFFSymRO __RPC_FAR *__RPC_FAR *__MIDL_0112);


void __RPC_STUB IEnumCOFFSymRO_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumCOFFSymRO_INTERFACE_DEFINED__ */


#ifndef __IEnumCOFFSymRW_INTERFACE_DEFINED__
#define __IEnumCOFFSymRW_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IEnumCOFFSymRW
 * at Wed Jun 10 17:42:56 1998
 * using MIDL 3.03.0110
 ****************************************/
/* [unique][uuid][object] */ 


typedef /* [unique] */ IEnumCOFFSymRW __RPC_FAR *PEnumCOFFSymRW;


EXTERN_C const IID IID_IEnumCOFFSymRW;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("01B3C322-B2FC-11d1-A71B-0060083E8C78")
    IEnumCOFFSymRW : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG __MIDL_0113,
            /* [out] */ ICOFFSymRW __RPC_FAR *__RPC_FAR *__MIDL_0114,
            /* [out] */ ULONG __RPC_FAR *__MIDL_0115) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG __MIDL_0116) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumCOFFSymRW __RPC_FAR *__RPC_FAR *__MIDL_0117) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumCOFFSymRWVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEnumCOFFSymRW __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEnumCOFFSymRW __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEnumCOFFSymRW __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IEnumCOFFSymRW __RPC_FAR * This,
            /* [in] */ ULONG __MIDL_0113,
            /* [out] */ ICOFFSymRW __RPC_FAR *__RPC_FAR *__MIDL_0114,
            /* [out] */ ULONG __RPC_FAR *__MIDL_0115);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IEnumCOFFSymRW __RPC_FAR * This,
            /* [in] */ ULONG __MIDL_0116);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IEnumCOFFSymRW __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IEnumCOFFSymRW __RPC_FAR * This,
            /* [out] */ IEnumCOFFSymRW __RPC_FAR *__RPC_FAR *__MIDL_0117);
        
        END_INTERFACE
    } IEnumCOFFSymRWVtbl;

    interface IEnumCOFFSymRW
    {
        CONST_VTBL struct IEnumCOFFSymRWVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumCOFFSymRW_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumCOFFSymRW_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumCOFFSymRW_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumCOFFSymRW_Next(This,__MIDL_0113,__MIDL_0114,__MIDL_0115)	\
    (This)->lpVtbl -> Next(This,__MIDL_0113,__MIDL_0114,__MIDL_0115)

#define IEnumCOFFSymRW_Skip(This,__MIDL_0116)	\
    (This)->lpVtbl -> Skip(This,__MIDL_0116)

#define IEnumCOFFSymRW_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumCOFFSymRW_Clone(This,__MIDL_0117)	\
    (This)->lpVtbl -> Clone(This,__MIDL_0117)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumCOFFSymRW_Next_Proxy( 
    IEnumCOFFSymRW __RPC_FAR * This,
    /* [in] */ ULONG __MIDL_0113,
    /* [out] */ ICOFFSymRW __RPC_FAR *__RPC_FAR *__MIDL_0114,
    /* [out] */ ULONG __RPC_FAR *__MIDL_0115);


void __RPC_STUB IEnumCOFFSymRW_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumCOFFSymRW_Skip_Proxy( 
    IEnumCOFFSymRW __RPC_FAR * This,
    /* [in] */ ULONG __MIDL_0116);


void __RPC_STUB IEnumCOFFSymRW_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumCOFFSymRW_Reset_Proxy( 
    IEnumCOFFSymRW __RPC_FAR * This);


void __RPC_STUB IEnumCOFFSymRW_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumCOFFSymRW_Clone_Proxy( 
    IEnumCOFFSymRW __RPC_FAR * This,
    /* [out] */ IEnumCOFFSymRW __RPC_FAR *__RPC_FAR *__MIDL_0117);


void __RPC_STUB IEnumCOFFSymRW_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumCOFFSymRW_INTERFACE_DEFINED__ */


#ifndef __ICOFFSymTabRO_INTERFACE_DEFINED__
#define __ICOFFSymTabRO_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ICOFFSymTabRO
 * at Wed Jun 10 17:42:56 1998
 * using MIDL 3.03.0110
 ****************************************/
/* [unique][uuid][object] */ 


typedef /* [unique] */ ICOFFSymTabRO __RPC_FAR *PCOFFSymTabRO;


EXTERN_C const IID IID_ICOFFSymTabRO;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CBDFD0D0-B21F-11d1-A71B-0060083E8C78")
    ICOFFSymTabRO : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CSymbols( 
            /* [out] */ DWORD __RPC_FAR *__MIDL_0118) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCOFFSymRO( 
            /* [in] */ DWORD __MIDL_0119,
            /* [out] */ ICOFFSymRO __RPC_FAR *__RPC_FAR *__MIDL_0120) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ISYMNextCOFFSymRO( 
            /* [in] */ ICOFFSymRO __RPC_FAR *__MIDL_0121,
            /* [out] */ ISYM __RPC_FAR *__MIDL_0122) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EmitCOFFSymbolTable( 
            /* [out] */ BYTE __RPC_FAR *__MIDL_0123,
            /* [in] */ DWORD __MIDL_0124) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumCOFFSymRO( 
            /* [out] */ IEnumCOFFSymRO __RPC_FAR *__RPC_FAR *__MIDL_0125) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICOFFSymTabROVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ICOFFSymTabRO __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ICOFFSymTabRO __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ICOFFSymTabRO __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CSymbols )( 
            ICOFFSymTabRO __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *__MIDL_0118);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCOFFSymRO )( 
            ICOFFSymTabRO __RPC_FAR * This,
            /* [in] */ DWORD __MIDL_0119,
            /* [out] */ ICOFFSymRO __RPC_FAR *__RPC_FAR *__MIDL_0120);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ISYMNextCOFFSymRO )( 
            ICOFFSymTabRO __RPC_FAR * This,
            /* [in] */ ICOFFSymRO __RPC_FAR *__MIDL_0121,
            /* [out] */ ISYM __RPC_FAR *__MIDL_0122);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EmitCOFFSymbolTable )( 
            ICOFFSymTabRO __RPC_FAR * This,
            /* [out] */ BYTE __RPC_FAR *__MIDL_0123,
            /* [in] */ DWORD __MIDL_0124);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumCOFFSymRO )( 
            ICOFFSymTabRO __RPC_FAR * This,
            /* [out] */ IEnumCOFFSymRO __RPC_FAR *__RPC_FAR *__MIDL_0125);
        
        END_INTERFACE
    } ICOFFSymTabROVtbl;

    interface ICOFFSymTabRO
    {
        CONST_VTBL struct ICOFFSymTabROVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICOFFSymTabRO_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICOFFSymTabRO_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICOFFSymTabRO_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICOFFSymTabRO_CSymbols(This,__MIDL_0118)	\
    (This)->lpVtbl -> CSymbols(This,__MIDL_0118)

#define ICOFFSymTabRO_GetCOFFSymRO(This,__MIDL_0119,__MIDL_0120)	\
    (This)->lpVtbl -> GetCOFFSymRO(This,__MIDL_0119,__MIDL_0120)

#define ICOFFSymTabRO_ISYMNextCOFFSymRO(This,__MIDL_0121,__MIDL_0122)	\
    (This)->lpVtbl -> ISYMNextCOFFSymRO(This,__MIDL_0121,__MIDL_0122)

#define ICOFFSymTabRO_EmitCOFFSymbolTable(This,__MIDL_0123,__MIDL_0124)	\
    (This)->lpVtbl -> EmitCOFFSymbolTable(This,__MIDL_0123,__MIDL_0124)

#define ICOFFSymTabRO_EnumCOFFSymRO(This,__MIDL_0125)	\
    (This)->lpVtbl -> EnumCOFFSymRO(This,__MIDL_0125)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICOFFSymTabRO_CSymbols_Proxy( 
    ICOFFSymTabRO __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *__MIDL_0118);


void __RPC_STUB ICOFFSymTabRO_CSymbols_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICOFFSymTabRO_GetCOFFSymRO_Proxy( 
    ICOFFSymTabRO __RPC_FAR * This,
    /* [in] */ DWORD __MIDL_0119,
    /* [out] */ ICOFFSymRO __RPC_FAR *__RPC_FAR *__MIDL_0120);


void __RPC_STUB ICOFFSymTabRO_GetCOFFSymRO_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICOFFSymTabRO_ISYMNextCOFFSymRO_Proxy( 
    ICOFFSymTabRO __RPC_FAR * This,
    /* [in] */ ICOFFSymRO __RPC_FAR *__MIDL_0121,
    /* [out] */ ISYM __RPC_FAR *__MIDL_0122);


void __RPC_STUB ICOFFSymTabRO_ISYMNextCOFFSymRO_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICOFFSymTabRO_EmitCOFFSymbolTable_Proxy( 
    ICOFFSymTabRO __RPC_FAR * This,
    /* [out] */ BYTE __RPC_FAR *__MIDL_0123,
    /* [in] */ DWORD __MIDL_0124);


void __RPC_STUB ICOFFSymTabRO_EmitCOFFSymbolTable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICOFFSymTabRO_EnumCOFFSymRO_Proxy( 
    ICOFFSymTabRO __RPC_FAR * This,
    /* [out] */ IEnumCOFFSymRO __RPC_FAR *__RPC_FAR *__MIDL_0125);


void __RPC_STUB ICOFFSymTabRO_EnumCOFFSymRO_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICOFFSymTabRO_INTERFACE_DEFINED__ */


#ifndef __ICOFFSymTabRW_INTERFACE_DEFINED__
#define __ICOFFSymTabRW_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ICOFFSymTabRW
 * at Wed Jun 10 17:42:56 1998
 * using MIDL 3.03.0110
 ****************************************/
/* [unique][uuid][object] */ 


typedef /* [unique] */ ICOFFSymTabRW __RPC_FAR *PCOFFSymTabRW;


EXTERN_C const IID IID_ICOFFSymTabRW;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6D2C4950-B788-11d1-A71B-0060083E8C78")
    ICOFFSymTabRW : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CSymbols( 
            /* [out] */ DWORD __RPC_FAR *__MIDL_0126) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCOFFSymRW( 
            /* [in] */ DWORD __MIDL_0127,
            /* [out] */ ICOFFSymRW __RPC_FAR *__RPC_FAR *__MIDL_0128) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ISYMNextCOFFSymRW( 
            /* [in] */ ICOFFSymRW __RPC_FAR *__MIDL_0129,
            /* [out] */ ISYM __RPC_FAR *__MIDL_0130) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EmitCOFFSymbolTable( 
            /* [out] */ BYTE __RPC_FAR *__MIDL_0131,
            /* [in] */ DWORD __MIDL_0132) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumCOFFSymRW( 
            /* [out] */ IEnumCOFFSymRW __RPC_FAR *__RPC_FAR *__MIDL_0133) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICOFFSymTabRWVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ICOFFSymTabRW __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ICOFFSymTabRW __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ICOFFSymTabRW __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CSymbols )( 
            ICOFFSymTabRW __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *__MIDL_0126);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCOFFSymRW )( 
            ICOFFSymTabRW __RPC_FAR * This,
            /* [in] */ DWORD __MIDL_0127,
            /* [out] */ ICOFFSymRW __RPC_FAR *__RPC_FAR *__MIDL_0128);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ISYMNextCOFFSymRW )( 
            ICOFFSymTabRW __RPC_FAR * This,
            /* [in] */ ICOFFSymRW __RPC_FAR *__MIDL_0129,
            /* [out] */ ISYM __RPC_FAR *__MIDL_0130);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EmitCOFFSymbolTable )( 
            ICOFFSymTabRW __RPC_FAR * This,
            /* [out] */ BYTE __RPC_FAR *__MIDL_0131,
            /* [in] */ DWORD __MIDL_0132);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumCOFFSymRW )( 
            ICOFFSymTabRW __RPC_FAR * This,
            /* [out] */ IEnumCOFFSymRW __RPC_FAR *__RPC_FAR *__MIDL_0133);
        
        END_INTERFACE
    } ICOFFSymTabRWVtbl;

    interface ICOFFSymTabRW
    {
        CONST_VTBL struct ICOFFSymTabRWVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICOFFSymTabRW_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICOFFSymTabRW_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICOFFSymTabRW_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICOFFSymTabRW_CSymbols(This,__MIDL_0126)	\
    (This)->lpVtbl -> CSymbols(This,__MIDL_0126)

#define ICOFFSymTabRW_GetCOFFSymRW(This,__MIDL_0127,__MIDL_0128)	\
    (This)->lpVtbl -> GetCOFFSymRW(This,__MIDL_0127,__MIDL_0128)

#define ICOFFSymTabRW_ISYMNextCOFFSymRW(This,__MIDL_0129,__MIDL_0130)	\
    (This)->lpVtbl -> ISYMNextCOFFSymRW(This,__MIDL_0129,__MIDL_0130)

#define ICOFFSymTabRW_EmitCOFFSymbolTable(This,__MIDL_0131,__MIDL_0132)	\
    (This)->lpVtbl -> EmitCOFFSymbolTable(This,__MIDL_0131,__MIDL_0132)

#define ICOFFSymTabRW_EnumCOFFSymRW(This,__MIDL_0133)	\
    (This)->lpVtbl -> EnumCOFFSymRW(This,__MIDL_0133)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICOFFSymTabRW_CSymbols_Proxy( 
    ICOFFSymTabRW __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *__MIDL_0126);


void __RPC_STUB ICOFFSymTabRW_CSymbols_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICOFFSymTabRW_GetCOFFSymRW_Proxy( 
    ICOFFSymTabRW __RPC_FAR * This,
    /* [in] */ DWORD __MIDL_0127,
    /* [out] */ ICOFFSymRW __RPC_FAR *__RPC_FAR *__MIDL_0128);


void __RPC_STUB ICOFFSymTabRW_GetCOFFSymRW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICOFFSymTabRW_ISYMNextCOFFSymRW_Proxy( 
    ICOFFSymTabRW __RPC_FAR * This,
    /* [in] */ ICOFFSymRW __RPC_FAR *__MIDL_0129,
    /* [out] */ ISYM __RPC_FAR *__MIDL_0130);


void __RPC_STUB ICOFFSymTabRW_ISYMNextCOFFSymRW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICOFFSymTabRW_EmitCOFFSymbolTable_Proxy( 
    ICOFFSymTabRW __RPC_FAR * This,
    /* [out] */ BYTE __RPC_FAR *__MIDL_0131,
    /* [in] */ DWORD __MIDL_0132);


void __RPC_STUB ICOFFSymTabRW_EmitCOFFSymbolTable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICOFFSymTabRW_EnumCOFFSymRW_Proxy( 
    ICOFFSymTabRW __RPC_FAR * This,
    /* [out] */ IEnumCOFFSymRW __RPC_FAR *__RPC_FAR *__MIDL_0133);


void __RPC_STUB ICOFFSymTabRW_EnumCOFFSymRW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICOFFSymTabRW_INTERFACE_DEFINED__ */


#ifndef __ICOFFObj_INTERFACE_DEFINED__
#define __ICOFFObj_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ICOFFObj
 * at Wed Jun 10 17:42:56 1998
 * using MIDL 3.03.0110
 ****************************************/
/* [unique][uuid][object] */ 


typedef /* [unique] */ ICOFFObj __RPC_FAR *PCOFFObj;


EXTERN_C const IID IID_ICOFFObj;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A9470BB0-911F-11d1-A712-0060083E8C78")
    ICOFFObj : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE BeginOptCaching( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CContrib( 
            /* [out] */ DWORD __RPC_FAR *__MIDL_0134) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Close( 
            /* [in] */ BOOL __MIDL_0135) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE COFFTimeStamp( 
            /* [out] */ DWORD __RPC_FAR *__MIDL_0136) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CSymbols( 
            /* [out] */ DWORD __RPC_FAR *__MIDL_0137) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EndOptCaching( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumContrib( 
            /* [out] */ IEnumContrib __RPC_FAR *__RPC_FAR *__MIDL_0138) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FImportObj( 
            /* [out] */ BOOL __RPC_FAR *__MIDL_0139) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStringTable( 
            /* [out] */ PLinkDataRO __RPC_FAR *__MIDL_0140) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSymbolTableRO( 
            /* [out] */ ICOFFSymTabRO __RPC_FAR *__RPC_FAR *__MIDL_0141) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSymbolTableRW( 
            /* [out] */ ICOFFSymTabRW __RPC_FAR *__RPC_FAR *__MIDL_0142) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ObjtkFromSzSymbol( 
            /* [in] */ PLinkDataRO __MIDL_0143,
            /* [out] */ OBJTK __RPC_FAR *__MIDL_0144) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE TimeStamp( 
            /* [out] */ DWORD __RPC_FAR *__MIDL_0145) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICOFFObjVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ICOFFObj __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ICOFFObj __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ICOFFObj __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *BeginOptCaching )( 
            ICOFFObj __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CContrib )( 
            ICOFFObj __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *__MIDL_0134);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Close )( 
            ICOFFObj __RPC_FAR * This,
            /* [in] */ BOOL __MIDL_0135);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *COFFTimeStamp )( 
            ICOFFObj __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *__MIDL_0136);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CSymbols )( 
            ICOFFObj __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *__MIDL_0137);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EndOptCaching )( 
            ICOFFObj __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumContrib )( 
            ICOFFObj __RPC_FAR * This,
            /* [out] */ IEnumContrib __RPC_FAR *__RPC_FAR *__MIDL_0138);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FImportObj )( 
            ICOFFObj __RPC_FAR * This,
            /* [out] */ BOOL __RPC_FAR *__MIDL_0139);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStringTable )( 
            ICOFFObj __RPC_FAR * This,
            /* [out] */ PLinkDataRO __RPC_FAR *__MIDL_0140);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSymbolTableRO )( 
            ICOFFObj __RPC_FAR * This,
            /* [out] */ ICOFFSymTabRO __RPC_FAR *__RPC_FAR *__MIDL_0141);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSymbolTableRW )( 
            ICOFFObj __RPC_FAR * This,
            /* [out] */ ICOFFSymTabRW __RPC_FAR *__RPC_FAR *__MIDL_0142);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ObjtkFromSzSymbol )( 
            ICOFFObj __RPC_FAR * This,
            /* [in] */ PLinkDataRO __MIDL_0143,
            /* [out] */ OBJTK __RPC_FAR *__MIDL_0144);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *TimeStamp )( 
            ICOFFObj __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *__MIDL_0145);
        
        END_INTERFACE
    } ICOFFObjVtbl;

    interface ICOFFObj
    {
        CONST_VTBL struct ICOFFObjVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICOFFObj_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICOFFObj_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICOFFObj_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICOFFObj_BeginOptCaching(This)	\
    (This)->lpVtbl -> BeginOptCaching(This)

#define ICOFFObj_CContrib(This,__MIDL_0134)	\
    (This)->lpVtbl -> CContrib(This,__MIDL_0134)

#define ICOFFObj_Close(This,__MIDL_0135)	\
    (This)->lpVtbl -> Close(This,__MIDL_0135)

#define ICOFFObj_COFFTimeStamp(This,__MIDL_0136)	\
    (This)->lpVtbl -> COFFTimeStamp(This,__MIDL_0136)

#define ICOFFObj_CSymbols(This,__MIDL_0137)	\
    (This)->lpVtbl -> CSymbols(This,__MIDL_0137)

#define ICOFFObj_EndOptCaching(This)	\
    (This)->lpVtbl -> EndOptCaching(This)

#define ICOFFObj_EnumContrib(This,__MIDL_0138)	\
    (This)->lpVtbl -> EnumContrib(This,__MIDL_0138)

#define ICOFFObj_FImportObj(This,__MIDL_0139)	\
    (This)->lpVtbl -> FImportObj(This,__MIDL_0139)

#define ICOFFObj_GetStringTable(This,__MIDL_0140)	\
    (This)->lpVtbl -> GetStringTable(This,__MIDL_0140)

#define ICOFFObj_GetSymbolTableRO(This,__MIDL_0141)	\
    (This)->lpVtbl -> GetSymbolTableRO(This,__MIDL_0141)

#define ICOFFObj_GetSymbolTableRW(This,__MIDL_0142)	\
    (This)->lpVtbl -> GetSymbolTableRW(This,__MIDL_0142)

#define ICOFFObj_ObjtkFromSzSymbol(This,__MIDL_0143,__MIDL_0144)	\
    (This)->lpVtbl -> ObjtkFromSzSymbol(This,__MIDL_0143,__MIDL_0144)

#define ICOFFObj_TimeStamp(This,__MIDL_0145)	\
    (This)->lpVtbl -> TimeStamp(This,__MIDL_0145)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICOFFObj_BeginOptCaching_Proxy( 
    ICOFFObj __RPC_FAR * This);


void __RPC_STUB ICOFFObj_BeginOptCaching_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICOFFObj_CContrib_Proxy( 
    ICOFFObj __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *__MIDL_0134);


void __RPC_STUB ICOFFObj_CContrib_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICOFFObj_Close_Proxy( 
    ICOFFObj __RPC_FAR * This,
    /* [in] */ BOOL __MIDL_0135);


void __RPC_STUB ICOFFObj_Close_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICOFFObj_COFFTimeStamp_Proxy( 
    ICOFFObj __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *__MIDL_0136);


void __RPC_STUB ICOFFObj_COFFTimeStamp_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICOFFObj_CSymbols_Proxy( 
    ICOFFObj __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *__MIDL_0137);


void __RPC_STUB ICOFFObj_CSymbols_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICOFFObj_EndOptCaching_Proxy( 
    ICOFFObj __RPC_FAR * This);


void __RPC_STUB ICOFFObj_EndOptCaching_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICOFFObj_EnumContrib_Proxy( 
    ICOFFObj __RPC_FAR * This,
    /* [out] */ IEnumContrib __RPC_FAR *__RPC_FAR *__MIDL_0138);


void __RPC_STUB ICOFFObj_EnumContrib_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICOFFObj_FImportObj_Proxy( 
    ICOFFObj __RPC_FAR * This,
    /* [out] */ BOOL __RPC_FAR *__MIDL_0139);


void __RPC_STUB ICOFFObj_FImportObj_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICOFFObj_GetStringTable_Proxy( 
    ICOFFObj __RPC_FAR * This,
    /* [out] */ PLinkDataRO __RPC_FAR *__MIDL_0140);


void __RPC_STUB ICOFFObj_GetStringTable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICOFFObj_GetSymbolTableRO_Proxy( 
    ICOFFObj __RPC_FAR * This,
    /* [out] */ ICOFFSymTabRO __RPC_FAR *__RPC_FAR *__MIDL_0141);


void __RPC_STUB ICOFFObj_GetSymbolTableRO_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICOFFObj_GetSymbolTableRW_Proxy( 
    ICOFFObj __RPC_FAR * This,
    /* [out] */ ICOFFSymTabRW __RPC_FAR *__RPC_FAR *__MIDL_0142);


void __RPC_STUB ICOFFObj_GetSymbolTableRW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICOFFObj_ObjtkFromSzSymbol_Proxy( 
    ICOFFObj __RPC_FAR * This,
    /* [in] */ PLinkDataRO __MIDL_0143,
    /* [out] */ OBJTK __RPC_FAR *__MIDL_0144);


void __RPC_STUB ICOFFObj_ObjtkFromSzSymbol_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICOFFObj_TimeStamp_Proxy( 
    ICOFFObj __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *__MIDL_0145);


void __RPC_STUB ICOFFObj_TimeStamp_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICOFFObj_INTERFACE_DEFINED__ */


/****************************************
 * Generated header for interface: __MIDL_itf_objint_0090
 * at Wed Jun 10 17:42:56 1998
 * using MIDL 3.03.0110
 ****************************************/
/* [local] */ 


typedef /* [public][public] */ 
enum __MIDL___MIDL_itf_objint_0090_0001
    {	tleMultDef	= 0,
	tleSecAttrib	= tleMultDef + 1,
	tleUnknown	= tleSecAttrib + 1
    }	TLE;



extern RPC_IF_HANDLE __MIDL_itf_objint_0090_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_objint_0090_v0_0_s_ifspec;

#ifndef __ILinkError_INTERFACE_DEFINED__
#define __ILinkError_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ILinkError
 * at Wed Jun 10 17:42:56 1998
 * using MIDL 3.03.0110
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_ILinkError;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2DEBF730-F5C3-11d1-A73F-0060083E8C78")
    ILinkError : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ErrorType( 
            /* [out] */ TLE __RPC_FAR *__MIDL_0146) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Objtk1( 
            /* [out] */ OBJTK __RPC_FAR *__MIDL_0147) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Objtk2( 
            /* [out] */ OBJTK __RPC_FAR *__MIDL_0148) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Sz( 
            /* [out] */ PLinkDataRO __RPC_FAR *__MIDL_0149) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DwInfo( 
            /* [out] */ DWORD __RPC_FAR *__MIDL_0150) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ILinkErrorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ILinkError __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ILinkError __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ILinkError __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ErrorType )( 
            ILinkError __RPC_FAR * This,
            /* [out] */ TLE __RPC_FAR *__MIDL_0146);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Objtk1 )( 
            ILinkError __RPC_FAR * This,
            /* [out] */ OBJTK __RPC_FAR *__MIDL_0147);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Objtk2 )( 
            ILinkError __RPC_FAR * This,
            /* [out] */ OBJTK __RPC_FAR *__MIDL_0148);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Sz )( 
            ILinkError __RPC_FAR * This,
            /* [out] */ PLinkDataRO __RPC_FAR *__MIDL_0149);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DwInfo )( 
            ILinkError __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *__MIDL_0150);
        
        END_INTERFACE
    } ILinkErrorVtbl;

    interface ILinkError
    {
        CONST_VTBL struct ILinkErrorVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ILinkError_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ILinkError_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ILinkError_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ILinkError_ErrorType(This,__MIDL_0146)	\
    (This)->lpVtbl -> ErrorType(This,__MIDL_0146)

#define ILinkError_Objtk1(This,__MIDL_0147)	\
    (This)->lpVtbl -> Objtk1(This,__MIDL_0147)

#define ILinkError_Objtk2(This,__MIDL_0148)	\
    (This)->lpVtbl -> Objtk2(This,__MIDL_0148)

#define ILinkError_Sz(This,__MIDL_0149)	\
    (This)->lpVtbl -> Sz(This,__MIDL_0149)

#define ILinkError_DwInfo(This,__MIDL_0150)	\
    (This)->lpVtbl -> DwInfo(This,__MIDL_0150)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ILinkError_ErrorType_Proxy( 
    ILinkError __RPC_FAR * This,
    /* [out] */ TLE __RPC_FAR *__MIDL_0146);


void __RPC_STUB ILinkError_ErrorType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ILinkError_Objtk1_Proxy( 
    ILinkError __RPC_FAR * This,
    /* [out] */ OBJTK __RPC_FAR *__MIDL_0147);


void __RPC_STUB ILinkError_Objtk1_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ILinkError_Objtk2_Proxy( 
    ILinkError __RPC_FAR * This,
    /* [out] */ OBJTK __RPC_FAR *__MIDL_0148);


void __RPC_STUB ILinkError_Objtk2_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ILinkError_Sz_Proxy( 
    ILinkError __RPC_FAR * This,
    /* [out] */ PLinkDataRO __RPC_FAR *__MIDL_0149);


void __RPC_STUB ILinkError_Sz_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ILinkError_DwInfo_Proxy( 
    ILinkError __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *__MIDL_0150);


void __RPC_STUB ILinkError_DwInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ILinkError_INTERFACE_DEFINED__ */


#ifndef __ILinkNotify_INTERFACE_DEFINED__
#define __ILinkNotify_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ILinkNotify
 * at Wed Jun 10 17:42:56 1998
 * using MIDL 3.03.0110
 ****************************************/
/* [unique][uuid][object] */ 


typedef /* [unique] */ ILinkNotify __RPC_FAR *PLinkNotify;


EXTERN_C const IID IID_ILinkNotify;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9D7E97A0-F5B6-11d1-A73F-0060083E8C78")
    ILinkNotify : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnError( 
            /* [in] */ ILinkError __RPC_FAR *__MIDL_0151) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnStatus( 
            /* [in] */ DWORD __MIDL_0152,
            /* [in] */ DWORD __MIDL_0153) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ILinkNotifyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ILinkNotify __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ILinkNotify __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ILinkNotify __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnError )( 
            ILinkNotify __RPC_FAR * This,
            /* [in] */ ILinkError __RPC_FAR *__MIDL_0151);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnStatus )( 
            ILinkNotify __RPC_FAR * This,
            /* [in] */ DWORD __MIDL_0152,
            /* [in] */ DWORD __MIDL_0153);
        
        END_INTERFACE
    } ILinkNotifyVtbl;

    interface ILinkNotify
    {
        CONST_VTBL struct ILinkNotifyVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ILinkNotify_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ILinkNotify_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ILinkNotify_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ILinkNotify_OnError(This,__MIDL_0151)	\
    (This)->lpVtbl -> OnError(This,__MIDL_0151)

#define ILinkNotify_OnStatus(This,__MIDL_0152,__MIDL_0153)	\
    (This)->lpVtbl -> OnStatus(This,__MIDL_0152,__MIDL_0153)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ILinkNotify_OnError_Proxy( 
    ILinkNotify __RPC_FAR * This,
    /* [in] */ ILinkError __RPC_FAR *__MIDL_0151);


void __RPC_STUB ILinkNotify_OnError_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ILinkNotify_OnStatus_Proxy( 
    ILinkNotify __RPC_FAR * This,
    /* [in] */ DWORD __MIDL_0152,
    /* [in] */ DWORD __MIDL_0153);


void __RPC_STUB ILinkNotify_OnStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ILinkNotify_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long __RPC_FAR *, unsigned long            , BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long __RPC_FAR *, BSTR __RPC_FAR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\vctools\pdb6\langapi\include\ppcimage.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1993  Microsoft Corporation

Module Name:

    ppcimage.h

Abstract:

    This is the include file that describes ppc-specific image info

Author:

    James Stulz (v-james)  July 1993

Revision History:

--*/

#ifndef _PPCIMAGE_
#define _PPCIMAGE_

#define IMAGE_FILE_MACHINE_MPPC_601         0x601   // PowerPC 601.
#define IMAGE_FILE_MPPC_DLL                 0x4000

//
// Power Macintosh relocation types
//

#define IMAGE_REL_MPPC_DESCREL              0x0000
#define IMAGE_REL_MPPC_LCALL                0x0001
#define IMAGE_REL_MPPC_DATAREL              0x0002
#define IMAGE_REL_MPPC_JMPADDR              0x0003
#define IMAGE_REL_MPPC_CREATEDESCRREL       0x0004
#define IMAGE_REL_MPPC_DATADESCRREL         0x0005
#define IMAGE_REL_MPPC_TOCREL               0x0006
#define IMAGE_REL_MPPC_SECTION              0x000A
#define IMAGE_REL_MPPC_SECREL               0x000B
#define IMAGE_REL_MPPC_ADDR24               0x000C // 26-bit address, shifted left 2 (branch absolute)
#define IMAGE_REL_MPPC_ADDR14               0x000D // 16-bit address, shifted left 2 (load doubleword)
#define IMAGE_REL_MPPC_REL24                0x000E // 26-bit PC-relative offset, shifted left 2 (branch relative)
#define IMAGE_REL_MPPC_REL14                0x000F // 16-bit PC-relative offset, shifted left 2 (br cond relative)
#define IMAGE_REL_MPPC_CV                   0x0013
#define IMAGE_REL_MPPC_TOCINDIRCALL         0x0022
#define IMAGE_REL_MPPC_TOCCALLREL           0x0025
#define IMAGE_REL_MPPC_PCODECALL            0x0028
#define IMAGE_REL_MPPC_PCODECALLTONATIVE    0x0029
#define IMAGE_REL_MPPC_PCODENEPE            0x002A

#endif // _PPCIMAGE_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\vctools\pdb6\langapi\include\objectfile.h ===
//-----------------------------------------------------------------------------
//	ObjectFile.h
//
//  Copyright (C) 1997, Microsoft Corporation
//
//  Purpose:
//		Define the classes for reading and groking object files
//
//  Revision History:
//
//	[]		10-Feb-1997 Dans	Created
//
//-----------------------------------------------------------------------------
#pragma once

#if !defined(_objectfile_h)
#define _objectfile_h 1

#include "crefobj.h"
#include "ref.h"
//#include "buffer.h"
#include "simparray.h"

#if !defined(OBJECTFILE_IMPL)
#define IMPORT_EXPORT   __declspec(dllimport)
#else
#define IMPORT_EXPORT   __declspec(dllexport)
#endif

typedef BYTE *                  PB;
typedef const PB                PCB;

namespace objf {

typedef IMAGE_ARCHIVE_MEMBER_HEADER ImgArchMbrHdr;
typedef ImgArchMbrHdr *         PImgArchMbrHdr;
typedef const ImgArchMbrHdr *   PCImgArchMbrHdr;

typedef IMAGE_FILE_HEADER       ImgFileHdr;
typedef ImgFileHdr *            PImgFileHdr;
typedef const PImgFileHdr       PCImgFileHdr;

typedef IMAGE_SECTION_HEADER    ImgSectHdr;
typedef ImgSectHdr *            PImgSectHdr;
typedef const ImgSectHdr *      PCImgSectHdr;

typedef IMAGE_RELOCATION        ImgReloc;
typedef ImgReloc *              PImgReloc;
typedef const ImgReloc *        PCImgReloc;

typedef IMAGE_LINENUMBER        ImgLineNo;
typedef PIMAGE_LINENUMBER       PImgLineNo;

typedef IMAGE_SYMBOL            ImgSym;
typedef ImgSym *                PImgSym;
typedef const ImgSym *          PCImgSym;

typedef IMAGE_AUX_SYMBOL        ImgAuxSym;
typedef ImgAuxSym *             PImgAuxSym;
typedef const ImgAuxSym *       PCImgAuxSym;

// symbol index (not COFF symbol index)
typedef DWORD                   SYMI;
const SYMI                      symiNil = 0;

// coff symbol table index
typedef DWORD                   COFFSYMI;
const COFFSYMI                  coffsymiNil = COFFSYMI(-1);


// munged info for fixups.  
struct FixupMap {
    DWORD   off;    // offset of fixup (in the section)
    DWORD   cb;     // how many bytes the fixup consumes in the data
    };

typedef SimpleArray<BYTE>       RGBYTE;
typedef SimpleArray<FixupMap>   RGFIXUPMAP;
typedef SimpleString            RGCH;

// 
struct SectionStat {
    bool     fComdat : 1;
    bool     fAssoc : 1;
    bool     fFunc : 1;
    bool     fExternal : 1;
    COFFSYMI csymi;
    bool     fImgSec : 1;
    };


#if !defined(pure)
#define pure = 0
#endif

#define Align(p, x)                (((x) & ((p)-1)) ? (((x) & ~((p)-1)) + p) : (x))

class ObjectCode;
class Section;
typedef RefPtr< ObjectCode >    RefObj;
typedef RefPtr< Section >       RefSec;
typedef RefPtr<SimpleString>    RefStr;

PdbInterface EnumSection;
PdbInterface EnumRelocation;
PdbInterface EnumImgSymbol;
PdbInterface EnumExSymbol;
typedef int             ISection;
const ISection          iSectionNil = 0;

const DWORD dwOrdNil = 0;       // 0 is an invalid ordinal number


// Dump flags
enum ODF {          // Object Dump Flags
    odfHdrs     = 0x01,
    odfSects    = 0x02,
    odfFixups   = 0x04,
    odfSyms     = 0x08,
    odfLineNum  = 0x10,
    odfAll      = (odfHdrs | odfSects | odfFixups | odfSyms | odfLineNum),
    odfFmtLong  = 0x20,
    odfFmtShort = 0x40,
    odfFmtByte  = 0x80
    };


// This interface is used by the objfile object to query the caller
// for the location of symbols at runtime.  Used in Section::FApplyFixups, for example.

typedef DWORD CRC;

PdbInterface RunTimeSymTab
{
    // Given a symbol that's undefined in the current module, returns its address,
    // section, and offset.
    virtual bool FAddrFromName( const char*, ISECT*, OFF*, DWORD* ) pure;

    // this returns the location where an object's contribution was loaded, given a name that that
    // contribution exports
    virtual bool FSectAddrFromName( const char*, ISECT*, OFF*, DWORD* ) pure;

    // this returns the location where an object contribution was loaded, given the CRC's that 
    // identify the component - used for statics that aren't defined in the same section
    // as some external.
    virtual bool FSectAddrFromCrc( CRC crcData, CRC crcReloc, DWORD cb, ISECT*, OFF*, DWORD* ) pure;

    // update the callee with line number information
    virtual bool FAddLines ( const char *, ISection, long, CB, long, USHORT, BYTE *, CB ) pure;
};

typedef RunTimeSymTab * PRunTimeSymTab;

// define the interface class to the rest of the world.
class ObjectCode : public CRefCountedObj {
    
public:
    // provide static creation methods so we don't have to expose operator
    // new/delete semantics
    IMPORT_EXPORT static bool __cdecl
    FCreate ( RefObj &, DWORD dwMachineTypeExpected, LPCTSTR szFileName, LPCTSTR szMemberName = 0 );

    IMPORT_EXPORT static bool __cdecl
    FCreate2 ( RefObj &, DWORD dwMachineTypeExpected, LPCTSTR szFileName,
              LPCTSTR szMemberName = 0, DWORD offset =0, DWORD cbObj = 0 );

    virtual COFFSYMI
    CoffSymiFromSymi ( SYMI symi ) const pure;

    // get the symbol index for a particular name
    virtual SYMI
    SymiFromSz ( LPCTSTR szName ) const pure;

    // get the name from a particular symbol index
    virtual LPCTSTR
    SzFromSymi ( SYMI symi ) const pure;

    virtual SYMI
    SymiFromCoffsymi ( COFFSYMI coffsymi ) const pure;

    // get a PImgSym from a coff symbol index
    virtual PCImgSym
    PCImgSymFromCoffsymi ( COFFSYMI coffsymi ) const pure;

    // determine whether the object represents an import
    virtual bool
    FImport ( ) const pure;

    // if the object's an import, return the dll name
    virtual char *
    SzDllName ( RefStr& ) const pure;

    // if the object is an import, returns the ordinal, or
    // dwOrdNil and its exported name
    virtual DWORD
    DwExportOrdinalName ( RefStr& ) const pure;

    virtual bool
    FSectionFromSzSymbol (
        LPCTSTR             szSymbolName,
        PCImgSectHdr &      pcImgSectHdr,
        RefPtr<RGBYTE> &    rgbSectdata,
        RefPtr<RGFIXUPMAP> &rgfixup
        ) const pure;

    virtual bool
    FSectionFromSzSymbol (
        LPCTSTR             szSymbolName,
        RefSec &            rSection
        ) const pure;

    // get the count of sections
    virtual DWORD
    CSections ( ) const pure;

    // get the count of image symbols
    virtual DWORD
    CImgSym ( ) const pure;

    // get a section enumerator
    virtual bool
    FGetEnumSection ( EnumSection ** ) const pure;

    // get a symbol enumerator
    virtual bool
    FGetEnumImgSymbol ( EnumImgSymbol ** ) const pure;

    // get the name of the object
    virtual char*
    SzName ( RefStr& ) const pure;

    // get the name of a symbol
    virtual LPCTSTR
    SzSymbol ( PCImgSym ) const pure;

    // get comdat symbol name defined by isection
    virtual void
    SzSymForIsec ( RGCH&, ISection ) const pure;

    virtual const char *
    SzRelocationType ( WORD, WORD *, bool * ) const pure;

    // emit an object
    virtual bool
    FEmitObject ( LPCTSTR ) pure;

    // emit an object, excluding a list of sections
    virtual bool
    FEmitObject ( LPCTSTR, LPCTSTR *, int ) pure;

    // dump an object
    virtual void
    Dump ( ODF ) const pure;

   };


// define the Section interface class to the rest of the world.
class Section : public CRefCountedObj {

public:

    virtual DWORD
    CRelocation ( ) const pure;

    // get a relocation enumerator
    virtual bool
    FGetEnumRelocation ( EnumRelocation ** ) const pure;

    // get the name of the section
    virtual char *
    SzName ( RefPtr<RGCH>& szName ) const pure;

    virtual DWORD
    CLineNum ( ) const pure;

    virtual DWORD
    CbRawData ( ) const pure;

    virtual DWORD
    dwCharacteristics ( ) const pure;

    virtual CB 
    cbAlignment() const pure;

    virtual bool
    FRawData( RefPtr<RGBYTE>& rgbSectdata ) const pure;

    virtual void
    LoadData ( void * ) const pure;

    virtual bool
    IsComdat() const pure;

    virtual bool
    IsAssociativeComdat() const pure;

    virtual ISection
    AssociativeSection() const pure;

    virtual bool
    FAssociativeSection( RefSec& rsec ) pure;

    virtual bool
    FAbsentInImage( PRunTimeSymTab ) const pure;

    virtual bool
    FImageSection() const pure;

    // apply fixups to the section's data
    virtual bool
    FApplyFixups ( DWORD vaImgBase, DWORD vaSection, PRunTimeSymTab, RefPtr<RGBYTE>& ) pure;

    // retrieve a block of line numbers
    virtual bool
    FGetLineNumbers ( DWORD, ISection, PRunTimeSymTab ) const pure;

    // get the section's statistics
    virtual void
    GetSectionStatistics( SectionStat& ) const pure;

    virtual void
    LoadFixupMap ( void * ) const pure;

    virtual void
    LoadLineNumbers ( void * ) const pure;

    virtual void
    Dump ( ODF ) const pure;

    // get an external symbol enumerator
    virtual bool
    FGetEnumExSymbol ( EnumExSymbol ** ) const pure;

    // get an associative comdat enumerator
    virtual bool
    FGetEnumComdat ( EnumSection ** ) const pure;

    virtual bool
    FGetCrcs ( CRC* pcrcData, CRC* pcrcReloc ) const pure;

    virtual PImgSectHdr
    GetSectionHeader ( ImgSectHdr& ) const pure;

    virtual void
    SetSectionHeader ( ImgSectHdr& ) pure;
    
    virtual void *
    GetDataPtr ( void ) const pure;
};
    
typedef Section *       PSection;

// section enumerator
PdbInterface EnumSection : public Enum {
    virtual void get( RefPtr<Section>& ) pure;
};

// relocation/fixup enumerator
PdbInterface EnumRelocation : public Enum {
    virtual void get( PImgReloc * const ) pure;
};

// symbol enumerator
PdbInterface EnumImgSymbol : public Enum {
    virtual void get ( PImgSym * const ) pure;
};

// external symbol enumerator
PdbInterface EnumExSymbol : public Enum {
    virtual void get ( RefPtr<RGCH>& szName, OFF* off, bool* fFunc ) pure;
};



PdbInterface Library;
typedef RefPtr<Library> RefLib;

// Object enumerator
PdbInterface EnumObject : public Enum {
    virtual void get( RefObj& ) pure;
};

// symbol enumerator
PdbInterface EnumSymbol : public Enum {
    virtual void get ( RefStr& ) pure;
};

PdbInterface Library : public CRefCountedObj {
    
public:
    // provide static creation methods so we don't have to expose operator
    // new/delete semantics
    IMPORT_EXPORT static bool __cdecl
    FCreate ( RefLib &, DWORD, LPCTSTR );

    virtual bool
    FObjectFromSzSymbol (
        LPCTSTR,
        RefObj&
        ) const pure;

    virtual bool
    FObjectFromSzName (
        LPCTSTR,
        RefObj&
        ) const pure;

    // get the count of objects
    virtual DWORD
    CObjects ( ) const pure;

    // get the count of symbols
    virtual DWORD
    CSymbols ( ) const pure;

    // get an object enumerator
    virtual bool
    FGetEnumObject ( EnumObject ** ) const pure;

    // get a symbol enumerator
    virtual bool
    FGetEnumSymbol ( EnumSymbol ** ) const pure;

    // get the name of the library
    virtual char*
    SzName ( RefStr& ) const pure;

};

    PdbInterface Image;
    typedef RefPtr<Image>     RefImg;

    // import enumerator
    PdbInterface EnumImport : public Enum {
        virtual void get ( RefStr& ) pure;
    };

    PdbInterface Image : public CRefCountedObj 
    {
        IMPORT_EXPORT static bool __cdecl
        FCreate ( RefImg &, DWORD dwMachineTypeExpected, LPCTSTR szFileName );

        virtual bool 
        FExportRvaByOrdinal( DWORD dwOrdinal, DWORD* prva, RefStr&  ) const pure;  // rva of export by ordinal

        virtual bool
        FExportRvaByName( LPCTSTR szName, DWORD* prva, RefStr&  )  const pure;  // rva by export name

        virtual bool
        FGetEnumImport ( EnumImport ** ) const pure;

        virtual void Dump( ODF odf ) const pure;

        // get the name of the image
        virtual char*
        SzName ( RefStr& ) const pure;
    };


};      // end of namespace

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\vctools\pdb6\langapi\include\prodids.h ===
//
// define the product identifiers and tags used to identify
// which MS tool built any particular object file
//
#pragma once
#if !defined(_prodids_h)
#define _prodids_h

// define the product ids, encodes version + language

enum PRODID {
    prodidUnknown       = 0x0000,
    prodidImport0       = 0x0001,   // Linker generated import object version 0
    prodidLinker510     = 0x0002,   // LINK 5.10 (Visual Studio 97 SP3)
    prodidCvtomf510     = 0x0003,   // LINK 5.10 (Visual Studio 97 SP3) OMF to COFF conversion
    prodidLinker600     = 0x0004,   // LINK 6.00 (Visual Studio 98)
    prodidCvtomf600     = 0x0005,   // LINK 6.00 (Visual Studio 98) OMF to COFF conversion
    prodidCvtres500     = 0x0006,   // CVTRES 5.00
    prodidUtc11_Basic   = 0x0007,   // VB 5.0 native code
    prodidUtc11_C       = 0x0008,   // VC++ 5.0 C/C++
    prodidUtc12_Basic   = 0x0009,   // VB 6.0 native code
    prodidUtc12_C       = 0x000a,   // VC++ 6.0 C
    prodidUtc12_CPP     = 0x000b,   // VC++ 6.0 C++
    prodidAliasObj60    = 0x000c,   // ALIASOBJ.EXE (CRT Tool that builds OLDNAMES.LIB)
    prodidVisualBasic60 = 0x000d,   // VB 6.0 generated object
    prodidMasm613       = 0x000e,   // MASM 6.13
    prodidMasm701       = 0x000f,   // MASM 7.01
    prodidLinker511     = 0x0010,   // LINK 5.11
    prodidCvtomf511     = 0x0011,   // LINK 5.11 OMF to COFF conversion
    prodidMasm614       = 0x0012,   // MASM 6.14 (MMX2 support)
    prodidLinker512     = 0x0013,   // LINK 5.12
    prodidCvtomf512     = 0x0014,   // LINK 5.12 OMF to COFF conversion
    prodidUtc12_C_Std   = 0x0015,   // VC++ 6.0 C standard edition
    prodidUtc12_CPP_Std = 0x0016,   // VC++ 6.0 C++ standard edition
    prodidUtc12_C_Book  = 0x0017,   // VC++ 6.0 C book edition
    prodidUtc12_CPP_Book= 0x0018,   // VC++ 6.0 C++ book edition
    prodidLinker700     = 0x0019,   // LINK 7.00
    prodidCvtomf700     = 0x001a,   // LINK 7.00 OMF to COFF conversion
    prodidUtc13_Basic   = 0x001b,   // VB 7.0 native code
    prodidUtc13_C       = 0x001c,   // VC++ 7.0 C
    prodidUtc13_CPP     = 0x001d,   // VC++ 7.0 C++
    prodidLinker610     = 0x001e,   // LINK 6.10
    prodidCvtomf610     = 0x001f,   // LINK 6.10 OMF to COFF conversion
    prodidLinker601     = 0x0020,   // LINK 6.01
    prodidCvtomf601     = 0x0021,   // LINK 6.01 OMF to COFF conversion
    prodidUtc12_1_Basic = 0x0022,   // VB 6.1 native code
    prodidUtc12_1_C     = 0x0023,   // VC++ 6.1 C
    prodidUtc12_1_CPP   = 0x0024,   // VC++ 6.1 C++
};

#define DwProdidFromProdidWBuild(prodid, wBuild) ((((unsigned long) (prodid)) << 16) | (wBuild))
#define ProdidFromDwProdid(dwProdid)             ((PRODID) ((dwProdid) >> 16))
#define WBuildFromDwProdid(dwProdid)             ((dwProdid) & 0xFFFF)


    // Symbol name and attributes in coff symbol table (requires windows.h)

#define symProdIdentName    "@comp.id"
#define symProdIdentClass   IMAGE_SYM_CLASS_STATIC
#define symProdIdentSection IMAGE_SYM_ABSOLUTE


    // Define the image data format

typedef struct PRODITEM {
    unsigned long   dwProdid;          // Product identity
    unsigned long   dwCount;           // Count of objects built with that product
} PRODITEM;


enum {
    tagEndID    = 0x536e6144,
    tagBegID    = 0x68636952,
};

/*
  Normally, the DOS header and PE header are contiguous.  We place some data
  in between them if we find at least one tagged object file.

  struct {
    IMAGE_DOS_HEADER dosHeader;
    BYTE             rgbDosStub[N];          // MS-DOS stub
    PRODITEM         { tagEndID, 0 };        // start of tallies (Masked with dwMask)
    PRODITEM         { 0, 0 };               // end of tallies   (Masked with dwMask)
    PRODITEM         rgproditem[];           // variable sized   (Masked with dwMask)
    PRODITEM         { tagBegID, dwMask };   // end of tallies
    PRODITEM         { 0, 0 };               // variable sized
    IMAGE_PE_HEADER  peHeader;
    };

*/


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\vctools\pdb6\langapi\include\pdb.h ===
// Debug Information API
// Copyright (C) 1993-1996, Microsoft Corp.  All Rights Reserved.

#ifndef _VC_VER_INC
#include "..\include\vcver.h"
#endif

#ifndef __PDB_INCLUDED__
#define __PDB_INCLUDED__

typedef int BOOL;
typedef unsigned UINT;
typedef unsigned char BYTE;
typedef unsigned long ULONG;
typedef unsigned short USHORT;
typedef unsigned long DWORD;
typedef unsigned __int64 DWORDLONG;
typedef ULONG   INTV;       // interface version number
typedef ULONG   IMPV;       // implementation version number
typedef ULONG   SIG;        // unique (across PDB instances) signature
typedef ULONG   AGE;        // no. of times this instance has been updated

enum {
    PDBIntv50a  = 19970116,
    PDBIntv50   = 19960502,
    PDBIntv41   = 920924,
    PDBIntvAlt  = PDBIntv50,   // Alternate (backward compatible) supported interface
    PDBIntv     = PDBIntv50a,
};

// cvinfo.h type index, intentionally typedef'ed here to check equivalence.
typedef unsigned short  CV_typ16_t;
typedef unsigned long   CV_typ_t;

typedef CV_typ_t        TI;     // PDB name for type index
typedef CV_typ16_t      TI16;   // 16-bit version
typedef unsigned long   NI;     // name index
typedef TI *            PTi;
typedef TI16 *          PTi16;

typedef BYTE            ITSM;   // type server map index
typedef ITSM*           PITSM;
struct _tagSEARCHDEBUGINFO;
typedef BOOL ( __stdcall * PfnFindDebugInfoFile) ( struct _tagSEARCHDEBUGINFO* );

#if CC_LAZYSYMS
#pragma message("using LAZYSYMS")
#endif
#if CC_LAZYLINES
#pragma message("using LAZYLINES")
#endif

enum {
    niNil        = 0,
    PDB_MAX_PATH = 260,
    cbErrMax     = 1024,
};


#define PdbInterface struct
PdbInterface PDB;                  // program database
PdbInterface DBI;                  // debug information within the PDB
PdbInterface Mod;                  // a module within the DBI
PdbInterface TPI;                  // type info within the DBI
PdbInterface GSI;                  // global symbol info
PdbInterface SO;
PdbInterface Stream;               // some named bytestream in the PDB
PdbInterface StreamImage;          // some memory mapped stream
PdbInterface NameMap;              // name mapping
PdbInterface Enum;                 // generic enumerator
PdbInterface EnumNameMap;          // enumerate names within a NameMap
PdbInterface EnumContrib;          // enumerate contributions
PdbInterface Dbg;                  // misc debug data (FPO, OMAP, etc)

typedef PdbInterface PDB PDB;
typedef PdbInterface DBI DBI;
typedef PdbInterface Mod Mod;
typedef PdbInterface TPI TPI;
typedef PdbInterface GSI GSI;
typedef PdbInterface SO SO;
typedef PdbInterface Stream Stream;
typedef PdbInterface StreamImage StreamImage;
typedef PdbInterface NameMap NameMap;
typedef PdbInterface Enum Enum;
typedef PdbInterface EnumStreamNames EnumStreamNames;
typedef PdbInterface EnumNameMap EnumNameMap;
typedef PdbInterface EnumContrib EnumContrib;
typedef PdbInterface WidenTi WidenTi;
typedef PdbInterface Dbg Dbg;
typedef PdbInterface EnumThunk EnumThunk;


typedef long EC;            // error code
enum PDBErrors {
    EC_OK,                  // -, no problemo
    EC_USAGE,               // -, invalid parameter or call order
    EC_OUT_OF_MEMORY,       // -, out of RAM
    EC_FILE_SYSTEM,         // "pdb name", can't write file, out of disk, etc.
    EC_NOT_FOUND,           // "pdb name", PDB file not found
    EC_INVALID_SIG,         // "pdb name", PDB::OpenValidate() and its clients only
    EC_INVALID_AGE,         // "pdb name", PDB::OpenValidate() and its clients only
    EC_PRECOMP_REQUIRED,    // "obj name", Mod::AddTypes() only
    EC_OUT_OF_TI,           // "pdb name", TPI::QueryTiForCVRecord() only
    EC_NOT_IMPLEMENTED,     // -
    EC_V1_PDB,              // "pdb name", PDB::Open* only
    EC_FORMAT,              // accessing pdb with obsolete format
    EC_LIMIT,
    EC_CORRUPT,             // cv info corrupt, recompile mod
    EC_TI16,                // no 16-bit type interface present
    EC_ACCESS_DENIED,       // "pdb name", PDB file read-only
    EC_ILLEGAL_TYPE_EDIT,   // trying to edit types in read-only mode
    EC_INVALID_EXECUTABLE,  // not recogized as a valid executable
    EC_DBG_NOT_FOUND,       // A required .DBG file was not found
    EC_NO_DEBUG_INFO,       // No recognized debug info found
	EC_INVALID_EXE_TIMESTAMP, // Invalid timestamp on Openvalidate of exe
	EC_RESERVED, // RESERVED for future use
	EC_DEBUG_INFO_NOT_IN_PDB,		 // returned by OpenValidate3 and OpenValidate4
    EC_MAX
};

#define  pure = 0

#ifndef PDBCALL
#define PDBCALL  __cdecl
#endif

#ifdef PDB_SERVER
#define PDB_IMPORT_EXPORT(RTYPE)    __declspec(dllexport) RTYPE PDBCALL
#elif   defined(PDB_LIBRARY)
#define PDB_IMPORT_EXPORT(RTYPE)    RTYPE PDBCALL
#else
#define PDB_IMPORT_EXPORT(RTYPE)    __declspec(dllimport) RTYPE PDBCALL
#endif

#define PDBAPI PDB_IMPORT_EXPORT

#ifndef IN
#define IN                  /* in parameter, parameters are IN by default */
#endif
#ifndef OUT
#define OUT                 /* out parameter */
#endif

// type of callback arg to PDB::GetRawBytes
typedef BOOL (PDBCALL *PFNfReadPDBRawBytes)(const void *, long);

// WidenTi interface needs a couple of structures to communicate info back
// and forth.
struct OffMap {
    ULONG       offOld;
    ULONG       offNew;
};
typedef struct OffMap   OffMap;
typedef OffMap *        POffMap;

struct SymConvertInfo {
    ULONG       cbSyms;             // size necessary for converting a block
    ULONG       cSyms;              // count of symbols, necessary to allocate
                                    // mpoffOldoffNew array.
    BYTE *      pbSyms;             // block of symbols (output side)
    OffMap *    rgOffMap;           // OffMap rgOffMap[cSyms]
};
typedef struct SymConvertInfo   SymConvertInfo;
enum { wtiSymsNB09 = 0, wtiSymsNB10 = 1 };

// Filter values for PDBCopyTo
enum { 
    copyRemovePrivate       = 0x00000001,   // remove private debug information
    copyCreateNewSig        = 0x00000002,   // create new signature for target pdb
};

enum DBGTYPE {
    dbgtypeFPO,
    dbgtypeException,
    dbgtypeFixup,
    dbgtypeOmapToSrc,
    dbgtypeOmapFromSrc,
    dbgtypeSectionHdr,
};

typedef enum DBGTYPE DBGTYPE;

// Linker data necessary for relinking an image.  Record contains two SZ strings
// off of the end of the record with two offsets from the base 
//
enum VerLinkInfo {
    vliOne = 1,
    vliTwo = 2,
    vliCur = vliTwo,
};

struct LinkInfo {
    ULONG           cb;             // size of the whole record.  computed as
                                    //  sizeof(LinkInfo) + strlen(szCwd) + 1 +
                                    //  strlen(szCommand) + 1
    ULONG           ver;            // version of this record (VerLinkInfo)
    ULONG           offszCwd;       // offset from base of this record to szCwd
    ULONG           offszCommand;   // offset from base of this record
    ULONG           ichOutfile;     // index of start of output file in szCommand
    ULONG           offszLibs;      // offset from base of this record to szLibs

    // The command includes the full path to the linker, the -re and -out:...
    // swithches.
    // A sample might look like the following:
    // "c:\program files\msdev\bin\link.exe -re -out:debug\foo.exe"
    // with ichOutfile being 48.
    // the -out switch is guaranteed to be the last item in the command line.
#ifdef __cplusplus
    VerLinkInfo Ver() const {
        return VerLinkInfo(ver);
    }
    long Cb() const {
        return cb;
    }
    char *     SzCwd() const {
        return (char *)((char *)(this) + offszCwd);
    }
    char *    SzCommand() const {
        return (char *)((char *)(this) + offszCommand);
    }
    char *    SzOutFile() const {
        return SzCommand() + ichOutfile;
    }
    LinkInfo() :
        cb(0), ver(vliCur), offszCwd(0), offszCommand(0), ichOutfile(0)
    {
    }
    char *    SzLibs() const {
        return (char *)((char *)(this) + offszLibs);
    }

#endif
};

typedef struct LinkInfo LinkInfo;
typedef LinkInfo *      PLinkInfo;


#ifdef __cplusplus

// C++ Binding

PdbInterface PDB {                 // program database
    enum {
        intv  = PDBIntv,
        intvAlt = PDBIntvAlt
    };
    static PDBAPI(BOOL) OpenValidate(/*const*/ char* szPDB, /*const*/ char* szPath,
                /*const*/ char* szMode, SIG sig, AGE age,
                OUT EC* pec, OUT char szError[cbErrMax], OUT PDB** pppdb);
    static PDBAPI(BOOL) OpenValidateEx(/*const*/ char* szPDB, /*const*/ char* szPathOrig,
                /*const*/ char* szSearchPath, /*const*/ char* szMode,   SIG sig, AGE age,
                OUT EC* pec, OUT char szError[cbErrMax], OUT PDB** pppdb);
    static PDBAPI(BOOL) Open(/*const*/ char* szPDB, /*const*/ char* szMode, SIG sigInitial,
                OUT EC* pec, OUT char szError[cbErrMax], OUT PDB** pppdb);
    static PDBAPI(BOOL) OpenValidate2(/*const*/ char* szPDB, /*const*/ char* szPath,
                /*const*/ char* szMode, SIG sig, AGE age, long cbPage,
                OUT EC* pec, OUT char szError[cbErrMax], OUT PDB** pppdb);
    static PDBAPI(BOOL) OpenValidateEx2(/*const*/ char* szPDB, /*const*/ char* szPathOrig,
                /*const*/ char* szSearchPath, /*const*/ char* szMode,   SIG sig, AGE age,
                long cbPage, OUT EC* pec, OUT char szError[cbErrMax], OUT PDB** pppdb);
    static PDBAPI(BOOL) OpenEx(/*const*/ char* szPDB, /*const*/ char* szMode, SIG sigInitial,
                long cbPage, OUT EC* pec, OUT char szError[cbErrMax], OUT PDB** pppdb);
    static PDBAPI(BOOL) OpenValidate3(const char *szExecutable,const char *szSearchPath,
                OUT EC *pec, OUT char szError[cbErrMax],
                OUT char szDbgPath[PDB_MAX_PATH], OUT DWORD *pfo, OUT DWORD *pcb,
                OUT PDB **pppdb);

    static PDBAPI(BOOL) OpenValidate4(const char *szExecutable,
                const char *szSearchPath, OUT DWORDLONG *pTimeStamp,
                OUT EC *pec, OUT char szError[cbErrMax],
                OUT char szDbgPath[PDB_MAX_PATH], OUT DWORD *pfo, OUT DWORD *pcb,
                OUT PDB **pppdb);

    static PDBAPI(BOOL) ExportValidateInterface(INTV intv);
    virtual INTV QueryInterfaceVersion() pure;
    virtual IMPV QueryImplementationVersion() pure;
    virtual EC   QueryLastError(OUT char szError[cbErrMax]) pure;
    virtual char*QueryPDBName(OUT char szPDB[PDB_MAX_PATH]) pure;
    virtual SIG  QuerySignature() pure;
    virtual AGE  QueryAge() pure;
    virtual BOOL CreateDBI(const char* szTarget, OUT DBI** ppdbi) pure;
    virtual BOOL OpenDBI(const char* szTarget, const char* szMode, OUT DBI** ppdbi ) pure;
    virtual BOOL OpenTpi(const char* szMode, OUT TPI** pptpi) pure;

    virtual BOOL Commit() pure;
    virtual BOOL Close() pure;
    virtual BOOL OpenStream(const char* szStream, OUT Stream** ppstream) pure;
    virtual BOOL GetEnumStreamNameMap(OUT Enum** ppenum) pure;
    virtual BOOL GetRawBytes(PFNfReadPDBRawBytes fSnarfRawBytes) pure;
    virtual IMPV QueryPdbImplementationVersion() pure;

    virtual BOOL OpenDBIEx(const char* szTarget, const char* szMode, OUT DBI** ppdbi, PfnFindDebugInfoFile pfn=0) pure;

    virtual BOOL CopyTo(const char *szDst, DWORD dwCopyFilter, DWORD dwReserved) pure;

    inline BOOL ValidateInterface()
    {
        return ExportValidateInterface(intv);
    }
};


// Review: a stream directory service would be more appropriate
// than Stream::Delete, ...

PdbInterface Stream {
    virtual long   QueryCb() pure;
    virtual BOOL Read(long off, void* pvBuf, long* pcbBuf) pure;
    virtual BOOL Write(long off, void* pvBuf, long cbBuf) pure;
    virtual BOOL Replace(void* pvBuf, long cbBuf) pure;
    virtual BOOL Append(void* pvBuf, long cbBuf) pure;
    virtual BOOL Delete() pure;
    virtual BOOL Release() pure;
    virtual BOOL Read2(long off, void* pvBuf, long cbBuf) pure;
    virtual BOOL Truncate(long cb) pure;
};

PdbInterface StreamImage {
    static PDBAPI(BOOL) open(Stream* pstream, long cb, OUT StreamImage** ppsi);
    virtual long size() pure;
    virtual void* base() pure;
    virtual BOOL noteRead(long off, long cb, OUT void** ppv) pure;
    virtual BOOL noteWrite(long off, long cb, OUT void** ppv) pure;
    virtual BOOL writeBack() pure;
    virtual BOOL release() pure;
};

PdbInterface DBI {             // debug information
    enum { intv = PDBIntv };
    virtual IMPV QueryImplementationVersion() pure;
    virtual INTV QueryInterfaceVersion() pure;
    virtual BOOL OpenMod(const char* szModule, const char* szFile, OUT Mod** ppmod) pure;
    virtual BOOL DeleteMod(const char* szModule) pure;
    virtual BOOL QueryNextMod(Mod* pmod, Mod** ppmodNext) pure;
    virtual BOOL OpenGlobals(OUT GSI **ppgsi) pure;
    virtual BOOL OpenPublics(OUT GSI **ppgsi) pure;
    virtual BOOL AddSec(USHORT isect, USHORT flags, long off, long cb) pure;
    virtual BOOL QueryModFromAddr(USHORT isect, long off, OUT Mod** ppmod,
                    OUT USHORT* pisect, OUT long* poff, OUT long* pcb) pure;
    virtual BOOL QuerySecMap(OUT BYTE* pb, long* pcb) pure;
    virtual BOOL QueryFileInfo(OUT BYTE* pb, long* pcb) pure;
    virtual void DumpMods() pure;
    virtual void DumpSecContribs() pure;
    virtual void DumpSecMap() pure;

    virtual BOOL Close() pure;
    virtual BOOL AddThunkMap(long* poffThunkMap, unsigned nThunks, long cbSizeOfThunk,
                    struct SO* psoSectMap, unsigned nSects,
                    USHORT isectThunkTable, long offThunkTable) pure;
    virtual BOOL AddPublic(const char* szPublic, USHORT isect, long off) pure;
    virtual BOOL getEnumContrib(OUT Enum** ppenum) pure;
    virtual BOOL QueryTypeServer( ITSM itsm, OUT TPI** pptpi ) pure;
    virtual BOOL QueryItsmForTi( TI ti, OUT ITSM* pitsm ) pure;
    virtual BOOL QueryNextItsm( ITSM itsm, OUT ITSM *inext ) pure;
    virtual BOOL QueryLazyTypes() pure;
    virtual BOOL SetLazyTypes( BOOL fLazy ) pure;   // lazy is default and can only be turned off
    virtual BOOL FindTypeServers( OUT EC* pec, OUT char szError[cbErrMax] ) pure;
    virtual void DumpTypeServers() pure;
    virtual BOOL OpenDbg(DBGTYPE dbgtype, OUT Dbg **ppdbg) pure;
    virtual BOOL QueryDbgTypes(OUT DBGTYPE *pdbgtype, OUT long* pcDbgtype) pure;
    // apis to support EnC work
    virtual BOOL QueryAddrForSec(OUT USHORT* pisect, OUT long* poff, 
            USHORT imod, long cb, DWORD dwDataCrc, DWORD dwRelocCrc) pure;
    virtual BOOL QuerySupportsEC() pure;
    virtual BOOL QueryPdb( OUT PDB** pppdb ) pure;
    virtual BOOL AddLinkInfo(IN PLinkInfo ) pure;
    virtual BOOL QueryLinkInfo(PLinkInfo, OUT long * pcb) pure;
    // new to vc6
    virtual AGE  QueryAge() const pure;
    virtual void * QueryHeader() const pure;
    virtual void FlushTypeServers() pure;
    virtual BOOL QueryTypeServerByPdb( const char* szPdb, OUT ITSM* pitsm ) pure;
};

PdbInterface Mod {             // info for one module within DBI
    enum { intv = PDBIntv };
    virtual INTV QueryInterfaceVersion() pure;
    virtual IMPV QueryImplementationVersion() pure;
    virtual BOOL AddTypes(BYTE* pbTypes, long cb) pure;
#if CC_LAZYSYMS
    virtual BOOL AddSymbols(BYTE* pbSym, long cb, unsigned icon) pure;
#else
    virtual BOOL AddSymbols(BYTE* pbSym, long cb) pure;
#endif
    virtual BOOL AddPublic(const char* szPublic, USHORT isect, long off) pure;
#if CC_LAZYLINES
    virtual BOOL AddLines(const char* szSrc, USHORT isect, long offCon, long cbCon, long doff,
                          USHORT lineStart, BYTE* pbCoff, long cbCoff, ULONG foCoff = 0) pure;
#else
    virtual BOOL AddLines(const char* szSrc, USHORT isect, long offCon, long cbCon, long doff,
                          USHORT lineStart, BYTE* pbCoff, long cbCoff) pure;
#endif
    virtual BOOL AddSecContrib(USHORT isect, long off, long cb, ULONG dwCharacteristics) pure;
    virtual BOOL QueryCBName(OUT long* pcb) pure;
    virtual BOOL QueryName(OUT char szName[PDB_MAX_PATH], OUT long* pcb) pure;
    virtual BOOL QuerySymbols(BYTE* pbSym, long* pcb) pure;
    virtual BOOL QueryLines(BYTE* pbLines, long* pcb) pure;

    virtual BOOL SetPvClient(void *pvClient) pure;
    virtual BOOL GetPvClient(OUT void** ppvClient) pure;
    virtual BOOL QuerySecContrib(OUT USHORT* pisect, OUT long* poff, OUT long* pcb, OUT ULONG* pdwCharacteristics) pure;
    virtual BOOL QueryImod(OUT USHORT* pimod) pure;
    virtual BOOL QueryDBI(OUT DBI** ppdbi) pure;
    virtual BOOL Close() pure;
    virtual BOOL QueryCBFile(OUT long* pcb) pure;
    virtual BOOL QueryFile(OUT char szFile[PDB_MAX_PATH], OUT long* pcb) pure;
    virtual BOOL QueryTpi(OUT TPI** pptpi) pure; // return this Mod's Tpi
    // apis to support EnC work
    virtual BOOL AddSecContribEx(USHORT isect, long off, long cb, ULONG dwCharacteristics, DWORD dwDataCrc, DWORD dwRelocCrc) pure;
    virtual BOOL QueryItsm(OUT USHORT* pitsm) pure;
    virtual BOOL QuerySrcFile(OUT char szFile[PDB_MAX_PATH], OUT long* pcb) pure;
    virtual BOOL QuerySupportsEC() pure;
};

PdbInterface TPI {             // type info

    enum { intv = PDBIntv };

    virtual INTV QueryInterfaceVersion() pure;
    virtual IMPV QueryImplementationVersion() pure;

    virtual BOOL QueryTi16ForCVRecord(BYTE* pb, OUT TI16* pti) pure;
    virtual BOOL QueryCVRecordForTi16(TI16 ti, OUT BYTE* pb, IN OUT long* pcb) pure;
    virtual BOOL QueryPbCVRecordForTi16(TI16 ti, OUT BYTE** ppb) pure;
    virtual TI16 QueryTi16Min() pure;
    virtual TI16 QueryTi16Mac() pure;

    virtual long QueryCb() pure;
    virtual BOOL Close() pure;
    virtual BOOL Commit() pure;

    virtual BOOL QueryTi16ForUDT(char* sz, BOOL fCase, OUT TI16* pti) pure;
    virtual BOOL SupportQueryTiForUDT() pure;

    // the new versions that truly take 32-bit types
    virtual BOOL fIs16bitTypePool() pure;
    virtual BOOL QueryTiForUDT(char* sz, BOOL fCase, OUT TI* pti) pure;
    virtual BOOL QueryTiForCVRecord(BYTE* pb, OUT TI* pti) pure;
    virtual BOOL QueryCVRecordForTi(TI ti, OUT BYTE* pb, IN OUT long* pcb) pure;
    virtual BOOL QueryPbCVRecordForTi(TI ti, OUT BYTE** ppb) pure;
    virtual TI   QueryTiMin() pure;
    virtual TI   QueryTiMac() pure;
    virtual BOOL AreTypesEqual( TI ti1, TI ti2 ) pure;
    virtual BOOL IsTypeServed( TI ti ) pure;
};

PdbInterface GSI {
    enum { intv = PDBIntv };
    virtual INTV QueryInterfaceVersion() pure;
    virtual IMPV QueryImplementationVersion() pure;
    virtual BYTE* NextSym (BYTE* pbSym) pure;
    virtual BYTE* HashSym (const char* szName, BYTE* pbSym) pure;
    virtual BYTE* NearestSym (USHORT isect, long off, OUT long* pdisp) pure;      //currently only supported for publics
    virtual BOOL Close() pure;
    virtual BOOL getEnumThunk( USHORT isect, long off, OUT EnumThunk** ppenum ) pure;
};


PdbInterface NameMap {
    static PDBAPI(BOOL) open(PDB* ppdb, BOOL fWrite, OUT NameMap** ppnm);
    virtual BOOL close() pure;
    virtual BOOL reinitialize() pure;
    virtual BOOL getNi(const char* sz, OUT NI* pni) pure;
    virtual BOOL getName(NI ni, OUT const char** psz) pure;
    virtual BOOL getEnumNameMap(OUT Enum** ppenum) pure;
    virtual BOOL contains(const char* sz, OUT NI* pni) pure;
    virtual BOOL commit() pure;
    virtual BOOL isValidNi(NI ni) pure;
};

#define __ENUM_INCLUDED__
PdbInterface Enum {
    virtual void release() pure;
    virtual void reset() pure;
    virtual BOOL next() pure;
};

PdbInterface EnumNameMap : Enum {
    virtual void get(OUT const char** psz, OUT NI* pni) pure;
};

PdbInterface EnumContrib : Enum {
    virtual void get(OUT USHORT* pimod, OUT USHORT* pisect, OUT long* poff, OUT long* pcb, OUT ULONG* pdwCharacteristics) pure;
    virtual void getCrcs(OUT DWORD* pcrcData, OUT DWORD* pcrcReloc ) pure;
};

PdbInterface EnumThunk: Enum {
	virtual void get( OUT USHORT* pisect, OUT long* poff, OUT long* pcb ) pure;
};

//
// interface to use to widen type indices from 16 to 32 bits
// and store the results in a new location.
//
PdbInterface WidenTi {
public:
    static PDBAPI(BOOL)
    fCreate (
        WidenTi *&,
        unsigned cTypeInitialCache =256,
        BOOL fNB10Syms =wtiSymsNB09
        );

    virtual void
    release() pure;

    virtual BYTE /* TYPTYPE */ *
    pTypeWidenTi ( TI ti16, BYTE /* TYPTYPE */ * ) pure;

    virtual BYTE /* SYMTYPE */ *
    pSymWidenTi ( BYTE /* SYMTYPE */ * ) pure;

    virtual BOOL
    fTypeWidenTiNoCache ( BYTE * pbTypeDst, BYTE * pbTypeSrc, long & cbDst ) pure;

    virtual BOOL
    fSymWidenTiNoCache ( BYTE * pbSymDst, BYTE * pbSymSrc, long & cbDst ) pure;

    virtual BOOL
    fTypeNeedsWidening ( BYTE * pbType ) pure;

    virtual BOOL
    fSymNeedsWidening ( BYTE * pbSym ) pure;

    virtual BOOL
    freeRecord ( void * ) pure;

    // symbol block converters/query.  symbols start at doff from pbSymIn,
    // converted symbols will go at sci.pbSyms + doff, cbSyms are all including
    // doff.
    virtual BOOL
        fQuerySymConvertInfo (
        SymConvertInfo &    sciOut,
        BYTE *              pbSym,
        long                cbSym,
        int                 doff =0
        ) pure;

    virtual BOOL
    fConvertSymbolBlock (
        SymConvertInfo &    sciOut,
        BYTE *              pbSymIn,
        long                cbSymIn,
        int                 doff =0
        ) pure;
};

// interface for managing Dbg data
PdbInterface Dbg {
   // close Dbg Interface
   virtual BOOL Close() pure;
   // return number of elements (NOT bytes)
   virtual long QuerySize() pure;
   // reset enumeration index
   virtual void Reset() pure;
   // skip next celt elements (move enumeration index)
   virtual BOOL Skip(ULONG celt) pure;
   // query next celt elements into user-supplied buffer
   virtual BOOL QueryNext(ULONG celt, OUT void *rgelt) pure;
   // search for an element and fill in the entire struct given a field.
   // Only supported for the following debug types and fields:
   // DBG_FPO              'ulOffStart' field of FPO_DATA
   // DBG_FUNC             'StartingAddress' field of IMAGE_FUNCTION_ENTRY
   // DBG_OMAP             'rva' field of OMAP
   virtual BOOL Find(IN OUT void *pelt) pure;
   // remove debug data
   virtual BOOL Clear() pure;
   // append celt elements
   virtual BOOL Append(ULONG celt, const void *rgelt) pure;
   // replace next celt elements
   virtual BOOL ReplaceNext(ULONG celt, const void *rgelt) pure;
};

#endif  // __cplusplus

// ANSI C Binding

#if __cplusplus
extern "C" {
#endif

PDBAPI(BOOL)
PDBOpenValidate(
    /*const*/ char* szPDB,
    /*const*/ char* szPath,
    /*const*/ char* szMode,
    SIG sig,
    AGE age,
    OUT EC* pec,
    OUT char szError[cbErrMax],
    OUT PDB** pppdb);

PDBAPI(BOOL)
PDBOpenValidateEx(
    /*const*/ char* szPDB,
    /*const*/ char* szPathOrig,
    /*const*/ char* szSearchPath,
    /*const*/ char* szMode,
    SIG sig,
    AGE age,
    OUT EC* pec,
    OUT char szError[cbErrMax],
    OUT PDB** pppdb);

PDBAPI(BOOL)
PDBOpen(
    /*const*/ char* szPDB,
    /*const*/ char* szMode,
    SIG sigInitial,
    OUT EC* pec,
    OUT char szError[cbErrMax],
    OUT PDB** pppdb);

typedef BOOL (PDBCALL *PfnPDBOpen)(
    char*,
    char*,
    SIG,
    EC*,
    char [cbErrMax],
    PDB**);

PDBAPI(BOOL)
PDBOpenValidate2(
    /*const*/ char* szPDB,
    /*const*/ char* szPath,
    /*const*/ char* szMode,
    SIG sig,
    AGE age,
    long cbPage,
    OUT EC* pec,
    OUT char szError[cbErrMax],
    OUT PDB** pppdb);

PDBAPI(BOOL)
PDBOpenValidateEx2(
    /*const*/ char* szPDB,
    /*const*/ char* szPathOrig,
    /*const*/ char* szSearchPath,
    /*const*/ char* szMode,
    SIG sig,
    AGE age,
    long cbPage,
    OUT EC* pec,
    OUT char szError[cbErrMax],
    OUT PDB** pppdb);

PDBAPI(BOOL)
PDBOpenEx(
    /*const*/ char* szPDB,
    /*const*/ char* szMode,
    SIG sigInitial,
    long cbPage,
    OUT EC* pec,
    OUT char szError[cbErrMax],
    OUT PDB** pppdb);

PDBAPI(BOOL)
PDBOpenValidate3(
    const char *szExecutable,
    const char *szSearchPath,
    OUT EC *pec,
    OUT char szError[cbErrMax],
    OUT char szDbgPath[PDB_MAX_PATH],
    OUT DWORD *pfo,
    OUT DWORD *pcb,
    OUT PDB **pppdb);

PDBAPI(BOOL)
PDBOpenValidate4(
    const char *szExecutable,
    const char *szSearchPath,
    OUT DWORDLONG *pTimeStamp,
    OUT EC *pec,
    OUT char szError[cbErrMax],
    OUT char szDbgPath[PDB_MAX_PATH],
    OUT DWORD *pfo,
    OUT DWORD *pcb,
    OUT PDB **pppdb);

// a dbi client should never call PDBExportValidateInterface directly - use PDBValidateInterface
PDBAPI(BOOL)
PDBExportValidateInterface(
    INTV intv);

__inline BOOL PDBValidateInterface()
{
    return PDBExportValidateInterface(PDBIntv);
}

typedef BOOL (PDBCALL *PfnPDBExportValidateInterface)(INTV);

__inline BOOL PDBValidateInterfacePfn(PfnPDBExportValidateInterface pfn)
{
    return (*pfn)(PDBIntv);
}

PDBAPI(EC)     PDBQueryLastError(PDB* ppdb, OUT char szError[cbErrMax]);
PDBAPI(INTV)   PDBQueryInterfaceVersion(PDB* ppdb);
PDBAPI(IMPV)   PDBQueryImplementationVersion(PDB* ppdb);
PDBAPI(char*)  PDBQueryPDBName(PDB* ppdb, OUT char szPDB[PDB_MAX_PATH]);
PDBAPI(SIG)    PDBQuerySignature(PDB* ppdb);
PDBAPI(AGE)    PDBQueryAge(PDB* ppdb);
PDBAPI(BOOL)   PDBCreateDBI(PDB* ppdb, const char* szTarget, OUT DBI** ppdbi);
PDBAPI(BOOL)   PDBOpenDBIEx(PDB* ppdb, const char* szMode, const char* szTarget, OUT DBI** ppdbi, PfnFindDebugInfoFile pfn);
PDBAPI(BOOL)   PDBOpenDBI(PDB* ppdb, const char* szMode, const char* szTarget, OUT DBI** ppdbi);
PDBAPI(BOOL)   PDBOpenTpi(PDB* ppdb, const char* szMode, OUT TPI** pptpi);
PDBAPI(BOOL)   PDBCommit(PDB* ppdb);
PDBAPI(BOOL)   PDBClose(PDB* ppdb);
PDBAPI(BOOL)   PDBOpenStream(PDB* ppdb, const char* szStream, OUT Stream** ppstream);
PDBAPI(BOOL)   PDBCopyTo(PDB* ppdb, const char* szTargetPdb, DWORD dwCopyFilter, DWORD dwReserved);

PDBAPI(INTV)   DBIQueryInterfaceVersion(DBI* pdbi);
PDBAPI(IMPV)   DBIQueryImplementationVersion(DBI* pdbi);
PDBAPI(BOOL)   DBIOpenMod(DBI* pdbi, const char* szModule, const char* szFile, OUT Mod** ppmod);
PDBAPI(BOOL)   DBIDeleteMod(DBI* pdbi, const char* szModule);
PDBAPI(BOOL)   DBIQueryNextMod(DBI* pdbi, Mod* pmod, Mod** ppmodNext);
PDBAPI(BOOL)   DBIOpenGlobals(DBI* pdbi, OUT GSI **ppgsi);
PDBAPI(BOOL)   DBIOpenPublics(DBI* pdbi, OUT GSI **ppgsi);
PDBAPI(BOOL)   DBIAddSec(DBI* pdbi, USHORT isect, USHORT flags, long off, long cb);
PDBAPI(BOOL)   DBIAddPublic(DBI* pdbi, const char* szPublic, USHORT isect, long off);
PDBAPI(BOOL)   DBIQueryModFromAddr(DBI* pdbi, USHORT isect, long off, OUT Mod** ppmod, OUT USHORT* pisect, OUT long* poff, OUT long* pcb);
PDBAPI(BOOL)   DBIQuerySecMap(DBI* pdbi, OUT BYTE* pb, long* pcb);
PDBAPI(BOOL)   DBIQueryFileInfo(DBI* pdbi, OUT BYTE* pb, long* pcb);
PDBAPI(BOOL)   DBIQuerySupportsEC(DBI* pdbi);
PDBAPI(void)   DBIDumpMods(DBI* pdbi);
PDBAPI(void)   DBIDumpSecContribs(DBI* pdbi);
PDBAPI(void)   DBIDumpSecMap(DBI* pdbi);
PDBAPI(BOOL)   DBIClose(DBI* pdbi);
PDBAPI(BOOL)   DBIAddThunkMap(DBI* pdbi, long* poffThunkMap, unsigned nThunks, long cbSizeOfThunk,
                              struct SO* psoSectMap, unsigned nSects, USHORT isectThunkTable, long offThunkTable);
PDBAPI(BOOL)   DBIGetEnumContrib(DBI* pdbi, OUT Enum** ppenum);
PDBAPI(BOOL)   DBIQueryTypeServer(DBI* pdbi, ITSM itsm, OUT TPI** pptpi );
PDBAPI(BOOL)   DBIQueryItsmForTi(DBI* pdbi, TI ti, OUT ITSM* pitsm );
PDBAPI(BOOL)   DBIQueryNextItsm(DBI* pdbi, ITSM itsm, OUT ITSM *inext );
PDBAPI(BOOL)   DBIQueryLazyTypes(DBI* pdbi);
PDBAPI(BOOL)   DBIFindTypeServers( DBI* pdbi, OUT EC* pec, OUT char szError[cbErrMax] );
PDBAPI(BOOL)   DBIOpenDbg(DBI* pdbi, DBGTYPE dbgtype, OUT Dbg **ppdbg);
PDBAPI(BOOL)   DBIQueryDbgTypes(DBI* pdbi, OUT DBGTYPE *pdbgtype, OUT long* pcDbgtype);
PDBAPI(BOOL)   DBIAddLinkInfo(DBI* pdbi, IN PLinkInfo);
PDBAPI(BOOL)   DBIQueryLinkInfo(DBI* pdbi, PLinkInfo, IN OUT long * pcb);

PDBAPI(INTV)   ModQueryInterfaceVersion(Mod* pmod);
PDBAPI(IMPV)   ModQueryImplementationVersion(Mod* pmod);
PDBAPI(BOOL)   ModAddTypes(Mod* pmod, BYTE* pbTypes, long cb);
#if CC_LAZYSYMS
PDBAPI(BOOL)   ModAddSymbols(Mod* pmod, BYTE* pbSym, long cb, unsigned icon);
#else
PDBAPI(BOOL)   ModAddSymbols(Mod* pmod, BYTE* pbSym, long cb);
#endif
PDBAPI(BOOL)   ModAddPublic(Mod* pmod, const char* szPublic, USHORT isect, long off);
PDBAPI(BOOL)   ModAddLines(Mod* pmod, const char* szSrc, USHORT isect, long offCon, long cbCon, long doff,
                           USHORT lineStart, BYTE* pbCoff, long cbCoff);
PDBAPI(BOOL)   ModAddSecContrib(Mod * pmod, USHORT isect, long off, long cb, ULONG dwCharacteristics);
PDBAPI(BOOL)   ModQueryCBName(Mod* pmod, OUT long* pcb);
PDBAPI(BOOL)   ModQueryName(Mod* pmod, OUT char szName[PDB_MAX_PATH], OUT long* pcb);
PDBAPI(BOOL)   ModQuerySymbols(Mod* pmod, BYTE* pbSym, long* pcb);
PDBAPI(BOOL)   ModQueryLines(Mod* pmod, BYTE* pbLines, long* pcb);
PDBAPI(BOOL)   ModSetPvClient(Mod* pmod, void *pvClient);
PDBAPI(BOOL)   ModGetPvClient(Mod* pmod, OUT void** ppvClient);
PDBAPI(BOOL)   ModQuerySecContrib(Mod* pmod, OUT USHORT* pisect, OUT long* poff, OUT long* pcb, OUT ULONG* pdwCharacteristics);
PDBAPI(BOOL)   ModQueryImod(Mod* pmod, OUT USHORT* pimod);
PDBAPI(BOOL)   ModQueryDBI(Mod* pmod, OUT DBI** ppdbi);
PDBAPI(BOOL)   ModClose(Mod* pmod);
PDBAPI(BOOL)   ModQueryCBFile(Mod* pmod, OUT long* pcb);
PDBAPI(BOOL)   ModQueryFile(Mod* pmod, OUT char szFile[PDB_MAX_PATH], OUT long* pcb);
PDBAPI(BOOL)   ModQuerySrcFile(Mod* pmod, OUT char szFile[PDB_MAX_PATH], OUT long* pcb);
PDBAPI(BOOL)   ModQuerySupportsEC(Mod* pmod);
PDBAPI(BOOL)   ModQueryTpi(Mod* pmod, OUT TPI** pptpi);

PDBAPI(INTV)   TypesQueryInterfaceVersion(TPI* ptpi);
PDBAPI(IMPV)   TypesQueryImplementationVersion(TPI* ptpi);
// can't use the same api's for 32-bit TIs.
PDBAPI(BOOL)   TypesQueryTiForCVRecordEx(TPI* ptpi, BYTE* pb, OUT TI* pti);
PDBAPI(BOOL)   TypesQueryCVRecordForTiEx(TPI* ptpi, TI ti, OUT BYTE* pb, IN OUT long* pcb);
PDBAPI(BOOL)   TypesQueryPbCVRecordForTiEx(TPI* ptpi, TI ti, OUT BYTE** ppb);
PDBAPI(TI)     TypesQueryTiMinEx(TPI* ptpi);
PDBAPI(TI)     TypesQueryTiMacEx(TPI* ptpi);
PDBAPI(long)   TypesQueryCb(TPI* ptpi);
PDBAPI(BOOL)   TypesClose(TPI* ptpi);
PDBAPI(BOOL)   TypesCommit(TPI* ptpi);
PDBAPI(BOOL)   TypesQueryTiForUDTEx(TPI* ptpi, char* sz, BOOL fCase, OUT TI* pti);
PDBAPI(BOOL)   TypesSupportQueryTiForUDT(TPI*);
PDBAPI(BOOL)   TypesfIs16bitTypePool(TPI*);
// Map all old ones to new ones for new compilands.
#define TypesQueryTiForCVRecord     TypesQueryTiForCVRecordEx
#define TypesQueryCVRecordForTi     TypesQueryCVRecordForTiEx
#define TypesQueryPbCVRecordForTi   TypesQueryPbCVRecordForTiEx
#define TypesQueryTiMin             TypesQueryTiMinEx
#define TypesQueryTiMac             TypesQueryTiMacEx
#define TypesQueryTiForUDT          TypesQueryTiForUDTEx
PDBAPI(BOOL)    TypesAreTypesEqual( TPI* ptpi, TI ti1, TI ti2 );
PDBAPI(BOOL)    TypesIsTypeServed( TPI* ptpi, TI ti );

PDBAPI(BYTE*)  GSINextSym (GSI* pgsi, BYTE* pbSym);
PDBAPI(BYTE*)  GSIHashSym (GSI* pgsi, const char* szName, BYTE* pbSym);
PDBAPI(BYTE*)  GSINearestSym (GSI* pgsi, USHORT isect, long off,OUT long* pdisp);//currently only supported for publics
PDBAPI(BOOL)   GSIClose(GSI* pgsi);

PDBAPI(long)   StreamQueryCb(Stream* pstream);
PDBAPI(BOOL)   StreamRead(Stream* pstream, long off, void* pvBuf, long* pcbBuf);
PDBAPI(BOOL)   StreamWrite(Stream* pstream, long off, void* pvBuf, long cbBuf);
PDBAPI(BOOL)   StreamReplace(Stream* pstream, void* pvBuf, long cbBuf);
PDBAPI(BOOL)   StreamAppend(Stream* pstream, void* pvBuf, long cbBuf);
PDBAPI(BOOL)   StreamDelete(Stream* pstream);
PDBAPI(BOOL)   StreamTruncate(Stream* pstream, long cb);
PDBAPI(BOOL)   StreamRelease(Stream* pstream);

PDBAPI(BOOL)   StreamImageOpen(Stream* pstream, long cb, OUT StreamImage** ppsi);
PDBAPI(void*)  StreamImageBase(StreamImage* psi);
PDBAPI(long)   StreamImageSize(StreamImage* psi);
PDBAPI(BOOL)   StreamImageNoteRead(StreamImage* psi, long off, long cb, OUT void** ppv);
PDBAPI(BOOL)   StreamImageNoteWrite(StreamImage* psi, long off, long cb, OUT void** ppv);
PDBAPI(BOOL)   StreamImageWriteBack(StreamImage* psi);
PDBAPI(BOOL)   StreamImageRelease(StreamImage* psi);

PDBAPI(BOOL)   NameMapOpen(PDB* ppdb, BOOL fWrite, OUT NameMap** ppnm);
PDBAPI(BOOL)   NameMapClose(NameMap* pnm);
PDBAPI(BOOL)   NameMapReinitialize(NameMap* pnm);
PDBAPI(BOOL)   NameMapGetNi(NameMap* pnm, const char* sz, OUT NI* pni);
PDBAPI(BOOL)   NameMapGetName(NameMap* pnm, NI ni, OUT const char** psz);
PDBAPI(BOOL)   NameMapGetEnumNameMap(NameMap* pnm, OUT Enum** ppenum);
PDBAPI(BOOL)   NameMapCommit(NameMap* pnm);

PDBAPI(void)   EnumNameMapRelease(EnumNameMap* penum);
PDBAPI(void)   EnumNameMapReset(EnumNameMap* penum);
PDBAPI(BOOL)   EnumNameMapNext(EnumNameMap* penum);
PDBAPI(void)   EnumNameMapGet(EnumNameMap* penum, OUT const char** psz, OUT NI* pni);

PDBAPI(void)   EnumContribRelease(EnumContrib* penum);
PDBAPI(void)   EnumContribReset(EnumContrib* penum);
PDBAPI(BOOL)   EnumContribNext(EnumContrib* penum);
PDBAPI(void)   EnumContribGet(EnumContrib* penum, OUT USHORT* pimod, OUT USHORT* pisect, OUT long* poff, OUT long* pcb, OUT ULONG* pdwCharacteristics);
PDBAPI(void)   EnumContribGetCrcs(EnumContrib* penum, OUT DWORD* pcrcData, OUT DWORD* pcrcReloc);

PDBAPI(SIG)    SigForPbCb(BYTE* pb, long cb, SIG sig);
PDBAPI(void)   TruncStFromSz(char *stDst, const char *szSrc, unsigned cbSrc);

PDBAPI(BOOL)   DbgClose(Dbg *pdbg);
PDBAPI(long)   DbgQuerySize(Dbg *pdbg);
PDBAPI(void)   DbgReset(Dbg *pdbg);
PDBAPI(BOOL)   DbgSkip(Dbg *pdbg, ULONG celt);
PDBAPI(BOOL)   DbgQueryNext(Dbg *pdbg, ULONG celt, OUT void *rgelt);
PDBAPI(BOOL)   DbgFind(Dbg *pdbg, IN OUT void *pelt);
PDBAPI(BOOL)   DbgClear(Dbg *pdbg);
PDBAPI(BOOL)   DbgAppend(Dbg *pdbg, ULONG celt, const void *rgelt);
PDBAPI(BOOL)   DbgReplaceNext(Dbg *pdbg, ULONG celt, const void *rgelt);

#if __cplusplus
};
#endif

struct SO {
    long off;
    USHORT isect;
    unsigned short pad;
};

#ifndef cbNil
#define cbNil   ((long)-1)
#endif
#define tsNil   ((TPI*)0)
#define tiNil   ((TI)0)
#define imodNil ((USHORT)(-1))

#define pdbWrite                "w"
#define pdbRead                 "r"
#define pdbGetTiOnly            "i"
#define pdbGetRecordsOnly       "c"
#define pdbFullBuild            "f"
#define pdbTypeAppend           "a"

#endif // __PDB_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\vctools\pdb6\langapi\include\sdci.h ===
//
// sdci.h
//
// ODBC/DBLib private entry point 
// Copyright (C) 1996, Microsoft Corp.	All Rights Reserved.
//

#ifndef __SDCI_INCLUDED__
#define __SDCI_INCLUDED__

#ifndef ULONG
typedef unsigned long ULONG;
#endif 

enum {
	cbMaxMchName = 32,
	cbMaxDLLName = 16
};

typedef struct _SDCI {
	ULONG		cbLength;			// size of this struct
	ULONG		dbgpid;				// pid of debugger
	ULONG		pid;				// pid to start/stop debugging 
	char		rgchMchName[cbMaxMchName];	// machine name of debugger
	UNALIGNED void *pvData;				// future use
	ULONG		cbData;				// size of data
	char		rgchSDIDLLName[cbMaxDLLName];	// name of DLL to load
	ULONG		fOption;			// 1 - start debugging; 0 - stop debugging
} SDCI, *PSDCI;


BOOL _stdcall SQLDebug(SDCI *psdci);

typedef BOOL (_stdcall *pfnSQLDebug) (SDCI *psdci);

#define	SDCI_CODE_BREAK		1
#define	SDCI_CODE_ENABLE	2
#define	SDCI_CODE_RESUME	3

#endif // __SDCI_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\vctools\pdb6\langapi\include\ref.h ===
#pragma once

#if !defined(_ref_h)
#define _ref_h 1

#define refNil  0

template <class TARG>
class RefPtr {
  private:
    TARG *  _ptarg;

    // unuse pointer and free if last user
    void Release() {
        if (_ptarg != NULL && _ptarg->FUnUse()) {
            delete _ptarg;
            }

        // put garbage in pointer
        Debug(_ptarg = (TARG *) 0xdadadada);
        }

  public:
    // constructors
    RefPtr<TARG>() {
        _ptarg = NULL;
        }

    RefPtr<TARG>(TARG * ptargNew) {
        _ptarg = ptargNew;
        if (ptargNew != NULL) {
            ptargNew->Use();
            }
        }

    RefPtr<TARG>(const RefPtr<TARG> & rtarg) {
        _ptarg = rtarg._ptarg;
        if (rtarg._ptarg != NULL) {
            rtarg._ptarg->Use();
            }
        }

    // destructor
   ~RefPtr<TARG>() {
        Release();
        }

    // assignment functions (mirror the ctors)
    RefPtr<TARG>& operator=(TARG *ptargNew) {
        if (ptargNew != NULL) {
            ptargNew->Use();
            }

        Release();
        _ptarg = ptargNew;

        return *this;
        }

    RefPtr<TARG>& operator=(const RefPtr<TARG> &rtarg) {
        if (rtarg._ptarg != NULL) {
            rtarg._ptarg->Use();
            }

        Release();
        _ptarg = rtarg._ptarg;

        return *this;
        }

    bool  operator==(TARG *ptarg) const { return  _ptarg == ptarg; }
    bool  operator!=(TARG *ptarg) const { return  _ptarg != ptarg; }
    TARG &operator*()             const { return *_ptarg;          }
    TARG *operator->()            const { return  _ptarg;          }
          operator TARG *()       const { return  _ptarg;          }
    };

template <class TARG>
class COMRefPtr {
  private:
    TARG *  _ptarg;

    // unuse pointer and free if last user
    void Release() {
        if (_ptarg != NULL) {
            _ptarg->Release();
            }

        // put garbage in pointer
//      Debug(_ptarg = (TARG *) 0xdadadada);
        }

  public:
    // constructors
    COMRefPtr<TARG>() {
        _ptarg = NULL;
        }

    COMRefPtr<TARG>(TARG * ptargNew) {
        _ptarg = ptargNew;
        if (ptargNew != NULL) {
            ptargNew->AddRef();
            }
        }

    COMRefPtr<TARG>(const RefPtr<TARG> & rtarg) {
        _ptarg = rtarg._ptarg;
        if (rtarg._ptarg != NULL) {
            rtarg._ptarg->AddRef();
            }
        }

    // destructor
   ~COMRefPtr<TARG>() {
        Release();
        }

    // assignment functions (mirror the ctors)
    COMRefPtr<TARG>& operator=(TARG *ptargNew) {
        if (ptargNew != NULL) {
            ptargNew->AddRef();
            }

        Release();
        _ptarg = ptargNew;

        return *this;
        }

    COMRefPtr<TARG>& operator=(const RefPtr<TARG> &rtarg) {
        if (rtarg._ptarg != NULL) {
            rtarg._ptarg->AddRef();
            }

        Release();
        _ptarg = rtarg._ptarg;

        return *this;
        }
    TARG **operator&() {
        if (_ptarg != NULL) {
            _ptarg->Release();
            _ptarg = NULL;
            }

        return &_ptarg;
        }

    bool  operator==(TARG *ptarg) const { return  _ptarg == ptarg; }
    bool  operator!=(TARG *ptarg) const { return  _ptarg != ptarg; }
    TARG &operator*()             const { return *_ptarg;          }
    TARG *operator->()            const { return  _ptarg;          }
    operator TARG *()       const { return  _ptarg;          }
    };

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\vctools\pdb6\langapi\include\sbrfdef.h ===
// sdbfdef.h    Source Browser .SBR file definitions

#define SBR_L_UNDEF         0       // Undefined         
#define SBR_L_BASIC         1       // Basic
#define SBR_L_C             2       // C
#define SBR_L_FORTRAN       3       // Fortran
#define SBR_L_MASM          4       // Macro
#define SBR_L_PASCAL        5       // Pascal
#define SBR_L_COBOL			6		// Cobol
#define SBR_L_CXX			7		// C++

#define SBR_REC_HEADER      0x00    // Header
#define SBR_REC_MODULE      0x01    // Module definition
#define SBR_REC_LINDEF      0x02    // Line Number
#define SBR_REC_SYMDEF      0x03    // Symbol Definition
#define SBR_REC_SYMREFUSE   0x04    // Symbol Reference
#define SBR_REC_SYMREFSET   0x05    // Symbol Ref assign
#define SBR_REC_MACROBEG    0x06    // Macro Start
#define SBR_REC_MACROEND    0x07    // Macro End
#define SBR_REC_BLKBEG      0x08    // Block Start
#define SBR_REC_BLKEND      0x09    // Block End
#define SBR_REC_MODEND      0x0A    // Module End
#define SBR_REC_OWNER		0x0B	// Scope Owner
#define SBR_REC_BASE		0x0C	// Define base class of owner
#define SBR_REC_FRIEND		0x0D	// Define friend of owner
#define SBR_REC_ABORT		0x0E	// Compiler aborted, .sbr file ended early
#define SBR_REC_PCHNAME		0x0F	// Precompiler header include
#define SBR_REC_PCHMARK		0x10	// Precompiler header highwater mark

//  psuedo records for internal use.

#define SBR_REC_ERROR       0x11    // error-record -- xlated to symdef
#define SBR_REC_MACROREF    0x12	// this space for rent
#define SBR_REC_MACRODEF    0x13	// this space for rent
#define SBR_REC_IGNORE      0x14    // abort condition discovered
									// after record already enqueued

// icc related records (these actually occur in .sbr files)

#define SBR_REC_LINDELTA	0x15	// 16 bit signed line number delta
#define SBR_REC_INFOSEP		0x16	// begins any ICC section + ends previous
#define SBR_REC_PATCHTAB	0x17	// introduces patch table entry
#define SBR_REC_PATCHTERM	0x18	// ends the patch table (includes cookie)
#define SBR_REC_SYMDECL		0x19	// used in fe internally for icc browse

#define SBR_COOKIE_ICC		0x4A525301	// cookie at EOF if ICC patch present

//
//  records which have extended keys (when the keys don't fit in 16 bits.)
//
#define SBR_REC_SYMDEF_X    (SBR_REC_SYMDEF | SBR_REC_EXTENDED_KEYS)	// Extended key symbol definition
#define SBR_REC_SYMREFUSE_X (SBR_REC_SYMREFUSE | SBR_REC_EXTENDED_KEYS)	// Extended key symbol reference
#define SBR_REC_SYMREFSET_X (SBR_REC_SYMREFSET | SBR_REC_EXTENDED_KEYS)	// Extended key symbol ref assign
#define SBR_REC_OWNER_X     (SBR_REC_OWNER | SBR_REC_EXTENDED_KEYS)		// Extended key scope owner
#define SBR_REC_BASE_X      (SBR_REC_BASE | SBR_REC_EXTENDED_KEYS)		// Extended key base class
#define SBR_REC_FRIEND_X	(SBR_REC_FRIEND | SBR_REC_EXTENDED_KEYS)	// Extended key friend of owner

#define SBR_REC_BUMP_N      0x20    // Bump the line number N+1 times

#define	SBR_REC_EXTENDED_KEYS		0x40	// the keys are bigger than 16 bits.

#define	SBR_REC_EXTENDED_MASK		(SBR_REC_EXTENDED_KEYS)	//  add more as required

#define	GetSbrRecType(v)			(v & (~ SBR_REC_EXTENDED_MASK ))

#define	SetSbrRecExtendedAttrib(v,a)	(v |= (a))
#define	ClrSbrRecExtendedAttrib(v,a)	(v &= ~(a))
#define	IsSetSbrRecExtendedAttrib(v,a)	(v & (a))

#define SBR_REC_NOCOLUMN    1       // Missing column default 1

#define SBR_TYP_FUNCTION    0x01
#define SBR_TYP_LABEL       0x02
#define SBR_TYP_PARAMETER   0x03
#define SBR_TYP_VARIABLE    0x04
#define SBR_TYP_CONSTANT    0x05
#define SBR_TYP_MACRO       0x06
#define SBR_TYP_TYPEDEF     0x07
#define SBR_TYP_STRUCNAM    0x08
#define SBR_TYP_ENUMNAM     0x09
#define SBR_TYP_ENUMMEM     0x0A
#define SBR_TYP_UNIONNAM    0x0B
#define SBR_TYP_SEGMENT	    0x0C
#define SBR_TYP_GROUP	    0x0D
#define SBR_TYP_PROGRAM	    0x0E
#define SBR_TYP_CLASSNAM    0x0F
#define SBR_TYP_MEMFUNC	    0x10
#define SBR_TYP_MEMVAR	    0x11
#define SBR_TYP_ERROR		0x12

#define SBR_ATR_LOCAL	    0x001
#define SBR_ATR_STATIC	    0x002
#define SBR_ATR_SHARED	    0x004
#define SBR_ATR_NEAR	    0x008
#define SBR_ATR_COMMON	    0x010
#define SBR_ATR_DECL		0x020
#define SBR_ATR_DECL_ONLY	0x020	// synonym for the above
#define SBR_ATR_PUBLIC      0x040
#define SBR_ATR_NAMED	    0x080
#define SBR_ATR_MODULE		0x100
#define SBR_ATR_VIRTUAL		0x200
#define SBR_ATR_PRIVATE		0x400
#define SBR_ATR_PROTECT		0x800

#define SBR_ITYP_VIRTUAL	0x01
#define SBR_ITYP_PRIVATE	0x02
#define SBR_ITYP_PUBLIC		0x04
#define SBR_ITYP_PROTECT	0x08

#define SBR_VER_MAJOR       2       // Major version
#define SBR_VER_MINOR       0       // Minor version

#define SBR_LIMIT_ID_LENGTH	256		// At the moment (12Apr94) bscmake can't take longer names
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\vctools\pdb6\langapi\include\rttidata.h ===
//
//	_RTTIBaseClassDescriptor
//
//	TypeDescriptor is declared in ehdata.h
//
typedef const struct	_s_RTTIBaseClassDescriptor	{
	TypeDescriptor					*pTypeDescriptor;
	DWORD							numContainedBases;
	PMD								where;
	DWORD							attributes;
	} _RTTIBaseClassDescriptor;

#define BCD_NOTVISIBLE				0x00000001
#define BCD_AMBIGUOUS				0x00000002
#define BCD_PRIVORPROTINCOMPOBJ		0x00000004
#define BCD_PRIVORPROTBASE			0x00000008
#define BCD_VBOFCONTOBJ				0x00000010
#define BCD_NONPOLYMORPHIC			0x00000020

#define BCD_PTD(bcd)				((bcd).pTypeDescriptor)
#define BCD_NUMCONTBASES(bcd)		((bcd).numContainedBases)
#define BCD_WHERE(bcd)				((bcd).where)
#define BCD_ATTRIBUTES(bcd)			((bcd).attributes)


//
//	_RTTIBaseClassArray
//
#pragma warning(disable:4200)		// get rid of obnoxious nonstandard extension warning
typedef const struct	_s_RTTIBaseClassArray	{
	_RTTIBaseClassDescriptor		*arrayOfBaseClassDescriptors[];
	} _RTTIBaseClassArray;
#pragma warning(default:4200)


//
//	_RTTIClassHierarchyDescriptor
//
typedef const struct	_s_RTTIClassHierarchyDescriptor	{
	DWORD							signature;
	DWORD							attributes;
	DWORD							numBaseClasses;
	_RTTIBaseClassArray				*pBaseClassArray;
	} _RTTIClassHierarchyDescriptor;

#define CHD_MULTINH					0x00000001
#define CHD_VIRTINH					0x00000002
#define CHD_AMBIGUOUS				0x00000004

#define CHD_SIGNATURE(chd)			((chd).signature)
#define CHD_ATTRIBUTES(chd)			((chd).attributes)
#define CHD_NUMBASES(chd)			((chd).numBaseClasses)
#define CHD_PBCA(chd)				((chd).pBaseClassArray)

//
//	_RTTICompleteObjectLocator
//
typedef const struct	_s_RTTICompleteObjectLocator	{
	DWORD							signature;
	DWORD							offset;
	DWORD							cdOffset;
	TypeDescriptor					*pTypeDescriptor;
	_RTTIClassHierarchyDescriptor	*pClassDescriptor;
	} _RTTICompleteObjectLocator;

#define COL_SIGNATURE(col)			((col).signature)
#define COL_OFFSET(col)				((col).offset)
#define COL_CDOFFSET(col)			((col).cdOffset)
#define COL_PTD(col)				((col).pTypeDescriptor)
#define COL_PCHD(col)				((col).pClassDescriptor)

#ifdef BUILDING_TYPESRC_C
//
// Type of the result of __RTtypeid and internal applications of typeid().
// This also introduces the tag "type_info" as an incomplete type.
//

typedef const class type_info &__RTtypeidReturnType;

//
// Declaration of CRT entrypoints, as seen by the compiler.  Types are 
// simplified so as to avoid type matching hassles.
//

// Perform a dynamic_cast on obj. of polymorphic type
extern "C" PVOID __cdecl __RTDynamicCast (
								PVOID,				// ptr to vfptr
								LONG,				// offset of vftable
								PVOID,				// src type
								PVOID,				// target type
								BOOL); 				// isReference

// Perform 'typeid' on obj. of polymorphic type
extern "C" PVOID __cdecl __RTtypeid (PVOID);		// ptr to vfptr

// Perform a dynamic_cast from obj. of polymorphic type to void*
extern "C" PVOID __cdecl __RTCastToVoid (PVOID);	// ptr to vfptr
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\vctools\pdb6\langapi\include\sdidef.h ===
//
// SQL Debug Information Definitions
// Copyright (C) 1997, Microsoft Corp.	All Rights Reserved.
//

#ifndef __SDIDEF_INCLUDED__
#define __SDIDEF_INCLUDED__

#pragma pack(push, enter_SDIdef)
#pragma pack(2)

// Basic typedefs
typedef ULONG   INTV;       // interface version number
typedef ULONG   IMPV;       // implementation version number
typedef ULONG   SPID;       // connection id
typedef ULONG   PRID;       // stored procedure id
typedef USHORT  IDX;        // statement index
typedef USHORT  NLVL;       // nesting level
typedef USHORT  OFF;        // offset into stored proc/batch
typedef ULONG   PID;        // process id
typedef ULONG	THID;	     // thread id
typedef ULONG	SQLLEID;   // token issued by SQL LE for every connection

typedef enum {symGlobals, symLocals, symParams} SYMS;       // class of syms

typedef enum {                                              // sym types
    stInvalid,  
    stBIT,
    stTIMESTAMP,
    stTINYINT,
    stSMALLINT,
    stINT,
    stREAL,
    stFLOAT,
    stNUMERIC,
    stDECIMAL,
    stCHAR,
    stVARCHAR,
    stBINARY,
    stVARBINARY,
    stSMALLMONEY,
    stMONEY,
    stSMALLDATETIME,
    stDATETIME,
    stTEXT,
    stIMAGE,
 	stGUID,
	stLARGEINT,
	stNCHAR,
	stNVARCHAR,
	stNTEXT,
	stMONEY60,	//SQL Server 7.0 format; compatible with VC Ent 6.0
    stSMALLDATETIME60,//SQL Server 7.0 format; compatible with VC Ent 6.0
    stDATETIME60,//SQL Server 7.0 format; compatible with VC Ent 6.0
    stLast
} SYM_TYPE;                 


typedef struct _SYMINFO {
    SYM_TYPE    st;                 // symbol type
    void        *pv;                // ptr to symbol value
    USHORT      cb;                 // length 
    USHORT      cbName;             // length of name
    char        *Name;              // symbol name
    BYTE        cbPrec;             // precision info
    BYTE        cbScale;            // scale info
} SYMINFO, *PSYMINFO;

#pragma pack(pop, enter_SDIdef)

#endif // __SDIDEF_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\vctools\pdb6\langapi\include\simparray.h ===
#pragma once
#include "crefobj.h"

template <class T>
class SimpleArray : public CRefCountedObj {
protected:
    unsigned    _cT;
    T *         _rgT;

public:
    SimpleArray ( unsigned cT ) {
        if ( cT ) {
            _rgT = new T[cT];
            if ( _rgT ) {
                _cT = cT;
                }
            }
        else {
            _cT = 0;
            _rgT = 0;
            }
        }

    ~SimpleArray() {
        if ( _rgT ) {
            delete [] _rgT;
            }
        _cT = 0;
        _rgT = 0;
        }

    unsigned Count() const {
        return _cT;
        }

    const T * Base() const {
        return _rgT;
        }

    T * Base() {
        return _rgT;
        }

    T & operator[] ( unsigned it ) {
        return _rgT[it];
        }

    const T & operator[] ( unsigned it ) const {
        return _rgT[it];
        }
    };

class SimpleString: public SimpleArray<char>
{
public:
    unsigned Length() const { return strlen( _rgT ); } // # non-nulls
    const char* operator=( const char *str ) {
        return Set( str, strlen( str ) );
    }
    bool operator==( SimpleString& str ) { return *this == str.Base(); }
    bool operator!=( SimpleString& str ) { return !(*this == str); }
    bool operator==( const char* str ) {
        return strcmp( str, Base() ) == 0; 
    }
    bool operator!=( const char* str ) { return !(*this == str); }
    void Clear() {
        assert( Count() > 0 );
        Set( "", 0 );
    }
    const char* Set( const char* str, unsigned len ) {
        Grow( len+1 );
        strncpy( _rgT, str, len );
        _rgT[ len ] = '\0';
        return Base();
    }
    SimpleString( const SimpleString& str ) 
        : SimpleArray<char>( str.Length()+1 ) {
        Set( str.Base(), str.Length()+1 );
    }
    SimpleString( unsigned len = 256 ) : SimpleArray<char>( max( len, 1 ) ) {
        Set( "", 0 );
    }
private:
    bool Grow( unsigned cb ) {
        if ( Count() < cb ) {
            delete [] _rgT;
            _rgT = new char[cb];
            _cT = cb;
        }
        return _rgT != 0;
    }

};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\vctools\pdb6\langapi\include\sdi.h ===
//
// SQL Debug Information API
// Copyright (C) 1995, Microsoft Corp.	All Rights Reserved.
//

#include <stddef.h>

#ifndef __SDI_INCLUDED__
#define __SDI_INCLUDED__

#pragma pack(push, enter_SDI)
#pragma pack(2)

// Basic typedefs
typedef int BOOL;
typedef unsigned char BYTE;
typedef unsigned long ULONG;
typedef unsigned short USHORT;

#ifndef __SDIDEF_INCLUDED__
#include "sdidef.h"
#endif // __SDIDEF_INCLUDED__


typedef SPID SDI_SPID;		// for VC

// Interface Version Number; they are shipped with VC so adopt the VC version suffix
enum {	SDIIntv42 = 951027, SDIIntv50 = 961025, SDIIntv60 = 970915 };

// Interesting values
enum {	
		cbMchNmMax   = 32,	// maximum m/c name length (sql has a limit of 30)
		cbSqlSrvrMax = 32	// maximum sql server name length
};

// dll/entrypoint names
#define SDIDLL_ENTRYPOINT   "SDIInit"

#ifndef EXTERN_C
#if __cplusplus
#define EXTERN_C extern "C"
#else
#define EXTERN_C
#endif
#endif

// init API
typedef struct _SQLFNTBL SQLFNTBL;
typedef struct _DBGFNTBL DBGFNTBL;
typedef long SDI_EC;            // error code

BOOL _stdcall SDIInit (SQLFNTBL *psqlfntbl, INTV intvsql, DBGFNTBL **ppdbgfntbl, INTV *pintvdbg);

typedef BOOL (_stdcall *pfnSDIInit)(SQLFNTBL *psqlfntbl, INTV intvsql, DBGFNTBL **ppdbgfntbl, INTV *pintvdbg);

// execution control API
typedef BOOL (_stdcall *pfnSDINewSPID)(SDI_SPID spid, char szSqlServer[cbSqlSrvrMax], char szMachine[cbMchNmMax], void *pvDbgData,ULONG cbDbgData,PID pid, PID dbgpid);
typedef BOOL (_stdcall *pfnSDINewSP)  (SDI_SPID spid, char *DBName, USHORT DBLen, PRID prid, NLVL nlvl);
typedef BOOL (_stdcall *pfnSDIStep) (SDI_SPID spid, PRID prid, IDX idx, OFF off, NLVL nlvl);
typedef BOOL (_stdcall *pfnSDINewBatch)(SDI_SPID spid, char *CmdBuf, ULONG cbCmdBuf, NLVL nlvl);
typedef BOOL (_stdcall *pfnSDIPop)(SDI_SPID spid, NLVL nlvl);
typedef BOOL (_stdcall *pfnSDICloseConnection)(SDI_SPID spid, ULONG sqlerror, SDI_EC sdierror);
typedef BOOL (_stdcall *pfnSDISpidContext)(SDI_SPID spid, PID pid, THID tid);
//Provide a list of line numbers for action SQL statements
typedef BOOL (_stdcall *pfnSDIActionLines)(SDI_SPID spid, PRID prid, USHORT *rgusActionLines, USHORT cActionLines);

// data handling API

// 4.2
typedef BOOL (_stdcall *pfnSDISetSym) (SDI_SPID spid, SYMS syms, PSYMINFO psyminfo, NLVL nlvl);
typedef BOOL (_stdcall *pfnSDIGetSym) (SDI_SPID spid, SYMS syms, PSYMINFO *prgsyminfo, USHORT *pcsym, NLVL nlvl);
//6.0
typedef BOOL (_stdcall *pfnSDIGetSym60) (SDI_SPID spid, SYMS syms, PSYMINFO *prgsyminfo, USHORT *pcsym, NLVL nlvl, ULONG cbMax);

// version checking API

// error handling/shutdown API
typedef BOOL (_stdcall *pfnSDIDbgOff)(SDI_SPID);
typedef BOOL (_stdcall *pfnSDIError) (SDI_SPID spid, char *szDB, USHORT cchDB, PRID prid, IDX idx, OFF off, long numErr, char *szErr, ULONG cbErr);

enum SDIErrors {                // possible error codes
    SDI_OK,                     // looking good
    SDI_USAGE,                  // invalid paramter etc. should never happen
    SDI_VERSION,                // version mismatch; cannot proceed
    SDI_OUT_OF_MEMORY,          // out of memory
    SDI_SYM_NOTFOUND,           // invalid sym name
    SDI_INVALID_SYMTYPE,        // invalid sym type
    SDI_INVALID_SYMVAL,         // invalid sym value
    SDI_INVALID_SPID,           // invalid spid
    SDI_SHUTDOWN,               // code set during SDIDbgOff
    SDI_MAX                     // last code we know of
};

typedef SDI_EC (_stdcall *pfnSDIGetLastError) (void);    

// memory management routines
typedef void * (_stdcall *pfnSDIPvAlloc)  (size_t cb);
typedef void * (_stdcall *pfnSDIPvAllocZ) (size_t cb);
typedef void * (_stdcall *pfnSDIPvRealloc)(void *pv, size_t cb);
typedef void   (_stdcall *pfnSDIFreePv)   (void *pv);

// function tables
// Important!!  The caller of these SQL Server APIs should always have the same SPID as
// the SPID argument they pass, since fatal errors in these routines will cause an
// MSSqlSDICleanup, which cleans up everything and switch off SQL Debugging.
//
typedef struct _SQLFNTBL {                      // function table filled in by sql server
    pfnSDIGetLastError          SDIGetLastError;//4.2
    pfnSDIGetSym                SDIGetSym;		//4.2
    pfnSDISetSym                SDISetSym;		//4.2
    pfnSDIDbgOff                SDIDbgOff;		//4.2
    pfnSDIGetSym60              SDIGetSym60;	//6.0
} SQLFNTBL, *PSQLFNTBL;

typedef struct _DBGFNTBL {                      // function table filled in by debug dll
    pfnSDINewSPID				SDINewSPID;		//4.2
    pfnSDINewSP                 SDINewSP;		//4.2
    pfnSDIStep                  SDIStep;		//4.2
    pfnSDINewBatch              SDINewBatch;	//4.2
    pfnSDIPvAlloc               SDIPvAlloc;		//4.2
    pfnSDIPvAllocZ              SDIPvAllocZ;	//4.2
    pfnSDIPvRealloc             SDIPvRealloc;	//4.2
    pfnSDIFreePv                SDIFreePv;		//4.2
    pfnSDIPop                   SDIPop;			//4.2
    pfnSDICloseConnection       SDICloseConnection;//4.2
    pfnSDISpidContext           SDISpidContext;	//4.2
	pfnSDIError					SDIError;		//5.0
	pfnSDIActionLines			SDIActionLines;	//6.0
} DBGFNTBL, *PDBGFNTBL;

// macros for ease of use
#define SDINEWSPID(pfntbl,spid,szSqlSrvr,szMachine,pvDbgData,cbDbgData,pid,dbgpid) ((*((pfntbl)->SDINewSPID))((spid),(szSqlSrvr),(szMachine),(pvDbgData),(cbDbgData),(pid),(dbgpid)))
#define SDINEWBATCH(pfntbl,spid,CmdBuf,cbCmdBuf,nlvl) ((*((pfntbl)->SDINewBatch))((spid),(CmdBuf),(cbCmdBuf),(nlvl)))
#define SDINEWSP(pfntbl, spid, DBName, DBLen, prid, nlvl) ((*((pfntbl)->SDINewSP))((spid),(DBName),(DBLen),(prid),(nlvl)))
#define SDISTEP(pfntbl, spid, prid, idx, off, nlvl) ((*((pfntbl)->SDIStep))((spid),(prid),(idx),(off),(nlvl)))
#define SDIPOP(pfntbl, spid, nlvl) ((*((pfntbl)->SDIPop))((spid),(nlvl)))
#define SDICLOSECONNECTION(pfntbl,spid,sqlerror,sdierror) ((*((pfntbl)->SDICloseConnection))((spid),(sqlerror),(sdierror)))
#define	SDISPIDCONTEXT(pfntbl,spid,pid,tid) ((*((pfntbl)->SDISpidContext))((spid),(pid),(tid)))
#define SDIACTIONLINES(pfntbl,spid,prid,rgusActionLines, cActionLines) ((*((pfntbl)->SDIActionLines))((spid),(prid),(rgusActionLines),(cActionLines)))
#define SDIGETSYM(pfntbl, spid, syms, rgsyminfo, cnt, nlvl)((*((pfntbl)->SDIGetSym))((spid),(syms),(rgsyminfo),(cnt),(nlvl)))
#define SDISETSYM(pfntbl, spid, syms, psyminfo, nlvl)((*((pfntbl)->SDISetSym))((spid),(syms),(psyminfo),(nlvl)))
#define SDIGETSYM60(pfntbl, spid, syms, rgsyminfo, cnt, nlvl, cbMax)((*((pfntbl)->SDIGetSym60))((spid),(syms),(rgsyminfo),(cnt),(nlvl), (cbMax)))

#define SDIDBGOFF(pfntbl, spid)((*((pfntbl)->SDIDbgOff))((spid)))

#define SDIGETLASTERROR(pfntbl)((*((pfntbl)->SDIGetLastError))())

#define SDIPVALLOC(pfntbl, cb)((*((pfntbl)->SDIPvAlloc))((cb)))
#define SDIPVALLOCZ(pfntbl, cb)((*((pfntbl)->SDIPvAllocZ))((cb)))
#define SDIPVREALLOC(pfntbl, pv, cb)((*((pfntbl)->SDIPvReAlloc))((pv), (cb)))
#define SDIFREEPV(pfntbl, pv)((*((pfntbl)->SDIPvReAlloc))((pv)))
#define SDIERROR(pfntbl, spid, szDB, cchDB, prid, idx, off, numErr, szErr, cbErr) ((*((pfntbl)->SDIError))((spid),(szDB), (cchDB), (prid), (idx), (off), (numErr),(szErr),(cbErr)))

#pragma pack(pop, enter_SDI)

#endif // __SDI_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\vctools\pdb6\langapi\include\sqlprxky.h ===
// SqldprxyKey.h - startup key for sqldprxy

// proxy gets started up with 2 args, the first is the key,
// the 2nd is the event name (which includes the PID to make it unique)
#define SZSQLPROXYKEY	"SqlProxyKeyArg"

void __inline BuildProxyEventName( char *p )
{
	wsprintf(p, "MS.MSDev.Event.Ent.%x", GetCurrentProcessId() );
}

#ifdef DEBUG
#define	szSqlProxyBase	"sqlprxyd"
#else
#define	szSqlProxyBase	"sqlprxy"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\vctools\pdb6\langapi\include\simpldis.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    simpldis.h

Abstract:

    Generic C language interface to PUMA disassembler.

    This is designed to expose the functionality of the PUMA disassembler
    via a simple C language API.  It is not intended to be as flexible or
    as efficient as using the DIS class interface.  It is intended to provide
    "least common denominator" access to the disassembler for C code which
    does not have stringent performance demands.  A minimum set of types is
    exposed, and they are named so as to minimize the chance of collisions.

Author:

    KentF 16-Jan-1996

--*/


#ifndef _SIMPLDIS_H
#define _SIMPLDIS_H

#ifdef __cplusplus
extern "C" {
#endif

enum _SIMPLE_ARCHITECTURE {
    Simple_Arch_X86,
    Simple_Arch_Mips,
    Simple_Arch_AlphaAxp,
    Simple_Arch_PowerPc
};

//
// enumeration for x86 registers.
// all of the other platforms currently supported
// use an intuitively obvious register numbering
// scheme - e.g. r0..r31 represented as 0..31
//

enum _SIMPLE_REGX86
{
   SimpleRegEax	= 0,
   SimpleRegEcx	= 1,
   SimpleRegEdx	= 2,
   SimpleRegEbx	= 3,
   SimpleRegEsp	= 4,
   SimpleRegEbp	= 5,
   SimpleRegEsi	= 6,
   SimpleRegEdi	= 7,
};

#define SD_STRINGMAX 100

//
// disassembly return structure.  this contains
// all of the data returned from the disassembler.
// it contains no input data, and need not be
// initialized by the caller.
//

typedef struct _SIMPLEDIS {

    DWORD   dwEA0;              // First effective address
    size_t  cbEA0;              // data size
    DWORD   dwEA1;              // Second effective address
    size_t  cbEA1;              // data size
    DWORD   dwEA2;              // Third effective address
    size_t  cbEA2;              // data size
    DWORD   cbMemref;           // size of data at EA0
    DWORD   dwBranchTarget;     // branch target, if IsBranch or IsCall
    DWORD   dwJumpTable;        // jump table for indirect jumps
    DWORD   cbJumpEntry;        // size of each jump table entry
    BOOL    IsCall;
    BOOL    IsBranch;
    BOOL    IsTrap;

    char    szAddress[SD_STRINGMAX];
    char    szRaw[SD_STRINGMAX];
    char    szOpcode[SD_STRINGMAX];
    char    szOperands[SD_STRINGMAX];
    char    szComment[SD_STRINGMAX];
    char    szEA0[SD_STRINGMAX];
    char    szEA1[SD_STRINGMAX];
    char    szEA2[SD_STRINGMAX];

} SIMPLEDIS, *PSIMPLEDIS;



   // Pfncchaddr() is the callback function for symbol lookup.
   // If the address is non-zero, the callback function is called during
   // CchFormatInstr to query the symbol for the supplied address.  If there
   // is no symbol at this address, the callback should return 0.

typedef
size_t (WINAPI *PFNCCHADDR) (
    PVOID pv,
    DWORD addr,
    PCHAR symbol,
    size_t symsize,
    DWORD *displacement
    );


   // Pfncchfixup() is the callback function for symbol lookup.
   // If the address is non-zero, the callback function is called during
   // CchFormatInstr to query the symbol and displacement referenced by
   // operands of the current instruction.  The callback should examine the
   // contents of the memory identified by the supplied address and size and
   // return the name of any symbol targeted by a fixup on this memory and the
   // displacement from that symbol.  If there is no fixup on the specified
   // memory, the callback should return 0.

typedef
size_t (WINAPI *PFNCCHFIXUP) (
    PVOID pv,
    DWORD ipaddr,
    DWORD addr,
    size_t opsize,
    PCHAR symbol,
    size_t symsize,
    DWORD *displacement
    );


typedef
size_t (WINAPI *PFNCCHREGREL) (
    PVOID pv,
    DWORD ipaddr,
    int reg,
    DWORD offset,
    PCHAR symbol,
    size_t symsize,
    DWORD *displacement
    );


typedef
DWORDLONG (WINAPI *PFNQWGETREG) (
    PVOID pv,
    int reg
    );


int
WINAPI
SimplyDisassemble(
    PBYTE           pb,
    const size_t    cbMax,
    const DWORD     Address,
    const int       Architecture,
    PSIMPLEDIS      Sdis,
    PFNCCHADDR      pfnCchAddr,
    PFNCCHFIXUP     pfnCchFixup,
    PFNCCHREGREL    pfnCchRegrel,
    PFNQWGETREG     pfnQwGetreg,
    const PVOID     pv
    );

// Call this when you are done using the disassembler. 
// This frees up any memory allocated by the disassembler.

void 
WINAPI
CleanupDisassembler(
	VOID
	);

#ifdef __cplusplus
}
#endif

#endif // _SIMPLDIS_H

=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\vctools\pdb6\langapi\include\sqlpkapi.h ===
/////////////////////////////////////////////////////////////////////////////
//	SQLPKAPI.H
//		SQL specific package interface declarations.

// IMPORTANT: this file is used by debugger components so:
// 1. Needs to be C-parsable ie no C++ luxuries (easier said than done I know)
// 2. Must not require MFC types or headers
// 3. Make sure you use the OLE macros in a C-compatible way (ditto)
// 4. If this changes, the debugger bits will need a rebuild

#ifndef __SQLPKAPI_H__
#define __SQLPKAPI_H__

interface ISqlExec;
interface ISrcDebug;

#ifdef __cplusplus
typedef ISqlExec* LPSQLEXEC;
typedef ISrcDebug* LPSRCDEBUG;
#endif

/////////////////////////////////////////////////////////////////////////////
// ISqlExec

#undef  INTERFACE
#define INTERFACE ISqlExec

enum LoadNotifyType {lntBeforeLoad, lntAfterLoad, lntTerminatingAndRestoringBPs, lntDebugSessionEnding, lntSQLThreadCreated,
			lntProgLoad, lntProgTerm, lntBadDriver};

typedef WORD SPCOOKIE;
typedef SPCOOKIE *PSPCOOKIE;

DECLARE_INTERFACE_(ISqlExec, IUnknown)
{
	// IUnknown methods

	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG, AddRef)(THIS) PURE;
	STDMETHOD_(ULONG, Release)(THIS) PURE;

	// ISqlExec methods

	STDMETHOD_(void, GoSql)(THIS) PURE;
	STDMETHOD_(void, StepIntoSql)(THIS) PURE;
	STDMETHOD_(void, StepOverSql)(THIS) PURE;
	STDMETHOD_(void, AddTmpBpSql)(THIS) PURE;
	STDMETHOD_(void, ToggleBPSql)(THIS) PURE;

	STDMETHOD_(BOOL, DebuggeeLoadNotify)(THIS_ enum LoadNotifyType lnt, LPVOID) PURE;
	STDMETHOD_(BOOL, GetSqlSPInfo)(THIS_ SPCOOKIE Cookie, char *ServerName, char *DBN, char *Name, WORD *cLine, WORD) PURE;
	STDMETHOD_(BOOL, GetSqlLocation)(THIS_ WORD *pline, PSPCOOKIE pCookie, WORD) PURE;

	STDMETHOD_(BOOL, FindSqlSymbol)(THIS_ PVOID pSymInfo, WORD nlvl ) PURE;
	STDMETHOD_(BOOL, SetSqlSymbol)(THIS_ PVOID pSymInfo, WORD nlvl ) PURE;
	STDMETHOD_(UINT, CountSqlLocals)(THIS_ WORD nlvl, BOOL ) PURE;
	STDMETHOD_(BOOL, GetSqlLocalName)(THIS_ char*, WORD, UINT, BOOL ) PURE;

	STDMETHOD_(void, StepToReturnSql)(THIS) PURE;
	STDMETHOD_(void, HackRefCount)(THIS_ int ) PURE;
	STDMETHOD_(void, KillSql)(THIS_ unsigned long, BOOL fAsync ) PURE;

	STDMETHOD_(void*,FindSqlDocument)(THIS_ char*, BOOL) PURE;
	STDMETHOD_(BOOL, GetSqlStack)(THIS_ WORD*, int, PSPCOOKIE, WORD*) PURE;
	STDMETHOD_(BOOL, SetSqlBreakpoint)(THIS_ BOOL, SPCOOKIE, WORD ) PURE;

	STDMETHOD_(BOOL, FindCookie)(THIS_ char* szSrvr, char* szDBN, char* szProc, SPCOOKIE *pCookie) PURE;

	STDMETHOD_(BOOL, ParseSqlPath)(THIS_ char* szPath, char *szServ, char *szDB, char *szSP, int) PURE;
	STDMETHOD_(BOOL, BuildSqlPath)(THIS_ char* szPath, char *szServ, char *szDB, char *szSP, int) PURE;
	STDMETHOD_(BOOL, GetCodeLines)(THIS_ SPCOOKIE, int*pSize, unsigned short** ppList) PURE;

	STDMETHOD_(BOOL, InProcSql)(THIS_ char* szPath) PURE;
    STDMETHOD(LoadDocument)(LPCTSTR szName) PURE;
};


/////////////////////////////////////////////////////////////////////////////
// ISrcDebug

#undef  INTERFACE
#define INTERFACE ISrcDebug

DECLARE_INTERFACE_(ISrcDebug, IUnknown)
{
	// IUnknown methods

	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG, AddRef)(THIS) PURE;
	STDMETHOD_(ULONG, Release)(THIS) PURE;

	// ISrcDebug methods

	STDMETHOD_(BOOL, DebugSystemService)(THIS_ int i1, int i2, int i3, void *pv1, int i4, void *pv2) PURE;
	STDMETHOD_(void, UpdateBPViews)(THIS) PURE;
};


#endif	// __SQLPKAPI_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\vctools\pdb6\langapi\include\vcver.h ===
#ifndef _VC_VER_INC
#define _VC_VER_INC
#ifndef _VC_VER
#define _VC_VER 550
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\vctools\pdb6\langapi\include\ssvc.h ===
/*++

Copyright (c) 1992-1996  Microsoft Corporation

Module Name:

    ssvc.h

Abstract:

    This header contains the enumeration of system services provided
    by OSDebug 4.

Author:

    Kent Forschmiedt (kentf) 09-Oct-1996

Environment:

    Win32, User Mode

--*/



typedef enum {
        ssvcNull = 0,
        ssvcDumpLocalHeap,
        ssvcDumpGlobalHeap,
        ssvcDumpModuleList,
        ssvcCrackLocalHmem,
        ssvcCrackGlobalHmem,
        ssvcKillApplication,
        ssvcFreeLibrary,
        ssvcInput,
        ssvcOutput,
        ssvcOleRpc,             // Enable/disable OLE Remote Procedure Call tracing
                                    // Pass cb = 1, rgb[0] = fEnable.  Before this is
                                    // called the first time, OLE RPC debugging is
                                    // disabled.  Also see mtrcOleRpc.
        ssvcHackFlipScreen,     // Hack for testing: toggle switching previous
                                    // foreground window back to foreground on F8/F10.
        ssvcNativeDebugger,     // Activate remote debugger
        ssvcSetETS,
        ssvcCvtRez2Seg,
        ssvcSqlDebug,
        ssvcFiberDebug,
} SSVC;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\vctools\pdb6\langapi\include\typesrvr.h ===
// Type server interface.

#ifndef _VC_VER_INC
#include "..\include\vcver.h"
#endif

#if (defined (_M_IX86) && (_M_IX86) < 300) || (_MSC_VER < 800)
#define PDBFAR	__far
#else
#define PDBFAR
#endif

typedef void PDBFAR*	TS;		// type server, opaque type
typedef unsigned short	TI;		// type index
typedef unsigned long	TSIG;	// type database signature
typedef unsigned long	TVER;	// type server version
typedef unsigned long	TAGE;	// type database age
typedef char PDBFAR*		PB;		// pointer to some bytes
typedef unsigned long	CB;		// count of bytes
typedef CB PDBFAR*	PCB;	// pointer to count of bytes
typedef PB				SZ;		// zero terminated string
typedef int				PDBBOOL;// Boolean

#define	tsNil			((TS)0)
#define	tiNil			((TI)0)

#define	tdbWrite				"w"
#define	tdbRead					"r"
#define	tdbGetTiOnly			"i"
#define	tdbGetRecordsOnly		"c"

#ifdef __cplusplus
extern "C" {
#endif

TVER	TypesQueryServerVersion(void);
TS		TypesOpen(SZ szDatabase, SZ szMode, TSIG sig);
TSIG	TypesQuerySignature(TS ts);
TAGE	TypesQueryAge(TS ts);
TI		TypesQueryTiForCVRecord(TS ts, PB pb);
PB		TypesQueryPbCVRecordForTi(TS ts, TI ti);
void	TypesQueryCVRecordForTi(TS ts, TI ti, PB pb, PCB pcb);
TI		TypesQueryTiMin(TS ts);
TI		TypesQueryTiMac(TS ts);
CB		TypesQueryCb(TS ts);
PDBBOOL	TypesCommit(TS ts);
PDBBOOL	TypesClose(TS ts);

#ifdef __cplusplus
};
#endif

struct THDR { // type database header:
	char	szMagic[0x2C];
	TVER	tver;			// version which created this file
	TSIG	tsig;			// signature
	TAGE	tage;			// age (no. of times written)
	TI		tiMin;			// lowest TI
	TI		tiMac;			// highest TI + 1
	CB		cb;				// count of bytes used by the gprec which follows.
	// rest of file is "REC gprec[];"
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\vctools\pdb6\langapi\include\vcexcept.h ===
// defined exceptions used by Visual C++
// [created apennell 6/24/97]
// must be kept in sync in both V6 and V7 langapi trees

#pragma once
#if !defined(_vcexcept_h)
#define _vcexcept_h

// the facility code we have chosen is based on the fact that we already
// use an exception of 'msc' when we throw C++ exceptions

#define FACILITY_VISUALCPP  ((LONG)0x6D)

#define VcppException(sev,err)  ((sev) | (FACILITY_VISUALCPP<<16) | err)

/////////////////////////////////////////////////////////////////
// define all exceptions here, so we don't mess with each other
/////////////////////////////////////////////////////////////////

// used by CRTs for C++ exceptions, really defined in ehdata.h
//#define EH_EXCEPTION_NUMBER   VcppException( 3<<30, 0x7363 )      // SEV_ERROR, used by CRTs for C++

// used by debugger to do e.g. SetThreadName call
#define EXCEPTION_VISUALCPP_DEBUGGER    VcppException(1<<30, 5000)      // SEV_INFORMATIONAL

#endif	// _vcexcept_h
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\vctools\pdb6\langapi\include\sqlguid.h ===
// Interface ID for SQL Execution control

DEFINE_GUID(IID_ISqlExec, 
0xfbca3ca2, 0x6abe, 0x11cf, 0x92, 0x81, 0x0, 0xa0, 0xc9, 0x3, 0x49, 0x10);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\vctools\pdb6\langapi\include\vcbudefs.h ===
// VCBUDEFS.H - standard defs to be used for hungarian notation

#ifndef _VC_VER_INC
#include "..\include\vcver.h"
#endif

#ifndef VCBUDEFS_INCLUDED
#define VCBUDEFS_INCLUDED

typedef int BOOL;
typedef unsigned UINT;
typedef unsigned char BYTE;
typedef unsigned long ULONG;
typedef unsigned short USHORT;
typedef ULONG	INTV;		// interface version number
typedef ULONG	IMPV;		// implementation version number
typedef ULONG	SIG;		// unique (across PDB instances) signature
typedef ULONG	AGE;		// no. of times this instance has been updated
typedef BYTE*	PB;			// pointer to some bytes
typedef long	CB;			// count of bytes
typedef char*	SZ;			// zero terminated string
typedef const char*	SZ_CONST;// const zero terminated string
typedef char*	PCH;		// char ptr
typedef USHORT	IFILE;		// file index
typedef USHORT	IMOD;		// module index
typedef USHORT	ISECT;		// section index
typedef USHORT	LINE;		// line number
typedef long	OFF;		// offset
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\vctools\pdb6\langapi\include\version.h ===
#define rmj		6
#define rmm		10
#define rup		8226
#define szVerName	"VC6x"
#define szVerUser	"BryanT3"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\Vulcan\inc\vulcanapi.h ===
/***********************************************************************
* Microsoft  Vulcan
*
* Microsoft Confidential.  Copyright 1997-1999 Microsoft Corporation.
*
* File: vulcanapi.h
*
* File Comments:
*
*
***********************************************************************/

#pragma once

#ifndef __VULCANAPI__
#define __VULCANAPI__

//
// Vulcan DLL version number.  Note that this constant was not in version
// 1.0, if it's defined at all then you've got at least version 1.01.
//
#define VULCANVER 0x200

#if     defined(VULCANDLL__)           //  Building the Vulcan DLL

#undef  __INLINE
#define __INLINE     inline

#undef  VULCANDLL
#define VULCANDLL    __declspec(dllexport)

#elif   defined(VULCANI__)             //  Building the Vulcan static library

#undef  __INLINE
#define __INLINE

#undef  VULCANDLL
#define VULCANDLL

#elif   defined(VULCANS__)             //  Building a client using the Vulcan static library

#undef  __INLINE
#define __INLINE     inline

#undef  VULCANDLL
#define VULCANDLL

#else                                  //  Building a Vulcan client

#undef  __INLINE
#define __INLINE     inline

#undef  VULCANDLL
#define VULCANDLL    __declspec(dllimport)

#if     !defined(BBTIRT)
#pragma comment(lib, "vulcan.lib")
#endif

#endif

#define VULCANCALL   __stdcall

typedef unsigned char    BYTE;
typedef unsigned short   WORD;
typedef unsigned long    DWORD;
typedef unsigned __int64 DWORDLONG;
typedef DWORDLONG        ADDR;
typedef unsigned __int64 VULHANDLE;

//UNDONE: remove this code once VC7 is required
#ifndef _INTPTR_T_DEFINED
#ifdef  _WIN64
typedef __int64    intptr_t;
#else
typedef int        intptr_t;
#endif
#define _INTPTR_T_DEFINED
#endif

// Classes defined in this file (vulcanapi.h)
class VSystem;
class VProg;
class VComp;
class VProc;
class VBlock;
class VInst;
class VProto;
class VProtoList;


// Classes defined in vulcanex.h
class VSrcInfo;
class VSrcIter;
class VSect;
class VReloc;
class VOperand;
class VAddress;
class VExport;
class VImport;
class VUserData;
struct VAddrRange;
class VAnnotation;
class VAnnotationIter;

// Classes defined in vulcancmdfile.h
class SZDICTIONARY;

// Classes defined in vulcanbmp.h
class CBmp;

// From <stdio.h>
struct _iobuf;                  // a FILE

#include <exception>
#include <stdarg.h>

#include "vulcanienum.h"
#include "vulcandlist.h"
#include "vulcankdlist.h"
#include "vulcanex.h"
#include "vulcanerr.h"

//   There are 4 important objects to understand for the Vulcan API.
//   Comps,Procs,Blocks,Insts:  are 4 types and represent the program structures.  They are queried or modified.
//   System and Prog are optional
//   [VSystem]
//       [VProg]
//           VComp
//               VProc
//                   VBlock
//                       VInst
//   The above is read to say that a VProg contains a list of VComps and VComps contain a list of VProcs and so on.

class VSystem
{
public:
    // Open a machine.  For now, szMachine should remain NULL
    static VULCANDLL VSystem * VULCANCALL Open( const char * szMachine = NULL, DWORD OpenFlags = 0);

    // Refresh the set of Progs.  This will only add new processes - the return is the number added
    virtual size_t RefreshProgs() = 0;

    // Get the first program on this system
    virtual VProg* FirstProg() = 0;

    // Get the current number of program on this system
    virtual size_t CountProg() = 0;

    // Free up this system component
    virtual void Destroy() = 0;
};

class VProg : public CDListElem_VProg
{
public:
    // Open a program.  This interface subsumes all functionality of the
    // other Open/OpenEx functions, via the OpenFlags parameter (made by
    // or'ing together values from enum OpenFlags, from vulcanienum.h).
    static VULCANDLL VProg* VULCANCALL Open(const char *DLLorEXEfileName, const char *CmdFileName, DWORD OpenFlags);

    // Open a program.  DoDllClosure will open all dlls that we can find
    // from this program.
    //
    // This API is obsolete and may be removed in a future version.  The
    // `OpenFlags' version of VProg::Open should be used instead.
    static VULCANDLL VProg* VULCANCALL Open( const char* DLLorEXEfileName, bool DoDllClosure = false, const char* CmdFileName = NULL);

    // Same as above but has an extra parameter to ignore missing CV info.
    // Please note that this is handy for experimental purposes but is not
    // safe in a production environment.  Please use this with care.
    //
    // This API is obsolete and may be removed in a future version.  The
    // `OpenFlags' version of VProg::Open should be used instead.
    static VULCANDLL VProg* VULCANCALL OpenEx( const char* DLLorEXEfileName, bool DoDllClosure = false, const char* CmdFileName = NULL, bool IgnoreCvError = false );

    // Open a program that is running.  -1 means the current process
    static VULCANDLL VProg* VULCANCALL OpenDynamic( DWORD idProcess, DWORD OpenFlags, const char *szMachine = NULL );

    // Open a program in dynamic mode by launching it.
    static VULCANDLL VProg* VULCANCALL OpenDynamic( const char *szCmdLine, DWORD OpenFlags, const char *szMachine = NULL);

    // Get an iterator for the components of this program
    virtual VComp* FirstComp() = 0;
    virtual VComp* LastComp() = 0;

    // Add to first/last
    virtual void InsertFirstComp(VComp*) = 0;
    virtual void InsertLastComp(VComp*) = 0;

    // Get the name of the program
    virtual const char* Name() = 0;

    // Delete this program
    virtual void Destroy() = 0;

    // How many components in the program?
    virtual size_t CountComps() = 0;

    // Get the next prog in the system (returns NULL if you opened a Prog)
    virtual VProg *Next() = 0;

    // Get the parent system (only works if you started with one)
    virtual VSystem *ParentSystem() = 0;

    // Get the process handle/id of the attached process (NULL for none)
    virtual VULHANDLE ProcessHandle() = 0;
    virtual DWORD  ProcessId() = 0;

    // Check whether this program is attached to a live process (false if GetProcessHandle() returns NULL)
    virtual bool IsProcessLive() = 0;

    // Allocate memory in the remote process, returning the address.
    // This memory will be read/write/execute
    virtual ADDR AllocateMemory(size_t cb) = 0;

    // Write memory in the process (this may fail... especially if the process has exited)
    virtual bool WriteMemory( ADDR addr, size_t cb, void *pv ) = 0;

    // Read memory in the process
    virtual bool ReadMemory( ADDR addr, size_t cb, void *pv ) = 0;

    // Stop/Restart the live process (this is reference counted!)
    virtual void Suspend() = 0;
    virtual void Resume() = 0;

    // Get/set the user data for this program
    inline void SetUserData(void*, VUserData*);
    inline void* GetUserData(VUserData*);
};

class VComp : public CDListElem_VComp
{
public:
    // Open a component.  `flags' is bits from OpenFlags, from vulcanienum.h.
    static VULCANDLL VComp* VULCANCALL Open(char *DLLorEXEfileName, DWORD flags = 0);

    // Gets the level used to open the image.  See OpenFlags
    virtual void GetOpenLevel(DWORD *pdwOpenFlags) = 0;

    // Get the program that this component is a member of (may return NULL)
    virtual VProg* ParentProg() = 0;

    // Get the first/last/prev/next component (returns NULL for none)
    virtual VComp* Next() = 0;
    virtual VComp* Prev() = 0;
    virtual VComp* First() = 0;
    virtual VComp* Last() = 0;

    // Insert a component before/after this component
    virtual void InsertPrev(VComp*) = 0;
    virtual void InsertNext(VComp*) = 0;

    // Remove this component from the program
    virtual void Remove() = 0;

    // Get the first/last code procedure in this component
    virtual VProc* FirstProc() = 0;
    virtual VProc* LastProc() = 0;

    // Get the first/last procedure in this component (either code or data)
    virtual VProc* FirstAllProc() = 0;
    virtual VProc* LastAllProc() = 0;

    // Add the first/last proc to the component
    virtual void InsertFirstProc(VProc*) = 0;
    virtual void InsertLastProc(VProc*) = 0;

    // How many procs in the comp
    virtual size_t CountProcs() = 0;

    // How many procs (code or data) in this section
    virtual size_t CountAllProcs() = 0;

    // How many sections in the comp
    virtual size_t CountSects() = 0;

    enum ECompType{
            CompNotUsed=0,
            PE,
            PE64,
            PECOM,
    };


    // Get the type of the input component
    virtual VComp::ECompType InputType() = 0;

    // Get the type of the output component
    virtual VComp::ECompType OutputType() = 0;

    // Get the input component name
    virtual const char* InputName() = 0;

    // Set command file (and dictionary): move to PE-specific?
    virtual void SetCommandFile(const char* szFile, SZDICTIONARY* pszdictCmd = NULL) = 0;


    // Is the PDB filename going to be output?
    virtual bool CanWritePdb() = 0;

    // Is the binary emitted by BBT tools?
    virtual bool IsEmittedByBBT() = 0;

    // Is the binary emitted by BBT tools?
    virtual bool IsEmittedByVulcan() = 0;

    // Is the binary emitted by BBINSTR?
    virtual bool IsInstrumentedByBBT() = 0;

    // Is this Vulcan emitted component be parsed again?
    virtual bool IsRereadable() = 0;

    // Get/set the timestamp of this component
    virtual DWORD TimeStamp() = 0;

    // Reads the exe/dll and creates IR (if not already created)
    virtual void Build() = 0;

    // Writes this component to outputname (defaults to foo.vulcan.exe, foo.vulcan.pdb, none, true )
    virtual void Write(const char *szOutputName = NULL, const char *szOutputPdbName = NULL, const char *szMapFile = NULL, bool fRereadable = false) = 0;
    virtual void Write(DWORD WriteFlags, const char *szOutputName, const char *szOutputPdbName, const char *szMapFile) = 0;

    // Same as Write above only MUCH faster.  Does not compact the exe.  Does not check Intel Errata 42 (a problem for a VERY small number of Intel chips).
    virtual void WriteFast(const char *szOutputName = NULL, const char *szOutputPdbName = NULL, const char *szMapFile = NULL, bool fRereadable = false) = 0;
    virtual void WriteFast(DWORD WriteFlags, const char *szOutputName = NULL, const char *szOutputPdbName = NULL, const char *szMapFile = NULL) = 0;

    // dump the printed VULCAN instructions.
    virtual void Print( const char *fileName ) = 0;

    // dump out the asmemit just like dmpdb /asmemit output.  Use only after calling write.
    virtual void PrintAsm(const char* fileName) = 0;

    // Get the primary entry point for this component (main, WinMain, DllMain...)
    virtual VBlock* EntryBlock() = 0;

    // Set the primary entry point for this component (you should call the old entry point yourself from p)
    virtual void SetEntryBlock( VBlock* pBlk ) = 0;

    // Get the block corresponding to the image header
    virtual VBlock* ImageHeaderBlock() = 0;

    // Create a new, empty procedure in this component (inserts at beginning of first code section)
    virtual VProc* NewProc( const char* name ) = 0;
    virtual VProc* NewProc() = 0;

    // Adds an import.  Block returned can be used to as call target to call new import
    virtual VBlock* CreateImport(const char* dll,const char* func, bool = false) = 0;

    // Get the first/last section for this component
    virtual VSect* FirstSect() = 0;
    virtual VSect* LastSect() = 0;

    // Create a new section (flags are ors of SectionFlags)
    virtual VSect* NewSect( const char* name, DWORD flags ) = 0;

    // Gives the block corresponding to a (public) mangled name - pib is out for offset into block
    virtual VBlock *BlockFromSymName(const char *sz, DWORD *pib = NULL) = 0;

    // Get the imports for this component
    virtual VImport* FirstImport() = 0;
    virtual size_t   CountImports() = 0;
    virtual VImport* FindImport(const char *dllName, const char *procName) = 0;
    virtual VImport* FindImport(const char *dllName, DWORD ordinal) = 0;

    // Merge this component with another component.  The first argument
    // specifies the string name of the component you want to merge with.
    // The second argument is a string that specifies the routine that
    // would be executed when the app is terminated.  This is needed mostly
    // for the case where a DLL is merged into an EXE and there is code in
    // DllMain to do some work when the DLL receives a PROCESS_DETACH
    // message.
    virtual void MergeIR(const char *, const char * = NULL) = 0;

    // Get the exports for this component
    virtual VExport* FirstExport() = 0;
    virtual size_t   CountExports() = 0;
    virtual VExport* FindExport(const char *exportName) = 0;
    virtual VExport* FindExport(DWORD ordinal) = 0;

    // Turn on block follower mode
    virtual void UseBlockFollowers() = 0;

    // Redirect an import/external procedure to another import/external procedure
    virtual bool RedirectImport(const char* DllFrom, const char* nameFrom, const char* DllTo, const char* NameTo) = 0;
    virtual bool RedirectImport(VImport * pimportFrom, const char* DllTo, const char* NameTo) = 0;

    // Redirect an import/external procedure to a procedure.
    // The procedure can be created by CreateImportThunk.
    virtual bool RedirectImport(const char* DllFrom, const char* nameFrom, VProc *pprocTo) = 0;
    virtual bool RedirectImport(VImport * pimportFrom, VProc *pprocTo) = 0;

    // Redirect an export to a block
    virtual VBlock * RedirectExport(const char* nameFrom, VBlock *pblkTo) = 0;
    virtual VBlock * RedirectExport(VExport * pexportFrom, VBlock *pblkTo) = 0;

    // Redirect a local procedure to another local procedure
    // Place a jump at the beginning of this procedure which goes to another address.
    // The returned block will be the entry point for the old routine.
    virtual VBlock * RedirectProc(const char* procName, VProc *pprocTo) = 0;
    virtual VBlock * RedirectProc(VProc * pprocFrom, VProc *pprocTo) = 0;

    // Redirect a local procedure to an import
    // Place a jump at the beginning of this procedure which goes to another address.
    // The returned block will be the entry point for the old routine.
    virtual VBlock * RedirectProc(const char* procName, const char* szDllTo, const char* szFuncTo) = 0;
    virtual VBlock * RedirectProc(VProc *pprocFrom, const char* szDllTo, const char* szFuncTo) = 0;

    // Delete this component
    virtual void Destroy() = 0;

    // Get/set the user data for this comp
    inline void  SetUserData(void*, VUserData*);
    inline void* GetUserData(VUserData*);

    // Debugging support (Print the components name and return it)
    virtual const char * DbgPrint() = 0;

    // Returns iterator over all the symbols for this component.
    virtual VSymIter * AllSymbols() = 0;   // Call Destroy() after use.

    // IF argument is NULL, Return the number of address ranges of asm code to keep together.
    // ELSE fill given array with address ranges.
    //
    virtual size_t GetAddrrangeAsmCodeKeepTogether(VAddrRange []=0) = 0;

    // IF argument is NULL, Return the number of address ranges to keep together.
    // ELSE fill given array with address ranges.
    //
    virtual size_t GetAddrrangeKeepTogether(VAddrRange []=0) = 0;

    // Does this VComp represent a "dll"
    virtual bool IsDll() = 0;

    // Does this VComp represent a "driver"
    virtual bool IsDriver() = 0;

    // Get the version for this component from (resources)
    // 3.75.0.31 would be encoded as 0x00030075 0x00000031
    virtual bool FGetVersion( DWORD *pdwFileMS, DWORD *pdwFileLS, DWORD *pdwProdMS, DWORD *pdwProdLS) = 0;

    // Get the checksum for this component (this is not always set)
    virtual DWORD Checksum() = 0;

    // Create a new export.
    // IF this component previously had exports, the existing export module name is used.
    // ELSE the output name of the component is used.
    // It is the caller's responsiblity to ensure that there are no name and/or ordinal conflicts.
    virtual VExport *CreateExport(const char *szName, ORD16 ordinal, VBlock *) = 0;

    // Create a forwarder export.
    virtual VExport *CreateExport(const char *szName, ORD16 ordinal, const char *szDest) = 0;

    // Create Alternate path to PDB
    virtual void SetPdbAlternatePath(const char *szPath) = 0;

    // Create stripped PDB when linking
    virtual void SetPdbStrippedPath(const char *) = 0;

    // Return an iterator that can be used to find annotations in the component.
    virtual VAnnotationIter *AnnotationIter(const char * = NULL) = 0;

    // Return the VProc that "contains" the specified address (i.e. the
    // address is >= the VProc's Addr(), and < the VProc's "Addr() +
    // Size()".  This function is not terribly efficient: it simply
    // iterates over all the VProcs in the VComp testing their addresses
    // and sizes.  Returns NULL if no matching VProc is found.
    virtual VProc *FindProc(ADDR addr) = 0;

    // Set this as the "current working" component - this will be a default
    virtual void SetCurrentWorking() = 0;

    // Create import thunk creates a procedure which jumps to the import.
    // Use this with VComp::RedirectProc or VComp::RedirectImport.
    virtual VProc* CreateImportThunk(const char* dll,const char* func,bool = false) = 0;

    // Mark all imports from a module to be delayed load or regular imports depending
    // on the specified flag.  If it is true, all imports entries from this module
    // will be delay-load.  If it is false, they will all turned into regular imports.
    virtual void SetImportModuleForDelayLoad(const char *, bool fDelayLoad = true) = 0;

    // Redirect all references to redirected imports to go to the new import blocks
    virtual void ProcessRedirectedImportTargets() = 0;

    // For dynamic mode, identify the path to the local binary so that we don't have to
    // download the remote binary to build the IR.
    virtual void DynamicSetLocalModuleName( const char *szLocalImage ) = 0;
};

class VProc : public CDListElem_VProc
{
public:
    // Create a new proc (not inserted automatically - the name becomes a sym in pComp )
    static VULCANDLL VProc* VULCANCALL Create(VComp* pComp, const char* name = NULL);

    // Get the component that this procedure is in
    virtual VComp* ParentComp() = 0;

    // Returns the next/prev/first/last code procedure in this component
    virtual VProc* Next() = 0;
    virtual VProc* Prev() = 0;
    virtual VProc* First() = 0;
    virtual VProc* Last() = 0;

    // Returns the next/prev/first/last procedure in this component
    virtual VProc* NextAll() = 0;
    virtual VProc* PrevAll() = 0;
    virtual VProc* FirstAll() = 0;
    virtual VProc* LastAll() = 0;

    // Returns the next/prev/first/last code procedure in this _section_
    virtual VProc* NextSectProc() = 0;
    virtual VProc* PrevSectProc() = 0;
    virtual VProc* FirstSectProc() = 0;
    virtual VProc* LastSectProc() = 0;

    // Returns the next/prev/first/last procedure in this _section_
    virtual VProc* NextAllSectProc() = 0;
    virtual VProc* PrevAllSectProc() = 0;
    virtual VProc* FirstAllSectProc() = 0;
    virtual VProc* LastAllSectProc() = 0;

    // Add a proc before/after this proc
    virtual void InsertNext(VProc*) = 0;
    virtual void InsertPrev(VProc*) = 0;

    // Remove this proc from the component (without destroying it)
    virtual void Remove() = 0;

    // Returns the first live code block in the proc
    virtual VBlock* FirstBlock() = 0;
    virtual VBlock* LastBlock() = 0;
    virtual size_t  CountBlocks() = 0;

    // Returns the first block in the proc (code, data, or unreachable)
    virtual VBlock* FirstAllBlock() = 0;
    virtual VBlock* LastAllBlock() = 0;
    virtual size_t  CountAllBlocks() = 0;

    // Add a block to the first/last of the proc
    virtual void InsertFirstBlock(VBlock*) = 0;
    virtual void InsertLastBlock(VBlock*) = 0;

    // Get the friendly name of this procedure
    virtual const char* Name() = 0;

    // Set the friendly name of this procedure - this only affects the name in Vulcan
    virtual void SetName( const char* name, VComp *pComp ) = 0;


    // Get the unique name of this procedure into szbuf, returns required size when szbuf is NULL
    virtual size_t SymName(char *buf, size_t bufsize, VComp *pComp) = 0;

    // Get the address of this procedure
    virtual ADDR Addr() = 0;

    // Get the size of this procedure
    virtual size_t Size() = 0;

    // Get a pointer to the raw bytes of the procedure
    virtual const void* Raw(VComp *pComp) = 0;

    // Reverse the order of the blocks in this procedure
    virtual void Reverse() = 0;

    // Fills a buffer with the printed VULCAN instruction in this proc (if the return is > than sizeBuf, the it failed)
    virtual size_t Print( char* szBuf, size_t sizeBuf ) = 0;

    // Fills a buffer with the printed DISASM instruction in this proc (if the return is > than sizeBuf, the it failed)
    virtual size_t PrintAsm( char* szBuf, size_t sizeBuf, VComp * ) = 0;

    // Is this procedure exported
    virtual bool IsExported(VComp *pComp) = 0;

    // Get an iterator for the exports of the procedure
    virtual VExport* FirstExport(VComp *pComp) = 0;

    // Get the section that this proc is in
    virtual VSect* ParentSection() = 0;

    // Returns an iterator for the source information of this procedure
    virtual VSrcIter FirstSrc(VComp *pComp) = 0;

    // Is this a thunk?
    virtual bool IsThunk() = 0;

    // Is this an import thunk? Call FirstBlock()->ImportTarget() to find out where it goes.
    virtual bool IsImportThunk() = 0;

    // Delete this Proc
    virtual void Destroy() = 0;

    // Was this proc generated from Masm?
    virtual bool IsMasm() = 0;

    // Does this proc not return
    virtual bool IsNoReturn() = 0;

    // Was this proc created for reasons other than a CodeView CvProc symbol?
    virtual bool IsPseudoProc() = 0;

    // Does this proc register an expection?
    virtual bool HasExcept(VComp *pComp) = 0;

    // Get/set the user data for this proc
    inline void SetUserData(void*, VUserData*);
    inline void* GetUserData(VUserData*);

    // Debugging support (Print the proc's name, addr and return it)
    virtual const char * DbgPrint() = 0;

    // Returns iterator over all the symbols for this proc start address.
    virtual VSymIter   * Symbols(VComp *) = 0; // Call Destroy() after use.

    enum CCPROC {ccUnknown, ccCdecl, ccFastcall, ccStdcall, ccThiscall};
    virtual CCPROC CallConv(VComp *) = 0;

    // Function Parameter Enumeration
    virtual VSymbol *FirstParam(VComp *) = 0;

    // Function Local Enumeration
    virtual VSymbol *FirstLocal(VComp *) = 0;

    // Function return type
    virtual VSymbol *ReturnSymbol(VComp *) = 0;

    // Get the complete function prototype as a string
    virtual size_t Prototype(char *szBuf, size_t cchBuf, VComp * ) = 0;

    // Check if this proc user's flag is set
    virtual bool IsUserFlagSet() = 0;
    virtual void SetUserFlag() = 0;
    virtual void ResetUserFlag() = 0;

    // Return the VBlock that "contains" the specified address (i.e. the
    // address is >= the VBlock's Addr(), and < the VBlock's "Addr() +
    // Size()".  This function is not terribly efficient: it simply
    // iterates over all the VBlocks in the VProc testing their addresses
    // and sizes.  Returns NULL if no matching VBlock is found.
    virtual VBlock *FindBlock( ADDR addr ) = 0;

    // Get the Entry block (This is often the first block except after re-ordering)
    virtual VBlock *EntryBlock() = 0;

    // Write this procedure to memory (dynamic mode only)
    virtual ADDR Commit(VComp *pComp) = 0;

    // Get the original address of this procedure (shortcut for EntryBlock()->OrigAddr(pComp) )
    virtual ADDR OrigAddr( VComp *pComp ) = 0;

    // Create a copy of this procedure.  In dynamic mode, this new routine can be modified and then commited.
    // The optional VUserData provides a map from the old blocks to the new blocks and back.
    virtual VProc *Copy( VComp *pComp, VUserData *pData = NULL ) = 0;

    // Emit this procedure and convert it into a single data block with relocs
    // Be careful because anyone calling a block other than the entry in this routine
    // will now fail to link.
    virtual VBlock *ConvertProcToDataBlock( VComp *pComp, ADDR addrStart ) = 0;
};


class VBlock : public CDListElem_VBlock
{
public:
    // Returns the procedure that this block is in
    VULCANDLL VProc* ParentProc();

    // Get the next/prev code block in the procedure
    inline VBlock* Next();
    inline VBlock* Prev();
    inline VBlock* First();
    inline VBlock* Last();

    // Get the next/prev block in the procedure
    inline VBlock* NextAll();
    inline VBlock* PrevAll();
    inline VBlock* FirstAll();
    inline VBlock* LastAll();

    // Remove this block from the proc
    inline void Remove();

    // Insert a block before/after this block
    inline void InsertPrev(VBlock*);
    inline void InsertNext(VBlock*);

    // Get an the first/last instruction in this block
    VULCANDLL VInst* FirstInst();
    VULCANDLL VInst* LastInst();
    VULCANDLL size_t CountInsts();

    // Call this once you're done with all the insts.  Can be a huge memory win.
    VULCANDLL void ReleaseSymbolic();

    // Insert the first/last instruction in this block
    VULCANDLL void InsertFirstInst(VInst*);
    VULCANDLL void InsertLastInst(VInst*);

    // Returns a mangled symbol name at offset ib within the block (pass pComp for speed)
    VULCANDLL size_t SymName(char *buf, size_t bufsize, VComp* pComp, int ib = 0, bool fNearest = false);

    // Creates a new code block - you must insert in into a procedure if you want it output (VComp is used to assign id)
    static VULCANDLL VBlock* VULCANCALL CreateCodeBlock(VComp*);

    // Creates a new code block with just the paltformtype
    static VULCANDLL VBlock* VULCANCALL CreateCodeBlock(PlatformType);

    // Creates a new data block - you must insert in into a procedure if you want it output (VComp is used to assign id)
    static VULCANDLL VBlock* VULCANCALL CreateDataBlock(VComp*, BYTE* pbData,size_t cb);

    // Get/set the alignment on this block (in bytes)
    // Valid values are 0 (default/none), 2 (WORD), 4 (DWORD), 8(DWORDLONG), 16, 32, 64, ... 8192)
    VULCANDLL size_t AlignmentSize();
    VULCANDLL void SetAlignmentSize(size_t align);

    // Set the data in this block (data blocks only)
    VULCANDLL void SetData(BYTE* data,size_t size);

    // Get the unique identifier of this block
    VULCANDLL DWORD BlockId();

    // Set the unique identifier of this block
    VULCANDLL void SetBlockId( DWORD blockId );

    // Get the address of this block
    VULCANDLL ADDR Addr();

    // Get the compiler-emmited address of this block (pass in a pComp for speed)
    VULCANDLL ADDR OrigAddr(VComp *pComp);

    // Get the size of this block
    VULCANDLL size_t Size();

    // Get a pointer to the bytes of this block (read-only)
    VULCANDLL const void* Raw(VComp *pComp);

    // Assemble this block to pb, returning the size
    VULCANDLL size_t Emit(BYTE* pb = NULL);

    // Get/set the follower (fall-through) block (NULL for none)
    VULCANDLL VBlock* BlockFollower();
    VULCANDLL bool SetBlockFollower(VBlock*);

    // Get the target block of this block (call, jmp, conditional jmp) (NULL for none)
    VULCANDLL VBlock* BlockTarget();
    VULCANDLL bool SetBlockTarget(VBlock*);

    // Get the target proc of this block (call)
    VULCANDLL VProc* ProcTarget();
    VULCANDLL bool SetProcTarget(VProc*);

    // Get the target import of this block (indirect call)
    VULCANDLL VImport* ImportTarget(VComp *pComp);
    VULCANDLL bool SetImportTarget(VImport*);

    // Get the reloc iter (empty for code blocks)
    VULCANDLL VRelocIter FirstReloc();

    // Returns an iterator for the source information of this block
    VULCANDLL VSrcIter FirstSrc(VComp *pComp);

    // Does this block end with a RET?
    VULCANDLL bool Returns();

    // Is this a data block?
    VULCANDLL bool IsDataBlock();

    // What is the termination type of this block
    VULCANDLL BlockTermType BlockTerminationType();

    // Does this block end with a CALL
    VULCANDLL bool HasCall();

    // Does this block end with a Conditional branch?
    VULCANDLL bool HasCBranch();

    // Has this block been inserted
    VULCANDLL bool IsInserted();

    // Is this block unreachable?
    VULCANDLL bool IsUnreachable();

    // Is this block obsolete?
    VULCANDLL bool IsObsolete();

    // Is this block a call target? (direct calls only)
    VULCANDLL bool IsCallTarget();

    // Is this a possible entry block for the procedure (IsCallTarget || IsAddrTakenGlobal)
    VULCANDLL bool IsEntryBlock();

    // Does somebody outside this
    VULCANDLL bool IsAddrTakenGlobal();

    // Is this block an jump table branch target or other intra-proc addr taken?
    VULCANDLL bool IsAddrTakenLocal();

    // Is this block instrumentable?  Can we insert new code into the block?
    VULCANDLL bool IsInstrumentable();

    // Have we been told to not split this block?
    VULCANDLL bool IsNoSplit();

    // Fills a buffer with the printed Vulcan instruction in this block (if the return is > than sizeBuf, the it failed)
    VULCANDLL size_t Print( char* szBuf, size_t sizeBuf );

    // Fills a buffer with the printed DISASM instruction in this block (if the return is > than sizeBuf, the it failed)
    VULCANDLL size_t PrintAsm( char* szBuf, size_t sizeBuf, VComp *pComp );

    // To delete
    VULCANDLL void Destroy();

    // Get/set the user data for this block
    inline void SetUserData(void*, VUserData*);
    inline void* GetUserData(VUserData*);

    // Debugging support (Print the blocks blkid, addr and return it)
    VULCANDLL const char * DbgPrint();

    // Returns iterator over all the symbols for this block.
    VULCANDLL VSymIter   * Symbols(VComp *);   // Call Destroy() after use.

    // Check if this block user's flag is set
    VULCANDLL bool IsUserFlagSet();
    VULCANDLL void SetUserFlag();
    VULCANDLL void ResetUserFlag();

    // Set/Get the platform types
    VULCANDLL void          SetPlatformT(PlatformType);
    VULCANDLL PlatformType  PlatformT();

    // Add symbol at this block
    VULCANDLL bool AddPublicSymbol(char* szName, VComp *pComp);

    // Copy this block into pBlkCopy (or optionally make a new block)
    VULCANDLL VBlock *Copy( VComp *pComp, VBlock *pBlkCopy = NULL);

    // For dynamic mode, replace the contents of this block with the contents of pBlk
    // The original instructions are moved to either pBlkOldCopy or the returned block and committed
    VULCANDLL VBlock *ReplaceInstructions( VBlock *pBlk, VComp *pComp, VBlock *pBlkOldCopy = NULL);

    // For dynamic mode, commit this block to memory
    VULCANDLL ADDR Commit( VComp *pComp );

    // Output statistics about the number of blocks.  In retail builds of
    // Vulcan this function will do nothing.  Each line of output will be
    // preceded by the string `pcszPrefix'.
    static VULCANDLL void VULCANCALL PrintBlockStats( const char *pcszPrefix );

    // Return the VInst that "contains" the specified address (i.e. the
    // address is >= the VInst's Addr(), and < the VInst's "Addr() +
    // Size()".  This function is not terribly efficient: it simply
    // iterates over all the VInsts in the VBlock testing their addresses
    // and sizes.  Returns NULL if no matching VInst is found.
    VULCANDLL VInst *FindInst( ADDR );

protected:
    VBlock() {}
    ~VBlock() {}
};

class VInst : public CDListElem_VInst
{
public:
    // Create an empty instruction, you must add it to a block yourself
    static VULCANDLL VInst*  VULCANCALL Create();

    // Create an instruction that only has an opcode (eg. NOP)
    static VULCANDLL VInst*  VULCANCALL Create(EOpcodes opcode);

    // Create an instruction that has an opcode and a register (eg. PUSHD  EAX); (also use for POP EAX!)
    static VULCANDLL VInst*  VULCANCALL Create(EOpcodes opcode, ERegister source);

    // Create an instruction that has an opcode and an immediate (eg. PUSHD, 42);
    static VULCANDLL VInst*  VULCANCALL Create(EOpcodes opcode, long immediate);

    // Create an instruction that has an opcode and 2 registers (eg. MOVD, EAX, ESP);
    static VULCANDLL VInst*  VULCANCALL Create(EOpcodes opcode, ERegister dest, ERegister source);

    // Create an instruction that has an opcode, and register, and an immediate (eg. MOVD, EAX, 42);
    static VULCANDLL VInst*  VULCANCALL Create(EOpcodes opcode, ERegister dest, long immediate);

    // Create an instruction that has an opcode, and three registers (eg. ADDD, ESP, ESP, EAX);
    static VULCANDLL VInst*  VULCANCALL Create(EOpcodes opcode, ERegister dest, ERegister source1, ERegister source2);

    // Create an instruction that has an opcode, two registers, and an immediate (eg. ADDD, ESP, ESP, 4);
    static VULCANDLL VInst*  VULCANCALL Create(EOpcodes opcode, ERegister dest, ERegister source, long immediate);

    // Create an instruction that has an opcode, and a target block (eg. JMP, pblock );
    static VULCANDLL VInst*  VULCANCALL Create(EOpcodes opcode, VBlock* pBlockTarget );

    // Create an instruction that has an opcode, a destination, and an address (eg. LEA, eax, [ESP + 4] );
    static VULCANDLL VInst*  VULCANCALL Create(EOpcodes opcode, ERegister dest, const VAddress*  pAddr );

    // Create an instruction that has an opcode, a dest address (eg. PUSH, [ESP + 4] );
    static VULCANDLL VInst*  VULCANCALL Create(EOpcodes opcode, const VAddress*  pAddr );

    // Creata an instruciton that has an opcode, a dest address, and a constant (eg. MOV [pblock + offset], 1)
    static VULCANDLL VInst*  VULCANCALL Create(EOpcodes opcode, const VAddress*  pAddr, long immediate );

    // Create an instruction that has an opcode, a destination, and an address (eg. MOVD, [ESP + 4, eax );
    static VULCANDLL VInst*  VULCANCALL Create(EOpcodes opcode, const VAddress* pAddr, ERegister reg );

    // Assembles from bytes, moves ppbSrc forward to end of instruction
    static VULCANDLL VInst*  VULCANCALL Create(BYTE** ppbSrc, BYTE* pbEnd);

    // Create an instruction using 3 VOperand's
    static VULCANDLL VInst*  VULCANCALL Create(EOpcodes opcode, VOperand &dest, VOperand &src1, VOperand &src2);

    // Copy an instruction
    static VULCANDLL VInst*  VULCANCALL Create(VInst*);

    // Get the block that this instruction is in.
    VULCANDLL VBlock* ParentBlock();

    // Get the first/last/next/prev instruction in this block
    inline VInst* Next();
    inline VInst* Prev();
    inline VInst* First();
    inline VInst* Last();

    // Insert an instruction before/after this instruction
    inline void InsertPrev(VInst*);
    inline void InsertNext(VInst*);

    // remove this instruction from the block
    inline void Remove();

    // Compute the address of this instruction (block's addr + offset)
    VULCANDLL ADDR Addr();

    // Get the source info for this instruction
    VULCANDLL VSrcIter FirstSrc(VComp *pComp);

    // Fills a buffer with the printed Vulcan instruction (if the return is > than sizeBuf, the it failed)
    VULCANDLL size_t Print( char* szBuf, size_t sizeBuf );

    // Fills a buffer with the printed DISASM instruction (if the return is > than sizeBuf, the it failed)
    VULCANDLL size_t PrintAsm( char* szBuf, size_t sizeBuf, VComp * );

    // Get/set the opcode of this instruction (eg. CALL,BNE, LSL, ...)
    VULCANDLL EOpcodes Opcode();
    VULCANDLL void     SetOpcode(EOpcodes eopcode);

    // Get the string representation of this instruction
    VULCANDLL const char* OpcodeStr();

    // Get the Opcode group of this instruction (eg. GCALL,GB,GILSL)
    VULCANDLL EOpGrp OpcodeGrp();

    // Get the size of the "primary" operand (0 (NOP), 8 (MOVB), 16, 32, 64...)
    VULCANDLL size_t OpSize();

    // Get the Opcode group as a string
    VULCANDLL const char* OpcodeGroupStr();

    // How many bytes is this instruction?
    VULCANDLL size_t Size();

    // What is the target of this instruction (if call/jmp), otherwise NULL
    VULCANDLL VBlock* BlockTarget();
    VULCANDLL bool SetBlockTarget( VBlock*  );

    // Get the target proc of this block (call)
    VULCANDLL VProc* ProcTarget();
    VULCANDLL bool SetProcTarget(VProc*);

    // Get the target import of this block (indirect calls)
    VULCANDLL VImport* ImportTarget(VComp* pComp);
    VULCANDLL bool SetImportTarget(VImport*);

    // Does this instruction represent data?
    VULCANDLL bool IsData();

    // Does this instruction read memory?
    VULCANDLL bool ReadsMemory();

    // Does this instruction write memory?
    VULCANDLL bool WritesMemory();

    // Does this instruction reference an offset of ESP?
    VULCANDLL bool StackMemory();

    // Is this instruction not from the original binary?
    VULCANDLL bool IsInserted();

    //Which registers does this instruction defined/use?
    //(fNoCover == false gives AL, AH, AX, EAH, and EAX for EAX - and so forth)
    VULCANDLL void RegsDef( CBmp *pBmp, bool fNoCover = false );
    VULCANDLL void RegsUse( CBmp *pBmp, bool fNoCover = false );

    //Is this instruction valid (can it be emitted under the current arch)?
    VULCANDLL bool IsValid( VBlock *pBlk );

    // Get/set the user data for this block
    inline void SetUserData(void*, VUserData*);
    inline void* GetUserData(VUserData*);

    // To delete
    VULCANDLL void Destroy();

    // Get/Set the X86-specific prefix of this instruction
    VULCANDLL Inst::Ex86Prefix X86Prefix();
    VULCANDLL void SetX86Prefix( Inst::Ex86Prefix );

    // Get the operand as a string (this interface will change)
    VULCANDLL const char* OperandStr(Inst::EOpParam epar);

    // Get the operands to the instruction (this interface will change)
    VULCANDLL VOperand Operand(Inst::EOpParam);

    // More complex instructions - build by setting params (this interface will change)
    VULCANDLL void SetOperand( Inst::EOpParam, VOperand &op );

    // Debugging support (Print the instruction and return it)
    VULCANDLL const char * DbgPrint();

    // Access to instruction completers (currently, IA64 only)
    VULCANDLL void SetCompleter(ECompleters value);
    VULCANDLL bool TestCompleter(ECompleters value) const;

    // Access to cycle break information (IA64 only)
    VULCANDLL bool IsCycleBreak() const;
    VULCANDLL void SetCycleBreak(bool value);

    // Test for IA64 marker instruction (cannot delete/replace)
    VULCANDLL bool IsMarker() const;

protected:
    // you can't create or delete these!
    VInst() {}
    ~VInst() {}
};

enum Where {BEFORE,AFTER, PREV=BEFORE, NEXT=AFTER};

class VProto
{
public:
    // AddCall(pComp, BEFORE...) places the call before the first instruction of the entry point
    // AddCall(pComp, AFTER...) places a call before each ret of the entry proc
    virtual void __cdecl AddCall(VComp* pComp, Where w, ...) = 0;

    // AddCall(pProc, BEFORE...) places the call before the first instructions in the proc
    // AddCall(pProc, AFTER...) places a call before each ret in the proc
    virtual void __cdecl AddCall(VProc* pProc, Where w, ...) = 0;

    // AddCall(pBlk, BEFORE...) places the call before the instructions in the block
    // AddCall(pBlk, AFTER...) places the call at the last point gaurenteed to execute in the block
    virtual void __cdecl AddCall(VBlock* pBlk,Where w, ...) = 0;

    // AddCall(pInst, BEFORE...) places the call before the instruction
    // AddCall(pInst, AFTER...) places the call after the instruction (it will never execute in pInst is a RET!)
    virtual void __cdecl AddCall(VInst* pInst, Where w, ...) = 0;

// Examples  // note the last line in each example belongs in "foodll.dll"
    // Int, short, char
    // VProto* bbProto = bbProtoList.CreateProto(vcomp,"foodll.dll","SendNum(int)");
    // bbProto->AddCall(pblock,BEFORE,5);
    // extern "C" __declspec(dllexport) void SendNum(int num)
    // int[],short[],char[]
    // sprintf(szproto"SendNums(int[%d])",arraysize);  // sprintf used to create a dynamically sized array
    // VProto* bbProto = bbProtoList.CreateProto(vcomp,"foodll.dll",szproto);
    // bbProto->AddCall(pblock,BEFORE,array);  // array being a int[arraysize]
    // extern "C" __declspec(dllexport) void SendNum(int* array);   // Note it is common to send the arraysize in a different function call
    // register
    // VProto* bbProto = bbProtoList.CreateProto(vcomp,"foodll.dll","SendReg(reg)");
    // bbProto->AddCall(pblock,BEFORE,X86Reg::EAX);
    // extern "C" __declspec(dllexport) void SendReg(int regvalue)
    // Effective address or the memory location of a load/store
    // VProto* iiProto = iiProtoList.CreateProto(vcomp,"foodll.dll","SendAddr(eff)");
    // iiProto->AddCall(pinst,BEFORE,Eff::ANY);  // should only use on a memory instruction
    // extern "C" __declspec(dllexport) void SendEff(int addr)
    // BlockAddr
    // VProto* bbProto = bbProtoList.CreateProto(vcomp,"foodll.dll","SendAddr(blockaddr)");
    // bbProto->AddCall(pblk,BEFORE,VBlock);
    // extern "C" __declspec(dllexport) void SendAddr(int Addr)
    // InstAddr
    // VProto* bbProto = bbProtoList.CreateProto(vcomp,"foodll.dll","SendAddr(instaddr)");
    // bbProto->AddCall(pblk,BEFORE,VInst);
    // extern "C" __declspec(dllexport) void SendAddr(int Addr)
    // CondCode
    // VProto* bbProto = bbProtoList.CreateProto(vcomp,"foodll.dll","Sendcond(condcode)");
    // bbProto->AddCall(pblk,BEFORE,EOp::ISETULT);
    // extern "C" __declspec(dllexport) void Sendcond(int cond)  // cond is either 0 or 1

    virtual VComp* Comp() = 0;
    virtual VBlock* Export() = 0;
};

class VProtoList
{
public:
    // Create a new set of prototypes
    static VULCANDLL VProtoList * VULCANCALL CreateProtoList();

    // Create a new import that you want to call from pComp into szDll at the export named szProto
    // SzProto needs to be declared as extern "C" __declspec(dllexport) ...
    // fUseWrapper means that the registers are saved and restored around the call (so you can use them all)
    virtual VProto* CreateProto( VComp* pComp, const char* szDll, const char* szProto, bool fUseWrapper = true) = 0;

    // Commit the protos that were created from this list
    // The order is COMP, then Proc, then Block, then Inst.
    // Within each group, the order is the order AddCall was called.
    virtual void Commit() = 0;

    // Uncommit the protos that were cread from this list
    virtual void Revert() = 0;

    //To Delete
    virtual void Destroy() = 0;
};

#include "vulcan.inl"

//backward compatibility
typedef VBlock VBBlock;

// This should only ever be called after all other Vulcan objects have been deallocated
// This will go through and clean up all outstanding allocations, and will return the memory
// usage back to that before any Vulcan calls were made.
VULCANDLL void VULCANCALL VulcanCleanUpAllAllocations(void);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\Vulcan\inc\vulcanbmp.h ===
/***********************************************************************
* Microsoft Vulcan
*
* Microsoft Confidential.  Copyright 1994-2000 Microsoft Corporation.
*
* Component:
*
* File: vulcanbmp.h
*
* File Comments:
*
*
***********************************************************************/

#ifndef __CBmp__
#define __CBmp__

class VULCANDLL CBmp
{
public:
	    CBmp();
        CBmp(size_t, bool = false);
	    ~CBmp();

   // Allocate() initializes the bitmap with the given size.  Bit indices range
   // from 0 to this limit minus one.  If the bitmap can't be initialized,
   // this method throws an exception.	The initial value of each bit is specified
   // by the second parameter.

	    void Allocate(size_t, bool = false);

   // Attach() binds this CBmp to a previously allocated block of memory.

	    void Attach(void *, size_t);

   // CbFromCbit() returns the number of bytes needed to an attached bitmap of a
   // given size.

   static   size_t VULCANCALL CbFromCbit(size_t);

   // CbitSet() returns the number of bits set in the bitmap.

	    size_t CbitSet() const;

   // UNDONE: Comment FAttached()

	    bool FAttached() const { return(m_fAttached); };

   // FTest() returns true if the specified bit is set and false otherwise.
   // It is invalid to call this methods with a bit index beyond the limit
   // given to FInit().

	    bool FTest(size_t) const;

   // FTestAndReset() returns true if the specified bit is set and false
   // otherwise.  The bit is then unconditionally reset.  It is invalid to call
   // this method with a bit index beyond the limit given to FInit().

	    bool FTestAndReset(size_t);

   // FTestAndSet() returns true if the specified bit is set and false
   // otherwise.  The bit is then unconditionally set.	It is invalid to call
   // this method with a bit index beyond the limit given to FInit().

	    bool FTestAndSet(size_t);

   // IbitNextSet() returns the bit number of the first bit set following
   // the specified bit.  If there are no more bits set, the method returns
   // ibitNil.

	    size_t IbitNextSet(size_t) const;

   // IbitNextSet() returns the bit number of the first bit set following
   // the specified bit up to the specified upper bound.  If there are no
   // more bits set, the method returns ibitNil.

	    size_t IbitNextSet(size_t, size_t) const;

   // IbitNextSet() returns the bit number of the first bit set in both
   // bitmaps following the specified bit.  If there are no more bits set,
   // the method returns ibitNil.  It is invalid to call this function
   // unless both bitmaps are initialized to the same size.

   static   size_t VULCANCALL IbitNextSet(size_t, const CBmp&, const CBmp&);

   // IbitPrevSet() returns the bit number of the first bit set prior to
   // the specified bit.  If there are no more bits set, the method returns
   // ibitNil.

	    size_t IbitPrevSet(size_t) const;

   // ReInitialize() the entire bitmap.  After this method is done, the bitmap
   // is reinitialized to its initial state, as in after a call to Allocate().

	    void ReInitialize();

   // Release() releases the memory allocated in Allocate() for the bitmap.  If the
   // bitmap was attached via Attach(), the connection is released.

	    void Release();

   // Reset() clears the specified bit in the bitmap.  It is invalid to
   // call this method with a bit index beyond the limit given to FInit().

	    void Reset(size_t);

   // Set() sets the specified bit in the bitmap.  It is invalid to
   // call this method with a bit index beyond the limit given to FInit().

	    void Set(size_t);


  // Used for dataflow
            size_t CntBits()  {return m_cbit;}
            void   SetAll(bool);
            void   And(CBmp*);
            void   And(CBmp*, CBmp*);
            void   Or(CBmp*);
            void   Or(CBmp*, CBmp*);
            void   Xor(CBmp*);
            void   Xor(CBmp*, CBmp*);
            void   Minus(CBmp*);
            void   Minus(CBmp*, CBmp*);
            void   Copy(CBmp*);
            bool   Equal(CBmp*);
            void   PrintBmp();

private:
	    size_t m_cbit;
	    size_t m_cdw;
	    DWORD  m_dwInit;
	    bool m_fAttached;
	    DWORD* m_rgdw;

   static   size_t IdwFromIbit(size_t ibit) { return(ibit >> 5); };
   static   DWORD DwMaskFromIbit(size_t ibit) { return(1UL << (ibit & 0x1f)); };
};


const size_t ibitNil = (size_t) -1;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\vctools\pdb6\langapi\include\verstamp.h ===
#ifndef _VERSION_H_INCL
#include "version.h"                   /* SLM maintained version file */
#endif
#include "bld_version.h"               /* User maintained build version */

#if defined(_WIN32) || defined(WIN32)
#include <winver.h>
#else   /* !WIN32 */
#include <ver.h>
#endif  /* !WIN32 */

#if     (rmm < 10)
#define rmmpad "0"
#else
#define rmmpad
#endif

#define VERSION_STR1(a,b,c,d)       #a "." rmmpad #b "." ruppad #c "." #d

#if     (rup < 10)
#define ruppad "000"
#elif   (rup < 100)
#define ruppad "00"
#elif   (rup < 1000)
#define ruppad "0"
#else
#define ruppad
#endif

#define VERSION_STR2(a,b,c,d)       VERSION_STR1(a,b,c,d)
#define VER_PRODUCTVERSION_STR      VERSION_STR2(rmj,rmm,rup,rbld)
#define VER_PRODUCTVERSION          rmj,rmm,rup,rbld

/*--------------------------------------------------------------*/
/* the following section defines values used in the version     */
/* data structure for all files, and which do not change.       */
/*--------------------------------------------------------------*/

#if defined(_SHIP)
#define VER_DEBUG                   0
#else
#define VER_DEBUG                   VS_FF_DEBUG
#endif

#if defined(_SHIP)
#define VER_PRIVATEBUILD            0
#else
#define VER_PRIVATEBUILD            VS_FF_PRIVATEBUILD
#endif

#if defined(_SHIP)
#define VER_PRERELEASE              0
#else
#define VER_PRERELEASE              VS_FF_PRERELEASE
#endif

#define VER_FILEFLAGSMASK           VS_FFI_FILEFLAGSMASK
#if defined(_WIN32) || defined(WIN32)
#define VER_FILEOS                  VOS__WINDOWS32
#else
#define VER_FILEOS                  VOS_DOS_WINDOWS16
#endif
#define VER_FILEFLAGS               (VER_PRIVATEBUILD|VER_PRERELEASE|VER_DEBUG)

#define VER_COMPANYNAME_STR         "Microsoft Corporation"
#define VER_PRODUCTNAME_STR         "Microsoft (R) Visual Studio"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\Vulcan\inc\vulcanbuf.h ===
/***********************************************************************
* Microsoft Vulcan
*
* Microsoft Confidential.  Copyright 1997-1999 Microsoft Corporation.
*
* File: vulcanbuf.h
*
* File Comments:
*
*
***********************************************************************/

#ifndef __VBUF__
#define __VBUF__

#define STRICT
#define WIN32_LEAN_AND_MEAN
#include "windows.h"

typedef void  (__cdecl *VBUF_FP)();

void VULCANCALL VBuf_VPro(LPVOID addr)
{
    DWORD temp;

    VirtualProtect(addr, 4 , PAGE_EXECUTE_READWRITE, &temp);
}


#define WIN9X_TLS 0x2c
int TLS_CONST = ((GetVersion() & 0x80000000) == 0)?0xe10:0;
int VBUF_ISWINNT = ((GetVersion() & 0x80000000) == 0)?1:0;

#define VBuf_MOVEARG1 \
        __asm mov eax,[esp+20+4*0]\
        __asm mov [ebx+4*0],eax\

#define VBuf_MOVEARG2 \
        VBuf_MOVEARG1 \
        __asm mov eax,[esp+20+4*1]\
        __asm mov [ebx+4*1],eax\

#define VBuf_MOVEARG3 \
        VBuf_MOVEARG2 \
        __asm mov eax,[esp+20+4*2]\
        __asm mov [ebx+4*2],eax\

#define VBuf_MOVEARG4 \
        VBuf_MOVEARG3 \
        __asm mov eax,[esp+20+4*3]\
        __asm mov [ebx+4*3],eax\

#define VBuf_MOVEARG5 \
        VBuf_MOVEARG4 \
        __asm mov eax,[esp+20+4*4]\
        __asm mov [ebx+4*4],eax\


//  This #define creates 3 functions.  Function NAME is a stub which will
//  change the import of the caller to either the winnt or win9x function.
//  The other two functions basically pull the arguments off the stack
//  and place them in a buffer.  When the buffer is full it calls flush.
//  For optimization reason this was written in asm.  Mainly to avoid using pushfd.
//  This prevents any instruction from touching the flags register in the general case.
//  For Instance LEAs are used instead of ADD instructions.



#define VBUFMT(NAME,RTNAME,NUMARGS,BUFSIZE) \
int NAME##VBuf_SlotIndex = TlsAlloc();\
int NAME##VBuf_SlotData = TlsAlloc();\
int NAME##VBuf_SLOTINDEX = NAME##VBuf_SlotIndex * 4 + TLS_CONST;\
int NAME##VBuf_SLOTDATA  = NAME##VBuf_SlotData  * 4 + TLS_CONST;\
extern "C" void NAME##_VBuf_Flush() {\
        DWORD dw = GetLastError();\
        if (TlsGetValue(NAME##VBuf_SlotData)) {\
            RTNAME(TlsGetValue(NAME##VBuf_SlotData),(void*)(BUFSIZE-((int)TlsGetValue(NAME##VBuf_SlotIndex))/(4*NUMARGS) ));\
        } else {\
            void* foo = (void*)new int[NUMARGS*BUFSIZE*4]; \
            TlsSetValue( NAME##VBuf_SlotData,foo );\
        }\
        TlsSetValue(NAME##VBuf_SlotIndex,(void*)(BUFSIZE*NUMARGS*4));\
        SetLastError(dw);\
}\
extern "C" __declspec(dllexport) __declspec(naked) void NAME##WINNT() {\
    __asm {\
        __asm push edx\
        __asm push ecx\
        __asm push ebx\
        __asm push eax\
        __asm mov edx,[NAME##VBuf_SLOTINDEX]\
        __asm mov ecx,fs:[edx]\
        __asm jecxz flush\
    __asm copyargs:  \
        __asm mov eax,[NAME##VBuf_SLOTDATA]\
        __asm mov ebx,fs:[eax]\
\
        __asm lea eax,[ecx-(BUFSIZE*NUMARGS*4)]\
        __asm not eax\
        __asm lea eax,[eax+1]\
        __asm lea ebx,[ebx+eax]\
\
        VBuf_MOVEARG##NUMARGS \
\
        __asm lea ecx,[ecx+(-NUMARGS*4)]\
        __asm mov fs:[edx],ecx\
\
        __asm pop eax\
        __asm pop ebx\
        __asm pop ecx\
        __asm pop edx\
        __asm ret\
    __asm flush: \
        __asm pushad\
        __asm pushfd\
        __asm cld\
        __asm call NAME##_VBuf_Flush\
        __asm popfd\
        __asm popad\
        __asm mov ecx,[NAME##VBuf_SLOTINDEX]\
        __asm mov ecx,fs:[ecx]\
        __asm jmp copyargs\
    }\
}\
extern "C" __declspec(dllexport) __declspec(naked) void NAME##WIN9X() {\
    __asm {\
        __asm push edx\
        __asm push ecx\
        __asm push ebx\
        __asm push eax\
        __asm mov edx,[NAME##VBuf_SLOTINDEX]\
        __asm mov ecx,fs:[WIN9X_TLS]\
        __asm lea ecx,[ecx+edx]\
        __asm mov ecx,[ecx]\
        __asm jecxz flush\
    __asm copyargs:  \
        __asm mov eax,[NAME##VBuf_SLOTDATA]\
        __asm mov ebx,fs:[WIN9X_TLS]\
        __asm lea ebx,[ebx+eax]\
        __asm mov ebx,[ebx]\
\
        __asm lea eax,[ecx-(BUFSIZE*NUMARGS*4)]\
        __asm not eax\
        __asm lea eax,[eax+1]\
        __asm lea ebx,[ebx+eax]\
\
        VBuf_MOVEARG##NUMARGS \
\
        __asm lea ecx,[ecx+(-NUMARGS*4)]\
        __asm mov ebx,fs:[WIN9X_TLS]\
        __asm lea edx,[ebx+edx]\
        __asm mov [edx],ecx\
\
        __asm pop eax\
        __asm pop ebx\
        __asm pop ecx\
        __asm pop edx\
        __asm ret\
    __asm flush: \
        __asm pushad\
        __asm pushfd\
        __asm cld\
        __asm call NAME##_VBuf_Flush\
        __asm popfd\
        __asm popad\
        __asm mov edx,[NAME##VBuf_SLOTINDEX]\
        __asm mov ecx,fs:[WIN9X_TLS]\
        __asm lea ecx,[ecx+edx]\
        __asm mov ecx,[ecx]\
        __asm jmp copyargs\
    }\
}\
VBUF_FP NAME##_VBUF_WINNT = NAME##WINNT;\
VBUF_FP NAME##_VBUF_WIN9X = NAME##WIN9X;\
extern "C" __declspec(dllexport) __declspec(naked) void NAME() {\
    __asm {\
        __asm push eax\
        __asm mov eax,[esp+4]\
        __asm lea eax,[eax-4]\
        __asm mov eax,[eax]\
        __asm pushad\
        __asm pushfd\
        __asm push eax\
        __asm push eax\
        __asm call VBuf_VPro\
        __asm pop eax\
        __asm mov ecx,[VBUF_ISWINNT]\
        __asm mov ebx,[NAME##_VBUF_WIN9X]\
        __asm jecxz iswin9x\
        __asm mov ebx,[NAME##_VBUF_WINNT]\
        __asm mov [eax],ebx\
        __asm popfd\
        __asm popad\
        __asm pop eax\
        __asm jmp [NAME##_VBUF_WINNT]\
    __asm iswin9x:\
        __asm mov [eax],ebx\
        __asm popfd\
        __asm popad\
        __asm pop eax\
        __asm jmp [NAME##_VBUF_WIN9X]\
    }\
}\

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\Vulcan\inc\vulcancmdline.h ===
/***********************************************************************
* Microsoft Vulcan
*
* Microsoft Confidential.  Copyright 1994-1999 Microsoft Corporation.
*
* Component:
*
* File: vulcancmdline.h
*
* File Comments:
*
*
***********************************************************************/

#pragma once

class VULCANDLL CMDLINE
{
public:

	    enum ARGT { argtNil, argtHelp, argtInt, argtString, argtOptString, argtEnd };

	    struct OPTDEF
	    {
	       // The following is statically initialized

	       ARGT  argt;			// Argument type
	       const char *szOptName;		// String for option name
	       bool  fOptRequired;		// Is option required?
	       void  *pv;			// Where to store argument
	       bool  *pfSpecified;		// Is option specified?
	    };

   static   void VULCANCALL DisplayBanner(const char *);
   static   bool VULCANCALL FProcessArgs(const char *, int, const char *[], const OPTDEF *);
   static   bool VULCANCALL FSamePath(const char *, const char *);

private:

   static   const OPTDEF *PoptdefLookup(const OPTDEF *, const char *);
   static   bool FParseValue(const OPTDEF *, const char *);
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\Vulcan\inc\vulcancmdfile.h ===
/***********************************************************************
* Microsoft Vulcan
*
* Microsoft Confidential.  Copyright 1994-1999 Microsoft Corporation.
*
* Component:
*
* File: vulcancmdfile.h
*
* File Comments:
*
*
***********************************************************************/

#pragma once

class VULCANDLL SZDICTIONARY
{
public:
   SZDICTIONARY(const char * const *);
   ~SZDICTIONARY();

   const char *Find(const char *sz) const;

private:
   static int __cdecl cmpsz(const void *, const void *);

   const char **m_rgsz;
   size_t       m_csz;
};


class VULCANDLL CMDFILE
{
public:
            typedef void (CMDFILE::*PFNCMD)(unsigned, const char *);

            enum CMDT { cmdtNil, cmdtLine, cmdtRptExist, cmdtEnd };

            struct CMDDEF
            {
               CMDT m_cmdt;
               char *m_szCmdName;
               PFNCMD m_pfncmd;
            };

            void ProcessFile(const char *, const CMDDEF *, SZDICTIONARY * = NULL);

private:
   static   const CMDDEF *PcmddefLookup(const CMDDEF *, const char *);
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\Vulcan\inc\vulcan.inl ===
/***********************************************************************
* Microsoft Vulcan
*
* Microsoft Confidential.  Copyright 1997-2000 Microsoft Corporation.
*
* File: vulcan.inl
*
* File Comments:
*
*
***********************************************************************/

#pragma warning(push)
#pragma warning(disable:4097)

//  VSrcIter inlines
VSrcIter::VSrcIter()
{
    m_pSrcCur = NULL;
}

VSrcIter::VSrcIter( VSrcIter &v) 
{
    m_pSrcCur = v.m_pSrcCur; 
    m_cSrcAfter = v.m_cSrcAfter; 
    m_cSrcBefore = v.m_cSrcBefore; 
}

VSrcInfo *VSrcIter::Curr() const     
{
    return m_pSrcCur;
}

bool VSrcIter::Done() const     
{
    return IsEmpty() || 
           m_cSrcAfter < 0   || 
           m_cSrcBefore < 0;
}

bool VSrcIter::IsEmpty() const  
{
   return  (m_cSrcAfter < 0 && m_cSrcBefore <= 0) ||
           (m_cSrcAfter <= 0 && m_cSrcBefore < 0) ||
           (m_cSrcAfter == 0 && m_cSrcBefore == 0 && (Curr() == NULL || (Curr()->FileName() == NULL)));

}

size_t VSrcIter::Length() const   
{
    return IsEmpty() ? 0 : 1 + m_cSrcAfter + m_cSrcBefore;
}
    
// VProg inlines
void VProg::SetUserData(void *pvData, VUserData *pDataStore)
{
    pDataStore->SetUserData(pvData, this);
}

void *VProg::GetUserData(VUserData *pDataStore)
{
    return pDataStore->GetUserData(this);
}

// VComp inlines
void VComp::SetUserData(void *pvData, VUserData *pDataStore)
{
    pDataStore->SetUserData(pvData, this);
}

void *VComp::GetUserData(VUserData *pDataStore)
{
    return pDataStore->GetUserData(this);
}

// VSect inlines

// VProc inlines


void VProc::SetUserData(void *pvData, VUserData *pDataStore)
{
    pDataStore->SetUserData(pvData, this);
}

void *VProc::GetUserData(VUserData *pDataStore)
{
    return pDataStore->GetUserData(this);
}

inline bool SkipAllButCodeBlks(void *p)
{
   VBlock *pBlk = (VBlock *) p;
   return ((NULL == pBlk) ||
           pBlk->IsDataBlock() ||
           pBlk->IsUnreachable());
}

inline bool SkipAllButDataBlks(void *p)
{
   VBlock *pBlk = (VBlock *) p;
   return (!pBlk->IsDataBlock());
}

inline bool SkipAllButDeadBlks(void *p)
{
   VBlock *pBlk = (VBlock *) p;
   return (!pBlk->IsUnreachable());
}

VBlock *VBlock::Next()
{
    VBlock *pBlk = this;
    
    do
    {
        pBlk = ((CDListElem_VBlock *)pBlk)->Next();
    }
    while (pBlk && SkipAllButCodeBlks(pBlk));

    return pBlk;
}

VBlock *VBlock::Prev()
{
    VBlock *pBlk = this;
    
    do
    {
        pBlk = ((CDListElem_VBlock *)pBlk)->Prev();
    }
    while (pBlk && SkipAllButCodeBlks(pBlk));

    return pBlk;
}

VBlock *VBlock::First()
{
    VBlock *pBlk = CDListElem_VBlock::First();

    if (pBlk && SkipAllButCodeBlks(pBlk))
    {
        pBlk = pBlk->Next();
    }

    return pBlk;
}

VBlock *VBlock::Last()
{
    VBlock *pBlk = CDListElem_VBlock::Last();

    if (pBlk && SkipAllButCodeBlks(pBlk))
    {
        pBlk = pBlk->Prev();
    }

    return pBlk;
}

VBlock *VBlock::NextAll()
{
    return CDListElem_VBlock::Next();
}

VBlock *VBlock::PrevAll()
{
    return CDListElem_VBlock::Prev();
}

VBlock *VBlock::FirstAll()
{
    return CDListElem_VBlock::First();
}

VBlock *VBlock::LastAll()
{
    return CDListElem_VBlock::Last();
}

void VBlock::InsertNext(VBlock *p)
{
    CDListElem_VBlock::InsertNext(p);
}

void VBlock::InsertPrev(VBlock *p)
{
    CDListElem_VBlock::InsertPrev(p);
}

void VBlock::Remove()
{
    CDListElem_VBlock::Remove();
}

void VBlock::SetUserData(void *pvData, VUserData *pDataStore)
{
    pDataStore->SetUserData(pvData, this);
}

void *VBlock::GetUserData(VUserData *pDataStore)
{
    return pDataStore->GetUserData(this);
}

VInst *VInst::Next()
{
    return (VInst *) CDListElem_VInst::Next();
}

VInst *VInst::Prev()
{
    return (VInst *) CDListElem_VInst::Prev();
}

VInst *VInst::First()
{
    return (VInst *) CDListElem_VInst::First();
}

VInst *VInst::Last()
{
    return (VInst *) CDListElem_VInst::Last();
}

void VInst::InsertNext(VInst *p)
{
    CDListElem_VInst::InsertNext(p);
}

void VInst::InsertPrev(VInst *p)
{
    CDListElem_VInst::InsertPrev(p);
}

void VInst::Remove()
{
    CDListElem_VInst::Remove();
}

void VInst::SetUserData(void *pvData, VUserData *pDataStore)
{
    pDataStore->SetUserData(pvData, this);
}

void *VInst::GetUserData(VUserData *pDataStore)
{
    return pDataStore->GetUserData(this);
}

VExport *VExport::Prev()
{
    return CDListElem_VExport::Prev();
}

VExport *VExport::Next()
{
    return CDListElem_VExport::Next();
}

VExport *VExport::First()
{
    return CDListElem_VExport::First();
}

VExport *VExport::Last()
{
    return CDListElem_VExport::Last();
}

VExport *VExport::NextProc()
{
    VBlock *pBlk = Block();
    
    VExport *pNext = Next();
    while (pNext && (pNext->Block() != pBlk))
    {
        pNext = pNext->Next();
    }

    return pNext;
}

VExport *VExport::PrevProc()
{
    VBlock *pBlk = Block();
    
    VExport *pPrev = Prev();
    while (pPrev && (pPrev->Block() != pBlk))
    {
        pPrev = pPrev->Prev();
    }

    return pPrev;
}

VExport *VExport::FirstProc()
{
    VExport *pPrev = PrevProc();

    if (pPrev)
    {
        while (pPrev->PrevProc())
        {
            pPrev = pPrev->PrevProc();
        }

        return pPrev;
    }

    return this;
}

VExport *VExport::LastProc()
{
    VExport *pNext = NextProc();

    if (pNext)
    {
        while (pNext->NextProc())
        {
            pNext = pNext->NextProc();
        }

        return pNext;
    }

    return this;
}

VImport *VImport::Next()
{
    return CDListElem_VImport::Next();
}

VImport *VImport::Prev()
{
    return CDListElem_VImport::Prev();
}

VImport *VImport::First()
{
    return CDListElem_VImport::First();
}

VImport *VImport::Last()
{
    return CDListElem_VImport::Last();
}

VOperand::VOperand()                      
{
   m_operand = NULL;
   m_type = OpndNotUsed;
}

VOperand::VOperand(VOperand &v)
{
   m_operand = v.m_operand; 
   m_type = v.m_type;
}

VOperand::VOperand(BYTE *pb)
{
   m_operand = (void *) pb; 
   m_type = OpndData;
}


VOperand::VOperand(ERegister reg)
{
#if     (_MSC_VER > 1200)
   m_operand = (void *) reg;
#else   // !(_MSC_VER > 1200)
   m_operand = (void *) reg;
#endif  // !(_MSC_VER > 1200)
   m_type = OpndReg;
}

VOperand::VOperand(VAddress *pAddr)
{
   m_operand = (void *) pAddr;
   m_type = OpndAddress;
}

VOperand::VOperand(long immed)
{
#if     (_MSC_VER > 1200)
   m_operand = (void *) (size_t) immed;
#else   // !(_MSC_VER > 1200)
   m_operand = (void *) immed;
#endif  // !(_MSC_VER > 1200)
   m_type = OpndImmediate;
}

VOperand::VOperand(VBlock *pBlk)
{
   m_operand = (void *) pBlk;
   m_type = OpndBlock;
}

VOperand::VOperand(VBlock *pBlk, long offset)
{
   m_operand = CreateGA(pBlk, offset);  
   m_type = OpndGenAddressBlock;
}

VOperand::VOperand(VInst *pInst)
{
   m_operand = CreateGA(pInst);  
   m_type = OpndGenAddressBlock;
}

EOpndTypes VOperand::Type() 
{
   return m_type;
}

ERegister VOperand::Register()  
{
    if (m_type == OpndReg || m_type == OpndRegPair)
    {
#if     (_MSC_VER > 1200)
        return (ERegister) (size_t) m_operand;
#else   // !(_MSC_VER > 1200)
        return (ERegister) (int) m_operand;
#endif  // !(_MSC_VER > 1200)
    }

    return X86Register::ZERO;
}  
    
const VAddress *VOperand::Address()   
{
    if (m_type == OpndAddress)
    {
        return (const VAddress *) m_operand;
    }

    return NULL;
}
 
long VOperand::Immediate() 
{
   if (Type() == OpndImmediate) 
   {
#if     (_MSC_VER > 1200)
      return (long) (size_t) m_operand;
#else   // !(_MSC_VER > 1200)
      return (long) m_operand;
#endif  // !(_MSC_VER > 1200)
   }

   if (Type() == OpndGenAddressBlock)
   {
      return ImmediateGA(m_operand);
   }

   if (Type() == OpndAddress)
   {
      return Address()->Offset();
   }

   return 0;
}

VBlock *VOperand::Block()     
{
   if (Type() == OpndBlock) 
   {
      return (VBlock *) m_operand;
   }

   if (Type() == OpndGenAddressBlock)
   {
      return BlockGA(m_operand);
   }

   if (Type() == OpndAddress)
   {
      return Address()->Block();
   }

   return NULL;
}

inline VInst * VOperand::Inst()
{
   if (Type() == OpndGenAddressBlock)
   {
      return InstGA(m_operand);
   }

   return NULL;
}


void *VOperand::Anything()
{
   return m_operand;
}

bool VOperand::SetBlock( VBlock *pBlk )
{
    switch (Type())
    {
        case OpndImmediate:
            if (pBlk && Immediate())
            {
                // must convert to OpndGenAddressBlock
                m_operand = CreateGA(pBlk, Immediate());  
                m_type = OpndGenAddressBlock;
                return true;
            }
            else if (pBlk)
            {
                m_operand = (void *)pBlk;
                m_type = OpndBlock;
                return true;
            }
            else
            {
                return false;
            }

        case OpndAddress:
            {
                // Oops, this results in a small memory leak... don't do it alot
                VAddress *pAddr = VAddress::Create( Address() );
                pAddr->SetBlock( pBlk );
                m_operand = (void *) pAddr;
                return true;
            }

        case OpndBlock:
            if (pBlk)
            {
                // switch it
                m_operand = (void *)pBlk;
            }
            else
            {
                // immediate of 0
                m_operand = 0;
                m_type = OpndImmediate;
            }
            return true;

        case OpndGenAddressBlock:
            if (pBlk)
            {
                // switch it
                m_operand = CreateGA( pBlk, Immediate());
            }
            else
            {
                // immediate
                m_operand = (void *)(size_t)Immediate();
                m_type = OpndImmediate;
            }
            return true;
    }

    return false;
}

bool VOperand::SetImmediate( long imm )
{
    switch (Type())
    {
        case OpndImmediate:
            // must convert to OpndGenAddressBlock
            m_operand = (void *)(size_t)imm; 
            return true;

        case OpndAddress:
            {
                // Oops, this results in a small memory leak... don't do it alot
                VAddress *pAddr = VAddress::Create( Address() );
                pAddr->SetOffset( imm );
                m_operand = (void *) pAddr;
            }
            return true;

        case OpndBlock:
            if (imm)
            {
                // switch it
                m_operand = CreateGA( Block(), imm );
                m_type = OpndGenAddressBlock;
            }
            return true;

        case OpndGenAddressBlock:
            if (imm)
            {
                // switch it
                m_operand = CreateGA( Block(), imm);
                m_type = OpndGenAddressBlock;
            }
            else
            {
                // immediate
                m_operand = (void *)Block();
                m_type = OpndBlock;
            }
            return true;
    }

    return false;
}

bool VOperand::SetInst( VInst * pInst )
{
    switch (Type())
    {
        case OpndAddress:
            {
                // Oops, this results in a small memory leak... don't do it alot
                VAddress *pAddr = VAddress::Create( Address() );
                pAddr->SetInst( pInst );
                m_operand = (void *) pAddr;
            }
            return true;

        case OpndImmediate:
        case OpndBlock:
        case OpndGenAddressBlock:
            // Inst is always a GA from these guys
            m_operand = CreateGA( pInst );
            m_type = OpndGenAddressBlock;
            return true;
    }

    return false;
}

#pragma warning(pop)


#if     defined(VULCANDLL__)    //  Building the Vulcan DLL
#pragma warning(disable: 4786)        // 255 size identifier.  A template nightmare
#pragma warning(disable: 4514)        // unreferenced inline function has been removed
#pragma warning(disable: 4710)        // Function not expanded
#elif   defined(VULCANI__)      //  Building the static Vulcan lib
#pragma warning(disable: 4786)        // 255 size identifier.  A template nightmare
#pragma warning(disable: 4514)        // unreferenced inline function has been removed
#pragma warning(disable: 4710)        // Function not expanded
#endif

//These are required for those internal-external components
#pragma warning(disable: 4275)        // non dll-interface class
#pragma warning(disable: 4251)        // Needs DLL interface
#pragma warning(disable: 4239)        // Non standard extension used
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\Vulcan\inc\vulcandlist.h ===
/***********************************************************************
* Microsoft Vulcan
*
* Microsoft Confidential.  Copyright 1997-1999 Microsoft Corporation.
*
* Component:
*
* File: vulcandlist.h
*
* File Comments:
*
*
***********************************************************************/

#ifndef __DList_H__
#define __DList_H__

#include "vulcanpa.h"   

#define VIRTUALPAD
///////////////////////Normal DList////////////////////////

#define PADDING(x) 
#include "vulcandlisttemplate.h"
#undef PADDING

///////////////////////Padded DList////////////////////////
#define CDList2     CDList_PA
#define CDList2Iter CDList_PA_Iter
#define CDList2Elem CDList_PA_Elem

#define PADDING(x) CPAD(x);
#include "vulcandlisttemplate.h"
#undef PADDING

#undef CDList2
#undef CDList2Iter
#undef CDList2Elem

///////////////////////Padded DList (VTable complient)/////
#define CDList2     CDList_VPA
#define CDList2Iter CDList_VPA_Iter
#define CDList2Elem CDList_VPA_Elem

#undef VIRTUALPAD
#define VIRTUALPAD   CPAD(v);
#define PADDING(x)   CPAD(x);
#include "vulcandlisttemplate.h"
#undef PADDING

#undef CDList2
#undef CDList2Iter
#undef CDList2Elem

///////////////////////DList TYPEDEFS /////////////////////
class CBBlock;
typedef CDList_PA_Elem<CBBlock*> CDListElem_CBBlock;
typedef CDList_PA<CBBlock*> CDList_CBBlock;
typedef CDList_PA_Iter<CBBlock*> CDListIter_CBBlock;
class VImport;
typedef CDList2Elem<VImport*> CDListElem_VImport;
typedef CDList2<VImport*> CDList_VImport;
typedef CDList2Iter<VImport*> CDListIter_VImport;
class VBlock;
typedef CDList_PA_Elem<VBlock*> CDListElem_VBlock;
typedef CDList_PA<VBlock*> CDList_VBlock;
typedef CDList_PA_Iter<VBlock*> CDListIter_VBlock;

typedef CDList_PA_Elem<VBlock*> CDListElem_VBBlock;
typedef CDList_PA<VBlock*> CDList_VBBlock;
typedef CDList_PA_Iter<VBlock*> CDListIter_VBBlock;
class CProtoList;
typedef CDList2Elem<CProtoList*> CDListElem_CProtoList;
typedef CDList2<CProtoList*> CDList_CProtoList;
typedef CDList2Iter<CProtoList*> CDListIter_CProtoList;
class IDFFile;
typedef CDList2Elem<IDFFile*> CDListElem_IDFFile;
typedef CDList2<IDFFile*> CDList_IDFFile;
typedef CDList2Iter<IDFFile*> CDListIter_IDFFile;
class INLINE_EDGE;
typedef CDList2Elem<INLINE_EDGE*> CDListElem_INLINE_EDGE;
typedef CDList2<INLINE_EDGE*> CDList_INLINE_EDGE;
typedef CDList2Iter<INLINE_EDGE*> CDListIter_INLINE_EDGE;
struct HISTORY_ListNode;
typedef CDList2Elem<HISTORY_ListNode*> CDListElem_HISTORY_ListNode;
typedef CDList2<HISTORY_ListNode*> CDList_HISTORY_ListNode;
typedef CDList2Iter<HISTORY_ListNode*> CDListIter_HISTORY_ListNode;
class VInst;
typedef CDList_PA_Elem<VInst*> CDListElem_VInst;
typedef CDList_PA<VInst*> CDList_VInst;
typedef CDList_PA_Iter<VInst*> CDListIter_VInst;
class VSect;
typedef CDList2Elem<VSect*> CDListElem_VSect;
typedef CDList2<VSect*> CDList_VSect;
typedef CDList2Iter<VSect*> CDListIter_VSect;
class VComp;
typedef CDList2Elem<VComp*> CDListElem_VComp;
typedef CDList2<VComp*> CDList_VComp;
typedef CDList2Iter<VComp*> CDListIter_VComp;
class VProg;
typedef CDList2Elem<VProg*> CDListElem_VProg;
typedef CDList2<VProg*> CDList_VProg;
typedef CDList2Iter<VProg*> CDListIter_VProg;
class VExport;
typedef CDList2Elem<VExport*> CDListElem_VExport;
typedef CDList2<VExport*> CDList_VExport;
typedef CDList2Iter<VExport*> CDListIter_VExport;
class VProc;
typedef CDList_VPA_Elem<VProc*> CDListElem_VProc;
typedef CDList_VPA<VProc*> CDList_VProc;
typedef CDList_VPA_Iter<VProc*> CDListIter_VProc;
class VSymbol;
typedef CDList2Elem<VSymbol*> CDListElem_VSymbol;
typedef CDList2<VSymbol*> CDList_VSymbol;
typedef CDList2Iter<VSymbol*> CDListIter_VSymbol;


#undef INLINE_DLIST
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\Vulcan\inc\vulcanienum.h ===
/***********************************************************************
* Microsoft  Vulcan
*
* Microsoft Confidential.  Copyright 1997-1999 Microsoft Corporation.
*
* File: VulcanIEnum.h
*
* File Comments:
*
*
***********************************************************************/

#ifndef __VULCANIENUM__
#define __VULCANIENUM__

enum OpenFlags
{
   // Print internal statistics.  This is intended primarily for debugging
   // purposes, or for getting some interesting information about what
   // just happened.  !!!DO NOT DEPEND ON THE OUTPUT FORMAT!!! as it may
   // change from drop to drop.
   //
   Open_PrintStats      = 0x00000001,

   // Only disassemble blocks into their component instructions as
   // necessary.  Accessing any instruction, or any information from the
   // instruction list (including VBlock::CountInsts) will likely cause a
   // disassembly.
   //
   // Several internal data structures are kept throughout the lifetime of
   // the VComp in order to handle the delayed disassembly.  These
   // structures will be significantly smaller than the size of all the
   // VInsts, but if you are going to cause all blocks to be disassembled
   // anyhow this option could actually result in decreased performance.
   //
   // When you are finished manipulating a block, call
   // VBlock::ReleaseSymbolic on it.  This may cause the storage allocated
   // to the block's VInsts to be released, depending on what you have
   // done with the block.
   //
   // WARNING: Errata42 checking cannot currently be performed at
   // VComp::Write time when this is enabled, and will be silently
   // skipped.  We will eventually fix that limitation, but for now you
   // should not enable compact blocks if you are producing final
   // customer-ready bits.
   //
   Open_CompactBlocks   = 0x00000002,

   // Ignore missing CV info.  Please note that this is handy for
   // experimental purposes but is not safe in a production environment.
   // Please use this with care.
   //
   Open_IgnoreCvError   = 0x00000004,

   // Open all dlls that we can find from this program.  Used by
   // VProg::Open; ignored by VComp::Open.
   //
   Open_DoDllClosure    = 0x00000008,

   // For use only by BBT.  Don't try this at home.
   //
   Open_BBTMode         = 0x00000010,

   // Opens the image with full PDB info. This is the default level.
   // This level allows full binary modification, which can be emitted.
   //
   Open_FullLevel       = 0x00000000,

   // Opens the image, ignoring any PDB info. Use this if you only want to
   // redirect an import or export.
   // This level only allows redirection modifications to be emitted.
   //
   Open_Level1          = 0x00000020,

   // Opens the image, using minimal PDB info. Usage unknown???
   // This level only allows certain modifications to be emitted.
   //
   Open_Level2          = 0x00000040,

   // Opens the image, using specified level, defaulting to Open_FullLevel.  If
   // not enough info, then the level is degraged.  The resulting level can
   // be retrieved by calling VComp::GetOpenLevel.
   //
   // WARNING: Missing information may limit what operations can be done.
   //
   Open_Degradable      = 0x00000080,
};

enum WriteFlags
{
   // Write_NoFixups allows the new binary to be written without propagating the
   // fixups information.  This means the binary has no chance to be reprocessed
   // unless VCOmp::Write() is invoked with fRereadable flag ON.  This does not
   // mean that fRereadable will override Write_NoFixups.  fRereadable writes
   // out different information so the binary can be reprocessed.

   Write_NoFixups       = 0x00000001,

   // Write_NoOMAP allows the new binary to be written with no OFFSET_MAP info.
   // This will prevent the new binary from being debuggable.  There is no
   // overriding flag for this option if specified.
   //
   // WARNING: no OMAP means no debugging period since stack trace
   // WARNING: will be completely wrong.

   Write_NoOMAP         = 0x00000002,

   // Write_Rereadable allows the emitted binary to be reprocessed by any
   // Vulcan tools.  And as long as this flag is specified when VComp::Write()
   // is called, the emitted binary continues to be reprocessable.

   Write_Rereadable     = 0x00000004,
};

enum PlatformType
{
    platformtUnknown,
    platformtX86,
    platformtIA64,
    platformtLVM, /* Soon to be obsolete */
    platformtMSIL,
};

enum SectionFlags
{
    Sec_DISCARDABLE = 0x00000001,
    Sec_NOTCACHED   = 0x00000002,
    Sec_NOTPAGED    = 0x00000004,
    Sec_SHARED      = 0x00000008,
    Sec_EXECUTABLE  = 0x00000010,
    Sec_READONLY    = 0x00000020,
    Sec_READWRITE   = 0x00000040,
    Sec_NORELOC     = 0x00000080,
};

enum Value
{
    BranchCondValue,
    EffectiveAddressValue,
    Arg0,
    Arg1,
    Arg2,
    Arg3,
    Arg4
};

enum BlockTermType
{
    BlockTermUnknown,
    BlockTermFallThrough,
    BlockTermTrap,
    BlockTermTrapCond,
    BlockTermBranch,
    BlockTermBranchCond,
    BlockTermBranchCondIndirect,
    BlockTermBranchIndirect,
    BlockTermCall,
    BlockTermCallIndirect,
    BlockTermCallCond,
    BlockTermCallCondIndirect,
    BlockTermNop,
    BlockTermRet,
};

struct Inst
{
    enum EOpParam {
        Dest,
        Src1,
        Src2,

        //For non-x86 archs (NYI)
        Dest2,
        Src3,
        Src4,
        Src5,
        QP
    };

    enum Ex86Prefix // very x86 specific -- very temporary
    {
        x86PrefixNotUsed = 0,
        x86PrefixIRep = 1,
        x86PrefixIRepNE = 2,
        x86PrefixLock = 3
    };
};

enum EOpndTypes
{
    OpndNotUsed = 0,        // not used
    OpndImmediate,          // constant
    OpndImmediate64,        // 64 bit constant
    OpndReg,                // register
    OpndStack,              // Stack
    OpndAddress,            // addressing mode
    OpndBlock,              // pointer to basic block
    OpndData,               // pointer to bytes; size in the second operand
    OpndGenAddressBlock,    // general form addr + disp
    OpndPcrel,              // argument imm should be added to PC (used for a
                            // short time while building the representation
    OpndRegPair,
    OpndSymbol,             // Anal symbolic representation (Operand points to a CSymbolRef)
    OpndOverflow,           // Operand is a pointer to an overflow area -- IA64 motivated
    OpndHiWordAdjust,       // for AXP LDAH inst: high 16 bits of address (adjusted)
    OpndLoWord              // for AXP LDA,LDL,STL insts: low 16 bits of address
};

enum EAddressBaseType
{
    AddressBaseNotUsed=0,
    AddressBaseRegister
};

enum EAddrDispType
{
    AddrDispNotUsed = 0,
    AddrDispImmediate,
    AddrDispBBlock,
    AddrDispProc,       //Not valid - will point to entry block instead
    AddrGenAddressBlock,
};

enum IA64Completers
{
    // Branch branch prediction hardware control
    BrNone = 0, BrClr,

    // Branch prediction vector hint
    BrpDcDc = 0, BrpNone = BrpDcDc, BrpDcNt, BrpTkDc, BrpTkTk, BrpTkNt,
    BrpNtDc, BrpNtTk, BrpNtNt,

    // Branch prediction importance hint (must share flag space with the above)
    BrpNotImp = 16, BrpImp,

    // Speculation Check ALAT control
    ChkClr = 0, ChkNc,

    // Compare Type
    CmpNone = 0, CmpUnc, CmpOr, CmpAnd, CmpOrAndCm,

    // Compute Zero Index, Mix, FSxt Direction
    LeftForm = 0, RightForm, LeftRightForm,

    // Compare and Exchange, Fetch & Add semaphore completer
    SemAcq = 0, SemRel,

    // Floating point status field (cannot share with compare type of left/right form)
    SF0 = 16, SF1, SF2, SF3,

    // FSwap Forms
    FSwapForm = 0, FSwapNlForm, FSwapNrForm,

    // Invala Forms
    InvalaComplete = 0, InvalaEntry,

    // Load types
    LdNone = 0, LdCNc, LdCClr, LdCClrAcq, LdAcq, LdBias, LdAdvanced, LdSpeculative, LdSpeculativeAdvanced,

    // Temporal Locality Hints (must share flag space with the above)
    LocNone = 16, LocNt1, LocNt2, LocNta,

    // Load Fault types (must share flag space with the above)
    LdFaultNone = 0, LdFaultRaise,

    // Memory Fence Modifiers
    FenceOrdering = 0, FenceAccept,

    // Move Modifiers
    MovNone = 0, MoveRet,

    // Parallel Op Modifiers
    ParNone = 0, ParSSS, ParUSS, ParUUS, ParUUU, ParRaz, ParUnsigned,

    // Unpack Modifiers
    UnpackHigh = 0, UnpackLow

};

enum IA64Syllable
{
    IllegalSlotType = 0,
    MSlot,
    ISlot,
    FSlot,
    BSlot,
    XSlot,    // For movl, long nops and branches
    B2Slot,   // For brp's mainly, issue in last B slot of bundle
    I0Slot    // Issue in 1st I slot of independence group
};

class Eff {
public:
    enum EEff {
        ANY = -1,
        Dest,
        Src1,
        Src2,
    };
};

class Register
{
public:
    enum Regs{
//********X86********
        ZERO        =     0x0,
        AL          =     0x1,
        AH          =     0x2,
        AX          =     0x3,
        EAH         =     0x4,
        EAX         =     0x7,

        BL          =     0x9,
        BH          =     0xa,
        BX          =     0xb,
        EBH         =     0xc,
        EBX         =     0xf,

        CL          =     0x11,
        CH          =     0x12,
        CX          =     0x13,
        ECH         =     0x14,
        ECX         =     0x17,

        DL          =     0x19,
        DH          =     0x1a,
        DX          =     0x1b,
        EDH         =     0x1c,
        EDX         =     0x1f,

        SI          =     0x23,
        SIH         =     0x26,
        ESI         =     0x27,

        DI          =     0x2b,
        DIH         =     0x2e,
        EDI         =     0x2f,

        SP          =     0x33,
        SPH         =     0x36,
        ESP         =     0x37,

        BP          =     0x3b,
        BPH         =     0x3e,
        EBP         =     0x3f,

        FLAGS       =     0x43,  // FL string
        EFLAGS      =     0x47,  // EF string

        CF          =     0x43,
        PF          =     0x44,
        AF          =     0x45,
        ZF          =     0x46,
        SF          =     0x47,
        TF          =     0x48,
        IF          =     0x49,
        DF          =     0x4a,
        OF          =     0x4b,
        IOPL        =     0x4c,
        NT          =     0x4d,
        RF          =     0x4e,
        VM          =     0x4f,
        AC          =     0x50,
        VIF         =     0x51,
        VIP         =     0x52,
        ID          =     0x53,

        IP          =     0x5b,
        EIP         =     0x5f,  // EP string
        ENDGENERAL  =     EIP,

        CS          =     0x63,
        DS          =     0x6b,
        SS          =     0x73,
        ES          =     0x7b,
        FS          =     0x83,
        GS          =     0x8b,

        TR0         =     0x90,
        TR1         =     0x91,
        TR2         =     0x92,
        TR3         =     0x93,
        TR4         =     0x94,
        TR5         =     0x95,
        TR6         =     0x96,
        TR7         =     0x97,

        DR0         =     0x98,
        DR1         =     0x99,
        DR2         =     0x9a,
        DR3         =     0x9b,
        DR4         =     0x9c,
        DR5         =     0x9d,
        DR6         =     0x9e,
        DR7         =     0x9f,

        CR0         =     0xa0,
        CR1         =     0xa1,
        CR2         =     0xa2,
        CR3         =     0xa3,
        CR4         =     0xa4,
        CR5         =     0xa5,
        CR6         =     0xa6,
        CR7         =     0xa7,

        MM0         =     0xa8,
        MM1         =     0xa9,
        MM2         =     0xaa,
        MM3         =     0xab,
        MM4         =     0xac,
        MM5         =     0xad,
        MM6         =     0xae,
        MM7         =     0xaf,

        CC          =     0xb0,
        PERF1       =     0xb1,
        PERF2       =     0xb2,

        XMM0        =     0xb3,
        XMM1        =     0xb4,
        XMM2        =     0xb5,
        XMM3        =     0xb6,
        XMM4        =     0xb7,
        XMM5        =     0xb8,
        XMM6        =     0xb9,
        XMM7        =     0xba,

        X86REGMAX,

//*******IA64*******

        // General Purpose Registers

        GR0 = 0,
              GR1 , GR2 , GR3 , GR4 , GR5 , GR6 , GR7 ,
        GR8 , GR9 , GR10, GR11, GR12, GR13, GR14, GR15,
        GR16, GR17, GR18, GR19, GR20, GR21, GR22, GR23,
        GR24, GR25, GR26, GR27, GR28, GR29, GR30, GR31,
        GR32, GR33, GR34, GR35, GR36, GR37, GR38, GR39,
        GR40, GR41, GR42, GR43, GR44, GR45, GR46, GR47,
        GR48, GR49, GR50, GR51, GR52, GR53, GR54, GR55,
        GR56, GR57, GR58, GR59, GR60, GR61, GR62, GR63,
        GR64, GR65, GR66, GR67, GR68, GR69, GR70, GR71,
        GR72, GR73, GR74, GR75, GR76, GR77, GR78, GR79,
        GR80, GR81, GR82, GR83, GR84, GR85, GR86, GR87,
        GR88, GR89, GR90, GR91, GR92, GR93, GR94, GR95,
        GR96, GR97, GR98, GR99, GR100, GR101, GR102, GR103,
        GR104, GR105, GR106, GR107, GR108, GR109, GR110, GR111,
        GR112, GR113, GR114, GR115, GR116, GR117, GR118, GR119,
        GR120, GR121, GR122, GR123, GR124, GR125, GR126, GR127,

        // Floating Point Registers

        FR0 , FR1 , FR2 , FR3 , FR4 , FR5 , FR6 , FR7 ,
        FR8 , FR9 , FR10, FR11, FR12, FR13, FR14, FR15,
        FR16, FR17, FR18, FR19, FR20, FR21, FR22, FR23,
        FR24, FR25, FR26, FR27, FR28, FR29, FR30, FR31,
        FR32, FR33, FR34, FR35, FR36, FR37, FR38, FR39,
        FR40, FR41, FR42, FR43, FR44, FR45, FR46, FR47,
        FR48, FR49, FR50, FR51, FR52, FR53, FR54, FR55,
        FR56, FR57, FR58, FR59, FR60, FR61, FR62, FR63,
        FR64, FR65, FR66, FR67, FR68, FR69, FR70, FR71,
        FR72, FR73, FR74, FR75, FR76, FR77, FR78, FR79,
        FR80, FR81, FR82, FR83, FR84, FR85, FR86, FR87,
        FR88, FR89, FR90, FR91, FR92, FR93, FR94, FR95,
        FR96, FR97, FR98, FR99, FR100, FR101, FR102, FR103,
        FR104, FR105, FR106, FR107, FR108, FR109, FR110, FR111,
        FR112, FR113, FR114, FR115, FR116, FR117, FR118, FR119,
        FR120, FR121, FR122, FR123, FR124, FR125, FR126, FR127,

        // Predicate Registers

        PR0 , PR1 , PR2 , PR3 , PR4 , PR5 , PR6 , PR7 ,
        PR8 , PR9 , PR10, PR11, PR12, PR13, PR14, PR15,
        PR16, PR17, PR18, PR19, PR20, PR21, PR22, PR23,
        PR24, PR25, PR26, PR27, PR28, PR29, PR30, PR31,
        PR32, PR33, PR34, PR35, PR36, PR37, PR38, PR39,
        PR40, PR41, PR42, PR43, PR44, PR45, PR46, PR47,
        PR48, PR49, PR50, PR51, PR52, PR53, PR54, PR55,
        PR56, PR57, PR58, PR59, PR60, PR61, PR62, PR63,

        // Predicate Aggregates: PR and PR.rot

        PR, PRROT,

        // Branch Registers

        BR0 , RP = BR0, BR1 , BR2 , BR3 , BR4 , BR5 , BR6 , BR7 ,

        // Application Registers

        // Kernel Registers are aliased with the first 8 AR's

        AR0 , KR0 = AR0, AR1 , KR1 = AR1, AR2 , KR2 = AR2, AR3 , KR3 =AR3,
        AR4 , KR4 = AR4, AR5 , KR5 = AR5, AR6 , KR6 = AR6, AR7 , KR7 = AR7,
        AR8 , AR9 , AR10, AR11, AR12, AR13, AR14, AR15,
        AR16, RSC = AR16, AR17, BSP = AR17, AR18, BSPSTORE = AR18, AR19, RNAT = AR19,
        AR20, AR21, AR22, AR23,
        AR24, AR25, AR26, AR27, AR28, AR29, AR30, AR31,
        AR32, CCV = AR32, AR33, AR34, AR35, AR36, UNAT = AR36, AR37, AR38, AR39,
        AR40, FPSR = AR40, AR41, AR42, AR43, AR44, ITC = AR44, AR45, AR46, AR47,
        AR48, AR49, AR50, AR51, AR52, AR53, AR54, AR55,
        AR56, AR57, AR58, AR59, AR60, AR61, AR62, AR63,
        AR64, PFS = AR64, AR65, LC = AR65, AR66, EC = AR66, AR67, AR68, AR69, AR70, AR71,
        AR72, AR73, AR74, AR75, AR76, AR77, AR78, AR79,
        AR80, AR81, AR82, AR83, AR84, AR85, AR86, AR87,
        AR88, AR89, AR90, AR91, AR92, AR93, AR94, AR95,
        AR96, AR97, AR98, AR99, AR100, AR101, AR102, AR103,
        AR104, AR105, AR106, AR107, AR108, AR109, AR110, AR111,
        AR112, AR113, AR114, AR115, AR116, AR117, AR118, AR119,
        AR120, AR121, AR122, AR123, AR124, AR125, AR126, AR127,

		// Control registers
        ia64CR0, DCR = ia64CR0, ia64CR1, ITM = ia64CR1, ia64CR2, IVA = ia64CR2, ia64CR3, ia64CR4, ia64CR5, ia64CR6, ia64CR7,
        CR8, PTA = CR8, CR9,  CR10, CR11, CR12, CR13, CR14, CR15,
        CR16, IPSR = CR16, CR17, ISR = CR17, CR18, CR19, IIP = CR19, CR20, IFA = CR20, CR21, ITIR = CR21, CR22,
                                                                     IIPA = CR22, CR23, IFS = CR23,
        CR24, IIM = CR24, CR25, IHA = CR25, CR26, CR27, CR28, CR29, CR30, CR31,
        CR32, CR33, CR34, CR35, CR36, CR37, CR38, CR39,
        CR40, CR41, CR42, CR43, CR44, CR45, CR46, CR47,
        CR48, CR49, CR50, CR51, CR52, CR53, CR54, CR55,
        CR56, CR57, CR58, CR59, CR60, CR61, CR62, CR63,
        CR64, LID = CR64, CR65, IVR = CR65, CR66, TPR = CR66, CR67, EOI = CR67, CR68, IRR0 = CR68, CR69, IRR1 = CR69,
                                                                    CR70, IRR2 = CR70, CR71, IRR3 = CR71,
        CR72, ITV = CR72, CR73, PMV = CR73, CR74, CMCV = CR74, CR75, CR76, CR77, CR78, CR79,
        CR80, LRR0 = CR80, CR81, LRR1 = CR81, CR82, CR83, CR84, CR85, CR86, CR87,
        CR88, CR89, CR90, CR91, CR92, CR93, CR94, CR95,
        CR96, CR97, CR98, CR99, CR100, CR101, CR102, CR103,
        CR104, CR105, CR106, CR107, CR108, CR109, CR110, CR111,
        CR112, CR113, CR114, CR115, CR116, CR117, CR118, CR119,
        CR120, CR121, CR122, CR123, CR124, CR125, CR126, CR127,

		// Program status register
        PSR, PSRL, PSRUM,

        // IP for ia64
        ia64IP,

        BadIA64Register,

        IA64RegisterCount,

//********AXP********

        // General Purpose Registers
        R0 = 0,
             R1,  R2,  R3,  R4,  R5,  R6,  R7,
        R8,  R9,  R10, R11, R12, R13, R14, R15,
        R16, R17, R18, R19, R20, R21, R22, R23,
        R24, R25, R26, R27, R28, R29, R30, R31,

        // Friendly names for General Purpose Registers
        V0 = 0,
             T0,  T1,  T2,  T3,  T4,  T5,  T6,  T7,
        S0,  S1,  S2,  S3,  S4,  S5,  Fp,
        A0,  A1,  A2,  A3,  A4,  A5,  T8,  T9,  T10, T11,
        Ra,  T12, At,  Gp,  Sp,  Zero,

        // Floating Point Registers
        F0,  F1,  F2,  F3,  F4,  F5,  F6,  F7,
        F8,  F9,  F10, F11, F12, F13, F14, F15,
        F16, F17, F18, F19, F20, F21, F22, F23,
        F24, F25, F26, F27, F28, F29, F30, F31,

        AXPRegisterCount
    };

    static VULCANDLL bool VULCANCALL IsStackReg(int reg) {return reg == ESP || reg == SP;}
};

typedef Register::Regs X86Reg;
typedef Register       X86Register;
typedef Register::Regs IA64Reg;
typedef Register       IA64Register;
typedef Register::Regs AXPReg;
typedef Register       AXPRegister;
typedef Register::Regs ERegister;

class COp{
public:
    enum EOpGroup
    {
        GOpERROR = 0x0,
        GADD,       GOR,         GAND,
        GXOR,       GNOT,        GNEG,
        GMUL,       GDIV,        GIADC,
        GISBB,      GSUB,
        GCMP,       GCMPL,
        GPUSH,      GPOP,
        GB,         GJMP,        GISETCC,
        GMOV,       GMOVZX,      GMOVSX,
        GBSWAP,     GLEA,
        GCVT,
        GCALL,      GRET,
        GINT,       GNOP,        GHLT,
        GROL,       GROR,
        GSAL,       GSHR,        GSAR,
        GRCL,       GRCR,

        GDATA,      GADDR,

        GIDAA,      GIAAS,       GIAAA,
        GIAAM,      GIAAD,       GIDAS,
        GIINC,      GIDEC,
        GIXADD,
        GIPUSHA,    GIPOPA,
        GIPUSHF,    GIPOPF,
        GIBOUND,    GIARPL,
        GIINS,      GIOUTS,
        GIIN,       GIOUT,
        GIXCH,      GIWAIT,      GIXLAT,
        GISAHF,     GILAHF,
        GIMOVS,     GICMPS,
        GISTOS,     GILODS,      GISCAS,
        GILES,      GILDS,       GILAR,
        GILSL,
        GIENTER,    GILEAVE,     GIINTO,
        GILOOP,
        GILOCK,     GIREP,
        GICMC,      GICLC,       GICLI,
        GICLD,      GICLTS,      GISTC,
        GISTI,      GISTD,
        GIINVD,     GIWBINVD,    GICPUID,
        GIRSM,
        GISHLD,     GISHRD,
        GIBT,       GIBTS,       GIBTR,
        GIBTC,
        GIBSF,      GIBSR,
        GILSS,      GILGS,
        GILFS,      GISLDT,      GISTR,
        GILLDT,     GILTR,
        GIVERR,     GIVERW,
        GISGDT,     GISIDT,      GILGDT,
        GILIDT,     GISMSW,      GILMSW,
        GIINVLPG,   GICMXCHG8B,
        GICMPXCH,

        GLD,        GST,

        GFADD,      GFCMP,       GFUCMPX,
        GFMUL,      GFSUB,       GFSUBR,
        GFDIV,      GFDIVR,
        GFLD,       GFST,
        GFXCHX,     GFNOP,       GFCHS,
        GFABS,      GFPTANX,     GFPATANX,
        GFSQRTX,    GFSCALEX,
        GFSINX,     GFCOSX,

        GIFCMPP,    GIFCMPPPX,
        GIFUCMPPPX, GIFUCMPPX,   GIFADDPX,  GIFMULPX,
        GIFSUBRPX,  GIFSUBPX,    GIFDIVRPX, GIFDIVPX,
        GIFSTP,
        GIFLDENV,   GIFLDCW,     GIFSTENV,  GIFSTCW,  GIFSTPQ,
        GIFRSTOR,   GIFSAVE,     GIFNSTSW,  GIFBLD,   GIFBSTP,
        GIFTST,     GIFXAM,      GIFLDL2T,
        GIFLD1,     GIFLDL2E,    GIFLDPI,   GIFLDLG2,
        GIFLDLN2,   GIFLDZ,      GIF2XM1,   GIFYL2X,  GIFXTRACT,
        GIFPREM1,   GIFDECSTP,   GIFINCSTP, GIFPREM,  GIFYL2XP1,
        GIFSINCOSX, GIFRNDINT,   GIFFREE,   GIFCLEX,  GIFINIT,
        GIRDMSR,    GIRDTSC,     GIWRMSR,   GIRDPMC,  GIXBTS,
        GIFCOMI,    GIFUCOMI,    GFCMOV,  GIFENI,     GIFDISI,    GIFSETPM,

        GMMXEMMS,
        GMMXMOV,
        GMMXPACK,
        GMMXPADD,
        GMMXPAND,
        GMMXPEQ,
        GMMXPGT,
        GMMXPMADD,
        GMMXPMUL,
        GMMXPOR,
        GMMXPSLL,   GMMXPSRA,    GMMXPSRL,
        GMMXPSUB,
        GMMXPUNPCK,
        GMMXPXOR,
        GMMXSYSTENTER,
        GMMXSYSEXIT,
        GMMXFXSAVE, GMMXFXRSTOR,
        GLDMXCSR, GSTMXCSR,

        GMMXPI2FD, GMMXPF2ID,    GMMXPFCMPGE, GMMXPFMIN,    GMMXPFRCP,    GMMXPFRSQRT, GMMXPFSUB,
        GMMXPFADD, GMMXPFCMPGT,  GMMXPFMAX,   GMMXPFRCPIT1, GMMXPFRSQIT1, GMMXPFSUBR,
        GMMXPFACC, GMMXPFCMPEQ,  GMMXPFMUL,   GMMXPFRCPIT2, GMMXPMULHRW,  GMMXPAVGUSB,
        GFEMMS,    GMMXPREFETCH, GMMXSFENCE,  GMMXXORPS,

        GMOVSS,  GMOVUPS, GCVTPI2PS, GCVTSI2SS,
        GPINSRW, GPEXTRW, GSHUFPS,   GRCP, GSQRT, GMAX, GMIN, GUNPCK,

        // UNDONE: To be moved near all the MOV instructions

        GCMOV,

        GMMXMASKMOV, GMMXPSADB, GPAUSE,

        EndGrp
    };

    enum EOp
    {
        OpERROR = 0x0,
        ADDB,         ADDW,         ADDD,
        ORB,          ORW,          ORD,
        ANDB,         ANDW,         ANDD,
        XORB,         XORW,         XORD,
        NOTB,         NOTW,         NOTD,
        NEGB,         NEGW,         NEGD,
        UMULB,        UMULW,        UMULD,
        SMULB,        SMULW,        SMULD,
        IMULW,        IMULD,
        UDIVB,        UDIVW,        UDIVD,
        SDIVB,        SDIVW,        SDIVD,
        IADCB,        IADCW,        IADCD,
        ISBBB,        ISBBW,        ISBBD,
        SUBB,         SUBW,         SUBD,
        CMPB,         CMPW,         CMPD,
        CMPLB,        CMPLW,        CMPLD,

        // IA64 Compares
        CMP_EQ,   CMP_LT,   CMP_LTU,   CMP_NE,   CMP_LE,   CMP_GT,   CMP_GE,
        CMP4_EQ,  CMP4_LT,  CMP4_LTU,  CMP4_NE,  CMP4_LE,  CMP4_GT,  CMP4_GE,
        TBIT_Z,   TBIT_NZ,  TNAT_Z,    TNAT_NZ,  PCMP1_EQ, PCMP2_EQ, PCMP4_EQ,
        PCMP1_GT, PCMP2_GT, PCMP4_GT,

        PUSHB,        PUSHW,        PUSHD,
        POPB,         POPW,         POPD,

        // Start of Conditional Branches
        // Start of Reversable Conditional Branches
        BULT,         BULE,         BUGT,         BUGE,
        BLT,          BLE,          BGT,          BGE,
        BO,           BNO,          BP,           BNP,
        BS,           BNS,          BZ,           BNZ,
        // AXP Floating Point Conditional Branches
        FBEQ, FBGE, FBGT, FBLE, FBLT, FBNE,
        // End of Reversable Conditional Branches
        BEQ,          BNE,

        // IA64 Branches
        BR_COND_SPNT_FEW, BR_COND_SPNT_MANY, BR_COND_SPTK_FEW, BR_COND_SPTK_MANY,
        BR_COND_DPNT_FEW, BR_COND_DPNT_MANY, BR_COND_DPTK_FEW, BR_COND_DPTK_MANY,

        BRL_COND_SPNT_FEW, BRL_COND_SPNT_MANY, BRL_COND_SPTK_FEW, BRL_COND_SPTK_MANY,
        BRL_COND_DPNT_FEW, BRL_COND_DPNT_MANY, BRL_COND_DPTK_FEW, BRL_COND_DPTK_MANY,

		BR_WEXIT_SPNT_FEW, BR_WEXIT_SPNT_MANY, BR_WEXIT_SPTK_FEW, BR_WEXIT_SPTK_MANY,
        BR_WEXIT_DPNT_FEW, BR_WEXIT_DPNT_MANY, BR_WEXIT_DPTK_FEW, BR_WEXIT_DPTK_MANY,

        BR_WTOP_SPNT_FEW, BR_WTOP_SPNT_MANY, BR_WTOP_SPTK_FEW, BR_WTOP_SPTK_MANY,
        BR_WTOP_DPNT_FEW, BR_WTOP_DPNT_MANY, BR_WTOP_DPTK_FEW, BR_WTOP_DPTK_MANY,

        BR_CLOOP_SPNT_FEW, BR_CLOOP_SPNT_MANY, BR_CLOOP_SPTK_FEW, BR_CLOOP_SPTK_MANY,
        BR_CLOOP_DPNT_FEW, BR_CLOOP_DPNT_MANY, BR_CLOOP_DPTK_FEW, BR_CLOOP_DPTK_MANY,

        BR_CEXIT_SPNT_FEW, BR_CEXIT_SPNT_MANY, BR_CEXIT_SPTK_FEW, BR_CEXIT_SPTK_MANY,
        BR_CEXIT_DPNT_FEW, BR_CEXIT_DPNT_MANY, BR_CEXIT_DPTK_FEW, BR_CEXIT_DPTK_MANY,

        BR_CTOP_SPNT_FEW, BR_CTOP_SPNT_MANY, BR_CTOP_SPTK_FEW, BR_CTOP_SPTK_MANY,
        BR_CTOP_DPNT_FEW, BR_CTOP_DPNT_MANY, BR_CTOP_DPTK_FEW, BR_CTOP_DPTK_MANY,

        BR_IA_SPNT_FEW, BR_IA_SPNT_MANY, BR_IA_SPTK_FEW, BR_IA_SPTK_MANY,
        BR_IA_DPNT_FEW, BR_IA_DPNT_MANY, BR_IA_DPTK_FEW, BR_IA_DPTK_MANY,

        // AXP
        BLBC, BLBS,
        // End of Conditional Branches
        IBCXZ,

        // Start of Unconditional Branches
        JMP,          IJMP16,       IJMP32,       IJMP48,

        // AXP
        BR_JMP,       BSR_JMP,      JMP_JMPI,     JSR_JMPI,
        // End of Unconditional Branches
        JSR_COROUTINE_JMPI,

        // Start of Calls
        CALL,         ICALL16,

        // IA64
        BR_CALL_SPNT_FEW, BR_CALL_SPNT_MANY, BR_CALL_SPTK_FEW,BR_CALL_SPTK_MANY,
        BR_CALL_DPNT_FEW, BR_CALL_DPNT_MANY, BR_CALL_DPTK_FEW,BR_CALL_DPTK_MANY,

        BRL_CALL_SPNT_FEW, BRL_CALL_SPNT_MANY, BRL_CALL_SPTK_FEW,BRL_CALL_SPTK_MANY,
        BRL_CALL_DPNT_FEW, BRL_CALL_DPNT_MANY, BRL_CALL_DPTK_FEW,BRL_CALL_DPTK_MANY,

        // AXP
        BR_CALL,      BSR_CALL,     JMP_CALLI,    JSR_CALLI,    RET_CALLI,
        // End of Calls
        JSR_COROUTINE_CALLI,

        // Start of Returns
        RET,          RETF,         IRET,

        // IA64
        BR_RET_SPNT_FEW, BR_RET_SPNT_MANY, BR_RET_SPTK_FEW, BR_RET_SPTK_MANY,
        BR_RET_DPNT_FEW, BR_RET_DPNT_MANY, BR_RET_DPTK_FEW, BR_RET_DPTK_MANY,
        RFI,

        // End of Returns
        RET_JMPI,

        ISETULT,      ISETULE,      ISETUGT,      ISETUGE,
        ISETLT,       ISETLE,       ISETGT,       ISETGE,
        ISETO,        ISETNO,       ISETP,        ISETNP,
        ISETS,        ISETNS,       ISETZ,        ISETNZ,

        MOVB,         MOVW,         MOVD,
        MOVZXDB,      MOVZXWB,      MOVZXDW,
        MOVSXDB,      MOVSXWB,      MOVSXDW,

        // IA64 MOV instructions
        // Execution unit specific MOV instructions
        MOV_I,        MOV_M,

        // Register set secific moves
        MOV_CPUID,
        MOV_TO_DBR, MOV_FROM_DBR,
        MOV_TO_IBR, MOV_FROM_IBR,
        MOV_TO_MSR, MOV_FROM_MSR,
        MOV_TO_PKR, MOV_FROM_PKR,
        MOV_TO_PMC, MOV_FROM_PMC,
        MOV_TO_PMD, MOV_FROM_PMD,
        MOV_TO_RR,  MOV_FROM_RR,

        // MOV's involving branch prediction and prefetch.
        // For now, cancellation vector and importance hint are omitted.
        MOV_FEW,      MOV_MANY,     MOV_SPTK_FEW,   MOV_SPTK_MANY,
        MOV_DP_FEW,   MOV_DP_MANY,

        // MOVE LONG
        MOVL,

        BSWAP,        LEAD,         LEAW,
        CWD,          CDQ,          CBW,
        INT,          NOP,          HLT,
        ROLB,         ROLW,         ROLD,
        RORB,         RORW,         RORD,
        SALB,         SALW,         SALD,
        SHRB,         SHRW,         SHRD,
        SARB,         SARW,         SARD,
        RCLB,         RCLW,         RCLD,
        RCRB,         RCRW,         RCRD,
        DATA,         ADDR,

        IDAA,         IAAS,         IAAA,
        IAAM,         IAAD,         IDAS,
        IINCB,        IINCW,        IINCD,
        IDECB,        IDECW,        IDECD,
        IXADDB,       IXADDW,       IXADDD,
        IPUSHA,       IPOPA,        IPUSHF,       IPOPF,
        IBOUNDW,      IBOUNDD,      IARPL,
        IINSB,        IINSW,        IINSD,
        IOUTSB,       IOUTSW,       IOUTSD,
        IINB,         IINW,         IIND,
        IOUTB,        IOUTW,        IOUTD,
        IXCHB,        IXCHW,        IXCHD,
        IWAIT,        IXLAT,
        ISAHF,        ILAHF,
        IMOVSB,       IMOVSW,       IMOVSD,
        ICMPSB,       ICMPSW,       ICMPSD,
        ISTOSB,       ISTOSW,       ISTOSD,
        ILODSB,       ILODSW,       ILODSD,
        ISCASB,       ISCASW,       ISCASD,
        ILESF,        ILESS,
        ILDSF,        ILDSS,
        ILARD,        ILARW,
        ILSLD,        ILSLW,
        IENTER,       ILEAVE,       IINTO,
        ILOOPN,       ILOOP,        ILOOPE,
        ILOCK,        IREP,         IREPNE,
        ICMC,         ICLC,         ICLI,         ICLD,
        ICLTS,        ISTC,         ISTI,         ISTD,
        IINVD,        IWBINVD,      ICPUID,       IRSM,
        ISHLDD,       ISHLDW,       ISHRDD,       ISHRDW,
        IBTD,         IBTW,         IBTSD,        IBTSW,
        IBTRD,        IBTRW,        IBTCD,        IBTCW,
        IBSFD,        IBSFW,        IBSRD,        IBSRW,
        ILSSF,        ILSSS,        ILGSF,        ILGSS,
        ILFSF,        ILFSS,        ISLDT,        ISTR,
        ILLDT,        ILTR,         IVERR,        IVERW,
        ISGDT,        ISIDT,        ILGDT,
        ILIDT,        ISMSW,        ILMSW,        IINVLPG,
        ICMXCHG8B,
        ICMPXCHB,     ICMPXCHW,     ICMPXCHD,

        LDD,          LDW,          LDH,          LDB,

        // IA64 FILL instructions
        LDD_FILL,     LDF_FILL,

        STD,          STW,          STH,          STB,

        // IA64 SPILL instructions
        STD_SPILL,    STF_SPILL,

        ASZ,          OSZ,          SEG,

        RESERVED,     GRP,          ESC,          ESCESC,
        ESCESC2,      KATMAI,      KATMAI2,

        FLOAT,
        FADDF,        FADDW,        FADDI,        FADDD,     FADDX,
        FCMPF,        FCMPW,        FCMPI,        FCMPD,     FCMPX,FUCMPX,

        // IA64 Floating comparisons
        FCMP_EQ,      FCMP_LT,      FCMP_LE,      FCMP_UNORD,
        FPCMP_EQ,     FPCMP_LT,     FPCMP_LE,     FPCMP_UNORD,
        FPCMP_NEQ,    FPCMP_NLT,    FPCMP_NLE,    FPCMP_ORD,


        FMULF,        FMULW,        FMULI,        FMULD,     FMULX,
        FSUBF,        FSUBW,        FSUBI,        FSUBD,     FSUBX,
        FSUBRF,       FSUBRW,       FSUBRI,       FSUBRD,    FSUBRX,
        FDIVF,        FDIVW,        FDIVI,        FDIVD,     FDIVX,
        FDIVRF,       FDIVRD,       FDIVRX,       FDIVRI,
        FLDF,         FLDW,         FLDI,         FLDD,      FLDQ,   FLDX,
        FSTF,         FSTW,         FSTI,         FSTD,      FSTX,
        FXCHX,
        FNOP,         FCHS,         FABS,         FPTANX,    FPATANX,
        FSQRTX,       FSCALEX,      FSINX,        FCOSX,     // fsqrt = 370

        IFCMPPF,      IFCMPPW,      IFCMPPI,      IFCMPPD,   IFCMPPX,
        IFCMPPPX,     IFUCMPPPX,    IFUCMPPX,     IFADDPX,   IFMULPX,
        IFSUBRPX,     IFSUBPX,      IFDIVRPX,     IFDIVPX,
        IFSTPF,       IFSTPW,       IFSTPI,       IFSTPD,    IFSTPX,
        IFLDENV,      IFLDCW,       IFSTENV,      IFSTCW,    IFSTPQ,
        IFRSTOR,      IFSAVE,       IFNSTSW,      IFBLD,     IFBSTP,
        IFTST,        IFXAM,        IFLDL2T,
        IFLD1,        IFLDL2E,      IFLDPI,       IFLDLG2,
        IFLDLN2,      IFLDZ,        IF2XM1,       IFYL2X,    IFXTRACT,
        IFPREM1,      IFDECSTP,     IFINCSTP,     IFPREM,    IFYL2XP1,
        IFSINCOSX,    IFRNDINT,     IFFREE,       IFCLEX,    IFINIT,
        IRDMSR,       IRDTSC,       IWRMSR,       IRDPMC,    IXBTS,
        IFCOMIP,      IFUCOMIP,     FCMOVNB,      FCMOVNE,   FCMOVNBE,
        FCMOVNU,      FCOMI,        FUCOMI,       FCMOVB,    FCMOVE,
        FCMOVBE,      FCMOVU,       IFENI,        IFDISI,    IFSETPM,

        MMXPADDB,     MMXPADDD,     MMXPADDSB,    MMXPADDSW,
        MMXPADDUSB,   MMXPADDUSW,   MMXPADDW,
        MMXPAND,      MMXPANDN,
        MMXEMMS,
        MMXPMADDWD,
        MMXMOVDTO,    MMXMOVDFROM,  MMXMOVQTO,    MMXMOVQFROM,
        MMXPACKSSDW,  MMXPACKSSWB,  MMXPACKUSWB,
        MMXPCMPEQB,   MMXPCMPEQD,   MMXPCMPEQW,
        MMXPCMPGTB,   MMXPCMPGTD,   MMXPCMPGTW,
        MMXPMULHW,    MMXPMULLW,
        MMXPOR,
        MMXPSLLD,     MMXPSLLQ,     MMXPSLLW,
        MMXPSRAD,     MMXPSRAW,
        MMXPSRLD,     MMXPSRLQ,     MMXPSRLW,
        MMXPSUBB,     MMXPSUBD,     MMXPSUBSB,    MMXPSUBSW,
        MMXPSUBUSB,   MMXPSUBUSW,   MMXPSUBW,
        MMXPUNPCKHBW, MMXPUNPCKHDQ, MMXPUNPCKHWD,
        MMXPUNPCKLBW, MMXPUNPCKLDQ, MMXPUNPCKLWD,
        MMXPXOR,
        MMXSYSTENTER,
        MMXSYSEXIT,
        MMXFXSAVE, MMXFXRSTOR,
        LDMXCSR, STMXCSR,

        MMXPI2FD, MMXPF2ID,   MMXPFCMPGE, MMXPFMIN,    MMXPFRCP,    MMXPFRSQRT, MMXPFSUB,
        MMXPFADD, MMXPFCMPGT, MMXPFMAX,   MMXPFRCPIT1, MMXPFRSQIT1, MMXPFSUBR,
        MMXPFACC, MMXPFCMPEQ, MMXPFMUL,   MMXPFRCPIT2, MMXPMULHRW,  MMXPAVGUSB,
        FEMMS,    MMXPREFETCH,MMXPREFETCHW,

        MMXPREFETCHNTA, MMXPREFETCH0, MMXPREFETCH1, MMXPREFETCH2, MMXSFENCE,

        XORPS, MOVNTPS, MOVAPS, COMISS, UCOMISS, MOVLPS, MOVHPS, UNPCKLPS, UNPCKHPS,
        MOVMSKPS, ANDPS, ANDNPS, ORPS, PMOVMSKB,


        // MMX

        // KATMAI
        MOVSS, MOVUPS, CVTPI2PS, CVTSI2SS,
        PINSRW, PEXTRW, SHUFPS,
        ADDPS, ADDSS, SUBPS, SUBSS, MULPS, MULSS, DIVPS, DIVSS, MINPS, MINSS, MAXPS, MAXSS,
        SQRTPS, SQRTSS, RSQRTPS, RSQRTSS, RCPPS, RCPSS,
        CMPEQPS, CMPEQSS, CMPLTPS, CMPLTSS, CMPLEPS, CMPLESS,
        CMPUNORDPS, CMPUNORDSS, CMPNEQPS, CMPNEQSS,
        CMPNLTPS, CMPNLTSS, CMPNLEPS, CMPNLESS,
        CMPORDPS, CMPORDSS,
        CVTTPS2PI, CVTTSS2SI, CVTPS2PI, CVTSS2SI,

        // IA64 Specific Instructions -- only those opcodes whose functionality
        // is not subsumed by the instructions above will be listed here.

        // Add Pointer
        ADDP4,

        // Register stack alloc
        ALLOC,

        // And Complement
        ANDCM,

        // Break
        BREAK_B, BREAK_F, BREAK_I, BREAK_M, BREAK_X,

		// Branch Prediction
        BRP_SPTK_FEW, BRP_SPTK_MANY, BRP_LOOP_FEW, BRP_LOOP_MANY,
        BRP_EXIT_FEW, BRP_EXIT_MANY, BRP_DPTK_FEW, BRP_DPTK_MANY,

		BRP_RET_SPTK_FEW, BRP_RET_SPTK_MANY, BRP_RET_DPTK_FEW, BRP_RET_DPTK_MANY,

		// Bank Switch
		BSW_0, BSW_1,

        // Speculation check instructions
        CHK_A, CHK_S,

        // Clear Rotating Register Base
        CLRRRB, CLRRRB_PR,

        // Compare and Exchange
        CMPXCHG1, CMPXCHG2, CMPXCHG4, CMPXCHG8,

        // Cover stack frame
        COVER,

        // Compute zero index
        CZX1, CZX2,

        // Deposit
        DEPOSIT, DEPOSIT_ZERO,

        // Enter privileged code
        EPC,

        // Extract
        EXTRACT, EXTRACT_UNSIGNED,

        // Floating abs. max
        FAMAX,

        // Floating abs. min
        FAMIN,

        // Floating and
        FAND,

        // Floating and complement
        FANDCM,

        // Flush cache
        FC,

        // Floating check flags
        FCHKF,

        // Floating class
        FCLASS,

        // Floating clear flags
        FCLRF,

        // Floating convert to integer
        FCVT_FX, FCVT_FX_TRUNC, FCVT_FXU, FCVT_FXU_TRUNC,

        // Convert signed to floating point
        FCVT_XF,

        // Fetch and Add
        FETCH_ADD4, FETCH_ADD8,

        // Flush Register Stack
        FLUSHRS,

        // Floating Multiply Add -- Also used to encode FADD and FMULT
        FMA_SINGLE,
        FMA_DOUBLE,
        FMA_DYNAMIC,

        // Floating max
        FMAX,

        // Floating Point Merge
        FMERGE_NEG_SIGN, FMERGE_SIGN, FMERGE_SIGN_EXP,

        // Floating min
        FMIN,

        // Floating mix
        FMIX,

        // Floating Multiply Subtract -- used to encode FSUB
        // We're ignoring status fields here for the time being.
        FMS_SINGLE, FMS_DOUBLE, FMS_DYNAMIC,

        // Floating Negative Multiply Add
        FNMA_SINGLE,
        FNMA_DOUBLE,
        FNMA_DYNAMIC,

        // Floating or
        FOR,

        // Floating pack
        FPACK,

        // SIMD Floating Opcodes
        FPAMAX, FPAMIN, FPCVT_FX, FPCVT_FX_TRUNC, FPCVT_FXU, FPCVT_FXU_TRUNC,
        FPMA, FPMAX, FPMERGE_NEG_SIGN, FPMERGE_SIGN, FPMERGE_SIGN_EXP, FPMIN,
        FPMS, FPNMA, FPRCPA, FPRSQRTA,

        // Floating point reciprocal approximation
        FRCPA,

        // Floating point reciprocal square root approximation
        FRSQRTA,

        // Floating select
        FSELECT,

        // Floating set controls
        FSETC,

        // Floating swap
        FSWAP,

        // Floating sign extend
        FSXT,

        // Flush Write Buffers
        FWB,

        // Floating xor
        FXOR,

        // Get Floating Point Value
        GETF_SINGLE, GETF_DOUBLE, GETF_EXP, GETF_SIG,

        // Halt
        HALT,

        // Invalidate ALAT
        INVALA,

        // Insert translation cache
        ITC_I, ITC_D,

        // Insert Translation Register
        ITR_I, ITR_D,

        // Line prefetch
        LFETCH, LFETCH_EXCL,

        // Load Register Stack
        LOADRS,

        // Memory Fence
        MEM_FENCE,

        // Mix
        MIX1, MIX2, MIX4,

        // Mux
        MUX1, MUX2,

        // NOP'S
        NOP_B, NOP_F, NOP_I, NOP_M, NOP_X,

        // Pack
        PACK2, PACK4,

        // Parallel add half word (other lengths already in x86: e.g. mmxpaddb)
        PADD2,

        // Parallel avg half word (other lengths already in x86: e.g. mmxpavgb)
        PAVG2,

        // Parallel avg subtract
        PAVGSUB1, PAVGSUB2,

        // Parallel max
        PMAX1, PMAX2,

        // Parallel min
        PMIN1, PMIN2,

        // Parallel multiply
        PMPY2,

        // Parallel multiply and shift right
        PMPYSHR2,

        // Population count
        POPCOUNT,

        // Probe access
        PROBE_R, PROBE_W, PROBE_RW,

        // Parallel sum absolute difference
        PSAD1,

        // Parallel shift left
        PSHL2, PSHL4,

         // Parallel shift left and add
        PSHLADD2,

        // Parallel shift right
        PSHR2, PSHR4,

         // Parallel shift right and add
        PSHRADD2,

        // Parallel subtract half (other lengths in x86)
        PSUB2,

        // Purge Translation Cache
        PTC_E, PTC_G, PTC_GA, PTC_L,

        // Purge Translation Register
        PTR_I, PTR_D,

        // Reset System/User Mask
        RSM, RUM,

        // Set Floating Point Value, Exponents or Significand
        SETF_SINGLE, SETF_DOUBLE, SETF_EXP, SETF_SIG,

        // Shift left and add
        SHLADD, SHLADDP4,

        // Shift right pair
        SHRP,

        // Serialize
        SRLZ_I,  SRLZ_D,

        // Set System Mask
        SSM,

        // Set user mask
        SUM,

        // Sign Extension
        SXT4, SXT2, SXT1,

        // Memory synchronization
        SYNC,

        // Translation access key
        TAK,

        // Translation hashed entry address
        THASH,

        // Translate to physical address
        TPA,

        // Translation hashed entry tag
        TTAG,

        // Unpack
        UNPACK1, UNPACK2, UNPACK4,

        // Exchange
        XCHG1, XCHG2, XCHG4, XCHG8,

        // xma -- fixed point multiply and accumulate
        XMA_LOW, XMA_HIGH, XMA_HIGH_UNSIGNED,

        // Zero Extend
        ZXT4, ZXT2, ZXT1,

        // END: IA64 specifics

        // UNDONE: To be moved near all the MOV instructions
        ICMOVO,       ICMOVNO,      ICMOVB,       ICMOVAE,
        ICMOVE,       ICMOVNE,      ICMOVBE,      ICMOVA,

        ICMOVS,       ICMOVNS,      ICMOVPE,      ICMOVNP,
        ICMOVL,       ICMOVGE,      ICMOVLE,      ICMOVG,

        ICMOVOW,      ICMOVNOW,     ICMOVBW,      ICMOVAEW,
        ICMOVEW,      ICMOVNEW,     ICMOVBEW,     ICMOVAW,

        ICMOVSW,      ICMOVNSW,     ICMOVPEW,     ICMOVNPW,
        ICMOVLW,      ICMOVGEW,     ICMOVLEW,     ICMOVGW,

        ISYSCALL,     ISYSENTER,

        MMXPMINUB,    MMXPAVGB,     MMXPAVGW,     MMXPMAXSW,
        MMXMASKMOVQ,  MMXPMULHUW,   MMXPMAXUB,    MMXPSADBW,
        MMXPMINSW,    MMXPSHUFW,    MOVNTQ,       CMPSS,
        CMPPS,

        MOVWO,
        IPAUSE,
        KATMAI3,      // For overloaded non-escaped opcodes


        // AXP Instructions

        // UNDONE: all instructions are here; need to figure out which
        // ones should be mapped to 'generic' IR opcodes.

        // Ones commented out are duplicates of previous opcodes

        //ADDD,
        ADDF, ADDG, ADDL,
        ADDL_V, ADDQ, ADDQ_V, ADDS, ADDT,
        AMASK, AND,
        BIC, BIS,
        CALL_PAL,
        CMOVEQ, CMOVGE, CMOVGT, CMOVLBC, CMOVLBS, CMOVLE, CMOVLT, CMOVNE,
        CMPBGE, CMPDEQ, CMPDLE, CMPDLT, CMPEQ, CMPGEQ, CMPGLE, CMPGLT, CMPLE,
        CMPLT, CMPTEQ, CMPTLE, CMPTLT, CMPTUN, CMPULE, CMPULT,
        CPYS, CPYSE, CPYSEE, CPYSN,
        CTLZ, CTPOP, CTTZ,
        CVTDF, CVTDG, CVTDQ, CVTFG, CVTGD, CVTGF, CVTGQ, CVTLQ,
        CVTQD, CVTQF, CVTQG, CVTQL, CVTQS, CVTQT, CVTTQ, CVTTS,
        DIVD, DIVF, DIVG, DIVS, DIVT,
        ECB, EQV,
        EXCB, EXTBL, EXTLH, EXTLL, EXTQH, EXTQL, EXTWH, EXTWL,
        FCMOVEQ, FCMOVGE, FCMOVGT, FCMOVLE, FCMOVLT,
        //FCMOVNE,
        FETCH, FETCH_M,
        FTOIS, FTOIT,
        HW_LD, HW_MFPR, HW_MTPR, HW_REI, HW_ST,
        IMPLVER,
        INSBL, INSLH, INSLL, INSQH, INSQL, INSWH, INSWL,
        ITOFF, ITOFS, ITOFT,
        LDA, LDAH, LDBU, LDF, LDG, LDL, LDL_L,
        LDQ, LDQ_L, LDQ_U, LDS, LDT, LDWU,
        MAXSB8, MAXSW4, MAXUB8, MAXUW4,
        MB, MB2, MB3,
        MF_FPCR,
        MINSB8, MINSW4, MINUB8, MINUW4,
        MSKBL, MSKLH, MSKLL, MSKQH, MSKQL, MSKWH, MSKWL,
        MT_FPCR,
        MULD, MULF, MULG, MULL, MULL_V, MULQ, MULQ_V, MULS, MULT,
        ORNOT, PERR, PKLB, PKWB,
        RC,
        RPCC, RS,
        S4ADDL, S4ADDQ, S4SUBL, S4SUBQ,
        S8ADDL, S8ADDQ, S8SUBL, S8SUBQ,
        SEXTB, SEXTW,
        SLL,
        SQRTF, SQRTG, SQRTS, SQRTT,
        SRA, SRL,
        //STB, STW,
        STF, STG, STL, STL_C, STQ, STQ_C, STQ_U, STS, STT,
        //SUBD,
        SUBF, SUBG, SUBL, SUBL_V, SUBQ, SUBQ_V, SUBS, SUBT,
        TRAPB,
        UMULH,
        UNPKBL, UNPKBW,
        WH64, WMB,
        XOR,
        ZAP, ZAPNOT,
        PADD, PARCP, PARCPH, PARCPL,
        PARSQRT, PARSQRTH, PARSQRTL,
        PCADD, PCMPEQ, PCMPLE, PCMPLT, PCMPNEQ, PCMPUN,
        PCPYS, PCPYSE, PCPYSN, PCSUB, PCVTFI, PCVTSP,
        PEXTH, PEXTL, PFMAX, PFMIN,
        PHADD, PHRSUB, PHSUB, PMOVHH,
        PMOVHL, PMOVLH, PMOVLL,
        PMUL, PMULH, PMULHN, PMULL, PMULLN, PSUB,

        // AXP Pseudo Instructions

        //BR,
        CLR, CVTST, CVTST_S,
        //FABS,
        FCLR, FMOV, FNEG,
        //FNOP,
        //MF_FPCR,
        MOV,
        //MT_FPCR,
        NEGF, NEGG, NEGL, NEGL_V, NEGQ, NEGQ_V, NEGS, NEGT,
        //NOP,
        NOT, SEXTL, UNOP,

        // End AXP Instructions

        // MSIL Instructions -- from tools\dis\inc\opcode.def
        // All real MSIL instructions must be enclosed between the
        // two pseudo instructions MSIL_BEGIN_MARKER and MSIL_END_MARKER.
        //
        MSIL_BEGIN_MARKER,
        CEE_NOP,
        CEE_BREAK,
        CEE_LDARG_0,
        CEE_LDARG_1,
        CEE_LDARG_2,
        CEE_LDARG_3,
        CEE_LDLOC_0,
        CEE_LDLOC_1,
        CEE_LDLOC_2,
        CEE_LDLOC_3,
        CEE_STLOC_0,
        CEE_STLOC_1,
        CEE_STLOC_2,
        CEE_STLOC_3,
        CEE_LDARG_S,
        CEE_LDARGA_S,
        CEE_STARG_S,
        CEE_LDLOC_S,
        CEE_LDLOCA_S,
        CEE_STLOC_S,
        CEE_LDNULL,
        CEE_LDC_I4_M1,
        CEE_LDC_I4_0,
        CEE_LDC_I4_1,
        CEE_LDC_I4_2,
        CEE_LDC_I4_3,
        CEE_LDC_I4_4,
        CEE_LDC_I4_5,
        CEE_LDC_I4_6,
        CEE_LDC_I4_7,
        CEE_LDC_I4_8,
        CEE_LDC_I4_S,
        CEE_LDC_I4,
        CEE_LDC_I8,
        CEE_LDC_R4,
        CEE_LDC_R8,
        CEE_LDPTR,
        CEE_DUP,
        CEE_POP,
        CEE_JMP,
        CEE_CALL,
        CEE_CALLI,
        CEE_RET,
        CEE_BR_S,
        CEE_BRFALSE_S,
        CEE_BRTRUE_S,
        CEE_BEQ_S,
        CEE_BGE_S,
        CEE_BGT_S,
        CEE_BLE_S,
        CEE_BLT_S,
        CEE_BNE_UN_S,
        CEE_BGE_UN_S,
        CEE_BGT_UN_S,
        CEE_BLE_UN_S,
        CEE_BLT_UN_S,
        CEE_BR,
        CEE_BRFALSE,
        CEE_BRTRUE,
        CEE_BEQ,
        CEE_BGE,
        CEE_BGT,
        CEE_BLE,
        CEE_BLT,
        CEE_BNE_UN,
        CEE_BGE_UN,
        CEE_BGT_UN,
        CEE_BLE_UN,
        CEE_BLT_UN,
        CEE_SWITCH,
        CEE_LDIND_I1,
        CEE_LDIND_U1,
        CEE_LDIND_I2,
        CEE_LDIND_U2,
        CEE_LDIND_I4,
        CEE_LDIND_U4,
        CEE_LDIND_I8,
        CEE_LDIND_I,
        CEE_LDIND_R4,
        CEE_LDIND_R8,
        CEE_LDIND_REF,
        CEE_STIND_REF,
        CEE_STIND_I1,
        CEE_STIND_I2,
        CEE_STIND_I4,
        CEE_STIND_I8,
        CEE_STIND_R4,
        CEE_STIND_R8,
        CEE_ADD,
        CEE_SUB,
        CEE_MUL,
        CEE_DIV,
        CEE_DIV_UN,
        CEE_REM,
        CEE_REM_UN,
        CEE_AND,
        CEE_OR,
        CEE_XOR,
        CEE_SHL,
        CEE_SHR,
        CEE_SHR_UN,
        CEE_NEG,
        CEE_NOT,
        CEE_CONV_I1,
        CEE_CONV_I2,
        CEE_CONV_I4,
        CEE_CONV_I8,
        CEE_CONV_R4,
        CEE_CONV_R8,
        CEE_CONV_U4,
        CEE_CONV_U8,
        CEE_CALLVIRT,
        CEE_CPOBJ,
        CEE_LDOBJ,
        CEE_LDSTR,
        CEE_NEWOBJ,
        CEE_CASTCLASS,
        CEE_ISINST,
        CEE_CONV_R_UN,
        CEE_ANN_DATA_S,
        CEE_BOX,
        CEE_UNBOX,
        CEE_THROW,
        CEE_LDFLD,
        CEE_LDFLDA,
        CEE_STFLD,
        CEE_LDSFLD,
        CEE_LDSFLDA,
        CEE_STSFLD,
        CEE_STOBJ,
        CEE_CONV_OVF_I1_UN,
        CEE_CONV_OVF_I2_UN,
        CEE_CONV_OVF_I4_UN,
        CEE_CONV_OVF_I8_UN,
        CEE_CONV_OVF_U1_UN,
        CEE_CONV_OVF_U2_UN,
        CEE_CONV_OVF_U4_UN,
        CEE_CONV_OVF_U8_UN,
        CEE_CONV_OVF_I_UN,
        CEE_CONV_OVF_U_UN,
        CEE_UNUSED49,
        CEE_NEWARR,
        CEE_LDLEN,
        CEE_LDELEMA,
        CEE_LDELEM_I1,
        CEE_LDELEM_U1,
        CEE_LDELEM_I2,
        CEE_LDELEM_U2,
        CEE_LDELEM_I4,
        CEE_LDELEM_U4,
        CEE_LDELEM_I8,
        CEE_LDELEM_I,
        CEE_LDELEM_R4,
        CEE_LDELEM_R8,
        CEE_LDELEM_REF,
        CEE_STELEM_I,
        CEE_STELEM_I1,
        CEE_STELEM_I2,
        CEE_STELEM_I4,
        CEE_STELEM_I8,
        CEE_STELEM_R4,
        CEE_STELEM_R8,
        CEE_STELEM_REF,
        CEE_UNUSED2,
        CEE_UNUSED3,
        CEE_UNUSED4,
        CEE_UNUSED5,
        CEE_UNUSED6,
        CEE_UNUSED7,
        CEE_UNUSED8,
        CEE_UNUSED9,
        CEE_UNUSED10,
        CEE_UNUSED11,
        CEE_UNUSED12,
        CEE_UNUSED13,
        CEE_UNUSED14,
        CEE_UNUSED15,
        CEE_UNUSED16,
        CEE_UNUSED17,
        CEE_CONV_OVF_I1,
        CEE_CONV_OVF_U1,
        CEE_CONV_OVF_I2,
        CEE_CONV_OVF_U2,
        CEE_CONV_OVF_I4,
        CEE_CONV_OVF_U4,
        CEE_CONV_OVF_I8,
        CEE_CONV_OVF_U8,
        CEE_UNUSED50,
        CEE_UNUSED18,
        CEE_UNUSED19,
        CEE_UNUSED20,
        CEE_UNUSED21,
        CEE_UNUSED22,
        CEE_UNUSED23,
        CEE_REFANYVAL,
        CEE_CKFINITE,
        CEE_UNUSED24,
        CEE_UNUSED25,
        CEE_MKREFANY,
        CEE_ANN_CALL,
        CEE_ANN_CATCH,
        CEE_ANN_DEAD,
        CEE_ANN_HOISTED,
        CEE_ANN_HOISTED_CALL,
        CEE_ANN_LAB,
        CEE_ANN_DEF,
        CEE_ANN_REF_S,
        CEE_ANN_PHI,
        CEE_LDTOKEN,
        CEE_CONV_U2,
        CEE_CONV_U1,
        CEE_CONV_I,
        CEE_CONV_OVF_I,
        CEE_CONV_OVF_U,
        CEE_ADD_OVF,
        CEE_ADD_OVF_UN,
        CEE_MUL_OVF,
        CEE_MUL_OVF_UN,
        CEE_SUB_OVF,
        CEE_SUB_OVF_UN,
        CEE_ENDFINALLY,
        CEE_LEAVE,
        CEE_LEAVE_S,
        CEE_STIND_I,
        CEE_CONV_U,
        CEE_UNUSED26,
        CEE_UNUSED27,
        CEE_UNUSED28,
        CEE_UNUSED29,
        CEE_UNUSED30,
        CEE_UNUSED31,
        CEE_UNUSED32,
        CEE_UNUSED33,
        CEE_UNUSED34,
        CEE_UNUSED35,
        CEE_UNUSED36,
        CEE_UNUSED37,
        CEE_UNUSED38,
        CEE_UNUSED39,
        CEE_UNUSED40,
        CEE_UNUSED41,
        CEE_UNUSED42,
        CEE_UNUSED43,
        CEE_UNUSED44,
        CEE_UNUSED45,
        CEE_UNUSED46,
        CEE_UNUSED47,
        CEE_UNUSED48,
        CEE_PREFIX7,
        CEE_PREFIX6,
        CEE_PREFIX5,
        CEE_PREFIX4,
        CEE_PREFIX3,
        CEE_PREFIX2,
        CEE_PREFIX1,
        CEE_PREFIXREF,
        CEE_ARGLIST,
        CEE_CEQ,
        CEE_CGT,
        CEE_CGT_UN,
        CEE_CLT,
        CEE_CLT_UN,
        CEE_LDFTN,
        CEE_LDVIRTFTN,
        CEE_JMPI,
        CEE_LDARG,
        CEE_LDARGA,
        CEE_STARG,
        CEE_LDLOC,
        CEE_LDLOCA,
        CEE_STLOC,
        CEE_LOCALLOC,
        CEE_UNUSED57,
        CEE_ENDFILTER,
        CEE_UNALIGNED,
        CEE_VOLATILE,
        CEE_TAILCALL,
        CEE_INITOBJ,
        CEE_ANN_LIVE,
        CEE_CPBLK,
        CEE_INITBLK,
        CEE_ANN_REF,
        CEE_RETHROW,
        CEE_UNUSED51,
        CEE_SIZEOF,
        CEE_REFANYTYPE,
        CEE_UNUSED52,
        CEE_UNUSED53,
        CEE_UNUSED54,
        CEE_UNUSED55,
        CEE_ANN_DATA,
        CEE_ILLEGAL,
        CEE_MACRO_END,
        MSIL_END_MARKER,
        // End MSIL Instructions.

        EOpMax,

        // Special opcodes for X86 escaped opcode groups
        G0=0,   G1=1,   G2=2,   G3=3,   G4=4,   G5=5,   G6=6,   G7=7,
        G8=8,   G9=9,   G10=10, G11=11, G12=12, G13=13, G14=14, G15=15,
        G16=16, G17=17, G18=18, G19=19, G20=20, G21=21
    };

    enum LVMOp
    {
        AddF4, ConvertF8F4, DivF4, LoadF4, MulF4, NegF4, PushConstF4, PushRefF4,
        PushRegF4, SubF4, AddF8, ConvertF4F8, ConvertI8F8, DivF8, LoadF8, MulF8,
        NegF8, PushConstF8, PushRefF8, PushRegF8, SubF8, EqF4, EqF8, EqI1,
        EqI2, EqI4, EqI8, EqU1, EqU2, EqU4, EqU8, GeF4,
        GeF8, GeI1, GeI2, GeI4, GeI8, GeU1, GeU2, GeU4,
        GeU8, GtF4, GtF8, GtI1, GtI2, GtI4, GtI8, GtU1,
        GtU2, GtU4, GtU8, LeF4, LeF8, LeI1, LeI2, LeI4,
        LeI8, LeU1, LeU2, LeU4, LeU8, LtF4, LtF8, LtI1,
        LtI2, LtI4, LtI8, LtU1, LtU2, LtU4, LtU8, NeF4,
        NeF8, NeI1, NeI2, NeI4, NeI8, NeU1, NeU2, NeU4,
        NeU8, AddI1, AddU1, AndU1, DivI1, DivU1, LShiftI1, LShiftU1,
        LoadU1, ModI1, ModU1, MulI1, MulU1, NarrowI2I1, NarrowU2U1, NegI1,
        NotU1, OrU1, PushConstU1, PushRefU1, PushRegU1, RShiftI1,RShiftU1,SubI1,
        SubU1, XorU1, AddI2, AddU2, AndU2, DivI2, DivU2, ExtendI1I2,
        ExtendU1U2, LShiftI2, LShiftU2, LoadU2, ModI2, ModU2, MulI2, MulU2,
        NarrowI4I2, NarrowU4U2,NegI2,NotU2,OrU2,PushConstU2,PushRefU2,PushRegU2,
        RShiftI2, RShiftU2, SubI2, SubU2, XorU2, AddI4, AddU4, AndU4,
        DivI4, DivU4, ExtendI2I4, ExtendU2U4, LShiftI4, LShiftU4, LoadU4, ModI4,
        ModU4, MulI4, MulU4, NegI4, NotU4, OrU4, PushConstU4, PushRefU4,
        PushRegU4, RShiftI4, RShiftU4, SubI4, SubU4, XorU4, AddI8, AddU8,
        AndU8, ConvertF8I8, DivI8,DivU8,ExtendI4I8,ExtendU4U8,LShiftI8,LShiftU8,
        LoadU8, ModI8, ModU8, MulI8, MulU8, NegI8, NotU8, OrU8,
        PushConstU8, PushRefU8, PushRegU8, RShiftI8, RShiftU8,SubI8,SubU8,XorU8,
        ConvertU4Ptr, BrFalse, BrTrue, Def, EndOfInput, Epilogue, Jsr, Jump,
        PopF4, PopF8, PopRegF4, PopRegF8, PopRegU1, PopRegU2, PopRegU4,PopRegU8,
        PopU1, PopU2, PopU4, PopU8, Prologue, StoreF4, StoreF8, StoreU1,
        StoreU2, StoreU4, StoreU8, End
    };

    static VULCANDLL bool VULCANCALL IsMSIL(EOp eop)
    {
       return (eop > MSIL_BEGIN_MARKER && eop < MSIL_END_MARKER);
    }

    static VULCANDLL EOp VULCANCALL GetReverseCondBranchOpcode(EOp eop)
    {
        switch (eop)
        {
            case BULT: return BUGE;
            case BULE: return BUGT;
            case BUGT: return BULE;
            case BUGE: return BULT;

            case BLT:  return BGE;
            case BLE:  return BGT;
            case BGT:  return BLE;
            case BGE:  return BLT;

            case BO:   return BNO;
            case BNO:  return BO;
            case BP:   return BNP;
            case BNP:  return BP;

            case BS:   return BNS;
            case BNS:  return BS;
            case BZ:   return BNZ;
            case BNZ:  return BZ;

            case BEQ:  return BNE;
            case BNE:  return BEQ;

            case CEE_BEQ:        return CEE_BNE_UN;
            case CEE_BEQ_S:      return CEE_BNE_UN_S;
            case CEE_BGE:        return CEE_BLT;
            case CEE_BGE_S:      return CEE_BLT_S;
            case CEE_BGE_UN:     return CEE_BLT_UN;
            case CEE_BGE_UN_S:   return CEE_BLT_UN_S;
            case CEE_BGT:        return CEE_BLE;
            case CEE_BGT_S:      return CEE_BLE_S;
            case CEE_BGT_UN:     return CEE_BLE_UN;
            case CEE_BGT_UN_S:   return CEE_BLE_UN_S;
            case CEE_BLE:        return CEE_BGT;
            case CEE_BLE_S:      return CEE_BGT_S;
            case CEE_BLE_UN:     return CEE_BGT_UN;
            case CEE_BLE_UN_S:   return CEE_BGT_UN_S;
            case CEE_BLT:        return CEE_BGE;
            case CEE_BLT_S:      return CEE_BGE_S;
            case CEE_BLT_UN:     return CEE_BGE_UN;
            case CEE_BLT_UN_S:   return CEE_BGE_UN_S;
            case CEE_BNE_UN:     return CEE_BEQ;
            case CEE_BNE_UN_S:   return CEE_BEQ_S;

            case CEE_BRTRUE:     return CEE_BRFALSE;
            case CEE_BRFALSE:    return CEE_BRTRUE;
            case CEE_BRTRUE_S:   return CEE_BRFALSE_S;
            case CEE_BRFALSE_S:  return CEE_BRTRUE_S;

            default:   break;
        }

        return(eop);   // return the old opcode with no change
    }

    static VULCANDLL bool VULCANCALL IsCondBranchReversable(EOp eop)
    {
       if ((eop >= BULT && eop <= BNE))
       {
          return (true);
       }

       // MSIL
       if ((eop >= CEE_BEQ && eop <= CEE_BLT_UN) || (eop >= CEE_BEQ_S && eop <= CEE_BLT_UN_S))
       {
          return (true);
       }

       if ((eop == CEE_BRFALSE ||
            eop == CEE_BRTRUE ||
            eop == CEE_BRFALSE_S ||
            eop == CEE_BRTRUE_S))
       {
          return (true);
       }

       return (false);
    }

    static VULCANDLL bool VULCANCALL IsCondBranch(EOp eop)
    {
       if (eop >= BULT && eop <= IBCXZ)
       {
          return (true);
       }

       // MSIL
       if ((eop >= CEE_BEQ && eop <= CEE_BLT_UN) || (eop >= CEE_BEQ_S && eop <= CEE_BLT_UN_S))
       {
          return (true);
       }

       if ((eop == CEE_BRFALSE ||
            eop == CEE_BRTRUE ||
            eop == CEE_BRFALSE_S ||
            eop == CEE_BRTRUE_S))
       {
          return (true);
       }

       return (false);
    }

    static VULCANDLL bool VULCANCALL IsUnCondBranch(EOp eop)
    {
       return ((eop >= JMP  && eop <= JSR_COROUTINE_JMPI) ||
               eop == CEE_BR || eop == CEE_BR_S ||
               eop == CEE_LEAVE || eop == CEE_LEAVE_S);
    }

    static VULCANDLL bool VULCANCALL IsRet(EOp eop)
    {
       return ((eop >= RET  && eop <= RET_JMPI) || eop == CEE_RET );
    }

    static VULCANDLL bool VULCANCALL IsCall(EOp eop)
    {
       return ((eop >= CALL && eop <= JSR_COROUTINE_CALLI) ||
               eop == CEE_CALL || eop == CEE_CALLI ||
               eop == CEE_NEWOBJ || eop == CEE_JMP || eop == CEE_JMPI );
    }

    static VULCANDLL bool VULCANCALL IsIA64Compare(EOp op)
    {
       switch (op)
       {
          case COp::FCMP_EQ:
          case COp::FCMP_LT:
          case COp::FCMP_LE:
          case COp::FCMP_UNORD:

          case COp::CMP_EQ:
          case COp::CMP_LT:
          case COp::CMP_LTU:
          case COp::CMP_NE:
          case COp::CMP_LE:
          case COp::CMP_GT:
          case COp::CMP_GE:

          case COp::CMP4_EQ:
          case COp::CMP4_LT:
          case COp::CMP4_LTU:
          case COp::CMP4_NE:
          case COp::CMP4_LE:
          case COp::CMP4_GT:
          case COp::CMP4_GE:

          case COp::TBIT_Z:
          case COp::TBIT_NZ:

          case COp::TNAT_Z:
          case COp::TNAT_NZ:

          case COp::PCMP1_EQ:
          case COp::PCMP1_GT:
          case COp::PCMP2_EQ:
          case COp::PCMP2_GT:
          case COp::PCMP4_EQ:
          case COp::PCMP4_GT:

             return true;

          default:

             return false;
       }
    }

    static VULCANDLL bool VULCANCALL Is2SlotInstruction(EOp eop)
    {
       return ((eop >= BRL_CALL_SPNT_FEW && eop <= BRL_CALL_DPTK_MANY) ||
               (eop >= BRL_COND_SPNT_FEW && eop <= BRL_COND_DPTK_MANY) ||
                eop == MOVL || eop == NOP_X || eop == BREAK_X);
    }

    static VULCANDLL bool VULCANCALL IsIA64CheckInstruction(EOp eop)
    {
        return eop == CHK_S || eop == CHK_A;
    }

    static VULCANDLL bool VULCANCALL IsData(EOp eop)
        {return eop == DATA;}

    static VULCANDLL bool VULCANCALL IsAddr(EOp eop)
        {return eop == ADDR;}

    static VULCANDLL bool VULCANCALL IsLoop(EOp eop)
        {return (eop >= ILOOPN && eop <=ILOOPE);}

    static VULCANDLL const char * VULCANCALL OpcodeStr(EOp eop);
    static VULCANDLL EOpGroup VULCANCALL OpcodeGrp(EOp eop);
    static VULCANDLL const char * VULCANCALL OpcodeGrpStr(EOp eop);
};

typedef COp::EOp EOpcodes;
typedef COp::EOpGroup EOpGrp;
typedef enum IA64Completers ECompleters;

#endif //__VULCANIENUM__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\Vulcan\inc\vulcanpa.h ===
/***********************************************************************
* Microsoft Vulcan
*
* Microsoft Confidential.  Copyright 1997-1999 Microsoft Corporation.
*
* File: vulcanpa.h
*
* File Comments:
*
*
***********************************************************************/

#pragma once

#include <string.h>

// Padding is an optimization to help workset and cache behaivor.
// See the paper "Improving cache behavior of dynamically allocated data
// structures" by Dan N. Troung et al.

// UNDONE: Padding is all wrong for IA64 hosting - turn it off for now.
#ifdef _M_IA64
#define VULCAN_PA_OFF
#endif

//Don't create an instance of CPad except through the #define below.  This will allow padding to be turned on and off easily.
struct CPad {
   enum {PADSIZE=4092};

   static void VULCANCALL Memset(void* vp,int value,int size) {

      if (size > PADSIZE) {
               for (char* i=(char*)vp;i<(char*)vp + size;i+=PADSIZE+4) {
                   int* j = (int*) i;
               *j=value;
               }
      } else {
         memset(vp,value,size);
      }

   }

   static void VULCANCALL Memcpy(void* dest,void* src,int size){
      if (size > PADSIZE) {
         int* d = (int*) dest;
         int* s = (int*) src;
         for (int i=0;i<size/4;i+=(PADSIZE+4)/4) {
            d[i] = s[i];
         }
      } else {
         memcpy(dest,src,size);
      }

   }
private:
    char m_pad[PADSIZE];
};


#ifdef VULCAN_PA_OFF
#define CPAD(ID)
#else
#define CPAD(ID) CPad  m_pad##ID;
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\Vulcan\inc\VulcanEX.h ===
/***********************************************************************
* Microsoft Vulcan
*
* Microsoft Confidential.  Copyright 1997-1999 Microsoft Corporation.
*
* File: Vulcanex.h
*
* File Comments:
*
*
***********************************************************************/


#ifndef __VULCANAPI__
#error  This file should be included via vulcanapi.h
#endif

class VSrcInfo
{
public:
    // Returns the file name (exactly as it appears in the pdb information)
    VULCANDLL const char *FileName();

    // Returns the line number
    VULCANDLL int LineStart();
protected:
    VSrcInfo();
    ~VSrcInfo();
};

class VSrcIter
{
public:
    inline VSrcIter();
    inline VSrcIter( VSrcIter &v);

    inline VSrcInfo        *Curr() const;
    inline bool             Done() const;
    inline bool             IsEmpty() const;
    inline size_t           Length() const;
    VULCANDLL void          MoveToFirst();
    VULCANDLL void          MoveToLast();
    VULCANDLL void          Next();
    VULCANDLL void          Prev();

protected:
    VSrcInfo *m_pSrcCur;
    int m_cSrcAfter;
    int m_cSrcBefore;
};

class VSect : public CDListElem_VSect
{
public:
    // Get the component this section is in
    virtual VComp *ParentComp() = 0;

    // Get the first/last/next/prev section in the componennt
    virtual VSect* Next() = 0;
    virtual VSect* Prev() = 0;
    virtual VSect* First() = 0;
    virtual VSect* Last() = 0;

    // Insert a section before/after this section
    virtual void InsertPrev(VSect*) = 0;
    virtual void InsertNext(VSect*) = 0;

    // Remove this section from the component
    virtual void Remove() = 0;

    // Get the first code procedure in this section
    // Don't forget to use (Prev/Next)SectProc to iterate
    virtual VProc* FirstProc() = 0;
    virtual VProc* LastProc() = 0;

    // Get the first procedure in this section (code or data)
    // Don't forget to use (Prev/Next)AllSectProc to iterate
    virtual VProc* FirstAllProc() = 0;
    virtual VProc* LastAllProc() = 0;

    // Add the first/last proc in this section
    virtual void InsertFirstProc(VProc *) = 0;
    virtual void InsertLastProc(VProc *) = 0;

    // How many code procs in this section
    virtual size_t CountProcs() = 0;

    // How many procs (code or data) in this section
    virtual size_t CountAllProcs() = 0;

    // Get the name of this section
    virtual const char *Name() = 0;


    // Get the address of this section
    virtual ADDR Addr() = 0;

    // Get the file offset to this section.
    virtual size_t FileOffset() = 0;

    // Get the raw size (on file) of this section.
    virtual size_t RawSize() = 0;

    // Get the initial size of this section
    virtual size_t Size() = 0;

    // Get a pointer to the raw bytes of the section
    virtual const void *Raw(VComp *pComp) = 0;

    // Create a new, empty procedure in this section
    virtual VProc *NewProc( const char *Name) = 0;
    virtual VProc *NewProc() = 0;

    // Is this section Executable
    virtual bool IsExecutable() = 0;

    // Is this section Inserted
    virtual bool IsInserted() = 0;

    // Is this section Read-Only
    virtual bool IsReadOnly() = 0;

    // Is this section Read-Write
    virtual bool IsReadWrite() = 0;

    // Is this section Regenerated?
    virtual bool IsRegenerated() = 0;

    // Is this section Resource
    virtual bool IsResource() = 0;

    // Get the flags of this section (SectionFlags)
    virtual DWORD Flags() = 0;

    // Delete this section
    virtual void Destroy() = 0;

    // Get the emitted size of this section (only available after VComp::Write())
    virtual size_t SizeEmit() = 0;

    // Get the emitted address of this section (only available after VComp::Write())
    virtual ADDR AddrEmit() = 0;

    // Set Callback function for the linker
    typedef void (VULCANCALL *PFNLINKCALLBACK)(VSect *, void *);
    virtual void SetCallBackForLink(PFNLINKCALLBACK pfn) = 0;

    typedef bool (VULCANCALL *PFNAACALLBACK)(VSect *);
    virtual void SetCallBackForAssignAddr( PFNAACALLBACK pfn) = 0;
};


template <class T>
class VKIter : public CKDListIter<T>
{
public:
    VKIter( const CKDListIter<T> &t ) : CKDListIter<T>( t ) {}
    VKIter()                          : CKDListIter<T>()    {}

    void          AddNext(T t)      {CKDListIter<T>::AddNext(t);}
    void          AddLast(T t)      {CKDListIter<T>::AddLast(t);}
    void          AddPrev(T t)      {CKDListIter<T>::AddPrev(t);}
    void          AddFirst(T t)     {CKDListIter<T>::AddFirst(t);}
    T             Curr() const      {return CKDListIter<T>::Curr();}
    T             Delete()          {return CKDListIter<T>::Delete();}
    bool          Done() const      {return CKDListIter<T>::Done();}
    bool          IsEmpty() const   {return CKDListIter<T>::IsEmpty();}
    bool          IsFirst() const   {return CKDListIter<T>::IsFirst();}
    bool          IsLast() const    {return CKDListIter<T>::IsLast();}
    size_t        Length() const    {return CKDListIter<T>::Length();}
    void          MoveToFirst()     {CKDListIter<T>::MoveToFirst();}
    void          MoveToLast()      {CKDListIter<T>::MoveToLast();}
    void          Next()            {CKDListIter<T>::Next();}
    void          Prev()            {CKDListIter<T>::Prev();}
};
typedef VKIter<VReloc *> VRelocIter;

class VReloc : CKDListElem<VReloc *>
{
public:
    // A "Reloc" is used to describe a pointer from a data block to another part of the executable.
    // The relocs allow the data in the block to be updated to the right number during linking and loading of the component.

    // The thing pointed at is desribed by a block and an offset
    VULCANDLL VBlock  *RelocTarget();
    VULCANDLL size_t   OffsetTarget();
    VULCANDLL VInst   *InstTarget();

    // The location of the pointer in the data block is also desribed by an offset.
    VULCANDLL size_t   OffsetReloc();

    // The pointers can different types
    enum Type
    {
        Absolute = 0,       // Absolute pointer (these are 32 or 64 bits depending on archicture)
        BaseRelative32 = 1, // Relative to the base of the image
        BaseRelative24 = 2, // Relative to the base of the image (max 16MB!)
        SectRelative8 = 3,  // Relative to the beginning of a section (1 byte long)
        SectRelative32 = 4, // Relative to the beginning of a section (full size)
        PcRelative32 = 5,   // Relative to the byte after the pointer
        UnknownType = 64,
    };
    VULCANDLL Type RelocType();

    // Move the reloc's target block
    VULCANDLL void SetRelocTarget(VBlock *pBlk);

    // For creating your own Data blocks with relocs in them (then add them to the reloc iter for the block)
    static VULCANDLL VReloc * VULCANCALL Create(VBlock *reloctarget, size_t offsettarget, size_t offsetreloc, Type type );
    static VULCANDLL VReloc * VULCANCALL Create(VInst *pInstTarget, size_t offsetreloc, Type type);

    //Destroy the reloc when you are done with it
    VULCANDLL void Destroy();
protected:
    VReloc() {}
    ~VReloc() {}
};

class VOperand
{
public:
    inline VOperand();
    inline VOperand(VOperand &v);

    inline VOperand( ERegister reg );
    inline VOperand( VAddress *pAddr );
    inline VOperand( long immed );
    inline VOperand( VBlock *pBlk );
    inline VOperand( VBlock *pBlk, long offset );
    inline VOperand( VInst *pInst );
    inline VOperand( BYTE *pb );

    // Returns the type of the operand - then use the methods before to retrieve specifics
    inline EOpndTypes Type();

    // Type() == OpndReg or OpndRegPair
    inline ERegister Register();

    // Type() == OpndAddress - indirect references to memory
    // constant because you shouldn't modify it (you can copy it to change it)
    inline const VAddress *Address();

    // Type() == OpndImmediate, OpndAddress, or OpndGenAddressBlock (otherwise returns 0)
    inline long Immediate();

    // Type() == OpndBlock, OpndAddress, or OpndGenAddressBlock (otherwise returns NULL)
    inline VBlock * Block();

    // Type() == OpndGenAddressBlock and !Block()->IsDataBlock()
    inline VInst * Inst();

    // Type() == Anything - give me it as a void
    inline void * Anything();

    // Modifying operands.. they can modify the type of operand, and will fail if it does not make sense
    inline bool SetBlock( VBlock * );
    inline bool SetImmediate( long );
    inline bool SetInst( VInst * );


private:
    static VULCANDLL VBlock * VULCANCALL BlockGA(void *operand);
    static VULCANDLL long VULCANCALL ImmediateGA(void *operand);
    static VULCANDLL VInst * VULCANCALL InstGA(void *operand);
    static VULCANDLL void *VULCANCALL CreateGA(VBlock *, long);
    static VULCANDLL void *VULCANCALL CreateGA(VInst *);
protected:
    void       *m_operand;
    EOpndTypes  m_type;
};

class VAddress
{
public:
    // An address can represent from just [ESP] to DS::[ESP + block + 4 + 4 * ECX]

    // Constuct an address like [ESP + 4]
    static VULCANDLL VAddress *VULCANCALL Create(ERegister reg, long disp);

    // Constuct an address like [pblock]
    static VULCANDLL VAddress *VULCANCALL Create(VBlock *pBlk, long disp = 0);

    // Constuct an address like [pinst]
    static VULCANDLL VAddress *VULCANCALL Create(VInst *pInst);

    // Empty construction (build with set functions below)
    static VULCANDLL VAddress *VULCANCALL Create();

    // Copy from const - if you want to change one
    static VULCANDLL VAddress *VULCANCALL Create(const VAddress *);

    // Base register (in [ESP + 4] ESP is the base register)
    VULCANDLL bool HasBaseReg() const;
    VULCANDLL ERegister BaseReg() const;
    VULCANDLL void SetBaseReg( ERegister reg );
    VULCANDLL void ClearBaseReg();

    // Offset (in [ESP + 4], the offset is 4)
    VULCANDLL long HasOffset() const;
    VULCANDLL long Offset() const;
    VULCANDLL void SetOffset(long offset);
    VULCANDLL void ClearOffset() {SetOffset(0);}

    // Inst (really block + offset of inst)
    VULCANDLL long HasInst() const;
    VULCANDLL VInst *Inst() const;
    VULCANDLL void SetInst(VInst *pInst);
    VULCANDLL void ClearInst();

    // Index register (in [ESP + 2 * EBX], EBX is the index register)
    VULCANDLL bool HasIndexReg() const;
    VULCANDLL ERegister IndexReg() const;
    VULCANDLL void SetIndexReg( ERegister reg );
    VULCANDLL void ClearIndexReg();

    // Scale (in [ESP + 2 * EBX], the scale is 2 (valid values are 1, 2, 4, 8)
    VULCANDLL int  Scale() const;
    VULCANDLL void SetScale(int scale);
    VULCANDLL void ClearScale() {SetScale(1);}

    // Block (in [pblock + 4], pblock is the block)
    VULCANDLL bool HasBlock() const;
    VULCANDLL VBlock *Block() const;
    VULCANDLL void SetBlock(VBlock *);
    VULCANDLL void ClearBlock() {SetBlock(NULL);}

    // Segment Override Register
    VULCANDLL bool HasSegReg() const;
    VULCANDLL ERegister SegReg() const;
    VULCANDLL void SetSegReg(ERegister reg);
    VULCANDLL void ClearSegReg();

    //Destroy the address when you are done with it
    VULCANDLL void Destroy();
};


typedef WORD ORD16;

class VExport : public CDListElem_VExport
{
public:
    // Get the next/prev export
    inline VExport *Prev();
    inline VExport *Next();
    inline VExport *First();
    inline VExport *Last();

    // Get the next/prev export of this same block
    inline VExport *NextProc();
    inline VExport *PrevProc();
    inline VExport *FirstProc();
    inline VExport *LastProc();

    // Get the ordinal that this export corresponds to
    VULCANDLL virtual ORD16 Ordinal() const = 0;

    // Set the ordinal
    VULCANDLL virtual void SetOrdinal(ORD16) = 0;

    // Get the name of this export
    VULCANDLL virtual const char *Name() const = 0;

    // Get the block that is exported (this will be NULL for exports forwarded to another component)
    VULCANDLL virtual VBlock *Block() const = 0;

    // Redirect this export to a new block. (Block must already be something or it fails!)
    VULCANDLL virtual bool Redirect(VBlock *, VComp *) = 0;

    // OBSOLETE: Use VExport::Redirect instead.
    VULCANDLL virtual bool SetBlock(VBlock *) = 0;

    // Get export module name.
    VULCANDLL virtual const char *ModuleName() const = 0;

    // Set export module name.
    // Note: This method changes the module name for all exports that shares the same module name.
    VULCANDLL virtual void SetModuleName(const char *) = 0;

    // Set name of this export.
    VULCANDLL virtual void SetName(const char *) = 0;
};


class VImport : public CDListElem_VImport
{
public:
    // Get next/prev/first/last import
    inline VImport *Next();
    inline VImport *Prev();
    inline VImport *First();
    inline VImport *Last();

    // Get the ordinal that this import corresponds to
    virtual DWORD Ordinal() = 0;

    // Get the name of this import
    virtual const char *Name() = 0;

    // Get the block calls to this import will call to
    virtual VBlock *Block() = 0;

    // Redirect the import to a new import
    virtual void Redirect(VImport *, VComp * = NULL) = 0;

    // Redirect the import to a local procedure
    virtual void Redirect(VProc *, VComp *) = 0;

    // (OBSOLETE): Use VImport::Redirect instead
    virtual void SetBlock(VBlock *, VComp * = NULL) = 0;

    // Get the name of the dll that is imported
    virtual const char *DllName() = 0;

    // is this a delay-load import
    virtual bool IsDelayLoad() = 0;

    // Has this import been redirected to another import?
    virtual bool IsRedirected() = 0;

    // Has this import been redirected to a proc.
    virtual bool IsRedirectedToProc() = 0;

    // Returns the proc that the import redirects to.
    virtual VProc *RedirectProc() = 0;
};

class VUserData
{
public:
    // Create a user-data object
    static VULCANDLL VUserData * VULCANCALL Create();

    // Free the user data resource associated with this object
    virtual void Destroy() = 0;

    // Remove all the user data associated with this object
    virtual void RemoveAll() = 0;

    // Get the data associated with key
    virtual void *GetUserData(void *pvKey) = 0;

    // Get the data associated with key
    virtual void SetUserData(void *pvData, void *pvKey) = 0;
};

class VDiff
{
public:
   enum EMatchType {DEFAULT};

   // Create a Diff
   static VULCANDLL VDiff* VULCANCALL Create(VComp* pComp1,VComp* pComp2,EMatchType type = DEFAULT );

   // Matches pBlk from either component to corrosponding VBBlock* in the other component.  return NULL if no match.
   virtual VBlock *Match(VBlock* pBlk) = 0;

   // Free up memory when done with diff.
   virtual void Destroy() = 0;

protected:
   VDiff() {}
   ~VDiff() {}
};


class VSymIter
{
public:
   VULCANDLL virtual const char   *SymName() = 0;              /* OBSOLETE */
   VULCANDLL virtual const char   *Name() = 0;                 /* OBSOLETE */
   VULCANDLL virtual bool         IsPublic() = 0;

   VULCANDLL virtual void         First() = 0;
   VULCANDLL virtual void         Next() = 0;
   VULCANDLL virtual void         Prev() = 0;
   VULCANDLL virtual bool         Done() = 0;
   VULCANDLL virtual void         Destroy() = 0;

   VULCANDLL virtual ADDR         Addr() = 0;      // may return NULL
   VULCANDLL virtual VBlock      *Block(DWORD *pib = NULL) = 0;     // may return NULL
   VULCANDLL virtual size_t       SymName(char *, size_t cb) = 0;
};

struct VAddrRange
{
   ADDR  addrBegin;
   ADDR  addrEnd;
};

class VSymbol : public CDListElem_VSymbol
{
public:

   // Get the name of the type
   virtual size_t Type(char *szBuf, size_t cchBuf, char **ppchName = NULL) = 0;

   // Get the symbol which this type corresponds to
   virtual const char *Name() = 0;

   // The register that this param/local is stored in (if it is)
   virtual bool IsInReg() = 0;
   virtual ERegister Register()= 0;

   // The offset of this param/local on the stack (the return address is at offset 0)
   virtual size_t Offset() = 0;

   // The size of the param/local
   virtual size_t Size() = 0;

   // Is this symbol implicit (not specified by the user)
   virtual bool IsImplicit() = 0;

   // Is this a pointer (and if it is, PTarget is the sybol under it (which could be another pointer))
   virtual bool IsPointer() = 0;
   virtual VSymbol *PTarget() = 0;

   // Is this type a primitive type (or enum)
   virtual bool IsPrimitive() = 0;

   // Is this primitive type signed?
   virtual bool IsSigned() = 0;

   // Bitfield accessors
   virtual bool IsBitField() = 0;
   virtual size_t BitOffset() = 0;
   virtual size_t BitSize() = 0;

   // Modifier accessors
   virtual bool IsConst() = 0;
   virtual bool IsVolatile() = 0;
   virtual bool IsUnaligned() = 0;

   // Get a pointer to the first field (non-primitive types)
   virtual VSymbol *FirstField() = 0;

   // Get a pointer to the first base type (non-primitive types)
   virtual VSymbol *FirstBase() = 0;

   // Get the next thing... this works for params, locals, and fields
   virtual VSymbol *Next() = 0;
};


class VAnnotation
{
public:
   // The address of the annotation.

   virtual ADDR Addr() const = 0;

   // Retrieve a string by zero based index to buffer given size.
   // Returns string length including terminator or zero for failure

   virtual size_t String(size_t, char *, size_t) const = 0;

   // The length of the string including terminator identified by zero based index.

   virtual size_t StringLength(size_t) const = 0;

   // The number of strings in the annotation.

   virtual size_t Count() const = 0;
};


class VAnnotationIter
{
public:
   // You need to "delete pIter" once you are finished with a
   // VAnnotationIter.
   //
   virtual                   ~VAnnotationIter() = 0;

   //
   // Get the current VAnnotation.  Returns NULL if there aren't any more
   // values within the specified range.
   //
   virtual const VAnnotation *Curr() = 0;

   //
   // Are you finished?  Note that you can use the iterator over again by
   // rebinding to the same thing you're bound to, binding to something
   // completely different, etc.
   //
   virtual bool               Done() const = 0;

   //
   // Go to the next VAnnotation that matches any Limit() currently in
   // effect.  Return value is next VAnnotation, or NULL if there aren't
   // any more.
   //
   virtual const VAnnotation *Next() = 0;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\Vulcan\inc\vulcanerr.h ===
/***********************************************************************
* Microsoft Vulcan
*
* Microsoft Confidential.  Copyright 1997-1999 Microsoft Corporation.
*
* File: vulcanerr.h
*
* File Comments:
*
*
***********************************************************************/

#pragma once

#include <exception>

class VErr;

typedef void (VULCANCALL *ErrHandler)(VErr &);

class VULCANDLL VErr
{
public:

    // DoErrHandler() executes the error handler(s).
    // Since this is a virtual method, error classes that
    // inherited from this class may provide their own versions.
    // However, all these versions should eventually pass control
    // to the ErrHandler that is current set.
    //
    virtual void  DoErrHandler();

    // SetErrHandler() replaces the current error handler.
    // The previous error handler is returned for restoring
    // at a later time if desired.
    //
    static ErrHandler VULCANCALL SetErrHandler(ErrHandler); /* UNDONE - To be removed */
    static ErrHandler VULCANCALL SetErrHandler(const char *szAppName = NULL, ErrHandler = NULL);

    // Warnings allow static control over whether warnings are output
    // (for the default error handler!)
    static void VULCANCALL OutputWarnings(bool output);
    static bool VULCANCALL IsOutputWarnings();

    // Your error handler may call the following methods to retrieve
    // information about this object. You may also call the
    // what() method inherited from the C++ standard exception class.
    //
    const char *AppName()       {return (const char *) m_szAppName;}
    DWORD       Flag()          {return m_Flag;}
    bool        IsAssert()      {return !!(m_Flag & FLG_ASSERT     );}
    bool        IsContinuable() {return !!(m_Flag & FLG_CONTINUABLE);}
    bool        IsFatal()       {return !!(m_Flag & FLG_FATAL      );}
    bool        IsWarning()     {return !!(m_Flag & FLG_WARNING    );}

    // These methods change the flags.
    //

    void SetFatal()             {m_Flag = FLG_FATAL;}
    void SetWarning()           {m_Flag = FLG_WARNING;}
    void SetContinuable()       {m_Flag = FLG_CONTINUABLE;}

    // This method gets the what field.  Normally the field is not available till DoErrHandler is called.
    char*       GetWhat();

    // Continuable errors are "delayed fatal errors." These errors are
    // marked for continuation so that as many such errors are displayed,
    // etc. before any "real damage" is done. For example, just before
    // an application is about to write out a file, it calls the method
    // HadContinuableErrors(). If the returned value is true, the
    // application will skip the file write and terminate with the
    // appropriate error code.
    //
    static bool VULCANCALL HadContinuableErrors() {return m_HadContinuableError;}
    static void VULCANCALL ClearContinuableErrors() {m_HadContinuableError = false;}

    // Use this early at application initializing time to set the
    // application name.
    //
    static void SetAppName(const char *);

    // Use this constructor to deal with an error condition.
    //
    VErr(const char *msg, DWORD flags);

    // Copy constructor.
    //
    VErr(VErr &verr);

    virtual ~VErr();

    const char       *what()     {return m_msg;}


    // Use these flags to indicate desired action to the
    // error handler.
    //
    enum
    {
        FLG_ASSERT      = 0x01,
        FLG_FATAL       = 0x02,
        FLG_CONTINUABLE = 0x04,
        FLG_WARNING     = 0x08
    };

protected:
    // These methods should only be used by inheriting classes.
    //
    VErr();
    char             *m_msg;

private:
    DWORD             m_Flag;

    static char      *m_szAppName;
    static bool       m_HadContinuableError;
    static bool       m_OutputWarnings;

    // Inheriting classes should call VErr::DoErrHandler() instead of going
    // directly to this member.
    //
    static ErrHandler m_errHandler;
};


//=============================================================================
//
// Example of using the VErr object and
// catching Vulcan errors in your application.
//
//=============================================================================
//
// int main(int argc, char *argv)
// {
//     VEr::SetErrHandler("MyVulcanApplication.Exe", NULL);   // use default error handler.
//
//     TheRestOfMyInitialization();
//
//     try
//     {
//         MakeVulcanCallsEtc();
//         ...
//     }
//     catch (VErr &verr)           // MUST BE caught by REFERENCE!!
//     {                            // because VErr class may be inherited and
//         verr.DoErrHandler();     // the DoErrHandler() of the inherited class
//         return 1;                // needs to execute.
//     }
//
//     if (myerrobj.HadContinuableError())
//     {
//         return 1;   // indicate error.
//     }
//
//     FILE *fout = fopen("MyOutputFile, "wt");
//     fwrite(MyData, sizeof(MyData), 1, fout);
//     fclose(fout);
//
//     return 0;    // success.
// }


//=============================================================================
//
// This is the source code to the default exception handler.
//
// Notice the stdcall convention. Your error handler must use this
// convention as well.
//
//=============================================================================
//
// void VULCANCALL DefaultErrorHandler(VErr &verr)
// {
//     if (verr.IsAssert())
//     {
//         VulcanMessageBox(verr.what(), verr.IsWarning());  // User may terminate;
//         return;
//     }
//
//     fflush(stdout);
//
//     if (verr.AppName())
//     {
//         fprintf(stderr, "%s : %s\n", verr.AppName(), verr.what());
//     }
//     else
//     {
//         fprintf(stderr, "%s\n", verr.what());
//     }
//
//     fprintf(stderr, "%s : %s\n", verr.AppName(), verr.what());
//     fflush(stderr);
//
//     if (verr.IsFatal())
//     {
//         exit(1);
//     }
// }


//=============================================================================
//
// Example of a class that inherits from VErr.
//
//=============================================================================
//
// class MyFortuneCookieErrorClass : public VErr
// {
// public:
//     MyFortuneCookieErrorClass(COOKIEID id) {m_id = id;}
//
//     MyFortuneCookieErrorClass(MyFortuneCookieErrorClass &me) : VErr(me)
//     {
//         // Copy constructor must alway be present for future VErr versions.
//
//         m_id = (me.id + time(NULL)) % ::COUNT_FORTUNE;
//     }
//
//     void DoErrHandler()
//     {
//         char *szFortune = ::RgszFortune[m_id];
//
//         // The DoErrHandler() of the inheriting class must
//         // render all its information as a simple string
//         // for the base VErr class to deal with because that
//         // is about all it understands.
//         // Then, VErr::DoErrHandler() has to be called. To do it
//         // all, just create a VErr class.
//
//         VErr verr(szFortune, VErr::FLG_FATAL);
//     }
//
// private:
//     COOKIEID m_id;
// };
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\Vulcan\inc\vulcandlisttemplate.h ===
/***********************************************************************
* Microsoft Vulcan
*
* Microsoft Confidential.  Copyright 1997-1999 Microsoft Corporation.
*
* File: vulcandlisttemplate.h
*
* File Comments:
*
*
***********************************************************************/

#ifndef INLINE
#define UNDEF_INLINE
#define INLINE    inline
#endif

/*******************************************************************************
   FILE    : vulcandlisttemplate.h

   CLASSES : CDList2Elem  (template)
             CDList2Iter  (template)
             CDList2      (template)

................................................................................
   CDList2Elem <T>
   ==============
   Any class can be made "Double-Link" ready simply by inheriting from the
   CDList2Elem template class as follows:

         class CBBlock : public CDList2Elem_CBBlock
         {
            ...
         };

   The type argument to all the templates MUST be a POINTER type to the derived
   class.

   The CDList2 template class implements a list of CDList2Elem nodes, and the
   CDList2Iter class implements navigation and modification methods on the List.

................................................................................
   CDList2Iter <T>
   ==============
   This template class implements the navigation and modification methods
   for the doubly-linked list.

   It can be initialized into one of two states:
      - K-state: List is known, current position known.
      - U-state: List is unknown, current position known.

   The U-state can only occur when the Iterator was initialized using the
   following method WITH the ListPtr argument NULL.

      CDList2Iter(CDList2 *ListPtr, CDList2Elem *ElemPtr, T);

   In the U-state, navigation of Prev() and Next() are still in order (1),
   but the insertion and deletion methods (and others) incur a ONE-TIME cost
   of order (n) to determine the List, and thereby, switching over to the
   K-state. In the K-state, most operations are in order (1).

   YES. You can always determine the List on which an Element is on.

   The time cost for each of the Iterator methods are listed here.

                                                      // K-state    U-state
                                                      //========    =======
   void           AddNext(T);                         //  O(1)        O(n)
   void           AddLast(T);                         //  O(1)        O(n)
   void           AddPrev(T);                         //  O(1)        O(n)
   void           AddFirst(T);                        //  O(1)        O(n)
   T              Curr() const;                       //  O(1)   ==   O(1)
   T              Delete();                           //  O(1)        O(n)
   bool           Done() const;                       //  O(1)   ==   O(1)
   CDList2<T>      *GetList();                         //  O(1)        O(n)
   void           Init(CDList2<T> &);                  //  O(1)   ==   O(1)
   void           Init(CDList2<T> &, T, T);            //  O(1)   ==   O(1)
   void           Init(CDList2<T> *, T, T);            //  O(1)   ==   O(1)
   bool           IsEmpty();                          //  O(1)        O(n)
   bool           IsFirst();                          //  O(1)        O(n)
   bool           IsLast();                           //  O(1)        O(n)
   size_t         Length();                           //  O(n)   ==   O(n)
   void           MoveToFirst();                      //  O(1)        O(n)
   void           MoveToLast();                       //  O(1)        O(n)
   void           Next();                             //  O(1)   ==   O(1)
   void           Prev();                             //  O(1)   ==   O(1)
   void           ReverseList();                      //  O(n)   ==   O(n)

................................................................................
   CDList2 <T>
   ==========
   This is the List. Due to the special property of it also being an Elem and
   on the double-linked chain, it is possible to determine the List from any
   Elem on the List.


   EMPTY, the List looks like this:
   ================================

      CDList2 (inherits from CDList2Elem)
      +--------+
      | m_Next |-----+
      |--------|     V
  +---| m_Prev |
  V   |========|
      | m_Head |-+
      +--------+ V


   NOT EMPTY, the List looks like this:
   ====================================

  +------------------------------------------------+
  |                                                |
  |   CDList2 (inherits from CDList2Elem)            |
  |   +--------+                                   |
  +---| m_Next |                                   |
      |--------|<----+                             V
    +-| m_Prev |     |     (First)              (Last)
    V +========+     |     CDList2Elem         CDList2Elem
      |        |     |     X--------X         X--------X
      | m_Head |-----)---->| m_Next |-------->| m_Next |---+
      +--------+     |     |--------|<----\   |--------|   V
                     +-----| m_Prev |      \--| m_Prev |
                           X--------X         X--------X

   SOON, the list will look like:

        CDList2               (First)                               (Last)
      +--------+           CDList2Elem         CDList2Elem         CDList2Elem
      | m_Head | --------->X--------X         X--------X         X--------X
      +--------+ <---------| m_Prev |<--------| m_Prev |<--------| m_Prev |
                           |--------|   /---->|--------|   /---->|--------|
                           | m_Next |--/      | m_Next |--/      | m_Next |---+
                           X--------X         X--------X         X--------X   V


******************************************************************************/

#pragma warning(disable: 4710)   // code not inlined.
#pragma warning(disable: 4786 )  // truncated identifier


// T is always only a pointer to a class that inherited from CDList2Elem.
//
template <class T> class CDList2;
template <class T> class CDList2Iter;

enum Where;

template <class T>
class CDList2Elem               //name changed to force use of typedef will change back later
{
private:
   VIRTUALPAD;
   CDList2Elem<T>  *m_Next;
   PADDING(1);
   CDList2Elem<T>  *m_Prev;

   friend class CDList2<T>;
   friend class CDList2Iter<T>;

public:
                              CDList2Elem<T>();
               T              First() const;
   INLINE      void           Insert(Where w, T);
               void           InsertPrev(T);
               void           InsertNext(T);
   INLINE      bool           IsInList();
               T              Last() const;
   INLINE      T              Next() const;
   INLINE      T              Prev() const;
               void           Remove();


private:
   INLINE      T              PrevOrHead() const;
   INLINE      void           SetLink(CDList2Elem<T> *, CDList2Elem<T> *);
   INLINE      void           SetNext(CDList2Elem<T> *);
   INLINE      void           SetPrev(CDList2Elem<T> *);
};

template <class T>
class CDList2Iter               //name changed to force use of typedef will change back later
{
   CDList2Elem<T>  *m_Curr;
   CDList2<T>      *m_pList;

   friend class CDList2Elem<T>;

public:
   INLINE                     CDList2Iter<T>();
   INLINE                     CDList2Iter<T>(CDList2<T> &);
   INLINE                     CDList2Iter<T>(CDList2<T> &, T, T);
   INLINE                     CDList2Iter<T>(CDList2<T> *, T, T);

                                                                  // K-state    U-state
                                                                  //========    =======
   INLINE      void           Add(Where w, T t);                  //  O(1)        O(n)
               void           AddNext(T);                         //  O(1)        O(n)
               void           AddLast(T);                         //  O(1)        O(n)
               void           AddPrev(T);                         //  O(1)        O(n)
               void           AddFirst(T);                        //  O(1)        O(n)
   INLINE      T              Curr() const;                       //  O(1)   ==   O(1)
               T              Delete();                           //  O(1)        O(n)
   INLINE      bool           Done() const;                       //  O(1)   ==   O(1)
   INLINE      CDList2<T>     *GetList() const;                   //  O(1)        O(n)
   INLINE      void           Init(CDList2<T> &);                 //  O(1)   ==   O(1)
   INLINE      void           Init(CDList2<T> &, T, T);           //  O(1)   ==   O(1)
   INLINE      void           Init(CDList2<T> *, T, T);           //  O(1)   ==   O(1)
   INLINE      bool           IsEmpty() const;                    //  O(1)        O(n)
   INLINE      bool           IsFirst() const;                    //  O(1)        O(n)
   INLINE      bool           IsLast() const;                     //  O(1)        O(n)
   INLINE      size_t         Length() const;                     //  O(n)   ==   O(n)
   INLINE      void           MoveToFirst();                      //  O(1)        O(n)
   INLINE      void           MoveToLast();                       //  O(1)        O(n)
   INLINE      void           Next();                             //  O(1)   ==   O(1)
               void           Prev();                             //  O(1)   ==   O(1)
               void           ReverseList();                      //  O(n)   ==   O(n)

private:
               void           InsertFirstAndOnly(T);
};


template <class T>
class CDList2 : private CDList2Elem<T>          //name changed to force use of typedef will change back later
{
private:
   friend class CDList2Iter<T>;
   friend class CDList2Elem<T>;
   PADDING(1);
   CDList2Elem<T>  *m_Head;

public:
   INLINE                     CDList2();

   INLINE      void           AddNext(T, CDList2Iter<T> &);
   INLINE      void           AddLast(T);
   INLINE      void           AddPrev(T, CDList2Iter<T> &);
   INLINE      void           AddFirst(T);
   INLINE      void           Delete(CDList2Iter<T> &);
   INLINE      CDList2Iter<T> First() const;
   INLINE      T              FirstElem() const;
   INLINE      void           Init();
   INLINE      bool           IsEmpty() const;
   INLINE      bool           IsFirst(CDList2Iter<T> &) const;
   INLINE      bool           IsLast(CDList2Iter<T> &) const;
               CDList2Iter<T> Last() const;
   INLINE      T              LastElem() const;
               size_t         Length() const;
               void           Reverse();                    // Reverse the list
};


//--------------------------------------------------------------
// CDList2Elem methods
//--------------------------------------------------------------
//
template <class T> T CDList2Elem<T>::Next() const
{
   return (T)m_Next;
}

template <class T> T CDList2Elem<T>::PrevOrHead() const
{
    return (T)m_Prev;
}

template <class T> T CDList2Elem<T>::Prev() const
{
   if (m_Prev &&
       m_Prev->m_Prev)
   {
      return (T)m_Prev;
   }
   else
   {
      return NULL;
   }
}

template <class T> bool CDList2Elem<T>::IsInList()
{
    return (m_Prev != NULL);
}

template <class T> void CDList2Elem<T>::SetLink(CDList2Elem<T> *prev, CDList2Elem<T> *next)
{
   m_Next = next;
   m_Prev = prev;
}

template <class T> void CDList2Elem<T>::SetNext(CDList2Elem<T> *next)
{
   m_Next = next;
}

template <class T> void CDList2Elem<T>::SetPrev(CDList2Elem<T> *prev)
{
   m_Prev = prev;
}

template <class T> CDList2Elem<T>::CDList2Elem<T>()
{
   m_Next = NULL;
   m_Prev = NULL;
}

template <class T> void CDList2Elem<T>::InsertPrev(T t)
{
   if (t && PrevOrHead() && t!=(T)this)
   {
       t->Remove();

       //for now use the iterator
       CDList2Iter<T> iter(NULL, (T)this, NULL);
       iter.AddPrev(t);
   }
}

template <class T> void CDList2Elem<T>::InsertNext(T t)
{
   if (t && PrevOrHead() && t!=(T)this)
   {
      t->Remove();

      //for now use the iterator
      CDList2Iter<T> iter(NULL, (T)this, NULL);
      iter.AddNext(t);
   }
}

template <class T> void CDList2Elem<T>::Insert(Where w, T t)
{
    if (w == PREV)
    {
        InsertPrev(t);
    }
    else
    {
        InsertNext(t);
    }
}

template <class T> T CDList2Elem<T>::First() const
{
    if (NULL == m_Prev)
    {
        return NULL; //I am not in a list
    }

    CDList2Iter<T> iter(NULL, (T)this, NULL);
    iter.MoveToFirst();
    return iter.Curr();
}

template <class T> T CDList2Elem<T>::Last() const
{
    if (NULL == m_Prev)
    {
        return NULL; //I am not in a list
    }

    CDList2Iter<T> iter(NULL, (T)this, NULL);
    iter.MoveToLast();
    return iter.Curr();
}

template <class T> void CDList2Elem<T>::Remove()
{
    if (NULL == m_Prev)
    {
        return; //I am not in a list
    }

   //for now use the iterator
   CDList2Iter<T> iter(NULL, (T)this, NULL);
   iter.Delete();

   //I am not in a list now
   m_Prev = m_Next = NULL;
}



//--------------------------------------------------------------
// CDList2Iter methods
//--------------------------------------------------------------
//
template <class T> CDList2Iter<T>::CDList2Iter<T>()
{
   m_Curr = NULL;
   m_pList = NULL;
}

template <class T> CDList2Iter<T>::CDList2Iter<T>(CDList2<T> &List)
{
   Init(List);
}

template <class T> CDList2Iter<T>::CDList2Iter<T>(CDList2<T> &List, T curr, T turd)
{
   Init(List, curr, turd);
}

template <class T> CDList2Iter<T>::CDList2Iter<T>(CDList2<T> *pList, T curr, T turd)
{
   Init(pList, curr, turd);
}

template <class T> void CDList2Iter<T>::Add(Where w, T t)
{
    if (w == BEFORE)
    {
        AddPrev(t);
    }
    else
    {
        AddNext(t);
    }
}
template <class T> void CDList2Iter<T>::AddNext(T t)
{
   if (Done() &&IsEmpty())
   {
      InsertFirstAndOnly(t);
   }
   else if (Done())
   {
      AddFirst(t);
   }
   else if (!(m_Curr->m_Next) && IsLast())
   {
      AddLast(t);
   }
   else
   {
      CDList2Elem<T> *pe = (CDList2Elem<T> *)t;
      CDList2Elem<T> *Next = m_Curr->Next();
      t->SetLink(m_Curr, Next);
      Next->SetPrev(pe);
      m_Curr->SetNext(pe);
   }
}

template <class T> void CDList2Iter<T>::AddLast(T t)
{
   if (NULL == t)
   {
      return;
   }

   t->Remove();

   if (IsEmpty())
   {
      InsertFirstAndOnly(t);
   }
   else
   {
      CDList2Elem<T> *pe = (CDList2Elem<T> *)t;
      CDList2Elem<T> *Last = m_pList->Next();
      t->SetLink(Last, NULL);
      Last->SetNext(pe);
      m_pList->SetNext(pe);
   }
}

template <class T> void CDList2Iter<T>::AddPrev(T t)
{
   CDList2Elem<T> *pe = (CDList2Elem<T> *)t;
   if (Done() && IsEmpty())
   {
      InsertFirstAndOnly(t);
   }
   else if (Done())
   {
      AddLast(t);
   }
   else if (!(m_Curr->m_Prev->m_Prev) && IsFirst())
   {
      AddFirst(t);
   }
   else
   {
      CDList2Elem<T> *Prev = m_Curr->PrevOrHead();
      t->SetLink(Prev, m_Curr);
      Prev->SetNext(pe);
      m_Curr->SetPrev(pe);
   }
}

template <class T> void CDList2Iter<T>::AddFirst(T t)
{
   if (NULL == t)
   {
      return;
   }

   t->Remove();

   CDList2Elem<T> *pe = (CDList2Elem<T> *)t;
   if (IsEmpty())
   {
      InsertFirstAndOnly(t);
   }
   else
   {
      CDList2Elem<T> *First = m_pList->m_Head;
      t->SetLink(First->PrevOrHead(), First);
      First->SetPrev(pe);
      m_pList->m_Head = pe;

      if (pe->PrevOrHead() != (CDList2Elem<T> *) m_pList)
      {
         //VulcanAssert(__FILE__, __LINE__, "List corrupted", false);
      }
   }
}

template <class T> T CDList2Iter<T>::Curr() const
{
   return (T) m_Curr;
}

template <class T> bool CDList2Iter<T>::Done() const
{
   return (m_Curr == NULL);
}

template <class T> T CDList2Iter<T>::Delete()
{
   if (IsEmpty())
   {
      return NULL;
   }

   if (Done())
   {
      m_Curr = m_pList->m_Head;                    // MoveToFirst()
   }

   if (IsFirst())
   {
      if (IsLast())
      {
         m_pList->m_Head = NULL;                   // DeleteOneAndOnly()
         m_pList->SetNext(NULL);
      }
      else
      {
         m_pList->m_Head = m_Curr->Next();         // Delete First but not only
         m_Curr->Next()->SetPrev(m_Curr->PrevOrHead());  // maintain relation to pList.
         m_pList->m_Head = m_Curr->Next();
      }
   }
   else if (m_Curr->Next() == NULL)                // IsLast()
   {
      m_Curr->PrevOrHead()->SetNext(NULL);               // Delete Last but not only
      m_pList->SetNext(m_Curr->PrevOrHead());
   }
   else
   {
      m_Curr->PrevOrHead()->SetNext(m_Curr->Next());     // Delete middle
      m_Curr->Next()->SetPrev(m_Curr->PrevOrHead());
   }

   T retval = (T) m_Curr;
   m_Curr = m_Curr->Next();
   retval->SetLink(NULL, NULL);
   return  retval;
}

template <class T> CDList2<T> *CDList2Iter<T>::GetList() const
{
   if (!m_pList)
   {
      for (CDList2Elem<T> *temp = m_Curr;m_Curr;((CDList2Iter<T> *)this)->m_Curr = (T) m_Curr->m_Prev)
      {
         ((CDList2Iter<T> *)this)->m_pList = (CDList2<T> *) m_Curr;
      }
      ((CDList2Iter<T> *)this)->m_Curr = temp;
   }

   return m_pList;

}

template <class T> void CDList2Iter<T>::Init(CDList2<T> &List)
{
   m_pList = &List;
   MoveToFirst();
}

template <class T> void CDList2Iter<T>::Init(CDList2<T> &List, T curr, T)
{
   m_pList = &List;
   m_Curr = (CDList2Elem<T> *) curr;
}

template <class T> void CDList2Iter<T>::Init(CDList2<T> *pList, T curr, T)
{
   if (!pList && !curr)
   {
      throw new VErr("Internal Error", VErr::FLG_FATAL);      // can't have both be NULL!
   }

   m_pList = pList;
   m_Curr = (CDList2Elem<T> *) curr;
}

template <class T> bool CDList2Iter<T>::IsEmpty() const
{
   return GetList()->IsEmpty();
}

template <class T> bool CDList2Iter<T>::IsFirst() const
{
   return (m_Curr == GetList()->m_Head);
}

template <class T> bool CDList2Iter<T>::IsLast() const
{
   return (m_Curr == GetList()->Next());
}

template <class T> size_t CDList2Iter<T>::Length() const
{
   return GetList()->Length();
}

template <class T> void CDList2Iter<T>::MoveToFirst()
{
   m_Curr = (IsEmpty()) ? NULL : GetList()->m_Head;
}

template <class T> void CDList2Iter<T>::MoveToLast()
{
   m_Curr = GetList()->Next();
}

template <class T> void CDList2Iter<T>::Next()
{
   m_Curr = m_Curr->Next();
}

template <class T> void CDList2Iter<T>::Prev()
{
   m_Curr = m_Curr->PrevOrHead();

   if (m_Curr->PrevOrHead() == NULL)
   {
      // currpos is extreme left
      //
      if (m_pList && (m_Curr != (CDList2Elem<T> *)m_pList))
      {
         // Was this initialized with the wrong m_pList ??
         //
          throw new VErr("Internal Error", VErr::FLG_FATAL);
      }

      m_pList = (CDList2<T> *) m_Curr;      // initialize List Ptr.
      m_Curr = NULL;
   }
}

template<class T> void CDList2Iter<T>::ReverseList()
{
   if (IsEmpty())
   {
      return;
   }

   CDList2Elem<T> *currsave = m_Curr;               // for restoration later.
   CDList2Elem<T> *First = m_pList->m_Head;         // for restoration later.
   CDList2Elem<T> *Last = m_pList->Next();          // for restoration later.
   m_pList->m_Head->SetPrev(NULL);                 // temporarily remove link back to m_pList.

   for (CDList2Elem<T> *curr = m_pList->m_Head ; curr ; )
   {
      CDList2Elem<T> *temp = curr->Next();
      curr->SetNext(curr->PrevOrHead());
      curr->SetPrev(temp);
      curr = temp;
   }

   m_pList->m_Head = Last;
   Last->SetPrev((CDList2Elem<T> *) m_pList);       // restore link back to m_pList
   m_pList->SetNext(First);

   m_Curr = currsave;                              // restore currpos.
}


// CDList2Iter private methods.
//
template <class T> void CDList2Iter<T>::InsertFirstAndOnly(T t)
{
#if DEBUG
   if ((m_pList == NULL) ||
       (m_pList->m_Head != NULL) ||
       (m_pList->Next() != NULL) ||
       (m_pList->PrevOrHead() != NULL))
   {
      //VulcanAssert(__FILE__, __LINE__, "List corrupted", false);
   }
#endif

   CDList2Elem<T> *pe = (CDList2Elem<T> *) t;
   t->SetLink((CDList2Elem<T> *) m_pList, NULL);
   m_pList->m_Head = pe;
   m_pList->SetNext(pe);
}


//--------------------------------------------------------------
// CDList2 methods
//--------------------------------------------------------------
//
template <class T> CDList2<T>::CDList2<T>()
{
   SetLink(NULL, NULL);
   m_Head = NULL;
}

template <class T> void CDList2<T>::AddNext(T t, CDList2Iter<T>& iter)
{
   iter.AddNext(t);
}

template <class T> void CDList2<T>::AddLast(T t)
{
   CDList2Iter<T> iter(*this);
   iter.AddLast(t);
}

template <class T> void CDList2<T>::AddPrev(T t, CDList2Iter<T>& iter)
{
   iter.AddPrev(t);
}

template <class T> void CDList2<T>::AddFirst(T t)
{
   CDList2Iter<T> iter(*this);
   iter.AddFirst(t);
}

template <class T> void CDList2<T>::Delete(CDList2Iter<T> &iter)
{
   iter.Delete();
}

template <class T> CDList2Iter<T> CDList2<T>::First() const
{
   CDList2Iter<T> retval(*(CDList2<T> *)this);
   return retval;
}

template <class T> T CDList2<T>::FirstElem() const
{
   return (T) m_Head;
}

template <class T> void CDList2<T>::Init()
{
   SetLink(NULL, NULL);
   m_Head = NULL;
}

template <class T> bool CDList2<T>::IsEmpty() const
{
   return m_Head == NULL;
}

template <class T> bool CDList2<T>::IsFirst(CDList2Iter<T> &iter) const
{
   return iter.IsFirst();
}

template <class T> bool CDList2<T>::IsLast(CDList2Iter<T> &iter) const
{
   return iter.IsLast();
}

template <class T> CDList2Iter<T> CDList2<T>::Last() const
{
   CDList2Iter<T> retval(*(CDList2<T> *)this);
   retval.MoveToLast();
   return retval;
}

template <class T> T CDList2<T>::LastElem() const
{
   return (T) Next();
}

template <class T> size_t CDList2<T>::Length() const
{
   size_t cnt = 0;
   for(CDList2Iter<T> iter(*(CDList2<T> *)this) ; !iter.Done() ; iter.Next())
   {
      cnt++;
   }

   return cnt;
}

template <class T> void CDList2<T>::Reverse()                    // Reverse the list
{
   CDList2Iter<T> iter(*this);
   iter.ReverseList();
}

#ifdef UNDEF_INLINE
#undef UNDEF_INLINE
#undef INLINE
#endif   // UNDEF_INLINE
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\Vulcan\Samples\src\Annotations\annotations.cpp ===
/***********************************************************************
* Microsoft Vulcan
*
* Microsoft Confidential.  Copyright 2000 Microsoft Corporation.
*
* File: annotations.cpp
*
* File Comments:
*
*
***********************************************************************/

#include <assert.h>
#include <stdio.h>
#include <stdlib.h>

#include "vulcanapi.h"

const char *g_szFilter;

void ShowAnnotations(const char *szComponentName)
{
   VComp *pComp = VComp::Open((char *) szComponentName, 0);

   printf("Annotations in %s\n", szComponentName);

   VAnnotationIter *pIter = pComp->AnnotationIter(g_szFilter);

   // Now iterate over all the VAnnotations.

   const VAnnotation *pAnnotation = pIter->Curr();

   while (pAnnotation != NULL)
   {
      printf("   0x%I64X", pAnnotation->Addr());

      VProc *pProc = pComp->FindProc(pAnnotation->Addr());

      if ((pProc != NULL)  && (pProc->Name() != NULL))
      {
         printf(": in VProc %s\n", pProc->Name());
      }

      else
      {
         printf( "\n" );
      }

      for (size_t x = 0; x < pAnnotation->Count(); x++)
      {
         size_t cch = pAnnotation->StringLength(x);
         assert(cch != 0);

         char *sz = new char[cch];

         size_t cchT = pAnnotation->String(x, sz, cch);
         assert(cchT == cch);

         printf("      %u: %s\n", x, sz);

         delete [] sz;
      }

      pAnnotation = pIter->Next();
   }

   delete pIter;

   pComp->Destroy();
}


void usage(const char *szProgname, int exitcode)
{
   FILE *out = exitcode ? stderr : stdout;

   fprintf(out,
           "usage: %s [-f filter] component...\n"
           "\n"
           "    List annotations present in components.\n"
           "\n"
           "    -f filter  Pass string to VComp::AnnotationIter() to restrict\n"
           "               output to specific annotations.\n",
           szProgname);

   exit(exitcode);
}


int __cdecl main(int argc, const char *argv[])
{
   try
   {
      int optind = 1;

      if (optind >= argc)
      {
         usage(argv[0], 2);
      }

      while (optind < argc)
      {
         const char *szArg = argv[optind++];

         if (strcmp(szArg, "-f") == 0)
         {
            if (optind >= argc)
            {
               usage(argv[0], 2);
            }

            g_szFilter = argv[optind++];
         }

         else if (szArg[0] == '-')
         {
            usage(argv[0], 2);
         }

         else
         {
            ShowAnnotations(szArg);
         }
      }
   }

   catch (VErr& verr)
   {
      printf("Error: %s\n", verr.GetWhat());
      exit(1);
   }

   return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\Vulcan\Samples\src\Addnop\addnop.cpp ===
/***********************************************************************
* Microsoft  Vulcan
*
* Microsoft Confidential.  Copyright 1997-2000 Microsoft Corporation.
*
* File: Addnop.cpp
*
* File Comments:
*
*
***********************************************************************/
#pragma warning(disable: 4514)

#include "vulcanapi.h"

#include <stdlib.h>
#include <stdio.h>

int __cdecl main(int argc, char** argv);
void __stdcall Myhandler(VErr verr);
void UINop(char* szImage);


void UINop(char* szImage)
{
   VProg *pprog = VProg::Open(szImage);
   int count = 0;

   for(VComp *pComp = pprog->FirstComp(); pComp; pComp = pComp->Next())
   {
      printf("%s\n",pComp->InputName());
      for(VProc *pProc = pComp->FirstProc(); pProc; pProc = pProc->Next())
      {
         for(VBBlock *pBlk = pProc->FirstBlock(); pBlk; pBlk = pBlk->Next())
         {
            // If we used FirstAllBlock and NextAll instead of FirstBlock and
            // Next, we would need to avoid data blocks (pBlk->IsDataBock()).

            for(VInst *pInst = pBlk->FirstInst(); pInst; pInst = pInst->Next())
            {
               VInst * newInst;

               switch (pBlk->PlatformT())
               {
                  case platformtMSIL:
                     pInst->InsertPrev(VInst::Create(COp::CEE_NOP));
                     count++;
                     break;

                  case platformtX86:
                     pInst->InsertPrev(VInst::Create(COp::NOP));
                     count++;
                     break;

                  case platformtIA64:
                     // Alloc must always appear first in a bundle

                     if (pInst->Opcode() != COp::ALLOC &&
                         pInst->Opcode() != COp::NOP_M &&
                         pInst->Opcode() != COp::NOP_I &&
                         pInst->Opcode() != COp::NOP_B &&
                         pInst->Opcode() != COp::NOP_F &&
                         pInst->Opcode() != COp::NOP_X &&
                         pInst != pBlk->LastInst())
                     {
                        // IA64 implements switch tables in code
                        // Hence there are some sequences that
                        // are not allowed to changed in size.
                        // These tests screen them out of consideration.

                        newInst = VInst::Create(COp::NOP_M, 0xbeef);
                        pInst->InsertPrev(newInst);
                        count++;
                     }
                     break;

                  default:
                     fprintf(stderr, "Unsupported architecture type\n");
                     exit(1);
               }
            }
         }
      }

      printf("%d NOP's inserted.\n", count);
      pComp->Write();
   }

   // To save time, we don't destroy the program object
   // pprog->Destroy();

   // This should only be called after ALL Vulcan objects have been Destroyed
   // It will clean up any outstanding allocations
   // VulcanCleanUpAllAllocations();
}


int __cdecl main(int argc, char** argv)
{
   if (argc != 2)
   {
      printf("Usage: Addnop [image-name]\n");
      return 1;
   }

   try
   {
      UINop(argv[1]);
   }
   catch (VErr& verr) 
   {
      printf("Error: %s\n",verr.GetWhat());
      return 1;
   }
   catch (...)
   {
      printf("Error: Unknown\n");
      return 1; 
   }

   return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\Vulcan\inc\vulcankdlist.h ===
/***********************************************************************
* Microsoft Vulcan
*
* Microsoft Confidential.  Copyright 1997-1999 Microsoft Corporation.
*
* File: vulcankdlist.h
*
* File Comments:
*
*
***********************************************************************/

#pragma once

//===============================================================
//  These two classes provide link fields and the basic list operations
//  Here is how it is intended to be used
//  Define the class that you want the linked fields in as
//
//  class mylist : public CKDListElem<mylist>
//  {
//  ....
//  };
//
//  Use DList to instantiate the list
//  DList<mylist*> dl;
//  Use DList for insertion/deletion/.. operations
//  Use navigation (Next/Prev) on CKDListIter<mylist>
//================================================================

template <class T>
class CKDList;

template <class T>
class CKDListIter;


//----------------------------------------------------------------
// CKDListElem
//----------------------------------------------------------------

template <class T>
class CKDListElem {
public:
    friend class CKDList<T>;
    friend class CKDListIter<T>;

    void* m_xor;
};


//----------------------------------------------------------------
// CKDListIter
//
// NOTE: T inherits CKDListElem<T>
//----------------------------------------------------------------

enum Where;

template <class T>
class CKDListIter
{
   friend class CKDList<T>;

   CKDListElem<T>*            m_pCurr;
   CKDListElem<T>*            m_pPrev;
   CKDList<T>*                m_pdl;

public:
                  CKDListIter<T>()  {m_pCurr=NULL; m_pPrev=NULL; m_pdl=NULL;}
                  CKDListIter<T>(CKDList<T> &dl);
                  CKDListIter<T>(CKDList<T>* dl,T curr,T prev);

    void          Init(CKDList<T> &dl);
    T             Curr() const      {return (T)m_pCurr;}
    void          Prev();
    void          Next();
    bool          Done() const      {return m_pCurr == NULL;}
    CKDList<T>*   GetList() const   {return m_pdl;}
    bool          IsFirst() const   {return m_pCurr == m_pdl->head;}
    bool          IsLast()  const;          
    bool          IsEmpty() const   {return m_pdl == NULL || m_pdl->head == NULL;}
    void          MoveToFirst()     {m_pCurr = m_pdl->head; m_pPrev = NULL;}
    void          MoveToLast();

    void          AddFirst(T t)     {if (IsFirst()) {m_pPrev = t;} m_pdl->AddFirst(t);}
    void          AddLast(T t)      {m_pdl->AddLast(t);}
    void          AddPrev(T t)      {m_pdl->AddPrev(t,*this);}
    void          AddNext(T t)      {m_pdl->AddNext(t,*this);}
    void          Add(Where w, T t) {if (w == BEFORE) AddPrev(t); else AddNext(t);}

    T             Delete()          {CKDListElem<T>* pt = m_pCurr; m_pdl->Delete(*this); return (T)pt;}
    int           Length() const    {return m_pdl->Length();}
};


template <class T>
CKDListIter<T>::CKDListIter<T>(CKDList<T> &dl)
{
   m_pCurr = dl.head;
   m_pPrev = NULL;
   m_pdl = &dl;
}

template <class T>
CKDListIter<T>::CKDListIter<T>(CKDList<T>* dl,T curr,T prev)
{
   m_pCurr = (CKDListElem<T>*) curr;
   m_pPrev = (CKDListElem<T>*)prev;
   m_pdl = dl;
}

template <class T>
void CKDListIter<T>::Init(CKDList<T> &dl)
{
   m_pCurr = dl.head;
   m_pPrev = NULL;
   m_pdl = &dl;
}

template <class T>
inline void CKDListIter<T>::Next()
{
   CKDListElem<T>* swap = m_pCurr;
   if (m_pCurr)
   {
      // "^" is XOR
      m_pCurr = (CKDListElem<T>*) (((size_t) m_pPrev) ^ ((size_t)(m_pCurr->m_xor)));
   }
   m_pPrev = swap;
}

template <class T>
inline void CKDListIter<T>::Prev()
{
   CKDListElem<T>* swap = m_pPrev;
   if (m_pPrev)
   {
      // "^" is XOR
      m_pPrev = (CKDListElem<T>*) (((size_t) m_pCurr) ^ ((size_t)(m_pPrev->m_xor)));
   }
   m_pCurr = swap;
}

template <class T>
void CKDListIter<T>::MoveToLast()
{
   CKDListIter<T> iter(*m_pdl);
   for (;iter.Curr();iter.Next())
   {
      *this = iter;
   }
}


template <class T>
bool CKDListIter<T>::IsLast() const
{
    if (m_pCurr == NULL)
    {
        return false;
    }
    
    return NULL == (((size_t) m_pPrev) ^ ((size_t)(m_pCurr->m_xor)));
}



//----------------------------------------------------------------
// CKDList
//
// NOTE: T inherits CKDListElem<T>
//----------------------------------------------------------------

template <class T>
class CKDList
{
private:
   CKDListElem<T>*                  head;
public:
   friend class CKDListIter<T>;

                  CKDList()         {head=NULL;}

   bool           IsFirst(const CKDListIter<T> t) const;
   T              FirstElem() const  {return (T)head;}
   T              LastElem() const;
   CKDListIter<T> First() const;
   CKDListIter<T> Last() const;
   void           AddPrev(T t,CKDListIter<T>& pos);
   void           AddNext(T t,CKDListIter<T>& pos);
   void           AddFirst(T t);
   void           AddLast(T t);
   void           Delete(CKDListIter<T>& t);  // Delete element
   int            Length() const;             // Count Elements
   void           Reverse();                  // Reverse the list

private:
    void          InsertFirstAndOnly(T t);
    void          AddMiddle(T t,CKDListIter<T>& left,CKDListIter<T>& right);
    void*         Xor(void* a,void* b) {return (void*)( (size_t)a ^ (size_t)b );}

};


template <class T>
bool CKDList<T>::IsFirst(CKDListIter<T> t) const
{
   return((T)head == t.Curr());
}

template <class T>
CKDListIter<T> CKDList<T>::First() const
{
   // Return the iterator pointing to the first element

   CKDListIter<T> ret;
   ret.m_pCurr = head;
   ret.m_pPrev=NULL;
   ret.m_pdl = (CKDList<T> *)this;
   return ret;
}

template <class T>
CKDListIter<T> CKDList<T>::Last() const
{
   // Return the iterator pointing to the last element

   CKDListIter<T> iter(*(CKDList<T> *)this);
   CKDListIter<T> ret(*(CKDList<T> *)this);
   for (;iter.Curr();iter.Next())
   {
      ret = iter;
   }
   return ret;
}

template <class T>
T CKDList<T>::LastElem() const
{
   CKDListIter<T> iter(*(CKDList<T> *)this);
   CKDListIter<T> ret(*(CKDList<T> *)this);
   for (;iter.Curr();iter.Next())
      ret = iter;
   return ret.Curr();
}

template <class T>
void CKDList<T>::AddPrev(T t, CKDListIter<T>& pos)
{
   if (!pos.Curr())
   {
       AddLast(t);
   }
   else
   {
      CKDListIter<T> prev = pos;
      prev.Prev();
      if (!prev.Curr())
      {
         AddFirst(t);
      }
      else
      {
         AddMiddle(t,prev,pos);
      }
      pos.m_pPrev = (CKDListElem<T>*) t;
   }
}

template <class T>
void CKDList<T>::AddNext(T t, CKDListIter<T>& pos)
{
   if (!pos.Curr())
   {
      AddFirst(t);
   }
   else
   {
      CKDListIter<T> next = pos;
      next.Next();
      if (!next.Curr())
      {
         AddLast(t);
      }
      else
      {
         AddMiddle(t,pos,next);
      }
   }
}

template <class T>
void CKDList<T>::AddFirst(T t)
{
   if (!head)
   {
      InsertFirstAndOnly(t);
   }
   else
   {
      ((CKDListElem<T>*)t)->m_xor = head;
      head->m_xor = Xor(t,head->m_xor);
      head = (CKDListElem<T>*)t;
   }
}

template <class T>
void CKDList<T>::AddLast(T t)
{
   if (!head)
   {
      InsertFirstAndOnly(t);
   }
   else
   {
      CKDListElem<T>* last = (CKDListElem<T>*) (Last().Curr());
      ((CKDListElem<T>*)t)->m_xor = last;
      last->m_xor = Xor(last->m_xor, t);
   }
}

template <class T>
void CKDList<T>::InsertFirstAndOnly(T t)
{
   ((CKDListElem<T>*)t)->m_xor = NULL;
   head = (CKDListElem<T>*)t;
}

template <class T>
void CKDList<T>::AddMiddle(T t,CKDListIter<T>& left,CKDListIter<T>& right)
{
   CKDListIter<T> prev = left;
   prev.Prev();
   CKDListIter<T> next = right;
   next.Next();
   left.m_pCurr->m_xor = Xor(prev.m_pCurr, (CKDListElem<T>*)t);
   right.m_pCurr->m_xor = Xor(next.m_pCurr, (CKDListElem<T>*)t);
   ((CKDListElem<T>*)t)->m_xor = Xor(left.m_pCurr, right.m_pCurr);
}

template <class T>
void CKDList<T>::Delete(CKDListIter<T>& pos)
{
   // Verify (pos.Curr() != NULL);
   CKDListIter<T> prev = pos;
   prev.Prev();
   CKDListIter<T> next = pos;
   next.Next();
   if (head == pos.m_pCurr)
      head = next.m_pCurr;
   if (prev.Curr())
   {
      prev.m_pCurr->m_xor = Xor(prev.m_pPrev, next.Curr());
   }
   if (next.Curr())
   {
      next.m_pCurr->m_xor = Xor(pos.Curr(), Xor(next.m_pCurr->m_xor, prev.Curr()));
   }
   pos.m_pCurr = (CKDListElem<T>*)next.m_pCurr;  //updating iter for user.
}

template <class T>
void CKDList<T>::Reverse()
{
   head = Last().m_pCurr;
}

template <class T>
int CKDList<T>::Length() const
{
   if (head == NULL)
      return 0;
   CKDListIter<T> pos(*(CKDList<T> *)this);
   int count = 0;
   while (pos.Curr())
   {
      ++count;
      pos.Next();
   }
   return count;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\Vulcan\Samples\src\CallsDll\callsdll.cpp ===
/***********************************************************************
* Microsoft  Vulcan
*
* Microsoft Confidential.  Copyright 1997-2000 Microsoft Corporation.
*
* File: Callsdll.cpp
*
* File Comments:
*
*
***********************************************************************/
#include <stdio.h>

extern "C" __declspec(dllexport) void _cdecl SendStr(char* str)
{
   printf("%s",str);
}

extern "C" __declspec(dllexport) void _cdecl SendInt(int i)
{
   printf("%d\n",i);
}

extern "C" __declspec(dllexport) void _cdecl SendEff(int i)
{
   printf("Memory use at %d\n",i);
}

extern "C" __declspec(dllexport) void _cdecl SendStrInt(char*str, int i)
{
   printf("Str = %s, i = %d\n",str,i);
}


typedef int (_cdecl *FP)(int);

FP fp;

extern "C" __declspec(dllexport) void _cdecl GetPointer(FP p)
{
   fp=p;
}

extern "C" __declspec(dllexport)int _cdecl Handler(int size)
{
   printf("hello world\n");

   int f = (*fp) (size);
   printf("allocated at %d size of %d\n",f,size);
   return f;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\Vulcan\Samples\src\DynInstCount\dyninstcount.cpp ===
/***********************************************************************
* Microsoft  Vulcan
*
* Microsoft Confidential.  Copyright 1997-2000 Microsoft Corporation.
*
* File: DynInstCount.cpp
*
* File Comments:
*
*
***********************************************************************/
#pragma warning(disable: 4514)

#include "stdio.h"
#include "vulcanapi.h"
#include "vulcanbmp.h"
#include "string.h"
#include "malloc.h"

int __cdecl main(int argc, char** argv);
void __stdcall Myhandler(VErr verr);
bool FDefsFlags(VInst *pInst);

void DynInstCount(char* szImage, char *szCmdFile)
{
   VProg *pprog = VProg::Open(szImage, false, szCmdFile);

   for(VComp *pComp = pprog->FirstComp(); pComp; pComp = pComp->Next())
   {
      printf("%s\n",pComp->InputName());

      pComp->Build();

      // Create a global to store the count in its own section

      BYTE count[4] = {0,0,0,0};
      VBlock *pBlkCount = VBlock::CreateDataBlock( pComp, count, sizeof(count) );
      VSect *pSect = pComp->NewSect( ".count", Sec_READWRITE );
      VProc *pDataProc = pSect->NewProc( "Count" );
      pDataProc->InsertFirstBlock(pBlkCount);

      // Create a block for the names of all the procedures

      VBlock *pBlkNames = VBlock::CreateDataBlock( pComp, count, sizeof(count) );
      int cbMax = 64*1024;
      char *szNames = (char *)malloc( cbMax );
      char *pchNextName = szNames;
      pDataProc->InsertFirstBlock(pBlkNames);

      int iProc = 0;

      for (VProc *pProc = pComp->FirstProc(); pProc; pProc = pProc->Next())
      {
         VBlock *pBlk = pProc->FirstBlock();

         //create an address object to reference the block
         VAddress *pAddrCount = VAddress::Create( pBlkCount,
                                                  iProc * sizeof(int) );

         const char *szName = pProc->Name();
         int cch = strlen(szName);

         if (pchNextName - szNames + cch + 1 >= cbMax)
         {
            cbMax *= 2;
            int ichNext = pchNextName - szNames;
            szNames = (char *)realloc(szNames, cbMax );
            pchNextName = szNames + ichNext;
         }

         strcpy(pchNextName, szName);
         pchNextName += cch + 1;

         for (; pBlk; pBlk = pBlk->Next())
         {
            int iCount = pBlk->CountInsts();

            if (iCount)
            {
               VAddress *pAddrAdd = VAddress::Create( X86Register::EAX, iCount );
                
               //we want to put an add [count], iCount into the block
               VInst *pInstPush = VInst::Create(COp::PUSHD, X86Register::EAX);
               VInst *pInstMov1 = VInst::Create(COp::MOVD,  X86Register::EAX, pAddrCount );
               VInst *pInstLea  = VInst::Create(COp::LEAD,  X86Register::EAX, pAddrAdd );
               VInst *pInstMov2 = VInst::Create(COp::MOVD,  pAddrCount,       X86Register::EAX );
               VInst *pInstPop  = VInst::Create(COp::POPD,  X86Register::EAX);

               pAddrAdd->Destroy();
               
               pBlk->InsertFirstInst( pInstPush );
               pInstPush->InsertNext( pInstMov1 );
               pInstMov1->InsertNext( pInstLea );
               pInstLea->InsertNext( pInstMov2 );
               pInstMov2->InsertNext( pInstPop );
            }
         }

         pAddrCount->Destroy();

         iProc++;
      }

      // Resize the data block

      int *rgCount = new int[iProc];
      memset( rgCount, 0, iProc * sizeof(int) );
      pBlkCount->SetData( (BYTE *)rgCount, iProc * sizeof(int) );

      // Resize the name block

      pBlkNames->SetData( (BYTE *)szNames, pchNextName - szNames );

      // Pass the pointer to the count to the dll

      VProtoList *pProtoList = VProtoList::CreateProtoList();
      VProto *pProto = pProtoList->CreateProto(
                           pComp,
                           "DynInstCountDll.dll",
                           "_cdecl SavePDynInstCount(blockaddr, int, blockaddr)");

      pProto->AddCall(pComp, BEFORE, pBlkCount, iProc, pBlkNames );
      pProtoList->Commit();

      pComp->Write();
   }
}


int __cdecl main(int argc, char** argv)
{

   if (argc != 2 && argc != 3)
   {
      printf("Usage: DynInstCount <Image-Name> <foo.cmdfile>\n");
      return 1;
   }

   try
   {
      DynInstCount(argv[1], argv[2]);
   }

   catch (VErr& verr) 
   {
      printf("Error: %s\n",verr.GetWhat());
      return 1;
   }

   catch (...)
   {
      printf("Error: unknown\n");
      return 1; 
   }

   return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\Vulcan\Samples\src\Capsize\capsize.h ===
/***********************************************************************
* Microsoft BBT
*
* Microsoft Confidential.  Copyright 1996-1997 Microsoft Corporation.
*
* Component:
*
* File: capsize.h
*
* File Comments:
*
*
***********************************************************************/

#include "vulcanapi.h"
#include "vulcancmdfile.h"
#include "vulcancmdline.h"
#include "cmddict.h"

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define FALSE false

#define DEFAULTCAPDIR "capsize\\"
#define DEFAULTPDBEXT ".pdb"
#define DEFAULTCMDEXT ".bbtcmd"
#define DEFAULTASMEXT ".asm"

class CMDFILEDEF : public CMDFILE
{
public:

   static   const CMDDEF rgcmddef[];

private:
   void Exclude(unsigned, const char *);
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\Vulcan\Samples\src\Capsize\capsize.cpp ===
/***********************************************************************
* Microsoft Vulcan
*
* Microsoft Confidential.  Copyright 1996-1999 Microsoft Corporation.
*
* Component:
*
* File: capsize.cpp
*
* File Comments:
*
*
***********************************************************************/

#include "capsize.h"
#include "vulcancmdline.h"
#include "vulcanapi.h"

#include <direct.h>
#include <sys/stat.h>

bool  fDlp;                            // Use DLP style instrumentation
char  *szAsm;                          // Asm filename
char  *szCmd;                          // Cmdfile name
char  *szDll;                          // Name of DLL containing callback
char  *szEntry;                        // Name of callback entry point
char  *szO;                            // Output file name
char  *szPdb;                          // Name of pdb file.
char  *szCmdCmd;                       // Cmd file specified on /cmd
char  *szCmdAsm;                       // Asm file specified on /asm
char  *szCmdPdb;                       // Pdb file specified on /pdb
char  *szCmdO;                         // Output file specified on /o
char  *szOrgDir;                       // Directory for input files
char  *szCapDir;                       // Directory for Output files

char  *szValidFlag;
long  cbNullStub = 0;

bool  fnocmd;                          // True if /nodefaultcmd specified
bool  fout;                            // True if /o specified
bool  fcmd;                            // True if /cmd specified
bool  fasm;                            // True if /asm specified
bool  fpdb;                            // True if /pdb specified
bool  fCompact;                        // True if /compact specified
bool  fBlockInfo;                      // True if /fBlockInfo specified
bool  fWriteFast;                      // True if /writefast specified
bool  fDoHelp;                         // True if /?
bool  fVerbose = false;
bool  fTerse = false;
bool  fNoLogo = false;
int   iArg;                            // First non-option argument

char  *szImage;

VComp *pComp;


   // Type                 OptionName     fOptReq  pvValue

const CMDLINE::OPTDEF rgoptdef[] =
{
   { CMDLINE::argtHelp,       "?",           false,   &fDoHelp                   },
   { CMDLINE::argtOptString,  "asm",         false,   &szCmdAsm,        &fasm    },
   { CMDLINE::argtOptString,  "asmemit",     false,   &szCmdAsm,        &fasm    },
   { CMDLINE::argtNil,        "blockinfo",   false,   &fBlockInfo,               }, // not in usage
   { CMDLINE::argtString,     "cmd",         false,   &szCmdCmd,        &fcmd    },
   { CMDLINE::argtNil,        "compact",     false,   &fCompact                  },
   { CMDLINE::argtString,     "dll",         false,   &szDll                     },
   { CMDLINE::argtNil,        "dlp",         false,   &fDlp                      },
   { CMDLINE::argtString,     "entry",       false,   &szEntry                   },
   { CMDLINE::argtHelp,       "help",        false,   &fDoHelp                   },
   { CMDLINE::argtNil,        "nocmd",       false,   &fnocmd                    },
   { CMDLINE::argtInt,        "nullstub",    false,   &cbNullStub,               },
   { CMDLINE::argtOptString,  "o",           false,   &szCmdO ,         &fout    },
   { CMDLINE::argtOptString,  "pdb",         false,   &szCmdPdb,        &fpdb    },
   { CMDLINE::argtString,     "validflag",   false,   &szValidFlag               },
   { CMDLINE::argtNil,        "verbose"  ,   false,   &fVerbose                  },
   { CMDLINE::argtNil,        "writefast",   false,   &fWriteFast                },
   { CMDLINE::argtNil,        "terse"    ,   false,   &fTerse                    },
   { CMDLINE::argtNil,        "q"    ,       false,   &fTerse                    },
   { CMDLINE::argtNil,        "nologo"   ,   false,   &fNoLogo                   },
   { CMDLINE::argtEnd,        NULL,          false,   &iArg                      },
};


const CMDFILEDEF::CMDDEF CMDFILEDEF::rgcmddef[] =
{
   { cmdtNil, "capsize.exclude",   (PFNCMD) &Exclude            },
   { cmdtEnd, NULL,                NULL                         }
};


const char *RgszCapsizeCmdDict [] =
{

   "capsize.exclude",       // CAPSIZE

   NULL                 // nothing comes after ME!
};

SZDICTIONARY gszdictCmd(RgszCapsizeCmdDict);

class RGSZ
{
public:
  RGSZ()
  {
    m_rgpsz = NULL;
    m_cpsz = 0;
    m_cpszmax = 0;
  }

  ~RGSZ()
  {
    for (int i = 0 ; i < m_cpsz ; i++)
    {
      free(m_rgpsz[i]);
    }

    free(m_rgpsz);
  }

  void Insert(const char *sz)
/***********************************************************************
* Add an element to the list of "excluded" functions
***********************************************************************/
  {
    if (m_cpsz >= m_cpszmax)
    {
      m_cpszmax = m_cpsz + (m_cpsz >> 1) + 100;
      m_rgpsz = (char **) realloc(m_rgpsz, m_cpszmax * sizeof(m_rgpsz));
    }
    m_rgpsz[m_cpsz++] = _strdup(sz);
  }

  int CpSz()
  {
        return(m_cpsz);
  }

  char ** Prgpsz()
  {
        return(m_rgpsz);
  }

private:
  char **m_rgpsz;
  int  m_cpsz;
  int  m_cpszmax;
};


RGSZ rgsz;

int __cdecl SortByIncreasingFunctionNames(const void *pv1, const void *pv2)
{
    return(strcmp(*((char **)pv1), *(char **)(pv2)));
}


void Error(const unsigned flags, const char *fmt, ...)
{
    char buf[512];

    va_list items;
    va_start(items, fmt);

    vsprintf(buf, fmt, items);
    va_end(items);

    VErr verr(buf, flags);
    verr.DoErrHandler();
}

void Usage(int iExit)
{
   printf("Microsoft (R) Vulcan IceCAP Preparation Tool\n");
   printf("Usage: CAPSIZE [options] Executable\n\n"
          "Options:\n\n"
          "/?                  Display this help\n"
          "/asmemit [filename] Write a disassembly listing for output binary\n"
          "/cmd     filename   Read the specified command file\n"
          "/compact            Use compact bblocks\n"
          "/dll     dllname    Name of DLL containing entry (default = ICAP.DLL/ICECAP.DLL)\n"
          "/dlp                Use DLP style profiling (IceCAP 4.0)\n"
          "/entry   name       Name of callback entry point (default = _penter2)\n"
          "/help               Display this help\n"
          "/nocmd              Do not use a command file\n"
          "/nologo             Do not display a banner message\n"
          "/o       filename   Output binary name\n"
          "/pdb     filename   Pdb output filename\n"
          "/q                  Terse output mode\n"
          "/verbose            Verbose output mode\n"
          "/writefast          Generate output file with VComp->WriteFast intead of Write\n"
          );

   exit(iExit);
}


void InitParams(int argc, char *argv[])
{
   char szDrive[_MAX_DRIVE];
   char szDir[_MAX_DIR];
   char szFname[_MAX_FNAME];
   char szExt[_MAX_EXT];
   char szBuf[5000];
   struct _stat rgStatBuf;

   bool fSuccess = true;                // avoid uninitialized var warning.

   /***********************************************************************
   * Call the Command Line processor to parse the argyuments using rgoptdef
   * as the strucuture to define how to handle the various arguements.
   ***********************************************************************/

   try
   {
      fSuccess = CMDLINE::FProcessArgs("CAPSIZE",
                                       argc,
                                       (const char **) argv,
                                       rgoptdef);
   }

   /***********************************************************************
   * Handle the various error situations and validate correct usage
   ***********************************************************************/

   catch (...)
   {
      Usage(1);
   }

   if (!fSuccess)
   {
      Usage(1);
   }

   if (fDoHelp)
   {
      Usage(0);
   }

   if (iArg >= argc)
   {
      Usage(1);
   }

   szImage = argv[iArg++];

   if (iArg != argc)
   {
      Usage(1);
   }

   if ((cbNullStub != 0) && (szDll != NULL))
   {
      Error(VErr::FLG_FATAL, "Cannot specify /Nullstub and /DLL");

      exit(1);
   }

   if ((szValidFlag != NULL) && (cbNullStub == 0))
   {
      Error(VErr::FLG_FATAL,
            "Must specify Nullstub when you specify ValidFlag");

      exit(1);
   }

   if (cbNullStub == 0)
   {
      if (szDll == NULL)
      {
         if (fDlp)
         {
            szDll = "ICECAP.DLL";
         }

         else
         {
            szDll = "ICAP.DLL";
         }
      }

      else
      {
         char szDrive[_MAX_DRIVE];
         char szDir[_MAX_DIR];

         _splitpath(szDll, szDrive, szDir, NULL, NULL);

         if ((szDrive[0] != '\0') || (szDir[0] != '\0'))
         {
            Error(VErr::FLG_FATAL,
                  "Cannot specify a pathname for with /NULLSTUB");

            exit(1);
         }
      }
   }

   if (szEntry == NULL)
   {
      szEntry = "_penter2";
   }

   /***********************************************************************
   * Display the startup banner for this utility
   ***********************************************************************/

   if (!fNoLogo)
      printf("Microsoft (R) Vulcan IceCAP Instrumentation Preparation Tool\n");

   if (fout)
   {
      _splitpath(szCmdO, szDrive, szDir, szFname, szExt);
      if (strlen(szDir) + strlen(szDrive))
      {
         szCapDir = new char[strlen(szDir) + strlen(szDrive) + 1];
         sprintf(szCapDir, "%s%s", szDrive, szDir);
         szCapDir[strlen(szCapDir)-1] = '\0';

         if ((strlen(szDir) > 1) && (_stat(szCapDir, &rgStatBuf)))
         {
            char szbuf[512 + _MAX_DIR + _MAX_DRIVE];
            sprintf(szbuf,
                    "The /o option specifies a directory '%s' "
                    "which does not exist.\n",
                    szCapDir);

            Error(VErr::FLG_FATAL, szbuf);
         }

         sprintf(szCapDir, "%s%s", szDrive, szDir);
      }
      else
      {
         szCapDir = new char[3];
         strcpy(szCapDir, ".\\");
      }
   }

   else
   {
      szCapDir = new char[sizeof(DEFAULTCAPDIR)+1];
      strcpy(szCapDir, DEFAULTCAPDIR);
      szCapDir[strlen(szCapDir) - 1] = '\0';

      // Create the Capsize Directory if it doesn't yet exist

      size_t staterr = _stat(szCapDir, &rgStatBuf);
      if (staterr || (rgStatBuf.st_mode & _S_IFREG))
      {
         if(_mkdir(szCapDir))
         {
            throw VErr("Unable to create capsize directory", VErr::FLG_FATAL);
         }
      }
      strcpy(szCapDir, DEFAULTCAPDIR);
   }

   _splitpath(szImage, szDrive, szDir, szFname, szExt);

   // Setup the org and Capsize directory names


   // The orgdir is constructed from the name of input binary.

   if (strlen(szDir))
   {
      szOrgDir = new char[strlen(szDir) + strlen(szDrive) + 1];
      sprintf(szOrgDir, "%s%s", szDrive, szDir);
   }
   else
   {
      szOrgDir = new char[3];
      strcpy(szOrgDir, ".\\");
   }

   if (!fcmd)
   {
      if (fnocmd)
      {
         szCmd = NULL;
      }
      else
      {
         sprintf(szBuf, "%s%s%s%s", szOrgDir, szFname, szExt, DEFAULTCMDEXT);
         szCmd = new char[strlen(szBuf) + 1];
         strcpy(szCmd, szBuf);

         if (_stat(szCmd, &rgStatBuf))
         {
            szCmd = NULL;
         }
      }
   }

   else
   {
      szCmd = szCmdCmd;
   }


   // Setup file names for the pdb, cmd, asm and output files

   if (fout)
   {
      _splitpath(szCmdO, szDrive, szDir, szFname, szExt);
   }

   if (fasm)
   {
      if (szCmdAsm)
      {
         szAsm = szCmdAsm;
      }
      else
      {
         sprintf(szBuf, "%s%s%s%s", szCapDir, szFname, szExt, DEFAULTASMEXT);
         szAsm = new char[strlen(szBuf) + 1];
         strcpy(szAsm, szBuf);
      }
   }

   if (!fpdb)
   {
      sprintf(szBuf, "%s%s%s%s", szCapDir, szFname, szExt, DEFAULTPDBEXT);
      szPdb = new char[strlen(szBuf) + 1];
      strcpy(szPdb, szBuf);
   }
   else
   {
      char szCmdPdbDrive[_MAX_DRIVE];
      char szCmdPdbDir[_MAX_DIR];
      char szCmdPdbFname[_MAX_FNAME];
      char szCmdPdbExt[_MAX_EXT];

      _splitpath(szCmdPdb, szCmdPdbDrive, szCmdPdbDir, szCmdPdbFname, szCmdPdbExt);
      if (strlen(szCmdPdbDir) + strlen(szCmdPdbDrive))
      {
         char *szPdbDir = new char[strlen(szCmdPdbDir) + strlen(szCmdPdbDrive) + 1];
         sprintf(szPdbDir, "%s%s", szCmdPdbDrive, szCmdPdbDir);
         szPdbDir[strlen(szPdbDir) -1] = '\0';

         if ((strlen(szCmdPdbDir) > 1) && (_stat(szPdbDir, &rgStatBuf)))
         {
            char szbuf[512 + _MAX_DRIVE +_MAX_DIR];
            sprintf(szbuf, "The /pdb option specifies a directory '%s' which does not exist.\n", szPdbDir);
            Error(VErr::FLG_FATAL, szbuf);
         }
      }

      szPdb = szCmdPdb;
   }

   if (!fout)
   {
      sprintf(szBuf, "%s%s%s", szCapDir, szFname, szExt);
      szO = new char[strlen(szBuf) + 1];
      strcpy(szO, szBuf);
   }
   else
   {
      szO = szCmdO;
   }

}


void ReportCapFiles()
{
   if (!fTerse)
   {
      char szFullPath[_MAX_PATH];

      fprintf(stdout, "Input Files:\n");
      _fullpath(szFullPath, szImage, _MAX_PATH);
           fprintf(stdout, "\tInput Binary:\t%s\n", szFullPath);

           if (szCmd)
           {
              _fullpath(szFullPath, szCmd, _MAX_PATH);
              fprintf(stdout, "\tCommand File:\t%s\n", szFullPath);
           }

      fprintf(stdout, "Output Files:\n");
      _fullpath(szFullPath, szO, _MAX_PATH);
      fprintf(stdout, "\tOutput Binary:\t%s\n", szFullPath);

      if ((szPdb != NULL) && strlen(szPdb))
      {
         _fullpath(szFullPath, szPdb, _MAX_PATH);
              fprintf(stdout, "\tPDB File:\t%s\n", szFullPath);
      }

      if (fasm)
      {
         _fullpath(szFullPath, szAsm, _MAX_PATH);
              fprintf(stdout, "\tAsm File:\t%s\n", szFullPath);
      }
   }
}


int __cdecl cmpsz(const void *pv1, const void *pv2)
{
   return(strcmp(*((char **)pv1), *((char **)pv2)));
}


bool Include(const char *sz)
{
   /***********************************************************************
   * Utility to see if the named funtion is in the list of
   * functions to be excluded.
   ***********************************************************************/

   char *psz = (char *) bsearch(&sz, rgsz.Prgpsz(), rgsz.CpSz(), sizeof(char *), cmpsz);

   if (psz == NULL)
   {
      return(true);
   }
   else
   {
      return(false);
   }
}


void CMDFILEDEF::Exclude(unsigned, const char *sz)
{
   /***********************************************************************
   * Every capsize.exclude item is checked to make sure it is a valid
   * symbol in the executable and then, if valid, is added to a list to exclude it
   * from instrumentation.
   ***********************************************************************/

   if ((pComp->BlockFromSymName(sz)) == NULL)
   {
      char szbuf[512];
      sprintf(szbuf, "Undefined exclude symbol '%s' in command file '%s'.\n", sz, szCmd);
      Error(VErr::FLG_WARNING, szbuf);
   }
   else
   {
      rgsz.Insert(sz);
   }
}


bool HasJumpToBlock(VBlock *pTo, VProc *pProc)
{
   for (VBlock *pFrom = pProc->FirstAllBlock();
        pFrom != NULL;
        pFrom = pFrom->NextAll())
   {
      if (!pFrom->IsDataBlock())
      {
         if (pFrom->BlockTarget() == pTo)
         {
            return true;
         }
      }
      else
      {
         for (VRelocIter relocs(pFrom->FirstReloc());
              !relocs.Done();
              relocs.Next())
         {
            if (relocs.Curr()->RelocTarget() == pTo)
            {
               return true;
            }
         }
      }
   }

   return false;
}


bool HasFallToBlock(VBlock *pTo, VProc *pProc)
{
   VBlock *pFrom = pTo->PrevAll();

   if (pFrom == NULL)
   {
      // Perhaps a fall from last block of previous block

      VProc *pProcFrom = pProc->PrevAll();

      if (pProcFrom)
      {
         pFrom = pProcFrom->LastAllBlock();
      }
   }

   if (pFrom && !pFrom->IsDataBlock())
   {
      switch (pFrom->BlockTerminationType())
      {
         // It is far better to be safe than sorry

         case BlockTermUnknown:
         case BlockTermFallThrough:
         case BlockTermTrap:
         case BlockTermTrapCond:
         case BlockTermBranchCond:
         case BlockTermBranchCondIndirect:
         case BlockTermCall:
         case BlockTermCallIndirect:
         case BlockTermCallCond:
         case BlockTermCallCondIndirect:
         case BlockTermNop:
             return true;

         case BlockTermBranchIndirect:
         case BlockTermBranch:
         case BlockTermRet:
             return false;
      }
   }

   return false;
}

void MoveAllInstructions(VBlock *pFrom, VBlock *pTo)
{
   VInst *pInstPrev;

   for (VInst *pInst = pFrom->LastInst(); pInst; pInst = pInstPrev)
   {
      pInstPrev = pInst->Prev();

      pInst->Remove();
      pTo->InsertFirstInst(pInst);
   }
}


void RedictLocalJumps(VProc *pProc, VBlock *pFrom, VBlock *pTo)
{
   for (VBlock *pBlk = pProc->FirstAllBlock(); pBlk; pBlk = pBlk->NextAll())
   {
      if (pBlk->BlockTarget() == pFrom)
      {
         pBlk->SetBlockTarget( pTo );
      }
      else
      {
         for (VRelocIter relocs(pBlk->FirstReloc());
              !relocs.Done();
              relocs.Next())
         {
            VReloc *pReloc = relocs.Curr();

            if (pReloc->RelocTarget() == pFrom)
            {
               pReloc->SetRelocTarget(pTo);
            }
         }
      }
   }
}



void CapInst(VProg* vprog)
{
   /***********************************************************************
   * In CapInst() the first thing that is checked is if a pdb file can be written
   * and if a pdb file must be written.  If a pdb file is required but not
   * specified then a fatal error is displayed.  If a pdb file is specified but
   * cannot be written a warning is displayed.  Next the output name of the
   * executable and the pdb file is specified and the command file name (if one
   * was specified) is supplied.  These operations must be performed BEFORE an IR
   * is built by Vulcan and the next thing we do will build the IR,  so they have
   * to be taken care of first.
   ***********************************************************************/

   VProtoList *DlpEntryProtolist = VProtoList::CreateProtoList();
   VProtoList *DlpExitProtolist = VProtoList::CreateProtoList();

   for (pComp = vprog->FirstComp(); pComp; pComp = pComp->Next() )
   {
      if (pComp->CanWritePdb() && (szPdb == NULL))
      {
         Error(VErr::FLG_FATAL,
               "This executable (VC6 or higher) requires the /pdb option.");
      }

      if (!pComp->CanWritePdb() && (szPdb != NULL))
      {
         /*********************************************************************************
         * If the /pdb switch was explicitly set and the binary is not VC6 or greater
         * then produce a warning that the PDB cannot be written.   If the /pdb switch
         * was not explicitly set,  then the szPdb contains a pdb name generated as the
         * default name and since it is not VC6 or greater the pdb name should be ignored.
         *********************************************************************************/

         if(!fpdb)
         {
            szPdb = NULL;
         }
         else
         {
            Error(VErr::FLG_WARNING,
                  "The option '/pdb' is not required for linking VC50 or "
                  "earlier binaries - No PDB file generated.\n");
         }
      }

      if (pComp->IsEmittedByVulcan())
      {
         if (pComp->IsEmittedByBBT())
         {
            if (pComp->IsInstrumentedByBBT())
            {
               Error(VErr::FLG_FATAL,
                     "CAPSIZE cannot process a binary that was "
                     "emitted by the BBT tool BBINSTR.");
            }
         }

         else if (!pComp->IsRereadable())
         {
            Error(VErr::FLG_FATAL,
                  "CAPSIZE can only process an original binary, a BBOPT "
                  "binary or a DLLMERGE binary.");
         }

      }

      ReportCapFiles();
      size_t cInstProc = 0;
      size_t cExclude = 0;
      if (szCmd != NULL)
      {
         pComp->SetCommandFile(szCmd, &gszdictCmd);
      }

      /***********************************************************************
      * Next the command file is processed to interpret the commands for Capsize.  In
      * this case the "capsize.exclude" command is processed.  The command file
      * interpreter is managed by the RgszCapsizeCmdDict data structure.
      ***********************************************************************/

      if (szCmd != NULL)
      {
         CMDFILEDEF cmdfiledef;
         cmdfiledef.ProcessFile(szCmd, CMDFILEDEF::rgcmddef, &gszdictCmd);

         qsort((void *)rgsz.Prgpsz(), rgsz.CpSz(), sizeof(char *), SortByIncreasingFunctionNames);
      }

      VBlock *vbblock = pComp->CreateImport(szDll, szEntry);

      /***********************************************************************
      * Next an import is created to the ICAP.DLL and a JMP to that import is built.
      ***********************************************************************/

      // Create a thunk to to the import block

      VInst *vinst = VInst::Create(COp::JMP, VAddress::Create(vbblock));
      VBlock *vbblockImport = VBlock::CreateCodeBlock(pComp);
      unsigned int blkidIceCAPImport = vbblockImport->BlockId();
      vbblockImport->InsertFirstInst(vinst);
      VProc *vprocNew = VProc::Create(pComp, (char *) NULL); //->NewProc();
      pComp->InsertLastProc(vprocNew);
      vprocNew->InsertFirstBlock(vbblockImport);
      VProto* DlpEntryProto = NULL;
      VProto* DlpExitProto = NULL;

      if (fDlp)
      {
         DlpEntryProto = DlpEntryProtolist->CreateProto(pComp,
                                                        szDll,
                                                        "_CAP_EnterFunction()",
                                                        FALSE);

         DlpExitProto = DlpExitProtolist->CreateProto(pComp,
                                                      szDll,
                                                      "_CAP_ExitFunction()",
                                                      FALSE);
      }

      if (fVerbose || fTerse)
      {
         if (fDlp)
         {
            printf("Instrumenting: %s\n"
                   "         with: %s:%s\n"
                   "           to: %s\n", szImage, "Dlp", szDll, szO);
         }
         else
         {
            printf("Instrumenting: %s\n"
                   "         with: %s:%s\n"
                   "           to: %s\n", szImage, szEntry, szDll, szO);
         }

         if (fVerbose)
            printf("\nProcedures: \n");
      }


      /***********************************************************************
      * Instrumentation is added at each entry point
      ***********************************************************************/

      for (VProc *pProc = pComp->FirstProc(); pProc; pProc = pProc->Next() )
      {
         VBlock *vbblock = pProc->FirstBlock();
         char szName[4096];

         if (!vbblock->SymName(szName, sizeof(szName), pComp, 0))
         {
            continue;
         }

         if (strcmp(szName, "_setjmp") == 0)
         {
            continue;
         }

         if (strcmp(szName, "_setjmp3") == 0)
         {
            continue;
         }

         if (strcmp(szName, "__setjmp3") == 0)
         {
            // Excel copied the CRT implementation to their own source tree
            // and added an extra leading underscore to the proc name because
            // they don't rely on MASM to decorate names and add an underscore
            // to public symbol names.

            continue;
         }

         if (strncmp(szName, "__tailMerge_", 12) == 0)
         {
            continue;
         }

         if (vbblock->BlockId() == blkidIceCAPImport)
         {
            // We don't want to instrument our insert import thunk

            continue;
         }

         if (Include(szName))
         {
             cInstProc++;

             if (fVerbose)
             {
                     printf("\t%s\n",szName);
             }

             if (fDlp)
             {
                     DlpEntryProto->AddCall(pProc, BEFORE);
                     DlpExitProto->AddCall(pProc, AFTER);
             }
             else
             {
                 // We need to add _penter2 calls at the beginning of each
                 // entry point into the procedure.  However, we need to
                 // avoid calling _penter2 when we fall through or jump to
                 // these entry points.

                 for ( vbblock = pProc->FirstBlock();
                       vbblock;
                       vbblock = vbblock->Next())
                 {

                     // First, handle jumps to other procedures by patching
                     // the target if it hasn't already been done.

                     BlockTermType trmt = vbblock->BlockTerminationType();

                     if ( trmt == BlockTermBranch  ||
                          trmt == BlockTermBranchCond  ||
                          trmt == BlockTermBranchCondIndirect ||
                          trmt == BlockTermBranchIndirect )
                     {
                        VBlock *pBlkTarget = vbblock->BlockTarget();
                        if (pBlkTarget && pBlkTarget->IsEntryBlock())
                        {
                           VProc *pProcTarget = pBlkTarget->ParentProc();
                           if (pProcTarget != pProc)
                           {
                              // We have a branch or jump to another procedure.
                              // We need to make sure that we do not hit
                              // _penter2 when going into that proc.  There are
                              // four cases to deal with:

                              VInst *pInstInstr = pBlkTarget->FirstInst();

                              if (pInstInstr)
                              {
                                 COp::EOp opInstr = pInstInstr->Opcode();
                                 if (opInstr == COp::CALL &&
                                     pInstInstr->BlockTarget() == vbblockImport)
                                 {
                                    // We have already added instrumentation

                                    if (pInstInstr->Next() == NULL)
                                    {
                                       // Case 1: This entry point has already
                                       // been patched and instrumented.

                                       vbblock->SetBlockTarget(pBlkTarget->Next());
                                    }
                                    else
                                    {
                                       // Case 2: This entry point has been
                                       // instrumented, but not patched.

                                       VBlock *pOldInsts = VBlock::CreateCodeBlock(pComp);
                                       pBlkTarget->InsertNext(pOldInsts);

                                       pInstInstr->Remove();
                                       MoveAllInstructions(pBlkTarget, pOldInsts);
                                       pBlkTarget->InsertFirstInst(pInstInstr);

                                       vbblock->SetBlockTarget(pOldInsts);
                                    }
                                 }
                                 else
                                 {
                                    // Case 3: this proc has not been
                                    // instrumented and has not been patched.

                                    VBlock *pOldInsts = VBlock::CreateCodeBlock(pComp);
                                    pBlkTarget->InsertNext(pOldInsts);

                                    MoveAllInstructions(pBlkTarget, pOldInsts);
                                    vbblock->SetBlockTarget(pOldInsts);
                                 }
                              }
                              else
                              {
                                 // Case 4: this proc has been patched, but not
                                 // instrumented.

                                 vbblock->SetBlockTarget( pBlkTarget->Next() );
                              }
                           }
                        }
                     }

                     // Now actually do the instrumentation of the entry blocks

                     if (vbblock->IsEntryBlock())
                     {
                         VBlock *pOldInsts = NULL;
                         bool fJumpedTo = HasJumpToBlock(vbblock, pProc);
                         bool fFallTo   = HasFallToBlock(vbblock, pProc);

                         if (fJumpedTo || fFallTo)
                         {
                            if (NULL != vbblock->FirstInst())
                            {
                               // We need to patch the entry block
                               pOldInsts = VBlock::CreateCodeBlock(pComp);
                               vbblock->InsertNext(pOldInsts);

                               MoveAllInstructions(vbblock, pOldInsts);
                            }
                            else
                            {
                               // We have already patched this entry
                               pOldInsts = vbblock->Next();
                            }

                            RedictLocalJumps(pProc, vbblock, pOldInsts);
                         }

                         if (fFallTo)
                         {
                             // Add a jump to handle the fall into as well
                             // without calling _penter2.

                             VBlock *pDummy = VBlock::CreateCodeBlock(pComp);
                             vbblock->InsertPrev(pDummy);

                             // Add an instruction to skip over the _penter2 block

                             pDummy->InsertFirstInst( VInst::Create(COp::JMP,
                                                      pOldInsts) );
                         }

                         // Add the instrumentation instruction

                         vbblock->InsertFirstInst(VInst::Create(COp::CALL,
                                                                vbblockImport));
                     }
                 }
             }
         }

         else
         {
            cExclude++;
         }
      }

      if (fVerbose || fTerse)
      {
         printf("%u procedures have been instrumented.\n", cInstProc);

         if (cExclude > 0)
         {
              printf("%u procedures have been excluded from instrumentation.", cExclude);
         }
      }

      /**********************************************************************
      * The vprog object is committed and written.  The write will create the
      * specified PDB and executables that were named in the OutputPDBName
      * and OutputName methods.
      ***********************************************************************/

      if (fDlp)
      {
         DlpEntryProtolist->Commit();
         DlpExitProtolist->Commit();
      }

      if ( fWriteFast )
      {
         pComp->WriteFast(szO, szPdb);
      }

      else
      {
         pComp->Write(szO, szPdb);
      }

      if (szAsm != NULL)
      {
         pComp->PrintAsm(szAsm);
      }
   }
}


int RealMain(int argc, char *argv[])
{
   /***********************************************************************
   *
   * RealMain() uses the Vulcan supplied command line interpreter to interpret the
   * arguments (inside InitParams) and then makes sure that output file selected
   * for the instrumented executable is not the same as the input executable.
   * Finally the constructor for the Vulcan program is called and then the Capsize
   * process can begin.
   *
   ***********************************************************************/

   InitParams(argc, argv);

   if (CMDLINE::FSamePath(szO, szImage))
   {
      Error(VErr::FLG_FATAL,"Capsized binary will overwrite input image file");
   }

   DWORD openFlags = 0;
   if ( fCompact )
   {
      openFlags |= Open_CompactBlocks;
   }
   VProg *vprog = VProg::Open( szImage, szCmd, openFlags );

   // Currently only X86 PE binaries are supported.
   //
   if (vprog->FirstComp()->InputType() != VComp::PE)
   {
      Error(VErr::FLG_FATAL, "Unsupported architecture.");
      exit(1);
   }

   CapInst(vprog);

   // To save time, we don't destroy the program object
   // vprog->Destroy();

   // Some info about the block types.
   if ( fBlockInfo )
   {
      VBlock::PrintBlockStats( "" );
   }

   return(0);
}


int __cdecl main(int argc, char *argv[])
{
   /***********************************************************************
   *
   * main() establishes the name of the utility as CAPSIZE for the default
   * error handler and then goes on to try running the real program.  If a
   * throw occurs whiles processing with Vulcan,  the error is flagged
   * as fatal and the default error handler is called to display the message.
   *
   ***********************************************************************/

   VErr::SetErrHandler("CAPSIZE");

   try
   {
      return RealMain(argc, argv);
   }
   catch (VErr &verr)
   {
      verr.SetFatal();
      verr.DoErrHandler();
   }

   return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\Vulcan\Samples\src\Capsize\cmddict.h ===
/***********************************************************************
* Microsoft Vulcan
*
* Microsoft Confidential.  Copyright 1997-1999 Microsoft Corporation.
*
* Component:
*
* File: cmddict.h
*
* File Comments:
*
*
***********************************************************************/

extern const char * const RgszBBTGlobalCommandFileDictionary[];
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\Vulcan\Samples\src\Calls\calls.cpp ===
/***********************************************************************
* Microsoft  Vulcan
*
* Microsoft Confidential.  Copyright 1997-2000 Microsoft Corporation.
*
* File: Calls.cpp
*
* File Comments:
*
*
***********************************************************************/
#include "vulcanapi.h"

#include <string.h>
#include <stdio.h>

char* ProgramName = 0;
char* CommandFile = 0;
char badstr[3000];

char* ModName(const char* origname, const char* app)
{
   char* start;
   char* end;
   char copy[900];

   strcpy (copy,origname);
   start = strtok(copy,".");
   end = strtok (0,".");
   sprintf(badstr, "%s.%s.%s", start, app, end);
   return badstr;
}

void OrderedCalls()
{
   // Results should be comp before,...,Inst before printed out

   VProg *vprog = VProg::Open(ProgramName);
   VProtoList *vprotolist = VProtoList::CreateProtoList();

   for (VComp* pComp = vprog->FirstComp(); pComp; pComp = pComp->Next())
   {
      pComp->SetCommandFile(CommandFile);
      VProto* vprotoStrInt = vprotolist->CreateProto(pComp,
                                                     "callsdll.dll",
                                                     "SendStrInt(char*,int)");

      VBlock *pBlock = pComp->EntryBlock();
      vprotoStrInt->AddCall(pBlock, BEFORE, "proc Before", 1234);

      for (VBBlock *pBlk = pBlock->ParentProc()->FirstBlock();
           pBlk;
           pBlk = pBlk->Next())
      {
         for (VInst *pInst = pBlk->FirstInst();pInst;pInst = pInst->Next())
         {
            vprotoStrInt->AddCall(pInst, BEFORE, "inst before", 22);
         }

         vprotoStrInt->AddCall(pBlk, BEFORE, "block Before", 134);
      }

      vprotoStrInt->AddCall(pComp, BEFORE, "comp before", 1212);
      vprotolist->Commit();
      pComp->Write(ModName(pComp->InputName(),"ORDER"));
   }

   vprog->Destroy();
}



void DoubleCalls()
{
   // Testing double parameters

   VProg *vprog = VProg::Open(ProgramName);
   VProtoList *vprotolist = VProtoList::CreateProtoList();

   for (VComp* pComp = vprog->FirstComp(); pComp; pComp = pComp->Next())
   {
      pComp->SetCommandFile(CommandFile);
      VProto* vprotoStrInt = vprotolist->CreateProto(pComp,
                                                     "callsdll.dll",
                                                     "SendStrInt(char*,int)");

      for(VProc *pProc = pComp->FirstProc(); pProc; pProc = pProc->Next())
      {
         vprotoStrInt->AddCall(pProc, BEFORE, pProc->Name(), 1234);
      }

      vprotolist->Commit();
      pComp->Write(ModName(pComp->InputName(), "DOUBLE"));
   }
   vprog->Destroy();
}


void RegCalls()
{
   // Testing Register Arguments

   VProg *vprog = VProg::Open(ProgramName);
   VProtoList *vprotolist = VProtoList::CreateProtoList();

   for (VComp* pComp = vprog->FirstComp(); pComp; pComp = pComp->Next())
   {
      pComp->SetCommandFile(CommandFile);
      VProto* bbProto = vprotolist->CreateProto(pComp,
                                                "callsdll.dll",
                                                "SendInt(reg)");

      for(VProc *pProc = pComp->FirstProc(); pProc; pProc = pProc->Next())
      {
         bbProto->AddCall(pProc, BEFORE, X86Register::ESP);
      }

      vprotolist->Commit();
      pComp->Write(ModName(pComp->InputName(), "REG"));
   }
   vprog->Destroy();
}


void FlagsCalls()
{
   // Testing Condcode

   VProg *vprog = VProg::Open(ProgramName);
   VProtoList *vprotolist = VProtoList::CreateProtoList();

   for (VComp* pComp = vprog->FirstComp(); pComp; pComp = pComp->Next())
   {
      pComp->SetCommandFile(CommandFile);
      VProto* bbProto = vprotolist->CreateProto(pComp,
                                                "callsdll.dll",
                                                "SendInt(condcode)");

      for(VProc *pProc = pComp->FirstProc(); pProc; pProc = pProc->Next())
      {
         const char* name = pProc->Name();
         bbProto->AddCall(pProc, BEFORE, COp::ISETZ);
      }
      vprotolist->Commit();
      pComp->Write(ModName(pComp->InputName(), "FLAG"));
   }
   vprog->Destroy();
}

void SwapCalls()
{
   // Testing Exchangeproc

   VProg *vprog = VProg::Open(ProgramName);
   VProtoList *vprotolist = VProtoList::CreateProtoList();

   for (VComp* pComp = vprog->FirstComp(); pComp; pComp=pComp->Next())
   {
      pComp->SetCommandFile(CommandFile);
      VProc *ep = pComp->CreateImportThunk("callsdll.dll", "Handler");

      VProto* vproto = vprotolist->CreateProto(pComp,
                                               "callsdll.dll",
                                               "GetPointer(bblockaddr)");

      VProto* vprotoEff = vprotolist->CreateProto(pComp,
                                                  "callsdll.dll",
                                                  "SendEff(eff)");

      for(VProc *pProc = pComp->FirstProc();pProc;pProc = pProc->Next())
      {
         const char* name = pProc->Name();

         if (strstr(name,"::operator new"))
         {
            printf("%s is being changed\n", name);
            VBBlock *temp = pComp->RedirectProc( pProc, ep);
            vproto->AddCall(pProc, BEFORE, temp);
         }
      }

      vprotolist->Commit();
      pComp->Write(ModName(pComp->InputName(), "SWAP"));
   }
   vprog->Destroy();
}

void EffCalls()
{
   // Testing effective Address

   VProg *vprog = VProg::Open(ProgramName);
   VProtoList *vprotolist = VProtoList::CreateProtoList();

   for (VComp* pComp = vprog->FirstComp(); pComp; pComp = pComp->Next())
   {
      pComp->SetCommandFile(CommandFile);
      VProto* vprotoEff = vprotolist->CreateProto(pComp,
                                                  "callsdll.dll",
                                                  "SendEff(eff)");

      for(VProc *pProc = pComp->FirstProc(); pProc; pProc = pProc->Next())
      {
         for (VBBlock *pBlk = pProc->FirstBlock(); pBlk; pBlk = pBlk->Next())
         {
            for (VInst *vinst = pBlk->FirstInst(); vinst; vinst = vinst->Next())
            {
               if ((vinst->ReadsMemory()   ||
                    vinst->WritesMemory()) &&
                    !(vinst->StackMemory()))
               {
                  vprotoEff->AddCall(vinst, BEFORE, Eff::ANY);
               }
            }
         }
      }

      vprotolist->Commit();
      pComp->Write(ModName(pComp->InputName(), "EFF"));
   }

   vprog->Destroy();
}



void BlockCalls()
{
   // Testing: BEFORE and AFTER on BBlocks.
   // Testing: follower and target
   // Testing: int as parameter

   VProg *vprog = VProg::Open(ProgramName);
   VProtoList *vprotolist = VProtoList::CreateProtoList();

   for (VComp* pComp = vprog->FirstComp(); pComp; pComp=pComp->Next())
   {
      pComp->SetCommandFile(CommandFile);
      VProto* vprotoInt = vprotolist->CreateProto(pComp,
                                                  "callsdll.dll",
                                                  "SendInt(int)");

      for(VProc *pProc = pComp->FirstProc(); pProc; pProc = pProc->Next())
      {
         for (VBBlock *pBlk = pProc->FirstBlock(); pBlk; pBlk = pBlk->Next())
         {
            vprotoInt->AddCall(pBlk,
                               BEFORE,
                               pBlk->BlockTarget() ?
                                    pBlk->BlockTarget()->BlockId() : 0);

            vprotoInt->AddCall(pBlk,
                               AFTER,
                               pBlk->BlockFollower() ?
                                    pBlk->BlockFollower()->BlockId() : 0);
         }
      }

      vprotolist->Commit();
      pComp->Write(ModName(pComp->InputName(), "BT"));
   }

   vprog->Destroy();
}

void ProcCalls()
{
   // Testing: BEFORE and AFTER on Procs.
   // Testing: putting calls on top of each other.
   // Testing: Char* as parameter.

   VProg *vprog = VProg::Open(ProgramName);
   VProtoList *vprotolist = VProtoList::CreateProtoList();

   for (VComp* pComp = vprog->FirstComp(); pComp; pComp = pComp->Next())
   {
      pComp->SetCommandFile(CommandFile);
      VProto* vprotoStr = vprotolist->CreateProto(pComp,
                                                  "callsdll.dll",
                                                  "SendStr(char*)");

      for(VProc *pProc=pComp->FirstProc(); pProc; pProc = pProc->Next())
      {
         sprintf(badstr,"entering %s",pProc->Name());
         vprotoStr->AddCall(pProc,BEFORE,"\n");
         vprotoStr->AddCall(pProc,BEFORE,badstr);

         sprintf(badstr,"exiting %s",pProc->Name());
         vprotoStr->AddCall(pProc,AFTER,badstr);
         vprotoStr->AddCall(pProc,BEFORE,"\n");
      }

      vprotolist->Commit();
      pComp->Write(ModName(pComp->InputName(), "PT"));
   }

   vprog->Destroy();
}


void CompCalls()
{
   // Testing Comp calls

   VProg *vprog = VProg::Open(ProgramName);
   VProtoList *vprotolist = VProtoList::CreateProtoList();

   for (VComp* pComp = vprog->FirstComp(); pComp; pComp = pComp->Next())
   {
      pComp->SetCommandFile(CommandFile);
      VProto* vprotoStr = vprotolist->CreateProto(pComp,"callsdll.dll","SendStr(char*)");

      for (int i=0;i<10;i++)
      {
         char temp[4000];
         sprintf(temp,"%d\n",i);
         vprotoStr->AddCall(pComp, BEFORE, temp);
      }

      vprotolist->Commit();
      pComp->Write(ModName(pComp->InputName(), "CT"));
   }

   vprog->Destroy();
}

int __cdecl main(int argc, char** argv)
{
   if (argc < 2)
   {
       printf("Usage: CALLS [image-name]\n");
       return 1;
   }

   ProgramName = argv[1];
   CommandFile = argv[2];
   try
   {
      CompCalls();
      ProcCalls();
      BlockCalls();
      EffCalls();
      RegCalls();
      SwapCalls();
      FlagsCalls();
      DoubleCalls();
      OrderedCalls();
   }

   catch (VErr& verr)
   {
      printf("Error: %s\n", verr.GetWhat());
      return 1;
   }

   catch (...)
   {
      printf("Error: Unknown\n");
      return 1;
   }

   return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\Vulcan\Samples\src\DynInstCount\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by DynInstCountDll.rc
//
#define IDD_STATUSDLG                   101
#define IDC_ALLOCSIZE                   1000
#define IDC_INSTRUCTIONS                1000
#define IDC_FUNCTIONS                   1002

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1003
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\Vulcan\Samples\src\Fields\fields.cpp ===
/***********************************************************************
* Microsoft  Vulcan
*
* Microsoft Confidential.  Copyright 1997-2000 Microsoft Corporation.
*
* File: Fields.cpp
*
* File Comments:
*  This program demonstrates the VSymbol interface.
*
*
***********************************************************************/
#pragma warning(disable: 4514)

#include "vulcanapi.h"

#include <stdlib.h>
#include <stdio.h>

int __cdecl main(int argc, char** argv);
void __stdcall Myhandler(VErr verr);
void UIFields(char* szImage);

void Indent( int cIndent )
{
   for (int i=0; i<cIndent; i++)
   {
      printf("\t");
   }
}

void ProcessSym( VSymbol *pSym, int cIndent )
{
   // Only go so deep
   if (cIndent > 3)
   {
      return;
   }

   if (pSym)
   {
      Indent( cIndent );
      printf("%d %s : ", pSym->Offset(), pSym->Name() );

      char szBuf[1024];
      pSym->Type(szBuf, sizeof(szBuf));
      printf("%s\n", szBuf );

      if (pSym->IsBitField())
      {
         Indent( cIndent + 1);
         printf("BitField (%d+%d)\n", pSym->BitOffset(), pSym->BitSize() );
      }

      bool fPointer = false;
      while (pSym->IsPointer())
      {
         if (!fPointer)
         {
            fPointer = true;
            Indent( cIndent + 1 );
         }
         printf("->");
         pSym = pSym->PTarget();

         if (NULL == pSym)
         {
            printf("\n");
            return;
         }
      }
      if (fPointer)
      {
         printf("\n");
      }

      for (VSymbol *pField = pSym->FirstField(); pField; pField = pField->Next())
      {
         ProcessSym( pField, cIndent + 1 );
      }

      bool fBases = false;
      for (VSymbol *pBase = pSym->FirstBase(); pField; pField = pField->Next())
      {
         if (!fBases)
         {
            Indent( cIndent );

            printf("Base classes:\n");
         }

         ProcessSym( pBase, cIndent + 1 );
      }
   }
}


void UIFields(char* szImage)
{
   VProg *pprog = VProg::Open(szImage);
   int count = 0;

   for(VComp *pComp = pprog->FirstComp(); pComp; pComp = pComp->Next())
   {
      printf("%s\n",pComp->InputName());
      for(VProc *pProc = pComp->FirstProc(); pProc; pProc = pProc->Next())
      {
         printf("%s:\n", pProc->Name() );
          
         VSymbol *pSym;

         for (pSym = pProc->FirstParam(pComp); pSym; pSym = pSym->Next())
         {
            ProcessSym( pSym, 1 );
         }

         for (pSym = pProc->FirstLocal(pComp); pSym; pSym = pSym->Next())
         {
            ProcessSym( pSym, 1 );
         }

         ProcessSym( pProc->ReturnSymbol(pComp), 1 );
      }
   }

   // To save time, we don't destroy the program object
   // pprog->Destroy();
}


int __cdecl main(int argc, char** argv)
{

   if (argc != 2)
   {
      printf("Fields:   fields foo.exe\n");
      return 1;
   }

   try
   {
      UIFields(argv[1]);
   }
   catch (VErr& verr) 
   {
      printf("Error: %s\n",verr.GetWhat());
      return 1;
   }
   catch (...)
   {
      printf("Error: unknown\n");
      return 1; 
   }

   return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\Vulcan\Samples\src\FlyingICount\FlyingICount.h ===
/***********************************************************************
* Microsoft  Vulcan
*
* Microsoft Confidential.  Copyright 1997-1999 Microsoft Corporation.
*
* File: FlyingICount.h
*
* File Comments:
*
*
***********************************************************************/


void RefreshProcesses();
void RefreshModules(VProg *pProg);
void RefreshFunctions(VComp *pComp);
void SetInstrumentation(VProc *pProc);
int GetCounter();

void ClearProgramList();
void ClearComponentList();    
void ClearFunctionList();

void AddProgramToList( const char *sz, VProg *pProg );
void AddComponentToList( const char *sz, VComp *pComp );
void AddFunctionToList( const char *sz, VProc *pProc );

void Error( const char *sz );
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\Vulcan\Samples\src\DynInstCount\dyninstcountdll.cpp ===
/***********************************************************************
* Microsoft  Vulcan
*
* Microsoft Confidential.  Copyright 1997-2000 Microsoft Corporation.
*
* File: DynInstCountDll.cpp
*
* File Comments:
*
*
***********************************************************************/
#include <stdio.h>

#define STRICT
#define WIN32_LEAN_AND_MEAN
#include "windows.h"
#include "commctrl.h"
#include "vulcanapi.h"

#pragma comment(lib, "user32.lib")
#pragma comment(lib, "kernel32.lib")
#pragma comment(lib, "gdi32.lib")

void OutputDataToFile();
int *rgDynInstCount;
int cProc;
const char *pchNames;

extern "C" _declspec (dllexport)
void _cdecl SavePDynInstCount(int *p, int c, char *pch)
{
    rgDynInstCount = p;
    pchNames = pch;
    cProc = c;
}

// Code for handling the window
#include "resource.h"
#include <list>


DWORD WINAPI VAWnd( void *);
HINSTANCE hInst;
HWND hWnd;

extern "C" BOOL __stdcall DllMain(HINSTANCE hModule, DWORD dwReason, LPVOID)
{
   switch (dwReason)
   {
      case DLL_PROCESS_ATTACH :
         hInst = hModule;
         CreateThread( NULL, 0, &VAWnd, NULL, 0, NULL );
         break;

      case DLL_PROCESS_DETACH :
         OutputDataToFile();
         break;
   }

   return(TRUE);
}

struct FUNDATA
{
    const char *m_szFun;
    __int64 m_cPrev;
};

FUNDATA *v_rgFD;
VComp *v_pComp;

int CALLBACK CmpFunItem( LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort )
{
    FUNDATA *p1 = (FUNDATA *)lParam1;
    FUNDATA *p2 = (FUNDATA *)lParam2;

    if (p2->m_cPrev > p1->m_cPrev)
    {
        return 1;
    }
    else if (p2->m_cPrev < p1->m_cPrev)
    {
        return -1;
    }
    else
    {
        return 0;
    }
}

std::list< int * > lstOverTimes;

void OutputOverTime()
{
   int *rgTimes = new int[ cProc + 1 ];

   lstOverTimes.push_back( rgTimes );

   rgTimes[cProc] = 0;
   for (int i=0; i<cProc; i++)
   {
      rgTimes[cProc] += rgTimes[i] = rgDynInstCount[i];
   }
    
}

__int64 UpdateCount( FUNDATA * pFD )
{
   int iProc = pFD - v_rgFD;

   pFD->m_cPrev += rgDynInstCount[iProc];
   rgDynInstCount[iProc] = 0;

   return pFD->m_cPrev;
}

int _cdecl cmpIFun( const void *pv1, const void *pv2)
{
   int i1 = *(const int *)pv1;
   int i2 = *(const int *)pv2;

   if (v_rgFD[i1].m_cPrev < v_rgFD[i2].m_cPrev)
   {
       return 1;
   }
   else if (v_rgFD[i1].m_cPrev > v_rgFD[i2].m_cPrev)
   {
       return -1;
   }
   else
   {
       return 0;
   }
}

void OutputDataToFile()
{
   if (v_rgFD)
   {
      OutputOverTime();

      int *rgFunSort = new int[ cProc ];
      for ( int iFun = 0; iFun < cProc; iFun ++)
      {
         UpdateCount( v_rgFD + iFun );
         rgFunSort[iFun] = iFun;
      }
      qsort( rgFunSort, cProc, sizeof(int), cmpIFun );

      FILE *pf = fopen( "dyninstcount.log", "w" );

      for ( iFun = 0; iFun < cProc; iFun ++)
      {
         int iSort = rgFunSort[iFun];
         fprintf(pf, "%I64d\t%s\n", v_rgFD[iSort].m_cPrev , v_rgFD[iSort].m_szFun );
      }

      fclose( pf );


      pf = fopen( "OverTime.log", "w" );
      for ( iFun = 0; iFun < min(cProc,50); iFun ++)
      {
         int iSort = rgFunSort[iFun];
         fprintf(pf, "%s\t", v_rgFD[iSort].m_szFun );
      }
      fprintf(pf, "Others\n");

      for (std::list< int * >::iterator i =  lstOverTimes.begin(); i != lstOverTimes.end(); i++)
      {
         int cRest = (*i)[cProc];

         for ( iFun = 0; iFun < min(cProc,50); iFun ++)
         {
            int iSort = rgFunSort[iFun];
            cRest -= (*i)[iSort];
            fprintf(pf, "%d\t", (*i)[iSort] );
         }

         fprintf(pf, "%d\n", cRest );
      }

      fclose(pf);
      delete [] rgFunSort;
   }
}

BOOL CALLBACK VADlgProc( HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
   static DWORD mytimer;
   
   switch (msg)
   {
      case WM_INITDIALOG:
      {
         // Add 2 columns to the listview
         HWND hwndList = GetDlgItem( hwnd, IDC_FUNCTIONS );
         LV_COLUMN lvc;
         lvc.mask = LVCF_SUBITEM | LVCF_TEXT | LVCF_WIDTH | LVCF_FMT;
         lvc.cx = 150;
         lvc.fmt = LVCFMT_LEFT;
         lvc.pszText = "Function";
         lvc.iSubItem = 0;
         ListView_InsertColumn( hwndList, 0, &lvc );
         
         lvc.cx = 100;
         lvc.pszText = "Dyn Inst Count";
         lvc.iSubItem = 1;
         ListView_InsertColumn( hwndList, 1, &lvc );
         
         // Open data file and read it in
         int iFun = 0;
         v_rgFD = new FUNDATA[ cProc ];
         const char *pch = pchNames;

         for (iFun = 0; iFun < cProc; iFun++)
         {
             FUNDATA *pFD = v_rgFD + iFun;
             pFD->m_cPrev = 0;

             pFD->m_szFun = pch;
             pch += strlen(pch) + 1;

             // Add to list control
             LV_ITEM lvi;
             lvi.mask = LVIF_PARAM | LVIF_TEXT;
             lvi.iItem = iFun;
             lvi.iSubItem = 0;
             lvi.pszText = (char *)pFD->m_szFun;
             lvi.lParam = LPARAM(pFD);

             ListView_InsertItem( hwndList, &lvi );

             char sz[25];
             sprintf(sz, "%u", 0 );
             lvi.mask = LVIF_TEXT;
             lvi.iItem = iFun;
             lvi.iSubItem = 1;
             lvi.pszText = sz;
             lvi.lParam = LPARAM(pFD);

             ListView_InsertItem( hwndList, &lvi );
         }

         OutputOverTime();

         mytimer = SetTimer(hwnd, 42, 1000, NULL );
         break;
      }

      case WM_TIMER:
      {
         if ( mytimer == wParam)
         {
            OutputOverTime();
                 HWND hwndList = GetDlgItem( hwnd, IDC_FUNCTIONS );

            // Update the IC column

            for ( int iFun = 0; iFun < cProc; iFun ++)
            {
               LV_ITEM lvi;
               lvi.mask = LVIF_PARAM;
               lvi.iItem = iFun;
               lvi.iSubItem = 0;

               if (ListView_GetItem( hwndList, &lvi ))
               {
                  FUNDATA *pfd = (FUNDATA *)lvi.lParam;

                  char sz[25];
                  __int64 i = UpdateCount(pfd);
                                      sprintf(sz, "%I64d",  i);

                  lvi.mask = LVIF_TEXT;
                  lvi.iItem = iFun;
                  lvi.iSubItem = 1;
                  lvi.pszText = sz;

                  ListView_SetItem( hwndList, &lvi );
               }
            }

            ListView_SortItems( hwndList, CmpFunItem, 0 );
         }
         break;
      }
   }
   
   return false;
}

#pragma comment( lib, "comctl32.lib" )

DWORD WINAPI VAWnd( void *)
{
   INITCOMMONCONTROLSEX icc;
   icc.dwSize = sizeof(INITCOMMONCONTROLSEX);
   icc.dwICC = ICC_LISTVIEW_CLASSES;
   InitCommonControlsEx( &icc );

   hWnd = CreateDialog(hInst, MAKEINTRESOURCE(IDD_STATUSDLG), NULL, VADlgProc ); 
   DWORD dw = GetLastError();
   ShowWindow(hWnd, SW_SHOW);

   // Pump messages

   while (1)
   {
      MSG msg;
      BOOL f = GetMessage( &msg, NULL, 0, 0 );
      if (!f)
      {
         return 0; //done
      }

      if (f != -1)
      {
         TranslateMessage( &msg );
         DispatchMessage( &msg );
      }
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\Vulcan\Samples\src\FlyingICount\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by FlyingICount.rc
//
#define IDD_STATUSDLG                   101
#define IDC_COMPONENT                   1002
#define IDC_PROCESS                     1003
#define IDC_ICOUNT                      1004
#define IDC_FUNCTION                    1005
#define IDC_REFRESH                     1006

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1007
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\Vulcan\Samples\src\FlyingICount\FlyingICountUI.cpp ===
/***********************************************************************
* Microsoft  Vulcan
*
* Microsoft Confidential.  Copyright 1997-2000 Microsoft Corporation.
*
* File: FlyingICountUI.cpp
*
* File Comments:
*
*
***********************************************************************/

#include <stdio.h>

#define STRICT
#define WIN32_LEAN_AND_MEAN
#include "windows.h"
#include "commctrl.h"
#include "resource.h"

#pragma comment(lib, "user32.lib")
#pragma comment(lib, "kernel32.lib")
#pragma comment(lib, "gdi32.lib")
#pragma comment(lib, "comctl32.lib" )

class VProg;
class VComp;
class VProc;
#include "flyingicount.h"

HWND hWndProcesses;
HWND hWndModules;
HWND hWndProcedures;


BOOL CALLBACK VADlgProc( HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

BOOL __stdcall WinMain(HINSTANCE hModule, HINSTANCE hInst, LPSTR lpCmdLine, int nCmdShow)
{
   INITCOMMONCONTROLSEX icc;
   icc.dwSize = sizeof(INITCOMMONCONTROLSEX);
   icc.dwICC = ICC_LISTVIEW_CLASSES;
   InitCommonControlsEx( &icc );

   HWND hWnd = CreateDialog(hInst, MAKEINTRESOURCE(IDD_STATUSDLG), NULL, VADlgProc ); 
   ShowWindow(hWnd, nCmdShow);

   //pump messages
   while (1)
   {
      MSG msg;
      BOOL f = GetMessage( &msg, NULL, 0, 0 );
      if (!f)
      {
         return 0; //done
      }

      if (f != -1)
      {
         TranslateMessage( &msg );
         DispatchMessage( &msg );
      }
   }
}

BOOL CALLBACK VADlgProc( HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
   static DWORD mytimer;
   
   switch (msg)
   {
      case WM_INITDIALOG:
      {
         hWndProcesses  = GetDlgItem( hWnd, IDC_PROCESS );
         hWndModules    = GetDlgItem( hWnd, IDC_COMPONENT );
         hWndProcedures = GetDlgItem( hWnd, IDC_FUNCTION );

         // Fill the process list
         RefreshProcesses();

         SetTimer( hWnd, 42, 100, NULL );
         return true;
      }

      case WM_TIMER:
      {
          if (wParam == 42)
          {
              int i = GetCounter();
              SetDlgItemInt( hWnd, IDC_ICOUNT, i, false );
              return true;
          }
      }

      case WM_CLOSE:
      {
          PostQuitMessage(0);
          EndDialog( hWnd, 0 );
          return true;
      }

      case WM_COMMAND:
      {
          DWORD idCtrl = LOWORD(wParam);
          switch (HIWORD(wParam))
          {
              case LBN_SELCHANGE:
                  switch (idCtrl)
                  {
                      case IDC_PROCESS:
                      {
                          int iSel = SendMessage( hWndProcesses, LB_GETCURSEL, 0, 0 ); 
                          VProg *pProg = NULL;
                          if (iSel != LB_ERR)
                          {
                             pProg = (VProg *)SendMessage( hWndProcesses, LB_GETITEMDATA, iSel, 0 );
                          }
                          
                          RefreshModules(pProg);
                          break;
                      }

                      case IDC_COMPONENT:
                      {
                          int iSel = SendMessage( hWndModules, LB_GETCURSEL, 0, 0 ); 
                          VComp *pComp = NULL;
                          if (iSel != LB_ERR)
                          {
                             pComp = (VComp *)SendMessage( hWndModules, LB_GETITEMDATA, iSel, 0 );
                          }
                          
                          RefreshFunctions(pComp);
                          break;
                      }

                      case IDC_FUNCTION:
                      {
                          int iSel = SendMessage( hWndProcedures, LB_GETCURSEL, 0, 0 ); 
                          VProc *pProc = NULL;
                          if (iSel != LB_ERR)
                          {
                             pProc = (VProc *)SendMessage( hWndProcedures, LB_GETITEMDATA, iSel, 0 );
                          }
                          
                          SetInstrumentation(pProc);
                          break;
                      }
                  }
                  break;

            case BN_CLICKED:
                  switch (idCtrl)
                  {
                      case IDC_REFRESH:
                          RefreshProcesses();
                          break;
                  }
          }
          break;
      }
   }

   return false;
}

void ClearProgramList()
{
    SendMessage( hWndProcesses, LB_RESETCONTENT, 0, 0 );
}

void AddProgramToList( const char *sz, VProg *pProg )
{
    int iItem = SendMessage( hWndProcesses, LB_ADDSTRING, 0, WPARAM(sz) );
    SendMessage( hWndProcesses, LB_SETITEMDATA, iItem, LPARAM(pProg) ); 
}

void ClearComponentList()
{
    SendMessage( hWndModules, LB_RESETCONTENT, 0, 0 );
}

void AddComponentToList( const char *sz, VComp *pComp )
{
    int iItem = SendMessage( hWndModules, LB_ADDSTRING, 0, WPARAM(sz) );
    SendMessage( hWndModules, LB_SETITEMDATA, iItem, LPARAM(pComp) ); 
}

void ClearFunctionList()
{
    SendMessage( hWndProcedures, LB_RESETCONTENT, 0, 0 );
}

void AddFunctionToList( const char *sz, VProc *pProc )
{
    int iItem = SendMessage( hWndProcedures, LB_ADDSTRING, 0, WPARAM(sz) );
    SendMessage( hWndProcedures, LB_SETITEMDATA, iItem, LPARAM(pProc) ); 
}

void Error( const char *szError )
{
    MessageBox( NULL, szError, "Error", MB_OK | MB_ICONEXCLAMATION );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\Vulcan\Samples\src\FlyingICount\FlyingICount.cpp ===
/***********************************************************************
* Microsoft  Vulcan
*
* Microsoft Confidential.  Copyright 1997-1999 Microsoft Corporation.
*
* File: FlyingICount.cpp
*
* File Comments:
*
*
***********************************************************************/

#include <stdio.h>
#include "vulcanapi.h"
#include "flyingicount.h"

VSystem *g_pSystem = NULL;
VProg *g_pProg = NULL;
VComp *g_pComp = NULL;

ADDR g_pvCount = NULL;
VProc *g_pProcInstrumented = NULL;

// Local helper routines
void RemoveInstrumentation();

void RefreshProcesses()
{
    RemoveInstrumentation();

    g_pProg = NULL;
    g_pComp = NULL;

    ClearProgramList();
    ClearComponentList();
    ClearFunctionList();

    if (NULL == g_pSystem)
    {
        g_pSystem = VSystem::Open();
    }
    else
    {
        g_pSystem->RefreshProgs();
    }

    for (VProg *pProg = g_pSystem->FirstProg(); pProg; pProg = pProg->Next())
    {
        if (pProg->IsProcessLive())
        {
            const char *sz = pProg->Name();
            const char *szBase = strrchr( sz, '\\' );
            if (szBase)
            {
                sz = szBase + 1;
            }

            AddProgramToList( sz, pProg );
        }
    }
}

int GetCounter()
{
    DWORD dw = 0;

    if (g_pvCount)
    {
        // Read counter

        g_pProg->ReadMemory( g_pvCount, sizeof(dw), &dw );
    }

    return dw;
}

void RefreshModules( VProg *pProg )
{
    if (pProg == g_pProg)
    {
        return;
    }

    RemoveInstrumentation();

    g_pComp = NULL;

    ClearComponentList();
    ClearFunctionList();

    g_pProg = pProg;

    for (VComp *pComp = g_pProg->FirstComp(); pComp; pComp = pComp->Next())
    {
        const char *szName = pComp->InputName();
        const char *szLastSlash = strrchr( szName, '\\' );
        if (szLastSlash)
        {
            szLastSlash++;
        }
        else
        {
            szLastSlash = szName;
        }

        AddComponentToList( szLastSlash, pComp );
    }
}

void RefreshFunctions(VComp *pComp)
{
    if (pComp == g_pComp)
    {
        return;
    }

    RemoveInstrumentation();

    ClearFunctionList();

    g_pComp = NULL;

    try
    {
        // If needed, set the local path to the binary here
        //
        // pComp->DynamicSetLocalModuleName("...");

        pComp->Build();
    }
    catch(VErr &err)
    {
        Error( err.GetWhat() );
        return;
    }
    catch(...)
    {
        Error( "Unknown Vulcan Error Building IR" );
        return;
    }

    for (VProc *pProc = pComp->FirstProc(); pProc; pProc = pProc->Next())
    {
        AddFunctionToList( pProc->Name(), pProc );
    }

    g_pComp = pComp;
    pComp->SetCurrentWorking();
}

void RemoveInstrumentation()
{
    if (g_pProcInstrumented)
    {
        g_pComp->RedirectProc( g_pProcInstrumented, NULL );
        g_pProcInstrumented = NULL;
    }
}

void SetInstrumentation( VProc *pProc )
{
    if (pProc == g_pProcInstrumented)
    {
        return;
    }

    RemoveInstrumentation();

    // Copy the procedure
    VProc *pProcCopy = pProc->Copy( g_pComp );

    if (NULL == g_pvCount)
    {
        // We only need 4 bytes for this counter

        g_pvCount = g_pProg->AllocateMemory( 4 );
    }

    // Zero counter
    DWORD dw = 0;
    g_pProg->WriteMemory( g_pvCount, sizeof(dw), &dw );

    VAddress *pAddr = VAddress::Create( NULL, (long)g_pvCount ); //displacement of address

    for (VBlock *pBlk = pProcCopy->FirstBlock(); pBlk; pBlk = pBlk->Next())
    {
        VInst *pInst = pBlk->FirstInst();

        pInst->InsertPrev( VInst::Create( COp::PUSHD, X86Register::EAX ));
        pInst->InsertPrev( VInst::Create( COp::MOVD, X86Register::EAX, pAddr ));

        VAddress *pAddrInc = VAddress::Create( X86Register::EAX, pBlk->Size() );
        pInst->InsertPrev( VInst::Create( COp::LEAD, X86Register::EAX, pAddrInc ));

        pInst->InsertPrev( VInst::Create( COp::MOVD, pAddr, X86Register::EAX ));
        pInst->InsertPrev( VInst::Create( COp::POPD, X86Register::EAX ));
    }

    pProcCopy->Commit( g_pComp );
    g_pComp->RedirectProc( pProc, pProcCopy);
    g_pProcInstrumented = pProc;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\Vulcan\Samples\src\FlyingParams\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by FlyingParams.rc
//
#define IDD_STATUSDLG                   101
#define IDC_ALLOCSIZE                   1000
#define IDC_INSTRUCTIONS                1000
#define IDC_FUNCTIONS                   1002
#define IDC_COMPONENT                   1002
#define IDC_COMPONENTS                  1003
#define IDC_PROCESS                     1003
#define IDC_ICOUNT                      1004
#define IDC_FUNCTION                    1005
#define IDC_REFRESH                     1006
#define IDC_VALUES                      1008
#define IDC_MACHINE                     1010
#define IDC_PARAMS                      1011

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        103
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1012
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\Vulcan\Samples\src\FlyingParams\FlyingParams.cpp ===
/***********************************************************************
* Microsoft  Vulcan
*
* Microsoft Confidential.  Copyright 1997-1999 Microsoft Corporation.
*
* File: FlyParamsUI.cpp
*
* File Comments:
*
*
***********************************************************************/

#include "flyingparams.h"
#include "vulcanapi.h"
#include "malloc.h"
#include "stdio.h"
#include "stdlib.h"

// State of currently selected things
char    g_szMachineSel[256] = {0};
VSystem *g_pSysSel  = NULL;
VProg   *g_pProgSel = NULL;
VComp   *g_pCompSel = NULL;
VProc   *g_pProcSel = NULL;
VSymbol *g_pSymSel  = NULL;

// Which procedures have recently been hit?
size_t   g_cProc = 0;
ADDR     g_addrProcHits = NULL;
BYTE *   g_rgProcHits = NULL;

// Value data
VALUE_DATA *g_rgValueData = NULL;
ADDR g_addrValueData = NULL;

// Dereference stuff
ADDR g_addrDerefStream = NULL;
VAddress *g_pAddrDerefHandler;
bool g_fProcSelInst = false;

// Local helper functions
void RemoveAllInstrumentation();
void AddProcHitInstrumentation( VProc *pProc, int iProc );
void GetNameFromSymbol( VSymbol *pSym, char *szSym, size_t cchSym );
void RemoveParamInstrumentation();
void RemoveProcHitInstrumentation();
bool GetProcessReadyForParams();
void WriteDerefStreamToProcess( int *rgDeref );
void ZeroParamCounters();
void CreateDerefStream( VSymbol **rgpSyms, size_t cPSym, int *rgDeref );
void AddParamInstrumentation( VSymbol *pSymRoot );
int _cdecl CmpValueData( const void *pv1, const void *pv2);
bool HasChildrenSym( VSymbol *pSym );

void RefreshProcesses( const char *szMachine )
{
    RemoveAllInstrumentation();

    ClearProgramList();
    g_pProcSel = NULL;

    ClearComponentList();
    g_pCompSel = NULL;

    ClearProcedureList();
    g_pProcSel = NULL;

    ClearParamsList();
    g_pSymSel = NULL;

    if (NULL != g_pSysSel &&
        0 != stricmp( szMachine, g_szMachineSel ))
    {
        // Machine name changed... go find that one?
        g_pSysSel->Destroy();
        g_pSysSel = NULL;
    }

    strcpy( g_szMachineSel, szMachine );

    if (NULL == g_pSysSel)
    {
        try
        {
            if (g_szMachineSel[0])
            {
                // Open named machine
                g_pSysSel = VSystem::Open(g_szMachineSel);
            }
            else
            {
                // Open local machine
                g_pSysSel = VSystem::Open((const char *)NULL);
            }
        }
        catch(...)
        {
            Error( "Vulcan failed to locate the remote client" );
            g_pSysSel = NULL;
            return;
        }
    }
    else
    {
        g_pSysSel->RefreshProgs();
    }

    for (VProg *pProg = g_pSysSel->FirstProg(); pProg; pProg = pProg->Next())
    {
        if (pProg->IsProcessLive())
        {
            const char *sz = pProg->Name();
            const char *szBase = strrchr( sz, '\\' );
            if (szBase)
            {
                sz = szBase + 1;
            }

            AddProgramToList( sz, pProg );
        }
    }
}

void OnSelChangeProcesses( VProg * pProg )
{
    if (pProg == g_pProgSel)
    {
        return;
    }

    RemoveAllInstrumentation();

    g_pCompSel = NULL;
    g_pProcSel = NULL;
    g_pSymSel = NULL;

    ClearComponentList();
    ClearProcedureList();
    ClearParamsList();

    g_pProgSel = pProg;

    if (NULL == pProg)
    {
        return;
    }

    for (VComp *pComp = pProg->FirstComp(); pComp; pComp = pComp->Next() )
    {
        const char *szName = pComp->InputName();
        if (szName)
        {
            const char *szLastSlash = strrchr( szName, '\\' );
            if (szLastSlash)
            {
                szLastSlash++;
            }
            else
            {
                szLastSlash = szName;
            }

            AddComponentToList( szLastSlash, pComp );
        }
    }
}

void OnSelChangeComponent( VComp *pComp )
{
    if (pComp == g_pCompSel)
    {
        return;
    }
    g_pCompSel = NULL;

    RemoveAllInstrumentation();

    g_pProcSel = NULL;
    g_pSymSel = NULL;

    ClearProcedureList();
    ClearParamsList();

    if (NULL == pComp)
    {
        return;
    }

    try
    {
        pComp->Build();
    }
    catch (VErr err)
    {
        Error( err.GetWhat() );
        return;
    }
    catch (...)
    {
        Error( "Vulcan failed to open the component" );
        return;
    }

    g_pCompSel = pComp;
    g_cProc = pComp->CountProcs();

    if (NULL == g_addrProcHits)
    {
        // To keep things simple, we assume all modules have less than 64k procedures
        g_addrProcHits = g_pProgSel->AllocateMemory( 64*1024 );
        g_rgProcHits = (BYTE *)malloc( 64*1024 );
    }

    // We are going to add instrumentation, so freeze the process
    g_pProgSel->Suspend();

    int iProc = 0;
    for (VProc *pProc = pComp->FirstProc(); pProc; pProc = pProc->Next())
    {
        if (!pProc->IsThunk())
        {
            // The procedure listbox will call us back for the name...
            AddProcedureToList( pProc, iProc );

            AddProcHitInstrumentation( pProc, iProc );

            iProc++;
        }
    }

    g_pProgSel->Resume();
    g_pCompSel->SetCurrentWorking();
}

void OnSelChangeProcedures( VProc *pProc )
{
    char szSym[1024];
    VSymbol *pSym;

    if (pProc == g_pProcSel)
    {
        return;
    }

    RemoveParamInstrumentation();
    ZeroParamCounters();

    g_pProcSel = NULL;
    g_pSymSel = NULL;
    ClearParamsList();

    if (NULL == pProc)
    {
        return;
    }

    for (pSym = pProc->FirstParam(g_pCompSel); pSym; pSym = pSym->Next())
    {
        GetNameFromSymbol( pSym, szSym, sizeof(szSym) );

        AddParamToTree( szSym, pSym, HasChildrenSym(pSym) );
    }

    // Also add the return symbol
    pSym = pProc->ReturnSymbol(g_pCompSel);
    if (pSym)
    {
        GetNameFromSymbol( pSym, szSym, sizeof(szSym) );

        AddParamToTree( szSym, pSym, HasChildrenSym(pSym) );
    }

    g_pProcSel = pProc;
}

void OnExpandParam( VSymbol *pSymFrom )
{
    char szSym[1024];

    VSymbol *pSym;

    if (pSymFrom->IsPointer())
    {
        pSym = pSymFrom->PTarget();
    }
    else
    {
        pSym = pSymFrom->FirstField();
    }

    for ( ; pSym; pSym = pSym->Next())
    {
        // Insert children
        GetNameFromSymbol( pSym, szSym, sizeof(szSym) );

        AddParamToTree( szSym, pSym, HasChildrenSym(pSym) );
    }

    pSym = pSymFrom->FirstBase();
    for ( ; pSym; pSym = pSym->Next())
    {
        // Insert children
        GetNameFromSymbol( pSym, szSym, sizeof(szSym) );

        AddParamToTree( szSym, pSym, HasChildrenSym(pSym) );
    }

}

void OnSelChangeParams( VSymbol **rgpSyms, size_t cPSym )
{
    // rgpSyms is a pointer to the array of selected symbols
    // The first one is actually selected, the next ones are its parents

    if (cPSym != 0 && rgpSyms[0] == g_pSymSel)
    {
        return;
    }

    RemoveParamInstrumentation();
    g_pSymSel = rgpSyms[0];

    if (cPSym == 0 || NULL == rgpSyms[0] || g_pProcSel == NULL)
    {
        return;
    }

    GetProcessReadyForParams();

    int *rgDeref = new int[ cPSym + 2 ];
    rgDeref[0] = -4; //default to reading 4 bytes
    CreateDerefStream( rgpSyms, cPSym, rgDeref );
    WriteDerefStreamToProcess( rgDeref );
    delete [] rgDeref;

    ZeroParamCounters();

    AddParamInstrumentation( rgpSyms[cPSym-1] );
}

void GetNameFromSymbol( VSymbol *pSym, char *szSym, size_t cchSym )
{
    char *pchName = NULL;
    const char *szName = pSym->Name();
    pSym->Type( szSym, cchSym, &pchName );
    if (szName && pchName)
    {
        // pchName points to the location to put the name after the type
        // this will be the end of the type name, unless this is a pointer to a function
        memmove( pchName + strlen(szName) + 1, pchName, strlen(pchName) );
        *pchName = ' ';
        strncpy( pchName+1, szName, strlen(szName) );
    }
}

void UpdateProcedureHitData()
{
    if (NULL == g_addrProcHits)
    {
        return;
    }

    g_pProgSel->ReadMemory( g_addrProcHits, 64*1024, g_rgProcHits );

    // Decay the hit functions so we can see them for a little while
    for (size_t i =0; i<g_cProc; i++)
    {
        if (g_rgProcHits[i] == 0)
        {
            continue;
        }
        else if (g_rgProcHits[i] < 5)
        {
            // trying to decay...
            g_rgProcHits[i]++;
        }
        else
        {
            g_rgProcHits[i] = 0;
        }
    }
    g_pProgSel->WriteMemory( g_addrProcHits, 64*1024, g_rgProcHits );
}

const char *SzNameAndHitFromProcedure( VProc * pProc, int iProc, bool &fHit )
{
    const char *szName = pProc->Name();

    fHit = false;

    if (g_rgProcHits)
    {
        fHit = g_rgProcHits[iProc] > 0;
    }

    return szName;
}

void RemoveAllInstrumentation()
{
    RemoveParamInstrumentation();
    ZeroParamCounters();

    RemoveProcHitInstrumentation();
}

void AddProcHitInstrumentation( VProc *pProc, int iProc )
{
    // Create a copy of the first block in the procedure
    VBlock *pEntry = pProc->FirstBlock();
    VBlock *pBlk = pEntry->Copy(g_pCompSel);
    pProc->InsertLastBlock( pBlk );

    // Add mov byte ptr [g_addrProcHits + iProc], 1 to the copied entry block
    VAddress *pAddrProcHit = VAddress::Create( NULL, long(g_addrProcHits) + iProc );
    pBlk->InsertFirstInst( VInst::Create( COp::MOVB, pAddrProcHit, 1 ));
    pAddrProcHit->Destroy();
    pBlk->Commit( g_pCompSel );

    // Make a new block which jumps to the copy of the first block in the procedure
    VBlock *pJump = VBlock::CreateCodeBlock(g_pCompSel);
    pJump->InsertFirstInst( VInst::Create( COp::JMP, pBlk ));

    // Write the jump block into the first block of the original procedure
    pEntry->ReplaceInstructions( pJump, g_pCompSel );
    pJump->Destroy(); // Free temp block
}

void RemoveProcHitInstrumentation()
{
    // This is unimplemented...
}

void WriteDerefStreamToProcess( int *rgDeref )
{
    if (NULL == g_addrDerefStream)
    {
        g_addrDerefStream = g_pProgSel->AllocateMemory( 2048 );
    }

    for (int i=0; rgDeref[i] >= 0; i++)
        ;

    size_t cb = (i + 1)* sizeof(int);
    g_pProgSel->WriteMemory( g_addrDerefStream, cb, rgDeref );
}

void CreateDerefStream( VSymbol **rgpSyms, size_t cPSym, int *rgDeref )
{
    if (cPSym > 1)
    {
        CreateDerefStream( rgpSyms + 1, cPSym - 1, rgDeref );
    }

    VSymbol *pSym = rgpSyms[0];

    size_t size = pSym->Size();
    if (size == 0)
    {
        // default to reading first 4 bytes of object
        size = 4;
    }

    // Go find the negative number in the stream
    for (int i=0; rgDeref[i] >= 0; i++)
        ;

    if (pSym->Offset())
    {
        rgDeref[i++] = pSym->Offset();
    }

    if (!pSym->FirstField() &&
        !pSym->IsInReg())
    {
        // This is not a structure
        rgDeref[i++] = 0;
    }

    if (pSym->IsBitField())
    {
        // Offset and size are packed into 6 bits each, with next highest bit set.
        // Then the whole thing is negated so we know we are at then end of the string
        rgDeref[i] = -(int)( 0x1000 | pSym->BitOffset() << 6 | pSym->BitSize() );
    }
    else
    {
        // We pass in the contents of the register
        rgDeref[i] = -(int)size;
    }
}

void AddParamInstrumentation( VSymbol *pSymRoot )
{
    VProc *pProcCopy = g_pProcSel->Copy( g_pCompSel );

    VBlock *pBlk = pProcCopy->FirstBlock();
    VInst *pInst = pBlk->FirstInst();

    if (pSymRoot == g_pProcSel->ReturnSymbol(g_pCompSel))
    {
        // Go get EAX at each return instruction
        for ( ; pBlk; pBlk = pBlk->Next())
        {
            VInst *pInst = pBlk->LastInst();
            if (pInst->Opcode() == COp::RET)
            {
                pInst->InsertPrev( VInst::Create( COp::PUSHD, long(g_addrDerefStream) ));
                pInst->InsertPrev( VInst::Create( COp::PUSHD, X86Register::EAX ));
                pInst->InsertPrev( VInst::Create( COp::CALL, g_pAddrDerefHandler ));
            }
        }
    }
    else if (pSymRoot->IsInReg())
    {
        // ECX, EDX, or EAX
        pInst->InsertPrev( VInst::Create( COp::PUSHD, long(g_addrDerefStream) ));
        pInst->InsertPrev( VInst::Create( COp::PUSHD, pSymRoot->Register() ));
        pInst->InsertPrev( VInst::Create( COp::CALL, g_pAddrDerefHandler ));
    }
    else
    {
        // Watch out for JMP to entry block...
        if (pInst->Opcode() == COp::JMP &&
            pInst->BlockTarget())
        {
            pBlk = pInst->BlockTarget();
            pInst = pBlk->FirstInst();
        }

        // Watch for MOVB [addr], 1 (our instrumentation)
        if (pInst->Opcode() == COp::MOVB &&
            pInst->Operand( Inst::Dest ).Type() == OpndAddress &&
            pInst->Operand( Inst::Src1 ).Immediate() == 1)
        {
            pInst = pInst->Next();
        }

        // Watch out for PUSH EBP, MOV ESP, EBP.. the param offset are after EBP is pushed
        if (pInst->Opcode() == COp::PUSHD &&
            pInst->Operand( Inst::Src1 ).Register() == X86Register::EBP)
        {
            VInst *pInstMov = pInst->Next();

            if (pInstMov->Opcode() == COp::MOVD &&
                pInstMov->Operand( Inst::Dest ).Register() == X86Register::EBP &&
                pInstMov->Operand( Inst::Src1 ).Register() == X86Register::ESP)
            {
                // Bump passed push ebp since that's where param offsets are calculated from
                pInst = pInstMov;
            }
        }

        // Push address of dererence data
        pInst->InsertPrev( VInst::Create( COp::PUSHD, long(g_addrDerefStream) ));

        // Save EAX
        pInst->InsertPrev( VInst::Create( COp::PUSHD, X86Register::EAX ));

        // Compute address of parameters on stack (dereference stream determines which one to read)
        VAddress *pAddrParams = VAddress::Create( X86Register::ESP, 8 ); // + 8 to reach across the pushed params
        pInst->InsertPrev( VInst::Create( COp::LEAD, X86Register::EAX, pAddrParams ));
        pAddrParams->Destroy();

        // Effectively push address and restore EAX by exchanging them
        VAddress *pAddrXCHG = VAddress::Create( X86Register::ESP, 0 );
        pInst->InsertPrev( VInst::Create( COp::IXCHD, VOperand(pAddrXCHG), VOperand(X86Register::EAX), VOperand(X86Register::EAX) ));
        pAddrXCHG->Destroy();

        // Call handler
        pInst->InsertPrev( VInst::Create( COp::CALL, g_pAddrDerefHandler ));
    }

    pProcCopy->Commit( g_pCompSel );
    g_pCompSel->RedirectProc( g_pProcSel, pProcCopy);
    g_fProcSelInst = true;
}

void RemoveParamInstrumentation()
{
    if (g_pProcSel && g_fProcSelInst)
    {
        g_pCompSel->RedirectProc( g_pProcSel, NULL );
        g_fProcSelInst = false;
    }
}

bool GetProcessReadyForParams()
{
    if (g_rgValueData != NULL)
    {
        return true; //alrady done
    }

    g_addrValueData = g_pProgSel->AllocateMemory( cbValueMax );
    g_rgValueData = (VALUE_DATA *)malloc( cbValueMax );

    // Inject the dll
    VBlock *pBlk = g_pCompSel->CreateImport( "FlyingParamsDll.dll", "rgValueData" );
    if (NULL == pBlk)
    {
        Error( "Can't load FlyingParamsDll into remote process" );
        return false;
    }

    // Write the counter into the dll
    ADDR addr = pBlk->Addr();
    g_pProgSel->ReadMemory( addr, sizeof(void *), &addr );
    g_pProgSel->WriteMemory( addr, sizeof(void *), &g_addrValueData );

    // Get the handler proc too
    pBlk = g_pCompSel->CreateImport( "FlyingParamsDll.dll", "_ValueHandler@4" );
    if (NULL == pBlk)
    {
        return false;
    }
    g_pAddrDerefHandler = VAddress::Create( pBlk );

    return true;
}

void ZeroParamCounters()
{
    if (g_rgValueData == NULL)
    {
        return;
    }

    memset( g_rgValueData, 0, cbValueMax );
    g_pProgSel->WriteMemory( g_addrValueData, cbValueMax, g_rgValueData );
}

void GetValueStringFromValueIndex( int iVI, char *szName )
{
    if (NULL == g_rgValueData || NULL == g_pSymSel)
    {
        strcpy(szName, "0");
        return;
    }

    if (g_pSymSel->IsPointer())
    {
        //UNDONE: use type information to print this pretty
        sprintf(szName, "0x%08X", g_rgValueData[iVI].value );
    }
    else
    {
        // Get type
        char szType[1024];
        g_pSymSel->Type( szType, sizeof(szType), NULL );

        if (strstr( szType, "float" ))
        {
            sprintf(szName, "%f", *(float *)&g_rgValueData[iVI].value );
        }
        else if (strstr( szType, "double" ))
        {
            sprintf(szName, "%f", *(double *)&g_rgValueData[iVI].value );
        }
        else if (strstr( szType, "int64" ))
        {
            sprintf(szName, "%I64d", *(double *)&g_rgValueData[iVI].value );
        }
        else if (strstr( szType, "int" ) ||
                 strstr( szType, "char" ) ||
                 strstr( szType, "short" ) ||
                 strstr( szType, "long" ))
        {
            if (strstr( szType, "unsigned" ))
            {
                sprintf(szName, "%u", *(int *)&g_rgValueData[iVI].value );
            }
            else
            {
                sprintf(szName, "%d", *(int *)&g_rgValueData[iVI].value );
            }
        }
        else
        {
            sprintf(szName, "%p", *(int **)&g_rgValueData[iVI].value );
        }
    }
}

int GetValueCountFromValueIndex( int iVI )
{
    if (NULL == g_rgValueData)
    {
        return 0;
    }

    return g_rgValueData[iVI].count;
}

int _cdecl CmpValueData( const void *pv1, const void *pv2)
{
    VALUE_DATA *pp1 = (VALUE_DATA *)pv1;
    VALUE_DATA *pp2 = (VALUE_DATA *)pv2;

    return pp2->count - pp1->count;
}

int CValuesUpdateValueData()
{
    int i;

    if (g_pCompSel == NULL ||
        g_rgValueData == NULL)
    {
        return 0;
    }

    g_pProgSel->ReadMemory( g_addrValueData, cbValueMax, g_rgValueData );
    for (i=0; i<cValueMax; i++)
    {
        // 0 terminated array
        if (0 == g_rgValueData[i].count)
        {
            break;
        }
    }

    qsort( g_rgValueData, i, sizeof(VALUE_DATA), CmpValueData );
    return i;
}

bool HasChildrenSym( VSymbol *pSym )
{
    if (pSym->IsPointer())
    {
        if (pSym->PTarget() != NULL)
        {
            return true;
        }
    }
    else
    {
        if (pSym->FirstField() != NULL)
        {
            return true;
        }

        if (pSym->FirstBase() != NULL)
        {
            return true;
        }
    }

    return false;
}

void Cleanup()
{
    if (g_pSysSel)
    {
        g_pSysSel->Destroy();
        g_pSysSel = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\Vulcan\Samples\src\FlyingParams\FlyingParamsDll.cpp ===
/***********************************************************************
* Microsoft  Vulcan
*
* Microsoft Confidential.  Copyright 1997-1999 Microsoft Corporation.
*
* File: FlyingParamsDll.cpp
*
* File Comments:
*
*
***********************************************************************/

#include "flyingparams.h"

extern "C" _declspec (dllexport) VALUE_DATA *rgValueData = 0;

void _stdcall IncForValue( int value, int* pDeref )
{
    __int64 val64 = value;
    
    if (rgValueData)
    {
        try
        {
            while (*pDeref >= 0)
            {
               if (*pDeref)
               {
                   val64 += *pDeref;
               }
               else
               {
                   val64 = *(__int64 *)(val64 & 0xFFFFFFFF);
               }
               pDeref++;
            }
        }
        catch(...)
        {
            return; //ignore value!
        }

        switch (*pDeref)
        {
        case -1:
            val64 &= 0xFF;
            break;

        case -2:
            val64 &= 0xFFFF;
            break;

        case -4:
            val64 &= 0xFFFFFFFF;
            break;

        case -8:
            break;

        default:
            // Is this a bit field?
            if ((-*pDeref) & 0x1000)
            {
               // Offset and size are packed into 6 bits each
               size_t bitOffset = ((-*pDeref)>>6) & 0x3f;
               size_t bitSize   = ((-*pDeref))    & 0x3f;

               val64 >>= bitOffset;
               val64 &=  ((1<<bitSize)-1);
            }
            break;
        }
    
        for (VALUE_DATA *pData = rgValueData; pData->count && pData < rgValueData + cValueMax; pData++)
        {
            if (pData->value == val64)
            {
                //UNDONE: consider slight re-order of array for perf
            
                pData->count++;
                return;
            }
        }

        if (pData < rgValueData + cValueMax)
        {
            // Make a new slot
            pData->value = val64;
            pData->count = 1;
        }
    }
}

extern "C" _declspec(naked) _declspec(dllexport) void _stdcall ValueHandler( void * )
{
    _asm push eax
    _asm push ecx
    _asm push edx

    _asm push [esp + 0x14]
    _asm push [esp + 0x14]
    _asm call IncForValue

    _asm pop edx
    _asm pop ecx
    _asm pop eax
    _asm ret 8
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\Vulcan\Samples\src\Inststat\inststat.cpp ===
/***********************************************************************
* Microsoft  Vulcan
*
* Microsoft Confidential.  Copyright 1997-2000 Microsoft Corporation.
*
* File: Inststat.cpp
*
* File Comments:
*
*
***********************************************************************/

// This program instruments a program so that the new program will print out
// for each instruction how many of that type were executed.
// The output of the instrumented app
//
// CALL  50
// B 90
// LSL 100
//
// would mean 50 calls were executed 90 Branch instructions and 100
// logical shift lefts.


#include "vulcanapi.h"
#pragma warning(disable: 4786) //dentifier was truncated to '255'
#include "map"
#include "vector"

std::map<const char*,int> opStrs;
std::vector<int> bbIndexes;
std::vector<int> insts;
int opStrsNum = 0;
int instCount = 0;

void SendInstInfo(VProtoList* cProtoList,VProg* vprog,VComp *pComp)
{
   char protoStr[2000];

   int blen = bbIndexes.size();
   int ilen = insts.size();
   sprintf(protoStr,"SendInstInfo(int,int,int[%d],int[%d])",blen,ilen);

   VProto* vproto = cProtoList->CreateProto(pComp,"inststatdll.dll",protoStr);

   int *bbs = new int [blen + 1];
   int *is  = new int [ilen + 1];
   std::copy(bbIndexes.begin(), bbIndexes.end(), bbs);
   std::copy(insts.begin(), insts.end(), is);

   vproto->AddCall(pComp,BEFORE,blen,ilen,bbs,is);
}

void InstInfo(VBBlock *pBlk,VProto* cProto,VComp *pComp,VProg* vprog)
{
   for (VInst *pInst = pBlk->FirstInst(); pInst; pInst = pInst->Next())
   {
      const char* opstr = pInst->OpcodeGroupStr();

      if (opStrs.find(opstr)==opStrs.end())
      {
         opStrs[opstr] = opStrsNum;
         cProto->AddCall(pComp,BEFORE,opstr);
         printf("%s\n",opstr);
         opStrsNum++;
      }

      insts.push_back(opStrs[opstr]);
      instCount++;
   }

   bbIndexes.push_back(instCount);
}

void InstStat(VProg* vprog)
{
   VProtoList *protolist = VProtoList::CreateProtoList();
   printf("IR Reading\n");

   for (VComp *pComp = vprog->FirstComp(); pComp; pComp = pComp->Next())
   {
      VProto* bbProto = protolist->CreateProto(pComp,
                                               "inststatdll.dll",
                                               "SendNum(int)");

      VProto* cProto = protolist->CreateProto(pComp,
                                              "inststatdll.dll",
                                              "SendStr(char*)");

      for (VProc *pProc = pComp->FirstProc();pProc;pProc = pProc->Next())
      {
         const char* name = pProc->Name();
         for (VBBlock *pBlk = pProc->FirstBlock(); pBlk; pBlk = pBlk->Next())
         {
            bbProto->AddCall(pBlk,BEFORE,pBlk->BlockId());
            InstInfo(pBlk,cProto,pComp,vprog);
         }
      }

      SendInstInfo(protolist,vprog,pComp);
      protolist->Commit();

      printf("IR Writing\n");
      pComp->Write();
   }
}


int __cdecl main(int argc, char** argv)
{
   if (argc != 2)
   {
      printf("Usage: Inststat [Image-name]\n");
      return 1;
   }

   try
   {
      VProg *vprog = VProg::Open(argv[1]);
      InstStat(vprog);  

      // To save time, we don't destroy the vprog object
      // vprog->Destroy();
   }

   catch (VErr& verr) 
   {
      printf("Error: %s\n",verr.GetWhat());
      return 1;
   }

   catch (...)
   {
      printf("Error: unknown\n");
      return 1; 
   }

   return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\Vulcan\Samples\src\FlyingParams\FlyingParams.h ===
/***********************************************************************
* Microsoft  Vulcan
*
* Microsoft Confidential.  Copyright 1997-1999 Microsoft Corporation.
*
* File: FlyingParams.h
*
* File Comments:
*
*
***********************************************************************/

struct VALUE_DATA
{
    __int64 value;
    int count;
};

const int cValueMax = 128*1024/sizeof(VALUE_DATA);
const int cbValueMax = cValueMax * sizeof(VALUE_DATA);

//#include "psapi.h"
//#include "vulcanapi.h"
class VProg;
class VComp;
class VProc;
class VSymbol;

// Callbacks into UI side
void ClearProgramList();
void ClearComponentList();
void ClearProcedureList();
void ClearParamsList();
void AddProgramToList( const char *sz, VProg *pProg );
void AddComponentToList( const char *sz, VComp *pComp );
void AddProcedureToList( VProc *pProc, int iProc ); 
void AddParamToTree( const char *szSym, VSymbol *pSym, bool fHashChildren );
void Error( const char *szError );

// Calls from UI to Vulcan local routines
void RefreshProcesses( const char *szMachine );
void OnSelChangeProcesses( VProg * pProgSel );
void OnSelChangeComponent( VComp *pComp );
void OnSelChangeProcedures( VProc *pProc );
void OnSelChangeParams( VSymbol **rgpSyms, size_t cPSym );
void OnExpandParam( VSymbol *pSymParent );
void UpdateProcedureHitData();
int  CValuesUpdateValueData();
const char *SzNameAndHitFromProcedure( VProc * pProc, int iProc, bool &fHit );
void GetValueStringFromValueIndex( int iVI, char *szName );
int  GetValueCountFromValueIndex( int iVI );
void Cleanup();
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\Vulcan\Samples\src\FlyingParams\FlyParamsUI.cpp ===
/***********************************************************************
* Microsoft  Vulcan
*
* Microsoft Confidential.  Copyright 1997-1999 Microsoft Corporation.
*
* File: FlyParamsUI.cpp
*
* File Comments:
*
*
***********************************************************************/

#include <stdio.h>

#define STRICT
#define WIN32_LEAN_AND_MEAN
#include "windows.h"
#include "commctrl.h"
#include "flyingparams.h"
#include "resource.h"

#pragma comment(lib, "user32.lib")
#pragma comment(lib, "kernel32.lib")
#pragma comment(lib, "gdi32.lib")
#pragma comment( lib, "comctl32.lib" )

// Local helper functions
BOOL CALLBACK VADlgProc( HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
void CallSelChangeParams( HTREEITEM hItemSel );

BOOL __stdcall WinMain(HINSTANCE hModule, HINSTANCE hInst, LPSTR lpCmdLine, int nCmdShow)
{
   INITCOMMONCONTROLSEX icc;
   icc.dwSize = sizeof(INITCOMMONCONTROLSEX);
   icc.dwICC = ICC_LISTVIEW_CLASSES;
   InitCommonControlsEx( &icc );

   HWND hWnd = CreateDialog(hInst, MAKEINTRESOURCE(IDD_STATUSDLG), NULL, VADlgProc ); 
   ShowWindow(hWnd, nCmdShow);

   //pump messages
   while (1)
   {
      MSG msg;
      BOOL f = GetMessage( &msg, NULL, 0, 0 );
      if (!f)
      {
          Cleanup();
          return 0; //done
      }

      if (f != -1)
      {
         TranslateMessage( &msg );
         DispatchMessage( &msg );
      }
   }
}

HWND hWndProgams = NULL;
HWND hWndComponents = NULL;
HWND hWndFunctions = NULL;
HWND hWndParams    = NULL;
HWND hWndValues    = NULL;
HWND hWndMachine   = NULL;

// Global used to know where to put items in param tree
HTREEITEM g_hItemParent = TVI_ROOT;

BOOL CALLBACK VADlgProc( HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
   static DWORD mytimer;
   
   switch (msg)
   {
      case WM_INITDIALOG:
      {
         hWndProgams  = GetDlgItem( hWnd, IDC_PROCESS );
         hWndComponents = GetDlgItem( hWnd, IDC_COMPONENT );
         hWndFunctions  = GetDlgItem( hWnd, IDC_FUNCTION );
         hWndParams     = GetDlgItem( hWnd, IDC_PARAMS );
         hWndValues     = GetDlgItem( hWnd, IDC_VALUES );
         hWndMachine    = GetDlgItem( hWnd, IDC_MACHINE );
         
         LVCOLUMN col;
         col.mask = LVCF_TEXT | LVCF_WIDTH;
         col.cx = 85;
         col.pszText = "Value";
         SendMessage( hWndValues, LVM_INSERTCOLUMN, 0, LPARAM(&col) );

         col.cx = 65;
         col.pszText = "Count";
         SendMessage( hWndValues, LVM_INSERTCOLUMN, 1, LPARAM(&col) );

         ListView_SetExtendedListViewStyle( hWndValues, LVS_EX_FULLROWSELECT );
         
         // Fill the process list
         char szMachine[256];
         GetWindowText( hWndMachine, szMachine, sizeof(szMachine) );
         RefreshProcesses(szMachine);

         SetTimer( hWnd, 42, 300, NULL );
         return true;
      }

      case WM_TIMER:
      {
          if (wParam == 42)
          {
              int c = CValuesUpdateValueData();
              ListView_SetItemCountEx( hWndValues, c, LVSICF_NOSCROLL  );
              InvalidateRect( hWndValues, NULL, true );
              
              UpdateProcedureHitData();
              InvalidateRect( hWndFunctions, NULL, true );
              return true;
          }
      }

      case WM_CLOSE:
      {
          PostQuitMessage(0);
          EndDialog( hWnd, 0 );
          return true;
      }


      case WM_MEASUREITEM: 
      {
          MEASUREITEMSTRUCT *pmis = (MEASUREITEMSTRUCT *)lParam; 

          HDC hDC = GetDC(hWndFunctions);

          TEXTMETRIC tm; 
          GetTextMetrics(hDC, &tm); 

          ReleaseDC( hWndFunctions, hDC );

          pmis->itemHeight = tm.tmHeight; 

          return true; 
      }
 
      case WM_DRAWITEM: 
      {
          DRAWITEMSTRUCT *lpdis = (DRAWITEMSTRUCT *) lParam; 
          if (lpdis->itemID == -1) 
          { 
             break; 
          } 
 
          // Draw the bitmap and text for the list box item. Draw a 
          // rectangle around the bitmap if it is selected. 
 
          switch (lpdis->itemAction) 
          { 
             case ODA_SELECT: 
             case ODA_DRAWENTIRE: 
                // Display the bitmap associated with the item. 
 
                VProc *pProc = (VProc *)(lpdis->itemData);
                bool fHit;
                const char *szName = SzNameAndHitFromProcedure( pProc, lpdis->itemID, fHit );
                
                TEXTMETRIC tm; 
                GetTextMetrics(lpdis->hDC, &tm); 
                
                COLORREF cobk;
                COLORREF co = RGB(0,0,0);
                
                if (fHit)
                {
                    co = RGB(255, 0, 0);
                }

                co = SetTextColor( lpdis->hDC, co );
                
                if (lpdis->itemState & ODS_SELECTED) 
                {
                    cobk = SetBkColor( lpdis->hDC, RGB(0,0,128) );
                    SetTextColor( lpdis->hDC, RGB(255,255,255) );
                }
 
                int y = (lpdis->rcItem.bottom + lpdis->rcItem.top - tm.tmHeight) / 2; 
                ExtTextOut( lpdis->hDC, 2, y, ETO_OPAQUE | ETO_CLIPPED, &lpdis->rcItem, szName, strlen(szName), NULL );

                SetTextColor( lpdis->hDC, co );
 
                // Is the item selected? 
                if (lpdis->itemState & ODS_SELECTED) 
                { 
                    SetBkColor( lpdis->hDC, cobk );
                } 
                break; 
          }
      }
 

      case WM_COMMAND:
      {
          DWORD idCtrl = LOWORD(wParam);
          switch (HIWORD(wParam))
          {
              case LBN_SELCHANGE:
                  switch (idCtrl)
                  {
                      case IDC_PROCESS:
                      {
                          int iSel = SendMessage( hWndProgams, LB_GETCURSEL, 0, 0 ); 
                          if (iSel == LB_ERR)
                          {
                              OnSelChangeProcesses( NULL );
                          }
                          else
                          {
                              VProg *pProg = (VProg *)SendMessage( hWndProgams, LB_GETITEMDATA, iSel, 0 );
                              OnSelChangeProcesses( pProg );
                          }
                          break;
                      }

                      case IDC_COMPONENT:
                      {
                          int iSel = SendMessage( hWndComponents, LB_GETCURSEL, 0, 0 ); 
                          if (iSel == LB_ERR)
                          {
                              OnSelChangeComponent( NULL );
                          }
                          else
                          {
                              VComp *pComp = (VComp *)SendMessage( hWndComponents, LB_GETITEMDATA, iSel, 0 );
                              OnSelChangeComponent( pComp );
                          }
                          break;
                      }

                      case IDC_FUNCTION:
                      {
                          int iSel = SendMessage( hWndFunctions, LB_GETCURSEL, 0, 0 ); 
                          if (iSel == LB_ERR)
                          {
                              OnSelChangeProcedures( NULL );    
                          }
                          else
                          {
                              VProc *pProc = (VProc *)SendMessage( hWndFunctions, LB_GETITEMDATA, iSel, 0 );
                              OnSelChangeProcedures( pProc );
                          }
                          break;
                      }
                  }
                  break;

            case BN_CLICKED:
                  switch (idCtrl)
                  {
                      case IDC_REFRESH:
                      {
                          char szMachine[256];
                          GetWindowText( hWndMachine, szMachine, sizeof(szMachine) );
                          RefreshProcesses(szMachine);
                          break;
                      }
                  }
          }
          break;
      }

      case WM_NOTIFY:
      {
          DWORD idCtrl = wParam;
          NMHDR *pnmh = (NMHDR *) lParam; 

          if (pnmh->code == LVN_GETDISPINFO)
          {
              NMLVDISPINFO *pdi = (NMLVDISPINFO*)pnmh;
              static char szGlobalBuf[100];
              if (pdi->item.mask | LVIF_TEXT)
              {
                  switch (pdi->item.iSubItem)
                  {
                  case 0:
                      GetValueStringFromValueIndex( pdi->item.iItem, szGlobalBuf );
                      pdi->item.pszText = szGlobalBuf;
                      break;

                  case 1:
                      int count = GetValueCountFromValueIndex( pdi->item.iItem );
                      sprintf(szGlobalBuf, "%d", count );
                      pdi->item.pszText = szGlobalBuf;
                      break;
                  }
              }
          }

          if (pnmh->code == TVN_SELCHANGED)
          {
              // The only tree
              NMTREEVIEW *pnmtv = (NMTREEVIEW *)pnmh;
              CallSelChangeParams(pnmtv->itemNew.hItem);
          }

          if (pnmh->code == TVN_ITEMEXPANDING)
          {
              NMTREEVIEW *pnmtv = (NMTREEVIEW *)pnmh;
              if (pnmtv->hdr.idFrom == IDC_PARAMS &&
                  pnmtv->action == TVE_EXPAND )
              {
                  if (NULL == TreeView_GetChild( pnmtv->hdr.hwndFrom, pnmtv->itemNew.hItem ))
                  {
                      // should have children, but it doesn't yet.. add them now
                      g_hItemParent = pnmtv->itemNew.hItem;
                      OnExpandParam( (VSymbol *)pnmtv->itemNew.lParam );
                      g_hItemParent = TVI_ROOT;
                  }
              }
          }
      }

   }

   return false;
}

void ClearProgramList()
{
    SendMessage( hWndProgams, LB_RESETCONTENT, 0 ,0 );
}

void AddProgramToList( const char *sz, VProg *pProg )
{
    int iItem = SendMessage( hWndProgams, LB_ADDSTRING, 0, WPARAM(sz) );
    SendMessage( hWndProgams, LB_SETITEMDATA, iItem, LPARAM(pProg) ); 
}

void ClearComponentList()
{
    SendMessage( hWndComponents, LB_RESETCONTENT, 0, 0 );
}

void AddComponentToList( const char *sz, VComp *pComp )
{
    int iItem = SendMessage( hWndComponents, LB_ADDSTRING, 0, WPARAM(sz) );
    SendMessage( hWndComponents, LB_SETITEMDATA, iItem, LPARAM(pComp) ); 
}

void ClearProcedureList()
{
    SendMessage( hWndFunctions, LB_RESETCONTENT, 0, 0 );
}

void AddProcedureToList( VProc *pProc, int iProc )
{
    SendMessage( hWndFunctions, LB_ADDSTRING, iProc, WPARAM(pProc) );
}

void ClearParamsList()
{
    TreeView_DeleteAllItems( hWndParams );
}

void AddParamToTree( const char *szSym, VSymbol *pSym, bool fChildren )
{
    TVINSERTSTRUCT tvis;
    memset( &tvis, 0, sizeof(tvis));
    tvis.hParent = g_hItemParent;
    tvis.hInsertAfter = TVI_LAST;
    tvis.item.mask = TVIF_CHILDREN | TVIF_PARAM | TVIF_TEXT;
    tvis.item.pszText = (char *)szSym;
    tvis.item.lParam = LPARAM(pSym);
    tvis.item.cChildren = fChildren;

    SendMessage( hWndParams, TVM_INSERTITEM, 0, LPARAM( &tvis ) );
}

VSymbol *PSymFromHItem( HWND hParams, HTREEITEM hItem)
{
    TVITEM tvi;
    memset( &tvi, 0, sizeof(TVITEM) );
    tvi.mask = TVIF_PARAM;
    tvi.hItem = hItem;
    TreeView_GetItem( hParams, LPARAM(&tvi));

    return (VSymbol *)tvi.lParam;
}

void CallSelChangeParams(HTREEITEM hItemSel)
{
    // First, build up the array of selected items
    if (hItemSel == NULL)
    {
        OnSelChangeParams( NULL, 0 );
        return;
    }

    // Go get the array of pSym's
    VSymbol *rgSym[256];
    
    HTREEITEM hItem = hItemSel;
    int i = 0;
    while (hItem && i <256)
    {
        rgSym[i++] = PSymFromHItem( hWndParams, hItem );
        hItem = TreeView_GetParent( hWndParams, hItem );
    }

    if (i == 256)
    {
        OnSelChangeParams( NULL, 0 );
        return;
    }

    OnSelChangeParams( rgSym, i );
}

void Error( const char *szError )
{
    MessageBox( NULL, szError, "Error", MB_OK | MB_ICONEXCLAMATION );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\Vulcan\Samples\src\Inststatdll\inststatdll.cpp ===
/***********************************************************************
* Microsoft  Vulcan
*
* Microsoft Confidential.  Copyright 1997-2000 Microsoft Corporation.
*
* File: Inststatdll.cpp
*
* File Comments:
*
*
***********************************************************************/

#pragma warning(disable: 4786) //dentifier was truncated to '255'

#include <map>
#include <stdio.h>
#include <vector>

#define STRICT
#define WIN32_LEAN_AND_MEAN
#include "windows.h"

std::vector<char*> opStrs;
std::map<int,int> bbCount;

int NumBBs;
int NumInsts;
int* BBindexes;
int* Insts;

extern "C" __declspec(dllexport) void _cdecl SendNum(int num)
{
   if (bbCount.find(num) == bbCount.end())
   {
      bbCount[num]=0;
   }

   bbCount[num]++;
}

extern "C" __declspec(dllexport)
void _cdecl SendProcStr(char* str)
{
}

extern "C" __declspec(dllexport)
void _cdecl SendStr(char* str)
{
    opStrs.push_back(str);
}

extern "C" __declspec(dllexport)
void _cdecl SendInstInfo(int numbb, int numi, int *bbs, int* is)
{
   NumBBs=numbb;
   NumInsts=numi;
   BBindexes = bbs;
   Insts = is;
}

std::vector<int> InstCount(std::map<int,int> counts)
{
   std::vector<int> ret(opStrs.size(),0);
   int index=0;

   for (int bbi=0;bbi<NumBBs;bbi++)
   {
      int addAmount = 0;
      if (counts.find(bbi) != counts.end())
      {
         addAmount = counts[bbi];
      }

      int bbIndexEnd = BBindexes[bbi];
      for ( ; ((index < bbIndexEnd) && (index < NumInsts)); index++)
      {
         ret[Insts[index]] += addAmount;
      }
   }
   return ret;
}

void PrintResults()
{
   std::vector<int> InstCounts = InstCount(bbCount);

#if 0
   std::map<int,int> StatCount;
   for (int i=0;i<NumBBs;i++)
   {
      StatCount[i]=1;
   }

   std::vector<int> StatCounts = InstCount(StatCount);
#endif

   for (int i=0;i<opStrs.size();i++)
   {
      printf("%s\t%d\n",opStrs[i],InstCounts[i]);
   }
}

BOOL APIENTRY DllMain(HANDLE hModule, 
                      DWORD  ul_reason_for_call, 
                      LPVOID lpReserved)
{
   switch ( ul_reason_for_call )
   {
      case DLL_PROCESS_DETACH:
         PrintResults();
         break;
   }

   return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\Vulcan\Samples\src\ProcTrace\proctracedll.cpp ===
#include <stdio.h>

extern "C" _declspec (dllexport) void _cdecl ProcTrace( const char * szName )
{
   //Just print out the name to stdout, and flush

   printf("%s\n", szName);
   fflush(stdout);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\Vulcan\Samples\src\ProcProf\procprof.h ===
/***********************************************************************
* Microsoft  Vulcan
*
* Microsoft Confidential.  Copyright 1997-2000 Microsoft Corporation.
*
* File: ProcProf.cpp
*
* File Comments:
*
*
***********************************************************************/

struct FUNDATA
{
    DWORD addr;         // The address of a routine in the instrumented binary
    const char *szFun;  // A pointer to the null terminated name of the routine
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\Vulcan\Samples\src\ProcProf\procprof.cpp ===
/***********************************************************************
* Microsoft  Vulcan
*
* Microsoft Confidential.  Copyright 1997-2000 Microsoft Corporation.
*
* File: ProcProf.cpp
*
* File Comments:
*
*
***********************************************************************/
#pragma warning(disable: 4514)

#include "vulcanapi.h"
#include "string.h"
#include "procprof.h"
#include "stdio.h"

int __cdecl main(int argc, char** argv);
void __stdcall Myhandler(VErr verr);

void ProcTrace(char* szImage, char *szCmdFile)
{
   VProg *pprog = VProg::Open(szImage, false, szCmdFile);
   int cProc = 0;

   for(VComp *pComp = pprog->FirstComp(); pComp; pComp = pComp->Next())
   {
      printf("%s\n",pComp->InputName());

      VBlock *pBlkInstr = pComp->CreateImport( "procprofdll.dll", "_ProcProf@0" );
      VAddress *pAddr = VAddress::Create( pBlkInstr );

      // Add a call to our dll at the beginning of each routine

      for (VProc *pProc = pComp->FirstProc(); pProc; pProc = pProc->Next())
      {
         cProc++;
         
         if (strstr( pProc->Name(), "setjmp" ))
         {
             // This function can return more than once per call, so ignore it
             continue;
         }
          
         VBlock *pBlk = pProc->FirstBlock();
         pBlk->InsertFirstInst( VInst::Create( COp::CALL, pAddr ));
      }

      // Leave an extra "empty" entry in the proc table

      cProc++;

      // Create a data section in the image to store the address and
      // name of each routine.

      VSect *pSectData = pComp->NewSect( ".prof", Sec_READWRITE );
      VProc *pProcData = VProc::Create(pComp, "Data");
      pSectData->InsertFirstProc( pProcData );
      FUNDATA *rgData = new FUNDATA[cProc];
      memset( rgData, 0, sizeof(FUNDATA) * cProc);
      VBlock *pBlk = VBlock::CreateDataBlock( pComp,
                                              (BYTE *)rgData,
                                              cProc * sizeof(FUNDATA) );
      pProcData->InsertFirstBlock( pBlk );

      // Add pointers in the section which point at each routine and its name
      // (which we also add to the section).

      VRelocIter ri = pBlk->FirstReloc();
      int iProc = 0;
      for (pProc = pComp->FirstProc(); pProc; pProc = pProc->Next())
      {
         VReloc *pReloc = VReloc::Create(
                              pProc->FirstBlock(),
                              0,
                              ((BYTE *)(&rgData[iProc].addr)) - (BYTE *)rgData,
                              VReloc::Absolute );
         ri.AddLast(pReloc);

         const char *szName = pProc->Name();
         VBlock *pBlkStr = VBlock::CreateDataBlock( pComp,
                                                    (BYTE *)szName,
                                                    strlen(szName) + 1 );
         pProcData->InsertLastBlock( pBlkStr );

         pReloc = VReloc::Create( pBlkStr,
                                  0,
                                  ((BYTE *)(&rgData[iProc].szFun)) - (BYTE *)rgData,
                                  VReloc::Absolute );
         ri.AddLast(pReloc);

         iProc++;
      }

      // Init the last entry with a large address

      rgData[iProc].addr  = 0xFFFFFFFF;
      rgData[iProc].szFun = NULL;

      // Add a call to our dlls initialization routine before the binary begins executing

      VProtoList *pList = VProtoList::CreateProtoList();
      VProto *pProto = pList->CreateProto( pComp, "procprofdll.dll", "InitProcProf(blockaddr, int)");
      pProto->AddCall( pComp, BEFORE, pBlk, cProc );
      pList->Commit();

      // Write out the image

      pComp->Write();
   }
}


int __cdecl main(int argc, char** argv)
{

   if (argc != 2 && argc != 3)
   {
      printf("usage: ProcTrace <Image-Name> [foo.cmdfile]\n");
      return 1;
   }

   try
   {
      ProcTrace(argv[1], argv[2]);
   }

   catch (VErr& verr) 
   {
      printf("Error: %s\n",verr.GetWhat());
      return 1;
   }

   catch (...)
   {
      printf("Error: unknown\n");
      return 1; 
   }

   return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\Vulcan\Samples\src\ProcProf\procprofdll.cpp ===
/***********************************************************************
* Microsoft  Vulcan
*
* Microsoft Confidential.  Copyright 1997-2000 Microsoft Corporation.
*
* File: ProcProfDll.cpp
*
* File Comments:
*
*
***********************************************************************/
#include <stdio.h>

#define WIN32_LEAN_AND_MEAN
#include "windows.h"
#include "stdlib.h"

#include "procprof.h"

// Routine to read Pentium time stamp counter
_inline _declspec( naked ) __int64 RDTSC()
{
   _asm RDTSC
   _asm ret
}

#pragma pack (1)

// We maintain a "shadow stack" for each thread so we don't have to unwind the stack.
struct SHADOWSTACKENTRY
{
   // The first 10 bytes of a shadow stack entry are code.
   // We patch the a return address of each function call with
   // the address of the associated shadow stack entry.
   // This way, we always know where we are returning to.
   BYTE push;               // 0x68 or push dword on x86;
   SHADOWSTACKENTRY *psse;  // This is a pointer to this shadow stack entry
   BYTE jump;               // 0xE9 or jump dword on x86
   DWORD ibProcExit;        // Offset to our ProcExitProf routine

   void *pvRASave;          // The real return address assocated with this entry
   void *pvTarget;          // The procedure which was called
   __int64 timeEnter;       // The RDTSC time we entered this routine
};

// A single structure which represents the shadow stack for each thread
struct THREADDATA
{
   THREADDATA *pNext;               // Free List next pointer
   SHADOWSTACKENTRY *pTop;          // A pointer to the top entry in this stack
   SHADOWSTACKENTRY rgEntries[200]; // Array of entries on this stack

   void *operator new( size_t cb );
   void operator delete( void *pv );
   static THRE