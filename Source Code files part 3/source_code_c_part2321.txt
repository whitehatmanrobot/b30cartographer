I_WR08              // In:[Bus, Device, Function, Offset, Data] Out:[]
    ,PROPERTY_PCI_WR16              // In:[Bus, Device, Function, Offset, Data] Out:[]
    ,PROPERTY_PCI_WR32              // In:[Bus, Device, Function, Offset, Data] Out:[]

    // Set clocks.
    ,PROPERTY_SET_GRAPHICS_CLOCK    // In:[Frequency (Hz)]       Out:[]
    ,PROPERTY_SET_MEMORY_CLOCK      // In:[Frequency (Hz)]       Out:[]
    ,PROPERTY_SET_PIXEL_CLOCK       // In:[Head, Frequency (Hz)] Out:[]
};

#ifdef __cplusplus
}
#endif // __cplusplus

#endif // _NVCMRSVD_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\common\inc\rmfail.h ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-1999 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-1997  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/*
 * header file for resource manager failure injection (testing) support
 */

#ifdef DEBUG_RM_FAILURES

#define RM_FAILURES_MAX 1024  /* or whatever */
int rm_failure[RM_FAILURES_MAX];
int rm_failure_counts[RM_FAILURES_MAX];

// personality flags for the triggers
#define RM_FAILURES_FLAG_BREAK_ON_TRIGGER        0x80000000
#define RM_FAILURES_FLAG_DONT_DISABLE_ON_TRIGGER 0x40000000

// these occupy the bottom half of the word
#define RM_FAILURES_MASK_PERCENT 0x8000
#define RM_FAILURES_MAX_COUNT    0x7fff
#define RM_FAILURES_MASK_COUNT   0x7fff

#define RM_FAILURE_TRIGGER_ENABLED(n) \
          (rm_failure[(n)] != 0)

#define RM_FAILURE_TRIGGERED(n) \
          RmFailureTriggered((n))

#define RM_FAILURE_TRIGGER_DISABLE(n) \
          rm_failure[(n)] = 0

#define RM_FAILURE_TEST(n, trigger) \
    do { \
        if (RM_FAILURE_TRIGGER_ENABLED((n))) { \
             if (RM_FAILURE_TRIGGERED((n))) { \
                trigger;	/* trigger the error */ \
             } \
         } \
    } while (0)
        

#define RM_FAILURE_ENABLE()  RmFailuresEnable()
#define RM_FAILURE_DISABLE() RmFailuresDisable()

int RmFailureTriggered(int n);
void RmFailuresEnable(void);
void RmFailuresDisable(void);
 
// how do the RM_FAILURE routines "printf" ?

#define RM_FAILURE_PRINTF(args)  DbgPrint args

#else	/* ! DEBUG_RM_FAILURES */
#define RM_FAILURE_TEST(n, trigger)
#define RM_FAILURE_ENABLE()
#define RM_FAILURE_DISABLE()

#endif  /* DEBUG_RM_FAILURES */

//
// convenience macros to assign ranges to tests
//

#define RM_FAILURE_OS(n, trig)          RM_FAILURE_TEST( 00+(n), trig)
#define RM_FAILURE_DAC(n, trig)         RM_FAILURE_TEST( 20+(n), trig)
#define RM_FAILURE_BTREE(N, TRIG)       RM_FAILURE_TEST( 40+(N), TRIG)
#define RM_FAILURE_CLASS(N, TRIG)       RM_FAILURE_TEST( 60+(N), TRIG)
#define RM_FAILURE_DEVINIT(N, TRIG)     RM_FAILURE_TEST( 80+(N), TRIG)
#define RM_FAILURE_DMA(N, TRIG)         RM_FAILURE_TEST(100+(N), TRIG)
#define RM_FAILURE_FB(N, TRIG)          RM_FAILURE_TEST(120+(N), TRIG)
#define RM_FAILURE_FIFO(N, TRIG)        RM_FAILURE_TEST(140+(N), TRIG)
#define RM_FAILURE_GR(N, TRIG)          RM_FAILURE_TEST(160+(N), TRIG)
#define RM_FAILURE_HEAP(N, TRIG)        RM_FAILURE_TEST(180+(N), TRIG)
#define RM_FAILURE_MC(N, TRIG)          RM_FAILURE_TEST(200+(N), TRIG)
#define RM_FAILURE_MODULAR(N, TRIG)     RM_FAILURE_TEST(220+(N), TRIG)
#define RM_FAILURE_MP(N, TRIG)          RM_FAILURE_TEST(240+(N), TRIG)
#define RM_FAILURE_NVKERNEL(N, TRIG)    RM_FAILURE_TEST(260+(N), TRIG)
#define RM_FAILURE_STATE(N, TRIG)       RM_FAILURE_TEST(280+(N), TRIG)
#define RM_FAILURE_TMR(N, TRIG)         RM_FAILURE_TEST(300+(N), TRIG)
#define RM_FAILURE_VBLANK(N, TRIG)      RM_FAILURE_TEST(320+(N), TRIG)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\common\inc\nvwin32.h ===
#ifndef NVWIN32_INCLUDED
#define NVWIN32_INCLUDED
 /***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*       Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/

#ifdef __cplusplus
extern "C" {
#endif

#ifndef NV32_INCLUDED
#include <nv32.h>                       /* for NvChannel typedef */
#endif

/***************************************************************************
 *                   NVIDIA-supplied routines                              *
 ***************************************************************************/

/***** Hardware access *****/

/*
 * NvOpen() opens a 64KB channel (shared memory region) to the chip.
 * Pass NULL as the parameter for the default NV1 chip in the computer.
 */
extern NvChannel * __stdcall NvOpen(char *);

/*
 * NvOpenDma() opens a 64KB channel (shared memory region) to the chip.
 * Pass NULL as the parameter for the default NV1 chip in the computer.
 */
extern NvChannel * __stdcall NvOpenDma(char *, int, int, int);

/*
 * NvClose() closes the channel to the chip and attempts to
 * clean up all objects created in that channel.
 */
extern int                  __stdcall NvClose(NvChannel *);

/***** Operating Environment routines *****/
/*
 * NvWait() waits to be "awakened" after requesting notification with
 * the NV_OS_NOTIFY_WILL_SLEEP style.
 * Note that in Windows 3.1 any Windows message will wake up the
 * application.
 */
extern int  __stdcall NvWait(NvChannel *);

/*
 * NvNotifyMsg() specifies a Windows message for NV1 to send to the
 * application after requesting notifications with the
 * NV_OS_NOTIFY_MESSAGE style.
 *    first parameter is the NvChannel
 *    second is the HWND window handle
 *    third is the Windows message that the Resource Manager should send
 */
extern int  __stdcall NvNotifyMsg(NvChannel *, int, int);

/*
 * NvErrorMsg() specifies a Windows message for NV to send to the
 * application upon detecting an error.
 *    first parameter is the NvChannel
 *    second is the HWND window handle
 *    third is the Windows message that the Resource Manager should send
 */
extern int  __stdcall NvErrorMsg(NvChannel *, int, int);

/*
 * Although Win32 applications have a flat address space, on the X86 
 * architecture they still have a single selector that you must supply as
 *    contextDmaToMemory.SetDmaSpecifier.address[1].
 */
extern int  __stdcall NvGetFlatDataSelector(void);
extern int  __stdcall NvGetFlatCodeSelector(void);

/*
 * NvConfigVersion() returns an NV version number indicating the NV version.
 * The format of this is 0x00010206, where
 *  - 0x0001 is the chip architecture
 *  -   0x02 is the software release
 *  -   0x06 is the minor revision
 */
extern int  __stdcall NvConfigVersion(void);

#define NV_CHIP_ARCH(ver)   ((ver) >> 16)
#define NV_SW_RELEASE(ver)  (((ver) >> 8) & 0xFF)
#define NV_MINOR_REV(ver)   ((ver) & 0xFF)

/***************************************************************************
 *                          Constants                                      *
 ***************************************************************************/

/***** OS-dependent constants *****/

/* This posts a new architecture event */
#define NV_OS_WRITE_THEN_AWAKEN	   0x00000001

/* This puts the process to sleep awaiting notification */
#define NV_OS_NOTIFY_WILL_SLEEP	   0x00000003

/* This puts a message in the client's message queue upon notification */
#define NV_OS_NOTIFY_MESSAGE	   0x00000002

/* This posts a Win32 event to the client upon notification */
#define NV_OS_NOTIFY_EVENT  	   0x00000004

/* This posts a Ring0 event to the client upon notification */
#define NV_OS_NOTIFY_VM_EVENT  	   0x00000005

/* This posts a Ring0 event to the client upon notification */
#define NV_OS_NOTIFY_STATE_CHANGE  0x00000006


/***************************************************************************
 *                     OS Resource Strings                                 *
 ***************************************************************************/

/* Maximum length of an OS string (conservative, actual is about 24) */
#define NV_OS_MAX_NAME_LENGTH      32

/***** OS resource names for sources and sinks of samples *****/

/* for NV_VIDEO_SINK */
#define NV_OS_VIDEO_MONITOR        "CON:"

/* for NV_IMAGE_TO_VIDEO. The HWND window handle should replace %u */
#define NV_OS_CANVAS_WINDOW        "WND%u:"

/* for NV_AUDIO_SINK */
#define NV_OS_LINE_OUT_LEFT        "LIN:\\LEFT"
#define NV_OS_LINE_OUT_RIGHT       "LIN:\\RIGHT"

/* for NV_AUDIO_SOURCE */
#define NV_OS_LINE_IN_LEFT         "LIN:\\LEFT"
#define NV_OS_LINE_IN_RIGHT        "LIN:\\RIGHT"
#define NV_OS_MIC_IN_LEFT          "MIC:\\LEFT"
#define NV_OS_MIC_IN_RIGHT         "MIC:\\RIGHT"


/***** Many devices can provide samples for NV_GAME_PORT_SOURCE *****/

/* Raw potentiometer data on analog connector from NV_GAME_PORT_SOURCE. */
/* One of the 8 channels (0-7) replaces %d */
/* NOTE: The NV_OS_POT O/S string changed to "POTA%d:". The 2.0 and higher
 * Resource Manager will generate NV_ERROR1_NO_SUCH_OBJECT if there is no 
 * joystick connected. This string means nothing to the 1.20 Resource Manager.
 * For backwards compatibility, use NV_OS_GAME_PORT ("POT%d:"): both the 2.0 
 * and 1.20 Resource Manager will not generate an error if no joystick is
 * connected.
 */
#define NV_OS_POT                      "POTA%d:"
/* XXX Old name preserved for compatibility, use NV_OS_POT */
#define NV_OS_GAME_PORT                "POT%d:"


/* Calibrated joystick data on analog connector from NV_GAME_PORT_SOURCE. */
/* One of the 2 channels (0-1) replaces %d */
/* XXX Not yet implemented */
#define NV_OS_JOYSTICK_BUTTONS         "JOY%d:\\BUTTONS"

#define NV_OS_JOYSTICK_BUTTON_TRIGGER  0x0001
#define NV_OS_JOYSTICK_BUTTON_SELECT   0x0002
#define NV_OS_JOYSTICK_BUTTON_A        0x0004
#define NV_OS_JOYSTICK_BUTTON_B        0x0008

#define NV_OS_JOYSTICK_X_AXIS          "JOY%d:\\X_AXIS"
#define NV_OS_JOYSTICK_Y_AXIS          "JOY%d:\\Y_AXIS"


/* Pedal data on analog connector from NV_GAME_PORT_SOURCE. */
/* One of the 2 channels (0-1) replaces %d */
/* XXX Not yet implemented */
#define NV_OS_PEDALS                   "PEDALS%d:"


/* Throttle data on analog connector from NV_GAME_PORT_SOURCE. */
/* One of the 2 channels (0-1) replaces %d */
/* XXX Not yet implemented */
#define NV_OS_THROTTLE                 "THROTTLE%d:"


/* 8-button game pad data on Sega Saturn connector from NV_GAME_PORT_SOURCE. */
/* One of the 6 channels (0-5) replaces %d */
#define NV_OS_PAD_BUTTONS              "PAD%d:"
/* XXX Old name preserved for compatibility, use NV_OS_PAD_BUTTONS */
#define NV_OS_PAD                      "PAD%d:"

#define NV_OS_PAD_BUTTON_START         0x0001
#define NV_OS_PAD_BUTTON_RIGHT         0x0002
#define NV_OS_PAD_BUTTON_LEFT          0x0004
#define NV_OS_PAD_BUTTON_UP            0x0008
#define NV_OS_PAD_BUTTON_DOWN          0x0010
#define NV_OS_PAD_BUTTON_A             0x0020
#define NV_OS_PAD_BUTTON_B             0x0040
#define NV_OS_PAD_BUTTON_C             0x0080
#define NV_OS_PAD_BUTTON_X             0x0100
#define NV_OS_PAD_BUTTON_Y             0x0200
#define NV_OS_PAD_BUTTON_Z             0x0400
#define NV_OS_PAD_BUTTON_TOP_RIGHT     0x0800
#define NV_OS_PAD_BUTTON_TOP_LEFT      0x1000


/* 3-axis yoke data on Sega Saturn connector from NV_GAME_PORT_SOURCE. */
/* One of the 6 channels (0-5) replaces %d */
#define NV_OS_YOKE_BUTTONS             "YOKE%d:\\BUTTONS"

#define NV_OS_YOKE_BUTTON_START        0x0001
#define NV_OS_YOKE_BUTTON_RIGHT        0x0002
#define NV_OS_YOKE_BUTTON_LEFT         0x0004
#define NV_OS_YOKE_BUTTON_UP           0x0008
#define NV_OS_YOKE_BUTTON_DOWN         0x0010
#define NV_OS_YOKE_BUTTON_A            0x0020
#define NV_OS_YOKE_BUTTON_B            0x0040
#define NV_OS_YOKE_BUTTON_C            0x0080
#define NV_OS_YOKE_BUTTON_X            0x0100
#define NV_OS_YOKE_BUTTON_Y            0x0200
#define NV_OS_YOKE_BUTTON_Z            0x0400
#define NV_OS_YOKE_BUTTON_TOP_RIGHT    0x0800
#define NV_OS_YOKE_BUTTON_TOP_LEFT     0x1000

#define NV_OS_YOKE_X_AXIS              "YOKE%d:\\X_AXIS"
#define NV_OS_YOKE_Y_AXIS              "YOKE%d:\\Y_AXIS"
#define NV_OS_YOKE_Z_AXIS              "YOKE%d:\\Z_AXIS"

/* 2-axis gun position data on Sega Saturn connector from NV_GAME_PORT_SOURCE. */
/* One of the 2 channels (0-1) replaces %d */
/* The HWND window handle should replace %u */
#define NV_OS_GUN_BUTTONS              "GUN%dWND%u:\\BUTTONS"

#define NV_OS_GUN_BUTTON_START         0x0001
#define NV_OS_GUN_BUTTON_TRIGGER	   0x0002

#define NV_OS_GUN_X_POSITION		   "GUN%dWND%u:\\X_POS"
#define NV_OS_GUN_Y_POSITION		   "GUN%dWND%u:\\Y_POS"

/* Value returned if gun is still determing X/Y coordinate */
#define NV_OS_GUN_POSITION_COUNTING    0xFFFE
/* Value returned if gun is off screen or outside canvas) */
#define NV_OS_GUN_POSITION_OFF_SCREEN  0xFFFF

/***** WATCOM special handling *****/
/* WATCOM 10.0 compiler needs special declaration of these functions */
#ifdef __WATCOMC__
#pragma aux (__stdcall) NvOpen "*";
#pragma aux (__stdcall) NvClose "*";
#pragma aux (__stdcall) NvWait "*";
#pragma aux (__stdcall) NvNotifyMsg "*";
#pragma aux (__stdcall) NvErrorMsg "*";
#pragma aux (__stdcall) NvGetFlatDataSelector "*";
#pragma aux (__stdcall) NvGetFlatCodeSelector "*";
#pragma aux (__stdcall) NvVpeExtras "*";
#pragma aux (__stdcall) NvDmaPushOperation "*";
#ifdef VPE_EXTRAS
#pragma aux (__stdcall) NvOverlayExtras "*";
#endif

#ifdef _WIN32  // don't do this for the DOS compile!!
#pragma aux (__stdcall) NvConfigVersion "*";
#endif
#endif /* __WATCOMC__ */

#ifdef __cplusplus
};
#endif
#endif /* NVWIN32_INCLUDED */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\common\src\nv\cpuid-ppc.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1999 NVIDIA, Corp.  All rights reserved.             *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1999 NVIDIA, Corp.    NVIDIA  design  patents           *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************* CPU Information Gather Routines ***********************\
*                                                                           *
* Module: cpuid-ppc.c                                                       *
*   One time initialization code to setup the Processor type                *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nvrm.h>
#include <nvcm.h>
#include <os.h>

#ifdef MACOS9
#include <MacTypes.h>
#include <NameRegistry.h>

static U032 PPCAttributes_macos9(
    PHWINFO pDev
)
{
    U032 attributes = 0;
    U032 wc_supported;
    RegEntryIter            cookie;
    RegEntryID              entryID;
    OSStatus                err = noErr;
    RegEntryIterationOp     iterOp;
    Boolean                 done;
        
    // write-combining?
    wc_supported = osReadRegistryBoolean(pDev, "Devices:device-tree:pci", "write-combining");

    if (wc_supported)
          attributes |= NV_CPU_FUNC_WRITE_COMBINING;
    
    // XXX hack for P21s that don't have a rom that sets 'write-combining' (1/2001)
    // WC first supported on P21
    if ( ! wc_supported)
    {
        char model_name[32+1];
        U032 len = sizeof(model_name) - 1;
        if (RM_OK == osReadRegistryBinary(pDev, "Devices:device-tree", "model", (unsigned char *) model_name, &len))
        {
            if (0 == strncmp(model_name, "PowerMac3,4", 11))
               attributes |= NV_CPU_FUNC_WRITE_COMBINING;
        }
    }

    // altivec?
    RegistryEntryIDInit(&entryID);

    iterOp = kRegIterDescendants;
    if (noErr == RegistryEntryIterateCreate(&cookie))
    {
       do
       {
           err = RegistryEntrySearch(&cookie, iterOp,
                                     &entryID, &done, "altivec", (char *) 0, 0);
           if ( ! done && (noErr == err))
           {
               attributes |= NV_CPU_FUNC_ALTIVEC;
               RegistryEntryIDDispose(&entryID);
               done = 1;        // can also be set by RegistryEntrySearch
           }

           iterOp = kRegIterContinue;
       } while ( ! done && (err == noErr));
    }
    RegistryEntryIterateDispose(&cookie);   

    return attributes;
}
#endif

#ifdef MACOSX
static U032 PPCAttributes_macosX(
    PHWINFO pDev
)
{
    U032 attributes = 0;

    return attributes;
}
#endif

/*
 * ID the CPU.
 */
VOID RmInitCpuInfo(
    PHWINFO pDev
)
{
    PRMINFO pRmInfo = (PRMINFO) pDev->pRmInfo;

    // XXX
    pRmInfo->Processor.Type = NV_CPU_PPC603;
#if defined(MACOS9)
    pRmInfo->Processor.Type |= PPCAttributes_macos9(pDev);
#elif defined(MACOSX)
    pRmInfo->Processor.Type |= PPCAttributes_macosX(pDev);
#endif

    // Calculate the frequency
    pRmInfo->Processor.Clock = osGetCpuFrequency();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\common\src\nv\dload_inflate.c ===
/* inflate.c -- Not copyrighted 1992 by Mark Adler
   version c10p1, 10 January 1993 */

/* You can do whatever you like with this source file, though I would
   prefer that if you modify it and redistribute it that you include
   comments to that effect with your name and the date.  Thank you.
   [The history has been moved to the file ChangeLog.]
 */

/*
   Inflate deflated (PKZIP's method 8 compressed) data.  The compression
   method searches for as much of the current string of bytes (up to a
   length of 258) in the previous 32K bytes.  If it doesn't find any
   matches (of at least length 3), it codes the next byte.  Otherwise, it
   codes the length of the matched string and its distance backwards from
   the current position.  There is a single Huffman code that codes both
   single bytes (called "literals") and match lengths.  A second Huffman
   code codes the distance information, which follows a length code.  Each
   length or distance code actually represents a base value and a number
   of "extra" (sometimes zero) bits to get to add to the base value.  At
   the end of each deflated block is a special end-of-block (EOB) literal/
   length code.  The decoding process is basically: get a literal/length
   code; if EOB then done; if a literal, emit the decoded byte; if a
   length then get the distance and emit the referred-to bytes from the
   sliding window of previously emitted data.

   There are (currently) three kinds of inflate blocks: stored, fixed, and
   dynamic.  The compressor deals with some chunk of data at a time, and
   decides which method to use on a chunk-by-chunk basis.  A chunk might
   typically be 32K or 64K.  If the chunk is uncompressible, then the
   "stored" method is used.  In this case, the bytes are simply stored as
   is, eight bits per byte, with none of the above coding.  The bytes are
   preceded by a count, since there is no longer an EOB code.

   If the data is compressible, then either the fixed or dynamic methods
   are used.  In the dynamic method, the compressed data is preceded by
   an encoding of the literal/length and distance Huffman codes that are
   to be used to decode this block.  The representation is itself Huffman
   coded, and so is preceded by a description of that code.  These code
   descriptions take up a little space, and so for small blocks, there is
   a predefined set of codes, called the fixed codes.  The fixed method is
   used if the block codes up smaller that way (usually for quite small
   chunks), otherwise the dynamic method is used.  In the latter case, the
   codes are customized to the probabilities in the current block, and so
   can code it much better than the pre-determined fixed codes.
 
   The Huffman codes themselves are decoded using a mutli-level table
   lookup, in order to maximize the speed of decoding plus the speed of
   building the decoding tables.  See the comments below that precede the
   lbits and dbits tuning parameters.
 */


/*
   Notes beyond the 1.93a appnote.txt:

   1. Distance pointers never point before the beginning of the output
      stream.
   2. Distance pointers can point back across blocks, up to 32k away.
   3. There is an implied maximum of 7 bits for the bit length table and
      15 bits for the actual data.
   4. If only one code exists, then it is encoded using one bit.  (Zero
      would be more efficient, but perhaps a little confusing.)  If two
      codes exist, they are coded using one bit each (0 and 1).
   5. There is no way of sending zero distance codes--a dummy must be
      sent if there are none.  (History: a pre 2.0 version of PKZIP would
      store blocks with no distance codes, but this was discovered to be
      too harsh a criterion.)  Valid only for 1.93a.  2.04c does allow
      zero distance codes, which is sent as one code of zero bits in
      length.
   6. There are up to 286 literal/length codes.  Code 256 represents the
      end-of-block.  Note however that the static length tree defines
      288 codes just to fill out the Huffman codes.  Codes 286 and 287
      cannot be used though, since there is no length base or extra bits
      defined for them.  Similarly, there are up to 30 distance codes.
      However, static trees define 32 codes (all 5 bits) to fill out the
      Huffman codes, but the last two had better not show up in the data.
   7. Unzip can check dynamic Huffman blocks for complete code sets.
      The exception is that a single code would not be complete (see #4).
   8. The five bits following the block type is really the number of
      literal codes sent minus 257.
   9. Length codes 8,16,16 are interpreted as 13 length codes of 8 bits
      (1+6+6).  Therefore, to output three times the length, you output
      three codes (1+1+1), whereas to output four times the same length,
      you only need two codes (1+3).  Hmm.
  10. In the tree reconstruction algorithm, Code = Code + Increment
      only if BitLength(i) is not zero.  (Pretty obvious.)
  11. Correction: 4 Bits: # of Bit Length codes - 4     (4 - 19)
  12. Note: length code 284 can represent 227-258, but length code 285
      really is 258.  The last length deserves its own, short code
      since it gets used a lot in very redundant files.  The length
      258 is special since 258 - 3 (the min match length) is 255.
  13. The literal/length and distance code bit lengths are read as a
      single stream of lengths.  It is possible (and advantageous) for
      a repeat code (16, 17, or 18) to go across the boundary between
      the two sets of lengths.
 */

//-----------------------------------------------------------------------------
// nVidia modifications are soley around interface cleanup,                  //
// compiler warnings, etc.  Nothing of any consequence.                      //
// This file comes from the gzip dist'n, but is not covered by GPL           //
// due to the statement at the top.                                          //
//-----------------------------------------------------------------------------

#include <nv_ref.h>
#include <nvrm.h>
#include <os.h>

#define NOMEMCPY 1

typedef NvU8   uch;
typedef NvU16 ush;
typedef NvU32  ulg;


//#include <sys/types.h>
//#include <stdlib.h>


/* Huffman code lookup table entry--this entry is four bytes for machines
   that have 16-bit pointers (e.g. PC's in the small or medium model).
   Valid extra bits are 0..13.  e == 15 is EOB (end of block), e == 16
   means that v is a literal, 16 < e < 32 means that v is a pointer to
   the next table, which codes e - 16 bits, and lastly e == 99 indicates
   an unused code.  If a code with e == 99 is looked up, this implies an
   error in the data. */
struct huft {
  uch e;                /* number of extra bits or operation */
  uch b;                /* number of bits in this code or subcode */
  union {
    ush n;              /* literal, length base, or distance base */
    struct huft *t;     /* pointer to next level of table */
  } v;
};

#define OF(X) X

/* Function prototypes */
static int huft_build OF((unsigned int *, unsigned int, unsigned int , ush *, ush *,
                   struct huft **, int *));
static int huft_free OF((struct huft *));
static int inflate_codes OF((struct huft *, struct huft *, int, int));
static int inflate_stored OF((void));
static int inflate_fixed OF((void));
static int inflate_dynamic OF((void));
static int inflate_block OF((int *));



/* The inflate algorithm uses a sliding 32K byte window on the uncompressed
   stream to find repeated byte strings.  This is implemented here as a
   circular buffer.  The index is updated simply by incrementing and then
   and'ing with 0x7fff (32K-1). */
/* It is left to other modules to supply the 32K area.  It is assumed
   to be usable as if it were declared "uch slide[32768];" or as just
   "uch *slide;" and then malloc'ed in the latter case.  The definition
   must be in unzip.h, included above. */
/* unsigned wp;             current position in slide */
#define WSIZE 0x8000
static NvU8 *inbuf,*outbuf;
static NvU32 inptr,outptr;
static unsigned int wp;
#define slide window
static uch window[WSIZE];
#define flush_output(w) (wp=(w),flush_window())
#define Tracecv(A,B) 
#define Tracevv(X) 



static void flush_window()
{
        if ( wp == 0) return;

        osMemCopy(outbuf+outptr,window,wp);

        outptr += wp;
        wp = 0;
}


/* Tables for deflate from PKZIP's appnote.txt. */
static unsigned int border[] = {    /* Order of the bit length code lengths */
        16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};
static ush cplens[] = {         /* Copy lengths for literal codes 257..285 */
        3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
        35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0};
        /* note: see note #13 above about the 258 in this list. */
static ush cplext[] = {         /* Extra bits for literal codes 257..285 */
        0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2,
        3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 99, 99}; /* 99==invalid */
static ush cpdist[] = {         /* Copy offsets for distance codes 0..29 */
        1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
        257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
        8193, 12289, 16385, 24577};
static ush cpdext[] = {         /* Extra bits for distance codes */
        0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6,
        7, 7, 8, 8, 9, 9, 10, 10, 11, 11,
        12, 12, 13, 13};



/* Macros for inflate() bit peeking and grabbing.
   The usage is:
   
        NEEDBITS(j)
        x = b & mask_bits[j];
        DUMPBITS(j)

   where NEEDBITS makes sure that b has at least j bits in it, and
   DUMPBITS removes the bits from b.  The macros use the variable k
   for the number of bits in b.  Normally, b and k are register
   variables for speed, and are initialized at the beginning of a
   routine that uses these macros from a global bit buffer and count.

   If we assume that EOB will be the longest code, then we will never
   ask for bits with NEEDBITS that are beyond the end of the stream.
   So, NEEDBITS should not read any more bytes than are needed to
   meet the request.  Then no bytes need to be "returned" to the buffer
   at the end of the last block.

   However, this assumption is not true for fixed blocks--the EOB code
   is 7 bits, but the other literal/length codes can be 8 or 9 bits.
   (The EOB code is shorter than other codes because fixed blocks are
   generally short.  So, while a block always has an EOB, many other
   literal/length codes have a significantly lower probability of
   showing up at all.)  However, by making the first table have a
   lookup of seven bits, the EOB code will be found in that first
   lookup, and so will not require that too many bits be pulled from
   the stream.
 */

static ulg bb;                         /* bit buffer */
static unsigned int bk;                    /* bits in bit buffer */

static ush mask_bits[] = {
    0x0000,
    0x0001, 0x0003, 0x0007, 0x000f, 0x001f, 0x003f, 0x007f, 0x00ff,
    0x01ff, 0x03ff, 0x07ff, 0x0fff, 0x1fff, 0x3fff, 0x7fff, 0xffff
};

#define NEXTBYTE()  inbuf[inptr++]



#define NEEDBITS(n) {while(k<(n)){b|=((ulg)NEXTBYTE())<<k;k+=8;}}
#define DUMPBITS(n) {b>>=(n);k-=(n);}


/*
   Huffman code decoding is performed using a multi-level table lookup.
   The fastest way to decode is to simply build a lookup table whose
   size is determined by the longest code.  However, the time it takes
   to build this table can also be a factor if the data being decoded
   is not very long.  The most common codes are necessarily the
   shortest codes, so those codes dominate the decoding time, and hence
   the speed.  The idea is you can have a shorter table that decodes the
   shorter, more probable codes, and then point to subsidiary tables for
   the longer codes.  The time it costs to decode the longer codes is
   then traded against the time it takes to make longer tables.

   This results of this trade are in the variables lbits and dbits
   below.  lbits is the number of bits the first level table for literal/
   length codes can decode in one step, and dbits is the same thing for
   the distance codes.  Subsequent tables are also less than or equal to
   those sizes.  These values may be adjusted either when all of the
   codes are shorter than that, in which case the longest code length in
   bits is used, or when the shortest code is *longer* than the requested
   table size, in which case the length of the shortest code in bits is
   used.

   There are two different values for the two tables, since they code a
   different number of possibilities each.  The literal/length table
   codes 286 possible values, or in a flat code, a little over eight
   bits.  The distance table codes 30 possible values, or a little less
   than five bits, flat.  The optimum values for speed end up being
   about one bit more than those, so lbits is 8+1 and dbits is 5+1.
   The optimum values may differ though from machine to machine, and
   possibly even between compilers.  Your mileage may vary.
 */


const int lbits = 9;          /* bits in base literal/length lookup table */
const int dbits = 6;          /* bits in base distance lookup table */


/* If BMAX needs to be larger than 16, then h and x[] should be ulg. */
#define BMAX 16         /* maximum bit length of any code (16 for explode) */
#define N_MAX 288       /* maximum number of codes in any set */


static unsigned int hufts;         /* track memory usage */


static int huft_build(b, n, s, d, e, t, m)
unsigned int *b;            /* code lengths in bits (all assumed <= BMAX) */
unsigned int n;             /* number of codes (assumed <= N_MAX) */
unsigned int s;             /* number of simple-valued codes (0..s-1) */
ush *d;                 /* list of base values for non-simple codes */
ush *e;                 /* list of extra bits for non-simple codes */
struct huft **t;        /* result: starting table */
int *m;                 /* maximum lookup bits, returns actual */
/* Given a list of code lengths and a maximum table size, make a set of
   tables to decode that set of codes.  Return zero on success, one if
   the given code set is incomplete (the tables are still built in this
   case), two if the input is invalid (all zero length codes or an
   oversubscribed set of lengths), and three if not enough memory. */
{
  unsigned int a;                   /* counter for codes of length k */
  unsigned int c[BMAX+1];           /* bit length count table */
  unsigned int f;                   /* i repeats in table every f entries */
  int g;                        /* maximum code length */
  int h;                        /* table level */
  unsigned int i;          /* counter, current code */
  unsigned int j;          /* counter */
  int k;               /* number of bits in current code */
  int l;                        /* bits per table (returned in m) */
  unsigned int *p;         /* pointer into c[], b[], or v[] */
  struct huft *q;      /* points to current table */
  struct huft r;                /* table entry for structure assignment */
  struct huft *u[BMAX];         /* table stack */
  unsigned int v[N_MAX];            /* values in order of bit length */
  int w;               /* bits before this table == (l * h) */
  unsigned int x[BMAX+1];           /* bit offsets, then code stack */
  unsigned int *xp;                 /* pointer into x */
  int y;                        /* number of dummy codes added */
  unsigned int z;                   /* number of entries in current table */


  /* Generate counts for each bit length */
  osMemSet((VOID*)c,0,sizeof(c));

  p = b;  i = n;
  do {
    Tracecv(*p, (stderr, (n-i >= ' ' && n-i <= '~' ? "%c %d\n" : "0x%x %d\n"), 
	    n-i, *p));
    c[*p]++;                    /* assume all entries <= BMAX */
    p++;                      /* Can't combine with above line (Solaris bug) */
  } while (--i);
  if (c[0] == n)                /* null input--all zero length codes */
  {
    *t = (struct huft *)NULL;
    *m = 0;
    return 0;
  }


  /* Find minimum and maximum length, bound *m by those */
  l = *m;
  for (j = 1; j <= BMAX; j++)
    if (c[j])
      break;
  k = j;                        /* minimum code length */
  if ((unsigned int)l < j)
    l = j;
  for (i = BMAX; i; i--)
    if (c[i])
      break;
  g = i;                        /* maximum code length */
  if ((unsigned int)l > i)
    l = i;
  *m = l;


  /* Adjust last length count to fill out codes, if needed */
  for (y = 1 << j; j < i; j++, y <<= 1)
    if ((y -= c[j]) < 0)
      return 2;                 /* bad input: more codes than bits */
  if ((y -= c[i]) < 0)
    return 2;
  c[i] += y;


  /* Generate starting offsets into the value table for each length */
  x[1] = j = 0;
  p = c + 1;  xp = x + 2;
  while (--i) {                 /* note that i == g from above */
    *xp++ = (j += *p++);
  }


  /* Make a table of values in order of bit lengths */
  p = b;  i = 0;
  do {
    if ((j = *p++) != 0)
      v[x[j]++] = i;
  } while (++i < n);


  /* Generate the Huffman codes and for each, make the table entries */
  x[0] = i = 0;                 /* first Huffman code is zero */
  p = v;                        /* grab values in bit order */
  h = -1;                       /* no tables yet--level -1 */
  w = -l;                       /* bits decoded == (l * h) */
  u[0] = (struct huft *)NULL;   /* just to keep compilers happy */
  q = (struct huft *)NULL;      /* ditto */
  z = 0;                        /* ditto */

  /* go through the bit lengths (k already is bits in shortest code) */
  for (; k <= g; k++)
  {
    a = c[k];
    while (a--)
    {
      /* here i is the Huffman code of length k bits for value *p */
      /* make tables up to required level */
      while (k > w + l)
      {
        h++;
        w += l;                 /* previous table always l bits */

        /* compute minimum size table less than or equal to l bits */
        z = (z = g - w) > (unsigned int)l ? l : z;  /* upper limit on table size */
        if ((f = 1 << (j = k - w)) > a + 1)     /* try a k-w bit table */
        {                       /* too few codes for k-w bit table */
          f -= a + 1;           /* deduct codes from patterns left */
          xp = c + k;
          while (++j < z)       /* try smaller tables up to z bits */
          {
            if ((f <<= 1) <= *++xp)
              break;            /* enough codes to use up j bits */
            f -= *xp;           /* else deduct codes from patterns */
          }
        }
        z = 1 << j;             /* table entries for j-bit table */

        /* allocate and link in new table */

        osAllocMem((void**)&q,(z + 1)*sizeof(struct huft));

        if (q == (struct huft *)NULL)
        {
          if (h)
            huft_free(u[0]);
          return 3;             /* not enough memory */
        }
        hufts += z + 1;         /* track memory usage */
        *t = q + 1;             /* link to list for huft_free() */
        *(t = &(q->v.t)) = (struct huft *)NULL;
        u[h] = ++q;             /* table starts after link */

        /* connect to last table, if there is one */
        if (h)
        {
          x[h] = i;             /* save pattern for backing up */
          r.b = (uch)l;         /* bits to dump before this table */
          r.e = (uch)(16 + j);  /* bits in this table */
          r.v.t = q;            /* pointer to this table */
          j = i >> (w - l);     /* (get around Turbo C bug) */
          u[h-1][j] = r;        /* connect to last table */
        }
      }

      /* set up table entry in r */
      r.b = (uch)(k - w);
      if (p >= v + n)
        r.e = 99;               /* out of values--invalid code */
      else if (*p < s)
      {
        r.e = (uch)(*p < 256 ? 16 : 15);    /* 256 is end-of-block code */
        r.v.n = (ush)(*p);             /* simple code is just the value */
	p++;                           /* one compiler does not like *p++ */
      }
      else
      {
        r.e = (uch)e[*p - s];   /* non-simple--look up in lists */
        r.v.n = d[*p++ - s];
      }

      /* fill code-like entries with r */
      f = 1 << (k - w);
      for (j = i >> w; j < z; j += f)
        q[j] = r;

      /* backwards increment the k-bit code i */
      for (j = 1 << (k - 1); i & j; j >>= 1)
        i ^= j;
      i ^= j;

      /* backup over finished tables */
      while ((i & ((1 << w) - 1)) != x[h])
      {
        h--;                    /* don't need to update q */
        w -= l;
      }
    }
  }


  /* Return true (1) if we were given an incomplete table */
  return y != 0 && g != 1;
}



static int huft_free(t)
struct huft *t;         /* table to free */
/* Free the malloc'ed tables built by huft_build(), which makes a linked
   list of the tables it made, with the links in a dummy first entry of
   each table. */
{
  struct huft *p, *q;


  /* Go through linked list, freeing from the malloced (t[-1]) address. */
  p = t;
  while (p != (struct huft *)NULL)
  {
    q = (--p)->v.t;
    osFreeMem((char*)p);
    p = q;
  } 
  return 0;
}


static int inflate_codes(tl, td, bl, bd)
struct huft *tl, *td;   /* literal/length and distance decoder tables */
int bl, bd;             /* number of bits decoded by tl[] and td[] */
/* inflate (decompress) the codes in a deflated (compressed) block.
   Return an error code or zero if it all goes ok. */
{
  unsigned int e;  /* table entry flag/number of extra bits */
  unsigned int n, d;        /* length and index for copy */
  unsigned int w;           /* current window position */
  struct huft *t;       /* pointer to table entry */
  unsigned int ml, md;      /* masks for bl and bd bits */
  ulg b;       /* bit buffer */
  unsigned int k;  /* number of bits in bit buffer */


  /* make local copies of globals */
  b = bb;                       /* initialize bit buffer */
  k = bk;
  w = wp;                       /* initialize window position */

  /* inflate the coded data */
  ml = mask_bits[bl];           /* precompute masks for speed */
  md = mask_bits[bd];
  for (;;)                      /* do until end of block */
  {
    NEEDBITS((unsigned)bl)
    if ((e = (t = tl + ((unsigned)b & ml))->e) > 16)
      do {
        if (e == 99)
          return 1;
        DUMPBITS(t->b)
        e -= 16;
        NEEDBITS(e)
      } while ((e = (t = t->v.t + ((unsigned)b & mask_bits[e]))->e) > 16);
    DUMPBITS(t->b)
    if (e == 16)                /* then it's a literal */
    {
      slide[w++] = (uch)t->v.n;
      Tracevv((stderr, "%c", slide[w-1]));
      if (w == WSIZE)
      {
        flush_output(w);
        w = 0;
      }
    }
    else                        /* it's an EOB or a length */
    {
      /* exit if end of block */
      if (e == 15)
        break;

      /* get length of block to copy */
      NEEDBITS(e)
      n = t->v.n + ((unsigned)b & mask_bits[e]);
      DUMPBITS(e);

      /* decode distance of block to copy */
      NEEDBITS((unsigned)bd)
      if ((e = (t = td + ((unsigned)b & md))->e) > 16)
        do {
          if (e == 99)
            return 1;
          DUMPBITS(t->b)
          e -= 16;
          NEEDBITS(e)
        } while ((e = (t = t->v.t + ((unsigned)b & mask_bits[e]))->e) > 16);
      DUMPBITS(t->b)
      NEEDBITS(e)
      d = w - t->v.n - ((unsigned)b & mask_bits[e]);
      DUMPBITS(e)
      Tracevv((stderr,"\\[%d,%d]", w-d, n));

      /* do the copy */
      do {
        n -= (e = (e = WSIZE - ((d &= WSIZE-1) > w ? d : w)) > n ? n : e);
#if !defined(NOMEMCPY) && !defined(DEBUG)
        if (w - d >= e)         /* (this test assumes unsigned comparison) */
        {
          memcpy(slide + w, slide + d, e);
          w += e;
          d += e;
        }
        else                      /* do it slow to avoid memcpy() overlap */
#endif /* !NOMEMCPY */
          do {
            slide[w++] = slide[d++];
	    Tracevv((stderr, "%c", slide[w-1]));
          } while (--e);
        if (w == WSIZE)
        {
          flush_output(w);
          w = 0;
        }
      } while (n);
    }
  }


  /* restore the globals from the locals */
  wp = w;                       /* restore global window pointer */
  bb = b;                       /* restore global bit buffer */
  bk = k;

  /* done */
  return 0;
}



static int inflate_stored()
/* "decompress" an inflated type 0 (stored) block. */
{
  unsigned int n;           /* number of bytes in block */
  unsigned int w;           /* current window position */
  ulg b;       /* bit buffer */
  unsigned int k;  /* number of bits in bit buffer */


  /* make local copies of globals */
  b = bb;                       /* initialize bit buffer */
  k = bk;
  w = wp;                       /* initialize window position */


  /* go to byte boundary */
  n = k & 7;
  DUMPBITS(n);


  /* get the length and its complement */
  NEEDBITS(16)
  n = ((unsigned int)b & 0xffff);
  DUMPBITS(16)
  NEEDBITS(16)
  if (n != (unsigned int)((~b) & 0xffff))
    return 1;                   /* error in compressed data */
  DUMPBITS(16)


  /* read and output the compressed data */
  while (n--)
  {
    NEEDBITS(8)
    slide[w++] = (uch)b;
    if (w == WSIZE)
    {
      flush_output(w);
      w = 0;
    }
    DUMPBITS(8)
  }


  /* restore the globals from the locals */
  wp = w;                       /* restore global window pointer */
  bb = b;                       /* restore global bit buffer */
  bk = k;
  return 0;
}



static int inflate_fixed()
/* decompress an inflated type 1 (fixed Huffman codes) block.  We should
   either replace this with a custom decoder, or at least precompute the
   Huffman tables. */
{
  int i;                /* temporary variable */
  struct huft *tl;      /* literal/length code table */
  struct huft *td;      /* distance code table */
  int bl;               /* lookup bits for tl */
  int bd;               /* lookup bits for td */
  unsigned int l[288];      /* length list for huft_build */


  /* set up literal table */
  for (i = 0; i < 144; i++)
    l[i] = 8;
  for (; i < 256; i++)
    l[i] = 9;
  for (; i < 280; i++)
    l[i] = 7;
  for (; i < 288; i++)          /* make a complete, but wrong code set */
    l[i] = 8;
  bl = 7;
  if ((i = huft_build(l, 288, 257, cplens, cplext, &tl, &bl)) != 0)
    return i;


  /* set up distance table */
  for (i = 0; i < 30; i++)      /* make an incomplete code set */
    l[i] = 5;
  bd = 5;
  if ((i = huft_build(l, 30, 0, cpdist, cpdext, &td, &bd)) > 1)
  {
    huft_free(tl);
    return i;
  }


  /* decompress until an end-of-block code */
  if (inflate_codes(tl, td, bl, bd))
    return 1;


  /* free the decoding tables, return */
  huft_free(tl);
  huft_free(td);
  return 0;
}



static int inflate_dynamic()
/* decompress an inflated type 2 (dynamic Huffman codes) block. */
{
  int i;                /* temporary variables */
  unsigned int j;
  unsigned int l;           /* last length */
  unsigned int m;           /* mask for bit lengths table */
  unsigned int n;           /* number of lengths to get */
  struct huft *tl;      /* literal/length code table */
  struct huft *td;      /* distance code table */
  int bl;               /* lookup bits for tl */
  int bd;               /* lookup bits for td */
  unsigned int nb;          /* number of bit length codes */
  unsigned int nl;          /* number of literal/length codes */
  unsigned int nd;          /* number of distance codes */
#ifdef PKZIP_BUG_WORKAROUND
  unsigned int ll[288+32];  /* literal/length and distance code lengths */
#else
  unsigned int ll[286+30];  /* literal/length and distance code lengths */
#endif
  ulg b;       /* bit buffer */
  unsigned int k;  /* number of bits in bit buffer */


  /* make local bit buffer */
  b = bb;
  k = bk;


  /* read in table lengths */
  NEEDBITS(5)
  nl = 257 + ((unsigned int)b & 0x1f);      /* number of literal/length codes */
  DUMPBITS(5)
  NEEDBITS(5)
  nd = 1 + ((unsigned int)b & 0x1f);        /* number of distance codes */
  DUMPBITS(5)
  NEEDBITS(4)
  nb = 4 + ((unsigned int)b & 0xf);         /* number of bit length codes */
  DUMPBITS(4)
#ifdef PKZIP_BUG_WORKAROUND
  if (nl > 288 || nd > 32)
#else
  if (nl > 286 || nd > 30)
#endif
    return 1;                   /* bad lengths */


  /* read in bit-length-code lengths */
  for (j = 0; j < nb; j++)
  {
    NEEDBITS(3)
    ll[border[j]] = (unsigned int)b & 7;
    DUMPBITS(3)
  }
  for (; j < 19; j++)
    ll[border[j]] = 0;


  /* build decoding table for trees--single level, 7 bit lookup */
  bl = 7;
  if ((i = huft_build(ll, 19, 19, NULL, NULL, &tl, &bl)) != 0)
  {
    if (i == 1)
      huft_free(tl);
    return i;                   /* incomplete code set */
  }


  /* read in literal and distance code lengths */
  n = nl + nd;
  m = mask_bits[bl];
  i = l = 0;
  while ((unsigned int)i < n)
  {
    NEEDBITS((unsigned int)bl)
    j = (td = tl + ((unsigned int)b & m))->b;
    DUMPBITS(j)
    j = td->v.n;
    if (j < 16)                 /* length of code in bits (0..15) */
      ll[i++] = l = j;          /* save last length in l */
    else if (j == 16)           /* repeat last length 3 to 6 times */
    {
      NEEDBITS(2)
      j = 3 + ((unsigned int)b & 3);
      DUMPBITS(2)
      if ((unsigned int)i + j > n)
        return 1;
      while (j--)
        ll[i++] = l;
    }
    else if (j == 17)           /* 3 to 10 zero length codes */
    {
      NEEDBITS(3)
      j = 3 + ((unsigned int)b & 7);
      DUMPBITS(3)
      if ((unsigned int)i + j > n)
        return 1;
      while (j--)
        ll[i++] = 0;
      l = 0;
    }
    else                        /* j == 18: 11 to 138 zero length codes */
    {
      NEEDBITS(7)
      j = 11 + ((unsigned int)b & 0x7f);
      DUMPBITS(7)
      if ((unsigned int)i + j > n)
        return 1;
      while (j--)
        ll[i++] = 0;
      l = 0;
    }
  }


  /* free decoding table for trees */
  huft_free(tl);


  /* restore the global bit buffer */
  bb = b;
  bk = k;


  /* build the decoding tables for literal/length and distance codes */
  bl = lbits;
  if ((i = huft_build(ll, nl, 257, cplens, cplext, &tl, &bl)) != 0)
  {
    if (i == 1) {
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,"NVRM: dload, incomplete literal tree");

      huft_free(tl);
    }
    return i;                   /* incomplete code set */
  }
  bd = dbits;
  if ((i = huft_build(ll + nl, nd, 0, cpdist, cpdext, &td, &bd)) != 0)
  {
    if (i == 1) {
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,"NVRM: dload, incomplete distance tree");

#ifdef PKZIP_BUG_WORKAROUND
      i = 0;
    }
#else
      huft_free(td);
    }
    huft_free(tl);
    return i;                   /* incomplete code set */
#endif
  }


  /* decompress until an end-of-block code */
  if (inflate_codes(tl, td, bl, bd))
    return 1;


  /* free the decoding tables, return */
  huft_free(tl);
  huft_free(td);
  return 0;
}



static int inflate_block(e)
int *e;                 /* last block flag */
/* decompress an inflated block */
{
  unsigned int t;           /* block type */
  ulg b;       /* bit buffer */
  unsigned int k;  /* number of bits in bit buffer */


  /* make local bit buffer */
  b = bb;
  k = bk;


  /* read in last block bit */
  NEEDBITS(1)
  *e = (int)b & 1;
  DUMPBITS(1)


  /* read in block type */
  NEEDBITS(2)
  t = (unsigned int)b & 3;
  DUMPBITS(2)


  /* restore the global bit buffer */
  bb = b;
  bk = k;


  /* inflate that block type */
  if (t == 2)
    return inflate_dynamic();
  if (t == 0)
    return inflate_stored();
  if (t == 1)
    return inflate_fixed();


  /* bad block type */
  return 2;
}


/* nVidia addition: give pointers to input and known-large-enough output buffers. */

RM_STATUS DldInflate(NvU8 *inBuffer, NvU8 *outBuffer)
/* decompress an inflated entry */
{
  int e;                /* last block flag */
  int r;                /* result code */
  unsigned int h;           /* maximum struct huft's malloc'ed */

  inptr  = 0;
  outptr = 0;

  inbuf  = inBuffer;
  outbuf = outBuffer;

  /* initialize window, bit buffer */
  wp = 0;
  bk = 0;
  bb = 0;


  /* decompress until the last block */
  h = 0;
  do {
    hufts = 0;
    if ((r = inflate_block(&e)) != 0)
      return RM_ERROR;
    if (hufts > h)
      h = hufts;
  } while (!e);

  /* Undo too much lookahead. The next read will be byte aligned so we
   * can discard unused bits in the last meaningful byte.
   */
  while (bk >= 8) {
    bk -= 8;
    inptr--;
  }

  /* flush out slide */
  flush_output(wp);


  /* return success */

  return RM_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\common\src\nv\dload.c ===
/*****************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2001 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2001  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
|*****************************************************************************|
|*                                                                           *|
|* Module: dload.c                                                           *|
|*    These are the OS-specific bits of implementing dynamic loading of      *|
|* driver code.  Be that from file, ROM/BIOS, etc.                           *|
|*                                                                           *|
|*****************************************************************************|
|*                                                                           *|
|* History:                                                                  *|
|*       Ken Adams (kadams)     02/2001 - wrote it based upon investigatory  *|
|*                                        code from Todd Poynter.            *|
|*                                                                           *|
\*****************************************************************************/

#include <nv_ref.h>
#include <nvrm.h>
#include <os.h>

#include <dload.h>
#include <nvdload.h>


#define MakePtr(cast, ptr, addValue) (cast)((unsigned)(ptr) + (addValue))

#define BAIL(r,s,p)  {     \
   ret = (r);              \
   DBG_PRINT_STRING(p ,s); \
   DBG_BREAKPOINT();       \
   goto cleanup;           \
}


RM_STATUS initDload(PHWINFO pDev)
{
#if 0
	PRMINFO pRmInfo = (PRMINFO) pDev->pRmInfo;
	// The assumption is that the RMINFO global will be
	// filled to zero when we start.  When and if we ever
	// need to do anything more than zero'ing out structs
	// add a flag and test for it... or some such thing.
	pRmInfo->Dload.modules    = 0;
	pRmInfo->Dload.modulesSz  = 0; // How many NV_Image pointers we have allocated.
#endif

    return RM_OK;
}


//-----------------------------------------------------------------------------
// DldLoadModule
// 
// Given a pointer to the binary image as it reside(s,d) in BIOS/ROM or a file,
// perform the necessary steps to bring it in, make it executable, etc. and
// then wire it up.  The original image pointer given will not be held 
// so _that_ memory can be freed as necessary by the caller.
//-----------------------------------------------------------------------------

RM_STATUS DldLoadModule(PHWINFO pDev, NvU8 *pImage)
{
	
	PRMINFO     pRmInfo = (PRMINFO) pDev->pRmInfo;
	RM_STATUS   ret     = RM_OK;
	PDLD_MODULE pMod;
	unsigned    int checkSize, modIdx;
	NvU8        *pRawImg = 0;

	
	for ( modIdx = 0; modIdx < pRmInfo->Dload.modulesSz && pRmInfo->Dload.modules[modIdx] ; modIdx++ ) {;;;;}
	
	if ( RM_OK != osAllocMem((VOID**)&pMod, sizeof(DLD_MODULE) ) ) 
		BAIL(RM_ERROR,"NVRM: oom in DldLoadModule\n",DEBUGLEVEL_ERRORS);

	pMod->refCnt = 0;
	pMod->osHook = 0;

	// The set of all loaded images is managed as a dynamic array of pointers.
	// Zero pointers are by definition unused, and we just attempt to realloc
	// and copy the existing contents if the array needs to grow.  Simple simple.
	// XXX Some sort of locking necessary here

	if ( modIdx == pRmInfo->Dload.modulesSz )  {
		unsigned int j;
		void *p;
		
		// Attempt to grow the number of NV_Image pointers we're holding onto
		// by 4, and then copy the existing ones over...

		if ( RM_OK != osAllocMem( &p, sizeof( PDLD_MODULE ) * 4 ) ) 
			BAIL(RM_ERROR,"NVRM: can't grow PDLD_MODULE array\n",DEBUGLEVEL_ERRORS);
		
		((PDLD_MODULE*)p)[pRmInfo->Dload.modulesSz] = pMod;
		
		for ( j = 1; j < 4 ; j++ )  ((PDLD_MODULE*)p)[j] = 0;
		
		for ( j = 0; j < pRmInfo->Dload.modulesSz ; j++ ) {
			((PDLD_MODULE*)p)[j] =  pRmInfo->Dload.modules[j];
		}
		
		if ( pRmInfo->Dload.modules ) 
			osFreeMem( pRmInfo->Dload.modules );

		pRmInfo->Dload.modules = (PDLD_MODULE*)p;
		pRmInfo->Dload.modulesSz += 4;
		
	} 
	else {
		pRmInfo->Dload.modules[modIdx] = pMod;
	}
	
	// Wire up the pMod with the raw image offsets, etc.
	// The OS-layer must copy out anything it needs such that
	// after linking there will not be any references to this
	// raw image.  Again, the caller can free everything about
	// pImage... pMod however will stay 'round.  So the OS-layer
	// linking code can attach anything it needs via that extra
	// pointer at the end.
	
	pMod->header     = (PNV_ImageHeader)       pImage;

        // See if this is a compressed image.  If so, 'inflate' it here.
        
        if ( pMod->header->compressedSize ) {

                
                if ( RM_OK != osAllocMem((VOID **)&pRawImg, pMod->header->imageSize - sizeof(NV_ImageHeader) ) ) {
                        BAIL(RM_ERROR,"NVRM: oom in DldLoadModule\n",DEBUGLEVEL_ERRORS);
                }

                if ( RM_OK != DldInflate((NvU8*)(pMod->header + 1),pRawImg) ) {
                        BAIL(RM_ERROR,"NVRM: error in DldInflate\n",DEBUGLEVEL_ERRORS);
                }

                pMod->secTable   = (PSectionInfoEntry)    (pRawImg);

        }
        else {
                pMod->secTable   = (PSectionInfoEntry)    (pMod->header     + 1);
        }

        // Refer to 'secTable' above for start of image addressing...

        pMod->relocTable = (PRelocationInfoEntry) (pMod->secTable   + pMod->header->nSections);
        pMod->symTable   = (PSymbolTableEntry)    (pMod->relocTable + pMod->header->nRelocs);
        pMod->dataBuffer = (NvU8*)                (pMod->symTable   + pMod->header->nSymbols);
        pMod->codeBuffer = (NvU8*)                ((NvU8*)pMod->dataBuffer + pMod->header->dataSize);
        pMod->bssBuffer  = 0;
        pMod->footer     = (PNV_ImageFooter)      (pMod->codeBuffer + pMod->header->codeSize);


	checkSize = (unsigned int) ((NvU8*) pMod->footer - (NvU8*) pMod->secTable) + sizeof(NV_ImageFooter);


	DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,"NVRM: header.magicNumber = ", pMod->header->magicNumber);
	DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,"NVRM: footer.magicNumber = ", pMod->footer->magicNumber); 
	DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,"NVRM: header.imageSize   = ", pMod->header->imageSize);
	DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,"NVRM: header.nSections   = ", pMod->header->nSections);
	DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,"NVRM: header.nRelocs     = ", pMod->header->nRelocs);
	DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,"NVRM: header.nSymbols    = ", pMod->header->nSymbols);
	DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,"NVRM: header.dataSize    = ", pMod->header->dataSize);
	DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,"NVRM: header.codeSize    = ", pMod->header->codeSize);
	DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,"NVRM: header.bssSize     = ", pMod->header->bssSize);
	DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,"NVRM: checkSize          = ", checkSize);	


	// Reject egregiously wrong images here.

	if ( (pMod->header->magicNumber != NV_DLOAD_HEADER_MAGIC) 
	     || (pMod->footer->magicNumber != NV_DLOAD_FOOTER_MAGIC) 
	     || (pMod->header->imageSize != (checkSize + sizeof(NV_ImageHeader)) ) ) 
		BAIL(RM_ERROR,"NVRM: bad image",DEBUGLEVEL_ERRORS);

	

	// Now ask the OS-layer to make the image executable by putting it
	// into executable pages, wiring up anything gnarly necessary, etc.

	if ( RM_OK != osDldLinkImg((VOID*)pMod) ) 
		BAIL(RM_ERROR,"NVRM: link error",DEBUGLEVEL_ERRORS);

	pMod->refCnt = 1;

#if 0
	// This is a placeholder for something other than just a "plug-in-the-fn-table" link step.
	{
#define NV_DLOAD_QUERY_IMAGE_LAYER

		int layer;
		void ** nvImgIface;
		typedef RM_STATUS (PDLD_MODULEQueryFn*)(int, void*);

		nvImgIface = (void**)osDloadFindImgSymbol(pMod, NV_DLOAD_IMAGE_ENTRY);
		if ( !nvImgIface ) BAIL(RM_ERROR,"NVRM: can't find image entry point table",DEBUGLEVEL_ERRORS);

		pQueryFn = (PDLD_MODULEQueryFn)nvImgIface[0];
		if ( !pQueryFn ) BAIL(RM_ERROR,"NVRM: can't find image query fn",DEBUGLEVEL_ERRORS);

		// Here we go.  Not much we can do now except assume this is going to work...
		ret = pQueryFn(NV_DLOAD_QUERY_IMAGE_LAYER,(void*)&layer);
		if ( ret != RM_OK ) BAIL(RM_ERROR,"NVRM: can't get image layer",DEBUGLEVEL_ERRORS);
		
		switch (layer) {
			case NV_CFGEX_DLOAD_HAL_LAYER:
			break;

			// Some point later we may want to extend this beyond the HAL?
			case NV_CFGEX_DLOAD_RM_LAYER:
			default:
				BAIL(RM_ERROR,"NVRM: bad image layer",DEBUGLEVEL_ERRORS);
		}
		
	}
#endif
    // Try to find the interface table.
    // Spew what we find.  Wire it in.
    {
	    VOID **iface;

	    iface = (VOID *)DldFindMemOffset(pMod,"_halimg"); // Hack name (see e.g. resman/module/nv20/halimg_nv20.c)

	    if ( ! iface ) {
		    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,"NVRM: can't find iface block");
	    } 
	    else {
		    DBG_PRINT_STRING_PTR(DEBUGLEVEL_TRACEINFO,"NVRM: hal iface block :",iface);
		    DBG_PRINT_STRING_PTR(DEBUGLEVEL_TRACEINFO,"NVRM:   fntable   :",(unsigned*)(iface[0]));
		    DBG_PRINT_STRING_PTR(DEBUGLEVEL_TRACEINFO,"NVRM:   #clasdesc :",(unsigned*)(iface[1]));
		    DBG_PRINT_STRING_PTR(DEBUGLEVEL_TRACEINFO,"NVRM:    clasdesc :",(unsigned*)(iface[2]));
		    DBG_PRINT_STRING_PTR(DEBUGLEVEL_TRACEINFO,"NVRM:    engdesc  :",(unsigned*)(iface[3]));
	    }

	    // Finish the deed.
	    pDev->pHalFuncs = (PHALFUNCS)iface[0];
    }



    cleanup:

        if ( pRawImg ) {

                osFreeMem((void*)pRawImg);

                pRawImg = 0;
        }

	if ( ret != RM_OK ) {

		if ( pMod ) {
		    
			if ( pMod->refCnt ) {
				(void)osDldUnlinkImg((VOID*)pMod);
			}
			
			if ( pRmInfo->Dload.modules[modIdx] == pMod ) 
				pRmInfo->Dload.modules[modIdx] = 0;
			
			osFreeMem(pMod);
		}
		
	}
    
	return ret;
}





// Given a symbol name, find it's address after linking.

NV_UINTPTR_T DldFindMemOffset(PDLD_MODULE pMod, char *symname) 
{
	unsigned i = 0;
	NvU32 nSymbols = pMod->header->nSymbols;

	// find the symbol with this index
	for (i = 0; i < nSymbols; i++)
	{
		if ( !osStringCompare((const char *)pMod->symTable[i].name,symname) ) {
			return DldGetMemOffset(pMod,pMod->symTable[i].symIndex);
		}
	}

	return ~(NV_UINTPTR_T)0;
}


NV_UINTPTR_T DldGetImageOffset(PDLD_MODULE pMod, unsigned symIndex)
{
	return DldGetMemOffset(pMod,symIndex) - (NV_UINTPTR_T)pMod->dataBuffer;
}


NvU16 DldGetSymbolSection(PDLD_MODULE pMod, unsigned symIndex)
{
	NvU16 j, nSections = pMod->header->nSections;
	NvU32 i, nSymbols  = pMod->header->nSymbols;
	
	// find the symbol with this index
	for (i = 0; i < nSymbols; i++)
	{
		if (pMod->symTable[i].symIndex == symIndex)
		{
			// find the section with this section number and return the memOffset
			// printf("searching for %s's memoffset\n",nv_img.symTable[i].name);
			for (j = 0; j < nSections; j++)
			{
				if(pMod->secTable[j].secNumber == pMod->symTable[i].secNumber)
				{
					return j;
				}
			}
		}
	}

	return ~(NvU16)0;
}


NV_UINTPTR_T DldGetSectionMemOffset(PDLD_MODULE pMod, unsigned secNumber)
{
	NvU16 i, nSections = pMod->header->nSections;

	for ( i=0; i < nSections; i++ ) {
		if ( pMod->secTable[i].secNumber == secNumber ) {
			return (unsigned) pMod->secTable[i].memOffset;
		}
	}
	
	return ~(NV_UINTPTR_T)0;
}


NV_UINTPTR_T DldGetMemOffset(PDLD_MODULE pMod, unsigned symIndex)
{
	NvU16 j, nSections = pMod->header->nSections;
	NvU32 i, nSymbols = pMod->header->nSymbols;
	
	// find the symbol with this index
	for (i = 0; i < nSymbols; i++)
	{
		if (pMod->symTable[i].symIndex == symIndex)
		{
			// find the section with this section number and return the memOffset
			for (j = 0; j < nSections; j++)
			{
				if(pMod->secTable[j].secNumber == pMod->symTable[i].secNumber)
				{
					return((NV_UINTPTR_T) pMod->secTable[j].memOffset + pMod->symTable[i].value);
				}
			}
		}
	}
	
	// The image should never have made it this far...
	// Our images are fully self contained and make no
	// external references...

	DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS,"NVRM: Error: getMemOffset(...) symIndex was not found! ", symIndex);
	
	DBG_BREAKPOINT();
	return ~(NV_UINTPTR_T)0;
}


//------------------------------------------------------------------
// void printImgInfo()
//------------------------------------------------------------------
void DldPrintImgInfo(PDLD_MODULE pMod)
{
	DldPrintSectionInfo(pMod);
	DldPrintRelocationInfo(pMod);
	DldPrintSymbolTableInfo(pMod);
}


//------------------------------------------------------------------
// void printSectionInfo(unsigned nSections)
//------------------------------------------------------------------
void DldPrintSectionInfo(PDLD_MODULE pMod)
{
	unsigned int i = 0;

	DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,"NVRM: PRINTING pMod->secTable ----------------------------");
	for (i = 0; i < pMod->header->nSections; i++)
	{
		DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,"secNumber:      ", pMod->secTable[i].secNumber);
		DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,"type:           ", pMod->secTable[i].type);
		DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,"dataSize:       ", pMod->secTable[i].dataSize);
		DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,"numRelocs:      ", pMod->secTable[i].numRelocs);
		DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,"memOffset:      ", pMod->secTable[i].memOffset);

	}
}


//------------------------------------------------------------------
// void printRelocationInfo(unsigned nRelocs)
//------------------------------------------------------------------
void DldPrintRelocationInfo(PDLD_MODULE pMod)
{
	unsigned int i = 0;

	DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,"NVRM: PRINTING pMod->relocTable --------------------------");
	for (i = 0; i < pMod->header->nRelocs; i++)
	{
		DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,"address:        ", pMod->relocTable[i].address);
		DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,"symIndex:       ", pMod->relocTable[i].symIndex);
		DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,"secNumber:      ", pMod->relocTable[i].secNumber);
	}
}


//------------------------------------------------------------------
// void printSymbolTableInfo(unsigned nSymbols)
//------------------------------------------------------------------
void DldPrintSymbolTableInfo(PDLD_MODULE pMod)
{
	unsigned int i = 0;

	DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,"NVRM: PRINTING pMod->symTable ----------------------------");
	for (i = 0; i < pMod->header->nSymbols; i++)
	{
		DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,"symIndex:       ", pMod->symTable[i].symIndex);
		DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,"name:           ");
		DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,pMod->symTable[i].name);
		DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,"secNumber:      ", pMod->symTable[i].secNumber);

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\common\src\nv\client.c ===
/******************************************************************************
*
*   File:  client.c
*
*   Description:
*       This file contains the functions necessary to manage NV Resource
*   Manager client information.
*
*
*   THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
*   NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
*   IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
*
******************************************************************************/

// TO DO: ClientInstance is a global!!!!  Can we rely on it's being SMP safe??
//        i.e. can two IOCTLs be processing simultaneously?

// This file is chip independent AND OS independent

#include <nvrm.h>
#include <client.h>
#include <nvos.h>
#include <nvarch.h>

//
// Return a "unique" client handle by incrementing our clientHandle variable.
// We cannot let this freely range over all possible values, since it would
// eventually match an already existing handle (looping after 1MB hopefully
// will be enough).
//
static U032 clientHandle = 0xc1d00000;

RM_STATUS CliAddClient(
    U032 *phClient,
    U032 hClass
)
{
    U032 i;

    // verify class is a root object
    switch (hClass)
    {
        case NV01_ROOT:
        case NV01_ROOT_USER:
            break;

        default:
            return RM_ERR_BAD_CLASS;

    }

    // register the client
    for (i = 1; i < NUM_CLIENTS; i++)
    {
        if ( ! clientInfo[i].InUse)
        {
            // create a unique client handle
            clientHandle = ((clientHandle + 1) % 0x100000) ? (clientHandle + 1) : 0xc1d00000;
            // mark it busy asap
            clientInfo[i].InUse         = TRUE;

            // initialize the client
            clientInfo[i].Handle           = clientHandle;
            clientInfo[i].Class            = hClass;
            clientInfo[i].ProcID           = i;
            clientInfo[i].ProcContext      = 0;
            clientInfo[i].FifoCount        = 0;
            clientInfo[i].CliDmaList       = NULL;
            clientInfo[i].CliMemoryList    = NULL;
            clientInfo[i].CliEventList     = NULL;
            clientInfo[i].CliHeapOwnerList = NULL;    //added by Chuck Moidel

            // set the client instance and return the client handle
            CliSetClientInstance(i);
            *phClient = clientInfo[i].Handle;

            return RM_OK;
        }
    }

    return RM_ERR_INSUFFICIENT_RESOURCES;

} // end of CliAddClient()

BOOL CliDelClient()
{
    clientInfo[ClientInstance].InUse = FALSE;

    return TRUE;

} // end of CliDelClient()

BOOL CliGetClientHandle(
    U032 *phClient
)
{
    if (clientInfo[ClientInstance].InUse == TRUE)
    {
        *phClient = clientInfo[ClientInstance].Handle;
        return TRUE;
    }

    return FALSE;

} // end of CliGetClientHandle()

BOOL CliGetClientIndex(
    U032 hClient,
    U032 *pIndex
)
{
    U032 i;

    for (i = 1; i < NUM_CLIENTS; i++)
    {
        if (clientInfo[i].InUse && clientInfo[i].Handle == hClient)
        {
            *pIndex = i;
            return TRUE;
        }
    }

    return FALSE;

} // end of CliGetClientIndex()

BOOL CliSetClientContext(
    U032 hClient
)
{
    U032 i;

    for (i = 1; i < NUM_CLIENTS; i++)
    {
        if (clientInfo[i].InUse && clientInfo[i].Handle == hClient)
        {
            ClientInstance = i;
            return TRUE;
        }
    }

    return FALSE;

} // end of CliSetClientContext()

BOOL CliSetClientInstance(
    U032 instance
)
{
    if (instance < NUM_CLIENTS)
    {
        ClientInstance = instance;
        return TRUE;
    }

    return TRUE;

} // end of CliSetClientInstance()

BOOL CliSetClientAppHandle(
    U032  hClient,
    void *appHandle
)
{
    U032 i;

    for (i = 1; i < NUM_CLIENTS; i++)
    {
        if (clientInfo[i].InUse && clientInfo[i].Handle == hClient)
        {
            clientInfo[i].AppHandle = appHandle;
            return TRUE;
        }
    }

    return FALSE;

} // end of CliSetClientAppHandle()

BOOL CliGetClientAppHandle(
    U032   hClient,
    void **appHandle
)
{
    U032 i;

    for (i = 1; i < NUM_CLIENTS; i++)
    {
        if (clientInfo[i].InUse && clientInfo[i].Handle == hClient)
        {
            *appHandle = clientInfo[i].AppHandle;
            return TRUE;
        }
    }

    return FALSE;

} // end of CliGetClientAppHandle()


RM_STATUS CliAddDevice(
    U032 hClient,
    U032 hDevice,
    U032 hClass
)
{
    U032 client, device;

    // validate client
    if (!CliGetClientHandle(&client) || client != hClient)
    {
        return RM_ERR_BAD_OBJECT_PARENT;
    }

    // validate device
    if (!CliIsUniqueHandle(hDevice, FALSE))
    {
        return RM_ERR_BAD_OBJECT_HANDLE;
    }

    // validate class
    if (!CliGetPhysicalDevice(hClass, &device))
    {
        return RM_ERR_BAD_CLASS;
    }

    // make sure we have a device list
    if ( ! clientInfo[ClientInstance].CliDeviceList)
        if ( ! CliMakeDeviceList(ClientInstance, NUM_DEVICES, &clientInfo[ClientInstance].CliDeviceList))
            goto failed;

    // initialize the device
    if ( ! clientInfo[ClientInstance].CliDeviceList[device].InUse)
    {
        clientInfo[ClientInstance].CliDeviceList[device].InUse          = TRUE;
        clientInfo[ClientInstance].CliDeviceList[device].Handle         = hDevice;
        clientInfo[ClientInstance].CliDeviceList[device].Client         = hClient;
        clientInfo[ClientInstance].CliDeviceList[device].Class          = hClass;
        clientInfo[ClientInstance].CliDeviceList[device].DevMemoryList  = NULL;
        clientInfo[ClientInstance].CliDeviceList[device].AppHandle      = NULL;
        clientInfo[ClientInstance].CliDeviceList[device].DevFifoList    = NULL;
        return RM_OK;
    }

 failed:
    return RM_ERR_INSUFFICIENT_RESOURCES;

} // end of CliAddDevice()


BOOL CliDelDevice(
    U032 hDevice
)
{
    PCLI_DEVICE_INFO pDevice;

    if (CliGetDeviceInfo(hDevice, &pDevice))
    {
        // delete the dynamically allocated device fifo list
        if (pDevice->DevFifoList)
        {
            osFreeMem(pDevice->DevFifoList);
            pDevice->DevFifoList = NULL;
        }

        // mark the device as unused
        pDevice->InUse = FALSE;
        return TRUE;
    }

    return FALSE;

} // end of CliDelDevice()


// allocate a single client's device info
BOOL CliMakeDeviceList(
    U032              client_instance,
    U032              num_devices,
    PCLI_DEVICE_INFO *ppDeviceList
)
{
    PCLI_DEVICE_INFO pdevice;
	
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: make new device list\n");

    if (RM_OK != osAllocMem((VOID **)ppDeviceList, sizeof(CLI_DEVICE_INFO) * num_devices))
        return FALSE;

    for (pdevice = *ppDeviceList; pdevice < *ppDeviceList + num_devices; pdevice++)
    {
        pdevice->InUse       = FALSE;
        pdevice->AppID       = client_instance;
        pdevice->AppHandle   = (void *) 0;
        pdevice->DevID       = (U032)(pdevice - *ppDeviceList);
        pdevice->DevFifoList = NULL;
    }

    return TRUE;
}


BOOL CliGetDeviceInfo(
    U032 hDevice,
    PCLI_DEVICE_INFO *ppDeviceInfo
)
{
    PCLI_DEVICE_INFO deviceList;
    U032 i;

    if ((deviceList = CliGetDeviceList()) != NULL)
    {
        for (i = 0; i < NUM_DEVICES; i++)
        {
            if (deviceList[i].InUse && deviceList[i].Handle == hDevice)
            {
                *ppDeviceInfo = &deviceList[i];
                return TRUE;
            }
        }
    }

    return FALSE;

} // end of CliGetDeviceInfo()

PCLI_DEVICE_INFO CliGetDeviceList()
{
    return clientInfo[ClientInstance].CliDeviceList;

} // end of CliGetDeviceList()

BOOL CliGetDeviceHandle(
    U032 hFifo,
    U032 *phDevice
)
{
    PCLI_DEVICE_INFO deviceList;
    U032 i, j;

    // get the device handle based on one of its fifo handles
    if ((deviceList = CliGetDeviceList()) != NULL)
    {
        for (i = 0; i < NUM_DEVICES; i++)
        {
            if (deviceList[i].InUse && deviceList[i].DevFifoList)
            {
                for (j = 0; j < MAX_FIFOS; j++)
                {
                    if (deviceList[i].DevFifoList[j].InUse &&
                        (deviceList[i].DevFifoList[j].Handle == hFifo))
                    {
                        *phDevice = deviceList[i].Handle;
                        return TRUE;
                    }
                }
            }
        }
    }

    return FALSE;
}

BOOL CliSetDeviceContext(
    U032 hDevice,
    PHWINFO* ppDev
)
{
    PCLI_DEVICE_INFO pDevice;

    if (CliGetDeviceInfo(hDevice, &pDevice))
    {
        // For NT there is no global DeviceInstance variable.
        U032 deviceInstance;

        if (CliGetPhysicalDevice(pDevice->Class, &deviceInstance))
        {
            *ppDev = NvDBPtr_Table[deviceInstance];
            osEnsureDeviceEnabled((PHWINFO)*ppDev);
            return TRUE;
        }
    }

    return FALSE;

} // end of CliSetDeviceContext()

BOOL CliSetDeviceAppHandle(
    U032  hDevice,
    void *appHandle
)
{
    PCLI_DEVICE_INFO pDevice;

    if (CliGetDeviceInfo(hDevice, &pDevice))
    {
        pDevice->AppHandle = appHandle;
        return TRUE;
    }

    return FALSE;

} // end of CliSetDeviceAppHandle()

BOOL CliGetDeviceAppHandle(
    U032   hDevice,
    void **appHandle
)
{
    PCLI_DEVICE_INFO pDevice;

    if (CliGetDeviceInfo(hDevice, &pDevice))
    {
        *appHandle = pDevice->AppHandle;
        return TRUE;
    }

    return FALSE;

} // end of CliSetDeviceAppHandle()


RM_STATUS CliAddDeviceFifo(
    PHWINFO pDev,
    U032 hDevice,
    U032 hFifo,
    U032 hClass,
    U032 hErrorCtx,
    U032 hDataCtx,
    U032 offset,
    U032 flags,
    U032 chID,
    VOID* pChannel
)
{
    PCLI_DEVICE_INFO pDevice;

    // validate device
    if (!CliGetDeviceInfo(hDevice, &pDevice))
    {
        return RM_ERR_BAD_OBJECT_PARENT;
    }

    // validate fifo
    if ( ! CliIsUniqueHandle(hFifo, FALSE))
    {
        return RM_ERR_BAD_OBJECT_HANDLE;
    }

    // make sure we have a fifo list
    // allocate MAX_FIFOS worth because some of the code in here walks the
    //     list without having access to NUM_FIFOS for a particular card.
    //     (NUM_FIFOS is a macro defined in terms of pDev)
    if ( ! pDevice->DevFifoList)
        if ( ! CliMakeDeviceFifoList(ClientInstance,
                                     pDevice->DevID,
                                     MAX_FIFOS,
                                     &pDevice->DevFifoList))
            return RM_ERR_INSUFFICIENT_RESOURCES;

    // add fifo info to the given device's fifo
    if ( ! pDevice->DevFifoList[chID].InUse)
    {
        pDevice->DevFifoList[chID].Handle           = hFifo;
        pDevice->DevFifoList[chID].Device           = hDevice;
        pDevice->DevFifoList[chID].Class            = hClass;
        pDevice->DevFifoList[chID].ErrorDmaContext  = hErrorCtx;
        pDevice->DevFifoList[chID].DataDmaContext   = hDataCtx;
        pDevice->DevFifoList[chID].Selector         = 0;
        pDevice->DevFifoList[chID].Flat             = pChannel;
        pDevice->DevFifoList[chID].FifoPtr          = &pDev->DBfifoTable[chID];
        pDevice->DevFifoList[chID].heventWait       = 0;
        pDevice->DevFifoList[chID].hwndNotify       = 0;
        pDevice->DevFifoList[chID].hwndError        = 0;
        pDevice->DevFifoList[chID].msgNotify        = 0;
        pDevice->DevFifoList[chID].msgError         = 0;
        pDevice->DevFifoList[chID].lpSysCallback    = 0;
        pDevice->DevFifoList[chID].eventNotify      = 0;

        pDevice->DevFifoList[chID].InUse            = TRUE;
        return RM_OK;
    }

    return RM_ERR_INSUFFICIENT_RESOURCES;

} // end of CliAddDeviceFifo()

BOOL CliDelDeviceFifo(
    U032 hDevice,
    U032 hFifo
)
{
    PCLI_FIFO_INFO pFifo;

    if (CliGetDeviceFifoInfo(hDevice, hFifo, &pFifo))
    {
        pFifo->InUse = FALSE;
        return TRUE;
    }

    return FALSE;

} // end of CliDelDeviceFifo()

// allocate a single device's fifo info

BOOL CliMakeDeviceFifoList(
    U032              client_instance,
    U032              device_instance,
    U032              num_fifos,
    PCLI_FIFO_INFO   *ppFifoList
)
{
    PCLI_FIFO_INFO pfifo;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: make new fifo list\n");

    if (RM_OK != osAllocMem((VOID **)ppFifoList, sizeof(CLI_FIFO_INFO) * num_fifos))
        return FALSE;

    for (pfifo = *ppFifoList; pfifo < *ppFifoList + num_fifos; pfifo++)
    {
        pfifo->InUse = FALSE;
        pfifo->AppID = client_instance;
        pfifo->AppHandle = (void *) 0;
        pfifo->DevID = device_instance;
        pfifo->ChID = (U032)(pfifo - *ppFifoList);

        pfifo->Selector = 0;
        pfifo->Handle = 0;
        pfifo->Device = 0;
        pfifo->Class = 0;
        pfifo->ErrorDmaContext = 0;
        pfifo->DataDmaContext = 0;
        pfifo->FifoPtr = 0;
        pfifo->Flat = 0;
        pfifo->heventWait = 0;
        pfifo->hwndNotify = 0;
        pfifo->hwndError = 0;
        pfifo->msgNotify = 0;
        pfifo->msgError = 0;
        pfifo->lpSysCallback = 0;
        pfifo->eventNotify = 0;
        pfifo->pDmaObject = 0;
    }

    return TRUE;
}

BOOL CliGetDeviceFifoInfo(
    U032 hDevice,
    U032 hFifo,
    PCLI_FIFO_INFO *ppFifoInfo
)
{
    PCLI_FIFO_INFO fifoList;
    U032 i;

    if (CliGetDeviceFifoList(hDevice, &fifoList) && fifoList)
    {
        for (i = 0; i < MAX_FIFOS; i++)
        {
            if (fifoList[i].InUse && (fifoList[i].Handle == hFifo))
            {
                *ppFifoInfo = &fifoList[i];
                return TRUE;
            }
        }
    }

    return FALSE;

} // end of CliGetDeviceFifoInfo()


// CliGetDeviceFifoList() could return a NULL list on TRUE
BOOL CliGetDeviceFifoList(
    U032 hDevice,
    PCLI_FIFO_INFO *pFifoList
)
{
    PCLI_DEVICE_INFO pDevice;

    if (CliGetDeviceInfo(hDevice, &pDevice))
    {
        *pFifoList = pDevice->DevFifoList;
        return TRUE;
    }

    return FALSE;

} // end of CliGetDeviceFifoList()

RM_STATUS CliAddDeviceMemory(
    U032 hDevice,
    U032 hMemory,
    U032 hClass,
    VOID *address,
    U032 length,
    U032 instance,
    U032 heapOwner,
    U032 version      //see CLI_MEMORY_INFO definition for more info on version  -C.Moidel
)
{
    PCLI_DEVICE_INFO pDevice;
    PCLI_MEMORY_INFO pMemory;

    // validate client
    if (!CliGetDeviceInfo(hDevice, &pDevice))
    {
        return RM_ERR_BAD_OBJECT_PARENT;
    }

    // validate device
    if (!CliIsUniqueHandle(hMemory, FALSE))
    {
        return RM_ERR_BAD_OBJECT_HANDLE;
    }

    // validate class
    switch (hClass)
    {
        case NV01_MEMORY_LOCAL_PRIVILEGED:
        case NV01_MEMORY_LOCAL_USER:
            break;

        default:
            return RM_ERR_BAD_CLASS;

    }

    //TODO: Validate HeapOwner based on version     -C.Moidel

    // allocate a new memory info struct and add to the device
    if (RM_SUCCESS(osAllocMem((void **) &pMemory, sizeof(CLI_MEMORY_INFO))))
    {
        // link in the new device memory mapping
        pMemory->Next = pDevice->DevMemoryList;
        pMemory->Prev = NULL;
        pDevice->DevMemoryList = pMemory;
        if (pMemory->Next)
        {
            pMemory->Next->Prev = pMemory;
        }

        // initialize the device
        pMemory->Handle     = hMemory;
        pMemory->Parent     = hDevice;
        pMemory->Class      = hClass;
        pMemory->Address    = address;
        pMemory->Length     = length;
        pMemory->Instance   = instance;
        pMemory->HeapOwner  = heapOwner;
        pMemory->version    = version;
        return RM_OK;
    }

    return RM_ERR_INSUFFICIENT_RESOURCES;

} // end of CliAddDeviceMemory()

BOOL CliDelDeviceMemory(
    U032 hDevice,
    U032 hMemory
)
{
    PCLI_MEMORY_INFO pMemory;
    PCLI_DEVICE_INFO pDevice;

    if (CliGetDeviceMemoryInfo(hDevice, hMemory, &pMemory))
    {
        // fixup prev link
        if (pMemory->Prev)
        {
            pMemory->Prev->Next = pMemory->Next;
        }
        else
        {
            // head of list, so modify the list head link
            if (!CliGetDeviceInfo(hDevice, &pDevice))
            {
                return FALSE;
            }
            pDevice->DevMemoryList = pMemory->Next;
        }

        // fixup next link
        if (pMemory->Next)
        {
            pMemory->Next->Prev = pMemory->Prev;
        }

        // free the list element
        osFreeMem(pMemory);

        return TRUE;
    }

    return FALSE;

} // end of CliDelDeviceMemory()

//
// This is currently used only by heapPurge to delete DeviceMemory based
// only on the owner.
//
BOOL CliDelDeviceHeapOwner(
    U032 hDevice,
    U032 heapOwner
)
{
    PCLI_MEMORY_INFO pMemory;
    BOOL retval = FALSE;

    for (pMemory = CliGetDeviceMemoryList(hDevice); pMemory; )
    {
        if (pMemory->HeapOwner == heapOwner)
        {
            U032 hMemory = pMemory->Handle;

            pMemory = pMemory->Next;                // get Next, before we delete it
            CliDelDeviceMemory(hDevice, hMemory);

            retval = TRUE;
        } else
            pMemory = pMemory->Next;
    }

    return retval;

} // end of CliDelDeviceHeapOwner

BOOL CliGetDeviceMemoryInfo(
    U032 hDevice,
    U032 hMemory,
    PCLI_MEMORY_INFO *ppMemoryInfo
)
{
    PCLI_MEMORY_INFO pMemory;

    for (pMemory = CliGetDeviceMemoryList(hDevice); pMemory; pMemory = pMemory->Next)
    {
        if (pMemory->Handle == hMemory)
        {
            *ppMemoryInfo = pMemory;
            return TRUE;
        }
    }

    return FALSE;

} // end of CliGetDeviceMemoryInfo()

PCLI_MEMORY_INFO CliGetDeviceMemoryList(
    U032 hDevice
)
{
    PCLI_DEVICE_INFO pDevice;
    PCLI_MEMORY_INFO memoryList = NULL;

    if (CliGetDeviceInfo(hDevice, &pDevice))
    {
        memoryList = pDevice->DevMemoryList;
    }

    return memoryList;

} // end of CliGetDeviceMemoryList()

RM_STATUS CliAddDma(
    U032 hClient,
    U032 hDma,
    U032 hClass,
    U032 flags,
    U032 selector,
    VOID* base,
    U032 limit,
    PCLI_DMA_INFO *ppDma
)
{
    U032 client;
    PCLI_DMA_INFO pDma;
    U032 access, physicality, locked, coherency;

    // validate client
    if (!CliGetClientHandle(&client) || client != hClient)
    {
        return RM_ERR_BAD_OBJECT_PARENT;
    }

    // validate handle
    if (!CliIsUniqueHandle(hDma, FALSE))
    {
        return RM_ERR_BAD_OBJECT_HANDLE;
    }

    // validate class
    switch (hClass)
    {
        case NV01_CONTEXT_DMA:
            break;

        default:
            return RM_ERR_BAD_CLASS;
    }

    // validate the flags
    switch (flags >> DRF_SHIFT(NVOS03_FLAGS_ACCESS) & DRF_MASK(NVOS03_FLAGS_ACCESS))
    {
        case NVOS03_FLAGS_ACCESS_READ_WRITE:
            access = NV01_CONTEXT_DMA_IN_MEMORY;
            break;

        case NVOS03_FLAGS_ACCESS_READ_ONLY:
            access = NV01_CONTEXT_DMA_FROM_MEMORY;
            break;

        case NVOS03_FLAGS_ACCESS_WRITE_ONLY:
            access = NV01_CONTEXT_DMA_TO_MEMORY;
            break;

        default:
            return RM_ERR_BAD_FLAGS;
    }
    switch (flags >> DRF_SHIFT(NVOS03_FLAGS_PHYSICALITY) & DRF_MASK(NVOS03_FLAGS_PHYSICALITY))
    {
        case NVOS03_FLAGS_PHYSICALITY_CONTIGUOUS:
            physicality = NVOS03_FLAGS_PHYSICALITY_CONTIGUOUS;
            break;

        case NVOS03_FLAGS_PHYSICALITY_NONCONTIGUOUS:
            physicality = NVOS03_FLAGS_PHYSICALITY_NONCONTIGUOUS;
            break;

        default:
            return RM_ERR_BAD_FLAGS;
    }
    switch (flags >> DRF_SHIFT(NVOS03_FLAGS_LOCKED) & DRF_MASK(NVOS03_FLAGS_LOCKED))
    {
        case NVOS03_FLAGS_LOCKED_ALWAYS:
            locked = NVOS03_FLAGS_LOCKED_ALWAYS;
            break;

        case NVOS03_FLAGS_LOCKED_IN_TRANSIT:
            locked = NVOS03_FLAGS_LOCKED_IN_TRANSIT;
            break;

        default:
            return RM_ERR_BAD_FLAGS;
    }
    switch (flags >> DRF_SHIFT(NVOS03_FLAGS_COHERENCY) & DRF_MASK(NVOS03_FLAGS_COHERENCY))
    {
        case NVOS03_FLAGS_COHERENCY_UNCACHED:
            coherency = NVOS03_FLAGS_COHERENCY_UNCACHED;
            break;

        case NVOS03_FLAGS_COHERENCY_CACHED:
            coherency = NVOS03_FLAGS_COHERENCY_CACHED;
            break;

        default:
            return RM_ERR_BAD_FLAGS;
    }

    // allocate a new dmaInfo and add the device to the client
    if (RM_SUCCESS(osAllocMem((void **) &pDma, sizeof(CLI_DMA_INFO))))
    {
        // link in the new DMA
        pDma->Next = clientInfo[ClientInstance].CliDmaList;
        pDma->Prev = NULL;
        clientInfo[ClientInstance].CliDmaList = pDma;
        if (pDma->Next)
        {
            pDma->Next->Prev = pDma;
        }

        // initialize the device
        pDma->Handle        = hDma;
        pDma->Client        = hClient;
        pDma->Class         = hClass;
        pDma->Flags         = flags;
        pDma->Access        = access;
        pDma->Physicality   = physicality;
        pDma->Locked        = locked;
        pDma->Coherency     = coherency;
        pDma->Valid         = FALSE;
        pDma->DescSelector  = selector;
        pDma->DescOffset    = base;
        pDma->DescLimit     = limit;
        pDma->DescAddr      = 0;
        pDma->BufferBase    = 0;
        pDma->BufferSize    = 0;
        pDma->LockHandle    = 0;
        pDma->PteCount      = 0;
        pDma->PteAdjust     = 0;
        pDma->PteLimit      = 0;
        pDma->PteArray      = 0;
        pDma->AddressSpace  = ADDR_UNKNOWN;
        *ppDma = pDma;

        return RM_OK;
    }

    return RM_ERR_INSUFFICIENT_RESOURCES;

} // end of CliAddDma()

BOOL CliDelDma(
    U032 hDma
)
{
    PCLI_DMA_INFO pDma;

    if (CliGetDmaInfo(hDma, &pDma))
    {
        // fixup prev link
        if (pDma->Prev)
        {
            pDma->Prev->Next = pDma->Next;
        }
        else
        {
            // head of list, so modify the list head link
            clientInfo[ClientInstance].CliDmaList = pDma->Next;
        }

        // fixup the next link
        if (pDma->Next)
        {
            pDma->Next->Prev = pDma->Prev;
        }

        // free the list element
        osFreeMem(pDma);

        return TRUE;
    }

    return FALSE;

} // end of CliDelDma()

BOOL CliGetDmaInfo(
    U032 hDma,
    PCLI_DMA_INFO *ppDmaInfo
)
{
    PCLI_DMA_INFO pDma;

    for (pDma = CliGetDmaList(); pDma; pDma = pDma->Next)
    {
        if (pDma->Handle == hDma)
        {
            *ppDmaInfo = pDma;
            return TRUE;
        }
    }

    return FALSE;

} // end of CliGetDmaInfo()

PCLI_DMA_INFO CliGetDmaList()
{
    return clientInfo[ClientInstance].CliDmaList;

} // end of CliGetDmaList()

RM_STATUS CliAddMemory(
    PHWINFO pDev,
    U032 hClient,
    U032 hMemory,
    U032 hClass,
    U032 flags,
    VOID* address,
    U032 length,
    VOID* memdata       // private per-alloc data
)
{
    U032 client;
    PCLI_MEMORY_INFO pMemory;

    // validate client
    if (!CliGetClientHandle(&client) || client != hClient)
    {
        return RM_ERR_BAD_OBJECT_PARENT;
    }

    // validate memory description
    if (!CliIsUniqueHandle(hMemory, FALSE))
    {
        return RM_ERR_BAD_OBJECT_HANDLE;
    }

    // validate class
    switch (hClass)
    {
        case NV01_MEMORY_SYSTEM:
            break;

        default:
            return RM_ERR_BAD_CLASS;

    }

    // allocate a new memory description and add the device to the client
    if (RM_SUCCESS(osAllocMem((void **) &pMemory, sizeof(CLI_MEMORY_INFO))))
    {
        // link in the new system memory mapping
        pMemory->Next = clientInfo[ClientInstance].CliMemoryList;
        pMemory->Prev = NULL;
        clientInfo[ClientInstance].CliMemoryList = pMemory;
        if (pMemory->Next)
        {
            pMemory->Next->Prev = pMemory;
        }

        // initialize the memory description
        pMemory->pDev       = pDev;
        pMemory->Handle     = hMemory;
        pMemory->Parent     = hClient;
        pMemory->Class      = hClass;
        pMemory->Address    = address;
        pMemory->Length     = length;
        pMemory->Type       = DRF_VAL(OS02, _FLAGS, _LOCATION, flags);
        pMemory->Physicality = DRF_VAL(OS02, _FLAGS, _PHYSICALITY, flags);
        pMemory->Coherency  = DRF_VAL(OS02, _FLAGS, _COHERENCY, flags);
        pMemory->MemData    = memdata;

        return RM_OK;
    }

    return RM_ERR_INSUFFICIENT_RESOURCES;

} // end of CliAddMemory()

BOOL CliDelMemory(
    U032 hMemory
)
{
    PCLI_MEMORY_INFO pMemory;

    if (CliGetMemoryInfo(hMemory, &pMemory))
    {
        // fixup prev link
        if (pMemory->Prev)
        {
            pMemory->Prev->Next = pMemory->Next;
        }
        else
        {
            // head of list, so modify the list head link
            clientInfo[ClientInstance].CliMemoryList = pMemory->Next;
        }

        // fixup the next link
        if (pMemory->Next)
        {
            pMemory->Next->Prev = pMemory->Prev;
        }

        pMemory->MemData = NULL;

        // free the list element
        osFreeMem(pMemory);

        return TRUE;
    }

    return FALSE;

} // end of CliDelMemory()

BOOL CliGetMemoryInfo(
    U032 hMemory,
    PCLI_MEMORY_INFO *ppMemoryInfo
)
{
    PCLI_MEMORY_INFO pMemory;

    for (pMemory = CliGetMemoryList(); pMemory; pMemory = pMemory->Next)
    {
        if (pMemory->Handle == hMemory)
        {
            *ppMemoryInfo = pMemory;
            return TRUE;
        }
    }

    return FALSE;

} // end of CliGetMemoryInfo()


// which memory chunk spans a given linear address?
BOOL CliGetMemoryInfoForLinAddr(
    VOID *address,
    PCLI_MEMORY_INFO *ppMemoryInfo
)
{
    PCLI_MEMORY_INFO pMemory;

    for (pMemory = CliGetMemoryList(); pMemory; pMemory = pMemory->Next)
    {
        // NOTE: pMemory->length is really length-1
        if ((address >= pMemory->Address) &&
            (address <= (VOID*)((U008*)pMemory->Address + pMemory->Length)))
        {
            *ppMemoryInfo = pMemory;
            return TRUE;
        }
    }

    return FALSE;

} // end of CliGetMemoryInfoForLinAddr()


PCLI_MEMORY_INFO CliGetMemoryList()
{
    return clientInfo[ClientInstance].CliMemoryList;

} // end of CliGetMemoryList()

RM_STATUS CliAddEvent(
    U032 hClient,
    U032 hObject,
    U032 hEvent,
    U032 hClass,
    PCLI_EVENT_INFO* ppEventInfo
)
{
    RM_STATUS rmStatus = RM_OK;
    POBJECT pObject;
    PCLI_EVENT_INFO pEvent;
    PCLI_EVENT_USER pUser;
    U032 hChannel;

    // validate parent
    if (!CliFindObject(hObject, &pObject, &hChannel))
    {
        return RM_ERR_BAD_OBJECT_PARENT;
    }

    // validate handle -- disregard existing event handles
    if (!CliIsUniqueHandle(hEvent, TRUE))
    {
        return RM_ERR_BAD_OBJECT_HANDLE;
    }

    // validate class
    switch (hClass)
    {
        case NV01_EVENT_KERNEL_CALLBACK:
        case NV01_EVENT_WIN32_EVENT:
            break;

        default:
            return RM_ERR_BAD_CLASS;

    }

    // return a pointer to the client event list element
    if (!CliGetEventInfo(hEvent, &pEvent))
    {
        // allocate a new event and add to the client
        rmStatus = osAllocMem((void **) &pEvent, sizeof(CLI_EVENT_INFO));
        if (RM_SUCCESS(rmStatus))
        {
            // link in the new event
            pEvent->Next = clientInfo[ClientInstance].CliEventList;
            pEvent->Prev = NULL;
            clientInfo[ClientInstance].CliEventList = pEvent;
            if (pEvent->Next)
            {
                pEvent->Next->Prev = pEvent;
            }

            // initialize the event
            pEvent->Handle      = hEvent;
            pEvent->Class       = hClass;
            pEvent->UserList    = NULL;
        }
    }
    else
    {
        // validate the user object's uniqueness for non-trivial lists
        for (pUser = pEvent->UserList; pUser; pUser = pUser->Next)
        {
            if (pUser->Handle == hObject)
            {
                return RM_ERR_BAD_OBJECT_HANDLE;
            }
        }
    }

    // add the next user
    if (RM_SUCCESS(rmStatus))
    {
        rmStatus = osAllocMem((void **) &pUser, sizeof(CLI_EVENT_USER));
        if (RM_SUCCESS(rmStatus))
        {
            // link in the new event's user
            pUser->Next = pEvent->UserList;
            pUser->Prev = NULL;
            pEvent->UserList = pUser;
            if (pUser->Next)
            {
                pUser->Next->Prev = pUser;
            }

            // initialize the new user
            pUser->Handle   = hObject;
            pUser->Channel  = hChannel;

            // set the return value
            *ppEventInfo = pEvent;
        }
    }

    return rmStatus;

} // end of CliAddEvent()

BOOL CliDelEvent(
    U032 hEvent
)
{
    PCLI_EVENT_INFO pEvent;
    PCLI_EVENT_USER nextUser;

    // remove the event from the client database
    if (CliGetEventInfo(hEvent, &pEvent))
    {
        // free up user list
        nextUser = pEvent->UserList;
        while (pEvent->UserList)
        {
            pEvent->UserList = nextUser->Next;
            osFreeMem(nextUser);
        }

        // fixup next link
        if (pEvent->Prev)
        {
            pEvent->Prev->Next = pEvent->Next;
        }
        else
        {
            // head of list, so modify the list head link
            clientInfo[ClientInstance].CliEventList = pEvent->Next;
        }

        // fixup the prev link
        if (pEvent->Next)
        {
            pEvent->Next->Prev = pEvent->Prev;
        }

        // free the list element
        osFreeMem(pEvent);

        return TRUE;
    }

    return FALSE;

} // end of CliDelEvent()

BOOL CliDelEventUser
(
    U032 hUser,
    U032 hClass
)
{
    PCLI_EVENT_INFO nextEvent;
    PCLI_EVENT_USER nextUser, pUser;
    U032 hEvent;

    // remove user from all events
    nextEvent = CliGetEventList();
    while (nextEvent)
    {
        nextUser = nextEvent->UserList;
        while (nextUser)
        {
            if (CliGetEventUserHandle(nextUser, hClass) == hUser)
            {
                // fixup next link
                if (nextUser->Prev)
                {
                    nextUser->Prev->Next = nextUser->Next;
                }
                else
                {
                    // head of list, so modify the list head link
                    nextEvent->UserList = nextUser->Next;
                }

                // fixup the prev link
                if (nextUser->Next)
                {
                    nextUser->Next->Prev = nextUser->Prev;
                }

                // free the list element
                pUser = nextUser;
                nextUser = nextUser->Next;
                osFreeMem(pUser);
            }
            else
            {
                nextUser = nextUser->Next;
            }
        }

        // remove the event if user list is empty
        if (nextEvent->UserList == NULL)
        {
            hEvent = nextEvent->Handle;
            nextEvent = nextEvent->Next;
            CliDelEvent(hEvent);
        }
        else
        {
            nextEvent = nextEvent->Next;
        }
    }

    return TRUE;

}

U032 CliGetEventUserHandle
(
    PCLI_EVENT_USER pUser,
    U032 hClass
)
{
    switch (hClass)
    {
        // object
        case NV01_NULL_OBJECT:
            return pUser->Handle;

        // channel
        default:
            return pUser->Channel;
    }

} // end of CliGetEventUserHandle()

BOOL CliGetEventInfo(
    U032 hEvent,
    PCLI_EVENT_INFO* ppEventInfo
)
{
    PCLI_EVENT_INFO pEvent;

    for (pEvent = CliGetEventList(); pEvent; pEvent = pEvent->Next)
    {
        if (pEvent->Handle == hEvent)
        {
            *ppEventInfo = pEvent;
            return TRUE;
        }
    }

    return FALSE;

} // end of CliGetEventInfo()

PCLI_EVENT_INFO CliGetEventList()
{
    return clientInfo[ClientInstance].CliEventList;

} // end of CliGetEventList()

BOOL CliFindObject(
    U032 hObject,
    POBJECT* ppObject,
    U032* phChannel
)
{
    BOOL found = FALSE;
    PCLI_DEVICE_INFO deviceList;
    PCLI_FIFO_INFO fifoList;
    U032 device, fifo;
    PHWINFO pDev;

    deviceList = CliGetDeviceList();
    if ( ! deviceList)
        goto done;

    // search thru all channels of all devices for the object
    for (device = 0; device < NUM_DEVICES; device++)
    {
        if (deviceList[device].InUse)
        {
            if (CliSetDeviceContext(deviceList[device].Handle, &pDev))
            {
                if (CliGetDeviceFifoList(deviceList[device].Handle, &fifoList)
                    && fifoList)
                {
                    for (fifo = 0; fifo < NUM_FIFOS; fifo++)
                    {
                        if (fifoList[fifo].InUse)
                        {
                            if (RM_OK == fifoSearchObject(pDev,
                                                          hObject,
                                                          fifoList[fifo].ChID,
                                                          ppObject))
                            {
                                found = TRUE;
                                *phChannel = fifoList[fifo].Handle;
                                goto done;
                            }
                        }
                    }
                }
            }
        }
    }

 done:
    return found;

} // end of CliFindObject()

BOOL CliGetClass(
    U032 hParent,
    U032 hObject,
    U032 *phClass
)
{
    U032 client;
    PCLI_DEVICE_INFO pDevice;
    PCLI_FIFO_INFO pFifo;
    PCLI_MEMORY_INFO pMemory;
    PCLI_DMA_INFO pDma;
    PCLI_EVENT_INFO pEvent;

    // scan all object types

    if (CliGetClientHandle(&client) && client == hObject)
    {
        *phClass = clientInfo[ClientInstance].Class;
    }
    else if (CliGetDeviceInfo(hObject, &pDevice))
    {
        *phClass = pDevice->Class;
    }
    else if (CliGetDeviceFifoInfo(hParent, hObject, &pFifo))
    {
        *phClass = pFifo->Class;
    }
    else if (CliGetDeviceMemoryInfo(hParent, hObject, &pMemory))
    {
        *phClass = pMemory->Class;
    }
    else if (CliGetDmaInfo(hObject, &pDma))
    {
        *phClass = pDma->Class;
    }
    else if (CliGetMemoryInfo(hObject, &pMemory))
    {
        *phClass = pMemory->Class;
    }
    else if (CliGetEventInfo(hObject, &pEvent))
    {
        *phClass = pEvent->Class;
    }
    else
    {
        return FALSE;
    }

    return TRUE;

} // end of CliGetClass()

BOOL CliIsUniqueHandle(U032 hObject, BOOL omitEvents)
{
    U032 i, j;
    PCLI_DEVICE_INFO deviceList;
    PCLI_FIFO_INFO fifoList;
    PCLI_DMA_INFO nextDma;
    PCLI_MEMORY_INFO nextMemory;
    PCLI_EVENT_INFO nextEvent;
    POBJECT pObject;
    U032 hChannel;

    // handle is unique if it is non-null or does not exist in the client
    if (hObject == NV01_NULL_OBJECT)
        return FALSE;

    if ((deviceList = CliGetDeviceList()) != NULL)
    {
        for (i = 0; i < NUM_DEVICES; i++)
        {
            if (deviceList[i].InUse)
            {
                if (deviceList[i].Handle == hObject)
                    return FALSE;

                if (CliGetDeviceFifoList(deviceList[i].Handle, &fifoList) && fifoList)
                {
                    for (j = 0; j < MAX_FIFOS; j++)
                    {
                        if (fifoList[j].InUse)
                        {
                            if (fifoList[j].Handle == hObject)
                                return FALSE;
                        }
                    }
                }
            }
        }
    }

    for (nextDma = CliGetDmaList(); nextDma; nextDma = nextDma->Next)
    {
        if (nextDma->Handle == hObject)
        {
            return FALSE;
        }
    }
    for (nextMemory = CliGetMemoryList(); nextMemory; nextMemory = nextMemory->Next)
    {
        if (nextMemory->Handle == hObject)
        {
            return FALSE;
        }
    }
    for (nextEvent = CliGetEventList(); nextEvent; nextEvent = nextEvent->Next)
    {
        if (nextEvent->Handle == hObject)
        {
            return FALSE;
        }
    }
    if (CliFindObject(hObject, &pObject, &hChannel))
    {
        return FALSE;
    }

    return TRUE;

} // end of CliIsUniqueHandle()

BOOL CliGetPhysicalDevice(
    U032 logicalDevice,
    U032 *physicalDevice
)
{
    switch (logicalDevice)
    {
        case NV01_DEVICE_0:
            *physicalDevice = 0;
            break;

        case NV01_DEVICE_1:
            *physicalDevice = 1;
            break;

        case NV01_DEVICE_2:
            *physicalDevice = 2;
            break;

        case NV01_DEVICE_3:
            *physicalDevice = 3;
            break;

        case NV01_DEVICE_4:
            *physicalDevice = 4;
            break;

        case NV01_DEVICE_5:
            *physicalDevice = 5;
            break;

        case NV01_DEVICE_6:
            *physicalDevice = 6;
            break;

        case NV01_DEVICE_7:
            *physicalDevice = 7;
            break;

        default:
            return FALSE;
    }

    return TRUE;

} // end of CliGetPhysicalDevice()

// Given a Channel ID return the Client handle
//
// Currently, this is routine is only called at intr time from
// dmaValidateObjectName, so dmaFindContext has the client handle
// to retrieve the correct DmaObject from the global DmaList. The
// DeviceInstance has already been set.
//
RM_STATUS CliGetClientHandleFromChID(
    PHWINFO pDev,
    U032 ChID,
    U032 *phClient
)
{
    U032 i, j, k, physnum;

    PCLI_FIFO_INFO fifoList;

    *phClient = 0;

    for (i = 0; i < NUM_CLIENTS; i++)
    {
        if (!clientInfo[i].InUse)
            continue;

        if (!clientInfo[i].CliDeviceList)
            continue;

        // scan the client's devices
        for (j = 0; j < NUM_DEVICES; j++)
        {
            if (!clientInfo[i].CliDeviceList[j].InUse)
                continue;

            // look for the DeviceInstance in DeviceList
            CliGetPhysicalDevice(clientInfo[i].CliDeviceList[j].Class, &physnum);
            if (physnum != devInstance)
                continue;

            // see if any "inuse" fifos match this channel ID
            fifoList = clientInfo[i].CliDeviceList[j].DevFifoList;
            if ( ! fifoList)
                continue;

            for (k = 0; k < MAX_FIFOS; k++)
            {
                if (fifoList[k].InUse && (fifoList[k].ChID == ChID))
                {
                    // find the one corresponding to largest client id.
                    // this avoids returning a stale client id in case
                    // of a previous client (using this device/channel)
                    // not being properly freed up.
                    if (clientInfo[i].Handle > *phClient)
                        *phClient = clientInfo[i].Handle;
                }
            }
        }
    }

    if (*phClient != 0)
        return RM_OK;

    return RM_ERR_BAD_OBJECT_ERROR;

} // end of CliGetClientHandleFromChID()

//
// Initialize the client database.
//
RM_STATUS initClientInfo(
    VOID
)
{
    RM_STATUS rmStatus;
    U032 i;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: initClientInfo\n");

    // allocate table
    rmStatus = osAllocMem((VOID **)&clientInfo, sizeof(CLIENTINFO) * NUM_CLIENTS);
    if (!RM_SUCCESS(rmStatus))
        return rmStatus;

    // initialize the client database
    for (i = 0; i < NUM_CLIENTS; i++)
    {
        clientInfo[i].InUse = FALSE;
        clientInfo[i].AppID = i;
        clientInfo[i].AppHandle = (void *) 0;
        clientInfo[i].CliDeviceList = NULL;
        clientInfo[i].CliHeapOwnerList = NULL;         //added by Chuck Moidel
    }

    return RM_OK;
}

//
// Tear down a clientInfo by free'ing all the memory allocated to it.
//
RM_STATUS destroyClientInfo(
    VOID
)
{
    U032 i, d;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: destroyClientInfo\n");

    if ( ! clientInfo)
        return RM_OK;

    for (i = 0; i < NUM_CLIENTS; i++)
    {
        if ( ! clientInfo[i].CliDeviceList)
            continue;

        for (d = 0; d < NUM_DEVICES; d++)
        {
            if ( ! clientInfo[i].CliDeviceList[d].DevFifoList)
                continue;

            osFreeMem(clientInfo[i].CliDeviceList[d].DevFifoList);
            clientInfo[i].CliDeviceList[d].DevFifoList = NULL;
        }
        osFreeMem(clientInfo[i].CliDeviceList);
        clientInfo[i].CliDeviceList = NULL;
    }

    osFreeMem(clientInfo);
    clientInfo = NULL;

    return RM_OK;
}

// end of client.c
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\common\src\nv\nvagp.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-1997 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-1997  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************* AGP Chipset Routines **********************************\
*                                                                           *
* Module: NVAGP.C                                                           *
*   One time initialization code to update the AGP chipset and              *
*   our own AGP related values (includes workarounds and registry           *
*   overrides.                                                              *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <stddef.h>    // for size_t
#include <nvReg.h>
#include <nvrm.h>
#include <nvhw.h>
#include <os.h>
#include <nvos.h>
#include <nvagp.h>

#ifdef LINUX 
#include <os-interface.h>
#include <asm/system.h>
#define INTERRUPT_SETUP    unsigned long flags;
#else
#define INTERRUPT_SETUP
#endif

#define BYTES_MAPPED_PER_PAGE   ((RM_PAGE_SIZE >> 2) * RM_PAGE_SIZE)

extern char strDevNodeRM[];

// see how many "devices" are connected to us.
// This is important under Linux, since multiple X Servers can
// be run at once. We don't want the second X Server to reinitialize
// everything when it starts up, or the first X Server to exit
// teardown AGP on the remaining X Server.
static int agp_ref_count = 0;

// XXX get rid of this quick!!
#ifdef LINUX
#define RM_REGISTRY_AGP_BASE_PATH 0
#endif

/* define which chipsets should be compiled in. 
 * This allows controlled adding and testing of new chipsets without 
 * causing problems for people not expecting them.
 */
#define SUPPORT_INTEL_AGP     1
#define SUPPORT_VIA_AGP       1
#define SUPPORT_AMD_AGP       1
#define SUPPORT_RCC_AGP       1
#define SUPPORT_MICRON_AGP    1

enum {
      CS_UNKNOWN = 0
#ifdef SUPPORT_INTEL_AGP
    , CS_INTEL_440LX,
      CS_INTEL_440BX,
      CS_INTEL_440GX,
      CS_INTEL_815,       // solano
      CS_INTEL_820,       // camino
      CS_INTEL_840,       // carmel
      CS_INTEL_845,       // brookdale
      CS_INTEL_850,       // tehama
      CS_INTEL_860,       // colusa
      CS_INTEL_COMPAT     // compatibility
#endif
#ifdef SUPPORT_AMD_AGP
    , CS_AMD_751,         // irongate
      CS_AMD_761,         // igd4
      CS_AMD_762          // igd4 mp
#endif
#ifdef SUPPORT_VIA_AGP
    , CS_VIA_8371,        // w/ intel cpu
      CS_VIA_82C694X,     // w/ amd slot A
      CS_VIA_KT133        // w/ amd socket A
#endif
#ifdef SUPPORT_RCC_AGP
    , CS_RCC_6585HE       // cnb20he
#endif
#ifdef SUPPORT_MICRON_AGP
    , CS_MICRON_SAMDDR,   // samurai
      CS_MICRON_SCIDDR    // scimitar
#endif
};

/* moved agp mapping info here from pDev.
 * this primarily allows two things:
 *   - a second X Server run on another VT can share AGP with the
 *         initial X Server by using this info.
 *   - if X crashes and leaves AGP setup, the restarting X Server
 *         can use this info, as if it was just a second X Server.
 * In the long run, the variables in pDev should be changed to point
 * to this structure here, but we're too close to a release under
 * multiple platforms to change that much code.
 * For now, we'll just have to deal with keeping info synchronized.
 */

typedef struct {
    unsigned int initialized;
    unsigned int fw_capable;
    unsigned int sba_capable;
    VOID (*enable_mappings)(PHWINFO pDev, VOID *handle, U032 physaddr);
    VOID (*flush_mappings)(PHWINFO pDev, VOID *handle);
    U032 (*get_aper_size)(PHWINFO pDev, VOID *handle);
    U032 (*get_aper_base)(PHWINFO pDev, VOID *handle);
    U032 (*get_gart_size)(PHWINFO pDev, VOID *handle);
    U032 (*earlyinit)(PHWINFO pDev, VOID *handle);
    VOID (*fixup_gart)(PHWINFO pDev, VOID *handle, U032 physaddr);
    VOID (*apply_updates)(PHWINFO pDev, VOID *handle, U016 deviceID);
    VOID (*disable_chipset)(PHWINFO pDev, VOID *handle);
    VOID (*saverestore_chipset)(PHWINFO pDev, VOID *handle, U032 state);
} agp_chipset_funcs;

/* noop error functions to avoid NULL pointer dereferences */
static VOID agp_noop1(PHWINFO pDev, VOID *handle, U032 physaddr);
static VOID agp_noop2(PHWINFO pDev, VOID *handle);
static U032 agp_noop3(PHWINFO pDev, VOID *handle);
static VOID agp_noop4(PHWINFO pDev, VOID *handle, U016 deviceID);

/* Chipset Explanation:
 *
 * In theory, it should be easy (sw-wise) to add multiple AGP chipsets per 
 * system. chipset_funcs[] is a static array of all chipsets in a system, 
 * but is only accessed in the code via the chipset ptr. To initialize to 
 * a different chipset, call the AGP_SELECT_DEVICE() macro, to select a 
 * new bus/slot combination. currently, this uses the bus as an offset to 
 * choose which chipset to use. Although this may be a bad assumption, the 
 * only place it is made is right here, and so is a simple, isolated change.
 */

#define AGP_MAX_CHIPSETS 1
static agp_chipset_funcs chipset_funcs[AGP_MAX_CHIPSETS] = 
    { 
        { 
            0, 0, 0, 
            agp_noop1, agp_noop2, agp_noop3, agp_noop3, agp_noop3, agp_noop3, 
            agp_noop1, agp_noop4, agp_noop2
        }
    };

static agp_chipset_funcs *agp_current = NULL;

#define AGP_SELECT_DEVICE(handle, venid, devid)                      \
    agp_current = &chipset_funcs[0];                                 \
    NvSetBusDeviceFunc(pDev);                                        \
    handle = osPciInitHandle(AgpInfo(pDev).NBAddr.bus,               \
                             AgpInfo(pDev).NBAddr.device,            \
                             AgpInfo(pDev).NBAddr.func,              \
                             venid, devid);


static VOID 
agp_noop1(PHWINFO pDev, VOID *handle, U032 physaddr)
{
    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: *** called agp_noop1\n");
}

static VOID 
agp_noop2(PHWINFO pDev, VOID *handle)
{
    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: *** called agp_noop2\n");
}

static U032
agp_noop3(PHWINFO pDev, VOID *handle)
{
    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: *** called agp_noop3\n");
    return 0;
}

static VOID 
agp_noop4(PHWINFO pDev, VOID *handle, U016 deviceID)
{
    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: *** called agp_noop4\n");
}


#ifdef SUPPORT_AMD_AGP

BOOL 
AMD_IsChipset(PHWINFO pDev)
{
    switch (AgpInfo(pDev).AGPChipset) 
    {
        case CS_AMD_751:
        case CS_AMD_761:
        case CS_AMD_762:
            return TRUE;
    }
    return FALSE;
}

U032
AMD_GetChipset(PHWINFO pDev, U032 device)
{
    switch(device)
    {
        case 0x7006:
            return CS_AMD_751;
        case 0x700E:
            return CS_AMD_761;
        case 0x700C:
            return CS_AMD_762;
    }
    return 0;
}

static VOID AMD_EnableMappings(PHWINFO pDev, VOID *handle, U032 physaddr);
static VOID AMD_FlushMappings(PHWINFO pDev, VOID *handle);
static U032 AMD_GetAperSize(PHWINFO pDev, VOID *handle);
static U032 AMD_GetAperBase(PHWINFO pDev, VOID *handle);
static U032 AMD_GetGartSize(PHWINFO pDev, VOID *handle);
static U032 AMD_EarlyInit(PHWINFO pDev, VOID *handle);
static VOID AMD_FixupGart(PHWINFO pDev, VOID *handle, U032 physaddr);
static VOID AMD_ApplyChipsetUpdates(PHWINFO pDev, VOID *handle, U016 deviceID);
static VOID AMD_DisableChipset(PHWINFO pDev, VOID *handle);
static VOID AMD_SaveRestoreChipset(PHWINFO pDev, VOID *handle, U032 state);

VOID
AMD_SetupFuncs(U032 chipset, agp_chipset_funcs *funcs)
{
    funcs->enable_mappings     = AMD_EnableMappings;
    funcs->flush_mappings      = AMD_FlushMappings;
    funcs->get_aper_size       = AMD_GetAperSize;
    funcs->get_aper_base       = AMD_GetAperBase;
    funcs->get_gart_size       = AMD_GetGartSize;
    funcs->earlyinit           = AMD_EarlyInit;
    funcs->fixup_gart          = AMD_FixupGart;
    funcs->apply_updates       = AMD_ApplyChipsetUpdates;
    funcs->disable_chipset     = AMD_DisableChipset;
    funcs->saverestore_chipset = AMD_SaveRestoreChipset;
    funcs->initialized = 1;
    funcs->fw_capable = 1;
    funcs->sba_capable = 0;
}


static VOID
AMD_EnableMappings(PHWINFO pDev, VOID *handle, U032 physaddr)
{
    switch (AgpInfo(pDev).AGPChipset)    
    {
        case CS_AMD_751:
        case CS_AMD_761:
        case CS_AMD_762:
            // enable GART directory cache  
            osPciOrWord(handle, PCI_DEVICE_SPECIFIC + 0x72, 0x2);

            // enable GART table cache and errors
            ((unsigned char*)AgpInfo(pDev).AGPChipsetMapping)[0x2] |= 0x5;

            // base of GART
            ((unsigned int*)AgpInfo(pDev).AGPChipsetMapping)[0x1] = physaddr;
            break;
        default:
            break;
    }

}

static VOID
AMD_FlushMappings(PHWINFO pDev, VOID *handle)
{
    // We could invalidate the individual entries, but for starters, just
    // invalidate the whole cache of entries. 
    ((unsigned int*)AgpInfo(pDev).AGPChipsetMapping)[0x3] |= 0x1;
}

static U032
AMD_GetAperSize(PHWINFO pDev, VOID *handle)
{
    unsigned int apsize = osPciReadWord(handle, AMD_APER_SIZE); // aperture size
    switch ( (apsize & 0xE) >> 1 )   /* mask and shift bits 1-3 */
    {
        case 0x00:
            apsize = (  32 * 1024 * 1024);
        break;
        case 0x01:
            apsize = (  64 * 1024 * 1024);
        break;
        case 0x02:
            apsize = ( 128 * 1024 * 1024);
        break;
        case 0x03:
            apsize = ( 256 * 1024 * 1024);
        break;
        case 0x04:
            apsize = ( 512 * 1024 * 1024);
        break;
        case 0x05:
            apsize = (1024 * 1024 * 1024);
        break;
        case 0x06:
            apsize = (2024 * 1024 * 1024);
        break;
        default:
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: *** Intel bad apsize!\n");
            apsize = 0;
    }

#if 1
    // I'm having problems under Linux if I go greater than 32 Megs...
    if (apsize > AGP_APERTURE_SIZE) 
    {
        apsize = AGP_APERTURE_SIZE;
        // XXX - translate new aperture size back to hw-encoding
        osPciAndWord(handle, AMD_APER_SIZE, ~(0xe) /* apsize */);
    }
#endif

    return apsize;
}

static U032
AMD_GetAperBase(PHWINFO pDev, VOID *handle)
{
    return osPciReadDword(handle, PCI_BASE_ADDRESS_0);
}

static U032
AMD_GetGartSize(PHWINFO pDev, VOID *handle)
{
    unsigned int gart_size;
    gart_size = ((AgpInfo(pDev).AGPLimit + RM_PAGE_SIZE - 1) / RM_PAGE_SIZE) * 4;
    gart_size += RM_PAGE_SIZE;     // this is for the 1st-level lookup
    return gart_size;
}

static U032 
AMD_EarlyInit(PHWINFO pDev, VOID *handle)
{
    if ((AgpInfo(pDev).AGPChipset == CS_AMD_751) || 
        (AgpInfo(pDev).AGPChipset == CS_AMD_761) ||
        (AgpInfo(pDev).AGPChipset == CS_AMD_762))
    {
        // AMD 751/761/762 has its AGP related regs memory-mapped via BAR1
        unsigned int physaddr = (osPciReadDword(handle, PCI_BASE_ADDRESS_1) & ~RM_PAGE_MASK);

        AgpInfo(pDev).AGPChipsetMapping = (VOID_PTR) 
            osMapKernelSpace(physaddr, RM_PAGE_SIZE, MAP_UNCACHED);
        if (AgpInfo(pDev).AGPChipsetMapping == (VOID_PTR)NULL)
        {
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, 
                    "NVRM: *** Failed to map AMD's AGP chipset registers\n");
            return 0;
        }
    }
    return 1;
}

static VOID
AMD_FixupGart(PHWINFO pDev, VOID *handle, U032 physaddr)
{
    U032 i, *baseptr, tableptr;

    //
    // For AMD 751/761/762, convert the first allocated GART page into the first
    // level GART lookup ... where each GART directory entry is just the subsequent
    // 4k pages. We can derive the following entries, because we know the pages
    // are contiguous.
    //

    baseptr  = (U032 *)((U008 *)AgpInfo(pDev).AGPGartBase + 
        (AgpInfo(pDev).AGPPhysStart >> 20));
    tableptr = physaddr + RM_PAGE_SIZE;    // GART directory entries start on the 2nd page

    for (i = 0; i < ((AgpInfo(pDev).AGPLimit + 1) / BYTES_MAPPED_PER_PAGE); i++)
    {
        *baseptr = (tableptr | 0x1);

        tableptr += RM_PAGE_SIZE;   // next phys GART table address
        baseptr++;                  // next GART directory entry
    }
        
    //
    // Move the AGPGartBase past the first level GART page to where the GART
    // tables really begin (this makes nvagp_LoadGARTEntries() common).
    //
    (U008 *)AgpInfo(pDev).AGPGartBase += RM_PAGE_SIZE;
}

static VOID
AMD_ApplyChipsetUpdates(PHWINFO pDev, VOID *handle, U016 deviceID)
{
    U032 agp_command;

    if (deviceID != 0x7006)
        return;    // workarounds below are AMD751 (Irongate) specific

    // disable SBA on Irongate with NV5 (some faster NV5's are failing in the lab).
    if (IsNV5(pDev))
    {
        // clear chipset's SBA enable bit
        agp_command  = osPciReadDword(handle, AGP_COMMAND);
        agp_command &= ~(DRF_DEF(_PBUS, _PCI_NV_19, _AGP_COMMAND_SBA_ENABLE, _ON));
        osPciWriteDword(handle, AGP_COMMAND, agp_command);

        // clear our SBA enable bit
        FLD_WR_DRF_DEF(_PBUS, _PCI_NV_19, _AGP_COMMAND_SBA_ENABLE, _OFF);
    }

    // Due to an AMD power glitch bug, drop down to 1x on NV10/NV15
    if (IsNV10orBetter(pDev))
    {
        //
        // Compaq (and possibly others) have a modified NV10 which allows 2x to work.
        // This rework is not SW visable, so we detect it by a registry key.
        //
        if (IsNV10(pDev))
        {
            U032 data32;
            RM_STATUS status;

            // 
            // Compaq has a modified NV10 which allows 2x to work. This rework is not
            // SW visible, so we detect it by a registry key. If set, there's nothing
            // to do.
            //
            status = OS_READ_REGISTRY_DWORD(pDev, RM_REGISTRY_AGP_BASE_PATH,
                                            "EnableIrongate2x", &data32);
            if (status == RM_OK)
                return;

            //
            // This yields little perf difference, but Gateway has requested an option
            // to turn back on SBA when dropping to 1x mode. This requires setting the
            // strap first, since NV10 is normally not strapped for SBA.
            //
            status = OS_READ_REGISTRY_DWORD(pDev, RM_REGISTRY_AGP_BASE_PATH,
                                            "EnableIrongateSBA", &data32);
            if (status == RM_OK)
            {
                // set the overwrite bit and change our SBA strapping
                FLD_WR_DRF_DEF(_PEXTDEV, _BOOT_0, _STRAP_OVERWRITE, _ENABLED);
                FLD_WR_DRF_DEF(_PEXTDEV, _BOOT_0, _STRAP_AGP_SBA,   _ENABLED);

                // set chipset's SBA enable bit
                agp_command  = osPciReadDword(handle, AGP_COMMAND);
                agp_command |= DRF_DEF(_PBUS, _PCI_NV_19, _AGP_COMMAND_SBA_ENABLE, _ON);
                osPciWriteDword(handle, AGP_COMMAND, agp_command);

                // set our SBA enable bit
                FLD_WR_DRF_DEF(_PBUS, _PCI_NV_19, _AGP_COMMAND_SBA_ENABLE, _ON);
            }
        }

        // set AGP 1x mode
        agp_command  = osPciReadDword(handle, AGP_COMMAND);
        agp_command &= ~0xF;    // clear the old AGP rate
        agp_command |= DRF_DEF(_PBUS, _PCI_NV_19, _AGP_COMMAND_DATA_RATE, _1X);
        osPciWriteDword(handle, AGP_COMMAND, agp_command);

        FLD_WR_DRF_DEF(_PBUS, _PCI_NV_19, _AGP_COMMAND_DATA_RATE, _1X);
    }
}

static VOID
AMD_DisableChipset(PHWINFO pDev, VOID *handle)
{
    // paranoia
    if (!AgpInfo(pDev).AGPChipsetMapping)
        return;

    // enable GART directory cache
    // nv_printf("disabling GART directory cache\n");
    // osPciOrWord(handle, PCI_DEVICE_SPECIFIC + 0x72, 0x2);

    // enable GART table cache and errors
    ((unsigned char*)AgpInfo(pDev).AGPChipsetMapping)[0x2] &= ~(0x5);

    // base of GART
    ((unsigned int*)AgpInfo(pDev).AGPChipsetMapping)[0x1] = 0x0;

    // unmap AMD AGP registers
    osUnmapKernelSpace((void *) AgpInfo(pDev).AGPChipsetMapping, RM_PAGE_SIZE);
}

static VOID
AMD_SaveRestoreChipset(PHWINFO pDev, VOID *handle, U032 state)
{
    /* nothing to do... */
}

#endif

#ifdef SUPPORT_INTEL_AGP
BOOL 
Intel_IsChipset(PHWINFO pDev)
{
    switch (AgpInfo(pDev).AGPChipset) 
    {
        case CS_INTEL_440LX:
        case CS_INTEL_440BX:
        case CS_INTEL_440GX:
        case CS_INTEL_815:
        case CS_INTEL_820:
        case CS_INTEL_840:
        case CS_INTEL_845:
        case CS_INTEL_850:
        case CS_INTEL_860:
        case CS_INTEL_COMPAT:
            return TRUE;
    }
    return FALSE;
}

U032
Intel_GetChipset(PHWINFO pDev, U032 device)
{
    RM_STATUS status;
    U032 data32;

    switch(device)
    {
        case 0x7180:
            return CS_INTEL_440LX;
        case 0x7190:
            return CS_INTEL_440BX;
        case 0x71A0:
            return CS_INTEL_440GX;
        case 0x1130:
            return CS_INTEL_815;
        case 0x2500:          // dell poblano
            return CS_INTEL_820;
        case 0x2501:
            return CS_INTEL_820;
        case 0x1A20:
            return CS_INTEL_840;
        case 0x1A21:
            return CS_INTEL_840;
        case 0x1A22:
            return CS_INTEL_840;
        case 0x1A30:
            return CS_INTEL_845;
        case 0x2530:
            return CS_INTEL_850;
        case 0x2531:
            return CS_INTEL_860;
    }

    //
    // For this undetected chipset, check if the registry key is on to run it
    // in "compatibility mode". This allows Intel customers with new chipsets
    // to see if it'll work with our existing Intel support.
    //
    status = OS_READ_REGISTRY_DWORD(pDev, RM_REGISTRY_AGP_BASE_PATH, "UseIntelCompat", &data32);
    if ((status == RM_OK) && data32)
        return CS_INTEL_COMPAT;

    return 0;
}

static VOID Intel_EnableMappings(PHWINFO pDev, VOID *handle, U032 physaddr);
static VOID Intel_FlushMappings(PHWINFO pDev, VOID *handle);
static U032 Intel_GetAperSize(PHWINFO pDev, VOID *handle);
static U032 Intel_GetAperBase(PHWINFO pDev, VOID *handle);
static U032 Intel_GetGartSize(PHWINFO pDev, VOID *handle);
static U032 Intel_EarlyInit(PHWINFO pDev, VOID *handle);
static VOID Intel_FixupGart(PHWINFO pDev, VOID *handle, U032 physaddr);
static VOID Intel_ApplyChipsetUpdates(PHWINFO pDev, VOID *handle, U016 deviceID);
static VOID Intel_DisableChipset(PHWINFO pDev, VOID *handle);
static VOID Intel_SaveRestoreChipset(PHWINFO pDev, VOID *handle, U032 state);

VOID
Intel_SetupFuncs(U032 chipset, agp_chipset_funcs *funcs)
{
    funcs->enable_mappings     = Intel_EnableMappings;
    funcs->flush_mappings      = Intel_FlushMappings;
    funcs->get_aper_size       = Intel_GetAperSize;
    funcs->get_aper_base       = Intel_GetAperBase;
    funcs->get_gart_size       = Intel_GetGartSize;
    funcs->earlyinit           = Intel_EarlyInit;
    funcs->fixup_gart          = Intel_FixupGart;
    funcs->apply_updates       = Intel_ApplyChipsetUpdates;
    funcs->disable_chipset     = Intel_DisableChipset;
    funcs->saverestore_chipset = Intel_SaveRestoreChipset;
    funcs->initialized = 1;
    funcs->sba_capable = 0;

    /* SOLANO, CAMINO, CARMEL, TEHAMA and COLUSA are fast-write capable */
    if (chipset == CS_INTEL_820
        || chipset == CS_INTEL_840
        || chipset == CS_INTEL_850
#ifdef SOLANO_FW
        || chipset == CS_INTEL_815
#endif
        || chipset == CS_INTEL_860)
       funcs->fw_capable = 1;
    else
       funcs->fw_capable = 0;
}

static VOID
Intel_EnableMappings(PHWINFO pDev, VOID *handle, U032 physaddr)
{
    switch (AgpInfo(pDev).AGPChipset)    
    {
        case CS_INTEL_440LX:
        case CS_INTEL_440BX:
        case CS_INTEL_440GX:
            osPciWriteWord(handle, INTEL_ERRSTS, 0x07);
        /* FALLTHROUGH */
        case CS_INTEL_815:
        case CS_INTEL_820:
        case CS_INTEL_840:
        case CS_INTEL_845:
        case CS_INTEL_850:
        case CS_INTEL_860:
        case CS_INTEL_COMPAT:
            osPciWriteDword(handle, INTEL_GART_BASE, physaddr); // base of GART
            osPciOrDword(handle, INTEL_GART_CONTROL, 0x80);  // enable GTLB
            osPciOrDword(handle, INTEL_CHIPSET_CONFIG, 0x200);  // enable global access
        default:
            break;
    }
}

static VOID
Intel_FlushMappings(PHWINFO pDev, VOID *handle)
{
    // Invalidate the GTLB
    if (!handle) return;
    osPciAndDword(handle, INTEL_GART_CONTROL, ~(0x80));
    osPciOrDword(handle, INTEL_GART_CONTROL, 0x80);
}


static U032
Intel_GetAperSize(PHWINFO pDev, VOID *handle)
{
    unsigned int apsize;
    apsize = osPciReadWord(handle, INTEL_APER_SIZE); // aperture size
    switch (apsize)
    {
        case 0x3f:
            apsize = (4 * 1024 * 1024);
        break;
        case 0x3e:
            apsize = (8 * 1024 * 1024);
        break;
        case 0x3c:
            apsize = (16 * 1024 * 1024);
        break;
        case 0x38:
            apsize = (32 * 1024 * 1024);
        break;
        case 0x30:
            apsize = (64 * 1024 * 1024);
        break;
        case 0x20:
            apsize = (128 * 1024 * 1024);
        break;
        case 0x00:
            apsize = (256 * 1024 * 1024);
        break;
        default:
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: *** Intel bad apsize!\n");
            apsize = 0;
    }

    // I'm having problems under Linux if I go greater than 32 Megs...
    if (apsize > AGP_APERTURE_SIZE) 
    {
        apsize = AGP_APERTURE_SIZE;
        // XXX - translate new aperture size back to hw-encoding
        osPciWriteWord(handle, INTEL_APER_SIZE, 0x38 /* apsize */);
    }

    return apsize;
}

static U032
Intel_GetAperBase(PHWINFO pDev, VOID *handle)
{
    return osPciReadDword(handle, PCI_BASE_ADDRESS_0);
}

static U032
Intel_GetGartSize(PHWINFO pDev, VOID *handle)
{
    /* XXX - change 4 to sizeof(void *)?? */
    return ((AgpInfo(pDev).AGPLimit + RM_PAGE_SIZE) / RM_PAGE_SIZE) * 4;
}

static U032 
Intel_EarlyInit(PHWINFO pDev, VOID *handle)
{
    /* nothing to do... */
    return 1;
}

static VOID
Intel_FixupGart(PHWINFO pDev, VOID *handle, U032 physaddr)
{
    /* nothing to do... */
}

static VOID
Intel_ApplyChipsetUpdates(PHWINFO pDev, VOID *handle, U016 deviceID)
{
    U032 agp_status, agp_command;
    U032 data;
    INTERRUPT_SETUP

    // Some special Intel chipset handling
    switch (deviceID)
    {
        case 0x2500:    // Camino
        case 0x2501:
            // expose the FW capability on Camino
            osPciOrDword(handle, INTEL_GART_CONTROL, 0x2);
            break;
        case 0x7190:    // BX/ZX

            if (IsNV15(pDev) || IsNV11(pDev))
                FLD_WR_DRF_DEF(_PBUS, _DEBUG_2, _AGP_VREF, _ENABLED);

            //
            // Temporary workaround for Toshiba's motherboard that didn't
            // connect external vref.
            //
            if (IsNV11(pDev) &&
                (OS_READ_REGISTRY_DWORD(pDev, strDevNodeRM, "Mobile", &data) == RM_OK)) {
                if (data == 2) {        // equate for Toshiba
                    FLD_WR_DRF_DEF(_PBUS, _DEBUG_2, _AGP_VREF, _DISABLED);
                }
            }

            break;
        default:
            break;
    }

    //
    // Check for chipset overrides to AGP Multi-Transaction Timer or the
    // Low Priority Transaction Timer for the supported Intel chipsets.
    //
    switch (deviceID)
    {
        case 0x2500:    // Camino
        case 0x2501:
        case 0x1A20:    // Carmel
        case 0x1A21:
        case 0x1A22:
        case 0x1130:    // Solano
        case 0x2530:    // Tehama
        case 0x2531:    // Colusa
        {
            U032 amtt, lptt;
            if (OS_READ_REGISTRY_DWORD(pDev, RM_REGISTRY_AGP_BASE_PATH,
                                       "IntelAMTT", &amtt) == RM_OK) {
                if (amtt != ~0) {    // value of 0xFFFFFFFF disables the override
                    if (amtt & 0x7) {
                        DBG_PRINT_STRING(DEBUGLEVEL_WARNINGS, "NVRM: Intel AMTT not multiple of 8 clocks\n");
                    } else {
                        osPciWriteByte(handle, INTEL_MULTI_TRANS_TIMER, (U008)amtt);
                    }
                }
            }
            if (OS_READ_REGISTRY_DWORD(pDev, RM_REGISTRY_AGP_BASE_PATH,
                                       "IntelLPTT", &lptt) == RM_OK) {
                if (lptt != ~0) {    // value of 0xFFFFFFFF disables the override
                    if (lptt & 0x7) {
                        DBG_PRINT_STRING(DEBUGLEVEL_WARNINGS, "NVRM: Intel LPTT not multiple of 8 clocks\n");
                    } else {
                        osPciWriteByte(handle, INTEL_LOW_PRI_TRANS_TIMER, (U008)lptt);
                    }
                }
            }
            break;
        }
        default:
            break;
    }

#ifdef LINUX
    {
        unsigned int support_fw;
        if ( (OS_READ_REGISTRY_DWORD(pDev, RM_REGISTRY_AGP_BASE_PATH, 
                                     "EnableAGPFW", &support_fw) != RM_OK) ||
             (support_fw == 0))
        {
            return;
        }
    }
#endif

    // First, check if this chipset is FW capable
    if (!agp_current->fw_capable)
        return;

    // Also, check if we're FW capable
    if (REG_RD_DRF(_PBUS, _PCI_NV_18, _AGP_STATUS_FW) == NV_PBUS_PCI_NV_18_AGP_STATUS_FW_NONE)
        return;

    // Finally, check if this chipset is strapped for fastwrites.
    agp_status = osPciReadDword(handle, AGP_STATUS);
#ifdef SOLANO_FW
    // Solano lies about no FW support (so, ignore their strapping)
    if (((agp_status & 0x10) == 0) &&
        (Intel_GetChipset(pDev, deviceID) != CS_INTEL_815))
        return;
#else
    // AGP fastwrites aren't supported on this chipset
    if ((agp_status & 0x10) == 0)
        return;
#endif

    osDisableHardwareInterrupts(pDev);

    // enable AGP fastwrites for both us and the chipset
    agp_command  = osPciReadDword(handle, AGP_COMMAND);
    agp_command |= DRF_DEF(_PBUS, _PCI_NV_19, _AGP_COMMAND_FW_ENABLE, _ON);

    FLD_WR_DRF_DEF(_PBUS, _PCI_NV_19, _AGP_COMMAND_FW_ENABLE, _ON);
    osPciWriteDword(handle, AGP_COMMAND, agp_command);

    osEnableHardwareInterrupts(pDev);
}

static VOID
Intel_DisableChipset(PHWINFO pDev, VOID *handle)
{
    unsigned int agp_command;
    INTERRUPT_SETUP

    agp_command  = osPciReadDword(handle, AGP_COMMAND);

    /* if fast-writes aren't enabled, exit */
    if ( !(agp_command & 0x10) ) return;

    agp_command &= ~(DRF_DEF(_PBUS, _PCI_NV_19, _AGP_COMMAND_FW_ENABLE, _ON));

    osDisableHardwareInterrupts(pDev);

    // disable AGP fastwrites for both us and the chipset
    FLD_WR_DRF_DEF(_PBUS, _PCI_NV_19, _AGP_COMMAND_FW_ENABLE, _OFF);
    osPciWriteDword(handle, AGP_COMMAND, agp_command);

    osEnableHardwareInterrupts(pDev);
}

static VOID
Intel_SaveRestoreChipset(PHWINFO pDev, VOID *handle, U032 state)
{
    /* nothing to do... */
}
#endif

#ifdef SUPPORT_VIA_AGP

/* XXX hack alert!! */
static unsigned int via_base = 0;

BOOL 
Via_IsChipset(PHWINFO pDev)
{
    switch (AgpInfo(pDev).AGPChipset) {
        case CS_VIA_8371:
        case CS_VIA_82C694X:
        case CS_VIA_KT133:
            return TRUE;
    }
    return FALSE;
}

U032
Via_GetChipset(PHWINFO pDev, U032 device)
{
    // The spec for the 8371 chipset claims it has a device ID
    // of 0x691, but the version we looked at returned 0x391.
    // This also happens to be the device ID for the 82C694X
    // chipset, so we'll be OK regardless.
    switch(device)
    {
        case 0x0691:
            return CS_VIA_8371;
        case 0x0391:
            return CS_VIA_82C694X;
        case 0x0305:
            return CS_VIA_KT133;
    }
    return 0;
}

static VOID Via_EnableMappings(PHWINFO pDev, VOID *handle, U032 physaddr);
static VOID Via_FlushMappings(PHWINFO pDev, VOID *handle);
static U032 Via_GetAperSize(PHWINFO pDev, VOID *handle);
static U032 Via_GetAperBase(PHWINFO pDev, VOID *handle);
static U032 Via_GetGartSize(PHWINFO pDev, VOID *handle);
static U032 Via_EarlyInit(PHWINFO pDev, VOID *handle);
static VOID Via_FixupGart(PHWINFO pDev, VOID *handle, U032 physaddr);
static VOID Via_ApplyChipsetUpdates(PHWINFO pDev, VOID *handle, U016 deviceID);
static VOID Via_DisableChipset(PHWINFO pDev, VOID *handle);
static VOID Via_SaveRestoreChipset(PHWINFO pDev, VOID *handle, U032 state);

VOID
Via_SetupFuncs(U032 chipset, agp_chipset_funcs *funcs)
{
    funcs->enable_mappings     = Via_EnableMappings;
    funcs->flush_mappings      = Via_FlushMappings;
    funcs->get_aper_size       = Via_GetAperSize;
    funcs->get_aper_base       = Via_GetAperBase;
    funcs->get_gart_size       = Via_GetGartSize;
    funcs->earlyinit           = Via_EarlyInit;
    funcs->fixup_gart          = Via_FixupGart;
    funcs->apply_updates       = Via_ApplyChipsetUpdates;
    funcs->disable_chipset     = Via_DisableChipset;
    funcs->saverestore_chipset = Via_SaveRestoreChipset;
    funcs->initialized = 1;
    funcs->fw_capable = 0;
    funcs->sba_capable = 0;
}

static VOID
Via_EnableMappings(PHWINFO pDev, VOID *handle, U032 physaddr)
{
    switch (AgpInfo(pDev).AGPChipset)    
    { 
        case CS_VIA_8371:
        case CS_VIA_82C694X:
        case CS_VIA_KT133:
            // enable global access 
            osPciOrDword(handle, VIA_GART_BASE, physaddr | 0x2);
            // enable GA address translation
            osPciOrDword(handle, VIA_GART_CONTROL, 0xf);
            break;
        default:
            break;
    }
}

static VOID
Via_FlushMappings(PHWINFO pDev, VOID *handle)
{
    if (!handle) return;
    osPciOrDword(handle, VIA_GART_CONTROL, 0x80);       // enable TLB flush
    osPciAndDword(handle, VIA_GART_CONTROL, ~(0x80));   // disable TLB flush
}


/* XXX 
 * I'm unsure if there is a BIOS-default size here, the docs seem
 * to indicate it defaults to 0, so we'll see
 */
static U032
Via_GetAperSize(PHWINFO pDev, VOID *handle)
{
    unsigned int apsize = 0;
    apsize = osPciReadDword(handle, VIA_APER_SIZE);

    switch (apsize)
    {
        case 0xff:
            apsize =   1 * 1024 * 1024; /*   1 Meg */
            break;
        case 0xfe:
            apsize =   2 * 1024 * 1024; /*   2 Meg */
            break;
        case 0xfc:
            apsize =   4 * 1024 * 1024; /*   4 Meg */
            break;
        case 0xf8:
            apsize =   8 * 1024 * 1024; /*   8 Meg */
            break;
        case 0xf0:
            apsize =  16 * 1024 * 1024; /*  16 Meg */
            break;
        case 0xe0:
            apsize =  32 * 1024 * 1024; /*  32 Meg */
            break;
        case 0xc0:
            apsize =  64 * 1024 * 1024; /*  64 Meg */
            break;
        case 0x80:
            apsize = 128 * 1024 * 1024; /* 128 Meg */
            break;
        case 0x00:
            apsize = 256 * 1024 * 1024; /* 256 Meg */
            break;
        default:
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: *** VIA bad apsize!\n");
        apsize = 0;
    }

#if 1
    // I'm having problems under Linux if I go greater than 32 Megs...
    if (apsize > AGP_APERTURE_SIZE) 
    {
        apsize = AGP_APERTURE_SIZE;
        // XXX - translate new aperture size back to hw-encoding
        osPciWriteWord(handle, VIA_APER_SIZE, 0xe0 /* apsize */);
    }
#endif

    return apsize;
}

static U032
Via_GetAperBase(PHWINFO pDev, VOID *handle)
{
    if (!via_base)
        via_base = osPciReadDword(handle, PCI_BASE_ADDRESS_0);
    return via_base;
}

static U032
Via_GetGartSize(PHWINFO pDev, VOID *handle)
{
    /* XXX - change 4 to sizeof(void *)?? */
    return ((AgpInfo(pDev).AGPLimit + RM_PAGE_SIZE) / RM_PAGE_SIZE) * 4;
}

static U032 
Via_EarlyInit(PHWINFO pDev, VOID *handle)
{
    /* nothing to do... */
    return 1;
}

static VOID
Via_FixupGart(PHWINFO pDev, VOID *handle, U032 physaddr)
{
    /* nothing to do... */
}

static VOID
Via_ApplyChipsetUpdates(PHWINFO pDev, VOID *handle, U016 deviceID)
{
    U032 agp_status, agp_command, gart_control;
    INTERRUPT_SETUP

    //
    // First, determine the real ID of the chipset.
    //
    // Via, in some cases, has been using the Apollo 694x device ID with
    // the KX133 and KT133, and since we're not treating them the same
    // anymore, we need to get the real ID.
    //
    if (deviceID == 0x691)
    {
        U008 backdoor1;

        // disable the Back-Door Device ID Enable bit
        backdoor1  = osPciReadByte(handle, 0xFC);
        osPciWriteByte(handle, 0xFC, (U008)(backdoor1 & ~0x1));

        // reread the deviceID
        deviceID = (U016)(osPciReadDword(handle, 0x0) >> 16);

        // restore the Back-Door control byte
        osPciWriteByte(handle, 0xFC, backdoor1);
    }

    // return, if it's not a 694x, KX133 or KT133
    if ((deviceID != 0x691) && (deviceID != 0x391) && (deviceID != 0x305))
        return;

    //
    // Workaround for a Via chipset driver in WinME that forgot to reenable
    // this bit on the way back from hibernation. This is fixed in the latest
    // Via chipset driver, but just to be safe, leave it in for now.
    //
    gart_control = osPciReadDword(handle, 0x80);
    gart_control |= 0x2;
    osPciWriteDword(handle, 0x80, gart_control);

    if (IsNV10orBetter(pDev))
    {
        //
        // Set Via's AGP Read Synchronization bit which fixes a coherency
        // problem on their chipset (applies to NV10 and later chips).
        //
        osPciOrByte(handle, VIA_AGP_CONTROL /* 0xAC */, 0x40);
    }

    // 
    // If AGP FW's are already enabled (as part of normal chipset driver
    // configuration) avoid trying to change the AGP rate, since this can
    // cause a hang.
    //
    if (REG_RD_DRF(_PBUS, _PCI_NV_19, _AGP_COMMAND_FW_ENABLE) ==
        NV_PBUS_PCI_NV_19_AGP_COMMAND_FW_ENABLE_ON)
        return;

    //
    // Only the Apollo Pro133 (Via694x) should be dropped down from 4x to 2x
    //
    if (deviceID == 0x691)
    {
        // check if we're currently in AGP 4x mode
        agp_command = osPciReadDword(handle, AGP_COMMAND);
        if (DRF_VAL(_PBUS, _PCI_NV_19, _AGP_COMMAND_DATA_RATE, agp_command) == NV_PBUS_PCI_NV_19_AGP_COMMAND_DATA_RATE_4X)
        {
            U032 data32;
            RM_STATUS status;

            // check if there's a registry override to stay at AGP 4x
            status = OS_READ_REGISTRY_DWORD(pDev, RM_REGISTRY_AGP_BASE_PATH, "EnableVia4x", &data32);
            if ( (status != RM_OK) || (data32 == 0) )
            {
                U008 agp_misc;

                // no override, so we'll go to AGP 2x mode
                agp_command &= ~0xF;    // clear the old AGP rate
                agp_command |= DRF_DEF(_PBUS, _PCI_NV_19, _AGP_COMMAND_DATA_RATE, _2X);
                osPciWriteDword(handle, AGP_COMMAND, agp_command);

                FLD_WR_DRF_DEF(_PBUS, _PCI_NV_19, _AGP_COMMAND_DATA_RATE, _2X);

                // 
                // In addition to changing AGPCMD, also change AGPSTATUS to disable 4x
                // in case there's another module that tries to put us back in that mode.
                //
                agp_misc  = osPciReadByte(handle, 0xAE);
                agp_misc &= 0xFB;    // clear 4x enable
                osPciWriteByte(handle, 0xAE, agp_misc);

                // clear our 4x enable
                FLD_WR_DRF_DEF(_PEXTDEV, _BOOT_0, _STRAP_OVERWRITE, _ENABLED);
                FLD_WR_DRF_DEF(_PEXTDEV, _BOOT_0, _STRAP_AGP_4X,    _DISABLED);
            }
        }
    }

#ifdef LINUX
    {
        unsigned int support_fw;
        if ( (OS_READ_REGISTRY_DWORD(pDev, RM_REGISTRY_AGP_BASE_PATH, 
                                     "EnableAGPFW", &support_fw) != RM_OK) ||
             (support_fw == 0))
        {
            return;
        }
    }
#endif

    // check if we're FW capable
    if (REG_RD_DRF(_PBUS, _PCI_NV_18, _AGP_STATUS_FW) == NV_PBUS_PCI_NV_18_AGP_STATUS_FW_NONE)
        return;

    // check if Via is strapped for FW
    agp_status = osPciReadDword(handle, AGP_STATUS /* 0xA4 */);
    if (DRF_VAL(_PBUS, _PCI_NV_18, _AGP_STATUS_FW, agp_status) == NV_PBUS_PCI_NV_18_AGP_STATUS_FW_NONE)
        return;
    
    osDisableHardwareInterrupts(pDev);

    // enable AGP fastwrites for both us and the chipset
    agp_command  = osPciReadDword(handle, AGP_COMMAND);
    agp_command |= DRF_DEF(_PBUS, _PCI_NV_19, _AGP_COMMAND_FW_ENABLE, _ON);

    FLD_WR_DRF_DEF(_PBUS, _PCI_NV_19, _AGP_COMMAND_FW_ENABLE, _ON);
    osPciWriteDword(handle, AGP_COMMAND, agp_command);
    
    osEnableHardwareInterrupts(pDev);
}

static VOID
Via_DisableChipset(PHWINFO pDev, VOID *handle)
{
    switch (AgpInfo(pDev).AGPChipset)    
    { 
        case CS_VIA_8371:
        case CS_VIA_82C694X:
        case CS_VIA_KT133:
            // enable global access 
            osPciWriteDword(handle, VIA_GART_BASE, 0x0);
            // enable GA address translation
            // osPciAndDword(handle, VIA_GART_CONTROL, ~(0xf));
            // restore aperture size
            // XXX hack, need to translate this mapping from stored value!!
            osPciWriteWord(handle, VIA_APER_SIZE, 0xe0 /* apsize */);
            break;
        default:
            break;
    }
}

static VOID
Via_SaveRestoreChipset(PHWINFO pDev, VOID *handle, U032 state)
{
    /* nothing to do... */
}
#endif

#ifdef SUPPORT_RCC_AGP

BOOL 
RCC_IsChipset(PHWINFO pDev)
{
    switch (AgpInfo(pDev).AGPChipset) 
    {
        case CS_RCC_6585HE:
            return TRUE;
    }
    return FALSE;
}

U032
RCC_GetChipset(PHWINFO pDev, U032 device)
{
    switch(device)
    {
        case 0x0005:
        case 0x0009:
            return CS_RCC_6585HE;
    }
    return 0;
}

static VOID RCC_EnableMappings(PHWINFO pDev, VOID *handle, U032 physaddr);
static VOID RCC_FlushMappings(PHWINFO pDev, VOID *handle);
static U032 RCC_GetAperSize(PHWINFO pDev, VOID *handle);
static U032 RCC_GetAperBase(PHWINFO pDev, VOID *handle);
static U032 RCC_GetGartSize(PHWINFO pDev, VOID *handle);
static U032 RCC_EarlyInit(PHWINFO pDev, VOID *handle);
static VOID RCC_FixupGart(PHWINFO pDev, VOID *handle, U032 physaddr);
static VOID RCC_ApplyChipsetUpdates(PHWINFO pDev, VOID *handle, U016 deviceID);
static VOID RCC_DisableChipset(PHWINFO pDev, VOID *handle);
static VOID RCC_FlushPostedWriteBuffer(PHWINFO pDev);
static VOID RCC_SaveRestoreChipset(PHWINFO pDev, VOID *handle, U032 state);

VOID
RCC_SetupFuncs(U032 chipset, agp_chipset_funcs *funcs)
{
    funcs->enable_mappings     = RCC_EnableMappings;
    funcs->flush_mappings      = RCC_FlushMappings;
    funcs->get_aper_size       = RCC_GetAperSize;
    funcs->get_aper_base       = RCC_GetAperBase;
    funcs->get_gart_size       = RCC_GetGartSize;
    funcs->earlyinit           = RCC_EarlyInit;
    funcs->fixup_gart          = RCC_FixupGart;
    funcs->apply_updates       = RCC_ApplyChipsetUpdates;
    funcs->disable_chipset     = RCC_DisableChipset;
    funcs->saverestore_chipset = RCC_SaveRestoreChipset;
    funcs->initialized = 1;
    funcs->fw_capable = 0;
    funcs->sba_capable = 0;
}

static VOID
RCC_EnableMappings(PHWINFO pDev, VOID *handle, U032 physaddr)
{
    volatile U032 *ccr;    // cache control register

    switch (AgpInfo(pDev).AGPChipset)    
    {
        case CS_RCC_6585HE:

            // enable GART cache and error reporting 
            ((unsigned char*)AgpInfo(pDev).AGPChipsetMapping)[0x2] |= 0x9;
            
            // invalidate the caches before we start (and poll until it's done)
            ccr = &((U032 *)AgpInfo(pDev).AGPChipsetMapping)[0x3];
            *ccr |= 0x1;
            while ((*ccr & 0x1) != 0)
                ;

            // set the base of GART
            ((unsigned int*)AgpInfo(pDev).AGPChipsetMapping)[0x1] = physaddr;

            // set the global AGP enable bit
            osPciOrByte(handle, RCC_APER_SIZE, 0x1);
            break;

        default:
            break;
    }
}

static VOID
RCC_FlushMappings(PHWINFO pDev, VOID *handle)
{
    volatile U008 *ccr;    // cache control register

    //
    // We could invalidate individual entries, but for starters, just
    // invalidate the whole cache (and poll until it's done).
    //
    ccr = &((U008 *)AgpInfo(pDev).AGPChipsetMapping)[0xC];
    *ccr |= 0x1;
    while ((*ccr & 0x1) != 0)
        ;
}

static U032
RCC_GetAperSize(PHWINFO pDev, VOID *handle)
{
    unsigned int apsize = osPciReadWord(handle, RCC_APER_SIZE); // aperture size
    switch ( (apsize & 0xE) >> 1 )   /* mask and shift bits 1-3 */
    {
        case 0x00:
            apsize = (  32 * 1024 * 1024);
        break;
        case 0x01:
            apsize = (  64 * 1024 * 1024);
        break;
        case 0x02:
            apsize = ( 128 * 1024 * 1024);
        break;
        case 0x03:
            apsize = ( 256 * 1024 * 1024);
        break;
        case 0x04:
            apsize = ( 512 * 1024 * 1024);
        break;
        case 0x05:
            apsize = (1024 * 1024 * 1024);
        break;
        case 0x06:
            apsize = (2024 * 1024 * 1024);
        break;
        default:
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: *** Intel bad apsize!\n");
            apsize = 0;
    }

#if 1
    // I'm having problems under Linux if I go greater than 32 Megs...
    if (apsize > AGP_APERTURE_SIZE) 
    {
        apsize = AGP_APERTURE_SIZE;
        // XXX - translate new aperture size back to hw-encoding
        osPciAndWord(handle, RCC_APER_SIZE, ~(0xe) /* apsize */);
    }
#endif

    return apsize;
}

static U032
RCC_GetAperBase(PHWINFO pDev, VOID *handle)
{
    VOID *handle_func0;
    U016 vendorID, deviceID;

    //
    // Note, for RCC the handle is for func 1, but BAR0/BAR1 are in func 0
    // space, so we have to temporarily generate a func 0 handle.
    //
    handle_func0 = osPciInitHandle(AgpInfo(pDev).NBAddr.bus,
                                   AgpInfo(pDev).NBAddr.device,
                                   0x0,            // func 0
                                   &vendorID, &deviceID);

    return osPciReadDword(handle_func0, PCI_BASE_ADDRESS_0);
}

static U032
RCC_GetGartSize(PHWINFO pDev, VOID *handle)
{
    unsigned int gart_size;
    gart_size = ((AgpInfo(pDev).AGPLimit + RM_PAGE_SIZE - 1) / RM_PAGE_SIZE) * 4;
    gart_size += RM_PAGE_SIZE;     // this is for the 1st-level lookup
    return gart_size;
}

static U032 
RCC_EarlyInit(PHWINFO pDev, VOID *handle)
{
    VOID *handle_func0;
    U032 physaddr;
    U016 vendorID, deviceID;

    if (AgpInfo(pDev).AGPChipset != CS_RCC_6585HE)
        return 1;

    //
    // Note, for RCC the handle is for func 1, but BAR0/BAR1 are in func 0
    // space, so we have to temporarily generate a func 0 handle.
    //
    handle_func0 = osPciInitHandle(AgpInfo(pDev).NBAddr.bus,
                                   AgpInfo(pDev).NBAddr.device,
                                   0x0,            // func 0
                                   &vendorID, &deviceID);

    // The RCC chipset registers, like AMD are mapped at BAR1.
    physaddr = (osPciReadDword(handle_func0, PCI_BASE_ADDRESS_1) & ~RM_PAGE_MASK);
    AgpInfo(pDev).AGPChipsetMapping = (VOID_PTR)osMapKernelSpace(physaddr,
                                                                 RM_PAGE_SIZE,
                                                                 MAP_UNCACHED);
    if (AgpInfo(pDev).AGPChipsetMapping == (VOID_PTR)NULL)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, 
        "NVRM: *** Failed to map RCC 6585HE's AGP chipset registers\n");
        return 0;
    }

    //
    // For RCC2.2, we need to enable the IO-instruction-at-PUT-update
    // war in the ogl driver to remedy a write buffer flush problem.
    //
    // Assuming Processor.Type has already gone thru RmInitCpuInfo.
    //
    // Bridge Revision Register is at offset 0x8.
    //
    if (osPciReadByte(handle_func0, 0x8) == 0x22)
    {
        PRMINFO pRmInfo = (PRMINFO)pDev->pRmInfo;

        pRmInfo->Processor.Type |= NV_CPU_FUNC_PUT_NEEDS_IO;
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: RCC2.2 workaround enabled\n");
    }

    return 1;
}

static VOID
RCC_FixupGart(PHWINFO pDev, VOID *handle, U032 physaddr)
{
    U032 i, *baseptr, tableptr;

    //
    // Convert the first allocated GART page into the first level GART lookup,
    // where each GART directory entry is just the subsequent 4k page.
    // We can derive the following entries, because we know the pages are
    // contiguous.
    //
    baseptr  = (U032 *)AgpInfo(pDev).AGPGartBase;
    tableptr = physaddr + RM_PAGE_SIZE;    // GART directory entries start on the 2nd page

    for (i = 0; i < ((AgpInfo(pDev).AGPLimit + 1) / BYTES_MAPPED_PER_PAGE); i++)
    {
        *baseptr = tableptr;

        tableptr += RM_PAGE_SIZE;   // next phys GART table address
        baseptr++;                  // next GART directory entry
    }
        
    //
    // Move the AGPGartBase past the first level GART page to where the GART
    // tables really begin (this makes nvagp_LoadGARTEntries() common).
    //
    (U008 *)AgpInfo(pDev).AGPGartBase += RM_PAGE_SIZE;
}

static VOID
RCC_ApplyChipsetUpdates(PHWINFO pDev, VOID *handle, U016 deviceID)
{
    U032 data32, agp_command;
    RM_STATUS status;

    //
    // SGI has requested enabling sidebanding on the RCC chipset
    // the installer will install an sgi/rcc/sba flag to enable sba,
    // but we need to recognize we're on an actual rcc chipset before
    // enabling sba. if we're here, we're on an actual rcc chipset, 
    // so check for the key and enable things...
    //
    status = OS_READ_REGISTRY_DWORD(pDev, RM_REGISTRY_AGP_BASE_PATH,
                                            "EnableRccSBA", &data32);
    if ( (status == RM_OK) && (data32 == 1) )
    {
        // set the overwrite bit and change our SBA strapping
        FLD_WR_DRF_DEF(_PEXTDEV, _BOOT_0, _STRAP_OVERWRITE, _ENABLED);
        FLD_WR_DRF_DEF(_PEXTDEV, _BOOT_0, _STRAP_AGP_SBA,   _ENABLED);

        // set chipset's SBA enable bit
        agp_command  = osPciReadDword(handle, AGP_COMMAND);
        agp_command |= DRF_DEF(_PBUS, _PCI_NV_19, _AGP_COMMAND_SBA_ENABLE, _ON);
        osPciWriteDword(handle, AGP_COMMAND, agp_command);

        // set our SBA enable bit
        FLD_WR_DRF_DEF(_PBUS, _PCI_NV_19, _AGP_COMMAND_SBA_ENABLE, _ON);
    }

    return;
}

static VOID
RCC_DisableChipset(PHWINFO pDev, VOID *handle)
{

    // paranoia
    if (!AgpInfo(pDev).AGPChipsetMapping)
        return;

    // enable GART directory cache
    // nv_printf("disabling GART directory cache\n");
    // osPciOrWord(handle, PCI_DEVICE_SPECIFIC + 0x72, 0x2);

    // enable GART table cache and errors
    ((unsigned char*)AgpInfo(pDev).AGPChipsetMapping)[0x2] &= ~(0x9);

    // base of GART
    ((unsigned int*)AgpInfo(pDev).AGPChipsetMapping)[0x1] = 0x0;

    // unmap RCC AGP registers
    osUnmapKernelSpace((void *) AgpInfo(pDev).AGPChipsetMapping, RM_PAGE_SIZE);
}

static VOID
RCC_FlushPostedWriteBuffer(PHWINFO pDev)
{
    volatile U008 *pwbcr;    // posted writebuffer control register

    // flush the write buffer and wait until it's completed
    pwbcr = &((U008 *)AgpInfo(pDev).AGPChipsetMapping)[0x14];
    *pwbcr |= 0x1;
    while ((*pwbcr & 0x1) != 0)
        ;
}

static VOID
RCC_SaveRestoreChipset(PHWINFO pDev, VOID *handle, U032 state)
{
    U032 * AGPChipsetMapping;

    AGPChipsetMapping = (U032 *)AgpInfo(pDev).AGPChipsetMapping;
    if (!AGPChipsetMapping)
    {
        VOID *handle_func0;
        U032 physaddr;
        U016 vendorID, deviceID;

        //
        // Note, for RCC the handle is for func 1, but BAR0/BAR1 are in func 0
        // space, so we have to temporarily generate a func 0 handle.
        //
        handle_func0 = osPciInitHandle(AgpInfo(pDev).NBAddr.bus,
                                       AgpInfo(pDev).NBAddr.device,
                                       0x0,            // func 0
                                       &vendorID, &deviceID);

        // The RCC chipset registers, like AMD are mapped at BAR1.
        physaddr = (osPciReadDword(handle_func0, PCI_BASE_ADDRESS_1) & ~RM_PAGE_MASK);
        AGPChipsetMapping = (U032 *)osMapKernelSpace(physaddr, RM_PAGE_SIZE, MAP_UNCACHED);
    }
    if (AGPChipsetMapping)
    {
        switch (state)
        {
            case MC_POWER_LEVEL_0: // Restore (i.e. power on)
                //
                // Restore chipset registers saved off earlier.
                // NOTE: Only if the chipset AGP GART Table address register is zero
                //       AND our saved version is non-zero
                // 
                if ((!AGPChipsetMapping[0x1])
                 && (AgpInfo(pDev).AGPRegisterSave[1]))
                {
                    AGPChipsetMapping[0x0] = AgpInfo(pDev).AGPRegisterSave[0];
                    AGPChipsetMapping[0x1] = AgpInfo(pDev).AGPRegisterSave[1];
                    AGPChipsetMapping[0x2] = AgpInfo(pDev).AGPRegisterSave[2];
                    AGPChipsetMapping[0x3] = AgpInfo(pDev).AGPRegisterSave[3];
                    AGPChipsetMapping[0x4] = AgpInfo(pDev).AGPRegisterSave[4];
                    AGPChipsetMapping[0x5] = AgpInfo(pDev).AGPRegisterSave[5];
                    AGPChipsetMapping[0x6] = AgpInfo(pDev).AGPRegisterSave[6];
                    AGPChipsetMapping[0x7] = AgpInfo(pDev).AGPRegisterSave[7];
                    AGPChipsetMapping[0x8] = AgpInfo(pDev).AGPRegisterSave[8];
                    AGPChipsetMapping[0x9] = AgpInfo(pDev).AGPRegisterSave[9];
                }
                break;
            case MC_POWER_LEVEL_7: // Save (i.e. hibernate)
                //
                // Save off the AGP Config registers for possible restore later.
                //
                AgpInfo(pDev).AGPRegisterSave[0] = AGPChipsetMapping[0x0];
                AgpInfo(pDev).AGPRegisterSave[1] = AGPChipsetMapping[0x1];
                AgpInfo(pDev).AGPRegisterSave[2] = AGPChipsetMapping[0x2];
                AgpInfo(pDev).AGPRegisterSave[3] = AGPChipsetMapping[0x3];
                AgpInfo(pDev).AGPRegisterSave[4] = AGPChipsetMapping[0x4];
                AgpInfo(pDev).AGPRegisterSave[5] = AGPChipsetMapping[0x5];
                AgpInfo(pDev).AGPRegisterSave[6] = AGPChipsetMapping[0x6];
                AgpInfo(pDev).AGPRegisterSave[7] = AGPChipsetMapping[0x7];
                AgpInfo(pDev).AGPRegisterSave[8] = AGPChipsetMapping[0x8];
                AgpInfo(pDev).AGPRegisterSave[9] = AGPChipsetMapping[0x9];
                break;
        }
        //
        // unmap RCC AGP registers only if the mapping was done in this routine.
        //
        if (!AgpInfo(pDev).AGPChipsetMapping)
            osUnmapKernelSpace((void *)AGPChipsetMapping, RM_PAGE_SIZE);
    }
}
#endif

#ifdef SUPPORT_MICRON_AGP
BOOL 
Micron_IsChipset(PHWINFO pDev)
{
    switch (AgpInfo(pDev).AGPChipset) 
    {
        case CS_MICRON_SAMDDR:
        case CS_MICRON_SCIDDR:
            return TRUE;
    }
    return FALSE;
}

U032
Micron_GetChipset(PHWINFO pDev, U032 device)
{
    switch(device)
    {
        case 0x3120:
            return CS_MICRON_SAMDDR;
        case 0x3200:
            return CS_MICRON_SCIDDR;
    }

    return 0;
}

static VOID Micron_EnableMappings(PHWINFO pDev, VOID *handle, U032 physaddr);
static VOID Micron_FlushMappings(PHWINFO pDev, VOID *handle);
static U032 Micron_GetAperSize(PHWINFO pDev, VOID *handle);
static U032 Micron_GetAperBase(PHWINFO pDev, VOID *handle);
static U032 Micron_GetGartSize(PHWINFO pDev, VOID *handle);
static U032 Micron_EarlyInit(PHWINFO pDev, VOID *handle);
static VOID Micron_FixupGart(PHWINFO pDev, VOID *handle, U032 physaddr);
static VOID Micron_ApplyChipsetUpdates(PHWINFO pDev, VOID *handle, U016 deviceID);
static VOID Micron_DisableChipset(PHWINFO pDev, VOID *handle);
static VOID Micron_SaveRestoreChipset(PHWINFO pDev, VOID *handle, U032 state);

VOID
Micron_SetupFuncs(U032 chipset, agp_chipset_funcs *funcs)
{
    funcs->enable_mappings     = Micron_EnableMappings;
    funcs->flush_mappings      = Micron_FlushMappings;
    funcs->get_aper_size       = Micron_GetAperSize;
    funcs->get_aper_base       = Micron_GetAperBase;
    funcs->get_gart_size       = Micron_GetGartSize;
    funcs->earlyinit           = Micron_EarlyInit;
    funcs->fixup_gart          = Micron_FixupGart;
    funcs->apply_updates       = Micron_ApplyChipsetUpdates;
    funcs->disable_chipset     = Micron_DisableChipset;
    funcs->saverestore_chipset = Micron_SaveRestoreChipset;
    funcs->initialized = 1;
    funcs->sba_capable = 0;
}

static VOID
Micron_EnableMappings(PHWINFO pDev, VOID *handle, U032 physaddr)
{
    switch (AgpInfo(pDev).AGPChipset)    
    {
        case CS_MICRON_SAMDDR:
        case CS_MICRON_SCIDDR:
            osPciWriteDword(handle, INTEL_GART_BASE, physaddr); // base of GART
            osPciOrDword(handle,    INTEL_GART_CONTROL, 0x80);  // enable GTLB
            osPciOrDword(handle,    INTEL_CHIPSET_CONFIG, 0x08);  // enable global access
        default:
            break;
    }
}

static VOID
Micron_FlushMappings(PHWINFO pDev, VOID *handle)
{
    // Invalidate the GTLB
    if (!handle)
        return;
    osPciAndDword(handle, INTEL_GART_CONTROL, ~(0x80));
    osPciOrDword(handle,  INTEL_GART_CONTROL, 0x80);
}


static U032
Micron_GetAperSize(PHWINFO pDev, VOID *handle)
{
    unsigned int apsize;
    apsize = osPciReadWord(handle, INTEL_APER_SIZE); // aperture size
    switch (apsize)
    {
        case 0x3f:
            apsize = (4 * 1024 * 1024);
        break;
        case 0x3e:
            apsize = (8 * 1024 * 1024);
        break;
        case 0x3c:
            apsize = (16 * 1024 * 1024);
        break;
        case 0x38:
            apsize = (32 * 1024 * 1024);
        break;
        case 0x30:
            apsize = (64 * 1024 * 1024);
        break;
        case 0x20:
            apsize = (128 * 1024 * 1024);
        break;
        case 0x00:
            apsize = (256 * 1024 * 1024);
        break;
        default:
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: *** Intel bad apsize!\n");
            apsize = 0;
    }

    // I'm having problems under Linux if I go greater than 32 Megs...
    if (apsize > AGP_APERTURE_SIZE) 
    {
        apsize = AGP_APERTURE_SIZE;
        // XXX - translate new aperture size back to hw-encoding
        osPciWriteWord(handle, INTEL_APER_SIZE, 0x38 /* apsize */);
    }
    return apsize;
}

static U032
Micron_GetAperBase(PHWINFO pDev, VOID *handle)
{
    return osPciReadDword(handle, PCI_BASE_ADDRESS_0);
}

static U032
Micron_GetGartSize(PHWINFO pDev, VOID *handle)
{
    /* XXX - change 4 to sizeof(void *)?? */
    return ((AgpInfo(pDev).AGPLimit + RM_PAGE_SIZE) / RM_PAGE_SIZE) * 4;
}

static U032 
Micron_EarlyInit(PHWINFO pDev, VOID *handle)
{
    /* nothing to do... */
    return 1;
}

static VOID
Micron_FixupGart(PHWINFO pDev, VOID *handle, U032 physaddr)
{
    /* nothing to do... */
}

static VOID
Micron_ApplyChipsetUpdates(PHWINFO pDev, VOID *handle, U016 deviceID)
{
    /* nothing to do... */
}

static VOID
Micron_DisableChipset(PHWINFO pDev, VOID *handle)
{
    /* nothing to do... */
}

static VOID
Micron_SaveRestoreChipset(PHWINFO pDev, VOID *handle, U032 state)
{
    /* nothing to do... */
}
#endif


// END OF CHIPSET-SPECIFIC CODE
// the rest of this file is generic AGP support

//
// Determine which chipset we're using (from available options)
// and initialize chipset-specific functions
//
RM_STATUS
NvInitChipset(PHWINFO pDev, VOID **handle, U032 *chipset)
{
    U016 vendor_id, device_id;

    AGP_SELECT_DEVICE(*handle, &vendor_id, &device_id);
    if (!*handle) {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: *** Unable to get PCI handle\n");
        return RM_ERR_OPERATING_SYSTEM;
    }

#ifdef SUPPORT_INTEL_AGP
    // Check Intel ...
    if (vendor_id == PCI_VENDOR_ID_INTEL)
    {
        *chipset = Intel_GetChipset(pDev, device_id);
        Intel_SetupFuncs(*chipset, agp_current);
    }
#endif

#ifdef SUPPORT_AMD_AGP
    // Check AMD ...
    if (vendor_id == PCI_VENDOR_ID_AMD)
    {
        *chipset = AMD_GetChipset(pDev, device_id);
        AMD_SetupFuncs(*chipset, agp_current);
    }
#endif

#ifdef SUPPORT_VIA_AGP
    // Check Via ...
    if (vendor_id == PCI_VENDOR_ID_VIA)
    {
        *chipset = Via_GetChipset(pDev, device_id);
        Via_SetupFuncs(*chipset, agp_current);
    }
#endif

#ifdef SUPPORT_RCC_AGP
    // Check RCC/ServerWorks ...
    if (vendor_id == PCI_VENDOR_ID_RCC)
    {
        *chipset = RCC_GetChipset(pDev, device_id);
        RCC_SetupFuncs(*chipset, agp_current);
    }
#endif
#ifdef SUPPORT_MICRON_AGP
    // Check Micron ...
    if ((vendor_id == PCI_VENDOR_ID_MICRON_1) ||
        (vendor_id == PCI_VENDOR_ID_MICRON_2))
    {
        *chipset = Micron_GetChipset(pDev, device_id);
        Micron_SetupFuncs(*chipset, agp_current);
    }
#endif

    //
    // Set the AGP Cap offset.
    // By offsetting to get to the chipset's AGP_STATUS/AGP_COMMAND, more common
    // code is used, since accessing these registers is now chipset independent.
    // 
    NvSetCapIDOffset(pDev, *handle, &AgpInfo(pDev).AGPCapPtr);
    return RM_OK;
}


//
// If the AGP chipset is 2.0 compliant, we'll set the AGP rate in a
// chipset independent way.
// 
// This is called at boot time from NvUpdateAGPConfig based on a
// registry key, but could also be called in response to a ConfigSet
// called after boot up.
//
RM_STATUS
NvSetAGPRate(PHWINFO pDev, VOID *handle, U032 *agprate)
{
    U032 agp_status, agp_command; 

    if (handle == 0)
        return RM_ERROR;    // handle hasn't been initialized

    // return, if the capability offset for the chipset is NULL
    if (AgpInfo(pDev).AGPCapPtr == 0x0)
        return RM_ERROR;

    // 
    // If AGP FW's are already enabled, avoid trying to change the
    // AGP rate, since this can cause a hang.
    //
    if (REG_RD_DRF(_PBUS, _PCI_NV_19, _AGP_COMMAND_FW_ENABLE) ==
        NV_PBUS_PCI_NV_19_AGP_COMMAND_FW_ENABLE_ON)
        return RM_ERROR;

    //
    // Compare the rate with what the chipset and NV can do
    //
    agp_status = osPciReadDword(handle, AGP_STATUS);
    *agprate &= agp_status;
    *agprate &= REG_RD_DRF(_PBUS, _PCI_NV_18, _AGP_STATUS_RATE);

    /* we now have a mask of acceptable agp rates, but this may 
     * be more than just one rate. Choose the highest rate of
     * the available, and set the chipsets to that rate
     */
    if (*agprate & 0x4) *agprate = 0x4;
    else 
    if (*agprate & 0x2) *agprate = 0x2;
    else 
    if (*agprate & 0x1) *agprate = 0x1;

    if (*agprate)
    {
       // Looks to be a valid rate for the chipset and NV, set it.
        agp_command = osPciReadDword(handle, AGP_COMMAND);
        agp_command &= ~0xF;    // clear the current rate
        agp_command |= *agprate;
        osPciWriteDword(handle, AGP_COMMAND, agp_command);

        FLD_WR_DRF_NUM(_PBUS, _PCI_NV_19, _AGP_COMMAND_DATA_RATE, *agprate);
    }

    return RM_OK;
}

RM_STATUS
NvSetAGPFastwrites(PHWINFO pDev, VOID *handle, U032 agpfw)
{
    U032 agp_status, agp_command; 
    INTERRUPT_SETUP

    if (handle == 0)
        return RM_ERROR;    // handle hasn't been initialized

    // return, if the capability offset for the chipset is NULL
    if (AgpInfo(pDev).AGPCapPtr == 0x0)
        return RM_ERROR;

    //
    // Compare the fastwrite bit with what the chipset and NV can do
    //
    agp_status = osPciReadDword(handle, AGP_STATUS);
    agpfw &= (agp_status >> 0x4);
    agpfw &= REG_RD_DRF(_PBUS, _PCI_NV_18, _AGP_STATUS_FW);

    agp_command = osPciReadDword(handle, AGP_COMMAND);
    agp_command &= ~0x10;    // clear the current fw bit
    agp_command |= (agpfw << 0x4);

    osDisableHardwareInterrupts(pDev);

    osPciWriteDword(handle, AGP_COMMAND, agp_command);
    FLD_WR_DRF_NUM(_PBUS, _PCI_NV_19, _AGP_COMMAND_FW_ENABLE, agpfw);

    osEnableHardwareInterrupts(pDev);

    return RM_OK;
}

RM_STATUS
NvSetAGPSideBand(PHWINFO pDev, VOID *handle, U032 agpsba)
{
    U032 agp_status, agp_command; 

    if (handle == 0)
        return RM_ERROR;    // handle hasn't been initialized

    // return, if the capability offset for the chipset is NULL
    if (AgpInfo(pDev).AGPCapPtr == 0x0)
        return RM_ERROR;

    agp_status = osPciReadDword(handle, AGP_STATUS);
    agpsba &= (agp_status >> 0x9);

    //
    // If we're turning on SBA (and the chipset supports it), make sure it's
    // also in our AGP_STATUS before we enable ourselves.
    //
    if (agpsba &&
        (REG_RD_DRF(_PBUS, _PCI_NV_18, _AGP_STATUS_SBA) == NV_PBUS_PCI_NV_18_AGP_STATUS_SBA_NONE)) {
        U032 strapbits;

        // Write the STRAP_AGP_SBA enable bit
        strapbits  = REG_RD32(NV_PEXTDEV_BOOT_0);
        strapbits &= ~(DRF_MASK(NV_PEXTDEV_BOOT_0_STRAP_AGP_SBA) <<
                       DRF_SHIFT(NV_PEXTDEV_BOOT_0_STRAP_AGP_SBA));
        strapbits |= DRF_DEF(_PEXTDEV, _BOOT_0, _STRAP_AGP_SBA, _ENABLED);
        REG_WR32(NV_PEXTDEV_BOOT_0, (strapbits |
                                     DRF_DEF(_PEXTDEV, _BOOT_0, _STRAP_OVERWRITE, _ENABLED)));

        // Read it back to make sure the write's completed
        strapbits = (volatile U032)REG_RD32(NV_PEXTDEV_BOOT_0);

        // If AGP_STATUS still indicates SBA isn't supported, then it's not
        if (REG_RD_DRF(_PBUS, _PCI_NV_18, _AGP_STATUS_SBA) == NV_PBUS_PCI_NV_18_AGP_STATUS_SBA_NONE) {
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: NvSetAGPSideBand: SBA isn't supported\n");
            return RM_ERROR;
        }
    }

    // mask and set the chipsets SBA bit
    agp_command  = osPciReadDword(handle, AGP_COMMAND);
    agp_command &= ~(DRF_MASK(NV_PBUS_PCI_NV_19_AGP_COMMAND_SBA_ENABLE) <<
                     DRF_SHIFT(NV_PBUS_PCI_NV_19_AGP_COMMAND_SBA_ENABLE));
    agp_command |= DRF_NUM(_PBUS, _PCI_NV_19, _AGP_COMMAND_SBA_ENABLE, agpsba);
    osPciWriteDword(handle, AGP_COMMAND, agp_command);

    // set our SBA enable bit
    FLD_WR_DRF_NUM(_PBUS, _PCI_NV_19, _AGP_COMMAND_SBA_ENABLE, agpsba);

    return RM_OK;
}

//
// Determine if any updates are needed to the AGP rate or state of AGP fastwrites.
//
VOID
NvUpdateAGPConfig(PHWINFO pDev)
{
    VOID *handle;
    U032 agprate, agpfw, agpfwstrap, agpsba;
    U016 vendorID, deviceID;

    // return if AGP is not enabled
    if (REG_RD_DRF(_PBUS, _PCI_NV_19, _AGP_COMMAND_AGP_ENABLE) == NV_PBUS_PCI_NV_19_AGP_COMMAND_AGP_ENABLE_OFF)
        return;

    AGP_SELECT_DEVICE(handle, &vendorID, &deviceID);
    if (!handle)
        return;

    /* this may be our first entry point under 9x/w2k, so
     * if we're not initialized, call NvInitChipset(), which
     * will only detect the chipset and set up our data structures.
     */
    if (!agp_current->initialized) 
    {
        U032 dummy;
        NvInitChipset(pDev, &handle, &dummy);
    }

    //
    // Before applying the chipset updates, look for a registry key that changes
    // the strap bits. This impacts what apply_updates will do and any registry
    // overrides (but, doesn't affect normal boot time AGP configuration).
    // 
    if (IsNV10orBetter(pDev) &&
        (OS_READ_REGISTRY_DWORD(pDev, RM_REGISTRY_AGP_BASE_PATH,
                                           "EnableAGPFWStrap", &agpfwstrap) == RM_OK)) {
        U032 strapbits;
        strapbits  = REG_RD32(NV_PEXTDEV_BOOT_0);
        strapbits &= ~(DRF_MASK(NV_PEXTDEV_BOOT_0_STRAP_AGP_FASTWR) <<
                       DRF_SHIFT(NV_PEXTDEV_BOOT_0_STRAP_AGP_FASTWR));
        if (agpfwstrap)
            strapbits |= DRF_DEF(_PEXTDEV, _BOOT_0, _STRAP_AGP_FASTWR, _ENABLED);
        else
            strapbits |= DRF_DEF(_PEXTDEV, _BOOT_0, _STRAP_AGP_FASTWR, _DISABLED);

        // OR-in the _STRAP_OVERWRITE_ENABLED bit before writing
        REG_WR32(NV_PEXTDEV_BOOT_0, (strapbits |
                                     DRF_DEF(_PEXTDEV, _BOOT_0, _STRAP_OVERWRITE, _ENABLED)));
    }

    agp_current->apply_updates(pDev, handle, deviceID);

    // 
    // After applying any chipset updates and/or workarounds, see if there's an
    // AGP command overrides in the registry. We've seen where the Via chipset
    // driver later resets the AGP rate, so this key may not work there.
    //

    // set the AGP transfer rate
    if (OS_READ_REGISTRY_DWORD(pDev, RM_REGISTRY_AGP_BASE_PATH,
                               "ReqAGPRate",  &agprate) == RM_OK) {
        NvSetAGPRate(pDev, handle, &agprate);
    }

    // set/clear the AGP sideband addressing bit
    if (OS_READ_REGISTRY_DWORD(pDev, RM_REGISTRY_AGP_BASE_PATH,
                                "EnableAGPSBA", &agpsba) == RM_OK) {
        NvSetAGPSideBand(pDev, handle, agpsba);
    }

    if (IsNV11orBetter(pDev)) {
        U032 agpfw_adis;

        // allows switching between fullspeed FW's and NV10-style compat mode
        if (OS_READ_REGISTRY_DWORD(pDev, RM_REGISTRY_AGP_BASE_PATH,
                                   "DisableAGPFWDisconnect", &agpfw_adis) == RM_OK)
            FLD_WR_DRF_NUM(_PBUS, _DEBUG_1, _AGPFW_ADIS, agpfw_adis);
    }

    // Never allow NV11's to ever enable FW, independent of what the board strapping says,
    // but do allow overrides for testing purposes (see next)
    //
    // Hmmm, not working.  Need to debug.  For some reason this killed overlays
    //
    //if (IsNV11(pDev))
    //    NvSetAGPFastwrites(pDev, handle, 0);

    // set/clear the AGP fastwrite bit
    if (OS_READ_REGISTRY_DWORD(pDev, RM_REGISTRY_AGP_BASE_PATH,
                                "EnableAGPFW", &agpfw) == RM_OK) {
        NvSetAGPFastwrites(pDev, handle, agpfw);
    }

    //Check for Crush 11 north bridge
    if( (vendorID==0x10de) && ((deviceID==0x1a4) || (deviceID==0x1a5) || (deviceID==0x1a6)) )
    {
        U032    dwAGPCommand;

        //++This is only necessary through rev A.  Rev B should fix the caps.

        dwAGPCommand = REG_RD32(NV_PBUS_PCI_NV_19);
        dwAGPCommand &= ~DRF_NUM(_PBUS, _PCI_NV_19, _AGP_COMMAND_RQ_DEPTH, DRF_MASK(NV_PBUS_PCI_NV_19_AGP_COMMAND_RQ_DEPTH)); 
        dwAGPCommand |= DRF_NUM(_PBUS, _PCI_NV_19, _AGP_COMMAND_RQ_DEPTH, 0x0f);
        REG_WR32(NV_PBUS_PCI_NV_19, dwAGPCommand );
    }
}


//
// Return the AGP base/limit from the chipset. This function assumes
// the aperture base and size can be determined from PCI BAR0 in config
// space.
//
RM_STATUS
NvGetAGPBaseLimit(PHWINFO pDev, U032 *base, U032 *limit)
{
    U032 aper0, apoffset, mask;
    U032 size;
    VOID *handle;

#ifdef _WIN64
    //
    // XXX This code is specific to the 460GX chipset that's used with
    // Itanium with WIN64.
    //
    U016 vendorID, deviceID;
    U032 aper1, apsize;

    AGP_SELECT_DEVICE(handle, &vendorID, &deviceID);

    if ((vendorID != 0x8086) || ((deviceID != 0x84EA) && (deviceID != 0x84E2))) {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: didn't find expected 460GX vendor/device ID's\n");
        return RM_ERROR;
    }

    //
    // read APSIZE holds the size (limit + 1) and bit 3 determine which
    // PCI offset holds the Aperture base.
    //
    apsize = osPciReadByte(handle, 0xA2);
    switch (apsize & 0x7) {
    case 0x1:   // 256 Mb
    case 0x2:   // 1 Gb
        break;
    case 0x4:   // 32GB
    default :
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: too big an Aperture size\n");
        break;
    }
    
    if (apsize & 0x8)
        apoffset = 0x98; // use BAPBASE, which are bits 0x98->0x9F
    else
        apoffset = 0x10; // use APBASE, which are bits 0x10->0x17

    aper0 = osPciReadDword(handle, apoffset);
    if ((aper0 & 0x6) == 0x4)
        aper1 = osPciReadDword(handle, apoffset + 0x4);
    else
        aper1 = 0x0;

    // 
    // If the upper 32bit's of the aperture are set, we're in trouble.
    // Because we're a 32bit device, this better be 0's, since we won't
    // be able to generate the proper address.
    //
    if (aper1) {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Aperture base above 4GB\n");
        return RM_ERROR;
    }

#else
    U016 vendorID, deviceID;

    AGP_SELECT_DEVICE(handle, &vendorID, &deviceID);
    if (!handle)
        return RM_ERROR;

    apoffset = PCI_BASE_ADDRESS_0;

    //
    // We need to special case the RCC chipset for 2 reasons.
    //
    // The first is though we found the AGP cap id in func 1, the Aperture
    // base is in func 0. Also, with win2k, we're seeing a problem where
    // writing -1 and reading back the mask hangs, so we're going to read
    // the size from the RCC specific register.
    //
    if (vendorID == PCI_VENDOR_ID_RCC)
    {
        U032 size;

        // Set the limit based on a chipset register (size in bits 3:1).
        size = (osPciReadByte(handle, RCC_APER_SIZE) >> 1) & 0x7;
        *limit = (0x2000000 << size) - 1;

        // Need to move this back to func 0 (where the aperture base is)
        handle = osPciInitHandle(0x0, 0x0, 0x0, &vendorID, &deviceID);
        *base = osPciReadDword(handle, apoffset) & 0xFFFFF000;

        return RM_OK;
    }

    // read BAR0 to get the base
    aper0 = osPciReadDword(handle, apoffset);

#endif

    *base = aper0 & 0xFFFFF000;

    // write -1 and then read BAR0 to get the size mask
    osPciWriteDword(handle, apoffset, 0xFFFFFFFF);
    mask = osPciReadDword(handle, apoffset);
    *limit = (mask & 0xFFFFF000) ^ 0xFFFFFFFF;

    // restore original aperture value
    osPciWriteDword(handle, apoffset, aper0);

    // limit should be a power of 2 (i.e. size has one bit set)
    size = *limit + 1;    
    if ((size & (size - 1)) != 0)
        return RM_ERROR;

    return RM_OK;
}


VOID
NvEnableAGP(PHWINFO pDev)
{
    VOID *handle;
    unsigned short dummy;

    AGP_SELECT_DEVICE(handle, &dummy, &dummy);
    if (!handle) return;

    /* set AGP_ENABLE bit */
    osPciOrWord(handle, AGP_COMMAND, 0x100);
}

VOID
NvDisableAGP(PHWINFO pDev)
{
    VOID *handle;
    unsigned short dummy;
    INTERRUPT_SETUP
        
    AGP_SELECT_DEVICE(handle, &dummy, &dummy);
    if (!handle) return;

    /* clear AGP_ENABLE bit */
    osPciWriteWord(handle, AGP_COMMAND, 0x0);

    osDisableHardwareInterrupts(pDev);

    /* for some reason, I have to write this multiple times for it
     * to catch, at least under linux
     */
    REG_WR32(NV_PBUS_PCI_NV_19, 0x0);
    REG_WR32(NV_PBUS_PCI_NV_19, 0x0);
    REG_WR32(NV_PBUS_PCI_NV_19, 0x0);
    REG_WR32(NV_PBUS_PCI_NV_19, 0x0);

    osEnableHardwareInterrupts(pDev);
}

VOID
NvSaveRestoreAGPChipset(PHWINFO pDev, U032 state)
{
    VOID *handle;
    unsigned short dummy;

    AGP_SELECT_DEVICE(handle, &dummy, &dummy);
    if (!handle)
        return;

    if (agp_current->saverestore_chipset)
        agp_current->saverestore_chipset(pDev, handle, state);

    return;
}

/*
 * Basic AGP config/turn-on. 
 * Let chipset-specific code deal with workarounds in update.
 * Fast-write "stuff" is there.
 */
VOID
NvSetupAGPConfig(PHWINFO pDev)
{
    unsigned int do_sba, rq_depth, chipset_rq_depth;
    U016 wVendorID, wDeviceID;
    U032 agprate;
    VOID *handle;
    INTERRUPT_SETUP

    AGP_SELECT_DEVICE(handle, &wVendorID, &wDeviceID);
    if (!handle) return;

    //
    // At init time, an AGP rate has not been established, so max it out.
    // If this needs to be downgraded, it'll be done in the apply_updates
    // routine.
    //
    agprate = 0x7;
    if (RM_OK != NvSetAGPRate(pDev, handle, &agprate))
        return;

    /* setup AGP state */
    // Can we do side-band addressing (we assume the chipset can do SBA)??
    do_sba = REG_RD_DRF(_PBUS, _PCI_NV_18, _AGP_STATUS_SBA);
    do_sba &= agp_current->sba_capable;
    if (do_sba) {
        osPciOrWord(handle,  AGP_COMMAND, 0x0200);
    } else {
        osPciAndWord(handle, AGP_COMMAND, ~0x0200);    // make sure it's off
    }

    //
    // Determine the maximum AGP request depth, our value must be less
    // than or equal to the maximum the chipset can handle.
    //
    rq_depth         = REG_RD_DRF(_PBUS, _PCI_NV_18, _AGP_STATUS_RQ);
    chipset_rq_depth = osPciReadDword(handle, AGP_STATUS) >> 24;
    if (chipset_rq_depth < rq_depth)
        rq_depth = chipset_rq_depth;

    osDisableHardwareInterrupts(pDev);

    REG_WR32(NV_PBUS_PCI_NV_19, DRF_NUM(_PBUS, _PCI_NV_19, _AGP_COMMAND_RQ_DEPTH, rq_depth) |
                                DRF_NUM(_PBUS, _PCI_NV_19, _AGP_COMMAND_AGP_ENABLE, 0x1)    |
                                DRF_NUM(_PBUS, _PCI_NV_19, _AGP_COMMAND_DATA_RATE, agprate) |
                                ((do_sba) ? DRF_DEF(_PBUS, _PCI_NV_19, _AGP_COMMAND_SBA_ENABLE, _ON) : 0) |
                                0);

    osEnableHardwareInterrupts(pDev);

    osFlushCpuCache(pDev);
}

RM_STATUS 
nvagp_AllocAGPBitmap
(
    PHWINFO pDev,
    U032   Size,    // in pages
    U032  *Offset
)
{
    U008 *GARTBitmap = (U008 *)AgpInfo(pDev).AGPGartBitmap;
    U032 agp_pages = (AgpInfo(pDev).AGPLimit + RM_PAGE_SIZE) / RM_PAGE_SIZE;
    U032 i, j;

    osEnterCriticalCode(pDev);
    for (i = 0; i < agp_pages; i++)
    {
        if (!GARTBitmap[i >> 3])
        {
            i += 7;
        }
        else if (GARTBitmap[i >> 3] & BIT(i & 7))
        {
            //
            // Search for string of 1's the length of the block.
            //
            j = 0;
            do
            {
                if ((++i >= agp_pages) || (++j >= Size))
                    break;
            }
            while (GARTBitmap[i >> 3] & BIT(i & 7));
            if (j == Size)
            {
                //
                // Score, a block was found.
                //
                *Offset = i - j;
                while (j--)
                {
                    //
                    // Mark AGP memory as allocated.
                    //
                    i--;
                    GARTBitmap[i >> 3] &= ~BIT(i & 7);
                }
                osExitCriticalCode(pDev);
                return (RM_OK);
            }
        }
    }
    osExitCriticalCode(pDev);

    return (RM_ERR_NO_FREE_MEM);
}


VOID 
nvagp_FreeAGPBitmap
(
    PHWINFO pDev,
    U032 Offset,
    U032 PageCount
)
{
    U008 *GARTBitmap = (U008 *)AgpInfo(pDev).AGPGartBitmap;

    osEnterCriticalCode(pDev);
    while (PageCount--)
    {
        //
        // Mark AGP memory as free.
        //
        GARTBitmap[Offset >> 3] |= BIT(Offset & 7);
        Offset++;
    }
    osExitCriticalCode(pDev);
}

RM_STATUS
nvagp_InsertGARTEntries
(
    PHWINFO pDev,
    U032 Index,
    U032 PageCount,
    U032 Data

)
{
    U032 *GARTEntry = ((U032 *)AgpInfo(pDev).AGPGartBase) + Index;
    U032 dummyEntry;
    U032 i;

    osEnterCriticalCode(pDev);
    // load the GART with the specified value, repeating as necessary
    for (i = 0; i < PageCount; i++)
    {
        GARTEntry[i] = Data;
        // need this readback on RCC to guarantee this is flushed
        dummyEntry = GARTEntry[i];
        if (dummyEntry != Data)
            DBG_BREAKPOINT();
    }
    osExitCriticalCode(pDev);

    return RM_OK;
}

RM_STATUS
nvagp_FlushGARTEntries
(
    PHWINFO pDev
)
{
    U016 dummy;
    VOID *handle;

    AGP_SELECT_DEVICE(handle, &dummy, &dummy);
    if (!handle)
        return RM_ERROR;

    osEnterCriticalCode(pDev);

#ifdef SUPPORT_RCC_AGP
    // Make sure to flush the posted write buffer
    if (RCC_IsChipset(pDev))
        RCC_FlushPostedWriteBuffer(pDev);
#endif
    osFlushCpuCache(pDev);

    agp_current->flush_mappings(pDev, handle);

    osExitCriticalCode(pDev);

    return RM_OK;
}

//
// This include is needed to remap the following routines to
// their MP-safe equivalents for nt4:
//
//  nvagp_AllocAGPBitmap
//  nvagp_FreeAGPBitmap
//  nvagp_InsertGARTEntries
//  nvagp_FlushGARTEntries
//  
// This works only because these routines are defined above.
//
#include <smp.h>

static RM_STATUS 
nvagp_LoadGARTEntries
(
    PHWINFO pDev,
    VOID *pAddress,
    U032 PageCount,
    U032 Index
)
{
    U032 i;
    VOID *ucptr;    // uncached ptr
    U032 pagePhysicalAddr;
    RM_STATUS status;

    for (i = 0; i < PageCount; i++)
    {
        status = osGetAGPPhysAddr( pDev, (VOID *) pAddress, i, &pagePhysicalAddr);
        if (status != RM_OK)
        {
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: NULL physical address for DMA page\n");
            return RM_ERR_NO_FREE_MEM;
        }

        // As part of loading the GART entry, create a temporary uncached mapping
        // to clean each page (must do this page by page, since the memory won't
        // be contiguous) and then free the mapping.
        //
        // It seems we can't be certain, the cache is clean w.r.t. this page, so
        // by zeroing it uncached, we hopefully force everything out preventing
        // any later writebacks to corrupt our data.

        ucptr = osMapKernelSpace(pagePhysicalAddr, RM_PAGE_SIZE, MAP_UNCACHED);
        if (ucptr == NULL)
        {
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Unable to create uncached mapping\n");
            return RM_ERR_NO_FREE_MEM;
        }

        // clean the page
        osMemSet(ucptr, 0, RM_PAGE_SIZE);
        *(U032 *)ucptr = 0x0;

        // free the mapping
        osUnmapKernelSpace(ucptr, RM_PAGE_SIZE);

#ifdef SUPPORT_MICRON_AGP
        if (Micron_IsChipset(pDev))
            nvagp_InsertGARTEntries(pDev, Index+i, 1, (pagePhysicalAddr >> RM_PAGE_SHIFT) | 0x80000000);
        else 
#endif
            nvagp_InsertGARTEntries(pDev, Index+i, 1, (pagePhysicalAddr & ~RM_PAGE_MASK) | 1);
    }

    nvagp_FlushGARTEntries(pDev);

    return RM_OK;
}

static RM_STATUS 
nvagp_MapAGPAperture
(
    PHWINFO pDev,
    U032 clientClass,
    U032 index,
    U032 pagecount,
    VOID **pMdl,
    VOID **pAddress
)
{
    RM_STATUS rmStatus = RM_OK;

    switch (clientClass)
    {
        case NV01_ROOT:
            pMdl = NULL;           // no MDL needed for this mapping
            *pAddress = osMapIOSpace(AgpInfo(pDev).AGPPhysStart +
                                     (index << RM_PAGE_SHIFT) +
                                     (((int)(NV_UINTPTR_T)*pAddress) & RM_PAGE_MASK),
                                     pagecount << RM_PAGE_SHIFT,
                                     pMdl, MAP_KERNEL | MAP_WRITECOMBINE);
            if (*pAddress == (VOID *)NULL)
                rmStatus = RM_ERROR;
            else
                osMemSet(*pAddress, 0, pagecount << RM_PAGE_SHIFT);
            break;

        case NV01_ROOT_USER:
            // create the user mapping to these pages
            *pMdl = *pAddress;  // linux will use this, but NT will ignore it
            *pAddress = osMapIOSpace(AgpInfo(pDev).AGPPhysStart +
                                     (index << RM_PAGE_SHIFT) +
                                     (((int)(NV_UINTPTR_T)*pAddress) & RM_PAGE_MASK),
                                     pagecount << RM_PAGE_SHIFT,
                                     pMdl, MAP_USER | MAP_WRITECOMBINE);
            if (*pAddress == (VOID *)NULL)
                rmStatus = RM_ERROR;
            else
                osMemSet(*pAddress, 0, pagecount << RM_PAGE_SHIFT);
            break;

        default:
            rmStatus = RM_ERR_OPERATING_SYSTEM;
            break;
    }

    return rmStatus;
}

static VOID 
nvagp_UnmapAGPAperture
(
    PHWINFO pDev,
    VOID *pAddress,
    U032 Index,
    PAGP_MEM_INFO pMemInfo
)
{
    //
    // Clear out GART entries for this allocation.
    //
    nvagp_InsertGARTEntries(pDev, Index, pMemInfo->PageCount, 0);

    nvagp_FlushGARTEntries(pDev);

    //
    // If we're passed a non-NULL MDL, this means a user mapping was
    // created and needs to be cleaned up
    //
    if (pMemInfo->pMdl)
    {
        // free the user mapping
        osUnmapIOSpace(pAddress, pMemInfo->PageCount << RM_PAGE_SHIFT,
                       pMemInfo->pMdl, MAP_USER);
        pMemInfo->pMdl = NULL;
    }
    else
    {
        osUnmapIOSpace(pAddress, pMemInfo->PageCount << RM_PAGE_SHIFT,
                       pMemInfo->pMdl, MAP_KERNEL);
    }
}

RM_STATUS NvAllocAGPPages
(
    PHWINFO pDev,
    VOID **pAddress,
    U032   PageCount,
    U032   ClientClass,
    VOID **pMemData
)
{
    U032          Index;
    PAGP_MEM_INFO pMemInfo;
    U032          rmStatus = RM_ERROR;

    if (!pDev) {
        return RM_ERR_NO_FREE_MEM;  // AGP not initialized, PCI card?
    }

    if (!AgpInfo(pDev).AGPLinearStart) {
        return RM_ERR_NO_FREE_MEM;  // true for PCI cards
    }

    // Since there will be some cleanup needed on the free side
    // create a struct that hooks into VOID * in CLI_MEMORY_INFO

    rmStatus = osAllocMem((VOID **)&pMemInfo, sizeof(AGP_MEM_INFO));
    if (rmStatus != RM_OK)
    {
        return rmStatus;
    }

    // Alloc the pages for the caller.
    //
    // Don't use osAllocMem, since it'll write a DEBUG pattern to the buffer
    // via a cached mapping. Just use the underlying NT routine ... using the
    // non-paged pool guarantees nothing needs to be done in osLockUserMem.
 
    rmStatus = osAllocPool(pAddress, PageCount << RM_PAGE_SHIFT);
    if (rmStatus != RM_OK)
    {
        osFreeMem(pMemInfo);
        return RM_ERR_NO_FREE_MEM;
    }

    pMemInfo->SysAddr   = *pAddress;      // keep the original system addr
    pMemInfo->PageCount = PageCount;

    // Alloc from the GART bitmap for the number of pages we'll need.
    rmStatus = nvagp_AllocAGPBitmap(pDev, PageCount, &Index);
    if (rmStatus != RM_OK)
    {
        osFreePool(pMemInfo->SysAddr);
        osFreeMem(pMemInfo);
        return rmStatus;
    }

    pMemInfo->Offset = Index;

    // Load up the GART entries with the physical addresses
    rmStatus = nvagp_LoadGARTEntries(pDev, *pAddress, PageCount, Index);
    if (rmStatus != RM_OK)
    {
        nvagp_FreeAGPBitmap(pDev, Index, PageCount);
        osFreePool(pMemInfo->SysAddr);
        osFreeMem(pMemInfo);
        return rmStatus;
    }

    *pMemData = (VOID *)pMemInfo;

    return RM_OK;
}


RM_STATUS NvMapAGPPages
(
    PHWINFO pDev,
    VOID  **pAddress,
    U032    ClientClass,
    VOID   *pMemData
)
{
    PAGP_MEM_INFO pMemInfo = (PAGP_MEM_INFO) pMemData;
    U032          rmStatus = RM_ERROR;

    // Finally, setup a user/kernel mapping within the Aperture
    rmStatus = nvagp_MapAGPAperture(pDev,
                                    ClientClass,
                                    pMemInfo->Offset,
                                    pMemInfo->PageCount,
                                   &pMemInfo->pMdl,
                                    pAddress);
   if (rmStatus != RM_OK)
   {
        nvagp_FreeAGPBitmap(pDev, pMemInfo->Offset, pMemInfo->PageCount);
        osFreePool(pMemInfo->SysAddr);
        osFreeMem(pMemInfo);
        return rmStatus;
    }

#ifdef _WIN64
   DBG_PRINT_STRING_VAL64(DEBUGLEVEL_TRACEINFO, "NVRM: alloc user addr    ", *(U064*)pAddress);
#else
   DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: alloc user addr    ", *(U032*)pAddress);
#endif
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: mapped to agp addr ", (U032)AgpInfo(pDev).AGPPhysStart + (pMemInfo->Offset << RM_PAGE_SHIFT));

    return RM_OK;
}

//
// osFreeAGPPages - Free a number of aligned memory pages
//
//  **pAddress - handle to the linear address
//  MemoryType - memory pool
//  *pMemData  - pointer to private per-alloc data
//
RM_STATUS NvFreeAGPPages
(
    PHWINFO pDev,
    VOID **pAddress,
    VOID  *pMemData
)
{
    PAGP_MEM_INFO pMemInfo = (PAGP_MEM_INFO)pMemData;

    if (!pDev)
        return RM_ERROR;        // this would be a misguided free

    if (!AgpInfo(pDev).AGPLinearStart)
        return RM_ERROR;        // this would be a misguided free

    nvagp_FreeAGPBitmap(pDev, pMemInfo->Offset, pMemInfo->PageCount);

    // reset the GART entries, free the mapping and flush the GTLB
    nvagp_UnmapAGPAperture(pDev, *pAddress, pMemInfo->Offset, pMemInfo);

    // free the original system pages
    osFreePool(pMemInfo->SysAddr);

    // free our data struct that kept track of this mapping
    osFreeMem(pMemInfo);

    return RM_OK;
}


//
// Here's our attempt to configure AGP on our own for NT4.
//
// First, we'll attempt to recognize the chipset to determine if we know how to
// program it. Next, we'll create a bitmap that's used to alloc/free slots from
// the GART.
//
BOOL RmInitAGP
(
    PHWINFO pDev
)
{
    U032 i, status;
    U032 physaddr, apsize, apbase;
    VOID *handle;
    U032 chipset = CS_UNKNOWN;
    U008 *pBitmap;
    U032 gart_size, gart_bitmap_size;

    // verify we're an AGP graphics card
    if (REG_RD_DRF(_PBUS, _PCI_NV_24, _NEXT_PTR) != NV_PBUS_PCI_NV_24_NEXT_PTR_AGP)
    {
        if (!agp_ref_count)
        {
            AgpInfo(pDev).AGPLinearStart = 0;
            AgpInfo(pDev).AGPLimit = 0;
        }
        return FALSE;
    }

    // don't initialize AGP if it's already setup
    // moved after the AGP card check so we know we should be
    // safe for the agp_restore_mappings() if needed.
    if (agp_ref_count) 
    {
        agp_ref_count++;
        return 0;
    }

    NvInitChipset(pDev, &handle, &chipset);

    if (chipset == CS_UNKNOWN)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: *** Unrecongnized AGP chipset\n");
        AgpInfo(pDev).AGPLinearStart = 0;
        AgpInfo(pDev).AGPLimit = 0;
        return FALSE;
    }

    AgpInfo(pDev).AGPChipset = chipset;

    /* if AGP is already turned on, turn it off while we configure it */
#ifdef SUPPORT_RCC_AGP
    /* this disable scrubs the RCC bios settings, so skip it */
    if (!RCC_IsChipset(pDev))
#endif
    NvDisableAGP(pDev);

    if (!agp_current->earlyinit(pDev, handle))
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: *** AGP early init failed\n");
        AgpInfo(pDev).AGPLinearStart = 0;
        AgpInfo(pDev).AGPLimit = 0;
        return FALSE;
    }

    // get aperture info
    apsize = agp_current->get_aper_size(pDev, handle);
    apbase = agp_current->get_aper_base(pDev, handle);

    if (!apsize || !apbase)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: *** Cannot find Aperture Base or Size\n");
        AgpInfo(pDev).AGPLinearStart = 0;
        AgpInfo(pDev).AGPLimit = 0;
        return FALSE;
    }

    apbase &= ~RM_PAGE_MASK;

    if (osSetMemRange(apbase, apsize, MEM_WRITECOMBINE) != RM_OK)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: *** Cannot set Aperture to Write Combined\n");
        AgpInfo(pDev).AGPLinearStart = 0;
        AgpInfo(pDev).AGPLimit = 0;
        return FALSE;
    }

    AgpInfo(pDev).AGPPhysStart = apbase;
        
    // Map a single page for drivers wanting to setup a context DMA for the
    // whole AGP aperture.  The type of mapping really doesn't matter.
    AgpInfo(pDev).AGPLinearStart = 
        (VOID_PTR) osMapKernelSpace(AgpInfo(pDev).AGPPhysStart, RM_PAGE_SIZE, MAP_UNCACHED);
    if (AgpInfo(pDev).AGPLinearStart == (VOID_PTR)NULL)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: *** Cannot map the AGP Aperture\n");
        AgpInfo(pDev).AGPLimit = 0;
        return FALSE;
    }

    AgpInfo(pDev).AGPLimit = apsize - 1;

    //
    // Allocate space for the GART.
    //
    // This memory needs to be contiguous, 4K (RM_PAGE_SIZE) aligned and locked
    // down for the page tables. My best guess at what to use is __dma_get_pages()
    // for this. If on AMD, we'll add another page for their first level table.
    //
    gart_size = agp_current->get_gart_size(pDev, handle);

    /* this is num_pages / 8 bits for bitmasks */
    gart_bitmap_size = (AgpInfo(pDev).AGPLimit + RM_PAGE_SIZE) / (8 * RM_PAGE_SIZE); /* don't want the lookup here */

    AgpInfo(pDev).AGPGartContigAlloc = (VOID_PTR) osAllocContigPages(gart_size);
    if (AgpInfo(pDev).AGPGartContigAlloc == (VOID_PTR) NULL)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: *** Unable to allocate GART\n");
        AgpInfo(pDev).AGPLinearStart = 0;
        AgpInfo(pDev).AGPLimit = 0;
        return FALSE;
    }

    // Get the physical addr to be loaded into the chipset
    physaddr = osGetKernPhysAddr( (void *) AgpInfo(pDev).AGPGartContigAlloc); 
    physaddr = ((physaddr + (RM_PAGE_SIZE - 1)) & ~RM_PAGE_MASK); // if it's not page aligned

    // Mark these pages uncached, so we can freely update the GART
    AgpInfo(pDev).AGPGartBase = (VOID_PTR) osMapKernelSpace(physaddr, gart_size, MAP_UNCACHED);

    if (AgpInfo(pDev).AGPGartBase == (VOID_PTR)NULL)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: *** Unable to create uncached mapping for the GART\n");
        osFreeContigPages( (void *) AgpInfo(pDev).AGPGartContigAlloc);
        AgpInfo(pDev).AGPLinearStart = 0;
        AgpInfo(pDev).AGPLimit = 0;
        return FALSE;
    }

    osMemSet((void *)AgpInfo(pDev).AGPGartBase, 0, gart_size); /* Clear the ram out, no junk to the user */
    osFlushCpuCache(pDev);

    // allow chipset-specific modifications to gart structuring (amd...)
    agp_current->fixup_gart(pDev, handle, physaddr);

    //
    // Allocate the GART bitmap, which we'll use to manage AGP allocations.
    // Each bit in the bitmap represents a 4K mapping.
    //
    status = osAllocMem((VOID **)&AgpInfo(pDev).AGPGartBitmap, gart_bitmap_size);

    if (status != RM_OK) {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: *** Unable to allocate GART bitmap\n");
        /* osUnmapIoSpace((VOID *)AgpInfo(pDev).AGPGartBase, gart_size); */
        osFreeContigPages( (void *) AgpInfo(pDev).AGPGartContigAlloc);
        AgpInfo(pDev).AGPLinearStart = 0;
        AgpInfo(pDev).AGPLimit = 0;
        return FALSE;
    }

    pBitmap = (char *)AgpInfo(pDev).AGPGartBitmap;
    for (i = 0; i < gart_bitmap_size; i++)
        pBitmap[i] = 0xFF;


    //
    // Program up the rest of the chipset.
    //
    agp_current->enable_mappings(pDev, handle, physaddr);

    /* setup chipset-specific features */
    NvSetupAGPConfig(pDev);

    /* enable chipset-specific overrides */
    NvUpdateAGPConfig(pDev);

    /* now that everything's configured, turn it on */
#ifdef SUPPORT_RCC_AGP
    /* see call to NvDisableAGP above */
    if (!RCC_IsChipset(pDev))
#endif
    NvEnableAGP(pDev);

    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: AGP Phys Base:      ", 
        AgpInfo(pDev).AGPPhysStart);
    DBG_PRINT_STRING_PTR(DEBUGLEVEL_TRACEINFO, "NVRM: AGP Linear Base:    ", 
        (VOID *)AgpInfo(pDev).AGPLinearStart);
    DBG_PRINT_STRING_PTR(DEBUGLEVEL_TRACEINFO, "NVRM: AGP GART Base:      ", 
        (VOID *)AgpInfo(pDev).AGPGartBase);
    DBG_PRINT_STRING_PTR(DEBUGLEVEL_TRACEINFO, "NVRM: AGP GART Bitmap:    ", 
        (VOID *)AgpInfo(pDev).AGPGartBitmap);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: # of GART Mappings: ", 
        (AgpInfo(pDev).AGPLimit + RM_PAGE_SIZE) / RM_PAGE_SIZE);

    // looks all good, count this as a "connected device"
    agp_ref_count++;

    return 0;

} // end of RmInitAGP()



BOOL RmTeardownAGP
(
    PHWINFO pDev
)
{
    unsigned short dummy;
    VOID *handle;
    U032 gart_size;

    AGP_SELECT_DEVICE(handle, &dummy, &dummy);
    if (!handle)
        return 0;

    agp_ref_count--;

    // Don't tear down AGP if someone is still using it
    // (like a second X Server)
    if (agp_ref_count != 0) 
        return 0;

    gart_size = agp_current->get_gart_size(pDev, handle);
    agp_current->disable_chipset(pDev, handle);
    NvDisableAGP(pDev);

    if (AgpInfo(pDev).AGPLinearStart) 
        osUnmapKernelSpace( (void *) AgpInfo(pDev).AGPLinearStart, 
            RM_PAGE_SIZE);
    AgpInfo(pDev).AGPLinearStart = 0;

    if (AgpInfo(pDev).AGPGartBase) 
    {
        osUnmapKernelSpace((void *) AgpInfo(pDev).AGPGartBase, gart_size);
        osFreeContigPages( (void *) AgpInfo(pDev).AGPGartContigAlloc);
    }
    AgpInfo(pDev).AGPGartBase = 0;

    return 0;
}


//
// Return the Bus, Device, Func numbers of the Northbridge.
//
// We determine this by looking for the another AGP device that's not us
// and is a bridge device (so, we hopefully avoid an integrated graphics
// device). We should check for a host bridge device where the subclass
// is PCI_SUBCLASS_BR_HOST, but this doesn't work on the RCC chipset.
//
BOOL
NvSetBusDeviceFunc
(
    PHWINFO pDev
)
{
    PRMINFO pRmInfo = (PRMINFO)pDev->pRmInfo;
    VOID *handle;
    U008 bus, device, func;
    U032 cap_offset;
    U016 vendorID, deviceID;
    RM_STATUS status;

    // return it, if we've got it already
    if (pRmInfo->AGP.NBAddr.valid)
        return TRUE;

    // we're checking all the device/funcs for the first 5 buses
    for (bus = 0; bus < 5; bus++)
    {
        for (device = 0; device < PCI_MAX_DEVICES; device++)
        {
            for (func = 0; func < PCI_MAX_FUNCTION; func++)
            {
                // read at bus, device, func
                handle = osPciInitHandle(bus, device, func, &vendorID, &deviceID);
                if (!handle)
                    break;

                if (vendorID == PCI_INVALID_VENDORID)
                    break;           // skip to the next device

                if (REG_RD32(NV_PBUS_PCI_NV_0) == (U032)(deviceID << 16 | vendorID))
                    break;           // skip over ourselves

                if (osPciReadByte(handle, 0xB) != PCI_CLASS_BRIDGE_DEV)
                    break;           // not a bridge device

                // look for the AGP Capability ID
                status = NvSetCapIDOffset(pDev, handle, &cap_offset);
                if (status == RM_OK)
                {
                    // Found it
                    AgpInfo(pDev).NBAddr.bus    = bus;
                    AgpInfo(pDev).NBAddr.device = device;
                    AgpInfo(pDev).NBAddr.func   = func;
                    AgpInfo(pDev).NBAddr.valid  = 0x1;
                    return TRUE;
                }

                if ((osPciReadByte(handle, 0xE) & PCI_MULTIFUNCTION) == 0)
                    break;        // no need to cycle through functions
            }
        }
    }

    // This is bad, we didn't find the NB device (assume bus0/device0/func0)
    AgpInfo(pDev).NBAddr.bus    = 0x0;
    AgpInfo(pDev).NBAddr.device = 0x0;
    AgpInfo(pDev).NBAddr.func   = 0x0;
    AgpInfo(pDev).NBAddr.valid  = 0x1;
    DBG_BREAKPOINT();

    return FALSE;
}

RM_STATUS
NvSetCapIDOffset
(
    PHWINFO pDev, 
    VOID *handle,
    U032 *cap_offset
)
{
    U008 cap_next; 
    U032 agp_caps; 

    if (handle == 0)
        return RM_ERROR;    // handle hasn't been initialized

    if ((osPciReadDword(handle, 0x4) & 0x00100000) == 0)
        return RM_ERROR;    // chipset doesn't support capability ptrs

    // find the PCI offset for the AGP Cap ID
    cap_next = osPciReadByte(handle, PCI_CAPABILITY_LIST);
    while (cap_next)
    {
        agp_caps = osPciReadDword(handle, cap_next);
        if ((agp_caps & 0xFF) == 0x2)
            break;      // found the AGP Cap ID
        cap_next = (U008)((agp_caps >> 8) & 0xFF);            
    }

    if (cap_next == 0)
        return RM_ERROR;    // didn't find the AGP capid

    *cap_offset = cap_next;
    return RM_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\common\src\nv\cpuid.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-1997 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-1997  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************* CPU Information Gather Routines ***********************\
*                                                                           *
* Module: CPUID.C                                                           *
*   One time initialization code to setup the Processor type                *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nvrm.h>
#include <nvcm.h>
#include <os.h>

#define CPU_STD_TSC                 BIT(4)
#define CPU_STD_MMX                 BIT(23)
#define CPU_STD_XMM                 BIT(25)
#define CPU_STD_WNI                 BIT(26)
#define CPU_EXT_3DNOW               BIT(31)

/*
 * Identify chip foundry.
 *      IS_INTEL   = "GenuineIntel"
 *      IS_AMD     = "AuthenticAMD"
 *      IS_WINCHIP = "CentaurHauls"
 *      IS_CYRIX   = "CyrixInstead"
 */
#define IS_INTEL(fndry)     (((fndry).StrID[0]==0x756E6547)&&((fndry).StrID[1]==0x49656E69)&&((fndry).StrID[2]==0x6C65746E))
#define IS_AMD(fndry)       (((fndry).StrID[0]==0x68747541)&&((fndry).StrID[1]==0x69746E65)&&((fndry).StrID[2]==0x444D4163))
#define IS_WINCHIP(fndry)   (((fndry).StrID[0]==0x746E6543)&&((fndry).StrID[1]==0x48727561)&&((fndry).StrID[2]==0x736C7561))
#define IS_CYRIX(fndry)     (((fndry).StrID[0]==0x69727943)&&((fndry).StrID[1]==0x736E4978)&&((fndry).StrID[2]==0x64616574))

/*
 * ID the CPU.
 */
VOID RmInitCpuInfo
(
    PHWINFO pDev
)
{
	PRMINFO pRmInfo = (PRMINFO) pDev->pRmInfo;

#if defined(IA64)
    pRmInfo->Processor.Type = NV_CPU_IA64 |
                              NV_CPU_FUNC_MMX |
                              NV_CPU_FUNC_SFENCE |
                              NV_CPU_FUNC_SSE;
    pRmInfo->Processor.Clock = 0;
#else
    int i;
    struct _CPUID
    {
        union
        {
            U008 String[12];
            U032 StrID[3];
        } Foundry;
        U032 pad;
        U032 Family;
        U032 Model;
        U032 Stepping;
        U032 StandardFeatures;
        U032 MemoryFeatures[4];
        U032 ExtendedFeatures;
        U032 ChipFlags;
        U032 MHz;
    } cpuinfo;

#ifdef __GNUC__
    U032 eax, ebx, ecx, edx;
#endif

    
    /*
     * Init structure to default.
     */
    for (i = 0; i < 12; i++)
        cpuinfo.Foundry.String[i] = '\0';
    cpuinfo.pad              = 0;
    cpuinfo.Family           = 0;
    cpuinfo.Model            = 0;
    cpuinfo.Stepping         = 0;
    cpuinfo.StandardFeatures = 0;
    cpuinfo.ExtendedFeatures = 0;
    cpuinfo.ChipFlags        = 0;
    cpuinfo.MHz              = 0;
    
    pRmInfo->Processor.Type = 0;
    pRmInfo->Processor.Clock = 0;
    
#ifdef __GNUC__
    // if nv_cpuid() returns 0, then this cpu does not support cpuid instruction
    // We just worry about this on the first call...
    if ( ! nv_cpuid(0x00000000/*cpuid op*/, &eax, &ebx, &ecx, &edx))
        goto Exit;

    cpuinfo.Foundry.StrID[0] = ebx;
    cpuinfo.Foundry.StrID[1] = edx;
    cpuinfo.Foundry.StrID[2] = ecx;
        
    nv_cpuid(0x00000001/*cpuid op*/, &eax, &ebx, &ecx, &edx);
    cpuinfo.Family = (eax >> 8) & 0xF;
    cpuinfo.Model = (eax >> 4) & 0xF;
    cpuinfo.Stepping = (eax & 0xF);
    cpuinfo.StandardFeatures = edx;

    nv_cpuid(0x00000002/*cpuid op*/, &eax, &ebx, &ecx, &edx);
    cpuinfo.MemoryFeatures[0] = eax;
    cpuinfo.MemoryFeatures[1] = ebx;
    cpuinfo.MemoryFeatures[2] = ecx;
    cpuinfo.MemoryFeatures[3] = edx;

#else        /* ! __GNUC__ */

        /* XXX this code should be converted to use less asm */

    __asm
    {
        ; save state
        push    eax
        push    ebx
        push    ecx
        push    edx

        pushfd
        pop     eax
        mov     ebx, eax
        xor     eax, 0x00200000
        push    eax
        popfd
        pushfd
        pop     eax
        cmp     eax, ebx
        je      Exit                      // cpuid inst not supported
        mov     eax, 0
//      cpuid instr
        _emit   0x0F
        _emit   0xA2
        lea     esi, cpuinfo
        mov     [esi], ebx                // cpuinfo.Foundary.StrID[0]
        mov     [esi + 4], edx            // cpuinfo.Foundary.StrID[1]
        mov     [esi + 8], ecx            // cpuinfo.Foundary.StrID[2] 
        push    eax                       // Save max function count for later


        mov     eax, 1
//      cpuid instr
        _emit   0x0F
        _emit   0xA2

        mov     ebx, eax
        shr     ebx, 8
        and     ebx, 0x0F
        mov     [esi + 16], ebx           // cpuinfo.Family

        mov     ebx, eax
        shr     ebx, 4
        and     ebx, 0x0F
        mov     [esi + 20], ebx           // cpuinfo.Model

        mov     ebx, eax
        and     ebx, 0x0F
        mov     [esi + 24], ebx           // cpuinfo.Stepping

        mov     [esi + 28], edx           // cpuinfo.StandardFeatures


        mov     eax, 2
//      cpuid instr
        _emit   0x0F
        _emit   0xA2
        mov     [esi + 32], eax           // cpuinfo.MemoryFeatures
        mov     [esi + 36], ebx
        mov     [esi + 40], ecx
        mov     [esi + 44], edx
        pop     eax                       // Restore max function, but discard
        
        ; restore state
        pop     edx
        pop     ecx
        pop     ebx
        pop     eax
    }
#endif
    
    if (IS_INTEL(cpuinfo.Foundry))
    {
        if (cpuinfo.Family == 5)
        {
            if (cpuinfo.Model == 4)
                pRmInfo->Processor.Type = NV_CPU_P55;
            else 
                pRmInfo->Processor.Type = NV_CPU_P5;
        }
        if (cpuinfo.Family == 6)
        {
            if (cpuinfo.Model == 1)
                pRmInfo->Processor.Type = NV_CPU_P6;
            else if (cpuinfo.Model == 3)
                pRmInfo->Processor.Type = NV_CPU_P2;
            else if (cpuinfo.Model == 5)
                pRmInfo->Processor.Type = NV_CPU_P2XC;
            else if (cpuinfo.Model == 6)
                pRmInfo->Processor.Type = NV_CPU_CELA;
            else if (cpuinfo.Model == 7)
                pRmInfo->Processor.Type = NV_CPU_P3;
            else if (cpuinfo.Model == 8)
                pRmInfo->Processor.Type = NV_CPU_P3_INTL2;
        }
        if (cpuinfo.Family == 0x0F) {
            if (cpuinfo.Model == 0)
                pRmInfo->Processor.Type = NV_CPU_P4;
        }

            
        if (cpuinfo.StandardFeatures & CPU_STD_MMX)
            pRmInfo->Processor.Type |= NV_CPU_FUNC_MMX;
        if (cpuinfo.StandardFeatures & CPU_STD_XMM)
        {
            U032 my_cr4;
            
            pRmInfo->Processor.Type |= NV_CPU_FUNC_SFENCE;
#ifdef __GNUC__
            my_cr4 = nv_rdcr4();
#else
            // Before setting the NV_CPU_FUNC_SSE bit, we'll also check
            // that CR4.OSFXSR(bit 9) is set, which means the OS is prepared
            // to switch the additional KATMAI FP state for us.
            
            __asm
            {
                ; save state
                push    eax
                push    ebx
                push    ecx
                push    edx

                // mov     eax,cr4
                _emit   0x0F
                _emit   0x20
                _emit   0xE0

                mov     my_cr4, eax
                
                ; restore state
                pop     edx
                pop     ecx
                pop     ebx
                pop     eax
            }
#endif
            if (my_cr4 & 0x200)
            {
                pRmInfo->Processor.Type |= NV_CPU_FUNC_SSE;

                // supports SSE2 (Willamette NI) instructions
                if (cpuinfo.StandardFeatures & CPU_STD_WNI)
                    pRmInfo->Processor.Type |= NV_CPU_FUNC_SSE2;
            }
        }
    }
    else
    {
#ifdef __GNUC__
        nv_cpuid(0x80000001/*cpuid op*/, &eax, &ebx, &ecx, &edx);
        cpuinfo.ExtendedFeatures = edx;
#else
        // All other non-Intel CPU types will want to get the extended features
        __asm
        {
            ; save state
            push    eax
            push    ebx
            push    ecx
            push    edx
                
            mov     eax, 0x80000001
            // cpuid instr
            _emit   0x0F
            _emit   0xA2
            mov     [esi + 48], edx           // cpuinfo.ExtendedFeatures
        
            ; restore state
            pop     edx
            pop     ecx
            pop     ebx
            pop     eax
        }
#endif

        if (IS_AMD(cpuinfo.Foundry))
        {
            if (cpuinfo.Family == 5)                // K5, K6, K6-2 with 3DNow, K6-3
            {
                if (cpuinfo.Model < 6)
                    pRmInfo->Processor.Type = NV_CPU_K5;
                else if (cpuinfo.Model < 8)
                    pRmInfo->Processor.Type = NV_CPU_K6;
                else if (cpuinfo.Model == 8)
                    pRmInfo->Processor.Type = NV_CPU_K62;
                else if (cpuinfo.Model == 9)
                    pRmInfo->Processor.Type = NV_CPU_K63;
             }
            if (cpuinfo.Family == 6)                // K7
            {
                pRmInfo->Processor.Type = NV_CPU_K7;
#ifdef AMD_K7_SFENCE
                //
                // AMD docs indicate it's supported, but in practice on a KT133, the
                // pushbuf wasn't being flushed properly, so go back to flush by out
                // instruction, until we know different.
                //
                pRmInfo->Processor.Type |= NV_CPU_FUNC_SFENCE;
#endif
            }
            if (cpuinfo.StandardFeatures & CPU_STD_MMX)
                pRmInfo->Processor.Type |= NV_CPU_FUNC_MMX;
            if (cpuinfo.ExtendedFeatures & CPU_EXT_3DNOW)
                pRmInfo->Processor.Type |= NV_CPU_FUNC_3DNOW;
        }
        else if (IS_WINCHIP(cpuinfo.Foundry))
        {
            if (cpuinfo.Family == 5)                // Winchip C6, Winchip2 w/ 3DNow
            {
                if (cpuinfo.Model == 4)
                    pRmInfo->Processor.Type = NV_CPU_C6;
                if (cpuinfo.Model == 8)        
                    pRmInfo->Processor.Type = NV_CPU_C62;
            }
                    
            if (cpuinfo.StandardFeatures & CPU_STD_MMX)
                pRmInfo->Processor.Type |= NV_CPU_FUNC_MMX;
            if (cpuinfo.ExtendedFeatures & CPU_EXT_3DNOW)
                pRmInfo->Processor.Type |= NV_CPU_FUNC_3DNOW;
        }
        else if (IS_CYRIX(cpuinfo.Foundry))
        {
            if (cpuinfo.Family == 4)                // MediaGX
                pRmInfo->Processor.Type = NV_CPU_GX;
            if (cpuinfo.Family == 5)                // Cyrix 6x86 or MediaGX w/ MMX
            {
                if (cpuinfo.Model == 2)
                    pRmInfo->Processor.Type = NV_CPU_M1;
                if (cpuinfo.Model == 4)        
                    pRmInfo->Processor.Type = NV_CPU_MGX;
            }
            if (cpuinfo.Family == 6)                // Cyrix MII
                pRmInfo->Processor.Type = NV_CPU_M2;
        
            if (cpuinfo.StandardFeatures & CPU_STD_MMX)
                pRmInfo->Processor.Type |= NV_CPU_FUNC_MMX;
            if (cpuinfo.ExtendedFeatures & CPU_EXT_3DNOW)
                pRmInfo->Processor.Type |= NV_CPU_FUNC_3DNOW;
        }
    }
    
    // Calculate the frequency
    if (cpuinfo.StandardFeatures & CPU_STD_TSC)
        pRmInfo->Processor.Clock = osGetCpuFrequency();
Exit:    
    return;
#endif // !defined(IA64)
}

void RmInitBusInfo
(
    PHWINFO pDev
)
{
	PRMINFO pRmInfo = (PRMINFO) pDev->pRmInfo;

    VOID *handle;
    U016 vendorID, deviceID;
    U032 data32;
    U032 hclk_freq, mclk_freq;

    //
    // Currently the only chipset we need to really concern ourselves with is
    // Crush, so zero out the others for now
    //
    pRmInfo->Processor.HalInfo.FrontSideBusFreq = 0;
    pRmInfo->Processor.HalInfo.SystemMemoryFreq = 0;

    //
    // Determine if this is a Crush system
    //
    handle = osPciInitHandle(0, 0, 0, &vendorID, &deviceID);
    if (!handle)
        return;

    if ((vendorID != 0x10B9) || (deviceID != 0x1631))
    {
        U016 tempvid, tempdid;
        VOID *temphandle;

        //
        // Deal with ALI trickery.  On some systems they changed the chipset
        // devid to 0x1621 (their old chipset).  If this is the case, peer at
        // bus1 dev0 to see if we're there.  If so, assume this is really
        // a 1631
        //
        if ((vendorID == 0x10B9) && (deviceID == 0x1621))
        {
            temphandle = osPciInitHandle(1, 0, 0, &tempvid, &tempdid);
            if (!temphandle)
                return;

            // Is NV out there at Bus1 Dev0?
            if ((tempvid != 0x10DE) || ((tempdid & 0xFFF0) != 0x00A0))
                return;

            // Get the original handle back
            handle = osPciInitHandle(0, 0, 0, &vendorID, &deviceID);
            if (!handle)
                return;
        }
        else
            return;
    }

    data32 = osPciReadDword(handle, 0xF4);    // Clock Freq register

    hclk_freq = (data32 >> 6) & 0x03;   // hclk_freq [7:6]
    mclk_freq = (data32 >> 4) & 0x03;   // mclk_freq [5:4]

    switch (hclk_freq)
    {
        case 2:
            pRmInfo->Processor.HalInfo.FrontSideBusFreq = 133000000;
            break;

        case 1:
            pRmInfo->Processor.HalInfo.FrontSideBusFreq = 100000000;
            break;

        case 0:
        default:
            pRmInfo->Processor.HalInfo.FrontSideBusFreq = 66000000;
            break;
    }

    switch (mclk_freq)
    {
        case 2:
            pRmInfo->Processor.HalInfo.SystemMemoryFreq = 133000000;
            break;

        case 1:
            pRmInfo->Processor.HalInfo.SystemMemoryFreq = 100000000;
            break;

        case 0:
        default:
            pRmInfo->Processor.HalInfo.SystemMemoryFreq = 66000000;
            break;
    }
}

#if defined(DEBUG) && !defined(IA64)
static char *MTRR_Typenames[] = {
    "NVRM:      Type Uncached\n",
    "NVRM:      Type WriteCombined\n",
    "NVRM:      Type Reserved\n",
    "NVRM:      Type Reserved\n",
    "NVRM:      Type WriteThrough\n",
    "NVRM:      Type WriteProtected\n",
    "NVRM:      Type WriteBack\n",
    "NVRM:      Type Reserved\n"
};

//
// This routine is used to make sure the MTRRs are setup the way we think
// they should be. Manually edit the mtrr_done_once variable, if you want
// to see the output post-boot.
//
VOID dbgDumpMTRRs(VOID)
{
    U032 i, numRanges = 0, mtrrAddr;
    U032 BaseHi, BaseLo, MaskHi, MaskLo, Type;
    static U032 mtrr_done_once = 0;
#ifdef __GNUC__
    U032 eax, ebx, ecx, edx;
#endif

     if (mtrr_done_once)
        return;
    mtrr_done_once = 1;

#ifdef __GNUC__
    // if nv_cpuid() returns 0, then this cpu does not support cpuid instruction
    // We just worry about this on the first call...
    if ( ! nv_cpuid(0x00000001/*cpuid op*/, &eax, &ebx, &ecx, &edx))
        return;

    // Is MTRR supported?
    if (0 == (edx & 0x1000))
        return;

    if ( ! nv_rdmsr(254/*address*/, &eax, &edx))
        return;
    if (0 == (eax & 0x400))
        return;
    
    numRanges = eax & 0xFF;

#else

#define CPUID   __asm _emit 0x0F __asm _emit 0xA2
#define RDMSR   __asm _emit 0x0F __asm _emit 0x32

    __asm
    {
        ; save state
        push    eax
        push    ebx
        push    ecx
        push    edx

        pushfd
        pop     eax
        mov     ebx, eax
        xor     eax, 0x00200000
        push    eax
        popfd
        pushfd
        pop     eax
        cmp     eax, ebx
        je      Exit                // CPUID inst not supported

        mov     eax, 1
        CPUID
        and     edx, 0x1000         // check for MTRR support
        jz      Exit

        mov     ecx, 254            // read the MTRRcap MSR to determine number of ranges.
        RDMSR
        test    eax, 0x400          // check that WC as a type is supported (should be 1).
        jz      Exit

        and     eax, 0xFF           // save number of ranges
        mov     numRanges, eax
Exit:    
        ; restore state
        pop     edx
        pop     ecx
        pop     ebx
        pop     eax
    }
#endif

    // Use a high DEBUGLEVEL for these strings, since this is normally done once.
    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Valid MTRRs:\n");

    // Now determine if we find a Write Combined match in the MTRRs
    for (i = 0, mtrrAddr = 512; i < numRanges; i++, mtrrAddr += 2)
    {
#ifdef __GNUC__
        nv_rdmsr(mtrrAddr, &BaseLo, &BaseHi);
        nv_rdmsr(mtrrAddr+1, &MaskLo, &MaskHi);        
#else
        __asm {
            ; save state
            push    eax
            push    ebx
            push    ecx
            push    edx

            mov     ecx, mtrrAddr
            RDMSR

            mov     BaseHi, edx
            mov     BaseLo, eax

            mov     ecx, mtrrAddr
            add     ecx, 1
            RDMSR

            mov     MaskHi, edx
            mov     MaskLo, eax

            ; restore state
            pop     edx
            pop     ecx
            pop     ebx
            pop     eax
        }
#endif

        if (!(MaskLo & 0x800))
            continue;               // valid bit not set

        Type = BaseLo & 0xFF;      // set the type
        if (Type >= 0x8)
            Type = 0x7;            // reserved, if it's too large

        MaskLo &= ~0xFFF;          // mask off the valid bit
        BaseLo &= ~0xFFF;          // mask off the type bits

        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: Range ", i);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM:      Base ", BaseLo);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM:    Length ", (~(MaskLo & ~0xFFF)) + 1);
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, MTRR_Typenames[Type]);
    }
}
#endif // defined(DEBUG) && !defined(IA64)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\common\src\nv\miscr0.c ===
/*----------------------------------------------------------------------------*/
/*
 * miscR0.c
 *
 *      misc ring0 functions
 *	
 */

/*----------------------------------------------------------------------------*/
/*
 * include files
 */

#define WANTVXDWRAPS 
#include <basedef.h>
#include <vmm.h>
#include <vxdldr.h>
//#include <debug.h>
#include <vxdwraps.h>
#include <vwin32.h>

#include "nvtypes.h"
#include "nvrmr0api.h"
#include "nvrmwin.h"
#include "nvos.h"

/*----------------------------------------------------------------------------*/
/*
 * pragma's to put the code and data into locked memory (XXX not sure if needed)
 */

#pragma VxD_LOCKED_CODE_SEG
#pragma VxD_LOCKED_DATA_SEG

/*----------------------------------------------------------------------------*/
/*
 * globals
 */

typedef DWORD (* LPDWFN)();
    
/*----------------------------------------------------------------------------*/
/*
 * getApiProcR0 - get the API Proc entry point for a given Vxd from Ring0
 */

LPDWFN getApiProcR0(PCHAR nameVxd)
{

    DWORD	    rc;
    PVMMDDB	    pddb;
    PDEVICEINFO	pdevinfo = NULL;
    
    rc = VXDLDR_LoadDevice( &pddb, &pdevinfo, nameVxd, TRUE); /* XXX what does TRUE do? */
                                                              /* XXX what's the return value */
    if ( (pdevinfo == NULL) || (pddb == NULL) ) {
        return ( NULL );
    }
    else {
        return ( (LPDWFN) pddb->DDB_PM_API_Proc );
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\common\src\nv\nvapi.c ===
/******************************************************************************
*
*	Module: nvapi.c
*
*   Description:
*       This module is the main entry module into the NV Architecture Driver.
*
*
*   THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
*   NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
*   IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
*
******************************************************************************/

#include <nvrm.h>
#include <nv32.h>
#include <nv_ref.h>
#include <nvhw.h>
#include <rmfail.h>

#include <state.h>
#include <class.h>
#include <vblank.h>
#include <dma.h>
#include <event.h>
#include <fifo.h>
#include <fb.h>
#include <gr.h>
#include <heap.h>
#include <tmr.h>
#include <mc.h>
#include <client.h>

#include <os.h>
#include <nvos.h>
#include <nvarch.h>
#include <smp.h>

PCLIENTINFO clientInfo;
U032        ClientInstance;
#ifdef DEBUG
PCLIENTINFO pClient;
U032 clientSize = sizeof(CLIENTINFO);
#endif

// NV4+ passes around an element of this table instead of using a global index
PHWINFO     NvDBPtr_Table[MAX_INSTANCE]={NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL};

RMINFO      NvRmInfo;

// globals used by the OS specific calls
U032        nvInfoSelector      = 0;
U032        clientInfoSelector  = 0;
U032        rmInService;
U032        osInService;
U032        rmInSafeService;
U032        rmInCallback;

// NV RM API functions

/*
NV01_ALLOC_ROOT
    NVOS01_PARAMETERS:
        NvV32 hObjectNew
        NvV32 hClass
        NvV32 status
*/
VOID Nv01AllocRoot(
    NVOS01_PARAMETERS *pArgs
)
{
    DBG_PRINT_STRING      (DEBUGLEVEL_TRACEINFO, "NVRM: Allocating root...\n");
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM:    class:", ARG(hClass));

    ARG(status) = RmAllocClient(
        &ARG(hObjectNew),
        ARG(hClass)
    );
    if (ARG(status) == NVOS01_STATUS_SUCCESS)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM:   client:", ARG(hObjectNew));
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: ...root object allocation complete\n");
    }
    else
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: ...root object allocation *FAILED*\n");
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS , "NVRM:    status:", ARG(status));
    }

} // end of Nv01AllocRoot()

/*
NV01_ALLOC_DEVICE
    NVOS06_PARAMETERS:
        NvV32 hObjectParent
        NvV32 hObjectNew
        NvV32 hClass
        NvP64 szName
        NvV32 status
*/
VOID Nv01AllocDevice(
    NVOS06_PARAMETERS *pArgs
)
{
    DBG_PRINT_STRING      (DEBUGLEVEL_TRACEINFO, "NVRM: Allocating device...\n");
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM:   client:", ARG(hObjectParent));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM:   device:", ARG(hObjectNew));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM:    class:", ARG(hClass));

    NVRM_TRACE_API('ADEV', ARG(hObjectParent), ARG(hObjectNew), ARG(hClass));
 
    ARG(status) = RmAllocDevice(
        ARG(hObjectParent),
        ARG(hObjectNew),
        ARG(hClass),
#if _WIN32_WINNT >= 0x0400
        (char*)ARG_P064(szName)
#else
        (char*)ARG(szName)
#endif
    );
    if (ARG(status) == NVOS06_STATUS_SUCCESS)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: ...device allocation complete\n");
        NVRM_TRACE('adev');
    }
    else
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: ...device allocation *FAILED*\n");
        NVRM_TRACE_ERROR('adev', ARG(status));
    }

} // end of Nv01AllocDevice()

/*
NV01_ALLOC_CONTEXT_DMA
    NVOS03_PARAMETERS:
        NvV32 hObjectParent
        NvV32 hObjectNew
        NvV32 hClass
        NvV32 flags
        NvP64 pBase
        NvU64 limit
        NvV32 status
*/
VOID Nv01AllocContextDma(
    NVOS03_PARAMETERS *pArgs
)
{
    DBG_PRINT_STRING      (DEBUGLEVEL_TRACEINFO, "NVRM: Allocating DMA context...\n");
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM:    client:", ARG(hObjectParent));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM:   context:", ARG(hObjectNew));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM:     class:", ARG(hClass));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM:     flags:", ARG(flags));
    DBG_PRINT_STRING_PTR  (DEBUGLEVEL_TRACEINFO, "NVRM:     pBase:", (VOID*)ARG_P064(pBase));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM:     limit:", (U032)ARG_U064(limit));

    NVRM_TRACE_API('ACTX', ARG(hObjectParent), ARG(hObjectNew), ARG(hClass));
    NVRM_TRACE3(ARG(flags), (U032) ARG_P064(pBase), (U032) ARG_U064(limit));

    ARG(status) = RmAllocContextDma(
        ARG(hObjectParent),
        ARG(hObjectNew),
        ARG(hClass),
        ARG(flags),
        ARG_SELECTOR(pBase),
        (VOID *)ARG_P064(pBase),
        (U032)ARG_U064(limit)
    );
    if (ARG(status) == NVOS03_STATUS_SUCCESS)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: ...DMA context allocation complete\n");
        NVRM_TRACE('actx');
    }
    else
    {
        DBG_PRINT_STRING      (DEBUGLEVEL_ERRORS, "NVRM: ...DMA context allocation *FAILED*\n");
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS , "NVRM:    client:", ARG(hObjectParent));
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS , "NVRM:   context:", ARG(hObjectNew));
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS , "NVRM:     class:", ARG(hClass));
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS , "NVRM:     flags:", ARG(flags));
        DBG_PRINT_STRING_PTR  (DEBUGLEVEL_USERERRORS , "NVRM:     pBase:", (VOID*)ARG_P064(pBase));
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS , "NVRM:     limit:", (U032)ARG_U064(limit));
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS , "NVRM:    status:", ARG(status));
        NVRM_TRACE_ERROR('actx', ARG(status));
    }

} // end of Nv01AllocContextDma()

/*
NV01_ALLOC_CHANNEL_PIO
    NVOS04_PARAMETERS:
        NvV32 hRoot;
        NvV32 hObjectParent
        NvV32 hObjectNew
        NvV32 hClass
        NvV32 hObjectError
        NvP64 pChannel
        NvV32 flags
        NvV32 status
*/
VOID Nv01AllocChannelPio(
    NVOS04_PARAMETERS *pArgs
)
{
    VOID *channel;

    DBG_PRINT_STRING      (DEBUGLEVEL_TRACEINFO,  "NVRM: Allocating PIO channel...\n");
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:    client:", ARG(hRoot));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:    device:", ARG(hObjectParent));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:   channel:", ARG(hObjectNew));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:     class:", ARG(hClass));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:     error:", ARG(hObjectError));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:     flage:", ARG(flags));

    // allocate the PIO channel
    ARG(status) = RmAllocChannelPio(
        ARG(hRoot),
        ARG(hObjectParent),
        ARG(hObjectNew),
        ARG(hClass),
        ARG(hObjectError),
        &channel,
        ARG(flags)
    );
    ARG_P064(pChannel) = (NvP64_VALUE_T)channel;
    if (ARG(status) == NVOS04_STATUS_SUCCESS)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,  "NVRM: ...PIO channel allocation complete\n");
    }
    else
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,  "NVRM: ...PIO channel allocation *FAILED*\n");
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS , "NVRM:    status:", ARG(status));
    }

} // end of Nv01AllocChannelPio()

/*
NV03_ALLOC_CHANNEL_DMA
    NVOS07_PARAMETERS:
        NvV32 hRoot;
        NvV32 hObjectParent
        NvV32 hObjectNew
        NvV32 hClass
        NvV32 hObjectError
        NvV32 hObjectBuffer
        NvU32 offset
        NvP64 pControl
        NvV32 status
*/
VOID Nv03AllocChannelDma(
    NVOS07_PARAMETERS *pArgs
)
{
    VOID *control;

    DBG_PRINT_STRING      (DEBUGLEVEL_TRACEINFO,  "NVRM: Allocating DMA channel...\n");
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:      client:", ARG(hRoot));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:      device:", ARG(hObjectParent));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:     channel:", ARG(hObjectNew));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:       class:", ARG(hClass));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:   error ctx:", ARG(hObjectError));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:    data ctx:", ARG(hObjectBuffer));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:      offset:", ARG(offset));

    // allocate DMA channel
    ARG(status) = RmAllocChannelDma(
        ARG(hRoot),
        ARG(hObjectParent),
        ARG(hObjectNew),
        ARG(hClass),
        ARG(hObjectError),
        ARG(hObjectBuffer),
        ARG(offset),
        &control
    );
    ARG_P064(pControl) = (NvP64_VALUE_T)control;
    if (ARG(status) == NVOS07_STATUS_SUCCESS)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,  "NVRM: ...DMA channel allocation complete\n");
    }
    else
    {
        DBG_PRINT_STRING      (DEBUGLEVEL_ERRORS,  "NVRM: ...DMA channel allocation *FAILED*\n");
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS ,  "NVRM:      client:", ARG(hRoot));
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS ,  "NVRM:      device:", ARG(hObjectParent));
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS ,  "NVRM:     channel:", ARG(hObjectNew));
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS ,  "NVRM:       class:", ARG(hClass));
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS ,  "NVRM:   error ctx:", ARG(hObjectError));
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS ,  "NVRM:    data ctx:", ARG(hObjectBuffer));
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS ,  "NVRM:      offset:", ARG(offset));
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS ,  "NVRM:      status:", ARG(status));
    }

} // end of Nv03AllocChannelDma()

/*
NV01_ALLOC_MEMORY
        NVOS02_PARAMETERS:
        NvV32 hRoot;       
        NvV32 hObjectParent;
        NvV32 hObjectNew;
        NvV32 hClass;
        NvV32 flags;
        NvP64 pMemory;
        NvU64 pLimit;
        NvV32 status;
*/
VOID Nv01AllocMemory(
    NVOS02_PARAMETERS *pArgs
)
{
    VOID *memory;
    U032 limit;

    DBG_PRINT_STRING      (DEBUGLEVEL_TRACEINFO,  "NVRM: Allocating memory...\n");
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:    client:", ARG(hRoot));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:    parent:", ARG(hObjectParent));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:    memory:", ARG(hObjectNew));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:     class:", ARG(hClass));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:     flags:", ARG(flags));
    DBG_PRINT_STRING_PTR  (DEBUGLEVEL_TRACEINFO,  "NVRM:   pMemory:", (VOID*)ARG_P064(pMemory));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:     limit:", (U032)ARG_U064(pLimit));

    // allocate memory

    memory = (VOID *)ARG_P064(pMemory);
    limit = (U032)ARG_U064(pLimit);

    NVRM_TRACE_API('AMEM', ARG(hObjectParent), ARG(hObjectNew), ARG(hClass));
    NVRM_TRACE3(ARG(flags), (U032) ARG_P064(pMemory), (U032) ARG_U064(pLimit));

    ARG(status) = RmAllocMemory(
        ARG(hRoot),
        ARG(hObjectParent),
        ARG(hObjectNew),
        ARG(hClass),
        ARG(flags),
        &memory,
        &limit
    );

    ARG_P064(pMemory) = (NvP64_VALUE_T)memory;
    ARG_U064(pLimit) = (NvU64_VALUE_T)limit;

    if (ARG(status) == NVOS02_STATUS_SUCCESS)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,  "NVRM: ...memory allocation complete\n");
        NVRM_TRACE2('amem', (U032) memory);
    }
    else
    {
        DBG_PRINT_STRING      (DEBUGLEVEL_ERRORS,  "NVRM: ...memory allocation *FAILED*\n");
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS ,  "NVRM:    client:", ARG(hRoot));
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS ,  "NVRM:    parent:", ARG(hObjectParent));
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS ,  "NVRM:    memory:", ARG(hObjectNew));
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS ,  "NVRM:     class:", ARG(hClass));
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS ,  "NVRM:     flags:", ARG(flags));
        DBG_PRINT_STRING_PTR  (DEBUGLEVEL_USERERRORS ,  "NVRM:   pMemory:", (VOID*)ARG_P064(pMemory));
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS ,  "NVRM:     limit:", (U032)ARG_U064(pLimit));
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS ,  "NVRM:    status:", ARG(status));
        NVRM_TRACE_ERROR('amem', ARG(status));
    }

} // end of Nv01AllocMemory()


/*
NV01_ALLOC_DEVICE
    NVOS05_PARAMETERS
        NvV32 hRoot;
        NvV32 hObjectParent;
        NvV32 hObjectNew;
        NvV32 hClass;
        NvV32 status;
*/
VOID Nv01AllocObject(
    NVOS05_PARAMETERS *pArgs
)
{
    DBG_PRINT_STRING      (DEBUGLEVEL_TRACEINFO,  "NVRM: Allocating object...\n");
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:    client:", ARG(hRoot));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:   channel:", ARG(hObjectParent));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:    object:", ARG(hObjectNew));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:     class:", ARG(hClass));

    NVRM_TRACE_API('AOBJ', ARG(hObjectParent), ARG(hObjectNew), ARG(hClass));

    ARG(status) = RmAllocObject(
        ARG(hRoot),
        ARG(hObjectParent),
        ARG(hObjectNew),
        ARG(hClass)
    );
    if (ARG(status) == NVOS05_STATUS_SUCCESS)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,  "NVRM: ...object allocation complete\n");
        NVRM_TRACE('aobj');
    }
    else
    {
        DBG_PRINT_STRING      (DEBUGLEVEL_ERRORS,       "NVRM: ...object allocation *FAILED*\n");
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS ,  "NVRM:    client:", ARG(hRoot));
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS ,  "NVRM:   channel:", ARG(hObjectParent));
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS ,  "NVRM:    object:", ARG(hObjectNew));
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS ,  "NVRM:     class:", ARG(hClass));
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS ,  "NVRM:    status:", ARG(status));
        NVRM_TRACE_ERROR('aobj', ARG(status));
    }

} // end of Nv01AllocObject()

/*
NV04_ALLOC
    NVOS21_PARAMETERS;
        NvV32 hRoot;
        NvV32 hObjectParent;
        NvV32 hObjectNew;
        NvV32 hClass;
        NvP64 pAllocParms;
        NvV32 status;
*/
VOID Nv04Alloc(
    NVOS21_PARAMETERS *pArgs
)
{
    DBG_PRINT_STRING      (DEBUGLEVEL_TRACEINFO,  "NVRM: Allocating object...\n");
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:    client:", ARG(hRoot));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:   channel:", ARG(hObjectParent));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:    object:", ARG(hObjectNew));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:     class:", ARG(hClass));

    NVRM_TRACE_API('ALOC', ARG(hObjectParent), ARG(hObjectNew), ARG(hClass));
    NVRM_TRACE((U032) ARG_P064(pAllocParms));

    ARG(status) = RmAlloc(
        ARG(hRoot),
        ARG(hObjectParent),
        ARG(hObjectNew),
        ARG(hClass),
        (VOID *) ARG_P064(pAllocParms)
    );
    if (ARG(status) == NVOS21_STATUS_SUCCESS)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,  "NVRM: ...allocation complete\n");
        NVRM_TRACE('aloc');
    }
    else
    {
        DBG_PRINT_STRING      (DEBUGLEVEL_ERRORS,       "NVRM: ...allocation *FAILED*\n");
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS ,  "NVRM:    client:", ARG(hRoot));
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS ,  "NVRM:   channel:", ARG(hObjectParent));
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS ,  "NVRM:    object:", ARG(hObjectNew));
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS ,  "NVRM:     class:", ARG(hClass));
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS ,  "NVRM:    status:", ARG(status));
        NVRM_TRACE_ERROR('aloc', ARG(status));
    }

} // end of Nv04Alloc()

/*
NV01_ALLOC_EVENT
    NVOS10_PARAMETERS:
        NvV32 hRoot;
        NvV32 hObjectParent;
        NvV32 hObjectNew;
        NvV32 hClass;
        NvV32 index;
        NvU64 hEvent;
        NvV32 status;
*/
VOID Nv01AllocEvent(
    NVOS10_PARAMETERS *pArgs
)
{
    DBG_PRINT_STRING      (DEBUGLEVEL_TRACEINFO,  "NVRM: Allocating Event...\n");
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:   client:", ARG(hRoot));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:  channel:", ARG(hObjectParent));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:   object:", ARG(hObjectNew));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:   class:",  ARG(hClass));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:   index:",  ARG(index));
    DBG_PRINT_STRING_VAL64(DEBUGLEVEL_TRACEINFO,  "NVRM:   event:",  ARG(hEvent));

    ARG(status) = RmAllocEvent(
        ARG(hRoot),
        ARG(hObjectParent),
        ARG(hObjectNew),
        ARG(hClass),
        ARG(index),
        ARG(hEvent)
    );
    if (ARG(status) == NVOS10_STATUS_SUCCESS)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,  "NVRM: ...event allocation complete\n");
    }
    else
    {
        DBG_PRINT_STRING      (DEBUGLEVEL_ERRORS,       "NVRM: ...event allocation *FAILED*\n");
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS ,  "NVRM:    client:", ARG(hRoot));
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS ,  "NVRM:   channel:", ARG(hObjectParent));
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS ,  "NVRM:    object:", ARG(hObjectNew));
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS ,  "NVRM:     class:", ARG(hClass));
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS ,  "NVRM:     index:",  ARG(index));
        DBG_PRINT_STRING_VAL64(DEBUGLEVEL_USERERRORS ,  "NVRM:     event:",  ARG(hEvent));
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS ,  "NVRM:    status:", ARG(status));
    }

} // end of Nv01AllocEvent()

/*
NV01_FREE
    NVOS00_PARAMETERS:
        NvV32 hRoot;
        NvV32 hObjectParent;
        NvV32 hObjectOld;
        NvV32 status;
*/
VOID Nv01Free(
    NVOS00_PARAMETERS *pArgs
)
{
    DBG_PRINT_STRING      (DEBUGLEVEL_TRACEINFO,  "NVRM: Freeing object...\n");
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:   client:", ARG(hRoot));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:   parent:", ARG(hObjectParent));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:   object:", ARG(hObjectOld));

    NVRM_TRACE_API('FREE', ARG(hRoot), ARG(hObjectParent), ARG(hObjectOld));

    ARG(status) = RmFree(
        ARG(hRoot),
        ARG(hObjectParent),
        ARG(hObjectOld)
    );
    if (ARG(status) == NVOS00_STATUS_SUCCESS)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,  "NVRM: ...object free complete\n");
        NVRM_TRACE('free');
    }
    else
    {
        DBG_PRINT_STRING      (DEBUGLEVEL_ERRORS,       "NVRM: ...object free *FAILED*\n");
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS ,  "NVRM:   client:", ARG(hRoot));
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS ,  "NVRM:   parent:", ARG(hObjectParent));
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS ,  "NVRM:   object:", ARG(hObjectOld));
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS ,  "NVRM:   status:", ARG(status));
        NVRM_TRACE_ERROR('free', ARG(status));
    }

} // end of Nv01Free()

/*
NV03_DMA_FLOW_CONTROL
    NVOS08_PARAMETERS:
        NvV32 hChannel
        NvV32 flags
        NvU32 put
        NvU32 get
        NvV32 status
*/
VOID Nv03DmaFlowControl(
    NVOS08_PARAMETERS *pArgs
)
{
    // This function is not valid on NV4 and later devices.
    ARG(status) = NVOS08_STATUS_ERROR_BAD_OBJECT_PARENT;
    if (ARG(status) == NVOS08_STATUS_SUCCESS)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,  "NVRM: ...DMA channel flow control complete\n");
    }
    else
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,  "NVRM: ...DMA channel flow control *FAILED*\n");
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS , "NVRM:    status:", ARG(status));
    }
} // end of Nv3DmaFlowControl()

/*
NV01_ARCH_HEAP
    NVOS11_PARAMETERS;
        NvV32 hRoot;
        NvV32 hObjectParent;
        NvU32 function;
        NvU32 owner;
        NvU32 type;
        NvU32 depth;
        NvU32 width;
        NvU32 height;
        NvS32 pitch;
        NvU32 offset;
        NvU32 size;
        NvP64 address;
        NvU64 limit;
        NvU32 total;
        NvU32 free;
        NvV32 status;
*/
VOID Nv03ArchHeap(
    NVOS11_PARAMETERS *pArgs
)
{
    VOID *address;
    
	DBG_PRINT_STRING      (DEBUGLEVEL_TRACEINFO,  "NVRM: Arch Heap...\n");
	DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:   Client:", ARG(hRoot));
	DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:   Device:", ARG(hObjectParent));

    NVRM_TRACE_API('HEAP', ARG(hObjectParent), ARG(function), ARG(owner));
    NVRM_TRACE3(ARG(type), ARG(width), ARG(height));

    ARG(status) = RmArchHeap(
        ARG(hRoot),
        ARG(hObjectParent),
        ARG(function),
        ARG(owner),
        ARG(type),
        ARG(depth),
        ARG(width),
        ARG(height),
        &ARG(pitch),
        &ARG(offset),
        &ARG(size),
        &address,
        &ARG(limit),
        &ARG(total),
        &ARG(free)
    );
#if defined(NVRM_64)
    ARG_P064(address) = (NvP64_VALUE_T)address;
#else
    ARG(address) = (NvU32)address;
#endif
    if (ARG(status) == NVOS11_STATUS_SUCCESS)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,  "NVRM: ...Arch Heap complete\n");
        NVRM_TRACE2('heap', (U032) address);
    }
    else
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,  "NVRM: ...Arch Heap *FAILED*\n");
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS ,  "NVRM:    status:", ARG(status));
        NVRM_TRACE_ERROR('heap', ARG(status));
    }
} // end of Nv03ArchHeap()

/*
NV01_CONFIG_VERSION:
    NVOS12_PARAMETERS:
        NvV32 hClient;
        NvV32 hDevice;
        NvV32 version;
        NvV32 status;
*/
VOID Nv01ConfigVersion(
    NVOS12_PARAMETERS *pArgs
)
{
    DBG_PRINT_STRING      (DEBUGLEVEL_TRACEINFO,  "NVRM: Config Version...\n");
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:   Client:", ARG(hClient));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:   Device:", ARG(hDevice));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:  Version:", ARG(version));

    ARG(status) = RmConfigVersion(
        ARG(hClient),
        ARG(hDevice),
        &ARG(version)
    );
    if (ARG(status) == NVOS12_STATUS_SUCCESS)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,  "NVRM: ...Config Version complete\n");
    }
    else
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,  "NVRM: ...Config Version *FAILED*\n");
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS ,  "NVRM:    status:", ARG(status));
    }

} // end of Nv01ConfigVersion()

/*
NV01_CONFIG_GET:
    NVOS13_PARAMETERS:
      NvV32 hClient;
      NvV32 hDevice;
      NvV32 index;
      NvV32 value;
      NvV32 status;
*/
VOID Nv01ConfigGet(
    NVOS13_PARAMETERS *pArgs
)
{
    DBG_PRINT_STRING      (DEBUGLEVEL_TRACEINFO,  "NVRM: Config Get...\n");
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:   Client:", ARG(hClient));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:   Device:", ARG(hDevice));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:    Index:", ARG(index));

    // get a specific configuration value
    ARG(status) = RmConfigGet(
        ARG(hClient),
        ARG(hDevice),
        ARG(index),
        &ARG(value)
    );
    if (ARG(status) == NVOS13_STATUS_SUCCESS)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,  "NVRM: ...Config Get complete\n");
    }
    else
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,  "NVRM: ...Config Get *FAILED*\n");
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS ,  "NVRM:    status:", ARG(status));
    }

} // end of Nv01ConfigGet()

/*
NV01_CONFIG_SET:
    NVOS14_PARAMETERS:
      NvV32 hClient;
      NvV32 hDevice;
      NvV32 index;
      NvV32 oldValue;
      NvV32 newValue;
      NvV32 status;
*/
VOID Nv01ConfigSet(
    NVOS14_PARAMETERS *pArgs
)
{
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,  "NVRM: Setting Configuration...\n");
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:    Client:", ARG(hClient));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:    Device:", ARG(hDevice));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:     Index:", ARG(index));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:     Value:", ARG(newValue));

    // set a specific configuration value
    ARG(status) = RmConfigSet(
        ARG(hClient),
        ARG(hDevice),
        ARG(index),
        &ARG(oldValue),
        ARG(newValue)
    );
    if (ARG(status) == NVOS14_STATUS_SUCCESS)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,  "NVRM: ...Config Set complete\n");
    }
    else
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,  "NVRM: ...Config Set *FAILED*\n");
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS ,  "NVRM:    status:", ARG(status));
    }

} // end of Nv01ConfigSet()

/*
NV01_CONFIG_UPDATE:
    NVOS15_PARAMETERS:
        NvV32 hClient;
        NvV32 hDevice;
        NvV32 flags;
        NvV32 status;
*/
VOID Nv01ConfigUpdate(
    NVOS15_PARAMETERS *pArgs
)
{
    DBG_PRINT_STRING      (DEBUGLEVEL_TRACEINFO,  "NVRM: Config Update...\n");
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:   Client:", ARG(hClient));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:   Device:", ARG(hDevice));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:    Flags:", ARG(flags));

    ARG(status) = RmConfigUpdate(
        ARG(hClient),
        ARG(hDevice),
        ARG(flags)
    );
    if (ARG(status) == NVOS15_STATUS_SUCCESS)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,  "NVRM: ...Config Update complete\n");
    }
    else
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,  "NVRM: ...Config Update *FAILED*\n");
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS ,  "NVRM:    status:", ARG(status));
    }

} // end of Nv01ConfigUpdate()

/*
NV04_CONFIG_GET_EX:
    NVOS_CONFIG_GET_EX_PARAMS:
        NvV32 hClient;
        NvV32 hDevice;
        NvV32 index;
        NvP64 paramStructPtr;
        NvU32 paramSize;
        NvV32 status;
*/
VOID Nv04ConfigGetEx(
    NVOS_CONFIG_GET_EX_PARAMS *pArgs
)
{
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,  "NVRM: config getEx...\n");
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:    Client:", ARG(hClient));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:    Device:", ARG(hDevice));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:     Index:", ARG(index));
#if _WIN32_WINNT >= 0x0400
    DBG_PRINT_STRING_PTR  (DEBUGLEVEL_TRACEINFO,  "NVRM:  Parm Ptr:", (VOID*)ARG_P064(paramStructPtr));
#else
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:  Parm Ptr:", ARG(paramStructPtr));
#endif
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM: Parm size:", ARG(paramSize));

    ARG(status) = RmConfigGetEx(
        ARG(hClient),
        ARG(hDevice),
        ARG(index),
#if _WIN32_WINNT >= 0x0400
        (VOID*)ARG_P064(paramStructPtr),
#else
        (VOID*)ARG(paramStructPtr),
#endif
        ARG(paramSize)
    );
    if (ARG(status) == NVOS_CGE_STATUS_SUCCESS)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,  "NVRM: ...config getEx complete\n");
    }
    else
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,  "NVRM: ...config getEx *FAILED*\n");
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS ,  "NVRM:    status:", ARG(status));
    }

} // end of Nv04ConfigGetEx()

/*
NV04_CONFIG_SET_EX:
    NVOS_CONFIG_SET_EX_PARAMS:
        NvV32 hClient;
        NvV32 hDevice;
        NvV32 index;
        NvP64 paramStructPtr;
        NvU32 paramSize;
        NvV32 status;
*/
VOID Nv04ConfigSetEx(
    NVOS_CONFIG_SET_EX_PARAMS *pArgs
)
{
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,  "NVRM: config SetEx...\n");
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:    Client:", ARG(hClient));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:    Device:", ARG(hDevice));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:     Index:", ARG(index));
#if _WIN32_WINNT >= 0x0400
    DBG_PRINT_STRING_PTR  (DEBUGLEVEL_TRACEINFO,  "NVRM:  Parm Ptr:", (VOID*)ARG_P064(paramStructPtr));
#else
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:  Parm Ptr:", ARG(paramStructPtr));
#endif
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM: Parm size:", ARG(paramSize));

    ARG(status) = RmConfigSetEx(
        ARG(hClient),
        ARG(hDevice),
        ARG(index),
#if _WIN32_WINNT >= 0x0400
        (VOID*)ARG_P064(paramStructPtr),
#else
        (VOID*)ARG(paramStructPtr),
#endif
        ARG(paramSize)
    );
    if (ARG(status) == NVOS_CSE_STATUS_SUCCESS)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,  "NVRM: ...config SetEx complete\n");
    }
    else
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,  "NVRM: ...config SetEx *FAILED*\n");
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS ,  "NVRM:    status:", ARG(status));
    }

} // end of Nv04ConfigSetEx()

/*
NV01_INTERRUPT:
    NVOS09_PARAMETERS:
        NvV32 hClient;
        NvV32 hDevice;
        NvV32 status;
*/

VOID Nv01Interrupt(
    NVOS09_PARAMETERS *pArgs
)
{
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,  "NVRM: interrupt...\n");
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:    Client:", ARG(hClient));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:    Device:", ARG(hDevice));


    // service an interrupt
    ARG(status) = RmInterrupt(
        ARG(hClient),
        ARG(hDevice)
    );
    if (ARG(status) == NVOS09_STATUS_SUCCESS)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,  "NVRM: ...interrupt service complete\n");
    }
    else
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,  "NVRM: ...interrupt service *FAILED*\n");
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS ,  "NVRM:    status:", ARG(status));
    }

} // end of Nv01Interrupt()

#ifdef WIN32
/*
NV04_RING0_CALLBACK:
    NVRM_RING0CALLBACK_PARAMS:
        NvV32 hClient;
        NvV32 hDevice;
        NvP64 functionPtr;
        NvU32 param1;
        NvU32 param2;
        NvV32 status;
    typedef NvU32 (*RING0CALLBACKPROC)(NvU32, NvU32);
*/
VOID NvRing0Callback(
    NVRM_RING0CALLBACK_PARAMS *pArgs
)
{
#if _WIN32_WINNT >= 0x0400
    RING0CALLBACKPROC callbackFct = (RING0CALLBACKPROC)ARG_P064(functionPtr);
#else
    RING0CALLBACKPROC callbackFct = ARG(functionPtr);
#endif

    DBG_PRINT_STRING      (DEBUGLEVEL_TRACEINFO,  "NVRM: Ring 0 Callback...\n");
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:   Client:", ARG(hClient));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:   Device:", ARG(hDevice));
#if _WIN32_WINNT >= 0x0400
    DBG_PRINT_STRING_PTR  (DEBUGLEVEL_TRACEINFO,  "NVRM:     func:", (VOID*)ARG_P064(functionPtr));
#else
    DBG_PRINT_STRING_PTR  (DEBUGLEVEL_TRACEINFO,  "NVRM:     func:", (VOID*)ARG(functionPtr));
#endif
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:   param1:", ARG(param1));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:   param2:", ARG(param2));

    ARG(status) = callbackFct(
        ARG(param1),
        ARG(param2)
    );
    if (ARG(status) == NVOS16_STATUS_SUCCESS)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,  "NVRM: ...Ring 0 Callback complete\n");
    }
    else
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,  "NVRM: ...Ring 0 Callback *FAILED*\n");
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS ,  "NVRM:    status:", ARG(status));
    }

} // end of NvRing0Callback()
#endif

/*
NV04_I2C_ACCESS
    NVOS_I2C_ACCESS_PARAMS:
        NvV32 hClient;
        NvV32 hDevice;
        NvP64 paramStructPtr;
        NvU32 paramSize;
        NvV32 status;
*/
VOID Nv04I2CAccess(
    NVOS_I2C_ACCESS_PARAMS *pArgs
)
{
    DBG_PRINT_STRING      (DEBUGLEVEL_TRACEINFO,  "NVRM: I2C Access...\n");
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:   Client:", ARG(hClient));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:   Device:", ARG(hDevice));
#if _WIN32_WINNT >= 0x0400
    DBG_PRINT_STRING_PTR  (DEBUGLEVEL_TRACEINFO,  "NVRM:     func:", (VOID*)ARG_P064(paramStructPtr));
#else
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:     func:", ARG(paramStructPtr));
#endif
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:   Device:", ARG(paramSize));

    ARG(status) = RmI2CAccess(
        ARG(hClient),
        ARG(hDevice),
#if _WIN32_WINNT >= 0x0400
        (VOID*)ARG_P064(paramStructPtr)
#else
        (VOID*)ARG(paramStructPtr)
#endif
    );
    if (ARG(status) == NVOS_I2C_ACCESS_STATUS_SUCCESS)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,  "NVRM: ...I2C Access complete\n");
    }
    else
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,  "NVRM: ...I2C Access *FAILED*\n");
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS ,  "NVRM:    status:", ARG(status));
    }

} // end of Nv04I2CAccess()

/*
NV04_DIRECT_METHOD_CALL
    NVOS1D_PARAMETERS:
        NvV32 hRoot;
        NvV32 hObjectParent;
        NvV32 hObjectOld;
        NvV32 method;
        NvV32 data;
        NvV32 status;
*/
VOID Nv04DirectMethodCall(
    NVOS1D_PARAMETERS *pArgs
)
{
    DBG_PRINT_STRING      (DEBUGLEVEL_TRACEINFO,  "NVRM: Performing Direct Method Call...\n");
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:   client:", ARG(hRoot));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:   channel:", ARG(hObjectParent));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:   object:", ARG(hObjectOld));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:   method:", ARG(method));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:   data:", ARG(data));

    ARG(status) = RmDirectMethodCall(
        ARG(hRoot),
        ARG(hObjectParent),
        ARG(hObjectOld),
        ARG(method),
        ARG(data)
    );
    if (ARG(status) == NVOS1D_STATUS_SUCCESS)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,  "NVRM: ...DMC complete\n");
    }
    else
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,  "NVRM: ...DMC *FAILED*\n");
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS ,  "NVRM:    status:", ARG(status));
    }

} // end of Nv04DirectMethodCall()

NvV32 RmAllocClient(
    U032 *phClient,
    U032 hClass
)
{
    RM_STATUS rmStatus = RM_OK;

    // register a new client and return the client handle
    rmStatus = CliAddClient(phClient, hClass);

    return RmArchStatus(rmStatus, NV01_ALLOC_ROOT);

} // end of RmAllocClient

NvV32 RmAllocDevice(
    NvV32 hClient,
    NvV32 hDevice,
    NvV32 hClass,
    char *szName
)
{
    RM_STATUS rmStatus = RM_OK;
    PCLI_DMA_INFO pDmaInfo;
    PDMAOBJECT pDmaObject;
    PHWINFO pDev;

    // set the client context
    if (!CliSetClientContext(hClient))
    {
        return RmArchStatus(RM_ERR_BAD_OBJECT_PARENT, NV01_ALLOC_DEVICE);
    }

    // The caller has to either pass a valid device class (NV01_DEVICE_0 through NV01_DEVICE_7)
    // or pass NV03_DEVICE_XX as the hClass and pass the name of the device in szName.
    rmStatus = osDeviceNameToDeviceClass(szName, &hClass);
    if (!RM_SUCCESS(rmStatus))
    {
        return RmArchStatus(RM_ERR_BAD_CLASS, NV01_ALLOC_DEVICE);
    }

    // add new device to client and set the device context
    rmStatus = CliAddDevice(hClient, hDevice, hClass);
    if (!RM_SUCCESS(rmStatus))
    {
        return RmArchStatus(rmStatus, NV01_ALLOC_DEVICE);
    }
    if (!CliSetDeviceContext(hDevice, &pDev))
    {
        return RmArchStatus(RM_ERR_BAD_OBJECT_HANDLE, NV01_ALLOC_DEVICE);
    }

    // register all DMA contexts with the device
    for (pDmaInfo = CliGetDmaList(); pDmaInfo; pDmaInfo = pDmaInfo->Next)
    {
        rmStatus = dmaRegisterToDevice(pDev, pDmaInfo, &pDmaObject);
        if (!RM_SUCCESS(rmStatus))
        {
            return RmArchStatus(rmStatus, NV01_ALLOC_DEVICE);
        }
    }

    return RmArchStatus(rmStatus, NV01_ALLOC_DEVICE);

} // end of RmAllocDevice

NvV32 RmAllocContextDma(
    U032 hClient,
    U032 hDma,
    U032 hClass,
    U032 flags,
    U032 selector,
    VOID* base,
    U032 limit
)
{
    RM_STATUS rmStatus = RM_OK;
    PCLI_DMA_INFO pDmaInfo;
    PCLI_DEVICE_INFO deviceList = 0;
    PCLI_FIFO_INFO fifoList;
    PDMAOBJECT pDmaObject;
    U032 i, j, hDeviceWithFrameBufferCtx = 0;
    PHWINFO pDev;

    // A limit of 0 is not valid.
    if (limit == 0)
    {
        return NVOS03_STATUS_ERROR_BAD_LIMIT;
    }

    // set the client context
    if (!CliSetClientContext(hClient))
    {
        return RmArchStatus(RM_ERR_BAD_OBJECT_PARENT, NV01_ALLOC_CONTEXT_DMA);
    }

    // add DMA context to client
    rmStatus = CliAddDma(hClient, hDma, hClass, flags, selector, base, limit, &pDmaInfo);
    if (!RM_SUCCESS(rmStatus))
    {
        return RmArchStatus(rmStatus, NV01_ALLOC_CONTEXT_DMA);
    }

    // TO DO: USE FLAGS FOR CREATION??

    // lock down DMA pages -- zero length is not an error for legacy reasons
    if (pDmaInfo->DescLimit != 0)
    {
        // validate DMA buffer address, searching each device's FB
        if ((deviceList = CliGetDeviceList()) == NULL)
        {
            RmFreeContextDma(hClient, hDma);
            return RmArchStatus(RM_ERR_BAD_OBJECT_PARENT, NV01_ALLOC_CONTEXT_DMA);
        }
        for (i = 0; i < NUM_DEVICES; i++)
        {
            if (deviceList[i].InUse)
            {
                if (!CliSetDeviceContext(deviceList[i].Handle, &pDev))
                {
                    RmFreeContextDma(hClient, hDma);
                    return RmArchStatus(RM_ERR_BAD_OBJECT_PARENT, NV01_ALLOC_CONTEXT_DMA);
                }
                rmStatus = osGetAddressInfo(
                    pDev,
                    0 /* ChId */,
                    pDmaInfo->DescSelector,
                    &pDmaInfo->DescOffset,
                    pDmaInfo->DescLimit,
                    &pDmaInfo->DescAddr,
                    &pDmaInfo->AddressSpace
                    );

                if (!RM_SUCCESS(rmStatus))
                {
                    RmFreeContextDma(hClient, hDma);
                    return RmArchStatus(RM_ERR_BAD_OBJECT_HANDLE, NV01_ALLOC_CONTEXT_DMA);
                }
                if (pDmaInfo->AddressSpace != ADDR_UNKNOWN)
                {
                    // found the buffer -- remember the device, if the context describes a frame buffer
                    hDeviceWithFrameBufferCtx = (pDmaInfo->AddressSpace == ADDR_FBMEM) ? deviceList[i].Handle : 0;
                    break;
                }
            }
        }

        // calculate page table values
        pDmaInfo->BufferSize = pDmaInfo->DescLimit + 1;
        osCalculatePteAdjust(pDev, pDmaInfo->AddressSpace, pDmaInfo->DescAddr, &pDmaInfo->PteAdjust);
        pDmaInfo->PteLimit   = pDmaInfo->DescLimit; // pDmaInfo->PteAdjust + pDmaInfo->BufferSize;
        pDmaInfo->PteCount   = (pDmaInfo->PteLimit + pDmaInfo->PteAdjust + RM_PAGE_SIZE - 1) >> RM_PAGE_SHIFT;
        rmStatus = osAllocMem((VOID **)&(pDmaInfo->PteArray), pDmaInfo->PteCount * 4);
        if (!RM_SUCCESS(rmStatus))
        {
            RmFreeContextDma(hClient, hDma);
            return RmArchStatus(RM_ERR_OPERATING_SYSTEM, NV01_ALLOC_CONTEXT_DMA);
        }

        // lock DMA buffer
        rmStatus = osLockUserMem(
            pDev,
            INVALID_CHID,
            pDmaInfo->DescSelector,
            pDmaInfo->DescOffset,
            pDmaInfo->DescAddr,
            &pDmaInfo->AddressSpace,
            pDmaInfo->DescLimit,
            pDmaInfo->PteCount,
            pDmaInfo->PteArray,
            &pDmaInfo->BufferBase,
            &pDmaInfo->LockHandle
        );
        if (!RM_SUCCESS(rmStatus))
        {
            RmFreeContextDma(hClient, hDma);
            return RmArchStatus(RM_ERR_OPERATING_SYSTEM, NV01_ALLOC_CONTEXT_DMA);
        }
    }

    // register and bind DMA context
    for (i = 0; i < NUM_DEVICES; i++)
    {
        if (deviceList && deviceList[i].InUse)
        {
            // set the device context
            if (!CliSetDeviceContext(deviceList[i].Handle, &pDev))
            {
                rmStatus = RM_ERR_BAD_OBJECT_PARENT;
                break;
            }

            // only allow the device with a DMA context in its FB to be registered as such
            if(deviceList[i].Handle == hDeviceWithFrameBufferCtx)
              pDmaInfo->AddressSpace = ADDR_FBMEM;
            
            // register DMA context with the current device
            if (!RM_SUCCESS(rmStatus = dmaRegisterToDevice(pDev, pDmaInfo, &pDmaObject)))
            {
                break;
            }

            // bind DMA context to all FIFOs of the current device
            if (!CliGetDeviceFifoList(deviceList[i].Handle, &fifoList))
            {
                rmStatus = RM_ERR_BAD_OBJECT_PARENT;
                break;
            }
            for (j = 0; j < NUM_FIFOS; j++)
            {
                if (fifoList && fifoList[j].InUse)
                {
                    if (!RM_SUCCESS(rmStatus = dmaBindToChannel(pDev, pDmaObject, j)))
                    {
                        break;
                    }
                }
            }
            if (!RM_SUCCESS(rmStatus))
            {
                break;
            }
        }
    }
    if (!RM_SUCCESS(rmStatus))
    {
        RmFreeContextDma(hClient, hDma);
    }

    return RmArchStatus(rmStatus, NV01_ALLOC_CONTEXT_DMA);

} // end of RmAllocContextDma()

NvV32 RmAllocChannelPio(
    U032 hClient,
    U032 hDevice,
    U032 hPioChannel,
    U032 hClass,
    U032 hErrorContext,
    VOID** ppChannel,
    U032 flags
)
{
    RM_STATUS rmStatus = RM_OK;

    rmStatus = RmAllocChannel(
        hClient,
        hDevice,
        hPioChannel,
        hClass,
        hErrorContext,
        0,          // no DMA context
        0,          // no DMA push initial offset
        ppChannel,
        flags
    );

    return RmArchStatus(rmStatus, NV01_ALLOC_CHANNEL_PIO);

} // end of RmAllocChannelPio()

NvV32 RmAllocChannelDma(
    U032 hClient,
    U032 hDevice,
    U032 hDmaChannel,
    U032 hClass,
    U032 hErrorContext,
    U032 hDataContext,
    U032 offset,
    VOID** ppControl
)
{
    RM_STATUS rmStatus = RM_OK;

    rmStatus = RmAllocChannel(
        hClient,
        hDevice,
        hDmaChannel,
        hClass,
        hErrorContext,
        hDataContext,
        offset,
        ppControl,
        0           // no flags
    );

    return RmArchStatus(rmStatus, NV03_ALLOC_CHANNEL_DMA);

} // end of RmAllocChannelDma()

RM_STATUS RmAllocChannel(
    U032 hClient,
    U032 hDevice,
    U032 hChannel,
    U032 hClass,
    U032 hErrorContext,
    U032 hDataContext,
    U032 offset,
    VOID** ppChannel,
    U032 flags
)
{
    RM_STATUS rmStatus = RM_OK;
    U032 chID;
    U032 length = CHANNEL_LENGTH;
    PDMAOBJECT pDmaObject;
    PCLI_DMA_INFO pDmaInfo;
    U032 clientClass;
    PHWINFO pDev;

    // set the client context
    if (!CliSetClientContext(hClient))
    {
        return RM_ERR_OPERATING_SYSTEM;
    }

    // set the correct device context
    if (!CliSetDeviceContext(hDevice, &pDev))
    {
        CliDelDeviceFifo(hDevice, hChannel);
        return RM_ERR_INSUFFICIENT_RESOURCES;
    }

    // allocate the channel based on hDataContext
    if (hDataContext == 0)
    {
        // allocate a PIO channel
        rmStatus = fifoAlloc(pDev, hClass, &chID);
    }
    else
    {
        // get context dma object
        if (RM_SUCCESS(rmStatus = dmaFindContext(pDev, hDataContext, hClient, &pDmaObject)))
        {
            // allocate a DMA channel
            rmStatus = fifoAllocDma(pDev, hClass, &chID, pDmaObject);
#if defined(MACOS) && defined(DEBUG)
            // save pushbuffer address
            // *((void **) (0xE0 + (chID * 4)) ) = pDmaObject->DescOffset;
#endif
        }
    }

    if (!RM_SUCCESS(rmStatus))
    {
        return rmStatus;
    }

    if (!CliGetClass(NV01_NULL_OBJECT, hClient, &clientClass))
    {
        return RM_ERR_OPERATING_SYSTEM;
    }

    // map the channel
    switch (hClass)
    {
        // special case the nv3 dma channel
        case NV03_CHANNEL_DMA:
            *ppChannel = NULL;
            break;
        default:
        {
            rmStatus = osMapFifo(pDev, clientClass, chID, ppChannel);
            break;
        }
    }
    if (!RM_SUCCESS(rmStatus))
    {
        fifoFree(pDev, chID);
        //CliDelDeviceFifo(hDevice, hChannel);
        return rmStatus;
    }
    //pFifoInfo->Flat = *ppChannel;

    // add fifo to device fifo list
    rmStatus = CliAddDeviceFifo(
        pDev,
        hDevice,
        hChannel,
        hClass,
        hErrorContext,
        hDataContext,
        offset,
        flags,
        chID,
        *ppChannel
    );
    if (!RM_SUCCESS(rmStatus))
    {
        osUnmapMemory(pDev, clientClass, *ppChannel, length);
        fifoFree(pDev, chID);
        return rmStatus;
    }

    // bind all DMA contexts of the client to the FIFO of the current device
    for (pDmaInfo = CliGetDmaList(); pDmaInfo; pDmaInfo = pDmaInfo->Next)
    {
        // When the device was allocated, the dma context was registered to it.
        // Find the dmaObject created at that time.
        rmStatus = dmaFindContext(pDev, pDmaInfo->Handle, hClient, &pDmaObject);
        if (!RM_SUCCESS(rmStatus))
        {
            RmFreeChannel(hClient, hDevice, hChannel);
            return RmArchStatus(rmStatus, NV01_ALLOC_DEVICE);
        }
        rmStatus = dmaBindToChannel(pDev, pDmaObject, chID);
        if (!RM_SUCCESS(rmStatus))
        {
            RmFreeChannel(hClient, hDevice, hChannel);
            return RmArchStatus(rmStatus, NV01_ALLOC_DEVICE);
        }
    }

    rmStatus = 0;

    DBG_PRINT_STRING_PTR(DEBUGLEVEL_TRACEINFO, "NVRM:   logical address:", *ppChannel);

    return rmStatus;

} // end of RmAllocChannel()

NvV32 RmAllocMemory(
    U032 hClient,
    U032 hParent,
    U032 hMemory,
    U032 hClass,
    U032 flags,
    VOID** pAddress,
    U032* pLimit
)
{
    RM_STATUS rmStatus = RM_OK;
    U032 trueLength;
    U032 instance = 0;
    BOOL addDeviceMemory = TRUE;
    PHWINFO pDev;
    VOID *pMemData = NULL;

    // set the client context
    if (!CliSetClientContext(hClient))
    {
        return RmArchStatus(RM_ERR_OPERATING_SYSTEM, NV01_ALLOC_MEMORY);
    }

    // set the device context
    if (!CliSetDeviceContext(hParent, &pDev))
    {
        return RmArchStatus(RM_ERR_BAD_OBJECT_PARENT, NV01_ALLOC_MEMORY);
    }

    switch (hClass)
    {
        case NV01_MEMORY_SYSTEM:

            rmStatus = RmAllocSystemMemory(pDev, hClient, pAddress, pLimit, &pMemData, flags);
            if (RM_SUCCESS(rmStatus))
            {
                rmStatus = CliAddMemory(pDev, hClient, hMemory, hClass, flags, *pAddress, *pLimit + 1, pMemData);
                if (!RM_SUCCESS(rmStatus))
                {
                    RmFreeSystemMemoryWithArgs(pDev, pAddress, *pLimit + 1, pMemData, flags);
                }
            }
            break;


        // modified by Chuck Moidel
        case NV01_MEMORY_LOCAL_PRIVILEGED:
            #ifndef NV3
            RM_ASSERT(0);  //NV01_MEMORY_LOCAL_PRIVILEGED should only be used by NV3 and before
            #endif
            /*
            // the length returned is the offset into instance memory, but the
            // true length is registered with the client.
            rmStatus = RmAllocInstanceMemory(pDev, hClient, pAddress, pLimit, &trueLength, &instance);
            if (RM_SUCCESS(rmStatus))
            {
               rmStatus = CliAddDeviceMemory(hParent, hMemory, hClass, *pAddress, trueLength, instance, 0);
               // is this right to return the status of the Free rather than the failure of CliAddDeviceMemory??
               if (!RM_SUCCESS(rmStatus))
               {
                   rmStatus = RmFreeInstanceMemory(pDev, hClient, hParent, hMemory);
               }
            }
            */
            break;

        /*
        ATTENTION!
        RmAllocMemory(NV01_MEMORY_LOCAL_USER) and RmAlloc(NV01_MEMORY_LOCAL USER) do VERY different things.
        For more information see nvarch.h  - added by Charles Moidel
        */

        case NV01_MEMORY_LOCAL_USER: /* please note that this function does not allocate ANY framebuffer memory.
                                        This function only allocates and returns a dumb linear mapping to the entire 
                                        framebuffer.  -C.Moidel
                                     */

            // if the address is non-NULL, only return the length -- don't add as device memory
            addDeviceMemory = !*pAddress;
            rmStatus = RmAllocFrameBufferMapping(pDev, hClient, pAddress, pLimit);
            trueLength = *pLimit;

            // add the device memory info to the client database
            if (RM_SUCCESS(rmStatus) && addDeviceMemory)
            {
                rmStatus = CliAddDeviceMemory(hParent, hMemory, hClass, *pAddress, trueLength, instance, 0, 0);
                if (!RM_SUCCESS(rmStatus))
                {
                    rmStatus = RmFreeFrameBuffer(pDev, hClient, hParent, hMemory);
                }
            }
            break;

        default:
            rmStatus = RM_ERR_BAD_CLASS;
            break;
    }

    return RmArchStatus(rmStatus, NV01_ALLOC_MEMORY);

} // end of RmAllocMemory()

RM_STATUS RmAllocSystemMemory(
    PHWINFO pDev,
    U032    hClient,
    VOID**   pAddress,
    U032*   pLimit,
    VOID**  pMemData,
    U032    flags
)
{
    RM_STATUS rmStatus = RM_OK;
    U032      MemoryType, Contiguous, PageCount;
    U032      Cache = 0;
    U032      clientClass;

    if (!CliGetClass(NV01_NULL_OBJECT, hClient, &clientClass))
    {
        return RM_ERR_BAD_OBJECT_PARENT;
    }

    //
    // Allocate system memory
    //
    // 4k Page sized allocation?  This is the page size default for arch work.
    // Remember that the given length is actually a limit (size-1)
    //
    if ((*pLimit + 1) & 0xFFF)
    {
        //
        // Not a page request.  Don't support for now.
        //
        rmStatus = NVOS03_STATUS_ERROR_BAD_LIMIT;
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,  "NVRM: *** Invalid limit: not page aligned\n");
        return rmStatus;
    }
    else
    {
        //
        // Page sized request
        //
        // Convert arch constants into RM constants.
        //
        PageCount = (*pLimit + 1) >> 12;

        if (DRF_VAL(OS02, _FLAGS, _LOCATION, flags) == NVOS02_FLAGS_LOCATION_AGP)
            MemoryType = NV_MEMORY_TYPE_AGP;
        else
            MemoryType = NV_MEMORY_TYPE_SYSTEM;

        if (DRF_VAL(OS02, _FLAGS, _PHYSICALITY, flags) == NVOS02_FLAGS_PHYSICALITY_CONTIGUOUS)
            Contiguous = NV_MEMORY_CONTIGUOUS;
        else
            Contiguous = NV_MEMORY_NONCONTIGUOUS;

        if (DRF_VAL(OS02, _FLAGS, _COHERENCY, flags) == NVOS02_FLAGS_COHERENCY_UNCACHED)
            Cache = NV_MEMORY_UNCACHED;
        else if (DRF_VAL(OS02, _FLAGS, _COHERENCY, flags) == NVOS02_FLAGS_COHERENCY_CACHED)
            Cache = NV_MEMORY_DEFAULT;
        else if (DRF_VAL(OS02, _FLAGS, _COHERENCY, flags) == NVOS02_FLAGS_COHERENCY_WRITE_COMBINE)
            Cache = NV_MEMORY_WRITECOMBINED;
        else if (DRF_VAL(OS02, _FLAGS, _COHERENCY, flags) == NVOS02_FLAGS_COHERENCY_WRITE_THROUGH)
            Cache = NV_MEMORY_WRITETHRU;
        else if (DRF_VAL(OS02, _FLAGS, _COHERENCY, flags) == NVOS02_FLAGS_COHERENCY_WRITE_PROTECT)
            Cache = NV_MEMORY_WRITEPROTECT;
        else if (DRF_VAL(OS02, _FLAGS, _COHERENCY, flags) == NVOS02_FLAGS_COHERENCY_WRITE_BACK)
            Cache = NV_MEMORY_WRITEBACK;

        rmStatus = osAllocPages(pDev,
                                pAddress,
                                PageCount,
                                MemoryType,
                                Contiguous,
                                Cache,
                                clientClass,
                                pMemData);

        if (!RM_SUCCESS(rmStatus))
        {
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,  "NVRM: *** Cannot allocate pages\n");
            rmStatus = NVOS02_STATUS_ERROR_BAD_FLAGS;
            return rmStatus;
        }
    }

    DBG_PRINT_STRING      (DEBUGLEVEL_TRACEINFO, "NVRM: after system memory allocation:\n");
    DBG_PRINT_STRING_PTR  (DEBUGLEVEL_TRACEINFO, "NVRM:   pMemory:", *pAddress);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM:     limit:", *pLimit);

    return rmStatus;

} // end of RmAllocSystemMemory()

RM_STATUS RmAllocInstanceMemory(
    PHWINFO pDev,
    U032 hClient,
    VOID** pAddress,
    U032* pLength,
    U032* pTrueLength,
    U032* pInstance
)
{
    RM_STATUS rmStatus = RM_OK;
    U032 instMemOffset, clientClass;
    // U032 instanceMemoryPciAddress = INSTANCE_MEMORY_BASE;

    // get the class of client
    if (!CliGetClass(NV01_NULL_OBJECT, hClient, &clientClass))
    {
        rmStatus = RM_ERR_BAD_OBJECT_PARENT;
    }

    // NOTE: never allocate cursor memory for client of type "user"
    // TO DO: this is not generalized -- for NV3 legacy reasons, only a kernel client can alloc inst mem
    // validate the client class
    if (clientClass != NV01_ROOT)
    {
        return RM_ERR_BAD_OBJECT_PARENT;
    }

    // allocate instance memory for the cursor aligned on 2K boundary
    rmStatus = fbAllocInstMemAlign(pDev, pInstance, *pLength >> 4, 0x800 >> 4);
    if (!RM_SUCCESS(rmStatus))
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,  "NVRM: *** Cannot allocate instance for cursor\n");
        return rmStatus;
    }
    instMemOffset = *pInstance << 4;

    // map the memory into the client's context
    rmStatus = osMapInstanceMemory(pDev, clientClass, instMemOffset, *pLength, pAddress);
    if (!RM_SUCCESS(rmStatus))
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,  "NVRM: *** Cannot map instance memory for cursor\n");
        return rmStatus;
    }

    // return the offset from the top of instance memory in pLength, and the true length in pTrueLength
    // TODO: eliminate this when the miniport does not talk to HW
    *pTrueLength = *pLength;
    *pLength = instMemOffset;

    DBG_PRINT_STRING      (DEBUGLEVEL_TRACEINFO, "NVRM:  after cursor allocation:\n");
    DBG_PRINT_STRING_PTR  (DEBUGLEVEL_TRACEINFO, "NVRM:   pMemory:", *pAddress);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM:     limit:", *pLength);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM:  instance:", *pInstance);

    return rmStatus;

} // end of RmAllocInstanceMemory()

RM_STATUS RmAllocFrameBufferMapping(
    PHWINFO pDev,
    U032 hClient,
    VOID** pAddress,
    U032* pLength
)
{
    RM_STATUS rmStatus = RM_OK;
    U032 clientClass;

    // get the class of client
    if (!CliGetClass(NV01_NULL_OBJECT, hClient, &clientClass))
    {
        rmStatus = RM_ERR_BAD_OBJECT_PARENT;
    }

    // map frame buffer into the client's context -- only map if null is passed in as address
    *pLength = pDev->Framebuffer.HalInfo.Limit[0];
    if (*pAddress == NULL)
    {
        rmStatus = osMapFrameBuffer(pDev, clientClass, 0, *pLength, pAddress);
        if (!RM_SUCCESS(rmStatus))
        {
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,  "NVRM: *** Cannot map frame buffer\n");
            return rmStatus;
        }
    }

    DBG_PRINT_STRING_PTR  (DEBUGLEVEL_TRACEINFO, "NVRM:   address:", *pAddress);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM:    length:", *pLength);

    return rmStatus;

} // end of RmAllocFrameBufferMapping()

NvV32 RmAllocObject(
    U032 hClient,
    U032 hChannel,
    U032 hObject,
    U032 hClass
)
{
    RM_STATUS rmStatus = RM_OK;
    U032 hDevice;
    PCLI_FIFO_INFO pFifo;
    POBJECT pObject;
    PHWINFO pDev;

    // set the client context
    if (!CliSetClientContext(hClient))
    {
        //return RmArchStatus(RM_ERR_BAD_CLIENT, NV01_ALLOC_OBJECT);
        return RmArchStatus(RM_ERR_OPERATING_SYSTEM, NV01_ALLOC_OBJECT);
    }

    // find and set the device context
    if (!CliGetDeviceHandle(hChannel, &hDevice))
    {
        return RmArchStatus(RM_ERR_BAD_OBJECT_PARENT, NV01_ALLOC_OBJECT);
    }
    if (!CliSetDeviceContext(hDevice, &pDev))
    {
        return RmArchStatus(RM_ERR_BAD_OBJECT_PARENT, NV01_ALLOC_OBJECT);
    }

    // get the class object
    //nv->subchannel[BLIT_SUBCHANNEL].SetObject = NV_VIDEO_COLORMAP;
    if (!CliGetDeviceFifoInfo(hDevice, hChannel, &pFifo))
    {
        return RmArchStatus(RM_ERR_BAD_OBJECT_PARENT, NV01_ALLOC_OBJECT);
    }
    if (hClass == NV01_NULL_OBJECT)
    {
        return RmArchStatus(RM_ERR_BAD_OBJECT_HANDLE, NV01_ALLOC_OBJECT);
    }

    rmStatus = fifoSearchObject(pDev, hClass, pFifo->ChID, &pObject);
    if (!RM_SUCCESS(rmStatus))
    {
        return RmArchStatus(RM_ERR_BAD_CLASS, NV01_ALLOC_OBJECT);
    }

    // create the device given its class object
    //nv->subchannel[BLIT_SUBCHANNEL].nvClass.Create = DD_COLORMAP;
    rmStatus = mthdCreate(pDev, pObject, 0, 0, hObject, NULL);
    if (!RM_SUCCESS(rmStatus))
    {
        return RmArchStatus(RM_ERR_INSUFFICIENT_RESOURCES, NV01_ALLOC_OBJECT);
    }

    return RmArchStatus(rmStatus, NV01_ALLOC_OBJECT);

} // end of RmAllocObject()

NvV32 RmAllocEvent
(
    U032 hClient,
    U032 hUser,
    U032 hObject,
    U032 hClass,
    U032 index,
    U064 hEvent
)
{
    RM_STATUS rmStatus = RM_OK;
    PCLI_EVENT_INFO pEventInfo;
    POBJECT pUser;
    U032 hChannel;

    // set client context
    if (!CliSetClientContext(hClient))
    {
        return NVOS10_STATUS_ERROR_OPERATING_SYSTEM;
    }

    // add event to client and parent object
    rmStatus = CliAddEvent(hClient, hUser, hObject, hClass, &pEventInfo);
    if (RM_SUCCESS(rmStatus))
    {
        CliFindObject(hUser, &pUser, &hChannel);
        rmStatus = eventSetObjectEventNotify(pUser, hObject, index, hClass, hEvent);
        if (!RM_SUCCESS(rmStatus))
        {
            CliDelEvent(hObject);
        }
    }

    return RmArchStatus(rmStatus, NV01_ALLOC_EVENT);

} // end of RmAllocEvent()




NvV32 RmAlloc(
    U032 hClient,
    U032 hParent,
    U032 hObject,
    U032 hClass,
    VOID* pAllocParms
)
{
    RM_STATUS rmStatus = RM_OK;

    //special case for Client Allocation - added by Chuck Moidel
    if (hClass == NV01_ROOT)
    {
        NVOS01_PARAMETERS *pArgs = (NVOS01_PARAMETERS*)pAllocParms;
        ARG(status) = RmAllocClient(&ARG(hObjectNew),ARG(hClass));
        return ARG(status);
    }
    
    // set the client context
    if (!CliSetClientContext(hClient))
    {
        return RmArchStatus(RM_ERR_BAD_CLIENT, NV04_ALLOC);
    }

    // allocate the object based on its class
    switch(hClass)
    {
        //case NV01_NULL_OBJECT:
        case NV01_ROOT:  //should be handled above!! -C.Moidel
            RM_ASSERT(hClass);
            return RmArchStatus(RM_ERR_BAD_CLASS, NV04_ALLOC);

        case NV01_MEMORY_SYSTEM:




        //case NV01_MEMORY_LOCAL_PRIVILEGED:  //shouldn't be using this in NV4+   -C.Moidel

        /*
        ATTENTION!
        RmAllocMemory(NV01_MEMORY_LOCAL_USER) and RmAlloc(NV01_MEMORY_LOCAL USER) do VERY different things.
        For more information see nvarch.h  - added by Charles Moidel
        */
        case NV01_MEMORY_LOCAL_USER:      /*This is used to allocate blocks from the Framebuffer Heap!   -C.Moidel */



        case NV04_HEAP_OWNER:             //added by Chuck Moidel


        case NV01_EVENT:
        case NV01_CONTEXT_DMA:
        case NV01_DEVICE_0:
        case NV01_DEVICE_1:
        case NV01_DEVICE_2:
        case NV01_DEVICE_3:
        case NV01_DEVICE_4:
        case NV01_DEVICE_5:
        case NV01_DEVICE_6:
        case NV01_DEVICE_7:
        case NV03_CHANNEL_PIO:
        case NV04_CHANNEL_PIO:
        case NV03_CHANNEL_DMA:
        case NV04_CHANNEL_DMA:
            return RmArchStatus(RM_ERR_BAD_OBJECT_HANDLE, NV04_ALLOC);

        case NVDE_DEBUGGER:
        case NVDE_REGISTER_DEBUGGER:
        case NVDE_UNREGISTER_DEBUGGER:
        case NVDE_READ_MEMORY:
        case NVDE_WRITE_MEMORY:
        case NVDE_TEST:
        case NVDE_GET_EVENT_INFORMATION:
            rmStatus = RmDebugEx(hClient, hObject, hClass, pAllocParms);
            break;

        default:
            rmStatus = RmAllocObjectEx(hParent, hObject, hClass, pAllocParms);
            break;
    }

    return RmArchStatus(rmStatus, NV04_ALLOC);

} // end of RmAlloc()

RM_STATUS RmAllocObjectEx(
    U032 hChannel,
    U032 hObject,
    U032 hClass,
    VOID* pAllocParms
)
{
    RM_STATUS rmStatus = RM_OK;
    U032 hDevice;
    PCLI_FIFO_INFO pFifo;
    POBJECT pObject;
    PHWINFO pDev;

    // set the device context
    if (!CliGetDeviceHandle(hChannel, &hDevice))
    {
        return RM_ERR_BAD_OBJECT_PARENT;
    }
    if (!CliSetDeviceContext(hDevice, &pDev))
    {
        return RM_ERR_BAD_OBJECT_PARENT;
    }

    // get the class object
    if (!CliGetDeviceFifoInfo(hDevice, hChannel, &pFifo))
    {
        return RM_ERR_BAD_OBJECT_PARENT;
    }
    rmStatus = fifoSearchObject(pDev, hClass, pFifo->ChID, &pObject);
    if (!RM_SUCCESS(rmStatus))
    {
        return RM_ERR_BAD_CLASS;
    }

    // create the device given its class object
    rmStatus = mthdCreate(pDev, pObject, 0, 0, hObject, pAllocParms);
    if (!RM_SUCCESS(rmStatus))
    {
        return RM_ERR_INSUFFICIENT_RESOURCES;
    }

    return rmStatus;

} // end of RmAllocObjectEx()

// TO DO: clean up as much as possible despite any errors, for all free routines

NvV32 RmFree(
    U032 hClient,
    U032 hParent,
    U032 hObject
)
{
    U032 client;
    PCLI_DEVICE_INFO pDevice;
    PCLI_FIFO_INFO pFifo;
    PCLI_MEMORY_INFO pMemory;
    PCLI_DMA_INFO pDma;
    PCLI_EVENT_INFO pEvent;
    RM_STATUS rmStatus = RM_OK;

    // set the client context
    if (!CliSetClientContext(hClient))
    {
        return RmArchStatus(RM_ERR_OPERATING_SYSTEM, NV01_FREE);
    }

    // scan all object types
    if (CliGetClientHandle(&client) && client == hObject)
    {
        rmStatus = RmFreeClient(hClient);
    }
    else if (CliGetDeviceInfo(hObject, &pDevice))
    {
        rmStatus = RmFreeDevice(hClient, hObject);
    }
    else if (CliGetDeviceFifoInfo(hParent, hObject, &pFifo))
    {
        rmStatus = RmFreeChannel(hClient, hParent, hObject);
    }
    else if (CliGetDeviceMemoryInfo(hParent, hObject, &pMemory))
    {
        rmStatus = RmFreeMemory(hClient, hParent, pMemory->Class, hObject);
    }
    else if (CliGetDmaInfo(hObject, &pDma))
    {
        rmStatus = RmFreeContextDma(hClient, hObject);
    }
    else if (CliGetMemoryInfo(hObject, &pMemory))
    {
        rmStatus = RmFreeMemory(hClient, hParent, pMemory->Class, hObject);
    }
    else if (CliGetEventInfo(hObject, &pEvent))
    {
        rmStatus = RmFreeEvent(hClient, hObject);
    }
    else
    {
        rmStatus = RmFreeObject(hParent, hObject);
    }

    return RmArchStatus(rmStatus, NV01_FREE);

} // end of RmFree()

RM_STATUS RmFreeClient(
    U032 hClient
)
{
    RM_STATUS rmStatus = RM_OK;
    PCLI_DMA_INFO pDmaInfo, nextDma;
    PCLI_DEVICE_INFO deviceList;
    PCLI_MEMORY_INFO pMemoryInfo, nextMem;
    U032 i;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,  "NVRM:     type: client\n");

    // free all of the devices of the client
    if ((deviceList = CliGetDeviceList()) != NULL)
    {
        for (i = 0; i < NUM_DEVICES; i++)
        {
            if (deviceList[i].InUse)
            {
                rmStatus |= RmFreeDevice(hClient, deviceList[i].Handle);
            }
        }
    }
    else
        rmStatus |= RM_ERR_BAD_OBJECT_HANDLE;

    // free all of the DMA contexts of the client
    nextDma = CliGetDmaList();
    while (nextDma)
    {
        pDmaInfo = nextDma;
        nextDma = nextDma->Next;
        rmStatus |= RmFreeContextDma(hClient, pDmaInfo->Handle);
    }

    // free all client system memory
    nextMem = CliGetMemoryList();
    while (nextMem)
    {
        pMemoryInfo = nextMem;
        nextMem = nextMem->Next;
        rmStatus |= RmFreeSystemMemory(pMemoryInfo->pDev, pMemoryInfo->Handle);
    }

#ifdef LINUX
    RmSwapClientGone(hClient);
#endif

    // free the client
    if (!CliDelClient())
    {
        rmStatus |= RM_ERR_BAD_OBJECT_HANDLE;
    }

    return rmStatus;

} // end of RmFreeClient()

RM_STATUS RmFreeDevice(
    U032 hClient,
    U032 hDevice
)
{
    RM_STATUS rmStatus = RM_OK;
    PCLI_FIFO_INFO fifoList;
    PCLI_MEMORY_INFO pMemoryInfo;
    PCLI_DMA_INFO pDmaInfo;
    U032 i;
    PDMAOBJECT pDmaObject;
    PHWINFO pDev;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,  "NVRM:     type: device\n");

    // set the device context
    if (!CliSetDeviceContext(hDevice, &pDev))
    {
        return RM_ERR_BAD_OBJECT_HANDLE;
    }

    // if the client was created, but never had any devices successfully
    //   attached, we'll get here.  The client's device structure will have
    //   been created, but pDev will be NULL if the device was later found
    //   to be non-existent
    // Since NUM_FIFOS macro ref's pDev, we stay away
    if (pDev)
    {
        // free all of the FIFOs of the device
        if (CliGetDeviceFifoList(hDevice, &fifoList))
        {
            for (i = 0; i < NUM_FIFOS; i++)
            {
                if (fifoList && fifoList[i].InUse)
                {
                    rmStatus |= RmFreeChannel(hClient, hDevice, fifoList[i].Handle);
                }
            }
        }
    }

    // unregister all DMA contexts with the device
    for (pDmaInfo = CliGetDmaList(); pDmaInfo; pDmaInfo = pDmaInfo->Next)
    {
        if (RM_SUCCESS(dmaFindContext(pDev, pDmaInfo->Handle, hClient, &pDmaObject)))
        {
            rmStatus |= dmaUnregisterFromDevice(pDev, pDmaObject);
        }
    }

    // free all device memory
    while ((pMemoryInfo = CliGetDeviceMemoryList(hDevice)) != NULL)
    {
        rmStatus |= RmFreeMemory(hClient, hDevice, pMemoryInfo->Class, pMemoryInfo->Handle);
    }

    // free the device
    if (!CliDelDevice(hDevice))
    {
        rmStatus |= RM_ERR_BAD_OBJECT_HANDLE;
    }

    return rmStatus;

} // end of RmFreeDevice()

RM_STATUS RmFreeContextDma(
    U032 hClient,
    U032 hDma
)
{
    RM_STATUS rmStatus = RM_OK;
    PCLI_DEVICE_INFO deviceList;
    PCLI_FIFO_INFO fifoList;
    U032 i, j;
    PDMAOBJECT pDmaObject;
    PHWINFO pDev;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,  "NVRM:     type: DMA context\n");

    // unregister and unbind the DMA context
    if ((deviceList = CliGetDeviceList()) == NULL)
    {
        rmStatus |= RM_ERR_BAD_OBJECT_PARENT;
    }
    else
    {
        for (i = 0; i < NUM_DEVICES; i++)
        {
            if (deviceList[i].InUse)
            {
                // set the current device context
                if (!CliSetDeviceContext(deviceList[i].Handle, &pDev))
                {
                    rmStatus |= RM_ERR_BAD_OBJECT_PARENT;
                }

                // get a pointer to the dma object
                else if (RM_SUCCESS(rmStatus |= dmaFindContext(pDev, hDma, hClient, &pDmaObject)))
                {
                    // unbind DMA context from all FIFOs of the current device
                    if (!CliGetDeviceFifoList(deviceList[i].Handle, &fifoList))
                    {
                        rmStatus |= RM_ERR_BAD_OBJECT_PARENT;
                    }
                    else
                    {
                        for (j = 0; j < NUM_FIFOS; j++)
                        {
                            if (fifoList && fifoList[j].InUse)
                            {
                                rmStatus |= dmaUnbindFromChannel(pDev, pDmaObject, j);
                            }
                        }

                        // unregister DMA context with the current device
                        rmStatus |= dmaUnregisterFromDevice(pDev, pDmaObject);
                    }
                }
            }
        }
    }

    // TO DO:  ***** THIS SHOULD HAPPEN HERE, BUT UNTIL IT IS PROVED
    //               IT IS DONE IN DMA DELETE
    /*
    // unlock pages
    if (!CliGetDmaInfo(hDma, &pDmaInfo))
    {
        return RM_ERR_BAD_OBJECT_HANDLE;
    }
    rmStatus = osUnlockUserMem(
        INVALID_CHID,
        pDmaInfo->BufferBase,
        pDmaInfo->DescAddr,
        pDmaInfo->AddressSpace,
        pDmaInfo->DescLimit,
        pDmaInfo->PteCount,
        pDmaInfo->LockHandle,
        pDmaInfo->Class == NV_CONTEXT_DMA_TO_MEM ? TRUE : FALSE
    );
    if (!RM_SUCCESS(rmStatus))
    {
        return rmStatus;
    }
    */

    // delete the DMA context from the client
    if (!CliDelDma(hDma))
    {
        rmStatus |= RM_ERR_BAD_OBJECT_HANDLE;
    }

    return rmStatus;

} // end of RmFreeContextDma()

RM_STATUS RmFreeChannel(
    U032 hClient,
    U032 hDevice,
    U032 hFifo
)
{
    RM_STATUS rmStatus = RM_OK;
    PCLI_DMA_INFO pDmaInfo;
    PCLI_FIFO_INFO pFifoInfo;
    PDMAOBJECT pDmaObject;
    PHWINFO pDev;
    U032 hClass;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,  "NVRM:     type: channel\n");

    // set the device context
    if (!CliSetDeviceContext(hDevice, &pDev))
    {
        return RM_ERR_BAD_OBJECT_HANDLE;
    }

    // unbind all DMA contexts from the FIFO
    for (pDmaInfo = CliGetDmaList(); pDmaInfo; pDmaInfo = pDmaInfo->Next)
    {
        if (!RM_SUCCESS(rmStatus = dmaFindContext(pDev, pDmaInfo->Handle, hClient, &pDmaObject)))
        {
            return rmStatus;
        }
        if (!CliGetDeviceFifoInfo(hDevice, hFifo, &pFifoInfo))
        {
            return RM_ERR_BAD_OBJECT_HANDLE;
        }
        if (!RM_SUCCESS(rmStatus = dmaUnbindFromChannel(pDev, pDmaObject, pFifoInfo->ChID)))
        {
            return rmStatus;
        }
    }

    // unmap the channel
    if (!CliGetDeviceFifoInfo(hDevice, hFifo, &pFifoInfo))
    {
        return RM_ERR_BAD_OBJECT_HANDLE;
    }
    hClass = pFifoInfo->Class;

    // NV03_CHANNEL_DMA wasn't mapped into clients address space
    if (hClass != NV03_CHANNEL_DMA)
    {
        U032 clientClass;

        if (!CliGetClass(NV01_NULL_OBJECT, hClient, &clientClass))
        {
            return RM_ERR_OPERATING_SYSTEM;
        }
        osUnmapMemory(pDev, clientClass, (VOID *)pFifoInfo->Flat, CHANNEL_LENGTH);
    }

    // free the FIFO
    rmStatus = fifoFree(pDev, pFifoInfo->ChID);
    if (!RM_SUCCESS(rmStatus))
    {
        return rmStatus;
    }

    // delete the device fifo info
    if (!CliDelDeviceFifo(hDevice, hFifo))
    {
        return RM_ERR_BAD_OBJECT_HANDLE;
    }

    // remove any events associated with this channel from the client
    CliDelEventUser(hFifo, hClass);

    return rmStatus;

} // end of RmFreeChannel()


RM_STATUS RmFreeMemory
(
    U032 hClient,
    U032 hDevice,
    U032 hClass,
    U032 hMemory
)
{
    RM_STATUS rmStatus = RM_OK;
    PHWINFO pDev;

    // set the device context
    if (!CliSetDeviceContext(hDevice, &pDev))
    {
        return RM_ERR_BAD_OBJECT_PARENT;
    }

    switch(hClass)
    {
        case NV01_MEMORY_SYSTEM:

            rmStatus = RmFreeSystemMemory(pDev, hMemory);

            // remove the system memory reference from the client
            if (!CliDelMemory(hMemory))
            {
                rmStatus |= RM_ERR_BAD_OBJECT_HANDLE;
            }
            break;

        case NV01_MEMORY_LOCAL_PRIVILEGED:
        case NV01_MEMORY_LOCAL_USER:

            // set the device context
            if (!CliSetDeviceContext(hDevice, &pDev))
            {
                rmStatus |= RM_ERR_BAD_OBJECT_PARENT;
            }

            // free the device memory
            switch(hClass)
            {
                case NV01_MEMORY_LOCAL_PRIVILEGED:
                    rmStatus |= RmFreeInstanceMemory(pDev, hClient, hDevice, hMemory);
                    break;

                case NV01_MEMORY_LOCAL_USER:
                    rmStatus |= RmFreeFrameBuffer(pDev, hClient, hDevice, hMemory);
                    break;
            }

            // remove the device memory reference from the client
            if (!CliDelDeviceMemory(hDevice, hMemory))
            {
                rmStatus |= RM_ERR_BAD_OBJECT_HANDLE;
            }

            break;
    }

    return rmStatus;

} // end of RmFreeMemory()


RM_STATUS RmFreeSystemMemoryWithArgs
(
    PHWINFO pDev,
	VOID**  pAddress, 
	U032    size,
	VOID*   pMemData,
    U032    flags
)
{
    // version of RmFreeSystemMemory when a memory handle isn't valid
    return (osFreePages(pDev,
                        pAddress,
                        DRF_VAL(OS02, _FLAGS, _LOCATION, flags), 
                        size >> RM_PAGE_SHIFT,
                        pMemData,
                        DRF_VAL(OS02, _FLAGS, _COHERENCY, flags) == NVOS02_FLAGS_COHERENCY_WRITE_COMBINE));

} // end of RmFreeSystemMemoryWithArgs()

RM_STATUS RmFreeSystemMemory
(
    PHWINFO pDev,
    U032 hMemory
)
{
    RM_STATUS rmStatus = RM_OK;
    PCLI_MEMORY_INFO pMemoryInfo;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,  "NVRM:     type: system memory\n");

    if (!CliGetMemoryInfo(hMemory, &pMemoryInfo))
    {
        rmStatus = RM_ERR_BAD_OBJECT_HANDLE;
    }
    else
    {
        rmStatus = osFreePages(pDev,
                               &pMemoryInfo->Address,
                               pMemoryInfo->Type,
                               pMemoryInfo->Length >> RM_PAGE_SHIFT,
                               pMemoryInfo->MemData,
                               (pMemoryInfo->Coherency == NVOS02_FLAGS_COHERENCY_WRITE_COMBINE));
    }

    return rmStatus;

} // end of RmFreeSystemMemory()

RM_STATUS RmFreeInstanceMemory(
    PHWINFO pDev,
    U032 hClient,
    U032 hDevice,
    U032 hMemory
)
{
    RM_STATUS rmStatus = RM_OK;
    U032 clientClass;
    PCLI_MEMORY_INFO pMemoryInfo;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,  "NVRM:     type: cursor memory\n");

    // get the class of client
    if (!CliGetClass(NV01_NULL_OBJECT, hClient, &clientClass))
    {
        rmStatus = RM_ERR_BAD_OBJECT_PARENT;
    }

    // free the instance memory
    else if (!CliGetDeviceMemoryInfo(hDevice, hMemory, &pMemoryInfo))
    {
        rmStatus = RM_ERR_BAD_OBJECT_HANDLE;
    }
    else
    {
        // unmap the memory
        osUnmapMemory(pDev, clientClass, pMemoryInfo->Address, pMemoryInfo->Length);

        // deallocate the instance memory held by the cursor
        rmStatus = fbFreeInstMem(pDev, pMemoryInfo->Instance, pMemoryInfo->Length >> 4);
    }

    return rmStatus;

} // end of RmFreeInstanceMemory()

RM_STATUS RmFreeFrameBuffer(
    PHWINFO pDev,
    U032 hClient,
    U032 hDevice,
    U032 hMemory
)
{
    RM_STATUS rmStatus = RM_OK;
    U032 clientClass;
    PCLI_MEMORY_INFO pMemoryInfo;
    U032 memHandle;


    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,  "NVRM:     type: frame buffer\n");

    // get the class of client
    if (!CliGetClass(NV01_NULL_OBJECT, hClient, &clientClass))
    {
        rmStatus = RM_ERR_BAD_OBJECT_PARENT;
    }

    // free the frame buffer
    else if (!CliGetDeviceMemoryInfo(hDevice, hMemory, &pMemoryInfo))
    {
        rmStatus = RM_ERR_BAD_OBJECT_HANDLE;
    }
    else
    {
        // free the video memory based on how it was alloced ... a non-zero
        // HeapOwner indicates it was heapAlloc-ed.

        if (pMemoryInfo->HeapOwner)
        {
            DBG_PRINT_STRING      (DEBUGLEVEL_TRACEINFO,  "NVRM: Function: FREE\n");
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:   Owner:", pMemoryInfo->HeapOwner);
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:   Offset:", pMemoryInfo->Handle);

            // memHandle is returned, but not needed ... the caller already has
            // the correct handle to pass to CliDelDeviceMemory, since it's
            // traversing the client DB.

            rmStatus = heapFree(
                pDev,
                (PHEAP)pDev->Framebuffer.HeapHandle,
                pMemoryInfo->HeapOwner,
                (U032)((U008*)pMemoryInfo->Address - (U008*)fbAddr),
                &memHandle);
        }
        else
        {
            // unmap the memory
            osUnmapMemory(pDev, clientClass, pMemoryInfo->Address, pMemoryInfo->Length);
        }
    }
    return rmStatus;

} // end of RmFreeFrameBuffer()

RM_STATUS RmFreeObject(
    U032 hChannel,
    U032 hObject
)
{
    RM_STATUS rmStatus = RM_OK;
    U032 hDevice;
    PCLI_FIFO_INFO pFifo;
    OBJECT classObject;
    PHWINFO pDev;

    // check for debugger object
    if (NvRmInfo.Debugger.object)
        if (NvRmInfo.Debugger.object->Name == hObject)
            return NvdeFree(hChannel, hObject);

    // set the corresponding device context
    if (!CliGetDeviceHandle(hChannel, &hDevice))
    {
        return RM_ERR_BAD_OBJECT_PARENT;
    }
    if (!CliSetDeviceContext(hDevice, &pDev))
    {
        return RM_ERR_BAD_OBJECT_PARENT;
    }

    // contrive the class object
    if (!CliGetDeviceFifoInfo(hDevice, hChannel, &pFifo))
    {
        return RM_ERR_BAD_OBJECT_PARENT;
    }
    classObject.Name = NV01_NULL_OBJECT;
    classObject.ChID = pFifo->ChID;

    // destroy the object
    rmStatus = mthdDestroy(pDev, &classObject, 0, 0, hObject);
    if (!RM_SUCCESS(rmStatus))
    {
        return RM_ERR_BAD_OBJECT_HANDLE;
    }

    // remove this user object from client events
    CliDelEventUser(hObject, NV01_NULL_OBJECT);

    return rmStatus;

} // end of RmFreeObject()

RM_STATUS RmFreeEvent(
    U032 hClient,
    U032 hEvent
)
{
    RM_STATUS rmStatus = RM_OK;
    PCLI_EVENT_INFO pEvent;
    PCLI_EVENT_USER nextUser;
    POBJECT pUser;
    U032 hChannel;

    // delete the event from all parent objects and client
    if (CliGetEventInfo(hEvent, &pEvent))
    {
        for (nextUser = pEvent->UserList; nextUser; nextUser = nextUser->Next)
        {
            if (CliFindObject(nextUser->Handle, &pUser, &hChannel))
            {
                eventRemoveObjectEventNotify(pUser, hEvent);
            }
        }
        CliDelEvent(hEvent);
    }
    else
    {
        rmStatus = RM_ERR_BAD_OBJECT;
    }

    return rmStatus;

} // end of RmFreeEvent()

NvV32 RmArchHeap
(
    U032 hRoot,
    U032 hObjectParent,
    U032 function,
    U032 owner,
    U032 type,
    U032 depth,
    U032 width,
    U032 height,
    S032* pPitch,
    U032* pOffset,
    U032* pSize,
    VOID** pAddress,
    U032* pLimit,
    U032* pTotal,
    U032* pFree
)
{
    U032 tempPitch;
    RM_STATUS rmStatus = NVOS11_STATUS_SUCCESS;
    PHWINFO pDev;
    U032 memHandle;
#ifdef DEBUG
    U032 oldFree;
#endif

    // set the client context
    if (!CliSetClientContext(hRoot))
    {
        return RM_ERR_OPERATING_SYSTEM;
    }

    // set the correct device context
    if (!CliSetDeviceContext(hObjectParent, &pDev))
    {
        return RM_ERR_INSUFFICIENT_RESOURCES;
    }

    //
    // Heap manager for NV memory.
    //
    if ((owner == 0) || (owner == 0xFFFFFFFF))
    {
        return NVOS11_STATUS_ERROR_INVALID_OWNER;
    }

    //
    // Setup size for DEPTH_WIDTH_HEIGHT or TILED_PITCH_HEIGHT allocs
    //
    if (function == NVOS11_HEAP_ALLOC_DEPTH_WIDTH_HEIGHT)
    {
        U032 byteWidth;

        // For NV3, scanline alignment is 32 bytes.
        byteWidth = ((width * depth) + 7) >> 3;
        *pSize  = height * ((byteWidth + 31) & ~31);
    }
    else if (function == NVOS11_HEAP_ALLOC_TILED_PITCH_HEIGHT)
    {
        *pSize  = (height * *pPitch);
        tempPitch = *pPitch;
    }

    switch (function)
    {
        //
        // Alloc mem.
        //
        case NVOS11_HEAP_ALLOC_DEPTH_WIDTH_HEIGHT:
        case NVOS11_HEAP_ALLOC_SIZE:
            tempPitch = 0;          // pitch is valid only for TILED_PITCH_HEIGHT

        case NVOS11_HEAP_ALLOC_TILED_PITCH_HEIGHT:
            DBG_PRINT_STRING      (DEBUGLEVEL_TRACEINFO,  "NVRM:    Function: ALLOC\n");
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:    Type:  ", type);
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:    Owner: ", owner);
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:    Size:  ", *pSize);
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:    Pitch: ", *pPitch);
            rmStatus =
                heapAlloc
                (
                    pDev,
                    (PHEAP)pDev->Framebuffer.HeapHandle,
                    owner,
                    pSize,
                    type,
                    height,
                    &tempPitch,
                    pOffset
                );
            if (rmStatus == RM_OK)
            {
                //
                // Set the mapping for the memory.
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:    Allocated at Offset: ", *pOffset);
                if (tempPitch)
                {
                    // update pitch value
                    *pPitch = tempPitch;
                }
                *pAddress = (U008*)fbAddr + *pOffset;
                *pLimit = *pSize - 1;

                // add the heapAlloc to the Client DB
                rmStatus =
                    CliAddDeviceMemory
                    (
                        hObjectParent,
                        ((PHEAP)pDev->Framebuffer.HeapHandle)->memHandle, // generated handle
                        NV01_MEMORY_LOCAL_USER,
                        *pAddress,
                        *pSize,
                        0x0,
                        owner,
                        0           //version = 0 because the HeapOwner is just an ID without an allocated object behind it - C.Moidel
                    );
                if (rmStatus != RM_OK)
                {
                    // return the failed rmStatus from CliAddMemory not heapFree
                    (VOID)heapFree
                    (
                        pDev,
                        (PHEAP)pDev->Framebuffer.HeapHandle,
                        owner,
                        *pOffset,
                        &memHandle
                    );
                }
            }
            *pFree   = ((PHEAP)pDev->Framebuffer.HeapHandle)->free;
            *pTotal  = ((PHEAP)pDev->Framebuffer.HeapHandle)->total;

            break;

        //
        // Free mem.
        //
        case NVOS11_HEAP_FREE:
            DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,  "NVRM:    Function: FREE\n");
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:    Type:", type);
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:    Owner:", owner);
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:    Offset:", *pOffset);

            //
            // OpenGL might try to call heapfree (via an ESCAPE call) before NT
            // ever gets the chance to call RmLoadState (in SetPowerState).
            // So to be safe, make sure the HeapHandle is not null.
            //

            if ( ((PHEAP)pDev->Framebuffer.HeapHandle) != NULL)
            {
                rmStatus =
                    heapFree
                    (
                        pDev,
                        (PHEAP)pDev->Framebuffer.HeapHandle,
                        owner,
                        *pOffset,
                        &memHandle  // return the memory handle used
                    );

                *pFree   = ((PHEAP)pDev->Framebuffer.HeapHandle)->free;
                *pTotal  = ((PHEAP)pDev->Framebuffer.HeapHandle)->total;

                if (!CliDelDeviceMemory(hObjectParent, memHandle))
                {
                    rmStatus |= RM_ERR_BAD_OBJECT_HANDLE;
                }
            }

            else
            {
                rmStatus = NVOS11_STATUS_ERROR_INVALID_HEAP;
            }

            break;

        //
        // Purge mem.
        //
        case NVOS11_HEAP_PURGE:

            DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,  "NVRM:    Function: PURGE\n");
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:    Type:", type);
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:    Owner:", owner);
#ifdef DEBUG
            oldFree = ((PHEAP)pDev->Framebuffer.HeapHandle)->free;
#endif
            rmStatus = heapPurge(pDev, (PHEAP)pDev->Framebuffer.HeapHandle, owner);
            *pFree   = ((PHEAP)pDev->Framebuffer.HeapHandle)->free;
            *pTotal  = ((PHEAP)pDev->Framebuffer.HeapHandle)->total;
#ifdef DEBUG
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:    Blocks puged:", *pFree-oldFree);
#endif
/*
#ifdef DEBUG
            if (!(*pFree-oldFree))
            {
                DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,  "NVRM:    You did a PURGE for NO REASON!\n");
            };
#endif
*/

            if (!CliDelDeviceHeapOwner(hObjectParent, owner))
            {
                rmStatus |= RM_ERR_BAD_OBJECT_HANDLE;
            }

            break;

        //
        // Info.
        //
        case NVOS11_HEAP_INFO:
            DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,  "NVRM:    Function: INFO\n");
            rmStatus =
                heapInfo
                (
                    (PHEAP)pDev->Framebuffer.HeapHandle,
                    pFree,
                    pTotal,
                    pAddress,  // base of heap
                    pOffset,   // base of largest free block
                    pSize      // size of largest free block
                );
            if (rmStatus == RM_OK)
            {
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:     Free:", *pFree);
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:    Total:", *pTotal);
                DBG_PRINT_STRING_PTR  (DEBUGLEVEL_TRACEINFO,  "NVRM:     Base:", *pAddress);
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:  MaxFree:", *pSize);
            }

            break;

        //
        // Info with freed blocks.
        //
        // The offsets passed in are considered freed for calculation purposes, but
        // aren't actually freed. Passing -1 as an offset arg indicates offset doesn't
        // contain a valid arg (use the NVOS11_INVALID_BLOCK_FREE_OFFSET #define).
        //
        case NVOS11_HEAP_INFO_FREE_BLOCKS:
            DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,  "NVRM:    Function: INFO FREE BLOCKS\n");
            rmStatus = 
                heapInfoFreeBlocks
                (
                    (PHEAP)pDev->Framebuffer.HeapHandle,
                    pFree,
                    pTotal,
                    *pOffset,   // offset of block to be considered free
                    *pLimit,    // offset of block to be considered free
                    pSize       // size of resulting largest free block
                );    
            if (rmStatus == RM_OK)
            {
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:     Free:", *pFree);
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:    Total:", *pTotal);
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:  MaxFree:", *pSize);
            }
            
            break;
            
        //
        // Destroy.
        //
        case NVOS11_HEAP_DESTROY:
            DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,  "NVRM:    Function: DESTROY\n");
            rmStatus = heapDestroy(pDev, (PHEAP)pDev->Framebuffer.HeapHandle, HEAP_DESTROY_EXTERNAL);
            if (rmStatus == RM_OK)
            {
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:     Free:",
                    ((PHEAP)pDev->Framebuffer.HeapHandle)->free);
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:    Total:",
                    ((PHEAP)pDev->Framebuffer.HeapHandle)->total);
            }

            break;

        //
        // Invalid.
        //
        default:
            rmStatus = NVOS11_STATUS_ERROR_INVALID_FUNCTION;
            break;
    }

    return rmStatus;

} // end of RmArchHeap

NvV32 RmConfigVersion
(
    U032 hClient,
    U032 hDevice,
    U032* pVersion
)
{
    PHWINFO pDev;

    // set the client context
    if (!CliSetClientContext(hClient))
    {
        return RM_ERR_OPERATING_SYSTEM;
    }

    // set the correct device context
    if (!CliSetDeviceContext(hDevice, &pDev))
    {
        return RM_ERR_INSUFFICIENT_RESOURCES;
    }

    // call the kernel for help
    //*pVersion = stateConfigVersion(pDev);
    *pVersion = 0x01000000;

    return NVOS12_STATUS_SUCCESS;

} // end of RmConfigVersion

NvV32 RmConfigGet
(
    U032 hClient,
    U032 hDevice,
    U032 index,
    U032* pValue
)
{
    RM_STATUS rmStatus = NVOS13_STATUS_SUCCESS;
    PHWINFO pDev;

    // set the client context
    if (!CliSetClientContext(hClient))
    {
        return NVOS13_STATUS_ERROR_BAD_CLIENT;
    }

    // set the correct device context
    if (!CliSetDeviceContext(hDevice, &pDev))
    {
        return NVOS13_STATUS_ERROR_BAD_DEVICE;
    }

    // call the kernel for help
    rmStatus = stateConfigGet(pDev, index, pValue);
    if (!RM_SUCCESS(rmStatus))
    {
        rmStatus = NVOS13_STATUS_ERROR_BAD_INDEX;
    }

    return rmStatus;

} // end of RmConfigGet()

NvV32 RmConfigSet
(
    U032 hClient,
    U032 hDevice,
    U032 index,
    U032* pOldValue,
    U032 newValue
)
{
    RM_STATUS rmStatus = NVOS14_STATUS_SUCCESS;
    PHWINFO pDev;

    // set the client context
    if (!CliSetClientContext(hClient))
    {
        return NVOS14_STATUS_ERROR_BAD_CLIENT;
    }

    // set the correct device context
    if (!CliSetDeviceContext(hDevice, &pDev))
    {
        return NVOS14_STATUS_ERROR_BAD_DEVICE;
    }

    // access the kernel state
    rmStatus = stateConfigSet(pDev, index, newValue, pOldValue);
    if (!RM_SUCCESS(rmStatus))
    {
        rmStatus = NVOS14_STATUS_ERROR_BAD_INDEX;
    }

    return rmStatus;

} // end of RmConfigSet()

NvV32 RmConfigUpdate
(
    U032 hClient,
    U032 hDevice,
    U032 flags
)
{
    RM_STATUS rmStatus = NVOS15_STATUS_SUCCESS;
    PHWINFO pDev;

    // set the client context
    if (!CliSetClientContext(hClient))
    {
        return RM_ERR_OPERATING_SYSTEM;
    }

    // set the correct device context
    if (!CliSetDeviceContext(hDevice, &pDev))
    {
        return RM_ERR_INSUFFICIENT_RESOURCES;
    }

    // call the kernel for help
    //stateConfigUpdate(pDev, flags);

    return rmStatus;

} // end of RmConfigUpdate

NvV32 RmConfigGetEx
(
    U032 hClient,
    U032 hDevice,
    U032 index,
    VOID* pParms,
    U032 parmsSize
)
{
    RM_STATUS rmStatus = RM_OK;
    PHWINFO pDev;

    // set the client context
    if (!CliSetClientContext(hClient))
    {
        return NVOS_CGE_STATUS_ERROR_BAD_CLIENT;
    }

    // set the correct device context
    if (!CliSetDeviceContext(hDevice, &pDev))
    {
        return NVOS_CGE_STATUS_ERROR_BAD_DEVICE;
    }

    // call the kernel for help
    rmStatus =
        stateConfigGetEx
        (
            pDev,
            index,
            pParms,
            parmsSize
        );

    return RmArchStatus(rmStatus, NV04_CONFIG_GET_EX);

} // end of RmConfigGetEx

NvV32 RmConfigSetEx
(
    U032 hClient,
    U032 hDevice,
    U032 index,
    VOID* pParms,
    U032 parmsSize
)
{
    RM_STATUS rmStatus = RM_OK;
    PHWINFO pDev;

    // set the client context
    if (!CliSetClientContext(hClient))
    {
        return NVOS_CSE_STATUS_ERROR_BAD_CLIENT;
    }

    // set the correct device context
    if (!CliSetDeviceContext(hDevice, &pDev))
    {
        return NVOS_CSE_STATUS_ERROR_BAD_DEVICE;
    }

    // call the kernel for help
    rmStatus =
        stateConfigSetEx
        (
            pDev,
            index,
            pParms,
            parmsSize
        );

    return RmArchStatus(rmStatus, NV04_CONFIG_SET_EX);

} // end of RmConfigSetEx

NvV32 RmInterrupt
(
    U032 hClient,
    U032 hDevice
)
{
    PHWINFO pDev;

    // set the client context
    if (!CliSetClientContext(hClient))
    {
        return NVOS09_STATUS_ERROR_BAD_CLIENT;
    }

    // set the correct device context
    if (!CliSetDeviceContext(hDevice, &pDev))
    {
        return NVOS09_STATUS_ERROR_BAD_DEVICE;
    }

    // call the os ISR service
    osIsr(pDev);

    return NVOS09_STATUS_SUCCESS;

} // end of RmInterrupt()

RM_STATUS RmAllocDeviceInstance
(
    U032 *pInstance
)
{
    RM_STATUS rmStatus = RM_OK;
    U032 instance, i, instanceSize;

    // allocate the next available device instance
    for (instance = 0; instance < MAX_INSTANCE; instance++)
    {
        if (NvDBPtr_Table[instance] == NULL)
        {
            // allocate and init the device information structure
            instanceSize = sizeof(HWINFO);
            rmStatus = osAllocMem((VOID **)&NvDBPtr_Table[instance], instanceSize);
            if (RM_SUCCESS(rmStatus))
            {
                // clear out the new instance
                for (i = 0; i < instanceSize; i++)
                {
                     ((U008 *)(NvDBPtr_Table[instance]))[i] = 0;
                }
                
                // set the instance self-reference in the device instance
                NvDBPtr_Table[instance]->DBdevInstance = instance;

                // return the instance
                *pInstance = instance;

                // setup the pointer to the global NvRmInfo
                NvDBPtr_Table[instance]->pRmInfo = (VOID_PTR) &NvRmInfo;
            }
            break;
        }
    }
    if (instance == MAX_INSTANCE)
    {
        rmStatus = RM_ERROR;
    }

    return rmStatus;

}

NvV32 RmArchStatus(RM_STATUS rmStatus, U032 archFct)
{
    switch (archFct)
    {
        case NV01_FREE:
            switch (rmStatus)
            {
                case RM_OK:
                    return NVOS00_STATUS_SUCCESS;
                case RM_ERR_OPERATING_SYSTEM:
                    return NVOS00_STATUS_ERROR_OPERATING_SYSTEM;
                case RM_ERR_BAD_OBJECT_PARENT:
                    return NVOS00_STATUS_ERROR_BAD_OBJECT_PARENT;
                case RM_ERR_BAD_OBJECT_HANDLE:
                    return NVOS00_STATUS_ERROR_BAD_OBJECT_OLD;
                case RM_ERR_OBJECT_IN_USE:
                    return NVOS00_STATUS_ERROR_OBJECT_IN_USE;
                case RM_ERR_OBJECT_HAS_CHILDERN:
                    return NVOS00_STATUS_ERROR_OBJECT_HAS_CHILDERN;
                default:
                    return rmStatus;
            }
        
        case NV01_ROOT_USER:
        case NV01_ALLOC_ROOT:
            switch (rmStatus)
            {
                case RM_OK:
                    return NVOS01_STATUS_SUCCESS;
                case RM_ERR_OPERATING_SYSTEM:
                    return NVOS01_STATUS_ERROR_OPERATING_SYSTEM;
                case RM_ERR_BAD_OBJECT_PARENT:
                    return NVOS01_STATUS_ERROR_BAD_OBJECT_PARENT;
                case RM_ERR_BAD_OBJECT_HANDLE:
                    return NVOS01_STATUS_ERROR_BAD_OBJECT_NEW;
                case RM_ERR_BAD_CLASS:
                    return NVOS01_STATUS_ERROR_BAD_CLASS;
                case RM_ERR_INSUFFICIENT_RESOURCES:
                    return NVOS01_STATUS_ERROR_INSUFFICIENT_RESOURCES;
                default:
                    return rmStatus;
            }

        case NV01_ALLOC_MEMORY:
            switch (rmStatus)
            {
                case RM_OK:
                    return NVOS02_STATUS_SUCCESS;
                case RM_ERR_OPERATING_SYSTEM:
                    return NVOS02_STATUS_ERROR_OPERATING_SYSTEM;
                case RM_ERR_BAD_OBJECT_PARENT:
                    return NVOS02_STATUS_ERROR_BAD_OBJECT_PARENT;
                case RM_ERR_BAD_OBJECT_HANDLE:
                    return NVOS02_STATUS_ERROR_BAD_OBJECT_NEW;
                case RM_ERR_BAD_CLASS:
                    return NVOS02_STATUS_ERROR_BAD_CLASS;
                case RM_ERR_INSUFFICIENT_RESOURCES:
                    return NVOS02_STATUS_ERROR_INSUFFICIENT_RESOURCES;
                default:
                    return rmStatus;
            }

        case NV01_ALLOC_CONTEXT_DMA:
            switch (rmStatus)
            {
                case RM_OK:
                    return NVOS03_STATUS_SUCCESS;
                case RM_ERR_OPERATING_SYSTEM:
                    return NVOS03_STATUS_ERROR_OPERATING_SYSTEM;
                case RM_ERR_BAD_OBJECT_PARENT:
                    return NVOS03_STATUS_ERROR_BAD_OBJECT_PARENT;
                case RM_ERR_BAD_OBJECT_HANDLE:
                    return NVOS03_STATUS_ERROR_BAD_OBJECT_NEW;
                case RM_ERR_BAD_CLASS:
                    return NVOS03_STATUS_ERROR_BAD_CLASS;
                case RM_ERR_BAD_FLAGS:
                    return NVOS03_STATUS_ERROR_BAD_FLAGS;
                case RM_ERR_BAD_BASE:
                    return NVOS03_STATUS_ERROR_BAD_BASE;
                case RM_ERR_BAD_LIMIT:
                    return NVOS03_STATUS_ERROR_BAD_LIMIT;
                case RM_ERR_PROTECTION_FAULT:
                    return NVOS03_STATUS_ERROR_PROTECTION_FAULT;
                case RM_ERR_MULTIPLE_MEMORY_TYPES:
                    return NVOS03_STATUS_ERROR_MULTIPLE_MEMORY_TYPES;
                case RM_ERR_INSUFFICIENT_RESOURCES:
                    return NVOS03_STATUS_ERROR_INSUFFICIENT_RESOURCES;
                default:
                    return rmStatus;
            }

        case NV01_ALLOC_CHANNEL_PIO:
            switch (rmStatus)
            {
                case RM_OK:
                    return NVOS04_STATUS_SUCCESS;
                case RM_ERR_OPERATING_SYSTEM:
                    return NVOS04_STATUS_ERROR_OPERATING_SYSTEM;
                case RM_ERR_BAD_OBJECT_PARENT:
                    return NVOS04_STATUS_ERROR_BAD_OBJECT_PARENT;
                case RM_ERR_BAD_OBJECT_HANDLE:
                    return NVOS04_STATUS_ERROR_BAD_OBJECT_NEW;
                case RM_ERR_BAD_CLASS:
                    return NVOS04_STATUS_ERROR_BAD_CLASS;
                case RM_ERR_BAD_OBJECT_ERROR:
                    return NVOS04_STATUS_ERROR_BAD_OBJECT_ERROR;
                case RM_ERR_BAD_FLAGS:
                    return NVOS04_STATUS_ERROR_BAD_FLAGS;
                case RM_ERR_INSUFFICIENT_RESOURCES:
                case RM_ERR_NO_FREE_FIFOS:
                    return NVOS04_STATUS_ERROR_INSUFFICIENT_RESOURCES;
                default:
                    return rmStatus;
            }

        case NV01_ALLOC_OBJECT:
            switch (rmStatus)
            {
                case RM_OK:
                    return NVOS05_STATUS_SUCCESS;
                case RM_ERR_OPERATING_SYSTEM:
                    return NVOS05_STATUS_ERROR_OPERATING_SYSTEM;
                case RM_ERR_BAD_OBJECT_PARENT:
                    return NVOS05_STATUS_ERROR_BAD_OBJECT_PARENT;
                case RM_ERR_BAD_OBJECT_HANDLE:
                    return NVOS05_STATUS_ERROR_BAD_OBJECT_NEW;
                case RM_ERR_BAD_CLASS:
                    return NVOS05_STATUS_ERROR_BAD_CLASS;
                case RM_ERR_INSUFFICIENT_RESOURCES:
                    return NVOS05_STATUS_ERROR_INSUFFICIENT_RESOURCES;
                default:
                    return rmStatus;
            }

        case NV04_ALLOC:
            switch (rmStatus)
            {
                case RM_OK:
                    return NVOS21_STATUS_SUCCESS;
                case RM_ERR_OPERATING_SYSTEM:
                    return NVOS21_STATUS_ERROR_OPERATING_SYSTEM;
                case RM_ERR_BAD_CLIENT:
                    return NVOS21_STATUS_ERROR_BAD_ROOT;
                case RM_ERR_BAD_OBJECT_PARENT:
                    return NVOS21_STATUS_ERROR_BAD_OBJECT_PARENT;
                case RM_ERR_BAD_OBJECT_HANDLE:
                    return NVOS21_STATUS_ERROR_BAD_OBJECT_NEW;
                case RM_ERR_BAD_CLASS:
                    return NVOS21_STATUS_ERROR_BAD_CLASS;
                case RM_ERR_INSUFFICIENT_RESOURCES:
                    return NVOS21_STATUS_ERROR_INSUFFICIENT_RESOURCES;
                default:
                    return rmStatus;
            }

        case NV01_ALLOC_DEVICE:
            switch (rmStatus)
            {
                case RM_OK:
                    return NVOS06_STATUS_SUCCESS;
                case RM_ERR_OPERATING_SYSTEM:
                    return NVOS06_STATUS_ERROR_OPERATING_SYSTEM;
                case RM_ERR_BAD_OBJECT_PARENT:
                    return NVOS06_STATUS_ERROR_BAD_OBJECT_PARENT;
                case RM_ERR_BAD_OBJECT_HANDLE:
                    return NVOS06_STATUS_ERROR_BAD_OBJECT_NEW;
                case RM_ERR_BAD_CLASS:
                    return NVOS06_STATUS_ERROR_BAD_CLASS;
                case RM_ERR_INSUFFICIENT_RESOURCES:
                    return NVOS06_STATUS_ERROR_INSUFFICIENT_RESOURCES;
                default:
                    return rmStatus;
            }

        case NV03_ALLOC_CHANNEL_DMA:
            switch (rmStatus)
            {
                case RM_OK:
                    return NVOS07_STATUS_SUCCESS;
                case RM_ERR_OPERATING_SYSTEM:
                    return NVOS07_STATUS_ERROR_OPERATING_SYSTEM;
                case RM_ERR_BAD_OBJECT_PARENT:
                    return NVOS07_STATUS_ERROR_BAD_OBJECT_PARENT;
                case RM_ERR_BAD_OBJECT_HANDLE:
                    return NVOS07_STATUS_ERROR_BAD_OBJECT_NEW;
                case RM_ERR_BAD_CLASS:
                    return NVOS07_STATUS_ERROR_BAD_CLASS;
                case RM_ERR_BAD_OBJECT_ERROR:
                    return NVOS07_STATUS_ERROR_BAD_OBJECT_ERROR;
                case RM_ERR_BAD_OBJECT_BUFFER:
                    return NVOS07_STATUS_ERROR_BAD_OBJECT_BUFFER;
                case RM_ERR_BAD_OFFSET:
                    return NVOS07_STATUS_ERROR_BAD_OFFSET;
                case RM_ERR_INSUFFICIENT_RESOURCES:
                case RM_ERR_NO_FREE_FIFOS:
                    return NVOS07_STATUS_ERROR_INSUFFICIENT_RESOURCES;
                default:
                    return rmStatus;
            }

        case NV04_CONFIG_GET_EX:
            switch (rmStatus)
            {
                case RM_OK:
                    return NVOS_CGE_STATUS_SUCCESS;
                case RM_ERR_OPERATING_SYSTEM:
                    return NVOS_CGE_STATUS_ERROR_OPERATING_SYSTEM;
                case CONFIG_GETEX_BAD_INDEX:
                    return NVOS_CGE_STATUS_ERROR_BAD_INDEX;
                case RM_ERR_INSUFFICIENT_RESOURCES:
                    return NVOS_CGE_STATUS_ERROR_INSUFFICIENT_RESOURCES;
                case CONFIG_GETEX_BAD_PARAM:
                    return NVOS_CGE_STATUS_ERROR_BAD_PARAM_STRUCT;
            }

        case NV04_CONFIG_SET_EX:
            switch (rmStatus)
            {
                case RM_OK:
                    return NVOS_CSE_STATUS_SUCCESS;
                case RM_ERR_OPERATING_SYSTEM:
                    return NVOS_CSE_STATUS_ERROR_OPERATING_SYSTEM;
                case CONFIG_SETEX_BAD_INDEX:
                    return NVOS_CSE_STATUS_ERROR_BAD_INDEX;
                case RM_ERR_INSUFFICIENT_RESOURCES:
                    return NVOS_CSE_STATUS_ERROR_INSUFFICIENT_RESOURCES;
                case CONFIG_SETEX_BAD_PARAM:
                    return NVOS_CSE_STATUS_ERROR_BAD_PARAM_STRUCT;
            }

        default:
            return rmStatus;
    }

} // end of RmArchStatus()

NvV32 RmI2CAccess
(
    U032  hClient,
    U032  hDevice,
    VOID*  pCtrl
)
{
    RM_STATUS   rmStatus;
    PHWINFO pDev;
    U032        Head = 0;   // TO DO: specify which head
    // set the client context
    if (!CliSetClientContext(hClient))
    {
        return NVOS_I2C_ACCESS_STATUS_ERROR_BAD_CLIENT;
    }

    // set the correct device context
    // also checking for NULL pDev.
    if (!CliSetDeviceContext(hDevice, &pDev) || !pDev)
    {
        return NVOS_I2C_ACCESS_STATUS_ERROR_BAD_DEVICE;
    }
    
    // set head to InitialBootHead
    Head=pDev->Dac.HalInfo.InitialBootHead;
    
    //print out debug data
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,"I2C access occuring on head: %d",Head);
 	
    // call the kernel for help
    rmStatus = i2cAccess(pDev, Head, pCtrl);

    return rmStatus;

} // end of RmI2CAccess()

NvV32 RmDirectMethodCall
(
    U032 hClient,
    U032 hChannel,
    U032 hObject,
    U032 offset,
    U032 data
)
{
    RM_STATUS rmStatus = RM_OK;
    U032 hDevice;
    PCLI_FIFO_INFO pFifo;
    POBJECT pObject;
    PHWINFO pDev;

    // TO DO: it is necessary to be very restrictive as to which methods can be called -- is there a better test?
    // check for valid methods
    switch (offset)
    {
        case NV046_SET_CONTEXT_DMA_NOTIFIES:
        case NV046_SET_CONTEXT_DMA_LUT(0):
        case NV046_SET_LUT_OFFSET(0):
        case NV046_SET_LUT_FORMAT(0):
        case NV046_SET_CURSOR_POINT:
        case NV046_SET_DAC_IMAGE_SIZE(0):
        case NV046_SET_DAC_HORIZONTAL_BLANK(0):
        case NV046_SET_DAC_HORIZONTAL_SYNC(0):
        case NV046_SET_DAC_VERTICAL_BLANK(0):
        case NV046_SET_DAC_VERTICAL_SYNC(0):
        case NV046_SET_DAC_TOTAL_SIZE(0):
        case NV046_SET_DAC_PIXEL_CLOCK(0):
        case NV046_SET_DAC_FORMAT(0):
            break;

        default:
            return NVOS1D_STATUS_ERROR_BAD_METHOD;
    }

    // set the client context
    if (!CliSetClientContext(hClient))
    {
        return NVOS1D_STATUS_ERROR_OPERATING_SYSTEM;
    }

    // set the corresponding device context
    if (!CliGetDeviceHandle(hChannel, &hDevice))
    {
        return NVOS1D_STATUS_ERROR_BAD_OBJECT_PARENT;
    }
    if (!CliSetDeviceContext(hDevice, &pDev))
    {
        return NVOS1D_STATUS_ERROR_BAD_OBJECT_PARENT;
    }

    // get the object
    if (!CliGetDeviceFifoInfo(hDevice, hChannel, &pFifo))
    {
        return NVOS1D_STATUS_ERROR_BAD_OBJECT_PARENT;
    }
    rmStatus = fifoSearchObject(pDev, hObject, pFifo->ChID, &pObject);
    if (!RM_SUCCESS(rmStatus))
    {
        return NVOS1D_STATUS_ERROR_BAD_OBJECT_OLD;
    }

    // call the method directly and safely
    rmStatus = classDirectSoftwareMethod(pDev, pObject, offset, data);
    if (!RM_SUCCESS(rmStatus))
    {
        return NVOS1D_STATUS_ERROR_BAD_DATA;
    }

    return NVOS1D_STATUS_SUCCESS;

} // end of RmDirectMethodCall()

/*
 * Control various debugging facilities in the resource manager
 */

VOID Nv01DebugControl(
    NVOS20_PARAMETERS * configParams
)
{
    RM_STATUS rmStatus = NVOS20_STATUS_SUCCESS;

    switch (configParams->command)
    {
        case NVOS20_COMMAND_RM_FAILURE_ENABLE:
            RM_FAILURE_ENABLE();
            break;

        case NVOS20_COMMAND_RM_FAILURE_DISABLE:
            RM_FAILURE_DISABLE();
            break;
    }

    configParams->status = rmStatus;
} // end of RmDebugControl

RM_STATUS RmDebugEx(
	U032 hClient,
    U032 hObject,
	U032 hClass,
    VOID* pAllocParms
)
{
    RM_STATUS status = RM_OK;

#if !defined(_M_IA64) && !defined(__ia64)
    switch (hClass)
    {
        case NVDE_DEBUGGER:
        {
            status = NvdeAlloc(hObject, pAllocParms);
            break;
        }
        case NVDE_REGISTER_DEBUGGER:
        {
            if (hClient == 0)
                return NVDE_STATUS_ERROR_BAD_ARGUMENT;
            if (NvRmInfo.Debugger.Handle != 0)
                return NVDE_STATUS_ERROR_STATE_IN_USE;

            NvRmInfo.Debugger.Handle = hClient;
            break;
        }
        case NVDE_UNREGISTER_DEBUGGER:
        {
            if (NvRmInfo.Debugger.Handle != hClient)
                return NVDE_STATUS_ERROR_BAD_ARGUMENT;
            NvRmInfo.Debugger.Handle = 0;
            break;
        }
        case NVDE_READ_MEMORY:
        {
            NVDE_READ_MEMORY_PARAMETERS *pNvDEParams;
            U008 *in, *out;
            U032 i;

            if (NvRmInfo.Debugger.Handle != hClient)
                return NVDE_STATUS_ERROR_BAD_ARGUMENT;

            //
            // Not bothering with osCopyin/osCopyout here because
            // this code will soon be moved to the DMC interface.
            // 
            // bdw: we need 32-bit xfers to be atomic - please retain
            //      this notion when we port this.
            //
            pNvDEParams = (NVDE_READ_MEMORY_PARAMETERS *)pAllocParms;
            
            in  = (U008 *)(NvU64_VALUE_T)pNvDEParams->Data;     /* XXX change to PTR_SIZE? */
            out = (U008 *)(NvU64_VALUE_T)pNvDEParams->Address;  /* XXX change to PTR_SIZE? */
            i   = pNvDEParams->Size;
            while (i >= 4)
            {
                *(U032*)in = *(U032*)out;
                in  += 4;
                out += 4;
                i   -= 4;
            }
            while (i)
            {
                *in = *out;
                in  += 1;
                out += 1;
                i   -= 1;
            }
            break;
        }
        case NVDE_WRITE_MEMORY:
        {
            NVDE_WRITE_MEMORY_PARAMETERS *pNvDEParams;
            U008 *in, *out;
            U032 i;

            if (NvRmInfo.Debugger.Handle != hClient)
                return NVDE_STATUS_ERROR_BAD_ARGUMENT;

            //
            // Not bothering with osCopyin/osCopyout here because
            // this code will soon be moved to the DMC interface.
            // 
            // bdw: we need 32-bit xfers to be atomic - please retain
            //      this notion when we port this.
            //
            pNvDEParams = (NVDE_WRITE_MEMORY_PARAMETERS *)pAllocParms;
            
            in  = (U008 *)(NvU64_VALUE_T)pNvDEParams->Address;    /* XXX change to PTR_SIZE? */
            out = (U008 *)(NvU64_VALUE_T)pNvDEParams->Data;       /* XXX change to PTR_SIZE? */
            i   = pNvDEParams->Size;
            while (i >= 4)
            {
                *(U032*)in = *(U032*)out;
                in  += 4;
                out += 4;
                i   -= 4;
            }
            while (i)
            {
                *in = *out;
                in  += 1;
                out += 1;
                i   -= 1;
            }
            break;
        }
        case NVDE_TEST:
        {
            NVDE_TEST_PARAMETERS *pNvDEParams = (NVDE_TEST_PARAMETERS *)pAllocParms;
            NVDE_TEST_FUNC        pfn         = (NVDE_TEST_FUNC)pNvDEParams->CallBackAddress;

            (pfn)();

            break;
        }
        case NVDE_GET_EVENT_INFORMATION:
        {
            NVDE_GET_EVENT_INFORMATION_PARAMETERS *pNvDEParams = (NVDE_GET_EVENT_INFORMATION_PARAMETERS*)pAllocParms;
            U032 *s, *d;
            int  i;

            pNvDEParams->Count = ((PNVDEOBJECT)NvRmInfo.Debugger.object)->EventBufferCount;
            s = &((PNVDEOBJECT)NvRmInfo.Debugger.object)->EventBuffer[0].code;
            d = &pNvDEParams->Event[0][0];
            for (i = 0; i < NVDE_MAX_EVENTS * sizeof(NVDEEVENT) / 4; i++)
            {
                *d = *s;
                s++;
                d++;
            }

            // reset events
            ((PNVDEOBJECT)NvRmInfo.Debugger.object)->EventBufferCount = 0;

            break;
        }
    }
#endif

    return status;

} // end of RmDebugEx()

// end of nvapi.c
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\common\src\nv\nvdebug.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/
/******************* Common Debug Print Defines *****************************\
*                                                                           *
* Module: NVDEBUG.C                                                         *
*                                                                           *
\***************************************************************************/

#include <nvrm.h>

#if defined(DEBUG) || defined(__DJGPP__) || defined(_XBOX)

VOID nvDbg_Printf(
    int     module,
    int     debuglevel,
    const char *printf_format,
    ...)
{
    va_list arglist;

    va_start(arglist, printf_format);
    osDbgPrintf_va(module, debuglevel, printf_format, arglist);
    va_end(arglist);
}

VOID global_DbgPrintf(int debuglevel, const char* printf_format, ...)
{
    va_list arglist;

    va_start(arglist, printf_format);
    osDbgPrintf_va(DBG_MODULE_GLOBAL, debuglevel, printf_format, arglist);
    va_end(arglist);
}

VOID arch_DbgPrintf(int debuglevel, const char* printf_format, ...)
{
    va_list arglist;

    va_start(arglist, printf_format);
    osDbgPrintf_va(DBG_MODULE_ARCH, debuglevel, printf_format, arglist);
    va_end(arglist);
}

VOID os_DbgPrintf(int debuglevel, const char* printf_format, ...)
{
    va_list arglist;

    va_start(arglist, printf_format);
    osDbgPrintf_va(DBG_MODULE_OS, debuglevel, printf_format, arglist);
    va_end(arglist);
}

VOID dac_DbgPrintf(int debuglevel, const char* printf_format, ...)
{
    va_list arglist;

    va_start(arglist, printf_format);
    osDbgPrintf_va(DBG_MODULE_DAC, debuglevel, printf_format, arglist);
    va_end(arglist);
}

VOID fifo_DbgPrintf(int debuglevel, const char* printf_format, ...)
{
    va_list arglist;

    va_start(arglist, printf_format);
    osDbgPrintf_va(DBG_MODULE_FIFO, debuglevel, printf_format, arglist);
    va_end(arglist);
}

VOID gr_DbgPrintf(int debuglevel, const char* printf_format, ...)
{
    va_list arglist;

    va_start(arglist, printf_format);
    osDbgPrintf_va(DBG_MODULE_GR, debuglevel, printf_format, arglist);
    va_end(arglist);
}

VOID heap_DbgPrintf(int debuglevel, const char* printf_format, ...)
{
    va_list arglist;

    va_start(arglist, printf_format);
    osDbgPrintf_va(DBG_MODULE_HEAP, debuglevel, printf_format, arglist);
    va_end(arglist);
}

VOID video_DbgPrintf(int debuglevel, const char* printf_format, ...)
{
    va_list arglist;

    va_start(arglist, printf_format);
    osDbgPrintf_va(DBG_MODULE_VIDEO, debuglevel, printf_format, arglist);
    va_end(arglist);
}

VOID mp_DbgPrintf(int debuglevel, const char* printf_format, ...)
{
    va_list arglist;

    va_start(arglist, printf_format);
    osDbgPrintf_va(DBG_MODULE_MP, debuglevel, printf_format, arglist);
    va_end(arglist);
}

VOID dacClass_DbgPrintf(int debuglevel, const char* printf_format, ...)
{
    va_list arglist;

    va_start(arglist, printf_format);
    osDbgPrintf_va(DBG_MODULE_DACCLASS, debuglevel, printf_format, arglist);
    va_end(arglist);
}

VOID videoClass_DbgPrintf(int debuglevel, const char* printf_format, ...)
{
    va_list arglist;

    va_start(arglist, printf_format);
    osDbgPrintf_va(DBG_MODULE_VIDEOCLASS, debuglevel, printf_format, arglist);
    va_end(arglist);
}

VOID power_DbgPrintf(int debuglevel, const char* printf_format, ...)
{
    va_list arglist;

    va_start(arglist, printf_format);
    osDbgPrintf_va(DBG_MODULE_POWER, debuglevel, printf_format, arglist);
    va_end(arglist);
}


//======================================================================================
//
// nvDbgSprintf()
//
//======================================================================================
int nvDbgSprintf(U008 *dest, const U008 *fmt, va_list args)
{
    int ch, fieldwidth, precision, flags;
    int usedefaultprecision;
    S032 s32val;
    U032 u32val;

#if 0
    F064 f64val = 0.0;
#endif // 0 

    U008 *f, *d, *specptr;
    U008 *strpval;
    void *pval;

    if (dest == 0) // was nil
        return(0);  // If we don't have a destination, we didn't do any characters

    f = (U008 *)fmt;
    d = (U008 *)dest;

    while ((ch = *f++) != 0) {
        if (ch != '%') {
            *d++ = (U008)ch;
            continue;
        }
        specptr = f - 1;    // Save a pointer to the '%' specifier, in case of syntax errors
        ch = *f++;

        flags = DONTTERMINATE;  // Don't terminate substrings -- we'll null-terminate when we're all done
        // Check for left-alignment
        if (ch == '-') {
            flags |= LEFTALIGN_F;
            ch = *f++;
        }
        // Check for using a plus sign for non-negative numbers
        if (ch == '+') {
            flags |= PLUSSIGN_F;
            ch = *f++;
        }
        // Check for using a space character (sign place-holder) for non-negative numbers
        if (ch == ' ') {
            flags |= SPACESIGN_F;
            ch = *f++;
        }
        // Check for leading zero fill
        if (ch == '0') {
            flags |= ZEROFILL_F;
            // Don't bump the character pointer in case '0' was the only digit
        }
        // Collect the field width specifier
        fieldwidth = 0; // Default field width
        while (ch >= '0' && ch <= '9') {
            fieldwidth = fieldwidth * 10 + ch - '0';
            ch = *f++;
        }
        usedefaultprecision = TRUE; // In case a precision wasn't specified
        // Check for a precision specifier
        if (ch == '.') {    // We have a precision specifier, skip the '.'
            ch = *f++;
            precision = 0;  // Start with 0
            while (ch >= '0' && ch <= '9') {
                precision = precision * 10 + ch - '0';
                ch = *f++;
            }
            usedefaultprecision = FALSE;
        }

        // Perform the conversion operation
        switch (ch) {
        case 'c':   // Copy an ASCII character
            u32val = va_arg(args, int);
            *d++ = (U008) u32val;
            break;
        case 'u':   // Copy a formatted, unsigned decimal number
            flags |= UNSIGNED_F;
        case 'd':   // Copy a formatted, signed decimal number
            s32val = va_arg(args, int);
            // Format the number, increment the dest pointer by the characters copied
            d += nvDbg_int32todecfmtstr(s32val, d, fieldwidth, flags);
            break;
        case 'x':   // Copy a formatted, lower-case hexadecimal number
            flags |= LOWERCASE_F;
        case 'X':   // Copy a formatted, upper-case hexadecimal number
            u32val = va_arg(args, int);
            // Format the number, increment the dest pointer by the characters copied
            d += nvDbg_uint32tohexfmtstr(u32val, d, fieldwidth, flags);
            break;
        case 'p':   // Copy a formatted pointer value
            pval = va_arg(args, void *);
#if !defined(_M_IA64) && !defined(__ia64)
            // Fix me for 64 bit...

            d += nvDbg_uint32tohexfmtstr((U032)pval, d, fieldwidth, flags);
#endif
            break;
#if 0
        case 'f':   // Copy a formatted floating point number
            f64val = va_arg(args, F064);
            if (usedefaultprecision)
                precision = 6;
            // Format the number, increment the dest pointer by the characters copied
            d += nvDbg_float64todecfmtstr(f64val, d, fieldwidth, precision, flags);
            break;
#endif // 0
        case 's':   // Copy a formatted string
            strpval = va_arg(args, U008 *);
            d += nvDbg_strtofmtstr(strpval, d, fieldwidth, flags);
            break;
        case '%':   // Copy a formatted '%' sign
            d += nvDbg_strtofmtstr((U008 *)"%", d, fieldwidth, flags);
            break;
        case 0:     // Gracefully handle premature end-of-string
            f--;    // Back up, now f points to the null character again
        default:    // Unexpected conversion operator, so just echo to the destination
            while (specptr < f)
                *d++ = *specptr++;
            if (ch == 0)
                goto stringdone;
            break;
        }
    }

stringdone:
    *d = 0; // Null-terminate the string
    return((int)(d - (U008 *)dest));   // Return the number of characters we transferred
}


enum {  // Padding option definitions
    PRESPACE_O = 1,
    PREZERO_O = 2,
    POSTSPACE_O = 4
};


#define NUMBUFSIZE  16  // Should be enough for 32-bit integers in decimal or hex

//======================================================================================
//
// nvDbg_int32todecfmtstr()
//
//  This takes a 32-bit integer value and converts it to a formatted decimal string,
//  using options (field width and flags) like those provided by sprintf().  The 32-bit
//  number is assumed to be signed unless the UNSIGNED_F flag is set.  Look at the code
//  for dbugsprintf() above to see which formatting options are implemented.
//
//======================================================================================
int nvDbg_int32todecfmtstr(S032 s32val, U008 *dest, int fieldwidth, int flags)
{
    int i, digitcount, destcount;
    int sign, signchar;
    int fillcount;
    int pad_options;
    U032 u32val, quotient, remainder;
    U008 *intdigp;
    U008 nbuf[NUMBUFSIZE];

    // Process the sign-related options
    if (flags & UNSIGNED_F) {   // Unsigned conversion
        sign = 0;   // No sign character
    } else {    // We're doing a signed conversion
        sign = 1;   // Assume we'll have a sign character
        if (s32val < 0) {
            signchar = '-';
            s32val = -s32val;   // Make the number positive now so we can 'digitize' it
        } else {    // s32val >= 0
            if (flags & PLUSSIGN_F)
                signchar = '+';
            else if (flags & SPACESIGN_F)
                signchar = ' ';
            else
                sign = 0;   // No sign character
        }
    }
    u32val = s32val;    // Do unsigned math from here on out

    // Convert the number into ASCII decimal digits in our local buffer, counting them
    intdigp = &nbuf[NUMBUFSIZE];    // Point past the last character in the buffer
    digitcount = 0; // Nothing written to our local buffer yet
    do {
        quotient = u32val / 10;
        remainder = u32val - quotient * 10;
        *--intdigp =  (U008) (remainder + '0'); // Put the digit into the next lower buffer slot
        digitcount++;
        u32val = quotient;
    } while (u32val > 0);

    // Process the field-padding options
    pad_options = 0;    // Assume we won't be doing any padding
    fillcount = fieldwidth - (sign + digitcount);   // Account for the sign, if used
    if (fillcount > 0) {    // We need to do left or right padding
        if (flags & LEFTALIGN_F) {
            pad_options = POSTSPACE_O;
        } else {    // Right-aligned, fill with zeros or spaces
            if (flags & ZEROFILL_F)
                pad_options = PREZERO_O;
            else
                pad_options = PRESPACE_O;
        }
    }

    destcount = 0;  // Nothing written out to the destination yet

    // Copy any leading spaces
    if (pad_options & PRESPACE_O) {
        for (i = 0; i < fillcount; i++) // Copy the pad character(s)
            *dest++ = ' ';
        destcount += fillcount;
    }
    // Copy the sign character, if any
    if (sign) {
        *dest++ = (U008)signchar;
        destcount++;
    }
    // Copy any leading zeros
    if (pad_options & PREZERO_O) {
        for (i = 0; i < fillcount; i++) // Copy the pad character(s)
            *dest++ = '0';
        destcount += fillcount;
    }
    // Copy the decimal digits from our local buffer
    for (i = 0; i < digitcount; i++)
        *dest++ = *intdigp++;
    destcount += digitcount;

    // Copy any trailing spaces
    if (pad_options & POSTSPACE_O) {
        for (i = 0; i < fillcount; i++) // Copy the pad character(s)
            *dest++ = ' ';
        destcount += fillcount;
    }
    if ((flags & DONTTERMINATE) == 0)   // Null-terminate the string unless requested not to
        *dest = 0;
    return(destcount);  // Return the character count, not including the null
}

//======================================================================================
//
// nvDbg_uint32tohexfmtstr()
//
//  This takes a 32-bit unsigned integer value and converts it to a formatted hexadecimal
//  string, using options (field width and flags) like those provided by sprintf().  Look
//  at the code for dbugsprintf() above to see which formatting options are implemented.
//
//======================================================================================
int nvDbg_uint32tohexfmtstr(U032 u32val,  U008 *dest, int fieldwidth, int flags)
{
    int i, digitcount, destcount;
    int c, hexadjust;
    int fillcount;
    U008 fillchar;
    int pad_options;
    U032 quotient;
    U008 *intdigp;
    U008 nbuf[NUMBUFSIZE];

    hexadjust = 'A' - '9' - 1;
    if (flags & LOWERCASE_F)
        hexadjust += 'a' - 'A';

    // Convert the number into ASCII hex digits in our local buffer, counting them
    intdigp = &nbuf[NUMBUFSIZE];    // Point past the last character in the buffer
    digitcount = 0; // Nothing written to our local buffer yet
    do {
        quotient = u32val / 16;
        c = u32val % 16 + '0';
        if (c > '9')    /* A-F */
            c += hexadjust;
        *--intdigp = (U008)c; // Put the digit into the next lower buffer slot
        digitcount++;
        u32val /= 16;
    } while (u32val > 0);

    // Process the field-padding options
    pad_options = 0;    // Assume we won't be doing any padding
    fillcount = fieldwidth - digitcount;    // No sign to worry about
    if (fillcount > 0) {    // We need to do left or right padding
        fillchar = ' ';     // Most common fill character is the space
        if (flags & LEFTALIGN_F) {
            pad_options = POSTSPACE_O;
        } else {    // Right-aligned, fill with zeros or spaces
            if (flags & ZEROFILL_F) {
                pad_options = PREZERO_O;
                fillchar = '0';
            } else {
                pad_options = PRESPACE_O;
            }
        }
    }

    destcount = 0;  // Nothing written out to the destination yet

    // Copy any leading zeros or spaces
    if (pad_options & (PREZERO_O | PRESPACE_O)) {
        for (i = 0; i < fillcount; i++) // Copy the pad character(s)
            *dest++ = fillchar;
        destcount += fillcount;
    }
    // Copy the hex digits from our local buffer
    for (i = 0; i < digitcount; i++)
        *dest++ = *intdigp++;
    destcount += digitcount;

    // Copy any trailing spaces
    if (pad_options & POSTSPACE_O) {
        for (i = 0; i < fillcount; i++) // Copy the pad character(s)
            *dest++ = fillchar;
        destcount += fillcount;
    }
    if ((flags & DONTTERMINATE) == 0)   // Null-terminate the string unless requested not to
        *dest = 0;
    return(destcount);  // Return the character count, not including the null
}


#if 0

//======================================================================================
//
// nvDbg_float64todecfmtstr()
//
//  This takes a 64-bit floating-point value and converts it to a formatted decimal
//  string, using options (field width, precision, and flags) like those provided by
//  sprintf().  Look at the code for dbugsprintf() above to see which formatting options
//  are implemented.
//
//======================================================================================
int nvDbg_float64todecfmtstr(F064 f64val, U008 *dest, int fieldwidth, int precision, int flags)
{
    int i, firstcount, destcount;
    int sign, signchar, decpt;
    int fillcount;
    int pad_options;
    int reducecount, loopdigits, digitsleft;
    U032 u32val, quotient, remainder;
    F064 f64mant9 = 0.0, f64mant9factor = 0.0, fone = 0.0, ften = 0.0, fbillion = 0.0, powerof10 = 0.0;
    U008 *digp;
    U008 nbuf[NUMBUFSIZE];  // This only needs to hold the first 9 digits of the integer part

    // Process the sign-related options
    sign = 1;   // Assume at first we'll have a sign character
    if (f64val < 0.0) {
        signchar = '-';
        f64val = -f64val;   // Make the number positive now so we can 'digitize' it
    } else {    // f64val >= 0.0
        if (flags & PLUSSIGN_F)
            signchar = '+';
        else if (flags & SPACESIGN_F)
            signchar = ' ';
        else
            sign = 0;   // No sign character
    }

    // Round the number to N decimal places.  We add 0.5 x 10^(-N), which is
    //  equivalent to adding 1 / (2*10^N).  We'll use this latter formula.
    fone = 1.0;     // Keep the compiler from always loading these constants from memory
    ften = 10.0;
    powerof10 = fone;   // 10 ^ 0
    for (i = 0; i < precision; i++)
        powerof10 *= ften;  // Build 10 ^ N
    f64val += fone / (2.0 * powerof10);
    // f64val now contains the properly rounded number

    f64mant9 = f64val;  // Start hunting for the mantissa's 9 uppermost decimal digits
    fbillion = 1e9;     // Keep it in a register
    f64mant9factor = fone;
    // Reduce the mantissa to less than 1 billion, so it will fit in a 32-bit integer
    for (reducecount = 0; f64mant9 >= fbillion; reducecount++) {
        f64mant9 /= fbillion;
        f64mant9factor *= fbillion;
    }

    // Process the highest 32-bits of the mantissa so we can count those digits first

    f64mant9 = f64val / f64mant9factor; // Grab highest 9 integer decimal digits
    u32val = (U032) f64mant9;   // Drop any fraction
    f64mant9 = u32val;  // Now we have a float with only an integer part
    f64val -= f64mant9 * f64mant9factor;    // Subtract out the previous high digits
    f64mant9factor /= fbillion;     // Adjust our division factor

    // Convert the binary into ASCII decimal digits in our local buffer, counting them
    digp = &nbuf[NUMBUFSIZE];   // Point past the last char. of these 9 digits
    firstcount = 0; // No digits of the first 32-bit integer part yet
    do {
        quotient = u32val / 10;
        remainder = u32val - quotient * 10;
        *--digp = (U008) (remainder + '0'); // Put the digit into the next lower buffer slot
        firstcount++;
        u32val = quotient;
    } while (u32val > 0);

    // Figure out whether we'll have a decimal point
    decpt = (precision > 0);    // Don't use a decimal point if no fractional part

    // Process the field-padding options
    pad_options = 0;    // Assume we won't be doing any padding
    // We have the information we need to calculate how many output characters we'll have
    fillcount = fieldwidth - (sign + firstcount + (reducecount * 9) + decpt + precision);
    if (fillcount > 0) {    // We need to do left or right padding
        if (flags & LEFTALIGN_F) {
            pad_options = POSTSPACE_O;
        } else {    // Right-aligned, fill with zeros or spaces
            if (flags & ZEROFILL_F)
                pad_options = PREZERO_O;
            else
                pad_options = PRESPACE_O;
        }
    }

    destcount = 0;  // Nothing written out to the destination yet

    // Copy any leading spaces
    if (pad_options & PRESPACE_O) {
        for (i = 0; i < fillcount; i++) // Copy the pad character(s)
            *dest++ = ' ';
        destcount += fillcount;
    }
    // Copy the sign character, if any
    if (sign) {
        *dest++ = signchar;
        destcount++;
    }
    // Copy any leading zeros
    if (pad_options & PREZERO_O) {
        for (i = 0; i < fillcount; i++) // Copy the pad character(s)
            *dest++ = '0';
        destcount += fillcount;
    }
    // Copy the highest chunk of integer digits from the local buffer
    for (i = 0; i < firstcount; i++)
        *dest++ = *digp++;
    destcount += firstcount;

    // Now we need to convert the remaining integer digits, if any
    for (i = 0; i < reducecount; i++) {
        f64mant9 = f64val / f64mant9factor; // Grab 9 more decimal digits
        u32val = (U032) f64mant9;       // Drop any fraction
        f64mant9 = u32val;      // Now we have a float with only an integer part
        f64val -= f64mant9 * f64mant9factor;    // Subtract out the previous high digits
        f64mant9factor /= fbillion;         // Adjust our division factor
        // Convert the integer part into ASCII decimal digits, directly to the destination
        dest += 9;              // Point past the last char. of this 9-digit chunk
        digp = dest;
        for (loopdigits = 0; loopdigits < 9; loopdigits++) {
            quotient = u32val / 10;
            remainder = u32val - quotient * 10;
            *--digp = (U008) (remainder + '0'); // Put the digit into the next lower buffer slot
            u32val = quotient;
        }
        destcount += 9;
    }
    // f64val has only the fractional part now

    if (!decpt)
        goto checktrailing; // Skip the laborious fraction-processing part

    // Copy the decimal point
    *dest++ = '.';
    destcount++;

    // Similar to how we handled the integer part processing, we'll process up to
    //  9 digits at a time, by multiplying the fraction by a power of 10,
    //  converting to an integer, and converting digits to the destination.

    digitsleft = precision;
    do {
        loopdigits = digitsleft;
        if (loopdigits > 9)
            loopdigits = 9;
        powerof10 = fone;   // 10 ^ 0
        for (i = 0; i < loopdigits; i++)
            powerof10 *= ften;  // Build 10 ^ N
        f64val *= powerof10;    // Push some fractional digits into the integer part
        u32val = (U032) f64val; // Conversion truncates any remaining fraction
        f64val -= u32val;   // Remove the integer part, leave remaining fraction digits
        digp = dest + loopdigits;   // Point past the last char. of this chunk
        for (i = 0; i < loopdigits; i++) {
            quotient = u32val / 10;
            remainder = u32val - quotient * 10;
            *--digp = (U008) (remainder + '0'); // Put the digit into the next lower buffer slot
            u32val = quotient;
        }
        dest += loopdigits;
        destcount += loopdigits;
        digitsleft -= loopdigits;
    } while (digitsleft > 0);

checktrailing:
    // Copy any trailing spaces
    if (pad_options & POSTSPACE_O) {
        for (i = 0; i < fillcount; i++) // Copy the pad character(s)
            *dest++ = ' ';
        destcount += fillcount;
    }
    if ((flags & DONTTERMINATE) == 0)   // Null-terminate the string unless requested not to
        *dest = 0;
    return(destcount);  // Return the character count, not including the null
}

#endif // 0

//======================================================================================
//
// nvDbg_strtofmtstr()
//
//  This takes a source C string and converts it to a formatted output C string,
//  using options (field width and flags) like those provided by sprintf().  Look at
//  the code for dbugsprintf() above to see which formatting options are implemented.
//
//======================================================================================
int nvDbg_strtofmtstr(U008 *src, U008 *dest, int fieldwidth, int flags)
{
    int i, srclen;
    int fillcount;
    U008 fillchar;
    int pad_options;
    U008 *s, *d;

    // For padding calculations, we need to know the source string length
    for (s = src, srclen = 0; *s != 0; s++)
        srclen++;
    // Process the field-padding options
    pad_options = 0;    // Assume we won't be doing any padding
    fillcount = fieldwidth - srclen;

    if (fillcount > 0) {    // We need to do left or right padding
        fillchar = ' ';     // Most common fill character is the space
        if (flags & LEFTALIGN_F) {
            pad_options = POSTSPACE_O;
        } else {    // Right-aligned, fill with zeros or spaces
            if (flags & ZEROFILL_F) {
                pad_options = PREZERO_O;
                fillchar = '0';
            } else {
                pad_options = PRESPACE_O;
            }
        }
    }

    s = src;
    d = dest;

    // Copy any leading zeros or spaces
    if (pad_options & (PREZERO_O | PRESPACE_O)) {
        for (i = 0; i < fillcount; i++) // Copy the pad character(s)
            *d++ = fillchar;
    }
    // Copy the characters from the source string
    for (i = 0; i < srclen; i++)
        *d++ = *s++;

    // Copy any trailing spaces
    if (pad_options & POSTSPACE_O) {
        for (i = 0; i < fillcount; i++) // Copy the pad character(s)
            *d++ = fillchar;
    }

    if ((flags & DONTTERMINATE) == 0)   // Null-terminate the string unless requested not to
        *d = 0;
    return((int)(d - dest));   // Return the character count, not including the null
}

#endif // #if defined(DEBUG) || defined(__DJGPP__) || defined(_XBOX)


//********************************************************************************
//
//  NVRM_TRACE support
//    low-overhead runtime state capture
//    to enable, define USE_NVRM_TRACE (retail or debug builds)
//
//********************************************************************************

#ifdef USE_NVRM_TRACE

// the number of trace words in the ring buffer.
// a trace event can be 1 or more words
#define NVRM_TRACE_ENTRIES (8192)
// a typedef for the trace table.  Add a pad to simplify 
// bounds checking
typedef U032 NVRM_TRACE_t[NVRM_TRACE_ENTRIES + 16];

U032 NVRM_tracing = 0;    // enabled or not?
// a type'd ptr to the table.  This may make it easier for your debugger
//   to dump out the table (definitely helps on the mac)
NVRM_TRACE_t *NVRM_TRACE_GTRACE;
// actual table pointer
U032 *NVRM_TRACE_table;
// current index into the table
U032 NVRM_TRACE_idx;

#define NVRM_TRACE_BUMP(inc) { NVRM_TRACE_idx += (inc); \
                               if (NVRM_TRACE_idx >= NVRM_TRACE_ENTRIES) NVRM_TRACE_idx = 0; \
                               NVRM_TRACE_table[NVRM_TRACE_idx] = '****'; \
                             }

U032 NVRM_TRACE_INIT()
{
// allocate the table
// depending on when you call NVRM_TRACE_INIT, might not be able to
// use osAllocMem()
#ifdef MACOS9
    { extern void *PoolAllocateResident(ULONG, int);
      NVRM_TRACE_table = PoolAllocateResident(sizeof(NVRM_TRACE_t), 1/* clear */);
    }
#endif

    NVRM_TRACE_GTRACE = (void *) NVRM_TRACE_table;

#if defined(MACOS9) && defined(DEBUG) 
    // find the table
    *(U032 *) 0xf8 = (U032) NVRM_TRACE_table;
#endif

    if (NVRM_TRACE_table)
        NVRM_tracing = 1;
    return NVRM_tracing;
}

U032 NVRM_TRACE_DISABLE(void)
{
    U032 previous = NVRM_tracing;
    NVRM_tracing = 0;
    return previous;
}

void NVRM_TRACE_ENABLE(void)
{
    NVRM_tracing = 1;
}

void NVRM_TRACE(U032 value)
{
    if ( ! NVRM_tracing) return;
    if (NVRM_TRACE_table == (U032 *) 0)
        if ( ! NVRM_TRACE_INIT())
            return;

    NVRM_TRACE_table[NVRM_TRACE_idx] = value;
    NVRM_TRACE_BUMP(1);
}

void NVRM_TRACE1(U032 value)
{
    if ( ! NVRM_tracing) return;
    if (NVRM_TRACE_table == (U032 *) 0)
        if ( ! NVRM_TRACE_INIT())
            return;

    NVRM_TRACE_table[NVRM_TRACE_idx] = value;
    NVRM_TRACE_BUMP(1);
}

void NVRM_TRACE2(U032 value1, U032 value2)
{
    if ( ! NVRM_tracing) return;
    if (NVRM_TRACE_table == (U032 *) 0)
        if ( ! NVRM_TRACE_INIT())
            return;
    
    NVRM_TRACE_table[NVRM_TRACE_idx]   = value1;
    NVRM_TRACE_table[NVRM_TRACE_idx+1] = value2;
    NVRM_TRACE_BUMP(2);
}

void NVRM_TRACE3(U032 value1, U032 value2, U032 value3)
{
    if ( ! NVRM_tracing) return;
    if (NVRM_TRACE_table == (U032 *) 0)
        if ( ! NVRM_TRACE_INIT())
            return;
    
    NVRM_TRACE_table[NVRM_TRACE_idx]   = value1;
    NVRM_TRACE_table[NVRM_TRACE_idx+1] = value2;
    NVRM_TRACE_table[NVRM_TRACE_idx+2] = value3;
    NVRM_TRACE_BUMP(3);
}

void NVRM_TRACE4(U032 value1, U032 value2, U032 value3, U032 value4)
{
    if ( ! NVRM_tracing) return;
    if (NVRM_TRACE_table == (U032 *) 0)
        if ( ! NVRM_TRACE_INIT())
            return;
    
    NVRM_TRACE_table[NVRM_TRACE_idx]   = value1;
    NVRM_TRACE_table[NVRM_TRACE_idx+1] = value2;
    NVRM_TRACE_table[NVRM_TRACE_idx+2] = value3;
    NVRM_TRACE_table[NVRM_TRACE_idx+3] = value4;
    NVRM_TRACE_BUMP(4);
}

void NVRM_TRACE5(U032 value1, U032 value2, U032 value3, U032 value4, U032 value5)
{
    if ( ! NVRM_tracing) return;
    if (NVRM_TRACE_table == (U032 *) 0)
        if ( ! NVRM_TRACE_INIT())
            return;
    
    NVRM_TRACE_table[NVRM_TRACE_idx]   = value1;
    NVRM_TRACE_table[NVRM_TRACE_idx+1] = value2;
    NVRM_TRACE_table[NVRM_TRACE_idx+2] = value3;
    NVRM_TRACE_table[NVRM_TRACE_idx+3] = value4;
    NVRM_TRACE_table[NVRM_TRACE_idx+4] = value5;
    NVRM_TRACE_BUMP(5);
}

U032 NVRM_TRACE_REG_RD32(PHWINFO pDev, U032 offset)
{
    U032 value = ACTUAL_REG_RD32(offset);
    NVRM_TRACE3('RD32', offset, value);
    return value;
}

void NVRM_TRACE_REG_WR32(PHWINFO pDev, U032 offset, U032 value)
{
    ACTUAL_REG_WR32(offset, value);
    NVRM_TRACE3('WR32', offset, value);
}

#endif  // USE_NVRM_TRACE

#undef NVRM_TRACE_DUMP
void NVRM_TRACE_DUMP(void)
{
#ifdef USE_NVRM_TRACE    // make an empty one so dump can be called from oslog.c retail
    int i;
    static int dumping = 0;
    
    // No table?
    if ( ! NVRM_TRACE_table) return;
    
    // don't nest while dumping this
    if (dumping) return;
    dumping = 1;
    
    NVRM_TRACE_DISABLE();

    for (i=0; i <= NVRM_TRACE_ENTRIES; i += 8)
    {
        DBG_PRINTF((DEBUGLEVEL_ERRORS, "%x %x %x %x %x %x %x %x\n", 
                    NVRM_TRACE_table[i+0],
                    NVRM_TRACE_table[i+1],
                    NVRM_TRACE_table[i+2], 
                    NVRM_TRACE_table[i+3],
                    NVRM_TRACE_table[i+4],
                    NVRM_TRACE_table[i+5],
                    NVRM_TRACE_table[i+6],
                    NVRM_TRACE_table[i+7]));
    }
    dumping = 0;
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\common\src\nv\nvrmapi.c ===
/*
 * nvRmApi.c
 *
 * NVidia resource manager API.
 *
 * Copyright (c) 1997, Nvidia Corporation.  All rights reserved.
 * Portions Copyright (c) 1996, 1997, Silicon Graphics Inc.
 *
 * THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
 * NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
 * IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
 */

#include <windows.h>
#include <nvEscDef.h>
#include "nvos.h"
#include "nv32.h"
#include "nvRmInt.h"
#include "files.h"
#include "nvmisc.h"
#include "nvcm.h"
#include "nvReg.h"

/*
 * pragmas
 */
#pragma warning(disable : 4101 4035)

/*
 * Function defined in the scope of this file.
 */
static DWORD GetWindowsType(void);

/*
 ********************************************************************************
 * The following functions are the external, exported API to the resource manager.
 ********************************************************************************
/*
 * NvRmOpen - open connection to resource manager
 */
HANDLE __stdcall NvRmOpen
(
    VOID
)
{
}

/*
 * NvRmClose - close connection with resource manager
 */
void __stdcall NvRmClose
(
    VOID
)
{
}

/*
 * NvAlloc - allocate any arbitrary object
 */
ULONG __stdcall NvRmAlloc
(
    ULONG hClient, 
    ULONG hParent, 
    ULONG hObject, 
    ULONG hClass, 
    PVOID pAllocParms
)
{
    if (NV_WIN_IS_9X(GetWindowsType()))
        return(NvRmAllocWin9x(hClient, hParent, hObject, hClass, pAllocParms));
    else
        return(NvRmAllocWinNt(hClient, hParent, hObject, hClass, pAllocParms));
}

/*
 * NvAllocRoot - allocate root of device tree
 */
ULONG __stdcall NvRmAllocRoot
(
    ULONG *phClient
)
{
    if (NV_WIN_IS_9X(GetWindowsType()))
        return(NvRmAllocRootWin9x(phClient));
    else
        return(NvRmAllocRootWinNt(phClient));
}

/*
 * NvAllocDevice - allocate a device.
 */
ULONG __stdcall NvRmAllocDevice
(
    ULONG hClient,
    ULONG hDevice,
    ULONG hClass,
    PUCHAR szName
)
{
    if (NV_WIN_IS_9X(GetWindowsType()))
        return(NvRmAllocDeviceWin9x(hClient, hDevice, hClass, szName));
    else
        return(NvRmAllocDeviceWinNt(hClient, hDevice, hClass, szName));
}

/*
 * NvAllocContextDma - allocate and lock down memory using the resource manager.
 */
ULONG __stdcall NvRmAllocContextDma
(
    ULONG hClient,
    ULONG hDma,
    ULONG hClass,
    ULONG flags,
    PVOID base,
    ULONG limit
)
{
    if (NV_WIN_IS_9X(GetWindowsType()))
        return(NvRmAllocContextDmaWin9x(hClient, hDma, hClass, flags, base, limit));
    else
        return(NvRmAllocContextDmaWinNt(hClient, hDma, hClass, flags, base, limit));
}

/*
 * AllocChannelPio - allocate a PIO channel by calling RM.
 */
ULONG __stdcall NvRmAllocChannelPio
(
    ULONG hClient,
    ULONG hDevice,
    ULONG hChannel,
    ULONG hClass,
    ULONG hErrorCtx,
    PVOID *ppChannel,
    ULONG flags
)
{
    if (NV_WIN_IS_9X(GetWindowsType()))
        return(NvRmAllocChannelPioWin9x(hClient, hDevice, hChannel, hClass, hErrorCtx, ppChannel, flags));
    else
        return(NvRmAllocChannelPioWinNt(hClient, hDevice, hChannel, hClass, hErrorCtx, ppChannel, flags));
}

/*
 * NvAllocChannelDma - allocate a DMA push channel using RM.
 */
ULONG __stdcall NvRmAllocChannelDma
(
    ULONG hClient,
    ULONG hDevice,
    ULONG hChannel,
    ULONG hClass,
    ULONG hErrorCtx,
    ULONG hDataCtx,
    ULONG offset,
    PVOID *ppChannel
)
{
    if (NV_WIN_IS_9X(GetWindowsType()))
        return(NvRmAllocChannelDmaWin9x(hClient, hDevice, hChannel, hClass, hErrorCtx, hDataCtx, offset, ppChannel));
    else
        return(NvRmAllocChannelDmaWinNt(hClient, hDevice, hChannel, hClass, hErrorCtx, hDataCtx, offset, ppChannel));
}

/*
 * NvAllocMemory - allocate and lock down a mess 'o memory using RM.
 */
ULONG __stdcall NvRmAllocMemory
(
    ULONG hClient,
    ULONG hParent,
    ULONG hMemory,
    ULONG hClass,
    ULONG flags,
    PVOID *ppAddress,
    ULONG *pLimit
)
{
    if (NV_WIN_IS_9X(GetWindowsType()))
        return(NvRmAllocMemoryWin9x(hClient, hParent, hMemory, hClass, flags, ppAddress, pLimit));
    else
        return(NvRmAllocMemoryWinNt(hClient, hParent, hMemory, hClass, flags, ppAddress, pLimit));
}

/*
 * NvAllocObject - allocate a object using RM.
 */
ULONG __stdcall NvRmAllocObject
(
    ULONG hClient,
    ULONG hChannel,
    ULONG hObject,
    ULONG hClass
)
{
    if (NV_WIN_IS_9X(GetWindowsType()))
        return(NvRmAllocObjectWin9x(hClient, hChannel, hObject, hClass));
    else
        return(NvRmAllocObjectWinNt(hClient, hChannel, hObject, hClass));
}

/*
 * NvFree - free a "thing" allocated using RM.
 */
ULONG __stdcall NvRmFree
(
    ULONG hClient,
    ULONG hParent,
    ULONG hObject
)
{
    if (NV_WIN_IS_9X(GetWindowsType()))
        return(NvRmFreeWin9x(hClient, hParent, hObject));
    else
        return(NvRmFreeWinNt(hClient, hParent, hObject));
}

/*
 * NV3GetDmaPutInfo - These functions get the channel ID, TLB PT base and address space
 * from the resource manager.  This is a backdoor to program the DMA push registers.
 */
ULONG __stdcall Nv3RmGetDmaPushInfo
(
    ULONG hClient,
    ULONG hDevice,
    ULONG hChannel,
    ULONG hDmaContext,
    ULONG retArray
)
{
    if (NV_WIN_IS_9X(GetWindowsType()))
        return(Nv3RmGetDmaPushInfoWin9x(hClient, hDevice, hChannel, hDmaContext, retArray));
    else
        return(Nv3RmGetDmaPushInfoWinNt(hClient, hDevice, hChannel, hDmaContext, retArray));
}

ULONG __stdcall NvRmAllocEvent
(
    ULONG hClient,
    ULONG hObjectParent,
    ULONG hObjectNew,
    ULONG hClass,
    ULONG index,
    ULONG data
)
{
    if (NV_WIN_IS_9X(GetWindowsType()))
        return(NvRmAllocEventWin9x(hClient, hObjectParent, hObjectNew, hClass, index, data));
    else
        return(NvRmAllocEventWinNt(hClient, hObjectParent, hObjectNew, hClass, index, data));
}


ULONG __stdcall NvRmArchHeap
(
    ULONG hClient,
    ULONG hParent,
    ULONG function,
    ULONG owner,
    ULONG type,
    ULONG height,
    ULONG size,
    ULONG *pitch,
    ULONG *offset,
    ULONG *address,
    ULONG *limit,
    ULONG *free,
    ULONG *total
)
{
    if (NV_WIN_IS_9X(GetWindowsType()))
        return(NvRmArchHeapWin9x(hClient, hParent, function, owner, type,
                                   height, size, pitch, offset, address, limit, free, total));
    else
        return(NvRmArchHeapWinNt(hClient, hParent, function, owner, type,
                                   height, size, pitch, offset, address, limit, free, total));
}

ULONG  __stdcall NvRmConfigVersion
(
    ULONG hClient,
    ULONG hDevice,
    ULONG *pVersion
)
{
    return NVOS12_STATUS_SUCCESS;
}

ULONG  __stdcall NvRmConfigGet
(
    ULONG hClient,
    ULONG hDevice,
    ULONG index,
    ULONG *pValue
)
{
    if (NV_WIN_IS_9X(GetWindowsType()))
        return(NvRmConfigGetWin9x(hClient, hDevice, index, pValue));
    else
        return(NvRmConfigGetWinNt(hClient, hDevice, index, pValue));
}

ULONG  __stdcall NvRmConfigSet
(
    ULONG hClient,
    ULONG hDevice,
    ULONG index,
    ULONG newValue,
    ULONG *pOldValue
)
{
    if (NV_WIN_IS_9X(GetWindowsType()))
        return(NvRmConfigSetWin9x(hClient, hDevice, index, newValue, pOldValue));
    else
        return(NvRmConfigSetWinNt(hClient, hDevice, index, newValue, pOldValue));
}

ULONG  __stdcall NvRmConfigUpdate
(
    ULONG hClient,
    ULONG hDevice,
    ULONG flags
)
{
    return NVOS15_STATUS_SUCCESS;
}

ULONG  __stdcall NvRmConfigGetEx
(
    ULONG hClient,
    ULONG hDevice,
    ULONG index,
    VOID  *paramStructPtr,
    ULONG paramSize
)
{
    if (NV_WIN_IS_9X(GetWindowsType()))
        return(NvRmConfigGetExWin9x(hClient, hDevice, index, paramStructPtr, paramSize));
    else
        return(NvRmConfigGetExWinNt(hClient, hDevice, index, paramStructPtr, paramSize));
}

ULONG  __stdcall NvRmConfigSetEx
(
    ULONG hClient,
    ULONG hDevice,
    ULONG index,
    VOID  *paramStructPtr,
    ULONG paramSize
)
{
    if (NV_WIN_IS_9X(GetWindowsType()))
        return(NvRmConfigSetExWin9x(hClient, hDevice, index, paramStructPtr, paramSize));
    else
        return(NvRmConfigSetExWinNt(hClient, hDevice, index, paramStructPtr, paramSize));
}

ULONG  __stdcall NvRmInterrupt
(
    ULONG hClient,
    ULONG hDevice
)
{
    if (NV_WIN_IS_9X(GetWindowsType()))
        return(NvRmInterruptWin9x(hClient, hDevice));
    else
        return(NvRmInterruptWinNt(hClient, hDevice));
}

ULONG  __stdcall NvRmRing0Callback
(
    ULONG hClient,
    ULONG hDevice,
    ULONG procAddr,
    ULONG param1,
    ULONG param2
)
{
    if (NV_WIN_IS_9X(GetWindowsType()))
        return(NvRmRing0CallbackWin9x(hClient, hDevice, procAddr, param1, param2));
    else
        return(NvRmRing0CallbackWinNt(hClient, hDevice, procAddr, param1, param2));
}

ULONG  __stdcall NvRmI2CAccess
(
    ULONG hClient,
    ULONG hDevice,
    VOID  *paramStructPtr
)
{
    if (NV_WIN_IS_9X(GetWindowsType()))
        return(NvRmI2CAccessWin9x(hClient, hDevice, paramStructPtr ));
    else
        return(NvRmI2CAccessWinNt(hClient, hDevice, paramStructPtr ));
}

ULONG  __stdcall NvRmDebugControl
(
    ULONG hRoot,
    ULONG command,
    VOID *pArgs
)
{
    if (NV_WIN_IS_9X(GetWindowsType()))
        return NvRmDebugControlWin9x(hRoot, command, pArgs);
    else
        return NvRmDebugControlWinNt(hRoot, command, pArgs);
}

/*
 * GetWindowsType - Use Win32 to get windows type (9x or NT)
 */
static DWORD
GetWindowsType
(
    void
)
{
    OSVERSIONINFO osVer; /* for GetVersionEx() */

    /*
     * Get Windows type: 9x or NT
     */
    memset(&osVer, 0, sizeof(osVer));
    osVer.dwOSVersionInfoSize = sizeof(osVer);
    (void)GetVersionEx(&osVer);
    return(osVer.dwPlatformId);
}

// end of nvRmApi.c
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\common\src\nv\nvRmApi9x.c ===
/*
 * nvRmApi9x.c
 *
 * NVidia resource manager API for Windows 9x.
 *
 * Copyright (c) 1997, Nvidia Corporation.  All rights reserved.
 * Portions Copyright (c) 1996, 1997, Silicon Graphics Inc.
 *
 * THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
 * NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
 * IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
 */

#include <windows.h>
#include <nvEscDef.h>
#include "nvos.h"
#include "nv32.h"
#include "nvRmInt.h"
#include "files.h"
#include "nvmisc.h"
#include "nvcm.h"
#include "nvReg.h"

/*
 * pragmas
 */

#pragma warning(disable : 4101 4035)


/*
 * Global variables local to the scope of this file.
 */
/*
 * Although Win32 applications have a flat address space, on the X86
 * architecture they still have a single selector that you must supply as
 *    contextDmaToMemory.SetDmaSpecifier.address[1].
 */
int GetFlatDataSelector(void)
{
    DWORD Selector;

    _asm xor eax, eax
    _asm mov ax, ds
    _asm mov Selector, eax
    return (Selector);
}

/*
 * NvRmOpen - open connection to resource manager
 */
HANDLE NvRmOpenWin9x
(
    VOID
)
{
}

/*
 * NvRmClose - close connection with resource manager
 */
VOID NvRmCloseWin9x
(
	HANDLE IOCTL_hDevice
)
{
}

/*
 * NvRmAlloc - allocate arbitrary objects
 */
ULONG NvRmAllocWin9x
(
    ULONG hClient, 
    ULONG hParent, 
    ULONG hObject, 
    ULONG hClass, 
    PVOID pAllocParms
)
{
    NVOS21_PARAMETERS parms;
    NvIoctlArch       t_arch;
    HANDLE            IOCTL_hDevice;

    // set input parameters
    parms.hRoot                 = (NvV32)hClient;
    parms.hObjectParent         = (NvV32)hParent;
    parms.hObjectNew            = (NvV32)hObject;
    parms.hClass                = (NvV32)hClass;
    parms.pAllocParms.selector  = GetFlatDataSelector();
    parms.pAllocParms.offset    = (NvU32)pAllocParms;

    t_arch.function    = (DWORD)NVRM_ARCH_NV04ALLOC;
    t_arch.pParameters = (DWORD)&parms;
	NvIoControl(t_arch.function,(VOID *) &parms);
    
    return (ULONG)parms.status;
}

/*
 * NvAllocRoot - allocate root of device tree
 */
ULONG NvRmAllocRootWin9x
(
    ULONG *phClient
)
{
    NVOS01_PARAMETERS parms;
    NvIoctlArch       t_arch;
	HANDLE            IOCTL_hDevice;

    parms.hClass = NV01_ROOT;

    t_arch.function     = (DWORD)NVRM_ARCH_NV01ALLOCROOT;
    t_arch.pParameters  = (DWORD)&parms;

    NvIoControl(t_arch.function,(VOID *) &parms);

    *phClient = (ULONG)parms.hObjectNew;

    return (ULONG)parms.status;
}

/*
 * NvAllocDevice - allocate a device.
 */
ULONG NvRmAllocDeviceWin9x
(
    ULONG hClient,
    ULONG hDevice,
    ULONG hClass,
    PUCHAR szName
)
{
    NVOS06_PARAMETERS parms;
    NvIoctlArch       t_arch;
    HANDLE            IOCTL_hDevice;

    parms.hObjectParent = hClient;
    parms.hObjectNew    = hDevice;
    parms.hClass        = hClass;
    parms.szName        = (NvV32)szName;

    t_arch.function     = (DWORD)NVRM_ARCH_NV01ALLOCDEVICE;
    t_arch.pParameters  = (DWORD)&parms;
    
    NvIoControl(t_arch.function,(VOID *) &parms);

    return((DWORD)parms.status);
}

/*
 * NvAllocContextDma - allocate and lock down memory using the resource manager.
 */
ULONG NvRmAllocContextDmaWin9x
(
    ULONG hClient,
    ULONG hDma,
    ULONG hClass,
    ULONG flags,
    PVOID base,
    ULONG limit
)
{
    NVOS03_PARAMETERS parms;
    NvIoctlArch t_arch;
    HANDLE            IOCTL_hDevice;

    parms.hObjectParent  = hClient;
    parms.hObjectNew     = hDma;
    parms.hClass         = hClass;
    parms.flags          = flags;
    parms.pBase.selector = GetFlatDataSelector();
    parms.pBase.offset   = (DWORD)base;
    parms.limit.low      = limit;

    t_arch.function    = (DWORD)NVRM_ARCH_NV01ALLOCCONTEXTDMA;
    t_arch.pParameters = (DWORD)&parms;
    NvIoControl(t_arch.function,(VOID *) &parms);
    
    return((DWORD)parms.status);
}

/*
 * AllocChannelPio - allocate a PIO channel by calling RM.
 */
ULONG NvRmAllocChannelPioWin9x
(
    ULONG hClient,
    ULONG hDevice,
    ULONG hChannel,
    ULONG hClass,
    ULONG hErrorCtx,
    PVOID *ppChannel,
    ULONG flags
)
{
    NVOS04_PARAMETERS parms;
    NvIoctlArch       t_arch;
    HANDLE            IOCTL_hDevice;

    parms.hRoot         = hClient;
    parms.hObjectParent = hDevice;
    parms.hObjectNew    = hChannel;
    parms.hClass        = hClass;
    parms.hObjectError  = hErrorCtx;
    parms.flags         = flags;

    t_arch.function    = (DWORD)NVRM_ARCH_NV01ALLOCCHANNELPIO;
    t_arch.pParameters = (DWORD)&parms;
    NvIoControl(t_arch.function,(VOID *) &parms);
    
    *ppChannel = (PVOID)parms.pChannel.offset;

    return((DWORD) parms.status);
}

/*
 * NvAllocChannelDma - allocate a DMA push channel using RM.
 */
ULONG NvRmAllocChannelDmaWin9x
(
    ULONG hClient,
    ULONG hDevice,
    ULONG hChannel,
    ULONG hClass,
    ULONG hErrorCtx,
    ULONG hDataCtx,
    ULONG offset,
    PVOID *ppChannel
)
{
    NVOS07_PARAMETERS parms;
    NvIoctlArch       t_arch;
    HANDLE            IOCTL_hDevice;

    parms.hRoot         = (NvV32)hClient;
    parms.hObjectParent = (NvV32)hDevice;
    parms.hObjectNew    = (NvV32)hChannel;
    parms.hClass        = (NvV32)hClass;
    parms.hObjectError  = (NvV32)hErrorCtx;
    parms.hObjectBuffer = (NvV32)hDataCtx;
    parms.offset        = (NvV32)offset;

    t_arch.function    = (DWORD)NVRM_ARCH_NV03ALLOCCHANNELDMA;
    t_arch.pParameters = (DWORD)&parms;
    NvIoControl(t_arch.function,(VOID *) &parms);
    
    *ppChannel = (PVOID)parms.pControl.offset;

    return((DWORD)parms.status);
}

/*
 * NvAllocMemory - allocate and lock down a mess 'o memory using RM.
 */
ULONG NvRmAllocMemoryWin9x
(
    ULONG hClient,
    ULONG hParent,
    ULONG hMemory,
    ULONG hClass,
    ULONG flags,
    PVOID *ppAddress,
    ULONG *pLimit
)
{
    NVOS02_PARAMETERS parms;
    NvIoctlArch       t_arch;
    HANDLE            IOCTL_hDevice;

    // set input parameters
    parms.hRoot             = (NvV32)hClient;
    parms.hObjectParent     = (NvV32)hParent;
    parms.hObjectNew        = (NvV32)hMemory;
    parms.hClass            = (NvV32)hClass;
    parms.flags             = (NvV32)flags;
    parms.pMemory.selector  = GetFlatDataSelector();
    parms.pMemory.offset    = (NvU32)*ppAddress;
    parms.pLimit.high       = 0x00000000;
    parms.pLimit.low        = (NvU32)*pLimit;

    t_arch.function    = (DWORD)NVRM_ARCH_NV01ALLOCMEMORY;
    t_arch.pParameters = (DWORD)&parms;
    NvIoControl(t_arch.function,(VOID *) &parms);
    
    // retrieve output parameters
    *ppAddress = (PVOID)parms.pMemory.offset;
    *pLimit    = (ULONG)parms.pLimit.low;

    return (ULONG)parms.status;
}

/*
 * NvAllocObject - allocate a object using RM.
 */
ULONG NvRmAllocObjectWin9x
(
    ULONG hClient,
    ULONG hChannel,
    ULONG hObject,
    ULONG hClass
)
{
    NVOS05_PARAMETERS parms;
    NvIoctlArch       t_arch;
    HANDLE            IOCTL_hDevice;

    // set input parameters
    parms.hRoot             = (NvV32)hClient;
    parms.hObjectParent     = (NvV32)hChannel;
    parms.hObjectNew        = (NvV32)hObject;
    parms.hClass            = (NvV32)hClass;

    t_arch.function    = (DWORD)NVRM_ARCH_NV01ALLOCOBJECT;
    t_arch.pParameters = (DWORD)&parms;
    NvIoControl(t_arch.function,(VOID *) &parms);
    
    return (ULONG)parms.status;
}

/*
 * NvFree - free a "thing" allocated using RM.
 */
ULONG NvRmFreeWin9x
(
    ULONG hClient,
    ULONG hParent,
    ULONG hObject
)
{
    NVOS00_PARAMETERS parms;
    NvIoctlArch       t_arch;
    HANDLE            IOCTL_hDevice;

    parms.hRoot         = hClient;
    parms.hObjectParent = hParent;
    parms.hObjectOld    = hObject;

    t_arch.function    = (DWORD)NVRM_ARCH_NV01FREE;
    t_arch.pParameters = (DWORD)&parms;
    NvIoControl(t_arch.function,(VOID *) &parms);
    
    return((DWORD)parms.status);
}

/*
 * NVGetDmaPutInfo - These functions get the channel ID, TLB PT base and address space
 * from the resource manager.  This is a backdoor to program the DMA push registers.
 */
ULONG Nv3RmGetDmaPushInfoWin9x
(
    ULONG hClient,  // this is client NOT channel
    ULONG hDevice,  // this is device NOT flags
    ULONG hChannel, // this is channel NOT put
    ULONG hDmaContext, // this is the DMA context for the push buffer
    ULONG retArray
)
{
    ULONG       parms[5];
    NvIoctlArch t_arch;
    HANDLE            IOCTL_hDevice;

    parms[0] = (NvV32)hClient;
    parms[1] = (NvV32)hDevice;
    parms[2] = (NvV32)hChannel;
    parms[3] = (NvV32)retArray;
    parms[4] = (NvV32)hDmaContext;

    t_arch.function    = (DWORD)NVRM_ARCH_NV03DMAFLOWCONTROL;
    t_arch.pParameters = (DWORD)&parms;
    NvIoControl(t_arch.function,(VOID *) &parms);
    
    return(parms[4]);
}

ULONG NvRmAllocEventWin9x
(
    ULONG hClient,
    ULONG hObjectParent,
    ULONG hObjectNew,
    ULONG hClass,
    ULONG index,
    ULONG data
)
{
    NVOS10_PARAMETERS parms;
    NvIoctlArch       t_arch;
    HANDLE            IOCTL_hDevice;

    parms.hRoot         = hClient;
    parms.hObjectParent = hObjectParent;
    parms.hObjectNew    = hObjectNew;
    parms.hClass        = hClass;
    parms.index         = index;
    parms.hEvent.low    = data;

    t_arch.function    = (DWORD)NVRM_ARCH_NV01ALLOCEVENT;
    t_arch.pParameters = (DWORD)&parms;
    NvIoControl(t_arch.function,(VOID *) &parms);
    
    return((DWORD)parms.status);

}

ULONG NvRmArchHeapWin9x
(
    ULONG hClient,
    ULONG hParent,
    ULONG function,
    ULONG owner,
    ULONG type,
    ULONG height,
    ULONG size,
    ULONG *pitch,
    ULONG *offset,
    ULONG *address,
    ULONG *limit,
    ULONG *free,
    ULONG *total
)
{
    NVOS11_PARAMETERS parms;
    NvIoctlArch       t_arch;
    HANDLE            IOCTL_hDevice;

    parms.hRoot         = hClient;
    parms.hObjectParent = hParent;
    parms.function      = function;
    parms.owner         = owner;
    parms.type          = type;
    parms.pitch         = (pitch) ? *pitch : 0x0;
    parms.height        = height;
    parms.size          = size;
    parms.offset        = *offset;
    t_arch.function    = (DWORD)NVRM_ARCH_NV01HEAP;
    t_arch.pParameters = (DWORD)&parms;
    NvIoControl(t_arch.function,(VOID *) &parms);
    
    if (pitch)
        *pitch   = parms.pitch;
    *offset  = parms.offset;
    *address = parms.address;
    *limit   = parms.limit;
    *total   = parms.total;
    *free    = parms.free;
    return((DWORD)parms.status);

}

ULONG NvRmConfigGetWin9x
(
    ULONG hClient,
    ULONG hDevice,
    ULONG index,
    ULONG *pValue
)
{
    NVOS13_PARAMETERS parms;
    NvIoctlArch       t_arch;
    HANDLE            IOCTL_hDevice;

    parms.hClient       = (NvV32)hClient;
    parms.hDevice       = (NvV32)hDevice;
    parms.index         = (NvV32)index;

    t_arch.function     = (DWORD)NVRM_ARCH_NV01CONFIGGET;
    t_arch.pParameters  = (DWORD)&parms;
    NvIoControl(t_arch.function,(VOID *) &parms);
    
    *pValue = (ULONG)parms.value;

    return (ULONG)parms.status;
}

ULONG NvRmConfigSetWin9x
(
    ULONG hClient,
    ULONG hDevice,
    ULONG index,
    ULONG newValue,
    ULONG *pOldValue
)
{
    NVOS14_PARAMETERS parms;
    NvIoctlArch       t_arch;
    HANDLE            IOCTL_hDevice;

    parms.hClient       = (NvV32)hClient;
    parms.hDevice       = (NvV32)hDevice;
    parms.index         = (NvV32)index;
    parms.newValue      = (NvV32)newValue;

    t_arch.function     = (DWORD)NVRM_ARCH_NV01CONFIGSET;
    t_arch.pParameters  = (DWORD)&parms;
    NvIoControl(t_arch.function,(VOID *) &parms);
    
    *pOldValue = (ULONG)parms.oldValue;

    return (ULONG)parms.status;
}

ULONG NvRmConfigGetExWin9x
(
    ULONG hClient,
    ULONG hDevice,
    ULONG index,
    VOID *paramStructPtr,
    ULONG paramSize
)
{
    NVOS_CONFIG_GET_EX_PARAMS parms;
    NvIoctlArch               t_arch;
    HANDLE            IOCTL_hDevice;

    parms.hClient         = (NvV32)hClient;
    parms.hDevice         = (NvV32)hDevice;
    parms.index           = (NvV32)index;
    parms.paramStructPtr  = (NvV32)paramStructPtr;
    parms.paramSize       = (NvU32)paramSize;

    t_arch.function     = (DWORD)NVRM_ARCH_NV04CONFIGGETEX;
    t_arch.pParameters  = (DWORD)&parms;
    NvIoControl(t_arch.function,(VOID *) &parms);
    
    return (ULONG)parms.status;
}

ULONG NvRmConfigSetExWin9x
(
    ULONG hClient,
    ULONG hDevice,
    ULONG index,
    VOID *paramStructPtr,
    ULONG paramSize
)
{
    NVOS_CONFIG_SET_EX_PARAMS parms;
    NvIoctlArch               t_arch;
    HANDLE            IOCTL_hDevice;

    parms.hClient         = (NvV32)hClient;
    parms.hDevice         = (NvV32)hDevice;
    parms.index           = (NvV32)index;
    parms.paramStructPtr  = (NvV32)paramStructPtr;
    parms.paramSize       = (NvU32)paramSize;

    t_arch.function     = (DWORD)NVRM_ARCH_NV04CONFIGSETEX;
    t_arch.pParameters  = (DWORD)&parms;
    NvIoControl(t_arch.function,(VOID *) &parms);
    
    return (ULONG)parms.status;
}

ULONG NvRmInterruptWin9x
(
    ULONG hClient,
    ULONG hDevice
)
{
    NVOS09_PARAMETERS parms;
    NvIoctlArch       t_arch;
    HANDLE            IOCTL_hDevice;

    parms.hClient       = (NvV32)hClient;
    parms.hDevice       = (NvV32)hDevice;

    t_arch.function     = (DWORD)NVRM_ARCH_NV01INTERRUPT;
    t_arch.pParameters  = (DWORD)&parms;
    NvIoControl(t_arch.function,(VOID *) &parms);
    
    return (ULONG)parms.status;
}

ULONG NvRmRing0CallbackWin9x
(
    ULONG hClient,
    ULONG hDevice,
    ULONG procAddr,
    ULONG param1,
    ULONG param2
)
{
    NVRM_RING0CALLBACK_PARAMS parms;
    NvIoctlArch               t_arch;
    HANDLE                    IOCTL_hDevice;

    parms.hClient       = (NvV32)hClient;
    parms.hDevice       = (NvV32)hDevice;
    parms.functionPtr   = (RING0CALLBACKPROC)procAddr;
    parms.param1        = (NvU32)param1;
    parms.param2        = (NvU32)param2;

    t_arch.function     = (DWORD)NVRM_ARCH_RING0CALLBACK;
    t_arch.pParameters  = (DWORD)&parms;
    NvIoControl(t_arch.function,(VOID *) &parms);
    
    return (ULONG)parms.status;
}

ULONG NvRmI2CAccessWin9x
(
    ULONG hClient,
    ULONG hDevice,
    VOID *paramStructPtr
)
{
    NVOS_I2C_ACCESS_PARAMS    parms;
    NvIoctlArch               t_arch;
    HANDLE                    IOCTL_hDevice;

    parms.hClient         = (NvV32)hClient;
    parms.hDevice         = (NvV32)hDevice;
    parms.paramStructPtr  = (NvV32)paramStructPtr;

    t_arch.function     = (DWORD)NVRM_ARCH_NV04I2CACCESS;
    t_arch.pParameters  = (DWORD)&parms;
    NvIoControl(t_arch.function,(VOID *) &parms);
    
    return (ULONG)parms.status;
}

ULONG NvRmDebugControlWin9x
(
    ULONG hRoot,
    ULONG command,
    VOID *pArgs
)
{
    NVOS20_PARAMETERS         parms;
    NvIoctlArch               t_arch;

    parms.hRoot = hRoot;
    parms.command = command;
    parms.pArgs.selector = GetFlatDataSelector();
    parms.pArgs.offset = (DWORD) pArgs;

    t_arch.function     = (DWORD)NVRM_ARCH_NV01DEBUGCONTROL;
    t_arch.pParameters  = (DWORD)&parms;
    NvIoControl(t_arch.function,(VOID *) &parms);

    return (ULONG)parms.status;
}

// end of nvRmApi9x.c
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\common\src\nv\nvAuApi.c ===
/******************************************************************************
*
*   Module: nvauapi.c
*
*   Description:
*       This module is the main entry module into the NV Architecture Audio Driver.
*
*
*   THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
*   NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
*   IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
*
******************************************************************************/
#include <nvarm.h>
#include <nv32.h>
#include <nvos.h>
// #include <nvarch.h>

#include <aos.h>
#include <AHal.h>

PHWINFO_COMMON_FIELDS	pNvHWInfo[MAX_AUDIO_INSTANCE]={NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL};

// device instance utilities
PHWINFO_COMMON_FIELDS
RmGetAudioDeviceInstance(U032 uRef)
{
    U032 uCount;
    AUDIO_REF aRef;
    
    aRef.uValue = uRef;
    
    for (uCount = 0; uCount < MAX_AUDIO_INSTANCE; uCount++)
    {
        if ((pNvHWInfo[uCount]) && 
            (pNvHWInfo[uCount]->uDevType == aRef.field.type) &&
            (pNvHWInfo[uCount]->uRevisionID == aRef.field.revID))
        {
            // found a device
            return pNvHWInfo[uCount];
        }
    }

    aosDbgPrintString(DEBUGLEVEL_WARNINGS, "NVARM: RmGetAudioDeviceInstance - instance not found\n");
    return NULL;
}


PHWINFO_COMMON_FIELDS
RmAllocAudioDeviceInstance(U032 uType, U008 uRevId)
{
    AUDIO_REF aRef;
    PHWINFO_COMMON_FIELDS pDev;
    
    aRef.field.type = uType;
    aRef.field.revID = uRevId;
    // client id-- don't care
    
    pDev = RmGetAudioDeviceInstance(aRef.uValue);
    
    if (!pDev)
    {
        U032 uCount;
        RM_STATUS rmStatus;
        
        for (uCount = 0; uCount < MAX_AUDIO_INSTANCE; uCount++)
        {
            // find a free index
            if (pNvHWInfo[uCount] == NULL)
                break;
        }
        
        if (uCount == MAX_AUDIO_INSTANCE)
        {
            aosDbgPrintString(DEBUGLEVEL_ERRORS, "NVARM: RmAllocAudioDeviceInstance - MAX_INSTANCE exceeded\n");
            return NULL;
        }
        
        // allocate a new one
        rmStatus = aosAllocateMem(sizeof(HWINFO_COMMON_FIELDS), 
                                    ALIGN_DONT_CARE,
                                    (VOID **)&pNvHWInfo[uCount], 
                                    NULL);
        
        if (rmStatus != RM_OK)
        {
            aosDbgPrintString(DEBUGLEVEL_ERRORS, "NVARM: RmAllocAudioDeviceInstance - mem alloc fails\n");
            return NULL;
        }
        
        pDev = pNvHWInfo[uCount];
        
        // fill the structure up
        pDev->uDevType = uType;
        pDev->uRevisionID = uRevId;
        pDev->uInstanceCounter = 0;
        pDev->pHalContext = NULL;
    }
    
    // increment the instance counter
    pDev->uInstanceCounter++;

    return pDev;
}

VOID
RmFreeAudioDeviceInstance(PHWINFO_COMMON_FIELDS pDev)
{
    // look for the pDev in the array
    U032 uCount;
    
    // check the ref count..
    if (pDev->uInstanceCounter > 1)
    {
        pDev->uInstanceCounter--;
        return;
    }
    
    for (uCount = 0; uCount < MAX_AUDIO_INSTANCE; uCount++)
    {
        if (pNvHWInfo[uCount] == pDev)
            break;
    }
    
    if (uCount == MAX_AUDIO_INSTANCE)
    {
        aosDbgPrintString(DEBUGLEVEL_ERRORS, "NVARM: RmFreeAudioDeviceInstance - instance could not be located\n");
        return;
    }
    
    pNvHWInfo[uCount] = NULL;
    aosFreeMem(pDev);
}

RM_STATUS 
RmAllocAudioMemory(VOID *pParam)
{
    AUDIO_ALLOC_MEMORY	*pAllocParam = (AUDIO_ALLOC_MEMORY *) pParam;
    
    return aosAllocateMem(pAllocParam->uSize,
                        pAllocParam->uAlignMask,
                        (VOID **)&(pAllocParam->pLinearAddress),
                        NULL);
}

RM_STATUS 
RmFreeAudioMemory(VOID *pParam)
{
    AUDIO_FREE_MEMORY *pFreeParam = (AUDIO_FREE_MEMORY *) pParam;
    
    aosFreeMem((VOID *)pFreeParam->pLinearAddress);
    
    return RM_OK;
}

// utility stuff
NvV32 
RmArchStatus(RM_STATUS rmStatus, U032 uArchFunc)
{
    // todo
    return (NvV32) rmStatus;
}

// exported to the calls
NvV32 
NvAuAlloc(U032 hClass, VOID* pAllocParms)
{
    PHWINFO_COMMON_FIELDS   pDev;
    RM_STATUS               rmStatus = RM_ERROR;
    
    switch(hClass)
    {
    case NV01_MEMORY_AUDIO:
        aosDbgPrintString(DEBUGLEVEL_TRACEINFO, "NVARM: NvAuAlloc - NV01_MEMORY_AUDIO ... start\n");
        rmStatus = RmAllocAudioMemory(pAllocParms);
        break;
        
    case NV01_DEVICE_AUDIO:
        {
            AUDIO_INIT_DEVICE *pParam = (AUDIO_INIT_DEVICE *)pAllocParms;
            U008 uClientID = 0;
            AUDIO_REF aRef;
            MCP1_CLIENT_INFO clientInfo;
            
            aosDbgPrintString(DEBUGLEVEL_TRACEINFO, "NVARM: NvAuAlloc - NV01_DEVICE_AUDIO ... start\n");

            if (!pParam)
            {
                aosDbgPrintString(DEBUGLEVEL_WARNINGS, "NVARM: NvAuAlloc - bad param list\n");
                rmStatus = RM_ERR_BAD_OBJECT_BUFFER;
                break;
            }
            
            // allocate a device reference
            // note (WDM specific) - NVMM is not initialized at this point
            // but mem allocation is fine, since it does not ask for physically
            // contiguous memory
            pDev = RmAllocAudioDeviceInstance(hClass, (U008) pParam->uRevisionID);
            
            while(pDev)
            {
                // if it's the first instance then init the device etc
                if (pDev->uInstanceCounter == 1)
                {
                    rmStatus = RmInitAudioDevice((VOID *)pParam->pResList,
                                                (VOID *)pParam->pDevObj,
                                                pDev);
                    
                    if (rmStatus == RM_OK)
                    {
                        rmStatus = InitAudioHal(pParam->uRevisionID, pDev);

                        if (rmStatus == RM_OK)
                            rmStatus = AllocDevice(pDev);
                    }
                }

                break;
            };
            
            if (rmStatus != RM_OK)
            {
                aosDbgPrintString(DEBUGLEVEL_ERRORS, "NVARM: NvAuAlloc - NV01_DEVICE_AUDIO - 1 of the calls failed\n");
                break; 
            }
            
            clientInfo.pFn = pParam->pISRFn;
            clientInfo.Mask.uValue = pParam->IntrMask.uValue;
            clientInfo.pContext = (VOID *)pParam->pServiceContext;
            
            // everything done.. now add the client
            rmStatus = DeviceAddClient(pDev, &clientInfo, &uClientID);
            
            // form a context to be returned
            aRef.field.type = hClass;
            aRef.field.revID = pParam->uRevisionID;
            aRef.field.client = uClientID;
            
            pParam->uDeviceRef = aRef.uValue;
            break;
        }
        
    case NV01_CONTEXT_DMA_AUDIO:
        {
            // get the pDev
            APU_AP_ALLOC_CONTEXT_DMA *pParams = (APU_AP_ALLOC_CONTEXT_DMA *)pAllocParms;

            aosDbgPrintString(DEBUGLEVEL_TRACEINFO, "NVARM: NvAuAlloc - NV01_CONTEXT_DMA_AUDIO ... start\n");

            pDev = RmGetAudioDeviceInstance(pParams->uDeviceRef);
            if (!pDev)
                rmStatus = RM_ERR_BAD_OBJECT_HANDLE;
            else
                rmStatus = AllocContextDma((PHWINFO_COMMON_FIELDS)pDev, pAllocParms);
            
            break;
        }
        
        // audio object calls
    case NV1B_AUDIO_OBJECT:
        {
            APU_OBJECT *pParams = (APU_OBJECT *)pAllocParms;

            aosDbgPrintString(DEBUGLEVEL_TRACEINFO, "NVARM: NvAuAlloc - NV1B_AUDIO_OBJECT ... start\n");

            pDev = RmGetAudioDeviceInstance(pParams->uDeviceRef);
            if (!pDev)
                rmStatus = RM_ERR_BAD_OBJECT_HANDLE;
            else
                rmStatus = AllocObject((PHWINFO_COMMON_FIELDS)pDev, pAllocParms);
            
            break;
        }
        
    default:
        aosDbgPrintString(DEBUGLEVEL_WARNINGS, "NVARM: NvAuAlloc - bad handle\n");
        rmStatus = RM_ERR_BAD_CLASS;
        break;
    }
    
    aosDbgPrintString(DEBUGLEVEL_TRACEINFO, "NVARM: NvAuAlloc ... end\n");
    return RmArchStatus(rmStatus, NV01_ALLOC_DEVICE);
}


NvV32
NvAuFree
(
	U032 hClient,
    U032 hClass,
    U032 uDeviceRef,
    VOID *pParam
)
{
    RM_STATUS rmStatus;

    // find the pDev
    PHWINFO_COMMON_FIELDS pDev = RmGetAudioDeviceInstance(uDeviceRef);

    if (!pDev)
        rmStatus = RM_ERR_BAD_OBJECT_HANDLE;
    else
    {
        switch(hClass)
        {
        case NV01_DEVICE_AUDIO:
        case NV01_DEVICE_EXTERNAL_CODEC:
            {

                // remove client
                AUDIO_REF aRef;
                aRef.uValue = uDeviceRef;

                aosDbgPrintString(DEBUGLEVEL_TRACEINFO, "NVARM: NvAuFree ... NV01_DEVICE start\n");
                
                DeviceRemoveClient(pDev, (U008) aRef.field.client);
                
                // check if this is the last instance
                if (pDev->uInstanceCounter == 1)
                {
                    aosDbgPrintString(DEBUGLEVEL_TRACEINFO, "NVARM: NvAuFree ... NV01_DEVICE freeing device object...\n");
                    rmStatus = FreeDevice(pDev);
                    
                    aosDbgPrintString(DEBUGLEVEL_TRACEINFO, "NVARM: NvAuFree ... NV01_DEVICE freeing HAL...\n");
                    DestroyAudioHal(pDev);
                    
                    aosDbgPrintString(DEBUGLEVEL_TRACEINFO, "NVARM: NvAuFree ... NV01_DEVICE shutting down device...\n");
                    RmShutdownAudioDevice(pDev);
                    
                    aosDbgPrintString(DEBUGLEVEL_TRACEINFO, "NVARM: NvAuFree ... NV01_DEVICE removing instance...\n");
                    RmFreeAudioDeviceInstance(pDev);
                }
            }
            break;
            
        case NV01_CONTEXT_DMA_AUDIO:
        case NV01_CONTEXT_DMA_EXTERNAL_CODEC:
            aosDbgPrintString(DEBUGLEVEL_TRACEINFO, "NVARM: NvAuFree ...  NV01_CONTEXT_DMA start\n");
            rmStatus = FreeContextDma(pDev, pParam);
            break;

        case NV01_EXTERNAL_CODEC_OBJECT:
        case NV1B_AUDIO_OBJECT:
            aosDbgPrintString(DEBUGLEVEL_TRACEINFO, "NVARM: NvAuFree ... one of the audio objects..  start\n");
            rmStatus = FreeObject(pDev, pParam);
            break;
            
        case NV01_MEMORY_AUDIO:
            aosDbgPrintString(DEBUGLEVEL_TRACEINFO, "NVARM: NvAuFree ... NV01_MEMORY_AUDIO start\n");
            rmStatus = RmFreeAudioMemory(pParam);
            break;
            
        default:
            aosDbgPrintString(DEBUGLEVEL_WARNINGS, "NVARM: NvAuFree ... Bad class handle\n");
            rmStatus = RM_ERR_BAD_OBJECT_PARENT;
            break;
        }
    }
    
    aosDbgPrintString(DEBUGLEVEL_TRACEINFO, "NVARM: NvAuFree ... end\n");

    return RmArchStatus(rmStatus, NV01_FREE);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\common\src\nv\nvrmr0api.c ===
/*----------------------------------------------------------------------------*/
/*
 * nvRmR0Api.c
 *
 *  Routines to interact with the resource manager VxD's API services.
 *  
 */

/*----------------------------------------------------------------------------*/
/*
 * include files
 */

// #define WANTVXDWRAPS 
#include <basedef.h>
#include <vmm.h>
#include <vmmreg.h>
#include <vxdldr.h>
//#include <debug.h>
//#include <vxdwraps.h>
#include <vwin32.h>

#include "nvtypes.h"
#include "nvrmr0api.h"
#include "nvrmwin.h"
#include "nvos.h"
#include "files.h"
#include "nvmisc.h"
#include "nvReg.h"

/*----------------------------------------------------------------------------*/
/*
 * pragma's to put the code and data into locked memory (XXX not sure if needed)
 */

#pragma VxD_LOCKED_CODE_SEG
#pragma VxD_LOCKED_DATA_SEG

/*----------------------------------------------------------------------------*/
/*
 * globals
 */

typedef DWORD (* LPDWFN)();
static LPDWFN apiEntry = NULL;
LPDWFN getApiProcR0(char*);

static char strDevNodeRM[128] = NV4_REG_GLOBAL_BASE_PATH "\\" NV4_REG_RESOURCE_MANAGER_SUBKEY;
static char strRmCoreName[] = STR_RM_CORE_NAME;

static CHAR VxdName[32];
#ifdef NV3_HW
static CHAR defaultVxd[] = VXDLDR_NV3_RESMAN_VXD_NAME;
#else
static CHAR defaultVxd[] = VXDLDR_NVX_RESMAN_VXD_NAME;
#endif

#define DEFAULT_DEVICE 0
    
/*----------------------------------------------------------------------------*/
/*
 * nvGetResManAPIEntry - get the API entry point for the resource manager VxD
 */

static PVOID nvGetResManAPIEntry()
{
    ULONG*      pdevinfo = NULL;
    ULONG       size = 32;
    ULONG       hkSW;
    ULONG       cbType;
    ULONG       pos;
    ULONG       status;
    
#ifdef NV3_HW

    //
    // For NV3, don't check registry for RM Core VxD's name. Use the default name.
    //

    // (do string manipulation directly so we don't have to link in the standard str functions)
    pos = 0;
    while ( defaultVxd[pos] ) {
      VxdName[pos] = defaultVxd[pos];
      pos++;
    }
    VxdName[pos] = '\0';

#else

    //
    // For NV4 and up, attempt to get the RM Core VxD's name from the registdry
    //
    status = VMM_RegOpenKey(HKEY_LOCAL_MACHINE, strDevNodeRM, (PVMMHKEY)&hkSW);

    if ( (status == 0) && hkSW ) {
        cbType = REG_BINARY;
        status = VMM_RegQueryValueEx(hkSW, strRmCoreName, NULL, &cbType, &(VxdName[0]), &size);
        VMM_RegCloseKey(hkSW);
    }

    // status = 1; // force use of default VxD name

    if ( status != 0 ) {
        // no registry entry so use default VxD name
        // (do string manipulation directly so we don't have to link in the standard str functions)
        pos = 0;
        while ( defaultVxd[pos] ) {
          VxdName[pos] = defaultVxd[pos];
          pos++;
        }
        VxdName[pos] = '\0';
    }

#endif

    apiEntry = getApiProcR0(VxdName);
    if ( apiEntry == NULL ) {
        // try again with default Vxd name
        apiEntry = getApiProcR0(defaultVxd);
    }

    return(apiEntry);
}

/*----------------------------------------------------------------------------*/
/*
 * callRmAPI - call Resman VxD's API entry point
 */

ULONG callRmAPI(ULONG service, ULONG function, PVOID params)
{

    CLIENT_STRUCT cs;
    CLIENT_STRUCT * pcs = &cs;
    RMUSRAPI_STRUCT rm_struct;
    
    rm_struct.function = service;
    rm_struct.device = DEFAULT_DEVICE;
    cs.CRS.Client_EAX = (ULONG) &rm_struct;
    //cs.CRS.Client_EAX = service;
    

    cs.CRS.Client_EDX = function;
    cs.CRS.Client_EBX = (ULONG)params;
    
    _asm push ebp
    _asm mov  ebp, pcs      ; point ebp to client reg struct 
    
    (*apiEntry)();
    _asm pop  ebp
    
    /* return EAX since resman seems to return most of the "good" stuff there */
    return(cs.CRS.Client_EAX);
}

/*----------------------------------------------------------------------------*/
/*
 * callRmArchAPI - call Resman VxD's API entry point and use the "architecture" 
 *         service
 */

VOID callRmArchAPI(ULONG function, PVOID params)
{

    CLIENT_STRUCT cs;
    CLIENT_STRUCT * pcs = &cs;
    RMUSRAPI_STRUCT rm_struct;
    
    rm_struct.function = NVRM_API_ARCHITECTURE_32;
    rm_struct.device = DEFAULT_DEVICE;
    cs.CRS.Client_EAX = (ULONG) &rm_struct;
    //cs.CRS.Client_EAX = NVRM_API_ARCHITECTURE_32;

    cs.CRS.Client_EDX = function;
    cs.CRS.Client_EBX = (ULONG)params;
    
    _asm push ebp
    _asm mov  ebp, pcs      ; point ebp to client reg struct 
    
    (*apiEntry)();
    _asm pop  ebp
    
    return;
}

/*----------------------------------------------------------------------------*/
/*
 * __GetFlatDataSelector - duplicate of NvGetFlatDataSelector()
 *
 */

static int __GetFlatDataSelector()
{
    DWORD   Selector;

    _asm xor eax, eax
    _asm mov ax, ds
    _asm mov Selector, eax
    return (Selector);
}

/*----------------------------------------------------------------------------*/
/*
 * NvRmR0AllocRoot - allocate root of device tree
 */

ULONG __stdcall NvRmR0AllocRoot (
    ULONG *phClient)
{

    NVOS01_PARAMETERS   parms;
    
    if ( apiEntry == NULL ) {
        nvGetResManAPIEntry();
    }

    /*
     * fill in parameters
     */

    parms.hClass = NV01_ROOT;

    callRmArchAPI(NVRM_ARCH_NV01ALLOCROOT, (PVOID)(&parms));

    *phClient = (ULONG)parms.hObjectNew;

    return(parms.status);

}                                               

/*----------------------------------------------------------------------------*/
/*
 * NvRmR0AllocDevice - allocate a device
 */

ULONG __stdcall NvRmR0AllocDevice (
    ULONG hClient,
    ULONG hDevice,
    ULONG hClass,
    PUCHAR szName )
{

    NVOS06_PARAMETERS   parms; 

    if ( apiEntry == NULL ) {
        nvGetResManAPIEntry();
    }

    /*
     * fill in parameters
     */

    parms.hObjectParent = hClient;
    parms.hObjectNew    = hDevice;
    parms.hClass        = hClass;
    parms.szName        = (NvV32)szName;

    callRmArchAPI(NVRM_ARCH_NV01ALLOCDEVICE, (PVOID)(&parms));

    return(parms.status);

}

/*----------------------------------------------------------------------------*/
/*
 * NvRmR0AllocChannelPio - allocate a PIO channel
 */

ULONG __stdcall NvRmR0AllocChannelPio (
    ULONG hClient,
    ULONG hDevice,
    ULONG hChannel,
    ULONG hClass,
    ULONG hErrorCtx,
    PVOID *ppChannel,
    ULONG flags )
{

    NVOS04_PARAMETERS   parms; 

    if ( apiEntry == NULL ) {
        nvGetResManAPIEntry();
    }

    /*
     * fill in parameters
     */

    parms.hRoot         = hClient;
    parms.hObjectParent = hDevice;
    parms.hObjectNew    = hChannel;
    parms.hClass        = hClass;
    parms.hObjectError  = hErrorCtx;
    parms.flags         = flags;
  
    callRmArchAPI(NVRM_ARCH_NV01ALLOCCHANNELPIO, (PVOID)(&parms));

    *ppChannel = (PVOID)parms.pChannel.offset;

    return(parms.status);

}                                               

/*----------------------------------------------------------------------------*/
/*
 * NvRmR0AllocChannelDMA - allocate a DMA channel
 */

ULONG __stdcall NvRmR0AllocChannelDma(
    ULONG hClient, 
    ULONG hDevice, 
    ULONG hChannel, 
    ULONG hClass, 
    ULONG hErrorCtx, 
    ULONG hDataCtx, 
    ULONG offset, 
    PVOID *ppChannel)
{

    NVOS07_PARAMETERS   parms; 

    if ( apiEntry == NULL ) {
        nvGetResManAPIEntry();
    }

    /*
     * fill in parameters
     */

    parms.hRoot         = hClient;
    parms.hObjectParent = hDevice;
    parms.hObjectNew    = hChannel;
    parms.hClass        = hClass;
    parms.hObjectError  = hErrorCtx;
    parms.hObjectBuffer = hDataCtx;
    parms.offset        = offset;

    callRmArchAPI(NVRM_ARCH_NV03ALLOCCHANNELDMA, (PVOID)(&parms));

    *ppChannel = (PVOID)parms.pControl.offset;

    return(parms.status);

}                                               

/*----------------------------------------------------------------------------*/
/*
 * NvRmR0AllocContextDma - get a context DMA
 */

ULONG __stdcall NvRmR0AllocContextDma(
    ULONG hClient, 
    ULONG hDma, 
    ULONG hClass, 
    ULONG flags, 
    PVOID base, 
    ULONG limit)
{

    NVOS03_PARAMETERS   parms;

    if ( apiEntry == NULL ) {
        nvGetResManAPIEntry();
    }

    /*
     * fill in parameters for the context dma (see nvdsptch.c)
     */

    parms.hObjectParent  = hClient;
    parms.hObjectNew     = hDma;
    parms.hClass         = hClass;
    parms.flags          = flags;
    parms.pBase.selector = __GetFlatDataSelector();
    parms.pBase.offset   = (DWORD)base;
    parms.limit.low      = limit;
  
    callRmArchAPI(NVRM_ARCH_NV01ALLOCCONTEXTDMA, (PVOID)(&parms));

    return(parms.status);

}

/*----------------------------------------------------------------------------*/
/*
 * NvRmR0AllocMemory - Allocate a chunk of memory using the RM
 */

ULONG __stdcall NvRmR0AllocMemory
(
    ULONG hClient, 
    ULONG hParent, 
    ULONG hMemory, 
    ULONG hClass, 
    ULONG flags, 
    PVOID *ppAddress, 
    ULONG *pLimit
)
{
    
    NVOS02_PARAMETERS parms;

    /*
     * fill in parameters for the context dma (see nvdsptch.c)
     */

    parms.hRoot             = hClient;
    parms.hObjectParent     = hParent;
    parms.hObjectNew        = hMemory;
    parms.hClass            = hClass;
    parms.flags             = flags;
    parms.pMemory.selector  = __GetFlatDataSelector();
    parms.pMemory.offset    = (NvU32)(*ppAddress);
    parms.pLimit.high       = 0x00000000;
    parms.pLimit.low        = *pLimit;

    callRmArchAPI(NVRM_ARCH_NV01ALLOCMEMORY, (PVOID)(&parms));

    *ppAddress = (PVOID)parms.pMemory.offset;
    *pLimit    = (ULONG)parms.pLimit.low;

    return(parms.status);
}

/*----------------------------------------------------------------------------*/
/*
 * NvRmR0AllocObject - Allocate a "thing" allocated using RM
 */


ULONG __stdcall NvRmR0AllocObject
(
    ULONG hClient,
    ULONG hChannel,
    ULONG hObject,
    ULONG hClass
)
{
    NVOS05_PARAMETERS parms;

    /*
     * fill in parameters for the context dma (see nvdsptch.c)
     */
    parms.hRoot             = hClient;
    parms.hObjectParent     = hChannel;
    parms.hObjectNew        = hObject;
    parms.hClass            = hClass;
    
    callRmArchAPI(NVRM_ARCH_NV01ALLOCOBJECT, (PVOID)(&parms));

    return(parms.status);
}

/*----------------------------------------------------------------------------*/
/*
 * NvRmR0Alloc - allocate arbitrary objects
 */

ULONG __stdcall NvRmR0Alloc
(
    ULONG hClient, 
    ULONG hChannel,
    ULONG hObject, 
    ULONG hClass, 
    PVOID pAllocParms
)
{
    NVOS21_PARAMETERS parms;

    // set input parameters
    parms.hRoot                 = hClient;
    parms.hObjectParent         = hChannel;
    parms.hObjectNew            = hObject;
    parms.hClass                = hClass;
    parms.pAllocParms.selector  = __GetFlatDataSelector();
    parms.pAllocParms.offset    = (NvU32)pAllocParms;

    callRmArchAPI(NVRM_ARCH_NV04ALLOC, (PVOID)(&parms));

    return parms.status;
}

/*----------------------------------------------------------------------------*/
/*
 * NvRmR0Free - free a "thing" allocated using RM
 */

ULONG __stdcall NvRmR0Free (
    ULONG   hClient,
    ULONG   hParent,
    ULONG   hObject)
{

    NVOS00_PARAMETERS   parms;
    
    if ( apiEntry == NULL ) {
        nvGetResManAPIEntry();
    }

    /*
     * fill in parameters for the root
     */

    parms.hRoot         = hClient;
    parms.hObjectParent = hParent;
    parms.hObjectOld    = hObject;

    callRmArchAPI(NVRM_ARCH_NV01FREE, (PVOID)(&parms));

    return(parms.status);

}

/*
 * NvRmR0Interrupt - force interrupt handling.
 */

ULONG __stdcall NvRmR0Interrupt (
    ULONG   hClient,
    ULONG   hDevice)
{

    NVOS09_PARAMETERS   parms;
    
    if ( apiEntry == NULL ) {
        nvGetResManAPIEntry();
    }

    /*
     * fill in parameters.
     */

    parms.hClient  = hClient;
    parms.hDevice  = hDevice;

    callRmArchAPI(NVRM_ARCH_NV01INTERRUPT, (PVOID)(&parms));

    return(parms.status);
}

/*----------------------------------------------------------------------------*/
/*
 * NvRmR0AllocEvent - Allocate an NV Event
 */


ULONG __stdcall NvRmR0AllocEvent
(
    ULONG hClient,
    ULONG hObjectParent,
    ULONG hObjectNew,
    ULONG hClass,
    ULONG index,
    PVOID data
)
{
    NVOS10_PARAMETERS parms;

    parms.hRoot         = hClient;
    parms.hObjectParent = hObjectParent;
    parms.hObjectNew    = hObjectNew;
    parms.hClass        = hClass;
    parms.index         = index;
    parms.hEvent.low    = (ULONG)data;

    callRmArchAPI(NVRM_ARCH_NV01ALLOCEVENT, (PVOID)(&parms));

    return(parms.status);
}

#ifndef NV3_HW

ULONG  __stdcall NvRmR0I2CAccess
(
    ULONG hClient, 
    ULONG hDevice, 
    VOID  *paramStructPtr
)
{
    NVOS_I2C_ACCESS_PARAMS    parms;

    parms.hClient = hClient;
    parms.hDevice = hDevice;
    parms.paramStructPtr = (ULONG)paramStructPtr;

    callRmArchAPI(NVRM_ARCH_I2C_ACCESS, (PVOID)(&parms));

    return(parms.status);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\common\src\nv\nvRmApiNt.c ===
/*
 * nvRmtApiNt.c
 *
 * NVidia resource manager API implementation for Windows NT.
 *
 * Copyright (c) 1997, Nvidia Corporation.  All rights reserved.
 * Portions Copyright (c) 1996, 1997, Silicon Graphics Inc.
 *
 * THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
 * NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
 * IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
 */

#include <windows.h>
#include <nvEscDef.h>
#include "nvos.h"
#include "nv32.h"
#include "nvRmInt.h"
#include "files.h"
#include "nvmisc.h"
#include "nvcm.h"
#include "nvReg.h"

/*
 * pragmas
 */
#pragma warning(disable : 4101 4035)

/*
 * NvRmOpen - open connection to resource manager
 */

HANDLE NvRmOpenWinNt
(
    VOID
)
{
    HDC   hDC;
    int   ret;
    DWORD in, out;

    hDC = GetDC(0);
    if (hDC == NULL) {
        return (HANDLE)-1;
    }

    in  = (DWORD)0;
    ret = ExtEscape(hDC,
                    NV_ESC_RM_OPEN,
                    sizeof(DWORD), (LPCSTR)&in,
                    sizeof(DWORD), (LPSTR)&out);

    if (ret <= 0) {
        ReleaseDC(0, hDC);
        return (HANDLE)-1;
    }

    ReleaseDC(0, hDC);
    return (out == (DWORD)INVALID_HANDLE_VALUE) ? (HANDLE)-1 : (HANDLE) 0;
}

/*
 * NvRmClose - close connection with resource manager
 */
VOID NvRmCloseWinNt
(
    VOID
)
{
    HDC   hDC;
    int   ret;
    DWORD in, out;

    hDC = GetDC(0);
    if (hDC == NULL) {
        return;
    }

    in  = (DWORD)0;
    ret = ExtEscape(hDC,
                    NV_ESC_RM_CLOSE,
                    sizeof(DWORD), (LPCSTR)&in,
                    sizeof(DWORD), (LPSTR)&out);

    if (ret <= 0) {
        ReleaseDC(0, hDC);
        return;
    }

    ReleaseDC(0, hDC);
    return;
}

/*
 * NvRmAlloc - allocate arbitrary objects
 */
ULONG NvRmAllocWinNt
(
    ULONG hClient, 
    ULONG hParent, 
    ULONG hObject, 
    ULONG hClass, 
    PVOID pAllocParms
)
{
    HDC   hDC;
    int   ret;
    NVOS21_PARAMETERS inParms, outParms;

    // set input parameters
    inParms.hRoot                 = (NvV32)hClient;
    inParms.hObjectParent         = (NvV32)hParent;
    inParms.hObjectNew            = (NvV32)hObject;
    inParms.hClass                = (NvV32)hClass;
    inParms.pAllocParms           = (NvP64)pAllocParms;

    hDC = GetDC(0);
    if (hDC == NULL) {
        return(NVOS21_STATUS_ERROR_OPERATING_SYSTEM);
    }

    ret = ExtEscape(hDC,
                    NV_ESC_RM_ALLOC,
                    sizeof(NVOS21_PARAMETERS), (LPCSTR)&inParms,
                    sizeof(NVOS21_PARAMETERS), (LPSTR)&outParms);

    if (ret <= 0) {
        ReleaseDC(0, hDC);
        return(NVOS21_STATUS_ERROR_OPERATING_SYSTEM);
    }

    ReleaseDC(0, hDC);
    return outParms.status;
}

/*
 * NvAllocRoot - allocate root of device tree
 */
ULONG NvRmAllocRootWinNt
(
    ULONG *phClient
)
{
    HDC   hDC;
    int   ret;
    NVOS01_PARAMETERS inParms, outParms;

    *phClient = 0;

    inParms.hClass = NV01_ROOT;

    hDC = GetDC(0);
    if (hDC == NULL) {
        return(NVOS01_STATUS_ERROR_OPERATING_SYSTEM);
    }

    ret = ExtEscape(hDC,
                    NV_ESC_RM_ALLOC_ROOT,
                    sizeof(NVOS01_PARAMETERS), (LPCSTR)&inParms,
                    sizeof(NVOS01_PARAMETERS), (LPSTR)&outParms);

    if (ret <= 0) {
        ReleaseDC(0, hDC);
        return(NVOS01_STATUS_ERROR_OPERATING_SYSTEM);
    }

    *phClient = (ULONG)outParms.hObjectNew;

    ReleaseDC(0, hDC);
    return outParms.status;
}

/*
 * NvAllocDevice - allocate a device.
 */
ULONG NvRmAllocDeviceWinNt
(
    ULONG hClient,
    ULONG hDevice,
    ULONG hClass,
    PUCHAR szName
)
{
    HDC   hDC;
    int   ret;
    NVOS06_PARAMETERS inParms, outParms;

    inParms.hObjectParent   = (NvV32)hClient;
    inParms.hObjectNew      = (NvV32)hDevice;
    inParms.hClass          = (NvV32)hClass;
    inParms.szName          = (NvV32)szName;

    hDC = GetDC(0);
    if (hDC == NULL) {
        return(NVOS06_STATUS_ERROR_OPERATING_SYSTEM);
    }

    ret = ExtEscape(hDC,
                    NV_ESC_RM_ALLOC_DEVICE,
                    sizeof(NVOS06_PARAMETERS), (LPCSTR)&inParms,
                    sizeof(NVOS06_PARAMETERS), (LPSTR)&outParms);

    if (ret <= 0) {
        ReleaseDC(0, hDC);
        return(NVOS06_STATUS_ERROR_OPERATING_SYSTEM);
    }

    ReleaseDC(0, hDC);
    return outParms.status;
}

/*
 * NvAllocContextDma - allocate and lock down memory using the resource manager.
 */
ULONG NvRmAllocContextDmaWinNt
(
    ULONG hClient,
    ULONG hDma,
    ULONG hClass,
    ULONG flags,
    PVOID base,
    ULONG limit
)
{
    HDC   hDC;
    int   ret;
    NVOS03_PARAMETERS inParms, outParms;

    inParms.hObjectParent   = (NvV32)hClient;
    inParms.hObjectNew      = (NvV32)hDma;
    inParms.hClass          = (NvV32)hClass;
    inParms.flags           = (NvV32)flags;
    inParms.pBase           = (NvP64)base;
    inParms.limit           = (NvU64)limit;

    hDC = GetDC(0);
    if (hDC == NULL) {
        return(NVOS03_STATUS_ERROR_OPERATING_SYSTEM);
    }

    ret = ExtEscape(hDC,
                    NV_ESC_RM_ALLOC_CONTEXT_DMA,
                    sizeof(NVOS03_PARAMETERS), (LPCSTR)&inParms,
                    sizeof(NVOS03_PARAMETERS), (LPSTR)&outParms);

    if (ret <= 0) {
        ReleaseDC(0, hDC);
        return(NVOS03_STATUS_ERROR_OPERATING_SYSTEM);
    }

    ReleaseDC(0, hDC);
    return outParms.status;
}

/*
 * AllocChannelPio - allocate a PIO channel by calling RM.
 */
ULONG NvRmAllocChannelPioWinNt
(
    ULONG hClient,
    ULONG hDevice,
    ULONG hChannel,
    ULONG hClass,
    ULONG hErrorCtx,
    PVOID *ppChannel,
    ULONG flags
)
{
    HDC   hDC;
    int   ret;
    NVOS04_PARAMETERS inParms, outParms;

    inParms.hRoot           = (NvV32)hClient;
    inParms.hObjectParent   = (NvV32)hDevice;
    inParms.hObjectNew      = (NvV32)hChannel;
    inParms.hClass          = (NvV32)hClass;
    inParms.hObjectError    = (NvV32)hErrorCtx;
    inParms.flags           = (NvV32)flags;

    hDC = GetDC(0);
    if (hDC == NULL) {
        return(NVOS04_STATUS_ERROR_OPERATING_SYSTEM);
    }

    ret = ExtEscape(hDC,
                    NV_ESC_RM_ALLOC_CHANNEL_PIO,
                    sizeof(NVOS04_PARAMETERS), (LPCSTR)&inParms,
                    sizeof(NVOS04_PARAMETERS), (LPSTR)&outParms);

    if (ret <= 0) {
        ReleaseDC(0, hDC);
        return(NVOS04_STATUS_ERROR_OPERATING_SYSTEM);
    }

    *ppChannel = (PVOID)outParms.pChannel;

    ReleaseDC(0, hDC);
    return outParms.status;
}

/*
 * NvAllocChannelDma - allocate a DMA push channel using RM.
 */
ULONG NvRmAllocChannelDmaWinNt
(
    ULONG hClient,
    ULONG hDevice,
    ULONG hChannel,
    ULONG hClass,
    ULONG hErrorCtx,
    ULONG hDataCtx,
    ULONG offset,
    PVOID *ppChannel
)
{
    HDC   hDC;
    int   ret;
    NVOS07_PARAMETERS inParms, outParms;

    inParms.hRoot           = (NvV32)hClient;
    inParms.hObjectParent   = (NvV32)hDevice;
    inParms.hObjectNew      = (NvV32)hChannel;
    inParms.hClass          = (NvV32)hClass;
    inParms.hObjectError    = (NvV32)hErrorCtx;
    inParms.hObjectBuffer   = (NvV32)hDataCtx;
    inParms.offset          = (NvV32)offset;

    hDC = GetDC(0);
    if (hDC == NULL) {
        return(NVOS07_STATUS_ERROR_OPERATING_SYSTEM);
    }

    ret = ExtEscape(hDC,
                    NV_ESC_RM_ALLOC_CHANNEL_DMA,
                    sizeof(NVOS07_PARAMETERS), (LPCSTR)&inParms,
                    sizeof(NVOS07_PARAMETERS), (LPSTR)&outParms);

    if (ret <= 0) {
        ReleaseDC(0, hDC);
        return(NVOS07_STATUS_ERROR_OPERATING_SYSTEM);
    }

    *ppChannel = (PVOID)outParms.pControl;

    ReleaseDC(0, hDC);
    return outParms.status;
}

/*
 * NvAllocMemory - allocate and lock down a mess 'o memory using RM.
 */
ULONG NvRmAllocMemoryWinNt
(
    ULONG hClient,
    ULONG hParent,
    ULONG hMemory,
    ULONG hClass,
    ULONG flags,
    PVOID *ppAddress,
    ULONG *pLimit
)
{
    HDC   hDC;
    int   ret;
    NVOS02_PARAMETERS inParms, outParms;

    // set input parameters
    inParms.hRoot               = (NvV32)hClient;
    inParms.hObjectParent       = (NvV32)hParent;
    inParms.hObjectNew          = (NvV32)hMemory;
    inParms.hClass              = (NvV32)hClass;
    inParms.flags               = (NvV32)flags;
    inParms.pMemory             = (NvP64)*ppAddress;
    inParms.pLimit              = (NvU64)*pLimit;

    hDC = GetDC(0);
    if (hDC == NULL) {
        return(NVOS02_STATUS_ERROR_OPERATING_SYSTEM);
    }

    ret = ExtEscape(hDC,
                    NV_ESC_RM_ALLOC_MEMORY,
                    sizeof(NVOS02_PARAMETERS), (LPCSTR)&inParms,
                    sizeof(NVOS02_PARAMETERS), (LPSTR)&outParms);

    if (ret <= 0) {
        ReleaseDC(0, hDC);
        return(NVOS02_STATUS_ERROR_OPERATING_SYSTEM);
    }

    // retrieve output parameters
    *ppAddress = (PVOID)outParms.pMemory;
    *pLimit    = (ULONG)outParms.pLimit;

    ReleaseDC(0, hDC);
    return outParms.status;
}

/*
 * NvAllocObject - allocate a object using RM.
 */
ULONG NvRmAllocObjectWinNt
(
    ULONG hClient,
    ULONG hChannel,
    ULONG hObject,
    ULONG hClass
)
{
    HDC   hDC;
    int   ret;
    NVOS05_PARAMETERS inParms, outParms;

    // set input parameters
    inParms.hRoot           = (NvV32)hClient;
    inParms.hObjectParent   = (NvV32)hChannel;
    inParms.hObjectNew      = (NvV32)hObject;
    inParms.hClass          = (NvV32)hClass;

    hDC = GetDC(0);
    if (hDC == NULL) {
        return(NVOS05_STATUS_ERROR_OPERATING_SYSTEM);
    }

    ret = ExtEscape(hDC,
                    NV_ESC_RM_ALLOC_OBJECT,
                    sizeof(NVOS05_PARAMETERS), (LPCSTR)&inParms,
                    sizeof(NVOS05_PARAMETERS), (LPSTR)&outParms);

    if (ret <= 0) {
        ReleaseDC(0, hDC);
        return(NVOS05_STATUS_ERROR_OPERATING_SYSTEM);
    }

    ReleaseDC(0, hDC);
    return outParms.status;
}

/*
 * NvFree - free a "thing" allocated using RM.
 */
ULONG NvRmFreeWinNt
(
    ULONG hClient,
    ULONG hParent,
    ULONG hObject
)
{
    HDC   hDC;
    int   ret;
    NVOS00_PARAMETERS inParms, outParms;

    inParms.hRoot           = (NvV32)hClient;
    inParms.hObjectParent   = (NvV32)hParent;
    inParms.hObjectOld      = (NvV32)hObject;

    hDC = GetDC(0);
    if (hDC == NULL) {
        return(NVOS00_STATUS_ERROR_OPERATING_SYSTEM);
    }

    ret = ExtEscape(hDC,
                    NV_ESC_RM_FREE,
                    sizeof(NVOS00_PARAMETERS), (LPCSTR)&inParms,
                    sizeof(NVOS00_PARAMETERS), (LPSTR)&outParms);

    if (ret <= 0) {
        ReleaseDC(0, hDC);
        return(NVOS00_STATUS_ERROR_OPERATING_SYSTEM);
    }

    ReleaseDC(0, hDC);
    return(outParms.status);
}

/*
 * NVGetDmaPutInfo - These functions get the channel ID, TLB PT base and address space
 * from the resource manager.  This is a backdoor to program the DMA push registers.
 */
ULONG Nv3RmGetDmaPushInfoWinNt
(
    ULONG hClient,  // this is client NOT channel
    ULONG hDevice,  // this is device NOT flags
    ULONG hChannel, // this is channel NOT put
    ULONG hDmaContext, // this is the DMA context for the push buffer
    ULONG retArray
)
{
    HDC   hDC;
    int   ret;
    ULONG inParms[5], outParms[5];

    inParms[0] = (NvV32)hClient;
    inParms[1] = (NvV32)hDevice;
    inParms[2] = (NvV32)hChannel;
    inParms[3] = (NvV32)retArray;
    inParms[4] = (NvV32)hDmaContext;

    hDC = GetDC(0);
    if (hDC == NULL) {
        return(NVOS08_STATUS_ERROR_OPERATING_SYSTEM);
    }

    ret = ExtEscape(hDC,
                    NV_ESC_RM_DMA_PUSH_INFO,
                    sizeof(inParms), (LPCSTR)&inParms,
                    sizeof(outParms), (LPSTR)&outParms);

    if (ret <= 0) {
        ReleaseDC(0, hDC);
        return(NVOS08_STATUS_ERROR_OPERATING_SYSTEM);
    }

    ReleaseDC(0, hDC);
    return(outParms[4]);
}

ULONG NvRmAllocEventWinNt
(
    ULONG hClient,
    ULONG hObjectParent,
    ULONG hObjectNew,
    ULONG hClass,
    ULONG index,
    ULONG data
)
{
    // This is not supported yet.
    return NVOS10_STATUS_ERROR_OPERATING_SYSTEM;
}

ULONG NvRmArchHeapWinNt
(
    ULONG hClient,
    ULONG hParent,
    ULONG function,
    ULONG owner,
    ULONG type,
    ULONG height,
    ULONG size,
    ULONG *pitch,
    ULONG *offset,
    ULONG *address,
    ULONG *limit,
    ULONG *free,
    ULONG *total
)
{
    HDC   hDC;
    int   ret;
    NVOS11_PARAMETERS inParms, outParms;

    inParms.hRoot         = (NvV32)hClient;
    inParms.hObjectParent = (NvV32)hParent;
    inParms.function      = (NvU32)function;
    inParms.owner         = (NvU32)owner;
    inParms.type          = (NvU32)type;
    inParms.pitch         = (NvS32)((pitch) ? *pitch : 0x0);
    inParms.height        = (NvU32)height;
    inParms.size          = (NvU32)size;
    inParms.offset        = (NvU32)*offset;


    hDC = GetDC(0);
    if (hDC == NULL) {
        return(NVOS11_STATUS_ERROR_INSUFFICIENT_RESOURCES);
    }

    ret = ExtEscape(hDC,
                    NV_ESC_RM_ARCH_HEAP,
                    sizeof(NVOS11_PARAMETERS), (LPCSTR)&inParms,
                    sizeof(NVOS11_PARAMETERS), (LPSTR)&outParms);

    if (ret <= 0) {
        ReleaseDC(0, hDC);
        return(NVOS11_STATUS_ERROR_INSUFFICIENT_RESOURCES);
    }

    if (pitch)
        *pitch   = (ULONG)outParms.pitch;
    *offset  = (ULONG)outParms.offset;
    *address = (ULONG)outParms.address;
    *limit   = (ULONG)outParms.limit;
    *free    = (ULONG)outParms.free;
    *total   = (ULONG)outParms.total;

    ReleaseDC(0, hDC);
    return outParms.status;
}

ULONG NvRmConfigGetWinNt
(
    ULONG hClient,
    ULONG hDevice,
    ULONG index,
    ULONG *pValue
)
{
    HDC   hDC;
    int   ret;
    NVOS13_PARAMETERS inParms, outParms;

    inParms.hClient         = (NvV32)hClient;
    inParms.hDevice         = (NvV32)hDevice;
    inParms.index           = (NvV32)index;

    hDC = GetDC(0);
    if (hDC == NULL) {
        return(NVOS13_STATUS_ERROR_OPERATING_SYSTEM);
    }

    ret = ExtEscape(hDC,
                    NV_ESC_RM_CONFIG_GET,
                    sizeof(NVOS13_PARAMETERS), (LPCSTR)&inParms,
                    sizeof(NVOS13_PARAMETERS), (LPSTR)&outParms);

    if (ret <= 0) {
        ReleaseDC(0, hDC);
        return(NVOS13_STATUS_ERROR_OPERATING_SYSTEM);
    }

    *pValue = (ULONG)outParms.value;

    ReleaseDC(0, hDC);
    return outParms.status;
}

ULONG NvRmConfigSetWinNt
(
    ULONG hClient,
    ULONG hDevice,
    ULONG index,
    ULONG newValue,
    ULONG *pOldValue
)
{
    HDC   hDC;
    int   ret;
    NVOS14_PARAMETERS inParms, outParms;

    inParms.hClient         = (NvV32)hClient;
    inParms.hDevice         = (NvV32)hDevice;
    inParms.index           = (NvV32)index;
    inParms.newValue        = (NvV32)newValue;

    hDC = GetDC(0);
    if (hDC == NULL) {
        return(NVOS14_STATUS_ERROR_OPERATING_SYSTEM);
    }

    ret = ExtEscape(hDC,
                    NV_ESC_RM_CONFIG_SET,
                    sizeof(NVOS14_PARAMETERS), (LPCSTR)&inParms,
                    sizeof(NVOS14_PARAMETERS), (LPSTR)&outParms);

    if (ret <= 0) {
        ReleaseDC(0, hDC);
        return(NVOS14_STATUS_ERROR_OPERATING_SYSTEM);
    }

    *pOldValue = (ULONG)outParms.oldValue;

    ReleaseDC(0, hDC);
    return outParms.status;
}

ULONG NvRmConfigGetExWinNt
(
    ULONG hClient,
    ULONG hDevice,
    ULONG index,
    VOID *paramStructPtr,
    ULONG paramSize
)
{
    HDC   hDC;
    int   ret;
    NVOS_CONFIG_GET_EX_PARAMS inParms, outParms;

    inParms.hClient         = (NvV32)hClient;
    inParms.hDevice         = (NvV32)hDevice;
    inParms.index           = (NvV32)index;
    inParms.paramStructPtr  = (NvV32)paramStructPtr;
    inParms.paramSize       = (NvU32)paramSize;

    hDC = GetDC(0);
    if (hDC == NULL) {
        return(NVOS_CGE_STATUS_ERROR_OPERATING_SYSTEM);
    }

    ret = ExtEscape(hDC,
                    NV_ESC_RM_CONFIG_GET_EX,
                    sizeof(NVOS_CONFIG_GET_EX_PARAMS), (LPCSTR)&inParms,
                    sizeof(NVOS_CONFIG_GET_EX_PARAMS), (LPSTR)&outParms);

    if (ret <= 0) {
        ReleaseDC(0, hDC);
        return(NVOS_CGE_STATUS_ERROR_OPERATING_SYSTEM);
    }

    ReleaseDC(0, hDC);
    return outParms.status;
}

ULONG NvRmConfigSetExWinNt
(
    ULONG hClient,
    ULONG hDevice,
    ULONG index,
    VOID *paramStructPtr,
    ULONG paramSize
)
{
    HDC   hDC;
    int   ret;
    NVOS_CONFIG_SET_EX_PARAMS inParms, outParms;

    inParms.hClient         = (NvV32)hClient;
    inParms.hDevice         = (NvV32)hDevice;
    inParms.index           = (NvV32)index;
    inParms.paramStructPtr  = (NvV32)paramStructPtr;
    inParms.paramSize       = (NvU32)paramSize;

    hDC = GetDC(0);
    if (hDC == NULL) {
        return(NVOS_CSE_STATUS_ERROR_OPERATING_SYSTEM);
    }

    ret = ExtEscape(hDC,
                    NV_ESC_RM_CONFIG_SET_EX,
                    sizeof(NVOS_CONFIG_SET_EX_PARAMS), (LPCSTR)&inParms,
                    sizeof(NVOS_CONFIG_SET_EX_PARAMS), (LPSTR)&outParms);

    if (ret <= 0) {
        ReleaseDC(0, hDC);
        return(NVOS_CSE_STATUS_ERROR_OPERATING_SYSTEM);
    }

    ReleaseDC(0, hDC);
    return outParms.status;
}

ULONG NvRmInterruptWinNt
(
    ULONG hClient,
    ULONG hDevice
)
{
    return NVOS09_STATUS_SUCCESS;
}

ULONG NvRmRing0CallbackWinNt
(
    ULONG hClient,
    ULONG hDevice,
    ULONG procAddr,
    ULONG param1,
    ULONG param2
)
{
    return NVOS09_STATUS_SUCCESS;
}

ULONG NvRmI2CAccessWinNt
(
    ULONG hClient,
    ULONG hDevice,
    VOID *paramStructPtr
)
{
    NVOS_I2C_ACCESS_PARAMS inParams,outParams;
    HDC   hDC;
    int   ret;

    inParams.hClient         = (NvV32)hClient;
    inParams.hDevice         = (NvV32)hDevice;
    inParams.paramStructPtr  = (NvV32)paramStructPtr;
    inParams.paramSize       = (NvV32)sizeof(NVRM_I2C_ACCESS_CONTROL);
    inParams.status          = (NvV32)0;

    hDC = GetDC(0);
    if (hDC == NULL) {
       return NVOS_I2C_ACCESS_STATUS_ERROR_OPERATING_SYSTEM;
    }

    ret = ExtEscape(hDC,
                    NV_ESC_RM_I2C_ACCESS,
                    sizeof(NVOS_I2C_ACCESS_PARAMS), (LPSTR)&inParams,
                    sizeof(NVOS_I2C_ACCESS_PARAMS), (LPSTR)&outParams);

    if (ret <= 0) {
        ReleaseDC(0, hDC);
        return NVOS_I2C_ACCESS_STATUS_ERROR_OPERATING_SYSTEM;
    }
    ReleaseDC(0, hDC);

    return (ULONG)outParams.status;
    
}

ULONG NvRmDebugControlWinNt(
    ULONG hRoot,
    ULONG command,
    VOID *pArgs
)
{
    NVOS20_PARAMETERS inParms, outParms;
    HDC   hDC;
    int   ret;

    inParms.hRoot = hRoot;
    inParms.command = command;
    inParms.pArgs = (NvP64) pArgs;

    hDC = GetDC(0);
    if (hDC == NULL) {
        return NVOS20_STATUS_ERROR_OPERATING_SYSTEM;
    }

    ret = ExtEscape(hDC,
                    NV_ESC_RM_DEBUG_CONTROL,
                    sizeof(NVOS20_PARAMETERS), (LPCSTR)&inParms,
                    sizeof(NVOS20_PARAMETERS), (LPSTR)&outParms);

    if (ret <= 0) {
        ReleaseDC(0, hDC);
        return NVOS20_STATUS_ERROR_OPERATING_SYSTEM;
    }
    ReleaseDC(0, hDC);

    return outParms.status;
}

// end of nvRmApiNt.c
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\common\src\nv\rmfail.c ===
/*
 * TODO
 *    what about multiboard stuff?
 *     win2k puts RM_FAILURE in per-device registery area
 *    win9x: need printf
 */

 /***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-1999 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-1997  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/*
 * Usage:
 *
 *    Add RM_FAILURE tests and triggers as desired
 *    #include <rmfail.h> in any file w/ RM_FAILURE
 * 
 *    Compile with -DDEBUG_RM_FAILURES
 *        Otherwise all RM_FAILURE macro's will vanish
 *
 *    use rmfail.pl in tools/scripts to set RM_FAILURES registry
 *
 *       rmfail.pl set '127 128:18 129:37% 113:50% 200-300:10%'
 *
 *    Optionally set RM_FAILURES_SEED to seed the random number generator.
 *    Otherwise it will be seeded w/ the current time.
 *
 *    Any RM_FAILURE's encountered before RM_FAILURE_ENABLE() will
 *    harmlessly do nothing.
 *    At startup, RmFailuresEnable() will parse the RM_FAILURES string
 *    and produce debug output indicating tests being probed.
 *
 */

#if !defined(__GNUC__) && !defined(MACOS) && !defined(_XBOX)
#include <ntddk.h>       /* XXX just for DbgPrint; delete this if/when switch to another printf */
#endif
#include <nvrm.h>
#include <client.h>
#include <nvos.h>
#include <nvarch.h>

#include <rmfail.h>

#ifdef DEBUG_RM_FAILURES

/* our libc routines.  Since we can't get at libc from the driver we have
 * them incorporated in this file.  These are all from CYGNUS' newlib
 */
// we can't use ctype.h from within resman...
#undef isspace
#define isspace(c) (((c) == ' ') || ((c) == '\011') || ((c) == '\012'))
#undef isdigit
#define isdigit(c) (((c) >= '0') && ((c) <= '9'))
#undef isalpha
#define isalpha(c) ((((c) >= 'a') && ((c) <= 'z')) || (((c) >= 'A') && ((c) <= 'Z')))
#undef isupper
#define isupper(c) (((c) >= 'A') && ((c) <= 'Z'))

long nv_strtol(const char *nptr, char **endptr, int base);
#define RAND_MAX 0x7fffffff
void nv_srand(unsigned int seed);
int nv_rand(void);

static void rm_failure_clear(void)
{        
    (void) memset(rm_failure, 0, sizeof(rm_failure));
    (void) memset(rm_failure_counts, 0, sizeof(rm_failure_counts));
}

static void freakout(char *s)
{
    RM_FAILURE_PRINTF(("RM_FAILURE: init failed: %s\n", s));
    rm_failure_clear();
}

#endif // DEBUG_RM_FAILURES

int RmFailureTriggered(
    int n
)
{
    int rc = 0;
#ifdef DEBUG_RM_FAILURES
    int rint;
    int percent;
    int trigger_count;

    trigger_count = ++rm_failure_counts[n];

    if (rm_failure[n] & RM_FAILURES_MASK_PERCENT)
    {
        percent = rm_failure[n] & RM_FAILURES_MASK_COUNT;
        rint = 1 + (nv_rand() % 100);
        if (rint <= percent)
            rc = 1;
    }
    else
        rc = trigger_count >= rm_failure[n];

    if (rc)
    {
        RM_FAILURE_PRINTF(("RM_FAILURE: triggering %d\n", n));

        if (rm_failure[n] & RM_FAILURES_FLAG_BREAK_ON_TRIGGER)
        {
            osDbgBreakPoint();
        }
        
        // disable the trigger after it fires?
        if (rm_failure[n] & RM_FAILURES_FLAG_DONT_DISABLE_ON_TRIGGER)
        {
            // we aren't disabling, just set count to 0
            if ( ! (rm_failure[n] & RM_FAILURES_MASK_PERCENT))
                rm_failure_counts[n] = 0;
        }
        else
        {
            RM_FAILURE_TRIGGER_DISABLE(n);
        }
    }
#endif  // DEBUG_RM_FAILURES

    return rc;
}


void RmFailuresEnable(void)
{
/*
    parse input of environment variables or registry or config file
        or all 3! into rm_failure[]

    comma or space separated list of

       t[-T][:n[%]] 

    where 't' is test number, 'n' is integer and '%' indicates
    'n' is a percent likelihood of failure
    T is used to specify a range

    Example:

        set RM_FAILURES=127b 128:18 129:37% 113:50% 200-300:10%
        
        test 127 will fail on first pass and enter debugger (checked build)
        test 128 will fail on 18th pass
        test 129 has a 37% chance of failing on every pass
        test 113 has a 50% chance of failing
        test range 200-300 to 10% failing each
*/

#ifdef DEBUG_RM_FAILURES
#define MY_MAX_STR 1024
    char s[MY_MAX_STR], sr[32];
    char *p;
    unsigned int seed;
    int len;
    RM_STATUS rm_status;
    extern char strDevNodeRM[];
    
    // init all to disabled
    rm_failure_clear();
    
    (void) memset(s, 0, sizeof(s));
    len = sizeof(s) - 1;	// for NULL term
    rm_status = osReadRegistryString(strDevNodeRM, "RM_FAILURES", s, &len);
    if (rm_status != RM_OK)
        goto done;

    RM_FAILURE_PRINTF(("RM_FAILURE: %s\n", s));
    
    // init random #
    len = 0; // XXX GetEnvironmentVariable("RM_FAILURES_SEED", sr, sizeof(sr));
    if (len > 0)
        seed = (unsigned int) nv_strtol(sr, (void *) 0, 0);
    else
    {
        // use current time in seconds as seed
        // not exactly defensible for Numerical Methods, but...
#ifdef UNIX
        U032 sec, usec;
        osGetCurrentTime(&sec, &usec);
#else
        U032 year, month, day, hour, min, sec, msec;
        osGetCurrentTime(&year, &month, &day, &hour, &min, &sec, &msec);
        if (year > 1970) year -= 1970;
        month += year * 12;
        day += month * 30;
        hour += day * 24;
        min += hour * 60;
        sec += min * 60;
#endif
        seed = (unsigned int) sec;
    }
    nv_srand(seed);

    RM_FAILURE_PRINTF(("RM_FAILURE: rand seed is %d\n", seed));

    // parse the string
    p = s;
    while (*p)
    {
        int t1, t2, n, percent;
        char *newp;
        int flags = 0;

        newp = p;
        t1 = nv_strtol(p, &newp, 0);
        if (newp == p)   // did not advance; garbage in str. bail out
            break;
        p = newp;

        n = 1;
        percent = 0;
        if ((t1 < 0) || (t1 >= RM_FAILURES_MAX))
            freakout("invalid test number");

        // test range specified?
        t2 = t1;
        if (*p == '-')
        {
            p++;
            newp = p;
            t2 = nv_strtol(p, &newp, 0);
            if (newp == p) // advance?
                break;
            p = newp;

            if ((t2 < 0) || (t2 >= RM_FAILURES_MAX) || (t1 > t2))
            {
                freakout("invalid test range");
                goto failed;
            }
        }

        // check for break and dont disable flags
        while (*p == 'b' || *p == 'd')
        {
            if (*p == 'b')
                flags |= RM_FAILURES_FLAG_BREAK_ON_TRIGGER;
            else if (*p == 'd')
                flags |= RM_FAILURES_FLAG_DONT_DISABLE_ON_TRIGGER;
            p++;
        }
        
        // how quick does the failure fire?
        if (*p == ':')
        {
            p++;
            n = nv_strtol(p, &p, 0);            
            if (n > RM_FAILURES_MAX_COUNT)
            {
                freakout("invalid count");
                goto failed;
            }
            if (*p == '%')
            {
                p++;
                percent = n;
                if ((percent > 100) || (percent < 1))
                {
                    freakout("invalid percent");
                    goto failed;
                }
            }
        }
        
        // record the failure instructions in rm_failure[]
        if (t2 != t1)
        {
            int t;

            for (t = t1; t <= t2; t++)
                if (percent)
                    rm_failure[t] = RM_FAILURES_MASK_PERCENT | percent | flags;
                else
                    rm_failure[t] = n | flags;

            RM_FAILURE_PRINTF(("RM_FAILURE: set range %d-%d to %d%s%s%s\n",
                               t1, t2,
                               percent ? percent : n,
                               percent ? "%" : "",
                               flags & RM_FAILURES_FLAG_BREAK_ON_TRIGGER ?
                                 " (break)" : "",
                               flags & RM_FAILURES_FLAG_DONT_DISABLE_ON_TRIGGER ?
                              "(dont disable)" : ""
                              ));
        }
        else
        {            
            if (percent)
                rm_failure[t1] = RM_FAILURES_MASK_PERCENT | percent | flags;
            else
                rm_failure[t1] = n | flags;

            RM_FAILURE_PRINTF(("RM_FAILURE: set %3d to %d%s%s%s\n",
                               t1,
                               percent ? percent : n,
                               percent ? "%" : "",
                               flags & RM_FAILURES_FLAG_BREAK_ON_TRIGGER ?
                                 " (break)" : "",
                               flags & RM_FAILURES_FLAG_DONT_DISABLE_ON_TRIGGER ?
                              "(dont disable)" : ""
                              ));
        }

        while (*p && (*p == ' '))
            p++;
        if (*p == ',') p++;
    }

 done:
    return;
 failed:
    return;
#endif
}

//
// Disable all RM_FAILURE triggers by zapping them
// To re-enable you must use RmFailuresEnable() which will
// re-read the registry RM_FAILURES value.
//
void RmFailuresDisable(void)
{
#ifdef DEBUG_RM_FAILURES
    RM_FAILURE_PRINTF(("RM_FAILURE: disabled\n"));
    rm_failure_clear();
#endif
}

#ifdef DEBUG_RM_FAILURES
/* Utility routines only below this point */

/*
 * Convert a string to a long integer.
 * From 
 * Ignores `locale' stuff.  Assumes that the upper and lower case
 * alphabets and digits are each contiguous.
 *
 * Copyright (c) 1990 The Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#define LONG_MAX  2147483647L
#define LONG_MIN	(- LONG_MAX - 1L)

long nv_strtol(
    const char *nptr,
    char **endptr,
    int base
)
{
	register const char *s = nptr;
	register unsigned long acc;
	register int c;
	register unsigned long cutoff;
	register int neg = 0, any, cutlim;

	/*
	 * Skip white space and pick up leading +/- sign if any.
	 * If base is 0, allow 0x for hex and 0 for octal, else
	 * assume decimal; if base is already 16, allow 0x.
	 */
	do {
		c = *s++;
	} while (isspace(c));
	if (c == '-') {
		neg = 1;
		c = *s++;
	} else if (c == '+')
		c = *s++;
	if ((base == 0 || base == 16) &&
	    c == '0' && (*s == 'x' || *s == 'X')) {
		c = s[1];
		s += 2;
		base = 16;
	}
	if (base == 0)
		base = c == '0' ? 8 : 10;

	/*
	 * Compute the cutoff value between legal numbers and illegal
	 * numbers.  That is the largest legal value, divided by the
	 * base.  An input number that is greater than this value, if
	 * followed by a legal input character, is too big.  One that
	 * is equal to this value may be valid or not; the limit
	 * between valid and invalid numbers is then based on the last
	 * digit.  For instance, if the range for longs is
	 * [-2147483648..2147483647] and the input base is 10,
	 * cutoff will be set to 214748364 and cutlim to either
	 * 7 (neg==0) or 8 (neg==1), meaning that if we have accumulated
	 * a value > 214748364, or equal but the next digit is > 7 (or 8),
	 * the number is too big, and we will return a range error.
	 *
	 * Set any if any `digits' consumed; make it negative to indicate
	 * overflow.
	 */
	cutoff = neg ? -LONG_MIN : LONG_MAX;
	cutlim = cutoff % (unsigned long)base;
	cutoff /= (unsigned long)base;
	for (acc = 0, any = 0;; c = *s++) {
		if (isdigit(c))
			c -= '0';
		else if (isalpha(c))
			c -= isupper(c) ? 'A' - 10 : 'a' - 10;
		else
			break;
		if (c >= base)
			break;
		if (any < 0 || acc > cutoff || acc == cutoff && c > cutlim)
			any = -1;
		else {
			any = 1;
			acc *= base;
			acc += c;
		}
	}
	if (any < 0) {
		acc = neg ? LONG_MIN : LONG_MAX;
	} else if (neg)
		acc = -(long)acc;
	if (endptr != 0)
		*endptr = (char *) (any ? s - 1 : nptr);
	return (acc);
}
static unsigned int next = 1;

void nv_srand(unsigned int seed)
{
        next = seed;
}

int nv_rand(void)
{
        return ((next = next * 1103515245 + 12345) & RAND_MAX);
}


#endif  // DEBUG_RM_FAILURES
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\common\src\nv\nvRmApiUnix.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1999 NVIDIA, Corp.  All rights reserved.             *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-1997  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/*
 * nvRmApiUnix.c
 *
 *   based on NT/Win9x version of nvRmApi.c
 *
 * NVidia resource manager API.
 *
 * Copyright (c) 1997, Nvidia Corporation.  All rights reserved.
 * Portions Copyright (c) 1996, 1997, Silicon Graphics Inc.
 *
 * THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
 * NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
 * IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
 */

/*
 * This file is linked into programs that talk to the Resource Manager.
 * It does the 'trampoline' as necessary to get to into resman proper.
 */

#if !defined(XFree86LOADER)
#include <sys/mman.h>

#include <sys/ioctl.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>

#include <unistd.h>
#include <stdio.h>
#include <errno.h>

#include <string.h>
#include <stdlib.h>             /* malloc */
#else
# include <xf86_ansic.h>
# include <asm/ioctl.h>
# ifndef off_t
#  define off_t       xf86size_t
# endif
#endif /* XFree86LOADER */

#include <stdint.h>

#include <nv.h>

#include <nvos.h>
#include <nvrm.h>
#include <nv32.h>

#include <nvrmint.h>
#include <nvEscDef.h>
#include <nvmisc.h>
#include <nvcm.h>

typedef struct nv_allocated_mmap_s {
    void *address;
    int   length;
    unsigned int handle;
    struct nv_allocated_mmap_s *next;
} nv_allocated_mmap_t;

/*
 * track the memory mappings visible by the *current application*
 * so that we can just do pointer arithmetic to get valid mappings
 * instead of having the kernel do it.
 *
 * There is one of these per open device in *this application.
 */

typedef struct
{

    ULONG  client;
    ULONG  device_id;
    int    fd;
    int    agpfd;

    ULONG  reg_phys_base;
    ULONG  reg_length;           // size in bytes

    ULONG  fb_phys_base;
    void  *fb;
    ULONG  fb_length;            // size in bytes

    nv_allocated_mmap_t *mmap_list;    // mmap'd memory to free

    char   path[128];            // pathname for device

	int    agp_enabled;          // indicates AGP is enabled one way or another
    
} nv_mapping_t;

nv_mapping_t  nv_mappings[NV_MAX_DEVICES];

nv_ioctl_card_info_t nv_cards[NV_MAX_DEVICES];


/*
 * file descriptor for the NV control device so we can talk to the
 *   driver before picking a board
 */

int ctl_fd = -1;


/*
 * Initialize the mappings and open the control device
 */
static int init_api_layer(void)
{
    nv_mapping_t *nm;
    char *path = "/dev/nvidiactl";
    int rc;
    
    for (nm = nv_mappings; nm < &nv_mappings[NV_MAX_DEVICES]; nm++)
    {
        (void) memset(nm, 0, sizeof(nv_mapping_t));
        nm->fd = -1;
    }

    ctl_fd = open(path, O_RDWR);
    if (ctl_fd < 0)
    {
#ifdef DEBUG
        fprintf(stderr,
                "NV: could not open control device %s (%s)\n",
                path,
                strerror(errno));
#endif
        return 0;
    }

    // pull in the card info from the driver
    rc = ioctl(ctl_fd, NV_IOCTL_CARD_INFO, (void *) nv_cards);
    if (rc < 0)
    {
#ifdef DEBUG
        fprintf(stderr, "NV: could not get NV card info (%s)\n",
                strerror(errno));
#endif
        return 0;
    }

    return 1;
}             

/*
 * remember a memory range so that it can be freed when we free the client
 */

static nv_allocated_mmap_t *remember_mmap_memory(
    nv_mapping_t *nm,
    void    *address,
    int      length,
    unsigned int handle
)
{
    nv_allocated_mmap_t *mm;

    mm = malloc(sizeof(nv_allocated_mmap_t));
    if (mm == (void *) 0)
        return (void *) 0;

    mm->address = address;
    mm->length = length;
    mm->next = nm->mmap_list;
    mm->handle = handle;
    nm->mmap_list = mm;        
    
    return mm;
}

static void *mmap_memory(
    nv_mapping_t *nm,
    int           length,
    off_t         offset,
    unsigned int  handle
)
{
    void *ptr;

    ptr = mmap((void *) 0, length, PROT_WRITE | PROT_READ,
               MAP_SHARED, nm->fd, offset);
    if (ptr != MAP_FAILED)
        return remember_mmap_memory(nm, ptr, length, handle);

    return (void *) 0;
}

static void munmap_memory(
    nv_allocated_mmap_t *mm
)
{
    if (mm->address)
    {
        munmap(mm->address, mm->length);
        mm->address = 0;
        mm->length = ~0;
    }
}

static nv_allocated_mmap_t *find_mmap_by_handle(
    nv_mapping_t *nm,
    unsigned int handle
)
{
    nv_allocated_mmap_t *tmp = nm->mmap_list;

    while (tmp)
    {
        if (tmp->handle == handle)
             break;
        tmp = tmp->next;
    }
    return tmp;
}

static void free_all_mmap_memory(
    nv_mapping_t *nm
)
{
    nv_allocated_mmap_t *mm;
    nv_allocated_mmap_t *next;

    for (mm = nm->mmap_list; mm; )
    {
        (void) munmap_memory(mm);
        next = mm->next;
        free(mm);
        mm = next;
    }    
}
   
static nv_mapping_t *find_mapping(
    ULONG client,
    ULONG device_id
)
{
    nv_mapping_t *nm;
    for (nm = nv_mappings; nm < &nv_mappings[NV_MAX_DEVICES]; nm++)
        if (nm->client == client)
            if ((device_id == 0) || (nm->device_id == device_id))
                return nm;
    return (nv_mapping_t *) 0;
}

static nv_mapping_t *find_empty_mapping(void)
{
    nv_mapping_t *nm;
    for (nm = nv_mappings; nm < &nv_mappings[NV_MAX_DEVICES]; nm++)
        if (nm->client == 0)
            return nm;
    return (nv_mapping_t *) 0;
}

static void clear_old_mapping(nv_mapping_t *nm)
{
    if (!nm) return;

    free_all_mmap_memory(nm);
    (void) memset(nm, 0, sizeof(nv_mapping_t));
}

static int fixup_fb_address(
    nv_mapping_t *nm,
    void        **ppAddress,
    ULONG         offset,
    ULONG         length
)
{
    offset -= nm->fb_phys_base;
    if ((offset + length) > nm->fb_length)
    {
#ifdef DEBUG
        fprintf(stderr,
                "NV: bad offset/length into frame buffer: 0x%lx 0x%lx\n", 
                offset, length);
#endif
        return 1;
    }
    *ppAddress = nm->fb + offset;
    return 0;
}

static int fixup_reg_address(
    nv_mapping_t *nm,
    void        **ppAddress,
    off_t         offset,
    ULONG         length
)
{
    nv_allocated_mmap_t *mm;

    if ((offset + length) > nm->reg_length)
    {
#ifdef DEBUG
        fprintf(stderr,
                "NV: bad offset/length into register area: 0x%lx 0x%lx\n", 
                offset, length);
#endif
        return 1;
    }

    mm = mmap_memory(nm, length, NV_MMAP_REG_OFFSET + offset, 0x0);
    if (mm == (void *) 0)
    {
#ifdef DEBUG
        fprintf(stderr,
                "NV: could not map register space on %s at 0x%lx for 0x%lx "
                "bytes (%s)\n",
                nm->path,
                offset,
                length,
                strerror(errno));
#endif
        return 1;
    }

    *ppAddress = mm->address;

    return 0;
}
    
static int open_actual_device(
    nv_mapping_t *nm,
    char         *pathname,
    int           device_number
)
{
    /* build up the path name */
    if (pathname)
        strcpy(nm->path, pathname);
    else
    {
        strcpy(nm->path, "/dev/nvidia#");
        nm->path[strlen(nm->path) - 1] = '0' + device_number;
    }
    
    nm->fd = open(nm->path, O_RDWR);
    if (nm->fd < 0)
    {
#ifdef DEBUG
        fprintf(stderr,
                "NV: could not open device %s (%s)\n",
                nm->path,
                strerror(errno));
#endif
        return NVOS06_STATUS_ERROR_OPERATING_SYSTEM;
    }

    return 0;
}

static int close_actual_device(
    nv_mapping_t *nm
)
{
    (void) close(nm->fd);
    return 0;
}

static int map_actual_device(
    nv_mapping_t *nm
)
{
    nv_allocated_mmap_t *mm;
    nv_ioctl_memory_vtop_t vtop;
    int ret;

    nm->reg_length = 16 * 1024 * 1024;

    // XXX should map size, not hardwired
    nm->fb_length = 64 * 1024 * 1024;
    mm = mmap_memory(nm, nm->fb_length, NV_MMAP_FB_OFFSET, 0x0);
    if (mm == (void *) 0)
    {
#ifdef DEBUG
        fprintf(stderr,
                "NV: could not map frame buffer on %s (%s)\n",
                nm->path,
                strerror(errno));
        fprintf(stderr,
                "    hint: this may be due to ulimit limiting the amount of virtual memory available to XFree86. Please check your start-up scripts for something like 'ulimit -v <number>' and either boost this value or remove the line.");
#endif
        return NVOS06_STATUS_ERROR_OPERATING_SYSTEM;
    }

    nm->fb = mm->address;
    nm->reg_phys_base = 0;

    /* what is physical address of fb? */
    nm->fb_phys_base = 0;
    vtop.buffer = nm->fb;
    vtop.byte_length = 1;	/* will be rounded up to 1 page */
    vtop.physical_addresses = (unsigned int *) &nm->fb_phys_base;
    ret = ioctl(nm->fd, NV_IOCTL_MEMORY_VTOP, (void *) &vtop);
    if ((ret < 0) || (nm->fb_phys_base == 0))
    {
#ifdef DEBUG
        fprintf(stderr,
                "NV: could not get physical address of frame buffer on %s "
                "(%s)\n",
                nm->path,
                strerror(errno));
#endif
        return NVOS06_STATUS_ERROR_OPERATING_SYSTEM;
    }

    return 0;
}
    
static inline int doEscape(
    int fd,
    int cmd,
    void * parms)
{
    return (ioctl(fd, _IOWR(NV_IOCTL_MAGIC, cmd, sizeof(void *)), parms) >= 0) ? 1 : -1;
}


/*
 * NvAllocRoot - allocate root of device tree
 */
ULONG NvRmAllocRoot(
    ULONG *phClient
)
{
    int   ret;
    NVOS01_PARAMETERS Parms;
    static int firstcall = 1;

    if (firstcall)
        if ( ! init_api_layer())
            return NVOS01_STATUS_ERROR_OPERATING_SYSTEM;
    firstcall = 0;

    *phClient = 0;

    Parms.hClass = NV01_ROOT;

    ret = doEscape(ctl_fd, NV_ESC_RM_ALLOC_ROOT, (void *) &Parms);
    if (ret <= 0)
        return NVOS01_STATUS_ERROR_OPERATING_SYSTEM;

    *phClient = (ULONG)Parms.hObjectNew;

    return Parms.status;
}


/*
 * NvAllocDevice - allocate a device.
 */
ULONG NvRmAllocDevice(
    ULONG hClient,
    ULONG hDevice,
    ULONG hClass,
    PUCHAR szName
)
{
    int   ret;
    NVOS06_PARAMETERS Parms;
    nv_mapping_t *nm;
    char saved_file_name[128];
    char *str;

    strcpy(saved_file_name, "");
    str = saved_file_name;

    if (hClass == NV03_DEVICE_XX)
    {
        nv_ioctl_card_info_t *ci;
	nv_ioctl_primary_card_t pc;
        int bus, slot;
        char *p;
        int i;
	int primary_head = 0;
	int rc;

        strcpy(saved_file_name, (char *) szName);

	// first check if the first character is a "*".
	// If it is, then that's X telling us this is a
	// primary head.
	if (str[0] == '*') {
	    primary_head = 1;
	    str++;
	}

        // check to see if the bus:slot device name requested
        // the X server uses this to request a particular card
        // We convert it here into /dev/nvidia0 form, since the
        // the bus:slot style is not exported to /dev
        if (strchr(str, ':'))
        {
            bus = strtol(str, &p, 0);
            slot = strtol(p+1, (char **) 0, 0);

            for (i=0, ci = nv_cards; i<NV_MAX_DEVICES; i++, ci++)
            {
                if ((ci->flags & NV_IOCTL_CARD_INFO_FLAG_PRESENT) &&
                    (ci->bus == bus) &&
                    (ci->slot == slot))
                {
                    hClass = NV01_DEVICE_0 + i;

		    /* let kernel knw if this is primary */
		    if (primary_head) {
                        pc.index = i;
			rc = ioctl(ctl_fd, NV_IOCTL_PRIMARY_CARD, (void *) &pc);
			if (rc < 0) {
#ifdef DEBUG
			    fprintf(stderr, "NV: could not set primary card "
                                    "(%s)\n", strerror(errno));
#endif
			    return NVOS06_STATUS_ERROR_OPERATING_SYSTEM;
			}
		    }
                    break;
                }
            }
        }
    }

    Parms.hObjectParent   = (NvV32) hClient;
    Parms.hObjectNew      = (NvV32) hDevice;
    Parms.hClass          = (NvV32) hClass;
    Parms.szName          = (NvP64) ((uintptr_t)szName); // assume 64-bit compliance in linux

    ret = doEscape(ctl_fd, NV_ESC_RM_ALLOC_DEVICE, (void *) &Parms);
    if (ret <= 0)
        return NVOS06_STATUS_ERROR_OPERATING_SYSTEM;

    if (Parms.status == NVOS06_STATUS_SUCCESS)
    {
        int devnum = -1;
        char *pathname = 0;


        /*
         * save the client handle in the mapping structure
         */

        nm = find_empty_mapping();
        if (nm == 0)
            return NVOS06_STATUS_ERROR_INSUFFICIENT_RESOURCES;

        nm->client    = hClient;
        nm->device_id = hDevice;

        /*
         * figure out the device name.
         * API allows it to be specified numerically or by string based
         *  on hClass
         */

        if (hClass == NV03_DEVICE_XX)
            pathname = str;
        else
        {
            devnum = hClass - NV01_DEVICE_0;
            if (devnum < 0 || devnum > 8)    // XXX does resman have #define for num devices?
                return NVOS06_STATUS_ERROR_OPERATING_SYSTEM;
        }

        if ((Parms.status = open_actual_device(nm, pathname, devnum)))
            goto done;

        if ((Parms.status = map_actual_device(nm)))
            goto done;
    }

 done:
    return Parms.status;
}

/*
 * NvAllocContextDma - allocate and lock down memory using the resource manager.
 */
ULONG NvRmAllocContextDma(
    ULONG hClient,
    ULONG hDma,
    ULONG hClass,
    ULONG flags,
    PVOID base,
    ULONG limit
)
{
    int   ret;
    NVOS03_PARAMETERS Parms;

    memset(&Parms, 0, sizeof(NVOS03_PARAMETERS));
    Parms.hObjectParent      = (NvV32) hClient;
    Parms.hObjectNew         = (NvV32) hDma;
    Parms.hClass             = (NvV32) hClass;
    Parms.flags              = (NvV32) flags;
    Parms.pBase              = (NvP64) ((uintptr_t)base);
    Parms.limit              = (NvU64) limit;

    ret = doEscape(ctl_fd, NV_ESC_RM_ALLOC_CONTEXT_DMA, (void *) &Parms);
    if (ret <= 0)
        return NVOS03_STATUS_ERROR_OPERATING_SYSTEM;

    return Parms.status;
}

/*
 * AllocChannelPio - allocate a PIO channel by calling RM.
 */
ULONG NvRmAllocChannelPio(
    ULONG  hClient,
    ULONG  hDevice,
    ULONG  hChannel,
    ULONG  hClass,
    ULONG  hErrorCtx,
    PVOID *ppChannel,
    ULONG  flags
)
{
    int   ret;
    NVOS04_PARAMETERS Parms;
    nv_mapping_t *nm;

    nm = find_mapping(hClient, hDevice);
    if (nm == 0)
        return NVOS04_STATUS_ERROR_BAD_CLASS;

    memset(&Parms, 0, sizeof(NVOS04_PARAMETERS));
    Parms.hRoot           = (NvV32) hClient;
    Parms.hObjectParent   = (NvV32) hDevice;
    Parms.hObjectNew      = (NvV32) hChannel;
    Parms.hClass          = (NvV32) hClass;
    Parms.hObjectError    = (NvV32) hErrorCtx;
    Parms.flags           = (NvV32) flags;

    ret = doEscape(nm->fd, NV_ESC_RM_ALLOC_CHANNEL_PIO, (void *) &Parms);
    if (ret <= 0)
        return NVOS04_STATUS_ERROR_OPERATING_SYSTEM;

    if (Parms.status != RM_OK)
        return Parms.status;

    // convert the offset returned into a virtual ptr for this app
    if (0 == fixup_reg_address(nm, ppChannel, (off_t) Parms.pChannel, CHANNEL_LENGTH))
        return Parms.status;

    return NVOS04_STATUS_ERROR_OPERATING_SYSTEM;
}

/*
 * NvAllocChannelDma - allocate a DMA push channel using RM.
 */
ULONG NvRmAllocChannelDma(
    ULONG  hClient,
    ULONG  hDevice,
    ULONG  hChannel,
    ULONG  hClass,
    ULONG  hErrorCtx,
    ULONG  hDataCtx,
    ULONG  offset,
    PVOID *ppChannel
)
{
    int   ret;
    NVOS07_PARAMETERS Parms;
    nv_mapping_t *nm;

    nm = find_mapping(hClient, hDevice);
    if (nm == 0)
        return NVOS07_STATUS_ERROR_BAD_CLASS;

    memset(&Parms, 0, sizeof(NVOS07_PARAMETERS));
    Parms.hRoot           = (NvV32) hClient;
    Parms.hObjectParent   = (NvV32) hDevice;
    Parms.hObjectNew      = (NvV32) hChannel;
    Parms.hClass          = (NvV32) hClass;
    Parms.hObjectError    = (NvV32) hErrorCtx;
    Parms.hObjectBuffer   = (NvV32) hDataCtx;
    Parms.offset          = (NvV32) offset;

    ret = doEscape(nm->fd, NV_ESC_RM_ALLOC_CHANNEL_DMA, (void *) &Parms);
    if (ret <= 0)
        return NVOS07_STATUS_ERROR_OPERATING_SYSTEM;

    if (Parms.status != RM_OK)
        return Parms.status;

    // convert the offset returned into a virtual ptr for this app
    if (0 == fixup_reg_address(nm, ppChannel, (off_t) Parms.pControl, CHANNEL_LENGTH))
        return Parms.status;

    return NVOS04_STATUS_ERROR_OPERATING_SYSTEM;
}

/*
 * NvAllocMemory - allocate and lock down a mess 'o memory using RM.
 */
ULONG NvRmAllocMemory(
    ULONG  hClient,
    ULONG  hParent,
    ULONG  hMemory,
    ULONG  hClass,
    ULONG  flags,
    PVOID *ppAddress,
    ULONG *pLimit
)
{
    int   ret;
    int   status;
    ULONG byte_count = 0;
    nv_mapping_t *nm;
    nv_allocated_mmap_t *mm = (void *) 0;
    NVOS02_PARAMETERS Parms;

#if defined(IA64)
    /* we're only playing with the lower 32 bits of pLimit, which is 64 bits.
     * make sure we zero out the high 32 bits, in case the user passes us an
     * uninitialized memory location.
     */
    {
        U032 *ptr = (U032 *) pLimit;
        ptr[1] = 0x0;
    }
#endif

    // set input parameters
    memset(&Parms, 0, sizeof(NVOS02_PARAMETERS));
    Parms.hRoot                = (NvV32) hClient;
    Parms.hObjectParent        = (NvV32) hParent;
    Parms.hObjectNew           = (NvV32) hMemory;
    Parms.hClass               = (NvV32) hClass;
    Parms.flags                = (NvV32) flags;
    Parms.pMemory              = (NvP64) ((uintptr_t)*ppAddress);
    Parms.pLimit               = (NvU64) *pLimit;

    nm = find_mapping(hClient, hParent);
    if (nm == 0)
        return NVOS02_STATUS_ERROR_BAD_CLASS;

    ret = doEscape(nm->fd, NV_ESC_RM_ALLOC_MEMORY, (void *) &Parms);
    if (ret <= 0)
    {
        status = NVOS02_STATUS_ERROR_OPERATING_SYSTEM;
        goto failed;
    }

    if (Parms.status != RM_OK)
    {
        status = Parms.status;
        goto failed;
    }

    /*
     * On Unix, the only approved way to map memory into user
     *   space is via mmap(2).
     * So here in the glue layer, we actually allocate the memory, and
     *   sneak the pointer into resman to validate and hook into its
     *   data structures.
     */

    switch (hClass)
    {
        case NV01_MEMORY_SYSTEM:
        {
            /* if we're AGP, we'll allocate and map from kernel land..
             * otherwise the kernel complaints about pre-existing PTEs
             */
            off_t offset = NV_MMAP_ALLOCATION_OFFSET;

            if (DRF_VAL(OS02, _FLAGS, _LOCATION, flags) == NVOS02_FLAGS_LOCATION_AGP) {
                offset = NV_MMAP_AGP_OFFSET;
            }
            byte_count = *pLimit + 1;

            mm = mmap_memory(nm, byte_count, offset, hMemory);
            if (mm == (void *) 0)
            {
                status = NVOS02_STATUS_ERROR_OPERATING_SYSTEM;
                goto failed;
            }

            break;
        }
        default:
    }

    *pLimit = (NvU64) Parms.pLimit;
        
    switch (hClass)
    {
        /*
         * Frame buffer memory
         *
         * A little different from NV01_MEMORY_SYSTEM, since we don't know where
         * in fbmem we're going to get our memory until afterwards.
         *
         * So the resman just returns an offset to us and we patch it up
         * afterwards.
         */

        case NV01_MEMORY_LOCAL_USER:
        {
            if (fixup_fb_address(nm,
                                 (void **) ppAddress,
                                 (off_t) Parms.pMemory,
                                 *pLimit + 1))
            {
                status = NVOS02_STATUS_ERROR_INSUFFICIENT_RESOURCES;
                goto failed;
            }
            break;
        }

        // return the pointer in our own space
        case NV01_MEMORY_SYSTEM:
			*ppAddress = mm->address;
            break;

        default:
            *ppAddress = (PVOID)((uintptr_t)Parms.pMemory);
            break;
    }

    return Parms.status;

 failed:
    if (mm && mm->address)
        munmap_memory(mm);

    return status;
}

/* 
 * NvAlloc - allocate any arbitrary object
 */
ULONG NvRmAlloc(
    ULONG hClient,
    ULONG hParent,
    ULONG hObject,
    ULONG hClass,
    PVOID pAllocParms
)
{
    int   ret;
    NVOS21_PARAMETERS Parms;

    // set input parameters
    memset(&Parms, 0, sizeof(NVOS21_PARAMETERS));
    Parms.hRoot                       = (NvV32)hClient;
    Parms.hObjectParent               = (NvV32)hParent;
    Parms.hObjectNew                  = (NvV32)hObject;
    Parms.hClass                      = (NvV32)hClass;
    Parms.pAllocParms                 = (NvP64)((uintptr_t)pAllocParms);

    ret = doEscape(ctl_fd, NV_ESC_RM_ALLOC, (void *)&Parms);

    if (ret <= 0)
        return NVOS21_STATUS_ERROR_OPERATING_SYSTEM;

    return Parms.status;
}

/*
 * NvAllocObject - allocate a object using RM.
 */

ULONG NvRmAllocObject(
    ULONG hClient,
    ULONG hChannel,
    ULONG hObject,
    ULONG hClass
)
{
    int   ret;
    NVOS05_PARAMETERS Parms;

    // set input parameters
    Parms.hRoot           = (NvV32) hClient;
    Parms.hObjectParent   = (NvV32) hChannel;
    Parms.hObjectNew      = (NvV32) hObject;
    Parms.hClass          = (NvV32) hClass;

    ret = doEscape(ctl_fd, NV_ESC_RM_ALLOC_OBJECT, (void *) &Parms);
    if (ret <= 0)
        return NVOS05_STATUS_ERROR_OPERATING_SYSTEM;

    return Parms.status;
}

/*
 * NvFree - free a "thing" allocated using RM.
 */
ULONG NvRmFree(
    ULONG hClient,
    ULONG hParent,
    ULONG hObject
)
{
    int   ret;
    NVOS00_PARAMETERS Parms;
    nv_mapping_t *nm;

    Parms.hRoot           = (NvV32) hClient;
    Parms.hObjectParent   = (NvV32) hParent;
    Parms.hObjectOld      = (NvV32) hObject;

    /* if this is mmapped memory, be sure to munmap it */
    /* not a failure if no nm */
    nm = find_mapping(hClient, hParent);
    if (nm)
    {
        nv_allocated_mmap_t *mm = (void *) 0;
        if ((mm = find_mmap_by_handle(nm, hObject)))
        {
            munmap_memory(mm);
        }
    }

    ret = doEscape(ctl_fd, NV_ESC_RM_FREE, (void *) &Parms);
    if (ret <= 0)
        return NVOS00_STATUS_ERROR_OPERATING_SYSTEM;

    /*
     * if we're freeing up the entire client, then we also need to
     * free the memory and close the device allocated in the glue layer here.
     */

    if ((Parms.status == NVOS00_STATUS_SUCCESS) && (hParent == NV01_NULL_OBJECT))
    {
        nv_mapping_t *nm;
		int i;

        // for each device on this client
        for (nm = &nv_mappings[0], i = 0; i < NV_MAX_DEVICES; nm++, i++)
        {
            if (nm->client == hClient)
            {
                /* free_all_mmap_memory(nm); */
                close_actual_device(nm);
                clear_old_mapping(nm);
            }
        }
    }

    return Parms.status;
}

ULONG NvRmAllocEvent(
    ULONG hClient,
    ULONG hObjectParent,
    ULONG hObjectNew,
    ULONG hClass,
    ULONG index,
    ULONG data
)
{
    int ret;
    NVOS10_PARAMETERS Parms;

    memset(&Parms, 0, sizeof(NVOS10_PARAMETERS));
    Parms.hRoot               = hClient;
    Parms.hObjectParent       = hObjectParent;
    Parms.hObjectNew          = hObjectNew;
    Parms.hClass              = hClass;
    Parms.index               = index;
    Parms.hEvent              = (NvU64) data;

    // we don't really know which device is doing this call, so just use control fd
    ret = doEscape(ctl_fd, NV_ESC_RM_ALLOC_EVENT, (void *) &Parms);
    if (ret <= 0)
        return NVOS10_STATUS_ERROR_OPERATING_SYSTEM;

    return Parms.status;
}


ULONG NvRmArchHeap(
    ULONG hClient,
    ULONG hParent,
    ULONG function,
    ULONG owner,
    ULONG type,
    ULONG height,
    ULONG size,
    ULONG *pitch,
    ULONG *offset,
    ULONG *address,
    ULONG *limit,
    ULONG *free,
    ULONG *total
)
{
    int   ret;
    NVOS11_PARAMETERS Parms;
    nv_mapping_t *nm;

    Parms.hRoot         = (NvV32) hClient;
    Parms.hObjectParent = (NvV32) hParent;
    Parms.function      = (NvU32) function;
    Parms.owner         = (NvU32) owner;
    Parms.type          = (NvU32) type;
    Parms.pitch         = (NvS32) (pitch ? *pitch : 0);
    Parms.height        = (NvU32) height;
    Parms.size          = (NvU32) size;
    Parms.offset        = (NvU32) *offset;

    nm = find_mapping(hClient, hParent);
    if (nm == 0)
        return NVOS11_STATUS_ERROR_INVALID_OWNER;

    ret = doEscape(nm->fd, NV_ESC_RM_ARCH_HEAP, (void *) &Parms);
    if (ret <= 0)
        return NVOS11_STATUS_ERROR_INSUFFICIENT_RESOURCES;
    if (Parms.status != RM_OK)
        return Parms.status;

    if (pitch)
        *pitch = (ULONG) Parms.pitch;
    *offset  = (ULONG) Parms.offset;
    *address = (ULONG) Parms.address;
    *limit   = (ULONG) Parms.limit;
    *free    = (ULONG) Parms.free;
    *total   = (ULONG) Parms.total;

    //
    // fixup address and limit on successful allocate calls
    //
    if (Parms.status == NVOS11_STATUS_SUCCESS)
    {
        switch (function)
        {
            case NVOS11_HEAP_ALLOC_DEPTH_WIDTH_HEIGHT:
            case NVOS11_HEAP_ALLOC_SIZE:
            case NVOS11_HEAP_ALLOC_TILED_PITCH_HEIGHT:
            {
                if (fixup_fb_address(nm,
                                     (void **) address,
                                     *offset + nm->fb_phys_base,
                                     size))
                    return NVOS11_STATUS_ERROR_INSUFFICIENT_RESOURCES;

                break;
            }
        }
    }

    return Parms.status;
}

ULONG NvRmConfigGet(
    ULONG  hClient,
    ULONG  hDevice,
    ULONG  index,
    ULONG *pValue
)
{
    int   ret;
    NVOS13_PARAMETERS Parms;
    nv_mapping_t *nm;

    Parms.hClient         = (NvV32) hClient;
    Parms.hDevice         = (NvV32) hDevice;
    Parms.index           = (NvV32) index;

    nm = find_mapping(hClient, hDevice);
    if (nm == 0)
        return NVOS13_STATUS_ERROR_BAD_CLIENT;

    // we handle some of these in here
    switch (Parms.index)
    {
        case  NV_CFG_DEVICE_HANDLE:
            *pValue = nm->fd;
            Parms.status = NVOS13_STATUS_SUCCESS;
            break;

        default:
            ret = doEscape(nm->fd, NV_ESC_RM_CONFIG_GET, (void *) &Parms);
            if (ret <= 0)
                return NVOS13_STATUS_ERROR_OPERATING_SYSTEM;
            *pValue = Parms.value;
    }

    return Parms.status;
}


ULONG NvRmConfigSet(
    ULONG  hClient,
    ULONG  hDevice,
    ULONG  index,
    ULONG  newValue,
    ULONG *pOldValue
)
{
    int   ret;
    NVOS14_PARAMETERS Parms;
    nv_mapping_t *nm;

    Parms.hClient         = (NvV32) hClient;
    Parms.hDevice         = (NvV32) hDevice;
    Parms.index           = (NvV32) index;
    Parms.newValue        = (NvV32) newValue;

    nm = find_mapping(hClient, hDevice);
    if (nm == 0)
        return NVOS14_STATUS_ERROR_BAD_CLIENT;

    ret = doEscape(nm->fd, NV_ESC_RM_CONFIG_SET, (void *) &Parms);
    if (ret <= 0)
        return NVOS14_STATUS_ERROR_OPERATING_SYSTEM;

    *pOldValue = (ULONG) Parms.oldValue;

    return Parms.status;
}

ULONG NvRmConfigGetEx(
    ULONG hClient,
    ULONG hDevice,
    ULONG index,
    VOID *paramStructPtr,
    ULONG paramSize
)
{
    int   ret;
    NVOS_CONFIG_GET_EX_PARAMS Parms;
    nv_mapping_t *nm;

    nm = find_mapping(hClient, hDevice);
    if (nm == 0)
        return NVOS06_STATUS_ERROR_BAD_OBJECT_PARENT;

    Parms.hClient         = hClient;
    Parms.hDevice         = hDevice;
    Parms.index           = index;
    Parms.paramStructPtr  = (NvP64) ((uintptr_t)paramStructPtr);
    Parms.paramSize       = paramSize;

    ret = doEscape(nm->fd, NV_ESC_RM_CONFIG_GET_EX, (void *) &Parms);
    if (ret <= 0)
        return NVOS_CGE_STATUS_ERROR_OPERATING_SYSTEM;

    return Parms.status;
}


ULONG NvRmConfigSetEx(
    ULONG hClient,
    ULONG hDevice,
    ULONG index,
    VOID *paramStructPtr,
    ULONG paramSize
)
{
    int   ret;
    NVOS_CONFIG_SET_EX_PARAMS Parms;
    nv_mapping_t *nm;

    Parms.hClient         = hClient;
    Parms.hDevice         = hDevice;
    Parms.index           = index;
    Parms.paramStructPtr  = (NvP64) ((uintptr_t)paramStructPtr);
    Parms.paramSize       = paramSize;

    nm = find_mapping(hClient, hDevice);
    if (nm == 0)
        return NVOS_CSE_STATUS_ERROR_BAD_CLIENT;

    ret = doEscape(nm->fd, NV_ESC_RM_CONFIG_SET_EX, (void *) &Parms);
    if (ret <= 0)
        return NVOS_CSE_STATUS_ERROR_OPERATING_SYSTEM;

    return Parms.status;
}

#if 0
ULONG NvRmClipSlam(
    ULONG    hClient,
    ULONG    hChannel,
    ULONG    clips[],        /* {x0,y0,x1,y1}, {x0,y0,x1,y1}, ... */
    ULONG    nClips,
    ULONG    inclusive
)
{
    int  ret;
    XXX_NVOS_I2C_ACCESS_PARAMS  Parms;
    nv_mapping_t *nm;

    Parms.hClient   = hClient;
    Parms.hDevice   = hDevice;
    Parms.clipList  = clipList;
    memcpy(Parms.nClips, clips, min(8, nClips) * 4 * 4);
    Parms.inclusive = inclusive;

    nm = find_mapping(hClient);
    if (nm == 0)
        return XXX_NVOS_I2C_ACCESS_STATUS_ERROR_BAD_CLIENT;

    ret = doEscape(nm->fd, NV_ESC_RM_CLIPLIST_SLAM, (void *) &Parms);
    if (ret <= 0)
        return XXX_NVOS_I2C_ACCESS_STATUS_ERROR_OPERATING_SYSTEM;
    
    return Parms.status;
}

implementation in resman

if not nv10 or better
    return error;

if count too large return error;

wait for IDLE???
set inclusive bit as appropriate in GLOBALSTATE0
for each
   convert to screen space coords of -2048, 2047
   stuff them all

#endif

ULONG  NvRmI2CAccess(
    ULONG hClient,
    ULONG hDevice,
    VOID  *paramStructPtr
)
{
    int  ret;
    NVOS_I2C_ACCESS_PARAMS  Parms;
    nv_mapping_t *nm;

    Parms.hClient        = (NvV32) hClient;
    Parms.hDevice        = (NvV32) hDevice;
    Parms.paramStructPtr = (NvP64) ((uintptr_t)paramStructPtr);

    nm = find_mapping(hClient, hDevice);
    if (nm == 0)
        return NVOS_I2C_ACCESS_STATUS_ERROR_BAD_CLIENT;

    ret = doEscape(nm->fd, NV_ESC_RM_I2C_ACCESS, (void *) &Parms);
    if (ret <= 0)
        return NVOS_I2C_ACCESS_STATUS_ERROR_OPERATING_SYSTEM;
    
    return Parms.status;
}

ULONG  NvRmPowerManagement(
    ULONG hClient,
    ULONG hDevice,
    ULONG head,
    ULONG command, 
    VOID *paramStructPtr
)
{
    int  ret;
    NVOS22_PARAMETERS Parms;
    nv_mapping_t *nm;

    Parms.hRoot          = (NvV32) hClient;
    Parms.hDevice        = (NvV32) hDevice;
    Parms.command        = (NvV32) command;
    Parms.head           = (NvV32) head;
    Parms.params         = (NvP64) ((uintptr_t)paramStructPtr);

    nm = find_mapping(hClient, hDevice);
    if (nm == 0)
        return NVOS22_STATUS_ERROR_BAD_CLIENT;

    ret = doEscape(nm->fd, NV_ESC_RM_POWER_MANAGEMENT, (void *) &Parms);
    if (ret <= 0)
        return NVOS22_STATUS_ERROR_OPERATING_SYSTEM;

    return Parms.status;
}


ULONG NvRmDebugControl(NVOS20_PARAMETERS *parms)
{
    int   ret;
    NVOS20_PARAMETERS Parms;

    ret = doEscape(ctl_fd, NV_ESC_RM_DEBUG_CONTROL, (void *) &Parms);
    if (ret <= 0)
        return NVOS20_STATUS_ERROR_OPERATING_SYSTEM;

    return Parms.status;
}

ULONG  NvRmAGPInit(
    ULONG hClient,
    ULONG hDevice,
    ULONG agp_config
)
{
    int  ret = 0;
    nv_mapping_t *nm;
    NVOS_AGP_PARAMS  Parms;

    nm = find_mapping(hClient, hDevice);
    if (nm == 0)
        return NVOS_AGP_STATUS_ERROR_BAD_CLIENT;

    Parms.hDevice = (NvV32) hDevice;
    Parms.config  = (NvV32) agp_config;

    ret = doEscape(nm->fd, NV_ESC_RM_AGP_INIT, (void *) &Parms);
    if (ret <= 0)
        return NVOS_AGP_STATUS_ERROR_OPERATING_SYSTEM;

    if (Parms.status == RM_OK)
        nm->agp_enabled = 1;

    return Parms.status;
}

ULONG  NvRmAGPTeardown(
    ULONG hClient,
    ULONG hDevice
)
{
    int  ret = 0;
    nv_mapping_t *nm;
    NVOS_AGP_PARAMS  Parms;

    nm = find_mapping(hClient, hDevice);
    if (nm == 0)
        return NVOS_AGP_STATUS_ERROR_BAD_CLIENT;

    // AGP may not be enabled, which is no error
    if (!nm->agp_enabled) 
        return RM_OK;

    Parms.hDevice = (NvV32) hDevice;

    ret = doEscape(nm->fd, NV_ESC_RM_AGP_TEARDOWN, (void *) &Parms);
    if (ret <= 0)
        return NVOS_AGP_STATUS_ERROR_OPERATING_SYSTEM;

    return Parms.status;
}

ULONG NvRmIoFlush(VOID)
{
    int   ret;
    NVOS20_PARAMETERS Parms;

    ret = doEscape(ctl_fd, NV_ESC_RM_IO_FLUSH, (void *) &Parms);
    if (ret <= 0)
        return NVOS20_STATUS_ERROR_OPERATING_SYSTEM;

    return Parms.status;
}

ULONG NvRmConfigVersion(
    ULONG  hClient,
    ULONG  hDevice,
    ULONG *pVersion
)
{
    return NVOS12_STATUS_SUCCESS;
}

ULONG NvRmConfigUpdate(
    ULONG hClient,
    ULONG hDevice,
    ULONG flags
)
{
    return NVOS15_STATUS_SUCCESS;
}

ULONG NvWatchApiFrontEnd(
    ULONG p0,
    ULONG p1,
    ULONG p2,
    ULONG p3,
    ULONG p4,
    ULONG p5,
    ULONG p6
)
{
    NVWATCHAPI_PARAMETERS Parms;

    Parms.p0 = p0;
    Parms.p1 = p1;
    Parms.p2 = p2;
    Parms.p3 = p3;
    Parms.p4 = p4;
    Parms.p5 = p5;
    Parms.p6 = p6;
    return doEscape(ctl_fd, NV_ESC_RM_NVWATCH, (void *) &Parms);
}


/*
 * NvRmInitSwapBarrier
 */
ULONG NvRmInitSwapBarrier(
    ULONG hClient
)
{
    int  ret;
    NVOS2A_PARAMETERS Parms;

    Parms.hClient        = (NvV32) hClient;
    Parms.flags          = (NvV32) (NVOS2A_FLAGS_SWAP_BARRIER | 
                                    NVOS2A_FLAGS_ACTION_INIT);

    ret = doEscape(ctl_fd, NV_ESC_RM_SWAP_EXT, (void *) &Parms);
    if (ret <= 0)
        return NVOS2A_STATUS_ERROR_OPERATING_SYSTEM;

    return Parms.status;
}

/*
 * NvRmAddSwapGroupClient - register us as a swap group client
 */
ULONG NvRmAddSwapGroup(
    ULONG hClient,
    ULONG hDevice,
    ULONG hChannel,
    ULONG id 
)
{
    int  ret;
    NVOS2A_PARAMETERS Parms;

    Parms.hClient        = (NvV32) hClient;
    Parms.hDevice        = (NvV32) hDevice;
    Parms.hChannel       = (NvV32) hChannel;
    Parms.group_id       = (NvV32) id;
    Parms.flags          = (NvV32) (DRF_DEF(OS2A, _FLAGS, _SWAP, _GROUP)| 
                                    DRF_DEF(OS2A, _FLAGS, _ACTION, _ADD));

    ret = doEscape(ctl_fd, NV_ESC_RM_SWAP_EXT, (void *) &Parms);
    if (ret <= 0)
        return NVOS2A_STATUS_ERROR_OPERATING_SYSTEM;

    return Parms.status;
}

/*
 * NvRmRemoveSwapGroup - unregister us as a swap group client
 */
ULONG NvRmRemoveSwapGroup(
    ULONG hClient,
    ULONG hDevice,
    ULONG hChannel,
    ULONG id
)
{
    int  ret;
    NVOS2A_PARAMETERS Parms;

    Parms.hClient        = (NvV32) hClient;
    Parms.hDevice        = (NvV32) hDevice;
    Parms.hChannel       = (NvV32) hChannel;
    Parms.group_id       = (NvV32) id;
    Parms.flags          = (NvV32) (DRF_DEF(OS2A, _FLAGS, _SWAP, _GROUP)| 
                                    DRF_DEF(OS2A, _FLAGS, _ACTION, _REMOVE));

    ret = doEscape(ctl_fd, NV_ESC_RM_SWAP_EXT, (void *) &Parms);
    if (ret <= 0)
        return NVOS2A_STATUS_ERROR_OPERATING_SYSTEM;

    return Parms.status;
}

/*
 * NvRmAddSwapBarrier - register us as a swap barrier client
 */
ULONG NvRmAddSwapBarrier(
    ULONG group_id,
    ULONG barrier_id
)
{
    int  ret;
    NVOS2A_PARAMETERS Parms;

    Parms.group_id       = (NvV32) group_id;
    Parms.barrier_id     = (NvV32) barrier_id;
    Parms.flags          = (NvV32) (DRF_DEF(OS2A, _FLAGS, _SWAP, _BARRIER)| 
                                    DRF_DEF(OS2A, _FLAGS, _ACTION, _ADD));

    ret = doEscape(ctl_fd, NV_ESC_RM_SWAP_EXT, (void *) &Parms);
    if (ret <= 0)
        return NVOS2A_STATUS_ERROR_OPERATING_SYSTEM;

    return Parms.status;
}

/*
 * NvRmRemoveSwapBarrier - unregister us as a swap barrier client
 */
ULONG NvRmRemoveSwapBarrier(
    ULONG barrier_id
)
{
    int  ret;
    NVOS2A_PARAMETERS Parms;

    Parms.barrier_id     = (NvV32) barrier_id;
    Parms.flags          = (NvV32) (DRF_DEF(OS2A, _FLAGS, _SWAP, _BARRIER)| 
                                    DRF_DEF(OS2A, _FLAGS, _ACTION, _REMOVE));

    ret = doEscape(ctl_fd, NV_ESC_RM_SWAP_EXT, (void *) &Parms);
    if (ret <= 0)
        return NVOS2A_STATUS_ERROR_OPERATING_SYSTEM;

    return Parms.status;
}


// end of nvRmApi.c
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\common\src\nv\sgroup.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-1999 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-1997  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************************************************************************
*
*   File: sgroup.c
*
*   Description:
*       This file contains the core implementation of the SWAP GROUP and
*   SWAP BARRIER extensions for SGI.
*
******************************************************************************/

#include <nvrm.h>
#include <os.h>
#include <nvos.h>
#include <nvhw.h>

#define SWAP_MAX_CHANNELS    32
#define SWAP_MAX_GROUPS       5
#define SWAP_INVALID_CHANNEL -1
#define SWAP_INVALID_DEVICE  -1

#define SWAP_MASK(chid)                  (1<<(chid))
#define SWAP_MASK_ADD_CHANNEL(sg,chid)    \
                              ((sg)->channel_mask |= SWAP_MASK(chid))
#define SWAP_MASK_REMOVE_CHANNEL(sg,chid) \
    ((sg)->channel_mask &= ~SWAP_MASK(chid));\
    ((sg)->ready_mask  &= ~SWAP_MASK(chid))
#define SWAP_MASK_CHANNEL_READY(sg,chid)  ((sg)->ready_mask |= SWAP_MASK(chid))
#define SWAP_MASK_SWAP_READY(sg)         ((sg)->ready_mask == (sg)->channel_mask)

static VOID RmSwapCallback(VOID *);
RM_STATUS RmSwapAddGroup(PHWINFO, U032, U032, U032, U032);
RM_STATUS RmSwapAddBarrier(PHWINFO, U032, U032);
RM_STATUS RmSwapRemoveGroup(PHWINFO, U032, U032, U032, U032);
RM_STATUS RmSwapRemoveBarrier(PHWINFO, U032);


/*******
 * Helper Functions
 *******/

static U032
GetChID(
    U032 hClient,
    U032 hDevice,
    U032 hChannel
)
{
    PCLI_DEVICE_INFO deviceList;
    U032 i, j;

    DBG_PRINT_STRING      (DEBUGLEVEL_TRACEINFO, "NVRM: looking for chid:"); 
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM:       client 0x%x", hClient); 
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM:       channel 0x%x", hChannel);


    if (CliSetClientContext(hClient) == FALSE)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: no client, returning -1\n");
        return (U032) SWAP_INVALID_CHANNEL;
    }

    if ((deviceList = CliGetDeviceList()) == NULL)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: no device, returning -1\n");
        return (U032) SWAP_INVALID_CHANNEL;
    }

    for (i = 0; i < NUM_DEVICES; i++)
    {       
        if (deviceList[i].InUse && (deviceList[i].Handle == hDevice) && deviceList[i].DevFifoList)
        {
            for (j = 0; j < MAX_FIFOS; j++)
            {
                if (deviceList[i].DevFifoList[j].Handle == hChannel)
                {
                    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, 
                        "NVRM: returning ", deviceList[i].DevFifoList[j].ChID);
                    return deviceList[i].DevFifoList[j].ChID;
                }
            }
        }
    }
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: no chid, returning -1\n");
    return (U032) SWAP_INVALID_CHANNEL;
}

static U032
GetDevID(PHWINFO pDev)
{
    U032 i;

    for (i = 0; i < MAX_INSTANCE; i++)
        if (pDev == NvDBPtr_Table[i])
            return i;

    return SWAP_INVALID_DEVICE;
}

static PHWINFO
GetPDev(U032 DevID)
{
    if (DevID >= MAX_INSTANCE)
        return NULL;
    return NvDBPtr_Table[DevID];
}

static U032
GetClientDevID(U032 hClient, U032 hDevice)
{
    PCLI_DEVICE_INFO deviceList;
    U032 i;

    if (CliSetClientContext(hClient) == FALSE)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: no client, returning -1\n");
        return (U032) SWAP_INVALID_CHANNEL;
    }

    if ((deviceList = CliGetDeviceList()) == NULL)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: no device, returning -1\n");
        return (U032) SWAP_INVALID_CHANNEL;
    }

    for (i = 0; i < NUM_DEVICES; i++)
    {       
        if (deviceList[i].InUse && (deviceList[i].Handle == hDevice))
            return deviceList[i].DevID;
    }

    return SWAP_INVALID_DEVICE; 
}

static U032
GetErrorDmaContext(
    U032 hClient,
    U032 hDevice,
    U032 hChannel
)
{
    PCLI_DEVICE_INFO deviceList;
    U032 i, j;

    DBG_PRINT_STRING      (DEBUGLEVEL_TRACEINFO, "NVRM: looking for chid:"); 
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM:       client 0x%x", hClient); 
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM:       channel 0x%x", hChannel);


    if (CliSetClientContext(hClient) == FALSE)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: no client, returning -1\n");
        return (U032) SWAP_INVALID_CHANNEL;
    }

    if ((deviceList = CliGetDeviceList()) == NULL)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: no device, returning -1\n");
        return (U032) SWAP_INVALID_CHANNEL;
    }

    for (i = 0; i < NUM_DEVICES; i++)
    {       
        if (deviceList[i].InUse && (deviceList[i].Handle == hDevice) && deviceList[i].DevFifoList)
        {
            for (j = 0; j < MAX_FIFOS; j++)
            {
                if (deviceList[i].DevFifoList[j].Handle == hChannel)
                {
                    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, 
                        "NVRM: returning ", deviceList[i].DevFifoList[j].ErrorDmaContext);
                    return deviceList[i].DevFifoList[j].ErrorDmaContext;
                }
            }
        }
    }
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: no chid, returning -1\n");
    return (U032) SWAP_INVALID_CHANNEL;
}


/*
 * All swap clients are sorted by device.
 * A database of devices is shared among swap groups. A swap group has a 
 * linked list of device pointers that point to the devices in that group.
 *
 * Since a device can have channels in multiple swap groups, the device
 * pointer contains masks specificing which channels belong to that 
 * particular swap group.
 *
 * A channel can only belong to one swap group at a time, so the group id
 * of the bound group is stored in the channel structure.
 *
 */

struct swap_channel_entry_t {
    U032 valid;
    U032 GroupID;
    U032 hClient;
    U032 hErrorDma;   /* to write notifier */
    PDMAOBJECT pDma;
    U032 Put;
};

struct swap_device_entry_t {
    void *pDev;
    struct swap_channel_entry_t channels[SWAP_MAX_CHANNELS];
};

struct dev_ptr_t {
    U032 DevID;
    struct swap_device_entry_t *dev;
    U032 num_channels;
    U032 channel_mask;              /* mask of channels in this group */
    U032 ready_mask;                /* mask of channels ready to swap */
    struct dev_ptr_t *next;
};

struct swap_group_entry_t {
    U032 valid;
    U032 GroupID;
    U032 BarrierID;
    struct dev_ptr_t *devices;
};

// databases
static struct swap_group_entry_t swap_group_db[SWAP_MAX_GROUPS] = {};

// array of pointers to active devices..
static struct swap_device_entry_t *swap_device_db[MAX_INSTANCE] = {};


/********
 * Swap Database Functions
 ********/

static int
dbChannelValidClient(U032 hClient, U032 DevID, U032 ChID)
{
    if (swap_device_db[DevID] == NULL)
        return 0;

    if (swap_device_db[DevID]->channels[ChID].valid &&
        swap_device_db[DevID]->channels[ChID].hClient == hClient)
    {
        return 1;
    }
    return 0;
}

static struct swap_channel_entry_t *
dbChannelFind(U032 DevID, U032 ChID)
{
    // make sure the device is valid
    if (swap_device_db[DevID] == NULL)
        return NULL;

    // make sure the channel was allocated
    if (!swap_device_db[DevID]->channels[ChID].valid)
    {
        return NULL;
    }

    // return the channel
    return (&swap_device_db[DevID]->channels[ChID]);
}

static struct swap_channel_entry_t *
dbChannelAlloc(U032 DevID, U032 ChID)
{
    // we allocate devices as needed to save space..
    if (swap_device_db[DevID] == NULL)
    {
        if (RM_OK != osAllocMem( (void **) &swap_device_db[DevID], 
            sizeof(struct swap_device_entry_t)))
        {
            return NULL;
        }

        // zero the structure out
        osMemSet(swap_device_db[DevID], 0, 
            sizeof(struct swap_device_entry_t));

        // set the device number
        swap_device_db[DevID]->pDev = GetPDev(DevID);
    }

    // make sure this channel isn't already allocated
    if (swap_device_db[DevID]->channels[ChID].valid)
    {
        return NULL;
    }

    // return the channel
    return (&swap_device_db[DevID]->channels[ChID]);
}
    

static VOID
dbChannelFree(U032 DevID, U032 ChID)
{
    // make sure the device is valid
    if (swap_device_db[DevID] == NULL)
        return;

    // make sure the channel was allocated
    if (!swap_device_db[DevID]->channels[ChID].valid)
        return;

    osMemSet(&(swap_device_db[DevID]->channels[ChID]), 0, 
        sizeof(struct swap_channel_entry_t));
}

static struct swap_group_entry_t *
dbGroupFind(U032 GroupID)
{
    U032 i;

    for (i = 0; i < SWAP_MAX_GROUPS; i++)
    {
        if (swap_group_db[i].valid && 
            swap_group_db[i].GroupID == GroupID)
            return (&swap_group_db[i]);
    }
    return NULL;
}

static struct swap_group_entry_t *
dbGroupAlloc(U032 GroupID)
{
    U032 i;

    for (i = 0; i < SWAP_MAX_GROUPS; i++)
    {
        if (!swap_group_db[i].valid)
            return (&swap_group_db[i]);
    }
    return NULL;
}
    

static VOID
dbGroupFree(U032 GroupID)
{
    U032 i;

    for (i = 0; i < SWAP_MAX_GROUPS; i++)
    {
        if (swap_group_db[i].valid && 
            swap_group_db[i].GroupID == GroupID)
        {
            osMemSet(&swap_group_db[i], 0, 
                sizeof(struct swap_group_entry_t));
        }
    }
    return;
}


static struct swap_group_entry_t *
dbGroupFindBarrier(U032 BarrierID)
{
    int i;

    for (i = 0; i < SWAP_MAX_GROUPS; i++)
    {
        // use pDev to make sure the group is valid.. can BarrierID be '0'?
        if (swap_group_db[i].valid && swap_group_db[i].BarrierID == BarrierID)
        {
            return &swap_group_db[i];
        }
    }
    return NULL;
}

/********
 * Swap Group Member Functions
 ********/

static VOID sgRemoveBarrier(struct swap_group_entry_t *sg);

static struct dev_ptr_t *
sgAllocDevPtr(struct swap_group_entry_t *sg, U032 DevID)
{
    struct dev_ptr_t *tmp, *newdev;

    if (RM_OK != osAllocMem( (void **) &newdev, sizeof(struct dev_ptr_t)))
        return NULL;

    // zero the new structure out
    osMemSet(newdev, 0, sizeof(struct dev_ptr_t));

    if ( (sg->devices == NULL) || (sg->devices[0].DevID > DevID))
    {
        // new head device
        newdev->next = sg->devices;
        sg->devices = newdev;
    } else {
        // look for either the end of the list or a larger devID
        tmp = sg->devices;
        while ( (tmp) && (tmp->next) && (tmp->next->DevID > DevID))
            tmp = tmp->next;

        newdev->next = tmp->next;
        tmp->next = newdev;
    }

    newdev->dev          = swap_device_db[DevID];
    newdev->DevID        = DevID;
    newdev->channel_mask = 0;
    newdev->ready_mask   = 0;
    newdev->num_channels = 0;

    return newdev;
}

static void
sgFreeDevPtr(struct swap_group_entry_t *sg, U032 DevID)
{
    struct dev_ptr_t *tmp, *prev;

    if (sg->devices == NULL)
        return;

    prev = tmp = sg->devices;
    while (tmp && tmp->DevID != DevID)
    {
        prev = tmp;
        tmp = tmp->next;
    }

    if (prev == tmp)
        sg->devices = tmp->next;
    else
        prev->next = tmp->next;

    osFreeMem(tmp);

    return;
}

static struct dev_ptr_t *
sgFindDevPtr(struct swap_group_entry_t *sg, U032 DevID)
{
    struct dev_ptr_t *tmp = sg->devices;

    while ( (tmp) && (tmp->DevID != DevID) )
        tmp = tmp->next;

    return tmp;
}

static VOID
sgInit(struct swap_group_entry_t *sg, PHWINFO pDev, U032 GroupID)
{
    sg->GroupID = GroupID;
    sg->BarrierID    = 0;
    sg->devices      = NULL;
    sg->valid = 1;
}

static RM_STATUS
sgAddChannel(struct swap_group_entry_t *sg, U032 DevID, U032 ChID)
{
    struct dev_ptr_t *devptr;

    nv_printf("Adding channel %d:%d to group %d\n", 
        DevID, ChID, sg->GroupID);

    devptr = sgFindDevPtr(sg, DevID);
    if (devptr == NULL)
    {
        devptr = sgAllocDevPtr(sg, DevID);
        if (devptr == NULL)
            return RM_ERROR;
    }

    if (!devptr->dev->channels[ChID].valid)
    {
        return RM_ERROR;
    }

    SWAP_MASK_ADD_CHANNEL(devptr, ChID);
    devptr->num_channels++;

    return RM_OK;
}

static VOID
sgSwapIfReady(struct swap_group_entry_t *sg)
{
    struct dev_ptr_t *tmp;

    // nothing to swap
    if (sg->devices == NULL)
    {
        return;
    }


    // if any device isn't ready, bail out
    tmp = sg->devices;
    while (tmp)
    {
        if (!SWAP_MASK_SWAP_READY(tmp))
        {
            return;
        }
        tmp = tmp->next;
    }

    // if this is part of a barrier, call the barrier function
    // to handle things, otherwise call the swap function to 
    // write everything
    if (sg->BarrierID)
        osSwapBarrier(sg->BarrierID, RmSwapCallback, (VOID*) sg);
    else
        RmSwapCallback((VOID*) sg);
}

static RM_STATUS
sgRemoveChannel(struct swap_group_entry_t *sg, U032 DevID, U032 ChID)
{
    struct dev_ptr_t *devptr;

    nv_printf("Removing channel %d:%d from group %d\n", 
        DevID, ChID, sg->GroupID);

    devptr = sgFindDevPtr(sg, DevID);
    if (devptr == NULL)
    {
        return RM_ERROR;
    }

    // remove channel from masks, and see if we're ready to swap now
    SWAP_MASK_REMOVE_CHANNEL(devptr, ChID);
    devptr->num_channels--;

    if (devptr->num_channels <= 0)
        sgFreeDevPtr(sg, DevID);

    if (sg->devices == 0)
    {
        if (sg->BarrierID)
            sgRemoveBarrier(sg);
        dbGroupFree(sg->GroupID);
        return RM_OK;
    }

    sgSwapIfReady(sg);

    return RM_OK;
}

static VOID
sgChannelReady(struct swap_group_entry_t *sg, U032 DevID, U032 ChID)
{
    struct dev_ptr_t *tmp;

    nv_printf("marking channel %d:%d as ready\n", DevID, ChID);

    if ((tmp = sgFindDevPtr(sg, DevID)) == NULL)
        return;

    SWAP_MASK_CHANNEL_READY(tmp, ChID);
    sgSwapIfReady(sg);
}

static VOID
sgAddBarrier(struct swap_group_entry_t *sg, U032 BarrierID)
{
    sg->BarrierID = BarrierID;
    osInitSwapBarrier(BarrierID);
}

static VOID
sgRemoveBarrier(struct swap_group_entry_t *sg)
{
    osRemoveSwapBarrier(sg->BarrierID);
    sg->BarrierID = 0;
}

/********
 * Swap Channel Member Functions
 ********/

static VOID
scInit(struct swap_channel_entry_t *sc, 
       U032 hClient, 
       U032 hDevice, 
       U032 hChannel, 
       U032 GroupID
)
{
    sc->hClient   = hClient;
    sc->Put       = 0;
    sc->valid     = 1;
    sc->GroupID   = GroupID;
    sc->hErrorDma = GetErrorDmaContext(hClient, hDevice, hChannel);
    sc->pDma      = NULL;
}

static VOID
scPrepareForSwap(struct swap_channel_entry_t *sc, PHWINFO pDev, U032 Put)
{
    sc->Put = Put;

    // the dma object may not be valid when we init the channel,
    // but probably is now. Let's track it down to make the swap
    // itself go faster
    dmaFindContext(pDev, sc->hErrorDma, sc->hClient, &sc->pDma);
}


/********
 * Exported RmSwap Functions
 ********/

RM_STATUS
RmSwapInit(
    PHWINFO pDev
)
{
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "initializing swap extension\n");
    /* anything else needed? */
    osMemSet(swap_group_db, 0x0, sizeof(struct swap_group_entry_t) * 
        SWAP_MAX_GROUPS);
    osMemSet(swap_device_db, 0x0, sizeof(struct swap_device_entry_t *) * 
        MAX_INSTANCE);

    return RM_OK;
}

/* let 'er rip! */
static VOID
RmSwapCallback(
    VOID *data
)
{
    struct swap_group_entry_t *sg = (struct swap_group_entry_t *) data;
    struct dev_ptr_t *devtmp;
    U032 i, ChID;


    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,"RmSwapCallback: 0x%x", data);

    if ((devtmp = sg->devices) == 0)
        return;

#if 0
    // XXX do I even need this??
    /* first, make sure the Pusher can't context switch on us */
    REG_WR_DRF_DEF(_PFIFO, _CACHES, _REASSIGN, _DISABLED);
    while (REG_RD_DRF(_PFIFO, _CACHES, _DMA_SUSPEND) ==
        NV_PFIFO_CACHES_DMA_SUSPEND_BUSY)
        ;
#endif

    while (devtmp)
    {
        PHWINFO pDev = devtmp->dev->pDev;
        U032 DevID = GetDevID(pDev);

        ChID = 0;
        for (i = 0; i < devtmp->num_channels; i++)
        {
            struct swap_channel_entry_t *sc;

            // find the next ChID in the channel mask
            while (!(devtmp->channel_mask & (1<<ChID)))
                ChID++;

            // assume all channels exist for now
            sc = dbChannelFind(DevID, ChID);

            /* write through our mapping to the user's dma put */
            REG_WR32(NV_USER_DMA_PUT(ChID, 0), sc->Put);

            // assume dma object is good, the app will hang otherwise
            notifyFillNotifier(pDev, sc->pDma, 0, 0, RM_OK);

            // increment past the current channel
            ChID++;
        }
        devtmp->ready_mask = 0;
        devtmp = devtmp->next;
    }

#if 0
    REG_WR_DRF_DEF(_PFIFO, _CACHES, _REASSIGN, _ENABLED);
#endif

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "RmSwapCallback: done with swap callback\n");
}


RM_STATUS
RmSwapClient(
    PHWINFO pDev,
    U032    ChID,
    U032    Put
)
{
    struct swap_channel_entry_t *sc = NULL;
    struct swap_group_entry_t  *sg = NULL;
    U032 DevID;

    nv_printf("SwapClient\n");

    if ((DevID = GetDevID(pDev)) == SWAP_INVALID_DEVICE)
    {
        return RM_ERROR;
    }

    sc = dbChannelFind(DevID, ChID);
    if (sc == NULL)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, 
            "Attempting to swap non-registered client\n");
        return RM_ERROR;
    }

    sg = dbGroupFind(sc->GroupID);
    if (sg == NULL)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,
            "Attempting to swap non-registered group\n");
        return RM_ERROR;
    }

    sc->Put = Put;
    scPrepareForSwap(sc, pDev, Put);

    /* indicate we're ready to go */
    sgChannelReady(sg, DevID, ChID);

    sgSwapIfReady(sg);

    return RM_OK;
}

RM_STATUS
RmSwapAddGroup(
    PHWINFO pDev,
    U032    hClient,
    U032    hDevice,
    U032    hChannel,
    U032    GroupID
)
{
    struct swap_channel_entry_t *sc = NULL;
    struct swap_group_entry_t *sg = NULL;
    U032 ChID, DevID;


    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,  "NVRM: SwapAddGroup");
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM: client 0x%x", hClient);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM: channel 0x%x", hChannel);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM: group 0x%x", GroupID);

    sg = dbGroupFind(GroupID);

    if (sg == NULL)
    {
        sg = dbGroupAlloc(GroupID);
        if (sg == NULL)
            return RM_ERROR /* SYS RESOURCES */;

        sgInit(sg, pDev, GroupID);
    }

    ChID = GetChID(hClient, hDevice, hChannel);
    if (ChID == SWAP_INVALID_CHANNEL)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "Couldn't find ChID");
        return RM_ERROR /* INVALID CLIENT? */;
    }

    DevID = GetClientDevID(hClient, hDevice);
    if (DevID == SWAP_INVALID_DEVICE)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "Couldn't find DevID");
        return RM_ERROR /* INVALID DEVICE? */;
    }

    nv_printf("AddGroup: add channel %d:%d to group %d\n", DevID, ChID, GroupID);

    sc = dbChannelAlloc(DevID, ChID);
    if (sc == NULL)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "Channel already allocated?");
        return RM_ERROR /* INVALID CLIENT? */;
    }

    /* store client data */
    scInit(sc, hClient, hDevice, hChannel, GroupID);

    /* store group data */
    sgAddChannel(sg, DevID, ChID);

    return RM_OK;
}


RM_STATUS
RmSwapAddBarrier(
    PHWINFO pDev,
    U032    GroupID,
    U032    BarrierID
)
{
    struct swap_group_entry_t *sg = NULL;

    sg = dbGroupFind(GroupID);

    if (sg == NULL)
    {
        return RM_ERROR /* BAD_GROUP */;
    }

    sgAddBarrier(sg, BarrierID);

    return RM_OK;
}


RM_STATUS
RmSwapRemoveGroup(
    PHWINFO pDev,
    U032    hClient,
    U032    hDevice,
    U032    hChannel,
    U032    GroupID
)
{
    struct swap_group_entry_t *sg = NULL;
    U032 ChID, DevID;

    sg = dbGroupFind(GroupID);
    if (sg == NULL)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,
            "RemoveSwapGroup: invalid group id 0x%x", GroupID);
        return RM_ERROR /* BAD_GROUP */;
    }

    ChID = GetChID(hClient, hDevice, hChannel);
    if (ChID == SWAP_INVALID_CHANNEL)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, 
            "RemoveSwapGroup: invalid group or channel");
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,
            "    client : 0x%x", hClient);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,
            "    channel: 0x%x", hChannel);
        return RM_ERROR /* BAD_GROUP */;
    }

    DevID = GetClientDevID(hClient, hDevice);
    if (ChID == SWAP_INVALID_DEVICE)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "Couldn't find DevID");
        return RM_ERROR /* INVALID DEVICE? */;
    }

    sgRemoveChannel(sg, DevID, ChID);

    dbChannelFree(DevID, ChID);

    return RM_OK;
}

RM_STATUS
RmSwapRemoveBarrier(
    PHWINFO pDev,
    U032    BarrierID
)
{
    struct swap_group_entry_t *sg = NULL;

    sg = dbGroupFindBarrier(BarrierID);

    if (sg == NULL)
    {
        return RM_ERROR /* BAD_GROUP */;
    }

    sgRemoveBarrier(sg);

    return RM_OK;
}


RM_STATUS
RmSwapExt(
    PHWINFO pDev,
    U032    hClient,
    U032    hDevice,
    U032    hChannel,
    U032    flags,
    U032    group_id,
    U032    barrier_id
)
{
    RM_STATUS rmStatus = RM_ERROR;

    if (DRF_VAL(OS2A, _FLAGS, _SWAP, flags) == NVOS2A_FLAGS_SWAP_GROUP)
    {
        if (DRF_VAL(OS2A, _FLAGS, _ACTION, flags) ==
            NVOS2A_FLAGS_ACTION_ADD)
                rmStatus = RmSwapAddGroup(pDev, hClient, hDevice, hChannel, group_id);
        else

        if (DRF_VAL(OS2A, _FLAGS, _ACTION, flags) ==
            NVOS2A_FLAGS_ACTION_REMOVE)
                rmStatus = RmSwapRemoveGroup(pDev, hClient, hDevice, hChannel, group_id);
    } else

    if (DRF_VAL(OS2A, _FLAGS, _SWAP, flags) == NVOS2A_FLAGS_SWAP_BARRIER)
    {
        if (DRF_VAL(OS2A, _FLAGS, _ACTION, flags) ==
            NVOS2A_FLAGS_ACTION_ADD)
                rmStatus = RmSwapAddBarrier(pDev, group_id, barrier_id);

        if (DRF_VAL(OS2A, _FLAGS, _ACTION, flags) ==
            NVOS2A_FLAGS_ACTION_REMOVE)
                rmStatus = RmSwapRemoveBarrier(pDev, barrier_id);
    } else
    /* unknown swap extension */
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: unknown Swap Extension\n");

    return rmStatus;
}

RM_STATUS
RmSwapClientGone(
    U032    hClient
)
{
    U032 DevID, ChID;

    for (DevID = 0; DevID < MAX_INSTANCE; DevID++)
    {
        for (ChID = 0; ChID < SWAP_MAX_CHANNELS; ChID++)
        {
            if (dbChannelValidClient(hClient, DevID, ChID))
            {
                struct swap_channel_entry_t *sc;
                struct swap_group_entry_t *sg;

                sc = dbChannelFind(DevID, ChID);
                if (sc == NULL)
                    return RM_ERROR;

                sg = dbGroupFind(sc->GroupID);
                if (sg == NULL)
                    return RM_ERROR;

                sgRemoveChannel(sg, DevID, ChID);

                dbChannelFree(DevID, ChID);
            }
        }
    }
    return RM_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\dll16\nvarch16.c ===
//
// (C) Copyright NVIDIA Corporation Inc., 1995,1996. All rights reserved.
//
/******************* Operating System Interface Routines *******************\
*                                                                           *
* Module: NVARCH.C                                                          *
*         This is the 16bit DLL interface to the RM for the new architecture*
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Jim Vito (jvito)    03/04/98 - wrote it.                            *
\***************************************************************************/
#include <windows.h>
#include "nv_ref.h"
#include "nvrm.h"
#include "nvrmwin.h"
#include "nvcm.h"
#include <class.h>
#include <vblank.h>
#include <gr.h>
#include <vga.h>
#include "nvsys.h"

extern  void CallRM_DeviceSetup(LPRMPARAMS lprmParams);

#define NVRM_DLL16_NV01FREE            NVRM_ARCH_NV01FREE            
#define NVRM_DLL16_NV01ALLOCROOT       NVRM_ARCH_NV01ALLOCROOT       
#define NVRM_DLL16_NV01ALLOCMEMORY     NVRM_ARCH_NV01ALLOCMEMORY     
#define NVRM_DLL16_NV01ALLOCCONTEXTDMA NVRM_ARCH_NV01ALLOCCONTEXTDMA 
#define NVRM_DLL16_NV01ALLOCCHANNELPIO NVRM_ARCH_NV01ALLOCCHANNELPIO 
#define NVRM_DLL16_NV01ALLOCOBJECT     NVRM_ARCH_NV01ALLOCOBJECT     
#define NVRM_DLL16_NV01ALLOCDEVICE     NVRM_ARCH_NV01ALLOCDEVICE     
#define NVRM_DLL16_NV03ALLOCCHANNELDMA NVRM_ARCH_NV03ALLOCCHANNELDMA 
#define NVRM_DLL16_NV03DMAFLOWCONTROL  NVRM_ARCH_NV03DMAFLOWCONTROL  
#define NVRM_DLL16_NV01INTERRUPT       NVRM_ARCH_NV01INTERRUPT       
#define NVRM_DLL16_NV01ALLOCEVENT      NVRM_ARCH_NV01ALLOCEVENT      
#define NVRM_DLL16_NVI2CACCESS         NVRM_ARCH_I2C_ACCESS      
#define NVRM_DLL16_NV04CONFIGGETEX     NVRM_ARCH_CONFIG_GET_EX       
#define NVRM_DLL16_NV04CONFIGSETEX     NVRM_ARCH_CONFIG_SET_EX       
#define NVRM_DLL16_NV04ALLOC           NVRM_ARCH_NV04ALLOC

#define NVRM_ARCHITECTURE_API          NVRM_API_ARCHITECTURE_16
#define NVOPEN_STATUS_SUCCESS          0
#define NVCLOSE_STATUS_SUCCESS         0

extern U032 FAR * lp16bitProcessDS;

VOID FAR PASCAL NvIoControl
(
  U032 Function,
  VOID FAR *pParameters
)
{
  WORD seg_,off_;
  DWORD seg_base,parameters_flat_offset;
  RMPARAMS rmParams;

  _asm push es
  _asm push di

  _asm les  di,pParameters
  _asm mov  seg_,es
  _asm mov  off_,di

  _asm pop  di
  _asm pop  es

  seg_base = GetSelectorBase((UINT) seg_);
  parameters_flat_offset = seg_base+((DWORD) off_);

  //
  // Call the resource manager and have all of the work done over there.
  // If needed this can send a pointer to an interface structure instead. I think we will run out of registers
  // otherwise. 
  rmParams.RegEAX = NVRM_ARCHITECTURE_API;
  rmParams.RegEBX = parameters_flat_offset;
  rmParams.RegEDX = Function;
  rmParams.RegESI = DEFAULT_DEVICEHANDLE;
  rmParams.RegES  = 0;
  CallRM_DeviceSetup(&rmParams);
}   


VOID FAR PASCAL Arch_NvOpen(U032 *status)                   
{
  *status = NVOPEN_STATUS_SUCCESS;
}

VOID FAR PASCAL Arch_NvClose(U032 *status)                  
{
  *status = NVCLOSE_STATUS_SUCCESS;
}

VOID FAR PASCAL Arch_Nv01Free(VOID FAR *pParameters)            
{
  NvIoControl(NVRM_DLL16_NV01FREE,pParameters);
}

VOID FAR PASCAL Arch_Nv01AllocRoot(VOID FAR *pParameters)       
{
  NvIoControl(NVRM_DLL16_NV01ALLOCROOT,pParameters);
}

VOID FAR PASCAL Arch_Nv04Alloc(VOID FAR *pParameters)       
{
  NvIoControl(NVRM_DLL16_NV04ALLOC,pParameters);
}

VOID FAR PASCAL Arch_Nv01AllocMemory(VOID FAR *pParameters)     
{
  NvIoControl(NVRM_DLL16_NV01ALLOCMEMORY,pParameters);
}

VOID FAR PASCAL Arch_Nv01AllocContextDma(VOID FAR *pParameters) 
{
  NvIoControl(NVRM_DLL16_NV01ALLOCCONTEXTDMA,pParameters);
}

VOID FAR PASCAL Arch_Nv01AllocChannelPio(VOID FAR *pParameters) 
{
  NvIoControl(NVRM_DLL16_NV01ALLOCCHANNELPIO,pParameters);
}

VOID FAR PASCAL Arch_Nv01AllocObject(VOID FAR *pParameters)     
{
  NvIoControl(NVRM_DLL16_NV01ALLOCOBJECT,pParameters);
}

VOID FAR PASCAL Arch_Nv01AllocDevice(VOID FAR *pParameters)     
{
  NvIoControl(NVRM_DLL16_NV01ALLOCDEVICE,pParameters);
}

VOID FAR PASCAL Arch_Nv01AllocChannelDma(VOID FAR *pParameters)     
{
  NvIoControl(NVRM_DLL16_NV03ALLOCCHANNELDMA,pParameters);
}
VOID FAR PASCAL Arch_Nv03DmaFlowControl(VOID FAR *pParameters)
{
  NvIoControl(NVRM_DLL16_NV03DMAFLOWCONTROL,pParameters);
}
VOID FAR PASCAL Arch_Nv01Interrupt(VOID FAR *pParameters)       
{
  NvIoControl(NVRM_DLL16_NV01INTERRUPT,pParameters);
}

VOID FAR PASCAL Arch_Nv01AllocEvent(VOID FAR *pParameters)      
{
  NvIoControl(NVRM_DLL16_NV01ALLOCEVENT,pParameters);
}

VOID FAR PASCAL Arch_NvI2CAccess(VOID FAR *pParameters)      
{
  NvIoControl(NVRM_DLL16_NVI2CACCESS,pParameters);
}

VOID FAR PASCAL Arch_Nv04ConfigGetEx(VOID FAR *pParameters)      
{
  NvIoControl(NVRM_DLL16_NV04CONFIGGETEX,pParameters);
}

VOID FAR PASCAL Arch_Nv04ConfigSetEx(VOID FAR *pParameters)      
{
  NvIoControl(NVRM_DLL16_NV04CONFIGSETEX,pParameters);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\dll16\NVRM16.ASM ===
; 
;  (C) Copyright NVIDIA Corporation Inc., 1995,1996. All rights reserved.
; 
.386

_DATA           SEGMENT WORD PUBLIC USE16 'DATA'

EXTERN  _ResManAPI : DWORD

_DATA           ENDS
        
_TEXT           SEGMENT WORD PUBLIC USE16 'CODE'

        ASSUME  ds:_DATA
;
; Call the resource manager.
; It is called as:
;
;       VOID FAR PASCAL CallRM((LPNVPARAMS)lpParams);
;
lpParams        EQU     [bp + 6]
RegEAX          EQU     0
RegEBX          EQU     4
RegECX          EQU     8
RegEDX          EQU     12
RegEDI          EQU     16
RegESI          EQU     20
RegES           EQU     24
RegDS           EQU     28
RegCS           EQU     32

public  CALLRM
CALLRM          PROC NEAR
        push    bp
        mov     bp, sp
        push    eax
        push    ebx
        push    ecx
        push    edx
        push    edi
        push    esi
        push    es
        les     si,  DWORD PTR lpParams
        mov     eax, DWORD PTR es:[si + RegEAX]
        push    eax
        mov     ebx, DWORD PTR es:[si + RegEBX]
        mov     ecx, DWORD PTR es:[si + RegECX]
        mov     edx, DWORD PTR es:[si + RegEDX]
        mov     edi, DWORD PTR es:[si + RegEDI]
        mov     ax,   WORD PTR es:[si + RegES]
        mov     esi, DWORD PTR es:[si + RegESI]
        mov     es, ax
        pop     eax
        call    DWORD PTR _ResManAPI
        push    eax
        push    esi
        mov     ax, es
        les     si, DWORD PTR lpParams
        mov     WORD PTR es:[si + RegES], ax
        pop     eax
        mov     DWORD PTR es:[si + RegESI], eax
        pop     eax
        mov     DWORD PTR es:[si + RegEAX], eax
        mov     DWORD PTR es:[si + RegEBX], ebx
        mov     DWORD PTR es:[si + RegECX], ecx
        mov     DWORD PTR es:[si + RegEDX], edx
        mov     DWORD PTR es:[si + RegEDI], edi
        pop     es
        pop     esi
        pop     edi
        pop     edx
        pop     ecx
        pop     ebx
        pop     eax
        leave
        retf	4
CALLRM          ENDP
;
; Read and write 32 bit registers.
; Called as:
;
;       VOID  FAR PASCAL REG_WR32(FAR DWORD *Address, DWORD Data);
;       DWORD FAR PASCAL REG_RD32(FAR DWORD *Address);
;
RdAddress       EQU     [bp + 6]
WrAddress       EQU     [bp + 10]
WrData          EQU     [bp + 6]

public  REG_WR32
REG_WR32        PROC NEAR
        push    bp
        mov     bp, sp
        push    eax
        push    si
        push    es
        les     si,  DWORD PTR WrAddress
        mov     eax, WrData
        mov     DWORD PTR es:[si], eax
        pop     es
        pop     si
        pop     eax
        leave
        retf	8
REG_WR32        ENDP
public  REG_RD32
REG_RD32        PROC NEAR
        push    bp
        mov     bp, sp
        push    ecx
        push    si
        push    es
        les     si,  DWORD PTR RdAddress
        mov     ecx, DWORD PTR es:[si]
        mov     ax, cx
        shr     ecx, 16
        mov     dx, cx
        pop     es
        pop     si
        pop     ecx
        leave
        retf	4
REG_RD32        ENDP
;
; Read and write 32 bit registers.
; Called as:
;
;       VOID  FAR PASCAL REG_WR32(FAR DWORD *Address, DWORD Data);
;       DWORD FAR PASCAL REG_RD32(FAR DWORD *Address);
;
RdAddress       EQU     [bp + 6]
WrAddress       EQU     [bp + 10]
WrData          EQU     [bp + 6]

public  REG_WR08
REG_WR08        PROC NEAR
        push    bp
        mov     bp, sp
        push    eax
        push    si
        push    es
        les     si,  DWORD PTR WrAddress
        mov     al, WrData
        mov     BYTE PTR es:[si], al
        pop     es
        pop     si
        pop     eax
        leave
        retf	8
REG_WR08        ENDP
public  REG_RD08
REG_RD08        PROC NEAR
        push    bp
        mov     bp, sp
        push    ecx
        push    si
        push    es
        les     si,  DWORD PTR RdAddress
        mov     al, BYTE PTR es:[si]
        pop     es
        pop     si
        pop     ecx
        leave
        retf	4
REG_RD08        ENDP
;
; Hide the emulated cursor in the framebuffer.
;
; Called as:
;
;        NvSysHideEmulatedCursor(WORD, WORD, WORD, WORD, WORD, WORD, WORD, WORD, DWORD FAR *);
;
xGlyphPos       EQU     [bp + 24]
yGlyphPos       EQU     [bp + 22]
cxGlyphWidth    EQU     [bp + 20]
cyGlyphHeight   EQU     [bp + 18]
cxScreenWidth   EQU     [bp + 16]
cyScreenHeight  EQU     [bp + 14]
cScreenDepth    EQU     [bp + 12]
selScreen       EQU     [bp + 10]
lpSaveUnder     EQU     [bp + 6]
public NvSysHideEmulatedCursor
NvSysHideEmulatedCursor PROC NEAR
        push    bp
        mov     bp, sp
        push    ds
        push    es
        push    esi
        push    edi
        push    edx
        push    ecx
        push    ebx
        mov     es, selScreen
        xor     esi, esi
        lds     si, lpSaveUnder
;
; Bound horizontal parameters to visible screen.
;
        mov     ax, xGlyphPos
        or      ax, ax
        jge     @f
        add     ax, cxGlyphWidth
        jl      HideCursorExit
        mov     cxGlyphWidth, ax
        xor     ax, ax
        mov     xGlyphPos, ax
@@:     mov     dx, cxScreenWidth
        cmp     ax, dx
        jge     HideCursorExit
        mov     cx, cxGlyphWidth
        or      cx, cx
        jz      HideCursorExit
        add     cx, ax
        cmp     cx, dx
        jl      @f
        sub     dx, ax
        mov     cxGlyphWidth, dx
@@: 
;
; Bound vertical parameters to visible screen.
;
        mov     ax, yGlyphPos
        or      ax, ax
        jge     @f
        add     ax, cyGlyphHeight
        jl      HideCursorExit
        mov     cyGlyphHeight, ax
        xor     ax, ax
        mov     yGlyphPos, ax
@@:     mov     dx, cyScreenHeight
        cmp     ax, dx
        jge     HideCursorExit
        mov     cx, cyGlyphHeight
        or      cx, cx
        jz      HideCursorExit
        add     cx, ax
        cmp     cx, dx
        jl      @f
        sub     dx, ax
        mov     cyGlyphHeight, dx
@@:
;
; Convert pixel depth into shift count.
;
        mov     cx, cScreenDepth
        shr     cx, 4
;
; Calc starting pixel position.
;
        xor     edi, edi
        xor     edx, edx
        mov     di, yGlyphPos
        mov     dx, cxScreenWidth
        imul    edi, edx
        xor     ebx, ebx
        mov     bx, xGlyphPos
        add     edi, ebx
        mov     bx, dx
        mov     dx, cxGlyphWidth
        add     edx, edi
        shl     edi, cl
        shl     edx, cl
        sub     edx, edi
        shl     ebx, cl
        mov     ax, di
        and     di, 0FFFCh
        and     ax, 03h
        add     ax, dx
        add     ax, 03h
        xor     edx, edx
        mov     dx, ax
        shr     ax, 2
        and     dl, 0FCh
        mov     cxGlyphWidth, ax
        sub     ebx, edx
        neg     edx
        add     edx, 128
;
; Loop through rows of pixel data.
;
        cld
        xor     ecx, ecx
RestoreRow:
        mov     cx, cxGlyphWidth
    rep movsd   es:[edi], [esi]
        add     edi, ebx
        add     esi, edx
        dec     WORD PTR cyGlyphHeight
        jnz     RestoreRow
;
; All done.
;        
HideCursorExit:        
        pop     ebx
        pop     ecx
        pop     edx
        pop     edi
        pop     esi
        pop     es
        pop     ds
        leave
        retf	20
NvSysHideEmulatedCursor ENDP

_TEXT           ENDS
;                END     LIBENTRY
                END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\dll16\NVSYS.C ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************* Operating System Interface Routines *******************\
*                                                                           *
* Module: NVSYS.C                                                           *
*   This is the Windows half of the Resource Manager.  System clients call  *
*   the Resource Manager through these APIS.  The VxD calls into this       *
*   to post a message to the Windows Resource Manager EXE.                  *
*                                                                           *
\***************************************************************************/

//
// Windows main include file
//
#include <windows.h>
//
// USER.275 function to redraw screen.
//
VOID FAR PASCAL RepaintScreen(VOID);
//
// Windows Resource Manager System includes.
//
#include "nv_ref.h"
#include "nvrm.h"
#include "nvrmwin.h"
#include "nvsys.h"
#include "nvcm.h"
#include "nvos.h"

#include <class.h>
#include <vblank.h>
#include <gr.h>
#include <vga.h>

#define DLL_PROCESS_ATTACH  1
#define DLL_PROCESS_DETACH  0

//
// Global cursor control defines
//
#define COLOR_OFFSET    32*sizeof(DWORD)    // offset of XOR mask from start of buffer (= size of and mask)
// white & black filtering
#define WHITE (0xffff)
#define BLACK (0x8000)
#define DRK_BLEND 10    // off-black
#define MED_DRK 14      // a little lighter, for black followed by white
#define LT_BLEND 3      // off-white
#define MED_LT 8        // a little darker, for white followed by black
// formatted filtered white & black
#define MED_WHITE (0x8000 | ((31-MED_LT) << 10) | ((31-MED_LT) << 5) | (31-MED_LT))
#define MED_BLACK (0x8000 | ((31-MED_DRK) << 10) | ((31-MED_DRK) << 5) | (31-MED_DRK))
#define LT_GRAY (0x8000 | ((31-LT_BLEND) << 10) | ((31-LT_BLEND) << 5) | (31-LT_BLEND))
#define DK_GRAY (0x8000 | (DRK_BLEND << 10) | (DRK_BLEND << 5) | DRK_BLEND)

#define IsNvCfgAgp(x) (x>=NV_CFG_AGP_FULLSPEED_FW&&x<=NV_CFG_AGP_LOAD_DUMMY_PAGES)
//---------------------------------------------------------------------------
//
//  Typedefs.
//
//---------------------------------------------------------------------------

typedef struct _def_hw_info      FAR * LPHWINFO;
typedef struct _def_client_info  FAR * LPCLIENTINFO;

//---------------------------------------------------------------------------
//
//  Prototypes.
//
//---------------------------------------------------------------------------

INT   FAR PASCAL LibMain(HINSTANCE, WORD, WORD, LPSTR);
INT   FAR PASCAL _WEP(BOOL);
BOOL  FAR PASCAL THK_ThunkConnect16(LPSTR, LPSTR, WORD, DWORD);
BOOL  FAR PASCAL DllEntryPoint(DWORD, WORD, WORD, WORD, DWORD, WORD);
VOID  FAR PASCAL NvSysIpcCallback(DWORD, DWORD, DWORD);
VOID  FAR PASCAL NvSysNotifyCallback(DWORD, DWORD, DWORD, DWORD, DWORD, DWORD);
typedef void (_far __cdecl *CAPTUREPROC)(DWORD);
VOID  FAR PASCAL __loadds NvCaptureFrameCallback(DWORD,DWORD);
DWORD FAR PASCAL NvSysDispatch(LPRMPARAMS, DWORD);
VOID  PASCAL CallRM(LPRMPARAMS);
void  CallRM_DeviceSetup(LPRMPARAMS);
BOOL  PASCAL ValidateScreenRect(RMPARAMS FAR *);
BOOL  PASCAL NvThunkNotifyEvent(DWORD, DWORD);
BOOL  PASCAL NvThunkNotifyMsg(DWORD, HWND, WORD);
BOOL  PASCAL NvThunkErrorMsg(DWORD, HWND, WORD);
BOOL  PASCAL NvThunkAllocPages(DWORD, LPDWORD, LPDWORD);
BOOL  PASCAL NvThunkFreePages(DWORD);

DWORD PASCAL REG_RD32(DWORD);
DWORD PASCAL REG_WR32(DWORD, DWORD);
BYTE  PASCAL REG_RD08(DWORD);
DWORD PASCAL REG_WR08(DWORD, DWORD);
VOID  PASCAL NvSysHideEmulatedCursor(WORD, WORD, WORD, WORD, WORD, WORD, WORD, WORD, LPDWORD);

DWORD PASCAL NvThunkNvArch(DWORD,DWORD,DWORD);

//---------------------------------------------------------------------------
//
//  Data.
//
//---------------------------------------------------------------------------
// Documentation says name should be blank-padded.

char    NVstring[9] = "NVCORE  ";

// Had trouble matching NVRM until I used 0-padded name. Windows bug if name is 4 chars?

//
// Enable flag.
//
BOOL Enabled = FALSE;
//
// Pointer to Resource Manager API routine.
//
DWORD ResManAPI;
//
// Pointers to shared Resource Manager structures.
//
LPCLIENTINFO  lpClientInfo;
U032 FAR * lp16bitProcessDS;
U032     dll16_ClientInstance=0;


LPHWINFO  dll16_NvInfoPtrTable[MAX_INSTANCE];
U032      FAR *lpNvInfoSelectors;

#undef NUM_FIFOS
#define NUM_FIFOS               dll16_NvInfoPtrTable[DeviceHandle-1]->Fifo.HalInfo.Count

//
// Because we are in 16 bit code, we can't just have a selector that describes the entire
// NV register space easily. So we have an array of selectors that point to each major portion
// of the register space. Also, to handle multimon, we need one such array of selectors for each
// NV device.
//
struct {
    WORD  devSelector[NV_DEV_MAX+1]; // Device Selector table.
} devSelectorTable[MAX_INSTANCE];

U008  VblankDummy = NULL;   // dummy vblank status 

//
// Instance of the Windows Resource Manager task.
//
HINSTANCE hInstNvSysEXE;
HANDLE    hTaskNvSysEXE;
//
// Instance of this DLL.
//
HINSTANCE hInstNvSysDLL;
//
// Bit reversal table for cursor glyph.
//
BYTE BitReversal[] =
{
    0x00, 0x80, 0x40, 0xC0, 0x20, 0xA0, 0x60, 0xE0,
    0x10, 0x90, 0x50, 0xD0, 0x30, 0xB0, 0x70, 0xF0,
    0x08, 0x88, 0x48, 0xC8, 0x28, 0xA8, 0x68, 0xE8,
    0x18, 0x98, 0x58, 0xD8, 0x38, 0xB8, 0x78, 0xF8,
    0x04, 0x84, 0x44, 0xC4, 0x24, 0xA4, 0x64, 0xE4,
    0x14, 0x94, 0x54, 0xD4, 0x34, 0xB4, 0x74, 0xF4,
    0x0C, 0x8C, 0x4C, 0xCC, 0x2C, 0xAC, 0x6C, 0xEC,
    0x1C, 0x9C, 0x5C, 0xDC, 0x3C, 0xBC, 0x7C, 0xFC,
    0x02, 0x82, 0x42, 0xC2, 0x22, 0xA2, 0x62, 0xE2,
    0x12, 0x92, 0x52, 0xD2, 0x32, 0xB2, 0x72, 0xF2,
    0x0A, 0x8A, 0x4A, 0xCA, 0x2A, 0xAA, 0x6A, 0xEA,
    0x1A, 0x9A, 0x5A, 0xDA, 0x3A, 0xBA, 0x7A, 0xFA,
    0x06, 0x86, 0x46, 0xC6, 0x26, 0xA6, 0x66, 0xE6,
    0x16, 0x96, 0x56, 0xD6, 0x36, 0xB6, 0x76, 0xF6,
    0x0E, 0x8E, 0x4E, 0xCE, 0x2E, 0xAE, 0x6E, 0xEE,
    0x1E, 0x9E, 0x5E, 0xDE, 0x3E, 0xBE, 0x7E, 0xFE,
    0x01, 0x81, 0x41, 0xC1, 0x21, 0xA1, 0x61, 0xE1,
    0x11, 0x91, 0x51, 0xD1, 0x31, 0xB1, 0x71, 0xF1,
    0x09, 0x89, 0x49, 0xC9, 0x29, 0xA9, 0x69, 0xE9,
    0x19, 0x99, 0x59, 0xD9, 0x39, 0xB9, 0x79, 0xF9,
    0x05, 0x85, 0x45, 0xC5, 0x25, 0xA5, 0x65, 0xE5,
    0x15, 0x95, 0x55, 0xD5, 0x35, 0xB5, 0x75, 0xF5,
    0x0D, 0x8D, 0x4D, 0xCD, 0x2D, 0xAD, 0x6D, 0xED,
    0x1D, 0x9D, 0x5D, 0xDD, 0x3D, 0xBD, 0x7D, 0xFD,
    0x03, 0x83, 0x43, 0xC3, 0x23, 0xA3, 0x63, 0xE3,
    0x13, 0x93, 0x53, 0xD3, 0x33, 0xB3, 0x73, 0xF3,
    0x0B, 0x8B, 0x4B, 0xCB, 0x2B, 0xAB, 0x6B, 0xEB,
    0x1B, 0x9B, 0x5B, 0xDB, 0x3B, 0xBB, 0x7B, 0xFB,
    0x07, 0x87, 0x47, 0xC7, 0x27, 0xA7, 0x67, 0xE7,
    0x17, 0x97, 0x57, 0xD7, 0x37, 0xB7, 0x77, 0xF7,
    0x0F, 0x8F, 0x4F, 0xCF, 0x2F, 0xAF, 0x6F, 0xEF,
    0x1F, 0x9F, 0x5F, 0xDF, 0x3F, 0xBF, 0x7F, 0xFF
};

//
// Translate  4 bpp into 555
//
U016 color4bpp[] =
{
    0,
    0x4000,
    0x200,
    0x4200,
    0x10,
    0x4010,
    0x210,
    0x6318,
    0x4210,
    0x7c00,
    0x3e0,
    0x7fe0,
    0x1f,
    0x7c1f,
    0x3ff,
    0x7fff
//    0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15
};


//---------------------------------------------------------------------------
//
//  In-line assembly routines.
//
//---------------------------------------------------------------------------

//
//  Get the call gate for calling into the resource manager
//  Now that the RM is a dynamic vxd, it has the undefined device ID and must be located by name
//
VOID GetCallGate(VOID)
{
    __asm {
    mov  bx, 0
    mov  ax, 01684h
    mov  di, ds
    mov  es, di
    lea  di, NVstring
    int  02Fh
    mov  WORD PTR ResManAPI, di
    mov  WORD PTR ResManAPI + 2, es
    }
}

VOID Breakpoint(VOID)
{
    __asm int    3
}

U016 GetSelector(U032 addrLin, U032 limit)
{
    U016    regAX,sel;

    __asm   {
	mov	ax,ds
	mov	regAX,ax
    }
    sel = AllocSelector(regAX);
    SetSelectorBase(sel,addrLin);
    SetSelectorLimit(sel,limit);
    return sel;
}

U032 FAR PASCAL NvSysDriverConnect(U032 osDevHandle, U032 osDeviceName)
{
  RMPARAMS rmParams;
  U032     rmDeviceHandle;

  rmParams.RegEAX = NVRM_API_DRIVER_CONNECT;
  rmParams.RegEBX = osDevHandle;
  rmParams.RegECX = osDeviceName;
  rmParams.RegES  = 0;
  rmParams.RegESI = DEFAULT_DEVICEHANDLE;
  CallRM_DeviceSetup(&rmParams);
  rmDeviceHandle = (U032) rmParams.RegEAX;
  if(rmDeviceHandle != 0)
  {
	  rmParams.RegEAX = NVRM_API_MULTIDEVICE_MAP_RM_INFO;
	  rmParams.RegES  = 0;
	  rmParams.RegESI = DEFAULT_DEVICEHANDLE;
	  CallRM_DeviceSetup(&rmParams);
	  lpNvInfoSelectors = (U032 FAR *) (rmParams.RegEAX << 16);
	  {
		int temp_count;
		for(temp_count=0;temp_count<MAX_INSTANCE;temp_count++)
		  dll16_NvInfoPtrTable[temp_count] = (LPHWINFO) (lpNvInfoSelectors[temp_count] << 16);
	  } 
  }
  
  return rmDeviceHandle;
}

VOID FAR PASCAL NvSysDriverDisConnect(U032 DeviceHandle)
{

  RMPARAMS rmParams;

  rmParams.RegEAX = NVRM_API_DRIVER_DISCONNECT;
  rmParams.RegEBX = DeviceHandle;               // is this parameter even used?
  rmParams.RegES  = 0;
  rmParams.RegESI = DeviceHandle-1;
  CallRM_DeviceSetup(&rmParams);
}

//---------------------------------------------------------------------------
//
//  System routines.
//
//---------------------------------------------------------------------------
//
// Win95 Dll entrypoint.
//
BOOL FAR PASCAL DllEntryPoint
(
    DWORD dwReason,
    WORD  hInstance,
    WORD  wDS,
    WORD  wHeapSize,
    DWORD dwReserved1,
    WORD  dwReserved2
)
{
    static INT AttachCount = 0;

    if (!(THK_ThunkConnect16("NV3SYS.DLL","NV3API.DLL",hInstance,dwReason)))
        return (FALSE);
    switch (dwReason)
    {
        case DLL_PROCESS_ATTACH:
            ++AttachCount;
            break;
        case DLL_PROCESS_DETACH:
            --AttachCount;
            break;
    }
    return (TRUE);
}
//
// DLL entrypoint.
//
INT FAR PASCAL LibMain
(
    HINSTANCE hInstance,
    WORD      wDataSeg,
    WORD      cbHeapSize,
    LPSTR     lpszCmdLine
)
{
    INT      i, j;
    RMPARAMS rmParams;
    
    if (Enabled)
        return (1);
    hInstNvSysDLL = hInstance;
    hInstNvSysEXE = 0;
    //
    // Get Resource Manager call gate.
    //
    GetCallGate();
    if (ResManAPI == 0)
    {
        return (FALSE);
    }
    //
    // Check version number.
    //
    
    rmParams.RegEAX = NVRM_API_GET_VERSION;
    rmParams.RegES  = 0;
    rmParams.RegESI = DEFAULT_DEVICEHANDLE;
    CallRM_DeviceSetup(&rmParams);
    if (rmParams.RegEAX != NVRM_VERSION)
    {
        return (FALSE);
    }
    //
    // Install Resource Manager callbacks.
    //
    rmParams.RegEAX = NVRM_API_NOTIFY_CALLBACK;
    rmParams.RegECX = ((DWORD)&NvSysNotifyCallback) & 0xFFFF;
    rmParams.RegEDX = ((DWORD)&NvSysNotifyCallback) >> 16;
    rmParams.RegES  = 0;
    rmParams.RegESI = DEFAULT_DEVICEHANDLE;
    CallRM_DeviceSetup(&rmParams);
    rmParams.RegEAX = NVRM_API_IPC_CALLBACK;
    rmParams.RegECX = ((DWORD)&NvSysIpcCallback) & 0xFFFF;
    rmParams.RegEDX = ((DWORD)&NvSysIpcCallback) >> 16;
    rmParams.RegESI = DEFAULT_DEVICEHANDLE;
    CallRM_DeviceSetup(&rmParams);

    //
    // Install mediaport callback mechanism (Canopus)
    //
	rmParams.RegEAX = NVRM_API_VPE_MISC; // main function
	rmParams.RegEBX = IMAGE_INSTALL_16CALLBACK; // subfunction
	rmParams.RegECX = ((DWORD)&NvCaptureFrameCallback) & 0xFFFF;
	rmParams.RegEDX = ((DWORD)&NvCaptureFrameCallback) >> 16;
	rmParams.RegES  = 0;
	rmParams.RegESI = DEFAULT_DEVICEHANDLE;
	CallRM_DeviceSetup(&rmParams);

    rmParams.RegEAX = NVRM_API_MULTIDEVICE_MAP_RM_INFO;
    rmParams.RegEBX = 0x69;
    rmParams.RegES  = 0;
    rmParams.RegESI = DEFAULT_DEVICEHANDLE;
    CallRM_DeviceSetup(&rmParams);
    lpNvInfoSelectors = (U032 FAR *) (rmParams.RegEAX   << 16);
    {
      int temp_count;
      for(temp_count=0;temp_count<MAX_INSTANCE;temp_count++)
        dll16_NvInfoPtrTable[temp_count] = (LPHWINFO) (lpNvInfoSelectors[temp_count] << 16);
    }    
    
    lpClientInfo  = (LPCLIENTINFO)(rmParams.RegECX << 16);
    lp16bitProcessDS = (U032 FAR *) (rmParams.RegEDI << 16);

    // clear the selector array.
    for(i = 0; i < MAX_INSTANCE; i++)
        for (j = 0; j < NV_DEV_MAX+1; j++)
            devSelectorTable[i].devSelector[j] = 0;

    Enabled = TRUE;
    return (1);
}
//
// DLL exitpoint.
//
INT FAR PASCAL _WEP
(
    BOOL bSysExit
)
{
    RMPARAMS rmParams;

    if (Enabled)
    {
        //
        // Tell Resource Manager not to call back to this DLL anymore.
        //
        rmParams.RegEAX = NVRM_API_UNLOAD_DLL;
        rmParams.RegES  = 0;
        rmParams.RegESI = DEFAULT_DEVICEHANDLE;
        CallRM_DeviceSetup(&rmParams);
    }
    return (1);
}

//
// Capturing Frame callback from mediaport
//
VOID FAR PASCAL __loadds NvCaptureFrameCallback(DWORD DeviceHandle, DWORD dwBufferOffset)
{
// Take care in MultiMonitor environments, the DeviceHandle passed here may NOT necessarily be
// used as an index to the dll_16NvInfoPtrTable !! Check this in the RM VXD
	if (dll16_NvInfoPtrTable[DeviceHandle-1]->MediaPort.ImageCallback)
		((CAPTUREPROC /*__far*/)(dll16_NvInfoPtrTable[DeviceHandle-1]->MediaPort.ImageCallback))( dwBufferOffset);
}


//
// VxD Resource Manager callback to Windows DLL.
//
VOID FAR PASCAL NvSysIpcCallback
(
    DWORD Msg,
    DWORD wParam,
    DWORD lParam
)
{
    ;
    /*
    if (hInstNvSysEXE)
        PostAppMessage(hTaskNvSysEXE,
                       (WORD)Msg,
                       (WORD)wParam,
                       lParam);
    */                       
}

VOID FAR PASCAL NvSysNotifyCallback
(
    DWORD ChID,
    DWORD Object,
    DWORD Offset,
    DWORD Data,
    DWORD Status,
    DWORD Action
)
{
}
//
// Nv thunk dispatcher for 32 bit applications.
//
DWORD FAR PASCAL NvSysDispatch
(
    LPRMPARAMS lpParams,
    DWORD      Function
)
{

//  lpParams->RegEDI holds the DeviceHandle from the 32bit DLL Caller.

    switch (Function)
    {
        //
        // Call Resource Manager.
        //
		case 0:
			lpParams->RegESI = lpParams->RegEDI-1;
            CallRM_DeviceSetup(lpParams);
            break;
        case NV_FUNCTION_NVALLOCPAGES:
            NvThunkAllocPages(GetSelectorBase((UINT)lpParams->RegDS),
                                             &(lpParams->RegEAX),
                                             &(lpParams->RegEDX));
            break;
        case NV_FUNCTION_NVFREEPAGES:
            NvThunkFreePages(lpParams->RegEAX);
            break;
        //
        // Map some routines that aren't available under Win32s.
        //
        case NV_FUNCTION_GETSELECTORBASE:
            lpParams->RegEAX = GetSelectorBase((UINT)lpParams->RegEAX);
            break;
        case NV_FUNCTION_GETCURRENTTASK:
            lpParams->RegEAX = GetCurrentTask();
            break;
        //
        // Configuration Manager APIs for 32 bit apps.
        //
        case NV_FUNCTION_NVCONFIGVERSION:
            lpParams->RegEAX = NvConfigVersion(lpParams->RegEDI);
            break;
        case NV_FUNCTION_NVCONFIGGET:
            lpParams->RegEAX = NvConfigGet(lpParams->RegEAX,lpParams->RegEDI);
            break;
        case NV_FUNCTION_NVCONFIGSET:
            lpParams->RegEAX = NvConfigSet(lpParams->RegEAX, lpParams->RegEBX,lpParams->RegEDI);
            break;
        case NV_FUNCTION_NVCONFIGUPDATE:
            lpParams->RegEAX = NvConfigUpdate(lpParams->RegEAX,lpParams->RegEDI);
            break;
        //
        // Pointer to certain hardware.
        //
        case NV_FUNCTION_NVSYSGETHWPTRS:
            NvSysGetHardwarePointers(&(lpParams->RegEAX),
                                     &(lpParams->RegEBX),
                                     &(lpParams->RegECX),
                                     &(lpParams->RegEDX),
                                     lpParams->RegEDI);
            break;
        case NV_FUNCTION_NVDEVICEBASEGET:
            lpParams->RegEAX = NvDeviceBaseGet(lpParams->RegEAX,lpParams->RegEDI);
            break;
        case NV_FUNCTION_NVDEVICELIMITGET:
            lpParams->RegEAX = NvDeviceLimitGet(lpParams->RegEAX,lpParams->RegEDI);
            break;
        case NVRM_API_ARCHITECTURE_32:
            // EAX-Function EBX-parameters DS-Client Data Selector
            lpParams->RegEAX = NvThunkNvArch(GetSelectorBase((UINT)lpParams->RegDS),lpParams->RegEAX,lpParams->RegEBX);
            break;
    }

    return (0);
}

//---------------------------------------------------------------------------
//
//  Nv display driver entrypoints.
//
//---------------------------------------------------------------------------

VOID FAR PASCAL NvSysMoveCursor
(
    INT    xPos,
    INT    yPos,
    U032   DeviceHandle
)
{

    xPos &= 0xfff;  // bits used on NV3
    yPos &= 0xfff;
    
    dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.CrtcInfo[0].CursorPosX   = xPos;
    dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.CrtcInfo[0].CursorPosY   = yPos;
    dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.CrtcInfo[0].UpdateFlags |= UPDATE_HWINFO_DAC_CURSOR_POS;

}

// This is the new interface to update the cursor image. 
// All we have to do is program the offset, width/height and colorformat.
// We don't have to worry about the converting glyphs etc.
// This is the way a cursor image is defined in NV{04 | 10}_VIDEO_LUT_CURSOR_DAC class.
// Because the cursor manipulation needs to happen independent of what other rendering
// that is going on, the class interface can not be used to update the cursor image and position.
//
// Flags.<0> : if 1, indicates that the rest of the cursor image parameters are valid and they should be
//           :       programmed into the hardware.
//           : if 0, the cursor image values are not valid.
// Flags.<1> : If 1, Flags.<2> indicates how the cursor's enable disable state should be changed.
//           : If 0, don't change the enable/disable state of the cursor.
// Flags.<2> : If 1, enable the cursor.
//           : If 0, disable the cursor.
VOID FAR PASCAL NvSysSetCursorImage
(
    U032  Flags,
    U032  Offset,
    U032  Width,
    U032  Height,
    U032  ColorFormat,
    U032  DeviceHandle
)
{
    // this is the new way of setting cursor image. The cursorType should not be used in this scheme.
    dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.CrtcInfo[0].CursorType = DAC_CURSOR_TYPE_NEW;

    if (Flags & 0x00000001)
    {
        // Offset is assumed to be an offset from the start of the Frame buffer.
        // Make sure The Address Space Indicator for the cursor says it is in the Frame buffer
        // (instead of Instance Memory).

        dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.CrtcInfo[0].CursorWidth  = Width;
        dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.CrtcInfo[0].CursorHeight = Height;
        dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.CrtcInfo[0].CursorOffset = Offset;
        dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.CrtcInfo[0].CursorColorFormat = ColorFormat;

        dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.CrtcInfo[0].UpdateFlags |= UPDATE_HWINFO_DAC_CURSOR_IMAGE_NEW;
    } // program the cursor image values.

    if (Flags & 0x00000002)
    {
        if (Flags & 0x00000004)
        {
            // Enable the cursor.
            dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.CrtcInfo[0].UpdateFlags |= UPDATE_HWINFO_DAC_CURSOR_ENABLE;

            // Make sure there is no pending request to disable the cursor.
            dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.CrtcInfo[0].UpdateFlags &= ~UPDATE_HWINFO_DAC_CURSOR_DISABLE;
        }
        else
        {
            // disable the cursor.
            dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.CrtcInfo[0].UpdateFlags |= UPDATE_HWINFO_DAC_CURSOR_DISABLE;

            // Make sure there is no pending request to enable the cursor.
            dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.CrtcInfo[0].UpdateFlags &= ~UPDATE_HWINFO_DAC_CURSOR_ENABLE;
        }
    } // enable or disable the cursor.
}


VOID FAR PASCAL NvSysMoveCursorMulti
(
    INT    xPos,
    INT    yPos,
    U032   DeviceHandle,
    U032   Head
)
{

    xPos &= 0xfff;  // bits used on NV3
    yPos &= 0xfff;
    
    dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.CrtcInfo[Head].CursorPosX   = xPos;
    dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.CrtcInfo[Head].CursorPosY   = yPos;
    dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.CrtcInfo[Head].UpdateFlags |= UPDATE_HWINFO_DAC_CURSOR_POS;

}

// This is the new interface to update the cursor image. 
// All we have to do is program the offset, width/height and colorformat.
// We don't have to worry about the converting glyphs etc.
// This is the way a cursor image is defined in NV{04 | 10}_VIDEO_LUT_CURSOR_DAC class.
// Because the cursor manipulation needs to happen independent of what other rendering
// that is going on, the class interface can not be used to update the cursor image and position.
//
// Flags.<0> : if 1, indicates that the rest of the cursor image parameters are valid and they should be
//           :       programmed into the hardware.
//           : if 0, the cursor image values are not valid.
// Flags.<1> : If 1, Flags.<2> indicates how the cursor's enable disable state should be changed.
//           : If 0, don't change the enable/disable state of the cursor.
// Flags.<2> : If 1, enable the cursor.
//           : If 0, disable the cursor.
VOID FAR PASCAL NvSysSetCursorImageMulti
(
    U032  Flags,
    U032  Offset,
    U032  Width,
    U032  Height,
    U032  ColorFormat,
    U032  DeviceHandle,
    U032  Head
)
{
    // this is the new way of setting cursor image. The cursorType should not be used in this scheme.
    dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.CrtcInfo[Head].CursorType = DAC_CURSOR_TYPE_NEW;

    if (Flags & 0x00000001)
    {
        // Offset is assumed to be an offset from the start of the Frame buffer.
        // Make sure The Address Space Indicator for the cursor says it is in the Frame buffer
        // (instead of Instance Memory).

        dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.CrtcInfo[Head].CursorWidth  = Width;
        dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.CrtcInfo[Head].CursorHeight = Height;
        dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.CrtcInfo[Head].CursorOffset = Offset;
        dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.CrtcInfo[Head].CursorColorFormat = ColorFormat;

        dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.CrtcInfo[Head].UpdateFlags |= UPDATE_HWINFO_DAC_CURSOR_IMAGE_NEW;
    } // program the cursor image values.

    if (Flags & 0x00000002)
    {
        if (Flags & 0x00000004)
        {
            // Enable the cursor.
            dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.CrtcInfo[Head].UpdateFlags |= UPDATE_HWINFO_DAC_CURSOR_ENABLE;

            // Make sure there is no pending request to disable the cursor.
            dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.CrtcInfo[Head].UpdateFlags &= ~UPDATE_HWINFO_DAC_CURSOR_DISABLE;
        }
        else
        {
            // disable the cursor.
            dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.CrtcInfo[Head].UpdateFlags |= UPDATE_HWINFO_DAC_CURSOR_DISABLE;

            // Make sure there is no pending request to enable the cursor.
            dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.CrtcInfo[Head].UpdateFlags &= ~UPDATE_HWINFO_DAC_CURSOR_ENABLE;
        }
    } // enable or disable the cursor.
}


VOID FAR PASCAL NvSysUpdateImageOffsetFormat
(
    U032   offset,
    U032   format,
    U032   chID,
    U032   objectHandle,
    U032   DeviceHandle,
    U032   Head
)
{
    //
    // Note: we don't need the object handle, since the current mode setting
    // pVidLutCurDac object is stashed away in the Dac.CrtcInfo struct already.
    //
    dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.CrtcInfo[Head].ImageOffset   = offset;
    dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.CrtcInfo[Head].ImageFormat   = format;
    dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.CrtcInfo[Head].ChID          = chID;
    dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.CrtcInfo[Head].ObjectHandle  = objectHandle;
    dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.CrtcInfo[Head].UpdateFlags |= UPDATE_HWINFO_DAC_IMAGE_OFFSET_FORMAT;
}


BOOL FAR PASCAL NvSysSetCursor
(
    LPBYTE lpGlyph,
    INT    Width,
    INT    Height,
    U032   DeviceHandle
)
{
    INT i;
    
    //
    // Save width and height.
    //
    dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.CrtcInfo[0].CursorWidth  = Width;
    dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.CrtcInfo[0].CursorHeight = Height;
    if (dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.CrtcInfo[0].CursorWidth > 32)
        dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.CrtcInfo[0].CursorWidth = 32;
    if (dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.CrtcInfo[0].CursorHeight > 32)
        dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.CrtcInfo[0].CursorHeight = 32;
    //
    // Make glyph transparent.
    //
    for (i = 0; i < 32 * sizeof(DWORD); i++)
    {
        dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.CrtcInfo[0].CursorImagePlane[1][i] = 0xFF;
        dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.CrtcInfo[0].CursorImagePlane[0][i] = 0x00;
    }
    if (lpGlyph && (Height > 0))
    {
        for (i = 0; i < (INT)(Height * sizeof(DWORD)); i++)
        {
            dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.CrtcInfo[0].CursorImagePlane[1][i] = BitReversal[lpGlyph[i]];
            dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.CrtcInfo[0].CursorImagePlane[0][i] = BitReversal[lpGlyph[i + Height * sizeof(DWORD)]];
        }
    }
    dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.CrtcInfo[0].CursorType = DAC_CURSOR_TWO_COLOR_XOR;
    dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.CrtcInfo[0].UpdateFlags |= UPDATE_HWINFO_DAC_CURSOR_IMAGE | UPDATE_HWINFO_DAC_CURSOR_POS;
    //
    // False means this isn't emulated.
    //
    
    return (FALSE);
}

DWORD FAR PASCAL NvSysGetScreenInfo
(
    U032    DeviceHandle
)
{
    DWORD returnvalue;

    returnvalue =
        (dll16_NvInfoPtrTable[DeviceHandle-1]->Framebuffer.HalInfo.VertDisplayWidth << 16) |
        dll16_NvInfoPtrTable[DeviceHandle-1]->Framebuffer.HalInfo.HorizDisplayWidth;

    return (returnvalue);
}
DWORD FAR PASCAL NvSysGetRamInfo
(
    U032    DeviceHandle
)
{
    DWORD returnvalue;

    returnvalue = (dll16_NvInfoPtrTable[DeviceHandle-1]->Framebuffer.HalInfo.RamSizeMb << 16) | dll16_NvInfoPtrTable[DeviceHandle-1]->Framebuffer.HalInfo.RamType;

    return (returnvalue);
}
DWORD FAR PASCAL NvSysGetBufferInfo
(
    U032    DeviceHandle
)
{
    DWORD returnvalue;

    returnvalue = (dll16_NvInfoPtrTable[DeviceHandle-1]->Framebuffer.Count << 16) | dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.HalInfo.Depth;

    returnvalue = 0xdeadbeef;

    return (returnvalue);
}
VOID FAR PASCAL NvSysClearScreen
(
    U032    DeviceHandle
)
{
    RMPARAMS rmParams;

    //
    // Clear visible screen.
    //
    rmParams.RegEAX = NVRM_API_CLEAR_SCREEN;
    rmParams.RegES  = 0;
    rmParams.RegESI = DeviceHandle-1;
    CallRM_DeviceSetup(&rmParams);

}
VOID FAR PASCAL NvSysDisplayModeHook
(
    DWORD   HookProc,
    U032    DeviceHandle
)
{
    RMPARAMS rmParams;

    //
    // Hook display mode changes.
    //
    rmParams.RegEAX = NVRM_API_MODE_HOOK;
    rmParams.RegEBX = HookProc;
    rmParams.RegES  = 0;
    rmParams.RegESI = DeviceHandle-1;
    CallRM_DeviceSetup(&rmParams);

}
VOID FAR PASCAL NvSysGetHardwarePointers
(
    DWORD FAR *pNv1,
    DWORD FAR *pAlternate,
    DWORD FAR *pFramebuffer,
    DWORD FAR *pTimer,
    U032      DeviceHandle
)
{
    RMPARAMS rmParams;

    //
    // Get all the hardware pointers.
    //
    rmParams.RegEAX = NVRM_API_GET_NV_ADDRESS;
    rmParams.RegES  = 0;
    rmParams.RegESI = DeviceHandle-1;
    CallRM_DeviceSetup(&rmParams);
    if (pNv1)         *pNv1         = rmParams.RegEAX;
    if (pAlternate)   *pAlternate   = rmParams.RegEAX + 0x00618000;
    if (pTimer)       *pTimer       = rmParams.RegEAX + 0x00101400;
    rmParams.RegEAX = NVRM_API_GET_FB_ADDRESS;
    rmParams.RegES  = 0;
    rmParams.RegESI = DeviceHandle-1;
    CallRM_DeviceSetup(&rmParams);
    if (pFramebuffer) *pFramebuffer = rmParams.RegEAX;

}
VOID FAR PASCAL NvSysGetCursorEmulatePosPointers
(
    DWORD FAR *pX,
    DWORD FAR *pY,
    U032      DeviceHandle
)
{
#ifdef SW_CURSOR
    //
    // Return pointers to current emulated cursor position.
    //    
    if (pX) *pX = (DWORD)&dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.CursorSaveUnderPosX;
    if (pY) *pY = (DWORD)&dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.CursorSaveUnderPosY;
#else
    if (pX) *pX = (DWORD)&dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.CrtcInfo[0].CursorPosX;
    if (pY) *pY = (DWORD)&dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.CrtcInfo[0].CursorPosY;
#endif // SW_CURSOR
    
}
DWORD FAR PASCAL NvSysGetCurrentBufferFlatPointer
(
    U032      DeviceHandle
)
{
    DWORD returnvalue;

    //
    // Return pointer to current buffer value.  This is the physical front buffer, only use
    // for direct frambeffer access.
    //
    returnvalue = (DWORD)GetSelectorBase((UINT)(((DWORD)dll16_NvInfoPtrTable[DeviceHandle-1] >> 16) + (DWORD)&(dll16_NvInfoPtrTable[DeviceHandle-1]->Framebuffer.Current) - (DWORD)dll16_NvInfoPtrTable[DeviceHandle-1]));

    return(returnvalue);
}
                               
//---------------------------------------------------------------------------
//
//  Nv system client entrypoints.
//
//---------------------------------------------------------------------------

BOOL FAR PASCAL NvSysAllocPages
(
    LPVOID FAR *Addr,
    LPDWORD     Handle,
    DWORD       Size,
    U032        DeviceHandle
)
{
    RMPARAMS   rmParams;

    rmParams.RegEAX = NVRM_API_ALLOC_PAGES;
    rmParams.RegECX = Size;
    rmParams.RegES  = 0;
    rmParams.RegESI = DeviceHandle-1;
    CallRM_DeviceSetup(&rmParams);
    *Addr   = (LPVOID)(rmParams.RegEDX);
    *Handle = rmParams.RegEAX;

    return (rmParams.RegEAX ? FALSE : TRUE);
}
BOOL FAR PASCAL NvSysFreePages
(
    DWORD       Handle,
    U032        DeviceHandle
)
{
    RMPARAMS   rmParams;

    rmParams.RegEAX = NVRM_API_FREE_PAGES;
    rmParams.RegECX = Handle;
    rmParams.RegES  = 0;
    rmParams.RegESI = DeviceHandle-1;
    CallRM_DeviceSetup(&rmParams);

    return (rmParams.RegEAX ? FALSE : TRUE);
}
BOOL FAR PASCAL NvSysLockPages
(
    WORD        Selector,
    DWORD       Offset,
    DWORD       Size,
    U032        DeviceHandle
)
{
    RMPARAMS   rmParams;

    rmParams.RegEAX = NVRM_API_LOCK_PAGES;
    rmParams.RegEBX = Selector;
    rmParams.RegECX = Offset;
    rmParams.RegEDX = Size;
    rmParams.RegES  = 0;
    rmParams.RegESI = DeviceHandle-1;
    CallRM_DeviceSetup(&rmParams);

    return (rmParams.RegEAX);
}
BOOL FAR PASCAL NvSysUnlockPages
(
    WORD        Selector,
    DWORD       Offset,
    DWORD       Size,
    U032        DeviceHandle
)
{
    RMPARAMS   rmParams;

    rmParams.RegEAX = NVRM_API_UNLOCK_PAGES;
    rmParams.RegEBX = Selector;
    rmParams.RegECX = Offset;
    rmParams.RegEDX = Size;
    rmParams.RegES  = 0;
    rmParams.RegESI = DeviceHandle-1;
    CallRM_DeviceSetup(&rmParams);

    return (rmParams.RegEAX);
}
//---------------------------------------------------------------------------
//
//  Thunked entrypoints from Win32 API DLL.
//
//---------------------------------------------------------------------------
BOOL PASCAL NvThunkAllocPages
(
    DWORD   FlatBase,
    LPDWORD AddrSize,
    LPDWORD Handle
)
{
    RMPARAMS   rmParams;

    rmParams.RegEAX = NVRM_API_ALLOC_PAGES;
    rmParams.RegECX = *AddrSize;
    rmParams.RegES  = 0;
    rmParams.RegESI = DEFAULT_DEVICEHANDLE;
    CallRM_DeviceSetup(&rmParams);
    *AddrSize = rmParams.RegEDX - FlatBase;
    *Handle   = rmParams.RegEAX;
    return (rmParams.RegEAX ? FALSE : TRUE);
}
BOOL PASCAL NvThunkFreePages
(
    DWORD Handle
)
{
    RMPARAMS   rmParams;

    rmParams.RegEAX = NVRM_API_FREE_PAGES;
    rmParams.RegECX = Handle;
    rmParams.RegES  = 0;
    rmParams.RegESI = DEFAULT_DEVICEHANDLE;
    CallRM_DeviceSetup(&rmParams);
    return (rmParams.RegEAX ? FALSE : TRUE);
}

DWORD PASCAL NvThunkNvArch
(
    DWORD pParameters_base,
    DWORD pParameters,
    DWORD Function
)
{
  DWORD    pParameters_flat_offset;
  RMPARAMS rmParams;

  pParameters_flat_offset = (DWORD) ((DWORD) pParameters_base + (DWORD) pParameters);

  rmParams.RegEAX = NVRM_API_ARCHITECTURE_32;
  rmParams.RegES  = 0;
  rmParams.RegEBX = Function;
  rmParams.RegECX = pParameters_flat_offset;
  rmParams.RegESI = DEFAULT_DEVICEHANDLE;
  CallRM_DeviceSetup(&rmParams);
  return (rmParams.RegEAX);
}

//---------------------------------------------------------------------------
//
//  Internal routines.
//
//---------------------------------------------------------------------------

// return raster position on nv4/nv10
DWORD PASCAL NvGetRasterPosition
(
    U032        DeviceHandle
)
{
    DWORD        pPCRTC_RASTER;

    pPCRTC_RASTER = ((DWORD)NvDeviceSelectorGet(NV_DEV_PCRTC, DeviceHandle) << 16)
                        | ((DWORD)NV_PCRTC_RASTER - (DWORD)NV_PCRTC_INTR_0);
    return (REG_RD32(pPCRTC_RASTER) & 0x7FF);
}

//---------------------------------------------------------------------------
//
// Configuration API.
//
//---------------------------------------------------------------------------

DWORD FAR PASCAL NvConfigVersion
(
    U032        DeviceHandle
)
{
    RMPARAMS   rmParams;
    CHAR       Title[256];
    CHAR       Message[512];

    rmParams.RegEAX = NVRM_API_GET_VERSION;
    rmParams.RegES  = 0;
    rmParams.RegESI = DeviceHandle-1;
    CallRM_DeviceSetup(&rmParams);
    if (rmParams.RegEAX != NVRM_VERSION)
    {
        LoadString(hInstNvSysDLL, NVSYS_STR_RM_ERROR, Title, 256);
        LoadString(hInstNvSysDLL, NVSYS_STR_VERSION_ERROR, Message, 512);
        MessageBox(0, Message, Title, MB_OK);
    }

    return (rmParams.RegEAX);
}
DWORD FAR PASCAL NvConfigGet
(
    DWORD       Index,
    U032        DeviceHandle
)
{
    RMINFO FAR *pRmInfo;
    U016	RmInfoSel = 0;
    U032	pv;

    DWORD        Value;
    U008         lock;
    DWORD        pPRMCIO_INDEX;
    DWORD        pPRMCIO_DATA;
    RMPARAMS     rmParams;

    Value = 0;

    // 
    // Special case the CRTC access since we're using the lower byte of
    // the index to denote the register we want to view
    //
    if ((Index & 0xF00) == NV_CFG_CRTC)
    {
        //
        // Build all the selectors we need: 3C4, 3C5, 3D4, 3D5
        //
        pPRMCIO_INDEX = ((DWORD)NvDeviceSelectorGet(NV_DEV_PRMCIO,DeviceHandle) << 16)
                         | ((DWORD)NV_PRMCIO_CRX__COLOR - (DWORD)DEVICE_BASE(NV_PRMCIO));
        pPRMCIO_DATA  = ((DWORD)NvDeviceSelectorGet(NV_DEV_PRMCIO,DeviceHandle) << 16)
                         | ((DWORD)NV_PRMCIO_CR__COLOR - (DWORD)DEVICE_BASE(NV_PRMCIO));

        //
        // Make sure the extended CRTC registers are enabled
        //
        REG_WR08(pPRMCIO_INDEX, NV_CIO_SR_LOCK_INDEX);      // 3D4
        lock = REG_RD08(pPRMCIO_DATA);                      // 3D5
        REG_WR08(pPRMCIO_INDEX, NV_CIO_SR_LOCK_INDEX);      // 3D4
        REG_WR08(pPRMCIO_DATA, NV_CIO_SR_UNLOCK_RW_VALUE);  // 3D5

        //
        // Get the register value.
        //
        REG_WR08(pPRMCIO_INDEX, Index & 0xFF);              // 3D4
        Value = REG_RD08(pPRMCIO_DATA);                     // 3D5
        
        //
        // Restore the lock
        //
        if (lock == 0)
        {        
            REG_WR08(pPRMCIO_INDEX, NV_CIO_SR_LOCK_INDEX);      // 3D4
            REG_WR08(pPRMCIO_DATA, NV_CIO_SR_LOCK_VALUE);       // 3D5
        }

        return (Value);
    }

    if(IsNvCfgAgp(Index))
    {
	pv = (U032)(dll16_NvInfoPtrTable[DeviceHandle-1]->pRmInfo);
	RmInfoSel = GetSelector(pv,sizeof(RMINFO));
	pRmInfo = (RMINFO FAR*)(((U032)RmInfoSel) << 16); 
    }
    
    switch (Index)
    {
        //
        // These values actually look at hardware, not NvInfo.
        //
        case NV_CFG_VBLANK_STATUS:

        // do the scanline method

            //
            // Build all the selectors we need: 3C4, 3C5, 3D4, 3D5
            //
            pPRMCIO_INDEX = ((DWORD)NvDeviceSelectorGet(NV_DEV_PRMCIO,DeviceHandle) << 16)
                      | ((DWORD)NV_PRMCIO_CRX__COLOR - (DWORD)DEVICE_BASE(NV_PRMCIO));
            pPRMCIO_DATA  = ((DWORD)NvDeviceSelectorGet(NV_DEV_PRMCIO,DeviceHandle) << 16)
                      | ((DWORD)NV_PRMCIO_CR__COLOR - (DWORD)DEVICE_BASE(NV_PRMCIO));
            //
            // Make sure the extended CRTC registers are enabled
            //
            REG_WR08(pPRMCIO_INDEX, NV_CIO_SR_LOCK_INDEX);      // 3D4
            lock = REG_RD08(pPRMCIO_DATA);                      // 3D5
            REG_WR08(pPRMCIO_INDEX, NV_CIO_SR_LOCK_INDEX);      // 3D4
            REG_WR08(pPRMCIO_DATA, NV_CIO_SR_UNLOCK_RW_VALUE);  // 3D5

            // Check whether in power saving mode. Return dummy status if so, or else direct draw will hang
            // waiting for vlank to change.
            REG_WR08(pPRMCIO_INDEX, NV_CIO_CRE_RPC1_INDEX);   // 3D4 = scanline hi byte
            Value = 0xC0 & REG_RD08(pPRMCIO_DATA);            // 3D5 bits 7&6 are hsync & vsync inactive
            if (Value)                                        // in power saving mode if either is set
                Value = (VblankDummy ^= 1);                   // just toggle, so we are sure to get both states
            else
            {
                Value = NvGetRasterPosition(DeviceHandle);
                if (Value == 0) // make sure we don't have false count. NV3 seems to have glitch during display period.
                {
                    Value = NvGetRasterPosition(DeviceHandle);
                }
                if (Value == 0)
                    Value = 1;
                else
                    Value = 0;            
            } // if in power saving mode            
            //
            // Restore the lock
            //
            if (lock == 0)
            {        
                REG_WR08(pPRMCIO_INDEX, NV_CIO_SR_LOCK_INDEX);      // 3D4
                REG_WR08(pPRMCIO_DATA, NV_CIO_SR_LOCK_VALUE);       // 3D5
            }
            break;
        case NV_CFG_GE_STATUS:
            {
                DWORD pGEStatus;
                pGEStatus = ((DWORD)NvDeviceSelectorGet(NV_DEV_PGRAPH,DeviceHandle) << 16)
                          | ((DWORD)NV_PGRAPH_STATUS - (DWORD)DEVICE_BASE(NV_PGRAPH));
                Value = REG_RD32(pGEStatus);
            }
            break;
        case NV_CFG_CURRENT_SCANLINE:
            //
            // Build all the selectors we need: 3C4, 3C5, 3D4, 3D5
            //
            pPRMCIO_INDEX = ((DWORD)NvDeviceSelectorGet(NV_DEV_PRMCIO,DeviceHandle) << 16)
                      | ((DWORD)NV_PRMCIO_CRX__COLOR - (DWORD)DEVICE_BASE(NV_PRMCIO));
            pPRMCIO_DATA  = ((DWORD)NvDeviceSelectorGet(NV_DEV_PRMCIO,DeviceHandle) << 16)
                      | ((DWORD)NV_PRMCIO_CR__COLOR - (DWORD)DEVICE_BASE(NV_PRMCIO));
            //
            // Make sure the extended CRTC registers are enabled
            //
            REG_WR08(pPRMCIO_INDEX, NV_CIO_SR_LOCK_INDEX);      // 3D4
            lock = REG_RD08(pPRMCIO_DATA);                      // 3D5
            REG_WR08(pPRMCIO_INDEX, NV_CIO_SR_LOCK_INDEX);      // 3D4
            REG_WR08(pPRMCIO_DATA, NV_CIO_SR_UNLOCK_RW_VALUE);  // 3D5

            //
            // Get the scanline value.
            //
            Value = NvGetRasterPosition(DeviceHandle);
            if (Value == 0) // make sure we don't have false 0 count
            {
                Value = NvGetRasterPosition(DeviceHandle);
            }
            
            //
            // Restore the lock
            //
            if (lock == 0)
            {        
                REG_WR08(pPRMCIO_INDEX, NV_CIO_SR_LOCK_INDEX);      // 3D4
                REG_WR08(pPRMCIO_DATA, NV_CIO_SR_LOCK_VALUE);       // 3D5
            }
            break;
        //
        // Fields in NvInfo.
        //
        case NV_CFG_MANUFACTURER:
            Value = dll16_NvInfoPtrTable[DeviceHandle-1]->Chip.HalInfo.Manufacturer;
            break;
        case NV_CFG_ARCHITECTURE:
            Value = dll16_NvInfoPtrTable[DeviceHandle-1]->Chip.HalInfo.Architecture;
            break;
        case NV_CFG_REVISION:
            Value = dll16_NvInfoPtrTable[DeviceHandle-1]->Chip.HalInfo.MaskRevision;
            break;
        case NV_CFG_BIOS_REVISION:
            Value = dll16_NvInfoPtrTable[DeviceHandle-1]->Chip.BiosRevision;
            break;
        case NV_CFG_BUS_TYPE:
            Value = dll16_NvInfoPtrTable[DeviceHandle-1]->Chip.Bus;
            break;
        case NV_CFG_CRYSTAL_FREQ:
            Value = dll16_NvInfoPtrTable[DeviceHandle-1]->Chip.HalInfo.CrystalFreq;
            break;
        case NV_CFG_ADDRESS:
            Value = dll16_NvInfoPtrTable[DeviceHandle-1]->Mapping.PhysAddr;
            break;
        case NV_CFG_IRQ:
            Value = dll16_NvInfoPtrTable[DeviceHandle-1]->Mapping.IntLine;
            break;
        case NV_CFG_IO_NEEDED:
            Value = dll16_NvInfoPtrTable[DeviceHandle-1]->Mapping.doIOToFlushCache;
            break;
        case NV_CFG_PCI_ID:
            Value = dll16_NvInfoPtrTable[DeviceHandle-1]->Chip.HalInfo.PCIDeviceID;
            break;
        case NV_CFG_PCI_SUB_ID:
            Value = dll16_NvInfoPtrTable[DeviceHandle-1]->Chip.HalInfo.PCISubDeviceID;
            break;
        case NV_CFG_GRAPHICS_CAPS:
            Value = dll16_NvInfoPtrTable[DeviceHandle-1]->Graphics.Capabilities;
            break;
        case NV_CFG_INSTANCE_TOTAL:
            Value = dll16_NvInfoPtrTable[DeviceHandle-1]->Pram.HalInfo.TotalInstSize;
            break;
        case NV_CFG_INSTANCE_SIZE:
            Value = dll16_NvInfoPtrTable[DeviceHandle-1]->Pram.FreeInstSize;
            break;
        case NV_CFG_FIFO_COUNT:
            Value = dll16_NvInfoPtrTable[DeviceHandle-1]->Fifo.HalInfo.Count;
            break;
        case NV_CFG_FIFO_USE_COUNT:
            Value = dll16_NvInfoPtrTable[DeviceHandle-1]->Fifo.HalInfo.AllocateCount;
            break;
        case NV_CFG_RAM_SIZE_MB:
            Value = dll16_NvInfoPtrTable[DeviceHandle-1]->Framebuffer.HalInfo.RamSizeMb;
            break;
        case NV_CFG_RAM_SIZE:
            Value = dll16_NvInfoPtrTable[DeviceHandle-1]->Framebuffer.HalInfo.RamSize;
            break;
        case NV_CFG_RAM_TYPE:
            Value = dll16_NvInfoPtrTable[DeviceHandle-1]->Framebuffer.HalInfo.RamType;
            break;
        case NV_CFG_AGP_PHYS_BASE:
			Value = pRmInfo->AGP.AGPPhysStart;
            break;
        case NV_CFG_AGP_LINEAR_BASE:
			Value = pRmInfo->AGP.AGPLinearStart;
            break;
        case NV_CFG_AGP_LIMIT:
			Value = pRmInfo->AGP.AGPLimit;
            break;
        case NV_CFG_AGP_HEAP_FREE:
            Value = pRmInfo->AGP.AGPHeapFree;
            break;
        case NV_CFG_AGP_FW_ENABLE:
            Value = pRmInfo->AGP.AGPFWEnable;
            break;
        case NV_CFG_AGP_FULLSPEED_FW:
            Value = pRmInfo->AGP.AGPFullSpeedFW;
            break;
        case NV_CFG_SCREEN_WIDTH:
            Value = dll16_NvInfoPtrTable[DeviceHandle-1]->Framebuffer.HalInfo.HorizDisplayWidth;
            break;
        case NV_CFG_SCREEN_HEIGHT:
            Value = dll16_NvInfoPtrTable[DeviceHandle-1]->Framebuffer.HalInfo.VertDisplayWidth;
            break;
        case NV_CFG_PIXEL_DEPTH:
            Value = dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.HalInfo.Depth;
            break;
        case NV_CFG_PRIMARY_SURFACE_PITCH:
            Value = dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.DisplayPitch;
            break;
        case NV_CFG_SCREEN_MAX_WIDTH:
            {
                // This value depends on the display type.
                // We really should read the EDID of the display device to get the max.
                // For now hard code the values.
                switch (GETMONITORTYPE(dll16_NvInfoPtrTable[DeviceHandle-1], 0))
                {
                    case MONITOR_TYPE_VGA:
                        Value = 2048;
                        break;
                    case MONITOR_TYPE_NTSC:
                        Value = 640;
                        break;
                    case MONITOR_TYPE_PAL:
                        Value = 800;
                        break;
                    case MONITOR_TYPE_FLAT_PANEL:
                        Value = dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.HalInfo.fpHMax;
                        break;
                    default:
                        Value = 0;
                        break;
                } // switch on MonitorType
            }
            break;
        case NV_CFG_SCREEN_MAX_HEIGHT:
            {
                // This value depends on the display type.
                // We really should read the EDID of the display device to get the max.
                // For now hard code the values.
                switch (GETMONITORTYPE(dll16_NvInfoPtrTable[DeviceHandle-1], 0))
                {
                    case MONITOR_TYPE_VGA:
                        Value = 1536;
                        break;
                    case MONITOR_TYPE_NTSC:
                        Value = 480;
                        break;
                    case MONITOR_TYPE_PAL:
                        Value = 600;
                        break;
                    case MONITOR_TYPE_FLAT_PANEL:
                        Value = dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.HalInfo.fpVMax;
                        break;
                    default:
                        Value = 0;
                        break;
                } // switch on MonitorType
            }
            break;
        case NV_CFG_VIDEO_ENCODER_TYPE:
            Value = dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.EncoderType;
            break;
        case NV_CFG_VIDEO_ENCODER_ID:
            Value = dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.EncoderID;
            break;
		case NV_CFG_BIOS_DEFAULT_TV_TYPE:
			// Build selectors to access CRTC
	        pPRMCIO_INDEX = ((DWORD)NvDeviceSelectorGet(NV_DEV_PRMCIO,DeviceHandle) << 16)
                         | ((DWORD)NV_PRMCIO_CRX__COLOR - (DWORD)DEVICE_BASE(NV_PRMCIO));
    	    pPRMCIO_DATA  = ((DWORD)NvDeviceSelectorGet(NV_DEV_PRMCIO,DeviceHandle) << 16)
                         | ((DWORD)NV_PRMCIO_CR__COLOR - (DWORD)DEVICE_BASE(NV_PRMCIO));
			// Unlock ext CRTC
            REG_WR08(pPRMCIO_INDEX, NV_CIO_SR_LOCK_INDEX);      // 3D4 <-1f
            lock = REG_RD08(pPRMCIO_DATA);                      // 3D5
            REG_WR08(pPRMCIO_DATA, NV_CIO_SR_UNLOCK_RW_VALUE);  // 3D5 <-57

            REG_WR08(pPRMCIO_INDEX, NV_CIO_CRE_SCRATCH0__INDEX);// 3D4 <-2B
            Value = REG_RD08(pPRMCIO_DATA) & 0x7;               // 3D5 get BIOS values (defined in nvcm.h)
            REG_WR08(pPRMCIO_INDEX, NV_CIO_SR_LOCK_INDEX);      // 3D4 <-1f
            REG_WR08(pPRMCIO_DATA, lock);  						// 3D5 <-former value
			break;
        case NV_CFG_VIDEO_DISPLAY_TYPE:
            rmParams.RegEAX = NVRM_API_DISPLAY;
            rmParams.RegEBX = NVRM_API_DISPLAY_GET_DISPLAY_TYPE;
            rmParams.RegES  = 0;
            rmParams.RegESI = DeviceHandle-1;
            CallRM_DeviceSetup(&rmParams);
            Value = rmParams.RegEAX;
            break;
        case NV_CFG_VIDEO_MONITOR_TYPE:
            rmParams.RegEAX = NVRM_API_DISPLAY;
            rmParams.RegEBX = NVRM_API_DISPLAY_GET_MONITOR_TYPE;
            rmParams.RegES  = 0;
            rmParams.RegESI = DeviceHandle-1;
            CallRM_DeviceSetup(&rmParams);
            Value = rmParams.RegEAX;
//            Value = GETMONITORTYPE(dll16_NvInfoPtrTable[DeviceHandle-1], 0);
            break;
        case NV_CFG_VIDEO_OVERLAY_ALLOWED:            
            Value = dll16_NvInfoPtrTable[DeviceHandle-1]->Video.HalInfo.OverlayAllowed;
            break;
        case NV_CFG_VIDEO_DOWNSCALE_RATIO_768:            
            Value = dll16_NvInfoPtrTable[DeviceHandle-1]->Video.HalInfo.OverlayMaxDownscale_768;
            break;
        case NV_CFG_VIDEO_DOWNSCALE_RATIO_1280:            
            Value = dll16_NvInfoPtrTable[DeviceHandle-1]->Video.HalInfo.OverlayMaxDownscale_1280;
            break;
        case NV_CFG_VIDEO_DOWNSCALE_RATIO_1920:            
            Value = dll16_NvInfoPtrTable[DeviceHandle-1]->Video.HalInfo.OverlayMaxDownscale_1920;
            break;
        case NV_CFG_VIDEO_REFRESH_RATE:
            Value = dll16_NvInfoPtrTable[DeviceHandle-1]->Framebuffer.HalInfo.RefreshRate;
            break;
        case NV_CFG_FRAMEBUFFER_UNDERSCAN_X:
            Value = dll16_NvInfoPtrTable[DeviceHandle-1]->Framebuffer.Underscan_x;
            break;
        case NV_CFG_FRAMEBUFFER_UNDERSCAN_Y:
            Value = dll16_NvInfoPtrTable[DeviceHandle-1]->Framebuffer.Underscan_y;
            break;
        case NV_CFG_VBLANK_TOGGLE:
            Value = dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.CrtcInfo[0].VBlankToggle;
            break;
        case NV_CFG_VBLANK_COUNTER:
            Value = dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.CrtcInfo[0].VBlankCounter;
            break;
        case NV_CFG_PRAM_CURRENT_SIZE:
            Value = dll16_NvInfoPtrTable[DeviceHandle-1]->Pram.HalInfo.CurrentSize;
            break;
        case NV_CFG_DAC_INPUT_WIDTH:
            Value = dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.HalInfo.InputWidth;
            break;
        case NV_CFG_DAC_PIXEL_CLOCK:
            Value = dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.HalInfo.VClk;
            break;
        case NV_CFG_DAC_MEMORY_CLOCK:
            Value = dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.HalInfo.MClk;
            break;
        case NV_CFG_DAC_GRAPHICS_CLOCK:
            Value = dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.HalInfo.NVClk;
            break;
        case NV_CFG_DAC_VPLL_M:
            Value = dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.HalInfo.VPllM;
            break;
        case NV_CFG_DAC_VPLL_N:
            Value = dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.HalInfo.VPllN;
            break;
        case NV_CFG_DAC_VPLL_O:
            Value = dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.HalInfo.VPllO;
            break;
        case NV_CFG_DAC_VPLL_P:
            Value = dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.HalInfo.VPllP;
            break;
        case NV_CFG_DAC_MPLL_M:
            Value = dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.HalInfo.MPllM;
            break;
        case NV_CFG_DAC_MPLL_N:
            Value = dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.HalInfo.MPllN;
            break;
        case NV_CFG_DAC_MPLL_O:
            Value = dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.HalInfo.MPllO;
            break;
        case NV_CFG_DAC_MPLL_P:
            Value = dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.HalInfo.MPllP;
            break;
        case NV_CFG_DAC_PCLK_LIMIT_8BPP:
            Value = GETCRTCHALINFO(dll16_NvInfoPtrTable[DeviceHandle-1], 0, PCLKLimit8bpp);
            break;            
        case NV_CFG_DAC_PCLK_LIMIT_16BPP:
            Value = GETCRTCHALINFO(dll16_NvInfoPtrTable[DeviceHandle-1], 0, PCLKLimit16bpp);
            break;            
        case NV_CFG_DAC_PCLK_LIMIT_32BPP:
            Value = GETCRTCHALINFO(dll16_NvInfoPtrTable[DeviceHandle-1], 0, PCLKLimit32bpp);
            break;            
        case NV_CFG_MAPPING_BUSDEVICEFUNC:
            rmParams.RegEAX = NVRM_API_GET_DEVICE_TYPE;
            rmParams.RegES  = 0;
            rmParams.RegESI = DeviceHandle-1;
            CallRM_DeviceSetup(&rmParams);
            Value = (dll16_NvInfoPtrTable[DeviceHandle-1]->Mapping.nvBusDeviceFunc << 8) | rmParams.RegEAX;
            break;
        case NV_CFG_FLAT_PANEL_CONNECT_16:
            rmParams.RegEAX = NVRM_API_DISPLAY;
            rmParams.RegEBX = NVRM_API_DISPLAY_GET_FP_CONNECT_STATUS;
            rmParams.RegES  = 0;
            rmParams.RegESI = DeviceHandle-1;
            CallRM_DeviceSetup(&rmParams);
            Value = rmParams.RegEAX;
            break;
        case NV_CFG_FLAT_PANEL_CONFIG_16:
            rmParams.RegEAX = NVRM_API_DISPLAY;
            rmParams.RegEBX = NVRM_API_DISPLAY_GET_FP_CONFIG;
            rmParams.RegES  = 0;
            rmParams.RegESI = DeviceHandle-1;
            CallRM_DeviceSetup(&rmParams);
            Value = rmParams.RegEAX;
            break;
        case NV_CFG_NUMBER_OF_HEADS:
            Value = dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.HalInfo.NumCrtcs;
            break;
        case NV_CFG_INITIAL_BOOT_HEAD:
            Value = dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.HalInfo.InitialBootHead;
            break;
        case NV_CFG_DEVICE_HANDLE:
            {
                PWIN9XHWINFO    pOsHwInfo = (PWIN9XHWINFO) dll16_NvInfoPtrTable[DeviceHandle-1]->pOsHwInfo;
                Value = pOsHwInfo->osDeviceHandle;
            }
            break;
#ifdef RM_STATS
        case NV_STAT_INTERVAL_NSEC_LO:
            Value = dll16_NvInfoPtrTable[DeviceHandle-1]->Statistics.UpdateLo;
            break;
        case NV_STAT_INTERVAL_NSEC_HI:
            Value = dll16_NvInfoPtrTable[DeviceHandle-1]->Statistics.UpdateHi;
            break;
        case NV_STAT_FIFO_EXCEPTIONS:
            Value = dll16_NvInfoPtrTable[DeviceHandle-1]->Statistics.FifoExceptionCount;
            break;
        case NV_STAT_FRAMEBUFFER_EXCEPTIONS:
            Value = dll16_NvInfoPtrTable[DeviceHandle-1]->Statistics.FramebufferExceptionCount;
            break;
        case NV_STAT_GRAPHICS_EXCEPTIONS:
            Value = dll16_NvInfoPtrTable[DeviceHandle-1]->Statistics.GraphicsExceptionCount;
            break;
        case NV_STAT_TIMER_EXCEPTIONS:
            Value = dll16_NvInfoPtrTable[DeviceHandle-1]->Statistics.TimerExceptionCount;
            break;
        case NV_STAT_CHIP_EXCEPTIONS:
            Value = dll16_NvInfoPtrTable[DeviceHandle-1]->Statistics.TotalExceptionCount;
            break;
        case NV_STAT_MEM_ALLOCATED:
            Value = dll16_NvInfoPtrTable[DeviceHandle-1]->Statistics.MemAlloced;
            break;
        case NV_STAT_MEM_LOCKED:
            Value = dll16_NvInfoPtrTable[DeviceHandle-1]->Statistics.MemLocked;
            break;
        case NV_STAT_EXEC_NSEC_LO:
            Value = dll16_NvInfoPtrTable[DeviceHandle-1]->Statistics.ExecTimeLo;
            break;
        case NV_STAT_EXEC_NSEC_HI:
            Value = dll16_NvInfoPtrTable[DeviceHandle-1]->Statistics.ExecTimeHi;
            break;
        case NV_STAT_INT_NSEC_LO:
            Value = dll16_NvInfoPtrTable[DeviceHandle-1]->Statistics.IntTimeLo;
            break;
        case NV_STAT_INT_NSEC_HI:
            Value = dll16_NvInfoPtrTable[DeviceHandle-1]->Statistics.IntTimeHi;
            break;
#endif
        case NV_CFG_GET_ALL_DEVICES:
            Value = dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.DevicesBitMap;
            break;
        case NV_CFG_GET_BOOT_DEVICES:
            Value = dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.BootDevicesBitMap;
            break;
    }

    if(RmInfoSel)
	FreeSelector(RmInfoSel);

    return (Value);
}
DWORD FAR PASCAL NvConfigSet
(
    DWORD       Index,
    DWORD       NewValue,
    U032        DeviceHandle
)
{
    RMINFO FAR *pRmInfo;
    U016 RmInfoSel = 0;
    U032 pv;

    DWORD OldValue, Value;
    U008  lock;
    DWORD pPRMCIO_INDEX;
    DWORD pPRMCIO_DATA;
    RMPARAMS     rmParams;
    NV_CFG_STEREO_PARAMS FAR *pStereoParams;

    OldValue = 0;

    // 
    // Special case the CRTC access since we're using the lower byte of
    // the index to denote the register we want to update
    //
    if ((Index & 0xF00) == NV_CFG_CRTC)
    {
        //
        // Build all the selectors we need: 3C4, 3C5, 3D4, 3D5
        //
        pPRMCIO_INDEX = ((DWORD)NvDeviceSelectorGet(NV_DEV_PRMCIO,DeviceHandle) << 16)
                  | ((DWORD)NV_PRMCIO_CRX__COLOR - (DWORD)DEVICE_BASE(NV_PRMCIO));
        pPRMCIO_DATA  = ((DWORD)NvDeviceSelectorGet(NV_DEV_PRMCIO,DeviceHandle) << 16)
                  | ((DWORD)NV_PRMCIO_CR__COLOR - (DWORD)DEVICE_BASE(NV_PRMCIO));
    
        //
        // Make sure the extended CRTC registers are enabled
        //
        REG_WR08(pPRMCIO_INDEX, NV_CIO_SR_LOCK_INDEX);      // 3D4
        lock = REG_RD08(pPRMCIO_DATA);                      // 3D5
        REG_WR08(pPRMCIO_INDEX, NV_CIO_SR_LOCK_INDEX);      // 3D4
        REG_WR08(pPRMCIO_DATA, NV_CIO_SR_UNLOCK_RW_VALUE);  // 3D5

        //
        // Set the register value.
        //
        REG_WR08(pPRMCIO_INDEX, Index & 0xFF);
        OldValue = REG_RD08(pPRMCIO_DATA);
        REG_WR08(pPRMCIO_DATA, NewValue & 0xFF);
        
        //
        // Restore the lock
        //
        if (lock == 0)
        {        
            REG_WR08(pPRMCIO_INDEX, NV_CIO_SR_LOCK_INDEX);      // 3D4
            REG_WR08(pPRMCIO_DATA, NV_CIO_SR_LOCK_VALUE);       // 3D5
        }

        return (OldValue);
    }

    if(IsNvCfgAgp(Index))
    {
	pv = (U032)(dll16_NvInfoPtrTable[DeviceHandle-1]->pRmInfo);
	RmInfoSel = GetSelector(pv,sizeof(RMINFO));
	pRmInfo = (RMINFO FAR*)(((U032)RmInfoSel) << 16); 
    }
    
    switch (Index)
    {
        //
        // Theses values actually look at hardware, not NvInfo.
        //
        case NV_CFG_VBLANK_STATUS:
            //
            //  Set OldValue = current value. No idea if this is used.
            //
            //
            // Build all the selectors we need: 3C4, 3C5, 3D4, 3D5
            //
            pPRMCIO_INDEX = ((DWORD)NvDeviceSelectorGet(NV_DEV_PRMCIO,DeviceHandle) << 16)
                      | ((DWORD)NV_PRMCIO_CRX__COLOR - (DWORD)DEVICE_BASE(NV_PRMCIO));
            pPRMCIO_DATA  = ((DWORD)NvDeviceSelectorGet(NV_DEV_PRMCIO,DeviceHandle) << 16)
                      | ((DWORD)NV_PRMCIO_CR__COLOR - (DWORD)DEVICE_BASE(NV_PRMCIO));

            //
            // Make sure the extended CRTC registers are enabled
            //
            REG_WR08(pPRMCIO_INDEX, NV_CIO_SR_LOCK_INDEX);      // 3D4
            lock = REG_RD08(pPRMCIO_DATA);                      // 3D5
            REG_WR08(pPRMCIO_INDEX, NV_CIO_SR_LOCK_INDEX);      // 3D4
            REG_WR08(pPRMCIO_DATA, NV_CIO_SR_UNLOCK_RW_VALUE);  // 3D5

            //
            // Get the scanline value.
            //
            Value = NvGetRasterPosition(DeviceHandle);
            // return boolean for (scanline == 0)
            if (Value == 0)
                OldValue = 1;
            else
                OldValue = 0;            
            //
            // Restore the lock
            //
            if (lock == 0)
            {        
                REG_WR08(pPRMCIO_INDEX, NV_CIO_SR_LOCK_INDEX);      // 3D4
                REG_WR08(pPRMCIO_DATA, NV_CIO_SR_LOCK_VALUE);       // 3D5
            }
            
            break;
        case NV_CFG_GE_STATUS:
            {
                DWORD pGEStatus;
                pGEStatus = ((DWORD)NvDeviceSelectorGet(NV_DEV_PGRAPH,DeviceHandle) << 16)
                          | ((DWORD)NV_PGRAPH_STATUS - (DWORD)DEVICE_BASE(NV_PGRAPH));
                OldValue = REG_RD32(pGEStatus);
            }
            break;
        //
        // Fields in NvInfo.
        //
        case NV_CFG_MANUFACTURER:
            OldValue = dll16_NvInfoPtrTable[DeviceHandle-1]->Chip.HalInfo.Manufacturer;
            break;
        case NV_CFG_ARCHITECTURE:
            OldValue = dll16_NvInfoPtrTable[DeviceHandle-1]->Chip.HalInfo.Architecture;
            break;
        case NV_CFG_REVISION:
            OldValue = dll16_NvInfoPtrTable[DeviceHandle-1]->Chip.HalInfo.Revision;
            break;
        case NV_CFG_BIOS_REVISION:
            OldValue = dll16_NvInfoPtrTable[DeviceHandle-1]->Chip.BiosRevision;
            break;
        case NV_CFG_IMPLEMENTATION:
            Value = dll16_NvInfoPtrTable[DeviceHandle-1]->Chip.HalInfo.Implementation;
            break;
        case NV_CFG_BUS_TYPE:
            OldValue = dll16_NvInfoPtrTable[DeviceHandle-1]->Chip.Bus;
            break;
        case NV_CFG_ADDRESS:
            OldValue = dll16_NvInfoPtrTable[DeviceHandle-1]->Mapping.PhysAddr;
            break;
        case NV_CFG_IRQ:
            OldValue = dll16_NvInfoPtrTable[DeviceHandle-1]->Mapping.IntLine;
            break;
        case NV_CFG_INSTANCE_SIZE:
            OldValue = dll16_NvInfoPtrTable[DeviceHandle-1]->Pram.FreeInstSize;
            break;
        case NV_CFG_FIFO_COUNT:
            OldValue = dll16_NvInfoPtrTable[DeviceHandle-1]->Fifo.HalInfo.Count;
            break;
        case NV_CFG_FIFO_USE_COUNT:
            OldValue = dll16_NvInfoPtrTable[DeviceHandle-1]->Fifo.HalInfo.AllocateCount;
            break;
        case NV_CFG_RAM_SIZE_MB:
            OldValue = dll16_NvInfoPtrTable[DeviceHandle-1]->Framebuffer.HalInfo.RamSizeMb;
            break;
        case NV_CFG_RAM_SIZE:
            OldValue = dll16_NvInfoPtrTable[DeviceHandle-1]->Framebuffer.HalInfo.RamSize;
            break;
        case NV_CFG_RAM_TYPE:
            OldValue = dll16_NvInfoPtrTable[DeviceHandle-1]->Framebuffer.HalInfo.RamType;
            break;
        case NV_CFG_AGP_PHYS_BASE:
            OldValue = pRmInfo->AGP.AGPPhysStart;
            pRmInfo->AGP.AGPPhysStart = NewValue;
            dll16_NvInfoPtrTable[DeviceHandle-1]->Mapping.UpdateFlags |= UPDATE_HWINFO_BUFFER_PARAMS;
            break;
        case NV_CFG_AGP_LINEAR_BASE:
            OldValue = pRmInfo->AGP.AGPLinearStart;
            pRmInfo->AGP.AGPLinearStart = NewValue;
            dll16_NvInfoPtrTable[DeviceHandle-1]->Mapping.UpdateFlags |= UPDATE_HWINFO_BUFFER_PARAMS;
            break;
        case NV_CFG_AGP_LIMIT:
            OldValue = pRmInfo->AGP.AGPLimit;
            pRmInfo->AGP.AGPLimit = NewValue;
            dll16_NvInfoPtrTable[DeviceHandle-1]->Mapping.UpdateFlags |= UPDATE_HWINFO_BUFFER_PARAMS;
            break;

        case NV_CFG_AGP_LOAD_DUMMY_PAGES:
            rmParams.RegEAX = NVRM_AGP_LOAD_DUMMY_PAGES;
            rmParams.RegES  = 0;
            rmParams.RegESI = DeviceHandle-1;
            CallRM_DeviceSetup(&rmParams);
            break;

        case NV_CFG_SCREEN_WIDTH:
            OldValue = dll16_NvInfoPtrTable[DeviceHandle-1]->Framebuffer.HalInfo.HorizDisplayWidth;
            dll16_NvInfoPtrTable[DeviceHandle-1]->Framebuffer.HalInfo.HorizDisplayWidth = NewValue;
            dll16_NvInfoPtrTable[DeviceHandle-1]->Framebuffer.UpdateFlags |= UPDATE_HWINFO_BUFFER_PARAMS;
            break;
        case NV_CFG_SCREEN_HEIGHT:
            OldValue = dll16_NvInfoPtrTable[DeviceHandle-1]->Framebuffer.HalInfo.VertDisplayWidth;
            dll16_NvInfoPtrTable[DeviceHandle-1]->Framebuffer.HalInfo.VertDisplayWidth = NewValue;
            dll16_NvInfoPtrTable[DeviceHandle-1]->Framebuffer.UpdateFlags |= UPDATE_HWINFO_BUFFER_PARAMS;
            break;
        case NV_CFG_PIXEL_DEPTH:
            OldValue = dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.HalInfo.Depth;
            dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.HalInfo.Depth = NewValue;
            dll16_NvInfoPtrTable[DeviceHandle-1]->Framebuffer.UpdateFlags |= UPDATE_HWINFO_BUFFER_PARAMS;
            break;
        case NV_CFG_VIDEO_DISPLAY_TYPE:
            OldValue = GETDISPLAYTYPE(dll16_NvInfoPtrTable[DeviceHandle-1], 0);
            rmParams.RegEAX = NVRM_API_DISPLAY;
            rmParams.RegEBX = NVRM_API_DISPLAY_SET_DISPLAY_TYPE;
            rmParams.RegECX = NewValue;
            rmParams.RegES  = 0;
            rmParams.RegESI = DeviceHandle-1;
            CallRM_DeviceSetup(&rmParams);
            break;
        case NV_CFG_VIDEO_MONITOR_TYPE:
            OldValue = GETMONITORTYPE(dll16_NvInfoPtrTable[DeviceHandle-1], 0);
            SETMONITORTYPE(dll16_NvInfoPtrTable[DeviceHandle-1], 0, NewValue);
            dll16_NvInfoPtrTable[DeviceHandle-1]->Framebuffer.UpdateFlags  |= UPDATE_HWINFO_DISPLAY_PARAMS;
            break;
        case NV_CFG_VIDEO_REFRESH_RATE:
            OldValue = dll16_NvInfoPtrTable[DeviceHandle-1]->Framebuffer.HalInfo.RefreshRate;
            dll16_NvInfoPtrTable[DeviceHandle-1]->Framebuffer.HalInfo.RefreshRate     = NewValue;
            dll16_NvInfoPtrTable[DeviceHandle-1]->Framebuffer.HorizFrontPorch = 0;
            dll16_NvInfoPtrTable[DeviceHandle-1]->Framebuffer.HorizSyncWidth  = 0;
            dll16_NvInfoPtrTable[DeviceHandle-1]->Framebuffer.HorizBackPorch  = 0;
            dll16_NvInfoPtrTable[DeviceHandle-1]->Framebuffer.VertFrontPorch  = 0;
            dll16_NvInfoPtrTable[DeviceHandle-1]->Framebuffer.VertSyncWidth   = 0;
            dll16_NvInfoPtrTable[DeviceHandle-1]->Framebuffer.VertBackPorch   = 0;
            dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.HalInfo.VClk            = 0;
            dll16_NvInfoPtrTable[DeviceHandle-1]->Framebuffer.UpdateFlags |= UPDATE_HWINFO_DISPLAY_PARAMS;
            dll16_NvInfoPtrTable[DeviceHandle-1]->Framebuffer.UpdateFlags |= UPDATE_HWINFO_BUFFER_PARAMS;       // kick a mode switch
            //
            // fb will reset the pixel clock, so we need to reload the VPLL
            //
            dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.UpdateFlags  |= UPDATE_HWINFO_DAC_VPLL;
            //
            // Allow Canopus to set the refresh rate and pull the
            // resolution from the registry (but not the refresh rate)
            // in only one mode set.  Yuck.  But until I can export all
            // modeset code...
            //
            dll16_NvInfoPtrTable[DeviceHandle-1]->Framebuffer.UpdateFlags |= UPDATE_HWINFO_REFRESH_PARAMS;
            break;
        case NV_CFG_FRAMEBUFFER_UNDERSCAN_X:
            OldValue = dll16_NvInfoPtrTable[DeviceHandle-1]->Framebuffer.Underscan_x;
            dll16_NvInfoPtrTable[DeviceHandle-1]->Framebuffer.Underscan_x = NewValue;
            // Recalculate the scale factor
            dll16_NvInfoPtrTable[DeviceHandle-1]->Framebuffer.Scale_x = dll16_NvInfoPtrTable[DeviceHandle-1]->Framebuffer.HalInfo.HorizDisplayWidth << 20;
            dll16_NvInfoPtrTable[DeviceHandle-1]->Framebuffer.Scale_x /= dll16_NvInfoPtrTable[DeviceHandle-1]->Framebuffer.Underscan_x;
            break;
        case NV_CFG_FRAMEBUFFER_UNDERSCAN_Y:
            OldValue = dll16_NvInfoPtrTable[DeviceHandle-1]->Framebuffer.Underscan_y;
            dll16_NvInfoPtrTable[DeviceHandle-1]->Framebuffer.Underscan_y = NewValue;
            // Recalculate the scale factor
            dll16_NvInfoPtrTable[DeviceHandle-1]->Framebuffer.Scale_y = dll16_NvInfoPtrTable[DeviceHandle-1]->Framebuffer.HalInfo.VertDisplayWidth << 20;
            dll16_NvInfoPtrTable[DeviceHandle-1]->Framebuffer.Scale_y /= dll16_NvInfoPtrTable[DeviceHandle-1]->Framebuffer.Underscan_y;
            break;
        case NV_CFG_VBLANK_TOGGLE:
            OldValue = dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.CrtcInfo[0].VBlankToggle;
            dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.CrtcInfo[0].VBlankToggle = NewValue;
            if (dll16_NvInfoPtrTable[DeviceHandle-1]->Vga.Enabled)
                dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.CrtcInfo[0].VBlankToggle = 0;
            break;
        case NV_CFG_VBLANK_COUNTER:
            OldValue = dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.CrtcInfo[0].VBlankCounter;
            dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.CrtcInfo[0].VBlankCounter = NewValue;
            break;
        case NV_CFG_PRAM_CURRENT_SIZE:
            OldValue = dll16_NvInfoPtrTable[DeviceHandle-1]->Pram.HalInfo.CurrentSize;
            break;
        case NV_CFG_DAC_INPUT_WIDTH:
            OldValue = dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.HalInfo.InputWidth;
            break;
        case NV_CFG_DAC_PIXEL_CLOCK:
            OldValue = dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.HalInfo.VClk;
            dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.HalInfo.VClk = NewValue;
            dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.UpdateFlags  |= UPDATE_HWINFO_DAC_VPLL;
            //
            // set DISPLAY flag as this parameter may be stored in EEPROM
            //
            dll16_NvInfoPtrTable[DeviceHandle-1]->Framebuffer.UpdateFlags |= UPDATE_HWINFO_DISPLAY_PARAMS;
            break;
        case NV_CFG_DAC_MEMORY_CLOCK:
            OldValue = dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.HalInfo.MClk;
            dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.HalInfo.MClk = NewValue;
            dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.UpdateFlags  |= UPDATE_HWINFO_DAC_MPLL;
            break;
        case NV_CFG_DAC_GRAPHICS_CLOCK:
            OldValue = dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.HalInfo.NVClk;
            dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.HalInfo.NVClk = NewValue;
            dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.UpdateFlags  |= UPDATE_HWINFO_DAC_NVPLL;
            break;
        case NV_CFG_DAC_VPLL_M:
            OldValue = dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.HalInfo.VPllM;
            break;
        case NV_CFG_DAC_VPLL_N:
            OldValue = dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.HalInfo.VPllN;
            break;
        case NV_CFG_DAC_VPLL_O:
            OldValue = dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.HalInfo.VPllO;
            break;
        case NV_CFG_DAC_VPLL_P:
            OldValue = dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.HalInfo.VPllP;
            break;
        case NV_CFG_DAC_MPLL_M:
            OldValue = dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.HalInfo.MPllM;
            break;
        case NV_CFG_DAC_MPLL_N:
            OldValue = dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.HalInfo.MPllN;
            break;
        case NV_CFG_DAC_MPLL_O:
            OldValue = dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.HalInfo.MPllO;
            break;
        case NV_CFG_DAC_MPLL_P:
            OldValue = dll16_NvInfoPtrTable[DeviceHandle-1]->Dac.HalInfo.MPllP;
            break;
        case NV_CFG_REGISTRY_STRING:
            rmParams.RegEAX = NVRM_REGISTRY_SET_STRING;
            rmParams.RegEBX = NewValue;
            rmParams.RegES  = 0;
            rmParams.RegESI = DeviceHandle-1;
            CallRM_DeviceSetup(&rmParams);
            break;
        case NV_CFG_FRAMECAPTURE_CALLBACK:			// Callback for the VFW capture driver
            OldValue = dll16_NvInfoPtrTable[DeviceHandle-1]->MediaPort.ImageCallback;
            dll16_NvInfoPtrTable[DeviceHandle-1]->MediaPort.ImageCallback = NewValue;
            break;
        case NV_CFG_FLAT_PANEL_CONFIG_16:
            rmParams.RegEAX = NVRM_API_DISPLAY;
            rmParams.RegEBX = NVRM_API_DISPLAY_GET_FP_CONFIG;
            rmParams.RegES  = 0;
            rmParams.RegESI = DeviceHandle-1;
            CallRM_DeviceSetup(&rmParams);
            OldValue = rmParams.RegEAX;
            rmParams.RegEAX = NVRM_API_DISPLAY;
            rmParams.RegEBX = NVRM_API_DISPLAY_SET_FP_CONFIG;
            rmParams.RegECX = NewValue;
            rmParams.RegES  = 0;
            rmParams.RegESI = DeviceHandle-1;
            CallRM_DeviceSetup(&rmParams);
            break;
        case NV_CFG_DISPLAY_CHANGE_CONFIG:
            rmParams.RegEAX = NVRM_API_DISPLAY;
            rmParams.RegEBX = NVRM_API_DISPLAY_CHANGE_CONFIG;
            rmParams.RegECX = NewValue;
            rmParams.RegES  = 0;
            rmParams.RegESI = DeviceHandle-1;
            CallRM_DeviceSetup(&rmParams);
            break;
        case NV_CFG_DISPLAY_CHANGE_START:
            rmParams.RegEAX = NVRM_API_DISPLAY;
            rmParams.RegEBX = NVRM_API_DISPLAY_CHANGE_START;
            rmParams.RegECX = NewValue;
            rmParams.RegES  = 0;
            rmParams.RegESI = DeviceHandle-1;
            CallRM_DeviceSetup(&rmParams);
            break;
        case NV_CFG_DISPLAY_CHANGE_END:
            rmParams.RegEAX = NVRM_API_DISPLAY;
            rmParams.RegEBX = NVRM_API_DISPLAY_CHANGE_END;
            rmParams.RegECX = NewValue;
            rmParams.RegES  = 0;
            rmParams.RegESI = DeviceHandle-1;
            CallRM_DeviceSetup(&rmParams);
            break;
        case NVRM_API_DISPLAY_GET_BOOT_PHYS_MAP:
            rmParams.RegEAX = NVRM_API_DISPLAY_GET_BOOT_PHYS_MAP;
//            rmParams.RegEBX = NVRM_API_DISPLAY_GET_BOOT_PHYS_MAP;
            rmParams.RegECX = NewValue;
            rmParams.RegES  = 0;
            rmParams.RegESI = DeviceHandle-1;
            CallRM_DeviceSetup(&rmParams);
            break;
        case NV_CFG_STEREO_CONFIG:
            pStereoParams = (NV_CFG_STEREO_PARAMS FAR *)NewValue;
            if (pStereoParams->Flags == STEREOCFG_EXIT_ADJACENT)
            {
                dll16_NvInfoPtrTable[DeviceHandle-1]->StereoFlags &= ~STEREO_ADJACENT_EYES;
            } else
            {
                if (pStereoParams->Flags == STEREOCFG_ENTER_ADJACENT)
                {
                    dll16_NvInfoPtrTable[DeviceHandle-1]->StereoFlags |= STEREO_ADJACENT_EYES;
                } 
            }        
            OldValue = (DWORD)dll16_NvInfoPtrTable[DeviceHandle-1]->pStereoParams;
            break;

#ifdef RM_STATS
        case NV_STAT_INTERVAL_NSEC_LO:
            OldValue = dll16_NvInfoPtrTable[DeviceHandle-1]->Statistics.UpdateLo;
            dll16_NvInfoPtrTable[DeviceHandle-1]->Statistics.UpdateLo = NewValue;
            break;
        case NV_STAT_INTERVAL_NSEC_HI:
            OldValue = dll16_NvInfoPtrTable[DeviceHandle-1]->Statistics.UpdateHi;
            dll16_NvInfoPtrTable[DeviceHandle-1]->Statistics.UpdateHi = NewValue;
            break;
        case NV_STAT_FIFO_EXCEPTIONS:
            OldValue = dll16_NvInfoPtrTable[DeviceHandle-1]->Statistics.FifoExceptionCount;
            break;
        case NV_STAT_FRAMEBUFFER_EXCEPTIONS:
            OldValue = dll16_NvInfoPtrTable[DeviceHandle-1]->Statistics.FramebufferExceptionCount;
            break;
        case NV_STAT_GRAPHICS_EXCEPTIONS:
            OldValue = dll16_NvInfoPtrTable[DeviceHandle-1]->Statistics.GraphicsExceptionCount;
            break;
        case NV_STAT_TIMER_EXCEPTIONS:
            OldValue = dll16_NvInfoPtrTable[DeviceHandle-1]->Statistics.TimerExceptionCount;
            break;
        case NV_STAT_CHIP_EXCEPTIONS:
            OldValue = dll16_NvInfoPtrTable[DeviceHandle-1]->Statistics.TotalExceptionCount;
            break;
        case NV_STAT_MEM_ALLOCATED:
            OldValue = dll16_NvInfoPtrTable[DeviceHandle-1]->Statistics.MemAlloced;
            break;
        case NV_STAT_MEM_LOCKED:
            OldValue = dll16_NvInfoPtrTable[DeviceHandle-1]->Statistics.MemLocked;
            break;
        case NV_STAT_EXEC_NSEC_LO:
            OldValue = dll16_NvInfoPtrTable[DeviceHandle-1]->Statistics.ExecTimeLo;
            break;
        case NV_STAT_EXEC_NSEC_HI:
            OldValue = dll16_NvInfoPtrTable[DeviceHandle-1]->Statistics.ExecTimeHi;
            break;
        case NV_STAT_INT_NSEC_LO:
            OldValue = dll16_NvInfoPtrTable[DeviceHandle-1]->Statistics.IntTimeLo;
            break;
        case NV_STAT_INT_NSEC_HI:
            OldValue = dll16_NvInfoPtrTable[DeviceHandle-1]->Statistics.IntTimeHi;
            break;
#endif
    }

    if(RmInfoSel)
	FreeSelector(RmInfoSel);

    return (OldValue);
}
DWORD FAR PASCAL NvConfigUpdate
(
    DWORD       UpdateFlag,
    U032        DeviceHandle
)
{
    RMPARAMS rmParams;
    WORD     RepaintFlag;

    if (dll16_NvInfoPtrTable[DeviceHandle-1]->Framebuffer.UpdateFlags & UPDATE_HWINFO_BUFFER_PARAMS)
        RepaintFlag = TRUE;
    else
        RepaintFlag = FALSE;
    rmParams.RegEAX = NVRM_API_UPDATE_CONFIGURATION;
    rmParams.RegEBX = UpdateFlag;
    rmParams.RegES  = 0;
    rmParams.RegESI = DeviceHandle-1;
    CallRM_DeviceSetup(&rmParams);
    if (RepaintFlag)
    {
        //
        // Update selectors to framebuffer.
        //
        if (devSelectorTable[DeviceHandle-1].devSelector[NV_DEV_BUFFER_0])
        {
            rmParams.RegEAX = NVRM_API_MAP_SELECTOR;
            rmParams.RegEBX = NvDeviceBaseGet(NV_DEV_BUFFER_0,DeviceHandle);
            rmParams.RegECX = NvDeviceLimitGet(NV_DEV_BUFFER_0,DeviceHandle);
            rmParams.RegEDX = devSelectorTable[DeviceHandle-1].devSelector[NV_DEV_BUFFER_0];
            rmParams.RegES  = 0;
            rmParams.RegESI = DeviceHandle-1;
            CallRM_DeviceSetup(&rmParams);
        }
        RepaintScreen();
    }
    
    return (rmParams.RegEAX);
}
DWORD FAR PASCAL NvConfigVga
(
    DWORD       Mode,
    U032        DeviceHandle
)
{
    RMPARAMS rmParams;

    dll16_NvInfoPtrTable[DeviceHandle-1]->Vga.GlobalEnable = Mode;
    rmParams.RegEAX = NVRM_API_CONFIG_VGA;
    rmParams.RegEBX = Mode;
    rmParams.RegES  = 0;
    rmParams.RegESI = DeviceHandle-1;
    CallRM_DeviceSetup(&rmParams);
    if (!Mode)
    {
        //
        // Update selectors to framebuffer.
        //
        if (devSelectorTable[DeviceHandle-1].devSelector[NV_DEV_BUFFER_0])
        {
            rmParams.RegEAX = NVRM_API_MAP_SELECTOR;
            rmParams.RegEBX = NvDeviceBaseGet(NV_DEV_BUFFER_0,DeviceHandle);
            rmParams.RegECX = NvDeviceLimitGet(NV_DEV_BUFFER_0,DeviceHandle);
            rmParams.RegEDX = devSelectorTable[DeviceHandle-1].devSelector[NV_DEV_BUFFER_0];
            rmParams.RegES  = 0;
            rmParams.RegESI = DeviceHandle-1;
            CallRM_DeviceSetup(&rmParams);
        }
    }

    return (rmParams.RegEAX);
}

//---------------------------------------------------------------------------
//
// Device API.
//
//---------------------------------------------------------------------------

DWORD FAR PASCAL NvDeviceBaseGet
(
    DWORD       Index,
    DWORD       DeviceHandle
)
{
    DWORD    DeviceOffset;
    RMPARAMS rmParams;

    switch (Index)
    {
        case NV_DEV_BASE:
            DeviceOffset = DEVICE_BASE(NV_SPACE);
            break;
        case NV_DEV_BUFFER_0:
            DeviceOffset = dll16_NvInfoPtrTable[DeviceHandle-1]->Framebuffer.HalInfo.Start[0];
            rmParams.RegEAX = NVRM_API_GET_FB_ADDRESS;
            rmParams.RegES  = 0;
            rmParams.RegESI = DeviceHandle-1;
            CallRM_DeviceSetup(&rmParams);
            
            return (rmParams.RegEAX + DeviceOffset);
            break;
        case NV_DEV_AGP:
            rmParams.RegEAX = NVRM_API_GET_AGP_ADDRESS;
            rmParams.RegES  = 0;
            rmParams.RegESI = DeviceHandle-1;
            CallRM_DeviceSetup(&rmParams);

            return (rmParams.RegEAX);
            break;
        case NV_DEV_GAMMA:
            rmParams.RegEAX = NVRM_API_GET_GAMMA_ADDRESS;
            rmParams.RegES  = 0;
            rmParams.RegESI = DeviceHandle-1;
            CallRM_DeviceSetup(&rmParams);

            return (rmParams.RegEAX);
            break;
        case NV_DEV_TIMER:
            DeviceOffset = NV_PTIMER_TIME_0;
            break;
        case NV_DEV_PFB:
            DeviceOffset = DEVICE_BASE(NV_PFB);
            break;
        case NV_DEV_PGRAPH:
            DeviceOffset = DEVICE_BASE(NV_PGRAPH);
            break;
        case NV_DEV_PRMCIO:
            DeviceOffset = DEVICE_BASE(NV_PRMCIO);
            break;
        case NV_DEV_PRMVIO:
            DeviceOffset = DEVICE_BASE(NV_PRMVIO);
            break;
        case NV_DEV_PRAMDAC:
            DeviceOffset = DEVICE_BASE(NV_PRAMDAC);
            break;
        case NV_DEV_PCRTC:
            // there's no limit:base define for NV_PCRTC, so use ...
            DeviceOffset = NV_PCRTC_INTR_0;
            break;
        default:

        return (0);
    }
    //
    // Get base pointer to the hardware.
    //
    rmParams.RegEAX = NVRM_API_GET_NV_ADDRESS;
    rmParams.RegES  = 0;
    rmParams.RegESI = DeviceHandle-1;
    CallRM_DeviceSetup(&rmParams);
    //
    // Return pointer to desired device.
    //
    
    return (rmParams.RegEAX + DeviceOffset);
}
DWORD FAR PASCAL NvDeviceLimitGet
(
    DWORD       Index,
    DWORD       DeviceHandle
)
{
    DWORD      DeviceLimit;

    switch (Index)
    {
        case NV_DEV_BASE:
            DeviceLimit = (1?NV_SPACE) - DEVICE_BASE(NV_SPACE);
            break;
        case NV_DEV_BUFFER_0:
            DeviceLimit = dll16_NvInfoPtrTable[DeviceHandle-1]->Framebuffer.HalInfo.Limit[0];
            break;
        case NV_DEV_TIMER:
            DeviceLimit = 7;
            break;
        case NV_DEV_GAMMA:
            DeviceLimit = 0x400;
            break;
        case NV_DEV_PFB:
            DeviceLimit = 0x0FFF;
            break;
        case NV_DEV_PGRAPH:
            DeviceLimit = 0x0FFF;
            break;
        case NV_DEV_PRMCIO:
            DeviceLimit = 0x0FFF;
            break;
        case NV_DEV_PRMVIO:
            DeviceLimit = 0x7FFF;
            break;
        case NV_DEV_PRAMDAC:
            DeviceLimit = DEVICE_EXTENT(NV_PRAMDAC) - DEVICE_BASE(NV_PRAMDAC);
            break;
        case NV_DEV_PCRTC:
            // there's no limit:base define for NV_PCRTC, so use ...
            DeviceLimit = ((NV_PCRTC_RASTER+4) - NV_PCRTC_INTR_0);
            break;
        default:
     
            return (0);
    }
    //
    // Return limit of desired device.
    //

    return (DeviceLimit);
}
WORD FAR PASCAL NvDeviceSelectorGet
(
    DWORD       Index,
    U032        DeviceHandle
)
{
    DWORD      DeviceBase;
    DWORD      DeviceLimit;
    RMPARAMS   rmParams;

    if (Index > NV_DEV_MAX)
    {    
        return (0);
    }        
    if (devSelectorTable[DeviceHandle-1].devSelector[Index])
    {    
        return (devSelectorTable[DeviceHandle-1].devSelector[Index]);
    }        
    DeviceBase  = NvDeviceBaseGet(Index,DeviceHandle);
    DeviceLimit = NvDeviceLimitGet(Index,DeviceHandle);
    //
    // Get selector for requested device.
    //
    rmParams.RegEAX = NVRM_API_MAP_SELECTOR;
    rmParams.RegEBX = DeviceBase;
    rmParams.RegECX = DeviceLimit;
    rmParams.RegEDX = 0;
    rmParams.RegES  = 0;
    rmParams.RegESI = DeviceHandle-1;
    CallRM_DeviceSetup(&rmParams);
    devSelectorTable[DeviceHandle-1].devSelector[Index] = (WORD) rmParams.RegEAX;
    
    return (devSelectorTable[DeviceHandle-1].devSelector[Index]);
}

void FAR PASCAL __loadds NvSysRegisterDisplayDriver(RMPARAMS FAR *prmParams)
{
    prmParams->RegEAX = NVRM_API_REGISTER_DISPLAY_DRIVER;
    prmParams->RegESI = 0;
    prmParams->RegES = 0;
    CallRM_DeviceSetup(prmParams);
}

void CallRM_DeviceSetup(LPRMPARAMS lprmParams)
{
    RMUSRAPI_STRUCT rmusrcall;
    WORD seg_,off_;
    DWORD seg_base,rmusrcall_flat_offset;
    
    rmusrcall.function = lprmParams->RegEAX;
    rmusrcall.device = lprmParams->RegESI;

    _asm push di
    _asm lea  di,rmusrcall
    _asm mov  off_,di
    _asm pop  di

	_asm mov  seg_,ss

    seg_base = GetSelectorBase((UINT) seg_);
    rmusrcall_flat_offset = seg_base+((DWORD) off_);
    lprmParams->RegEAX = rmusrcall_flat_offset;

    CallRM(lprmParams);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\inc16\DCIDDI.H ===
/*******************************************************************
 *
 *	FILE:		dciddi.h
 *	
 *	DESCRIPTION:	definitions for MS/Intel-defined DCI interface
 *
 *	Copyright (C) 1994 Intel/Microsoft Corporation.  All Rights Reserved.
 *
 *******************************************************************/

#ifndef _INC_DCIDDI
#define _INC_DCIDDI

#ifdef __cplusplus
extern "C" {
#endif

/* DCI Command Escapes */                                                               
#define DCICOMMAND			3075
#define DCI_VERSION			0x0100

#define DCICREATEPRIMARYSURFACE		1 
#define DCICREATEOFFSCREENSURFACE       2 
#define DCICREATEOVERLAYSURFACE         3
#define DCIENUMSURFACE                  4 
#define DCIESCAPE                       5

/* DCI-Defined error codes */
#define DCI_OK                              	0 /* success */

/* Hard errors -- DCI will be unavailable */
#define DCI_FAIL_GENERIC                     -1
#define DCI_FAIL_UNSUPPORTEDVERSION          -2
#define DCI_FAIL_INVALIDSURFACE              -3
#define DCI_FAIL_UNSUPPORTED                 -4    

/* Soft errors -- DCI may be available later */
#define DCI_ERR_CURRENTLYNOTAVAIL           -5
#define DCI_ERR_INVALIDRECT                 -6
#define DCI_ERR_UNSUPPORTEDFORMAT           -7
#define DCI_ERR_UNSUPPORTEDMASK             -8
#define DCI_ERR_TOOBIGHEIGHT                -9
#define DCI_ERR_TOOBIGWIDTH                 -10
#define DCI_ERR_TOOBIGSIZE                  -11
#define DCI_ERR_OUTOFMEMORY                 -12
#define DCI_ERR_INVALIDPOSITION             -13
#define DCI_ERR_INVALIDSTRETCH              -14
#define DCI_ERR_INVALIDCLIPLIST             -15
#define DCI_ERR_SURFACEISOBSCURED           -16
#define DCI_ERR_XALIGN			    -17
#define DCI_ERR_YALIGN			    -18
#define DCI_ERR_XYALIGN			    -19
#define DCI_ERR_WIDTHALIGN		    -20
#define DCI_ERR_HEIGHTALIGN		    -21
											 
/* success messages -- DCI call succeeded, but specified item changed */
#define DCI_STATUS_POINTERCHANGED           1
#define DCI_STATUS_STRIDECHANGED            2
#define DCI_STATUS_FORMATCHANGED            4
#define DCI_STATUS_SURFACEINFOCHANGED       8
#define DCI_STATUS_CHROMAKEYCHANGED        16				
#define DCI_STATUS_WASSTILLDRAWING         32


/* DCI Capability Flags */
#define DCI_SURFACE_TYPE			0x0000000F
#define DCI_PRIMARY                 		0x00000000
#define DCI_OFFSCREEN               		0x00000001
#define DCI_OVERLAY                 		0x00000002

#define DCI_VISIBLE                 		0x00000010
#define DCI_CHROMAKEY               		0x00000020
#define DCI_1632_ACCESS             		0x00000040
#define DCI_DWORDSIZE               		0x00000080
#define DCI_DWORDALIGN              		0x00000100
#define DCI_WRITEONLY               		0x00000200
#define DCI_ASYNC                   		0x00000400

#define DCI_CAN_STRETCHX            		0x00001000
#define DCI_CAN_STRETCHY            		0x00002000
#define DCI_CAN_STRETCHXY           		(DCI_CAN_STRETCHX | DCI_CAN_STRETCHY)

#define DCI_CAN_STRETCHXN           		0x00004000
#define DCI_CAN_STRETCHYN           		0x00008000
#define DCI_CAN_STRETCHXYN          		(DCI_CAN_STRETCHXN | DCI_CAN_STRETCHYN)


#define DCI_CANOVERLAY                          0x00010000

/*
 * Win32 RGNDATA structure.  This will be used for  cliplist info. passing.
 */
#if (WINVER < 0x0400)

#ifndef RDH_RECTANGLES

typedef struct tagRECTL
{                      
   LONG     left;      
   LONG     top;       
   LONG     right;     
   LONG     bottom;    
} RECTL;               
typedef RECTL*       PRECTL; 
typedef RECTL NEAR*  NPRECTL; 
typedef RECTL FAR*   LPRECTL;  
typedef const RECTL FAR* LPCRECTL;

#define RDH_RECTANGLES  0

typedef struct tagRGNDATAHEADER {
   DWORD   dwSize;                              /* size of structure             */
   DWORD   iType;                               /* Will be RDH_RECTANGLES        */
   DWORD   nCount;                              /* # of clipping rectangles      */
   DWORD   nRgnSize;                            /* size of buffer -- can be zero */
   RECTL   rcBound;                             /* bounding  rectangle for region*/
} RGNDATAHEADER;
typedef RGNDATAHEADER*       PRGNDATAHEADER;
typedef RGNDATAHEADER NEAR*  NPRGNDATAHEADER;
typedef RGNDATAHEADER FAR*   LPRGNDATAHEADER;
typedef const RGNDATAHEADER FAR* LPCRGNDATAHEADER;

typedef struct tagRGNDATA {
   RGNDATAHEADER   rdh;
   char            Buffer[1];
} RGNDATA;
typedef RGNDATA*       PRGNDATA;
typedef RGNDATA NEAR*  NPRGNDATA;
typedef RGNDATA FAR*   LPRGNDATA;
typedef const RGNDATA FAR* LPCRGNDATA;

#endif
#endif

typedef int     DCIRVAL;                /* return for callbacks */

#ifndef DCI_HAS_STUPID_H_FILE

/**************************************************************************
 *	input structures
 **************************************************************************/

/*
 * Used by a DCI client to provide input parameters for the 
 * DCICREATEPRIMARYSURFACE escape.
 */
typedef struct _DCICMD {
	DWORD	dwCommand;
	DWORD	dwParam1;
	DWORD 	dwParam2;
	DWORD	dwVersion;
	DWORD	dwReserved;
} DCICMD;

/*
 * This structure is used by a DCI client to provide input parameters for 
 * the DCICREATE... calls.  The fields that are actually relevant differ for 
 * each of the three calls.  Details are in the DCI Spec chapter providing 
 * the function specifications.
 */
typedef struct _DCICREATEINPUT {
	DCICMD	cmd;							/* common header structure */
	DWORD   dwCompression;          		/* format of surface to be created                      */
	DWORD   dwMask[3];                      /* for  nonstandard RGB (e.g. 5-6-5, RGB32) */
	DWORD   dwWidth;                        /* height of the surface to be created          */
	DWORD   dwHeight;                       /* width of input surfaces                                      */
	DWORD	dwDCICaps;						/* capabilities of surface wanted */
	DWORD	dwBitCount;					/* bit depth of format to be created */
	LPVOID  lpSurface;                      /* pointer to an associated surface             */      
} DCICREATEINPUT, FAR *LPDCICREATEINPUT;
		

/*
 * This structure is used by a DCI client to provide input parameters for the 
 * DCIEnumSurface call.
 */
typedef struct _DCIENUMINPUT {
	DCICMD	cmd;							/* common header structure */
	RECT    rSrc;                           /* source rect. for stretch  */
	RECT    rDst;                           /* dest. rect. for stretch       */
	void    (CALLBACK *EnumCallback)(LPDCISURFACEINFO, LPVOID);        /* callback for supported formats */
	LPVOID  lpContext;
} DCIENUMINPUT, FAR *LPDCIENUMINPUT;

/**************************************************************************
 *	surface info. structures
 **************************************************************************/

/*
 * This structure is used to return information about available support
 * during a DCIEnumSurface call.  It is also used to create a primary 
 * surface, and as a member of the larger structures returned by the 
 * offscreen and overlay calls.
 */
 typedef struct _DCISURFACEINFO {
	DWORD   dwSize;                 	/* size of structure                                            */
	DWORD   dwDCICaps;                  /* capability flags (stretch, etc.)             */
	DWORD   dwCompression;          	/* format of surface to be created                      */
	DWORD   dwMask[3];                  /* for BI_BITMASK surfaces                                      */

	DWORD   dwWidth;                    /* width of surface                                             */
	DWORD   dwHeight;                   /* height of surface                                            */
	LONG    lStride;                    /* distance in bytes betw. one pixel            */
										/* and the pixel directly below it                      */
	DWORD   dwBitCount;                 /* Bits per pixel for this dwCompression    */
	DWORD   dwOffSurface;               /* offset of surface pointer                            */
	WORD    wSelSurface;                /* selector of surface pointer                          */
	WORD    wReserved;					

	DWORD   dwReserved1;                /* reserved for provider */
	DWORD   dwReserved2;                /* reserved for DCIMAN */     
	DWORD   dwReserved3;                /* reserved for future */     
        DCIRVAL (CALLBACK *BeginAccess) (LPVOID, LPRECT);    /* BeginAccess callback         */
	void (CALLBACK *EndAccess) (LPVOID);                   /* EndAcess callback            */      
	void (CALLBACK *DestroySurface) (LPVOID);               /* Destroy surface callback     */
} DCISURFACEINFO, FAR *LPDCISURFACEINFO;

/*
 * This structure must be allocated and returned by the DCI provider in 
 * response to a DCICREATEPRIMARYSURFACE call.
 */
 typedef DCISURFACEINFO DCIPRIMARY, FAR *LPDCIPRIMARY;
								   
/*
 * This structure must be allocated and returned by the DCI provider in 
 * response to a DCICREATEOFFSCREENSURFACE call.
 */
 typedef struct _DCIOFFSCREEN {

	DCISURFACEINFO  dciInfo;                                                           /* surface info                  */
        DCIRVAL (CALLBACK *Draw) (LPVOID);                                            /* copy to onscreen buffer   */
        DCIRVAL (CALLBACK *SetClipList) (LPVOID, LPRGNDATA);          /* SetCliplist callback              */
        DCIRVAL (CALLBACK *SetDestination) (LPVOID, LPRECT, LPRECT);  /* SetDestination callback       */
} DCIOFFSCREEN, FAR *LPDCIOFFSCREEN;


/*
 * This structure must be allocated and returned by the DCI provider in response
 * to a DCICREATEOVERLAYSURFACE call.
 */
 typedef struct _DCIOVERLAY{

	DCISURFACEINFO  dciInfo;                                                /* surface info                  */
	DWORD   dwChromakeyValue;                                               /* chromakey color value                 */
	DWORD   dwChromakeyMask;                                                /* specifies valid bits of value */
} DCIOVERLAY, FAR *LPDCIOVERLAY;


/* DCI FOURCC def.s for extended DIB formats */                    

#ifndef YVU9
#define YVU9                        mmioFOURCC('Y','V','U','9')
#endif
#ifndef Y411
#define Y411                        mmioFOURCC('Y','4','1','1')                                             
#endif
#ifndef YUY2
#define YUY2                        mmioFOURCC('Y','U','Y','2')
#endif
#ifndef YVYU
#define YVYU                        mmioFOURCC('Y','V','Y','U')
#endif
#ifndef UYVY
#define UYVY                        mmioFOURCC('U','Y','V','Y')
#endif
#ifndef Y211
#define Y211                        mmioFOURCC('Y','2','1','1')
#endif

#endif // DCI_HAS_STUPID_H_FILE

#ifdef __cplusplus
}
#endif

#endif // _INC_DCIDDI
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\dll32\nvarch32.c ===
//
// (C) Copyright NVIDIA Corporation Inc., 1995,1996. All rights reserved.
//
/******************* Operating System Interface Routines *******************\
*                                                                           *
* Module: NVARCH.C                                                          *
*         This is the 32bit DLL interface to the RM for the new architecture*
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Jim Vito (jvito)    03/04/98 - wrote it.                            *
\***************************************************************************/
#include <windows.h>
#include <nvwin32.h>
#include <nvrmwin.h>

//#include "nv_ref.h"
//#include "nvrm.h"
//#include "nvrmwin.h"
//#include "nvcm.h"
//#include <class.h>
//#include <vblank.h>
//#include <gr.h>
//#include <vga.h>
//#include "nvsys.h"

typedef struct _def_rmParams FAR *LPRMPARAMS;
//extern  VOID PASCAL CallRM(LPRMPARAMS);

#define NVRM_DLL32_NV01FREE            NVRM_ARCH_NV01FREE			 
#define NVRM_DLL32_NV01ALLOCROOT       NVRM_ARCH_NV01ALLOCROOT       
#define NVRM_DLL32_NV01ALLOCMEMORY	   NVRM_ARCH_NV01ALLOCMEMORY	 
#define NVRM_DLL32_NV01ALLOCCONTEXTDMA NVRM_ARCH_NV01ALLOCCONTEXTDMA 
#define NVRM_DLL32_NV01ALLOCCHANNELPIO NVRM_ARCH_NV01ALLOCCHANNELPIO 
#define NVRM_DLL32_NV01ALLOCOBJECT	   NVRM_ARCH_NV01ALLOCOBJECT	 
#define NVRM_DLL32_NV01ALLOCDEVICE	   NVRM_ARCH_NV01ALLOCDEVICE	 
#define NVRM_DLL32_NV03ALLOCCHANNELDMA NVRM_ARCH_NV03ALLOCCHANNELDMA 
#define NVRM_DLL32_NV03DMAFLOWCONTROL  NVRM_ARCH_NV03DMAFLOWCONTROL  
#define NVRM_DLL32_NV01INTERRUPT       NVRM_ARCH_NV01INTERRUPT       
#define NVRM_DLL32_NV01ALLOCEVENT	   NVRM_ARCH_NV01ALLOCEVENT		 

#define NVRM_ARCHITECTURE_API          NVRM_API_ARCHITECTURE_32
#define NVOPEN_STATUS_SUCCESS 		   0
#define NVCLOSE_STATUS_SUCCESS		   0

DWORD PASCAL NvSysDispatch(LPRMPARAMS, DWORD);

VOID __stdcall NvIoControl
(
  U032 Function,
  VOID *pParameters
)
{
    RMPARAMS NvParams;

    NvParams.RegEAX = NVRM_ARCHITECTURE_API;
    NvParams.RegEDX = (DWORD)Function;
    NvParams.RegEBX = (DWORD)pParameters;
    NvParams.RegEDI = 1;				  // The device context will be assigned in the RM.
    NvParams.RegES  = 0;
    _asm xor eax, eax
    _asm mov ax, ds
    _asm mov NvParams.RegDS, eax
    _asm mov ax, cs
    _asm mov NvParams.RegCS, eax
    NvSysDispatch(&NvParams, 0);
}	


VOID Arch_NvOpen(U032 *status)                   
{
  *status = NVOPEN_STATUS_SUCCESS;
}

VOID Arch_NvClose(U032 *status)                  
{
  *status = NVCLOSE_STATUS_SUCCESS;
}

VOID Arch_Nv01Free(VOID *pParameters)            
{
  NvIoControl(NVRM_DLL32_NV01FREE,pParameters);
}

VOID Arch_Nv01AllocRoot(VOID *pParameters)       
{
  NvIoControl(NVRM_DLL32_NV01ALLOCROOT,pParameters);
}

VOID Arch_Nv01AllocDevice(VOID *pParameters)     
{
  NvIoControl(NVRM_DLL32_NV01ALLOCDEVICE,pParameters);
}

VOID Arch_Nv01AllocContextDma(VOID *pParameters) 
{
  NvIoControl(NVRM_DLL32_NV01ALLOCCONTEXTDMA,pParameters);
}

VOID Arch_Nv01AllocChannelPio(VOID *pParameters) 
{
  NvIoControl(NVRM_DLL32_NV01ALLOCCHANNELPIO,pParameters);
}

VOID Arch_Nv01AllocObject(VOID *pParameters)     
{
  NvIoControl(NVRM_DLL32_NV01ALLOCOBJECT,pParameters);
}

VOID Arch_Nv01AllocMemory(VOID *pParameters)     
{
  NvIoControl(NVRM_DLL32_NV01ALLOCMEMORY,pParameters);
}

VOID Arch_Nv01Interrupt(VOID *pParameters)       
{
  NvIoControl(NVRM_DLL32_NV01INTERRUPT,pParameters);
}

VOID Arch_Nv01AllocEvent(VOID *pParameters)      
{
  NvIoControl(NVRM_DLL32_NV01ALLOCEVENT,pParameters);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\inc16\ENVIRON.H ===
#ifndef _ENVIRON_H_
#define _ENVIRON_H_
/*************************** OS Specific Module ****************************\
*                                                                           *
* Module: ENVIRON.H                                                         *
*       WATCOM and Windows specific defines and pragmas.                    *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       David Schmenk (dschmenk)     1/06/95 - copied from nvrm.h.          *
*                                                                           *
\***************************************************************************/

#endif // _ENVIRON_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\dll32\nvapi32.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-1997 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-1997  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************* Operating System Interface Routines *******************\
*                                                                           *
* Module: NVAPI.C                                                           *
*   This is the Windows half of the Resource Manager.  System clients call  *
*   the Resource Manager through these APIS.  The VxD calls into this       *
*   to post a message to the Windows Resource Manager EXE.                  *
*                                                                           *
\***************************************************************************/

#include <windows.h>
//
// NvClient API to Resource Manager.
//
#include <nvwin32.h>
#include <nvrmwin.h>
#include <nv_ref.h>
//#include <nvcm.h>

//
// pragmas
//
#pragma warning(disable : 4035)

//---------------------------------------------------------------------------
//
//  Defines.
//
//---------------------------------------------------------------------------
#define NV_CFG_VBLANK_STATUS        500
#define NV_CFG_GE_STATUS            501
#define NV_CFG_CURRENT_SCANLINE     502
#define NUM_CLIENTS                 16
#define NUM_FIFOS                   32

// need these defines for the inline assembly
#define RegEDI	16
#define RegDS	28
#define RegCS	32

//---------------------------------------------------------------------------
//
//  Typedefs.
//
//---------------------------------------------------------------------------
typedef struct _def_rmParams FAR *LPRMPARAMS;

//---------------------------------------------------------------------------
//
//  Prototypes.
//
//---------------------------------------------------------------------------

//
// Prototype of dispatch routine.
//
DWORD FAR PASCAL _Nv32Dispatch(LPRMPARAMS, DWORD);
BOOL _stdcall THK_ThunkConnect32(LPSTR, LPSTR, HINSTANCE, DWORD);
DWORD PASCAL NvSysDispatch(LPRMPARAMS, DWORD);

//---------------------------------------------------------------------------
//
//  Data.
//
//---------------------------------------------------------------------------
DWORD dll32_DeviceInstance=0;
// Linear address of the chip
DWORD *pNv = NULL;

//---------------------------------------------------------------------------
//
//  Nv non-client entrypoints.
//
//---------------------------------------------------------------------------

//
// DLL initialization and termination routine.
//
BOOL APIENTRY DllMain
(
    HANDLE hInstance,
    DWORD  dwReason,
    LPSTR  lpszCmdLine
)
{
    static INT AttachCount = 0;

    if (!(THK_ThunkConnect32("NVARCH16.DLL", "NVARCH32.DLL", hInstance, dwReason)))
        return (FALSE);

    switch (dwReason)
    {
        case DLL_PROCESS_ATTACH:
            ++AttachCount;
            break;
        case DLL_PROCESS_DETACH:
            //_Nv32Dispatch(&NvParams, 3);  // Don't detach since OGL is actually multiple links
            --AttachCount;
            break;
    }
    return (TRUE);
}
//
// Dispatcher to Resource Manager.
//
DWORD PASCAL _Nv32Dispatch
(
    LPRMPARAMS lpParams,
    DWORD      Function
)
{
    //
    // Copy the flat selectors to the parameter list for the 16 bit
    // dispatcher to use.
    //
    _asm mov edi, lpParams
    _asm xor eax, eax
    _asm mov ax, ds
    _asm mov [edi].RegDS, eax
    _asm mov ax, cs
    _asm mov [edi].RegCS, eax
    _asm mov eax, dll32_DeviceInstance
    _asm mov [edi].RegEDI, eax 
    NvSysDispatch(lpParams, Function);
}

//---------------------------------------------------------------------------
//
//  Nv client entrypoints.
//
//---------------------------------------------------------------------------
int __stdcall Nv32SetDeviceInstance(DWORD DeviceHandle)
{
  dll32_DeviceInstance = DeviceHandle;
  return(0);
}

int __stdcall NvGetFlatDataSelector
(
    void
)
{
    DWORD Selector;

    _asm xor eax, eax
    _asm mov ax, ds
    _asm mov Selector, eax
    return (Selector);
}
int __stdcall NvGetFlatCodeSelector
(
    void
)
{
    DWORD Selector;

    _asm xor eax, eax
    _asm mov ax, cs
    _asm mov Selector, eax
    return (Selector);
}

//---------------------------------------------------------------------------
//
//  Nv configuration manager entrypoints.
//
//---------------------------------------------------------------------------

int __stdcall NvConfigVersion
(
    void
)
{
    RMPARAMS NvParams;

    _Nv32Dispatch(&NvParams, NV_FUNCTION_NVCONFIGVERSION);
    return (NvParams.RegEAX);
}
int __stdcall NvConfigGet
(
    DWORD Index,
    DWORD DeviceHandle
)
{
    RMPARAMS NvParams;

    //
    // If this is a different device than the last call, flush
    // the chip pointer
    //
    if (DeviceHandle != dll32_DeviceInstance)
        pNv = NULL;
        
    Nv32SetDeviceInstance(DeviceHandle);

    //
    // Watch for indices that we want to handle right here in 32bit.  Thunking down
    // to the 16bit DLL takes too long for some DCT flipping tests that are very
    // timing sensitive.
    //
    switch (Index)
    {
        case NV_CFG_VBLANK_STATUS:
            if (pNv == NULL)
            {
                //
                // Get a pointer to this chip
                //
				NvParams.RegESI = DeviceHandle-1;
                _Nv32Dispatch(&NvParams, NV_FUNCTION_NVSYSGETHWPTRS);
                pNv = (DWORD *)NvParams.RegEAX;
            }
            //
            // Grab the VBLANK status bit
            //
            NvParams.RegEAX = (((U032)*(pNv + (NV_PCRTC_RASTER/4))) & 0x00010000) >> 16;
                    
            break;
            
        case NV_CFG_CURRENT_SCANLINE:
            if (pNv == NULL)
            {
                //
                // Get a pointer to this chip
                //
				NvParams.RegESI = DeviceHandle-1;
                _Nv32Dispatch(&NvParams, NV_FUNCTION_NVSYSGETHWPTRS);
                pNv = (DWORD *)NvParams.RegEAX;
            }
            //
            // Grab the current scanline value
            //
            NvParams.RegEAX = ((U032)*(pNv + (NV_PCRTC_RASTER/4))) & 0x7FF;
            break;
            
        default:
    
            NvParams.RegEAX = Index;
			NvParams.RegESI = DeviceHandle-1;
            _Nv32Dispatch(&NvParams, NV_FUNCTION_NVCONFIGGET);
            break;
    }
            
    return (NvParams.RegEAX);
}
int __stdcall NvConfigSet
(
    DWORD Index,
    DWORD Value,
    DWORD DeviceHandle
)
{
    RMPARAMS NvParams;
    
    Nv32SetDeviceInstance(DeviceHandle);

    NvParams.RegEAX = Index;
    NvParams.RegEBX = Value;
	NvParams.RegESI = DeviceHandle-1;
    _Nv32Dispatch(&NvParams, NV_FUNCTION_NVCONFIGSET);
    return (NvParams.RegEAX);
}
int __stdcall NvConfigUpdate
(
    DWORD Flag,
    DWORD DeviceHandle
)
{
    RMPARAMS NvParams;

    Nv32SetDeviceInstance(DeviceHandle);

    NvParams.RegEAX = Flag;
	NvParams.RegESI = DeviceHandle-1;
    _Nv32Dispatch(&NvParams, NV_FUNCTION_NVCONFIGUPDATE);
    return (NvParams.RegEAX);
}

//---------------------------------------------------------------------------
//
//  Nv device manager entrypoints.
//
//---------------------------------------------------------------------------

int __stdcall NvGetHardwarePointers
(
    DWORD *pNv1,
    DWORD *pAlternate,
    DWORD *pFramebuffer,
    DWORD *pTimer
)
{
    RMPARAMS NvParams;
    
    //
    // Get all the hardware pointers.
    //
    _Nv32Dispatch(&NvParams, NV_FUNCTION_NVSYSGETHWPTRS);
    if (pNv1)         *pNv1         = NvParams.RegEAX;
    if (pAlternate)   *pAlternate   = NvParams.RegEBX;
    if (pFramebuffer) *pFramebuffer = NvParams.RegECX;
    if (pTimer)       *pTimer       = NvParams.RegEDX;
}
int __stdcall NvDeviceBaseGet
(
    DWORD Index,
    DWORD DeviceHandle
)
{
    RMPARAMS NvParams;

    Nv32SetDeviceInstance(DeviceHandle);

    NvParams.RegEAX = Index;
	NvParams.RegESI = DeviceHandle-1;
    _Nv32Dispatch(&NvParams, NV_FUNCTION_NVDEVICEBASEGET);
    return (NvParams.RegEAX);
}
int __stdcall NvDeviceLimitGet
(
    DWORD Index,
    DWORD DeviceHandle
)
{
    RMPARAMS NvParams;

    Nv32SetDeviceInstance(DeviceHandle);
    
    NvParams.RegEAX = Index;
	NvParams.RegESI = DeviceHandle-1;
    _Nv32Dispatch(&NvParams, NV_FUNCTION_NVDEVICELIMITGET);
    return (NvParams.RegEAX);
}
int __stdcall NvDeviceSelectorGet
(
    DWORD Index
)
{
    RMPARAMS NvParams;

    NvParams.RegEAX = Index;
    _Nv32Dispatch(&NvParams, NV_FUNCTION_NVDEVICESELECTORGET);
    return (NvParams.RegEAX);
}

//---------------------------------------------------------------------------
//
//  Nv system DLL entrypoints.
//
//---------------------------------------------------------------------------

void __stdcall NvSysShowHideCursor
(
    int HideShow
)
{
    RMPARAMS NvParams;

    NvParams.RegEAX = HideShow;
    _Nv32Dispatch(&NvParams, NV_FUNCTION_NVSYSSHOWHIDECRSR);
}

int __stdcall NvDmaPushOperation
(
    U032  flags,
    VOID  *pDmaPushInfo,
    DWORD DeviceHandle
)
{
    RMPARAMS NvParams;
    
    Nv32SetDeviceInstance(DeviceHandle);

	NvParams.RegESI = DeviceHandle-1;
    NvParams.RegEAX = NVRM_API_DMAPUSH_OPERATION;
    NvParams.RegEBX = flags;
    NvParams.RegECX = (U032) pDmaPushInfo;
    NvParams.RegES  = NvGetFlatDataSelector();

    _Nv32Dispatch(&NvParams, 0);

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\inc16\DCIMAN.H ===
/****************************************************************************

 DCIMAN.H

 Copyright (C) 1993-1994 Microsoft Corporation.  All Rights Reserved.

 DCIMAN 1.0 client interface definitions

 ***************************************************************************/

#ifndef _INC_DCIMAN
#define _INC_DCIMAN

#ifdef __cplusplus
    #define __inline inline
    extern "C" {
#endif

/****************************************************************************
 ***************************************************************************/

#include "dciddi.h"         // interface to the DCI provider

/****************************************************************************
 ***************************************************************************/

DECLARE_HANDLE(HWINWATCH);  // context handle for WinWatch instance

/****************************************************************************
 ***************************************************************************/

extern HWINWATCH WINAPI WinWatchOpen(HWND hwnd);
extern void      WINAPI WinWatchClose(HWINWATCH hWW);

// API changed to copy region data instead of return pointer to it
extern UINT	 WINAPI WinWatchGetClipList(HWINWATCH hWW, LPRECT prc,
				UINT size,  LPRGNDATA prd);
extern BOOL      WINAPI WinWatchDidStatusChange(HWINWATCH hWW);

extern DWORD     WINAPI GetWindowRegionData(HWND hwnd, DWORD size, LPRGNDATA prd);
extern DWORD     WINAPI GetDCRegionData(HDC hdc, DWORD size, LPRGNDATA prd);


#define WINWATCHNOTIFY_START        0
#define WINWATCHNOTIFY_STOP         1
#define WINWATCHNOTIFY_DESTROY      2
#define WINWATCHNOTIFY_CHANGING     3
#define WINWATCHNOTIFY_CHANGED      4
typedef void (CALLBACK *WINWATCHNOTIFYPROC)(HWINWATCH hww, HWND hwnd, DWORD code, LPARAM lParam);

extern BOOL WINAPI WinWatchNotify(HWINWATCH hWW, WINWATCHNOTIFYPROC NotifyCallback,
						LPARAM NotifyParam );

#ifndef DCI_HAS_STUPID_H_FILE


extern HDC WINAPI DCIOpenProvider(void);
extern void WINAPI DCICloseProvider(HDC hdc);

extern int WINAPI DCICreatePrimary(HDC hdc, LPDCISURFACEINFO FAR *lplpSurface);
extern int WINAPI DCICreateOffscreen(HDC hdc, DWORD dwCompression, DWORD dwRedMask,
    DWORD dwGreenMask, DWORD dwBlueMask, DWORD dwWidth, DWORD dwHeight, 
    DWORD dwDCICaps, DWORD dwBitCount, LPDCIOFFSCREEN FAR *lplpSurface);
extern int WINAPI DCICreateOverlay(HDC hdc, LPVOID lpOffscreenSurf, 
    LPDCIOVERLAY FAR *lplpSurface);
extern int WINAPI DCIEnum(HDC hdc, LPRECT lprDst, LPRECT lprSrc, LPVOID lpFnCallback,
    LPVOID lpContext);
extern DCIRVAL WINAPI DCISetSrcDestClip(LPDCIOFFSCREEN pdci, LPRECT srcrc,
			LPRECT destrc, LPRGNDATA prd );

#ifdef WIN32
/****************************************************************************
 helper functions to call DCIMAN16.DLL
 ***************************************************************************/
extern void WINAPI DCIEndAccess(LPDCISURFACEINFO pdci);
extern DCIRVAL WINAPI DCIBeginAccess(LPDCISURFACEINFO pdci, int x, int y, int dx, int dy);
extern void WINAPI DCIDestroy(LPDCISURFACEINFO pdci);
extern DCIRVAL WINAPI DCIDraw(LPDCIOFFSCREEN pdci);
extern DCIRVAL WINAPI DCISetClipList(LPDCIOFFSCREEN pdci, LPRGNDATA prd);
extern DCIRVAL WINAPI DCISetDestination(LPDCIOFFSCREEN pdci, LPRECT dst, LPRECT src);


#else

extern int WINAPI DCISendCommand(HDC hdc, VOID FAR *pcmd, int nSize, VOID FAR * FAR * lplpOut);

/****************************************************************************
 helper macros to call DCI callbacks
 ***************************************************************************/
__inline void DCIDestroy(LPDCISURFACEINFO pdci)
{
	if( pdci->DestroySurface != NULL ) {
		pdci->DestroySurface(pdci);
	}
}

__inline void DCIEndAccess(LPDCISURFACEINFO pdci)
{
	if( pdci->EndAccess != NULL ) {
		pdci->EndAccess(pdci);
	}
}

__inline DCIRVAL DCIBeginAccess(LPDCISURFACEINFO pdci, int x, int y, int dx, int dy)
{
    RECT rc;

	if( pdci->BeginAccess != NULL ) {
		rc.left=x;
		rc.top=y;
		rc.right = rc.left+dx;
		rc.bottom = rc.top+dy;
		return pdci->BeginAccess(pdci, &rc);
	} else {
		return DCI_OK;
	}
}

__inline DCIRVAL DCIDraw(LPDCIOFFSCREEN pdci)
{
	if( pdci->Draw != NULL ) {
		return pdci->Draw(pdci);
	} else {
		return DCI_OK;
	}
}

__inline DCIRVAL DCISetClipList(LPDCIOFFSCREEN pdci, LPRGNDATA prd)
{
	if( pdci->SetClipList != NULL ) {
		return pdci->SetClipList(pdci, prd);
	} else {
		return DCI_OK;
	}
}

__inline DCIRVAL DCISetDestination(LPDCIOFFSCREEN pdci, LPRECT dst, LPRECT src)
{
	if( pdci->SetDestination != NULL ) {
		return pdci->SetDestination(pdci, dst, src);
	} else {
		return DCI_OK;
	}
}
#endif
#endif // DCI_HAS_STUPID_H_FILE

/****************************************************************************
 ***************************************************************************/

#ifdef __cplusplus
    }
#endif

#endif // _INC_DCIMAN
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\inc16\VER.H ===
/*****************************************************************************\
*                                                                             *
* ver.h -       Version management functions, types, and definitions          *
*                                                                             *
*               Include file for VER.DLL and VER.LIB.  These libraries are    *
*               designed to allow version stamping of Windows executable files*
*               and of special .VER files for DOS executable files.           *
*                                                                             *
*               The API is unchanged for LIB and DLL versions.                *
*                                                                             *
*               Copyright (c) 1992, Microsoft Corp.  All rights reserved      *
*                                                                             *
*******************************************************************************
*
* #define LIB   - To be used with VER.LIB (default is for VER.DLL)
*
\*****************************************************************************/

#ifndef _INC_VER
#define _INC_VER

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif /* RC_INVOKED */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */

/*
 * If .lib version is being used, declare types used in this file.
 */
#ifdef LIB

#ifndef WINAPI                      /* don't declare if they're already declared */
#define WINAPI      _far _pascal
#define NEAR        _near
#define FAR         _far
#define PASCAL      _pascal
typedef int             BOOL;
#define TRUE        1
#define FALSE       0
typedef unsigned char   BYTE;
typedef unsigned short  WORD;
typedef unsigned int    UINT;
typedef signed long     LONG;
typedef unsigned long   DWORD;
typedef char far*       LPSTR;
typedef const char far* LPCSTR;
typedef int             HFILE;
#define OFSTRUCT    void            /* Not used by the .lib version */
#define LOWORD(l)		((WORD)(l))
#define HIWORD(l)		((WORD)(((DWORD)(l) >> 16) & 0xFFFF))
#define MAKEINTRESOURCE(i)	(LPSTR)((DWORD)((WORD)(i)))
#endif  /* WINAPI */

#else   /* LIB */

/* If .dll version is being used and we're being included with
 * the 3.0 windows.h, #define compatible type aliases.
 * If included with the 3.0 windows.h, #define compatible aliases
 */
#ifndef _INC_WINDOWS
#define UINT        WORD
#define LPCSTR      LPSTR
#define HFILE       int
#endif  /* !_INC_WINDOWS */

#endif  /* !LIB */

/* ----- RC defines ----- */
#ifdef RC_INVOKED
#define ID(id)			id
#else
#define ID(id)			MAKEINTRESOURCE(id)
#endif

/* ----- Symbols ----- */
#define VS_FILE_INFO		ID(16)		/* Version stamp res type */
#define VS_VERSION_INFO		ID(1)  		/* Version stamp res ID */
#define VS_USER_DEFINED		ID(100)		/* User-defined res IDs */

/* ----- VS_VERSION.dwFileFlags ----- */
#define	VS_FFI_SIGNATURE	0xFEEF04BDL
#define	VS_FFI_STRUCVERSION	0x00010000L
#define	VS_FFI_FILEFLAGSMASK	0x0000003FL

/* ----- VS_VERSION.dwFileFlags ----- */
#define	VS_FF_DEBUG		0x00000001L
#define	VS_FF_PRERELEASE	0x00000002L
#define	VS_FF_PATCHED		0x00000004L
#define	VS_FF_PRIVATEBUILD	0x00000008L
#define	VS_FF_INFOINFERRED	0x00000010L
#define	VS_FF_SPECIALBUILD	0x00000020L

/* ----- VS_VERSION.dwFileOS ----- */
#define	VOS_UNKNOWN		0x00000000L
#define	VOS_DOS			0x00010000L
#define	VOS_OS216		0x00020000L
#define	VOS_OS232		0x00030000L
#define	VOS_NT			0x00040000L

#define	VOS__BASE		0x00000000L
#define	VOS__WINDOWS16		0x00000001L
#define	VOS__PM16		0x00000002L
#define	VOS__PM32		0x00000003L
#define	VOS__WINDOWS32		0x00000004L

#define	VOS_DOS_WINDOWS16	0x00010001L
#define	VOS_DOS_WINDOWS32	0x00010004L
#define	VOS_OS216_PM16		0x00020002L
#define	VOS_OS232_PM32		0x00030003L
#define	VOS_NT_WINDOWS32	0x00040004L

/* ----- VS_VERSION.dwFileType ----- */
#define	VFT_UNKNOWN		0x00000000L
#define	VFT_APP			0x00000001L
#define	VFT_DLL			0x00000002L
#define	VFT_DRV			0x00000003L
#define	VFT_FONT		0x00000004L
#define	VFT_VXD			0x00000005L
#define	VFT_STATIC_LIB		0x00000007L

/* ----- VS_VERSION.dwFileSubtype for VFT_WINDOWS_DRV ----- */
#define	VFT2_UNKNOWN		0x00000000L
#define VFT2_DRV_PRINTER	0x00000001L
#define	VFT2_DRV_KEYBOARD	0x00000002L
#define	VFT2_DRV_LANGUAGE	0x00000003L
#define	VFT2_DRV_DISPLAY	0x00000004L
#define	VFT2_DRV_MOUSE		0x00000005L
#define	VFT2_DRV_NETWORK	0x00000006L
#define	VFT2_DRV_SYSTEM		0x00000007L
#define	VFT2_DRV_INSTALLABLE	0x00000008L
#define	VFT2_DRV_SOUND		0x00000009L
#define	VFT2_DRV_COMM		0x0000000AL

/* ----- VS_VERSION.dwFileSubtype for VFT_WINDOWS_FONT ----- */
#define VFT2_FONT_RASTER	0x00000001L
#define	VFT2_FONT_VECTOR	0x00000002L
#define	VFT2_FONT_TRUETYPE	0x00000003L

/* ----- VerFindFile() flags ----- */
#define VFFF_ISSHAREDFILE	0x0001

#define VFF_CURNEDEST		0x0001
#define VFF_FILEINUSE		0x0002
#define VFF_BUFFTOOSMALL	0x0004

/* ----- VerInstallFile() flags ----- */
#define VIFF_FORCEINSTALL	0x0001
#define VIFF_DONTDELETEOLD	0x0002

#define VIF_TEMPFILE		0x00000001L
#define VIF_MISMATCH		0x00000002L
#define VIF_SRCOLD		0x00000004L

#define VIF_DIFFLANG		0x00000008L
#define VIF_DIFFCODEPG		0x00000010L
#define VIF_DIFFTYPE		0x00000020L

#define VIF_WRITEPROT		0x00000040L
#define VIF_FILEINUSE		0x00000080L
#define VIF_OUTOFSPACE		0x00000100L
#define VIF_ACCESSVIOLATION	0x00000200L
#define VIF_SHARINGVIOLATION	0x00000400L
#define VIF_CANNOTCREATE	0x00000800L
#define VIF_CANNOTDELETE	0x00001000L
#define VIF_CANNOTRENAME	0x00002000L
#define VIF_CANNOTDELETECUR	0x00004000L
#define VIF_OUTOFMEMORY		0x00008000L

#define VIF_CANNOTREADSRC	0x00010000L
#define VIF_CANNOTREADDST	0x00020000L

#define VIF_BUFFTOOSMALL	0x00040000L

#ifndef RC_INVOKED              /* RC doesn't need to see the rest of this */

/* ----- Types and structures ----- */

typedef signed short int SHORT;

typedef struct tagVS_FIXEDFILEINFO
{
    DWORD   dwSignature;            /* e.g. 0xfeef04bd */
    DWORD   dwStrucVersion;         /* e.g. 0x00000042 = "0.42" */
    DWORD   dwFileVersionMS;        /* e.g. 0x00030075 = "3.75" */
    DWORD   dwFileVersionLS;        /* e.g. 0x00000031 = "0.31" */
    DWORD   dwProductVersionMS;     /* e.g. 0x00030010 = "3.10" */
    DWORD   dwProductVersionLS;     /* e.g. 0x00000031 = "0.31" */
    DWORD   dwFileFlagsMask;        /* = 0x3F for version "0.42" */
    DWORD   dwFileFlags;            /* e.g. VFF_DEBUG | VFF_PRERELEASE */
    DWORD   dwFileOS;               /* e.g. VOS_DOS_WINDOWS16 */
    DWORD   dwFileType;             /* e.g. VFT_DRIVER */
    DWORD   dwFileSubtype;          /* e.g. VFT2_DRV_KEYBOARD */
    DWORD   dwFileDateMS;           /* e.g. 0 */
    DWORD   dwFileDateLS;           /* e.g. 0 */
} VS_FIXEDFILEINFO;

/* ----- Function prototypes ----- */

UINT WINAPI VerFindFile(UINT uFlags, LPCSTR szFileName,
      LPCSTR szWinDir, LPCSTR szAppDir,
      LPSTR szCurDir, UINT FAR* lpuCurDirLen,
      LPSTR szDestDir, UINT FAR* lpuDestDirLen);

DWORD WINAPI VerInstallFile(UINT uFlags,
      LPCSTR szSrcFileName, LPCSTR szDestFileName, LPCSTR szSrcDir,
      LPCSTR szDestDir, LPCSTR szCurDir, LPSTR szTmpFile, UINT FAR* lpuTmpFileLen);

/* Returns size of version info in bytes */
DWORD WINAPI GetFileVersionInfoSize(
      LPCSTR lpstrFilename,     /* Filename of version stamped file */
      DWORD FAR *lpdwHandle);   /* Information for use by GetFileVersionInfo */

/* Read version info into buffer */
BOOL WINAPI GetFileVersionInfo(
      LPCSTR lpstrFilename,     /* Filename of version stamped file */
      DWORD dwHandle,           /* Information from GetFileVersionSize */
      DWORD dwLen,              /* Length of buffer for info */
      void FAR* lpData);        /* Buffer to place the data structure */

/* Returns size of resource in bytes */
DWORD WINAPI GetFileResourceSize(
      LPCSTR lpstrFilename,     /* Filename of version stamped file */
      LPCSTR lpstrResType,      /* Type:  normally VS_FILE_INFO */
      LPCSTR lpstrResID,        /* ID:  normally VS_VERSION_INFO */
      DWORD FAR *lpdwFileOffset); /* Returns file offset of resource */

/* Reads file resource into buffer */
BOOL WINAPI GetFileResource(
      LPCSTR lpstrFilename,     /* Filename of version stamped file */
      LPCSTR lpstrResType,      /* Type:  normally VS_FILE_INFO */
      LPCSTR lpstrResID,        /* ID:  normally VS_VERSION_INFO */
      DWORD dwFileOffset,       /* File offset or NULL */
      DWORD dwResLen,           /* Length of resource to read or NULL */
      void FAR* lpData);        /* Pointer to data buffer */

UINT WINAPI VerLanguageName(UINT wLang, LPSTR szLang, UINT nSize);

UINT WINAPI GetWindowsDir(LPCSTR szAppDir, LPSTR lpBuffer, int nSize);

UINT WINAPI GetSystemDir(LPCSTR szAppDir, LPSTR lpBuffer, int nSize);

BOOL WINAPI VerQueryValue(const void FAR* pBlock, LPCSTR lpSubBlock,
      void FAR* FAR* lplpBuffer, UINT FAR* lpuLen);

#ifdef __cplusplus
}
#endif	/* __cplusplus */

#pragma pack()

#endif  /* !RC_INVOKED */
#endif  /* !_INC_VER */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\inc16\W32SUT.H ===
/***
*w32sut.h -
*
*       Copyright (c) 1987-1992, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       This file declares the constants, structures, and functions
*       used for accessing and using the Universal Thunk mechanism.
*
*       This file should be compiled either with constants W32SUT_16 or
*       W32SUT_32 defined.
*
****/

/* Check that one of the 2 constants is defined  */
#ifdef W32SUT_16
#ifdef W32SUT_32
#error W32SUT_16 and W32SUT_32 cannot be defined simultaneously
#endif
#endif

#ifndef W32SUT_16
#ifndef W32SUT_32
#error  Either W32SUT_16 or W32SUT_32 should be defined
#endif
#endif


/****      Prototypes for 32 bit DLL   ***********/
#ifdef W32SUT_32

typedef DWORD  ( WINAPI * UT32PROC)( LPVOID lpBuff,
                                     DWORD  dwUserDefined,
                                     LPVOID *lpTranslationList
                                   );

BOOL    WINAPI UTRegister( HANDLE     hModule,
                           LPCSTR     lpsz16BitDLL,
                           LPCSTR     lpszInitName,
                           LPCSTR     lpszProcName,
                           UT32PROC * ppfn32Thunk,
                           FARPROC    pfnUT32Callback,
                           LPVOID     lpBuff
                         );


VOID    WINAPI UTUnRegister(HANDLE hModule);

#endif


/****      Prototypes for 16 bit DLL   ***********/
#ifdef W32SUT_16

typedef DWORD (FAR PASCAL  * UT16CBPROC)( LPVOID lpBuff,
                                          DWORD  dwUserDefined,
                                          LPVOID FAR *lpTranslationList
                                        );


LPVOID  WINAPI  UTLinearToSelectorOffset(LPBYTE lpByte);
LPVOID  WINAPI  UTSelectorOffsetToLinear(LPBYTE lpByte);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\inc16\WINDOWS.H ===
/****************************************************************************
 *
 *  WINDOWS.H - 
 *	
 *	Include file for Windows 3.0 applications
 *
 *  Copyright by WATCOM International Corp. 1988-1994.  All rights reserved.
 *
 ****************************************************************************/

#ifdef _WINDOWS_16_
#include <win16.h>
#else
#include <_win386.h>
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\inc16\STDDEF.H ===
/*
 *  stddef.h	Standard definitions
 *
 *  Copyright by WATCOM International Corp. 1988-1994.  All rights reserved.
 */
#ifndef _STDDEF_H_INCLUDED
#ifdef __cplusplus
extern "C" {
#endif

#ifndef _SIZE_T_DEFINED_
#define _SIZE_T_DEFINED_
 typedef unsigned size_t;
#endif

#ifndef _WCHAR_T_DEFINED_
#define _WCHAR_T_DEFINED_
#ifdef __cplusplus
typedef long char wchar_t;
#else
typedef unsigned short wchar_t;
#endif
#endif

#ifndef NULL
 #if defined(__SMALL__) || defined(__MEDIUM__) || defined(__386__)
  #define NULL   0
 #else
  #define NULL   0L
 #endif
#endif

#ifndef _PTRDIFF_T_DEFINED_
#define _PTRDIFF_T_DEFINED_
 #if defined(__HUGE__)
  typedef long	ptrdiff_t;
 #else
  typedef int	ptrdiff_t;
 #endif
#endif

#ifdef __cplusplus
#define offsetof __offsetof
#else
#define offsetof(typ,id) (size_t)&(((typ*)0)->id)
#endif
#if !defined(NO_EXT_KEYS) /* extensions enabled */
#ifdef __386__
 extern int *__threadid(void);	/* pointer to thread id */
 #define _threadid (__threadid())
#else
 extern int __far *_threadid;			/* pointer to thread id */
#endif
#endif
#define _STDDEF_H_INCLUDED
#ifdef __cplusplus
};
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\inc16\TOOLHELP.H ===
/*****************************************************************************\
*                                                                             *
* toolhelp.h -  toolhelp.dll functions, types, and definitions                *
*                                                                             *
*               Version 1.0                                                   *
*                                                                             *
*               NOTE: windows.h must be #included first                       *
*                                                                             *
*               Copyright (c) 1992, Microsoft Corp.  All rights reserved.     *
*                                                                             *
\*****************************************************************************/

#ifndef _INC_TOOLHELP
#define _INC_TOOLHELP

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */

#ifndef _INC_WINDOWS    /* If included with 3.0 headers... */
#define LPCSTR      LPSTR
#define WINAPI      FAR PASCAL
#define CALLBACK    FAR PASCAL
#define UINT        WORD
#define HMODULE     HANDLE
#define HINSTANCE   HANDLE
#define HLOCAL      HANDLE
#define HGLOBAL     HANDLE
#define HTASK       HANDLE
#endif  /* _INC_WINDOWS */

/****** General symbols ******************************************************/
#define MAX_DATA        11
#define MAX_PATH        255
#define MAX_MODULE_NAME 8 + 1
#define MAX_CLASSNAME   255

/****** Global heap walking ***************************************************/
typedef struct tagGLOBALINFO
{
    DWORD dwSize;
    WORD wcItems;
    WORD wcItemsFree;
    WORD wcItemsLRU;
} GLOBALINFO;

typedef struct tagGLOBALENTRY
{
    DWORD dwSize;
    DWORD dwAddress;
    DWORD dwBlockSize;
    HGLOBAL hBlock;
    WORD wcLock;
    WORD wcPageLock;
    WORD wFlags;
    BOOL wHeapPresent;
    HGLOBAL hOwner;
    WORD wType;
    WORD wData;
    DWORD dwNext;
    DWORD dwNextAlt;
} GLOBALENTRY;

/* GlobalFirst()/GlobalNext() flags */
#define GLOBAL_ALL      0
#define GLOBAL_LRU      1
#define GLOBAL_FREE     2

/* GLOBALENTRY.wType entries */
#define GT_UNKNOWN      0
#define GT_DGROUP       1
#define GT_DATA         2
#define GT_CODE         3
#define GT_TASK         4
#define GT_RESOURCE     5
#define GT_MODULE       6
#define GT_FREE         7
#define GT_INTERNAL     8
#define GT_SENTINEL     9
#define GT_BURGERMASTER 10

/* If GLOBALENTRY.wType==GT_RESOURCE, the following is GLOBALENTRY.wData: */
#define GD_USERDEFINED      0
#define GD_CURSORCOMPONENT  1
#define GD_BITMAP           2
#define GD_ICONCOMPONENT    3
#define GD_MENU             4
#define GD_DIALOG           5
#define GD_STRING           6
#define GD_FONTDIR          7
#define GD_FONT             8
#define GD_ACCELERATORS     9
#define GD_RCDATA           10
#define GD_ERRTABLE         11
#define GD_CURSOR           12
#define GD_ICON             14
#define GD_NAMETABLE        15
#define GD_MAX_RESOURCE     15

/* GLOBALENTRY.wFlags */
#define GF_PDB_OWNER        0x0100      /* Low byte is KERNEL flags */

BOOL    WINAPI GlobalInfo(GLOBALINFO FAR* lpGlobalInfo);
BOOL    WINAPI GlobalFirst(GLOBALENTRY FAR* lpGlobal, WORD wFlags);
BOOL    WINAPI GlobalNext(GLOBALENTRY FAR* lpGlobal, WORD wFlags);
BOOL    WINAPI GlobalEntryHandle(GLOBALENTRY FAR* lpGlobal, HGLOBAL hItem);
BOOL    WINAPI GlobalEntryModule(GLOBALENTRY FAR* lpGlobal, HMODULE hModule, WORD wSeg);
WORD    WINAPI GlobalHandleToSel(HGLOBAL hMem);

/****** Local heap walking ***************************************************/

typedef struct tagLOCALINFO
{
    DWORD dwSize;
    WORD wcItems;
} LOCALINFO;

typedef struct tagLOCALENTRY
{
    DWORD dwSize;
    HLOCAL hHandle;
    WORD wAddress;
    WORD wSize;
    WORD wFlags;
    WORD wcLock;
    WORD wType;
    WORD hHeap;
    WORD wHeapType;
    WORD wNext;
} LOCALENTRY;

/* LOCALENTRY.wHeapType flags */
#define NORMAL_HEAP     0
#define USER_HEAP       1
#define GDI_HEAP        2

/* LOCALENTRY.wFlags */
#define LF_FIXED        1
#define LF_FREE         2
#define LF_MOVEABLE     4

/* LOCALENTRY.wType */
#define LT_NORMAL                   0
#define LT_FREE                     0xff
#define LT_GDI_PEN                  1   /* LT_GDI_* is for GDI's heap */
#define LT_GDI_BRUSH                2
#define LT_GDI_FONT                 3
#define LT_GDI_PALETTE              4
#define LT_GDI_BITMAP               5
#define LT_GDI_RGN                  6
#define LT_GDI_DC                   7
#define LT_GDI_DISABLED_DC          8
#define LT_GDI_METADC               9
#define LT_GDI_METAFILE             10
#define LT_GDI_MAX                  LT_GDI_METAFILE
#define LT_USER_CLASS               1   /* LT_USER_* is for USER's heap */
#define LT_USER_WND                 2
#define LT_USER_STRING              3
#define LT_USER_MENU                4
#define LT_USER_CLIP                5
#define LT_USER_CBOX                6
#define LT_USER_PALETTE             7
#define LT_USER_ED                  8
#define LT_USER_BWL                 9
#define LT_USER_OWNERDRAW           10
#define LT_USER_SPB                 11
#define LT_USER_CHECKPOINT          12
#define LT_USER_DCE                 13
#define LT_USER_MWP                 14
#define LT_USER_PROP                15
#define LT_USER_LBIV                16
#define LT_USER_MISC                17
#define LT_USER_ATOMS               18
#define LT_USER_LOCKINPUTSTATE      19
#define LT_USER_HOOKLIST            20
#define LT_USER_USERSEEUSERDOALLOC  21
#define LT_USER_HOTKEYLIST          22
#define LT_USER_POPUPMENU           23
#define LT_USER_HANDLETABLE         32
#define LT_USER_MAX                 LT_USER_HANDLETABLE

BOOL    WINAPI LocalInfo(LOCALINFO FAR* lpLocal, HGLOBAL hHeap);
BOOL    WINAPI LocalFirst(LOCALENTRY FAR* lpLocal, HGLOBAL hHeap);
BOOL    WINAPI LocalNext(LOCALENTRY FAR* lpLocal);

/****** Stack Tracing ********************************************************/

typedef struct tagSTACKTRACEENTRY
{
    DWORD dwSize;
    HTASK hTask;
    WORD wSS;
    WORD wBP;
    WORD wCS;
    WORD wIP;
    HMODULE hModule;
    WORD wSegment;
    WORD wFlags;
} STACKTRACEENTRY;

/* STACKTRACEENTRY.wFlags values */
#define FRAME_FAR       0
#define FRAME_NEAR      1

BOOL    WINAPI StackTraceFirst(STACKTRACEENTRY FAR* lpStackTrace, HTASK hTask);
BOOL    WINAPI StackTraceCSIPFirst(STACKTRACEENTRY FAR* lpStackTrace,
            WORD wSS, WORD wCS, WORD wIP, WORD wBP);
BOOL    WINAPI StackTraceNext(STACKTRACEENTRY FAR* lpStackTrace);

/****** Module list walking **************************************************/

typedef struct tagMODULEENTRY
{
    DWORD dwSize;
    char szModule[MAX_MODULE_NAME + 1];
    HMODULE hModule;
    WORD wcUsage;
    char szExePath[MAX_PATH + 1];
    WORD wNext;
} MODULEENTRY;

BOOL    WINAPI ModuleFirst(MODULEENTRY FAR* lpModule);
BOOL    WINAPI ModuleNext(MODULEENTRY FAR* lpModule);
HMODULE WINAPI ModuleFindName(MODULEENTRY FAR* lpModule, LPCSTR lpstrName);
HMODULE WINAPI ModuleFindHandle(MODULEENTRY FAR* lpModule, HMODULE hModule);

/****** Task list walking *****************************************************/

typedef struct tagTASKENTRY
{
    DWORD dwSize;
    HTASK hTask;
    HTASK hTaskParent;
    HINSTANCE hInst;
    HMODULE hModule;
    WORD wSS;
    WORD wSP;
    WORD wStackTop;
    WORD wStackMinimum;
    WORD wStackBottom;
    WORD wcEvents;
    HGLOBAL hQueue;
    char szModule[MAX_MODULE_NAME + 1];
    WORD wPSPOffset;
    HANDLE hNext;
} TASKENTRY;

BOOL    WINAPI TaskFirst(TASKENTRY FAR* lpTask);
BOOL    WINAPI TaskNext(TASKENTRY FAR* lpTask);
BOOL    WINAPI TaskFindHandle(TASKENTRY FAR* lpTask, HTASK hTask);
DWORD   WINAPI TaskSetCSIP(HTASK hTask, WORD wCS, WORD wIP);
DWORD   WINAPI TaskGetCSIP(HTASK hTask);
BOOL    WINAPI TaskSwitch(HTASK hTask, DWORD dwNewCSIP);

/****** Window Class enumeration **********************************************/

typedef struct tagCLASSENTRY
{
    DWORD dwSize;
    HMODULE hInst;              /* This is really an hModule */
    char szClassName[MAX_CLASSNAME + 1];
    WORD wNext;
} CLASSENTRY;

BOOL    WINAPI ClassFirst(CLASSENTRY FAR* lpClass);
BOOL    WINAPI ClassNext(CLASSENTRY FAR* lpClass);

/****** Information functions *************************************************/

typedef struct tagMEMMANINFO
{
    DWORD dwSize;
    DWORD dwLargestFreeBlock;
    DWORD dwMaxPagesAvailable;
    DWORD dwMaxPagesLockable;
    DWORD dwTotalLinearSpace;
    DWORD dwTotalUnlockedPages;
    DWORD dwFreePages;
    DWORD dwTotalPages;
    DWORD dwFreeLinearSpace;
    DWORD dwSwapFilePages;
    WORD wPageSize;
} MEMMANINFO;

BOOL    WINAPI MemManInfo(MEMMANINFO FAR* lpEnhMode);

typedef struct tagSYSHEAPINFO
{
    DWORD dwSize;
    WORD wUserFreePercent;
    WORD wGDIFreePercent;
    HGLOBAL hUserSegment;
    HGLOBAL hGDISegment;
} SYSHEAPINFO;

BOOL    WINAPI SystemHeapInfo(SYSHEAPINFO FAR* lpSysHeap);

/****** Interrupt Handling ****************************************************/

/* Hooked interrupts */
#define INT_DIV0            0
#define INT_1               1
#define INT_3               3
#define INT_UDINSTR         6
#define INT_STKFAULT        12
#define INT_GPFAULT         13
#define INT_BADPAGEFAULT    14
#define INT_CTLALTSYSRQ     256

/* TOOLHELP Interrupt callbacks registered with InterruptRegister should
 *  always be written in assembly language.  The stack frame is not 
 *  compatible with high level language conventions.
 *
 *  This stack frame looks as follows to the callback.  All registers
 *  should be preserved across this callback to allow restarting fault.
 *               ------------
 *               |   Flags  |  [SP + 0Eh]
 *               |    CS    |  [SP + 0Ch]
 *               |    IP    |  [SP + 0Ah]
 *               |  Handle  |  [SP + 08h]
 *               |Exception#|  [SP + 06h]
 *               |    AX    |  [SP + 04h]  AX Saved to allow MakeProcInstance
 *               |  Ret CS  |  [SP + 02h]
 *       SP--->  |  Ret IP  |  [SP + 00h]
 *               ------------
 */
BOOL    WINAPI InterruptRegister(HTASK hTask, FARPROC lpfnIntCallback);
BOOL    WINAPI InterruptUnRegister(HTASK hTask);

/*  Notifications:
 *      When a notification callback is called, two parameters are passed
 *      in:  a WORD, wID, and another DWORD, dwData.  wID is one of
 *      the values NFY_* below.  Callback routines should ignore unrecog-
 *      nized values to preserve future compatibility.  Callback routines
 *      are also passed a dwData value.  This may contain data or may be
 *      a FAR pointer to a structure, or may not be used depending on
 *      which notification is being received.
 *
 *      In all cases, if the return value of the callback is TRUE, the
 *      notification will NOT be passed on to other callbacks.  It has
 *      been handled.  This should be used sparingly and only with certain
 *      notifications.  Callbacks almost always return FALSE.
 */

/* NFY_UNKNOWN:  An unknown notification has been returned from KERNEL.  Apps
 *  should ignore these.
 */
#define NFY_UNKNOWN         0

/* NFY_LOADSEG:  dwData points to a NFYLOADSEG structure */
#define NFY_LOADSEG         1
typedef struct tagNFYLOADSEG
{
    DWORD dwSize;
    WORD wSelector;
    WORD wSegNum;
    WORD wType;             /* Low bit set if data seg, clear if code seg */
    WORD wcInstance;        /* Instance count ONLY VALID FOR DATA SEG */
    LPCSTR lpstrModuleName;
} NFYLOADSEG;

/* NFY_FREESEG:  LOWORD(dwData) is the selector of the segment being freed */
#define NFY_FREESEG         2

/* NFY_STARTDLL:  dwData points to a NFYLOADSEG structure */
#define NFY_STARTDLL        3
typedef struct tagNFYSTARTDLL
{
    DWORD dwSize;
    HMODULE hModule;
    WORD wCS;
    WORD wIP;
} NFYSTARTDLL;

/* NFY_STARTTASK:  dwData is the CS:IP of the start address of the task */
#define NFY_STARTTASK       4

/* NFY_EXITTASK:  The low byte of dwData contains the program exit code */
#define NFY_EXITTASK        5

/* NFY_DELMODULE:  LOWORD(dwData) is the handle of the module to be freed */
#define NFY_DELMODULE       6

/* NFY_RIP:  dwData points to a NFYRIP structure */
#define NFY_RIP             7
typedef struct tagNFYRIP
{
    DWORD dwSize;
    WORD wIP;
    WORD wCS;
    WORD wSS;
    WORD wBP;
    WORD wExitCode;
} NFYRIP;

/* NFY_TASKIN:  No data.  Callback should do GetCurrentTask() */
#define NFY_TASKIN          8

/* NFY_TASKOUT:  No data.  Callback should do GetCurrentTask() */
#define NFY_TASKOUT         9

/* NFY_INCHAR:  Return value from callback is used.  If NULL, mapped to 'i' */
#define NFY_INCHAR          10

/* NFY_OUTSTR:  dwData points to the string to be displayed */
#define NFY_OUTSTR          11

/* NFY_LOGERROR:  dwData points to a NFYLOGERROR struct */
#define NFY_LOGERROR        12
typedef struct tagNFYLOGERROR
{
    DWORD dwSize;
    UINT wErrCode;
    void FAR* lpInfo;       /* Error code-dependent */
} NFYLOGERROR;

/* NFY_LOGPARAMERROR:  dwData points to a NFYLOGPARAMERROR struct */
#define NFY_LOGPARAMERROR   13
typedef struct tagNFYLOGPARAMERROR
{
    DWORD dwSize;
    UINT wErrCode;
    FARPROC lpfnErrorAddr;
    void FAR* FAR* lpBadParam;
} NFYLOGPARAMERROR;

/* NotifyRegister() flags */
#define NF_NORMAL       0
#define NF_TASKSWITCH   1
#define NF_RIP          2

typedef BOOL (CALLBACK* LPFNNOTIFYCALLBACK)(WORD wID, DWORD dwData);

BOOL    WINAPI NotifyRegister(HTASK hTask, LPFNNOTIFYCALLBACK lpfn, WORD wFlags);
BOOL    WINAPI NotifyUnRegister(HTASK hTask);

/****** Miscellaneous *********************************************************/

void    WINAPI TerminateApp(HTASK hTask, WORD wFlags);

/* TerminateApp() flag values */
#define UAE_BOX     0
#define NO_UAE_BOX  1

DWORD   WINAPI MemoryRead(WORD wSel, DWORD dwOffset, void FAR* lpBuffer, DWORD dwcb);
DWORD   WINAPI MemoryWrite(WORD wSel, DWORD dwOffset, void FAR* lpBuffer, DWORD dwcb);

typedef struct tagTIMERINFO
{
    DWORD dwSize;
    DWORD dwmsSinceStart;
    DWORD dwmsThisVM;
} TIMERINFO;

BOOL    WINAPI TimerCount(TIMERINFO FAR* lpTimer);

#ifdef __cplusplus
}
#endif	/* __cplusplus */

#ifndef RC_INVOKED
#pragma pack()          /* Revert to default packing */
#endif

#endif /* !_INC_TOOLHELP */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\inc32\CDERR.H ===
/*****************************************************************************\
*                                                                             *
* cderr.h -     Common dialog error return codes                              *
*                                                                             *
* Version 1.0								      *
*                                                                             *
* Copyright (c) 1992-1995, Microsoft Corp.	All rights reserved.	      *
*                                                                             *
\*****************************************************************************/

#ifndef _INC_CDERR
#define _INC_CDERR

#define CDERR_DIALOGFAILURE   0xFFFF

#define CDERR_GENERALCODES     0x0000
#define CDERR_STRUCTSIZE       0x0001
#define CDERR_INITIALIZATION   0x0002
#define CDERR_NOTEMPLATE       0x0003
#define CDERR_NOHINSTANCE      0x0004
#define CDERR_LOADSTRFAILURE   0x0005
#define CDERR_FINDRESFAILURE   0x0006
#define CDERR_LOADRESFAILURE   0x0007
#define CDERR_LOCKRESFAILURE   0x0008
#define CDERR_MEMALLOCFAILURE  0x0009
#define CDERR_MEMLOCKFAILURE   0x000A
#define CDERR_NOHOOK           0x000B
#define CDERR_REGISTERMSGFAIL  0x000C

#define PDERR_PRINTERCODES     0x1000
#define PDERR_SETUPFAILURE     0x1001
#define PDERR_PARSEFAILURE     0x1002
#define PDERR_RETDEFFAILURE    0x1003
#define PDERR_LOADDRVFAILURE   0x1004
#define PDERR_GETDEVMODEFAIL   0x1005
#define PDERR_INITFAILURE      0x1006
#define PDERR_NODEVICES        0x1007
#define PDERR_NODEFAULTPRN     0x1008
#define PDERR_DNDMMISMATCH     0x1009
#define PDERR_CREATEICFAILURE  0x100A
#define PDERR_PRINTERNOTFOUND  0x100B
#define PDERR_DEFAULTDIFFERENT 0x100C

#define CFERR_CHOOSEFONTCODES  0x2000
#define CFERR_NOFONTS          0x2001
#define CFERR_MAXLESSTHANMIN   0x2002

#define FNERR_FILENAMECODES    0x3000
#define FNERR_SUBCLASSFAILURE  0x3001
#define FNERR_INVALIDFILENAME  0x3002
#define FNERR_BUFFERTOOSMALL   0x3003

#define FRERR_FINDREPLACECODES 0x4000
#define FRERR_BUFFERLENGTHZERO 0x4001

#define CCERR_CHOOSECOLORCODES 0x5000

#endif  /* !_INC_CDERR */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\inc16\_WIN386.H ===
/*
 *  Copyright by WATCOM International Corp. 1988-1994.  All rights reserved.

   Special include for 32-bit Windows 3.x

 */
#ifndef ___WIN386_INCLUDED__
#define ___WIN386_INCLUDED__
#ifdef __cplusplus
extern "C" {
#endif

#ifndef RC_INVOKED
#include <stddef.h>
#endif

#ifdef __WINDOWS_386__
#ifndef NOAUTOPROCS
typedef void __far *REALFARPROC;
#endif
#define int short
#define __huge
#define __far
#define __export

#define NOMINMAX
#include <win16.h>
#ifndef NOCOVERSENDS
#define SendMessage _Cover_SendMessage
#define SendDlgItemMessage _Cover_SendDlgItemMessage
#endif
#ifndef NOCOVERRC
#define RegisterClass _Cover_RegisterClass
#endif
#ifndef NOAUTOPROCS
#define CreateDialog 			_Cover_CreateDialog
#define CreateDialogIndirect 		_Cover_CreateDialogIndirect
#define CreateDialogParam 		_Cover_CreateDialogParam
#define CreateDialogIndirectParam 	_Cover_CreateDialogIndirectParam
#define DialogBox 			_Cover_DialogBox
#define DialogBoxIndirect 		_Cover_DialogBoxIndirect
#define DialogBoxParam 			_Cover_DialogBoxParam
#define DialogBoxIndirectParam 		_Cover_DialogBoxIndirectParam
#define EnumChildWindows 		_Cover_EnumChildWindows
#define EnumFonts 			_Cover_EnumFonts
#define EnumFontFamilies		_Cover_EnumFontFamilies
#define EnumMetaFile 			_Cover_EnumMetaFile
#define EnumObjects 			_Cover_EnumObjects
#define EnumProps 			_Cover_EnumProps
#define EnumTaskWindows 		_Cover_EnumTaskWindows
#define EnumWindows 			_Cover_EnumWindows
#define Escape	 			_Cover_Escape
#define FreeProcInstance 		_Cover_FreeProcInstance
#define GetClassLong 			_Cover_GetClassLong
#define GetWindowLong 			_Cover_GetWindowLong
#define GlobalNotify 			_Cover_GlobalNotify
#define GrayString 			_Cover_GrayString
#define LineDDA 			_Cover_LineDDA
#define MakeProcInstance 		_Cover_MakeProcInstance
#define SetClassLong 			_Cover_SetClassLong
#define SetResourceHandler 		_Cover_SetResourceHandler
#define SetTimer 			_Cover_SetTimer
#define SetWindowsHook 			_Cover_SetWindowsHook
#define SetWindowsHookEx		_Cover_SetWindowsHookEx
#define SetWindowLong 			_Cover_SetWindowLong
#endif
#else
#include <win16.h>
#endif
#define API WINAPI

#ifndef NOKERNEL
FARPROC API _16MakeProcInstance(FARPROC, HANDLE);
#if !defined(NOAUTOPROCS) && defined(__WINDOWS_386__)
FARPROC API _Cover_MakeProcInstance(REALFARPROC, HANDLE);
#endif
void	API _16FreeProcInstance(FARPROC);
void	API _Cover_FreeProcInstance(FARPROC);
void    API _16GetCodeInfo(FARPROC lpProc, LPVOID lpSegInfo);
HANDLE  API _16GetModuleHandle(LPSTR);
int     API _16GetModuleFileName(HANDLE, LPSTR, int);
int     API _16GetInstanceData(HANDLE, NPSTR, int);
FARPROC API _16GetProcAddress(HANDLE, LPSTR);
HANDLE  API _16LoadLibrary(LPSTR);
HANDLE  API _16LoadModule(LPSTR, LPVOID);
WORD    API _16WinExec(LPSTR, WORD);
void    API _16OutputDebugString(LPSTR);
#ifndef NOOPENFILE
int  API _16OpenFile(LPSTR, LPOFSTRUCT, WORD);
int  API _16GetTempFileName(BYTE, LPSTR, WORD, LPSTR);
#endif /* NOOPENFILE */
HANDLE API _16FindResource(HANDLE, LPSTR, LPSTR);
FARPROC API _16SetResourceHandler(HANDLE, LPSTR, FARPROC);
FARPROC API _Cover_SetResourceHandler(HANDLE, LPSTR, FARPROC);
#ifndef NOATOM
ATOM   API _16AddAtom(LPSTR);
ATOM   API _16FindAtom(LPSTR);
WORD   API _16GetAtomName(ATOM, LPSTR, int);
ATOM   API _16GlobalAddAtom(LPSTR);
ATOM   API _16GlobalFindAtom(LPSTR);
WORD   API _16GlobalGetAtomName(ATOM, LPSTR, int);
#endif /* NOATOM */
WORD API _16GetProfileInt(LPSTR, LPSTR, int);
int  API _16GetProfileString(LPSTR, LPSTR, LPSTR, LPSTR, int);
BOOL API _16WriteProfileString(LPSTR, LPSTR, LPSTR);
WORD API _16GetPrivateProfileInt(LPSTR, LPSTR, int, LPSTR);
int  API _16GetPrivateProfileString(LPSTR, LPSTR, LPSTR, LPSTR, int, LPSTR);
BOOL API _16WritePrivateProfileString(LPSTR, LPSTR, LPSTR, LPSTR);
WORD API _16GetWindowsDirectory(LPSTR,WORD);
WORD API _16GetSystemDirectory(LPSTR,WORD);
int   API _16AnsiToOem(LPSTR, LPSTR);
BOOL  API _16OemToAnsi(LPSTR, LPSTR);
void  API _16AnsiToOemBuff(LPSTR, LPSTR, int);
void  API _16OemToAnsiBuff(LPSTR, LPSTR, int);
LPSTR API _16AnsiUpper(LPSTR);
WORD  API _16AnsiUpperBuff(LPSTR, WORD);
LPSTR API _16AnsiLower(LPSTR);
WORD  API _16AnsiLowerBuff(LPSTR, WORD);
LPSTR API _16AnsiNext(LPSTR);
LPSTR API _16AnsiPrev(LPSTR, LPSTR);
#ifndef NOKEYBOARDINFO
int   API _16GetKeyNameText(LONG, LPSTR, int);
int   API _16ToAscii(WORD wVirtKey, WORD wScanCode, LPSTR lpKeyState, LPVOID lpChar, WORD wFlags);
#endif /* NOKEYBOARDINFO */
#ifndef NOMEMMGR
VOID API _16GlobalNotify(FARPROC);
VOID API _Cover_GlobalNotify(FARPROC);
#endif /* NOMEMMGR */

#endif /* NOKERNEL */

#ifndef NOGDI
#ifndef NODRAWTEXT
int  API _16DrawText(HDC, LPSTR, int, LPRECT, WORD);
#endif /* NODRAWTEXT */
HDC   API _16CreateDC(LPSTR, LPSTR, LPSTR, LPSTR);
HDC   API _16CreateIC(LPSTR, LPSTR, LPSTR, LPSTR);
BOOL API _16ExtTextOut(HDC, int, int, WORD, LPRECT, LPSTR, WORD, LPINT);
BOOL API _16Polyline(HDC, LPPOINT, int);
BOOL API _16Polygon(HDC, LPPOINT, int);
BOOL API _16PolyPolygon(HDC, LPPOINT, LPINT, int);
BOOL  API _16TextOut(HDC, int, int, LPSTR, int);
LONG  API _16TabbedTextOut(HDC, int, int, LPSTR, int, int, LPINT, int);
BOOL  API _16GetCharWidth(HDC, WORD, WORD, LPINT);
void  API _16LineDDA(int, int, int, int, FARPROC, LPARAM);
void  API _Cover_LineDDA(int, int, int, int, FARPROC, LPARAM);
HPEN API _16CreatePenIndirect( LPLOGPEN );
HBRUSH API _16CreateBrushIndirect( LPLOGBRUSH );
HBITMAP API _16CreateBitmap(int, int, UINT, UINT, LPSTR);
HBITMAP API _16CreateBitmapIndirect( LPBITMAP );
HBITMAP API _16CreateDIBitmap(HDC, LPBITMAPINFOHEADER, DWORD, LPSTR, LPBITMAPINFO, UINT);
LONG  API _16SetBitmapBits(HBITMAP, DWORD, LPSTR);
LONG  API _16GetBitmapBits(HBITMAP, LONG, LPSTR);
HFONT API _16CreateFont(int, int, int, int, int, BYTE, BYTE, BYTE, BYTE, BYTE, BYTE, BYTE, BYTE, LPSTR);
HFONT API _16CreateFontIndirect( LPLOGFONT );
HRGN API _16CreateRectRgnIndirect(LPRECT);
HRGN API _16CreateEllipticRgnIndirect(LPRECT);
HRGN API _16CreatePolygonRgn(LPPOINT, int, int);
HRGN API _16CreatePolyPolygonRgn(LPPOINT, LPINT, int, int);
int    API _16GetObject(HANDLE, int, LPSTR);
int  API _16GetClipBox(HDC, LPRECT);
int  API _16GetRgnBox(HRGN, LPRECT);
DWORD API _16GetTextExtent(HDC, LPSTR, int);
DWORD API _16GetTabbedTextExtent(HDC, LPSTR, int, int, LPINT);
HANDLE API _16GetMetaFile(LPSTR);
HANDLE API _16CopyMetaFile(HANDLE, LPSTR);
#ifndef NOMETAFILE
void API _16PlayMetaFileRecord(HDC, LPHANDLETABLE, LPMETARECORD, WORD);
BOOL API _16EnumMetaFile(HDC, LOCALHANDLE, FARPROC, LPSTR );
BOOL API _Cover_EnumMetaFile(HDC, LOCALHANDLE, FARPROC, LPSTR );
#endif
int API _16Escape(HDC, int, int, LPSTR, LPSTR);
int API _Cover_Escape(HDC, int, int, LPSTR, LPSTR);
int API _16EnumFonts(HDC, LPSTR, FARPROC, LPSTR);
int API _Cover_EnumFonts(HDC, LPSTR, FARPROC, LPSTR);
int API _Cover_EnumFontFamilies(HDC, LPSTR, FARPROC, LPSTR);
int API _16EnumObjects(HDC, int, FARPROC, LPSTR);
int API _Cover_EnumObjects(HDC, int, FARPROC, LPSTR);
int API _16GetTextFace(HDC, int, LPSTR);
#ifndef NOTEXTMETRIC
BOOL API _16GetTextMetrics(HDC, LPTEXTMETRIC );
#endif /* NOTEXTMETRIC */
int API _16SetEnvironment(LPSTR, LPSTR, WORD);
int API _16GetEnvironment(LPSTR, LPSTR, WORD);
BOOL API _16DPtoLP(HDC, LPPOINT, int);
BOOL API _16LPtoDP(HDC, LPPOINT, int);
HANDLE API _16CreateMetaFile(LPSTR);
int API _16SetDIBits(HDC,HANDLE,WORD,WORD,LPSTR,LPBITMAPINFO,WORD);
int API _16GetDIBits(HDC,HANDLE,WORD,WORD,LPSTR,LPBITMAPINFO,WORD);
int API _16SetDIBitsToDevice(HDC,WORD,WORD,WORD,WORD,
					WORD,WORD,WORD,WORD,
					LPSTR,LPBITMAPINFO,WORD);
int API _16StretchDIBits(HDC, WORD, WORD, WORD, WORD, WORD, WORD, WORD, WORD, LPSTR, LPBITMAPINFO, WORD, DWORD);
HPALETTE API _16CreatePalette (LPLOGPALETTE);
void API _16AnimatePalette(HPALETTE, WORD, WORD, LPPALETTEENTRY);
WORD API _16SetPaletteEntries(HPALETTE,WORD,WORD,LPPALETTEENTRY);
WORD API _16GetPaletteEntries(HPALETTE,WORD,WORD,LPPALETTEENTRY);
WORD API _16GetSystemPaletteEntries(HDC,WORD,WORD,LPPALETTEENTRY);
#endif /* NOGDI */

#ifndef NOUSER
/*
 * replace windows fns with c library ones
 */
#ifdef __WINDOWS_386__
#undef wsprintf
#undef wvsprintf
#define wsprintf sprintf
#define wvsprintf vsprintf
#ifndef NOLSTRING
#undef lstrcmp
#undef lstrcmpi
#undef lstrcpy
#undef lstrcat
#undef lstrlen
#define lstrcmp strcmp
#define lstrcmpi strcmpi
#define lstrcpy strcpy
#define lstrcat strcat
#define lstrlen strlen
#endif /* NOLSTRING */
#endif
#ifndef NOWINMESSAGES
WORD API _16RegisterWindowMessage(LPSTR);
#endif /* NOWINMESSAGES */
#ifndef NOMSG
BOOL API _16TranslateMessage(LPMSG);
LONG API _16DispatchMessage(LPMSG);
#endif /* NOMSG */
LONG  API _Cover_SendMessage(HWND, WORD, WORD, LONG);
BOOL  API _Cover_RegisterClass(LPWNDCLASS);
BOOL  API _16UnregisterClass(LPSTR, HANDLE);
BOOL  API _16GetClassInfo(HANDLE, LPSTR, LPWNDCLASS);
HWND  API _16CreateWindow(LPSTR, LPSTR, DWORD, int, int, int, int, HWND, HMENU, HANDLE, LPSTR);
HWND  API _16CreateWindowEx(DWORD, LPSTR, LPSTR, DWORD, int, int, int, int, HWND, HMENU, HANDLE, LPSTR);
#ifndef NOCTLMGR
HWND API _Cover_CreateDialog(HANDLE, LPSTR, HWND, FARPROC);
HWND API _Cover_CreateDialogIndirect(HANDLE, LPSTR, HWND, FARPROC);
HWND API _Cover_CreateDialogParam(HANDLE, LPSTR, HWND, FARPROC, LONG);
HWND API _Cover_CreateDialogIndirectParam(HANDLE, LPSTR, HWND, FARPROC, LONG);
HWND API _16CreateDialog(HANDLE, LPSTR, HWND, FARPROC);
HWND API _16CreateDialogIndirect(HANDLE, LPSTR, HWND, FARPROC);
HWND API _16CreateDialogParam(HANDLE, LPSTR, HWND, FARPROC, LONG);
HWND API _16CreateDialogIndirectParam(HANDLE, LPSTR, HWND, FARPROC, LONG);
int  API _Cover_DialogBox(HANDLE, LPSTR, HWND, FARPROC);
int  API _Cover_DialogBoxParam(HANDLE, LPSTR, HWND, FARPROC, LONG);
int  API _Cover_DialogBoxIndirect(HANDLE, HANDLE, HWND, FARPROC);
int  API _Cover_DialogBoxIndirectParam(HANDLE, HANDLE, HWND, FARPROC, LONG);
int  API _16DialogBox(HANDLE, LPSTR, HWND, FARPROC);
int  API _16DialogBoxParam(HANDLE, LPSTR, HWND, FARPROC, LONG);
int  API _16DialogBoxIndirect(HANDLE, HANDLE, HWND, FARPROC);
int  API _16DialogBoxIndirectParam(HANDLE, HANDLE, HWND, FARPROC, LONG);
LONG API _Cover_SendDlgItemMessage(HWND, int, WORD, WORD, LONG);
WORD API _16GetDlgItemInt(HWND, int, BOOL *, BOOL);
void API _16SetDlgItemText(HWND, int, LPSTR);
int  API _16GetDlgItemText(HWND, int, LPSTR, int);
#endif /* NOCTLMSG */
#ifndef NOMSG
BOOL API _16CallMsgFilter(LPMSG, int);
#endif /* NOMSG */
#ifndef NOCLIPBOARD
WORD   API _16RegisterClipboardFormat(LPSTR);
int    API _16GetClipboardFormatName(WORD, LPSTR, int);
int    API _16GetPriorityClipboardFormat(WORD  *, int);
#endif /* NOCLIPBOARD */
void API _16GetKeyboardState(BYTE *);
void API _16SetKeyboardState(BYTE *);
WORD API _16SetTimer(HWND, int, WORD, FARPROC);
WORD API _Cover_SetTimer(HWND, int, WORD, FARPROC);
HANDLE API _16LoadAccelerators(HANDLE, LPSTR);
#ifndef NOMSG
int  API _16TranslateAccelerator(HWND, HANDLE, LPMSG);
#endif /* NOMSG */
#ifndef NOMENUS
HMENU API _16LoadMenu(HANDLE, LPSTR);
HMENU API _16LoadMenuIndirect(LPSTR);
BOOL  API _16ChangeMenu(HMENU, WORD, LPSTR, WORD, WORD);
int   API _16GetMenuString(HMENU, WORD, LPSTR, int, WORD);
BOOL  API _16TrackPopupMenu(HMENU, WORD, int, int, int, HWND, LPRECT);
#endif /* NOMENUS */
BOOL API _16GrayString(HDC, HBRUSH, FARPROC, DWORD, int, int, int, int, int);
BOOL API _Cover_GrayString(HDC, HBRUSH, FARPROC, DWORD, int, int, int, int, int);
void API _16EndPaint(HWND, LPPAINTSTRUCT);
BOOL API _16GetUpdateRect(HWND, LPRECT, BOOL);
void API _16InvalidateRect(HWND, LPRECT, BOOL);
void API _16ValidateRect(HWND, LPRECT);
void API _16ScrollWindow(HWND, int, int, LPRECT, LPRECT);
BOOL API _16ScrollDC(HDC, int, int, LPRECT, LPRECT, HRGN, LPRECT);
#ifndef NOSCROLL
void API _16GetScrollRange(HWND, int, LPINT, LPINT);
#endif /* NOSCROLL */
BOOL   API _16SetProp(HWND, LPSTR, HANDLE);
HANDLE API _16GetProp(HWND, LPSTR);
HANDLE API _16RemoveProp(HWND, LPSTR);
void   API _16SetWindowText(HWND, LPSTR);
int    API _16GetWindowText(HWND, LPSTR, int);
int    API _16EnumProps(HWND, FARPROC);
int    API _Cover_EnumProps(HWND, FARPROC);
void API _16GetClientRect(HWND, LPRECT);
void API _16GetWindowRect(HWND, LPRECT);
void API _16AdjustWindowRect(LPRECT, LONG, BOOL);
void API _16AdjustWindowRectEx(LPRECT, LONG, BOOL, DWORD);
#ifndef NOMB
int  API _16MessageBox(HWND, LPSTR, LPSTR, WORD);
#endif /* NOMB */
void    API _16GetCursorPos(LPPOINT);
void    API _16ClipCursor(LPRECT);
void API _16GetCaretPos(LPPOINT);
void API _16ClientToScreen(HWND, LPPOINT);
void API _16ScreenToClient(HWND, LPPOINT);
#ifndef NOCOLOR
void  API _16SetSysColors(int, LPINT, LONG *);
#endif /* NOCOLOR */
void API _16DrawFocusRect(HDC, LPRECT);
int  API _16FillRect(HDC, LPRECT, HBRUSH);
int  API _16FrameRect(HDC, LPRECT, HBRUSH);
void API _16InvertRect(HDC, LPRECT);
void API _16SetRect(LPRECT, int, int, int, int);
void API _16SetRectEmpty(LPRECT);
int  API _16CopyRect(LPRECT, LPRECT);
void API _16InflateRect(LPRECT, int, int);
int  API _16IntersectRect(LPRECT, LPRECT, LPRECT);
int  API _16UnionRect(LPRECT, LPRECT, LPRECT);
void API _16OffsetRect(LPRECT, int, int);
BOOL API _16IsRectEmpty(LPRECT);
BOOL API _16EqualRect(LPRECT, LPRECT);
BOOL API _16PtInRect(LPRECT, POINT);
BOOL API _16RectVisible(HDC, LPRECT);
BOOL API _16RectInRegion(HRGN, LPRECT);
#ifndef NOWINOFFSETS
LONG API _16SetWindowLong(HWND, int, LONG);
LONG API _16SetClassLong(HWND, int, LONG);
LONG API _Cover_GetWindowLong(HWND, int);
LONG API _Cover_SetWindowLong(HWND, int, LONG);
LONG API _Cover_GetClassLong(HWND, int);
LONG API _Cover_SetClassLong(HWND, int, LONG);
#endif /* NOWINOFFSETS */
HWND   API _16FindWindow(LPSTR, LPSTR);
BOOL   API _16EnumWindows(FARPROC, LONG);
BOOL   API _Cover_EnumWindows(FARPROC, LONG);
BOOL   API _16EnumTaskWindows(HANDLE, FARPROC, LONG);
BOOL   API _Cover_EnumTaskWindows(HANDLE, FARPROC, LONG);
BOOL   API _16EnumChildWindows(HWND, FARPROC, LONG);
BOOL   API _Cover_EnumChildWindows(HWND, FARPROC, LONG);
int    API _16GetClassName(HWND, LPSTR, int);
#ifndef NOWH
FARPROC API _16SetWindowsHook(int, FARPROC);
FARPROC API _Cover_SetWindowsHook(int, FARPROC);
BOOL	API _16UnhookWindowsHook(int, FARPROC);
#if (WINVER >= 0x030a)
HHOOK   API _Cover_SetWindowsHookEx(int idHook, HOOKPROC lpfn, HINSTANCE hInstance, HTASK hTask);
#endif  /* WINVER >= 0x030a */
#endif
HBITMAP API _16LoadBitmap(HANDLE, LPSTR);
HCURSOR API _16LoadCursor(HANDLE, LPSTR);
HCURSOR API _16CreateCursor(HANDLE, int, int, int, int, LPSTR, LPSTR);
HICON API _16LoadIcon(HANDLE, LPSTR);
HICON API _16CreateIcon(HANDLE, int, int, BYTE, BYTE, LPSTR, LPSTR);
int  API _16LoadString(HANDLE, WORD, LPSTR, int);
int  API _16AddFontResource(LPSTR);
BOOL API _16RemoveFontResource(LPSTR);

#ifndef NOCTLMGR
#ifndef NOMSG
BOOL API _16IsDialogMessage(HWND, LPMSG);
#endif /* NOMSG */
void API _16MapDialogRect(HWND, LPRECT);
int  API _16DlgDirList(HWND, LPSTR, int, int, WORD);
BOOL API _16DlgDirSelect(HWND, LPSTR, int);
int  API _16DlgDirListComboBox(HWND, LPSTR, int, int, WORD);
BOOL API _16DlgDirSelectComboBox(HWND, LPSTR, int);
#endif /* NOCTLMGR */
#ifdef USECOMM
int  API _16OpenComm(LPSTR, WORD, WORD);
int  API _16SetCommState(DCB *);
int  API _16GetCommState(int, DCB *);
int  API _16ReadComm(int, LPSTR, int);
int  API _16WriteComm(int, LPSTR, int);
int  API _16GetCommError(int, COMSTAT *);
int  API _16BuildCommDCB(LPSTR, DCB *);
#endif /* USECOMM */
#ifndef NOMDI
#ifndef NOMSG
BOOL API _16TranslateMDISysAccel(HWND,LPMSG);
#endif /* NOMSG */
#endif /* NOMDI */

#ifndef NOLFILEIO
WORD API _16_lread( int, LPSTR, int );
WORD API _16_lwrite( int, LPSTR, int );
#endif
#endif /* NOUSER */
#ifndef NOHELP
BOOL API _16WinHelp(HWND hwndMain, LPSTR lpszHelp, WORD usCommand, DWORD ulData);
#endif /* NOHELP */

#ifdef INCLUDE_DRIVINIT_H
#include <drivinit.h>
#endif
#ifdef INCLUDE_PRINT_H
#include <print.h>
#endif
#ifdef INCLUDE_DDE_H
#define unsigned unsigned short
#include <dde.h>
#undef unsigned
#endif
#ifdef INCLUDE_CUSTCNTL_H
#include <custcntl.h>
#endif
#ifdef INCLUDE_COMMDLG_H
#include <commdlg.h>
BOOL WINAPI _16ChooseColor(LPCHOOSECOLOR);
BOOL WINAPI _16ChooseFont(LPCHOOSEFONT);
HWND WINAPI _16FindText(LPFINDREPLACE);
int WINAPI _16GetFileTitle(LPCSTR, LPSTR, UINT);
BOOL WINAPI _16GetOpenFileName(LPOPENFILENAME);
BOOL WINAPI _16GetSaveFileName(LPOPENFILENAME);
BOOL WINAPI _16PrintDlg(LPPRINTDLG);
HWND WINAPI _16ReplaceText(LPFINDREPLACE);
#if !defined(NOAUTOPROCS) && defined(__WINDOWS_386__)
#define ChooseColor _CoverChooseColor
#define ChooseFont _CoverChooseFont
#define FindText _CoverFindText
#define GetOpenFileName _CoverGetOpenFileName
#define GetSaveFileName _CoverGetSaveFileName
#define PrintDlg _CoverPrintDlg
#define ReplaceText _CoverReplaceText
BOOL WINAPI _CoverChooseColor(LPCHOOSECOLOR);
BOOL WINAPI _CoverChooseFont(LPCHOOSEFONT);
HWND WINAPI _CoverFindText(LPFINDREPLACE);
BOOL WINAPI _CoverGetOpenFileName(LPOPENFILENAME);
BOOL WINAPI _CoverGetSaveFileName(LPOPENFILENAME);
BOOL WINAPI _CoverPrintDlg(LPPRINTDLG);
HWND WINAPI _CoverReplaceText(LPFINDREPLACE);
#endif

#endif
#ifdef INCLUDE_OLE_H
#include <ole.h>
OLESTATUS   WINAPI  _16OleActivate(LPOLEOBJECT, UINT, BOOL, BOOL, HWND, const RECT FAR*);
OLESTATUS   WINAPI  _16OleClone(LPOLEOBJECT, LPOLECLIENT, LHCLIENTDOC, LPCSTR, LPOLEOBJECT FAR*);
OLESTATUS   WINAPI  _16OleClose(LPOLEOBJECT);
OLESTATUS   WINAPI  _16OleCopyFromLink(LPOLEOBJECT, LPCSTR, LPOLECLIENT, LHCLIENTDOC, LPCSTR, LPOLEOBJECT FAR*);
OLESTATUS   WINAPI  _16OleCopyToClipboard(LPOLEOBJECT);
OLESTATUS   WINAPI  _16OleCreate(LPCSTR, LPOLECLIENT, LPCSTR, LHCLIENTDOC, LPCSTR, LPOLEOBJECT FAR*, OLEOPT_RENDER, OLECLIPFORMAT);
OLESTATUS   WINAPI  _16OleCreateFromClip(LPCSTR, LPOLECLIENT, LHCLIENTDOC, LPCSTR,  LPOLEOBJECT FAR*, OLEOPT_RENDER, OLECLIPFORMAT);
OLESTATUS   WINAPI  _16OleCreateFromFile(LPCSTR, LPOLECLIENT, LPCSTR, LPCSTR, LHCLIENTDOC, LPCSTR, LPOLEOBJECT FAR*, OLEOPT_RENDER, OLECLIPFORMAT);
OLESTATUS   WINAPI  _16OleCreateFromTemplate(LPCSTR, LPOLECLIENT, LPCSTR, LHCLIENTDOC, LPCSTR, LPOLEOBJECT FAR*, OLEOPT_RENDER, OLECLIPFORMAT);
OLESTATUS   WINAPI  _16OleCreateInvisible(LPCSTR, LPOLECLIENT, LPCSTR, LHCLIENTDOC, LPCSTR, LPOLEOBJECT FAR*, OLEOPT_RENDER, OLECLIPFORMAT, BOOL);
OLESTATUS   WINAPI  _16OleCreateLinkFromClip(LPCSTR, LPOLECLIENT, LHCLIENTDOC, LPCSTR, LPOLEOBJECT FAR*, OLEOPT_RENDER, OLECLIPFORMAT);
OLESTATUS   WINAPI  _16OleCreateLinkFromFile(LPCSTR, LPOLECLIENT, LPCSTR, LPCSTR, LPCSTR, LHCLIENTDOC, LPCSTR, LPOLEOBJECT FAR*, OLEOPT_RENDER, OLECLIPFORMAT);
OLESTATUS   WINAPI  _16OleDelete(LPOLEOBJECT);
OLESTATUS   WINAPI  _16OleDraw(LPOLEOBJECT, HDC, const RECT FAR*, const RECT FAR*, HDC);
OLECLIPFORMAT  WINAPI  _16OleEnumFormats(LPOLEOBJECT, OLECLIPFORMAT);
OLESTATUS   WINAPI  _16OleEnumObjects(LHCLIENTDOC, LPOLEOBJECT FAR*);
OLESTATUS   WINAPI  _16OleEqual(LPOLEOBJECT, LPOLEOBJECT );
OLESTATUS   WINAPI  _16OleExecute(LPOLEOBJECT, HGLOBAL, UINT);
OLESTATUS   WINAPI  _16OleGetData(LPOLEOBJECT, OLECLIPFORMAT, HANDLE FAR*);
OLESTATUS   WINAPI  _16OleGetLinkUpdateOptions(LPOLEOBJECT, OLEOPT_UPDATE FAR*);
OLESTATUS   WINAPI  _16OleLoadFromStream(LPOLESTREAM, LPCSTR, LPOLECLIENT, LHCLIENTDOC, LPCSTR, LPOLEOBJECT FAR*);
OLESTATUS   WINAPI  _16OleLockServer(LPOLEOBJECT, LHSERVER FAR*);
OLESTATUS   WINAPI  _16OleObjectConvert(LPOLEOBJECT, LPCSTR, LPOLECLIENT, LHCLIENTDOC, LPCSTR, LPOLEOBJECT FAR*);
OLESTATUS   WINAPI  _16OleQueryBounds(LPOLEOBJECT, RECT FAR*);
OLESTATUS   WINAPI  _16OleQueryCreateFromClip(LPCSTR, OLEOPT_RENDER, OLECLIPFORMAT);
OLESTATUS   WINAPI  _16OleQueryLinkFromClip(LPCSTR, OLEOPT_RENDER, OLECLIPFORMAT);
OLESTATUS   WINAPI  _16OleQueryName(LPOLEOBJECT, LPSTR, UINT FAR*);
OLESTATUS   WINAPI  _16OleQueryOpen(LPOLEOBJECT);
OLESTATUS   WINAPI  _16OleQueryOutOfDate(LPOLEOBJECT);
void FAR*   WINAPI  _16OleQueryProtocol(LPOLEOBJECT, LPCSTR);
OLESTATUS   WINAPI  _16OleQueryReleaseError(LPOLEOBJECT);
OLE_RELEASE_METHOD WINAPI _16OleQueryReleaseMethod(LPOLEOBJECT);
OLESTATUS   WINAPI  _16OleQueryReleaseStatus(LPOLEOBJECT);
OLESTATUS   WINAPI  _16OleQuerySize(LPOLEOBJECT, DWORD FAR*);
OLESTATUS   WINAPI  _16OleQueryType(LPOLEOBJECT, LONG FAR*);
OLESTATUS   WINAPI  _16OleReconnect(LPOLEOBJECT);
OLESTATUS   WINAPI  _16OleRegisterClientDoc(LPCSTR, LPCSTR, LONG, LHCLIENTDOC FAR*);
OLESTATUS   WINAPI  _16OleRelease(LPOLEOBJECT);
OLESTATUS   WINAPI  _16OleRename(LPOLEOBJECT, LPCSTR);
OLESTATUS   WINAPI  _16OleRenameClientDoc(LHCLIENTDOC, LPCSTR);
OLESTATUS   WINAPI  _16OleRequestData(LPOLEOBJECT, OLECLIPFORMAT);
OLESTATUS   WINAPI  _16OleSaveToStream(LPOLEOBJECT, LPOLESTREAM);
OLESTATUS   WINAPI  _16OleSetBounds(LPOLEOBJECT, const RECT FAR*);
OLESTATUS   WINAPI  _16OleSetColorScheme(LPOLEOBJECT, const LOGPALETTE FAR*);
OLESTATUS   WINAPI  _16OleSetData(LPOLEOBJECT, OLECLIPFORMAT, HANDLE);
OLESTATUS   WINAPI  _16OleSetHostNames(LPOLEOBJECT, LPCSTR, LPCSTR);
OLESTATUS   WINAPI  _16OleSetLinkUpdateOptions(LPOLEOBJECT, OLEOPT_UPDATE);
OLESTATUS   WINAPI  _16OleSetTargetDevice(LPOLEOBJECT, HGLOBAL);
OLESTATUS   WINAPI  _16OleUpdate(LPOLEOBJECT);
OLESTATUS   WINAPI  _16OleRegisterServer(LPCSTR, LPOLESERVER, LHSERVER FAR*, HINSTANCE, OLE_SERVER_USE);
OLESTATUS   WINAPI  _16OleRegisterServerDoc(LHSERVER, LPCSTR, LPOLESERVERDOC, LHSERVERDOC FAR*);
OLESTATUS   WINAPI  _16OleRenameServerDoc(LHSERVERDOC, LPCSTR);
OLESTATUS   WINAPI  _16OleRevokeObject(LPOLECLIENT);
OLESTATUS   WINAPI  _16OleUnblockServer(LHSERVER, BOOL FAR*);
#endif
#ifdef INCLUDE_DDEML_H
#include <ddeml.h>
HCONVLIST EXPENTRY _16DdeConnectList(DWORD idInst, HSZ hszService, HSZ hszTopic,
        HCONVLIST hConvList, PCONVCONTEXT pCC);
HCONV EXPENTRY _16DdeConnect(DWORD idInst, HSZ hszService, HSZ hszTopic,
        PCONVCONTEXT pCC);
WORD EXPENTRY _16DdeQueryConvInfo(HCONV hConv, DWORD idTransaction, PCONVINFO pConvInfo);
HDDEDATA EXPENTRY _16DdeClientTransaction(LPBYTE pData, DWORD cbData,
        HCONV hConv, HSZ hszItem, WORD wFmt, WORD wType, DWORD dwTimeout,
        LPDWORD pdwResult);
HDDEDATA EXPENTRY _16DdeCreateDataHandle(DWORD idInst, LPBYTE pSrc, DWORD cb,
        DWORD cbOff, HSZ hszItem, WORD wFmt, WORD afCmd);
HDDEDATA EXPENTRY _16DdeAddData(HDDEDATA hData, LPBYTE pSrc, DWORD cb, DWORD cbOff);
DWORD EXPENTRY _16DdeGetData(HDDEDATA hData, LPBYTE pDst, DWORD cbMax, DWORD cbOff);
LPBYTE EXPENTRY _16DdeAccessData(HDDEDATA hData, LPDWORD pcbDataSize);
HSZ  EXPENTRY _16DdeCreateStringHandle(DWORD idInst, LPSTR psz, int iCodePage);
DWORD EXPENTRY _16DdeQueryString(DWORD idInst, HSZ hsz, LPSTR psz, DWORD cchMax, int iCodePage);
UINT  EXPENTRY _16DdeInitialize(LPDWORD idInst, PFNCALLBACK pfnCallback,
				DWORD afCmd, DWORD ulRes);
#if !defined(NOAUTOPROCS) && defined(__WINDOWS_386__)
#define DdeInitialize _Cover_DdeInitialize
UINT  EXPENTRY _Cover_DdeInitialize(LPDWORD idInst, PFNCALLBACK pfnCallback,
				DWORD afCmd, DWORD ulRes);
#endif
#endif
#ifdef INCLUDE_SHELLAPI_H
#include <shellapi.h>
#endif
#ifdef INCLUDE_VER_H
#include <ver.h>
#endif
#ifdef INCLUDE_LZEXPAND_H
#include <lzexpand.h>
#endif
#ifdef INCLUDE_STRESS_H
#include <stress.h>
#endif
#ifdef INCLUDE_PENWIN_H
#include <penwin.h>
#if !defined(NOAUTOPROCS) && defined(__WINDOWS_386__)
#define Recognize _Cover_Recognize
#define RecognizeData _Cover_RecognizeData
#define TrainInk _Cover_TrainInk
#define ProcessWriting _Cover_ProcessWriting
#define CorrectWriting _Cover_CorrectWriting
#define DictionarySearch _Cover_DictionarySearch
#define SetPenHook _Cover_SetPenHook
#define EnumSymbols _Cover_EnumSymbols
REC WINAPI _Cover_Recognize( LPRC lprc );
REC WINAPI _Cover_RecognizeData( LPRC lprc, HPENDATA hpd );
BOOL WINAPI _Cover_TrainInk(LPRC lprc, HPENDATA hpd, LPSYV lpsvy );
REC WINAPI _Cover_ProcessWriting( HWND hwnd, LPRC lprc );
BOOL WINAPI _Cover_CorrectWriting( HWND hwnd, LPSTR lpstr, UINT cb, LPRC lprc, DWORD dw1, DWORD dw2 );
BOOL WINAPI _Cover_DictionarySearch( LPRC lprc, LPSYE lpsye, int i1, LPSYV lpsyv, int i2 );
BOOL WINAPI _Cover_SetPenHook(HKP hkpop, LPFNRAWHOOK lpfn );
UINT WINAPI _Cover_EnumSymbols(LPSYG, WORD, ENUMPROC, LPVOID);
#endif
#endif
#ifdef INCLUDE_PENWOEM_H
#include <penwoem.h>
#endif
#ifdef INCLUDE_MMSYSTEM_H
#include <mmsystem.h>
#if !defined(NOAUTOPROCS) && defined(__WINDOWS_386__)
#define mmioInstallIOProc _Cover_mmioInstallIOProc
#define mciSetYieldProc _Cover_mciSetYieldProc
LPMMIOPROC WINAPI _Cover_mmioInstallIOProc(FOURCC fccIOProc, LPMMIOPROC pIOProc, DWORD dwFlags);
BOOL WINAPI _Cover_mciSetYieldProc(UINT uDeviceID, YIELDPROC fpYieldProc, DWORD dwYieldData);
#endif
UINT WINAPI _16waveOutPrepareHeader(HWAVEOUT hWaveOut,DWORD,UINT uSize);
UINT WINAPI _16waveOutUnprepareHeader(HWAVEOUT hWaveOut,DWORD,UINT uSize);
UINT WINAPI _16waveOutWrite(HWAVEOUT hWaveOut, DWORD,UINT uSize);
#endif

#ifdef INCLUDE_TOOLHELP_H
#include <toolhelp.h>
#if !defined(NOAUTOPROCS) && defined(__WINDOWS_386__)
BOOL WINAPI _Cover_NotifyRegister(HTASK hTask, LPFNNOTIFYCALLBACK lpfn, WORD wFlags);
#define NotifyRegister _Cover_NotifyRegister
#endif
#endif

#ifdef __WINDOWS_386__

/*
 * re-define the pseudo-pointers
 */
#undef MAKEINTRESOURCE
#define MAKEINTRESOURCE(i)  (LPSTR)(0xFFFF0000L+(DWORD)((WORD)(i)))
#undef MAKEINTATOM
#define MAKEINTATOM(i)	(LPSTR)(0xFFFF0000L+(DWORD)((WORD)(i)))

#undef int
#undef __far
#undef __huge
#undef FAR
#define FAR far

/*
 * types
 */
typedef unsigned int PROCPTR;
typedef void * CALLBACKPTR;
typedef void * HINDIR;

/*
 * prototypes for special WIN386 library functions
 */
#define GETPROC_CALLBACK 0
#define GETPROC_SETTIMER 0
#define GETPROC_ABORTPROC 1
#define GETPROC_ENUMFONTS 2
#define GETPROC_ENUMMETAFILE 3
#define GETPROC_ENUMOBJECTS 4
#define GETPROC_ENUMPROPS_FIXED_DS 5
#define GETPROC_GRAYSTRING 5
#define GETPROC_ENUMPROPS_MOVEABLE_DS 6
#define GETPROC_ENUMTASKWINDOWS 7
#define GETPROC_ENUMWINDOWS 7
#define GETPROC_ENUMCHILDWINDOWS 7
#define GETPROC_TOOLHELP_NOTIFY 7
#define GETPROC_GLOBALNOTIFY 8
#define GETPROC_LINEDDA 9
#define GETPROC_SETWINDOWSHOOK 9
#define GETPROC_SETRESOURCEHANDLER 10
#define GETPROC_DDEMLCALLBACK 11
#define GETPROC_PENWIN_RCYIELDPROC 12
#define GETPROC_PENWIN_LPDF 13
#define GETPROC_PENWIN_LPFNRAWHOOK 14
#define GETPROC_PENWIN_ENUMPROC 15
#define GETPROC_MMSYSTEM_MMIOPROC 16
#define GETPROC_MMSYSTEM_YIELDPROC 17
#define GETPROC_USERDEFINED_1 101
#define GETPROC_USERDEFINED_2 102
#define GETPROC_USERDEFINED_3 103
#define GETPROC_USERDEFINED_4 104
#define GETPROC_USERDEFINED_5 105
#define GETPROC_USERDEFINED_6 106
#define GETPROC_USERDEFINED_7 107
#define GETPROC_USERDEFINED_8 108
#define GETPROC_USERDEFINED_9 109
#define GETPROC_USERDEFINED_10 110
#define GETPROC_USERDEFINED_11 111
#define GETPROC_USERDEFINED_12 112
#define GETPROC_USERDEFINED_13 113
#define GETPROC_USERDEFINED_14 114
#define GETPROC_USERDEFINED_15 115
#define GETPROC_USERDEFINED_16 116
#define GETPROC_USERDEFINED_17 117
#define GETPROC_USERDEFINED_18 118
#define GETPROC_USERDEFINED_19 119
#define GETPROC_USERDEFINED_20 120
#define GETPROC_USERDEFINED_21 121
#define GETPROC_USERDEFINED_22 122
#define GETPROC_USERDEFINED_23 123
#define GETPROC_USERDEFINED_24 124
#define GETPROC_USERDEFINED_25 125
#define GETPROC_USERDEFINED_26 126
#define GETPROC_USERDEFINED_27 127
#define GETPROC_USERDEFINED_28 128
#define GETPROC_USERDEFINED_29 129
#define GETPROC_USERDEFINED_30 130
#define GETPROC_USERDEFINED_31 131
#define GETPROC_USERDEFINED_32 132

#define GCB_DWORD		4
#define GCB_WORD		2
#define GCB_ENDLIST		-1
#define GCB_CDECL		-2

extern CALLBACKPTR GetProc16( PROCPTR, long );
extern void ReleaseProc16( CALLBACKPTR );
extern void ReleaseCallbackRoutine( CALLBACKPTR cbp );
CALLBACKPTR GetCallbackRoutine( PROCPTR fn, ... );
void ReleaseCallbackRoutine( CALLBACKPTR cbp );

extern void far *MK_LOCAL32( void * );
extern void far *MK_FP32( void * );
extern DWORD MK_FP16( void far * );

#pragma aux MK_LOCAL32 "*_" parm [eax] value [eax dx];
#pragma aux MK_FP32 = 0x8B 0xD0 0xC1 0xEA 0x10 0x25 0xFF 0xFF 0x00 0x00 \
   parm [eax] value [eax dx];
#pragma aux  MK_FP16 = 0xC1 0xE2 0x10 0x66 0x8B 0xD0 \
   parm [eax dx] value [edx];

extern DWORD _Call16( FARPROC lpFunc, char *fmt, ... );
/*
;  _Call16 performs the same function as "GetIndirectFunctionHandle,
;  InvokeIndirectFunctionHandle, FreeIndirectFunctionHandle" but is
;  much easier to use.
;  Fmt specifiers for _Call16:
;	c - call 'cdecl' func as opposed to 'pascal' func (must be first char)
;	b - unsigned byte
;	w - 16-bit word
;	d - 32-bit dword
;	f - double precision floating-point
;	p - 32-bit flat pointer (converted to 16:16 pointer)
*/
extern DWORD InvokeIndirectFunction( HINDIR handle, ... );
extern HINDIR GetIndirectFunctionHandle( FARPROC proc, ... );
extern void  FreeIndirectFunctionHandle( HINDIR );
#define INDIR_DWORD     ((int) 4)
#define INDIR_WORD      ((int) 2)
#define INDIR_CHAR      ((int) 2)
#define INDIR_PTR       ((int) -1)
#define INDIR_ENDLIST   ((int) -2)
#define INDIR_CDECL	((int) -3)

extern int DefineDLLEntry( int, void *, ... );
#define DLL_DWORD	((int) 4)
#define DLL_PTR		((int) 4)
#define DLL_WORD	((int) 2)
#define DLL_CHAR	((int) 2)
#define DLL_ENDLIST	((int) -1)

extern int DefineUserProc16( int, PROCPTR, ... );
#define UDP16_DWORD	((int) 4)
#define UDP16_PTR	((int) 4)
#define UDP16_WORD	((int) 2)
#define UDP16_CHAR	((int) 2)
#define UDP16_ENDLIST	((int) -1)
#define UDP16_CDECL	((int) -2)

#define DWORD_TO_PTR(i)  ((LPSTR)(0xFFFF0000L+(DWORD)((WORD)(i))))
#define PASS_WORD_AS_POINTER(i)  ((LPSTR)(0xFFFF0000L+(DWORD)((WORD)(i))))

extern DWORD AllocAlias16( void * );
extern void FreeAlias16( DWORD );
extern DWORD AllocHugeAlias16( void *, DWORD );
extern void FreeHugeAlias16( DWORD, DWORD );
void *MapAliasToFlat( DWORD alias );

extern WORD __A000;
#pragma aux __A000 "_*";
extern WORD __B000;
#pragma aux __B000 "_*";
extern WORD __B800;
#pragma aux __B800 "_*";
extern WORD __C000;
#pragma aux __C000 "_*";
extern WORD __D000;
#pragma aux __D000 "_*";
extern WORD __E000;
#pragma aux __E000 "_*";
extern WORD __F000;
#pragma aux __F000 "_*";
extern WORD LocalPtr;
#pragma aux LocalPtr "_*";

#pragma library (WIN386);

#else
typedef void __far * PROCPTR;
typedef void __far * CALLBACKPTR;
typedef void * HINDIR;

#define PASS_WORD_AS_POINTER(i) ((LPSTR)(WORD)(i))
#define AllocAlias16(a) ((DWORD)(LPSTR)(a))
#define FreeAlias16(a)
#define AllocHugeAlias16(a,b) ((DWORD)(LPSTR)(a))
#define FreeHugeAlias16(a,b)
#define MK_LOCAL32(a) ((void far *) a)
#define MK_FP32(a) (a)
#define MK_FP16(a) (a)
#define GetProc16(a,b) (a)
#define ReleaseProc16(a)

#ifndef NOKERNEL
#define _16MakeProcInstance MakeProcInstance
#define _16FreeProcInstance FreeProcInstance
#define _16GetCodeInfo GetCodeInfo
#define _16GetModuleHandle GetModuleHandle
#define _16GetModuleFileName GetModuleFileName
#define _16GetInstanceData GetInstanceData
#define _16GetProcAddress GetProcAddress
#define _16LoadLibrary LoadLibrary
#define _16LoadModule LoadModule
#define _16WinExec WinExec
#define _16OutputDebugString OutputDebugString
#ifndef NOOPENFILE
#define _16OpenFile OpenFile
#define _16GetTempFileName GetTempFileName
#endif /* NOOPENFILE */
#define _16FindResource FindResource
#define _16SetResourceHandler SetResourceHandler
#ifndef NOATOM
#define _16AddAtom AddAtom
#define _16FindAtom FindAtom
#define _16GetAtomName GetAtomName
#define _16GlobalAddAtom GlobalAddAtom
#define _16GlobalFindAtom GlobalFindAtom
#define _16GlobalGetAtomName GlobalGetAtomName
#endif /* NOATOM */
#define _16GetProfileInt GetProfileInt
#define _16GetProfileString GetProfileString
#define _16WriteProfileString WriteProfileString
#define _16GetPrivateProfileInt GetPrivateProfileInt
#define _16GetPrivateProfileString GetPrivateProfileString
#define _16WritePrivateProfileString WritePrivateProfileString
#define _16GetWindowsDirectory GetWindowsDirectory
#define _16GetSystemDirectory GetSystemDirectory
#define _16AnsiToOem AnsiToOem
#define _16OemToAnsi OemToAnsi
#define _16AnsiToOemBuff AnsiToOemBuff
#define _16OemToAnsiBuff OemToAnsiBuff
#define _16AnsiUpper AnsiUpper
#define _16AnsiUpperBuff AnsiUpperBuff
#define _16AnsiLower AnsiLower
#define _16AnsiLowerBuff AnsiLowerBuff
#define _16AnsiNext AnsiNext
#define _16AnsiPrev AnsiPrev
#ifndef NOKEYBOARDINFO
#define _16GetKeyNameText GetKeyNameText
#define _16ToAscii ToAscii
#endif /* NOKEYBOARDINFO */
#ifndef NOMEMMGR
#define _16GlobalNotify GlobalNotify
#endif /* NOMEMMGR */
#endif /* NOKERNEL */

#ifndef NOGDI
#ifndef NODRAWTEXT
#define _16DrawText DrawText
#endif /* NODRAWTEXT */
#define _16CreateDC CreateDC
#define _16CreateIC CreateIC
#define _16ExtTextOut ExtTextOut
#define _16Polyline Polyline
#define _16Polygon Polygon
#define _16PolyPolygon PolyPolygon
#define _16TextOut TextOut
#define _16TabbedTextOut TabbedTextOut
#define _16GetCharWidth GetCharWidth
#define _16LineDDA LineDDA
#define _16CreatePenIndirect CreatePenIndirect
#define _16CreateBrushIndirect CreateBrushIndirect
#define _16CreateBitmap CreateBitmap
#define _16CreateBitmapIndirect CreateBitmapIndirect
#define _16SetBitmapBits SetBitmapBits
#define _16GetBitmapBits GetBitmapBits
#define _16CreateFont CreateFont
#define _16CreateFontIndirect CreateFontIndirect
#define _16CreateRectRgnIndirect CreateRectRgnIndirect
#define _16CreateEllipticRgnIndirect CreateEllipticRgnIndirect
#define _16CreatePolygonRgn CreatePolygonRgn
#define _16CreatePolyPolygonRgn CreatePolyPolygonRgn
#define _16GetObject GetObject
#define _16GetClipBox GetClipBox
#define _16GetRgnBox GetRgnBox
#define _16GetTextExtent GetTextExtent
#define _16GetTabbedTextExtent GetTabbedTextExtent
#define _16GetMetaFile GetMetaFile
#define _16CopyMetaFile CopyMetaFile
#ifndef NOMETAFILE
#define _16PlayMetaFileRecord PlayMetaFileRecord
#define _16EnumMetaFile EnumMetaFile
#endif
#define _16Escape Escape
#define _16EnumFonts EnumFonts
#define _16EnumObjects EnumObjects
#define _16GetTextFace GetTextFace
#ifndef NOTEXTMETRIC
#define _16GetTextMetrics GetTextMetrics
#endif /* NOTEXTMETRIC */
#define _16SetEnvironment SetEnvironment
#define _16GetEnvironment GetEnvironment
#define _16DPtoLP DPtoLP
#define _16LPtoDP LPtoDP
#define _16CreateMetaFile CreateMetaFile
#define _16SetDIBits SetDIBits
#define _16GetDIBits GetDIBits
#define _16SetDIBitsToDevice SetDIBitsToDevice
#define _16StretchDIBits StretchDIBits
#define _16CreatePalette  CreatePalette 
#define _16AnimatePalette AnimatePalette
#define _16SetPaletteEntries SetPaletteEntries
#define _16GetPaletteEntries GetPaletteEntries
#define _16GetSystemPaletteEntries GetSystemPaletteEntries
#endif /* NOGDI */

#ifndef NOUSER
#ifndef NOWINMESSAGES
#define _16RegisterWindowMessage RegisterWindowMessage
#endif /* NOWINMESSAGES */
#ifndef NOMSG
#define _16TranslateMessage TranslateMessage
#define _16DispatchMessage DispatchMessage
#endif /* NOMSG */
#define _16UnregisterClass UnregisterClass
#define _16GetClassInfo GetClassInfo
#define _16CreateWindow CreateWindow
#define _16CreateWindowEx CreateWindowEx
#ifndef NOCTLMGR
#define _16CreateDialog CreateDialog
#define _16CreateDialogIndirect CreateDialogIndirect
#define _16CreateDialogParam CreateDialogParam
#define _16CreateDialogIndirectParam CreateDialogIndirectParam
#define _16DialogBox DialogBox
#define _16DialogBoxParam DialogBoxParam
#define _16DialogBoxIndirect DialogBoxIndirect
#define _16DialogBoxIndirectParam DialogBoxIndirectParam
#define _16GetDlgItemInt GetDlgItemInt
#define _16SetDlgItemText SetDlgItemText
#define _16GetDlgItemText GetDlgItemText
#endif /* NOCTLMSG */
#ifndef NOMSG
#define _16CallMsgFilter CallMsgFilter
#endif /* NOMSG */
#ifndef NOCLIPBOARD
#define _16RegisterClipboardFormat RegisterClipboardFormat
#define _16GetClipboardFormatName GetClipboardFormatName
#define _16GetPriorityClipboardFormat GetPriorityClipboardFormat
#endif /* NOCLIPBOARD */
#define _16GetKeyboardState GetKeyboardState
#define _16SetKeyboardState SetKeyboardState
#define _16LoadAccelerators LoadAccelerators
#define _16SetTimer SetTimer
#ifndef NOMSG
#define _16TranslateAccelerator TranslateAccelerator
#endif /* NOMSG */
#ifndef NOMENUS
#define _16LoadMenu LoadMenu
#define _16LoadMenuIndirect LoadMenuIndirect
#define _16ChangeMenu ChangeMenu
#define _16GetMenuString GetMenuString
#define _16TrackPopupMenu TrackPopupMenu
#endif /* NOMENUS */
#define _16GrayString GrayString
#define _16EndPaint EndPaint
#define _16GetUpdateRect GetUpdateRect
#define _16InvalidateRect InvalidateRect
#define _16ValidateRect ValidateRect
#define _16ScrollWindow ScrollWindow
#define _16ScrollDC ScrollDC
#ifndef NOSCROLL
#define _16GetScrollRange GetScrollRange
#endif /* NOSCROLL */
#define _16SetProp SetProp
#define _16GetProp GetProp
#define _16RemoveProp RemoveProp
#define _16SetWindowText SetWindowText
#define _16GetWindowText GetWindowText
#define _16GetClientRect GetClientRect
#define _16EnumProps EnumProps
#define _16GetWindowRect GetWindowRect
#define _16AdjustWindowRect AdjustWindowRect
#define _16AdjustWindowRectEx AdjustWindowRectEx
#ifndef NOMB
#define _16MessageBox MessageBox
#endif /* NOMB */
#define _16GetCursorPos GetCursorPos
#define _16ClipCursor ClipCursor
#define _16GetCaretPos GetCaretPos
#define _16ClientToScreen ClientToScreen
#define _16ScreenToClient ScreenToClient
#ifndef NOCOLOR
#define _16SetSysColors SetSysColors
#endif /* NOCOLOR */
#define _16DrawFocusRect DrawFocusRect
#define _16FillRect FillRect
#define _16FrameRect FrameRect
#define _16InvertRect InvertRect
#define _16SetRect SetRect
#define _16SetRectEmpty SetRectEmpty
#define _16CopyRect CopyRect
#define _16InflateRect InflateRect
#define _16IntersectRect IntersectRect
#define _16UnionRect UnionRect
#define _16OffsetRect OffsetRect
#define _16IsRectEmpty IsRectEmpty
#define _16EqualRect EqualRect
#define _16PtInRect PtInRect
#define _16RectVisible RectVisible
#define _16RectInRegion RectInRegion
#define _16EnumChildWindows EnumChildWindows
#define _16FindWindow FindWindow
#define _16EnumWindows EnumWindows
#define _16EnumTaskWindows EnumTaskWindows
#define _16GetClassName GetClassName
#ifndef NOWH
#define _16SetWindowsHook SetWindowsHook
#define _16UnhookWindowsHook UnhookWindowsHook
#endif
#define _16LoadBitmap LoadBitmap
#define _16LoadCursor LoadCursor
#define _16CreateCursor CreateCursor
#define _16LoadIcon LoadIcon
#define _16CreateIcon CreateIcon
#define _16LoadString LoadString
#define _16AddFontResource AddFontResource
#define _16RemoveFontResource RemoveFontResource

#ifndef NOCTLMGR
#ifndef NOMSG
#define _16IsDialogMessage IsDialogMessage
#endif /* NOMSG */
#define _16MapDialogRect MapDialogRect
#define _16DlgDirList DlgDirList
#define _16DlgDirSelect DlgDirSelect
#define _16DlgDirListComboBox DlgDirListComboBox
#define _16DlgDirSelectComboBox DlgDirSelectComboBox
#endif /* NOCTLMGR */
#ifdef USECOMM
#define _16OpenComm OpenComm
#define _16SetCommState SetCommState
#define _16GetCommState GetCommState
#define _16ReadComm ReadComm
#define _16WriteComm WriteComm
#define _16GetCommError GetCommError
#define _16BuildCommDCB BuildCommDCB
#endif /* USECOMM */
#ifndef NOMDI
#ifndef NOMSG
#define _16TranslateMDISysAccel TranslateMDISysAccel
#endif /* NOMSG */
#endif /* NOMDI */

#ifndef NOLFILEIO
#define _16_lread _lread
#define _16_lwrite _lwrite
#endif
#endif /* NOUSER */
#ifndef NOHELP
#define _16WinHelp WinHelp
#endif /* NOHELP */

#ifdef INCLUDE_COMMDLG_H
#define _16ChooseColor ChooseColor
#define _16ChooseFont ChooseFont
#define _16FindText FindText
#define _16GetFileTitle GetFileTitle
#define _16GetOpenFileName GetOpenFileName
#define _16GetSaveFileName GetSaveFileName
#define _16PrintDlg PrintDlg
#define _16ReplaceText ReplaceText
#endif
#ifdef INCLUDE_DDEML_H
#define _16DdeConnectList DdeConnectList
#define _16DdeConnect DdeConnect
#define _16DdeQueryConvInfo DdeQueryConvInfo
#define _16DdeClientTransaction DdeClientTransaction
#define _16DdeCreateDataHandle DdeCreateDataHandle
#define _16DdeAddData DdeAddData
#define _16DdeGetData DdeGetData
#define _16DdeAccessData DdeAccessData
#define _16DdeCreateStringHandle DdeCreateStringHandle
#define _16DdeQueryString DdeQueryString
#define _16DdeInitialize DdeInitialize
#endif
#ifdef INCLUDE_PENWIN_H
#endif
#endif

#ifdef __cplusplus
};
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\inc16\WIN16.H ===
/*****************************************************************************\
*                                                                             *
* windows.h -   Windows functions, types, and definitions                     *
*                                                                             *
*               Version 3.10                                                  *
*                                                                             *
*               Copyright (c) 1985-1992, Microsoft Corp. All rights reserved. *
*                                                                             *
*******************************************************************************
*
* The following symbols control inclusion of various parts of this file:
*
* WINVER            Windows version number (0x030a).  To exclude
*                   definitions introduced in version 3.1 (or above)
*                   #define WINVER 0x0300 before #including <windows.h>
*
* #define:          To prevent inclusion of:
*
* NOKERNEL          KERNEL APIs and definitions
* NOGDI             GDI APIs and definitions
* NOUSER            USER APIs and definitions
* NOSOUND           Sound APIs and definitions
* NOCOMM            Comm driver APIs and definitions
* NODRIVERS         Installable driver APIs and definitions
*
* NOMINMAX          min() and max() macros
* NOLOGERROR        LogError() and related definitions
* NOPROFILER        Profiler APIs
* NOMEMMGR          Local and global memory management
* NOLFILEIO         _l* file I/O routines
* NOOPENFILE        OpenFile and related definitions
* NORESOURCE        Resource management
* NOATOM            Atom management
* NOLANGUAGE        Character test routines
* NOLSTRING         lstr* string management routines
* NODBCS            Double-byte character set routines
* NOKEYBOARDINFO    Keyboard driver routines
* NOGDICAPMASKS     GDI device capability constants
* NOCOLOR           COLOR_* color values
* NOGDIOBJ          GDI pens, brushes, fonts
* NODRAWTEXT        DrawText() and related definitions
* NOTEXTMETRIC      TEXTMETRIC and related APIs
* NOSCALABLEFONT    Truetype scalable font support
* NOBITMAP          Bitmap support
* NORASTEROPS       GDI Raster operation definitions
* NOMETAFILE        Metafile support
* NOSYSMETRICS      GetSystemMetrics() and related SM_* definitions
* NOSYSTEMPARAMSINFO SystemParametersInfo() and SPI_* definitions
* NOMSG             APIs and definitions that use MSG structure
* NOWINSTYLES       Window style definitions
* NOWINOFFSETS      Get/SetWindowWord/Long offset definitions
* NOSHOWWINDOW      ShowWindow and related definitions
* NODEFERWINDOWPOS  DeferWindowPos and related definitions
* NOVIRTUALKEYCODES VK_* virtual key codes
* NOKEYSTATES       MK_* message key state flags
* NOWH              SetWindowsHook and related WH_* definitions
* NOMENUS           Menu APIs
* NOSCROLL          Scrolling APIs and scroll bar control
* NOCLIPBOARD       Clipboard APIs and definitions
* NOICONS           IDI_* icon IDs
* NOMB              MessageBox and related definitions
* NOSYSCOMMANDS     WM_SYSCOMMAND SC_* definitions
* NOMDI             MDI support
* NOCTLMGR          Control management and controls
* NOWINMESSAGES     WM_* window messages
* NOHELP            Help support
*
\****************************************************************************/

#ifndef _INC_WINDOWS
#define _INC_WINDOWS    /* #defined if windows.h has been included */

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif  /* RC_INVOKED */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */

/* If WINVER is not defined, assume version 3.1 */
#ifndef WINVER
#define WINVER  0x030a
#endif

#ifdef RC_INVOKED
/* Don't include definitions that RC.EXE can't parse */
#define NOATOM
#define NOGDI
#define NOGDICAPMASKS
#define NOMETAFILE
#define NOMINMAX
#define NOMSG
#define NOOPENFILE
#define NORASTEROPS
#define NOSCROLL
#define NOSOUND
#define NOSYSMETRICS
#define NOTEXTMETRIC
#define NOWH
#define NODBCS
#define NOSYSTEMPARAMSINFO
#define NOCOMM
#define NOOEMRESOURCE
#endif  /* RC_INVOKED */

/* Handle OEMRESOURCE for 3.0 compatibility */
#if (WINVER < 0x030a)
#define NOOEMRESOURCE
#ifdef OEMRESOURCE
#undef NOOEMRESOURCE
#endif
#endif

/******* Common definitions and typedefs ***********************************/

#define VOID		    void

#define FAR                 __far
#define NEAR		    __near
#define PASCAL		    __pascal
#define CDECL		    __cdecl

#define WINAPI              __far __pascal
#define CALLBACK            __far __pascal

/****** Simple types & common helper macros *********************************/

typedef int		    BOOL;
#define FALSE		    0
#define TRUE		    1

typedef unsigned char	    BYTE;
typedef unsigned short      WORD;
typedef unsigned long       DWORD;

typedef unsigned int	    UINT;

#ifdef STRICT
typedef signed long	    LONG;
#else
#define LONG long
#endif

#define LOBYTE(w)	    ((BYTE)(w))
#define HIBYTE(w)           ((BYTE)(((UINT)(w) >> 8) & 0xFF))

#define LOWORD(l)           ((WORD)(DWORD)(l))
#define HIWORD(l)           ((WORD)((((DWORD)(l)) >> 16) & 0xFFFF))

#define MAKELONG(low, high) ((LONG)(((WORD)(low)) | (((DWORD)((WORD)(high))) << 16)))

#ifndef NOMINMAX
#ifndef max
#define max(a,b)            (((a) > (b)) ? (a) : (b))
#endif
#ifndef min
#define min(a,b)            (((a) < (b)) ? (a) : (b))
#endif
#endif  /* NOMINMAX */

/* Types use for passing & returning polymorphic values */
typedef UINT WPARAM;
typedef LONG LPARAM;
typedef LONG LRESULT;

#define MAKELPARAM(low, high)	((LPARAM)MAKELONG(low, high))
#define MAKELRESULT(low, high)	((LRESULT)MAKELONG(low, high))

/****** Common pointer types ************************************************/

#ifndef NULL
#define NULL		    0
#endif

typedef char NEAR*          PSTR;
typedef char NEAR*          NPSTR;


typedef char FAR*           LPSTR;
typedef const char FAR*     LPCSTR;

typedef BYTE NEAR*	    PBYTE;
typedef BYTE FAR*	    LPBYTE;

typedef int NEAR*	    PINT;
typedef int FAR*	    LPINT;

typedef WORD NEAR*          PWORD;
typedef WORD FAR*           LPWORD;

typedef long NEAR*	    PLONG;
typedef long FAR*	    LPLONG;

typedef DWORD NEAR*         PDWORD;
typedef DWORD FAR*          LPDWORD;

typedef void FAR*           LPVOID;

#define MAKELP(sel, off)    ((void FAR*)MAKELONG((off), (sel)))
#define SELECTOROF(lp)      HIWORD(lp)
#define OFFSETOF(lp)        LOWORD(lp)

#define FIELDOFFSET(type, field)    ((int)(&((type NEAR*)1)->field)-1)

/****** Common handle types *************************************************/

#ifdef STRICT
typedef const void NEAR*        HANDLE;
#define DECLARE_HANDLE(name)    struct name##__ { int unused; }; \
                                typedef const struct name##__ NEAR* name
#define DECLARE_HANDLE32(name)  struct name##__ { int unused; }; \
                                typedef const struct name##__ FAR* name
#else   /* STRICT */
typedef UINT                    HANDLE;
#define DECLARE_HANDLE(name)    typedef UINT name
#define DECLARE_HANDLE32(name)  typedef DWORD name
#endif  /* !STRICT */

typedef HANDLE* 	    PHANDLE;
typedef HANDLE NEAR*	    SPHANDLE;
typedef HANDLE FAR*	    LPHANDLE;

typedef HANDLE		    HGLOBAL;
typedef HANDLE		    HLOCAL;

typedef HANDLE		    GLOBALHANDLE;
typedef HANDLE		    LOCALHANDLE;

typedef UINT                ATOM;

#ifdef STRICT
typedef void (CALLBACK*     FARPROC)(void);
typedef void (NEAR PASCAL*  NEARPROC)(void);
#else
typedef int (CALLBACK*      FARPROC)();
typedef int (NEAR PASCAL*   NEARPROC)();
#endif

DECLARE_HANDLE(HSTR);

/****** KERNEL typedefs, structures, and functions **************************/

DECLARE_HANDLE(HINSTANCE);
typedef HINSTANCE HMODULE;  /* HMODULEs can be used in place of HINSTANCEs */

#ifndef NOKERNEL

/****** Application entry point function ************************************/

#ifdef STRICT
int PASCAL WinMain(HINSTANCE, HINSTANCE, LPSTR, int);
#endif

/****** System Information **************************************************/

DWORD   WINAPI GetVersion(void);

DWORD   WINAPI GetFreeSpace(UINT);
UINT    WINAPI GetCurrentPDB(void);

UINT    WINAPI GetWindowsDirectory(LPSTR, UINT);
UINT    WINAPI GetSystemDirectory(LPSTR, UINT);

#if (WINVER >= 0x030a)
UINT    WINAPI GetFreeSystemResources(UINT);
#define GFSR_SYSTEMRESOURCES   0x0000
#define GFSR_GDIRESOURCES      0x0001
#define GFSR_USERRESOURCES     0x0002
#endif  /* WINVER >= 0x030a */

DWORD   WINAPI GetWinFlags(void);

#define WF_PMODE	0x0001
#define WF_CPU286	0x0002
#define WF_CPU386	0x0004
#define WF_CPU486	0x0008
#define WF_STANDARD	0x0010
#define WF_WIN286	0x0010
#define WF_ENHANCED	0x0020
#define WF_WIN386	0x0020
#define WF_CPU086	0x0040
#define WF_CPU186	0x0080
#define WF_LARGEFRAME	0x0100
#define WF_SMALLFRAME	0x0200
#define WF_80x87	0x0400
#define WF_PAGING	0x0800
#define WF_WLO          0x8000

LPSTR   WINAPI GetDOSEnvironment(void);

DWORD   WINAPI GetCurrentTime(void);
DWORD   WINAPI GetTickCount(void);
DWORD   WINAPI GetTimerResolution(void);

/****** Error handling ******************************************************/

#if (WINVER >= 0x030a)
#ifndef NOLOGERROR

void    WINAPI LogError(UINT err, void FAR* lpInfo);
void    WINAPI LogParamError(UINT err, FARPROC lpfn, void FAR* param);

/****** LogParamError/LogError values */

/* Error modifier bits */

#define ERR_WARNING		0x8000
#define ERR_PARAM		0x4000

#define ERR_SIZE_MASK		0x3000
#define ERR_BYTE                0x1000
#define ERR_WORD                0x2000
#define ERR_DWORD               0x3000

/****** LogParamError() values */

/* Generic parameter values */
#define ERR_BAD_VALUE           0x6001
#define ERR_BAD_FLAGS           0x6002
#define ERR_BAD_INDEX           0x6003
#define ERR_BAD_DVALUE		0x7004
#define ERR_BAD_DFLAGS		0x7005
#define ERR_BAD_DINDEX		0x7006
#define ERR_BAD_PTR		0x7007
#define ERR_BAD_FUNC_PTR	0x7008
#define ERR_BAD_SELECTOR        0x6009
#define ERR_BAD_STRING_PTR	0x700a
#define ERR_BAD_HANDLE          0x600b

/* KERNEL parameter errors */
#define ERR_BAD_HINSTANCE       0x6020
#define ERR_BAD_HMODULE         0x6021
#define ERR_BAD_GLOBAL_HANDLE   0x6022
#define ERR_BAD_LOCAL_HANDLE    0x6023
#define ERR_BAD_ATOM            0x6024
#define ERR_BAD_HFILE           0x6025

/* USER parameter errors */
#define ERR_BAD_HWND            0x6040
#define ERR_BAD_HMENU           0x6041
#define ERR_BAD_HCURSOR         0x6042
#define ERR_BAD_HICON           0x6043
#define ERR_BAD_HDWP            0x6044
#define ERR_BAD_CID             0x6045
#define ERR_BAD_HDRVR           0x6046

/* GDI parameter errors */
#define ERR_BAD_COORDS		0x7060
#define ERR_BAD_GDI_OBJECT      0x6061
#define ERR_BAD_HDC             0x6062
#define ERR_BAD_HPEN            0x6063
#define ERR_BAD_HFONT           0x6064
#define ERR_BAD_HBRUSH          0x6065
#define ERR_BAD_HBITMAP         0x6066
#define ERR_BAD_HRGN            0x6067
#define ERR_BAD_HPALETTE        0x6068
#define ERR_BAD_HMETAFILE       0x6069


/**** LogError() values */

/* KERNEL errors */
#define ERR_GALLOC              0x0001
#define ERR_GREALLOC            0x0002
#define ERR_GLOCK               0x0003
#define ERR_LALLOC              0x0004
#define ERR_LREALLOC            0x0005
#define ERR_LLOCK               0x0006
#define ERR_ALLOCRES            0x0007
#define ERR_LOCKRES             0x0008
#define ERR_LOADMODULE          0x0009

/* USER errors */
#define ERR_CREATEDLG           0x0040
#define ERR_CREATEDLG2          0x0041
#define ERR_REGISTERCLASS       0x0042
#define ERR_DCBUSY              0x0043
#define ERR_CREATEWND           0x0044
#define ERR_STRUCEXTRA          0x0045
#define ERR_LOADSTR             0x0046
#define ERR_LOADMENU            0x0047
#define ERR_NESTEDBEGINPAINT    0x0048
#define ERR_BADINDEX            0x0049
#define ERR_CREATEMENU          0x004a

/* GDI errors */
#define ERR_CREATEDC            0x0080
#define ERR_CREATEMETA          0x0081
#define ERR_DELOBJSELECTED      0x0082
#define ERR_SELBITMAP           0x0083

/* Debugging support (DEBUG SYSTEM ONLY) */
typedef struct tagWINDEBUGINFO
{
    UINT    flags;
    DWORD   dwOptions;
    DWORD   dwFilter;
    char    achAllocModule[8];
    DWORD   dwAllocBreak;
    DWORD   dwAllocCount;
} WINDEBUGINFO;

BOOL    WINAPI GetWinDebugInfo(WINDEBUGINFO FAR* lpwdi, UINT flags);
BOOL    WINAPI SetWinDebugInfo(const WINDEBUGINFO FAR* lpwdi);

void    FAR __cdecl DebugOutput(UINT flags, LPCSTR lpsz, ...);

/* WINDEBUGINFO flags values */
#define WDI_OPTIONS         0x0001
#define WDI_FILTER          0x0002
#define WDI_ALLOCBREAK      0x0004

/* dwOptions values */
#define DBO_CHECKHEAP       0x0001
#define DBO_BUFFERFILL      0x0004
#define DBO_DISABLEGPTRAPPING 0x0010
#define DBO_CHECKFREE       0x0020

#define DBO_SILENT          0x8000

#define DBO_TRACEBREAK      0x2000
#define DBO_WARNINGBREAK    0x1000
#define DBO_NOERRORBREAK    0x0800
#define DBO_NOFATALBREAK    0x0400
#define DBO_INT3BREAK       0x0100

/* DebugOutput flags values */
#define DBF_TRACE           0x0000
#define DBF_WARNING         0x4000
#define DBF_ERROR           0x8000
#define DBF_FATAL           0xc000

/* dwFilter values */
#define DBF_KERNEL          0x1000
#define DBF_KRN_MEMMAN      0x0001
#define DBF_KRN_LOADMODULE  0x0002
#define DBF_KRN_SEGMENTLOAD 0x0004
#define DBF_USER            0x0800
#define DBF_GDI             0x0400
#define DBF_MMSYSTEM        0x0040
#define DBF_PENWIN          0x0020
#define DBF_APPLICATION     0x0008
#define DBF_DRIVER          0x0010

#endif  /* NOLOGERROR */
#endif  /* WINVER >= 0x030a */

void    WINAPI FatalExit(int);
void    WINAPI FatalAppExit(UINT, LPCSTR);

BOOL    WINAPI ExitWindows(DWORD dwReturnCode, UINT wReserved);

#define EW_RESTARTWINDOWS 0x42
#if (WINVER >= 0x030a)
#define EW_REBOOTSYSTEM   0x43

BOOL    WINAPI ExitWindowsExec(LPCSTR, LPCSTR);
#endif  /* WINVER >= 0x030a */

void    WINAPI DebugBreak(void);
void    WINAPI OutputDebugString(LPCSTR);

/* SetErrorMode() constants */
#define SEM_FAILCRITICALERRORS  0x0001
#define SEM_NOGPFAULTERRORBOX   0x0002
#define SEM_NOOPENFILEERRORBOX  0x8000

UINT    WINAPI SetErrorMode(UINT);

/****** Pointer validation **************************************************/

#if (WINVER >= 0x030a)

BOOL    WINAPI IsBadReadPtr(const void FAR* lp, UINT cb);
BOOL    WINAPI IsBadWritePtr(void FAR* lp, UINT cb);
BOOL    WINAPI IsBadHugeReadPtr(const void _huge* lp, DWORD cb);
BOOL    WINAPI IsBadHugeWritePtr(void _huge* lp, DWORD cb);
BOOL    WINAPI IsBadCodePtr(FARPROC lpfn);
BOOL    WINAPI IsBadStringPtr(const void FAR* lpsz, UINT cchMax);
#endif  /* WINVER >= 0x030a */

/****** Profiling support ***************************************************/

#ifndef NOPROFILER

int     WINAPI ProfInsChk(void);
void    WINAPI ProfSetup(int,int);
void    WINAPI ProfSampRate(int,int);
void    WINAPI ProfStart(void);
void    WINAPI ProfStop(void);
void    WINAPI ProfClear(void);
void    WINAPI ProfFlush(void);
void    WINAPI ProfFinish(void);
#endif  /* NOPROFILER */

/****** Catch/Throw and stack management ************************************/

typedef int CATCHBUF[9];
typedef int FAR* LPCATCHBUF;

int     WINAPI Catch(int FAR*);
void    WINAPI Throw(const int FAR*, int);

void    WINAPI SwitchStackBack(void);
void    WINAPI SwitchStackTo(UINT, UINT, UINT);

/****** Module Management ***************************************************/

#define HINSTANCE_ERROR ((HINSTANCE)32)


HINSTANCE   WINAPI LoadModule(LPCSTR, LPVOID);
BOOL        WINAPI FreeModule(HINSTANCE);

HINSTANCE   WINAPI LoadLibrary(LPCSTR);
void        WINAPI FreeLibrary(HINSTANCE);

UINT    WINAPI WinExec(LPCSTR, UINT);

HMODULE WINAPI GetModuleHandle(LPCSTR);

int     WINAPI GetModuleUsage(HINSTANCE);
int     WINAPI GetModuleFileName(HINSTANCE, LPSTR, int);

FARPROC WINAPI GetProcAddress(HINSTANCE, LPCSTR);

int     WINAPI GetInstanceData(HINSTANCE, BYTE*, int);

HGLOBAL WINAPI GetCodeHandle(FARPROC);

typedef struct tagSEGINFO
{
    UINT offSegment;
    UINT cbSegment;
    UINT flags;
    UINT cbAlloc;
    HGLOBAL h;
    UINT alignShift;
    UINT reserved[2];
} SEGINFO;
typedef SEGINFO FAR* LPSEGINFO;

void    WINAPI GetCodeInfo(FARPROC lpProc, SEGINFO FAR* lpSegInfo);

FARPROC WINAPI MakeProcInstance(FARPROC, HINSTANCE);
void    WINAPI FreeProcInstance(FARPROC);

LONG    WINAPI SetSwapAreaSize(UINT);
void    WINAPI SwapRecording(UINT);
void    WINAPI ValidateCodeSegments(void);

/* Windows Exit Procedure flag values */
#define	WEP_SYSTEM_EXIT	1
#define	WEP_FREE_DLL	0

/****** Task Management *****************************************************/

#endif	/* NOKERNEL */

DECLARE_HANDLE(HTASK);

#ifndef NOKERNEL

UINT    WINAPI GetNumTasks(void);

#if (WINVER >= 0x030a)
BOOL    WINAPI IsTask(HTASK);
#endif  /* WINVER >= 0x030a */

HTASK   WINAPI GetCurrentTask(void);

void    WINAPI Yield(void);
void    WINAPI DirectedYield(HTASK);


/****** Global memory management ********************************************/

#ifndef NOMEMMGR

/* Global Memory Flags */

#define GMEM_FIXED	    0x0000
#define GMEM_MOVEABLE	    0x0002
#define GMEM_NOCOMPACT	    0x0010
#define GMEM_NODISCARD	    0x0020
#define GMEM_ZEROINIT	    0x0040
#define GMEM_MODIFY	    0x0080
#define GMEM_DISCARDABLE    0x0100
#define GMEM_NOT_BANKED     0x1000
#define GMEM_SHARE	    0x2000
#define GMEM_DDESHARE	    0x2000
#define GMEM_NOTIFY	    0x4000
#define GMEM_LOWER          GMEM_NOT_BANKED

#define GHND		    (GMEM_MOVEABLE | GMEM_ZEROINIT)
#define GPTR		    (GMEM_FIXED | GMEM_ZEROINIT)

#define GlobalDiscard(h)    GlobalReAlloc(h, 0L, GMEM_MOVEABLE)

HGLOBAL WINAPI GlobalAlloc(UINT, DWORD);
HGLOBAL WINAPI GlobalReAlloc(HGLOBAL, DWORD, UINT);
HGLOBAL WINAPI GlobalFree(HGLOBAL);

DWORD   WINAPI GlobalDosAlloc(DWORD);
UINT    WINAPI GlobalDosFree(UINT);

#ifdef STRICT
void FAR* WINAPI GlobalLock(HGLOBAL);
#else
char FAR* WINAPI GlobalLock(HGLOBAL);
#endif

BOOL    WINAPI GlobalUnlock(HGLOBAL);

DWORD   WINAPI GlobalSize(HGLOBAL);
DWORD   WINAPI GlobalHandle(UINT);

/* GlobalFlags return flags (in addition to GMEM_DISCARDABLE) */
#define GMEM_DISCARDED	    0x4000
#define GMEM_LOCKCOUNT	    0x00FF
UINT    WINAPI GlobalFlags(HGLOBAL);

#ifdef STRICT
void FAR* WINAPI GlobalWire(HGLOBAL);
#else
char FAR* WINAPI GlobalWire(HGLOBAL);
#endif

BOOL    WINAPI GlobalUnWire(HGLOBAL);

UINT    WINAPI GlobalPageLock(HGLOBAL);
UINT    WINAPI GlobalPageUnlock(HGLOBAL);

void    WINAPI GlobalFix(HGLOBAL);
void    WINAPI GlobalUnfix(HGLOBAL);

HGLOBAL WINAPI GlobalLRUNewest(HGLOBAL);
HGLOBAL WINAPI GlobalLRUOldest(HGLOBAL);

DWORD   WINAPI GlobalCompact(DWORD);

#ifdef STRICT
typedef BOOL (CALLBACK* GNOTIFYPROC)(HGLOBAL);
#else
typedef FARPROC GNOTIFYPROC;
#endif

void    WINAPI GlobalNotify(GNOTIFYPROC);

HGLOBAL WINAPI LockSegment(UINT);
void    WINAPI UnlockSegment(UINT);

#define LockData(dummy)     LockSegment((UINT)-1)
#define UnlockData(dummy)   UnlockSegment((UINT)-1)

UINT    WINAPI AllocSelector(UINT);
UINT    WINAPI FreeSelector(UINT);
UINT    WINAPI AllocDStoCSAlias(UINT);
UINT    WINAPI PrestoChangoSelector(UINT sourceSel, UINT destSel);
DWORD   WINAPI GetSelectorBase(UINT);
UINT    WINAPI SetSelectorBase(UINT, DWORD);
DWORD   WINAPI GetSelectorLimit(UINT);
UINT    WINAPI SetSelectorLimit(UINT, DWORD);

void    WINAPI LimitEmsPages(DWORD);

void    WINAPI ValidateFreeSpaces(void);

/* Low system memory notification message */
#define WM_COMPACTING       0x0041

/***** Local Memory Management */

/* Local Memory Flags */
#define LMEM_FIXED	    0x0000
#define LMEM_MOVEABLE	    0x0002
#define LMEM_NOCOMPACT	    0x0010
#define LMEM_NODISCARD	    0x0020
#define LMEM_ZEROINIT	    0x0040
#define LMEM_MODIFY	    0x0080
#define LMEM_DISCARDABLE    0x0F00

#define LHND		    (LMEM_MOVEABLE | LMEM_ZEROINIT)
#define LPTR		    (LMEM_FIXED | LMEM_ZEROINIT)

#define NONZEROLHND	    (LMEM_MOVEABLE)
#define NONZEROLPTR	    (LMEM_FIXED)


#define LocalDiscard(h)     LocalReAlloc(h, 0, LMEM_MOVEABLE)


HLOCAL  WINAPI LocalAlloc(UINT, UINT);
HLOCAL  WINAPI LocalReAlloc(HLOCAL, UINT, UINT);
HLOCAL  WINAPI LocalFree(HLOCAL);

#ifdef STRICT
void NEAR* WINAPI LocalLock(HLOCAL);
#else
char NEAR* WINAPI LocalLock(HLOCAL);
#endif

BOOL    WINAPI LocalUnlock(HLOCAL);

UINT    WINAPI LocalSize(HLOCAL);
#ifdef STRICT
HLOCAL  WINAPI LocalHandle(void NEAR*);
#else
HLOCAL  WINAPI LocalHandle(UINT);
#endif

/* LocalFlags return flags (in addition to LMEM_DISCARDABLE) */
#define LMEM_DISCARDED	    0x4000
#define LMEM_LOCKCOUNT	    0x00FF

UINT    WINAPI LocalFlags(HLOCAL);

BOOL    WINAPI LocalInit(UINT, UINT, UINT);
UINT    WINAPI LocalCompact(UINT);
UINT    WINAPI LocalShrink(HLOCAL, UINT);

#endif  /* NOMEMMGR */

/****** File I/O ************************************************************/

#ifndef NOLFILEIO

typedef int HFILE;      /* Polymorphic with C runtime file handle type */

#define HFILE_ERROR ((HFILE)-1)

#ifndef NOOPENFILE

/* OpenFile() Structure */
typedef struct tagOFSTRUCT
{
    BYTE cBytes;
    BYTE fFixedDisk;
    UINT nErrCode;
    BYTE reserved[4];
    char szPathName[128];
} OFSTRUCT;
typedef OFSTRUCT*       POFSTRUCT;
typedef OFSTRUCT NEAR* NPOFSTRUCT;
typedef OFSTRUCT FAR*  LPOFSTRUCT;

/* OpenFile() Flags */
#define OF_READ 	    0x0000
#define OF_WRITE	    0x0001
#define OF_READWRITE	    0x0002
#define OF_SHARE_COMPAT	    0x0000
#define OF_SHARE_EXCLUSIVE  0x0010
#define OF_SHARE_DENY_WRITE 0x0020
#define OF_SHARE_DENY_READ  0x0030
#define OF_SHARE_DENY_NONE  0x0040
#define OF_PARSE	    0x0100
#define OF_DELETE	    0x0200
#define OF_VERIFY	    0x0400      /* Used with OF_REOPEN */
#define OF_SEARCH	    0x0400	/* Used without OF_REOPEN */
#define OF_CANCEL	    0x0800
#define OF_CREATE	    0x1000
#define OF_PROMPT	    0x2000
#define OF_EXIST	    0x4000
#define OF_REOPEN	    0x8000

HFILE   WINAPI OpenFile(LPCSTR, OFSTRUCT FAR*, UINT);

#endif  /* NOOPENFILE */

/* _lopen() flags */
#define READ	    0
#define WRITE       1
#define READ_WRITE  2

HFILE   WINAPI _lopen(LPCSTR, int);
HFILE   WINAPI _lcreat(LPCSTR, int);

HFILE   WINAPI _lclose(HFILE);

LONG    WINAPI _llseek(HFILE, LONG, int);

/* _llseek origin values */
#define SEEK_SET 0
#define SEEK_CUR 1
#define SEEK_END 2

UINT    WINAPI _lread(HFILE, void _huge*, UINT);
UINT    WINAPI _lwrite(HFILE, const void _huge*, UINT);

#if (WINVER >= 0x030a)
long	WINAPI _hread(HFILE, void _huge*, long);
long	WINAPI _hwrite(HFILE, const void _huge*, long);
#endif	/* WINVER >= 0x030a */


#endif	/* NOLFILEIO */

/* GetTempFileName() Flags */
#define TF_FORCEDRIVE	    (BYTE)0x80

int     WINAPI GetTempFileName(BYTE, LPCSTR, UINT, LPSTR);
BYTE    WINAPI GetTempDrive(char);

/* GetDriveType return values */
#define DRIVE_REMOVABLE 2
#define DRIVE_FIXED     3
#define DRIVE_REMOTE    4
UINT    WINAPI GetDriveType(int);

UINT    WINAPI SetHandleCount(UINT);

/****** Network support *****************************************************/
UINT WINAPI WNetAddConnection(LPSTR, LPSTR, LPSTR);
UINT WINAPI WNetGetConnection(LPSTR, LPSTR, UINT FAR*);
UINT WINAPI WNetCancelConnection(LPSTR, BOOL);
/* Errors */
#define WN_SUCCESS			0x0000
#define WN_NOT_SUPPORTED		0x0001
#define WN_NET_ERROR			0x0002
#define WN_MORE_DATA			0x0003
#define WN_BAD_POINTER			0x0004
#define WN_BAD_VALUE			0x0005
#define WN_BAD_PASSWORD                 0x0006
#define WN_ACCESS_DENIED		0x0007
#define WN_FUNCTION_BUSY		0x0008
#define WN_WINDOWS_ERROR		0x0009
#define WN_BAD_USER			0x000A
#define WN_OUT_OF_MEMORY		0x000B
#define WN_CANCEL			0x000C
#define WN_CONTINUE			0x000D

/* Connection errors */
#define WN_NOT_CONNECTED		0x0030
#define WN_OPEN_FILES			0x0031
#define WN_BAD_NETNAME			0x0032
#define WN_BAD_LOCALNAME		0x0033
#define WN_ALREADY_CONNECTED		0x0034
#define WN_DEVICE_ERROR 		0x0035
#define WN_CONNECTION_CLOSED		0x0036

/****** Resource Management *************************************************/

DECLARE_HANDLE(HRSRC);

HRSRC   WINAPI FindResource(HINSTANCE, LPCSTR, LPCSTR);
HGLOBAL WINAPI LoadResource(HINSTANCE, HRSRC);
BOOL    WINAPI FreeResource(HGLOBAL);

#ifdef STRICT
void FAR* WINAPI LockResource(HGLOBAL);
#else
char FAR* WINAPI LockResource(HGLOBAL);
#endif

#define     UnlockResource(h)	    GlobalUnlock(h)

DWORD   WINAPI SizeofResource(HINSTANCE, HRSRC);

int     WINAPI AccessResource(HINSTANCE, HRSRC);

HGLOBAL WINAPI AllocResource(HINSTANCE, HRSRC, DWORD);

#ifdef STRICT
typedef HGLOBAL (CALLBACK* RSRCHDLRPROC)(HGLOBAL, HINSTANCE, HRSRC);
#else
typedef FARPROC RSRCHDLRPROC;
#endif

RSRCHDLRPROC WINAPI SetResourceHandler(HINSTANCE, LPCSTR, RSRCHDLRPROC);

#define MAKEINTRESOURCE(i)  ((LPCSTR)MAKELP(0, (i)))

#ifndef NORESOURCE

/* Predefined Resource Types */
#define RT_CURSOR	    MAKEINTRESOURCE(1)
#define RT_BITMAP	    MAKEINTRESOURCE(2)
#define RT_ICON 	    MAKEINTRESOURCE(3)
#define RT_MENU 	    MAKEINTRESOURCE(4)
#define RT_DIALOG	    MAKEINTRESOURCE(5)
#define RT_STRING	    MAKEINTRESOURCE(6)
#define RT_FONTDIR	    MAKEINTRESOURCE(7)
#define RT_FONT 	    MAKEINTRESOURCE(8)
#define RT_ACCELERATOR	    MAKEINTRESOURCE(9)
#define RT_RCDATA	    MAKEINTRESOURCE(10)

#define RT_GROUP_CURSOR     MAKEINTRESOURCE(12)
#define RT_GROUP_ICON	    MAKEINTRESOURCE(14)

#endif  /* NORESOURCE */

#ifdef OEMRESOURCE

/* OEM Resource Ordinal Numbers */
#define OBM_CLOSE	    32754
#define OBM_UPARROW         32753
#define OBM_DNARROW         32752
#define OBM_RGARROW         32751
#define OBM_LFARROW         32750
#define OBM_REDUCE          32749
#define OBM_ZOOM            32748
#define OBM_RESTORE         32747
#define OBM_REDUCED         32746
#define OBM_ZOOMD           32745
#define OBM_RESTORED        32744
#define OBM_UPARROWD        32743
#define OBM_DNARROWD        32742
#define OBM_RGARROWD        32741
#define OBM_LFARROWD        32740
#define OBM_MNARROW         32739
#define OBM_COMBO           32738
#if (WINVER >= 0x030a)
#define OBM_UPARROWI	    32737
#define OBM_DNARROWI	    32736
#define OBM_RGARROWI	    32735
#define OBM_LFARROWI	    32734
#endif  /* WINVER >= 0x030a */

#define OBM_OLD_CLOSE       32767
#define OBM_SIZE            32766
#define OBM_OLD_UPARROW     32765
#define OBM_OLD_DNARROW     32764
#define OBM_OLD_RGARROW     32763
#define OBM_OLD_LFARROW     32762
#define OBM_BTSIZE          32761
#define OBM_CHECK           32760
#define OBM_CHECKBOXES      32759
#define OBM_BTNCORNERS      32758
#define OBM_OLD_REDUCE      32757
#define OBM_OLD_ZOOM        32756
#define OBM_OLD_RESTORE     32755

#define OCR_NORMAL	    32512
#define OCR_IBEAM	    32513
#define OCR_WAIT	    32514
#define OCR_CROSS	    32515
#define OCR_UP		    32516
#define OCR_SIZE	    32640
#define OCR_ICON	    32641
#define OCR_SIZENWSE	    32642
#define OCR_SIZENESW	    32643
#define OCR_SIZEWE	    32644
#define OCR_SIZENS	    32645
#define OCR_SIZEALL	    32646
#define OCR_ICOCUR	    32647

#define OIC_SAMPLE	    32512
#define OIC_HAND	    32513
#define OIC_QUES	    32514
#define OIC_BANG	    32515
#define OIC_NOTE	    32516

#endif  /* OEMRESOURCE */

/****** Atom Management *****************************************************/

#define MAKEINTATOM(i)      ((LPCSTR)MAKELP(0, (i)))

#ifndef NOATOM

BOOL    WINAPI InitAtomTable(int);
ATOM    WINAPI AddAtom(LPCSTR);
ATOM    WINAPI DeleteAtom(ATOM);
ATOM    WINAPI FindAtom(LPCSTR);
UINT    WINAPI GetAtomName(ATOM, LPSTR, int);
ATOM    WINAPI GlobalAddAtom(LPCSTR);
ATOM    WINAPI GlobalDeleteAtom(ATOM);
ATOM    WINAPI GlobalFindAtom(LPCSTR);
UINT    WINAPI GlobalGetAtomName(ATOM, LPSTR, int);
HLOCAL  WINAPI GetAtomHandle(ATOM);

#endif  /* NOATOM */

/****** WIN.INI Support *****************************************************/

/* User Profile Routines */
UINT    WINAPI GetProfileInt(LPCSTR, LPCSTR, int);
int     WINAPI GetProfileString(LPCSTR, LPCSTR, LPCSTR, LPSTR, int);
BOOL    WINAPI WriteProfileString(LPCSTR, LPCSTR, LPCSTR);

UINT    WINAPI GetPrivateProfileInt(LPCSTR, LPCSTR, int, LPCSTR);
int     WINAPI GetPrivateProfileString(LPCSTR, LPCSTR, LPCSTR, LPSTR, int, LPCSTR);
BOOL    WINAPI WritePrivateProfileString(LPCSTR, LPCSTR, LPCSTR, LPCSTR);

#define WM_WININICHANGE	    0x001A

/****** International & Char Translation Support ****************************/

void    WINAPI AnsiToOem(const char _huge*, char _huge*);
void    WINAPI OemToAnsi(const char _huge*, char _huge*);

void    WINAPI AnsiToOemBuff(LPCSTR, LPSTR, UINT);
void    WINAPI OemToAnsiBuff(LPCSTR, LPSTR, UINT);

LPSTR   WINAPI AnsiNext(LPCSTR);
LPSTR   WINAPI AnsiPrev(LPCSTR, LPCSTR);

LPSTR   WINAPI AnsiUpper(LPSTR);
LPSTR   WINAPI AnsiLower(LPSTR);

UINT    WINAPI AnsiUpperBuff(LPSTR, UINT);
UINT    WINAPI AnsiLowerBuff(LPSTR, UINT);


#ifndef  NOLANGUAGE
BOOL    WINAPI IsCharAlpha(char);
BOOL    WINAPI IsCharAlphaNumeric(char);
BOOL    WINAPI IsCharUpper(char);
BOOL    WINAPI IsCharLower(char);
#endif

#ifndef NOLSTRING
int     WINAPI lstrcmp(LPCSTR, LPCSTR);
int     WINAPI lstrcmpi(LPCSTR, LPCSTR);
LPSTR   WINAPI lstrcpy(LPSTR, LPCSTR);
LPSTR   WINAPI lstrcat(LPSTR, LPCSTR);
int     WINAPI lstrlen(LPCSTR);
#if (WINVER >= 0x030a)
LPSTR   WINAPI lstrcpyn(LPSTR, LPCSTR, int);
void    WINAPI hmemcpy(void _huge*, const void _huge*, long);
#endif	/* WINVER >= 0x030a */
#endif	/* NOLSTRING */

#if (WINVER >= 0x030a)
#ifndef NODBCS
BOOL    WINAPI IsDBCSLeadByte(BYTE);
#endif	/* NODBCS */
#endif  /* WINVER >= 0x030a */

int     WINAPI LoadString(HINSTANCE, UINT, LPSTR, int);

/****** Keyboard Driver Functions *******************************************/

#ifndef	NOKEYBOARDINFO

DWORD   WINAPI OemKeyScan(UINT);
UINT    WINAPI VkKeyScan(UINT);
int     WINAPI GetKeyboardType(int);
UINT    WINAPI MapVirtualKey(UINT, UINT);
int     WINAPI GetKBCodePage(void);
int     WINAPI GetKeyNameText(LONG, LPSTR, int);
int     WINAPI ToAscii(UINT wVirtKey, UINT wScanCode, BYTE FAR* lpKeyState, DWORD FAR* lpChar, UINT wFlags);

#endif

#endif  /* NOKERNEL */

/****** GDI typedefs, structures, and functions *****************************/

DECLARE_HANDLE(HDC);

#ifndef NOGDI

#ifdef STRICT
typedef const void NEAR* HGDIOBJ;
#else
DECLARE_HANDLE(HGDIOBJ);
#endif

#endif	/* NOGDI */

DECLARE_HANDLE(HBITMAP);
DECLARE_HANDLE(HPEN);
DECLARE_HANDLE(HBRUSH);
DECLARE_HANDLE(HRGN);
DECLARE_HANDLE(HPALETTE);
DECLARE_HANDLE(HFONT);

typedef struct tagRECT
{
    int left;
    int top;
    int right;
    int bottom;
} RECT;
typedef RECT*      PRECT;
typedef RECT NEAR* NPRECT;
typedef RECT FAR*  LPRECT;

typedef struct tagPOINT
{
    int x;
    int y;
} POINT;
typedef POINT*       PPOINT;
typedef POINT NEAR* NPPOINT;
typedef POINT FAR*  LPPOINT;

#if (WINVER >= 0x030a)
typedef struct tagSIZE
{
    int cx;
    int cy;
} SIZE;
typedef SIZE*       PSIZE;
typedef SIZE NEAR* NPSIZE;
typedef SIZE FAR*  LPSIZE;
#endif  /* WINVER >= 0x030a */

#define MAKEPOINT(l)	    (*((POINT FAR*)&(l)))

#ifndef NOGDI

/****** DC Management *******************************************************/

HDC     WINAPI CreateDC(LPCSTR, LPCSTR, LPCSTR, const void FAR*);
HDC     WINAPI CreateIC(LPCSTR, LPCSTR, LPCSTR, const void FAR*);
HDC     WINAPI CreateCompatibleDC(HDC);

BOOL    WINAPI DeleteDC(HDC);

DWORD   WINAPI GetDCOrg(HDC);

int     WINAPI SaveDC(HDC);
BOOL    WINAPI RestoreDC(HDC, int);

int     WINAPI SetEnvironment(LPCSTR, const void FAR*, UINT);
int     WINAPI GetEnvironment(LPCSTR, void FAR*, UINT);

int     WINAPI MulDiv(int, int, int);

#if (WINVER >= 0x030a)
/* Drawing bounds accumulation APIs */
UINT    WINAPI SetBoundsRect(HDC hDC, const RECT FAR* lprcBounds, UINT flags);
UINT    WINAPI GetBoundsRect(HDC hDC, RECT FAR* lprcBounds, UINT flags);

#define DCB_RESET       0x0001
#define DCB_ACCUMULATE  0x0002
#define DCB_DIRTY	DCB_ACCUMULATE
#define DCB_SET 	(DCB_RESET | DCB_ACCUMULATE)
#define DCB_ENABLE      0x0004
#define DCB_DISABLE     0x0008
#endif  /* WINVER >= 0x030a */

/****** Device Capabilities *************************************************/

int WINAPI GetDeviceCaps(HDC, int);

/* Device Parameters for GetDeviceCaps() */
#define DRIVERVERSION 0
#define TECHNOLOGY    2
#define HORZSIZE      4
#define VERTSIZE      6
#define HORZRES       8
#define VERTRES       10
#define BITSPIXEL     12
#define PLANES        14
#define NUMBRUSHES    16
#define NUMPENS       18
#define NUMMARKERS    20
#define NUMFONTS      22
#define NUMCOLORS     24
#define PDEVICESIZE   26
#define CURVECAPS     28
#define LINECAPS      30
#define POLYGONALCAPS 32
#define TEXTCAPS      34
#define CLIPCAPS      36
#define RASTERCAPS    38
#define ASPECTX       40
#define ASPECTY       42
#define ASPECTXY      44

#define LOGPIXELSX    88
#define LOGPIXELSY    90

#define SIZEPALETTE  104
#define NUMRESERVED  106
#define COLORRES     108

#ifndef NOGDICAPMASKS

/* GetDeviceCaps() return value masks */

/* TECHNOLOGY */
#define DT_PLOTTER          0
#define DT_RASDISPLAY       1
#define DT_RASPRINTER       2
#define DT_RASCAMERA        3
#define DT_CHARSTREAM       4
#define DT_METAFILE         5
#define DT_DISPFILE         6

/* CURVECAPS */
#define CC_NONE             0x0000
#define CC_CIRCLES          0x0001
#define CC_PIE              0x0002
#define CC_CHORD            0x0004
#define CC_ELLIPSES         0x0008
#define CC_WIDE             0x0010
#define CC_STYLED           0x0020
#define CC_WIDESTYLED       0x0040
#define CC_INTERIORS        0x0080
#define CC_ROUNDRECT        0x0100

/* LINECAPS */
#define LC_NONE             0x0000
#define LC_POLYLINE         0x0002
#define LC_MARKER           0x0004
#define LC_POLYMARKER       0x0008
#define LC_WIDE             0x0010
#define LC_STYLED           0x0020
#define LC_WIDESTYLED       0x0040
#define LC_INTERIORS        0x0080

/* POLYGONALCAPS */
#define PC_NONE             0x0000
#define PC_POLYGON          0x0001
#define PC_RECTANGLE        0x0002
#define PC_WINDPOLYGON      0x0004
#define PC_SCANLINE         0x0008
#define PC_WIDE             0x0010
#define PC_STYLED           0x0020
#define PC_WIDESTYLED       0x0040
#define PC_INTERIORS        0x0080

/* TEXTCAPS */
#define TC_OP_CHARACTER     0x0001
#define TC_OP_STROKE        0x0002
#define TC_CP_STROKE        0x0004
#define TC_CR_90            0x0008
#define TC_CR_ANY           0x0010
#define TC_SF_X_YINDEP      0x0020
#define TC_SA_DOUBLE        0x0040
#define TC_SA_INTEGER       0x0080
#define TC_SA_CONTIN        0x0100
#define TC_EA_DOUBLE        0x0200
#define TC_IA_ABLE          0x0400
#define TC_UA_ABLE          0x0800
#define TC_SO_ABLE          0x1000
#define TC_RA_ABLE          0x2000
#define TC_VA_ABLE          0x4000
#define TC_RESERVED         0x8000

/* CLIPCAPS */
#define CP_NONE             0x0000
#define CP_RECTANGLE        0x0001
#define CP_REGION           0x0002

/* RASTERCAPS */
#define RC_NONE
#define RC_BITBLT           0x0001
#define RC_BANDING          0x0002
#define RC_SCALING          0x0004
#define RC_BITMAP64         0x0008
#define RC_GDI20_OUTPUT     0x0010
#define RC_GDI20_STATE      0x0020
#define RC_SAVEBITMAP       0x0040
#define RC_DI_BITMAP        0x0080
#define RC_PALETTE          0x0100
#define RC_DIBTODEV         0x0200
#define RC_BIGFONT          0x0400
#define RC_STRETCHBLT       0x0800
#define RC_FLOODFILL        0x1000
#define RC_STRETCHDIB       0x2000
#define RC_OP_DX_OUTPUT     0x4000
#define RC_DEVBITS          0x8000

#endif  /* NOGDICAPMASKS */

/****** Coordinate transformation support ***********************************/

int     WINAPI SetMapMode(HDC, int);
int     WINAPI GetMapMode(HDC);

/* Map modes */
#define MM_TEXT		    1
#define MM_LOMETRIC	    2
#define MM_HIMETRIC	    3
#define MM_LOENGLISH	    4
#define MM_HIENGLISH	    5
#define MM_TWIPS	    6
#define MM_ISOTROPIC	    7
#define MM_ANISOTROPIC	    8

DWORD   WINAPI SetWindowOrg(HDC, int, int);
DWORD   WINAPI GetWindowOrg(HDC);

DWORD   WINAPI SetWindowExt(HDC, int, int);
DWORD   WINAPI GetWindowExt(HDC);

DWORD   WINAPI OffsetWindowOrg(HDC, int, int);
DWORD   WINAPI ScaleWindowExt(HDC, int, int, int, int);

DWORD   WINAPI SetViewportOrg(HDC, int, int);
DWORD   WINAPI GetViewportOrg(HDC);

DWORD   WINAPI SetViewportExt(HDC, int, int);
DWORD   WINAPI GetViewportExt(HDC);

DWORD   WINAPI OffsetViewportOrg(HDC, int, int);
DWORD   WINAPI ScaleViewportExt(HDC, int, int, int, int);

#if (WINVER >= 0x030a)
BOOL    WINAPI SetWindowOrgEx(HDC, int, int, POINT FAR*);
BOOL    WINAPI GetWindowOrgEx(HDC, POINT FAR*);

BOOL    WINAPI SetWindowExtEx(HDC, int, int, SIZE FAR*);
BOOL    WINAPI GetWindowExtEx(HDC, SIZE FAR*);

BOOL    WINAPI OffsetWindowOrgEx(HDC, int, int, POINT FAR*);
BOOL    WINAPI ScaleWindowExtEx(HDC, int, int, int, int, SIZE FAR*);

BOOL    WINAPI SetViewportExtEx(HDC, int, int, SIZE FAR*);
BOOL    WINAPI GetViewportExtEx(HDC, SIZE FAR*);

BOOL    WINAPI SetViewportOrgEx(HDC, int, int, POINT FAR*);
BOOL    WINAPI GetViewportOrgEx(HDC, POINT FAR*);

BOOL    WINAPI OffsetViewportOrgEx(HDC, int, int, POINT FAR*);
BOOL    WINAPI ScaleViewportExtEx(HDC, int, int, int, int, SIZE FAR*);
#endif  /* WINVER >= 0x030a */

BOOL    WINAPI DPtoLP(HDC, POINT FAR*, int);
BOOL    WINAPI LPtoDP(HDC, POINT FAR*, int);


/* Coordinate Modes */
#define ABSOLUTE    1
#define RELATIVE    2

/****** Color support *******************************************************/

typedef DWORD COLORREF;

#define RGB(r,g,b)          ((COLORREF)(((BYTE)(r)|((WORD)(g)<<8))|(((DWORD)(BYTE)(b))<<16)))

#define GetRValue(rgb)	    ((BYTE)(rgb))
#define GetGValue(rgb)      ((BYTE)(((WORD)(rgb)) >> 8))
#define GetBValue(rgb)	    ((BYTE)((rgb)>>16))

COLORREF WINAPI GetNearestColor(HDC, COLORREF);

#ifndef NOCOLOR

COLORREF WINAPI GetSysColor(int);
void    WINAPI SetSysColors(int, const int FAR*, const COLORREF FAR*);

#define COLOR_SCROLLBAR		   0
#define COLOR_BACKGROUND	   1
#define COLOR_ACTIVECAPTION	   2
#define COLOR_INACTIVECAPTION	   3
#define COLOR_MENU		   4
#define COLOR_WINDOW		   5
#define COLOR_WINDOWFRAME	   6
#define COLOR_MENUTEXT		   7
#define COLOR_WINDOWTEXT	   8
#define COLOR_CAPTIONTEXT  	   9
#define COLOR_ACTIVEBORDER	  10
#define COLOR_INACTIVEBORDER	  11
#define COLOR_APPWORKSPACE	  12
#define COLOR_HIGHLIGHT		  13
#define COLOR_HIGHLIGHTTEXT	  14
#define COLOR_BTNFACE             15
#define COLOR_BTNSHADOW           16
#define COLOR_GRAYTEXT            17
#define COLOR_BTNTEXT		  18
#if (WINVER >= 0x030a)
#define COLOR_INACTIVECAPTIONTEXT 19
#define COLOR_BTNHIGHLIGHT        20
#endif  /* WINVER >= 0x030a */

#endif  /* NOCOLOR */

#define WM_SYSCOLORCHANGE   0x0015

/****** GDI Object Support **************************************************/

#ifndef NOGDIOBJ

HGDIOBJ WINAPI GetStockObject(int);

BOOL    WINAPI IsGDIObject(HGDIOBJ);

BOOL    WINAPI DeleteObject(HGDIOBJ);
HGDIOBJ WINAPI SelectObject(HDC, HGDIOBJ);
int     WINAPI GetObject(HGDIOBJ, int, void FAR*);
BOOL    WINAPI UnrealizeObject(HGDIOBJ);

#ifdef STRICT
typedef (CALLBACK* GOBJENUMPROC)(void FAR*, LPARAM);
#else
typedef FARPROC GOBJENUMPROC;
#endif

#ifdef STRICT
int     WINAPI EnumObjects(HDC, int, GOBJENUMPROC, LPARAM);
#else
int     WINAPI EnumObjects(HDC, int, GOBJENUMPROC, LPSTR);
#endif

/* Object types for EnumObjects() */
#define OBJ_PEN 	    1
#define OBJ_BRUSH	    2

/****** Pen support *********************************************************/

/* Logical Pen */
typedef struct tagLOGPEN
{
    UINT    lopnStyle;
    POINT   lopnWidth;
    COLORREF lopnColor;
} LOGPEN;
typedef LOGPEN*       PLOGPEN;
typedef LOGPEN NEAR* NPLOGPEN;
typedef LOGPEN FAR*  LPLOGPEN;

/* Pen Styles */
#define PS_SOLID	    0
#define PS_DASH             1
#define PS_DOT              2
#define PS_DASHDOT          3
#define PS_DASHDOTDOT       4
#define PS_NULL 	    5
#define PS_INSIDEFRAME 	    6

HPEN    WINAPI CreatePen(int, int, COLORREF);
HPEN    WINAPI CreatePenIndirect(LOGPEN FAR*);

/* Stock pens for use with GetStockObject(); */
#define WHITE_PEN	    6
#define BLACK_PEN	    7
#define NULL_PEN	    8

/****** Brush support *******************************************************/

/* Brush Styles */
#define BS_SOLID	    0
#define BS_NULL		    1
#define BS_HOLLOW	    BS_NULL
#define BS_HATCHED	    2
#define BS_PATTERN	    3
#define BS_INDEXED	    4
#define	BS_DIBPATTERN	    5

/* Hatch Styles */
#define HS_HORIZONTAL       0
#define HS_VERTICAL         1
#define HS_FDIAGONAL        2
#define HS_BDIAGONAL        3
#define HS_CROSS            4
#define HS_DIAGCROSS        5

/* Logical Brush (or Pattern) */
typedef struct tagLOGBRUSH
{
    UINT     lbStyle;
    COLORREF lbColor;
    int      lbHatch;
} LOGBRUSH;
typedef LOGBRUSH*       PLOGBRUSH;
typedef LOGBRUSH NEAR* NPLOGBRUSH;
typedef LOGBRUSH FAR*  LPLOGBRUSH;

typedef LOGBRUSH	    PATTERN;
typedef PATTERN*       PPATTERN;
typedef PATTERN NEAR* NPPATTERN;
typedef PATTERN FAR*  LPPATTERN;

HBRUSH  WINAPI CreateSolidBrush(COLORREF);
HBRUSH  WINAPI CreateHatchBrush(int, COLORREF);
HBRUSH  WINAPI CreatePatternBrush(HBITMAP);
HBRUSH  WINAPI CreateDIBPatternBrush(HGLOBAL, UINT);
HBRUSH  WINAPI CreateBrushIndirect(LOGBRUSH FAR*);

/* Stock brushes for use with GetStockObject() */
#define WHITE_BRUSH	    0
#define LTGRAY_BRUSH	    1
#define GRAY_BRUSH	    2
#define DKGRAY_BRUSH	    3
#define BLACK_BRUSH	    4
#define NULL_BRUSH	    5
#define HOLLOW_BRUSH	    NULL_BRUSH

DWORD   WINAPI SetBrushOrg(HDC, int, int);
DWORD   WINAPI GetBrushOrg(HDC);

#if (WINVER >= 0x030a)
BOOL    WINAPI GetBrushOrgEx(HDC, POINT FAR*);
#endif  /* WINVER >= 0x030a */
#endif	/* NOGDIOBJ */

/****** Region support ******************************************************/

HRGN    WINAPI CreateRectRgn(int, int, int, int);
HRGN    WINAPI CreateRectRgnIndirect(const RECT FAR*);
HRGN    WINAPI CreateEllipticRgnIndirect(const RECT FAR*);
HRGN    WINAPI CreateEllipticRgn(int, int, int, int);
HRGN    WINAPI CreatePolygonRgn(const POINT FAR*, int, int);
HRGN    WINAPI CreatePolyPolygonRgn(const POINT FAR*, const int FAR*, int, int);
HRGN    WINAPI CreateRoundRectRgn(int, int, int, int, int, int);

/* Region type flags */
#define ERROR		    0
#define NULLREGION	    1
#define SIMPLEREGION	    2
#define COMPLEXREGION	    3

void    WINAPI SetRectRgn(HRGN, int, int, int, int);

int     WINAPI CombineRgn(HRGN, HRGN, HRGN, int);

/* CombineRgn() command values */
#define RGN_AND 	    1
#define RGN_OR		    2
#define RGN_XOR 	    3
#define RGN_DIFF	    4
#define RGN_COPY	    5

BOOL    WINAPI EqualRgn(HRGN, HRGN);
int     WINAPI OffsetRgn(HRGN, int, int);

int     WINAPI GetRgnBox(HRGN, RECT FAR*);

BOOL    WINAPI RectInRegion(HRGN, const RECT FAR*);
BOOL    WINAPI PtInRegion(HRGN, int, int);

/****** Color palette Support ************************************************/

#define PALETTERGB(r,g,b)   (0x02000000L | RGB(r,g,b))
#define PALETTEINDEX(i)     ((COLORREF)(0x01000000L | (DWORD)(WORD)(i)))

typedef struct tagPALETTEENTRY
{
    BYTE    peRed;
    BYTE    peGreen;
    BYTE    peBlue;
    BYTE    peFlags;
} PALETTEENTRY;
typedef PALETTEENTRY FAR* LPPALETTEENTRY;

/* Palette entry flags */
#define PC_RESERVED	0x01	/* palette index used for animation */
#define PC_EXPLICIT	0x02	/* palette index is explicit to device */
#define	PC_NOCOLLAPSE	0x04	/* do not match color to system palette */

/* Logical Palette */
typedef struct tagLOGPALETTE
{
    WORD    palVersion;
    WORD    palNumEntries;
    PALETTEENTRY palPalEntry[1];
} LOGPALETTE;
typedef LOGPALETTE*       PLOGPALETTE;
typedef LOGPALETTE NEAR* NPLOGPALETTE;
typedef LOGPALETTE FAR*  LPLOGPALETTE;

HPALETTE WINAPI CreatePalette(const LOGPALETTE FAR*);

HPALETTE WINAPI SelectPalette(HDC, HPALETTE, BOOL);

UINT    WINAPI RealizePalette(HDC);

int     WINAPI UpdateColors(HDC);
void    WINAPI AnimatePalette(HPALETTE, UINT, UINT, const PALETTEENTRY FAR*);

UINT    WINAPI SetPaletteEntries(HPALETTE, UINT, UINT, const PALETTEENTRY FAR*);
UINT    WINAPI GetPaletteEntries(HPALETTE, UINT, UINT, PALETTEENTRY FAR*);

UINT    WINAPI GetNearestPaletteIndex(HPALETTE, COLORREF);

BOOL    WINAPI ResizePalette(HPALETTE, UINT);

UINT    WINAPI GetSystemPaletteEntries(HDC, UINT, UINT, PALETTEENTRY FAR*);

UINT    WINAPI GetSystemPaletteUse(HDC);
UINT    WINAPI SetSystemPaletteUse(HDC, UINT);

/* Get/SetSystemPaletteUse() values */
#define	SYSPAL_STATIC	1
#define	SYSPAL_NOSTATIC 2

/* Palette window messages */
#define WM_QUERYNEWPALETTE  0x030F
#define WM_PALETTEISCHANGING 0x0310
#define WM_PALETTECHANGED   0x0311

/****** Clipping support *****************************************************/

int     WINAPI SelectClipRgn(HDC, HRGN);
int     WINAPI GetClipBox(HDC, RECT FAR*);

int     WINAPI IntersectClipRect(HDC, int, int, int, int);
int     WINAPI OffsetClipRgn(HDC, int, int);
int     WINAPI ExcludeClipRect(HDC, int, int, int, int);

BOOL    WINAPI PtVisible(HDC, int, int);
BOOL    WINAPI RectVisible(HDC, const RECT FAR*);


/****** General drawing support ********************************************/

DWORD   WINAPI MoveTo(HDC, int, int);
DWORD   WINAPI GetCurrentPosition(HDC);

#if (WINVER >= 0x030a)
BOOL    WINAPI MoveToEx(HDC, int, int, POINT FAR*);
BOOL    WINAPI GetCurrentPositionEx(HDC, POINT FAR*);
#endif  /* WINVER >= 0x030a */

BOOL    WINAPI LineTo(HDC, int, int);
BOOL    WINAPI Polyline(HDC, const POINT FAR*, int);

#ifdef STRICT
typedef void (CALLBACK* LINEDDAPROC)(int, int, LPARAM);
#else
typedef FARPROC LINEDDAPROC;
#endif

void    WINAPI LineDDA(int, int, int, int, LINEDDAPROC, LPARAM);

BOOL    WINAPI Rectangle(HDC, int, int, int, int);
BOOL    WINAPI RoundRect(HDC, int, int, int, int, int, int);

BOOL    WINAPI Ellipse(HDC, int, int, int, int);
BOOL    WINAPI Arc(HDC, int, int, int, int, int, int, int, int);
BOOL    WINAPI Chord(HDC, int, int, int, int, int, int, int, int);
BOOL    WINAPI Pie(HDC, int, int, int, int, int, int, int, int);

BOOL    WINAPI Polygon(HDC, const POINT FAR*, int);
BOOL    WINAPI PolyPolygon(HDC, const POINT FAR*, int FAR*, int);

/* PolyFill Modes */
#define ALTERNATE   1
#define WINDING     2

int     WINAPI SetPolyFillMode(HDC, int);
int     WINAPI GetPolyFillMode(HDC);

BOOL    WINAPI FloodFill(HDC, int, int, COLORREF);
BOOL    WINAPI ExtFloodFill(HDC, int, int, COLORREF, UINT);

/* ExtFloodFill style flags */
#define  FLOODFILLBORDER   0
#define  FLOODFILLSURFACE  1

BOOL    WINAPI FillRgn(HDC, HRGN, HBRUSH);
BOOL    WINAPI FrameRgn(HDC, HRGN, HBRUSH, int, int);
BOOL    WINAPI InvertRgn(HDC, HRGN);
BOOL    WINAPI PaintRgn(HDC, HRGN);

/* Rectangle output routines */
int     WINAPI FillRect(HDC, const RECT FAR*, HBRUSH);
int     WINAPI FrameRect(HDC, const RECT FAR*, HBRUSH);
void    WINAPI InvertRect(HDC, const RECT FAR*);

void    WINAPI DrawFocusRect(HDC, const RECT FAR*);


/****** Text support ********************************************************/

BOOL    WINAPI TextOut(HDC, int, int, LPCSTR, int);
LONG    WINAPI TabbedTextOut(HDC, int, int, LPCSTR, int, int, int FAR*, int);
BOOL    WINAPI ExtTextOut(HDC, int, int, UINT, const RECT FAR*, LPCSTR, UINT, int FAR*);

#define ETO_GRAYED	0x0001
#define ETO_OPAQUE	0x0002
#define ETO_CLIPPED	0x0004

DWORD   WINAPI GetTextExtent(HDC, LPCSTR, int);
DWORD   WINAPI GetTabbedTextExtent(HDC, LPCSTR, int, int, int FAR*);

#if (WINVER >= 0x030a)
BOOL    WINAPI GetTextExtentPoint(HDC, LPCSTR, int, SIZE FAR*);
#endif  /* WINVER >= 0x030a */

/* DrawText() Format Flags */
#ifndef NODRAWTEXT
#define DT_TOP		    0x0000
#define DT_LEFT 	    0x0000
#define DT_CENTER	    0x0001
#define DT_RIGHT	    0x0002
#define DT_VCENTER	    0x0004
#define DT_BOTTOM	    0x0008
#define DT_WORDBREAK        0x0010
#define DT_SINGLELINE	    0x0020
#define DT_EXPANDTABS	    0x0040
#define DT_TABSTOP	    0x0080
#define DT_NOCLIP	    0x0100
#define DT_EXTERNALLEADING  0x0200
#define DT_CALCRECT	    0x0400
#define DT_NOPREFIX	    0x0800
#define DT_INTERNAL	    0x1000

int     WINAPI DrawText(HDC, LPCSTR, int, RECT FAR*, UINT);
#endif  /* NODRAWTEXT */

#ifdef STRICT
typedef BOOL (CALLBACK* GRAYSTRINGPROC)(HDC, LPARAM, int);
#else
typedef FARPROC GRAYSTRINGPROC;
#endif

BOOL    WINAPI GrayString(HDC, HBRUSH, GRAYSTRINGPROC, LPARAM, int, int, int, int, int);

BOOL    WINAPI GetCharWidth(HDC, UINT, UINT, int FAR*);

COLORREF WINAPI SetTextColor(HDC, COLORREF);
COLORREF WINAPI GetTextColor(HDC);

COLORREF WINAPI SetBkColor(HDC, COLORREF);
COLORREF WINAPI GetBkColor(HDC);

int     WINAPI SetBkMode(HDC, int);
int     WINAPI GetBkMode(HDC);

/* Background Modes */
#define TRANSPARENT     1
#define OPAQUE          2

UINT    WINAPI SetTextAlign(HDC, UINT);
UINT    WINAPI GetTextAlign(HDC);

/* Text Alignment Options */
#define TA_NOUPDATECP		     0x0000
#define TA_UPDATECP		     0x0001
#define TA_LEFT 		     0x0000
#define TA_RIGHT		     0x0002
#define TA_CENTER		     0x0006
#define TA_TOP			     0x0000
#define TA_BOTTOM		     0x0008
#define TA_BASELINE		     0x0018

int     WINAPI SetTextCharacterExtra(HDC, int);
int     WINAPI GetTextCharacterExtra(HDC);

int     WINAPI SetTextJustification(HDC, int, int);

/****** Font support ********************************************************/

#ifndef NOGDIOBJ
/* Logical Font */
#define LF_FACESIZE	    32
typedef struct tagLOGFONT
{
    int     lfHeight;
    int     lfWidth;
    int     lfEscapement;
    int     lfOrientation;
    int     lfWeight;
    BYTE    lfItalic;
    BYTE    lfUnderline;
    BYTE    lfStrikeOut;
    BYTE    lfCharSet;
    BYTE    lfOutPrecision;
    BYTE    lfClipPrecision;
    BYTE    lfQuality;
    BYTE    lfPitchAndFamily;
    char    lfFaceName[LF_FACESIZE];
} LOGFONT;
typedef LOGFONT*       PLOGFONT;
typedef LOGFONT NEAR* NPLOGFONT;
typedef LOGFONT FAR*  LPLOGFONT;

/* weight values */
#define FW_DONTCARE	    0
#define FW_THIN 	    100
#define FW_EXTRALIGHT	    200
#define FW_LIGHT	    300
#define FW_NORMAL	    400
#define FW_MEDIUM	    500
#define FW_SEMIBOLD	    600
#define FW_BOLD 	    700
#define FW_EXTRABOLD	    800
#define FW_HEAVY	    900

#define FW_ULTRALIGHT	    FW_EXTRALIGHT
#define FW_REGULAR	    FW_NORMAL
#define FW_DEMIBOLD	    FW_SEMIBOLD
#define FW_ULTRABOLD	    FW_EXTRABOLD
#define FW_BLACK	    FW_HEAVY

/* CharSet values */
#define ANSI_CHARSET	    0
#define DEFAULT_CHARSET     1
#define SYMBOL_CHARSET	    2
#define SHIFTJIS_CHARSET    128
#define HANGEUL_CHARSET     129
#define CHINESEBIG5_CHARSET 136
#define OEM_CHARSET	    255

/* OutPrecision values */
#define OUT_DEFAULT_PRECIS	0
#define OUT_STRING_PRECIS	1
#define OUT_CHARACTER_PRECIS	2
#define OUT_STROKE_PRECIS	3
#if (WINVER >= 0x030a)
#define OUT_TT_PRECIS		4
#define OUT_DEVICE_PRECIS	5
#define OUT_RASTER_PRECIS	6
#define OUT_TT_ONLY_PRECIS	7
#endif  /* WINVER >= 0x030a */

/* ClipPrecision values */
#define CLIP_DEFAULT_PRECIS     0x00
#define CLIP_CHARACTER_PRECIS   0x01
#define CLIP_STROKE_PRECIS      0x02
#define CLIP_MASK		0x0F
#if (WINVER >= 0x030a)
#define CLIP_LH_ANGLES		0x10
#define CLIP_TT_ALWAYS		0x20
#define CLIP_EMBEDDED		0x80
#endif  /* WINVER >= 0x030a */

/* Quality values */
#define DEFAULT_QUALITY     0
#define DRAFT_QUALITY       1
#define PROOF_QUALITY       2

/* PitchAndFamily pitch values (low 4 bits) */
#define DEFAULT_PITCH       0x00
#define FIXED_PITCH         0x01
#define VARIABLE_PITCH      0x02

/* PitchAndFamily family values (high 4 bits) */
#define FF_DONTCARE         0x00
#define FF_ROMAN            0x10
#define FF_SWISS            0x20
#define FF_MODERN           0x30
#define FF_SCRIPT           0x40
#define FF_DECORATIVE       0x50

HFONT   WINAPI CreateFont(int, int, int, int, int, BYTE, BYTE, BYTE, BYTE, BYTE, BYTE, BYTE, BYTE, LPCSTR);
HFONT   WINAPI CreateFontIndirect(const LOGFONT FAR*);

/* Stock fonts for use with GetStockObject() */
#define OEM_FIXED_FONT	    10
#define ANSI_FIXED_FONT     11
#define ANSI_VAR_FONT	    12
#define SYSTEM_FONT	    13
#define DEVICE_DEFAULT_FONT 14
#define DEFAULT_PALETTE     15
#define SYSTEM_FIXED_FONT   16


DWORD   WINAPI SetMapperFlags(HDC, DWORD);
#define ASPECT_FILTERING	     0x00000001L

int     WINAPI AddFontResource(LPCSTR);
BOOL    WINAPI RemoveFontResource(LPCSTR);

#define WM_FONTCHANGE	    0x001D

int     WINAPI GetTextFace(HDC, int, LPSTR);

DWORD   WINAPI GetAspectRatioFilter(HDC);
#if (WINVER >= 0x030a)
BOOL    WINAPI GetAspectRatioFilterEx(HDC, SIZE FAR*);
#endif  /* WINVER >= 0x030a */

#endif	/* NOGDIOBJ */

#ifndef NOTEXTMETRIC

typedef struct tagTEXTMETRIC
{
    int     tmHeight;
    int     tmAscent;
    int     tmDescent;
    int     tmInternalLeading;
    int     tmExternalLeading;
    int     tmAveCharWidth;
    int     tmMaxCharWidth;
    int     tmWeight;
    BYTE    tmItalic;
    BYTE    tmUnderlined;
    BYTE    tmStruckOut;
    BYTE    tmFirstChar;
    BYTE    tmLastChar;
    BYTE    tmDefaultChar;
    BYTE    tmBreakChar;
    BYTE    tmPitchAndFamily;
    BYTE    tmCharSet;
    int     tmOverhang;
    int     tmDigitizedAspectX;
    int     tmDigitizedAspectY;
} TEXTMETRIC;
typedef TEXTMETRIC*       PTEXTMETRIC;
typedef TEXTMETRIC NEAR* NPTEXTMETRIC;
typedef TEXTMETRIC FAR*  LPTEXTMETRIC;

/* tmPitchAndFamily values */
#define TMPF_FIXED_PITCH    0x01
#define TMPF_VECTOR	    0x02
#define TMPF_DEVICE	    0x08
#if (WINVER >= 0x030a)
#define TMPF_TRUETYPE	    0x04
#endif  /* WINVER >= 0x030a */

BOOL    WINAPI GetTextMetrics(HDC, TEXTMETRIC FAR*);

#if (WINVER >= 0x030a)
#ifndef NOSCALABLEFONT

typedef struct tagPANOSE
{
    BYTE    bFamilyType;
    BYTE    bSerifStyle;
    BYTE    bWeight;
    BYTE    bProportion;
    BYTE    bContrast;
    BYTE    bStrokeVariation;
    BYTE    bArmStyle;
    BYTE    bLetterform;
    BYTE    bMidline;
    BYTE    bXHeight;
} PANOSE, FAR* LPPANOSE;

typedef struct tagOUTLINETEXTMETRIC
{
    UINT    otmSize;
    TEXTMETRIC otmTextMetrics;
    BYTE    otmFiller;
    PANOSE  otmPanoseNumber;
    UINT    otmfsSelection;
    UINT    otmfsType;
    int     otmsCharSlopeRise;
    int     otmsCharSlopeRun;
    int     otmItalicAngle;
    UINT    otmEMSquare;
    int     otmAscent;
    int     otmDescent;
    UINT    otmLineGap;
    UINT    otmsCapEmHeight;
    UINT    otmsXHeight;
    RECT    otmrcFontBox;
    int     otmMacAscent;
    int     otmMacDescent;
    UINT    otmMacLineGap;
    UINT    otmusMinimumPPEM;
    POINT   otmptSubscriptSize;
    POINT   otmptSubscriptOffset;
    POINT   otmptSuperscriptSize;
    POINT   otmptSuperscriptOffset;
    UINT    otmsStrikeoutSize;
    int     otmsStrikeoutPosition;
    int     otmsUnderscorePosition;
    int     otmsUnderscoreSize;
    PSTR    otmpFamilyName;
    PSTR    otmpFaceName;
    PSTR    otmpStyleName;
    PSTR    otmpFullName;
} OUTLINETEXTMETRIC, FAR* LPOUTLINETEXTMETRIC;

WORD    WINAPI GetOutlineTextMetrics(HDC, UINT, OUTLINETEXTMETRIC FAR*);

#endif  /* WINVER >= 0x030a */
#endif  /* NOSCALABLEFONT */

#ifndef NOGDIOBJ
#if (WINVER >= 0x030a)

/* Structure passed to FONTENUMPROC */
/* NOTE: NEWTEXTMETRIC is the same as TEXTMETRIC plus 4 new fields */
typedef struct tagNEWTEXTMETRIC
{
    int     tmHeight;
    int     tmAscent;
    int     tmDescent;
    int     tmInternalLeading;
    int     tmExternalLeading;
    int     tmAveCharWidth;
    int     tmMaxCharWidth;
    int     tmWeight;
    BYTE    tmItalic;
    BYTE    tmUnderlined;
    BYTE    tmStruckOut;
    BYTE    tmFirstChar;
    BYTE    tmLastChar;
    BYTE    tmDefaultChar;
    BYTE    tmBreakChar;
    BYTE    tmPitchAndFamily;
    BYTE    tmCharSet;
    int     tmOverhang;
    int     tmDigitizedAspectX;
    int     tmDigitizedAspectY;
    DWORD   ntmFlags;
    UINT    ntmSizeEM;
    UINT    ntmCellHeight;
    UINT    ntmAvgWidth;
} NEWTEXTMETRIC;
typedef NEWTEXTMETRIC*       PNEWTEXTMETRIC;
typedef NEWTEXTMETRIC NEAR* NPNEWTEXTMETRIC;
typedef NEWTEXTMETRIC FAR*  LPNEWTEXTMETRIC;

/* ntmFlags field flags */
#define NTM_REGULAR	0x00000040L
#define NTM_BOLD	0x00000020L
#define NTM_ITALIC	0x00000001L

#define LF_FULLFACESIZE     64

/* Structure passed to FONTENUMPROC */
typedef struct tagENUMLOGFONT
{
    LOGFONT elfLogFont;
    char    elfFullName[LF_FULLFACESIZE];
    char    elfStyle[LF_FACESIZE];
} ENUMLOGFONT, FAR* LPENUMLOGFONT;

#endif  /* WINVER >= 0x030a */
#endif  /* NOGDIOBJ */

#ifdef STRICT
#ifndef NOGDIOBJ

typedef int (CALLBACK* OLDFONTENUMPROC)(const LOGFONT FAR*, const TEXTMETRIC FAR*, int, LPARAM);

#if (WINVER >= 0x030a)
typedef int (CALLBACK* FONTENUMPROC)(const ENUMLOGFONT FAR*, const NEWTEXTMETRIC FAR*, int, LPARAM);

int     WINAPI EnumFontFamilies(HDC, LPCSTR, FONTENUMPROC, LPARAM);

#else   /* WINVER >= 0x030a */
typedef OLDFONTENUMPROC FONTENUMPROC;
#endif  /* WINVER >= 0x030a) */

int     WINAPI EnumFonts(HDC, LPCSTR, OLDFONTENUMPROC, LPARAM);
#endif  /* NOGDIOBJ */

#else   /* STRICT */

typedef FARPROC OLDFONTENUMPROC;
typedef FARPROC FONTENUMPROC;

int     WINAPI EnumFonts(HDC, LPCSTR, OLDFONTENUMPROC, LPSTR);

#if (WINVER >= 0x030a)
int     WINAPI EnumFontFamilies(HDC, LPCSTR, FONTENUMPROC, LPSTR);
#endif  /* WINVER >= 0x030a */

#endif  /* !STRICT */

/* EnumFonts font type values */
#define RASTER_FONTTYPE     0x0001
#define DEVICE_FONTTYPE     0X0002
#if (WINVER >= 0x030a)
#define TRUETYPE_FONTTYPE   0x0004
#endif  /* WINVER >= 0x030a */

#endif  /* NOTEXTMETRIC */

#ifndef NOSCALABLEFONT
#if (WINVER >= 0x030a)

DWORD   WINAPI GetFontData(HDC, DWORD, DWORD, void FAR*, DWORD);
BOOL	WINAPI CreateScalableFontResource(UINT, LPCSTR, LPCSTR, LPCSTR);

typedef struct tagGLYPHMETRICS
{
    UINT    gmBlackBoxX;
    UINT    gmBlackBoxY;
    POINT   gmptGlyphOrigin;
    int     gmCellIncX;
    int     gmCellIncY;
} GLYPHMETRICS, FAR* LPGLYPHMETRICS;

typedef struct tagFIXED
{
    UINT    fract;
    int     value;
} FIXED, FAR* LPFIXED;

typedef struct tagMAT2
{
    FIXED  eM11;
    FIXED  eM12;
    FIXED  eM21;
    FIXED  eM22;
} MAT2, FAR* LPMAT2;

DWORD   WINAPI GetGlyphOutline(HDC, UINT, UINT, GLYPHMETRICS FAR*, DWORD, void FAR*, const MAT2 FAR*);

/* GetGlyphOutline constants */
#define GGO_METRICS        0
#define GGO_BITMAP         1
#define GGO_NATIVE         2

#define TT_POLYGON_TYPE   24

#define TT_PRIM_LINE       1
#define TT_PRIM_QSPLINE    2

typedef struct tagPOINTFX
{
    FIXED x;
    FIXED y;
} POINTFX, FAR* LPPOINTFX;

typedef struct tagTTPOLYCURVE
{
    UINT    wType;
    UINT    cpfx;
    POINTFX apfx[1];
} TTPOLYCURVE, FAR* LPTTPOLYCURVE;

typedef struct tagTTPOLYGONHEADER
{
    DWORD   cb;
    DWORD   dwType;
    POINTFX pfxStart;
} TTPOLYGONHEADER, FAR* LPTTPOLYGONHEADER;

typedef struct tagABC
{
    int   abcA;
    UINT  abcB;
    int   abcC;
} ABC;
typedef ABC FAR* LPABC;

BOOL    WINAPI GetCharABCWidths(HDC, UINT, UINT, ABC FAR*);

typedef struct tagKERNINGPAIR
{
    WORD wFirst;
    WORD wSecond;
    int  iKernAmount;
} KERNINGPAIR, FAR* LPKERNINGPAIR;

int     WINAPI GetKerningPairs(HDC, int, KERNINGPAIR FAR*);

typedef struct tagRASTERIZER_STATUS
{
    int   nSize;
    int   wFlags;
    int   nLanguageID;
} RASTERIZER_STATUS;
typedef RASTERIZER_STATUS FAR* LPRASTERIZER_STATUS;

/* bits defined in wFlags of RASTERIZER_STATUS */
#define TT_AVAILABLE	0x0001
#define TT_ENABLED	0x0002

BOOL    WINAPI GetRasterizerCaps(RASTERIZER_STATUS FAR*, int);

#endif  /* WINVER >= 0x030a */
#endif  /* NOSCALABLEFONT */

/****** Bitmap support ******************************************************/

#ifndef NOBITMAP
typedef struct tagBITMAP
{
    int     bmType;
    int     bmWidth;
    int     bmHeight;
    int     bmWidthBytes;
    BYTE    bmPlanes;
    BYTE    bmBitsPixel;
    void FAR* bmBits;
} BITMAP;
typedef BITMAP*       PBITMAP;
typedef BITMAP NEAR* NPBITMAP;
typedef BITMAP FAR*  LPBITMAP;

/* Bitmap Header structures */
typedef struct tagRGBTRIPLE
{
    BYTE    rgbtBlue;
    BYTE    rgbtGreen;
    BYTE    rgbtRed;
} RGBTRIPLE;
typedef RGBTRIPLE FAR* LPRGBTRIPLE;

typedef struct tagRGBQUAD
{
    BYTE    rgbBlue;
    BYTE    rgbGreen;
    BYTE    rgbRed;
    BYTE    rgbReserved;
} RGBQUAD;
typedef RGBQUAD FAR* LPRGBQUAD;

/* structures for defining DIBs */
typedef struct tagBITMAPCOREHEADER
{
    DWORD   bcSize;
    short   bcWidth;
    short   bcHeight;
    WORD    bcPlanes;
    WORD    bcBitCount;
} BITMAPCOREHEADER;
typedef BITMAPCOREHEADER*      PBITMAPCOREHEADER;
typedef BITMAPCOREHEADER FAR* LPBITMAPCOREHEADER;

typedef struct tagBITMAPINFOHEADER
{
    DWORD   biSize;
    LONG    biWidth;
    LONG    biHeight;
    WORD    biPlanes;
    WORD    biBitCount;
    DWORD   biCompression;
    DWORD   biSizeImage;
    LONG    biXPelsPerMeter;
    LONG    biYPelsPerMeter;
    DWORD   biClrUsed;
    DWORD   biClrImportant;
} BITMAPINFOHEADER;
typedef BITMAPINFOHEADER*      PBITMAPINFOHEADER;
typedef BITMAPINFOHEADER FAR* LPBITMAPINFOHEADER;

/* constants for the biCompression field */
#define BI_RGB      0L
#define BI_RLE8     1L
#define BI_RLE4     2L

typedef struct tagBITMAPINFO
{
    BITMAPINFOHEADER bmiHeader;
    RGBQUAD	     bmiColors[1];
} BITMAPINFO;
typedef BITMAPINFO*     PBITMAPINFO;
typedef BITMAPINFO FAR* LPBITMAPINFO;

typedef struct tagBITMAPCOREINFO
{
    BITMAPCOREHEADER bmciHeader;
    RGBTRIPLE	     bmciColors[1];
} BITMAPCOREINFO;
typedef BITMAPCOREINFO*      PBITMAPCOREINFO;
typedef BITMAPCOREINFO FAR* LPBITMAPCOREINFO;

typedef struct tagBITMAPFILEHEADER
{
    UINT    bfType;
    DWORD   bfSize;
    UINT    bfReserved1;
    UINT    bfReserved2;
    DWORD   bfOffBits;
} BITMAPFILEHEADER;
typedef BITMAPFILEHEADER*      PBITMAPFILEHEADER;
typedef BITMAPFILEHEADER FAR* LPBITMAPFILEHEADER;


HBITMAP WINAPI CreateBitmap(int, int, UINT, UINT, const void FAR*);
HBITMAP WINAPI CreateBitmapIndirect(BITMAP FAR* );
HBITMAP WINAPI CreateCompatibleBitmap(HDC, int, int);
HBITMAP WINAPI CreateDiscardableBitmap(HDC, int, int);
HBITMAP WINAPI CreateDIBitmap(HDC, BITMAPINFOHEADER FAR*, DWORD, const void FAR*, BITMAPINFO FAR*, UINT);

HBITMAP WINAPI LoadBitmap(HINSTANCE, LPCSTR);

/* DIB color table identifiers */
#define DIB_RGB_COLORS  0
#define DIB_PAL_COLORS  1

/* constants for CreateDIBitmap */
#define CBM_INIT        0x00000004L
#endif	/* NOBITMAP */

#ifndef NORASTEROPS

/* Binary raster ops */
#define R2_BLACK            1
#define R2_NOTMERGEPEN      2
#define R2_MASKNOTPEN       3
#define R2_NOTCOPYPEN       4
#define R2_MASKPENNOT       5
#define R2_NOT              6
#define R2_XORPEN           7
#define R2_NOTMASKPEN       8
#define R2_MASKPEN          9
#define R2_NOTXORPEN        10
#define R2_NOP              11
#define R2_MERGENOTPEN      12
#define R2_COPYPEN          13
#define R2_MERGEPENNOT      14
#define R2_MERGEPEN         15
#define R2_WHITE            16

/* Ternary raster operations */
#define SRCCOPY             0x00CC0020L
#define SRCPAINT            0x00EE0086L
#define SRCAND              0x008800C6L
#define SRCINVERT           0x00660046L
#define SRCERASE            0x00440328L
#define NOTSRCCOPY          0x00330008L
#define NOTSRCERASE         0x001100A6L
#define MERGECOPY           0x00C000CAL
#define MERGEPAINT          0x00BB0226L
#define PATCOPY             0x00F00021L
#define PATPAINT            0x00FB0A09L
#define PATINVERT           0x005A0049L
#define DSTINVERT           0x00550009L
#define BLACKNESS           0x00000042L
#define WHITENESS           0x00FF0062L

#endif  /* NORASTEROPS */

#ifndef NOBITMAP
BOOL    WINAPI BitBlt(HDC, int, int, int, int, HDC, int, int, DWORD);

BOOL    WINAPI PatBlt(HDC, int, int, int, int, DWORD);

BOOL    WINAPI StretchBlt(HDC, int, int, int, int, HDC, int, int, int, int, DWORD);
int     WINAPI StretchDIBits(HDC, int, int, int, int, int,
                        int, int, int, const void FAR*, LPBITMAPINFO, UINT, DWORD);

COLORREF WINAPI SetPixel(HDC, int, int, COLORREF);
COLORREF WINAPI GetPixel(HDC, int, int);

/* StretchBlt() Modes */
#define BLACKONWHITE	1
#define WHITEONBLACK	2
#define COLORONCOLOR	3

/* new StretchBlt() Modes (simpler names) */
#define STRETCH_ANDSCANS        1
#define STRETCH_ORSCANS         2
#define STRETCH_DELETESCANS     3

int     WINAPI SetStretchBltMode(HDC, int);
int     WINAPI GetStretchBltMode(HDC);

DWORD   WINAPI SetBitmapDimension(HBITMAP, int, int);
DWORD   WINAPI GetBitmapDimension(HBITMAP);
#if (WINVER >= 0x030a)
BOOL    WINAPI SetBitmapDimensionEx(HBITMAP, int, int, SIZE FAR*);
BOOL    WINAPI GetBitmapDimensionEx(HBITMAP, SIZE FAR*);
#endif  /* WINVER >= 0x030a */
int     WINAPI SetROP2(HDC, int);
int     WINAPI GetROP2(HDC);

LONG    WINAPI SetBitmapBits(HBITMAP, DWORD, const void FAR*);
LONG    WINAPI GetBitmapBits(HBITMAP, LONG, void FAR*);

int     WINAPI SetDIBits(HDC, HBITMAP, UINT, UINT, const void FAR*, BITMAPINFO FAR*, UINT);
int     WINAPI GetDIBits(HDC, HBITMAP, UINT, UINT, void FAR*, BITMAPINFO FAR*, UINT);

int     WINAPI SetDIBitsToDevice(HDC, int, int, int, int, int, int, UINT, UINT,
                    void FAR*, BITMAPINFO FAR*, UINT);
#endif	/* NOBITMAP */

/****** Metafile support ****************************************************/

#ifndef NOMETAFILE

DECLARE_HANDLE(HMETAFILE);

HDC     WINAPI CreateMetaFile(LPCSTR);
HMETAFILE WINAPI CloseMetaFile(HDC);

HMETAFILE WINAPI GetMetaFile(LPCSTR);
BOOL      WINAPI DeleteMetaFile(HMETAFILE);
HMETAFILE WINAPI CopyMetaFile(HMETAFILE, LPCSTR);

BOOL    WINAPI PlayMetaFile(HDC, HMETAFILE);

HGLOBAL WINAPI GetMetaFileBits(HMETAFILE);
HMETAFILE WINAPI SetMetaFileBits(HGLOBAL);
#if (WINVER >= 0x030a)
HMETAFILE WINAPI SetMetaFileBitsBetter(HGLOBAL);
#endif  /* WINVER >= 0x030a */

/* Clipboard Metafile Picture Structure */
typedef struct tagMETAFILEPICT
{
    int     mm;
    int     xExt;
    int     yExt;
    HMETAFILE hMF;
} METAFILEPICT;
typedef METAFILEPICT FAR* LPMETAFILEPICT;

typedef struct tagMETAHEADER
{
    UINT    mtType;
    UINT    mtHeaderSize;
    UINT    mtVersion;
    DWORD   mtSize;
    UINT    mtNoObjects;
    DWORD   mtMaxRecord;
    UINT    mtNoParameters;
} METAHEADER;

typedef struct tagHANDLETABLE
{
    HGDIOBJ objectHandle[1];
} HANDLETABLE;
typedef HANDLETABLE*      PHANDLETABLE;
typedef HANDLETABLE FAR* LPHANDLETABLE;

typedef struct tagMETARECORD
{
    DWORD   rdSize;
    UINT    rdFunction;
    UINT    rdParm[1];
} METARECORD;
typedef METARECORD*      PMETARECORD;
typedef METARECORD FAR* LPMETARECORD;

/* Metafile Functions */
#define META_SETBKCOLOR		     0x0201
#define META_SETBKMODE		     0x0102
#define META_SETMAPMODE		     0x0103
#define META_SETROP2		     0x0104
#define META_SETRELABS		     0x0105
#define META_SETPOLYFILLMODE	     0x0106
#define META_SETSTRETCHBLTMODE	     0x0107
#define META_SETTEXTCHAREXTRA	     0x0108
#define META_SETTEXTCOLOR	     0x0209
#define META_SETTEXTJUSTIFICATION    0x020A
#define META_SETWINDOWORG	     0x020B
#define META_SETWINDOWEXT	     0x020C
#define META_SETVIEWPORTORG	     0x020D
#define META_SETVIEWPORTEXT	     0x020E
#define META_OFFSETWINDOWORG	     0x020F
#define META_SCALEWINDOWEXT	     0x0410
#define META_OFFSETVIEWPORTORG	     0x0211
#define META_SCALEVIEWPORTEXT	     0x0412
#define META_LINETO		     0x0213
#define META_MOVETO		     0x0214
#define META_EXCLUDECLIPRECT	     0x0415
#define META_INTERSECTCLIPRECT	     0x0416
#define META_ARC		     0x0817
#define META_ELLIPSE		     0x0418
#define META_FLOODFILL		     0x0419
#define META_PIE		     0x081A
#define META_RECTANGLE		     0x041B
#define META_ROUNDRECT		     0x061C
#define META_PATBLT		     0x061D
#define META_SAVEDC		     0x001E
#define META_SETPIXEL		     0x041F
#define META_OFFSETCLIPRGN	     0x0220
#define META_TEXTOUT		     0x0521
#define META_BITBLT		     0x0922
#define META_STRETCHBLT		     0x0B23
#define META_POLYGON		     0x0324
#define META_POLYLINE		     0x0325
#define META_ESCAPE		     0x0626
#define META_RESTOREDC		     0x0127
#define META_FILLREGION		     0x0228
#define META_FRAMEREGION	     0x0429
#define META_INVERTREGION	     0x012A
#define META_PAINTREGION	     0x012B
#define META_SELECTCLIPREGION	     0x012C
#define META_SELECTOBJECT	     0x012D
#define META_SETTEXTALIGN	     0x012E
#define META_DRAWTEXT		     0x062F

#define	META_CHORD		     0x0830
#define	META_SETMAPPERFLAGS	     0x0231
#define	META_EXTTEXTOUT		     0x0a32
#define	META_SETDIBTODEV	     0x0d33
#define	META_SELECTPALETTE	     0x0234
#define	META_REALIZEPALETTE	     0x0035
#define	META_ANIMATEPALETTE	     0x0436
#define	META_SETPALENTRIES	     0x0037
#define	META_POLYPOLYGON	     0x0538
#define	META_RESIZEPALETTE	     0x0139

#define	META_DIBBITBLT		     0x0940
#define	META_DIBSTRETCHBLT	     0x0b41
#define	META_DIBCREATEPATTERNBRUSH   0x0142
#define	META_STRETCHDIB		     0x0f43

#define META_EXTFLOODFILL	     0x0548

#define META_RESETDC		     0x014C
#define META_STARTDOC		     0x014D
#define META_STARTPAGE		     0x004F
#define META_ENDPAGE		     0x0050
#define META_ABORTDOC		     0x0052
#define META_ENDDOC		     0x005E

#define	META_DELETEOBJECT	     0x01f0

#define	META_CREATEPALETTE	     0x00f7
#define META_CREATEBRUSH	     0x00F8
#define META_CREATEPATTERNBRUSH	     0x01F9
#define META_CREATEPENINDIRECT	     0x02FA
#define META_CREATEFONTINDIRECT	     0x02FB
#define META_CREATEBRUSHINDIRECT     0x02FC
#define META_CREATEBITMAPINDIRECT    0x02FD
#define META_CREATEBITMAP	     0x06FE
#define META_CREATEREGION	     0x06FF

void    WINAPI PlayMetaFileRecord(HDC, HANDLETABLE FAR*, METARECORD FAR*, UINT);

#ifdef STRICT
typedef int (CALLBACK* MFENUMPROC)(HDC, HANDLETABLE FAR*, METARECORD FAR*, int, LPARAM);
#else
typedef FARPROC MFENUMPROC;
#endif

BOOL    WINAPI EnumMetaFile(HDC, HMETAFILE, MFENUMPROC, LPARAM);

#endif  /* NOMETAFILE */

/****** Printing support ****************************************************/

#ifdef STRICT
typedef BOOL (CALLBACK* ABORTPROC)(HDC, int);
#else
typedef FARPROC ABORTPROC;
#endif

#if (WINVER >= 0x030a)

typedef struct
{
    int     cbSize;
    LPCSTR  lpszDocName;
    LPCSTR  lpszOutput;
}   DOCINFO;
typedef DOCINFO FAR* LPDOCINFO;

int     WINAPI StartDoc(HDC, DOCINFO FAR*);
int     WINAPI StartPage(HDC);
int     WINAPI EndPage(HDC);
int     WINAPI EndDoc(HDC);
int     WINAPI AbortDoc(HDC);

int     WINAPI SetAbortProc(HDC, ABORTPROC);
HANDLE  WINAPI SpoolFile(LPSTR, LPSTR, LPSTR, LPSTR);
#endif  /* WINVER >= 0x030a */

BOOL    WINAPI QueryAbort(HDC, int);

/* Spooler Error Codes */
#define SP_NOTREPORTED		     0x4000
#define SP_ERROR		     (-1)
#define SP_APPABORT		     (-2)
#define SP_USERABORT		     (-3)
#define SP_OUTOFDISK		     (-4)
#define SP_OUTOFMEMORY		     (-5)

#define PR_JOBSTATUS		     0x0000

#endif  /* NOGDI  */

/* Spooler status notification message */
#define WM_SPOOLERSTATUS	    0x002A

#ifndef NOGDI

/******* GDI Escape support *************************************************/

int     WINAPI Escape(HDC, int, int, LPCSTR, void FAR*);

/* GDI Escapes */
#define NEWFRAME		     1
#define ABORTDOC		     2
#define NEXTBAND		     3
#define SETCOLORTABLE		     4
#define GETCOLORTABLE		     5
#define FLUSHOUTPUT		     6
#define DRAFTMODE		     7
#define QUERYESCSUPPORT 	     8
#define SETABORTPROC		     9
#define STARTDOC		     10
#define ENDDOC			     11
#define GETPHYSPAGESIZE 	     12
#define GETPRINTINGOFFSET	     13
#define GETSCALINGFACTOR	     14
#define MFCOMMENT		     15
#define GETPENWIDTH		     16
#define SETCOPYCOUNT		     17
#define SELECTPAPERSOURCE	     18
#define DEVICEDATA		     19
#define PASSTHROUGH		     19
#define GETTECHNOLGY		     20
#define GETTECHNOLOGY		     20
#define SETLINECAP		     21
#define SETLINEJOIN		     22
#define SETMITERLIMIT		     23
#define BANDINFO		     24
#define DRAWPATTERNRECT 	     25
#define GETVECTORPENSIZE	     26
#define GETVECTORBRUSHSIZE	     27
#define ENABLEDUPLEX		     28
#define GETSETPAPERBINS 	     29
#define GETSETPRINTORIENT	     30
#define ENUMPAPERBINS		     31
#define SETDIBSCALING		     32
#define EPSPRINTING        	     33
#define ENUMPAPERMETRICS   	     34
#define GETSETPAPERMETRICS 	     35
#define POSTSCRIPT_DATA		     37
#define POSTSCRIPT_IGNORE	     38
#define MOUSETRAILS		     39

#define GETEXTENDEDTEXTMETRICS	     256
#define GETEXTENTTABLE		     257
#define GETPAIRKERNTABLE	     258
#define GETTRACKKERNTABLE	     259
#define EXTTEXTOUT		     512
#define GETFACENAME		     513
#define ENABLERELATIVEWIDTHS	     768
#define ENABLEPAIRKERNING	     769
#define SETKERNTRACK		     770
#define SETALLJUSTVALUES	     771
#define SETCHARSET		     772

#define STRETCHBLT		     2048

#define GETSETSCREENPARAMS           3072

#define BEGIN_PATH		     4096
#define CLIP_TO_PATH		     4097
#define END_PATH		     4098
#define EXT_DEVICE_CAPS		     4099
#define RESTORE_CTM		     4100
#define SAVE_CTM	             4101
#define SET_ARC_DIRECTION	     4102
#define SET_BACKGROUND_COLOR	     4103
#define SET_POLY_MODE		     4104
#define SET_SCREEN_ANGLE	     4105
#define SET_SPREAD		     4106
#define TRANSFORM_CTM		     4107
#define SET_CLIP_BOX		     4108
#define SET_BOUNDS                   4109

#endif  /* NOGDI */

/****** USER typedefs, structures, and functions *****************************/

DECLARE_HANDLE(HWND);

#ifndef NOUSER

DECLARE_HANDLE(HMENU);

DECLARE_HANDLE(HICON);
typedef HICON HCURSOR;	    /* HICONs & HCURSORs are polymorphic */

/****** System Metrics *******************************************************/

#ifndef NOSYSMETRICS

int WINAPI GetSystemMetrics(int);

/* GetSystemMetrics() codes */
#define SM_CXSCREEN	     0
#define SM_CYSCREEN	     1
#define SM_CXVSCROLL	     2
#define SM_CYHSCROLL	     3
#define SM_CYCAPTION	     4
#define SM_CXBORDER	     5
#define SM_CYBORDER	     6
#define SM_CXDLGFRAME	     7
#define SM_CYDLGFRAME	     8
#define SM_CYVTHUMB	     9
#define SM_CXHTHUMB	     10
#define SM_CXICON	     11
#define SM_CYICON	     12
#define SM_CXCURSOR	     13
#define SM_CYCURSOR	     14
#define SM_CYMENU	     15
#define SM_CXFULLSCREEN      16
#define SM_CYFULLSCREEN      17
#define SM_CYKANJIWINDOW     18
#define SM_MOUSEPRESENT      19
#define SM_CYVSCROLL	     20
#define SM_CXHSCROLL	     21
#define SM_DEBUG	     22
#define SM_SWAPBUTTON	     23
#define SM_RESERVED1	     24
#define SM_RESERVED2	     25
#define SM_RESERVED3	     26
#define SM_RESERVED4	     27
#define SM_CXMIN	     28
#define SM_CYMIN	     29
#define SM_CXSIZE	     30
#define SM_CYSIZE	     31
#define SM_CXFRAME	     32
#define SM_CYFRAME	     33
#define SM_CXMINTRACK	     34
#define SM_CYMINTRACK	     35

#if (WINVER >= 0x030a)
#define SM_CXDOUBLECLK       36
#define SM_CYDOUBLECLK       37
#define SM_CXICONSPACING     38
#define SM_CYICONSPACING     39
#define SM_MENUDROPALIGNMENT 40
#define SM_PENWINDOWS        41
#define SM_DBCSENABLED       42
#endif  /* WINVER >= 0x030a */

#define SM_CMETRICS	     43

#endif  /* NOSYSMETRICS */

UINT    WINAPI GetDoubleClickTime(void);
void    WINAPI SetDoubleClickTime(UINT);

#define WM_DEVMODECHANGE    0x001B
#define WM_TIMECHANGE	    0x001E

/****** System Parameters support ********************************************/

#if (WINVER >= 0x030a)
#ifndef NOSYSTEMPARAMSINFO

BOOL    WINAPI SystemParametersInfo(UINT, UINT, VOID FAR*, UINT);

#define SPI_GETBEEP		    1
#define SPI_SETBEEP		    2
#define SPI_GETMOUSE		    3
#define SPI_SETMOUSE		    4
#define SPI_GETBORDER		    5
#define SPI_SETBORDER		    6
#define SPI_GETKEYBOARDSPEED	    10
#define SPI_SETKEYBOARDSPEED	    11
#define SPI_LANGDRIVER		    12
#define SPI_ICONHORIZONTALSPACING   13
#define SPI_GETSCREENSAVETIMEOUT    14
#define SPI_SETSCREENSAVETIMEOUT    15
#define SPI_GETSCREENSAVEACTIVE     16
#define SPI_SETSCREENSAVEACTIVE     17
#define SPI_GETGRIDGRANULARITY	    18
#define SPI_SETGRIDGRANULARITY	    19
#define SPI_SETDESKWALLPAPER	    20
#define SPI_SETDESKPATTERN	    21
#define SPI_GETKEYBOARDDELAY	    22
#define SPI_SETKEYBOARDDELAY	    23
#define SPI_ICONVERTICALSPACING     24
#define SPI_GETICONTITLEWRAP	    25
#define SPI_SETICONTITLEWRAP	    26
#define SPI_GETMENUDROPALIGNMENT    27
#define SPI_SETMENUDROPALIGNMENT    28
#define SPI_SETDOUBLECLKWIDTH	    29
#define SPI_SETDOUBLECLKHEIGHT	    30
#define SPI_GETICONTITLELOGFONT     31
#define SPI_SETDOUBLECLICKTIME	    32
#define SPI_SETMOUSEBUTTONSWAP	    33
#define SPI_SETICONTITLELOGFONT     34
#define SPI_GETFASTTASKSWITCH       35
#define SPI_SETFASTTASKSWITCH       36

/* SystemParametersInfo flags */
#define SPIF_UPDATEINIFILE	    0x0001
#define SPIF_SENDWININICHANGE	    0x0002

#endif  /* NOSYSTEMPARAMSINFO  */
#endif  /* WINVER >= 0x030a */

/****** Rectangle support ****************************************************/

void    WINAPI SetRect(RECT FAR*, int, int, int, int);
void    WINAPI SetRectEmpty(RECT FAR*);

void    WINAPI CopyRect(RECT FAR*, const RECT FAR*);

BOOL    WINAPI IsRectEmpty(const RECT FAR*);

BOOL    WINAPI EqualRect(const RECT FAR*, const RECT FAR*);

BOOL    WINAPI IntersectRect(RECT FAR*, const RECT FAR*, const RECT FAR*);
BOOL    WINAPI UnionRect(RECT FAR*, const RECT FAR*, const RECT FAR*);
BOOL    WINAPI SubtractRect(RECT FAR*, const RECT FAR*, const RECT FAR*);

void    WINAPI OffsetRect(RECT FAR*, int, int);
void    WINAPI InflateRect(RECT FAR*, int, int);

BOOL    WINAPI PtInRect(const RECT FAR*, POINT);

/****** Window message support ***********************************************/

UINT WINAPI RegisterWindowMessage(LPCSTR);

#define WM_NULL		    0x0000

/* NOTE: All messages below 0x0400 are RESERVED by Windows */
#define WM_USER		    0x0400

#ifndef NOMSG

/* Queued message structure */
typedef struct tagMSG
{
    HWND	hwnd;
    UINT        message;
    WPARAM	wParam;
    LPARAM	lParam;
    DWORD       time;
    POINT	pt;
} MSG;
typedef MSG* PMSG;
typedef MSG NEAR* NPMSG;
typedef MSG FAR* LPMSG;

BOOL    WINAPI GetMessage(MSG FAR*, HWND, UINT, UINT);
BOOL    WINAPI PeekMessage(MSG FAR*, HWND, UINT, UINT, UINT);

/* PeekMessage() options */
#define PM_NOREMOVE	0x0000
#define PM_REMOVE	0x0001
#define PM_NOYIELD	0x0002

void    WINAPI WaitMessage(void);

DWORD   WINAPI GetMessagePos(void);
LONG    WINAPI GetMessageTime(void);
#if (WINVER >= 0x030a)
LPARAM  WINAPI GetMessageExtraInfo(void);
#endif  /* WINVER >= 0x030a */

BOOL    WINAPI TranslateMessage(const MSG FAR*);
LONG    WINAPI DispatchMessage(const MSG FAR*);

BOOL    WINAPI SetMessageQueue(int);

BOOL    WINAPI GetInputState(void);

#if (WINVER >= 0x030a)
DWORD   WINAPI GetQueueStatus(UINT flags);

/* GetQueueStatus flags */
#define QS_KEY		0x0001
#define QS_MOUSEMOVE	0x0002
#define QS_MOUSEBUTTON	0x0004
#define QS_MOUSE	(QS_MOUSEMOVE | QS_MOUSEBUTTON)
#define QS_POSTMESSAGE	0x0008
#define QS_TIMER	0x0010
#define QS_PAINT	0x0020
#define QS_SENDMESSAGE	0x0040

#define QS_ALLINPUT     0x007f
#endif  /* WINVER >= 0x030a */

#endif  /* NOMSG */

BOOL    WINAPI PostMessage(HWND, UINT, WPARAM, LPARAM);
LRESULT WINAPI SendMessage(HWND, UINT, WPARAM, LPARAM);

#ifndef NOMSG

BOOL    WINAPI PostAppMessage(HTASK, UINT, WPARAM, LPARAM);

void    WINAPI ReplyMessage(LRESULT);
BOOL    WINAPI InSendMessage(void);

/* Special HWND value for use with PostMessage() and SendMessage() */
#define HWND_BROADCAST	((HWND)0xffff)

BOOL WINAPI CallMsgFilter(MSG FAR*, int);

#define WH_GETMESSAGE	    3

#define WH_CALLWNDPROC	    4

#define WH_MSGFILTER	    (-1)
#define WH_SYSMSGFILTER	    6

/* CallMsgFilter() and WH_SYS/MSGFILTER context codes */
#define MSGF_DIALOGBOX		 0
#define MSGF_MENU		 2
#define MSGF_MOVE		 3
#define MSGF_SIZE		 4
#define MSGF_SCROLLBAR		 5
#define MSGF_NEXTWINDOW 	 6
#define MSGF_MAINLOOP            8
#define MSGF_USER                4096
#endif  /* NOMSG */

/* Standard window messages */
/* PenWindows specific messages */
#define WM_PENWINFIRST	    0x0380
#define WM_PENWINLAST	    0x038F

/* Coalescing messages */
#define WM_COALESCE_FIRST   0x0390
#define WM_COALESCE_LAST    0x039F


#if (WINVER >= 0x030a)
/****** Power management ****************************************************/
#define WM_POWER	    0x0048

/* wParam for WM_POWER window message and DRV_POWER driver notification */
#define PWR_OK              1
#define PWR_FAIL            (-1)
#define PWR_SUSPENDREQUEST  1
#define PWR_SUSPENDRESUME   2
#define PWR_CRITICALRESUME  3
#endif  /* WINVER >= 0x030a */

/****** Application termination *********************************************/

#define WM_QUERYENDSESSION  0x0011
#define WM_ENDSESSION	    0x0016

#define WM_QUIT		    0x0012

void    WINAPI PostQuitMessage(int);

#define WM_SYSTEMERROR	    0x0017

/****** Window class management *********************************************/

typedef LRESULT (CALLBACK* WNDPROC)(HWND, UINT, WPARAM, LPARAM);

typedef struct tagWNDCLASS
{
    UINT        style;
    WNDPROC	lpfnWndProc;
    int         cbClsExtra;
    int         cbWndExtra;
    HINSTANCE	hInstance;
    HICON	hIcon;
    HCURSOR	hCursor;
    HBRUSH	hbrBackground;
    LPCSTR	lpszMenuName;
    LPCSTR	lpszClassName;
} WNDCLASS;
typedef WNDCLASS* PWNDCLASS;
typedef WNDCLASS NEAR* NPWNDCLASS;
typedef WNDCLASS FAR* LPWNDCLASS;

ATOM    WINAPI RegisterClass(const WNDCLASS FAR*);
BOOL    WINAPI UnregisterClass(LPCSTR, HINSTANCE);

BOOL    WINAPI GetClassInfo(HINSTANCE, LPCSTR, WNDCLASS FAR*);
int     WINAPI GetClassName(HWND, LPSTR, int);

#ifndef NOWINSTYLES

/* Class styles */
#define CS_VREDRAW	    0x0001
#define CS_HREDRAW	    0x0002

#define CS_OWNDC	    0x0020
#define CS_CLASSDC	    0x0040
#define CS_PARENTDC	    0x0080

#define CS_SAVEBITS	    0x0800

#define CS_DBLCLKS	    0x0008

#define CS_BYTEALIGNCLIENT  0x1000
#define CS_BYTEALIGNWINDOW  0x2000

#define CS_NOCLOSE	    0x0200

#define CS_KEYCVTWINDOW     0x0004
#define CS_NOKEYCVT	    0x0100

#define CS_GLOBALCLASS	    0x4000
#endif	/* NOWINSTYLES */

#ifndef NOWINOFFSETS

WORD    WINAPI GetClassWord(HWND, int);
WORD    WINAPI SetClassWord(HWND, int, WORD);
LONG    WINAPI GetClassLong(HWND, int);
LONG    WINAPI SetClassLong(HWND, int, LONG);

/* Class field offsets for GetClassLong() and GetClassWord() */
#define GCL_MENUNAME	    (-8)
#define GCW_HBRBACKGROUND   (-10)
#define GCW_HCURSOR	    (-12)
#define GCW_HICON	    (-14)
#define GCW_HMODULE	    (-16)
#define GCW_CBWNDEXTRA	    (-18)
#define GCW_CBCLSEXTRA	    (-20)
#define GCL_WNDPROC	    (-24)
#define GCW_STYLE	    (-26)

#if (WINVER >= 0x030a)
#define GCW_ATOM            (-32)
#endif  /* WINVER >= 0x030a */

#endif	/* NOWINOFFSETS */

/****** Window creation/destroy *********************************************/

/* Window Styles */
#ifndef NOWINSTYLES

/* Basic window types */
#define WS_OVERLAPPED	    0x00000000L
#define WS_POPUP	    0x80000000L
#define WS_CHILD	    0x40000000L

/* Clipping styles */
#define WS_CLIPSIBLINGS     0x04000000L
#define WS_CLIPCHILDREN     0x02000000L

/* Generic window states */
#define WS_VISIBLE	    0x10000000L
#define WS_DISABLED	    0x08000000L

/* Main window states */
#define WS_MINIMIZE	    0x20000000L
#define WS_MAXIMIZE	    0x01000000L

/* Main window styles */
#define WS_CAPTION	    0x00C00000L     /* WS_BORDER | WS_DLGFRAME	*/
#define WS_BORDER	    0x00800000L
#define WS_DLGFRAME	    0x00400000L
#define WS_VSCROLL	    0x00200000L
#define WS_HSCROLL	    0x00100000L
#define WS_SYSMENU	    0x00080000L
#define WS_THICKFRAME	    0x00040000L
#define WS_MINIMIZEBOX	    0x00020000L
#define WS_MAXIMIZEBOX	    0x00010000L

/* Control window styles */
#define WS_GROUP	    0x00020000L
#define WS_TABSTOP	    0x00010000L

/* Common Window Styles */
#define WS_OVERLAPPEDWINDOW (WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_THICKFRAME | WS_MINIMIZEBOX | WS_MAXIMIZEBOX)
#define WS_POPUPWINDOW	    (WS_POPUP | WS_BORDER | WS_SYSMENU)
#define WS_CHILDWINDOW	    (WS_CHILD)

/* Extended Window Styles */
#define WS_EX_DLGMODALFRAME  0x00000001L
#define WS_EX_NOPARENTNOTIFY 0x00000004L

#if (WINVER >= 0x030a)
#define WS_EX_TOPMOST	     0x00000008L
#define WS_EX_ACCEPTFILES    0x00000010L
#define WS_EX_TRANSPARENT    0x00000020L
#endif  /* WINVER >= 0x030a */

/* Obsolete style names */
#define WS_TILED	    WS_OVERLAPPED
#define WS_ICONIC	    WS_MINIMIZE
#define WS_SIZEBOX	    WS_THICKFRAME
#define WS_TILEDWINDOW	    WS_OVERLAPPEDWINDOW


#endif  /* NOWINSTYLES */

/* Special value for CreateWindow, et al. */
#define HWND_DESKTOP        ((HWND)0)

BOOL    WINAPI IsWindow(HWND);

HWND    WINAPI CreateWindowEx(DWORD, LPCSTR, LPCSTR, DWORD, int, int, int, int, HWND, HMENU, HINSTANCE, void FAR*);
HWND    WINAPI CreateWindow(LPCSTR, LPCSTR, DWORD, int, int, int, int, HWND, HMENU, HINSTANCE, void FAR*);

#define WM_CREATE	    0x0001
#define WM_NCCREATE	    0x0081

/* WM_CREATE/WM_NCCREATE lParam struct */
typedef struct tagCREATESTRUCT
{
    void FAR* lpCreateParams;
    HINSTANCE hInstance;
    HMENU     hMenu;
    HWND      hwndParent;
    int       cy;
    int       cx;
    int       y;
    int       x;
    LONG      style;
    LPCSTR    lpszName;
    LPCSTR    lpszClass;
    DWORD     dwExStyle;
} CREATESTRUCT;
typedef CREATESTRUCT FAR* LPCREATESTRUCT;

BOOL    WINAPI DestroyWindow(HWND);

#define WM_DESTROY	    0x0002
#define WM_NCDESTROY	    0x0082

/* Basic window attributes */

HTASK   WINAPI GetWindowTask(HWND);

BOOL    WINAPI IsChild(HWND, HWND);

HWND    WINAPI GetParent(HWND);
HWND    WINAPI SetParent(HWND, HWND);

BOOL    WINAPI IsWindowVisible(HWND);

BOOL    WINAPI ShowWindow(HWND, int);


#ifndef NOSHOWWINDOW

#define SW_HIDE		    0
#define SW_SHOWNORMAL	    1
#define SW_NORMAL	    1
#define SW_SHOWMINIMIZED    2
#define SW_SHOWMAXIMIZED    3
#define SW_MAXIMIZE	    3
#define SW_SHOWNOACTIVATE   4
#define SW_SHOW		    5
#define SW_MINIMIZE	    6
#define SW_SHOWMINNOACTIVE  7
#define SW_SHOWNA	    8
#define SW_RESTORE          9

/* Obsolete ShowWindow() command names */
#define HIDE_WINDOW	    0
#define SHOW_OPENWINDOW     1
#define SHOW_ICONWINDOW     2
#define SHOW_FULLSCREEN     3
#define SHOW_OPENNOACTIVATE 4

#define WM_SHOWWINDOW	    0x0018

/* WM_SHOWWINDOW wParam codes */
#define SW_PARENTCLOSING    1
#define SW_OTHERMAXIMIZED   2
#define SW_PARENTOPENING    3
#define SW_OTHERRESTORED    4

/* Obsolete constant names */
#define SW_OTHERZOOM        SW_OTHERMAXIMIZED
#define SW_OTHERUNZOOM	    SW_OTHERRESTORED
#endif	/* NOSHOWWINDOW */

#define WM_SETREDRAW	    0x000B

/* Enabled state */
BOOL    WINAPI EnableWindow(HWND,BOOL);
BOOL    WINAPI IsWindowEnabled(HWND);

#define WM_ENABLE	    0x000A

/* Window text */
void    WINAPI SetWindowText(HWND, LPCSTR);
int     WINAPI GetWindowText(HWND, LPSTR, int);
int     WINAPI GetWindowTextLength(HWND);

#define WM_SETTEXT	    0x000C
#define WM_GETTEXT	    0x000D
#define WM_GETTEXTLENGTH    0x000E

/* Window words */
WORD    WINAPI GetWindowWord(HWND, int);
WORD    WINAPI SetWindowWord(HWND, int, WORD);
LONG    WINAPI GetWindowLong(HWND, int);
LONG    WINAPI SetWindowLong(HWND, int, LONG);

/* Window field offsets for GetWindowLong() and GetWindowWord() */
#ifndef NOWINOFFSETS
#define GWL_WNDPROC	    (-4)
#define GWW_HINSTANCE	    (-6)
#define GWW_HWNDPARENT	    (-8)
#define GWW_ID		    (-12)
#define GWL_STYLE	    (-16)
#define GWL_EXSTYLE	    (-20)
#endif  /* NOWINOFFSETS */

/****** Window size, position, Z-order, and visibility **********************/

#define CW_USEDEFAULT	    ((int)0x8000)

void    WINAPI GetClientRect(HWND, RECT FAR*);
void    WINAPI GetWindowRect(HWND, RECT FAR*);


#if (WINVER >= 0x030a)
typedef struct tagWINDOWPLACEMENT
{
    UINT  length;
    UINT  flags;
    UINT  showCmd;
    POINT ptMinPosition;
    POINT ptMaxPosition;
    RECT  rcNormalPosition;
} WINDOWPLACEMENT;
typedef WINDOWPLACEMENT     *PWINDOWPLACEMENT;
typedef WINDOWPLACEMENT FAR* LPWINDOWPLACEMENT;

#define WPF_SETMINPOSITION      0x0001
#define WPF_RESTORETOMAXIMIZED  0x0002

BOOL    WINAPI GetWindowPlacement(HWND, WINDOWPLACEMENT FAR*);
BOOL    WINAPI SetWindowPlacement(HWND, const WINDOWPLACEMENT FAR*);
#endif  /* WINVER >= 0x030a */

BOOL    WINAPI SetWindowPos(HWND, HWND, int, int, int, int, UINT);

/* SetWindowPos() and WINDOWPOS flags */
#define SWP_NOSIZE	    0x0001
#define SWP_NOMOVE	    0x0002
#define SWP_NOZORDER	    0x0004
#define SWP_NOREDRAW	    0x0008
#define SWP_NOACTIVATE	    0x0010
#define SWP_FRAMECHANGED    0x0020  /* The frame changed: send WM_NCCALCSIZE */
#define SWP_SHOWWINDOW	    0x0040
#define SWP_HIDEWINDOW	    0x0080
#define SWP_NOCOPYBITS	    0x0100
#define SWP_NOOWNERZORDER   0x0200  /* Don't do owner Z ordering */

#define SWP_DRAWFRAME	    SWP_FRAMECHANGED
#define SWP_NOREPOSITION    SWP_NOOWNERZORDER

#define SWP_NOSENDCHANGING  0x0400
#define SWP_DEFERERASE      0x2000

/* SetWindowPos() hwndInsertAfter field values */
#define HWND_TOP            ((HWND)0)
#define HWND_BOTTOM	    ((HWND)1)
#define HWND_TOPMOST        ((HWND)-1)
#define HWND_NOTOPMOST      ((HWND)-2)

#ifndef NODEFERWINDOWPOS

DECLARE_HANDLE(HDWP);

HDWP    WINAPI BeginDeferWindowPos(int);
HDWP    WINAPI DeferWindowPos(HDWP, HWND, HWND, int, int, int, int, UINT);
BOOL    WINAPI EndDeferWindowPos(HDWP);

#endif  /* NODEFERWINDOWPOS */

BOOL    WINAPI MoveWindow(HWND, int, int, int, int, BOOL);
BOOL    WINAPI BringWindowToTop(HWND);

#if (WINVER >= 0x030a)

#define WM_WINDOWPOSCHANGING 0x0046
#define WM_WINDOWPOSCHANGED 0x0047

/* WM_WINDOWPOSCHANGING/CHANGED struct pointed to by lParam */
typedef struct tagWINDOWPOS
{
    HWND    hwnd;
    HWND    hwndInsertAfter;
    int     x;
    int     y;
    int     cx;
    int     cy;
    UINT    flags;
} WINDOWPOS;
typedef WINDOWPOS FAR* LPWINDOWPOS;
#endif  /* WINVER >= 0x030a */

#define WM_MOVE		    0x0003
#define WM_SIZE		    0x0005

/* WM_SIZE message wParam values */
#define SIZE_RESTORED	    0
#define SIZE_MINIMIZED	    1
#define SIZE_MAXIMIZED	    2
#define SIZE_MAXSHOW	    3
#define SIZE_MAXHIDE	    4

/* Obsolete constant names */
#define SIZENORMAL	    SIZE_RESTORED
#define SIZEICONIC	    SIZE_MINIMIZED
#define SIZEFULLSCREEN	    SIZE_MAXIMIZED
#define SIZEZOOMSHOW	    SIZE_MAXSHOW
#define SIZEZOOMHIDE	    SIZE_MAXHIDE

/****** Window proc implementation & subclassing support *********************/

LRESULT WINAPI DefWindowProc(HWND, UINT, WPARAM, LPARAM);

#ifdef STRICT
LRESULT WINAPI CallWindowProc(WNDPROC, HWND, UINT, WPARAM, LPARAM);
#else
LRESULT WINAPI CallWindowProc(FARPROC, HWND, UINT, WPARAM, LPARAM);
#endif

/****** Main window support **************************************************/

void    WINAPI AdjustWindowRect(RECT FAR*, DWORD, BOOL);
void    WINAPI AdjustWindowRectEx(RECT FAR*, DWORD, BOOL, DWORD);

#define WM_QUERYOPEN	    0x0013
#define WM_CLOSE	    0x0010

/* Struct pointed to by WM_GETMINMAXINFO lParam */
typedef struct tagMINMAXINFO
{
    POINT ptReserved;
    POINT ptMaxSize;
    POINT ptMaxPosition;
    POINT ptMinTrackSize;
    POINT ptMaxTrackSize;
} MINMAXINFO;
#define WM_GETMINMAXINFO    0x0024


BOOL    WINAPI FlashWindow(HWND, BOOL);

void    WINAPI ShowOwnedPopups(HWND, BOOL);

/* Obsolete functions */
BOOL    WINAPI OpenIcon(HWND);
void    WINAPI CloseWindow(HWND);
BOOL    WINAPI AnyPopup(void);
BOOL    WINAPI IsIconic(HWND);
BOOL    WINAPI IsZoomed(HWND);

/****** Window coordinate mapping and hit-testing ***************************/

void    WINAPI ClientToScreen(HWND, POINT FAR*);
void    WINAPI ScreenToClient(HWND, POINT FAR*);

#if (WINVER >= 0x030a)
void    WINAPI MapWindowPoints(HWND hwndFrom, HWND hwndTo, POINT FAR* lppt, UINT cpt);
#endif  /* WINVER >= 0x030a */

HWND    WINAPI WindowFromPoint(POINT);
HWND    WINAPI ChildWindowFromPoint(HWND, POINT);

/****** Window query and enumeration ****************************************/

HWND    WINAPI GetDesktopWindow(void);

HWND    WINAPI FindWindow(LPCSTR, LPCSTR);

#ifdef STRICT
typedef BOOL (CALLBACK* WNDENUMPROC)(HWND, LPARAM);
#else
typedef FARPROC WNDENUMPROC;
#endif

BOOL    WINAPI EnumWindows(WNDENUMPROC, LPARAM);
BOOL    WINAPI EnumChildWindows(HWND, WNDENUMPROC, LPARAM);
BOOL    WINAPI EnumTaskWindows(HTASK, WNDENUMPROC, LPARAM);

HWND    WINAPI GetTopWindow(HWND);

HWND    WINAPI GetWindow(HWND, UINT);
HWND    WINAPI GetNextWindow(HWND, UINT);

/* GetWindow() constants */
#define GW_HWNDFIRST	0
#define GW_HWNDLAST	1
#define GW_HWNDNEXT	2
#define GW_HWNDPREV	3
#define GW_OWNER	4
#define GW_CHILD	5


/****** Window property support *********************************************/

BOOL    WINAPI SetProp(HWND, LPCSTR, HANDLE);
HANDLE  WINAPI GetProp(HWND, LPCSTR);
HANDLE  WINAPI RemoveProp(HWND, LPCSTR);

#ifdef STRICT
typedef BOOL (CALLBACK* PROPENUMPROC)(HWND, LPCSTR, HANDLE);
#else
typedef FARPROC PROPENUMPROC;
#endif

int     WINAPI EnumProps(HWND, PROPENUMPROC);

/****** Window drawing support **********************************************/

HDC     WINAPI GetDC(HWND);
int     WINAPI ReleaseDC(HWND, HDC);

HDC     WINAPI GetWindowDC(HWND);

#if (WINVER >= 0x030a)
HDC     WINAPI GetDCEx(register HWND hwnd, HRGN hrgnClip, DWORD flags);

#define DCX_WINDOW	    0x00000001L
#define DCX_CACHE	    0x00000002L
#define DCX_CLIPCHILDREN    0x00000008L
#define DCX_CLIPSIBLINGS    0x00000010L
#define DCX_PARENTCLIP	    0x00000020L

#define DCX_EXCLUDERGN	    0x00000040L
#define DCX_INTERSECTRGN    0x00000080L


#define DCX_LOCKWINDOWUPDATE 0x00000400L


#define DCX_USESTYLE	    0x00010000L

#endif  /* WINVER >= 0x030a */

/****** Window repainting ***************************************************/

#define WM_PAINT	    0x000F
#define WM_ERASEBKGND	    0x0014
#define WM_ICONERASEBKGND   0x0027

/* BeginPaint() return structure */
typedef struct tagPAINTSTRUCT
{
    HDC 	hdc;
    BOOL	fErase;
    RECT	rcPaint;
    BOOL	fRestore;
    BOOL	fIncUpdate;
    BYTE	rgbReserved[16];
} PAINTSTRUCT;
typedef PAINTSTRUCT* PPAINTSTRUCT;
typedef PAINTSTRUCT NEAR* NPPAINTSTRUCT;
typedef PAINTSTRUCT FAR* LPPAINTSTRUCT;

HDC     WINAPI BeginPaint(HWND, PAINTSTRUCT FAR*);
void    WINAPI EndPaint(HWND, const PAINTSTRUCT FAR*);

void    WINAPI UpdateWindow(HWND);

int     WINAPI ExcludeUpdateRgn(HDC, HWND);

#if (WINVER >= 0x030a)
BOOL    WINAPI LockWindowUpdate(HWND hwndLock);
#endif  /* WINVER >= 0x030a */

BOOL    WINAPI GetUpdateRect(HWND, RECT FAR*, BOOL);
int     WINAPI GetUpdateRgn(HWND, HRGN, BOOL);

void    WINAPI InvalidateRect(HWND, const RECT FAR*, BOOL);
void    WINAPI ValidateRect(HWND, const RECT FAR*);

void    WINAPI InvalidateRgn(HWND, HRGN, BOOL);
void    WINAPI ValidateRgn(HWND, HRGN);

#if (WINVER >= 0x030a)
BOOL    WINAPI RedrawWindow(HWND hwnd, const RECT FAR* lprcUpdate, HRGN hrgnUpdate, UINT flags);

#define RDW_INVALIDATE		0x0001
#define RDW_INTERNALPAINT	0x0002
#define RDW_ERASE		0x0004

#define RDW_VALIDATE		0x0008
#define RDW_NOINTERNALPAINT	0x0010
#define RDW_NOERASE		0x0020

#define RDW_NOCHILDREN		0x0040
#define RDW_ALLCHILDREN 	0x0080

#define RDW_UPDATENOW		0x0100
#define RDW_ERASENOW		0x0200

#define RDW_FRAME               0x0400
#define RDW_NOFRAME             0x0800

#endif  /* WINVER >= 0x030a */

/****** Window scrolling ****************************************************/

void    WINAPI ScrollWindow(HWND, int, int, const RECT FAR*, const RECT FAR*);
BOOL    WINAPI ScrollDC(HDC, int, int, const RECT FAR*, const RECT FAR*, HRGN, RECT FAR*);

#if (WINVER >= 0x030a)

int     WINAPI ScrollWindowEx(HWND hwnd, int dx, int dy,
                const RECT FAR* prcScroll, const RECT FAR* prcClip,
                HRGN hrgnUpdate, RECT FAR* prcUpdate, UINT flags);

#define SW_SCROLLCHILDREN   0x0001
#define SW_INVALIDATE       0x0002
#define SW_ERASE            0x0004


#endif  /* WINVER >= 0x030a */

/****** Non-client window area management ************************************/

#define WM_NCPAINT	    0x0085

#define WM_NCCALCSIZE	    0x0083

#if (WINVER >= 0x030a)
/* WM_NCCALCSIZE return flags */
#define WVR_ALIGNTOP	    0x0010
#define WVR_ALIGNLEFT	    0x0020
#define WVR_ALIGNBOTTOM     0x0040
#define WVR_ALIGNRIGHT	    0x0080
#define WVR_HREDRAW	    0x0100
#define WVR_VREDRAW	    0x0200
#define WVR_REDRAW	    (WVR_HREDRAW | WVR_VREDRAW)
#define WVR_VALIDRECTS	    0x0400


/* WM_NCCALCSIZE parameter structure */
typedef struct tagNCCALCSIZE_PARAMS
{
    RECT	   rgrc[3];
    WINDOWPOS FAR* lppos;
} NCCALCSIZE_PARAMS;
#else   /* WINVER >= 0x030a */
typedef struct tagNCCALCSIZE_PARAMS
{
    RECT    rgrc[2];
} NCCALCSIZE_PARAMS;
#endif  /* WINVER >= 0x030a */
typedef NCCALCSIZE_PARAMS FAR* LPNCCALCSIZE_PARAMS;

#define WM_NCHITTEST	    0x0084

/* WM_NCHITTEST return codes */
#define HTERROR 	    (-2)
#define HTTRANSPARENT	    (-1)
#define HTNOWHERE	    0
#define HTCLIENT	    1
#define HTCAPTION	    2
#define HTSYSMENU	    3
#define HTSIZE		    4
#define HTMENU		    5
#define HTHSCROLL	    6
#define HTVSCROLL	    7
#define HTMINBUTTON	    8
#define HTMAXBUTTON	    9
#define HTLEFT		    10
#define HTRIGHT 	    11
#define HTTOP		    12
#define HTTOPLEFT	    13
#define HTTOPRIGHT	    14
#define HTBOTTOM	    15
#define HTBOTTOMLEFT	    16
#define HTBOTTOMRIGHT	    17
#define HTBORDER	    18
#define HTGROWBOX	    HTSIZE
#define HTREDUCE	    HTMINBUTTON
#define HTZOOM		    HTMAXBUTTON

/****** Drag-and-drop support ***********************************************/

#define WM_QUERYDRAGICON    0x0037
#define WM_DROPFILES	    0x0233

/****** Window activation ***************************************************/

HWND    WINAPI SetActiveWindow(HWND);
HWND    WINAPI GetActiveWindow(void);

HWND    WINAPI GetLastActivePopup(HWND);

/* WM_ACTIVATE state values */
#define WA_INACTIVE	    0
#define WA_ACTIVE	    1
#define WA_CLICKACTIVE	    2

#define WM_ACTIVATE	    0x0006
#define WM_ACTIVATEAPP	    0x001C
#define WM_NCACTIVATE	    0x0086

/****** Keyboard input support **********************************************/

HWND    WINAPI SetFocus(HWND);
HWND    WINAPI GetFocus(void);

int     WINAPI GetKeyState(int);
int     WINAPI GetAsyncKeyState(int);

void    WINAPI GetKeyboardState(BYTE FAR* );
void    WINAPI SetKeyboardState(BYTE FAR* );

#define WM_SETFOCUS	    0x0007
#define WM_KILLFOCUS	    0x0008

#define WM_KEYDOWN	    0x0100
#define WM_KEYUP	    0x0101

#define WM_CHAR		    0x0102
#define WM_DEADCHAR	    0x0103

#define WM_SYSKEYDOWN	    0x0104
#define WM_SYSKEYUP	    0x0105

#define WM_SYSCHAR	    0x0106
#define WM_SYSDEADCHAR	    0x0107


/* Keyboard message range */
#define WM_KEYFIRST	    0x0100
#define WM_KEYLAST	    0x0108

/* WM_KEYUP/DOWN/CHAR HIWORD(lParam) flags */
#define KF_EXTENDED	    0x0100
#define KF_DLGMODE	    0x0800
#define KF_MENUMODE	    0x1000
#define KF_ALTDOWN	    0x2000
#define KF_REPEAT	    0x4000
#define KF_UP		    0x8000

/* Virtual key codes */
#ifndef NOVIRTUALKEYCODES
#define VK_LBUTTON	    0x01
#define VK_RBUTTON	    0x02
#define VK_CANCEL	    0x03
#define VK_MBUTTON          0x04
#define VK_BACK 	    0x08
#define VK_TAB		    0x09
#define VK_CLEAR	    0x0C
#define VK_RETURN	    0x0D
#define VK_SHIFT	    0x10
#define VK_CONTROL	    0x11
#define VK_MENU 	    0x12
#define VK_PAUSE	    0x13
#define VK_CAPITAL	    0x14
#define VK_ESCAPE	    0x1B
#define VK_SPACE	    0x20
#define VK_PRIOR	    0x21
#define VK_NEXT 	    0x22
#define VK_END		    0x23
#define VK_HOME 	    0x24
#define VK_LEFT 	    0x25
#define VK_UP		    0x26
#define VK_RIGHT	    0x27
#define VK_DOWN 	    0x28
#define VK_SELECT	    0x29
#define VK_PRINT	    0x2A
#define VK_EXECUTE	    0x2B
#define VK_SNAPSHOT	    0x2C
#define VK_INSERT	    0x2D
#define VK_DELETE	    0x2E
#define VK_HELP 	    0x2F
#define VK_NUMPAD0	    0x60
#define VK_NUMPAD1	    0x61
#define VK_NUMPAD2	    0x62
#define VK_NUMPAD3	    0x63
#define VK_NUMPAD4	    0x64
#define VK_NUMPAD5	    0x65
#define VK_NUMPAD6	    0x66
#define VK_NUMPAD7	    0x67
#define VK_NUMPAD8	    0x68
#define VK_NUMPAD9	    0x69
#define VK_MULTIPLY	    0x6A
#define VK_ADD		    0x6B
#define VK_SEPARATOR	    0x6C
#define VK_SUBTRACT	    0x6D
#define VK_DECIMAL	    0x6E
#define VK_DIVIDE	    0x6F
#define VK_F1		    0x70
#define VK_F2		    0x71
#define VK_F3		    0x72
#define VK_F4		    0x73
#define VK_F5		    0x74
#define VK_F6		    0x75
#define VK_F7		    0x76
#define VK_F8		    0x77
#define VK_F9		    0x78
#define VK_F10		    0x79
#define VK_F11		    0x7A
#define VK_F12		    0x7B
#define VK_F13		    0x7C
#define VK_F14		    0x7D
#define VK_F15		    0x7E
#define VK_F16		    0x7F
#define VK_F17		    0x80
#define VK_F18		    0x81
#define VK_F19		    0x82
#define VK_F20		    0x83
#define VK_F21		    0x84
#define VK_F22		    0x85
#define VK_F23		    0x86
#define VK_F24		    0x87
#define VK_NUMLOCK	    0x90
#define VK_SCROLL           0x91

/* VK_A thru VK_Z are the same as their ASCII equivalents: 'A' thru 'Z' */
/* VK_0 thru VK_9 are the same as their ASCII equivalents: '0' thru '0' */

#endif  /* NOVIRTUALKEYCODES */


/* SetWindowsHook() keyboard hook */
#define WH_KEYBOARD	    2

/****** Mouse input support *************************************************/

HWND    WINAPI SetCapture(HWND);
void    WINAPI ReleaseCapture(void);
HWND    WINAPI GetCapture(void);

BOOL    WINAPI SwapMouseButton(BOOL);

/* Mouse input messages */
#define WM_MOUSEMOVE	    0x0200
#define WM_LBUTTONDOWN	    0x0201
#define WM_LBUTTONUP	    0x0202
#define WM_LBUTTONDBLCLK    0x0203
#define WM_RBUTTONDOWN	    0x0204
#define WM_RBUTTONUP	    0x0205
#define WM_RBUTTONDBLCLK    0x0206
#define WM_MBUTTONDOWN	    0x0207
#define WM_MBUTTONUP	    0x0208
#define WM_MBUTTONDBLCLK    0x0209

/* Mouse input message range */
#define WM_MOUSEFIRST	    0x0200
#define WM_MOUSELAST	    0x0209

/* Mouse message wParam key states */
#ifndef NOKEYSTATES
#define MK_LBUTTON	    0x0001
#define MK_RBUTTON	    0x0002
#define MK_SHIFT	    0x0004
#define MK_CONTROL	    0x0008
#define MK_MBUTTON	    0x0010
#endif  /* NOKEYSTATES */

/* Non-client mouse messages */
#define WM_NCMOUSEMOVE	    0x00A0
#define WM_NCLBUTTONDOWN    0x00A1
#define WM_NCLBUTTONUP	    0x00A2
#define WM_NCLBUTTONDBLCLK  0x00A3
#define WM_NCRBUTTONDOWN    0x00A4
#define WM_NCRBUTTONUP	    0x00A5
#define WM_NCRBUTTONDBLCLK  0x00A6
#define WM_NCMBUTTONDOWN    0x00A7
#define WM_NCMBUTTONUP	    0x00A8
#define WM_NCMBUTTONDBLCLK  0x00A9

/* Mouse click activation support */
#define WM_MOUSEACTIVATE    0x0021

/* WM_MOUSEACTIVATE return codes */
#define MA_ACTIVATE	    1
#define MA_ACTIVATEANDEAT   2
#define MA_NOACTIVATE	    3
#if (WINVER >= 0x030a)
#define MA_NOACTIVATEANDEAT 4
#endif  /* WINVER >= 0x030a */

/* SetWindowsHook() mouse hook */
#ifndef NOWH
#define WH_MOUSE	    7

typedef struct tagMOUSEHOOKSTRUCT
{
    POINT   pt;
    HWND    hwnd;
    UINT    wHitTestCode;
    DWORD   dwExtraInfo;
} MOUSEHOOKSTRUCT;
typedef MOUSEHOOKSTRUCT  FAR* LPMOUSEHOOKSTRUCT;
#endif	/* NOWH */

/****** Mode control ********************************************************/

#define WM_CANCELMODE	    0x001F

/****** System modal window support *****************************************/

HWND    WINAPI GetSysModalWindow(void);
HWND    WINAPI SetSysModalWindow(HWND);

/****** Timer support *******************************************************/

#ifdef STRICT
typedef void (CALLBACK* TIMERPROC)(HWND, UINT, UINT, DWORD);
#else
typedef FARPROC TIMERPROC;
#endif

UINT    WINAPI SetTimer(HWND, UINT, UINT, TIMERPROC);

BOOL    WINAPI KillTimer(HWND, UINT);

#define WM_TIMER	    0x0113

/****** Accelerator support *************************************************/

DECLARE_HANDLE(HACCEL);

HACCEL  WINAPI LoadAccelerators(HINSTANCE, LPCSTR);

#ifndef NOMSG
int     WINAPI TranslateAccelerator(HWND, HACCEL, MSG FAR*);
#endif

/****** Menu support ********************************************************/

#ifndef NOMENUS

/* Menu template header */
typedef struct
{
    UINT    versionNumber;
    UINT    offset;
} MENUITEMTEMPLATEHEADER;

/* Menu template item struct */
typedef struct
{
    UINT    mtOption;
    UINT    mtID;
    char    mtString[1];
} MENUITEMTEMPLATE;

#if (WINVER >= 0x030a)
BOOL    WINAPI IsMenu(HMENU);
#endif  /* WINVER >= 0x030a */

HMENU   WINAPI CreateMenu(void);
HMENU   WINAPI CreatePopupMenu(void);
HMENU   WINAPI LoadMenu(HINSTANCE, LPCSTR);
HMENU   WINAPI LoadMenuIndirect(const void FAR*);

BOOL    WINAPI DestroyMenu(HMENU);

HMENU   WINAPI GetMenu(HWND);
BOOL    WINAPI SetMenu(HWND, HMENU);

HMENU   WINAPI GetSystemMenu(HWND, BOOL);

void    WINAPI DrawMenuBar(HWND);

BOOL    WINAPI HiliteMenuItem(HWND, HMENU, UINT, UINT);

BOOL    WINAPI InsertMenu(HMENU, UINT, UINT, UINT, LPCSTR);
BOOL    WINAPI AppendMenu(HMENU, UINT, UINT, LPCSTR);
BOOL    WINAPI ModifyMenu(HMENU, UINT, UINT, UINT, LPCSTR);
BOOL    WINAPI RemoveMenu(HMENU, UINT, UINT);
BOOL    WINAPI DeleteMenu(HMENU, UINT, UINT);

BOOL    WINAPI ChangeMenu(HMENU, UINT, LPCSTR, UINT, UINT);

#define MF_INSERT	    0x0000
#define MF_CHANGE	    0x0080
#define MF_APPEND	    0x0100
#define MF_DELETE	    0x0200
#define MF_REMOVE	    0x1000

/* Menu flags for Add/Check/EnableMenuItem() */
#define MF_BYCOMMAND	    0x0000
#define MF_BYPOSITION	    0x0400

#define MF_SEPARATOR	    0x0800

#define MF_ENABLED	    0x0000
#define MF_GRAYED	    0x0001
#define MF_DISABLED	    0x0002

#define MF_UNCHECKED	    0x0000
#define MF_CHECKED	    0x0008
#define MF_USECHECKBITMAPS  0x0200

#define MF_STRING	    0x0000
#define MF_BITMAP	    0x0004
#define MF_OWNERDRAW	    0x0100

#define MF_POPUP	    0x0010
#define MF_MENUBARBREAK     0x0020
#define MF_MENUBREAK	    0x0040

#define MF_UNHILITE	    0x0000
#define MF_HILITE	    0x0080

#define MF_SYSMENU	    0x2000
#define MF_HELP 	    0x4000
#define MF_MOUSESELECT	    0x8000


#define MF_END		    0x0080  /* Only valid in menu resource templates */

BOOL    WINAPI EnableMenuItem(HMENU, UINT, UINT);
BOOL    WINAPI CheckMenuItem(HMENU, UINT, UINT);

HMENU   WINAPI GetSubMenu(HMENU, int);

int     WINAPI GetMenuItemCount(HMENU);
UINT    WINAPI GetMenuItemID(HMENU, int);

int     WINAPI GetMenuString(HMENU, UINT, LPSTR, int, UINT);
UINT    WINAPI GetMenuState(HMENU, UINT, UINT);

BOOL    WINAPI SetMenuItemBitmaps(HMENU, UINT, UINT, HBITMAP, HBITMAP);
DWORD   WINAPI GetMenuCheckMarkDimensions(void);

BOOL    WINAPI TrackPopupMenu(HMENU, UINT, int, int, int, HWND, const RECT FAR*);

/* Flags for TrackPopupMenu */
#define TPM_LEFTBUTTON  0x0000
#if (WINVER >= 0x030a)
#define TPM_RIGHTBUTTON 0x0002
#define TPM_LEFTALIGN   0x0000
#define TPM_CENTERALIGN 0x0004
#define TPM_RIGHTALIGN  0x0008
#endif  /* WINVER >= 0x030a */

#endif  /* NOMENUS */

/* Menu messages */
#define WM_INITMENU	    0x0116
#define WM_INITMENUPOPUP    0x0117

#ifndef NOMENUS

#define WM_MENUSELECT	    0x011F
#define WM_MENUCHAR	    0x0120

#endif  /* NOMENUS */

/* Menu and control command messages */
#define WM_COMMAND	    0x0111

/****** Scroll bar support **************************************************/

#ifndef NOSCROLL

#define WM_HSCROLL	    0x0114
#define WM_VSCROLL	    0x0115

/* WM_H/VSCROLL commands */
#define SB_LINEUP	    0
#define SB_LINELEFT	    0
#define SB_LINEDOWN	    1
#define SB_LINERIGHT	    1
#define SB_PAGEUP	    2
#define SB_PAGELEFT	    2
#define SB_PAGEDOWN	    3
#define SB_PAGERIGHT	    3
#define SB_THUMBPOSITION    4
#define SB_THUMBTRACK	    5
#define SB_TOP		    6
#define SB_LEFT 	    6
#define SB_BOTTOM	    7
#define SB_RIGHT	    7
#define SB_ENDSCROLL	    8

/* Scroll bar selection constants */
#define SB_HORZ		    0
#define SB_VERT		    1
#define SB_CTL		    2
#define SB_BOTH		    3

int     WINAPI SetScrollPos(HWND, int, int, BOOL);
int     WINAPI GetScrollPos(HWND, int);
void    WINAPI SetScrollRange(HWND, int, int, int, BOOL);
void    WINAPI GetScrollRange(HWND, int, int FAR*, int FAR*);
void    WINAPI ShowScrollBar(HWND, int, BOOL);
BOOL    WINAPI EnableScrollBar(HWND, int, UINT);

/* EnableScrollBar() flags */
#define ESB_ENABLE_BOTH     0x0000
#define ESB_DISABLE_BOTH    0x0003

#define ESB_DISABLE_LEFT    0x0001
#define ESB_DISABLE_RIGHT   0x0002

#define ESB_DISABLE_UP      0x0001
#define ESB_DISABLE_DOWN    0x0002

#define ESB_DISABLE_LTUP    ESB_DISABLE_LEFT
#define ESB_DISABLE_RTDN    ESB_DISABLE_RIGHT

#endif  /* NOSCROLL */

/******* Clipboard manager **************************************************/

#ifndef NOCLIPBOARD

/* Predefined Clipboard Formats */
#define CF_TEXT 	     1
#define CF_BITMAP	     2
#define CF_METAFILEPICT      3
#define CF_SYLK 	     4
#define CF_DIF		     5
#define CF_TIFF 	     6
#define CF_OEMTEXT	     7
#define CF_DIB		     8
#define CF_PALETTE	     9
#define CF_PENDATA          10
#define CF_RIFF             11
#define CF_WAVE             12

#define CF_OWNERDISPLAY     0x0080
#define CF_DSPTEXT	    0x0081
#define CF_DSPBITMAP	    0x0082
#define CF_DSPMETAFILEPICT  0x0083

/* "Private" formats don't get GlobalFree()'d */
#define CF_PRIVATEFIRST     0x0200
#define CF_PRIVATELAST	    0x02FF

/* "GDIOBJ" formats do get DeleteObject()'d */
#define CF_GDIOBJFIRST	    0x0300
#define CF_GDIOBJLAST	    0x03FF

/* Clipboard Manager Functions */
BOOL    WINAPI OpenClipboard(HWND);
BOOL    WINAPI CloseClipboard(void);
BOOL    WINAPI EmptyClipboard(void);

#if (WINVER >= 0x030a)
HWND    WINAPI GetOpenClipboardWindow(void);
#endif  /* WINVER >= 0x030a */

HWND    WINAPI GetClipboardOwner(void);

HWND    WINAPI SetClipboardViewer(HWND);
HWND    WINAPI GetClipboardViewer(void);

HANDLE  WINAPI SetClipboardData(UINT, HANDLE);
HANDLE  WINAPI GetClipboardData(UINT);

BOOL    WINAPI IsClipboardFormatAvailable(UINT);
int     WINAPI GetPriorityClipboardFormat(UINT FAR*, int);

UINT    WINAPI RegisterClipboardFormat(LPCSTR);
int     WINAPI CountClipboardFormats(void);
UINT    WINAPI EnumClipboardFormats(UINT);
int     WINAPI GetClipboardFormatName(UINT, LPSTR, int);

BOOL    WINAPI ChangeClipboardChain(HWND, HWND);

/* Clipboard command messages */
#define WM_CUT		    0x0300
#define WM_COPY		    0x0301
#define WM_PASTE	    0x0302
#define WM_CLEAR	    0x0303
#define WM_UNDO		    0x0304

/* Clipboard owner messages */
#define WM_RENDERFORMAT	    0x0305
#define WM_RENDERALLFORMATS 0x0306
#define WM_DESTROYCLIPBOARD 0x0307

/* Clipboard viewer messages */
#define WM_DRAWCLIPBOARD    0x0308
#define WM_PAINTCLIPBOARD   0x0309
#define WM_SIZECLIPBOARD    0x030B
#define WM_VSCROLLCLIPBOARD 0x030A
#define WM_HSCROLLCLIPBOARD 0x030E
#define WM_ASKCBFORMATNAME  0x030C
#define WM_CHANGECBCHAIN    0x030D

#endif  /* NOCLIPBOARD */

/****** Mouse cursor support *************************************************/

HCURSOR WINAPI LoadCursor(HINSTANCE, LPCSTR);
HCURSOR WINAPI CreateCursor(HINSTANCE, int, int, int, int, const void FAR*, const void FAR*);
BOOL    WINAPI DestroyCursor(HCURSOR);

#if (WINVER >= 0x030a)
HCURSOR WINAPI CopyCursor(HINSTANCE, HCURSOR);
#endif  /* WINVER >= 0x030a */

int     WINAPI ShowCursor(BOOL);

void    WINAPI SetCursorPos(int, int);
void    WINAPI GetCursorPos(POINT FAR*);

HCURSOR WINAPI SetCursor(HCURSOR);

#if (WINVER >= 0x030a)
HCURSOR WINAPI GetCursor(void);
#endif  /* WINVER >= 0x030a */

void    WINAPI ClipCursor(const RECT FAR*);
#if (WINVER >= 0x030a)
void    WINAPI GetClipCursor(RECT FAR*);
#endif  /* WINVER >= 0x030a */

/* Standard cursor resource IDs */
#define IDC_ARROW	    MAKEINTRESOURCE(32512)
#define IDC_IBEAM	    MAKEINTRESOURCE(32513)
#define IDC_WAIT	    MAKEINTRESOURCE(32514)
#define IDC_CROSS	    MAKEINTRESOURCE(32515)
#define IDC_UPARROW	    MAKEINTRESOURCE(32516)
#define IDC_SIZE	    MAKEINTRESOURCE(32640)
#define IDC_ICON	    MAKEINTRESOURCE(32641)
#define IDC_SIZENWSE	    MAKEINTRESOURCE(32642)
#define IDC_SIZENESW	    MAKEINTRESOURCE(32643)
#define IDC_SIZEWE	    MAKEINTRESOURCE(32644)
#define IDC_SIZENS	    MAKEINTRESOURCE(32645)

#define WM_SETCURSOR	    0x0020

/****** Icon support *********************************************************/

HICON   WINAPI LoadIcon(HINSTANCE, LPCSTR);
HICON   WINAPI CreateIcon(HINSTANCE, int, int, BYTE, BYTE, const void FAR*, const void FAR*);
BOOL    WINAPI DestroyIcon(HICON);

#if (WINVER >= 0x030a)
HICON   WINAPI CopyIcon(HINSTANCE, HICON);
#endif  /* WINVER >= 0x030a */

BOOL    WINAPI DrawIcon(HDC, int, int, HICON);

#ifndef NOICONS

/* Standard icon resource IDs */
#define IDI_APPLICATION     MAKEINTRESOURCE(32512)
#define IDI_HAND	    MAKEINTRESOURCE(32513)
#define IDI_QUESTION	    MAKEINTRESOURCE(32514)
#define IDI_EXCLAMATION     MAKEINTRESOURCE(32515)
#define IDI_ASTERISK	    MAKEINTRESOURCE(32516)

#endif  /* NOICONS */

/****** Message Box support *************************************************/

#ifndef NOMB

int     WINAPI MessageBox(HWND, LPCSTR, LPCSTR, UINT);
void    WINAPI MessageBeep(UINT);

#define MB_OK		    0x0000
#define MB_OKCANCEL	    0x0001
#define MB_ABORTRETRYIGNORE 0x0002
#define MB_YESNOCANCEL	    0x0003
#define MB_YESNO	    0x0004
#define MB_RETRYCANCEL	    0x0005
#define MB_TYPEMASK	    0x000F

#define MB_ICONHAND	    0x0010
#define MB_ICONQUESTION	    0x0020
#define MB_ICONEXCLAMATION  0x0030
#define MB_ICONASTERISK     0x0040
#define MB_ICONMASK	    0x00F0

#define MB_ICONINFORMATION  MB_ICONASTERISK
#define MB_ICONSTOP         MB_ICONHAND

#define MB_DEFBUTTON1	    0x0000
#define MB_DEFBUTTON2	    0x0100
#define MB_DEFBUTTON3	    0x0200
#define MB_DEFMASK	    0x0F00

#define MB_APPLMODAL	    0x0000
#define MB_SYSTEMMODAL	    0x1000
#define MB_TASKMODAL	    0x2000

#define MB_NOFOCUS	    0x8000



#endif  /* NOMB */

/****** Caret support ********************************************************/

void    WINAPI CreateCaret(HWND, HBITMAP, int, int);
void    WINAPI DestroyCaret(void);

void    WINAPI SetCaretPos(int, int);
void    WINAPI GetCaretPos(POINT FAR*);

void    WINAPI HideCaret(HWND);
void    WINAPI ShowCaret(HWND);

UINT    WINAPI GetCaretBlinkTime(void);
void    WINAPI SetCaretBlinkTime(UINT);

/****** WM_SYSCOMMAND support ***********************************************/

#define WM_SYSCOMMAND	0x0112

#ifndef NOSYSCOMMANDS

/* System Menu Command Values */
#define SC_SIZE		0xF000
#define SC_MOVE		0xF010
#define SC_MINIMIZE	0xF020
#define SC_MAXIMIZE	0xF030
#define SC_NEXTWINDOW	0xF040
#define SC_PREVWINDOW	0xF050
#define SC_CLOSE	0xF060
#define SC_VSCROLL	0xF070
#define SC_HSCROLL	0xF080
#define SC_MOUSEMENU	0xF090
#define SC_KEYMENU	0xF100
#define SC_ARRANGE	0xF110
#define SC_RESTORE	0xF120
#define SC_TASKLIST	0xF130
#define SC_SCREENSAVE   0xF140
#define SC_HOTKEY       0xF150

/* Obsolete names */
#define SC_ICON		SC_MINIMIZE
#define SC_ZOOM 	SC_MAXIMIZE


#endif  /* NOSYSCOMMANDS */

/****** MDI Support *********************************************************/

#ifndef NOMDI

/* CreateWindow lpParams structure for creating MDI client */
typedef struct tagCLIENTCREATESTRUCT
{
    HMENU  hWindowMenu;
    UINT   idFirstChild;
} CLIENTCREATESTRUCT;
typedef CLIENTCREATESTRUCT FAR* LPCLIENTCREATESTRUCT;

/* MDI client style bits */
#if (WINVER >= 0x030a)
#define MDIS_ALLCHILDSTYLES 0x0001
#endif  /* WINVER >= 0x030a */

/* MDI messages */
#define WM_MDICREATE	    0x0220
#define WM_MDIDESTROY	    0x0221
#define WM_MDIACTIVATE	    0x0222
#define WM_MDIRESTORE	    0x0223
#define WM_MDINEXT	    0x0224
#define WM_MDIMAXIMIZE	    0x0225
#define WM_MDITILE	    0x0226
#define WM_MDICASCADE	    0x0227
#define WM_MDIICONARRANGE   0x0228
#define WM_MDIGETACTIVE     0x0229
#define WM_MDISETMENU	    0x0230

/* WM_MDICREATE message structure */
typedef struct tagMDICREATESTRUCT
{
    LPCSTR  szClass;
    LPCSTR  szTitle;
    HINSTANCE hOwner;
    int     x;
    int     y;
    int     cx;
    int     cy;
    DWORD   style;
    LPARAM  lParam;
} MDICREATESTRUCT;
typedef MDICREATESTRUCT FAR*  LPMDICREATESTRUCT;

#if (WINVER >= 0x030a)
/* wParam values for WM_MDITILE and WM_MDICASCADE messages. */
#define MDITILE_VERTICAL	0x0000
#define MDITILE_HORIZONTAL	0x0001
#define MDITILE_SKIPDISABLED	0x0002
#endif  /* WINVER >= 0x030a */

#define WM_CHILDACTIVATE    0x0022

LRESULT WINAPI DefFrameProc(HWND, HWND, UINT, WPARAM, LPARAM);
LRESULT WINAPI DefMDIChildProc(HWND, UINT, WPARAM, LPARAM);

#ifndef NOMSG
BOOL    WINAPI TranslateMDISysAccel(HWND, MSG FAR*);
#endif

UINT    WINAPI ArrangeIconicWindows(HWND);

#endif  /* NOMDI */

/****** Dialog and Control Management ***************************************/

#ifndef NOCTLMGR

/* Dialog window class */
#define WC_DIALOG	(MAKEINTATOM(0x8002))

/* cbWndExtra bytes needed by dialog manager for dialog classes */
#define DLGWINDOWEXTRA	30

/* Dialog styles */
#define DS_ABSALIGN	    0x01L
#define DS_SYSMODAL	    0x02L
#define DS_LOCALEDIT        0x20L
#define DS_SETFONT          0x40L
#define DS_MODALFRAME       0x80L
#define DS_NOIDLEMSG        0x100L

/* Dialog messages */
#define DM_GETDEFID	    (WM_USER+0)
#define DM_SETDEFID	    (WM_USER+1)

/* Returned in HIWORD() of DM_GETDEFID result if msg is supported */
#define DC_HASDEFID	    0x534B

#endif  /* NOCTLMGR */

/* Dialog notification messages */
#define WM_INITDIALOG	    0x0110
#define WM_NEXTDLGCTL	    0x0028

#define WM_PARENTNOTIFY     0x0210

#define WM_ENTERIDLE	    0x0121


#ifndef NOCTLMGR

#ifdef STRICT
typedef BOOL (CALLBACK* DLGPROC)(HWND, UINT, WPARAM, LPARAM);
#else
typedef FARPROC DLGPROC;
#endif

/* Get/SetWindowWord/Long offsets for use with WC_DIALOG windows */
#define DWL_MSGRESULT	0
#define DWL_DLGPROC	4
#define DWL_USER	8

#ifndef NOMSG
BOOL    WINAPI IsDialogMessage(HWND, MSG FAR*);
#endif

LRESULT WINAPI DefDlgProc(HWND, UINT, WPARAM, LPARAM);

HWND    WINAPI CreateDialog(HINSTANCE, LPCSTR, HWND, DLGPROC);
HWND    WINAPI CreateDialogIndirect(HINSTANCE, const void FAR*, HWND, DLGPROC);
HWND    WINAPI CreateDialogParam(HINSTANCE, LPCSTR, HWND, DLGPROC, LPARAM);
HWND    WINAPI CreateDialogIndirectParam(HINSTANCE, const void FAR*, HWND, DLGPROC, LPARAM);

int     WINAPI DialogBox(HINSTANCE, LPCSTR, HWND, DLGPROC);
int     WINAPI DialogBoxIndirect(HINSTANCE, HGLOBAL, HWND, DLGPROC);
int     WINAPI DialogBoxParam(HINSTANCE, LPCSTR, HWND, DLGPROC, LPARAM);
int     WINAPI DialogBoxIndirectParam(HINSTANCE, HGLOBAL, HWND, DLGPROC, LPARAM);

void    WINAPI EndDialog(HWND, int);

int     WINAPI GetDlgCtrlID(HWND);
HWND    WINAPI GetDlgItem(HWND, int);
LRESULT WINAPI SendDlgItemMessage(HWND, int, UINT, WPARAM, LPARAM);

void    WINAPI SetDlgItemInt(HWND, int, UINT, BOOL);
UINT    WINAPI GetDlgItemInt(HWND, int, BOOL FAR* , BOOL);

void    WINAPI SetDlgItemText(HWND, int, LPCSTR);
int     WINAPI GetDlgItemText(HWND, int, LPSTR, int);

void    WINAPI CheckDlgButton(HWND, int, UINT);
void    WINAPI CheckRadioButton(HWND, int, int, int);
UINT    WINAPI IsDlgButtonChecked(HWND, int);

HWND    WINAPI GetNextDlgGroupItem(HWND, HWND, BOOL);
HWND    WINAPI GetNextDlgTabItem(HWND, HWND, BOOL);

void    WINAPI MapDialogRect(HWND, RECT FAR*);
DWORD   WINAPI GetDialogBaseUnits(void);

#define WM_GETDLGCODE	    0x0087

/* dialog codes */
#define DLGC_WANTARROWS     0x0001
#define DLGC_WANTTAB        0x0002
#define DLGC_WANTALLKEYS    0x0004
#define DLGC_WANTMESSAGE    0x0004
#define DLGC_HASSETSEL      0x0008
#define DLGC_DEFPUSHBUTTON  0x0010
#define DLGC_UNDEFPUSHBUTTON 0x0020
#define DLGC_RADIOBUTTON    0x0040
#define DLGC_WANTCHARS      0x0080
#define DLGC_STATIC         0x0100
#define DLGC_BUTTON         0x2000

#define WM_CTLCOLOR	    0x0019

/* WM_CTLCOLOR control IDs */
#define CTLCOLOR_MSGBOX     0
#define CTLCOLOR_EDIT	    1
#define CTLCOLOR_LISTBOX    2
#define CTLCOLOR_BTN	    3
#define CTLCOLOR_DLG	    4
#define CTLCOLOR_SCROLLBAR  5
#define CTLCOLOR_STATIC     6

#define WM_SETFONT          0x0030
#define WM_GETFONT	    0x0031

#endif  /* NOCTLMGR */

/* Standard dialog button IDs */
#define IDOK		    1
#define IDCANCEL	    2
#define IDABORT 	    3
#define IDRETRY 	    4
#define IDIGNORE	    5
#define IDYES		    6
#define IDNO		    7

/****** Owner draw control support ******************************************/

/* Owner draw control types */
#define ODT_MENU	1
#define ODT_LISTBOX	2
#define ODT_COMBOBOX	3
#define ODT_BUTTON	4

/* Owner draw actions */
#define ODA_DRAWENTIRE	0x0001
#define ODA_SELECT	0x0002
#define ODA_FOCUS	0x0004

/* Owner draw state */
#define ODS_SELECTED	0x0001
#define ODS_GRAYED	0x0002
#define ODS_DISABLED	0x0004
#define ODS_CHECKED	0x0008
#define ODS_FOCUS	0x0010

#define WM_DRAWITEM         0x002B

typedef struct tagDRAWITEMSTRUCT
{
    UINT        CtlType;
    UINT        CtlID;
    UINT        itemID;
    UINT        itemAction;
    UINT        itemState;
    HWND	hwndItem;
    HDC		hDC;
    RECT	rcItem;
    DWORD       itemData;
} DRAWITEMSTRUCT;
typedef DRAWITEMSTRUCT NEAR* PDRAWITEMSTRUCT;
typedef DRAWITEMSTRUCT FAR* LPDRAWITEMSTRUCT;

#define WM_MEASUREITEM      0x002C

typedef struct tagMEASUREITEMSTRUCT
{
    UINT        CtlType;
    UINT        CtlID;
    UINT        itemID;
    UINT        itemWidth;
    UINT        itemHeight;
    DWORD       itemData;
} MEASUREITEMSTRUCT;
typedef MEASUREITEMSTRUCT NEAR* PMEASUREITEMSTRUCT;
typedef MEASUREITEMSTRUCT FAR* LPMEASUREITEMSTRUCT;

#define WM_DELETEITEM       0x002D

typedef struct tagDELETEITEMSTRUCT
{
    UINT       CtlType;
    UINT       CtlID;
    UINT       itemID;
    HWND       hwndItem;
    DWORD      itemData;
} DELETEITEMSTRUCT;
typedef DELETEITEMSTRUCT NEAR* PDELETEITEMSTRUCT;
typedef DELETEITEMSTRUCT FAR* LPDELETEITEMSTRUCT;

#define WM_COMPAREITEM	    0x0039

typedef struct tagCOMPAREITEMSTRUCT
{
    UINT        CtlType;
    UINT        CtlID;
    HWND	hwndItem;
    UINT        itemID1;
    DWORD       itemData1;
    UINT        itemID2;
    DWORD       itemData2;
} COMPAREITEMSTRUCT;
typedef COMPAREITEMSTRUCT NEAR* PCOMPAREITEMSTRUCT;
typedef COMPAREITEMSTRUCT FAR* LPCOMPAREITEMSTRUCT;

/****** Static control ******************************************************/

#ifndef NOCTLMGR

/* Static Control Styles */
#define SS_LEFT 	    0x00000000L
#define SS_CENTER	    0x00000001L
#define SS_RIGHT	    0x00000002L
#define SS_ICON 	    0x00000003L
#define SS_BLACKRECT	    0x00000004L
#define SS_GRAYRECT	    0x00000005L
#define SS_WHITERECT	    0x00000006L
#define SS_BLACKFRAME	    0x00000007L
#define SS_GRAYFRAME	    0x00000008L
#define SS_WHITEFRAME	    0x00000009L
#define SS_SIMPLE	    0x0000000BL
#define SS_LEFTNOWORDWRAP   0x0000000CL
#define SS_NOPREFIX         0x00000080L

#if (WINVER >= 0x030a)
#ifndef NOWINMESSAGES
/* Static Control Mesages */
#define STM_SETICON	    (WM_USER+0)
#define STM_GETICON	    (WM_USER+1)
#endif  /* NOWINMESSAGES */
#endif  /* WINVER >= 0x030a */

#endif  /* NOCTLMGR */

/****** Button control *****************************************************/

#ifndef NOCTLMGR

/* Button Control Styles */
#define BS_PUSHBUTTON	    0x00000000L
#define BS_DEFPUSHBUTTON    0x00000001L
#define BS_CHECKBOX	    0x00000002L
#define BS_AUTOCHECKBOX     0x00000003L
#define BS_RADIOBUTTON	    0x00000004L
#define BS_3STATE	    0x00000005L
#define BS_AUTO3STATE	    0x00000006L
#define BS_GROUPBOX	    0x00000007L
#define BS_USERBUTTON	    0x00000008L
#define BS_AUTORADIOBUTTON  0x00000009L
#define BS_OWNERDRAW	    0x0000000BL
#define BS_LEFTTEXT	    0x00000020L

/* Button Control Messages  */
#define BM_GETCHECK	    (WM_USER+0)
#define BM_SETCHECK	    (WM_USER+1)
#define BM_GETSTATE	    (WM_USER+2)
#define BM_SETSTATE	    (WM_USER+3)
#define BM_SETSTYLE	    (WM_USER+4)

/* User Button Notification Codes */
#define BN_CLICKED	    0
#define BN_PAINT	    1
#define BN_HILITE	    2
#define BN_UNHILITE	    3
#define BN_DISABLE	    4
#define BN_DOUBLECLICKED    5

#endif  /* NOCTLMGR */

/****** Edit control *******************************************************/

#ifndef NOCTLMGR

/* Edit control styles */
#ifndef NOWINSTYLES
#define ES_LEFT 	    0x00000000L
#define ES_CENTER	    0x00000001L
#define ES_RIGHT	    0x00000002L
#define ES_MULTILINE	    0x00000004L
#define ES_UPPERCASE	    0x00000008L
#define ES_LOWERCASE	    0x00000010L
#define ES_PASSWORD         0x00000020L
#define ES_AUTOVSCROLL	    0x00000040L
#define ES_AUTOHSCROLL	    0x00000080L
#define ES_NOHIDESEL	    0x00000100L
#define ES_OEMCONVERT	    0x00000400L
#if (WINVER >= 0x030a)
#define ES_READONLY	    0x00000800L
#define ES_WANTRETURN       0x00001000L
#endif  /* WINVER >= 0x030a */
#endif  /* NOWINSTYLES */

/* Edit control messages */
#ifndef NOWINMESSAGES
#define EM_GETSEL	        (WM_USER+0)
#define EM_SETSEL	        (WM_USER+1)
#define EM_GETRECT	        (WM_USER+2)
#define EM_SETRECT	        (WM_USER+3)
#define EM_SETRECTNP	        (WM_USER+4)
#define EM_LINESCROLL	        (WM_USER+6)
#define EM_GETMODIFY	        (WM_USER+8)
#define EM_SETMODIFY	        (WM_USER+9)
#define EM_GETLINECOUNT         (WM_USER+10)
#define EM_LINEINDEX	        (WM_USER+11)
#define EM_SETHANDLE	        (WM_USER+12)
#define EM_GETHANDLE	        (WM_USER+13)
#define EM_LINELENGTH	        (WM_USER+17)
#define EM_REPLACESEL	        (WM_USER+18)
#define EM_SETFONT              (WM_USER+19)    /* NOT IMPLEMENTED: use WM_SETFONT */
#define EM_GETLINE	        (WM_USER+20)
#define EM_LIMITTEXT	        (WM_USER+21)
#define EM_CANUNDO	        (WM_USER+22)
#define EM_UNDO 	        (WM_USER+23)
#define EM_FMTLINES	        (WM_USER+24)
#define EM_LINEFROMCHAR         (WM_USER+25)
#define EM_SETWORDBREAK         (WM_USER+26)    /* NOT IMPLEMENTED: use EM_SETWORDBREAK */
#define EM_SETTABSTOPS	        (WM_USER+27)
#define EM_SETPASSWORDCHAR      (WM_USER+28)
#define EM_EMPTYUNDOBUFFER      (WM_USER+29)
#if (WINVER >= 0x030a)
#define EM_GETFIRSTVISIBLELINE	(WM_USER+30)
#define EM_SETREADONLY	        (WM_USER+31)
#define EM_SETWORDBREAKPROC     (WM_USER+32)
#define EM_GETWORDBREAKPROC     (WM_USER+33)
#define EM_GETPASSWORDCHAR      (WM_USER+34)
#endif  /* WINVER >= 0x030a */
#endif  /* NOWINMESSAGES */

#if (WINVER >= 0x030a)
typedef int   (CALLBACK* EDITWORDBREAKPROC)(LPSTR lpch, int ichCurrent, int cch, int code);

/* EDITWORDBREAKPROC code values */
#define WB_LEFT		   0
#define WB_RIGHT	   1
#define WB_ISDELIMITER     2
#endif  /* WINVER >= 0x030a */

/* Edit control notification codes */
#define EN_SETFOCUS	    0x0100
#define EN_KILLFOCUS	    0x0200
#define EN_CHANGE	    0x0300
#define EN_UPDATE	    0x0400
#define EN_ERRSPACE	    0x0500
#define EN_MAXTEXT	    0x0501
#define EN_HSCROLL	    0x0601
#define EN_VSCROLL	    0x0602

#endif  /* NOCTLMGR */

/****** Scroll bar control *************************************************/
/* Also see scrolling support */

#ifndef NOCTLMGR

#ifndef NOWINSTYLES

/* Scroll bar styles */
#define SBS_HORZ		    0x0000L
#define SBS_VERT		    0x0001L
#define SBS_TOPALIGN		    0x0002L
#define SBS_LEFTALIGN		    0x0002L
#define SBS_BOTTOMALIGN		    0x0004L
#define SBS_RIGHTALIGN		    0x0004L
#define SBS_SIZEBOXTOPLEFTALIGN	    0x0002L
#define SBS_SIZEBOXBOTTOMRIGHTALIGN 0x0004L
#define SBS_SIZEBOX		    0x0008L

#endif  /* NOWINSTYLES */

#endif  /* NOCTLMGR */

/****** Listbox control ****************************************************/

#ifndef NOCTLMGR

/* Listbox styles */
#ifndef NOWINSTYLES
#define LBS_NOTIFY	      0x0001L
#define LBS_SORT	      0x0002L
#define LBS_NOREDRAW	      0x0004L
#define LBS_MULTIPLESEL       0x0008L
#define LBS_OWNERDRAWFIXED    0x0010L
#define LBS_OWNERDRAWVARIABLE 0x0020L
#define LBS_HASSTRINGS        0x0040L
#define LBS_USETABSTOPS       0x0080L
#define LBS_NOINTEGRALHEIGHT  0x0100L
#define LBS_MULTICOLUMN       0x0200L
#define LBS_WANTKEYBOARDINPUT 0x0400L
#define LBS_EXTENDEDSEL	      0x0800L
#if (WINVER >= 0x030a)
#define LBS_DISABLENOSCROLL   0x1000L
#endif  /* WINVER >= 0x030a */
#define LBS_STANDARD	      (LBS_NOTIFY | LBS_SORT | WS_VSCROLL | WS_BORDER)
#endif  /* NOWINSTYLES */

/* Listbox messages */
#ifndef NOWINMESSAGES
#define LB_ADDSTRING	       (WM_USER+1)
#define LB_INSERTSTRING        (WM_USER+2)
#define LB_DELETESTRING        (WM_USER+3)
#define LB_RESETCONTENT        (WM_USER+5)
#define LB_SETSEL	       (WM_USER+6)
#define LB_SETCURSEL	       (WM_USER+7)
#define LB_GETSEL	       (WM_USER+8)
#define LB_GETCURSEL	       (WM_USER+9)
#define LB_GETTEXT	       (WM_USER+10)
#define LB_GETTEXTLEN	       (WM_USER+11)
#define LB_GETCOUNT	       (WM_USER+12)
#define LB_SELECTSTRING        (WM_USER+13)
#define LB_DIR		       (WM_USER+14)
#define LB_GETTOPINDEX	       (WM_USER+15)
#define LB_FINDSTRING	       (WM_USER+16)
#define LB_GETSELCOUNT	       (WM_USER+17)
#define LB_GETSELITEMS	       (WM_USER+18)
#define LB_SETTABSTOPS         (WM_USER+19)
#define LB_GETHORIZONTALEXTENT (WM_USER+20)
#define LB_SETHORIZONTALEXTENT (WM_USER+21)
#define LB_SETCOLUMNWIDTH      (WM_USER+22)
#define LB_SETTOPINDEX	       (WM_USER+24)
#define LB_GETITEMRECT	       (WM_USER+25)
#define LB_GETITEMDATA         (WM_USER+26)
#define LB_SETITEMDATA         (WM_USER+27)
#define LB_SELITEMRANGE        (WM_USER+28)
#define LB_SETCARETINDEX       (WM_USER+31)
#define LB_GETCARETINDEX       (WM_USER+32)

#if (WINVER >= 0x030a)
#define LB_SETITEMHEIGHT       (WM_USER+33)
#define LB_GETITEMHEIGHT       (WM_USER+34)
#define LB_FINDSTRINGEXACT     (WM_USER+35)
#endif  /* WINVER >= 0x030a */

#endif  /* NOWINMESSAGES */

/* Listbox notification codes */
#define LBN_ERRSPACE	    (-2)
#define LBN_SELCHANGE	    1
#define LBN_DBLCLK	    2
#define LBN_SELCANCEL       3
#define LBN_SETFOCUS        4
#define LBN_KILLFOCUS       5

/* Listbox notification messages */
#define WM_VKEYTOITEM       0x002E
#define WM_CHARTOITEM       0x002F

/* Listbox message return values */
#define LB_OKAY 	    0
#define LB_ERR		    (-1)
#define LB_ERRSPACE	    (-2)

#define LB_CTLCODE	    0L

/****** Dialog directory support ********************************************/

int     WINAPI DlgDirList(HWND, LPSTR, int, int, UINT);
BOOL    WINAPI DlgDirSelect(HWND, LPSTR, int);

int     WINAPI DlgDirListComboBox(HWND, LPSTR, int, int, UINT);
BOOL    WINAPI DlgDirSelectComboBox(HWND, LPSTR, int);

#if (WINVER >= 0x030a)
BOOL    WINAPI DlgDirSelectEx(HWND, LPSTR, int, int);
BOOL    WINAPI DlgDirSelectComboBoxEx(HWND, LPSTR, int, int);
#endif  /* WINVER >= 0x030a */


/* DlgDirList, DlgDirListComboBox flags values */
#define DDL_READWRITE       0x0000
#define DDL_READONLY        0x0001
#define DDL_HIDDEN          0x0002
#define DDL_SYSTEM          0x0004
#define DDL_DIRECTORY	    0x0010
#define DDL_ARCHIVE	    0x0020

#define DDL_POSTMSGS	    0x2000
#define DDL_DRIVES	    0x4000
#define DDL_EXCLUSIVE	    0x8000

#endif  /* NOCTLMGR */

/****** Combo box control **************************************************/

#ifndef NOCTLMGR

/* Combo box styles */
#ifndef NOWINSTYLES
#define CBS_SIMPLE	      0x0001L
#define CBS_DROPDOWN	      0x0002L
#define CBS_DROPDOWNLIST      0x0003L
#define CBS_OWNERDRAWFIXED    0x0010L
#define CBS_OWNERDRAWVARIABLE 0x0020L
#define CBS_AUTOHSCROLL       0x0040L
#define CBS_OEMCONVERT        0x0080L
#define CBS_SORT              0x0100L
#define CBS_HASSTRINGS        0x0200L
#define CBS_NOINTEGRALHEIGHT  0x0400L
#if (WINVER >= 0x030a)
#define CBS_DISABLENOSCROLL   0x0800L
#endif  /* WINVER >= 0x030a */
#endif  /* NOWINSTYLES */

/* Combo box messages */
#ifndef NOWINMESSAGES
#define CB_GETEDITSEL	         (WM_USER+0)
#define CB_LIMITTEXT	         (WM_USER+1)
#define CB_SETEDITSEL	         (WM_USER+2)
#define CB_ADDSTRING	         (WM_USER+3)
#define CB_DELETESTRING	         (WM_USER+4)
#define CB_DIR                   (WM_USER+5)
#define CB_GETCOUNT	         (WM_USER+6)
#define CB_GETCURSEL	         (WM_USER+7)
#define CB_GETLBTEXT	         (WM_USER+8)
#define CB_GETLBTEXTLEN	         (WM_USER+9)
#define CB_INSERTSTRING          (WM_USER+10)
#define CB_RESETCONTENT	         (WM_USER+11)
#define CB_FINDSTRING	         (WM_USER+12)
#define CB_SELECTSTRING	         (WM_USER+13)
#define CB_SETCURSEL	         (WM_USER+14)
#define CB_SHOWDROPDOWN          (WM_USER+15)
#define CB_GETITEMDATA           (WM_USER+16)
#define CB_SETITEMDATA           (WM_USER+17)
#if (WINVER >= 0x030a)
#define CB_GETDROPPEDCONTROLRECT (WM_USER+18)
#define CB_SETITEMHEIGHT         (WM_USER+19)
#define CB_GETITEMHEIGHT         (WM_USER+20)
#define CB_SETEXTENDEDUI         (WM_USER+21)
#define CB_GETEXTENDEDUI         (WM_USER+22)
#define CB_GETDROPPEDSTATE       (WM_USER+23)
#define CB_FINDSTRINGEXACT       (WM_USER+24)
#endif  /* WINVER >= 0x030a */

#endif  /* NOWINMESSAGES */

/* Combo box notification codes */
#define CBN_ERRSPACE	    (-1)
#define CBN_SELCHANGE	    1
#define CBN_DBLCLK	    2
#define CBN_SETFOCUS	    3
#define CBN_KILLFOCUS	    4
#define CBN_EDITCHANGE      5
#define CBN_EDITUPDATE      6
#define CBN_DROPDOWN        7
#if (WINVER >= 0x030a)
#define CBN_CLOSEUP         8
#define CBN_SELENDOK        9
#define CBN_SELENDCANCEL    10
#endif  /* WINVER >= 0x030a */

/* Combo box message return values */
#define CB_OKAY 	    0
#define CB_ERR		    (-1)
#define CB_ERRSPACE	    (-2)

#endif	/* NOCTLMGR */

/******* Windows hook support **********************************************/

#ifndef NOWH

DECLARE_HANDLE32(HHOOK);

#ifdef STRICT
typedef LRESULT (CALLBACK* HOOKPROC)(int code, WPARAM wParam, LPARAM lParam);
#else
typedef FARPROC HOOKPROC;
#endif

#ifdef STRICT
HHOOK   WINAPI SetWindowsHook(int, HOOKPROC);
LRESULT WINAPI DefHookProc(int, WPARAM, LPARAM, HHOOK FAR*);
#else
HOOKPROC WINAPI SetWindowsHook(int, HOOKPROC);
LRESULT WINAPI DefHookProc(int, WPARAM, LPARAM, HOOKPROC FAR*);
#endif
BOOL    WINAPI UnhookWindowsHook(int, HOOKPROC);

#if (WINVER >= 0x030a)

HHOOK   WINAPI SetWindowsHookEx(int idHook, HOOKPROC lpfn, HINSTANCE hInstance, HTASK hTask);
BOOL    WINAPI UnhookWindowsHookEx(HHOOK hHook);
LRESULT WINAPI CallNextHookEx(HHOOK hHook, int code, WPARAM wParam, LPARAM lParam);

#endif  /* WINVER >= 0x030a */


/* Standard hook code */
#define HC_ACTION	    0

/* Obsolete hook codes (NO LONGER SUPPORTED) */
#define HC_GETLPLPFN	    (-3)
#define HC_LPLPFNNEXT	    (-2)
#define HC_LPFNNEXT	    (-1)

#endif	/* NOWH */

/****** Computer-based-training (CBT) support *******************************/

#define WM_QUEUESYNC        0x0023

#ifndef NOWH

/* SetWindowsHook() code */
#define WH_CBT		    5

#define HCBT_MOVESIZE	    0
#define HCBT_MINMAX	    1
#define HCBT_QS 	    2
#define HCBT_CREATEWND	    3
#define HCBT_DESTROYWND	    4
#define HCBT_ACTIVATE	    5
#define HCBT_CLICKSKIPPED   6
#define HCBT_KEYSKIPPED     7
#define HCBT_SYSCOMMAND	    8
#define HCBT_SETFOCUS	    9

#if (WINVER >= 0x030a)
/* HCBT_CREATEWND parameters pointed to by lParam */
typedef struct tagCBT_CREATEWND
{
    CREATESTRUCT FAR* lpcs;
    HWND    hwndInsertAfter;
} CBT_CREATEWND;
typedef CBT_CREATEWND FAR* LPCBT_CREATEWND;

/* HCBT_ACTIVATE structure pointed to by lParam */
typedef struct tagCBTACTIVATESTRUCT
{
    BOOL    fMouse;
    HWND    hWndActive;
} CBTACTIVATESTRUCT;

#endif  /* WINVER >= 0x030a */
#endif	/* NOWH */

/****** Hardware hook support ***********************************************/

#ifndef NOWH
#if (WINVER >= 0x030a)
#define WH_HARDWARE	    8

typedef struct tagHARDWAREHOOKSTRUCT
{
    HWND    hWnd;
    UINT    wMessage;
    WPARAM  wParam;
    LPARAM  lParam;
} HARDWAREHOOKSTRUCT;
#endif  /* WINVER >= 0x030a */
#endif  /* NOWH */

/****** Shell support *******************************************************/

#ifndef NOWH
#if (WINVER >= 0x030a)
/* SetWindowsHook() Shell hook code */
#define WH_SHELL           10

#define HSHELL_WINDOWCREATED       1
#define HSHELL_WINDOWDESTROYED     2
#define HSHELL_ACTIVATESHELLWINDOW 3

#endif  /* WINVER >= 0x030a */
#endif  /* NOWH */

/****** Journalling support *************************************************/

#ifndef NOWH
#define WH_JOURNALRECORD    0
#define WH_JOURNALPLAYBACK  1

/* Journalling hook codes */
#define HC_GETNEXT	    1
#define HC_SKIP 	    2
#define HC_NOREMOVE	    3
#define HC_NOREM	    HC_NOREMOVE
#define HC_SYSMODALON       4
#define HC_SYSMODALOFF	    5

/* Journalling message structure */
typedef struct tagEVENTMSG
{
    UINT    message;
    UINT    paramL;
    UINT    paramH;
    DWORD   time;
} EVENTMSG;
typedef EVENTMSG *PEVENTMSG;
typedef EVENTMSG NEAR* NPEVENTMSG;
typedef EVENTMSG FAR* LPEVENTMSG;

BOOL    WINAPI EnableHardwareInput(BOOL);

#endif	/* NOWH */


/****** Debugger support ****************************************************/

#if (WINVER >= 0x030a)
/* SetWindowsHook debug hook support */
#define WH_DEBUG	    9

typedef struct tagDEBUGHOOKINFO
{
    HMODULE	hModuleHook;
    LPARAM	reserved;
    LPARAM	lParam;
    WPARAM	wParam;
    int         code;
} DEBUGHOOKINFO;
typedef DEBUGHOOKINFO FAR* LPDEBUGHOOKINFO;

#ifndef NOMSG
BOOL WINAPI QuerySendMessage(HANDLE h1, HANDLE h2, HANDLE h3, LPMSG lpmsg);
#endif  /* NOMSG */

BOOL WINAPI LockInput(HANDLE h1, HWND hwndInput, BOOL fLock);

LONG WINAPI GetSystemDebugState(void);
/* Flags returned by GetSystemDebugState.
 */
#define SDS_MENU        0x0001
#define SDS_SYSMODAL    0x0002
#define SDS_NOTASKQUEUE 0x0004
#define SDS_DIALOG      0x0008
#define SDS_TASKLOCKED  0x0010
#endif  /* WINVER >= 0x030a */

/****** Help support ********************************************************/

#ifndef NOHELP

BOOL WINAPI WinHelp(HWND hwndMain, LPCSTR lpszHelp, UINT usCommand, DWORD ulData);

/* WinHelp() commands */
#define HELP_CONTEXT      0x0001
#define HELP_QUIT         0x0002
#define HELP_INDEX        0x0003
#define HELP_CONTENTS     0x0003
#define HELP_HELPONHELP   0x0004
#define HELP_SETINDEX     0x0005
#define HELP_SETCONTENTS  0x0005
#define HELP_CONTEXTPOPUP 0x0008
#define HELP_FORCEFILE    0x0009
#define HELP_KEY          0x0101
#define HELP_COMMAND      0x0102
#define HELP_PARTIALKEY   0x0105
#define HELP_MULTIKEY     0x0201
#define HELP_SETWINPOS    0x0203

typedef struct tagMULTIKEYHELP
{
    UINT    mkSize;
    BYTE    mkKeylist;
    BYTE    szKeyphrase[1];
} MULTIKEYHELP;


typedef struct
{
    int  wStructSize;
    int  x;
    int  y;
    int  dx;
    int  dy;
    int  wMax;
    char rgchMember[2];
} HELPWININFO;
typedef HELPWININFO NEAR* PHELPWININFO;
typedef HELPWININFO FAR* LPHELPWININFO;

#endif  /* NOHELP */

/****** Sound support ******************************************************/

#ifndef NOSOUND

int     WINAPI OpenSound(void);
void    WINAPI CloseSound(void);

int     WINAPI StartSound(void);
int     WINAPI StopSound(void);

int     WINAPI SetVoiceQueueSize(int, int);
int     WINAPI SetVoiceNote(int, int, int, int);
int     WINAPI SetVoiceAccent(int, int, int, int, int);
int     WINAPI SetVoiceEnvelope(int, int, int);
int     WINAPI SetVoiceSound(int, DWORD, int);

int     WINAPI SetVoiceThreshold(int, int);
int FAR* WINAPI GetThresholdEvent(void);
int     WINAPI GetThresholdStatus(void);

int     WINAPI SetSoundNoise(int, int);

/* SetSoundNoise() Sources */
#define S_PERIOD512   0
#define S_PERIOD1024  1
#define S_PERIOD2048  2
#define S_PERIODVOICE 3
#define S_WHITE512    4
#define S_WHITE1024   5
#define S_WHITE2048   6
#define S_WHITEVOICE  7

int     WINAPI WaitSoundState(int);

/* WaitSoundState() constants */
#define S_QUEUEEMPTY	    0
#define S_THRESHOLD	    1
#define S_ALLTHRESHOLD	    2

int     WINAPI SyncAllVoices(void);
int     WINAPI CountVoiceNotes(int);

/* Accent Modes */
#define S_NORMAL      0
#define S_LEGATO      1
#define S_STACCATO    2

/* Error return values */
#define S_SERDVNA     (-1)
#define S_SEROFM      (-2)
#define S_SERMACT     (-3)
#define S_SERQFUL     (-4)
#define S_SERBDNT     (-5)
#define S_SERDLN      (-6)
#define S_SERDCC      (-7)
#define S_SERDTP      (-8)
#define S_SERDVL      (-9)
#define S_SERDMD      (-10)
#define S_SERDSH      (-11)
#define S_SERDPT      (-12)
#define S_SERDFQ      (-13)
#define S_SERDDR      (-14)
#define S_SERDSR      (-15)
#define S_SERDST      (-16)

#endif  /* NOSOUND */

/****** Comm support ******************************************************/

#ifndef NOCOMM

#define NOPARITY	    0
#define ODDPARITY	    1
#define EVENPARITY	    2
#define MARKPARITY	    3
#define SPACEPARITY	    4

#define ONESTOPBIT	    0
#define ONE5STOPBITS	    1
#define TWOSTOPBITS	    2

#define IGNORE              0
#define INFINITE            0xFFFF

/* Error Flags */
#define CE_RXOVER           0x0001
#define CE_OVERRUN          0x0002
#define CE_RXPARITY         0x0004
#define CE_FRAME            0x0008
#define CE_BREAK            0x0010
#define CE_CTSTO            0x0020
#define CE_DSRTO            0x0040
#define CE_RLSDTO           0x0080
#define CE_TXFULL           0x0100
#define CE_PTO              0x0200
#define CE_IOE              0x0400
#define CE_DNS              0x0800
#define CE_OOP              0x1000
#define CE_MODE             0x8000

#define IE_BADID            (-1)
#define IE_OPEN             (-2)
#define IE_NOPEN            (-3)
#define IE_MEMORY           (-4)
#define IE_DEFAULT          (-5)
#define IE_HARDWARE         (-10)
#define IE_BYTESIZE         (-11)
#define IE_BAUDRATE         (-12)

/* Events */
#define EV_RXCHAR           0x0001
#define EV_RXFLAG           0x0002
#define EV_TXEMPTY          0x0004
#define EV_CTS              0x0008
#define EV_DSR              0x0010
#define EV_RLSD             0x0020
#define EV_BREAK            0x0040
#define EV_ERR              0x0080
#define EV_RING             0x0100
#define EV_PERR             0x0200
#define EV_CTSS             0x0400
#define EV_DSRS             0x0800
#define EV_RLSDS            0x1000
#define EV_RingTe           0x2000
#define EV_RINGTE	    EV_RingTe

/* Escape Functions */
#define SETXOFF             1
#define SETXON              2
#define SETRTS              3
#define CLRRTS              4
#define SETDTR              5
#define CLRDTR              6
#define RESETDEV            7

#define LPTx                0x80

#if (WINVER >= 0x030a)

/* new escape functions */
#define GETMAXLPT           8
#define GETMAXCOM           9
#define GETBASEIRQ          10

/* Comm Baud Rate indices */
#define CBR_110	     0xFF10
#define CBR_300      0xFF11
#define CBR_600      0xFF12
#define CBR_1200     0xFF13
#define CBR_2400     0xFF14
#define CBR_4800     0xFF15
#define CBR_9600     0xFF16
#define CBR_14400    0xFF17
#define CBR_19200    0xFF18
#define CBR_38400    0xFF1B
#define CBR_56000    0xFF1F
#define CBR_128000   0xFF23
#define CBR_256000   0xFF27

/* notifications passed in low word of lParam on WM_COMMNOTIFY messages */
#define CN_RECEIVE  0x0001
#define CN_TRANSMIT 0x0002
#define CN_EVENT    0x0004

#endif  /* WINVER >= 0x030a */

typedef struct tagDCB
{
    BYTE Id;
    UINT BaudRate;
    BYTE ByteSize;
    BYTE Parity;
    BYTE StopBits;
    UINT RlsTimeout;
    UINT CtsTimeout;
    UINT DsrTimeout;

    UINT fBinary        :1;
    UINT fRtsDisable    :1;
    UINT fParity        :1;
    UINT fOutxCtsFlow   :1;
    UINT fOutxDsrFlow   :1;
    UINT fDummy         :2;
    UINT fDtrDisable    :1;

    UINT fOutX          :1;
    UINT fInX           :1;
    UINT fPeChar        :1;
    UINT fNull          :1;
    UINT fChEvt         :1;
    UINT fDtrflow       :1;
    UINT fRtsflow       :1;
    UINT fDummy2        :1;

    char XonChar;
    char XoffChar;
    UINT XonLim;
    UINT XoffLim;
    char PeChar;
    char EofChar;
    char EvtChar;
    UINT TxDelay;
} DCB;
typedef DCB FAR* LPDCB;

#if (defined(STRICT) | (WINVER >= 0x030a))

typedef struct tagCOMSTAT
{
    BYTE status;
    UINT cbInQue;
    UINT cbOutQue;
} COMSTAT;

#define CSTF_CTSHOLD    0x01
#define CSTF_DSRHOLD    0x02
#define CSTF_RLSDHOLD   0x04
#define CSTF_XOFFHOLD   0x08
#define CSTF_XOFFSENT   0x10
#define CSTF_EOF        0x20
#define CSTF_TXIM       0x40

#else   /* (STRICT | WINVER >= 0x030a) */

/* NOTE: This structure declaration is not ANSI compatible! */
typedef struct tagCOMSTAT
{
    BYTE fCtsHold  :1;
    BYTE fDsrHold  :1;
    BYTE fRlsdHold :1;
    BYTE fXoffHold :1;
    BYTE fXoffSent :1;
    BYTE fEof      :1;
    BYTE fTxim     :1;
    UINT cbInQue;
    UINT cbOutQue;
} COMSTAT;

#endif  /* !(STRICT | WINVER >= 0x030a */

int     WINAPI BuildCommDCB(LPCSTR, DCB FAR*);

int     WINAPI OpenComm(LPCSTR, UINT, UINT);
int     WINAPI CloseComm(int);

int     WINAPI ReadComm(int, void FAR*, int);
int     WINAPI WriteComm(int, const void FAR*, int);
int     WINAPI UngetCommChar(int, char);
int     WINAPI FlushComm(int, int);
int     WINAPI TransmitCommChar(int, char);

int     WINAPI SetCommState(const DCB FAR*);
int     WINAPI GetCommState(int, DCB FAR*);
int     WINAPI GetCommError(int, COMSTAT FAR* );

int     WINAPI SetCommBreak(int);
int     WINAPI ClearCommBreak(int);

UINT FAR* WINAPI SetCommEventMask(int, UINT);
UINT    WINAPI GetCommEventMask(int, int);

LONG    WINAPI EscapeCommFunction(int, int);

#if (WINVER >= 0x030a)
BOOL    WINAPI EnableCommNotification(int, HWND, int, int);

#define WM_COMMNOTIFY		0x0044
#endif  /* WINVER >= 0x030a */

#endif  /* NOCOMM */

/****** String formatting support *******************************************/

int     WINAPI wvsprintf(LPSTR lpszOut, LPCSTR lpszFmt, const void FAR* lpParams);

int	FAR CDECL wsprintf(LPSTR lpszOut, LPCSTR lpszFmt, ...);


/****** Driver support ******************************************************/

#if (WINVER >= 0x030a)

#ifndef NODRIVERS

DECLARE_HANDLE(HDRVR);

typedef LRESULT (CALLBACK* DRIVERPROC)(DWORD, HDRVR, UINT, LPARAM, LPARAM);

/* Driver messages */
#define DRV_LOAD		0x0001
#define DRV_ENABLE		0x0002
#define DRV_OPEN		0x0003
#define DRV_CLOSE		0x0004
#define DRV_DISABLE		0x0005
#define DRV_FREE		0x0006
#define DRV_CONFIGURE		0x0007
#define DRV_QUERYCONFIGURE	0x0008
#define DRV_INSTALL		0x0009
#define DRV_REMOVE		0x000A
#define DRV_EXITSESSION         0x000B
#define DRV_EXITAPPLICATION     0x000C
#define DRV_POWER		0x000F

#define DRV_RESERVED		0x0800
#define DRV_USER		0x4000

/* LPARAM of DRV_CONFIGURE message */
typedef struct tagDRVCONFIGINFO
{
    DWORD   dwDCISize;
    LPCSTR  lpszDCISectionName;
    LPCSTR  lpszDCIAliasName;
} DRVCONFIGINFO;
typedef DRVCONFIGINFO NEAR* PDRVCONFIGINFO;
typedef DRVCONFIGINFO FAR* LPDRVCONFIGINFO;

/* Supported return values for DRV_CONFIGURE message */
#define DRVCNF_CANCEL		0x0000
#define DRVCNF_OK		0x0001
#define DRVCNF_RESTART		0x0002

/* Supported lParam1 of DRV_EXITAPPLICATION notification */
#define DRVEA_NORMALEXIT            0x0001
#define DRVEA_ABNORMALEXIT          0x0002

LRESULT WINAPI DefDriverProc(DWORD dwDriverIdentifier, HDRVR driverID, UINT message, LPARAM lParam1, LPARAM lParam2);

HDRVR   WINAPI OpenDriver(LPCSTR szDriverName, LPCSTR szSectionName, LPARAM lParam2);
LRESULT WINAPI CloseDriver(HDRVR hDriver, LPARAM lParam1, LPARAM lParam2);

LRESULT WINAPI SendDriverMessage(HDRVR hDriver, UINT message, LPARAM lParam1, LPARAM lParam2);

HINSTANCE WINAPI GetDriverModuleHandle(HDRVR hDriver);

HDRVR   WINAPI GetNextDriver(HDRVR, DWORD);

/* GetNextDriver flags */
#define GND_FIRSTINSTANCEONLY	0x00000001

#define GND_FORWARD             0x00000000
#define GND_REVERSE		0x00000002

typedef struct tagDRIVERINFOSTRUCT
{
    UINT    length;
    HDRVR   hDriver;
    HINSTANCE hModule;
    char    szAliasName[128];
} DRIVERINFOSTRUCT;
typedef DRIVERINFOSTRUCT FAR* LPDRIVERINFOSTRUCT;

BOOL    WINAPI GetDriverInfo(HDRVR, DRIVERINFOSTRUCT FAR*);

#endif  /* !NODRIVERS */
#endif  /* WINVER >= 0x030a */
#endif  /* NOUSER */

#ifndef RC_INVOKED
#pragma pack()          /* Revert to default packing */
#endif  /* RC_INVOKED */

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif	/* __cplusplus */

#endif  /* _INC_WINDOWS */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\inc32\COMMDLG.H ===
/************************************************************************
*                                                                       *
*   commdlg.h -- This module defines the 32-Bit Common Dialog APIs      *
*                                                                       *
*   Copyright (c) 1992-1995, Microsoft Corp. All rights reserved.       *
*                                                                       *
************************************************************************/
#ifndef _INC_COMMDLG
#define _INC_COMMDLG

#include <pshpack1.h>         /* Assume byte packing throughout */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */

#if(WINVER >= 0x0400)
#ifdef __cplusplus
#define SNDMSG ::SendMessage
#else   /* __cplusplus */
#define SNDMSG SendMessage
#endif  /* __cplusplus */
#endif /* WINVER >= 0x0400 */

typedef UINT (APIENTRY *LPOFNHOOKPROC) (HWND, UINT, WPARAM, LPARAM);

typedef struct tagOFNA {
   DWORD        lStructSize;
   HWND         hwndOwner;
   HINSTANCE    hInstance;
   LPCSTR       lpstrFilter;
   LPSTR        lpstrCustomFilter;
   DWORD        nMaxCustFilter;
   DWORD        nFilterIndex;
   LPSTR        lpstrFile;
   DWORD        nMaxFile;
   LPSTR        lpstrFileTitle;
   DWORD        nMaxFileTitle;
   LPCSTR       lpstrInitialDir;
   LPCSTR       lpstrTitle;
   DWORD        Flags;
   WORD         nFileOffset;
   WORD         nFileExtension;
   LPCSTR       lpstrDefExt;
   LPARAM       lCustData;
   LPOFNHOOKPROC lpfnHook;
   LPCSTR       lpTemplateName;
} OPENFILENAMEA, *LPOPENFILENAMEA;
typedef struct tagOFNW {
   DWORD        lStructSize;
   HWND         hwndOwner;
   HINSTANCE    hInstance;
   LPCWSTR      lpstrFilter;
   LPWSTR       lpstrCustomFilter;
   DWORD        nMaxCustFilter;
   DWORD        nFilterIndex;
   LPWSTR       lpstrFile;
   DWORD        nMaxFile;
   LPWSTR       lpstrFileTitle;
   DWORD        nMaxFileTitle;
   LPCWSTR      lpstrInitialDir;
   LPCWSTR      lpstrTitle;
   DWORD        Flags;
   WORD         nFileOffset;
   WORD         nFileExtension;
   LPCWSTR      lpstrDefExt;
   LPARAM       lCustData;
   LPOFNHOOKPROC lpfnHook;
   LPCWSTR      lpTemplateName;
} OPENFILENAMEW, *LPOPENFILENAMEW;
#ifdef UNICODE
typedef OPENFILENAMEW OPENFILENAME;
typedef LPOPENFILENAMEW LPOPENFILENAME;
#else
typedef OPENFILENAMEA OPENFILENAME;
typedef LPOPENFILENAMEA LPOPENFILENAME;
#endif // UNICODE

BOOL  APIENTRY     GetOpenFileNameA(LPOPENFILENAMEA);
BOOL  APIENTRY     GetOpenFileNameW(LPOPENFILENAMEW);
#ifdef UNICODE
#define GetOpenFileName  GetOpenFileNameW
#else
#define GetOpenFileName  GetOpenFileNameA
#endif // !UNICODE
BOOL  APIENTRY     GetSaveFileNameA(LPOPENFILENAMEA);
BOOL  APIENTRY     GetSaveFileNameW(LPOPENFILENAMEW);
#ifdef UNICODE
#define GetSaveFileName  GetSaveFileNameW
#else
#define GetSaveFileName  GetSaveFileNameA
#endif // !UNICODE
short APIENTRY     GetFileTitleA(LPCSTR, LPSTR, WORD);
short APIENTRY     GetFileTitleW(LPCWSTR, LPWSTR, WORD);
#ifdef UNICODE
#define GetFileTitle  GetFileTitleW
#else
#define GetFileTitle  GetFileTitleA
#endif // !UNICODE

#define OFN_READONLY                 0x00000001
#define OFN_OVERWRITEPROMPT          0x00000002
#define OFN_HIDEREADONLY             0x00000004
#define OFN_NOCHANGEDIR              0x00000008
#define OFN_SHOWHELP                 0x00000010
#define OFN_ENABLEHOOK               0x00000020
#define OFN_ENABLETEMPLATE           0x00000040
#define OFN_ENABLETEMPLATEHANDLE     0x00000080
#define OFN_NOVALIDATE               0x00000100
#define OFN_ALLOWMULTISELECT         0x00000200
#define OFN_EXTENSIONDIFFERENT       0x00000400
#define OFN_PATHMUSTEXIST            0x00000800
#define OFN_FILEMUSTEXIST            0x00001000
#define OFN_CREATEPROMPT             0x00002000
#define OFN_SHAREAWARE               0x00004000
#define OFN_NOREADONLYRETURN         0x00008000
#define OFN_NOTESTFILECREATE         0x00010000
#define OFN_NONETWORKBUTTON          0x00020000
#define OFN_NOLONGNAMES              0x00040000     // force no long names for 4.x modules
#if(WINVER >= 0x0400)
#define OFN_EXPLORER                 0x00080000     // new look commdlg
#define OFN_NODEREFERENCELINKS       0x00100000
#define OFN_LONGNAMES                0x00200000     // force long names for 3.x modules
#endif /* WINVER >= 0x0400 */

// Return values for the registered message sent to the hook function
// when a sharing violation occurs.  OFN_SHAREFALLTHROUGH allows the
// filename to be accepted, OFN_SHARENOWARN rejects the name but puts
// up no warning (returned when the app has already put up a warning
// message), and OFN_SHAREWARN puts up the default warning message
// for sharing violations.
//
// Note:  Undefined return values map to OFN_SHAREWARN, but are
//        reserved for future use.

#define OFN_SHAREFALLTHROUGH     2
#define OFN_SHARENOWARN          1
#define OFN_SHAREWARN            0

typedef UINT (APIENTRY *LPCCHOOKPROC) (HWND, UINT, WPARAM, LPARAM);

#if(WINVER >= 0x0400)
// Structure used for all OpenFileName notifications
typedef struct _OFNOTIFYA
{
        NMHDR           hdr;
        LPOPENFILENAMEA lpOFN;
        LPSTR           pszFile;        // May be NULL
} OFNOTIFYA, FAR *LPOFNOTIFYA;
// Structure used for all OpenFileName notifications
typedef struct _OFNOTIFYW
{
        NMHDR           hdr;
        LPOPENFILENAMEW lpOFN;
        LPWSTR          pszFile;        // May be NULL
} OFNOTIFYW, FAR *LPOFNOTIFYW;
#ifdef UNICODE
typedef OFNOTIFYW OFNOTIFY;
typedef LPOFNOTIFYW LPOFNOTIFY;
#else
typedef OFNOTIFYA OFNOTIFY;
typedef LPOFNOTIFYA LPOFNOTIFY;
#endif // UNICODE

#define CDN_FIRST   (0U-601U)
#define CDN_LAST    (0U-699U)

// Notifications when Open or Save dialog status changes
#define CDN_INITDONE            (CDN_FIRST - 0x0000)
#define CDN_SELCHANGE           (CDN_FIRST - 0x0001)
#define CDN_FOLDERCHANGE        (CDN_FIRST - 0x0002)
#define CDN_SHAREVIOLATION      (CDN_FIRST - 0x0003)
#define CDN_HELP                (CDN_FIRST - 0x0004)
#define CDN_FILEOK              (CDN_FIRST - 0x0005)
#define CDN_TYPECHANGE          (CDN_FIRST - 0x0006)

#define CDM_FIRST       (WM_USER + 100)
#define CDM_LAST        (WM_USER + 200)

// Messages to query information from the Open or Save dialogs

// lParam = pointer to text buffer that gets filled in
// wParam = max number of characters of the text buffer (including NULL)
// return = < 0 if error; number of characters needed (including NULL)
#define CDM_GETSPEC             (CDM_FIRST + 0x0000)
#define CommDlg_OpenSave_GetSpecA(_hdlg, _psz, _cbmax) \
        (int)SNDMSG(_hdlg, CDM_GETSPEC, (WPARAM)_cbmax, (LPARAM)(LPSTR)_psz)
#define CommDlg_OpenSave_GetSpecW(_hdlg, _psz, _cbmax) \
        (int)SNDMSG(_hdlg, CDM_GETSPEC, (WPARAM)_cbmax, (LPARAM)(LPWSTR)_psz)
#ifdef UNICODE
#define CommDlg_OpenSave_GetSpec  CommDlg_OpenSave_GetSpecW
#else
#define CommDlg_OpenSave_GetSpec  CommDlg_OpenSave_GetSpecA
#endif // !UNICODE

// lParam = pointer to text buffer that gets filled in
// wParam = max number of characters of the text buffer (including NULL)
// return = < 0 if error; number of characters needed (including NULL)
#define CDM_GETFILEPATH         (CDM_FIRST + 0x0001)
#define CommDlg_OpenSave_GetFilePathA(_hdlg, _psz, _cbmax) \
        (int)SNDMSG(_hdlg, CDM_GETFILEPATH, (WPARAM)_cbmax, (LPARAM)(LPSTR)_psz)
#define CommDlg_OpenSave_GetFilePathW(_hdlg, _psz, _cbmax) \
        (int)SNDMSG(_hdlg, CDM_GETFILEPATH, (WPARAM)_cbmax, (LPARAM)(LPWSTR)_psz)
#ifdef UNICODE
#define CommDlg_OpenSave_GetFilePath  CommDlg_OpenSave_GetFilePathW
#else
#define CommDlg_OpenSave_GetFilePath  CommDlg_OpenSave_GetFilePathA
#endif // !UNICODE

// lParam = pointer to text buffer that gets filled in
// wParam = max number of characters of the text buffer (including NULL)
// return = < 0 if error; number of characters needed (including NULL)
#define CDM_GETFOLDERPATH       (CDM_FIRST + 0x0002)
#define CommDlg_OpenSave_GetFolderPathA(_hdlg, _psz, _cbmax) \
        (int)SNDMSG(_hdlg, CDM_GETFOLDERPATH, (WPARAM)_cbmax, (LPARAM)(LPSTR)_psz)
#define CommDlg_OpenSave_GetFolderPathW(_hdlg, _psz, _cbmax) \
        (int)SNDMSG(_hdlg, CDM_GETFOLDERPATH, (WPARAM)_cbmax, (LPARAM)(LPWSTR)_psz)
#ifdef UNICODE
#define CommDlg_OpenSave_GetFolderPath  CommDlg_OpenSave_GetFolderPathW
#else
#define CommDlg_OpenSave_GetFolderPath  CommDlg_OpenSave_GetFolderPathA
#endif // !UNICODE

// lParam = pointer to ITEMIDLIST buffer that gets filled in
// wParam = size of the ITEMIDLIST buffer
// return = < 0 if error; length of buffer needed
#define CDM_GETFOLDERIDLIST     (CDM_FIRST + 0x0003)
#define CommDlg_OpenSave_GetFolderIDList(_hdlg, _pidl, _cbmax) \
        (int)SNDMSG(_hdlg, CDM_GETFOLDERIDLIST, (WPARAM)_cbmax, (LPARAM)(LPVOID)_pidl)

// lParam = pointer to a string
// wParam = ID of control to change
// return = not used
#define CDM_SETCONTROLTEXT      (CDM_FIRST + 0x0004)
#define CommDlg_OpenSave_SetControlText(_hdlg, _id, _text) \
        (void)SNDMSG(_hdlg, CDM_SETCONTROLTEXT, (WPARAM)_id, (LPARAM)(LPSTR)_text)

// lParam = not used
// wParam = ID of control to change
// return = not used
#define CDM_HIDECONTROL         (CDM_FIRST + 0x0005)
#define CommDlg_OpenSave_HideControl(_hdlg, _id) \
        (void)SNDMSG(_hdlg, CDM_HIDECONTROL, (WPARAM)_id, 0)

// lParam = pointer to default extension (no dot)
// wParam = not used
// return = not used
#define CDM_SETDEFEXT           (CDM_FIRST + 0x0006)
#define CommDlg_OpenSave_SetDefExt(_hdlg, _pszext) \
        (void)SNDMSG(_hdlg, CDM_SETDEFEXT, 0, (LPARAM)(LPSTR)_pszext)
#endif /* WINVER >= 0x0400 */

typedef struct tagCHOOSECOLORA {
   DWORD        lStructSize;
   HWND         hwndOwner;
   HWND         hInstance;
   COLORREF     rgbResult;
   COLORREF*    lpCustColors;
   DWORD        Flags;
   LPARAM       lCustData;
   LPCCHOOKPROC lpfnHook;
   LPCSTR       lpTemplateName;
} CHOOSECOLORA, *LPCHOOSECOLORA;
typedef struct tagCHOOSECOLORW {
   DWORD        lStructSize;
   HWND         hwndOwner;
   HWND         hInstance;
   COLORREF     rgbResult;
   COLORREF*    lpCustColors;
   DWORD        Flags;
   LPARAM       lCustData;
   LPCCHOOKPROC lpfnHook;
   LPCWSTR      lpTemplateName;
} CHOOSECOLORW, *LPCHOOSECOLORW;
#ifdef UNICODE
typedef CHOOSECOLORW CHOOSECOLOR;
typedef LPCHOOSECOLORW LPCHOOSECOLOR;
#else
typedef CHOOSECOLORA CHOOSECOLOR;
typedef LPCHOOSECOLORA LPCHOOSECOLOR;
#endif // UNICODE

BOOL  APIENTRY ChooseColorA(LPCHOOSECOLORA);
BOOL  APIENTRY ChooseColorW(LPCHOOSECOLORW);
#ifdef UNICODE
#define ChooseColor  ChooseColorW
#else
#define ChooseColor  ChooseColorA
#endif // !UNICODE

#define CC_RGBINIT               0x00000001
#define CC_FULLOPEN              0x00000002
#define CC_PREVENTFULLOPEN       0x00000004
#define CC_SHOWHELP              0x00000008
#define CC_ENABLEHOOK            0x00000010
#define CC_ENABLETEMPLATE        0x00000020
#define CC_ENABLETEMPLATEHANDLE  0x00000040
#if(WINVER >= 0x0400)
#define CC_SOLIDCOLOR            0x00000080
#define CC_ANYCOLOR              0x00000100
#endif /* WINVER >= 0x0400 */

typedef UINT (APIENTRY *LPFRHOOKPROC) (HWND, UINT, WPARAM, LPARAM);

typedef struct tagFINDREPLACEA {
   DWORD        lStructSize;        // size of this struct 0x20
   HWND         hwndOwner;          // handle to owner's window
   HINSTANCE    hInstance;          // instance handle of.EXE that
                                    //   contains cust. dlg. template
   DWORD        Flags;              // one or more of the FR_??
   LPSTR        lpstrFindWhat;      // ptr. to search string
   LPSTR        lpstrReplaceWith;   // ptr. to replace string
   WORD         wFindWhatLen;       // size of find buffer
   WORD         wReplaceWithLen;    // size of replace buffer
   LPARAM       lCustData;          // data passed to hook fn.
   LPFRHOOKPROC lpfnHook;           // ptr. to hook fn. or NULL
   LPCSTR       lpTemplateName;     // custom template name
} FINDREPLACEA, *LPFINDREPLACEA;
typedef struct tagFINDREPLACEW {
   DWORD        lStructSize;        // size of this struct 0x20
   HWND         hwndOwner;          // handle to owner's window
   HINSTANCE    hInstance;          // instance handle of.EXE that
                                    //   contains cust. dlg. template
   DWORD        Flags;              // one or more of the FR_??
   LPWSTR       lpstrFindWhat;      // ptr. to search string
   LPWSTR       lpstrReplaceWith;   // ptr. to replace string
   WORD         wFindWhatLen;       // size of find buffer
   WORD         wReplaceWithLen;    // size of replace buffer
   LPARAM       lCustData;          // data passed to hook fn.
   LPFRHOOKPROC lpfnHook;           // ptr. to hook fn. or NULL
   LPCWSTR      lpTemplateName;     // custom template name
} FINDREPLACEW, *LPFINDREPLACEW;
#ifdef UNICODE
typedef FINDREPLACEW FINDREPLACE;
typedef LPFINDREPLACEW LPFINDREPLACE;
#else
typedef FINDREPLACEA FINDREPLACE;
typedef LPFINDREPLACEA LPFINDREPLACE;
#endif // UNICODE

#define FR_DOWN                         0x00000001
#define FR_WHOLEWORD                    0x00000002
#define FR_MATCHCASE                    0x00000004
#define FR_FINDNEXT                     0x00000008
#define FR_REPLACE                      0x00000010
#define FR_REPLACEALL                   0x00000020
#define FR_DIALOGTERM                   0x00000040
#define FR_SHOWHELP                     0x00000080
#define FR_ENABLEHOOK                   0x00000100
#define FR_ENABLETEMPLATE               0x00000200
#define FR_NOUPDOWN                     0x00000400
#define FR_NOMATCHCASE                  0x00000800
#define FR_NOWHOLEWORD                  0x00001000
#define FR_ENABLETEMPLATEHANDLE         0x00002000
#define FR_HIDEUPDOWN                   0x00004000
#define FR_HIDEMATCHCASE                0x00008000
#define FR_HIDEWHOLEWORD                0x00010000

HWND  APIENTRY    FindTextA(LPFINDREPLACEA);
HWND  APIENTRY    FindTextW(LPFINDREPLACEW);
#ifdef UNICODE
#define FindText  FindTextW
#else
#define FindText  FindTextA
#endif // !UNICODE
HWND  APIENTRY    ReplaceTextA(LPFINDREPLACEA);
HWND  APIENTRY    ReplaceTextW(LPFINDREPLACEW);
#ifdef UNICODE
#define ReplaceText  ReplaceTextW
#else
#define ReplaceText  ReplaceTextA
#endif // !UNICODE

typedef UINT (APIENTRY *LPCFHOOKPROC) (HWND, UINT, WPARAM, LPARAM);

typedef struct tagCHOOSEFONTA {
   DWORD           lStructSize;
   HWND            hwndOwner;          // caller's window handle
   HDC             hDC;                // printer DC/IC or NULL
   LPLOGFONTA      lpLogFont;          // ptr. to a LOGFONT struct
   INT             iPointSize;         // 10 * size in points of selected font
   DWORD           Flags;              // enum. type flags
   COLORREF        rgbColors;          // returned text color
   LPARAM          lCustData;          // data passed to hook fn.
   LPCFHOOKPROC    lpfnHook;           // ptr. to hook function
   LPCSTR          lpTemplateName;     // custom template name
   HINSTANCE       hInstance;          // instance handle of.EXE that
                                       //   contains cust. dlg. template
   LPSTR           lpszStyle;          // return the style field here
                                       // must be LF_FACESIZE or bigger
   WORD            nFontType;          // same value reported to the EnumFonts
                                       //   call back with the extra FONTTYPE_
                                       //   bits added
   WORD            ___MISSING_ALIGNMENT__;
   INT             nSizeMin;           // minimum pt size allowed &
   INT             nSizeMax;           // max pt size allowed if
                                       //   CF_LIMITSIZE is used
} CHOOSEFONTA, *LPCHOOSEFONTA;
typedef struct tagCHOOSEFONTW {
   DWORD           lStructSize;
   HWND            hwndOwner;          // caller's window handle
   HDC             hDC;                // printer DC/IC or NULL
   LPLOGFONTW      lpLogFont;          // ptr. to a LOGFONT struct
   INT             iPointSize;         // 10 * size in points of selected font
   DWORD           Flags;              // enum. type flags
   COLORREF        rgbColors;          // returned text color
   LPARAM          lCustData;          // data passed to hook fn.
   LPCFHOOKPROC    lpfnHook;           // ptr. to hook function
   LPCWSTR         lpTemplateName;     // custom template name
   HINSTANCE       hInstance;          // instance handle of.EXE that
                                       //   contains cust. dlg. template
   LPWSTR          lpszStyle;          // return the style field here
                                       // must be LF_FACESIZE or bigger
   WORD            nFontType;          // same value reported to the EnumFonts
                                       //   call back with the extra FONTTYPE_
                                       //   bits added
   WORD            ___MISSING_ALIGNMENT__;
   INT             nSizeMin;           // minimum pt size allowed &
   INT             nSizeMax;           // max pt size allowed if
                                       //   CF_LIMITSIZE is used
} CHOOSEFONTW, *LPCHOOSEFONTW;
#ifdef UNICODE
typedef CHOOSEFONTW CHOOSEFONT;
typedef LPCHOOSEFONTW LPCHOOSEFONT;
#else
typedef CHOOSEFONTA CHOOSEFONT;
typedef LPCHOOSEFONTA LPCHOOSEFONT;
#endif // UNICODE

BOOL APIENTRY ChooseFontA(LPCHOOSEFONTA);
BOOL APIENTRY ChooseFontW(LPCHOOSEFONTW);
#ifdef UNICODE
#define ChooseFont  ChooseFontW
#else
#define ChooseFont  ChooseFontA
#endif // !UNICODE

#define CF_SCREENFONTS             0x00000001
#define CF_PRINTERFONTS            0x00000002
#define CF_BOTH                    (CF_SCREENFONTS | CF_PRINTERFONTS)
#define CF_SHOWHELP                0x00000004L
#define CF_ENABLEHOOK              0x00000008L
#define CF_ENABLETEMPLATE          0x00000010L
#define CF_ENABLETEMPLATEHANDLE    0x00000020L
#define CF_INITTOLOGFONTSTRUCT     0x00000040L
#define CF_USESTYLE                0x00000080L
#define CF_EFFECTS                 0x00000100L
#define CF_APPLY                   0x00000200L
#define CF_ANSIONLY                0x00000400L
#if(WINVER >= 0x0400)
#define CF_SCRIPTSONLY             CF_ANSIONLY
#endif /* WINVER >= 0x0400 */
#define CF_NOVECTORFONTS           0x00000800L
#define CF_NOOEMFONTS              CF_NOVECTORFONTS
#define CF_NOSIMULATIONS           0x00001000L
#define CF_LIMITSIZE               0x00002000L
#define CF_FIXEDPITCHONLY          0x00004000L
#define CF_WYSIWYG                 0x00008000L // must also have CF_SCREENFONTS & CF_PRINTERFONTS
#define CF_FORCEFONTEXIST          0x00010000L
#define CF_SCALABLEONLY            0x00020000L
#define CF_TTONLY                  0x00040000L
#define CF_NOFACESEL               0x00080000L
#define CF_NOSTYLESEL              0x00100000L
#define CF_NOSIZESEL               0x00200000L
#if(WINVER >= 0x0400)
#define CF_SELECTSCRIPT            0x00400000L
#define CF_NOSCRIPTSEL             0x00800000L
#define CF_NOVERTFONTS             0x01000000L
#endif /* WINVER >= 0x0400 */

// these are extra nFontType bits that are added to what is returned to the
// EnumFonts callback routine

#define SIMULATED_FONTTYPE    0x8000
#define PRINTER_FONTTYPE      0x4000
#define SCREEN_FONTTYPE       0x2000
#define BOLD_FONTTYPE         0x0100
#define ITALIC_FONTTYPE       0x0200
#define REGULAR_FONTTYPE      0x0400

#define WM_CHOOSEFONT_GETLOGFONT      (WM_USER + 1)
#define WM_CHOOSEFONT_SETLOGFONT      (WM_USER + 101)
#define WM_CHOOSEFONT_SETFLAGS        (WM_USER + 102)

// strings used to obtain unique window message for communication
// between dialog and caller

#define LBSELCHSTRINGA  "commdlg_LBSelChangedNotify"
#define SHAREVISTRINGA  "commdlg_ShareViolation"
#define FILEOKSTRINGA   "commdlg_FileNameOK"
#define COLOROKSTRINGA  "commdlg_ColorOK"
#define SETRGBSTRINGA   "commdlg_SetRGBColor"
#define HELPMSGSTRINGA  "commdlg_help"
#define FINDMSGSTRINGA  "commdlg_FindReplace"

#define LBSELCHSTRINGW  L"commdlg_LBSelChangedNotify"
#define SHAREVISTRINGW  L"commdlg_ShareViolation"
#define FILEOKSTRINGW   L"commdlg_FileNameOK"
#define COLOROKSTRINGW  L"commdlg_ColorOK"
#define SETRGBSTRINGW   L"commdlg_SetRGBColor"
#define HELPMSGSTRINGW  L"commdlg_help"
#define FINDMSGSTRINGW  L"commdlg_FindReplace"

#ifdef UNICODE
#define LBSELCHSTRING  LBSELCHSTRINGW
#define SHAREVISTRING  SHAREVISTRINGW
#define FILEOKSTRING   FILEOKSTRINGW
#define COLOROKSTRING  COLOROKSTRINGW
#define SETRGBSTRING   SETRGBSTRINGW
#define HELPMSGSTRING  HELPMSGSTRINGW
#define FINDMSGSTRING  FINDMSGSTRINGW
#else
#define LBSELCHSTRING  LBSELCHSTRINGA
#define SHAREVISTRING  SHAREVISTRINGA
#define FILEOKSTRING   FILEOKSTRINGA
#define COLOROKSTRING  COLOROKSTRINGA
#define SETRGBSTRING   SETRGBSTRINGA
#define HELPMSGSTRING  HELPMSGSTRINGA
#define FINDMSGSTRING  FINDMSGSTRINGA
#endif

// HIWORD values for lParam of commdlg_LBSelChangeNotify message
#define CD_LBSELNOITEMS -1
#define CD_LBSELCHANGE   0
#define CD_LBSELSUB      1
#define CD_LBSELADD      2

typedef UINT (APIENTRY *LPPRINTHOOKPROC) (HWND, UINT, WPARAM, LPARAM);
typedef UINT (APIENTRY *LPSETUPHOOKPROC) (HWND, UINT, WPARAM, LPARAM);

typedef struct tagPDA {
   DWORD            lStructSize;
   HWND             hwndOwner;
   HGLOBAL          hDevMode;
   HGLOBAL          hDevNames;
   HDC              hDC;
   DWORD            Flags;
   WORD             nFromPage;
   WORD             nToPage;
   WORD             nMinPage;
   WORD             nMaxPage;
   WORD             nCopies;
   HINSTANCE        hInstance;
   LPARAM           lCustData;
   LPPRINTHOOKPROC  lpfnPrintHook;
   LPSETUPHOOKPROC  lpfnSetupHook;
   LPCSTR           lpPrintTemplateName;
   LPCSTR           lpSetupTemplateName;
   HGLOBAL          hPrintTemplate;
   HGLOBAL          hSetupTemplate;
} PRINTDLGA, *LPPRINTDLGA;
typedef struct tagPDW {
   DWORD            lStructSize;
   HWND             hwndOwner;
   HGLOBAL          hDevMode;
   HGLOBAL          hDevNames;
   HDC              hDC;
   DWORD            Flags;
   WORD             nFromPage;
   WORD             nToPage;
   WORD             nMinPage;
   WORD             nMaxPage;
   WORD             nCopies;
   HINSTANCE        hInstance;
   LPARAM           lCustData;
   LPPRINTHOOKPROC  lpfnPrintHook;
   LPSETUPHOOKPROC  lpfnSetupHook;
   LPCWSTR          lpPrintTemplateName;
   LPCWSTR          lpSetupTemplateName;
   HGLOBAL          hPrintTemplate;
   HGLOBAL          hSetupTemplate;
} PRINTDLGW, *LPPRINTDLGW;
#ifdef UNICODE
typedef PRINTDLGW PRINTDLG;
typedef LPPRINTDLGW LPPRINTDLG;
#else
typedef PRINTDLGA PRINTDLG;
typedef LPPRINTDLGA LPPRINTDLG;
#endif // UNICODE

BOOL  APIENTRY     PrintDlgA(LPPRINTDLGA);
BOOL  APIENTRY     PrintDlgW(LPPRINTDLGW);
#ifdef UNICODE
#define PrintDlg  PrintDlgW
#else
#define PrintDlg  PrintDlgA
#endif // !UNICODE

#define PD_ALLPAGES                  0x00000000
#define PD_SELECTION                 0x00000001
#define PD_PAGENUMS                  0x00000002
#define PD_NOSELECTION               0x00000004
#define PD_NOPAGENUMS                0x00000008
#define PD_COLLATE                   0x00000010
#define PD_PRINTTOFILE               0x00000020
#define PD_PRINTSETUP                0x00000040
#define PD_NOWARNING                 0x00000080
#define PD_RETURNDC                  0x00000100
#define PD_RETURNIC                  0x00000200
#define PD_RETURNDEFAULT             0x00000400
#define PD_SHOWHELP                  0x00000800
#define PD_ENABLEPRINTHOOK           0x00001000
#define PD_ENABLESETUPHOOK           0x00002000
#define PD_ENABLEPRINTTEMPLATE       0x00004000
#define PD_ENABLESETUPTEMPLATE       0x00008000
#define PD_ENABLEPRINTTEMPLATEHANDLE 0x00010000
#define PD_ENABLESETUPTEMPLATEHANDLE 0x00020000
#define PD_USEDEVMODECOPIES          0x00040000
#define PD_USEDEVMODECOPIESANDCOLLATE 0x00040000
#define PD_DISABLEPRINTTOFILE        0x00080000
#define PD_HIDEPRINTTOFILE           0x00100000
#define PD_NONETWORKBUTTON           0x00200000

typedef struct tagDEVNAMES {
   WORD wDriverOffset;
   WORD wDeviceOffset;
   WORD wOutputOffset;
   WORD wDefault;
} DEVNAMES;

typedef DEVNAMES * LPDEVNAMES;

#define DN_DEFAULTPRN      0x0001

DWORD APIENTRY     CommDlgExtendedError(VOID);

#if(WINVER >= 0x0400)
#define WM_PSD_PAGESETUPDLG     (WM_USER  )
#define WM_PSD_FULLPAGERECT     (WM_USER+1)
#define WM_PSD_MINMARGINRECT    (WM_USER+2)
#define WM_PSD_MARGINRECT       (WM_USER+3)
#define WM_PSD_GREEKTEXTRECT    (WM_USER+4)
#define WM_PSD_ENVSTAMPRECT     (WM_USER+5)
#define WM_PSD_YAFULLPAGERECT   (WM_USER+6)

typedef UINT (APIENTRY* LPPAGEPAINTHOOK)( HWND, UINT, WPARAM, LPARAM );
typedef UINT (APIENTRY* LPPAGESETUPHOOK)( HWND, UINT, WPARAM, LPARAM );

typedef struct tagPSDA
{
    DWORD           lStructSize;
    HWND            hwndOwner;
    HGLOBAL         hDevMode;
    HGLOBAL         hDevNames;
    DWORD           Flags;
    POINT           ptPaperSize;
    RECT            rtMinMargin;
    RECT            rtMargin;
    HINSTANCE       hInstance;
    LPARAM          lCustData;
    LPPAGESETUPHOOK lpfnPageSetupHook;
    LPPAGEPAINTHOOK lpfnPagePaintHook;
    LPCSTR          lpPageSetupTemplateName;
    HGLOBAL         hPageSetupTemplate;
} PAGESETUPDLGA, * LPPAGESETUPDLGA;
typedef struct tagPSDW
{
    DWORD           lStructSize;
    HWND            hwndOwner;
    HGLOBAL         hDevMode;
    HGLOBAL         hDevNames;
    DWORD           Flags;
    POINT           ptPaperSize;
    RECT            rtMinMargin;
    RECT            rtMargin;
    HINSTANCE       hInstance;
    LPARAM          lCustData;
    LPPAGESETUPHOOK lpfnPageSetupHook;
    LPPAGEPAINTHOOK lpfnPagePaintHook;
    LPCWSTR         lpPageSetupTemplateName;
    HGLOBAL         hPageSetupTemplate;
} PAGESETUPDLGW, * LPPAGESETUPDLGW;
#ifdef UNICODE
typedef PAGESETUPDLGW PAGESETUPDLG;
typedef LPPAGESETUPDLGW LPPAGESETUPDLG;
#else
typedef PAGESETUPDLGA PAGESETUPDLG;
typedef LPPAGESETUPDLGA LPPAGESETUPDLG;
#endif // UNICODE

BOOL APIENTRY PageSetupDlgA( LPPAGESETUPDLGA );
BOOL APIENTRY PageSetupDlgW( LPPAGESETUPDLGW );
#ifdef UNICODE
#define PageSetupDlg  PageSetupDlgW
#else
#define PageSetupDlg  PageSetupDlgA
#endif // !UNICODE

#define PSD_DEFAULTMINMARGINS             0x00000000 // default (printer's)
#define PSD_INWININIINTLMEASURE           0x00000000 // 1st of 4 possible

#define PSD_MINMARGINS                    0x00000001 // use caller's
#define PSD_MARGINS                       0x00000002 // use caller's
#define PSD_INTHOUSANDTHSOFINCHES         0x00000004 // 2nd of 4 possible
#define PSD_INHUNDREDTHSOFMILLIMETERS     0x00000008 // 3rd of 4 possible
#define PSD_DISABLEMARGINS                0x00000010
#define PSD_DISABLEPRINTER                0x00000020
#define PSD_NOWARNING                     0x00000080 // must be same as PD_*
#define PSD_DISABLEORIENTATION            0x00000100
#define PSD_RETURNDEFAULT                 0x00000400 // must be same as PD_*
#define PSD_DISABLEPAPER                  0x00000200
#define PSD_SHOWHELP                      0x00000800 // must be same as PD_*
#define PSD_ENABLEPAGESETUPHOOK           0x00002000 // must be same as PD_*
#define PSD_ENABLEPAGESETUPTEMPLATE       0x00008000 // must be same as PD_*
#define PSD_ENABLEPAGESETUPTEMPLATEHANDLE 0x00020000 // must be same as PD_*
#define PSD_ENABLEPAGEPAINTHOOK           0x00040000
#define PSD_DISABLEPAGEPAINTING           0x00080000
#endif /* WINVER >= 0x0400 */

#ifdef __cplusplus
}
#endif  /* __cplusplus */

#include <poppack.h>
#endif  /* !_INC_COMMDLG */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\inc32\ENVIRON.H ===
#ifndef _ENVIRON_H_
#define _ENVIRON_H_
/*************************** OS Specific Module ****************************\
*                                                                           *
* Module: ENVIRON.H                                                         *
*       WATCOM and Windows specific defines and pragmas.                    *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       David Schmenk (dschmenk)     1/06/95 - copied from nvrm.h.          *
*                                                                           *
\***************************************************************************/

#endif // _ENVIRON_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\inc32\DDEML.H ===
/*++ BUILD Version: 0001 // Increment this if a change has global effects --*/

/*****************************************************************************\
*                                                                             *
*  ddeml.h -    DDEML API header file                                         *
*                                                                             *
*               Version 3.10                                                  *
*                                                                             *
*               Copyright (c) 1993-95, Microsoft Corp.  All rights reserved.  *
*                                                                             *
\*****************************************************************************/
#ifndef _INC_DDEMLH
#define _INC_DDEMLH

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

/******** public types ********/

DECLARE_HANDLE(HCONVLIST);
DECLARE_HANDLE(HCONV);
DECLARE_HANDLE(HSZ);
DECLARE_HANDLE(HDDEDATA);
#define EXPENTRY        CALLBACK

/* the following structure is for use with XTYP_WILDCONNECT processing. */

typedef struct tagHSZPAIR {
    HSZ hszSvc;
    HSZ hszTopic;
} HSZPAIR;
typedef HSZPAIR FAR *PHSZPAIR;

/* The following structure is used by DdeConnect() and DdeConnectList() and
   by XTYP_CONNECT and XTYP_WILDCONNECT callbacks. */

typedef struct tagCONVCONTEXT {
    UINT        cb;             /* set to sizeof(CONVCONTEXT) */
    UINT        wFlags;         /* none currently defined. */
    UINT        wCountryID;     /* country code for topic/item strings used. */
    int         iCodePage;      /* codepage used for topic/item strings. */
    DWORD       dwLangID;       /* language ID for topic/item strings. */
    DWORD       dwSecurity;     /* Private security code. */
    SECURITY_QUALITY_OF_SERVICE qos;  /* client side's quality of service */
} CONVCONTEXT;
typedef CONVCONTEXT FAR *PCONVCONTEXT;


/* The following structure is used by DdeQueryConvInfo(): */

typedef struct tagCONVINFO {
    DWORD   cb;            /* sizeof(CONVINFO)  */
    DWORD   hUser;         /* user specified field  */
    HCONV   hConvPartner;  /* hConv on other end or 0 if non-ddemgr partner  */
    HSZ     hszSvcPartner; /* app name of partner if obtainable  */
    HSZ     hszServiceReq; /* AppName requested for connection  */
    HSZ     hszTopic;      /* Topic name for conversation  */
    HSZ     hszItem;       /* transaction item name or NULL if quiescent  */
    UINT    wFmt;          /* transaction format or NULL if quiescent  */
    UINT    wType;         /* XTYP_ for current transaction  */
    UINT    wStatus;       /* ST_ constant for current conversation  */
    UINT    wConvst;       /* XST_ constant for current transaction  */
    UINT    wLastError;    /* last transaction error.  */
    HCONVLIST hConvList;   /* parent hConvList if this conversation is in a list */
    CONVCONTEXT ConvCtxt;  /* conversation context */
    HWND    hwnd;          /* window handle for this conversation */
    HWND    hwndPartner;   /* partner window handle for this conversation */
} CONVINFO;
typedef CONVINFO FAR *PCONVINFO;

/***** conversation states (usState) *****/

#define     XST_NULL              0  /* quiescent states */
#define     XST_INCOMPLETE        1
#define     XST_CONNECTED         2
#define     XST_INIT1             3  /* mid-initiation states */
#define     XST_INIT2             4
#define     XST_REQSENT           5  /* active conversation states */
#define     XST_DATARCVD          6
#define     XST_POKESENT          7
#define     XST_POKEACKRCVD       8
#define     XST_EXECSENT          9
#define     XST_EXECACKRCVD      10
#define     XST_ADVSENT          11
#define     XST_UNADVSENT        12
#define     XST_ADVACKRCVD       13
#define     XST_UNADVACKRCVD     14
#define     XST_ADVDATASENT      15
#define     XST_ADVDATAACKRCVD   16

/* used in LOWORD(dwData1) of XTYP_ADVREQ callbacks... */
#define     CADV_LATEACK         0xFFFF

/***** conversation status bits (fsStatus) *****/

#define     ST_CONNECTED            0x0001
#define     ST_ADVISE               0x0002
#define     ST_ISLOCAL              0x0004
#define     ST_BLOCKED              0x0008
#define     ST_CLIENT               0x0010
#define     ST_TERMINATED           0x0020
#define     ST_INLIST               0x0040
#define     ST_BLOCKNEXT            0x0080
#define     ST_ISSELF               0x0100


/* DDE constants for wStatus field */

#define DDE_FACK                0x8000
#define DDE_FBUSY               0x4000
#define DDE_FDEFERUPD           0x4000
#define DDE_FACKREQ             0x8000
#define DDE_FRELEASE            0x2000
#define DDE_FREQUESTED          0x1000
#define DDE_FAPPSTATUS          0x00ff
#define DDE_FNOTPROCESSED       0x0000

#define DDE_FACKRESERVED        (~(DDE_FACK | DDE_FBUSY | DDE_FAPPSTATUS))
#define DDE_FADVRESERVED        (~(DDE_FACKREQ | DDE_FDEFERUPD))
#define DDE_FDATRESERVED        (~(DDE_FACKREQ | DDE_FRELEASE | DDE_FREQUESTED))
#define DDE_FPOKRESERVED        (~(DDE_FRELEASE))

/***** message filter hook types *****/

#define     MSGF_DDEMGR             0x8001

/***** codepage constants ****/

#define CP_WINANSI      1004    /* default codepage for windows & old DDE convs. */
#define CP_WINUNICODE   1200

/***** transaction types *****/

#define     XTYPF_NOBLOCK            0x0002  /* CBR_BLOCK will not work */
#define     XTYPF_NODATA             0x0004  /* DDE_FDEFERUPD */
#define     XTYPF_ACKREQ             0x0008  /* DDE_FACKREQ */

#define     XCLASS_MASK              0xFC00
#define     XCLASS_BOOL              0x1000
#define     XCLASS_DATA              0x2000
#define     XCLASS_FLAGS             0x4000
#define     XCLASS_NOTIFICATION      0x8000

#define     XTYP_ERROR              (0x0000 | XCLASS_NOTIFICATION | XTYPF_NOBLOCK )
#define     XTYP_ADVDATA            (0x0010 | XCLASS_FLAGS         )
#define     XTYP_ADVREQ             (0x0020 | XCLASS_DATA | XTYPF_NOBLOCK )
#define     XTYP_ADVSTART           (0x0030 | XCLASS_BOOL          )
#define     XTYP_ADVSTOP            (0x0040 | XCLASS_NOTIFICATION)
#define     XTYP_EXECUTE            (0x0050 | XCLASS_FLAGS         )
#define     XTYP_CONNECT            (0x0060 | XCLASS_BOOL | XTYPF_NOBLOCK)
#define     XTYP_CONNECT_CONFIRM    (0x0070 | XCLASS_NOTIFICATION | XTYPF_NOBLOCK)
#define     XTYP_XACT_COMPLETE      (0x0080 | XCLASS_NOTIFICATION  )
#define     XTYP_POKE               (0x0090 | XCLASS_FLAGS         )
#define     XTYP_REGISTER           (0x00A0 | XCLASS_NOTIFICATION | XTYPF_NOBLOCK)
#define     XTYP_REQUEST            (0x00B0 | XCLASS_DATA          )
#define     XTYP_DISCONNECT         (0x00C0 | XCLASS_NOTIFICATION | XTYPF_NOBLOCK)
#define     XTYP_UNREGISTER         (0x00D0 | XCLASS_NOTIFICATION | XTYPF_NOBLOCK)
#define     XTYP_WILDCONNECT        (0x00E0 | XCLASS_DATA | XTYPF_NOBLOCK)

#define     XTYP_MASK                0x00F0
#define     XTYP_SHIFT               4  /* shift to turn XTYP_ into an index */

/***** Timeout constants *****/

#define     TIMEOUT_ASYNC           0xFFFFFFFF

/***** Transaction ID constants *****/

#define     QID_SYNC                0xFFFFFFFF

/****** public strings used in DDE ******/

#ifdef UNICODE
#define SZDDESYS_TOPIC         L"System"
#define SZDDESYS_ITEM_TOPICS   L"Topics"
#define SZDDESYS_ITEM_SYSITEMS L"SysItems"
#define SZDDESYS_ITEM_RTNMSG   L"ReturnMessage"
#define SZDDESYS_ITEM_STATUS   L"Status"
#define SZDDESYS_ITEM_FORMATS  L"Formats"
#define SZDDESYS_ITEM_HELP     L"Help"
#define SZDDE_ITEM_ITEMLIST    L"TopicItemList"
#else
#define SZDDESYS_TOPIC         "System"
#define SZDDESYS_ITEM_TOPICS   "Topics"
#define SZDDESYS_ITEM_SYSITEMS "SysItems"
#define SZDDESYS_ITEM_RTNMSG   "ReturnMessage"
#define SZDDESYS_ITEM_STATUS   "Status"
#define SZDDESYS_ITEM_FORMATS  "Formats"
#define SZDDESYS_ITEM_HELP     "Help"
#define SZDDE_ITEM_ITEMLIST    "TopicItemList"
#endif


/****** API entry points ******/

typedef HDDEDATA CALLBACK FNCALLBACK(UINT wType, UINT wFmt, HCONV hConv,
        HSZ hsz1, HSZ hsz2, HDDEDATA hData, DWORD dwData1, DWORD dwData2);
typedef HDDEDATA (CALLBACK *PFNCALLBACK)(UINT wType, UINT wFmt, HCONV hConv,
        HSZ hsz1, HSZ hsz2, HDDEDATA hData, DWORD dwData1, DWORD dwData2);

#define     CBR_BLOCK           ((HDDEDATA)0xffffffffL)

/* DLL registration functions */

UINT WINAPI DdeInitializeA(LPDWORD pidInst, PFNCALLBACK pfnCallback,
        DWORD afCmd, DWORD ulRes);
UINT WINAPI DdeInitializeW(LPDWORD pidInst, PFNCALLBACK pfnCallback,
        DWORD afCmd, DWORD ulRes);
#ifdef UNICODE
#define DdeInitialize  DdeInitializeW
#else
#define DdeInitialize  DdeInitializeA
#endif // !UNICODE

/*
 * Callback filter flags for use with standard apps.
 */

#define     CBF_FAIL_SELFCONNECTIONS     0x00001000
#define     CBF_FAIL_CONNECTIONS         0x00002000
#define     CBF_FAIL_ADVISES             0x00004000
#define     CBF_FAIL_EXECUTES            0x00008000
#define     CBF_FAIL_POKES               0x00010000
#define     CBF_FAIL_REQUESTS            0x00020000
#define     CBF_FAIL_ALLSVRXACTIONS      0x0003f000

#define     CBF_SKIP_CONNECT_CONFIRMS    0x00040000
#define     CBF_SKIP_REGISTRATIONS       0x00080000
#define     CBF_SKIP_UNREGISTRATIONS     0x00100000
#define     CBF_SKIP_DISCONNECTS         0x00200000
#define     CBF_SKIP_ALLNOTIFICATIONS    0x003c0000

/*
 * Application command flags
 */
#define     APPCMD_CLIENTONLY            0x00000010L
#define     APPCMD_FILTERINITS           0x00000020L
#define     APPCMD_MASK                  0x00000FF0L

/*
 * Application classification flags
 */
#define     APPCLASS_STANDARD            0x00000000L
#define     APPCLASS_MASK                0x0000000FL



BOOL WINAPI DdeUninitialize(DWORD idInst);

/*
 * conversation enumeration functions
 */

HCONVLIST WINAPI DdeConnectList(DWORD idInst, HSZ hszService, HSZ hszTopic,
        HCONVLIST hConvList, PCONVCONTEXT pCC);
HCONV WINAPI DdeQueryNextServer(HCONVLIST hConvList, HCONV hConvPrev);
BOOL WINAPI DdeDisconnectList(HCONVLIST hConvList);

/*
 * conversation control functions
 */

HCONV WINAPI DdeConnect(DWORD idInst, HSZ hszService, HSZ hszTopic,
        PCONVCONTEXT pCC);
BOOL WINAPI DdeDisconnect(HCONV hConv);
HCONV WINAPI DdeReconnect(HCONV hConv);
UINT WINAPI DdeQueryConvInfo(HCONV hConv, DWORD idTransaction, PCONVINFO pConvInfo);
BOOL WINAPI DdeSetUserHandle(HCONV hConv, DWORD id, DWORD hUser);
BOOL WINAPI DdeAbandonTransaction(DWORD idInst, HCONV hConv, DWORD idTransaction);


/*
 * app server interface functions
 */

BOOL WINAPI DdePostAdvise(DWORD idInst, HSZ hszTopic, HSZ hszItem);
BOOL WINAPI DdeEnableCallback(DWORD idInst, HCONV hConv, UINT wCmd);
BOOL WINAPI DdeImpersonateClient(HCONV hConv);

#define EC_ENABLEALL            0
#define EC_ENABLEONE            ST_BLOCKNEXT
#define EC_DISABLE              ST_BLOCKED
#define EC_QUERYWAITING         2


HDDEDATA WINAPI DdeNameService(DWORD idInst, HSZ hsz1, HSZ hsz2, UINT afCmd);

#define DNS_REGISTER        0x0001
#define DNS_UNREGISTER      0x0002
#define DNS_FILTERON        0x0004
#define DNS_FILTEROFF       0x0008

/*
 * app client interface functions
 */

HDDEDATA WINAPI DdeClientTransaction(LPBYTE pData, DWORD cbData,
        HCONV hConv, HSZ hszItem, UINT wFmt, UINT wType,
        DWORD dwTimeout, LPDWORD pdwResult);

/*
 *data transfer functions
 */

HDDEDATA WINAPI DdeCreateDataHandle(DWORD idInst, LPBYTE pSrc, DWORD cb,
        DWORD cbOff, HSZ hszItem, UINT wFmt, UINT afCmd);
HDDEDATA WINAPI DdeAddData(HDDEDATA hData, LPBYTE pSrc, DWORD cb, DWORD cbOff);
DWORD WINAPI DdeGetData(HDDEDATA hData, LPBYTE pDst, DWORD cbMax, DWORD cbOff);
LPBYTE WINAPI DdeAccessData(HDDEDATA hData, LPDWORD pcbDataSize);
BOOL WINAPI DdeUnaccessData(HDDEDATA hData);
BOOL WINAPI DdeFreeDataHandle(HDDEDATA hData);

#define     HDATA_APPOWNED          0x0001


UINT WINAPI DdeGetLastError(DWORD idInst);

#define     DMLERR_NO_ERROR                    0       /* must be 0 */

#define     DMLERR_FIRST                       0x4000

#define     DMLERR_ADVACKTIMEOUT               0x4000
#define     DMLERR_BUSY                        0x4001
#define     DMLERR_DATAACKTIMEOUT              0x4002
#define     DMLERR_DLL_NOT_INITIALIZED         0x4003
#define     DMLERR_DLL_USAGE                   0x4004
#define     DMLERR_EXECACKTIMEOUT              0x4005
#define     DMLERR_INVALIDPARAMETER            0x4006
#define     DMLERR_LOW_MEMORY                  0x4007
#define     DMLERR_MEMORY_ERROR                0x4008
#define     DMLERR_NOTPROCESSED                0x4009
#define     DMLERR_NO_CONV_ESTABLISHED         0x400a
#define     DMLERR_POKEACKTIMEOUT              0x400b
#define     DMLERR_POSTMSG_FAILED              0x400c
#define     DMLERR_REENTRANCY                  0x400d
#define     DMLERR_SERVER_DIED                 0x400e
#define     DMLERR_SYS_ERROR                   0x400f
#define     DMLERR_UNADVACKTIMEOUT             0x4010
#define     DMLERR_UNFOUND_QUEUE_ID            0x4011

#define     DMLERR_LAST                        0x4011

HSZ  WINAPI DdeCreateStringHandleA(DWORD idInst, LPCSTR psz, int iCodePage);
HSZ  WINAPI DdeCreateStringHandleW(DWORD idInst, LPCWSTR psz, int iCodePage);
#ifdef UNICODE
#define DdeCreateStringHandle  DdeCreateStringHandleW
#else
#define DdeCreateStringHandle  DdeCreateStringHandleA
#endif // !UNICODE
DWORD WINAPI DdeQueryStringA(DWORD idInst, HSZ hsz, LPSTR psz, DWORD cchMax, int iCodePage);
DWORD WINAPI DdeQueryStringW(DWORD idInst, HSZ hsz, LPWSTR psz, DWORD cchMax, int iCodePage);
#ifdef UNICODE
#define DdeQueryString  DdeQueryStringW
#else
#define DdeQueryString  DdeQueryStringA
#endif // !UNICODE
BOOL WINAPI DdeFreeStringHandle(DWORD idInst, HSZ hsz);
BOOL WINAPI DdeKeepStringHandle(DWORD idInst, HSZ hsz);
int WINAPI DdeCmpStringHandles(HSZ hsz1, HSZ hsz2);


#ifndef NODDEMLSPY
/*
 * DDEML public debugging header file info
 */

typedef struct tagDDEML_MSG_HOOK_DATA {    // new for NT
    UINT uiLo;      // unpacked lo and hi parts of lParam
    UINT uiHi;
    DWORD cbData;   // amount of data in message, if any. May be > than 32 bytes.
    DWORD Data[8];  // data peeking by DDESPY is limited to 32 bytes.
} DDEML_MSG_HOOK_DATA, *PDDEML_MSG_HOOK_DATA;


typedef struct tagMONMSGSTRUCT {
    UINT    cb;
    HWND    hwndTo;
    DWORD   dwTime;
    HANDLE  hTask;
    UINT    wMsg;
    WPARAM  wParam;
    LPARAM  lParam;
    DDEML_MSG_HOOK_DATA dmhd;       // new for NT
} MONMSGSTRUCT, *PMONMSGSTRUCT;

typedef struct tagMONCBSTRUCT {
    UINT   cb;
    DWORD  dwTime;
    HANDLE hTask;
    DWORD  dwRet;
    UINT   wType;
    UINT   wFmt;
    HCONV  hConv;
    HSZ    hsz1;
    HSZ    hsz2;
    HDDEDATA hData;
    DWORD  dwData1;
    DWORD  dwData2;
    CONVCONTEXT cc;                 // new for NT for XTYP_CONNECT callbacks
    DWORD  cbData;                  // new for NT for data peeking
    DWORD  Data[8];                 // new for NT for data peeking
} MONCBSTRUCT, *PMONCBSTRUCT;

typedef struct tagMONHSZSTRUCTA {
    UINT   cb;
    BOOL   fsAction;    /* MH_ value */
    DWORD  dwTime;
    HSZ    hsz;
    HANDLE hTask;
    CHAR    str[1];
} MONHSZSTRUCTA, *PMONHSZSTRUCTA;
typedef struct tagMONHSZSTRUCTW {
    UINT   cb;
    BOOL   fsAction;    /* MH_ value */
    DWORD  dwTime;
    HSZ    hsz;
    HANDLE hTask;
    WCHAR   str[1];
} MONHSZSTRUCTW, *PMONHSZSTRUCTW;
#ifdef UNICODE
typedef MONHSZSTRUCTW MONHSZSTRUCT;
typedef PMONHSZSTRUCTW PMONHSZSTRUCT;
#else
typedef MONHSZSTRUCTA MONHSZSTRUCT;
typedef PMONHSZSTRUCTA PMONHSZSTRUCT;
#endif // UNICODE

#define MH_CREATE   1
#define MH_KEEP     2
#define MH_DELETE   3
#define MH_CLEANUP  4

typedef struct tagMONERRSTRUCT {
    UINT    cb;
    UINT    wLastError;
    DWORD   dwTime;
    HANDLE  hTask;
} MONERRSTRUCT, *PMONERRSTRUCT;

typedef struct tagMONLINKSTRUCT {
    UINT    cb;
    DWORD   dwTime;
    HANDLE  hTask;
    BOOL    fEstablished;
    BOOL    fNoData;
    HSZ     hszSvc;
    HSZ     hszTopic;
    HSZ     hszItem;
    UINT    wFmt;
    BOOL    fServer;
    HCONV   hConvServer;
    HCONV   hConvClient;
} MONLINKSTRUCT, *PMONLINKSTRUCT;

typedef struct tagMONCONVSTRUCT {
    UINT    cb;
    BOOL    fConnect;
    DWORD   dwTime;
    HANDLE  hTask;
    HSZ     hszSvc;
    HSZ     hszTopic;
    HCONV   hConvClient;        // Globally unique value != apps local hConv
    HCONV   hConvServer;        // Globally unique value != apps local hConv
} MONCONVSTRUCT, PMONCONVSTRUCT;

#define     MAX_MONITORS            4
#define     APPCLASS_MONITOR        0x00000001L
#define     XTYP_MONITOR            (0x00F0 | XCLASS_NOTIFICATION | XTYPF_NOBLOCK)

/*
 * Callback filter flags for use with MONITOR apps - 0 implies no monitor
 * callbacks.
 */
#define     MF_HSZ_INFO                  0x01000000
#define     MF_SENDMSGS                  0x02000000
#define     MF_POSTMSGS                  0x04000000
#define     MF_CALLBACKS                 0x08000000
#define     MF_ERRORS                    0x10000000
#define     MF_LINKS                     0x20000000
#define     MF_CONV                      0x40000000

#define     MF_MASK                      0xFF000000
#endif /* NODDEMLSPY */

#ifdef __cplusplus
}
#endif  /* __cplusplus */

#endif /* _INC_DDEMLH */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\inc32\DDE.H ===
/*****************************************************************************\
*                                                                             *
* dde.h -       Dynamic Data Exchange structures and definitions              *
*                                                                             *
* Copyright (c) 1993-1995, Microsoft Corp.	All rights reserved	      *
*                                                                             *
\*****************************************************************************/
#ifndef _DDEHEADER_INCLUDED_
#define _DDEHEADER_INCLUDED_

#ifndef _WINDEF_
#include <windef.h>
#endif

#ifdef __cplusplus
extern "C" {
#endif

/* DDE window messages */

#define WM_DDE_FIRST	    0x03E0
#define WM_DDE_INITIATE     (WM_DDE_FIRST)
#define WM_DDE_TERMINATE    (WM_DDE_FIRST+1)
#define WM_DDE_ADVISE	    (WM_DDE_FIRST+2)
#define WM_DDE_UNADVISE     (WM_DDE_FIRST+3)
#define WM_DDE_ACK	        (WM_DDE_FIRST+4)
#define WM_DDE_DATA	        (WM_DDE_FIRST+5)
#define WM_DDE_REQUEST	    (WM_DDE_FIRST+6)
#define WM_DDE_POKE	        (WM_DDE_FIRST+7)
#define WM_DDE_EXECUTE	    (WM_DDE_FIRST+8)
#define WM_DDE_LAST	        (WM_DDE_FIRST+8)

/*----------------------------------------------------------------------------
|       DDEACK structure
|
|	Structure of wStatus (LOWORD(lParam)) in WM_DDE_ACK message
|       sent in response to a WM_DDE_DATA, WM_DDE_REQUEST, WM_DDE_POKE,
|       WM_DDE_ADVISE, or WM_DDE_UNADVISE message.
|
----------------------------------------------------------------------------*/

typedef struct {
        unsigned short bAppReturnCode:8,
                 reserved:6,
                 fBusy:1,
		 fAck:1;
} DDEACK;


/*----------------------------------------------------------------------------
|       DDEADVISE structure
|
|	WM_DDE_ADVISE parameter structure for hOptions (LOWORD(lParam))
|
----------------------------------------------------------------------------*/

typedef struct {
        unsigned short reserved:14,
                 fDeferUpd:1,
		 fAckReq:1;
	short     cfFormat;
} DDEADVISE;


/*----------------------------------------------------------------------------
|       DDEDATA structure
|
|       WM_DDE_DATA parameter structure for hData (LOWORD(lParam)).
|       The actual size of this structure depends on the size of
|       the Value array.
|
----------------------------------------------------------------------------*/

typedef struct {
	unsigned short unused:12,
                 fResponse:1,
                 fRelease:1,
                 reserved:1,
                 fAckReq:1;
	short	 cfFormat;
	BYTE	 Value[1];
} DDEDATA;


/*----------------------------------------------------------------------------
|	DDEPOKE structure
|
|	WM_DDE_POKE parameter structure for hData (LOWORD(lParam)).
|       The actual size of this structure depends on the size of
|       the Value array.
|
----------------------------------------------------------------------------*/

typedef struct {
	unsigned short unused:13,  /* Earlier versions of DDE.H incorrectly */
                             /* 12 unused bits.                       */
		 fRelease:1,
		 fReserved:2;
	short    cfFormat;
	BYTE	 Value[1];  /* This member was named rgb[1] in previous */
                            /* versions of DDE.H                        */

} DDEPOKE;

/*----------------------------------------------------------------------------
The following typedef's were used in previous versions of the Windows SDK.
They are still valid.  The above typedef's define exactly the same structures
as those below.  The above typedef names are recommended, however, as they
are more meaningful.

Note that the DDEPOKE structure typedef'ed in earlier versions of DDE.H did
not correctly define the bit positions.
----------------------------------------------------------------------------*/

typedef struct {
        unsigned short unused:13,
                 fRelease:1,
                 fDeferUpd:1,
		 fAckReq:1;
	short	 cfFormat;
} DDELN;

typedef struct {
	unsigned short unused:12,
                 fAck:1,
                 fRelease:1,
                 fReserved:1,
                 fAckReq:1;
	short	 cfFormat;
	BYTE	 rgb[1];
} DDEUP;


/*
 * DDE SECURITY
 */

BOOL
WINAPI
DdeSetQualityOfService(
    HWND hwndClient,
    CONST SECURITY_QUALITY_OF_SERVICE *pqosNew,
    PSECURITY_QUALITY_OF_SERVICE pqosPrev);

BOOL
WINAPI
ImpersonateDdeClientWindow(
    HWND hWndClient,
    HWND hWndServer);

/*
 * DDE message packing APIs
 */
LONG APIENTRY PackDDElParam(UINT msg, UINT uiLo, UINT uiHi);
BOOL APIENTRY UnpackDDElParam(UINT msg, LONG lParam, PUINT puiLo, PUINT puiHi);
BOOL APIENTRY FreeDDElParam(UINT msg, LONG lParam);
LONG APIENTRY ReuseDDElParam(LONG lParam, UINT msgIn, UINT msgOut, UINT uiLo, UINT uiHi);

#ifdef __cplusplus
}
#endif

#endif // _DDEHEADER_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\inc32\CTYPE.H ===
/***
*ctype.h - character conversion macros and ctype macros
*
*	Copyright (c) 1985-1994, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	Defines macros for character classification/conversion.
*	[ANSI/System V]
*
****/

#ifndef _INC_CTYPE
#define _INC_CTYPE

#ifdef __cplusplus
extern "C" {
#endif


/* Define _CRTAPI1 (for compatibility with the NT SDK) */

#ifndef _CRTAPI1
#if	( (_MSC_VER >= 800) && (_M_IX86 >= 300) )
#define _CRTAPI1 __cdecl
#else
#define _CRTAPI1
#endif
#endif


/* Define _CRTAPI2 (for compatibility with the NT SDK) */

#ifndef _CRTAPI2
#if	( (_MSC_VER >= 800) && (_M_IX86 >= 300) )
#define _CRTAPI2 __cdecl
#else
#define _CRTAPI2
#endif
#endif


/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef	_NTSDK
/* definition compatible with NT SDK */
#define _CRTIMP
#else	/* ndef _NTSDK */
/* current definition */
#ifdef	_DLL
#define _CRTIMP __declspec(dllimport)
#else	/* ndef _DLL */
#define _CRTIMP
#endif	/* _DLL */
#endif	/* _NTSDK */
#endif	/* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if	( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif


#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif

#ifndef _WCTYPE_T_DEFINED
typedef wchar_t wint_t;
typedef wchar_t wctype_t;
#define _WCTYPE_T_DEFINED
#endif

#ifndef WEOF
#define WEOF (wint_t)(0xFFFF)
#endif

/*
 * These declarations allow the user access to the ctype look-up
 * array _ctype defined in ctype.obj by simply including ctype.h
 */
#ifndef _CTYPE_DISABLE_MACROS

#ifdef	_NTSDK

/* Definitions and declarations compatible with the NT SDK */

#ifdef	_DLL

extern unsigned short * _ctype;
#define _pctype     (*_pctype_dll)
extern unsigned short **_pctype_dll;
#define _pwctype    (*_pwctype_dll)
extern unsigned short **_pwctype_dll;

#else	/* _DLL */


extern unsigned short _ctype[];
extern unsigned short *_pctype;
extern wctype_t *_pwctype;

#endif	/* _DLL */

#else	/* ndef _NTSDK */

/* Current declarations */

_CRTIMP extern unsigned short _ctype[];

#if	defined(_DLL) && defined(_M_IX86)

#define _pctype     (*__p__pctype())
_CRTIMP unsigned short ** __cdecl __p__pctype(void);

#define _pwctype    (*__p__pwctype())
_CRTIMP wctype_t ** __cdecl ___p__pwctype(void);

#else	/* !(defined(_DLL) && defined(_M_IX86)) */

_CRTIMP extern unsigned short *_pctype;
_CRTIMP extern wctype_t *_pwctype;

#endif	/* defined(_DLL) && defined(_M_IX86) */

#endif	/* _NTSDK */

#endif	/* _CTYPE_DISABLE_MACROS */

/* set bit masks for the possible character types */

#define _UPPER		0x1	/* upper case letter */
#define _LOWER		0x2	/* lower case letter */
#define _DIGIT		0x4	/* digit[0-9] */
#define _SPACE		0x8	/* tab, carriage return, newline, */
				/* vertical tab or form feed */
#define _PUNCT		0x10	/* punctuation character */
#define _CONTROL	0x20	/* control character */
#define _BLANK		0x40	/* space char */
#define _HEX		0x80	/* hexadecimal digit */

#define _LEADBYTE	0x8000			/* multibyte leadbyte */
#define _ALPHA		(0x0100|_UPPER|_LOWER)	/* alphabetic character */


/* character classification function prototypes */

#ifndef _CTYPE_DEFINED

_CRTIMP int __cdecl _isctype(int, int);

_CRTIMP int __cdecl isalpha(int);
_CRTIMP int __cdecl isupper(int);
_CRTIMP int __cdecl islower(int);
_CRTIMP int __cdecl isdigit(int);
_CRTIMP int __cdecl isxdigit(int);
_CRTIMP int __cdecl isspace(int);
_CRTIMP int __cdecl ispunct(int);
_CRTIMP int __cdecl isalnum(int);
_CRTIMP int __cdecl isprint(int);
_CRTIMP int __cdecl isgraph(int);
_CRTIMP int __cdecl iscntrl(int);
_CRTIMP int __cdecl toupper(int);
_CRTIMP int __cdecl tolower(int);
_CRTIMP int __cdecl _tolower(int);
_CRTIMP int __cdecl _toupper(int);
_CRTIMP int __cdecl __isascii(int);
_CRTIMP int __cdecl __toascii(int);
_CRTIMP int __cdecl __iscsymf(int);
_CRTIMP int __cdecl __iscsym(int);
#define _CTYPE_DEFINED
#endif

#ifndef _WCTYPE_DEFINED

/* wide function prototypes, also declared in wchar.h  */

/* character classification function prototypes */

_CRTIMP int __cdecl iswalpha(wint_t);
_CRTIMP int __cdecl iswupper(wint_t);
_CRTIMP int __cdecl iswlower(wint_t);
_CRTIMP int __cdecl iswdigit(wint_t);
_CRTIMP int __cdecl iswxdigit(wint_t);
_CRTIMP int __cdecl iswspace(wint_t);
_CRTIMP int __cdecl iswpunct(wint_t);
_CRTIMP int __cdecl iswalnum(wint_t);
_CRTIMP int __cdecl iswprint(wint_t);
_CRTIMP int __cdecl iswgraph(wint_t);
_CRTIMP int __cdecl iswcntrl(wint_t);
_CRTIMP int __cdecl iswascii(wint_t);
_CRTIMP int __cdecl isleadbyte(int);

_CRTIMP wchar_t __cdecl towupper(wchar_t);
_CRTIMP wchar_t __cdecl towlower(wchar_t);

_CRTIMP int __cdecl iswctype(wint_t, wctype_t);

/* --------- The following functions are OBSOLETE --------- */
_CRTIMP int __cdecl is_wctype(wint_t, wctype_t);
/*  --------- The preceding functions are OBSOLETE --------- */

#define _WCTYPE_DEFINED
#endif

/* the character classification macro definitions */

#ifndef _CTYPE_DISABLE_MACROS


/*
 * Maximum number of bytes in multi-byte character in the current locale
 * (also defined in stdlib.h).
 */
#ifndef MB_CUR_MAX

#ifdef	_NTSDK

/* definition compatible with NT SDK */
#ifdef	_DLL
#define __mb_cur_max	(*__mb_cur_max_dll)
#define MB_CUR_MAX	(*__mb_cur_max_dll)
extern	unsigned short *__mb_cur_max_dll;
#else	/* ndef _DLL */
#define MB_CUR_MAX __mb_cur_max
extern	unsigned short __mb_cur_max;
#endif	/* _DLL */

#else	/* ndef _NTSDK */

/* current definition */
#if	defined(_DLL) && defined(_M_IX86)
#define MB_CUR_MAX (*__p___mb_cur_max())
_CRTIMP int * __cdecl __p___mb_cur_max(void);
#else	/* !(defined(_DLL) && defined(_M_IX86)) */
#define MB_CUR_MAX __mb_cur_max
_CRTIMP extern int __mb_cur_max;
#endif	/* defined(_DLL) && defined(_M_IX86) */

#endif	/* _NTSDK */

#endif	/* MB_CUR_MAX */

#define isalpha(_c)	(MB_CUR_MAX > 1 ? _isctype(_c,_ALPHA) : _pctype[_c] & _ALPHA)
#define isupper(_c)	(MB_CUR_MAX > 1 ? _isctype(_c,_UPPER) : _pctype[_c] & _UPPER)
#define islower(_c)	(MB_CUR_MAX > 1 ? _isctype(_c,_LOWER) : _pctype[_c] & _LOWER)
#define isdigit(_c)	(MB_CUR_MAX > 1 ? _isctype(_c,_DIGIT) : _pctype[_c] & _DIGIT)
#define isxdigit(_c)	(MB_CUR_MAX > 1 ? _isctype(_c,_HEX)   : _pctype[_c] & _HEX)
#define isspace(_c)	(MB_CUR_MAX > 1 ? _isctype(_c,_SPACE) : _pctype[_c] & _SPACE)
#define ispunct(_c)	(MB_CUR_MAX > 1 ? _isctype(_c,_PUNCT) : _pctype[_c] & _PUNCT)
#define isalnum(_c)	(MB_CUR_MAX > 1 ? _isctype(_c,_ALPHA|_DIGIT) : _pctype[_c] & (_ALPHA|_DIGIT))
#define isprint(_c)	(MB_CUR_MAX > 1 ? _isctype(_c,_BLANK|_PUNCT|_ALPHA|_DIGIT) : _pctype[_c] & (_BLANK|_PUNCT|_ALPHA|_DIGIT))
#define isgraph(_c)	(MB_CUR_MAX > 1 ? _isctype(_c,_PUNCT|_ALPHA|_DIGIT) : _pctype[_c] & (_PUNCT|_ALPHA|_DIGIT))
#define iscntrl(_c)	(MB_CUR_MAX > 1 ? _isctype(_c,_CONTROL) : _pctype[_c] & _CONTROL)


#define _tolower(_c)	( (_c)-'A'+'a' )
#define _toupper(_c)	( (_c)-'a'+'A' )

#define __isascii(_c)	( (unsigned)(_c) < 0x80 )
#define __toascii(_c)	( (_c) & 0x7f )

#define iswalpha(_c)	( iswctype(_c,_ALPHA) )
#define iswupper(_c)	( iswctype(_c,_UPPER) )
#define iswlower(_c)	( iswctype(_c,_LOWER) )
#define iswdigit(_c)	( iswctype(_c,_DIGIT) )
#define iswxdigit(_c)	( iswctype(_c,_HEX) )
#define iswspace(_c)	( iswctype(_c,_SPACE) )
#define iswpunct(_c)	( iswctype(_c,_PUNCT) )
#define iswalnum(_c)	( iswctype(_c,_ALPHA|_DIGIT) )
#define iswprint(_c)	( iswctype(_c,_BLANK|_PUNCT|_ALPHA|_DIGIT) )
#define iswgraph(_c)	( iswctype(_c,_PUNCT|_ALPHA|_DIGIT) )
#define iswcntrl(_c)	( iswctype(_c,_CONTROL) )
#define iswascii(_c)	( (unsigned)(_c) < 0x80 )


#define isleadbyte(_c)	(_pctype[(unsigned char)(_c)] & _LEADBYTE)


/* MS C version 2.0 extended ctype macros */

#define __iscsymf(_c)	(isalpha(_c) || ((_c) == '_'))
#define __iscsym(_c)	(isalnum(_c) || ((_c) == '_'))

#endif /* _CTYPE_DISABLE_MACROS */

#if	!__STDC__

/* Non-ANSI names for compatibility */

#ifdef	_NTSDK

#define isascii __isascii
#define toascii __toascii
#define iscsymf __iscsymf
#define iscsym	__iscsym

#else	/* ndef _NTSDK */

#ifndef _CTYPE_DEFINED
_CRTIMP int __cdecl isascii(int);
_CRTIMP int __cdecl toascii(int);
_CRTIMP int __cdecl iscsymf(int);
_CRTIMP int __cdecl iscsym(int);
#else
#define isascii __isascii
#define toascii __toascii
#define iscsymf __iscsymf
#define iscsym	__iscsym
#endif

#endif	/* _NTSDK */

#endif	/* __STDC__ */

#ifdef __cplusplus
}
#endif


#endif	/* _INC_CTYPE */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\inc32\CGUID.H ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       cguid.h
//
//--------------------------------------------------------------------------

#ifndef __CGUID_H__
#define __CGUID_H__

#ifdef __cplusplus
extern "C" {
#endif

extern const IID GUID_NULL;
extern const IID IID_IRpcChannel;
extern const IID IID_IRpcStub;
extern const IID IID_IStubManager;
extern const IID IID_IRpcProxy;
extern const IID IID_IProxyManager;
extern const IID IID_IPSFactory;
extern const IID IID_IInternalMoniker;
extern const IID IID_IDfReserved1;
extern const IID IID_IDfReserved2;
extern const IID IID_IDfReserved3;
extern const CLSID CLSID_StdMarshal;
extern const IID IID_IStub;
extern const IID IID_IProxy;
extern const IID IID_IEnumGeneric;
extern const IID IID_IEnumHolder;
extern const IID IID_IEnumCallback;
extern const IID IID_IOleManager;
extern const IID IID_IOlePresObj;
extern const IID IID_IDebug;
extern const IID IID_IDebugStream;
extern const CLSID CLSID_PSGenObject;
extern const CLSID CLSID_PSClientSite;
extern const CLSID CLSID_PSClassObject;
extern const CLSID CLSID_PSInPlaceActive;
extern const CLSID CLSID_PSInPlaceFrame;
extern const CLSID CLSID_PSDragDrop;
extern const CLSID CLSID_PSBindCtx;
extern const CLSID CLSID_PSEnumerators;
extern const CLSID CLSID_StaticMetafile;
extern const CLSID CLSID_StaticDib;
extern const CLSID CID_CDfsVolume;

//********************************************
//
// CD Forms CLSIDs
//
//********************************************

//
// Form Kernel objects
//
extern const CLSID CLSID_CCDFormKrnl;
extern const CLSID CLSID_CCDPropertyPage;
extern const CLSID CLSID_CCDFormDialog;

//
// Control objects
//
extern const CLSID CLSID_CCDCommandButton;
extern const CLSID CLSID_CCDComboBox;
extern const CLSID CLSID_CCDTextBox;
extern const CLSID CLSID_CCDCheckBox;
extern const CLSID CLSID_CCDLabel;
extern const CLSID CLSID_CCDOptionButton;
extern const CLSID CLSID_CCDListBox;
extern const CLSID CLSID_CCDScrollBar;
extern const CLSID CLSID_CCDGroupBox;

//
// Property Pages
//
extern const CLSID CLSID_CCDGeneralPropertyPage;
extern const CLSID CLSID_CCDGenericPropertyPage;
extern const CLSID CLSID_CCDFontPropertyPage;
extern const CLSID CLSID_CCDColorPropertyPage;
extern const CLSID CLSID_CCDLabelPropertyPage;
extern const CLSID CLSID_CCDCheckBoxPropertyPage;
extern const CLSID CLSID_CCDTextBoxPropertyPage;
extern const CLSID CLSID_CCDOptionButtonPropertyPage;
extern const CLSID CLSID_CCDListBoxPropertyPage;
extern const CLSID CLSID_CCDCommandButtonPropertyPage;
extern const CLSID CLSID_CCDComboBoxPropertyPage;
extern const CLSID CLSID_CCDScrollBarPropertyPage;
extern const CLSID CLSID_CCDGroupBoxPropertyPage;
extern const CLSID CLSID_CCDXObjectPropertyPage;

extern const CLSID CLSID_CStdPropertyFrame;

extern const CLSID CLSID_CFormPropertyPage;
extern const CLSID CLSID_CGridPropertyPage;

extern const CLSID CLSID_CWSJArticlePage;
extern const CLSID CLSID_CSystemPage;

extern const CLSID CLSID_IdentityUnmarshal;
extern const CLSID CLSID_InProcFreeMarshaler;

extern const CLSID CLSID_Picture_Metafile;
extern const CLSID CLSID_Picture_EnhMetafile;
extern const CLSID CLSID_Picture_Dib;

//
// Enumerations
//
extern const GUID GUID_TRISTATE;

#ifdef __cplusplus
}
#endif


#endif // __CGUID_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\inc32\DLGS.H ===
/*---------------------------------------------------------------------------*/
/* Dlgs.h : UI dialog header                                                 */
/*                                                                           */
/* Copyright (c) Microsoft Corporation, 1990-1995                            */
/*---------------------------------------------------------------------------*/

#ifndef _DLGSH_INCLUDED_
#define _DLGSH_INCLUDED_

/*----Constants--------------------------------------------------------------*/
#define ctlFirst    0x0400
#define ctlLast     0x04ff
    /* Push buttons */
#define psh1        0x0400
#define psh2        0x0401
#define psh3        0x0402
#define psh4        0x0403
#define psh5        0x0404
#define psh6        0x0405
#define psh7        0x0406
#define psh8        0x0407
#define psh9        0x0408
#define psh10       0x0409
#define psh11       0x040a
#define psh12       0x040b
#define psh13       0x040c
#define psh14       0x040d
#define psh15       0x040e
#define pshHelp     psh15
#define psh16       0x040f
    /* Checkboxes */
#define chx1        0x0410
#define chx2        0x0411
#define chx3        0x0412
#define chx4        0x0413
#define chx5        0x0414
#define chx6        0x0415
#define chx7        0x0416
#define chx8        0x0417
#define chx9        0x0418
#define chx10       0x0419
#define chx11       0x041a
#define chx12       0x041b
#define chx13       0x041c
#define chx14       0x041d
#define chx15       0x041e
#define chx16       0x041f
    /* Radio buttons */
#define rad1        0x0420
#define rad2        0x0421
#define rad3        0x0422
#define rad4        0x0423
#define rad5        0x0424
#define rad6        0x0425
#define rad7        0x0426
#define rad8        0x0427
#define rad9        0x0428
#define rad10       0x0429
#define rad11       0x042a
#define rad12       0x042b
#define rad13       0x042c
#define rad14       0x042d
#define rad15       0x042e
#define rad16       0x042f
    /* Groups, frames, rectangles, and icons */
#define grp1        0x0430
#define grp2        0x0431
#define grp3        0x0432
#define grp4        0x0433
#define frm1        0x0434
#define frm2        0x0435
#define frm3        0x0436
#define frm4        0x0437
#define rct1        0x0438
#define rct2        0x0439
#define rct3        0x043a
#define rct4        0x043b
#define ico1        0x043c
#define ico2        0x043d
#define ico3        0x043e
#define ico4        0x043f
    /* Static text */
#define stc1        0x0440
#define stc2        0x0441
#define stc3        0x0442
#define stc4        0x0443
#define stc5        0x0444
#define stc6        0x0445
#define stc7        0x0446
#define stc8        0x0447
#define stc9        0x0448
#define stc10       0x0449
#define stc11       0x044a
#define stc12       0x044b
#define stc13       0x044c
#define stc14       0x044d
#define stc15       0x044e
#define stc16       0x044f
#define stc17       0x0450
#define stc18       0x0451
#define stc19       0x0452
#define stc20       0x0453
#define stc21       0x0454
#define stc22       0x0455
#define stc23       0x0456
#define stc24       0x0457
#define stc25       0x0458
#define stc26       0x0459
#define stc27       0x045a
#define stc28       0x045b
#define stc29       0x045c
#define stc30       0x045d
#define stc31       0x045e
#define stc32       0x045f
    /* Listboxes */
#define lst1        0x0460
#define lst2        0x0461
#define lst3        0x0462
#define lst4        0x0463
#define lst5        0x0464
#define lst6        0x0465
#define lst7        0x0466
#define lst8        0x0467
#define lst9        0x0468
#define lst10       0x0469
#define lst11       0x046a
#define lst12       0x046b
#define lst13       0x046c
#define lst14       0x046d
#define lst15       0x046e
#define lst16       0x046f
    /* Combo boxes */
#define cmb1        0x0470
#define cmb2        0x0471
#define cmb3        0x0472
#define cmb4        0x0473
#define cmb5        0x0474
#define cmb6        0x0475
#define cmb7        0x0476
#define cmb8        0x0477
#define cmb9        0x0478
#define cmb10       0x0479
#define cmb11       0x047a
#define cmb12       0x047b
#define cmb13       0x047c
#define cmb14       0x047d
#define cmb15       0x047e
#define cmb16       0x047f
    /* Edit controls */
#define edt1        0x0480
#define edt2        0x0481
#define edt3        0x0482
#define edt4        0x0483
#define edt5        0x0484
#define edt6        0x0485
#define edt7        0x0486
#define edt8        0x0487
#define edt9        0x0488
#define edt10       0x0489
#define edt11       0x048a
#define edt12       0x048b
#define edt13       0x048c
#define edt14       0x048d
#define edt15       0x048e
#define edt16       0x048f
    /* Scroll bars */
#define scr1        0x0490
#define scr2        0x0491
#define scr3        0x0492
#define scr4        0x0493
#define scr5        0x0494
#define scr6        0x0495
#define scr7        0x0496
#define scr8        0x0497

/* These dialog resource ordinals really start at 0x0600, but the
 * RC Compiler can't handle hex for resource IDs, hence the decimal.
 */
#define FILEOPENORD      1536
#define MULTIFILEOPENORD 1537
#define PRINTDLGORD      1538
#define PRNSETUPDLGORD   1539
#define FINDDLGORD       1540
#define REPLACEDLGORD    1541
#define FONTDLGORD       1542
#define FORMATDLGORD31   1543
#define FORMATDLGORD30   1544

#if (WINVER >= 0x30a)
#define PAGESETUPDLGORD  1546
#endif /* WINVER >= 0x30a)



/*----Types------------------------------------------------------------------*/
typedef struct tagCRGB
    {
    BYTE    bRed;
    BYTE    bGreen;
    BYTE    bBlue;
    BYTE    bExtra;
    }
CRGB;           /* RGB Color */


#endif // _DLGSH_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\inc32\EXCPT.H ===
/***
*excpt.h - defines exception values, types and routines
*
*	Copyright (c) 1990-1994, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	This file contains the definitions and prototypes for the compiler-
*	dependent intrinsics, support functions and keywords which implement
*	the structured exception handling extensions.
*
****/

#ifndef _INC_EXCPT
#define _INC_EXCPT

#ifdef __cplusplus
extern "C" {
#endif


/* Define _CRTAPI1 (for compatibility with the NT SDK) */

#ifndef _CRTAPI1
#if	( (_MSC_VER >= 800) && (_M_IX86 >= 300) )
#define _CRTAPI1 __cdecl
#else
#define _CRTAPI1
#endif
#endif


/* Define _CRTAPI2 (for compatibility with the NT SDK) */

#ifndef _CRTAPI2
#if	( (_MSC_VER >= 800) && (_M_IX86 >= 300) )
#define _CRTAPI2 __cdecl
#else
#define _CRTAPI2
#endif
#endif


/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef	_NTSDK
/* definition compatible with NT SDK */
#define _CRTIMP
#else	/* ndef _NTSDK */
/* current definition */
#ifdef	_DLL
#define _CRTIMP __declspec(dllimport)
#else	/* ndef _DLL */
#define _CRTIMP
#endif	/* _DLL */
#endif	/* _NTSDK */
#endif	/* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if	( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif


/*
 * Exception disposition return values.
 */
typedef enum _EXCEPTION_DISPOSITION {
    ExceptionContinueExecution,
    ExceptionContinueSearch,
    ExceptionNestedException,
    ExceptionCollidedUnwind
} EXCEPTION_DISPOSITION;


/*
 * Prototype for SEH support function.
 */

#ifdef	_M_IX86

/*
 * Declarations to keep MS C 8 (386/486) compiler happy
 */
struct _EXCEPTION_RECORD;
struct _CONTEXT;

EXCEPTION_DISPOSITION __cdecl _except_handler (
	struct _EXCEPTION_RECORD *ExceptionRecord,
	void * EstablisherFrame,
	struct _CONTEXT *ContextRecord,
	void * DispatcherContext
	);

#elif	defined(_M_MRX000) || defined(_M_ALPHA)

/*
 * Declarations to keep MIPS and ALPHA compiler happy
 */
typedef struct _EXCEPTION_POINTERS *Exception_info_ptr;
struct _EXCEPTION_RECORD;
struct _CONTEXT;
struct _DISPATCHER_CONTEXT;


EXCEPTION_DISPOSITION __C_specific_handler (
	struct _EXCEPTION_RECORD *ExceptionRecord,
	void *EstablisherFrame,
	struct _CONTEXT *ContextRecord,
	struct _DISPATCHER_CONTEXT *DispatcherContext
	);

#endif


/*
 * Keywords and intrinsics for SEH
 */

#ifdef	_MSC_VER

#if	defined(_NTSDK) && !defined(__cplusplus)
#define try				__try
#define except				__except
#define finally 			__finally
#define leave				__leave
#endif	/* _NTSDK */
#define GetExceptionCode		_exception_code
#define exception_code			_exception_code
#define GetExceptionInformation 	(struct _EXCEPTION_POINTERS *)_exception_info
#define exception_info			(struct _EXCEPTION_POINTERS *)_exception_info
#define AbnormalTermination		_abnormal_termination
#define abnormal_termination		_abnormal_termination

unsigned long __cdecl _exception_code(void);
void *	      __cdecl _exception_info(void);
int	      __cdecl _abnormal_termination(void);

#endif


/*
 * Legal values for expression in except().
 */

#define EXCEPTION_EXECUTE_HANDLER	 1
#define EXCEPTION_CONTINUE_SEARCH	 0
#define EXCEPTION_CONTINUE_EXECUTION	-1



#ifdef __cplusplus
}
#endif

#endif	/* _INC_EXCPT */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\inc32\MCX.H ===
/************************************************************************
*                                                                       *
*   mcx.h -- This module defines the 32-Bit Windows MCX APIs            *
*                                                                       *
*   Copyright (c) 1990-1995, Microsoft Corp. All rights reserved.       *
*                                                                       *
************************************************************************/

#ifndef _MCX_H_
#define _MCX_H_

typedef struct _MODEMDEVCAPS {
    DWORD   dwActualSize;
    DWORD   dwRequiredSize;
    DWORD   dwDevSpecificOffset;
    DWORD   dwDevSpecificSize;

    // product and version identification
    DWORD   dwModemProviderVersion;
    DWORD   dwModemManufacturerOffset;
    DWORD   dwModemManufacturerSize;
    DWORD   dwModemModelOffset;
    DWORD   dwModemModelSize;
    DWORD   dwModemVersionOffset;
    DWORD   dwModemVersionSize;

    // local option capabilities
    DWORD   dwDialOptions;          // bitmap of supported values
    DWORD   dwCallSetupFailTimer;   // maximum in seconds
    DWORD   dwInactivityTimeout;    // maximum in seconds
    DWORD   dwSpeakerVolume;        // bitmap of supported values
    DWORD   dwSpeakerMode;          // bitmap of supported values
    DWORD   dwModemOptions;         // bitmap of supported values
    DWORD   dwMaxDTERate;           // maximum value in bit/s
    DWORD   dwMaxDCERate;           // maximum value in bit/s

    // Variable portion for proprietary expansion
    BYTE    abVariablePortion [1];
} MODEMDEVCAPS, *PMODEMDEVCAPS, *LPMODEMDEVCAPS;

typedef struct _MODEMSETTINGS {
    DWORD   dwActualSize;
    DWORD   dwRequiredSize;
    DWORD   dwDevSpecificOffset;
    DWORD   dwDevSpecificSize;

    // static local options (read/write)
    DWORD   dwCallSetupFailTimer;       // seconds
    DWORD   dwInactivityTimeout;        // seconds
    DWORD   dwSpeakerVolume;            // level
    DWORD   dwSpeakerMode;              // mode
    DWORD   dwPreferredModemOptions;    // bitmap
    
    // negotiated options (read only) for current or last call
    DWORD   dwNegotiatedModemOptions;   // bitmap
    DWORD   dwNegotiatedDCERate;        // bit/s

    // Variable portion for proprietary expansion
    BYTE    abVariablePortion [1];
} MODEMSETTINGS, *PMODEMSETTINGS, *LPMODEMSETTINGS;

// Dial Options
#define DIALOPTION_BILLING  0x00000040  // Supports wait for bong "$"
#define DIALOPTION_QUIET    0x00000080  // Supports wait for quiet "@"
#define DIALOPTION_DIALTONE 0x00000100  // Supports wait for dial tone "W"

// SpeakerVolume for MODEMDEVCAPS
#define MDMVOLFLAG_LOW      0x00000001
#define MDMVOLFLAG_MEDIUM   0x00000002 
#define MDMVOLFLAG_HIGH     0x00000004 

// SpeakerVolume for MODEMSETTINGS
#define MDMVOL_LOW          0x00000000
#define MDMVOL_MEDIUM       0x00000001 
#define MDMVOL_HIGH         0x00000002

// SpeakerMode for MODEMDEVCAPS
#define MDMSPKRFLAG_OFF         0x00000001 
#define MDMSPKRFLAG_DIAL        0x00000002 
#define MDMSPKRFLAG_ON          0x00000004 
#define MDMSPKRFLAG_CALLSETUP   0x00000008

// SpeakerMode for MODEMSETTINGS
#define MDMSPKR_OFF         0x00000000 
#define MDMSPKR_DIAL        0x00000001 
#define MDMSPKR_ON          0x00000002 
#define MDMSPKR_CALLSETUP   0x00000003 
 
// Modem Options
#define MDM_COMPRESSION      0x00000001
#define MDM_ERROR_CONTROL    0x00000002
#define MDM_FORCED_EC        0x00000004
#define MDM_CELLULAR         0x00000008
#define MDM_FLOWCONTROL_HARD 0x00000010
#define MDM_FLOWCONTROL_SOFT 0x00000020
#define MDM_CCITT_OVERRIDE   0x00000040
#define MDM_SPEED_ADJUST     0x00000080
#define MDM_TONE_DIAL        0x00000100
#define MDM_BLIND_DIAL       0x00000200
#define MDM_V23_OVERRIDE     0x00000400

#endif /* _MCX_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\inc32\DRIVINIT.H ===
// All items moved to wingdi.h
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\inc32\IMM.H ===
/**********************************************************************/
/*      IMM.H - Input Method Manager definitions                      */
/*                                                                    */
/*      Copyright (c) 1993-1995  Microsoft Corporation                */
/**********************************************************************/

#ifndef _IMM_
#define _IMM_        // defined if IMM.H has been included

#ifdef __cplusplus
extern "C" {
#endif

#ifndef _WINUSER_
#define VK_PROCESSKEY 0x0E5
#endif

typedef DWORD     HIMC;
typedef DWORD     HIMCC;

typedef HKL FAR  *LPHKL;
typedef UINT FAR *LPUINT;

typedef struct tagCOMPOSITIONFORM {
    DWORD dwStyle;
    POINT ptCurrentPos;
    RECT  rcArea;
} COMPOSITIONFORM, *PCOMPOSITIONFORM, NEAR *NPCOMPOSITIONFORM, FAR *LPCOMPOSITIONFORM;

typedef struct tagCANDIDATEFORM {
    DWORD dwIndex;
    DWORD dwStyle;
    POINT ptCurrentPos;
    RECT  rcArea;
} CANDIDATEFORM, *PCANDIDATEFORM, NEAR *NPCANDIDATEFORM, FAR *LPCANDIDATEFORM;

typedef struct tagCANDIDATELIST {
    DWORD dwSize;
    DWORD dwStyle;
    DWORD dwCount;
    DWORD dwSelection;
    DWORD dwPageStart;
    DWORD dwPageSize;
    DWORD dwOffset[1];
} CANDIDATELIST, *PCANDIDATELIST, NEAR *NPCANDIDATELIST, FAR *LPCANDIDATELIST;

typedef struct tagREGISTERWORDA {
    LPSTR   lpReading;
    LPSTR   lpWord;
} REGISTERWORDA, *PREGISTERWORDA, NEAR *NPREGISTERWORDA, FAR *LPREGISTERWORDA;
typedef struct tagREGISTERWORDW {
    LPWSTR  lpReading;
    LPWSTR  lpWord;
} REGISTERWORDW, *PREGISTERWORDW, NEAR *NPREGISTERWORDW, FAR *LPREGISTERWORDW;
#ifdef UNICODE
typedef REGISTERWORDW REGISTERWORD;
typedef PREGISTERWORDW PREGISTERWORD;
typedef NPREGISTERWORDW NPREGISTERWORD;
typedef LPREGISTERWORDW LPREGISTERWORD;
#else
typedef REGISTERWORDA REGISTERWORD;
typedef PREGISTERWORDA PREGISTERWORD;
typedef NPREGISTERWORDA NPREGISTERWORD;
typedef LPREGISTERWORDA LPREGISTERWORD;
#endif // UNICODE

#define STYLE_DESCRIPTION_SIZE  32

typedef struct tagSTYLEBUFA {
    DWORD       dwStyle;
    CHAR        szDescription[STYLE_DESCRIPTION_SIZE];
} STYLEBUFA, *PSTYLEBUFA, NEAR *NPSTYLEBUFA, FAR *LPSTYLEBUFA;
typedef struct tagSTYLEBUFW {
    DWORD       dwStyle;
    WCHAR       szDescription[STYLE_DESCRIPTION_SIZE];
} STYLEBUFW, *PSTYLEBUFW, NEAR *NPSTYLEBUFW, FAR *LPSTYLEBUFW;
#ifdef UNICODE
typedef STYLEBUFW STYLEBUF;
typedef PSTYLEBUFW PSTYLEBUF;
typedef NPSTYLEBUFW NPSTYLEBUF;
typedef LPSTYLEBUFW LPSTYLEBUF;
#else
typedef STYLEBUFA STYLEBUF;
typedef PSTYLEBUFA PSTYLEBUF;
typedef NPSTYLEBUFA NPSTYLEBUF;
typedef LPSTYLEBUFA LPSTYLEBUF;
#endif // UNICODE

// prototype of IMM API

HKL  WINAPI ImmInstallIMEA(LPCSTR lpszIMEFileName, LPCSTR lpszLayoutText);
HKL  WINAPI ImmInstallIMEW(LPCWSTR lpszIMEFileName, LPCWSTR lpszLayoutText);
#ifdef UNICODE
#define ImmInstallIME  ImmInstallIMEW
#else
#define ImmInstallIME  ImmInstallIMEA
#endif // !UNICODE

HWND WINAPI ImmGetDefaultIMEWnd(HWND);

UINT WINAPI ImmGetDescriptionA(HKL, LPSTR, UINT uBufLen);
UINT WINAPI ImmGetDescriptionW(HKL, LPWSTR, UINT uBufLen);
#ifdef UNICODE
#define ImmGetDescription  ImmGetDescriptionW
#else
#define ImmGetDescription  ImmGetDescriptionA
#endif // !UNICODE

UINT WINAPI ImmGetIMEFileNameA(HKL, LPSTR, UINT uBufLen);
UINT WINAPI ImmGetIMEFileNameW(HKL, LPWSTR, UINT uBufLen);
#ifdef UNICODE
#define ImmGetIMEFileName  ImmGetIMEFileNameW
#else
#define ImmGetIMEFileName  ImmGetIMEFileNameA
#endif // !UNICODE

DWORD WINAPI ImmGetProperty(HKL, DWORD);

BOOL WINAPI ImmIsIME(HKL);

BOOL WINAPI ImmSimulateHotKey(HWND, DWORD);

HIMC WINAPI ImmCreateContext(void);
BOOL WINAPI ImmDestroyContext(HIMC);
HIMC WINAPI ImmGetContext(HWND);
BOOL WINAPI ImmReleaseContext(HWND, HIMC);
HIMC WINAPI ImmAssociateContext(HWND, HIMC);

LONG  WINAPI ImmGetCompositionStringA(HIMC, DWORD, LPVOID, DWORD);
LONG  WINAPI ImmGetCompositionStringW(HIMC, DWORD, LPVOID, DWORD);
#ifdef UNICODE
#define ImmGetCompositionString  ImmGetCompositionStringW
#else
#define ImmGetCompositionString  ImmGetCompositionStringA
#endif // !UNICODE

BOOL  WINAPI ImmSetCompositionStringA(HIMC, DWORD dwIndex, LPCVOID lpComp, DWORD, LPCVOID lpRead, DWORD);
BOOL  WINAPI ImmSetCompositionStringW(HIMC, DWORD dwIndex, LPCVOID lpComp, DWORD, LPCVOID lpRead, DWORD);
#ifdef UNICODE
#define ImmSetCompositionString  ImmSetCompositionStringW
#else
#define ImmSetCompositionString  ImmSetCompositionStringA
#endif // !UNICODE

DWORD WINAPI ImmGetCandidateListCountA(HIMC, LPDWORD lpdwListCount);
DWORD WINAPI ImmGetCandidateListCountW(HIMC, LPDWORD lpdwListCount);
#ifdef UNICODE
#define ImmGetCandidateListCount  ImmGetCandidateListCountW
#else
#define ImmGetCandidateListCount  ImmGetCandidateListCountA
#endif // !UNICODE

DWORD WINAPI ImmGetCandidateListA(HIMC, DWORD deIndex, LPCANDIDATELIST, DWORD dwBufLen);
DWORD WINAPI ImmGetCandidateListW(HIMC, DWORD deIndex, LPCANDIDATELIST, DWORD dwBufLen);
#ifdef UNICODE
#define ImmGetCandidateList  ImmGetCandidateListW
#else
#define ImmGetCandidateList  ImmGetCandidateListA
#endif // !UNICODE

DWORD WINAPI ImmGetGuideLineA(HIMC, DWORD dwIndex, LPSTR, DWORD dwBufLen);
DWORD WINAPI ImmGetGuideLineW(HIMC, DWORD dwIndex, LPWSTR, DWORD dwBufLen);
#ifdef UNICODE
#define ImmGetGuideLine  ImmGetGuideLineW
#else
#define ImmGetGuideLine  ImmGetGuideLineA
#endif // !UNICODE

BOOL WINAPI ImmGetConversionStatus(HIMC, LPDWORD, LPDWORD);
BOOL WINAPI ImmSetConversionStatus(HIMC, DWORD, DWORD);
BOOL WINAPI ImmGetOpenStatus(HIMC);
BOOL WINAPI ImmSetOpenStatus(HIMC, BOOL);

BOOL WINAPI ImmGetCompositionFontA(HIMC, LPLOGFONTA);
BOOL WINAPI ImmGetCompositionFontW(HIMC, LPLOGFONTW);
#ifdef UNICODE
#define ImmGetCompositionFont  ImmGetCompositionFontW
#else
#define ImmGetCompositionFont  ImmGetCompositionFontA
#endif // !UNICODE

BOOL WINAPI ImmSetCompositionFontA(HIMC, LPLOGFONTA);
BOOL WINAPI ImmSetCompositionFontW(HIMC, LPLOGFONTW);
#ifdef UNICODE
#define ImmSetCompositionFont  ImmSetCompositionFontW
#else
#define ImmSetCompositionFont  ImmSetCompositionFontA
#endif // !UNICODE

#ifdef UNICODE
#define ImmConfigureIME  ImmConfigureIMEW
#else
#define ImmConfigureIME  ImmConfigureIMEA
#endif // !UNICODE
BOOL    WINAPI ImmConfigureIMEA(HKL, HWND, DWORD, LPVOID);
BOOL    WINAPI ImmConfigureIMEW(HKL, HWND, DWORD, LPVOID);
#ifdef UNICODE
#define ImmConfigureIME  ImmConfigureIMEW
#else
#define ImmConfigureIME  ImmConfigureIMEA
#endif // !UNICODE

LRESULT WINAPI ImmEscapeA(HKL, HIMC, UINT, LPVOID);
LRESULT WINAPI ImmEscapeW(HKL, HIMC, UINT, LPVOID);
#ifdef UNICODE
#define ImmEscape  ImmEscapeW
#else
#define ImmEscape  ImmEscapeA
#endif // !UNICODE

DWORD   WINAPI ImmGetConversionListA(HKL, HIMC, LPCSTR, LPCANDIDATELIST, DWORD dwBufLen, UINT uFlag);
DWORD   WINAPI ImmGetConversionListW(HKL, HIMC, LPCWSTR, LPCANDIDATELIST, DWORD dwBufLen, UINT uFlag);
#ifdef UNICODE
#define ImmGetConversionList  ImmGetConversionListW
#else
#define ImmGetConversionList  ImmGetConversionListA
#endif // !UNICODE

BOOL    WINAPI ImmNotifyIME(HIMC, DWORD dwAction, DWORD dwIndex, DWORD dwValue);

BOOL WINAPI ImmGetStatusWindowPos(HIMC, LPPOINT);
BOOL WINAPI ImmSetStatusWindowPos(HIMC, LPPOINT);
BOOL WINAPI ImmGetCompositionWindow(HIMC, LPCOMPOSITIONFORM);
BOOL WINAPI ImmSetCompositionWindow(HIMC, LPCOMPOSITIONFORM);
BOOL WINAPI ImmGetCandidateWindow(HIMC, DWORD, LPCANDIDATEFORM);
BOOL WINAPI ImmSetCandidateWindow(HIMC, LPCANDIDATEFORM);

BOOL WINAPI ImmIsUIMessageA(HWND, UINT, WPARAM, LPARAM);
BOOL WINAPI ImmIsUIMessageW(HWND, UINT, WPARAM, LPARAM);
#ifdef UNICODE
#define ImmIsUIMessage  ImmIsUIMessageW
#else
#define ImmIsUIMessage  ImmIsUIMessageA
#endif // !UNICODE

UINT WINAPI ImmGetVirtualKey(HWND);

typedef int (CALLBACK *REGISTERWORDENUMPROCA)(LPCSTR, DWORD, LPCSTR, LPVOID);
typedef int (CALLBACK *REGISTERWORDENUMPROCW)(LPCWSTR, DWORD, LPCWSTR, LPVOID);
#ifdef UNICODE
#define REGISTERWORDENUMPROC  REGISTERWORDENUMPROCW
#else
#define REGISTERWORDENUMPROC  REGISTERWORDENUMPROCA
#endif // !UNICODE

BOOL WINAPI ImmRegisterWordA(HKL, LPCSTR lpszReading, DWORD, LPCSTR lpszRegister);
BOOL WINAPI ImmRegisterWordW(HKL, LPCWSTR lpszReading, DWORD, LPCWSTR lpszRegister);
#ifdef UNICODE
#define ImmRegisterWord  ImmRegisterWordW
#else
#define ImmRegisterWord  ImmRegisterWordA
#endif // !UNICODE

BOOL WINAPI ImmUnregisterWordA(HKL, LPCSTR lpszReading, DWORD, LPCSTR lpszUnregister);
BOOL WINAPI ImmUnregisterWordW(HKL, LPCWSTR lpszReading, DWORD, LPCWSTR lpszUnregister);
#ifdef UNICODE
#define ImmUnregisterWord  ImmUnregisterWordW
#else
#define ImmUnregisterWord  ImmUnregisterWordA
#endif // !UNICODE

UINT WINAPI ImmGetRegisterWordStyleA(HKL, UINT nItem, LPSTYLEBUFA);
UINT WINAPI ImmGetRegisterWordStyleW(HKL, UINT nItem, LPSTYLEBUFW);
#ifdef UNICODE
#define ImmGetRegisterWordStyle  ImmGetRegisterWordStyleW
#else
#define ImmGetRegisterWordStyle  ImmGetRegisterWordStyleA
#endif // !UNICODE

UINT WINAPI ImmEnumRegisterWordA(HKL, REGISTERWORDENUMPROCA, LPCSTR lpszReading, DWORD, LPCSTR lpszRegister, LPVOID);
UINT WINAPI ImmEnumRegisterWordW(HKL, REGISTERWORDENUMPROCW, LPCWSTR lpszReading, DWORD, LPCWSTR lpszRegister, LPVOID);
#ifdef UNICODE
#define ImmEnumRegisterWord  ImmEnumRegisterWordW
#else
#define ImmEnumRegisterWord  ImmEnumRegisterWordA
#endif // !UNICODE

#ifndef _WINUSER_ 
// the IME related messages
#define WM_CONVERTREQUESTEX             0x0108
#define WM_IME_STARTCOMPOSITION         0x010D
#define WM_IME_ENDCOMPOSITION           0x010E
#define WM_IME_COMPOSITION              0x010F
#define WM_IME_KEYLAST                  0x010F

#define WM_IME_SETCONTEXT               0x0281
#define WM_IME_NOTIFY                   0x0282
#define WM_IME_CONTROL                  0x0283
#define WM_IME_COMPOSITIONFULL          0x0284
#define WM_IME_SELECT                   0x0285
#define WM_IME_CHAR                     0x0286

#define WM_IME_KEYDOWN                  0x0290
#define WM_IME_KEYUP                    0x0291

// wParam for WM_IME_CONTROL                 
#define IMC_GETCANDIDATEPOS             0x0007
#define IMC_SETCANDIDATEPOS             0x0008
#define IMC_GETCOMPOSITIONFONT          0x0009
#define IMC_SETCOMPOSITIONFONT          0x000A
#define IMC_GETCOMPOSITIONWINDOW        0x000B
#define IMC_SETCOMPOSITIONWINDOW        0x000C
#define IMC_GETSTATUSWINDOWPOS          0x000F
#define IMC_SETSTATUSWINDOWPOS          0x0010
#define IMC_CLOSESTATUSWINDOW           0x0021
#define IMC_OPENSTATUSWINDOW            0x0022

#endif /* !_WINUSER_ */

// wParam for WM_IME_CONTROL to the soft keyboard
// dwAction for ImmNotifyIME
#define NI_OPENCANDIDATE                0x0010
#define NI_CLOSECANDIDATE               0x0011
#define NI_SELECTCANDIDATESTR           0x0012
#define NI_CHANGECANDIDATELIST          0x0013
#define NI_FINALIZECONVERSIONRESULT     0x0014
#define NI_COMPOSITIONSTR               0x0015
#define NI_SETCANDIDATE_PAGESTART       0x0016
#define NI_SETCANDIDATE_PAGESIZE        0x0017

// lParam for WM_IME_SETCONTEXT
#define ISC_SHOWUICANDIDATEWINDOW       0x00000001
#define ISC_SHOWUICOMPOSITIONWINDOW     0x80000000
#define ISC_SHOWUIGUIDELINE             0x40000000
#define ISC_SHOWUIALLCANDIDATEWINDOW    0x0000000F
#define ISC_SHOWUIALL                   0xC000000F

// dwIndex for ImmNotifyIME/NI_COMPOSITIONSTR
#define CPS_COMPLETE                    0x0001
#define CPS_CONVERT                     0x0002
#define CPS_REVERT                      0x0003
#define CPS_CANCEL                      0x0004

// the modifiers of hot key
#define MOD_ALT                         0x0001
#define MOD_CONTROL                     0x0002
#define MOD_SHIFT                       0x0004

#define MOD_LEFT                        0x8000
#define MOD_RIGHT                       0x4000

#define MOD_ON_KEYUP                    0x0800
#define MOD_IGNORE_ALL_MODIFIER         0x0400

// Windows for Simplified Chinese Edition hot key ID from 0x10 - 0x2F
#define IME_CHOTKEY_IME_NONIME_TOGGLE           0x10
#define IME_CHOTKEY_SHAPE_TOGGLE                0x11
#define IME_CHOTKEY_SYMBOL_TOGGLE               0x12

// Windows for Japanese Edition hot key ID from 0x30 - 0x4F
#define IME_JHOTKEY_CLOSE_OPEN                  0x30

// Windows for Korean Edition hot key ID from 0x50 - 0x6F
#define IME_KHOTKEY_SHAPE_TOGGLE                0x50
#define IME_KHOTKEY_HANJACONVERT                0x51
#define IME_KHOTKEY_ENGLISH                     0x52

// Windows for Tranditional Chinese Edition hot key ID from 0x70 - 0x8F
#define IME_THOTKEY_IME_NONIME_TOGGLE           0x70
#define IME_THOTKEY_SHAPE_TOGGLE                0x71
#define IME_THOTKEY_SYMBOL_TOGGLE               0x72

// direct switch hot key ID from 0x100 - 0x11F
#define IME_HOTKEY_DSWITCH_FIRST                0x100
#define IME_HOTKEY_DSWITCH_LAST                 0x11F

// IME private hot key from 0x200 - 0x21F
#define IME_ITHOTKEY_RESEND_RESULTSTR           0x200
#define IME_ITHOTKEY_PREVIOUS_COMPOSITION       0x201
#define IME_ITHOTKEY_UISTYLE_TOGGLE             0x202

// parameter of ImmGetCompositionString
#define GCS_COMPREADSTR                 0x0001
#define GCS_COMPREADATTR                0x0002
#define GCS_COMPREADCLAUSE              0x0004
#define GCS_COMPSTR                     0x0008
#define GCS_COMPATTR                    0x0010
#define GCS_COMPCLAUSE                  0x0020
#define GCS_CURSORPOS                   0x0080
#define GCS_DELTASTART                  0x0100
#define GCS_RESULTREADSTR               0x0200
#define GCS_RESULTREADCLAUSE            0x0400
#define GCS_RESULTSTR                   0x0800
#define GCS_RESULTCLAUSE                0x1000

// style bit flags for WM_IME_COMPOSITION
#define CS_INSERTCHAR                   0x2000
#define CS_NOMOVECARET                  0x4000

// bits of fdwInit of INPUTCONTEXT
// IME property bits
#define IME_PROP_AT_CARET               0x00010000
#define IME_PROP_SPECIAL_UI             0x00020000
#define IME_PROP_CANDLIST_START_FROM_1  0x00040000
#define IME_PROP_UNICODE                0x00080000

// IME UICapability bits
#define UI_CAP_2700                     0x00000001
#define UI_CAP_ROT90                    0x00000002
#define UI_CAP_ROTANY                   0x00000004

// ImmSetCompositionString Capability bits
#define SCS_CAP_COMPSTR                 0x00000001
#define SCS_CAP_MAKEREAD                0x00000002

// IME WM_IME_SELECT inheritance Capability bits
#define SELECT_CAP_CONVERSION           0x00000001
#define SELECT_CAP_SENTENCE             0x00000002

// ID for deIndex of ImmGetGuideLine
#define GGL_LEVEL                       0x00000001
#define GGL_INDEX                       0x00000002
#define GGL_STRING                      0x00000003
#define GGL_PRIVATE                     0x00000004

// ID for dwLevel of GUIDELINE Structure
#define GL_LEVEL_NOGUIDELINE            0x00000000
#define GL_LEVEL_FATAL                  0x00000001
#define GL_LEVEL_ERROR                  0x00000002
#define GL_LEVEL_WARNING                0x00000003
#define GL_LEVEL_INFORMATION            0x00000004

// ID for dwIndex of GUIDELINE Structure
#define GL_ID_UNKNOWN                   0x00000000
#define GL_ID_NOMODULE                  0x00000001
#define GL_ID_NODICTIONARY              0x00000010
#define GL_ID_CANNOTSAVE                0x00000011
#define GL_ID_NOCONVERT                 0x00000020
#define GL_ID_TYPINGERROR               0x00000021
#define GL_ID_TOOMANYSTROKE             0x00000022
#define GL_ID_READINGCONFLICT           0x00000023
#define GL_ID_INPUTREADING              0x00000024
#define GL_ID_INPUTRADICAL              0x00000025
#define GL_ID_INPUTCODE                 0x00000026
#define GL_ID_INPUTSYMBOL               0x00000027
#define GL_ID_CHOOSECANDIDATE           0x00000028
#define GL_ID_REVERSECONVERSION         0x00000029
#define GL_ID_PRIVATE_FIRST             0x00008000
#define GL_ID_PRIVATE_LAST              0x0000FFFF

// ID for dwIndex of ImmGetProperty
#define IGP_PROPERTY                    0x00000004
#define IGP_CONVERSION                  0x00000008
#define IGP_SENTENCE                    0x0000000c
#define IGP_UI                          0x00000010
#define IGP_SETCOMPSTR                  0x00000014
#define IGP_SELECT                      0x00000018

// dwIndex for ImmSetCompositionString API
#define SCS_SETSTR                      (GCS_COMPREADSTR|GCS_COMPSTR)
#define SCS_CHANGEATTR                  (GCS_COMPREADATTR|GCS_COMPATTR)
#define SCS_CHANGECLAUSE                (GCS_COMPREADCLAUSE|GCS_COMPCLAUSE)

// attribute for COMPOSITIONSTRING Structure
#define ATTR_INPUT                      0x00
#define ATTR_TARGET_CONVERTED           0x01
#define ATTR_CONVERTED                  0x02
#define ATTR_TARGET_NOTCONVERTED        0x03
#define ATTR_INPUT_ERROR                0x04

// bit field for IMC_SETCOMPOSITIONWINDOW, IMC_SETCANDIDATEWINDOW
#define CFS_DEFAULT                     0x0000
#define CFS_RECT                        0x0001
#define CFS_POINT                       0x0002
#define CFS_SCREEN                      0x0004
#define CFS_FORCE_POSITION              0x0020
#define CFS_CANDIDATEPOS                0x0040
#define CFS_EXCLUDE                     0x0080

// conversion direction for ImmGetConversionList
#define GCL_CONVERSION                  0x0001
#define GCL_REVERSECONVERSION           0x0002
#define GCL_REVERSE_LENGTH              0x0003

// bit field for conversion mode
#define IME_CMODE_ALPHANUMERIC          0x0000
#define IME_CMODE_NATIVE                0x0001
#define IME_CMODE_CHINESE               IME_CMODE_NATIVE
#define IME_CMODE_HANGEUL               IME_CMODE_NATIVE
#define IME_CMODE_JAPANESE              IME_CMODE_NATIVE
#define IME_CMODE_KATAKANA              0x0002  // only effect under IME_CMODE_NATIVE
#define IME_CMODE_LANGUAGE              0x0003
#define IME_CMODE_FULLSHAPE             0x0008
#define IME_CMODE_ROMAN                 0x0010
#define IME_CMODE_CHARCODE              0x0020
#define IME_CMODE_HANJACONVERT          0x0040
#define IME_CMODE_SOFTKBD               0x0080
#define IME_CMODE_NOCONVERSION          0x0100
#define IME_CMODE_EUDC                  0x0200
#define IME_CMODE_SYMBOL                0x0400

#define IME_SMODE_NONE                  0x0000
#define IME_SMODE_PLAURALCLAUSE         0x0001
#define IME_SMODE_SINGLECONVERT         0x0002
#define IME_SMODE_AUTOMATIC             0x0004
#define IME_SMODE_PHRASEPREDICT         0x0008

// style of candidate
#define IME_CAND_UNKNOWN                0x0000
#define IME_CAND_READ                   0x0001
#define IME_CAND_CODE                   0x0002
#define IME_CAND_MEANING                0x0003
#define IME_CAND_RADICAL                0x0004
#define IME_CAND_STROKE                 0x0005

#ifndef _WINUSER_
// wParam of report message WM_IME_NOTIFY
#define IMN_CLOSESTATUSWINDOW           0x0001
#define IMN_OPENSTATUSWINDOW            0x0002
#define IMN_CHANGECANDIDATE             0x0003
#define IMN_CLOSECANDIDATE              0x0004
#define IMN_OPENCANDIDATE               0x0005
#define IMN_SETCONVERSIONMODE           0x0006
#define IMN_SETSENTENCEMODE             0x0007
#define IMN_SETOPENSTATUS               0x0008
#define IMN_SETCANDIDATEPOS             0x0009
#define IMN_SETCOMPOSITIONFONT          0x000A
#define IMN_SETCOMPOSITIONWINDOW        0x000B
#define IMN_SETSTATUSWINDOWPOS          0x000C
#define IMN_GUIDELINE                   0x000D
#define IMN_PRIVATE                     0x000E
#endif

// error code of ImmGetCompositionString
#define IMM_ERROR_NODATA                (-1)
#define IMM_ERROR_GENERAL               (-2)

// dialog mode of ImmConfigureIME
#define IME_CONFIG_GENERAL              1
#define IME_CONFIG_REGISTERWORD         2
#define IME_CONFIG_SELECTDICTIONARY     3

// dialog mode of ImmEscape
#define IME_ESC_QUERY_SUPPORT           0x0003
#define IME_ESC_RESERVED_FIRST          0x0004
#define IME_ESC_RESERVED_LAST           0x07FF
#define IME_ESC_PRIVATE_FIRST           0x0800
#define IME_ESC_PRIVATE_LAST            0x0FFF
#define IME_ESC_SEQUENCE_TO_INTERNAL    0x1001
#define IME_ESC_GET_EUDC_DICTIONARY     0x1003
#define IME_ESC_SET_EUDC_DICTIONARY     0x1004
#define IME_ESC_MAX_KEY                 0x1005
#define IME_ESC_IME_NAME                0x1006
#define IME_ESC_SYNC_HOTKEY             0x1007
#define IME_ESC_HANJA_MODE              0x1008
#define IME_ESC_AUTOMATA                0x1009

// style of word registration
#define IME_REGWORD_STYLE_EUDC          0x00000001
#define IME_REGWORD_STYLE_USER_FIRST    0x80000000
#define IME_REGWORD_STYLE_USER_LAST     0xFFFFFFFF

// type of soft keyboard
// for Windows Tranditional Chinese Edition
#define SOFTKEYBOARD_TYPE_T1            0x0001
// for Windows Simplified Chinese Edition
#define SOFTKEYBOARD_TYPE_C1            0x0002

#ifdef __cplusplus
}
#endif

#endif  // _IMM_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\inc32\LZEXPAND.H ===
/*
** lzdos.h - Public interface to LZEXP?.LIB.
*/

#ifndef _LZEXPAND_
#define _LZEXPAND_

#ifdef __cplusplus
extern "C" {
#endif

/*
** Error Return Codes
*/

#define LZERROR_BADINHANDLE   (-1)  /* invalid input handle */
#define LZERROR_BADOUTHANDLE  (-2)  /* invalid output handle */
#define LZERROR_READ          (-3)  /* corrupt compressed file format */
#define LZERROR_WRITE         (-4)  /* out of space for output file */
#define LZERROR_GLOBALLOC     (-5)  /* insufficient memory for LZFile struct */
#define LZERROR_GLOBLOCK      (-6)  /* bad global handle */
#define LZERROR_BADVALUE      (-7)  /* input parameter out of acceptable range*/
#define LZERROR_UNKNOWNALG    (-8)  /* compression algorithm not recognized */


/*
** Prototypes
*/

INT
APIENTRY
LZStart(
	VOID
	);

VOID
APIENTRY
LZDone(
	VOID
	);

LONG
APIENTRY
CopyLZFile(
	INT,
	INT
	);

LONG
APIENTRY
LZCopy(
	INT,
	INT
	);

INT
APIENTRY
LZInit(
	INT
	);

INT
APIENTRY
GetExpandedNameA(
	LPSTR,
	LPSTR
	);
INT
APIENTRY
GetExpandedNameW(
	LPWSTR,
	LPWSTR
	);
#ifdef UNICODE
#define GetExpandedName  GetExpandedNameW
#else
#define GetExpandedName  GetExpandedNameA
#endif // !UNICODE

INT
APIENTRY
LZOpenFileA(
	LPSTR,
	LPOFSTRUCT,
	WORD
	);
INT
APIENTRY
LZOpenFileW(
	LPWSTR,
	LPOFSTRUCT,
	WORD
	);
#ifdef UNICODE
#define LZOpenFile  LZOpenFileW
#else
#define LZOpenFile  LZOpenFileA
#endif // !UNICODE

LONG
APIENTRY
LZSeek(
	INT,
	LONG,
	INT
	);

INT
APIENTRY
LZRead(
	INT,
	LPSTR,
	INT
	);

VOID
APIENTRY
LZClose(
	INT
	);

#ifdef __cplusplus
}
#endif


#endif // _LZEXPAND_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\inc32\MMSYSTEM.H ===
/*==========================================================================
 *
 *  mmsystem.h -- Include file for Multimedia API's
 *
 *  Version 4.00
 *
 *  Copyright (C) 1992-1995 Microsoft Corporation.  All Rights Reserved.
 *
 *--------------------------------------------------------------------------
 *
 *  Define:         Prevent inclusion of:
 *  --------------  --------------------------------------------------------
 *  MMNODRV         Installable driver support
 *  MMNOSOUND       Sound support
 *  MMNOWAVE        Waveform support
 *  MMNOMIDI        MIDI support
 *  MMNOAUX         Auxiliary audio support
 *  MMNOMIXER       Mixer support
 *  MMNOTIMER       Timer support
 *  MMNOJOY         Joystick support
 *  MMNOMCI         MCI support
 *  MMNOMMIO        Multimedia file I/O support
 *  MMNOMMSYSTEM    General MMSYSTEM functions
 *
 *==========================================================================
 */

#ifndef _INC_MMSYSTEM
#define _INC_MMSYSTEM   /* #defined if mmsystem.h has been included */

#ifdef _WIN32
#include <pshpack1.h>
#else
#ifndef RC_INVOKED
#pragma pack(1)
#endif
#endif

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */

#ifdef _WIN32
#ifndef _WINMM_
#define	WINMMAPI	DECLSPEC_IMPORT
#else
#define	WINMMAPI
#endif
#define _loadds
#define _huge
#else
#define	WINMMAPI
#endif

#ifdef _WIN32_VXD

#define NEAR
#define FAR

#define DECLARE_HANDLE(x) typedef WORD x
#define WINAPI

typedef DWORD LPSTR;
typedef DWORD LPVOID;
typedef DWORD LPCSTR;
typedef DWORD LPCWSTR;
typedef DWORD LRESULT;
typedef DWORD LPARAM;
typedef DWORD WPARAM;

typedef short WCHAR;

#endif

/****************************************************************************

		    General constants and data types

****************************************************************************/

/* general constants */
#define MAXPNAMELEN      32     /* max product name length (including NULL) */
#define MAXERRORLENGTH   256    /* max error text length (including NULL) */
#define MAX_JOYSTICKOEMVXDNAME 260 /* max oem vxd name length (including NULL) */

/*
 *  Microsoft Manufacturer and Product ID's (these have been moved to
 *  MMREG.H for Windows 4.00 and above).
 */
#if (WINVER <= 0x030A)
#ifndef MM_MICROSOFT
#define MM_MICROSOFT            1   /* Microsoft Corporation */
#endif

#ifndef MM_MIDI_MAPPER
#define MM_MIDI_MAPPER          1   /* MIDI Mapper */
#define MM_WAVE_MAPPER          2   /* Wave Mapper */
#define MM_SNDBLST_MIDIOUT      3   /* Sound Blaster MIDI output port */
#define MM_SNDBLST_MIDIIN       4   /* Sound Blaster MIDI input port */
#define MM_SNDBLST_SYNTH        5   /* Sound Blaster internal synthesizer */
#define MM_SNDBLST_WAVEOUT      6   /* Sound Blaster waveform output */
#define MM_SNDBLST_WAVEIN       7   /* Sound Blaster waveform input */
#define MM_ADLIB                9   /* Ad Lib-compatible synthesizer */
#define MM_MPU401_MIDIOUT      10   /* MPU401-compatible MIDI output port */
#define MM_MPU401_MIDIIN       11   /* MPU401-compatible MIDI input port */
#define MM_PC_JOYSTICK         12   /* Joystick adapter */
#endif
#endif

/* general data types */

#ifdef _WIN32
typedef UINT        MMVERSION;  /* major (high byte), minor (low byte) */
#else
typedef UINT        VERSION;    /* major (high byte), minor (low byte) */
#endif
typedef UINT        MMRESULT;   /* error return code, 0 means no error */
				/* call as if(err=xxxx(...)) Error(err); else */
#define _MMRESULT_

typedef UINT FAR   *LPUINT;

/* MMTIME data structure */
typedef struct mmtime_tag
{
    UINT            wType;      /* indicates the contents of the union */
    union
    {
	DWORD       ms;         /* milliseconds */
	DWORD       sample;     /* samples */
	DWORD       cb;         /* byte count */
	DWORD       ticks;      /* ticks in MIDI stream */

	/* SMPTE */
	struct
	{
	    BYTE    hour;       /* hours */
	    BYTE    min;        /* minutes */
	    BYTE    sec;        /* seconds */
	    BYTE    frame;      /* frames  */
	    BYTE    fps;        /* frames per second */
	    BYTE    dummy;      /* pad */
#ifdef _WIN32
	    BYTE    pad[2];
#endif
	} smpte;

	/* MIDI */
	struct
	{
	    DWORD songptrpos;   /* song pointer position */
	} midi;
    } u;
} MMTIME, *PMMTIME, NEAR *NPMMTIME, FAR *LPMMTIME;

/* types for wType field in MMTIME struct */
#define TIME_MS         0x0001  /* time in milliseconds */
#define TIME_SAMPLES    0x0002  /* number of wave samples */
#define TIME_BYTES      0x0004  /* current byte offset */
#define TIME_SMPTE      0x0008  /* SMPTE time */
#define TIME_MIDI       0x0010  /* MIDI time */
#define TIME_TICKS      0x0020  /* Ticks within MIDI stream */

/*
 *
 *
 */
#define MAKEFOURCC(ch0, ch1, ch2, ch3)                              \
		((DWORD)(BYTE)(ch0) | ((DWORD)(BYTE)(ch1) << 8) |   \
		((DWORD)(BYTE)(ch2) << 16) | ((DWORD)(BYTE)(ch3) << 24 ))

/****************************************************************************

		    Multimedia Extensions Window Messages

****************************************************************************/

#define MM_JOY1MOVE         0x3A0           /* joystick */
#define MM_JOY2MOVE         0x3A1
#define MM_JOY1ZMOVE        0x3A2
#define MM_JOY2ZMOVE        0x3A3
#define MM_JOY1BUTTONDOWN   0x3B5
#define MM_JOY2BUTTONDOWN   0x3B6
#define MM_JOY1BUTTONUP     0x3B7
#define MM_JOY2BUTTONUP     0x3B8

#define MM_MCINOTIFY        0x3B9           /* MCI */

#define MM_WOM_OPEN         0x3BB           /* waveform output */
#define MM_WOM_CLOSE        0x3BC
#define MM_WOM_DONE         0x3BD

#define MM_WIM_OPEN         0x3BE           /* waveform input */
#define MM_WIM_CLOSE        0x3BF
#define MM_WIM_DATA         0x3C0

#define MM_MIM_OPEN         0x3C1           /* MIDI input */
#define MM_MIM_CLOSE        0x3C2
#define MM_MIM_DATA         0x3C3
#define MM_MIM_LONGDATA     0x3C4
#define MM_MIM_ERROR        0x3C5
#define MM_MIM_LONGERROR    0x3C6

#define MM_MOM_OPEN         0x3C7           /* MIDI output */
#define MM_MOM_CLOSE        0x3C8
#define MM_MOM_DONE         0x3C9

/* these are also in msvideo.h */
#ifndef MM_DRVM_OPEN
 #define MM_DRVM_OPEN       0x3D0           /* installable drivers */
 #define MM_DRVM_CLOSE      0x3D1
 #define MM_DRVM_DATA       0x3D2
 #define MM_DRVM_ERROR      0x3D3
#endif

/* these are used by msacm.h */
#define MM_STREAM_OPEN	    0x3D4
#define MM_STREAM_CLOSE	    0x3D5
#define MM_STREAM_DONE	    0x3D6
#define MM_STREAM_ERROR	    0x3D7

#if(WINVER >= 0x0400)
#define MM_MOM_POSITIONCB   0x3CA           /* Callback for MEVT_POSITIONCB */

#ifndef MM_MCISIGNAL
 #define MM_MCISIGNAL        0x3CB
#endif

#define MM_MIM_MOREDATA      0x3CC          /* MIM_DONE w/ pending events */

#endif /* WINVER >= 0x0400 */
#define MM_MIXM_LINE_CHANGE     0x3D0       /* mixer line change notify */
#define MM_MIXM_CONTROL_CHANGE  0x3D1       /* mixer control change notify */

/****************************************************************************

		String resource number bases (internal use)

****************************************************************************/

#define MMSYSERR_BASE          0
#define WAVERR_BASE            32
#define MIDIERR_BASE           64
#define TIMERR_BASE            96
#define JOYERR_BASE            160
#define MCIERR_BASE            256
#define MIXERR_BASE            1024

#define MCI_STRING_OFFSET      512
#define MCI_VD_OFFSET          1024
#define MCI_CD_OFFSET          1088
#define MCI_WAVE_OFFSET        1152
#define MCI_SEQ_OFFSET         1216

/****************************************************************************

			General error return values

****************************************************************************/

/* general error return values */
#define MMSYSERR_NOERROR      0                    /* no error */
#define MMSYSERR_ERROR        (MMSYSERR_BASE + 1)  /* unspecified error */
#define MMSYSERR_BADDEVICEID  (MMSYSERR_BASE + 2)  /* device ID out of range */
#define MMSYSERR_NOTENABLED   (MMSYSERR_BASE + 3)  /* driver failed enable */
#define MMSYSERR_ALLOCATED    (MMSYSERR_BASE + 4)  /* device already allocated */
#define MMSYSERR_INVALHANDLE  (MMSYSERR_BASE + 5)  /* device handle is invalid */
#define MMSYSERR_NODRIVER     (MMSYSERR_BASE + 6)  /* no device driver present */
#define MMSYSERR_NOMEM        (MMSYSERR_BASE + 7)  /* memory allocation error */
#define MMSYSERR_NOTSUPPORTED (MMSYSERR_BASE + 8)  /* function isn't supported */
#define MMSYSERR_BADERRNUM    (MMSYSERR_BASE + 9)  /* error value out of range */
#define MMSYSERR_INVALFLAG    (MMSYSERR_BASE + 10) /* invalid flag passed */
#define MMSYSERR_INVALPARAM   (MMSYSERR_BASE + 11) /* invalid parameter passed */
#define MMSYSERR_HANDLEBUSY   (MMSYSERR_BASE + 12) /* handle being used */
						   /* simultaneously on another */
						   /* thread (eg callback) */
#define MMSYSERR_INVALIDALIAS (MMSYSERR_BASE + 13) /* specified alias not found */
#define MMSYSERR_BADDB        (MMSYSERR_BASE + 14) /* bad registry database */
#define MMSYSERR_KEYNOTFOUND  (MMSYSERR_BASE + 15) /* registry key not found */
#define MMSYSERR_READERROR    (MMSYSERR_BASE + 16) /* registry read error */
#define MMSYSERR_WRITEERROR   (MMSYSERR_BASE + 17) /* registry write error */
#define MMSYSERR_DELETEERROR  (MMSYSERR_BASE + 18) /* registry delete error */
#define MMSYSERR_VALNOTFOUND  (MMSYSERR_BASE + 19) /* registry value not found */
#define MMSYSERR_NODRIVERCB   (MMSYSERR_BASE + 20) /* driver does not call DriverCallback */
#define MMSYSERR_LASTERROR    (MMSYSERR_BASE + 20) /* last error in range */

#if (WINVER < 0x030a) || defined(_WIN32)
DECLARE_HANDLE(HDRVR);
#endif /* ifdef WINVER < 0x030a */

#ifndef MMNODRV

/****************************************************************************

			Installable driver support

****************************************************************************/

#ifdef _WIN32
typedef struct DRVCONFIGINFOEX {
    DWORD   dwDCISize;
    LPCWSTR  lpszDCISectionName;
    LPCWSTR  lpszDCIAliasName;
    DWORD    dnDevNode;
} DRVCONFIGINFOEX, *PDRVCONFIGINFOEX, NEAR *NPDRVCONFIGINFOEX, FAR *LPDRVCONFIGINFOEX;

#else
typedef struct DRVCONFIGINFOEX {
    DWORD   dwDCISize;
    LPCSTR  lpszDCISectionName;
    LPCSTR  lpszDCIAliasName;
    DWORD    dnDevNode;
} DRVCONFIGINFOEX, *PDRVCONFIGINFOEX, NEAR *NPDRVCONFIGINFOEX, FAR *LPDRVCONFIGINFOEX;
#endif

#if (WINVER < 0x030a) || defined(_WIN32)

#ifndef DRV_LOAD

/* Driver messages */
#define DRV_LOAD                0x0001
#define DRV_ENABLE              0x0002
#define DRV_OPEN                0x0003
#define DRV_CLOSE               0x0004
#define DRV_DISABLE             0x0005
#define DRV_FREE                0x0006
#define DRV_CONFIGURE           0x0007
#define DRV_QUERYCONFIGURE      0x0008
#define DRV_INSTALL             0x0009
#define DRV_REMOVE              0x000A
#define DRV_EXITSESSION         0x000B
#define DRV_POWER               0x000F
#define DRV_RESERVED            0x0800
#define DRV_USER                0x4000

/* LPARAM of DRV_CONFIGURE message */
#ifdef _WIN32
typedef struct tagDRVCONFIGINFO {
    DWORD   dwDCISize;
    LPCWSTR  lpszDCISectionName;
    LPCWSTR  lpszDCIAliasName;
} DRVCONFIGINFO, *PDRVCONFIGINFO, NEAR *NPDRVCONFIGINFO, FAR *LPDRVCONFIGINFO;
#else
typedef struct tagDRVCONFIGINFO {
    DWORD   dwDCISize;
    LPCSTR  lpszDCISectionName;
    LPCSTR  lpszDCIAliasName;
} DRVCONFIGINFO, *PDRVCONFIGINFO, NEAR *NPDRVCONFIGINFO, FAR *LPDRVCONFIGINFO;
#endif

/* Supported return values for DRV_CONFIGURE message */
#define DRVCNF_CANCEL           0x0000
#define DRVCNF_OK               0x0001
#define DRVCNF_RESTART          0x0002

/* installable driver function prototypes */
#ifdef _WIN32
 #ifndef _WIN32_VXD

typedef LRESULT (CALLBACK* DRIVERPROC)(DWORD, HDRVR, UINT, LPARAM, LPARAM);

WINMMAPI LRESULT   WINAPI CloseDriver(HDRVR hDriver, LONG lParam1, LONG lParam2);
WINMMAPI HDRVR     WINAPI OpenDriver(LPCWSTR szDriverName, LPCWSTR szSectionName, LONG lParam2);
WINMMAPI LRESULT   WINAPI SendDriverMessage(HDRVR hDriver, UINT message, LONG lParam1, LONG lParam2);
WINMMAPI HMODULE   WINAPI DrvGetModuleHandle(HDRVR hDriver);
WINMMAPI HMODULE   WINAPI GetDriverModuleHandle(HDRVR hDriver);
WINMMAPI LRESULT   WINAPI DefDriverProc(DWORD dwDriverIdentifier, HDRVR hdrvr, UINT uMsg, LPARAM lParam1, LPARAM lParam2);
 #endif /* ifndef _WIN32_VXD */
#else
LRESULT   WINAPI DrvClose(HDRVR hdrvr, LPARAM lParam1, LPARAM lParam2);
HDRVR     WINAPI DrvOpen(LPCSTR szDriverName, LPCSTR szSectionName, LPARAM lParam2);
LRESULT   WINAPI DrvSendMessage(HDRVR hdrvr, UINT uMsg, LPARAM lParam1, LPARAM lParam2);
HINSTANCE WINAPI DrvGetModuleHandle(HDRVR hdrvr);
LRESULT   WINAPI DrvDefDriverProc(DWORD dwDriverIdentifier, HDRVR hdrvr, UINT uMsg, LPARAM lParam1, LPARAM lParam2);
#define DefDriverProc DrvDefDriverProc
#endif /* ifdef _WIN32 */
#endif /* DRV_LOAD */
#endif /* ifdef (WINVER < 0x030a) || defined(_WIN32) */

#if (WINVER >= 0x030a)
/* return values from DriverProc() function */
#define DRV_CANCEL             DRVCNF_CANCEL
#define DRV_OK                 DRVCNF_OK
#define DRV_RESTART            DRVCNF_RESTART

#endif /* ifdef WINVER >= 0x030a */

#define DRV_MCI_FIRST          DRV_RESERVED
#define DRV_MCI_LAST           (DRV_RESERVED + 0xFFF)

#endif  /* ifndef MMNODRV */

/****************************************************************************

			  Driver callback support

****************************************************************************/

/* flags used with waveOutOpen(), waveInOpen(), midiInOpen(), and */
/* midiOutOpen() to specify the type of the dwCallback parameter. */

#define CALLBACK_TYPEMASK   0x00070000l    /* callback type mask */
#define CALLBACK_NULL       0x00000000l    /* no callback */
#define CALLBACK_WINDOW     0x00010000l    /* dwCallback is a HWND */
#define CALLBACK_TASK       0x00020000l    /* dwCallback is a HTASK */
#define CALLBACK_FUNCTION   0x00030000l    /* dwCallback is a FARPROC */
#ifdef _WIN32
#define CALLBACK_THREAD     (CALLBACK_TASK)/* thread ID replaces 16 bit task */
#define CALLBACK_EVENT      0x00050000l    /* dwCallback is an EVENT Handle */
#endif

#ifndef _WIN32_VXD 

typedef void (CALLBACK DRVCALLBACK)(HDRVR hdrvr, UINT uMsg, DWORD dwUser, DWORD dw1, DWORD dw2);

typedef DRVCALLBACK FAR *LPDRVCALLBACK;
#ifdef _WIN32
typedef DRVCALLBACK     *PDRVCALLBACK;
#endif

#endif   /* ifndef _WIN32_VXD */ 

#ifndef MMNOMMSYSTEM
#ifndef _WIN32_VXD
/****************************************************************************

		    General MMSYSTEM support

****************************************************************************/

#if (WINVER <= 0x030A)
WINMMAPI UINT WINAPI mmsystemGetVersion(void);
#endif
#ifdef _WIN32
#define OutputDebugStr  OutputDebugString
#else
void WINAPI OutputDebugStr(LPCSTR);
#endif

#endif  /* ifndef _WIN32_VXD */
#endif  /* ifndef MMNOMMSYSTEM */

#ifndef MMNOSOUND
#ifndef _WIN32_VXD
/****************************************************************************

			    Sound support

****************************************************************************/

#ifdef _WIN32

WINMMAPI BOOL WINAPI sndPlaySoundA(LPCSTR pszSound, UINT fuSound);
WINMMAPI BOOL WINAPI sndPlaySoundW(LPCWSTR pszSound, UINT fuSound);
#ifdef UNICODE
#define sndPlaySound  sndPlaySoundW
#else
#define sndPlaySound  sndPlaySoundA
#endif // !UNICODE

#else
BOOL WINAPI sndPlaySound(LPCSTR pszSound, UINT fuSound);
#endif

/*
 *  flag values for fuSound and fdwSound arguments on [snd]PlaySound
 */
#define SND_SYNC            0x0000  /* play synchronously (default) */
#define SND_ASYNC           0x0001  /* play asynchronously */
#define SND_NODEFAULT       0x0002  /* silence (!default) if sound not found */
#define SND_MEMORY          0x0004  /* pszSound points to a memory file */
#define SND_LOOP            0x0008  /* loop the sound until next sndPlaySound */
#define SND_NOSTOP          0x0010  /* don't stop any currently playing sound */

#define SND_NOWAIT	0x00002000L /* don't wait if the driver is busy */
#define SND_ALIAS       0x00010000L /* name is a registry alias */
#define SND_ALIAS_ID	0x00110000L /* alias is a predefined ID */
#define SND_FILENAME    0x00020000L /* name is file name */
#define SND_RESOURCE    0x00040004L /* name is resource name or atom */
#if(WINVER >= 0x0400)
#define SND_PURGE           0x0040  /* purge non-static events for task */
#define SND_APPLICATION     0x0080  /* look for application specific association */
#endif /* WINVER >= 0x0400 */

#define SND_ALIAS_START	0           /* alias base */

#ifdef _WIN32
#define	sndAlias(ch0, ch1)	(SND_ALIAS_START + (DWORD)(BYTE)(ch0) | ((DWORD)(BYTE)(ch1) << 8))

#define SND_ALIAS_SYSTEMASTERISK        sndAlias('S', '*')
#define SND_ALIAS_SYSTEMQUESTION        sndAlias('S', '?')
#define SND_ALIAS_SYSTEMHAND            sndAlias('S', 'H')
#define SND_ALIAS_SYSTEMEXIT            sndAlias('S', 'E')
#define SND_ALIAS_SYSTEMSTART           sndAlias('S', 'S')
#define SND_ALIAS_SYSTEMWELCOME         sndAlias('S', 'W')
#define SND_ALIAS_SYSTEMEXCLAMATION     sndAlias('S', '!')
#define SND_ALIAS_SYSTEMDEFAULT         sndAlias('S', 'D')

WINMMAPI BOOL WINAPI PlaySoundA(LPCSTR pszSound, HMODULE hmod, DWORD fdwSound);
WINMMAPI BOOL WINAPI PlaySoundW(LPCWSTR pszSound, HMODULE hmod, DWORD fdwSound);
#ifdef UNICODE
#define PlaySound  PlaySoundW
#else
#define PlaySound  PlaySoundA
#endif // !UNICODE

#else
BOOL WINAPI PlaySound(LPCSTR pszSound, HMODULE hmod, DWORD fdwSound);
#endif

#endif  /* ifndef _WIN32_VXD */
#endif  /* ifndef MMNOSOUND */

#ifndef MMNOWAVE
/****************************************************************************

			Waveform audio support

****************************************************************************/

/* waveform audio error return values */
#define WAVERR_BADFORMAT      (WAVERR_BASE + 0)    /* unsupported wave format */
#define WAVERR_STILLPLAYING   (WAVERR_BASE + 1)    /* still something playing */
#define WAVERR_UNPREPARED     (WAVERR_BASE + 2)    /* header not prepared */
#define WAVERR_SYNC           (WAVERR_BASE + 3)    /* device is synchronous */
#define WAVERR_LASTERROR      (WAVERR_BASE + 3)    /* last error in range */

/* waveform audio data types */
DECLARE_HANDLE(HWAVE);
DECLARE_HANDLE(HWAVEIN);
DECLARE_HANDLE(HWAVEOUT);
#ifndef _WIN32_VXD
typedef HWAVEIN FAR *LPHWAVEIN;
typedef HWAVEOUT FAR *LPHWAVEOUT;
typedef DRVCALLBACK WAVECALLBACK;
typedef WAVECALLBACK FAR *LPWAVECALLBACK;
#endif

/* wave callback messages */
#define WOM_OPEN        MM_WOM_OPEN
#define WOM_CLOSE       MM_WOM_CLOSE
#define WOM_DONE        MM_WOM_DONE
#define WIM_OPEN        MM_WIM_OPEN
#define WIM_CLOSE       MM_WIM_CLOSE
#define WIM_DATA        MM_WIM_DATA

/* device ID for wave device mapper */
#define WAVE_MAPPER     ((UINT)-1)

/* flags for dwFlags parameter in waveOutOpen() and waveInOpen() */
#define  WAVE_FORMAT_QUERY         0x0001
#define  WAVE_ALLOWSYNC            0x0002
#if(WINVER >= 0x0400)
#define  WAVE_MAPPED               0x0004
#endif /* WINVER >= 0x0400 */

/* wave data block header */
typedef struct wavehdr_tag {
    LPSTR       lpData;                 /* pointer to locked data buffer */
    DWORD       dwBufferLength;         /* length of data buffer */
    DWORD       dwBytesRecorded;        /* used for input only */
    DWORD       dwUser;                 /* for client's use */
    DWORD       dwFlags;                /* assorted flags (see defines) */
    DWORD       dwLoops;                /* loop control counter */
    struct wavehdr_tag FAR *lpNext;     /* reserved for driver */
    DWORD       reserved;               /* reserved for driver */
} WAVEHDR, *PWAVEHDR, NEAR *NPWAVEHDR, FAR *LPWAVEHDR;

/* flags for dwFlags field of WAVEHDR */
#define WHDR_DONE       0x00000001  /* done bit */
#define WHDR_PREPARED   0x00000002  /* set if this header has been prepared */
#define WHDR_BEGINLOOP  0x00000004  /* loop start block */
#define WHDR_ENDLOOP    0x00000008  /* loop end block */
#define WHDR_INQUEUE    0x00000010  /* reserved for driver */

/* waveform output device capabilities structure */
#ifdef _WIN32

typedef struct tagWAVEOUTCAPSA {
    WORD    wMid;                  /* manufacturer ID */
    WORD    wPid;                  /* product ID */
    MMVERSION vDriverVersion;      /* version of the driver */
    CHAR    szPname[MAXPNAMELEN];  /* product name (NULL terminated string) */
    DWORD   dwFormats;             /* formats supported */
    WORD    wChannels;             /* number of sources supported */
    WORD    wReserved1;            /* packing */
    DWORD   dwSupport;             /* functionality supported by driver */
} WAVEOUTCAPSA, *PWAVEOUTCAPSA, *NPWAVEOUTCAPSA, *LPWAVEOUTCAPSA;
typedef struct tagWAVEOUTCAPSW {
    WORD    wMid;                  /* manufacturer ID */
    WORD    wPid;                  /* product ID */
    MMVERSION vDriverVersion;      /* version of the driver */
    WCHAR   szPname[MAXPNAMELEN];  /* product name (NULL terminated string) */
    DWORD   dwFormats;             /* formats supported */
    WORD    wChannels;             /* number of sources supported */
    WORD    wReserved1;            /* packing */
    DWORD   dwSupport;             /* functionality supported by driver */
} WAVEOUTCAPSW, *PWAVEOUTCAPSW, *NPWAVEOUTCAPSW, *LPWAVEOUTCAPSW;
#ifdef UNICODE
typedef WAVEOUTCAPSW WAVEOUTCAPS;
typedef PWAVEOUTCAPSW PWAVEOUTCAPS;
typedef NPWAVEOUTCAPSW NPWAVEOUTCAPS;
typedef LPWAVEOUTCAPSW LPWAVEOUTCAPS;
#else
typedef WAVEOUTCAPSA WAVEOUTCAPS;
typedef PWAVEOUTCAPSA PWAVEOUTCAPS;
typedef NPWAVEOUTCAPSA NPWAVEOUTCAPS;
typedef LPWAVEOUTCAPSA LPWAVEOUTCAPS;
#endif // UNICODE

#else
typedef struct waveoutcaps_tag {
    WORD    wMid;                  /* manufacturer ID */
    WORD    wPid;                  /* product ID */
    VERSION vDriverVersion;        /* version of the driver */
    char    szPname[MAXPNAMELEN];  /* product name (NULL terminated string) */
    DWORD   dwFormats;             /* formats supported */
    WORD    wChannels;             /* number of sources supported */
    DWORD   dwSupport;             /* functionality supported by driver */
} WAVEOUTCAPS, *PWAVEOUTCAPS, NEAR *NPWAVEOUTCAPS, FAR *LPWAVEOUTCAPS;
#endif

/* flags for dwSupport field of WAVEOUTCAPS */
#define WAVECAPS_PITCH          0x0001   /* supports pitch control */
#define WAVECAPS_PLAYBACKRATE   0x0002   /* supports playback rate control */
#define WAVECAPS_VOLUME         0x0004   /* supports volume control */
#define WAVECAPS_LRVOLUME       0x0008   /* separate left-right volume control */
#define WAVECAPS_SYNC           0x0010
#define WAVECAPS_SAMPLEACCURATE 0x0020
#define WAVECAPS_DIRECTSOUND    0x0040

/* waveform input device capabilities structure */
#ifdef _WIN32

typedef struct tagWAVEINCAPSA {
    WORD    wMid;                    /* manufacturer ID */
    WORD    wPid;                    /* product ID */
    MMVERSION vDriverVersion;        /* version of the driver */
    CHAR    szPname[MAXPNAMELEN];    /* product name (NULL terminated string) */
    DWORD   dwFormats;               /* formats supported */
    WORD    wChannels;               /* number of channels supported */
    WORD    wReserved1;              /* structure packing */
} WAVEINCAPSA, *PWAVEINCAPSA, *NPWAVEINCAPSA, *LPWAVEINCAPSA;
typedef struct tagWAVEINCAPSW {
    WORD    wMid;                    /* manufacturer ID */
    WORD    wPid;                    /* product ID */
    MMVERSION vDriverVersion;        /* version of the driver */
    WCHAR   szPname[MAXPNAMELEN];    /* product name (NULL terminated string) */
    DWORD   dwFormats;               /* formats supported */
    WORD    wChannels;               /* number of channels supported */
    WORD    wReserved1;              /* structure packing */
} WAVEINCAPSW, *PWAVEINCAPSW, *NPWAVEINCAPSW, *LPWAVEINCAPSW;
#ifdef UNICODE
typedef WAVEINCAPSW WAVEINCAPS;
typedef PWAVEINCAPSW PWAVEINCAPS;
typedef NPWAVEINCAPSW NPWAVEINCAPS;
typedef LPWAVEINCAPSW LPWAVEINCAPS;
#else
typedef WAVEINCAPSA WAVEINCAPS;
typedef PWAVEINCAPSA PWAVEINCAPS;
typedef NPWAVEINCAPSA NPWAVEINCAPS;
typedef LPWAVEINCAPSA LPWAVEINCAPS;
#endif // UNICODE

#else
typedef struct waveincaps_tag {
    WORD    wMid;                    /* manufacturer ID */
    WORD    wPid;                    /* product ID */
    VERSION vDriverVersion;          /* version of the driver */
    char    szPname[MAXPNAMELEN];    /* product name (NULL terminated string) */
    DWORD   dwFormats;               /* formats supported */
    WORD    wChannels;               /* number of channels supported */
} WAVEINCAPS, *PWAVEINCAPS, NEAR *NPWAVEINCAPS, FAR *LPWAVEINCAPS;
#endif

/* defines for dwFormat field of WAVEINCAPS and WAVEOUTCAPS */
#define WAVE_INVALIDFORMAT     0x00000000       /* invalid format */
#define WAVE_FORMAT_1M08       0x00000001       /* 11.025 kHz, Mono,   8-bit  */
#define WAVE_FORMAT_1S08       0x00000002       /* 11.025 kHz, Stereo, 8-bit  */
#define WAVE_FORMAT_1M16       0x00000004       /* 11.025 kHz, Mono,   16-bit */
#define WAVE_FORMAT_1S16       0x00000008       /* 11.025 kHz, Stereo, 16-bit */
#define WAVE_FORMAT_2M08       0x00000010       /* 22.05  kHz, Mono,   8-bit  */
#define WAVE_FORMAT_2S08       0x00000020       /* 22.05  kHz, Stereo, 8-bit  */
#define WAVE_FORMAT_2M16       0x00000040       /* 22.05  kHz, Mono,   16-bit */
#define WAVE_FORMAT_2S16       0x00000080       /* 22.05  kHz, Stereo, 16-bit */
#define WAVE_FORMAT_4M08       0x00000100       /* 44.1   kHz, Mono,   8-bit  */
#define WAVE_FORMAT_4S08       0x00000200       /* 44.1   kHz, Stereo, 8-bit  */
#define WAVE_FORMAT_4M16       0x00000400       /* 44.1   kHz, Mono,   16-bit */
#define WAVE_FORMAT_4S16       0x00000800       /* 44.1   kHz, Stereo, 16-bit */

/* OLD general waveform format structure (information common to all formats) */
typedef struct waveformat_tag {
    WORD    wFormatTag;        /* format type */
    WORD    nChannels;         /* number of channels (i.e. mono, stereo, etc.) */
    DWORD   nSamplesPerSec;    /* sample rate */
    DWORD   nAvgBytesPerSec;   /* for buffer estimation */
    WORD    nBlockAlign;       /* block size of data */
} WAVEFORMAT, *PWAVEFORMAT, NEAR *NPWAVEFORMAT, FAR *LPWAVEFORMAT;

/* flags for wFormatTag field of WAVEFORMAT */
#define WAVE_FORMAT_PCM     1

/* specific waveform format structure for PCM data */
typedef struct pcmwaveformat_tag {
    WAVEFORMAT  wf;
    WORD        wBitsPerSample;
} PCMWAVEFORMAT, *PPCMWAVEFORMAT, NEAR *NPPCMWAVEFORMAT, FAR *LPPCMWAVEFORMAT;

#ifndef _WAVEFORMATEX_
#define _WAVEFORMATEX_

/*
 *  extended waveform format structure used for all non-PCM formats. this
 *  structure is common to all non-PCM formats.
 */
typedef struct tWAVEFORMATEX
{
    WORD        wFormatTag;         /* format type */
    WORD        nChannels;          /* number of channels (i.e. mono, stereo...) */
    DWORD       nSamplesPerSec;     /* sample rate */
    DWORD       nAvgBytesPerSec;    /* for buffer estimation */
    WORD        nBlockAlign;        /* block size of data */
    WORD        wBitsPerSample;     /* number of bits per sample of mono data */
    WORD        cbSize;             /* the count in bytes of the size of */
				    /* extra information (after cbSize) */
} WAVEFORMATEX, *PWAVEFORMATEX, NEAR *NPWAVEFORMATEX, FAR *LPWAVEFORMATEX;
typedef const WAVEFORMATEX FAR *LPCWAVEFORMATEX;

#endif /* _WAVEFORMATEX_ */

#ifndef _WIN32_VXD
/* waveform audio function prototypes */
WINMMAPI UINT WINAPI waveOutGetNumDevs(void);

#ifdef _WIN32

WINMMAPI MMRESULT WINAPI waveOutGetDevCapsA(UINT uDeviceID, LPWAVEOUTCAPSA pwoc, UINT cbwoc);
WINMMAPI MMRESULT WINAPI waveOutGetDevCapsW(UINT uDeviceID, LPWAVEOUTCAPSW pwoc, UINT cbwoc);
#ifdef UNICODE
#define waveOutGetDevCaps  waveOutGetDevCapsW
#else
#define waveOutGetDevCaps  waveOutGetDevCapsA
#endif // !UNICODE

#else
WINMMAPI MMRESULT WINAPI waveOutGetDevCaps(UINT uDeviceID, LPWAVEOUTCAPS pwoc, UINT cbwoc);
#endif

#if (WINVER >= 0x0400)
WINMMAPI MMRESULT WINAPI waveOutGetVolume(HWAVEOUT hwo, LPDWORD pdwVolume);
WINMMAPI MMRESULT WINAPI waveOutSetVolume(HWAVEOUT hwo, DWORD dwVolume);
#else
WINMMAPI MMRESULT WINAPI waveOutGetVolume(UINT uId, LPDWORD pdwVolume);
WINMMAPI MMRESULT WINAPI waveOutSetVolume(UINT uId, DWORD dwVolume);
#endif

#ifdef _WIN32

WINMMAPI MMRESULT WINAPI waveOutGetErrorTextA(MMRESULT mmrError, LPSTR pszText, UINT cchText);
WINMMAPI MMRESULT WINAPI waveOutGetErrorTextW(MMRESULT mmrError, LPWSTR pszText, UINT cchText);
#ifdef UNICODE
#define waveOutGetErrorText  waveOutGetErrorTextW
#else
#define waveOutGetErrorText  waveOutGetErrorTextA
#endif // !UNICODE

#else
MMRESULT WINAPI waveOutGetErrorText(MMRESULT mmrError, LPSTR pszText, UINT cchText);
#endif

WINMMAPI MMRESULT WINAPI waveOutOpen(LPHWAVEOUT phwo, UINT uDeviceID,
    LPCWAVEFORMATEX pwfx, DWORD dwCallback, DWORD dwInstance, DWORD fdwOpen);

WINMMAPI MMRESULT WINAPI waveOutClose(HWAVEOUT hwo);
WINMMAPI MMRESULT WINAPI waveOutPrepareHeader(HWAVEOUT hwo, LPWAVEHDR pwh, UINT cbwh);
WINMMAPI MMRESULT WINAPI waveOutUnprepareHeader(HWAVEOUT hwo, LPWAVEHDR pwh, UINT cbwh);
WINMMAPI MMRESULT WINAPI waveOutWrite(HWAVEOUT hwo, LPWAVEHDR pwh, UINT cbwh);
WINMMAPI MMRESULT WINAPI waveOutPause(HWAVEOUT hwo);
WINMMAPI MMRESULT WINAPI waveOutRestart(HWAVEOUT hwo);
WINMMAPI MMRESULT WINAPI waveOutReset(HWAVEOUT hwo);
WINMMAPI MMRESULT WINAPI waveOutBreakLoop(HWAVEOUT hwo);
WINMMAPI MMRESULT WINAPI waveOutGetPosition(HWAVEOUT hwo, LPMMTIME pmmt, UINT cbmmt);
WINMMAPI MMRESULT WINAPI waveOutGetPitch(HWAVEOUT hwo, LPDWORD pdwPitch);
WINMMAPI MMRESULT WINAPI waveOutSetPitch(HWAVEOUT hwo, DWORD dwPitch);
WINMMAPI MMRESULT WINAPI waveOutGetPlaybackRate(HWAVEOUT hwo, LPDWORD pdwRate);
WINMMAPI MMRESULT WINAPI waveOutSetPlaybackRate(HWAVEOUT hwo, DWORD dwRate);
WINMMAPI MMRESULT WINAPI waveOutGetID(HWAVEOUT hwo, LPUINT puDeviceID);

#if (WINVER >= 0x030a)
#ifdef _WIN32
WINMMAPI MMRESULT WINAPI waveOutMessage(HWAVEOUT hwo, UINT uMsg, DWORD dw1, DWORD dw2);
#else
DWORD WINAPI waveOutMessage(HWAVEOUT hwo, UINT uMsg, DWORD dw1, DWORD dw2);
#endif
#endif /* ifdef WINVER >= 0x030a */

WINMMAPI UINT WINAPI waveInGetNumDevs(void);

#ifdef _WIN32

WINMMAPI MMRESULT WINAPI waveInGetDevCapsA(UINT uDeviceID, LPWAVEINCAPSA pwic, UINT cbwic);
WINMMAPI MMRESULT WINAPI waveInGetDevCapsW(UINT uDeviceID, LPWAVEINCAPSW pwic, UINT cbwic);
#ifdef UNICODE
#define waveInGetDevCaps  waveInGetDevCapsW
#else
#define waveInGetDevCaps  waveInGetDevCapsA
#endif // !UNICODE

#else
MMRESULT WINAPI waveInGetDevCaps(UINT uDeviceID, LPWAVEINCAPS pwic, UINT cbwic);
#endif

#ifdef _WIN32

WINMMAPI MMRESULT WINAPI waveInGetErrorTextA(MMRESULT mmrError, LPSTR pszText, UINT cchText);
WINMMAPI MMRESULT WINAPI waveInGetErrorTextW(MMRESULT mmrError, LPWSTR pszText, UINT cchText);
#ifdef UNICODE
#define waveInGetErrorText  waveInGetErrorTextW
#else
#define waveInGetErrorText  waveInGetErrorTextA
#endif // !UNICODE

#else
MMRESULT WINAPI waveInGetErrorText(MMRESULT mmrError, LPSTR pszText, UINT cchText);
#endif

WINMMAPI MMRESULT WINAPI waveInOpen(LPHWAVEIN phwi, UINT uDeviceID,
    LPCWAVEFORMATEX pwfx, DWORD dwCallback, DWORD dwInstance, DWORD fdwOpen);

WINMMAPI MMRESULT WINAPI waveInClose(HWAVEIN hwi);
WINMMAPI MMRESULT WINAPI waveInPrepareHeader(HWAVEIN hwi, LPWAVEHDR pwh, UINT cbwh);
WINMMAPI MMRESULT WINAPI waveInUnprepareHeader(HWAVEIN hwi, LPWAVEHDR pwh, UINT cbwh);
WINMMAPI MMRESULT WINAPI waveInAddBuffer(HWAVEIN hwi, LPWAVEHDR pwh, UINT cbwh);
WINMMAPI MMRESULT WINAPI waveInStart(HWAVEIN hwi);
WINMMAPI MMRESULT WINAPI waveInStop(HWAVEIN hwi);
WINMMAPI MMRESULT WINAPI waveInReset(HWAVEIN hwi);
WINMMAPI MMRESULT WINAPI waveInGetPosition(HWAVEIN hwi, LPMMTIME pmmt, UINT cbmmt);
WINMMAPI MMRESULT WINAPI waveInGetID(HWAVEIN hwi, LPUINT puDeviceID);

#if (WINVER >= 0x030a)
#ifdef _WIN32
WINMMAPI MMRESULT WINAPI waveInMessage(HWAVEIN hwi, UINT uMsg, DWORD dw1, DWORD dw2);
#else
DWORD WINAPI waveInMessage(HWAVEIN hwi, UINT uMsg, DWORD dw1, DWORD dw2);
#endif
#endif /* ifdef WINVER >= 0x030a */

#endif /* ifndef _WIN32_VXD */

#endif  /* ifndef MMNOWAVE */

#ifndef MMNOMIDI
/****************************************************************************

			    MIDI audio support

****************************************************************************/

/* MIDI error return values */
#define MIDIERR_UNPREPARED    (MIDIERR_BASE + 0)   /* header not prepared */
#define MIDIERR_STILLPLAYING  (MIDIERR_BASE + 1)   /* still something playing */
#define MIDIERR_NOMAP         (MIDIERR_BASE + 2)   /* no configured instruments */
#define MIDIERR_NOTREADY      (MIDIERR_BASE + 3)   /* hardware is still busy */
#define MIDIERR_NODEVICE      (MIDIERR_BASE + 4)   /* port no longer connected */
#define MIDIERR_INVALIDSETUP  (MIDIERR_BASE + 5)   /* invalid MIF */
#define MIDIERR_BADOPENMODE   (MIDIERR_BASE + 6)   /* operation unsupported w/ open mode */
#define MIDIERR_DONT_CONTINUE (MIDIERR_BASE + 7)   /* thru device 'eating' a message */
#define MIDIERR_LASTERROR     (MIDIERR_BASE + 7)   /* last error in range */

/* MIDI audio data types */
DECLARE_HANDLE(HMIDI);
DECLARE_HANDLE(HMIDIIN);
DECLARE_HANDLE(HMIDIOUT);
DECLARE_HANDLE(HMIDISTRM);
#ifndef _WIN32_VXD
typedef HMIDI FAR *LPHMIDI;
typedef HMIDIIN FAR *LPHMIDIIN;
typedef HMIDIOUT FAR *LPHMIDIOUT;
typedef HMIDISTRM FAR *LPHMIDISTRM;
typedef DRVCALLBACK MIDICALLBACK;
typedef MIDICALLBACK FAR *LPMIDICALLBACK;
#define MIDIPATCHSIZE   128
typedef WORD PATCHARRAY[MIDIPATCHSIZE];
typedef WORD FAR *LPPATCHARRAY;
typedef WORD KEYARRAY[MIDIPATCHSIZE];
typedef WORD FAR *LPKEYARRAY;
#endif  /* ifndef _WIN32_VXD */

/* MIDI callback messages */
#define MIM_OPEN        MM_MIM_OPEN
#define MIM_CLOSE       MM_MIM_CLOSE
#define MIM_DATA        MM_MIM_DATA
#define MIM_LONGDATA    MM_MIM_LONGDATA
#define MIM_ERROR       MM_MIM_ERROR
#define MIM_LONGERROR   MM_MIM_LONGERROR
#define MOM_OPEN        MM_MOM_OPEN
#define MOM_CLOSE       MM_MOM_CLOSE
#define MOM_DONE        MM_MOM_DONE

#if(WINVER >= 0x0400)
#define MIM_MOREDATA      MM_MIM_MOREDATA
#define MOM_POSITIONCB    MM_MOM_POSITIONCB
#endif /* WINVER >= 0x0400 */

/* device ID for MIDI mapper */
#define MIDIMAPPER     ((UINT)-1)
#define MIDI_MAPPER    ((UINT)-1)

#if(WINVER >= 0x0400)
/* flags for dwFlags parm of midiInOpen() */
#define MIDI_IO_STATUS      0x00000020L
#endif /* WINVER >= 0x0400 */

/* flags for wFlags parm of midiOutCachePatches(), midiOutCacheDrumPatches() */
#define MIDI_CACHE_ALL      1
#define MIDI_CACHE_BESTFIT  2
#define MIDI_CACHE_QUERY    3
#define MIDI_UNCACHE        4

/* MIDI output device capabilities structure */
#ifdef _WIN32

typedef struct tagMIDIOUTCAPSA {
    WORD    wMid;                  /* manufacturer ID */
    WORD    wPid;                  /* product ID */
    MMVERSION vDriverVersion;      /* version of the driver */
    CHAR    szPname[MAXPNAMELEN];  /* product name (NULL terminated string) */
    WORD    wTechnology;           /* type of device */
    WORD    wVoices;               /* # of voices (internal synth only) */
    WORD    wNotes;                /* max # of notes (internal synth only) */
    WORD    wChannelMask;          /* channels used (internal synth only) */
    DWORD   dwSupport;             /* functionality supported by driver */
} MIDIOUTCAPSA, *PMIDIOUTCAPSA, *NPMIDIOUTCAPSA, *LPMIDIOUTCAPSA;
typedef struct tagMIDIOUTCAPSW {
    WORD    wMid;                  /* manufacturer ID */
    WORD    wPid;                  /* product ID */
    MMVERSION vDriverVersion;      /* version of the driver */
    WCHAR   szPname[MAXPNAMELEN];  /* product name (NULL terminated string) */
    WORD    wTechnology;           /* type of device */
    WORD    wVoices;               /* # of voices (internal synth only) */
    WORD    wNotes;                /* max # of notes (internal synth only) */
    WORD    wChannelMask;          /* channels used (internal synth only) */
    DWORD   dwSupport;             /* functionality supported by driver */
} MIDIOUTCAPSW, *PMIDIOUTCAPSW, *NPMIDIOUTCAPSW, *LPMIDIOUTCAPSW;
#ifdef UNICODE
typedef MIDIOUTCAPSW MIDIOUTCAPS;
typedef PMIDIOUTCAPSW PMIDIOUTCAPS;
typedef NPMIDIOUTCAPSW NPMIDIOUTCAPS;
typedef LPMIDIOUTCAPSW LPMIDIOUTCAPS;
#else
typedef MIDIOUTCAPSA MIDIOUTCAPS;
typedef PMIDIOUTCAPSA PMIDIOUTCAPS;
typedef NPMIDIOUTCAPSA NPMIDIOUTCAPS;
typedef LPMIDIOUTCAPSA LPMIDIOUTCAPS;
#endif // UNICODE

#else
typedef struct midioutcaps_tag {
    WORD    wMid;                  /* manufacturer ID */
    WORD    wPid;                  /* product ID */
    VERSION vDriverVersion;        /* version of the driver */
    char    szPname[MAXPNAMELEN];  /* product name (NULL terminated string) */
    WORD    wTechnology;           /* type of device */
    WORD    wVoices;               /* # of voices (internal synth only) */
    WORD    wNotes;                /* max # of notes (internal synth only) */
    WORD    wChannelMask;          /* channels used (internal synth only) */
    DWORD   dwSupport;             /* functionality supported by driver */
} MIDIOUTCAPS, *PMIDIOUTCAPS, NEAR *NPMIDIOUTCAPS, FAR *LPMIDIOUTCAPS;
#endif

/* flags for wTechnology field of MIDIOUTCAPS structure */
#define MOD_MIDIPORT    1  /* output port */
#define MOD_SYNTH       2  /* generic internal synth */
#define MOD_SQSYNTH     3  /* square wave internal synth */
#define MOD_FMSYNTH     4  /* FM internal synth */
#define MOD_MAPPER      5  /* MIDI mapper */

/* flags for dwSupport field of MIDIOUTCAPS structure */
#define MIDICAPS_VOLUME          0x0001  /* supports volume control */
#define MIDICAPS_LRVOLUME        0x0002  /* separate left-right volume control */
#define MIDICAPS_CACHE           0x0004
#if(WINVER >= 0x0400)
#define MIDICAPS_STREAM          0x0008  /* driver supports midiStreamOut directly */
#endif /* WINVER >= 0x0400 */

/* MIDI input device capabilities structure */
#ifdef _WIN32

typedef struct tagMIDIINCAPSA {
    WORD        wMid;                   /* manufacturer ID */
    WORD        wPid;                   /* product ID */
    MMVERSION   vDriverVersion;         /* version of the driver */
    CHAR        szPname[MAXPNAMELEN];   /* product name (NULL terminated string) */
#if (WINVER >= 0x0400)
    DWORD   dwSupport;             /* functionality supported by driver */
#endif
} MIDIINCAPSA, *PMIDIINCAPSA, *NPMIDIINCAPSA, *LPMIDIINCAPSA;
typedef struct tagMIDIINCAPSW {
    WORD        wMid;                   /* manufacturer ID */
    WORD        wPid;                   /* product ID */
    MMVERSION   vDriverVersion;         /* version of the driver */
    WCHAR       szPname[MAXPNAMELEN];   /* product name (NULL terminated string) */
#if (WINVER >= 0x0400)
    DWORD   dwSupport;             /* functionality supported by driver */
#endif
} MIDIINCAPSW, *PMIDIINCAPSW, *NPMIDIINCAPSW, *LPMIDIINCAPSW;
#ifdef UNICODE
typedef MIDIINCAPSW MIDIINCAPS;
typedef PMIDIINCAPSW PMIDIINCAPS;
typedef NPMIDIINCAPSW NPMIDIINCAPS;
typedef LPMIDIINCAPSW LPMIDIINCAPS;
#else
typedef MIDIINCAPSA MIDIINCAPS;
typedef PMIDIINCAPSA PMIDIINCAPS;
typedef NPMIDIINCAPSA NPMIDIINCAPS;
typedef LPMIDIINCAPSA LPMIDIINCAPS;
#endif // UNICODE

#else
typedef struct midiincaps_tag {
    WORD    wMid;                  /* manufacturer ID */
    WORD    wPid;                  /* product ID */
    VERSION vDriverVersion;        /* version of the driver */
    char    szPname[MAXPNAMELEN];  /* product name (NULL terminated string) */
#if (WINVER >= 0x0400)
    DWORD   dwSupport;             /* functionality supported by driver */
#endif
} MIDIINCAPS, *PMIDIINCAPS, NEAR *NPMIDIINCAPS, FAR *LPMIDIINCAPS;
#endif

/* MIDI data block header */
typedef struct midihdr_tag {
    LPSTR       lpData;               /* pointer to locked data block */
    DWORD       dwBufferLength;       /* length of data in data block */
    DWORD       dwBytesRecorded;      /* used for input only */
    DWORD       dwUser;               /* for client's use */
    DWORD       dwFlags;              /* assorted flags (see defines) */
    struct midihdr_tag FAR *lpNext;   /* reserved for driver */
    DWORD       reserved;             /* reserved for driver */
#if (WINVER >= 0x0400)
    DWORD       dwOffset;             /* Callback offset into buffer */
    DWORD       dwReserved[8];        /* Reserved for MMSYSTEM */
#endif
} MIDIHDR, *PMIDIHDR, NEAR *NPMIDIHDR, FAR *LPMIDIHDR;

#if(WINVER >= 0x0400)
typedef struct midievent_tag
{
    DWORD       dwDeltaTime;          /* Ticks since last event */
    DWORD       dwStreamID;           /* Reserved; must be zero */
    DWORD       dwEvent;              /* Event type and parameters */
    DWORD       dwParms[1];           /* Parameters if this is a long event */
} MIDIEVENT;

typedef struct midistrmbuffver_tag
{
    DWORD       dwVersion;                  /* Stream buffer format version */
    DWORD       dwMid;                      /* Manufacturer ID as defined in MMREG.H */
    DWORD       dwOEMVersion;               /* Manufacturer version for custom ext */
} MIDISTRMBUFFVER;
#endif /* WINVER >= 0x0400 */

/* flags for dwFlags field of MIDIHDR structure */
#define MHDR_DONE       0x00000001       /* done bit */
#define MHDR_PREPARED   0x00000002       /* set if header prepared */
#define MHDR_INQUEUE    0x00000004       /* reserved for driver */
#define MHDR_ISSTRM     0x00000008       /* Buffer is stream buffer */

#if(WINVER >= 0x0400)
/* */
/* Type codes which go in the high byte of the event DWORD of a stream buffer */
/* */
/* Type codes 00-7F contain parameters within the low 24 bits */
/* Type codes 80-FF contain a length of their parameter in the low 24 */
/* bits, followed by their parameter data in the buffer. The event */
/* DWORD contains the exact byte length; the parm data itself must be */
/* padded to be an even multiple of 4 bytes long. */
/* */

#define MEVT_F_SHORT        0x00000000L
#define MEVT_F_LONG         0x80000000L
#define MEVT_F_CALLBACK     0x40000000L

#define MEVT_EVENTTYPE(x)   ((BYTE)(((x)>>24)&0xFF))
#define MEVT_EVENTPARM(x)   ((DWORD)((x)&0x00FFFFFFL))

#define MEVT_SHORTMSG       ((BYTE)0x00)    /* parm = shortmsg for midiOutShortMsg */
#define MEVT_TEMPO          ((BYTE)0x01)    /* parm = new tempo in microsec/qn     */
#define MEVT_NOP            ((BYTE)0x02)    /* parm = unused; does nothing         */

/* 0x04-0x7F reserved */

#define MEVT_LONGMSG        ((BYTE)0x80)    /* parm = bytes to send verbatim       */
#define MEVT_COMMENT        ((BYTE)0x82)    /* parm = comment data                 */
#define MEVT_VERSION        ((BYTE)0x84)    /* parm = MIDISTRMBUFFVER struct       */

/* 0x81-0xFF reserved */

#define MIDISTRM_ERROR      (-2)

/* */
/* Structures and defines for midiStreamProperty */
/* */
#define MIDIPROP_SET        0x80000000L
#define MIDIPROP_GET        0x40000000L

/* These are intentionally both non-zero so the app cannot accidentally */
/* leave the operation off and happen to appear to work due to default */
/* action. */

#define MIDIPROP_TIMEDIV    0x00000001L
#define MIDIPROP_TEMPO      0x00000002L

typedef struct midiproptimediv_tag
{
    DWORD       cbStruct;
    DWORD       dwTimeDiv;
} MIDIPROPTIMEDIV, FAR *LPMIDIPROPTIMEDIV;

typedef struct midiproptempo_tag
{
    DWORD       cbStruct;
    DWORD       dwTempo;
} MIDIPROPTEMPO, FAR *LPMIDIPROPTEMPO;

#endif /* WINVER >= 0x0400 */

#ifndef _WIN32_VXD

/* MIDI function prototypes */
WINMMAPI UINT WINAPI midiOutGetNumDevs(void);
#if(WINVER >= 0x0400)
WINMMAPI MMRESULT WINAPI midiStreamOpen(LPHMIDISTRM phms, LPUINT puDeviceID, DWORD cMidi, DWORD dwCallback, DWORD dwInstance, DWORD fdwOpen);
WINMMAPI MMRESULT WINAPI midiStreamClose(HMIDISTRM hms);

WINMMAPI MMRESULT WINAPI midiStreamProperty(HMIDISTRM hms, LPBYTE lppropdata, DWORD dwProperty);
WINMMAPI MMRESULT WINAPI midiStreamPosition(HMIDISTRM hms, LPMMTIME lpmmt, UINT cbmmt);

WINMMAPI MMRESULT WINAPI midiStreamOut(HMIDISTRM hms, LPMIDIHDR pmh, UINT cbmh);
WINMMAPI MMRESULT WINAPI midiStreamPause(HMIDISTRM hms);
WINMMAPI MMRESULT WINAPI midiStreamRestart(HMIDISTRM hms);
WINMMAPI MMRESULT WINAPI midiStreamStop(HMIDISTRM hms);

#ifdef _WIN32
WINMMAPI MMRESULT WINAPI midiConnect(HMIDI hmi, HMIDIOUT hmo, LPVOID pReserved);
WINMMAPI MMRESULT WINAPI midiDisconnect(HMIDI hmi, HMIDIOUT hmo, LPVOID pReserved);
#endif
#endif /* WINVER >= 0x0400 */

#ifdef _WIN32

WINMMAPI MMRESULT WINAPI midiOutGetDevCapsA(UINT uDeviceID, LPMIDIOUTCAPSA pmoc, UINT cbmoc);
WINMMAPI MMRESULT WINAPI midiOutGetDevCapsW(UINT uDeviceID, LPMIDIOUTCAPSW pmoc, UINT cbmoc);
#ifdef UNICODE
#define midiOutGetDevCaps  midiOutGetDevCapsW
#else
#define midiOutGetDevCaps  midiOutGetDevCapsA
#endif // !UNICODE

#else
MMRESULT WINAPI midiOutGetDevCaps(UINT uDeviceID, LPMIDIOUTCAPS pmoc, UINT cbmoc);
#endif

#if (WINVER >= 0x0400)
WINMMAPI MMRESULT WINAPI midiOutGetVolume(HMIDIOUT hmo, LPDWORD pdwVolume);
WINMMAPI MMRESULT WINAPI midiOutSetVolume(HMIDIOUT hmo, DWORD dwVolume);
#else
WINMMAPI MMRESULT WINAPI midiOutGetVolume(UINT uId, LPDWORD pdwVolume);
WINMMAPI MMRESULT WINAPI midiOutSetVolume(UINT uId, DWORD dwVolume);
#endif

#ifdef _WIN32

WINMMAPI MMRESULT WINAPI midiOutGetErrorTextA(MMRESULT mmrError, LPSTR pszText, UINT cchText);
WINMMAPI MMRESULT WINAPI midiOutGetErrorTextW(MMRESULT mmrError, LPWSTR pszText, UINT cchText);
#ifdef UNICODE
#define midiOutGetErrorText  midiOutGetErrorTextW
#else
#define midiOutGetErrorText  midiOutGetErrorTextA
#endif // !UNICODE

#else
WINMMAPI MMRESULT WINAPI midiOutGetErrorText(MMRESULT mmrError, LPSTR pszText, UINT cchText);
#endif

WINMMAPI MMRESULT WINAPI midiOutOpen(LPHMIDIOUT phmo, UINT uDeviceID,
    DWORD dwCallback, DWORD dwInstance, DWORD fdwOpen);
WINMMAPI MMRESULT WINAPI midiOutClose(HMIDIOUT hmo);
WINMMAPI MMRESULT WINAPI midiOutPrepareHeader(HMIDIOUT hmo, LPMIDIHDR pmh, UINT cbmh);
WINMMAPI MMRESULT WINAPI midiOutUnprepareHeader(HMIDIOUT hmo, LPMIDIHDR pmh, UINT cbmh);
WINMMAPI MMRESULT WINAPI midiOutShortMsg(HMIDIOUT hmo, DWORD dwMsg);
WINMMAPI MMRESULT WINAPI midiOutLongMsg(HMIDIOUT hmo, LPMIDIHDR pmh, UINT cbmh);
WINMMAPI MMRESULT WINAPI midiOutReset(HMIDIOUT hmo);
WINMMAPI MMRESULT WINAPI midiOutCachePatches(HMIDIOUT hmo, UINT uBank, LPWORD pwpa, UINT fuCache);
WINMMAPI MMRESULT WINAPI midiOutCacheDrumPatches(HMIDIOUT hmo, UINT uPatch, LPWORD pwkya, UINT fuCache);
WINMMAPI MMRESULT WINAPI midiOutGetID(HMIDIOUT hmo, LPUINT puDeviceID);

#if (WINVER >= 0x030a)
#ifdef _WIN32
WINMMAPI MMRESULT WINAPI midiOutMessage(HMIDIOUT hmo, UINT uMsg, DWORD dw1, DWORD dw2);
#else
DWORD WINAPI midiOutMessage(HMIDIOUT hmo, UINT uMsg, DWORD dw1, DWORD dw2);
#endif
#endif /* ifdef WINVER >= 0x030a */

WINMMAPI UINT WINAPI midiInGetNumDevs(void);

#ifdef _WIN32

WINMMAPI MMRESULT WINAPI midiInGetDevCapsA(UINT uDeviceID, LPMIDIINCAPSA pmic, UINT cbmic);
WINMMAPI MMRESULT WINAPI midiInGetDevCapsW(UINT uDeviceID, LPMIDIINCAPSW pmic, UINT cbmic);
#ifdef UNICODE
#define midiInGetDevCaps  midiInGetDevCapsW
#else
#define midiInGetDevCaps  midiInGetDevCapsA
#endif // !UNICODE
WINMMAPI MMRESULT WINAPI midiInGetErrorTextA(MMRESULT mmrError, LPSTR pszText, UINT cchText);
WINMMAPI MMRESULT WINAPI midiInGetErrorTextW(MMRESULT mmrError, LPWSTR pszText, UINT cchText);
#ifdef UNICODE
#define midiInGetErrorText  midiInGetErrorTextW
#else
#define midiInGetErrorText  midiInGetErrorTextA
#endif // !UNICODE

#else
MMRESULT WINAPI midiInGetDevCaps(UINT uDeviceID, LPMIDIINCAPS pmic, UINT cbmic);
WINMMAPI MMRESULT WINAPI midiInGetErrorText(MMRESULT mmrError, LPSTR pszText, UINT cchText);
#endif

WINMMAPI MMRESULT WINAPI midiInOpen(LPHMIDIIN phmi, UINT uDeviceID,
	DWORD dwCallback, DWORD dwInstance, DWORD fdwOpen);
WINMMAPI MMRESULT WINAPI midiInClose(HMIDIIN hmi);
WINMMAPI MMRESULT WINAPI midiInPrepareHeader(HMIDIIN hmi, LPMIDIHDR pmh, UINT cbmh);
WINMMAPI MMRESULT WINAPI midiInUnprepareHeader(HMIDIIN hmi, LPMIDIHDR pmh, UINT cbmh);
WINMMAPI MMRESULT WINAPI midiInAddBuffer(HMIDIIN hmi, LPMIDIHDR pmh, UINT cbmh);
WINMMAPI MMRESULT WINAPI midiInStart(HMIDIIN hmi);
WINMMAPI MMRESULT WINAPI midiInStop(HMIDIIN hmi);
WINMMAPI MMRESULT WINAPI midiInReset(HMIDIIN hmi);
WINMMAPI MMRESULT WINAPI midiInGetID(HMIDIIN hmi, LPUINT puDeviceID);

#if (WINVER >= 0x030a)
#ifdef _WIN32
WINMMAPI MMRESULT WINAPI midiInMessage(HMIDIIN hmi, UINT uMsg, DWORD dw1, DWORD dw2);
#else
DWORD WINAPI midiInMessage(HMIDIIN hmi, UINT uMsg, DWORD dw1, DWORD dw2);
#endif
#endif /* ifdef WINVER >= 0x030a */

#endif /* ifndef _WIN32_VXD */

#endif  /* ifndef MMNOMIDI */

#ifndef MMNOAUX
/****************************************************************************

			Auxiliary audio support

****************************************************************************/

/* device ID for aux device mapper */
#define AUX_MAPPER     ((UINT)-1)

/* Auxiliary audio device capabilities structure */
#ifdef _WIN32

typedef struct tagAUXCAPSA {
    WORD        wMid;                /* manufacturer ID */
    WORD        wPid;                /* product ID */
    MMVERSION   vDriverVersion;      /* version of the driver */
    CHAR        szPname[MAXPNAMELEN];/* product name (NULL terminated string) */
    WORD        wTechnology;         /* type of device */
    WORD        wReserved1;          /* padding */
    DWORD       dwSupport;           /* functionality supported by driver */
} AUXCAPSA, *PAUXCAPSA, *NPAUXCAPSA, *LPAUXCAPSA;
typedef struct tagAUXCAPSW {
    WORD        wMid;                /* manufacturer ID */
    WORD        wPid;                /* product ID */
    MMVERSION   vDriverVersion;      /* version of the driver */
    WCHAR       szPname[MAXPNAMELEN];/* product name (NULL terminated string) */
    WORD        wTechnology;         /* type of device */
    WORD        wReserved1;          /* padding */
    DWORD       dwSupport;           /* functionality supported by driver */
} AUXCAPSW, *PAUXCAPSW, *NPAUXCAPSW, *LPAUXCAPSW;
#ifdef UNICODE
typedef AUXCAPSW AUXCAPS;
typedef PAUXCAPSW PAUXCAPS;
typedef NPAUXCAPSW NPAUXCAPS;
typedef LPAUXCAPSW LPAUXCAPS;
#else
typedef AUXCAPSA AUXCAPS;
typedef PAUXCAPSA PAUXCAPS;
typedef NPAUXCAPSA NPAUXCAPS;
typedef LPAUXCAPSA LPAUXCAPS;
#endif // UNICODE

#else
typedef struct auxcaps_tag {
    WORD    wMid;                  /* manufacturer ID */
    WORD    wPid;                  /* product ID */
    VERSION vDriverVersion;        /* version of the driver */
    char    szPname[MAXPNAMELEN];  /* product name (NULL terminated string) */
    WORD    wTechnology;           /* type of device */
    DWORD   dwSupport;             /* functionality supported by driver */
} AUXCAPS, *PAUXCAPS, NEAR *NPAUXCAPS, FAR *LPAUXCAPS;
#endif

/* flags for wTechnology field in AUXCAPS structure */
#define AUXCAPS_CDAUDIO    1       /* audio from internal CD-ROM drive */
#define AUXCAPS_AUXIN      2       /* audio from auxiliary input jacks */

/* flags for dwSupport field in AUXCAPS structure */
#define AUXCAPS_VOLUME          0x0001  /* supports volume control */
#define AUXCAPS_LRVOLUME        0x0002  /* separate left-right volume control */

#ifndef _WIN32_VXD

/* auxiliary audio function prototypes */
WINMMAPI UINT WINAPI auxGetNumDevs(void);
#ifdef _WIN32

WINMMAPI MMRESULT WINAPI auxGetDevCapsA(UINT uDeviceID, LPAUXCAPSA pac, UINT cbac);
WINMMAPI MMRESULT WINAPI auxGetDevCapsW(UINT uDeviceID, LPAUXCAPSW pac, UINT cbac);
#ifdef UNICODE
#define auxGetDevCaps  auxGetDevCapsW
#else
#define auxGetDevCaps  auxGetDevCapsA
#endif // !UNICODE

#else
MMRESULT WINAPI auxGetDevCaps(UINT uDeviceID, LPAUXCAPS pac, UINT cbac);
#endif
WINMMAPI MMRESULT WINAPI auxSetVolume(UINT uDeviceID, DWORD dwVolume);
WINMMAPI MMRESULT WINAPI auxGetVolume(UINT uDeviceID, LPDWORD pdwVolume);

#if (WINVER >= 0x030a)
#ifdef _WIN32
WINMMAPI MMRESULT WINAPI auxOutMessage(UINT uDeviceID, UINT uMsg, DWORD dw1, DWORD dw2);
#else
DWORD WINAPI auxOutMessage(UINT uDeviceID, UINT uMsg, DWORD dw1, DWORD dw2);
#endif
#endif /* ifdef WINVER >= 0x030a */

#endif /* ifndef _WIN32_VXD */

#endif  /* ifndef MMNOAUX */

#ifndef MMNOMIXER
#ifndef _WIN32_VXD
/****************************************************************************

			    Mixer Support

****************************************************************************/

DECLARE_HANDLE(HMIXEROBJ);
typedef HMIXEROBJ FAR *LPHMIXEROBJ;

DECLARE_HANDLE(HMIXER);
typedef HMIXER     FAR *LPHMIXER;

#define MIXER_SHORT_NAME_CHARS   16
#define MIXER_LONG_NAME_CHARS    64

/* */
/*  MMRESULT error return values specific to the mixer API */
/* */
/* */
#define MIXERR_INVALLINE            (MIXERR_BASE + 0)
#define MIXERR_INVALCONTROL         (MIXERR_BASE + 1)
#define MIXERR_INVALVALUE           (MIXERR_BASE + 2)
#define MIXERR_LASTERROR            (MIXERR_BASE + 2)

#define MIXER_OBJECTF_HANDLE    0x80000000L
#define MIXER_OBJECTF_MIXER     0x00000000L
#define MIXER_OBJECTF_HMIXER    (MIXER_OBJECTF_HANDLE|MIXER_OBJECTF_MIXER)
#define MIXER_OBJECTF_WAVEOUT   0x10000000L
#define MIXER_OBJECTF_HWAVEOUT  (MIXER_OBJECTF_HANDLE|MIXER_OBJECTF_WAVEOUT)
#define MIXER_OBJECTF_WAVEIN    0x20000000L
#define MIXER_OBJECTF_HWAVEIN   (MIXER_OBJECTF_HANDLE|MIXER_OBJECTF_WAVEIN)
#define MIXER_OBJECTF_MIDIOUT   0x30000000L
#define MIXER_OBJECTF_HMIDIOUT  (MIXER_OBJECTF_HANDLE|MIXER_OBJECTF_MIDIOUT)
#define MIXER_OBJECTF_MIDIIN    0x40000000L
#define MIXER_OBJECTF_HMIDIIN   (MIXER_OBJECTF_HANDLE|MIXER_OBJECTF_MIDIIN)
#define MIXER_OBJECTF_AUX       0x50000000L

WINMMAPI UINT WINAPI mixerGetNumDevs(void);

#ifdef _WIN32

typedef struct tagMIXERCAPSA {
    WORD            wMid;                   /* manufacturer id */
    WORD            wPid;                   /* product id */
    MMVERSION       vDriverVersion;         /* version of the driver */
    CHAR            szPname[MAXPNAMELEN];   /* product name */
    DWORD           fdwSupport;             /* misc. support bits */
    DWORD           cDestinations;          /* count of destinations */
} MIXERCAPSA, *PMIXERCAPSA, *LPMIXERCAPSA;
typedef struct tagMIXERCAPSW {
    WORD            wMid;                   /* manufacturer id */
    WORD            wPid;                   /* product id */
    MMVERSION       vDriverVersion;         /* version of the driver */
    WCHAR           szPname[MAXPNAMELEN];   /* product name */
    DWORD           fdwSupport;             /* misc. support bits */
    DWORD           cDestinations;          /* count of destinations */
} MIXERCAPSW, *PMIXERCAPSW, *LPMIXERCAPSW;
#ifdef UNICODE
typedef MIXERCAPSW MIXERCAPS;
typedef PMIXERCAPSW PMIXERCAPS;
typedef LPMIXERCAPSW LPMIXERCAPS;
#else
typedef MIXERCAPSA MIXERCAPS;
typedef PMIXERCAPSA PMIXERCAPS;
typedef LPMIXERCAPSA LPMIXERCAPS;
#endif // UNICODE

#else
typedef struct tMIXERCAPS {
    WORD            wMid;                   /* manufacturer id */
    WORD            wPid;                   /* product id */
    VERSION         vDriverVersion;         /* version of the driver */
    char            szPname[MAXPNAMELEN];   /* product name */
    DWORD           fdwSupport;             /* misc. support bits */
    DWORD           cDestinations;          /* count of destinations */
} MIXERCAPS, *PMIXERCAPS, FAR *LPMIXERCAPS;
#endif

#ifdef _WIN32

WINMMAPI MMRESULT WINAPI mixerGetDevCapsA(UINT uMxId, LPMIXERCAPSA pmxcaps, UINT cbmxcaps);
WINMMAPI MMRESULT WINAPI mixerGetDevCapsW(UINT uMxId, LPMIXERCAPSW pmxcaps, UINT cbmxcaps);
#ifdef UNICODE
#define mixerGetDevCaps  mixerGetDevCapsW
#else
#define mixerGetDevCaps  mixerGetDevCapsA
#endif // !UNICODE

#else
MMRESULT WINAPI mixerGetDevCaps(UINT uMxId, LPMIXERCAPS pmxcaps, UINT cbmxcaps);
#endif

WINMMAPI MMRESULT WINAPI mixerOpen(LPHMIXER phmx, UINT uMxId, DWORD dwCallback, DWORD dwInstance, DWORD fdwOpen);

WINMMAPI MMRESULT WINAPI mixerClose(HMIXER hmx);

WINMMAPI DWORD WINAPI mixerMessage(HMIXER hmx, UINT uMsg, DWORD dwParam1, DWORD dwParam2);

#ifdef _WIN32

typedef struct tagMIXERLINEA {
    DWORD       cbStruct;               /* size of MIXERLINE structure */
    DWORD       dwDestination;          /* zero based destination index */
    DWORD       dwSource;               /* zero based source index (if source) */
    DWORD       dwLineID;               /* unique line id for mixer device */
    DWORD       fdwLine;                /* state/information about line */
    DWORD       dwUser;                 /* driver specific information */
    DWORD       dwComponentType;        /* component type line connects to */
    DWORD       cChannels;              /* number of channels line supports */
    DWORD       cConnections;           /* number of connections [possible] */
    DWORD       cControls;              /* number of controls at this line */
    CHAR        szShortName[MIXER_SHORT_NAME_CHARS];
    CHAR        szName[MIXER_LONG_NAME_CHARS];
    struct {
	DWORD   dwType;                 /* MIXERLINE_TARGETTYPE_xxxx */
	DWORD   dwDeviceID;             /* target device ID of device type */
	WORD    wMid;                   /* of target device */
	WORD    wPid;                   /*      " */
	MMVERSION vDriverVersion;       /*      " */
	CHAR    szPname[MAXPNAMELEN];   /*      " */
    } Target;
} MIXERLINEA, *PMIXERLINEA, *LPMIXERLINEA;
typedef struct tagMIXERLINEW {
    DWORD       cbStruct;               /* size of MIXERLINE structure */
    DWORD       dwDestination;          /* zero based destination index */
    DWORD       dwSource;               /* zero based source index (if source) */
    DWORD       dwLineID;               /* unique line id for mixer device */
    DWORD       fdwLine;                /* state/information about line */
    DWORD       dwUser;                 /* driver specific information */
    DWORD       dwComponentType;        /* component type line connects to */
    DWORD       cChannels;              /* number of channels line supports */
    DWORD       cConnections;           /* number of connections [possible] */
    DWORD       cControls;              /* number of controls at this line */
    WCHAR       szShortName[MIXER_SHORT_NAME_CHARS];
    WCHAR       szName[MIXER_LONG_NAME_CHARS];
    struct {
	DWORD   dwType;                 /* MIXERLINE_TARGETTYPE_xxxx */
	DWORD   dwDeviceID;             /* target device ID of device type */
	WORD    wMid;                   /* of target device */
	WORD    wPid;                   /*      " */
	MMVERSION vDriverVersion;       /*      " */
	WCHAR   szPname[MAXPNAMELEN];   /*      " */
    } Target;
} MIXERLINEW, *PMIXERLINEW, *LPMIXERLINEW;
#ifdef UNICODE
typedef MIXERLINEW MIXERLINE;
typedef PMIXERLINEW PMIXERLINE;
typedef LPMIXERLINEW LPMIXERLINE;
#else
typedef MIXERLINEA MIXERLINE;
typedef PMIXERLINEA PMIXERLINE;
typedef LPMIXERLINEA LPMIXERLINE;
#endif // UNICODE

#else
typedef struct tMIXERLINE {
    DWORD       cbStruct;               /* size of MIXERLINE structure */
    DWORD       dwDestination;          /* zero based destination index */
    DWORD       dwSource;               /* zero based source index (if source) */
    DWORD       dwLineID;               /* unique line id for mixer device */
    DWORD       fdwLine;                /* state/information about line */
    DWORD       dwUser;                 /* driver specific information */
    DWORD       dwComponentType;        /* component type line connects to */
    DWORD       cChannels;              /* number of channels line supports */
    DWORD       cConnections;           /* number of connections [possible] */
    DWORD       cControls;              /* number of controls at this line */
    char        szShortName[MIXER_SHORT_NAME_CHARS];
    char        szName[MIXER_LONG_NAME_CHARS];
    struct {
	DWORD   dwType;                 /* MIXERLINE_TARGETTYPE_xxxx */
	DWORD   dwDeviceID;             /* target device ID of device type */
	WORD    wMid;                   /* of target device */
	WORD    wPid;                   /*      " */
	VERSION vDriverVersion;         /*      " */
	char    szPname[MAXPNAMELEN];   /*      " */
    } Target;
} MIXERLINE, *PMIXERLINE, FAR *LPMIXERLINE;
#endif

/* */
/*  MIXERLINE.fdwLine */
/* */
/* */
#define MIXERLINE_LINEF_ACTIVE              0x00000001L
#define MIXERLINE_LINEF_DISCONNECTED        0x00008000L
#define MIXERLINE_LINEF_SOURCE              0x80000000L

/* */
/*  MIXERLINE.dwComponentType */
/* */
/*  component types for destinations and sources */
/* */
/* */
#define MIXERLINE_COMPONENTTYPE_DST_FIRST       0x00000000L
#define MIXERLINE_COMPONENTTYPE_DST_UNDEFINED   (MIXERLINE_COMPONENTTYPE_DST_FIRST + 0)
#define MIXERLINE_COMPONENTTYPE_DST_DIGITAL     (MIXERLINE_COMPONENTTYPE_DST_FIRST + 1)
#define MIXERLINE_COMPONENTTYPE_DST_LINE        (MIXERLINE_COMPONENTTYPE_DST_FIRST + 2)
#define MIXERLINE_COMPONENTTYPE_DST_MONITOR     (MIXERLINE_COMPONENTTYPE_DST_FIRST + 3)
#define MIXERLINE_COMPONENTTYPE_DST_SPEAKERS    (MIXERLINE_COMPONENTTYPE_DST_FIRST + 4)
#define MIXERLINE_COMPONENTTYPE_DST_HEADPHONES  (MIXERLINE_COMPONENTTYPE_DST_FIRST + 5)
#define MIXERLINE_COMPONENTTYPE_DST_TELEPHONE   (MIXERLINE_COMPONENTTYPE_DST_FIRST + 6)
#define MIXERLINE_COMPONENTTYPE_DST_WAVEIN      (MIXERLINE_COMPONENTTYPE_DST_FIRST + 7)
#define MIXERLINE_COMPONENTTYPE_DST_VOICEIN     (MIXERLINE_COMPONENTTYPE_DST_FIRST + 8)
#define MIXERLINE_COMPONENTTYPE_DST_LAST        (MIXERLINE_COMPONENTTYPE_DST_FIRST + 8)

#define MIXERLINE_COMPONENTTYPE_SRC_FIRST       0x00001000L
#define MIXERLINE_COMPONENTTYPE_SRC_UNDEFINED   (MIXERLINE_COMPONENTTYPE_SRC_FIRST + 0)
#define MIXERLINE_COMPONENTTYPE_SRC_DIGITAL     (MIXERLINE_COMPONENTTYPE_SRC_FIRST + 1)
#define MIXERLINE_COMPONENTTYPE_SRC_LINE        (MIXERLINE_COMPONENTTYPE_SRC_FIRST + 2)
#define MIXERLINE_COMPONENTTYPE_SRC_MICROPHONE  (MIXERLINE_COMPONENTTYPE_SRC_FIRST + 3)
#define MIXERLINE_COMPONENTTYPE_SRC_SYNTHESIZER (MIXERLINE_COMPONENTTYPE_SRC_FIRST + 4)
#define MIXERLINE_COMPONENTTYPE_SRC_COMPACTDISC (MIXERLINE_COMPONENTTYPE_SRC_FIRST + 5)
#define MIXERLINE_COMPONENTTYPE_SRC_TELEPHONE   (MIXERLINE_COMPONENTTYPE_SRC_FIRST + 6)
#define MIXERLINE_COMPONENTTYPE_SRC_PCSPEAKER   (MIXERLINE_COMPONENTTYPE_SRC_FIRST + 7)
#define MIXERLINE_COMPONENTTYPE_SRC_WAVEOUT     (MIXERLINE_COMPONENTTYPE_SRC_FIRST + 8)
#define MIXERLINE_COMPONENTTYPE_SRC_AUXILIARY   (MIXERLINE_COMPONENTTYPE_SRC_FIRST + 9)
#define MIXERLINE_COMPONENTTYPE_SRC_ANALOG      (MIXERLINE_COMPONENTTYPE_SRC_FIRST + 10)
#define MIXERLINE_COMPONENTTYPE_SRC_LAST        (MIXERLINE_COMPONENTTYPE_SRC_FIRST + 10)

/* */
/*  MIXERLINE.Target.dwType */
/* */
/* */
#define MIXERLINE_TARGETTYPE_UNDEFINED      0
#define MIXERLINE_TARGETTYPE_WAVEOUT        1
#define MIXERLINE_TARGETTYPE_WAVEIN         2
#define MIXERLINE_TARGETTYPE_MIDIOUT        3
#define MIXERLINE_TARGETTYPE_MIDIIN         4
#define MIXERLINE_TARGETTYPE_AUX            5

#ifdef _WIN32

WINMMAPI MMRESULT WINAPI mixerGetLineInfoA(HMIXEROBJ hmxobj, LPMIXERLINEA pmxl, DWORD fdwInfo);
WINMMAPI MMRESULT WINAPI mixerGetLineInfoW(HMIXEROBJ hmxobj, LPMIXERLINEW pmxl, DWORD fdwInfo);
#ifdef UNICODE
#define mixerGetLineInfo  mixerGetLineInfoW
#else
#define mixerGetLineInfo  mixerGetLineInfoA
#endif // !UNICODE

#else
MMRESULT WINAPI mixerGetLineInfo(HMIXEROBJ hmxobj, LPMIXERLINE pmxl, DWORD fdwInfo);
#endif

#define MIXER_GETLINEINFOF_DESTINATION      0x00000000L
#define MIXER_GETLINEINFOF_SOURCE           0x00000001L
#define MIXER_GETLINEINFOF_LINEID           0x00000002L
#define MIXER_GETLINEINFOF_COMPONENTTYPE    0x00000003L
#define MIXER_GETLINEINFOF_TARGETTYPE       0x00000004L

#define MIXER_GETLINEINFOF_QUERYMASK        0x0000000FL

WINMMAPI MMRESULT WINAPI mixerGetID(HMIXEROBJ hmxobj, UINT FAR *puMxId, DWORD fdwId);

/* */
/*  MIXERCONTROL */
/* */
/* */
#ifdef _WIN32

typedef struct tagMIXERCONTROLA {
    DWORD           cbStruct;           /* size in bytes of MIXERCONTROL */
    DWORD           dwControlID;        /* unique control id for mixer device */
    DWORD           dwControlType;      /* MIXERCONTROL_CONTROLTYPE_xxx */
    DWORD           fdwControl;         /* MIXERCONTROL_CONTROLF_xxx */
    DWORD           cMultipleItems;     /* if MIXERCONTROL_CONTROLF_MULTIPLE set */
    CHAR            szShortName[MIXER_SHORT_NAME_CHARS];
    CHAR            szName[MIXER_LONG_NAME_CHARS];
    union {
	struct {
	    LONG    lMinimum;           /* signed minimum for this control */
	    LONG    lMaximum;           /* signed maximum for this control */
	};
	struct {
	    DWORD   dwMinimum;          /* unsigned minimum for this control */
	    DWORD   dwMaximum;          /* unsigned maximum for this control */
	};
	DWORD       dwReserved[6];
    } Bounds;
    union {
	DWORD       cSteps;             /* # of steps between min & max */
	DWORD       cbCustomData;       /* size in bytes of custom data */
	DWORD       dwReserved[6];      /* !!! needed? we have cbStruct.... */
    } Metrics;
} MIXERCONTROLA, *PMIXERCONTROLA, *LPMIXERCONTROLA;
typedef struct tagMIXERCONTROLW {
    DWORD           cbStruct;           /* size in bytes of MIXERCONTROL */
    DWORD           dwControlID;        /* unique control id for mixer device */
    DWORD           dwControlType;      /* MIXERCONTROL_CONTROLTYPE_xxx */
    DWORD           fdwControl;         /* MIXERCONTROL_CONTROLF_xxx */
    DWORD           cMultipleItems;     /* if MIXERCONTROL_CONTROLF_MULTIPLE set */
    WCHAR           szShortName[MIXER_SHORT_NAME_CHARS];
    WCHAR           szName[MIXER_LONG_NAME_CHARS];
    union {
	struct {
	    LONG    lMinimum;           /* signed minimum for this control */
	    LONG    lMaximum;           /* signed maximum for this control */
	};
	struct {
	    DWORD   dwMinimum;          /* unsigned minimum for this control */
	    DWORD   dwMaximum;          /* unsigned maximum for this control */
	};
	DWORD       dwReserved[6];
    } Bounds;
    union {
	DWORD       cSteps;             /* # of steps between min & max */
	DWORD       cbCustomData;       /* size in bytes of custom data */
	DWORD       dwReserved[6];      /* !!! needed? we have cbStruct.... */
    } Metrics;
} MIXERCONTROLW, *PMIXERCONTROLW, *LPMIXERCONTROLW;
#ifdef UNICODE
typedef MIXERCONTROLW MIXERCONTROL;
typedef PMIXERCONTROLW PMIXERCONTROL;
typedef LPMIXERCONTROLW LPMIXERCONTROL;
#else
typedef MIXERCONTROLA MIXERCONTROL;
typedef PMIXERCONTROLA PMIXERCONTROL;
typedef LPMIXERCONTROLA LPMIXERCONTROL;
#endif // UNICODE

#else
typedef struct tMIXERCONTROL {
    DWORD           cbStruct;           /* size in bytes of MIXERCONTROL */
    DWORD           dwControlID;        /* unique control id for mixer device */
    DWORD           dwControlType;      /* MIXERCONTROL_CONTROLTYPE_xxx */
    DWORD           fdwControl;         /* MIXERCONTROL_CONTROLF_xxx */
    DWORD           cMultipleItems;     /* if MIXERCONTROL_CONTROLF_MULTIPLE set */
    char            szShortName[MIXER_SHORT_NAME_CHARS];
    char            szName[MIXER_LONG_NAME_CHARS];
    union {
	struct {
	    LONG    lMinimum;           /* signed minimum for this control */
	    LONG    lMaximum;           /* signed maximum for this control */
	};
	struct {
	    DWORD   dwMinimum;          /* unsigned minimum for this control */
	    DWORD   dwMaximum;          /* unsigned maximum for this control */
	};
	DWORD       dwReserved[6];
    } Bounds;
    union {
	DWORD       cSteps;             /* # of steps between min & max */
	DWORD       cbCustomData;       /* size in bytes of custom data */
	DWORD       dwReserved[6];      /* !!! needed? we have cbStruct.... */
    } Metrics;
} MIXERCONTROL, *PMIXERCONTROL, FAR *LPMIXERCONTROL;
#endif

/* */
/*  MIXERCONTROL.fdwControl */
/* */
/* */
#define MIXERCONTROL_CONTROLF_UNIFORM   0x00000001L
#define MIXERCONTROL_CONTROLF_MULTIPLE  0x00000002L
#define MIXERCONTROL_CONTROLF_DISABLED  0x80000000L

/* */
/*  MIXERCONTROL_CONTROLTYPE_xxx building block defines */
/* */
/* */
#define MIXERCONTROL_CT_CLASS_MASK          0xF0000000L
#define MIXERCONTROL_CT_CLASS_CUSTOM        0x00000000L
#define MIXERCONTROL_CT_CLASS_METER         0x10000000L
#define MIXERCONTROL_CT_CLASS_SWITCH        0x20000000L
#define MIXERCONTROL_CT_CLASS_NUMBER        0x30000000L
#define MIXERCONTROL_CT_CLASS_SLIDER        0x40000000L
#define MIXERCONTROL_CT_CLASS_FADER         0x50000000L
#define MIXERCONTROL_CT_CLASS_TIME          0x60000000L
#define MIXERCONTROL_CT_CLASS_LIST          0x70000000L

#define MIXERCONTROL_CT_SUBCLASS_MASK       0x0F000000L

#define MIXERCONTROL_CT_SC_SWITCH_BOOLEAN   0x00000000L
#define MIXERCONTROL_CT_SC_SWITCH_BUTTON    0x01000000L

#define MIXERCONTROL_CT_SC_METER_POLLED     0x00000000L

#define MIXERCONTROL_CT_SC_TIME_MICROSECS   0x00000000L
#define MIXERCONTROL_CT_SC_TIME_MILLISECS   0x01000000L

#define MIXERCONTROL_CT_SC_LIST_SINGLE      0x00000000L
#define MIXERCONTROL_CT_SC_LIST_MULTIPLE    0x01000000L

#define MIXERCONTROL_CT_UNITS_MASK          0x00FF0000L
#define MIXERCONTROL_CT_UNITS_CUSTOM        0x00000000L
#define MIXERCONTROL_CT_UNITS_BOOLEAN       0x00010000L
#define MIXERCONTROL_CT_UNITS_SIGNED        0x00020000L
#define MIXERCONTROL_CT_UNITS_UNSIGNED      0x00030000L
#define MIXERCONTROL_CT_UNITS_DECIBELS      0x00040000L /* in 10ths */
#define MIXERCONTROL_CT_UNITS_PERCENT       0x00050000L /* in 10ths */

/* */
/*  Commonly used control types for specifying MIXERCONTROL.dwControlType */
/* */

#define MIXERCONTROL_CONTROLTYPE_CUSTOM         (MIXERCONTROL_CT_CLASS_CUSTOM | MIXERCONTROL_CT_UNITS_CUSTOM)
#define MIXERCONTROL_CONTROLTYPE_BOOLEANMETER   (MIXERCONTROL_CT_CLASS_METER | MIXERCONTROL_CT_SC_METER_POLLED | MIXERCONTROL_CT_UNITS_BOOLEAN)
#define MIXERCONTROL_CONTROLTYPE_SIGNEDMETER    (MIXERCONTROL_CT_CLASS_METER | MIXERCONTROL_CT_SC_METER_POLLED | MIXERCONTROL_CT_UNITS_SIGNED)
#define MIXERCONTROL_CONTROLTYPE_PEAKMETER      (MIXERCONTROL_CONTROLTYPE_SIGNEDMETER + 1)
#define MIXERCONTROL_CONTROLTYPE_UNSIGNEDMETER  (MIXERCONTROL_CT_CLASS_METER | MIXERCONTROL_CT_SC_METER_POLLED | MIXERCONTROL_CT_UNITS_UNSIGNED)
#define MIXERCONTROL_CONTROLTYPE_BOOLEAN        (MIXERCONTROL_CT_CLASS_SWITCH | MIXERCONTROL_CT_SC_SWITCH_BOOLEAN | MIXERCONTROL_CT_UNITS_BOOLEAN)
#define MIXERCONTROL_CONTROLTYPE_ONOFF          (MIXERCONTROL_CONTROLTYPE_BOOLEAN + 1)
#define MIXERCONTROL_CONTROLTYPE_MUTE           (MIXERCONTROL_CONTROLTYPE_BOOLEAN + 2)
#define MIXERCONTROL_CONTROLTYPE_MONO           (MIXERCONTROL_CONTROLTYPE_BOOLEAN + 3)
#define MIXERCONTROL_CONTROLTYPE_LOUDNESS       (MIXERCONTROL_CONTROLTYPE_BOOLEAN + 4)
#define MIXERCONTROL_CONTROLTYPE_STEREOENH      (MIXERCONTROL_CONTROLTYPE_BOOLEAN + 5)
#define MIXERCONTROL_CONTROLTYPE_BUTTON         (MIXERCONTROL_CT_CLASS_SWITCH | MIXERCONTROL_CT_SC_SWITCH_BUTTON | MIXERCONTROL_CT_UNITS_BOOLEAN)
#define MIXERCONTROL_CONTROLTYPE_DECIBELS       (MIXERCONTROL_CT_CLASS_NUMBER | MIXERCONTROL_CT_UNITS_DECIBELS)
#define MIXERCONTROL_CONTROLTYPE_SIGNED         (MIXERCONTROL_CT_CLASS_NUMBER | MIXERCONTROL_CT_UNITS_SIGNED)
#define MIXERCONTROL_CONTROLTYPE_UNSIGNED       (MIXERCONTROL_CT_CLASS_NUMBER | MIXERCONTROL_CT_UNITS_UNSIGNED)
#define MIXERCONTROL_CONTROLTYPE_PERCENT        (MIXERCONTROL_CT_CLASS_NUMBER | MIXERCONTROL_CT_UNITS_PERCENT)
#define MIXERCONTROL_CONTROLTYPE_SLIDER         (MIXERCONTROL_CT_CLASS_SLIDER | MIXERCONTROL_CT_UNITS_SIGNED)
#define MIXERCONTROL_CONTROLTYPE_PAN            (MIXERCONTROL_CONTROLTYPE_SLIDER + 1)
#define MIXERCONTROL_CONTROLTYPE_QSOUNDPAN      (MIXERCONTROL_CONTROLTYPE_SLIDER + 2)
#define MIXERCONTROL_CONTROLTYPE_FADER          (MIXERCONTROL_CT_CLASS_FADER | MIXERCONTROL_CT_UNITS_UNSIGNED)
#define MIXERCONTROL_CONTROLTYPE_VOLUME         (MIXERCONTROL_CONTROLTYPE_FADER + 1)
#define MIXERCONTROL_CONTROLTYPE_BASS           (MIXERCONTROL_CONTROLTYPE_FADER + 2)
#define MIXERCONTROL_CONTROLTYPE_TREBLE         (MIXERCONTROL_CONTROLTYPE_FADER + 3)
#define MIXERCONTROL_CONTROLTYPE_EQUALIZER      (MIXERCONTROL_CONTROLTYPE_FADER + 4)
#define MIXERCONTROL_CONTROLTYPE_SINGLESELECT   (MIXERCONTROL_CT_CLASS_LIST | MIXERCONTROL_CT_SC_LIST_SINGLE | MIXERCONTROL_CT_UNITS_BOOLEAN)
#define MIXERCONTROL_CONTROLTYPE_MUX            (MIXERCONTROL_CONTROLTYPE_SINGLESELECT + 1)
#define MIXERCONTROL_CONTROLTYPE_MULTIPLESELECT (MIXERCONTROL_CT_CLASS_LIST | MIXERCONTROL_CT_SC_LIST_MULTIPLE | MIXERCONTROL_CT_UNITS_BOOLEAN)
#define MIXERCONTROL_CONTROLTYPE_MIXER          (MIXERCONTROL_CONTROLTYPE_MULTIPLESELECT + 1)
#define MIXERCONTROL_CONTROLTYPE_MICROTIME      (MIXERCONTROL_CT_CLASS_TIME | MIXERCONTROL_CT_SC_TIME_MICROSECS | MIXERCONTROL_CT_UNITS_UNSIGNED)
#define MIXERCONTROL_CONTROLTYPE_MILLITIME      (MIXERCONTROL_CT_CLASS_TIME | MIXERCONTROL_CT_SC_TIME_MILLISECS | MIXERCONTROL_CT_UNITS_UNSIGNED)

/* */
/*  MIXERLINECONTROLS */
/* */
#ifdef _WIN32

typedef struct tagMIXERLINECONTROLSA {
    DWORD           cbStruct;       /* size in bytes of MIXERLINECONTROLS */
    DWORD           dwLineID;       /* line id (from MIXERLINE.dwLineID) */
    union {
	DWORD       dwControlID;    /* MIXER_GETLINECONTROLSF_ONEBYID */
	DWORD       dwControlType;  /* MIXER_GETLINECONTROLSF_ONEBYTYPE */
    };
    DWORD           cControls;      /* count of controls pmxctrl points to */
    DWORD           cbmxctrl;       /* size in bytes of _one_ MIXERCONTROL */
    LPMIXERCONTROLA pamxctrl;       /* pointer to first MIXERCONTROL array */
} MIXERLINECONTROLSA, *PMIXERLINECONTROLSA, *LPMIXERLINECONTROLSA;
typedef struct tagMIXERLINECONTROLSW {
    DWORD           cbStruct;       /* size in bytes of MIXERLINECONTROLS */
    DWORD           dwLineID;       /* line id (from MIXERLINE.dwLineID) */
    union {
	DWORD       dwControlID;    /* MIXER_GETLINECONTROLSF_ONEBYID */
	DWORD       dwControlType;  /* MIXER_GETLINECONTROLSF_ONEBYTYPE */
    };
    DWORD           cControls;      /* count of controls pmxctrl points to */
    DWORD           cbmxctrl;       /* size in bytes of _one_ MIXERCONTROL */
    LPMIXERCONTROLW pamxctrl;       /* pointer to first MIXERCONTROL array */
} MIXERLINECONTROLSW, *PMIXERLINECONTROLSW, *LPMIXERLINECONTROLSW;
#ifdef UNICODE
typedef MIXERLINECONTROLSW MIXERLINECONTROLS;
typedef PMIXERLINECONTROLSW PMIXERLINECONTROLS;
typedef LPMIXERLINECONTROLSW LPMIXERLINECONTROLS;
#else
typedef MIXERLINECONTROLSA MIXERLINECONTROLS;
typedef PMIXERLINECONTROLSA PMIXERLINECONTROLS;
typedef LPMIXERLINECONTROLSA LPMIXERLINECONTROLS;
#endif // UNICODE

#else
typedef struct tMIXERLINECONTROLS {
    DWORD           cbStruct;       /* size in bytes of MIXERLINECONTROLS */
    DWORD           dwLineID;       /* line id (from MIXERLINE.dwLineID) */
    union {
	DWORD       dwControlID;    /* MIXER_GETLINECONTROLSF_ONEBYID */
	DWORD       dwControlType;  /* MIXER_GETLINECONTROLSF_ONEBYTYPE */
    };
    DWORD           cControls;      /* count of controls pmxctrl points to */
    DWORD           cbmxctrl;       /* size in bytes of _one_ MIXERCONTROL */
    LPMIXERCONTROL  pamxctrl;       /* pointer to first MIXERCONTROL array */
} MIXERLINECONTROLS, *PMIXERLINECONTROLS, FAR *LPMIXERLINECONTROLS;
#endif

/* */
/* */
/* */
#ifdef _WIN32

WINMMAPI MMRESULT WINAPI mixerGetLineControlsA(HMIXEROBJ hmxobj, LPMIXERLINECONTROLSA pmxlc, DWORD fdwControls);
WINMMAPI MMRESULT WINAPI mixerGetLineControlsW(HMIXEROBJ hmxobj, LPMIXERLINECONTROLSW pmxlc, DWORD fdwControls);
#ifdef UNICODE
#define mixerGetLineControls  mixerGetLineControlsW
#else
#define mixerGetLineControls  mixerGetLineControlsA
#endif // !UNICODE

#else
MMRESULT WINAPI mixerGetLineControls(HMIXEROBJ hmxobj, LPMIXERLINECONTROLS pmxlc, DWORD fdwControls);
#endif

#define MIXER_GETLINECONTROLSF_ALL          0x00000000L
#define MIXER_GETLINECONTROLSF_ONEBYID      0x00000001L
#define MIXER_GETLINECONTROLSF_ONEBYTYPE    0x00000002L

#define MIXER_GETLINECONTROLSF_QUERYMASK    0x0000000FL

typedef struct tMIXERCONTROLDETAILS {
    DWORD           cbStruct;       /* size in bytes of MIXERCONTROLDETAILS */
    DWORD           dwControlID;    /* control id to get/set details on */
    DWORD           cChannels;      /* number of channels in paDetails array */
    union {
	HWND        hwndOwner;      /* for MIXER_SETCONTROLDETAILSF_CUSTOM */
	DWORD       cMultipleItems; /* if _MULTIPLE, the number of items per channel */
    };
    DWORD           cbDetails;      /* size of _one_ details_XX struct */
    LPVOID          paDetails;      /* pointer to array of details_XX structs */
} MIXERCONTROLDETAILS, *PMIXERCONTROLDETAILS, FAR *LPMIXERCONTROLDETAILS;

/* */
/*  MIXER_GETCONTROLDETAILSF_LISTTEXT */
/* */
/* */
#ifdef _WIN32

typedef struct tagMIXERCONTROLDETAILS_LISTTEXTA {
    DWORD           dwParam1;
    DWORD           dwParam2;
    CHAR            szName[MIXER_LONG_NAME_CHARS];
} MIXERCONTROLDETAILS_LISTTEXTA, *PMIXERCONTROLDETAILS_LISTTEXTA, *LPMIXERCONTROLDETAILS_LISTTEXTA;
typedef struct tagMIXERCONTROLDETAILS_LISTTEXTW {
    DWORD           dwParam1;
    DWORD           dwParam2;
    WCHAR           szName[MIXER_LONG_NAME_CHARS];
} MIXERCONTROLDETAILS_LISTTEXTW, *PMIXERCONTROLDETAILS_LISTTEXTW, *LPMIXERCONTROLDETAILS_LISTTEXTW;
#ifdef UNICODE
typedef MIXERCONTROLDETAILS_LISTTEXTW MIXERCONTROLDETAILS_LISTTEXT;
typedef PMIXERCONTROLDETAILS_LISTTEXTW PMIXERCONTROLDETAILS_LISTTEXT;
typedef LPMIXERCONTROLDETAILS_LISTTEXTW LPMIXERCONTROLDETAILS_LISTTEXT;
#else
typedef MIXERCONTROLDETAILS_LISTTEXTA MIXERCONTROLDETAILS_LISTTEXT;
typedef PMIXERCONTROLDETAILS_LISTTEXTA PMIXERCONTROLDETAILS_LISTTEXT;
typedef LPMIXERCONTROLDETAILS_LISTTEXTA LPMIXERCONTROLDETAILS_LISTTEXT;
#endif // UNICODE

#else
typedef struct tMIXERCONTROLDETAILS_LISTTEXT {
    DWORD           dwParam1;
    DWORD           dwParam2;
    char            szName[MIXER_LONG_NAME_CHARS];
} MIXERCONTROLDETAILS_LISTTEXT, *PMIXERCONTROLDETAILS_LISTTEXT, FAR *LPMIXERCONTROLDETAILS_LISTTEXT;
#endif

/* */
/*  MIXER_GETCONTROLDETAILSF_VALUE */
/* */
/* */
typedef struct tMIXERCONTROLDETAILS_BOOLEAN {
    LONG            fValue;
}       MIXERCONTROLDETAILS_BOOLEAN,
      *PMIXERCONTROLDETAILS_BOOLEAN,
 FAR *LPMIXERCONTROLDETAILS_BOOLEAN;

typedef struct tMIXERCONTROLDETAILS_SIGNED {
    LONG            lValue;
}       MIXERCONTROLDETAILS_SIGNED,
      *PMIXERCONTROLDETAILS_SIGNED,
 FAR *LPMIXERCONTROLDETAILS_SIGNED;

typedef struct tMIXERCONTROLDETAILS_UNSIGNED {
    DWORD           dwValue;
}       MIXERCONTROLDETAILS_UNSIGNED,
      *PMIXERCONTROLDETAILS_UNSIGNED,
 FAR *LPMIXERCONTROLDETAILS_UNSIGNED;

#ifdef _WIN32

WINMMAPI MMRESULT WINAPI mixerGetControlDetailsA(HMIXEROBJ hmxobj, LPMIXERCONTROLDETAILS pmxcd, DWORD fdwDetails);
WINMMAPI MMRESULT WINAPI mixerGetControlDetailsW(HMIXEROBJ hmxobj, LPMIXERCONTROLDETAILS pmxcd, DWORD fdwDetails);
#ifdef UNICODE
#define mixerGetControlDetails  mixerGetControlDetailsW
#else
#define mixerGetControlDetails  mixerGetControlDetailsA
#endif // !UNICODE

#else
MMRESULT WINAPI mixerGetControlDetails(HMIXEROBJ hmxobj, LPMIXERCONTROLDETAILS pmxcd, DWORD fdwDetails);
#endif

#define MIXER_GETCONTROLDETAILSF_VALUE      0x00000000L
#define MIXER_GETCONTROLDETAILSF_LISTTEXT   0x00000001L

#define MIXER_GETCONTROLDETAILSF_QUERYMASK  0x0000000FL

WINMMAPI MMRESULT WINAPI mixerSetControlDetails(HMIXEROBJ hmxobj, LPMIXERCONTROLDETAILS pmxcd, DWORD fdwDetails);

#define MIXER_SETCONTROLDETAILSF_VALUE      0x00000000L
#define MIXER_SETCONTROLDETAILSF_CUSTOM     0x00000001L

#define MIXER_SETCONTROLDETAILSF_QUERYMASK  0x0000000FL

#endif /* ifndef _WIN32_VXD */
#endif /* ifndef MMNOMIXER */

#ifndef MMNOTIMER
#ifndef _WIN32_VXD
/****************************************************************************

			    Timer support

****************************************************************************/

/* timer error return values */
#define TIMERR_NOERROR        (0)                  /* no error */
#define TIMERR_NOCANDO        (TIMERR_BASE+1)      /* request not completed */
#define TIMERR_STRUCT         (TIMERR_BASE+33)     /* time struct size */

/* timer data types */
typedef void (CALLBACK TIMECALLBACK)(UINT uTimerID, UINT uMsg, DWORD dwUser, DWORD dw1, DWORD dw2);

typedef TIMECALLBACK FAR *LPTIMECALLBACK;

/* flags for fuEvent parameter of timeSetEvent() function */
#define TIME_ONESHOT    0x0000   /* program timer for single event */
#define TIME_PERIODIC   0x0001   /* program for continuous periodic event */

#ifdef _WIN32
#define TIME_CALLBACK_FUNCTION      0x0000  /* callback is function */
#define TIME_CALLBACK_EVENT_SET     0x0010  /* callback is event - use SetEvent */
#define TIME_CALLBACK_EVENT_PULSE   0x0020  /* callback is event - use PulseEvent */
#endif

/* timer device capabilities data structure */
typedef struct timecaps_tag {
    UINT    wPeriodMin;     /* minimum period supported  */
    UINT    wPeriodMax;     /* maximum period supported  */
} TIMECAPS, *PTIMECAPS, NEAR *NPTIMECAPS, FAR *LPTIMECAPS;

/* timer function prototypes */
WINMMAPI MMRESULT WINAPI timeGetSystemTime(LPMMTIME pmmt, UINT cbmmt);
WINMMAPI DWORD WINAPI timeGetTime(void);
WINMMAPI MMRESULT WINAPI timeSetEvent(UINT uDelay, UINT uResolution,
    LPTIMECALLBACK fptc, DWORD dwUser, UINT fuEvent);
WINMMAPI MMRESULT WINAPI timeKillEvent(UINT uTimerID);
WINMMAPI MMRESULT WINAPI timeGetDevCaps(LPTIMECAPS ptc, UINT cbtc);
WINMMAPI MMRESULT WINAPI timeBeginPeriod(UINT uPeriod);
WINMMAPI MMRESULT WINAPI timeEndPeriod(UINT uPeriod);

#endif  /* ifndef _WIN32_VXD */
#endif  /* ifndef MMNOTIMER */

#ifndef MMNOJOY
/****************************************************************************

			    Joystick support

****************************************************************************/

/* joystick error return values */
#define JOYERR_NOERROR        (0)                  /* no error */
#define JOYERR_PARMS          (JOYERR_BASE+5)      /* bad parameters */
#define JOYERR_NOCANDO        (JOYERR_BASE+6)      /* request not completed */
#define JOYERR_UNPLUGGED      (JOYERR_BASE+7)      /* joystick is unplugged */

/* constants used with JOYINFO and JOYINFOEX structures and MM_JOY* messages */
#define JOY_BUTTON1         0x0001
#define JOY_BUTTON2         0x0002
#define JOY_BUTTON3         0x0004
#define JOY_BUTTON4         0x0008
#define JOY_BUTTON1CHG      0x0100
#define JOY_BUTTON2CHG      0x0200
#define JOY_BUTTON3CHG      0x0400
#define JOY_BUTTON4CHG      0x0800

/* constants used with JOYINFOEX */
#define JOY_BUTTON5         0x00000010l
#define JOY_BUTTON6         0x00000020l
#define JOY_BUTTON7         0x00000040l
#define JOY_BUTTON8         0x00000080l
#define JOY_BUTTON9         0x00000100l
#define JOY_BUTTON10        0x00000200l
#define JOY_BUTTON11        0x00000400l
#define JOY_BUTTON12        0x00000800l
#define JOY_BUTTON13        0x00001000l
#define JOY_BUTTON14        0x00002000l
#define JOY_BUTTON15        0x00004000l
#define JOY_BUTTON16        0x00008000l
#define JOY_BUTTON17        0x00010000l
#define JOY_BUTTON18        0x00020000l
#define JOY_BUTTON19        0x00040000l
#define JOY_BUTTON20        0x00080000l
#define JOY_BUTTON21        0x00100000l
#define JOY_BUTTON22        0x00200000l
#define JOY_BUTTON23        0x00400000l
#define JOY_BUTTON24        0x00800000l
#define JOY_BUTTON25        0x01000000l
#define JOY_BUTTON26        0x02000000l
#define JOY_BUTTON27        0x04000000l
#define JOY_BUTTON28        0x08000000l
#define JOY_BUTTON29        0x10000000l
#define JOY_BUTTON30        0x20000000l
#define JOY_BUTTON31        0x40000000l
#define JOY_BUTTON32        0x80000000l

/* constants used with JOYINFOEX structure */
#define JOY_POVCENTERED		(WORD) -1
#define JOY_POVFORWARD		0
#define JOY_POVRIGHT		9000
#define JOY_POVBACKWARD		18000
#define JOY_POVLEFT		27000

#define JOY_RETURNX		0x00000001l
#define JOY_RETURNY		0x00000002l
#define JOY_RETURNZ		0x00000004l
#define JOY_RETURNR		0x00000008l
#define JOY_RETURNU		0x00000010l	/* axis 5 */
#define JOY_RETURNV		0x00000020l	/* axis 6 */
#define JOY_RETURNPOV		0x00000040l
#define JOY_RETURNBUTTONS	0x00000080l
#define JOY_RETURNRAWDATA	0x00000100l
#define JOY_RETURNPOVCTS	0x00000200l
#define JOY_RETURNCENTERED	0x00000400l
#define JOY_USEDEADZONE		0x00000800l
#define JOY_RETURNALL		(JOY_RETURNX | JOY_RETURNY | JOY_RETURNZ | \
				 JOY_RETURNR | JOY_RETURNU | JOY_RETURNV | \
				 JOY_RETURNPOV | JOY_RETURNBUTTONS)
#define JOY_CAL_READALWAYS	0x00010000l
#define JOY_CAL_READXYONLY	0x00020000l
#define JOY_CAL_READ3		0x00040000l
#define JOY_CAL_READ4		0x00080000l
#define JOY_CAL_READXONLY	0x00100000l
#define JOY_CAL_READYONLY	0x00200000l
#define JOY_CAL_READ5		0x00400000l
#define JOY_CAL_READ6		0x00800000l
#define JOY_CAL_READZONLY	0x01000000l
#define JOY_CAL_READRONLY	0x02000000l
#define JOY_CAL_READUONLY	0x04000000l
#define JOY_CAL_READVONLY	0x08000000l

/* joystick ID constants */
#define JOYSTICKID1         0
#define JOYSTICKID2         1

/* joystick driver capabilites */
#define JOYCAPS_HASZ		0x0001
#define JOYCAPS_HASR		0x0002
#define JOYCAPS_HASU		0x0004
#define JOYCAPS_HASV		0x0008
#define JOYCAPS_HASPOV		0x0010
#define JOYCAPS_POV4DIR		0x0020
#define JOYCAPS_POVCTS		0x0040

/* joystick device capabilities data structure */
#ifdef _WIN32

typedef struct tagJOYCAPSA {
    WORD    wMid;                /* manufacturer ID */
    WORD    wPid;                /* product ID */
    CHAR    szPname[MAXPNAMELEN];/* product name (NULL terminated string) */
    UINT    wXmin;               /* minimum x position value */
    UINT    wXmax;               /* maximum x position value */
    UINT    wYmin;               /* minimum y position value */
    UINT    wYmax;               /* maximum y position value */
    UINT    wZmin;               /* minimum z position value */
    UINT    wZmax;               /* maximum z position value */
    UINT    wNumButtons;         /* number of buttons */
    UINT    wPeriodMin;          /* minimum message period when captured */
    UINT    wPeriodMax;          /* maximum message period when captured */
#if (WINVER >= 0x0400)
    UINT    wRmin;               /* minimum r position value */
    UINT    wRmax;               /* maximum r position value */
    UINT    wUmin;               /* minimum u (5th axis) position value */
    UINT    wUmax;               /* maximum u (5th axis) position value */
    UINT    wVmin;               /* minimum v (6th axis) position value */
    UINT    wVmax;               /* maximum v (6th axis) position value */
    UINT    wCaps;	 	 /* joystick capabilites */
    UINT    wMaxAxes;	 	 /* maximum number of axes supported */
    UINT    wNumAxes;	 	 /* number of axes in use */
    UINT    wMaxButtons;	 /* maximum number of buttons supported */
    CHAR    szRegKey[MAXPNAMELEN];/* registry key */
    CHAR    szOEMVxD[MAX_JOYSTICKOEMVXDNAME]; /* OEM VxD in use */
#endif
} JOYCAPSA, *PJOYCAPSA, *NPJOYCAPSA, *LPJOYCAPSA;
typedef struct tagJOYCAPSW {
    WORD    wMid;                /* manufacturer ID */
    WORD    wPid;                /* product ID */
    WCHAR   szPname[MAXPNAMELEN];/* product name (NULL terminated string) */
    UINT    wXmin;               /* minimum x position value */
    UINT    wXmax;               /* maximum x position value */
    UINT    wYmin;               /* minimum y position value */
    UINT    wYmax;               /* maximum y position value */
    UINT    wZmin;               /* minimum z position value */
    UINT    wZmax;               /* maximum z position value */
    UINT    wNumButtons;         /* number of buttons */
    UINT    wPeriodMin;          /* minimum message period when captured */
    UINT    wPeriodMax;          /* maximum message period when captured */
#if (WINVER >= 0x0400)
    UINT    wRmin;               /* minimum r position value */
    UINT    wRmax;               /* maximum r position value */
    UINT    wUmin;               /* minimum u (5th axis) position value */
    UINT    wUmax;               /* maximum u (5th axis) position value */
    UINT    wVmin;               /* minimum v (6th axis) position value */
    UINT    wVmax;               /* maximum v (6th axis) position value */
    UINT    wCaps;	 	 /* joystick capabilites */
    UINT    wMaxAxes;	 	 /* maximum number of axes supported */
    UINT    wNumAxes;	 	 /* number of axes in use */
    UINT    wMaxButtons;	 /* maximum number of buttons supported */
    WCHAR   szRegKey[MAXPNAMELEN];/* registry key */
    WCHAR   szOEMVxD[MAX_JOYSTICKOEMVXDNAME]; /* OEM VxD in use */
#endif
} JOYCAPSW, *PJOYCAPSW, *NPJOYCAPSW, *LPJOYCAPSW;
#ifdef UNICODE
typedef JOYCAPSW JOYCAPS;
typedef PJOYCAPSW PJOYCAPS;
typedef NPJOYCAPSW NPJOYCAPS;
typedef LPJOYCAPSW LPJOYCAPS;
#else
typedef JOYCAPSA JOYCAPS;
typedef PJOYCAPSA PJOYCAPS;
typedef NPJOYCAPSA NPJOYCAPS;
typedef LPJOYCAPSA LPJOYCAPS;
#endif // UNICODE

#else
typedef struct joycaps_tag {
    WORD wMid;                  /* manufacturer ID */
    WORD wPid;                  /* product ID */
    char szPname[MAXPNAMELEN];  /* product name (NULL terminated string) */
    UINT wXmin;                 /* minimum x position value */
    UINT wXmax;                 /* maximum x position value */
    UINT wYmin;                 /* minimum y position value */
    UINT wYmax;                 /* maximum y position value */
    UINT wZmin;                 /* minimum z position value */
    UINT wZmax;                 /* maximum z position value */
    UINT wNumButtons;           /* number of buttons */
    UINT wPeriodMin;            /* minimum message period when captured */
    UINT wPeriodMax;            /* maximum message period when captured */
#if (WINVER >= 0x0400)
    UINT wRmin;                 /* minimum r position value */
    UINT wRmax;                 /* maximum r position value */
    UINT wUmin;                 /* minimum u (5th axis) position value */
    UINT wUmax;                 /* maximum u (5th axis) position value */
    UINT wVmin;                 /* minimum v (6th axis) position value */
    UINT wVmax;                 /* maximum v (6th axis) position value */
    UINT wCaps;                 /* joystick capabilites */
    UINT wMaxAxes;	 	/* maximum number of axes supported */
    UINT wNumAxes;	 	/* number of axes in use */
    UINT wMaxButtons;	 	/* maximum number of buttons supported */
    char szRegKey[MAXPNAMELEN]; /* registry key */
    char szOEMVxD[MAX_JOYSTICKOEMVXDNAME]; /* OEM VxD in use */
#endif
} JOYCAPS, *PJOYCAPS, NEAR *NPJOYCAPS, FAR *LPJOYCAPS;
#endif

/* joystick information data structure */
typedef struct joyinfo_tag {
    UINT wXpos;                 /* x position */
    UINT wYpos;                 /* y position */
    UINT wZpos;                 /* z position */
    UINT wButtons;              /* button states */
} JOYINFO, *PJOYINFO, NEAR *NPJOYINFO, FAR *LPJOYINFO;

#if(WINVER >= 0x0400)
typedef struct joyinfoex_tag {
    DWORD dwSize;		 /* size of structure */
    DWORD dwFlags;		 /* flags to indicate what to return */
    DWORD dwXpos;                /* x position */
    DWORD dwYpos;                /* y position */
    DWORD dwZpos;                /* z position */
    DWORD dwRpos;		 /* rudder/4th axis position */
    DWORD dwUpos;		 /* 5th axis position */
    DWORD dwVpos;		 /* 6th axis position */
    DWORD dwButtons;             /* button states */
    DWORD dwButtonNumber;        /* current button number pressed */
    DWORD dwPOV;                 /* point of view state */
    DWORD dwReserved1;		 /* reserved for communication between winmm & driver */
    DWORD dwReserved2;		 /* reserved for future expansion */
} JOYINFOEX, *PJOYINFOEX, NEAR *NPJOYINFOEX, FAR *LPJOYINFOEX;
#endif /* WINVER >= 0x0400 */

#ifndef _WIN32_VXD

/* joystick function prototypes */
WINMMAPI UINT WINAPI joyGetNumDevs(void);
#ifdef _WIN32

WINMMAPI MMRESULT WINAPI joyGetDevCapsA(UINT uJoyID, LPJOYCAPSA pjc, UINT cbjc);
WINMMAPI MMRESULT WINAPI joyGetDevCapsW(UINT uJoyID, LPJOYCAPSW pjc, UINT cbjc);
#ifdef UNICODE
#define joyGetDevCaps  joyGetDevCapsW
#else
#define joyGetDevCaps  joyGetDevCapsA
#endif // !UNICODE

#else
MMRESULT WINAPI joyGetDevCaps(UINT uJoyID, LPJOYCAPS pjc, UINT cbjc);
#endif
WINMMAPI MMRESULT WINAPI joyGetPos(UINT uJoyID, LPJOYINFO pji);

#if(WINVER >= 0x0400)
WINMMAPI MMRESULT WINAPI joyGetPosEx(UINT uJoyID, LPJOYINFOEX pji);
#endif /* WINVER >= 0x0400 */

WINMMAPI MMRESULT WINAPI joyGetThreshold(UINT uJoyID, LPUINT puThreshold);
WINMMAPI MMRESULT WINAPI joyReleaseCapture(UINT uJoyID);
WINMMAPI MMRESULT WINAPI joySetCapture(HWND hwnd, UINT uJoyID, UINT uPeriod,
    BOOL fChanged);
WINMMAPI MMRESULT WINAPI joySetThreshold(UINT uJoyID, UINT uThreshold);

#endif /* ifndef _WIN32_VXD */

#endif  /* ifndef MMNOJOY */

#ifndef MMNOMMIO
#ifndef _WIN32_VXD
/****************************************************************************

			Multimedia File I/O support

****************************************************************************/

/* MMIO error return values */
#define MMIOERR_BASE                256
#define MMIOERR_FILENOTFOUND        (MMIOERR_BASE + 1)  /* file not found */
#define MMIOERR_OUTOFMEMORY         (MMIOERR_BASE + 2)  /* out of memory */
#define MMIOERR_CANNOTOPEN          (MMIOERR_BASE + 3)  /* cannot open */
#define MMIOERR_CANNOTCLOSE         (MMIOERR_BASE + 4)  /* cannot close */
#define MMIOERR_CANNOTREAD          (MMIOERR_BASE + 5)  /* cannot read */
#define MMIOERR_CANNOTWRITE         (MMIOERR_BASE + 6)  /* cannot write */
#define MMIOERR_CANNOTSEEK          (MMIOERR_BASE + 7)  /* cannot seek */
#define MMIOERR_CANNOTEXPAND        (MMIOERR_BASE + 8)  /* cannot expand file */
#define MMIOERR_CHUNKNOTFOUND       (MMIOERR_BASE + 9)  /* chunk not found */
#define MMIOERR_UNBUFFERED          (MMIOERR_BASE + 10) /*  */
#define MMIOERR_PATHNOTFOUND        (MMIOERR_BASE + 11) /* path incorrect */
#define MMIOERR_ACCESSDENIED        (MMIOERR_BASE + 12) /* file was protected */
#define MMIOERR_SHARINGVIOLATION    (MMIOERR_BASE + 13) /* file in use */
#define MMIOERR_NETWORKERROR        (MMIOERR_BASE + 14) /* network not responding */
#define MMIOERR_TOOMANYOPENFILES    (MMIOERR_BASE + 15) /* no more file handles  */
#define MMIOERR_INVALIDFILE         (MMIOERR_BASE + 16) /* default error file error */

/* MMIO constants */
#define CFSEPCHAR       '+'             /* compound file name separator char. */

/* MMIO data types */
typedef DWORD           FOURCC;         /* a four character code */
typedef char _huge *    HPSTR;          /* a huge version of LPSTR */
DECLARE_HANDLE(HMMIO);                  /* a handle to an open file */
typedef LRESULT (CALLBACK MMIOPROC)(LPSTR lpmmioinfo, UINT uMsg,
	    LPARAM lParam1, LPARAM lParam2);
typedef MMIOPROC FAR *LPMMIOPROC;

/* general MMIO information data structure */
typedef struct _MMIOINFO
{
	/* general fields */
	DWORD           dwFlags;        /* general status flags */
	FOURCC          fccIOProc;      /* pointer to I/O procedure */
	LPMMIOPROC      pIOProc;        /* pointer to I/O procedure */
	UINT            wErrorRet;      /* place for error to be returned */
	HTASK           htask;          /* alternate local task */

	/* fields maintained by MMIO functions during buffered I/O */
	LONG            cchBuffer;      /* size of I/O buffer (or 0L) */
	HPSTR           pchBuffer;      /* start of I/O buffer (or NULL) */
	HPSTR           pchNext;        /* pointer to next byte to read/write */
	HPSTR           pchEndRead;     /* pointer to last valid byte to read */
	HPSTR           pchEndWrite;    /* pointer to last byte to write */
	LONG            lBufOffset;     /* disk offset of start of buffer */

	/* fields maintained by I/O procedure */
	LONG            lDiskOffset;    /* disk offset of next read or write */
	DWORD           adwInfo[3];     /* data specific to type of MMIOPROC */

	/* other fields maintained by MMIO */
	DWORD           dwReserved1;    /* reserved for MMIO use */
	DWORD           dwReserved2;    /* reserved for MMIO use */
	HMMIO           hmmio;          /* handle to open file */
} MMIOINFO, *PMMIOINFO, NEAR *NPMMIOINFO, FAR *LPMMIOINFO;
typedef const MMIOINFO FAR *LPCMMIOINFO;

/* RIFF chunk information data structure */
typedef struct _MMCKINFO
{
	FOURCC          ckid;           /* chunk ID */
	DWORD           cksize;         /* chunk size */
	FOURCC          fccType;        /* form type or list type */
	DWORD           dwDataOffset;   /* offset of data portion of chunk */
	DWORD           dwFlags;        /* flags used by MMIO functions */
} MMCKINFO, *PMMCKINFO, NEAR *NPMMCKINFO, FAR *LPMMCKINFO;
typedef const MMCKINFO *LPCMMCKINFO;

/* bit field masks */
#define MMIO_RWMODE     0x00000003      /* open file for reading/writing/both */
#define MMIO_SHAREMODE  0x00000070      /* file sharing mode number */

/* constants for dwFlags field of MMIOINFO */
#define MMIO_CREATE     0x00001000      /* create new file (or truncate file) */
#define MMIO_PARSE      0x00000100      /* parse new file returning path */
#define MMIO_DELETE     0x00000200      /* create new file (or truncate file) */
#define MMIO_EXIST      0x00004000      /* checks for existence of file */
#define MMIO_ALLOCBUF   0x00010000      /* mmioOpen() should allocate a buffer */
#define MMIO_GETTEMP    0x00020000      /* mmioOpen() should retrieve temp name */

#define MMIO_DIRTY      0x10000000      /* I/O buffer is dirty */

/* read/write mode numbers (bit field MMIO_RWMODE) */
#define MMIO_READ       0x00000000      /* open file for reading only */
#define MMIO_WRITE      0x00000001      /* open file for writing only */
#define MMIO_READWRITE  0x00000002      /* open file for reading and writing */

/* share mode numbers (bit field MMIO_SHAREMODE) */
#define MMIO_COMPAT     0x00000000      /* compatibility mode */
#define MMIO_EXCLUSIVE  0x00000010      /* exclusive-access mode */
#define MMIO_DENYWRITE  0x00000020      /* deny writing to other processes */
#define MMIO_DENYREAD   0x00000030      /* deny reading to other processes */
#define MMIO_DENYNONE   0x00000040      /* deny nothing to other processes */

/* various MMIO flags */
#define MMIO_FHOPEN             0x0010  /* mmioClose: keep file handle open */
#define MMIO_EMPTYBUF           0x0010  /* mmioFlush: empty the I/O buffer */
#define MMIO_TOUPPER            0x0010  /* mmioStringToFOURCC: to u-case */
#define MMIO_INSTALLPROC    0x00010000  /* mmioInstallIOProc: install MMIOProc */
#define MMIO_GLOBALPROC     0x10000000  /* mmioInstallIOProc: install globally */
#define MMIO_REMOVEPROC     0x00020000  /* mmioInstallIOProc: remove MMIOProc */
#define MMIO_UNICODEPROC    0x01000000  /* mmioInstallIOProc: Unicode MMIOProc */
#define MMIO_FINDPROC       0x00040000  /* mmioInstallIOProc: find an MMIOProc */
#define MMIO_FINDCHUNK          0x0010  /* mmioDescend: find a chunk by ID */
#define MMIO_FINDRIFF           0x0020  /* mmioDescend: find a LIST chunk */
#define MMIO_FINDLIST           0x0040  /* mmioDescend: find a RIFF chunk */
#define MMIO_CREATERIFF         0x0020  /* mmioCreateChunk: make a LIST chunk */
#define MMIO_CREATELIST         0x0040  /* mmioCreateChunk: make a RIFF chunk */

/* message numbers for MMIOPROC I/O procedure functions */
#define MMIOM_READ      MMIO_READ       /* read */
#define MMIOM_WRITE    MMIO_WRITE       /* write */
#define MMIOM_SEEK              2       /* seek to a new position in file */
#define MMIOM_OPEN              3       /* open file */
#define MMIOM_CLOSE             4       /* close file */
#define MMIOM_WRITEFLUSH        5       /* write and flush */

#if (WINVER >= 0x030a)
#define MMIOM_RENAME            6       /* rename specified file */
#endif /* ifdef WINVER >= 0x030a */

#define MMIOM_USER         0x8000       /* beginning of user-defined messages */

/* standard four character codes */
#define FOURCC_RIFF     mmioFOURCC('R', 'I', 'F', 'F')
#define FOURCC_LIST     mmioFOURCC('L', 'I', 'S', 'T')

/* four character codes used to identify standard built-in I/O procedures */
#define FOURCC_DOS      mmioFOURCC('D', 'O', 'S', ' ')
#define FOURCC_MEM      mmioFOURCC('M', 'E', 'M', ' ')

/* flags for mmioSeek() */
#ifndef SEEK_SET
#define SEEK_SET        0               /* seek to an absolute position */
#define SEEK_CUR        1               /* seek relative to current position */
#define SEEK_END        2               /* seek relative to end of file */
#endif  /* ifndef SEEK_SET */

/* other constants */
#define MMIO_DEFAULTBUFFER      8192    /* default buffer size */

/* MMIO macros */
#define mmioFOURCC(ch0, ch1, ch2, ch3)  MAKEFOURCC(ch0, ch1, ch2, ch3)

/* MMIO function prototypes */
#ifdef _WIN32

WINMMAPI FOURCC WINAPI mmioStringToFOURCCA(LPCSTR sz, UINT uFlags);
WINMMAPI FOURCC WINAPI mmioStringToFOURCCW(LPCWSTR sz, UINT uFlags);
#ifdef UNICODE
#define mmioStringToFOURCC  mmioStringToFOURCCW
#else
#define mmioStringToFOURCC  mmioStringToFOURCCA
#endif // !UNICODE
WINMMAPI LPMMIOPROC WINAPI mmioInstallIOProcA(FOURCC fccIOProc, LPMMIOPROC pIOProc, DWORD dwFlags);
WINMMAPI LPMMIOPROC WINAPI mmioInstallIOProcW(FOURCC fccIOProc, LPMMIOPROC pIOProc, DWORD dwFlags);
#ifdef UNICODE
#define mmioInstallIOProc  mmioInstallIOProcW
#else
#define mmioInstallIOProc  mmioInstallIOProcA
#endif // !UNICODE
WINMMAPI HMMIO WINAPI mmioOpenA(LPSTR pszFileName, LPMMIOINFO pmmioinfo, DWORD fdwOpen);
WINMMAPI HMMIO WINAPI mmioOpenW(LPWSTR pszFileName, LPMMIOINFO pmmioinfo, DWORD fdwOpen);
#ifdef UNICODE
#define mmioOpen  mmioOpenW
#else
#define mmioOpen  mmioOpenA
#endif // !UNICODE
WINMMAPI MMRESULT WINAPI mmioRenameA(LPCSTR pszFileName, LPCSTR pszNewFileName, LPCMMIOINFO pmmioinfo, DWORD fdwRename);
WINMMAPI MMRESULT WINAPI mmioRenameW(LPCWSTR pszFileName, LPCWSTR pszNewFileName, LPCMMIOINFO pmmioinfo, DWORD fdwRename);
#ifdef UNICODE
#define mmioRename  mmioRenameW
#else
#define mmioRename  mmioRenameA
#endif // !UNICODE
#else
FOURCC WINAPI mmioStringToFOURCC(LPCSTR sz, UINT uFlags);
LPMMIOPROC WINAPI mmioInstallIOProc(FOURCC fccIOProc, LPMMIOPROC pIOProc, DWORD dwFlags);
HMMIO WINAPI mmioOpen(LPSTR pszFileName, LPMMIOINFO pmmioinfo, DWORD fdwOpen);
#if (WINVER >= 0x030a)
MMRESULT WINAPI mmioRename(LPCSTR pszFileName, LPCSTR pszNewFileName, const MMIOINFO FAR* pmmioinfo, DWORD fdwRename);
#endif /* ifdef WINVER >= 0x030a */
#endif

WINMMAPI MMRESULT WINAPI mmioClose(HMMIO hmmio, UINT fuClose);
WINMMAPI LONG WINAPI mmioRead(HMMIO hmmio, HPSTR pch, LONG cch);
WINMMAPI LONG WINAPI mmioWrite(HMMIO hmmio, const char _huge* pch, LONG cch);
WINMMAPI LONG WINAPI mmioSeek(HMMIO hmmio, LONG lOffset, int iOrigin);
WINMMAPI MMRESULT WINAPI mmioGetInfo(HMMIO hmmio, LPMMIOINFO pmmioinfo, UINT fuInfo);
WINMMAPI MMRESULT WINAPI mmioSetInfo(HMMIO hmmio, LPCMMIOINFO pmmioinfo, UINT fuInfo);
WINMMAPI MMRESULT WINAPI mmioSetBuffer(HMMIO hmmio, LPSTR pchBuffer, LONG cchBuffer,
    UINT fuBuffer);
WINMMAPI MMRESULT WINAPI mmioFlush(HMMIO hmmio, UINT fuFlush);
WINMMAPI MMRESULT WINAPI mmioAdvance(HMMIO hmmio, LPMMIOINFO pmmioinfo, UINT fuAdvance);
WINMMAPI LRESULT WINAPI mmioSendMessage(HMMIO hmmio, UINT uMsg,
    LPARAM lParam1, LPARAM lParam2);
WINMMAPI MMRESULT WINAPI mmioDescend(HMMIO hmmio, LPMMCKINFO pmmcki,
    const MMCKINFO FAR* pmmckiParent, UINT fuDescend);
WINMMAPI MMRESULT WINAPI mmioAscend(HMMIO hmmio, LPMMCKINFO pmmcki, UINT fuAscend);
WINMMAPI MMRESULT WINAPI mmioCreateChunk(HMMIO hmmio, LPMMCKINFO pmmcki, UINT fuCreate);

#endif  /* ifndef _WIN32_VXD */
#endif  /* ifndef MMNOMMIO */

#ifndef MMNOMCI
#ifndef _WIN32_VXD
/****************************************************************************

			    MCI support

****************************************************************************/

#ifndef _MCIERROR_              /* MCIERROR is defined in some post 3.1 apps */
#define _MCIERROR_
typedef DWORD   MCIERROR;       /* error return code, 0 means no error */
#endif

#ifndef _MCIDEVICEID_           /* Same with MCIDEVICEID */
#define _MCIDEVICEID_
typedef UINT    MCIDEVICEID;    /* MCI device ID type */
#endif

typedef UINT (CALLBACK *YIELDPROC)(MCIDEVICEID mciId, DWORD dwYieldData);

/* MCI function prototypes */
#ifdef _WIN32

WINMMAPI MCIERROR WINAPI mciSendCommandA(MCIDEVICEID mciId, UINT uMsg, DWORD dwParam1, DWORD dwParam2);
WINMMAPI MCIERROR WINAPI mciSendCommandW(MCIDEVICEID mciId, UINT uMsg, DWORD dwParam1, DWORD dwParam2);
#ifdef UNICODE
#define mciSendCommand  mciSendCommandW
#else
#define mciSendCommand  mciSendCommandA
#endif // !UNICODE
WINMMAPI MCIERROR  WINAPI mciSendStringA(LPCSTR lpstrCommand, LPSTR lpstrReturnString, UINT uReturnLength, HWND hwndCallback);
WINMMAPI MCIERROR  WINAPI mciSendStringW(LPCWSTR lpstrCommand, LPWSTR lpstrReturnString, UINT uReturnLength, HWND hwndCallback);
#ifdef UNICODE
#define mciSendString  mciSendStringW
#else
#define mciSendString  mciSendStringA
#endif // !UNICODE
WINMMAPI MCIDEVICEID WINAPI mciGetDeviceIDA(LPCSTR pszDevice);
WINMMAPI MCIDEVICEID WINAPI mciGetDeviceIDW(LPCWSTR pszDevice);
#ifdef UNICODE
#define mciGetDeviceID  mciGetDeviceIDW
#else
#define mciGetDeviceID  mciGetDeviceIDA
#endif // !UNICODE
WINMMAPI MCIDEVICEID WINAPI mciGetDeviceIDFromElementIDA(DWORD dwElementID, LPCSTR lpstrType );
WINMMAPI MCIDEVICEID WINAPI mciGetDeviceIDFromElementIDW(DWORD dwElementID, LPCWSTR lpstrType );
#ifdef UNICODE
#define mciGetDeviceIDFromElementID  mciGetDeviceIDFromElementIDW
#else
#define mciGetDeviceIDFromElementID  mciGetDeviceIDFromElementIDA
#endif // !UNICODE
WINMMAPI BOOL WINAPI mciGetErrorStringA(MCIERROR mcierr, LPSTR pszText, UINT cchText);
WINMMAPI BOOL WINAPI mciGetErrorStringW(MCIERROR mcierr, LPWSTR pszText, UINT cchText);
#ifdef UNICODE
#define mciGetErrorString  mciGetErrorStringW
#else
#define mciGetErrorString  mciGetErrorStringA
#endif // !UNICODE

#else
MCIERROR WINAPI mciSendCommand(MCIDEVICEID mciId, UINT uMsg, DWORD dwParam1, DWORD dwParam2);
MCIERROR  WINAPI mciSendString(LPCSTR lpstrCommand, LPSTR lpstrReturnString, UINT uReturnLength, HWND hwndCallback);
MCIDEVICEID WINAPI mciGetDeviceID(LPCSTR pszDevice);
BOOL WINAPI mciGetErrorString(MCIERROR mcierr, LPSTR pszText, UINT cchText);
#endif

WINMMAPI BOOL WINAPI mciSetYieldProc(MCIDEVICEID mciId, YIELDPROC fpYieldProc,
    DWORD dwYieldData);

#if (WINVER >= 0x030a)
WINMMAPI HTASK WINAPI mciGetCreatorTask(MCIDEVICEID mciId);
WINMMAPI YIELDPROC WINAPI mciGetYieldProc(MCIDEVICEID mciId, LPDWORD pdwYieldData);
#endif /* ifdef WINVER >= 0x030a */

#if (WINVER < 0x030a)
WINMMAPI BOOL WINAPI mciExecute(LPCSTR pszCommand);
#endif /* ifdef WINVER < 0x030a */

/* MCI error return values */
#define MCIERR_INVALID_DEVICE_ID        (MCIERR_BASE + 1)
#define MCIERR_UNRECOGNIZED_KEYWORD     (MCIERR_BASE + 3)
#define MCIERR_UNRECOGNIZED_COMMAND     (MCIERR_BASE + 5)
#define MCIERR_HARDWARE                 (MCIERR_BASE + 6)
#define MCIERR_INVALID_DEVICE_NAME      (MCIERR_BASE + 7)
#define MCIERR_OUT_OF_MEMORY            (MCIERR_BASE + 8)
#define MCIERR_DEVICE_OPEN              (MCIERR_BASE + 9)
#define MCIERR_CANNOT_LOAD_DRIVER       (MCIERR_BASE + 10)
#define MCIERR_MISSING_COMMAND_STRING   (MCIERR_BASE + 11)
#define MCIERR_PARAM_OVERFLOW           (MCIERR_BASE + 12)
#define MCIERR_MISSING_STRING_ARGUMENT  (MCIERR_BASE + 13)
#define MCIERR_BAD_INTEGER              (MCIERR_BASE + 14)
#define MCIERR_PARSER_INTERNAL          (MCIERR_BASE + 15)
#define MCIERR_DRIVER_INTERNAL          (MCIERR_BASE + 16)
#define MCIERR_MISSING_PARAMETER        (MCIERR_BASE + 17)
#define MCIERR_UNSUPPORTED_FUNCTION     (MCIERR_BASE + 18)
#define MCIERR_FILE_NOT_FOUND           (MCIERR_BASE + 19)
#define MCIERR_DEVICE_NOT_READY         (MCIERR_BASE + 20)
#define MCIERR_INTERNAL                 (MCIERR_BASE + 21)
#define MCIERR_DRIVER                   (MCIERR_BASE + 22)
#define MCIERR_CANNOT_USE_ALL           (MCIERR_BASE + 23)
#define MCIERR_MULTIPLE                 (MCIERR_BASE + 24)
#define MCIERR_EXTENSION_NOT_FOUND      (MCIERR_BASE + 25)
#define MCIERR_OUTOFRANGE               (MCIERR_BASE + 26)
#define MCIERR_FLAGS_NOT_COMPATIBLE     (MCIERR_BASE + 28)
#define MCIERR_FILE_NOT_SAVED           (MCIERR_BASE + 30)
#define MCIERR_DEVICE_TYPE_REQUIRED     (MCIERR_BASE + 31)
#define MCIERR_DEVICE_LOCKED            (MCIERR_BASE + 32)
#define MCIERR_DUPLICATE_ALIAS          (MCIERR_BASE + 33)
#define MCIERR_BAD_CONSTANT             (MCIERR_BASE + 34)
#define MCIERR_MUST_USE_SHAREABLE       (MCIERR_BASE + 35)
#define MCIERR_MISSING_DEVICE_NAME      (MCIERR_BASE + 36)
#define MCIERR_BAD_TIME_FORMAT          (MCIERR_BASE + 37)
#define MCIERR_NO_CLOSING_QUOTE         (MCIERR_BASE + 38)
#define MCIERR_DUPLICATE_FLAGS          (MCIERR_BASE + 39)
#define MCIERR_INVALID_FILE             (MCIERR_BASE + 40)
#define MCIERR_NULL_PARAMETER_BLOCK     (MCIERR_BASE + 41)
#define MCIERR_UNNAMED_RESOURCE         (MCIERR_BASE + 42)
#define MCIERR_NEW_REQUIRES_ALIAS       (MCIERR_BASE + 43)
#define MCIERR_NOTIFY_ON_AUTO_OPEN      (MCIERR_BASE + 44)
#define MCIERR_NO_ELEMENT_ALLOWED       (MCIERR_BASE + 45)
#define MCIERR_NONAPPLICABLE_FUNCTION   (MCIERR_BASE + 46)
#define MCIERR_ILLEGAL_FOR_AUTO_OPEN    (MCIERR_BASE + 47)
#define MCIERR_FILENAME_REQUIRED        (MCIERR_BASE + 48)
#define MCIERR_EXTRA_CHARACTERS         (MCIERR_BASE + 49)
#define MCIERR_DEVICE_NOT_INSTALLED     (MCIERR_BASE + 50)
#define MCIERR_GET_CD                   (MCIERR_BASE + 51)
#define MCIERR_SET_CD                   (MCIERR_BASE + 52)
#define MCIERR_SET_DRIVE                (MCIERR_BASE + 53)
#define MCIERR_DEVICE_LENGTH            (MCIERR_BASE + 54)
#define MCIERR_DEVICE_ORD_LENGTH        (MCIERR_BASE + 55)
#define MCIERR_NO_INTEGER               (MCIERR_BASE + 56)

#define MCIERR_WAVE_OUTPUTSINUSE        (MCIERR_BASE + 64)
#define MCIERR_WAVE_SETOUTPUTINUSE      (MCIERR_BASE + 65)
#define MCIERR_WAVE_INPUTSINUSE         (MCIERR_BASE + 66)
#define MCIERR_WAVE_SETINPUTINUSE       (MCIERR_BASE + 67)
#define MCIERR_WAVE_OUTPUTUNSPECIFIED   (MCIERR_BASE + 68)
#define MCIERR_WAVE_INPUTUNSPECIFIED    (MCIERR_BASE + 69)
#define MCIERR_WAVE_OUTPUTSUNSUITABLE   (MCIERR_BASE + 70)
#define MCIERR_WAVE_SETOUTPUTUNSUITABLE (MCIERR_BASE + 71)
#define MCIERR_WAVE_INPUTSUNSUITABLE    (MCIERR_BASE + 72)
#define MCIERR_WAVE_SETINPUTUNSUITABLE  (MCIERR_BASE + 73)

#define MCIERR_SEQ_DIV_INCOMPATIBLE     (MCIERR_BASE + 80)
#define MCIERR_SEQ_PORT_INUSE           (MCIERR_BASE + 81)
#define MCIERR_SEQ_PORT_NONEXISTENT     (MCIERR_BASE + 82)
#define MCIERR_SEQ_PORT_MAPNODEVICE     (MCIERR_BASE + 83)
#define MCIERR_SEQ_PORT_MISCERROR       (MCIERR_BASE + 84)
#define MCIERR_SEQ_TIMER                (MCIERR_BASE + 85)
#define MCIERR_SEQ_PORTUNSPECIFIED      (MCIERR_BASE + 86)
#define MCIERR_SEQ_NOMIDIPRESENT        (MCIERR_BASE + 87)

#define MCIERR_NO_WINDOW                (MCIERR_BASE + 90)
#define MCIERR_CREATEWINDOW             (MCIERR_BASE + 91)
#define MCIERR_FILE_READ                (MCIERR_BASE + 92)
#define MCIERR_FILE_WRITE               (MCIERR_BASE + 93)

#define MCIERR_NO_IDENTITY              (MCIERR_BASE + 94)

/* all custom device driver errors must be >= than this value */
#define MCIERR_CUSTOM_DRIVER_BASE       (MCIERR_BASE + 256)

#define MCI_FIRST                       DRV_MCI_FIRST   /* 0x0800 */
/* MCI command message identifiers */
#define MCI_OPEN                        0x0803
#define MCI_CLOSE                       0x0804
#define MCI_ESCAPE                      0x0805
#define MCI_PLAY                        0x0806
#define MCI_SEEK                        0x0807
#define MCI_STOP                        0x0808
#define MCI_PAUSE                       0x0809
#define MCI_INFO                        0x080A
#define MCI_GETDEVCAPS                  0x080B
#define MCI_SPIN                        0x080C
#define MCI_SET                         0x080D
#define MCI_STEP                        0x080E
#define MCI_RECORD                      0x080F
#define MCI_SYSINFO                     0x0810
#define MCI_BREAK                       0x0811
#define MCI_SAVE                        0x0813
#define MCI_STATUS                      0x0814
#define MCI_CUE                         0x0830
#define MCI_REALIZE                     0x0840
#define MCI_WINDOW                      0x0841
#define MCI_PUT                         0x0842
#define MCI_WHERE                       0x0843
#define MCI_FREEZE                      0x0844
#define MCI_UNFREEZE                    0x0845
#define MCI_LOAD                        0x0850
#define MCI_CUT                         0x0851
#define MCI_COPY                        0x0852
#define MCI_PASTE                       0x0853
#define MCI_UPDATE                      0x0854
#define MCI_RESUME                      0x0855
#define MCI_DELETE                      0x0856

/* all custom MCI command messages must be >= than this value */
#define MCI_USER_MESSAGES               (DRV_MCI_FIRST + 0x400)
#define MCI_LAST                        0x0FFF

/* device ID for "all devices" */
#define MCI_ALL_DEVICE_ID               ((MCIDEVICEID)-1)

/* constants for predefined MCI device types */
#define MCI_DEVTYPE_VCR                 513 /* (MCI_STRING_OFFSET + 1) */
#define MCI_DEVTYPE_VIDEODISC           514 /* (MCI_STRING_OFFSET + 2) */
#define MCI_DEVTYPE_OVERLAY             515 /* (MCI_STRING_OFFSET + 3) */
#define MCI_DEVTYPE_CD_AUDIO            516 /* (MCI_STRING_OFFSET + 4) */
#define MCI_DEVTYPE_DAT                 517 /* (MCI_STRING_OFFSET + 5) */
#define MCI_DEVTYPE_SCANNER             518 /* (MCI_STRING_OFFSET + 6) */
#define MCI_DEVTYPE_ANIMATION           519 /* (MCI_STRING_OFFSET + 7) */
#define MCI_DEVTYPE_DIGITAL_VIDEO       520 /* (MCI_STRING_OFFSET + 8) */
#define MCI_DEVTYPE_OTHER               521 /* (MCI_STRING_OFFSET + 9) */
#define MCI_DEVTYPE_WAVEFORM_AUDIO      522 /* (MCI_STRING_OFFSET + 10) */
#define MCI_DEVTYPE_SEQUENCER           523 /* (MCI_STRING_OFFSET + 11) */

#define MCI_DEVTYPE_FIRST               MCI_DEVTYPE_VCR
#define MCI_DEVTYPE_LAST                MCI_DEVTYPE_SEQUENCER

#define MCI_DEVTYPE_FIRST_USER          0x1000
/* return values for 'status mode' command */
#define MCI_MODE_NOT_READY              (MCI_STRING_OFFSET + 12)
#define MCI_MODE_STOP                   (MCI_STRING_OFFSET + 13)
#define MCI_MODE_PLAY                   (MCI_STRING_OFFSET + 14)
#define MCI_MODE_RECORD                 (MCI_STRING_OFFSET + 15)
#define MCI_MODE_SEEK                   (MCI_STRING_OFFSET + 16)
#define MCI_MODE_PAUSE                  (MCI_STRING_OFFSET + 17)
#define MCI_MODE_OPEN                   (MCI_STRING_OFFSET + 18)

/* constants used in 'set time format' and 'status time format' commands */
#define MCI_FORMAT_MILLISECONDS         0
#define MCI_FORMAT_HMS                  1
#define MCI_FORMAT_MSF                  2
#define MCI_FORMAT_FRAMES               3
#define MCI_FORMAT_SMPTE_24             4
#define MCI_FORMAT_SMPTE_25             5
#define MCI_FORMAT_SMPTE_30             6
#define MCI_FORMAT_SMPTE_30DROP         7
#define MCI_FORMAT_BYTES                8
#define MCI_FORMAT_SAMPLES              9
#define MCI_FORMAT_TMSF                 10

/* MCI time format conversion macros */
#define MCI_MSF_MINUTE(msf)             ((BYTE)(msf))
#define MCI_MSF_SECOND(msf)             ((BYTE)(((WORD)(msf)) >> 8))
#define MCI_MSF_FRAME(msf)              ((BYTE)((msf)>>16))

#define MCI_MAKE_MSF(m, s, f)           ((DWORD)(((BYTE)(m) | \
						  ((WORD)(s)<<8)) | \
						 (((DWORD)(BYTE)(f))<<16)))

#define MCI_TMSF_TRACK(tmsf)            ((BYTE)(tmsf))
#define MCI_TMSF_MINUTE(tmsf)           ((BYTE)(((WORD)(tmsf)) >> 8))
#define MCI_TMSF_SECOND(tmsf)           ((BYTE)((tmsf)>>16))
#define MCI_TMSF_FRAME(tmsf)            ((BYTE)((tmsf)>>24))

#define MCI_MAKE_TMSF(t, m, s, f)       ((DWORD)(((BYTE)(t) | \
						  ((WORD)(m)<<8)) | \
						 (((DWORD)(BYTE)(s) | \
						   ((WORD)(f)<<8))<<16)))

#define MCI_HMS_HOUR(hms)               ((BYTE)(hms))
#define MCI_HMS_MINUTE(hms)             ((BYTE)(((WORD)(hms)) >> 8))
#define MCI_HMS_SECOND(hms)             ((BYTE)((hms)>>16))

#define MCI_MAKE_HMS(h, m, s)           ((DWORD)(((BYTE)(h) | \
						  ((WORD)(m)<<8)) | \
						 (((DWORD)(BYTE)(s))<<16)))

/* flags for wParam of MM_MCINOTIFY message */
#define MCI_NOTIFY_SUCCESSFUL           0x0001
#define MCI_NOTIFY_SUPERSEDED           0x0002
#define MCI_NOTIFY_ABORTED              0x0004
#define MCI_NOTIFY_FAILURE              0x0008

/* common flags for dwFlags parameter of MCI command messages */
#define MCI_NOTIFY                      0x00000001L
#define MCI_WAIT                        0x00000002L
#define MCI_FROM                        0x00000004L
#define MCI_TO                          0x00000008L
#define MCI_TRACK                       0x00000010L

/* flags for dwFlags parameter of MCI_OPEN command message */
#define MCI_OPEN_SHAREABLE              0x00000100L
#define MCI_OPEN_ELEMENT                0x00000200L
#define MCI_OPEN_ALIAS                  0x00000400L
#define MCI_OPEN_ELEMENT_ID             0x00000800L
#define MCI_OPEN_TYPE_ID                0x00001000L
#define MCI_OPEN_TYPE                   0x00002000L

/* flags for dwFlags parameter of MCI_SEEK command message */
#define MCI_SEEK_TO_START               0x00000100L
#define MCI_SEEK_TO_END                 0x00000200L

/* flags for dwFlags parameter of MCI_STATUS command message */
#define MCI_STATUS_ITEM                 0x00000100L
#define MCI_STATUS_START                0x00000200L

/* flags for dwItem field of the MCI_STATUS_PARMS parameter block */
#define MCI_STATUS_LENGTH               0x00000001L
#define MCI_STATUS_POSITION             0x00000002L
#define MCI_STATUS_NUMBER_OF_TRACKS     0x00000003L
#define MCI_STATUS_MODE                 0x00000004L
#define MCI_STATUS_MEDIA_PRESENT        0x00000005L
#define MCI_STATUS_TIME_FORMAT          0x00000006L
#define MCI_STATUS_READY                0x00000007L
#define MCI_STATUS_CURRENT_TRACK        0x00000008L

/* flags for dwFlags parameter of MCI_INFO command message */
#define MCI_INFO_PRODUCT                0x00000100L
#define MCI_INFO_FILE                   0x00000200L
#define MCI_INFO_MEDIA_UPC              0x00000400L
#define MCI_INFO_MEDIA_IDENTITY         0x00000800L
#define MCI_INFO_NAME                   0x00001000L
#define MCI_INFO_COPYRIGHT              0x00002000L

/* flags for dwFlags parameter of MCI_GETDEVCAPS command message */
#define MCI_GETDEVCAPS_ITEM             0x00000100L

/* flags for dwItem field of the MCI_GETDEVCAPS_PARMS parameter block */
#define MCI_GETDEVCAPS_CAN_RECORD       0x00000001L
#define MCI_GETDEVCAPS_HAS_AUDIO        0x00000002L
#define MCI_GETDEVCAPS_HAS_VIDEO        0x00000003L
#define MCI_GETDEVCAPS_DEVICE_TYPE      0x00000004L
#define MCI_GETDEVCAPS_USES_FILES       0x00000005L
#define MCI_GETDEVCAPS_COMPOUND_DEVICE  0x00000006L
#define MCI_GETDEVCAPS_CAN_EJECT        0x00000007L
#define MCI_GETDEVCAPS_CAN_PLAY         0x00000008L
#define MCI_GETDEVCAPS_CAN_SAVE         0x00000009L

/* flags for dwFlags parameter of MCI_SYSINFO command message */
#define MCI_SYSINFO_QUANTITY            0x00000100L
#define MCI_SYSINFO_OPEN                0x00000200L
#define MCI_SYSINFO_NAME                0x00000400L
#define MCI_SYSINFO_INSTALLNAME         0x00000800L

/* flags for dwFlags parameter of MCI_SET command message */
#define MCI_SET_DOOR_OPEN               0x00000100L
#define MCI_SET_DOOR_CLOSED             0x00000200L
#define MCI_SET_TIME_FORMAT             0x00000400L
#define MCI_SET_AUDIO                   0x00000800L
#define MCI_SET_VIDEO                   0x00001000L
#define MCI_SET_ON                      0x00002000L
#define MCI_SET_OFF                     0x00004000L

/* flags for dwAudio field of MCI_SET_PARMS or MCI_SEQ_SET_PARMS */
#define MCI_SET_AUDIO_ALL               0x00000000L
#define MCI_SET_AUDIO_LEFT              0x00000001L
#define MCI_SET_AUDIO_RIGHT             0x00000002L

/* flags for dwFlags parameter of MCI_BREAK command message */
#define MCI_BREAK_KEY                   0x00000100L
#define MCI_BREAK_HWND                  0x00000200L
#define MCI_BREAK_OFF                   0x00000400L

/* flags for dwFlags parameter of MCI_RECORD command message */
#define MCI_RECORD_INSERT               0x00000100L
#define MCI_RECORD_OVERWRITE            0x00000200L

/* flags for dwFlags parameter of MCI_SAVE command message */
#define MCI_SAVE_FILE                   0x00000100L

/* flags for dwFlags parameter of MCI_LOAD command message */
#define MCI_LOAD_FILE                   0x00000100L

/* generic parameter block for MCI command messages with no special parameters */
typedef struct tagMCI_GENERIC_PARMS {
    DWORD   dwCallback;
} MCI_GENERIC_PARMS, *PMCI_GENERIC_PARMS, FAR *LPMCI_GENERIC_PARMS;

/* parameter block for MCI_OPEN command message */
#ifdef _WIN32

typedef struct tagMCI_OPEN_PARMSA {
    DWORD   dwCallback;
    MCIDEVICEID wDeviceID;
    LPCSTR     lpstrDeviceType;
    LPCSTR     lpstrElementName;
    LPCSTR     lpstrAlias;
} MCI_OPEN_PARMSA, *PMCI_OPEN_PARMSA, *LPMCI_OPEN_PARMSA;
typedef struct tagMCI_OPEN_PARMSW {
    DWORD   dwCallback;
    MCIDEVICEID wDeviceID;
    LPCWSTR    lpstrDeviceType;
    LPCWSTR    lpstrElementName;
    LPCWSTR    lpstrAlias;
} MCI_OPEN_PARMSW, *PMCI_OPEN_PARMSW, *LPMCI_OPEN_PARMSW;
#ifdef UNICODE
typedef MCI_OPEN_PARMSW MCI_OPEN_PARMS;
typedef PMCI_OPEN_PARMSW PMCI_OPEN_PARMS;
typedef LPMCI_OPEN_PARMSW LPMCI_OPEN_PARMS;
#else
typedef MCI_OPEN_PARMSA MCI_OPEN_PARMS;
typedef PMCI_OPEN_PARMSA PMCI_OPEN_PARMS;
typedef LPMCI_OPEN_PARMSA LPMCI_OPEN_PARMS;
#endif // UNICODE

#else
typedef struct tagMCI_OPEN_PARMS {
    DWORD       dwCallback;
    MCIDEVICEID wDeviceID;
    WORD        wReserved0;
    LPCSTR      lpstrDeviceType;
    LPCSTR      lpstrElementName;
    LPCSTR      lpstrAlias;
} MCI_OPEN_PARMS, FAR *LPMCI_OPEN_PARMS;
#endif

/* parameter block for MCI_PLAY command message */
typedef struct tagMCI_PLAY_PARMS {
    DWORD   dwCallback;
    DWORD   dwFrom;
    DWORD   dwTo;
} MCI_PLAY_PARMS, *PMCI_PLAY_PARMS, FAR *LPMCI_PLAY_PARMS;

/* parameter block for MCI_SEEK command message */
typedef struct tagMCI_SEEK_PARMS {
    DWORD   dwCallback;
    DWORD   dwTo;
} MCI_SEEK_PARMS, *PMCI_SEEK_PARMS, FAR *LPMCI_SEEK_PARMS;

/* parameter block for MCI_STATUS command message */
typedef struct tagMCI_STATUS_PARMS {
    DWORD   dwCallback;
    DWORD   dwReturn;
    DWORD   dwItem;
    DWORD   dwTrack;
} MCI_STATUS_PARMS, *PMCI_STATUS_PARMS, FAR * LPMCI_STATUS_PARMS;

/* parameter block for MCI_INFO command message */
#ifdef _WIN32

typedef struct tagMCI_INFO_PARMSA {
    DWORD   dwCallback;
    LPSTR   lpstrReturn;
    DWORD   dwRetSize;
} MCI_INFO_PARMSA, * LPMCI_INFO_PARMSA;
typedef struct tagMCI_INFO_PARMSW {
    DWORD   dwCallback;
    LPWSTR  lpstrReturn;
    DWORD   dwRetSize;
} MCI_INFO_PARMSW, * LPMCI_INFO_PARMSW;
#ifdef UNICODE
typedef MCI_INFO_PARMSW MCI_INFO_PARMS;
typedef LPMCI_INFO_PARMSW LPMCI_INFO_PARMS;
#else
typedef MCI_INFO_PARMSA MCI_INFO_PARMS;
typedef LPMCI_INFO_PARMSA LPMCI_INFO_PARMS;
#endif // UNICODE

#else
typedef struct tagMCI_INFO_PARMS {
    DWORD   dwCallback;
    LPSTR   lpstrReturn;
    DWORD   dwRetSize;
} MCI_INFO_PARMS, FAR * LPMCI_INFO_PARMS;
#endif

/* parameter block for MCI_GETDEVCAPS command message */
typedef struct tagMCI_GETDEVCAPS_PARMS {
    DWORD   dwCallback;
    DWORD   dwReturn;
    DWORD   dwItem;
} MCI_GETDEVCAPS_PARMS, *PMCI_GETDEVCAPS_PARMS, FAR * LPMCI_GETDEVCAPS_PARMS;

/* parameter block for MCI_SYSINFO command message */
#ifdef _WIN32

typedef struct tagMCI_SYSINFO_PARMSA {
    DWORD   dwCallback;
    LPSTR   lpstrReturn;
    DWORD   dwRetSize;
    DWORD   dwNumber;
    UINT    wDeviceType;
} MCI_SYSINFO_PARMSA, *PMCI_SYSINFO_PARMSA, * LPMCI_SYSINFO_PARMSA;
typedef struct tagMCI_SYSINFO_PARMSW {
    DWORD   dwCallback;
    LPWSTR  lpstrReturn;
    DWORD   dwRetSize;
    DWORD   dwNumber;
    UINT    wDeviceType;
} MCI_SYSINFO_PARMSW, *PMCI_SYSINFO_PARMSW, * LPMCI_SYSINFO_PARMSW;
#ifdef UNICODE
typedef MCI_SYSINFO_PARMSW MCI_SYSINFO_PARMS;
typedef PMCI_SYSINFO_PARMSW PMCI_SYSINFO_PARMS;
typedef LPMCI_SYSINFO_PARMSW LPMCI_SYSINFO_PARMS;
#else
typedef MCI_SYSINFO_PARMSA MCI_SYSINFO_PARMS;
typedef PMCI_SYSINFO_PARMSA PMCI_SYSINFO_PARMS;
typedef LPMCI_SYSINFO_PARMSA LPMCI_SYSINFO_PARMS;
#endif // UNICODE
#else
typedef struct tagMCI_SYSINFO_PARMS {
    DWORD   dwCallback;
    LPSTR   lpstrReturn;
    DWORD   dwRetSize;
    DWORD   dwNumber;
    WORD    wDeviceType;
    WORD    wReserved0;
} MCI_SYSINFO_PARMS, FAR * LPMCI_SYSINFO_PARMS;
#endif

/* parameter block for MCI_SET command message */
typedef struct tagMCI_SET_PARMS {
    DWORD   dwCallback;
    DWORD   dwTimeFormat;
    DWORD   dwAudio;
} MCI_SET_PARMS, *PMCI_SET_PARMS, FAR *LPMCI_SET_PARMS;

/* parameter block for MCI_BREAK command message */
typedef struct tagMCI_BREAK_PARMS {
    DWORD   dwCallback;
#ifdef _WIN32
    int     nVirtKey;
    HWND    hwndBreak;
#else
    short   nVirtKey;
    WORD    wReserved0;             /* padding for Win 16 */
    HWND    hwndBreak;
    WORD    wReserved1;             /* padding for Win 16 */
#endif
} MCI_BREAK_PARMS, *PMCI_BREAK_PARMS, FAR * LPMCI_BREAK_PARMS;

/* parameter block for MCI_SAVE command message */
#ifdef _WIN32

typedef struct tagMCI_SAVE_PARMSA {
    DWORD    dwCallback;
    LPCSTR    lpfilename;
} MCI_SAVE_PARMSA, *PMCI_SAVE_PARMSA, * LPMCI_SAVE_PARMSA;
typedef struct tagMCI_SAVE_PARMSW {
    DWORD    dwCallback;
    LPCWSTR   lpfilename;
} MCI_SAVE_PARMSW, *PMCI_SAVE_PARMSW, * LPMCI_SAVE_PARMSW;
#ifdef UNICODE
typedef MCI_SAVE_PARMSW MCI_SAVE_PARMS;
typedef PMCI_SAVE_PARMSW PMCI_SAVE_PARMS;
typedef LPMCI_SAVE_PARMSW LPMCI_SAVE_PARMS;
#else
typedef MCI_SAVE_PARMSA MCI_SAVE_PARMS;
typedef PMCI_SAVE_PARMSA PMCI_SAVE_PARMS;
typedef LPMCI_SAVE_PARMSA LPMCI_SAVE_PARMS;
#endif // UNICODE

#else
typedef struct tagMCI_SAVE_PARMS {
    DWORD   dwCallback;
    LPCSTR  lpfilename;
} MCI_SAVE_PARMS, FAR * LPMCI_SAVE_PARMS;
#endif

/* parameter block for MCI_LOAD command message */
#ifdef _WIN32

typedef struct tagMCI_LOAD_PARMSA {
    DWORD    dwCallback;
    LPCSTR      lpfilename;
} MCI_LOAD_PARMSA, *PMCI_LOAD_PARMSA, * LPMCI_LOAD_PARMSA;
typedef struct tagMCI_LOAD_PARMSW {
    DWORD    dwCallback;
    LPCWSTR     lpfilename;
} MCI_LOAD_PARMSW, *PMCI_LOAD_PARMSW, * LPMCI_LOAD_PARMSW;
#ifdef UNICODE
typedef MCI_LOAD_PARMSW MCI_LOAD_PARMS;
typedef PMCI_LOAD_PARMSW PMCI_LOAD_PARMS;
typedef LPMCI_LOAD_PARMSW LPMCI_LOAD_PARMS;
#else
typedef MCI_LOAD_PARMSA MCI_LOAD_PARMS;
typedef PMCI_LOAD_PARMSA PMCI_LOAD_PARMS;
typedef LPMCI_LOAD_PARMSA LPMCI_LOAD_PARMS;
#endif // UNICODE

#else
typedef struct tagMCI_LOAD_PARMS {
    DWORD   dwCallback;
    LPCSTR  lpfilename;
} MCI_LOAD_PARMS, FAR * LPMCI_LOAD_PARMS;
#endif

/* parameter block for MCI_RECORD command message */
typedef struct tagMCI_RECORD_PARMS {
    DWORD   dwCallback;
    DWORD   dwFrom;
    DWORD   dwTo;
} MCI_RECORD_PARMS, FAR *LPMCI_RECORD_PARMS;

/* MCI extensions for videodisc devices */

/* flag for dwReturn field of MCI_STATUS_PARMS */
/* MCI_STATUS command, (dwItem == MCI_STATUS_MODE) */
#define MCI_VD_MODE_PARK                (MCI_VD_OFFSET + 1)

/* flag for dwReturn field of MCI_STATUS_PARMS */
/* MCI_STATUS command, (dwItem == MCI_VD_STATUS_MEDIA_TYPE) */
#define MCI_VD_MEDIA_CLV                (MCI_VD_OFFSET + 2)
#define MCI_VD_MEDIA_CAV                (MCI_VD_OFFSET + 3)
#define MCI_VD_MEDIA_OTHER              (MCI_VD_OFFSET + 4)

#define MCI_VD_FORMAT_TRACK             0x4001

/* flags for dwFlags parameter of MCI_PLAY command message */
#define MCI_VD_PLAY_REVERSE             0x00010000L
#define MCI_VD_PLAY_FAST                0x00020000L
#define MCI_VD_PLAY_SPEED               0x00040000L
#define MCI_VD_PLAY_SCAN                0x00080000L
#define MCI_VD_PLAY_SLOW                0x00100000L

/* flag for dwFlags parameter of MCI_SEEK command message */
#define MCI_VD_SEEK_REVERSE             0x00010000L

/* flags for dwItem field of MCI_STATUS_PARMS parameter block */
#define MCI_VD_STATUS_SPEED             0x00004002L
#define MCI_VD_STATUS_FORWARD           0x00004003L
#define MCI_VD_STATUS_MEDIA_TYPE        0x00004004L
#define MCI_VD_STATUS_SIDE              0x00004005L
#define MCI_VD_STATUS_DISC_SIZE         0x00004006L

/* flags for dwFlags parameter of MCI_GETDEVCAPS command message */
#define MCI_VD_GETDEVCAPS_CLV           0x00010000L
#define MCI_VD_GETDEVCAPS_CAV           0x00020000L

#define MCI_VD_SPIN_UP                  0x00010000L
#define MCI_VD_SPIN_DOWN                0x00020000L

/* flags for dwItem field of MCI_GETDEVCAPS_PARMS parameter block */
#define MCI_VD_GETDEVCAPS_CAN_REVERSE   0x00004002L
#define MCI_VD_GETDEVCAPS_FAST_RATE     0x00004003L
#define MCI_VD_GETDEVCAPS_SLOW_RATE     0x00004004L
#define MCI_VD_GETDEVCAPS_NORMAL_RATE   0x00004005L

/* flags for the dwFlags parameter of MCI_STEP command message */
#define MCI_VD_STEP_FRAMES              0x00010000L
#define MCI_VD_STEP_REVERSE             0x00020000L

/* flag for the MCI_ESCAPE command message */
#define MCI_VD_ESCAPE_STRING            0x00000100L

/* parameter block for MCI_PLAY command message */
typedef struct tagMCI_VD_PLAY_PARMS {
    DWORD   dwCallback;
    DWORD   dwFrom;
    DWORD   dwTo;
    DWORD   dwSpeed;
} MCI_VD_PLAY_PARMS, *PMCI_VD_PLAY_PARMS, FAR *LPMCI_VD_PLAY_PARMS;

/* parameter block for MCI_STEP command message */
typedef struct tagMCI_VD_STEP_PARMS {
    DWORD   dwCallback;
    DWORD   dwFrames;
} MCI_VD_STEP_PARMS, *PMCI_VD_STEP_PARMS, FAR *LPMCI_VD_STEP_PARMS;

/* parameter block for MCI_ESCAPE command message */
#ifdef _WIN32

typedef struct tagMCI_VD_ESCAPE_PARMSA {
    DWORD   dwCallback;
    LPCSTR      lpstrCommand;
} MCI_VD_ESCAPE_PARMSA, *PMCI_VD_ESCAPE_PARMSA, *LPMCI_VD_ESCAPE_PARMSA;
typedef struct tagMCI_VD_ESCAPE_PARMSW {
    DWORD   dwCallback;
    LPCWSTR     lpstrCommand;
} MCI_VD_ESCAPE_PARMSW, *PMCI_VD_ESCAPE_PARMSW, *LPMCI_VD_ESCAPE_PARMSW;
#ifdef UNICODE
typedef MCI_VD_ESCAPE_PARMSW MCI_VD_ESCAPE_PARMS;
typedef PMCI_VD_ESCAPE_PARMSW PMCI_VD_ESCAPE_PARMS;
typedef LPMCI_VD_ESCAPE_PARMSW LPMCI_VD_ESCAPE_PARMS;
#else
typedef MCI_VD_ESCAPE_PARMSA MCI_VD_ESCAPE_PARMS;
typedef PMCI_VD_ESCAPE_PARMSA PMCI_VD_ESCAPE_PARMS;
typedef LPMCI_VD_ESCAPE_PARMSA LPMCI_VD_ESCAPE_PARMS;
#endif // UNICODE

#else
typedef struct tagMCI_VD_ESCAPE_PARMS {
    DWORD   dwCallback;
    LPCSTR  lpstrCommand;
} MCI_VD_ESCAPE_PARMS, FAR *LPMCI_VD_ESCAPE_PARMS;
#endif

/* MCI extensions for CD audio devices */

/* flags for the dwItem field of the MCI_STATUS_PARMS parameter block */
#define MCI_CDA_STATUS_TYPE_TRACK       0x00004001L

/* flags for the dwReturn field of MCI_STATUS_PARMS parameter block */
/* MCI_STATUS command, (dwItem == MCI_CDA_STATUS_TYPE_TRACK) */
#define MCI_CDA_TRACK_AUDIO             (MCI_CD_OFFSET + 0)
#define MCI_CDA_TRACK_OTHER             (MCI_CD_OFFSET + 1)

/* MCI extensions for waveform audio devices */

#define MCI_WAVE_PCM                    (MCI_WAVE_OFFSET + 0)
#define MCI_WAVE_MAPPER                 (MCI_WAVE_OFFSET + 1)

/* flags for the dwFlags parameter of MCI_OPEN command message */
#define MCI_WAVE_OPEN_BUFFER            0x00010000L

/* flags for the dwFlags parameter of MCI_SET command message */
#define MCI_WAVE_SET_FORMATTAG          0x00010000L
#define MCI_WAVE_SET_CHANNELS           0x00020000L
#define MCI_WAVE_SET_SAMPLESPERSEC      0x00040000L
#define MCI_WAVE_SET_AVGBYTESPERSEC     0x00080000L
#define MCI_WAVE_SET_BLOCKALIGN         0x00100000L
#define MCI_WAVE_SET_BITSPERSAMPLE      0x00200000L

/* flags for the dwFlags parameter of MCI_STATUS, MCI_SET command messages */
#define MCI_WAVE_INPUT                  0x00400000L
#define MCI_WAVE_OUTPUT                 0x00800000L

/* flags for the dwItem field of MCI_STATUS_PARMS parameter block */
#define MCI_WAVE_STATUS_FORMATTAG       0x00004001L
#define MCI_WAVE_STATUS_CHANNELS        0x00004002L
#define MCI_WAVE_STATUS_SAMPLESPERSEC   0x00004003L
#define MCI_WAVE_STATUS_AVGBYTESPERSEC  0x00004004L
#define MCI_WAVE_STATUS_BLOCKALIGN      0x00004005L
#define MCI_WAVE_STATUS_BITSPERSAMPLE   0x00004006L
#define MCI_WAVE_STATUS_LEVEL           0x00004007L

/* flags for the dwFlags parameter of MCI_SET command message */
#define MCI_WAVE_SET_ANYINPUT           0x04000000L
#define MCI_WAVE_SET_ANYOUTPUT          0x08000000L

/* flags for the dwFlags parameter of MCI_GETDEVCAPS command message */
#define MCI_WAVE_GETDEVCAPS_INPUTS      0x00004001L
#define MCI_WAVE_GETDEVCAPS_OUTPUTS     0x00004002L

/* parameter block for MCI_OPEN command message */
#ifdef _WIN32

typedef struct tagMCI_WAVE_OPEN_PARMSA {
    DWORD   dwCallback;
    MCIDEVICEID wDeviceID;
    LPCSTR      lpstrDeviceType;
    LPCSTR      lpstrElementName;
    LPCSTR      lpstrAlias;
    DWORD   dwBufferSeconds;
} MCI_WAVE_OPEN_PARMSA, *PMCI_WAVE_OPEN_PARMSA, *LPMCI_WAVE_OPEN_PARMSA;
typedef struct tagMCI_WAVE_OPEN_PARMSW {
    DWORD   dwCallback;
    MCIDEVICEID wDeviceID;
    LPCWSTR     lpstrDeviceType;
    LPCWSTR     lpstrElementName;
    LPCWSTR     lpstrAlias;
    DWORD   dwBufferSeconds;
} MCI_WAVE_OPEN_PARMSW, *PMCI_WAVE_OPEN_PARMSW, *LPMCI_WAVE_OPEN_PARMSW;
#ifdef UNICODE
typedef MCI_WAVE_OPEN_PARMSW MCI_WAVE_OPEN_PARMS;
typedef PMCI_WAVE_OPEN_PARMSW PMCI_WAVE_OPEN_PARMS;
typedef LPMCI_WAVE_OPEN_PARMSW LPMCI_WAVE_OPEN_PARMS;
#else
typedef MCI_WAVE_OPEN_PARMSA MCI_WAVE_OPEN_PARMS;
typedef PMCI_WAVE_OPEN_PARMSA PMCI_WAVE_OPEN_PARMS;
typedef LPMCI_WAVE_OPEN_PARMSA LPMCI_WAVE_OPEN_PARMS;
#endif // UNICODE

#else
typedef struct tagMCI_WAVE_OPEN_PARMS {
    DWORD   dwCallback;
    MCIDEVICEID wDeviceID;
    WORD        wReserved0;
    LPCSTR      lpstrDeviceType;
    LPCSTR      lpstrElementName;
    LPCSTR      lpstrAlias;
    DWORD       dwBufferSeconds;
} MCI_WAVE_OPEN_PARMS, FAR *LPMCI_WAVE_OPEN_PARMS;
#endif

/* parameter block for MCI_DELETE command message */
typedef struct tagMCI_WAVE_DELETE_PARMS {
    DWORD   dwCallback;
    DWORD   dwFrom;
    DWORD   dwTo;
} MCI_WAVE_DELETE_PARMS, *PMCI_WAVE_DELETE_PARMS, FAR *LPMCI_WAVE_DELETE_PARMS;

/* parameter block for MCI_SET command message */
typedef struct tagMCI_WAVE_SET_PARMS {
    DWORD   dwCallback;
    DWORD   dwTimeFormat;
    DWORD   dwAudio;
#ifdef _WIN32
    UINT    wInput;
    UINT    wOutput;
#else
    WORD    wInput;
    WORD    wReserved0;
    WORD    wOutput;
    WORD    wReserved1;
#endif
    WORD    wFormatTag;
    WORD    wReserved2;
    WORD    nChannels;
    WORD    wReserved3;
    DWORD   nSamplesPerSec;
    DWORD   nAvgBytesPerSec;
    WORD    nBlockAlign;
    WORD    wReserved4;
    WORD    wBitsPerSample;
    WORD    wReserved5;
} MCI_WAVE_SET_PARMS, *PMCI_WAVE_SET_PARMS, FAR * LPMCI_WAVE_SET_PARMS;

/* MCI extensions for MIDI sequencer devices */

/* flags for the dwReturn field of MCI_STATUS_PARMS parameter block */
/* MCI_STATUS command, (dwItem == MCI_SEQ_STATUS_DIVTYPE) */
#define     MCI_SEQ_DIV_PPQN            (0 + MCI_SEQ_OFFSET)
#define     MCI_SEQ_DIV_SMPTE_24        (1 + MCI_SEQ_OFFSET)
#define     MCI_SEQ_DIV_SMPTE_25        (2 + MCI_SEQ_OFFSET)
#define     MCI_SEQ_DIV_SMPTE_30DROP    (3 + MCI_SEQ_OFFSET)
#define     MCI_SEQ_DIV_SMPTE_30        (4 + MCI_SEQ_OFFSET)

/* flags for the dwMaster field of MCI_SEQ_SET_PARMS parameter block */
/* MCI_SET command, (dwFlags == MCI_SEQ_SET_MASTER) */
#define     MCI_SEQ_FORMAT_SONGPTR      0x4001
#define     MCI_SEQ_FILE                0x4002
#define     MCI_SEQ_MIDI                0x4003
#define     MCI_SEQ_SMPTE               0x4004
#define     MCI_SEQ_NONE                65533
#define     MCI_SEQ_MAPPER              65535

/* flags for the dwItem field of MCI_STATUS_PARMS parameter block */
#define MCI_SEQ_STATUS_TEMPO            0x00004002L
#define MCI_SEQ_STATUS_PORT             0x00004003L
#define MCI_SEQ_STATUS_SLAVE            0x00004007L
#define MCI_SEQ_STATUS_MASTER           0x00004008L
#define MCI_SEQ_STATUS_OFFSET           0x00004009L
#define MCI_SEQ_STATUS_DIVTYPE          0x0000400AL
#define MCI_SEQ_STATUS_NAME             0x0000400BL
#define MCI_SEQ_STATUS_COPYRIGHT        0x0000400CL

/* flags for the dwFlags parameter of MCI_SET command message */
#define MCI_SEQ_SET_TEMPO               0x00010000L
#define MCI_SEQ_SET_PORT                0x00020000L
#define MCI_SEQ_SET_SLAVE               0x00040000L
#define MCI_SEQ_SET_MASTER              0x00080000L
#define MCI_SEQ_SET_OFFSET              0x01000000L

/* parameter block for MCI_SET command message */
typedef struct tagMCI_SEQ_SET_PARMS {
    DWORD   dwCallback;
    DWORD   dwTimeFormat;
    DWORD   dwAudio;
    DWORD   dwTempo;
    DWORD   dwPort;
    DWORD   dwSlave;
    DWORD   dwMaster;
    DWORD   dwOffset;
} MCI_SEQ_SET_PARMS, *PMCI_SEQ_SET_PARMS, FAR * LPMCI_SEQ_SET_PARMS;

/* MCI extensions for animation devices */

/* flags for dwFlags parameter of MCI_OPEN command message */
#define MCI_ANIM_OPEN_WS                0x00010000L
#define MCI_ANIM_OPEN_PARENT            0x00020000L
#define MCI_ANIM_OPEN_NOSTATIC          0x00040000L

/* flags for dwFlags parameter of MCI_PLAY command message */
#define MCI_ANIM_PLAY_SPEED             0x00010000L
#define MCI_ANIM_PLAY_REVERSE           0x00020000L
#define MCI_ANIM_PLAY_FAST              0x00040000L
#define MCI_ANIM_PLAY_SLOW              0x00080000L
#define MCI_ANIM_PLAY_SCAN              0x00100000L

/* flags for dwFlags parameter of MCI_STEP command message */
#define MCI_ANIM_STEP_REVERSE           0x00010000L
#define MCI_ANIM_STEP_FRAMES            0x00020000L

/* flags for dwItem field of MCI_STATUS_PARMS parameter block */
#define MCI_ANIM_STATUS_SPEED           0x00004001L
#define MCI_ANIM_STATUS_FORWARD         0x00004002L
#define MCI_ANIM_STATUS_HWND            0x00004003L
#define MCI_ANIM_STATUS_HPAL            0x00004004L
#define MCI_ANIM_STATUS_STRETCH         0x00004005L

/* flags for the dwFlags parameter of MCI_INFO command message */
#define MCI_ANIM_INFO_TEXT              0x00010000L

/* flags for dwItem field of MCI_GETDEVCAPS_PARMS parameter block */
#define MCI_ANIM_GETDEVCAPS_CAN_REVERSE 0x00004001L
#define MCI_ANIM_GETDEVCAPS_FAST_RATE   0x00004002L
#define MCI_ANIM_GETDEVCAPS_SLOW_RATE   0x00004003L
#define MCI_ANIM_GETDEVCAPS_NORMAL_RATE 0x00004004L
#define MCI_ANIM_GETDEVCAPS_PALETTES    0x00004006L
#define MCI_ANIM_GETDEVCAPS_CAN_STRETCH 0x00004007L
#define MCI_ANIM_GETDEVCAPS_MAX_WINDOWS 0x00004008L

/* flags for the MCI_REALIZE command message */
#define MCI_ANIM_REALIZE_NORM           0x00010000L
#define MCI_ANIM_REALIZE_BKGD           0x00020000L

/* flags for dwFlags parameter of MCI_WINDOW command message */
#define MCI_ANIM_WINDOW_HWND            0x00010000L
#define MCI_ANIM_WINDOW_STATE           0x00040000L
#define MCI_ANIM_WINDOW_TEXT            0x00080000L
#define MCI_ANIM_WINDOW_ENABLE_STRETCH  0x00100000L
#define MCI_ANIM_WINDOW_DISABLE_STRETCH 0x00200000L

/* flags for hWnd field of MCI_ANIM_WINDOW_PARMS parameter block */
/* MCI_WINDOW command message, (dwFlags == MCI_ANIM_WINDOW_HWND) */
#define MCI_ANIM_WINDOW_DEFAULT         0x00000000L

/* flags for dwFlags parameter of MCI_PUT command message */
#define MCI_ANIM_RECT                   0x00010000L
#define MCI_ANIM_PUT_SOURCE             0x00020000L
#define MCI_ANIM_PUT_DESTINATION        0x00040000L

/* flags for dwFlags parameter of MCI_WHERE command message */
#define MCI_ANIM_WHERE_SOURCE           0x00020000L
#define MCI_ANIM_WHERE_DESTINATION      0x00040000L

/* flags for dwFlags parameter of MCI_UPDATE command message */
#define MCI_ANIM_UPDATE_HDC             0x00020000L

/* parameter block for MCI_OPEN command message */
#ifdef _WIN32

typedef struct tagMCI_ANIM_OPEN_PARMSA {
    DWORD   dwCallback;
    MCIDEVICEID wDeviceID;
    LPCSTR      lpstrDeviceType;
    LPCSTR      lpstrElementName;
    LPCSTR      lpstrAlias;
    DWORD   dwStyle;
    HWND    hWndParent;
} MCI_ANIM_OPEN_PARMSA, *PMCI_ANIM_OPEN_PARMSA, *LPMCI_ANIM_OPEN_PARMSA;
typedef struct tagMCI_ANIM_OPEN_PARMSW {
    DWORD   dwCallback;
    MCIDEVICEID wDeviceID;
    LPCWSTR     lpstrDeviceType;
    LPCWSTR     lpstrElementName;
    LPCWSTR     lpstrAlias;
    DWORD   dwStyle;
    HWND    hWndParent;
} MCI_ANIM_OPEN_PARMSW, *PMCI_ANIM_OPEN_PARMSW, *LPMCI_ANIM_OPEN_PARMSW;
#ifdef UNICODE
typedef MCI_ANIM_OPEN_PARMSW MCI_ANIM_OPEN_PARMS;
typedef PMCI_ANIM_OPEN_PARMSW PMCI_ANIM_OPEN_PARMS;
typedef LPMCI_ANIM_OPEN_PARMSW LPMCI_ANIM_OPEN_PARMS;
#else
typedef MCI_ANIM_OPEN_PARMSA MCI_ANIM_OPEN_PARMS;
typedef PMCI_ANIM_OPEN_PARMSA PMCI_ANIM_OPEN_PARMS;
typedef LPMCI_ANIM_OPEN_PARMSA LPMCI_ANIM_OPEN_PARMS;
#endif // UNICODE

#else
typedef struct tagMCI_ANIM_OPEN_PARMS {
    DWORD   dwCallback;
    MCIDEVICEID wDeviceID;
    WORD        wReserved0;
    LPCSTR      lpstrDeviceType;
    LPCSTR      lpstrElementName;
    LPCSTR      lpstrAlias;
    DWORD       dwStyle;
    HWND        hWndParent;
    WORD        wReserved1;
} MCI_ANIM_OPEN_PARMS, FAR *LPMCI_ANIM_OPEN_PARMS;
#endif

/* parameter block for MCI_PLAY command message */
typedef struct tagMCI_ANIM_PLAY_PARMS {
    DWORD   dwCallback;
    DWORD   dwFrom;
    DWORD   dwTo;
    DWORD   dwSpeed;
} MCI_ANIM_PLAY_PARMS, *PMCI_ANIM_PLAY_PARMS, FAR *LPMCI_ANIM_PLAY_PARMS;

/* parameter block for MCI_STEP command message */
typedef struct tagMCI_ANIM_STEP_PARMS {
    DWORD   dwCallback;
    DWORD   dwFrames;
} MCI_ANIM_STEP_PARMS, *PMCI_ANIM_STEP_PARMS, FAR *LPMCI_ANIM_STEP_PARMS;

/* parameter block for MCI_WINDOW command message */
#ifdef _WIN32

typedef struct tagMCI_ANIM_WINDOW_PARMSA {
    DWORD   dwCallback;
    HWND    hWnd;
    UINT    nCmdShow;
    LPCSTR     lpstrText;
} MCI_ANIM_WINDOW_PARMSA, *PMCI_ANIM_WINDOW_PARMSA, * LPMCI_ANIM_WINDOW_PARMSA;
typedef struct tagMCI_ANIM_WINDOW_PARMSW {
    DWORD   dwCallback;
    HWND    hWnd;
    UINT    nCmdShow;
    LPCWSTR    lpstrText;
} MCI_ANIM_WINDOW_PARMSW, *PMCI_ANIM_WINDOW_PARMSW, * LPMCI_ANIM_WINDOW_PARMSW;
#ifdef UNICODE
typedef MCI_ANIM_WINDOW_PARMSW MCI_ANIM_WINDOW_PARMS;
typedef PMCI_ANIM_WINDOW_PARMSW PMCI_ANIM_WINDOW_PARMS;
typedef LPMCI_ANIM_WINDOW_PARMSW LPMCI_ANIM_WINDOW_PARMS;
#else
typedef MCI_ANIM_WINDOW_PARMSA MCI_ANIM_WINDOW_PARMS;
typedef PMCI_ANIM_WINDOW_PARMSA PMCI_ANIM_WINDOW_PARMS;
typedef LPMCI_ANIM_WINDOW_PARMSA LPMCI_ANIM_WINDOW_PARMS;
#endif // UNICODE

#else
typedef struct tagMCI_ANIM_WINDOW_PARMS {
    DWORD   dwCallback;
    HWND    hWnd;
    WORD    wReserved1;
    WORD    nCmdShow;
    WORD    wReserved2;
    LPCSTR  lpstrText;
} MCI_ANIM_WINDOW_PARMS, FAR * LPMCI_ANIM_WINDOW_PARMS;
#endif

/* parameter block for MCI_PUT, MCI_UPDATE, MCI_WHERE command messages */
typedef struct tagMCI_ANIM_RECT_PARMS {
    DWORD   dwCallback;
#ifdef MCI_USE_OFFEXT
    POINT   ptOffset;
    POINT   ptExtent;
#else   /* ifdef MCI_USE_OFFEXT */
    RECT    rc;
#endif  /* ifdef MCI_USE_OFFEXT */
} MCI_ANIM_RECT_PARMS;
typedef MCI_ANIM_RECT_PARMS * PMCI_ANIM_RECT_PARMS;
typedef MCI_ANIM_RECT_PARMS FAR * LPMCI_ANIM_RECT_PARMS;

/* parameter block for MCI_UPDATE PARMS */
typedef struct tagMCI_ANIM_UPDATE_PARMS {
    DWORD   dwCallback;
    RECT    rc;
    HDC     hDC;
} MCI_ANIM_UPDATE_PARMS, *PMCI_ANIM_UPDATE_PARMS, FAR * LPMCI_ANIM_UPDATE_PARMS;

/* MCI extensions for video overlay devices */

/* flags for dwFlags parameter of MCI_OPEN command message */
#define MCI_OVLY_OPEN_WS                0x00010000L
#define MCI_OVLY_OPEN_PARENT            0x00020000L

/* flags for dwFlags parameter of MCI_STATUS command message */
#define MCI_OVLY_STATUS_HWND            0x00004001L
#define MCI_OVLY_STATUS_STRETCH         0x00004002L

/* flags for dwFlags parameter of MCI_INFO command message */
#define MCI_OVLY_INFO_TEXT              0x00010000L

/* flags for dwItem field of MCI_GETDEVCAPS_PARMS parameter block */
#define MCI_OVLY_GETDEVCAPS_CAN_STRETCH 0x00004001L
#define MCI_OVLY_GETDEVCAPS_CAN_FREEZE  0x00004002L
#define MCI_OVLY_GETDEVCAPS_MAX_WINDOWS 0x00004003L

/* flags for dwFlags parameter of MCI_WINDOW command message */
#define MCI_OVLY_WINDOW_HWND            0x00010000L
#define MCI_OVLY_WINDOW_STATE           0x00040000L
#define MCI_OVLY_WINDOW_TEXT            0x00080000L
#define MCI_OVLY_WINDOW_ENABLE_STRETCH  0x00100000L
#define MCI_OVLY_WINDOW_DISABLE_STRETCH 0x00200000L

/* flags for hWnd parameter of MCI_OVLY_WINDOW_PARMS parameter block */
#define MCI_OVLY_WINDOW_DEFAULT         0x00000000L

/* flags for dwFlags parameter of MCI_PUT command message */
#define MCI_OVLY_RECT                   0x00010000L
#define MCI_OVLY_PUT_SOURCE             0x00020000L
#define MCI_OVLY_PUT_DESTINATION        0x00040000L
#define MCI_OVLY_PUT_FRAME              0x00080000L
#define MCI_OVLY_PUT_VIDEO              0x00100000L

/* flags for dwFlags parameter of MCI_WHERE command message */
#define MCI_OVLY_WHERE_SOURCE           0x00020000L
#define MCI_OVLY_WHERE_DESTINATION      0x00040000L
#define MCI_OVLY_WHERE_FRAME            0x00080000L
#define MCI_OVLY_WHERE_VIDEO            0x00100000L

/* parameter block for MCI_OPEN command message */
#ifdef _WIN32

typedef struct tagMCI_OVLY_OPEN_PARMSA {
    DWORD   dwCallback;
    MCIDEVICEID wDeviceID;
    LPCSTR      lpstrDeviceType;
    LPCSTR      lpstrElementName;
    LPCSTR      lpstrAlias;
    DWORD   dwStyle;
    HWND    hWndParent;
} MCI_OVLY_OPEN_PARMSA, *PMCI_OVLY_OPEN_PARMSA, *LPMCI_OVLY_OPEN_PARMSA;
typedef struct tagMCI_OVLY_OPEN_PARMSW {
    DWORD   dwCallback;
    MCIDEVICEID wDeviceID;
    LPCWSTR     lpstrDeviceType;
    LPCWSTR     lpstrElementName;
    LPCWSTR     lpstrAlias;
    DWORD   dwStyle;
    HWND    hWndParent;
} MCI_OVLY_OPEN_PARMSW, *PMCI_OVLY_OPEN_PARMSW, *LPMCI_OVLY_OPEN_PARMSW;
#ifdef UNICODE
typedef MCI_OVLY_OPEN_PARMSW MCI_OVLY_OPEN_PARMS;
typedef PMCI_OVLY_OPEN_PARMSW PMCI_OVLY_OPEN_PARMS;
typedef LPMCI_OVLY_OPEN_PARMSW LPMCI_OVLY_OPEN_PARMS;
#else
typedef MCI_OVLY_OPEN_PARMSA MCI_OVLY_OPEN_PARMS;
typedef PMCI_OVLY_OPEN_PARMSA PMCI_OVLY_OPEN_PARMS;
typedef LPMCI_OVLY_OPEN_PARMSA LPMCI_OVLY_OPEN_PARMS;
#endif // UNICODE

#else
typedef struct tagMCI_OVLY_OPEN_PARMS {
    DWORD   dwCallback;
    MCIDEVICEID wDeviceID;
    WORD        wReserved0;
    LPCSTR      lpstrDeviceType;
    LPCSTR      lpstrElementName;
    LPCSTR      lpstrAlias;
    DWORD       dwStyle;
    HWND        hWndParent;
    WORD        wReserved1;
} MCI_OVLY_OPEN_PARMS, FAR *LPMCI_OVLY_OPEN_PARMS;
#endif

/* parameter block for MCI_WINDOW command message */
#ifdef _WIN32

typedef struct tagMCI_OVLY_WINDOW_PARMSA {
    DWORD   dwCallback;
    HWND    hWnd;
    UINT    nCmdShow;
    LPCSTR      lpstrText;
} MCI_OVLY_WINDOW_PARMSA, *PMCI_OVLY_WINDOW_PARMSA, * LPMCI_OVLY_WINDOW_PARMSA;
typedef struct tagMCI_OVLY_WINDOW_PARMSW {
    DWORD   dwCallback;
    HWND    hWnd;
    UINT    nCmdShow;
    LPCWSTR     lpstrText;
} MCI_OVLY_WINDOW_PARMSW, *PMCI_OVLY_WINDOW_PARMSW, * LPMCI_OVLY_WINDOW_PARMSW;
#ifdef UNICODE
typedef MCI_OVLY_WINDOW_PARMSW MCI_OVLY_WINDOW_PARMS;
typedef PMCI_OVLY_WINDOW_PARMSW PMCI_OVLY_WINDOW_PARMS;
typedef LPMCI_OVLY_WINDOW_PARMSW LPMCI_OVLY_WINDOW_PARMS;
#else
typedef MCI_OVLY_WINDOW_PARMSA MCI_OVLY_WINDOW_PARMS;
typedef PMCI_OVLY_WINDOW_PARMSA PMCI_OVLY_WINDOW_PARMS;
typedef LPMCI_OVLY_WINDOW_PARMSA LPMCI_OVLY_WINDOW_PARMS;
#endif // UNICODE
#else
typedef struct tagMCI_OVLY_WINDOW_PARMS {
    DWORD   dwCallback;
    HWND    hWnd;
    WORD    wReserved1;
    UINT    nCmdShow;
    WORD    wReserved2;
    LPCSTR  lpstrText;
} MCI_OVLY_WINDOW_PARMS, FAR * LPMCI_OVLY_WINDOW_PARMS;
#endif

/* parameter block for MCI_PUT, MCI_UPDATE, and MCI_WHERE command messages */
typedef struct tagMCI_OVLY_RECT_PARMS {
    DWORD   dwCallback;
#ifdef MCI_USE_OFFEXT
    POINT   ptOffset;
    POINT   ptExtent;
#else   /* ifdef MCI_USE_OFFEXT */
    RECT    rc;
#endif  /* ifdef MCI_USE_OFFEXT */
} MCI_OVLY_RECT_PARMS, *PMCI_OVLY_RECT_PARMS, FAR * LPMCI_OVLY_RECT_PARMS;

/* parameter block for MCI_SAVE command message */
#ifdef _WIN32

typedef struct tagMCI_OVLY_SAVE_PARMSA {
    DWORD   dwCallback;
    LPCSTR      lpfilename;
    RECT    rc;
} MCI_OVLY_SAVE_PARMSA, *PMCI_OVLY_SAVE_PARMSA, * LPMCI_OVLY_SAVE_PARMSA;
typedef struct tagMCI_OVLY_SAVE_PARMSW {
    DWORD   dwCallback;
    LPCWSTR     lpfilename;
    RECT    rc;
} MCI_OVLY_SAVE_PARMSW, *PMCI_OVLY_SAVE_PARMSW, * LPMCI_OVLY_SAVE_PARMSW;
#ifdef UNICODE
typedef MCI_OVLY_SAVE_PARMSW MCI_OVLY_SAVE_PARMS;
typedef PMCI_OVLY_SAVE_PARMSW PMCI_OVLY_SAVE_PARMS;
typedef LPMCI_OVLY_SAVE_PARMSW LPMCI_OVLY_SAVE_PARMS;
#else
typedef MCI_OVLY_SAVE_PARMSA MCI_OVLY_SAVE_PARMS;
typedef PMCI_OVLY_SAVE_PARMSA PMCI_OVLY_SAVE_PARMS;
typedef LPMCI_OVLY_SAVE_PARMSA LPMCI_OVLY_SAVE_PARMS;
#endif // UNICODE
#else
typedef struct tagMCI_OVLY_SAVE_PARMS {
    DWORD   dwCallback;
    LPCSTR  lpfilename;
    RECT    rc;
} MCI_OVLY_SAVE_PARMS, FAR * LPMCI_OVLY_SAVE_PARMS;
#endif

/* parameter block for MCI_LOAD command message */
#ifdef _WIN32

typedef struct tagMCI_OVLY_LOAD_PARMSA {
    DWORD   dwCallback;
    LPCSTR      lpfilename;
    RECT    rc;
} MCI_OVLY_LOAD_PARMSA, *PMCI_OVLY_LOAD_PARMSA, * LPMCI_OVLY_LOAD_PARMSA;
typedef struct tagMCI_OVLY_LOAD_PARMSW {
    DWORD   dwCallback;
    LPCWSTR     lpfilename;
    RECT    rc;
} MCI_OVLY_LOAD_PARMSW, *PMCI_OVLY_LOAD_PARMSW, * LPMCI_OVLY_LOAD_PARMSW;
#ifdef UNICODE
typedef MCI_OVLY_LOAD_PARMSW MCI_OVLY_LOAD_PARMS;
typedef PMCI_OVLY_LOAD_PARMSW PMCI_OVLY_LOAD_PARMS;
typedef LPMCI_OVLY_LOAD_PARMSW LPMCI_OVLY_LOAD_PARMS;
#else
typedef MCI_OVLY_LOAD_PARMSA MCI_OVLY_LOAD_PARMS;
typedef PMCI_OVLY_LOAD_PARMSA PMCI_OVLY_LOAD_PARMS;
typedef LPMCI_OVLY_LOAD_PARMSA LPMCI_OVLY_LOAD_PARMS;
#endif // UNICODE
#else
typedef struct tagMCI_OVLY_LOAD_PARMS {
    DWORD   dwCallback;
    LPCSTR  lpfilename;
    RECT    rc;
} MCI_OVLY_LOAD_PARMS, FAR * LPMCI_OVLY_LOAD_PARMS;
#endif

#endif  /* ifndef _WIN32_VXD */
#endif  /* ifndef MMNOMCI */

/****************************************************************************

			DISPLAY Driver extensions

****************************************************************************/

#ifndef NEWTRANSPARENT
    #define NEWTRANSPARENT  3           /* use with SetBkMode() */

    #define QUERYROPSUPPORT 40          /* use to determine ROP support */
#endif  /* ifndef NEWTRANSPARENT */

/****************************************************************************

			DIB Driver extensions

****************************************************************************/

#define SELECTDIB       41                      /* DIB.DRV select dib escape */
#define DIBINDEX(n)     MAKELONG((n),0x10FF)

/****************************************************************************

			ScreenSaver support

    The current application will receive a syscommand of SC_SCREENSAVE just
    before the screen saver is invoked.  If the app wishes to prevent a
    screen save, return non-zero value, otherwise call DefWindowProc().

****************************************************************************/

#ifndef SC_SCREENSAVE

    #define SC_SCREENSAVE   0xF140

#endif  /* ifndef SC_SCREENSAVE */

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif  /* __cplusplus */

#ifdef _WIN32
#include <poppack.h>
#else
#ifndef RC_INVOKED
#pragma pack()
#endif
#endif

#endif  /* _INC_MMSYSTEM */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\inc32\OAIDL.H ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 2.00.0102 */
/* at Fri Apr 28 07:02:38 1995
 */
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"
#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __oaidl_h__
#define __oaidl_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __ICreateTypeInfo_FWD_DEFINED__
#define __ICreateTypeInfo_FWD_DEFINED__
typedef interface ICreateTypeInfo ICreateTypeInfo;
#endif 	/* __ICreateTypeInfo_FWD_DEFINED__ */


#ifndef __ICreateTypeLib_FWD_DEFINED__
#define __ICreateTypeLib_FWD_DEFINED__
typedef interface ICreateTypeLib ICreateTypeLib;
#endif 	/* __ICreateTypeLib_FWD_DEFINED__ */


#ifndef __IDispatch_FWD_DEFINED__
#define __IDispatch_FWD_DEFINED__
typedef interface IDispatch IDispatch;
#endif 	/* __IDispatch_FWD_DEFINED__ */


#ifndef __IEnumVARIANT_FWD_DEFINED__
#define __IEnumVARIANT_FWD_DEFINED__
typedef interface IEnumVARIANT IEnumVARIANT;
#endif 	/* __IEnumVARIANT_FWD_DEFINED__ */


#ifndef __ITypeComp_FWD_DEFINED__
#define __ITypeComp_FWD_DEFINED__
typedef interface ITypeComp ITypeComp;
#endif 	/* __ITypeComp_FWD_DEFINED__ */


#ifndef __ITypeInfo_FWD_DEFINED__
#define __ITypeInfo_FWD_DEFINED__
typedef interface ITypeInfo ITypeInfo;
#endif 	/* __ITypeInfo_FWD_DEFINED__ */


#ifndef __ITypeLib_FWD_DEFINED__
#define __ITypeLib_FWD_DEFINED__
typedef interface ITypeLib ITypeLib;
#endif 	/* __ITypeLib_FWD_DEFINED__ */


#ifndef __IErrorInfo_FWD_DEFINED__
#define __IErrorInfo_FWD_DEFINED__
typedef interface IErrorInfo IErrorInfo;
#endif 	/* __IErrorInfo_FWD_DEFINED__ */


#ifndef __ICreateErrorInfo_FWD_DEFINED__
#define __ICreateErrorInfo_FWD_DEFINED__
typedef interface ICreateErrorInfo ICreateErrorInfo;
#endif 	/* __ICreateErrorInfo_FWD_DEFINED__ */


#ifndef __ISupportErrorInfo_FWD_DEFINED__
#define __ISupportErrorInfo_FWD_DEFINED__
typedef interface ISupportErrorInfo ISupportErrorInfo;
#endif 	/* __ISupportErrorInfo_FWD_DEFINED__ */


/* header files for imported files */
#include "objidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/****************************************
 * Generated header for interface: __MIDL__intf_0000
 * at Fri Apr 28 07:02:38 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [local] */ 


			/* size is 0 */

			/* size is 0 */

			/* size is 0 */

			/* size is 0 */

			/* size is 0 */



extern RPC_IF_HANDLE __MIDL__intf_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL__intf_0000_v0_0_s_ifspec;

#ifndef __RemVariant_INTERFACE_DEFINED__
#define __RemVariant_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: RemVariant
 * at Fri Apr 28 07:02:38 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [local][unique][version] */ 


//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//--------------------------------------------------------------------------
/* XBSTR is for internal use only, it is subject to change */
			/* size is 4 */
typedef struct  tagXBSTR
    {
    ULONG cbSize;
    /* [size_is] */ OLECHAR rgBstrData[ 1 ];
    }	XBSTR;

			/* size is 4 */
typedef OLECHAR __RPC_FAR *BSTR;

			/* size is 4 */
typedef BSTR __RPC_FAR *LPBSTR;

#ifndef _tagBLOB_DEFINED
#define _tagBLOB_DEFINED
#define _BLOB_DEFINED
#define _LPBLOB_DEFINED
			/* size is 8 */
typedef struct  tagBLOB
    {
    ULONG cbSize;
    /* [size_is] */ BYTE __RPC_FAR *pBlobData;
    }	BLOB;

			/* size is 4 */
typedef struct tagBLOB __RPC_FAR *LPBLOB;

#endif
#ifndef _tagCLIPDATA_DEFINED
#define _tagCLIPDATA_DEFINED
#define _CLIPDATA_DEFINED
			/* size is 12 */
typedef struct  tagCLIPDATA
    {
    ULONG cbSize;
    long ulClipFmt;
    /* [size_is] */ BYTE __RPC_FAR *pClipData;
    }	CLIPDATA;

#endif
#ifndef _tagSAFEARRAYBOUND_DEFINED
#define _tagSAFEARRAYBOUND_DEFINED
#define _SAFEARRAYBOUND_DEFINED
#define _LPSAFEARRAYBOUND_DEFINED
			/* size is 8 */
typedef struct  tagSAFEARRAYBOUND
    {
    ULONG cElements;
    LONG lLbound;
    }	SAFEARRAYBOUND;

			/* size is 4 */
typedef struct tagSAFEARRAYBOUND __RPC_FAR *LPSAFEARRAYBOUND;

#endif
#ifndef _tagSAFEARRAY_DEFINED
#define _tagSAFEARRAY_DEFINED
#define _SAFEARRAY_DEFINED
#define _LPSAFEARRAY_DEFINED
#if 0
/* the following is what RPC knows how to remote */
			/* size is 16 */
typedef struct  tagSAFEARRAY
    {
    unsigned short cDims;
    unsigned short fFeatures;
    unsigned long cbElements;
    unsigned long cLocks;
    BYTE __RPC_FAR *pvData;
    /* [size_is] */ SAFEARRAYBOUND rgsabound[ 1 ];
    }	SAFEARRAY;

			/* size is 4 */
typedef struct tagSAFEARRAY __RPC_FAR *LPSAFEARRAY;

#else
typedef struct FARSTRUCT tagSAFEARRAY {
    unsigned short cDims;
    unsigned short fFeatures;
#if defined(_WIN32)
    unsigned long cbElements;
    unsigned long cLocks;
#else
    unsigned short cbElements;
    unsigned short cLocks;
    unsigned long handle;               // unused but kept for compatiblity
#endif
    void HUGEP* pvData;
    SAFEARRAYBOUND rgsabound[1];
} SAFEARRAY, FAR* LPSAFEARRAY;
#endif
#endif
			/* size is 2 */
#define	FADF_AUTO	( 0x1 )

			/* size is 2 */
#define	FADF_STATIC	( 0x2 )

			/* size is 2 */
#define	FADF_EMBEDDED	( 0x4 )

			/* size is 2 */
#define	FADF_FIXEDSIZE	( 0x10 )

			/* size is 2 */
#define	FADF_BSTR	( 0x100 )

			/* size is 2 */
#define	FADF_UNKNOWN	( 0x200 )

			/* size is 2 */
#define	FADF_DISPATCH	( 0x400 )

			/* size is 2 */
#define	FADF_VARIANT	( 0x800 )

			/* size is 2 */
#define	FADF_RESERVED	( 0xf0e8 )

			/* size is 8 */
typedef double DATE;

#ifndef _tagCY_DEFINED
#define _tagCY_DEFINED
#define _CY_DEFINED
#if 0
/* the following isn't the real definition of CY, but it is */
/* what RPC knows how to remote */
			/* size is 8 */
typedef struct  tagCY
    {
    LONGLONG int64;
    }	CY;

#else
/* real definition that makes the C++ compiler happy */
typedef union tagCY {
    struct {         
#ifdef _MAC          
        long      Hi;
        long Lo;     
#else                
        unsigned long Lo;
        long      Hi;
#endif               
    };               
    LONGLONG int64;  
} CY;                
#endif
#endif
			/* size is 8 */
typedef CY CURRENCY;

/* 0 == FALSE, -1 == TRUE */
			/* size is 2 */
typedef short VARIANT_BOOL;

#ifndef VARIANT_TRUE
#define VARIANT_TRUE ((VARIANT_BOOL)0xffff)
#endif
#ifndef VARIANT_FALSE
#define VARIANT_FALSE ((VARIANT_BOOL)0)
#endif
#ifndef _VARENUM_DEFINED
#define _VARENUM_DEFINED
/*
 * VARENUM usage key,
 *
 * * [V] - may appear in a VARIANT
 * * [T] - may appear in a TYPEDESC
 * * [P] - may appear in an OLE property set
 * * [S] - may appear in a Safe Array
 *
 *
 *  VT_EMPTY            [V]   [P]     nothing                     
 *  VT_NULL             [V]           SQL style Null              
 *  VT_I2               [V][T][P][S]  2 byte signed int           
 *  VT_I4               [V][T][P][S]  4 byte signed int           
 *  VT_R4               [V][T][P][S]  4 byte real                 
 *  VT_R8               [V][T][P][S]  8 byte real                 
 *  VT_CY               [V][T][P][S]  currency                    
 *  VT_DATE             [V][T][P][S]  date                        
 *  VT_BSTR             [V][T][P][S]  OLE Automation string       
 *  VT_DISPATCH         [V][T]   [S]  IDispatch FAR*              
 *  VT_ERROR            [V][T]   [S]  SCODE                       
 *  VT_BOOL             [V][T][P][S]  True=-1, False=0            
 *  VT_VARIANT          [V][T][P][S]  VARIANT FAR*                
 *  VT_UNKNOWN          [V][T]   [S]  IUnknown FAR*               
 *  VT_I1                  [T]        signed char                 
 *  VT_UI1              [V][T]   [S]  unsigned char               
 *  VT_UI2                 [T]        unsigned short              
 *  VT_UI4                 [T]        unsigned short              
 *  VT_I8                  [T][P]     signed 64-bit int           
 *  VT_UI8                 [T]        unsigned 64-bit int         
 *  VT_INT                 [T]        signed machine int          
 *  VT_UINT                [T]        unsigned machine int        
 *  VT_VOID                [T]        C style void                
 *  VT_HRESULT             [T]                                    
 *  VT_PTR                 [T]        pointer type                
 *  VT_SAFEARRAY           [T]        (use VT_ARRAY in VARIANT)   
 *  VT_CARRAY              [T]        C style array               
 *  VT_USERDEFINED         [T]        user defined type           
 *  VT_LPSTR               [T][P]     null terminated string      
 *  VT_LPWSTR              [T][P]     wide null terminated string 
 *  VT_FILETIME               [P]     FILETIME                    
 *  VT_BLOB                   [P]     Length prefixed bytes       
 *  VT_STREAM                 [P]     Name of the stream follows  
 *  VT_STORAGE                [P]     Name of the storage follows 
 *  VT_STREAMED_OBJECT        [P]     Stream contains an object   
 *  VT_STORED_OBJECT          [P]     Storage contains an object  
 *  VT_BLOB_OBJECT            [P]     Blob contains an object     
 *  VT_CF                     [P]     Clipboard format            
 *  VT_CLSID                  [P]     A Class ID                  
 *  VT_VECTOR                 [P]     simple counted array        
 *  VT_ARRAY            [V]           SAFEARRAY*                  
 *  VT_BYREF            [V]                                       
 */
			/* size is 2 */

enum VARENUM
    {	VT_EMPTY	= 0,
	VT_NULL	= 1,
	VT_I2	= 2,
	VT_I4	= 3,
	VT_R4	= 4,
	VT_R8	= 5,
	VT_CY	= 6,
	VT_DATE	= 7,
	VT_BSTR	= 8,
	VT_DISPATCH	= 9,
	VT_ERROR	= 10,
	VT_BOOL	= 11,
	VT_VARIANT	= 12,
	VT_UNKNOWN	= 13,
	VT_I1	= 16,
	VT_UI1	= 17,
	VT_UI2	= 18,
	VT_UI4	= 19,
	VT_I8	= 20,
	VT_UI8	= 21,
	VT_INT	= 22,
	VT_UINT	= 23,
	VT_VOID	= 24,
	VT_HRESULT	= 25,
	VT_PTR	= 26,
	VT_SAFEARRAY	= 27,
	VT_CARRAY	= 28,
	VT_USERDEFINED	= 29,
	VT_LPSTR	= 30,
	VT_LPWSTR	= 31,
	VT_FILETIME	= 64,
	VT_BLOB	= 65,
	VT_STREAM	= 66,
	VT_STORAGE	= 67,
	VT_STREAMED_OBJECT	= 68,
	VT_STORED_OBJECT	= 69,
	VT_BLOB_OBJECT	= 70,
	VT_CF	= 71,
	VT_CLSID	= 72
    };
#endif
			/* size is 2 */
#define	VT_VECTOR	( 0x1000 )

			/* size is 2 */
#define	VT_ARRAY	( 0x2000 )

			/* size is 2 */
#define	VT_BYREF	( 0x4000 )

			/* size is 2 */
#define	VT_RESERVED	( 0x8000 )

#ifndef _VARTYPE_DEFINED
#define _VARTYPE_DEFINED
			/* size is 2 */
typedef unsigned short VARTYPE;

#endif
			/* size is 0 */
typedef struct tagVARIANT VARIANT;

/* forward declare IDispatch */
typedef interface IDispatch IDispatch;
/* VARIANT STRUCTURE
 *
 *  VARTYPE vt;
 *  unsigned short wReserved1;
 *  unsigned short wReserved2;
 *  unsigned short wReserved3;
 *  union {
 *    unsigned char        VT_UI1               
 *    short                VT_I2                
 *    long                 VT_I4                
 *    float                VT_R4                
 *    double               VT_R8                
 *    VARIANT_BOOL         VT_BOOL              
 *    SCODE                VT_ERROR             
 *    CY                   VT_CY                
 *    DATE                 VT_DATE              
 *    BSTR                 VT_BSTR              
 *    IUnknown FAR*        VT_UNKNOWN           
 *    IDispatch FAR*       VT_DISPATCH          
 *    SAFEARRAY FAR*       VT_ARRAY|*           
 *    short FAR*           VT_BYREF|VT_I2       
 *    long FAR*            VT_BYREF|VT_I4       
 *    float FAR*           VT_BYREF|VT_R4       
 *    double FAR*          VT_BYREF|VT_R8       
 *    VARIANT_BOOL FAR*    VT_BYREF|VT_BOOL     
 *    SCODE FAR*           VT_BYREF|VT_ERROR    
 *    CY FAR*              VT_BYREF|VT_CY       
 *    DATE FAR*            VT_BYREF|VT_DATE     
 *    BSTR FAR*            VT_BYREF|VT_BSTR     
 *    IUnknown FAR* FAR*   VT_BYREF|VT_UNKNOWN  
 *    IDispatch FAR* FAR*  VT_BYREF|VT_DISPATCH 
 *    SAFEARRAY FAR* FAR*  VT_BYREF|VT_ARRAY|*  
 *    VARIANT FAR*         VT_BYREF|VT_VARIANT  
 *    void FAR*            Generic ByRef        
 */
#ifndef _tagVARIANT_DEFINED
#define _tagVARIANT_DEFINED
#if 0
/* the following is what RPC knows how to remote */
			/* size is 16 */
struct  tagVARIANT
    {
    VARTYPE vt;
    WORD wReserved1;
    WORD wReserved2;
    WORD wReserved3;
    /* [switch_is][switch_type] */ union 
        {
        /* [case] */ long lVal;
        /* [case] */ unsigned char bVal;
        /* [case] */ short iVal;
        /* [case] */ float fltVal;
        /* [case] */ double dblVal;
        /* [case] */ VARIANT_BOOL bool;
        /* [case] */ SCODE scode;
        /* [case] */ CY cyVal;
        /* [case] */ DATE date;
        /* [case] */ BSTR bstrVal;
        /* [case] */ IUnknown __RPC_FAR *punkVal;
        /* [case] */ SAFEARRAY __RPC_FAR *parray;
        /* [case] */ unsigned char __RPC_FAR *pbVal;
        /* [case] */ short __RPC_FAR *piVal;
        /* [case] */ long __RPC_FAR *plVal;
        /* [case] */ float __RPC_FAR *pfltVal;
        /* [case] */ double __RPC_FAR *pdblVal;
        /* [case] */ VARIANT_BOOL __RPC_FAR *pbool;
        /* [case] */ SCODE __RPC_FAR *pscode;
        /* [case] */ CY __RPC_FAR *pcyVal;
        /* [case] */ DATE __RPC_FAR *pdate;
        /* [case] */ BSTR __RPC_FAR *pbstrVal;
        /* [case] */ IUnknown __RPC_FAR *__RPC_FAR *ppunkVal;
        /* [case] */ SAFEARRAY __RPC_FAR *__RPC_FAR *pparray;
        /* [case] */ VARIANT __RPC_FAR *pvarVal;
        /* [case] */ long __RPC_FAR *byref;
        }	;
    };
#endif
struct tagVARIANT{
    VARTYPE vt;
    WORD wReserved1;
    WORD wReserved2;
    WORD wReserved3;
    union
    {
      long          lVal;           /* VT_I4                */
      unsigned char bVal;           /* VT_UI1               */
      short         iVal;           /* VT_I2                */
      float         fltVal;         /* VT_R4                */
      double        dblVal;         /* VT_R8                */
      VARIANT_BOOL  bool;           /* VT_BOOL              */
      SCODE         scode;          /* VT_ERROR             */
      CY            cyVal;          /* VT_CY                */
      DATE          date;           /* VT_DATE              */
      BSTR          bstrVal;        /* VT_BSTR              */
      IUnknown      *punkVal;       /* VT_UNKNOWN           */
      IDispatch     *pdispVal;      /* VT_DISPATCH          */
      SAFEARRAY     *parray;        /* VT_ARRAY|*           */
      unsigned char *pbVal;         /* VT_BYREF|VT_UI1      */
      short         *piVal;         /* VT_BYREF|VT_I2       */
      long          *plVal;         /* VT_BYREF|VT_I4       */
      float         *pfltVal;       /* VT_BYREF|VT_R4       */
      double        *pdblVal;       /* VT_BYREF|VT_R8       */
      VARIANT_BOOL  *pbool;         /* VT_BYREF|VT_BOOL     */
      SCODE         *pscode;        /* VT_BYREF|VT_ERROR    */
      CY            *pcyVal;        /* VT_BYREF|VT_CY       */
      DATE          *pdate;         /* VT_BYREF|VT_DATE     */
      BSTR          *pbstrVal;      /* VT_BYREF|VT_BSTR     */
      IUnknown      **ppunkVal;     /* VT_BYREF|VT_UNKNOWN  */
      IDispatch     **ppdispVal;    /* VT_BYREF|VT_DISPATCH */
      SAFEARRAY     **pparray;      /* VT_BYREF|VT_ARRAY|*  */
      VARIANT       *pvarVal;       /* VT_BYREF|VT_VARIANT  */
      void     * byref;             /* Generic ByRef        */
    }
#if(defined(NONAMELESSUNION))
    u
#endif
     ;
};
#endif
#ifndef _LPVARIANT_DEFINED
#define _LPVARIANT_DEFINED
			/* size is 4 */
typedef struct tagVARIANT __RPC_FAR *LPVARIANT;

#endif
#ifndef _VARIANTARG_DEFINED
#define _VARIANTARG_DEFINED
			/* size is 16 */
typedef struct tagVARIANT VARIANTARG;

#endif
#ifndef _LPVARIANTARG_DEFINED
#define _LPVARIANTARG_DEFINED
			/* size is 4 */
typedef struct tagVARIANT __RPC_FAR *LPVARIANTARG;

#endif
#ifndef _DISPID_DEFINED
#define _DISPID_DEFINED
			/* size is 4 */
typedef LONG DISPID;

#endif
#ifndef _MEMBERID_DEFINED
#define _MEMBERID_DEFINED
			/* size is 4 */
typedef DISPID MEMBERID;

#endif
#ifndef _HREFTYPE_DEFINED
#define _HREFTYPE_DEFINED
			/* size is 4 */
typedef DWORD HREFTYPE;

#endif
			/* size is 4 */
typedef ULONG PROPID;

			/* size is 2 */
typedef /* [transmit] */ 
enum tagTYPEKIND
    {	TKIND_ENUM	= 0,
	TKIND_RECORD	= TKIND_ENUM + 1,
	TKIND_MODULE	= TKIND_RECORD + 1,
	TKIND_INTERFACE	= TKIND_MODULE + 1,
	TKIND_DISPATCH	= TKIND_INTERFACE + 1,
	TKIND_COCLASS	= TKIND_DISPATCH + 1,
	TKIND_ALIAS	= TKIND_COCLASS + 1,
	TKIND_UNION	= TKIND_ALIAS + 1,
	TKIND_MAX	= TKIND_UNION + 1
    }	TYPEKIND;

#define TYPEKIND_to_xmit(pEnum, ppLong) *(ppLong) = (long *) (pEnum)
#define TYPEKIND_from_xmit(pLong, pEnum) *(pEnum) = (TYPEKIND) *(pLong)
#define TYPEKIND_free_inst(pEnum) 
#define TYPEKIND_free_xmit(pLong) 
#ifndef _tagTYPEDESC_DEFINED
#define _tagTYPEDESC_DEFINED
#define _TYPEDESC_DEFINED
/* VT_PTR - lptdesc, the pointed at type */
/* VT_CARRAY - lpadesc */
/* VT_USERDEFINED - hreftype, used to get the UDT typeinfo */
			/* size is 6 */
typedef struct  tagTYPEDESC
    {
    /* [switch_is][switch_type] */ union 
        {
        /* [case] */ struct tagTYPEDESC __RPC_FAR *lptdesc;
        /* [case] */ struct tagARRAYDESC __RPC_FAR *lpadesc;
        /* [case] */ HREFTYPE hreftype;
        }	;
    VARTYPE vt;
    }	TYPEDESC;

#endif
#ifndef _tagARRAYDESC_DEFINED
#define _tagARRAYDESC_DEFINED
#define _ARRAYDESC_DEFINED
#if 0
			/* size is 8 */
typedef struct  tagARRAYDESC
    {
    TYPEDESC tdescElem;
    USHORT cDims;
    /* [size_is] */ SAFEARRAYBOUND rgbounds[ 1 ];
    }	ARRAYDESC;

#else
typedef struct tagARRAYDESC {
    TYPEDESC tdescElem;     /* element type */
    USHORT cDims;       /* dimension count */
    SAFEARRAYBOUND rgbounds[1]; /* variable length array of bounds */
} ARRAYDESC;
#endif
#endif
#ifndef _tagIDLDESC_DEFINED
#define _tagIDLDESC_DEFINED
#define _IDLDESC_DEFINED
#define _LPIDLDESC_DEFINED
#ifdef _WIN32
			/* size is 6 */
typedef struct  tagIDLDESC
    {
    unsigned long dwReserved;
    unsigned short wIDLFlags;
    }	IDLDESC;

			/* size is 4 */
typedef struct tagIDLDESC __RPC_FAR *LPIDLDESC;

#else
typedef struct FARSTRUCT tagIDLDESC {
#if defined(_WIN32)
    unsigned long dwReserved;
#else
    BSTR bstrIDLInfo;           /* reserved, but original name retained for
                                   compatibilty */
#endif
    unsigned short wIDLFlags;   /* IN, OUT, etc */
} IDLDESC, FAR* LPIDLDESC;
#endif
#endif
#ifndef _tagELEMDESC_DEFINED
#define _tagELEMDESC_DEFINED
#define _ELEMDESC_DEFINED
#define _LPELEMDESC_DEFINED
			/* size is 14 */
typedef struct  tagELEMDESC
    {
    TYPEDESC tdesc;
    IDLDESC idldesc;
    }	ELEMDESC;

			/* size is 4 */
typedef struct tagELEMDESC __RPC_FAR *LPELEMDESC;

#endif
#ifndef _tagTYPEATTR_DEFINED
#define _tagTYPEATTR_DEFINED
#define _TYPEATTR_DEFINED
#define _LPTYPEATTR_DEFINED
			/* size is 74 */
typedef struct  tagTYPEATTR
    {
    GUID guid;
    LCID lcid;
    DWORD dwReserved;
    MEMBERID memidConstructor;
    MEMBERID memidDestructor;
    LPOLESTR lpstrSchema;
    ULONG cbSizeInstance;
    TYPEKIND typekind;
    WORD cFuncs;
    WORD cVars;
    WORD cImplTypes;
    WORD cbSizeVft;
    WORD cbAlignment;
    WORD wTypeFlags;
    WORD wMajorVerNum;
    WORD wMinorVerNum;
    TYPEDESC tdescAlias;
    IDLDESC idldescType;
    }	TYPEATTR;

			/* size is 4 */
typedef struct tagTYPEATTR __RPC_FAR *LPTYPEATTR;

#endif
			/* size is 16 */
typedef struct  tagDISPPARAMS
    {
    /* [size_is] */ VARIANTARG __RPC_FAR *rgvarg;
    /* [size_is] */ DISPID __RPC_FAR *rgdispidNamedArgs;
    UINT cArgs;
    UINT cNamedArgs;
    }	DISPPARAMS;

			/* size is 24 */
typedef struct  tagRemEXCEPINFO
    {
    WORD wCode;
    WORD wReserved;
    DWORD dwHelpContext;
    DWORD scode;
    DWORD cSource;
    DWORD cDescription;
    DWORD cHelpFile;
    /* [size_is] */ OLECHAR strings[ 1 ];
    }	RemEXCEPINFO;

#if 0
			/* size is 32 */
typedef /* [transmit] */ struct  tagEXCEPINFO
    {
    WORD wCode;
    WORD wReserved;
    BSTR bstrSource;
    BSTR bstrDescription;
    BSTR bstrHelpFile;
    DWORD dwHelpContext;
    /* [unique] */ void __RPC_FAR *pvReserved;
    HRESULT ( __stdcall __RPC_FAR *pfnDeferredFillIn )( 
        struct tagEXCEPINFO __RPC_FAR *__MIDL_0004);
    SCODE scode;
    }	EXCEPINFO;

			/* size is 4 */
typedef /* [transmit] */ struct tagEXCEPINFO __RPC_FAR *LPEXCEPINFO;

#else
typedef struct tagEXCEPINFO {
    WORD wCode;
    WORD wReserved;
    BSTR bstrSource;
    BSTR bstrDescription;
    BSTR bstrHelpFile;
    DWORD dwHelpContext;
    void __RPC_FAR * pvReserved;
    HRESULT (__stdcall __RPC_FAR * pfnDeferredFillIn)(struct tagEXCEPINFO __RPC_FAR *);
    SCODE scode;
}  EXCEPINFO, __RPC_FAR * LPEXCEPINFO;
#endif
			/* size is 2 */
typedef /* [transmit] */ 
enum tagCALLCONV
    {	CC_CDECL	= 1,
	CC_MSCPASCAL	= CC_CDECL + 1,
	CC_PASCAL	= CC_MSCPASCAL,
	CC_MACPASCAL	= CC_PASCAL + 1,
	CC_STDCALL	= CC_MACPASCAL + 1,
	CC_RESERVED	= CC_STDCALL + 1,
	CC_SYSCALL	= CC_RESERVED + 1,
	CC_MPWCDECL	= CC_SYSCALL + 1,
	CC_MPWPASCAL	= CC_MPWCDECL + 1,
	CC_MAX	= CC_MPWPASCAL + 1
    }	CALLCONV;

#define CALLCONV_to_xmit(pEnum, ppLong) *(ppLong) = (long *) (pEnum)
#define CALLCONV_from_xmit(pLong, pEnum) *(pEnum) = (CALLCONV) *(pLong)
#define CALLCONV_free_inst(pEnum) 
#define CALLCONV_free_xmit(pLong) 
			/* size is 2 */
typedef /* [transmit] */ 
enum tagFUNCKIND
    {	FUNC_VIRTUAL	= 0,
	FUNC_PUREVIRTUAL	= FUNC_VIRTUAL + 1,
	FUNC_NONVIRTUAL	= FUNC_PUREVIRTUAL + 1,
	FUNC_STATIC	= FUNC_NONVIRTUAL + 1,
	FUNC_DISPATCH	= FUNC_STATIC + 1
    }	FUNCKIND;

#define FUNCKIND_to_xmit(pEnum, ppLong) *(ppLong) = (long *) (pEnum)
#define FUNCKIND_from_xmit(pLong, pEnum) *(pEnum) = (FUNCKIND) *(pLong)
#define FUNCKIND_free_inst(pEnum) 
#define FUNCKIND_free_xmit(pLong) 
			/* size is 2 */
typedef /* [transmit] */ 
enum tagINVOKEKIND
    {	INVOKE_FUNC	= 1,
	INVOKE_PROPERTYGET	= 2,
	INVOKE_PROPERTYPUT	= 4,
	INVOKE_PROPERTYPUTREF	= 8
    }	INVOKEKIND;

#define INVOKEKIND_to_xmit(pEnum, ppLong) *(ppLong) = (long *) (pEnum)
#define INVOKEKIND_from_xmit(pLong, pEnum) *(pEnum) = (INVOKEKIND) *(pLong)
#define INVOKEKIND_free_inst(pEnum) 
#define INVOKEKIND_free_xmit(pLong) 
			/* size is 44 */
typedef struct  tagFUNCDESC
    {
    MEMBERID memid;
    /* [size_is] */ SCODE __RPC_FAR *lprgscode;
    /* [size_is] */ ELEMDESC __RPC_FAR *lprgelemdescParam;
    FUNCKIND funckind;
    INVOKEKIND invkind;
    CALLCONV callconv;
    SHORT cParams;
    SHORT cParamsOpt;
    SHORT oVft;
    SHORT cScodes;
    ELEMDESC elemdescFunc;
    WORD wFuncFlags;
    }	FUNCDESC;

			/* size is 4 */
typedef struct tagFUNCDESC __RPC_FAR *LPFUNCDESC;

			/* size is 2 */
typedef /* [transmit] */ 
enum tagVARKIND
    {	VAR_PERINSTANCE	= 0,
	VAR_STATIC	= VAR_PERINSTANCE + 1,
	VAR_CONST	= VAR_STATIC + 1,
	VAR_DISPATCH	= VAR_CONST + 1
    }	VARKIND;

#define VARKIND_to_xmit(pEnum, ppLong) *(ppLong) = (long *) (pEnum)
#define VARKIND_from_xmit(pLong, pEnum) *(pEnum) = (VARKIND) *(pLong)
#define VARKIND_free_inst(pEnum) 
#define VARKIND_free_xmit(pLong) 
			/* size is 2 */
#define	IMPLTYPEFLAG_FDEFAULT	( 0x1 )

			/* size is 2 */
#define	IMPLTYPEFLAG_FSOURCE	( 0x2 )

			/* size is 2 */
#define	IMPLTYPEFLAG_FRESTRICTED	( 0x4 )

			/* size is 30 */
typedef struct  tagVARDESC
    {
    MEMBERID memid;
    LPOLESTR lpstrSchema;
    /* [switch_is][switch_type] */ union 
        {
        /* [case] */ ULONG oInst;
        /* [case] */ VARIANT __RPC_FAR *lpvarValue;
        }	;
    ELEMDESC elemdescVar;
    WORD wVarFlags;
    VARKIND varkind;
    }	VARDESC;

			/* size is 4 */
typedef struct tagVARDESC __RPC_FAR *LPVARDESC;

#ifndef _tagTYPEFLAGS_DEFINED
#define _tagTYPEFLAGS_DEFINED
#define _TYPEFLAGS_DEFINED
			/* size is 2 */
typedef 
enum tagTYPEFLAGS
    {	TYPEFLAG_FAPPOBJECT	= 0x1,
	TYPEFLAG_FCANCREATE	= 0x2,
	TYPEFLAG_FLICENSED	= 0x4,
	TYPEFLAG_FPREDECLID	= 0x8,
	TYPEFLAG_FHIDDEN	= 0x10,
	TYPEFLAG_FCONTROL	= 0x20,
	TYPEFLAG_FDUAL	= 0x40,
	TYPEFLAG_FNONEXTENSIBLE	= 0x80,
	TYPEFLAG_FOLEAUTOMATION	= 0x100,
	TYPEFLAG_FRESTRICTED	= 0x200
    }	TYPEFLAGS;

#endif
#ifndef _tagFUNCFLAGS_DEFINED
#define _tagFUNCFLAGS_DEFINED
#define _FUNCFLAGS_DEFINED
			/* size is 2 */
typedef 
enum tagFUNCFLAGS
    {	FUNCFLAG_FRESTRICTED	= 1,
	FUNCFLAG_FSOURCE	= 0x2,
	FUNCFLAG_FBINDABLE	= 0x4,
	FUNCFLAG_FREQUESTEDIT	= 0x8,
	FUNCFLAG_FDISPLAYBIND	= 0x10,
	FUNCFLAG_FDEFAULTBIND	= 0x20,
	FUNCFLAG_FHIDDEN	= 0x40,
	FUNCFLAG_FUSESGETLASTERROR	= 0x80
    }	FUNCFLAGS;

#endif
#ifndef _tagVARFLAGS_DEFINED
#define _tagVARFLAGS_DEFINED
#define _VARFLAGS_DEFINED
			/* size is 2 */
typedef 
enum tagVARFLAGS
    {	VARFLAG_FREADONLY	= 1,
	VARFLAG_FSOURCE	= 0x2,
	VARFLAG_FBINDABLE	= 0x4,
	VARFLAG_FREQUESTEDIT	= 0x8,
	VARFLAG_FDISPLAYBIND	= 0x10,
	VARFLAG_FDEFAULTBIND	= 0x20,
	VARFLAG_FHIDDEN	= 0x40
    }	VARFLAGS;

#endif


extern RPC_IF_HANDLE RemVariant_v0_1_c_ifspec;
extern RPC_IF_HANDLE RemVariant_v0_1_s_ifspec;
#endif /* __RemVariant_INTERFACE_DEFINED__ */

#ifndef __ICreateTypeInfo_INTERFACE_DEFINED__
#define __ICreateTypeInfo_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ICreateTypeInfo
 * at Fri Apr 28 07:02:38 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [local][unique][uuid][object] */ 


			/* size is 4 */
typedef /* [unique] */ ICreateTypeInfo __RPC_FAR *LPCREATETYPEINFO;


EXTERN_C const IID IID_ICreateTypeInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface ICreateTypeInfo : public IUnknown
    {
    public:
        virtual HRESULT __stdcall SetGuid( 
            /* [in] */ REFGUID guid) = 0;
        
        virtual HRESULT __stdcall SetTypeFlags( 
            /* [in] */ UINT uTypeFlags) = 0;
        
        virtual HRESULT __stdcall SetDocString( 
            /* [in] */ LPOLESTR lpstrDoc) = 0;
        
        virtual HRESULT __stdcall SetHelpContext( 
            /* [in] */ DWORD dwHelpContext) = 0;
        
        virtual HRESULT __stdcall SetVersion( 
            /* [in] */ WORD wMajorVerNum,
            /* [in] */ WORD wMinorVerNum) = 0;
        
        virtual HRESULT __stdcall AddRefTypeInfo( 
            /* [in] */ ITypeInfo __RPC_FAR *ptinfo,
            /* [in] */ HREFTYPE __RPC_FAR *phreftype) = 0;
        
        virtual HRESULT __stdcall AddFuncDesc( 
            /* [in] */ UINT index,
            /* [in] */ FUNCDESC __RPC_FAR *pfuncdesc) = 0;
        
        virtual HRESULT __stdcall AddImplType( 
            /* [in] */ UINT index,
            /* [in] */ HREFTYPE hreftype) = 0;
        
        virtual HRESULT __stdcall SetImplTypeFlags( 
            /* [in] */ UINT index,
            /* [in] */ INT impltypeflags) = 0;
        
        virtual HRESULT __stdcall SetAlignment( 
            /* [in] */ WORD cbAlignment) = 0;
        
        virtual HRESULT __stdcall SetSchema( 
            /* [in] */ LPOLESTR lpstrSchema) = 0;
        
        virtual HRESULT __stdcall AddVarDesc( 
            /* [in] */ UINT index,
            /* [in] */ VARDESC __RPC_FAR *pvardesc) = 0;
        
        virtual HRESULT __stdcall SetFuncAndParamNames( 
            /* [in] */ UINT index,
            /* [in][size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames) = 0;
        
        virtual HRESULT __stdcall SetVarName( 
            /* [in] */ UINT index,
            /* [in] */ LPOLESTR szName) = 0;
        
        virtual HRESULT __stdcall SetTypeDescAlias( 
            /* [in] */ TYPEDESC __RPC_FAR *ptdescAlias) = 0;
        
        virtual HRESULT __stdcall DefineFuncAsDllEntry( 
            /* [in] */ UINT index,
            /* [in] */ LPOLESTR szDllName,
            /* [in] */ LPOLESTR szProcName) = 0;
        
        virtual HRESULT __stdcall SetFuncDocString( 
            /* [in] */ UINT index,
            /* [in] */ LPOLESTR szDocString) = 0;
        
        virtual HRESULT __stdcall SetVarDocString( 
            /* [in] */ UINT index,
            /* [in] */ LPOLESTR szDocString) = 0;
        
        virtual HRESULT __stdcall SetFuncHelpContext( 
            /* [in] */ UINT index,
            /* [in] */ DWORD dwHelpContext) = 0;
        
        virtual HRESULT __stdcall SetVarHelpContext( 
            /* [in] */ UINT index,
            /* [in] */ DWORD dwHelpContext) = 0;
        
        virtual HRESULT __stdcall SetMops( 
            /* [in] */ UINT index,
            /* [in] */ BSTR bstrMops) = 0;
        
        virtual HRESULT __stdcall SetTypeIdldesc( 
            /* [in] */ IDLDESC __RPC_FAR *pidldesc) = 0;
        
        virtual HRESULT __stdcall LayOut( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICreateTypeInfoVtbl
    {
        
        HRESULT ( __stdcall __RPC_FAR *QueryInterface )( 
            ICreateTypeInfo __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( __stdcall __RPC_FAR *AddRef )( 
            ICreateTypeInfo __RPC_FAR * This);
        
        ULONG ( __stdcall __RPC_FAR *Release )( 
            ICreateTypeInfo __RPC_FAR * This);
        
        HRESULT ( __stdcall __RPC_FAR *SetGuid )( 
            ICreateTypeInfo __RPC_FAR * This,
            /* [in] */ REFGUID guid);
        
        HRESULT ( __stdcall __RPC_FAR *SetTypeFlags )( 
            ICreateTypeInfo __RPC_FAR * This,
            /* [in] */ UINT uTypeFlags);
        
        HRESULT ( __stdcall __RPC_FAR *SetDocString )( 
            ICreateTypeInfo __RPC_FAR * This,
            /* [in] */ LPOLESTR lpstrDoc);
        
        HRESULT ( __stdcall __RPC_FAR *SetHelpContext )( 
            ICreateTypeInfo __RPC_FAR * This,
            /* [in] */ DWORD dwHelpContext);
        
        HRESULT ( __stdcall __RPC_FAR *SetVersion )( 
            ICreateTypeInfo __RPC_FAR * This,
            /* [in] */ WORD wMajorVerNum,
            /* [in] */ WORD wMinorVerNum);
        
        HRESULT ( __stdcall __RPC_FAR *AddRefTypeInfo )( 
            ICreateTypeInfo __RPC_FAR * This,
            /* [in] */ ITypeInfo __RPC_FAR *ptinfo,
            /* [in] */ HREFTYPE __RPC_FAR *phreftype);
        
        HRESULT ( __stdcall __RPC_FAR *AddFuncDesc )( 
            ICreateTypeInfo __RPC_FAR * This,
            /* [in] */ UINT index,
            /* [in] */ FUNCDESC __RPC_FAR *pfuncdesc);
        
        HRESULT ( __stdcall __RPC_FAR *AddImplType )( 
            ICreateTypeInfo __RPC_FAR * This,
            /* [in] */ UINT index,
            /* [in] */ HREFTYPE hreftype);
        
        HRESULT ( __stdcall __RPC_FAR *SetImplTypeFlags )( 
            ICreateTypeInfo __RPC_FAR * This,
            /* [in] */ UINT index,
            /* [in] */ INT impltypeflags);
        
        HRESULT ( __stdcall __RPC_FAR *SetAlignment )( 
            ICreateTypeInfo __RPC_FAR * This,
            /* [in] */ WORD cbAlignment);
        
        HRESULT ( __stdcall __RPC_FAR *SetSchema )( 
            ICreateTypeInfo __RPC_FAR * This,
            /* [in] */ LPOLESTR lpstrSchema);
        
        HRESULT ( __stdcall __RPC_FAR *AddVarDesc )( 
            ICreateTypeInfo __RPC_FAR * This,
            /* [in] */ UINT index,
            /* [in] */ VARDESC __RPC_FAR *pvardesc);
        
        HRESULT ( __stdcall __RPC_FAR *SetFuncAndParamNames )( 
            ICreateTypeInfo __RPC_FAR * This,
            /* [in] */ UINT index,
            /* [in][size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames);
        
        HRESULT ( __stdcall __RPC_FAR *SetVarName )( 
            ICreateTypeInfo __RPC_FAR * This,
            /* [in] */ UINT index,
            /* [in] */ LPOLESTR szName);
        
        HRESULT ( __stdcall __RPC_FAR *SetTypeDescAlias )( 
            ICreateTypeInfo __RPC_FAR * This,
            /* [in] */ TYPEDESC __RPC_FAR *ptdescAlias);
        
        HRESULT ( __stdcall __RPC_FAR *DefineFuncAsDllEntry )( 
            ICreateTypeInfo __RPC_FAR * This,
            /* [in] */ UINT index,
            /* [in] */ LPOLESTR szDllName,
            /* [in] */ LPOLESTR szProcName);
        
        HRESULT ( __stdcall __RPC_FAR *SetFuncDocString )( 
            ICreateTypeInfo __RPC_FAR * This,
            /* [in] */ UINT index,
            /* [in] */ LPOLESTR szDocString);
        
        HRESULT ( __stdcall __RPC_FAR *SetVarDocString )( 
            ICreateTypeInfo __RPC_FAR * This,
            /* [in] */ UINT index,
            /* [in] */ LPOLESTR szDocString);
        
        HRESULT ( __stdcall __RPC_FAR *SetFuncHelpContext )( 
            ICreateTypeInfo __RPC_FAR * This,
            /* [in] */ UINT index,
            /* [in] */ DWORD dwHelpContext);
        
        HRESULT ( __stdcall __RPC_FAR *SetVarHelpContext )( 
            ICreateTypeInfo __RPC_FAR * This,
            /* [in] */ UINT index,
            /* [in] */ DWORD dwHelpContext);
        
        HRESULT ( __stdcall __RPC_FAR *SetMops )( 
            ICreateTypeInfo __RPC_FAR * This,
            /* [in] */ UINT index,
            /* [in] */ BSTR bstrMops);
        
        HRESULT ( __stdcall __RPC_FAR *SetTypeIdldesc )( 
            ICreateTypeInfo __RPC_FAR * This,
            /* [in] */ IDLDESC __RPC_FAR *pidldesc);
        
        HRESULT ( __stdcall __RPC_FAR *LayOut )( 
            ICreateTypeInfo __RPC_FAR * This);
        
    } ICreateTypeInfoVtbl;

    interface ICreateTypeInfo
    {
        CONST_VTBL struct ICreateTypeInfoVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICreateTypeInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICreateTypeInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICreateTypeInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICreateTypeInfo_SetGuid(This,guid)	\
    (This)->lpVtbl -> SetGuid(This,guid)

#define ICreateTypeInfo_SetTypeFlags(This,uTypeFlags)	\
    (This)->lpVtbl -> SetTypeFlags(This,uTypeFlags)

#define ICreateTypeInfo_SetDocString(This,lpstrDoc)	\
    (This)->lpVtbl -> SetDocString(This,lpstrDoc)

#define ICreateTypeInfo_SetHelpContext(This,dwHelpContext)	\
    (This)->lpVtbl -> SetHelpContext(This,dwHelpContext)

#define ICreateTypeInfo_SetVersion(This,wMajorVerNum,wMinorVerNum)	\
    (This)->lpVtbl -> SetVersion(This,wMajorVerNum,wMinorVerNum)

#define ICreateTypeInfo_AddRefTypeInfo(This,ptinfo,phreftype)	\
    (This)->lpVtbl -> AddRefTypeInfo(This,ptinfo,phreftype)

#define ICreateTypeInfo_AddFuncDesc(This,index,pfuncdesc)	\
    (This)->lpVtbl -> AddFuncDesc(This,index,pfuncdesc)

#define ICreateTypeInfo_AddImplType(This,index,hreftype)	\
    (This)->lpVtbl -> AddImplType(This,index,hreftype)

#define ICreateTypeInfo_SetImplTypeFlags(This,index,impltypeflags)	\
    (This)->lpVtbl -> SetImplTypeFlags(This,index,impltypeflags)

#define ICreateTypeInfo_SetAlignment(This,cbAlignment)	\
    (This)->lpVtbl -> SetAlignment(This,cbAlignment)

#define ICreateTypeInfo_SetSchema(This,lpstrSchema)	\
    (This)->lpVtbl -> SetSchema(This,lpstrSchema)

#define ICreateTypeInfo_AddVarDesc(This,index,pvardesc)	\
    (This)->lpVtbl -> AddVarDesc(This,index,pvardesc)

#define ICreateTypeInfo_SetFuncAndParamNames(This,index,rgszNames,cNames)	\
    (This)->lpVtbl -> SetFuncAndParamNames(This,index,rgszNames,cNames)

#define ICreateTypeInfo_SetVarName(This,index,szName)	\
    (This)->lpVtbl -> SetVarName(This,index,szName)

#define ICreateTypeInfo_SetTypeDescAlias(This,ptdescAlias)	\
    (This)->lpVtbl -> SetTypeDescAlias(This,ptdescAlias)

#define ICreateTypeInfo_DefineFuncAsDllEntry(This,index,szDllName,szProcName)	\
    (This)->lpVtbl -> DefineFuncAsDllEntry(This,index,szDllName,szProcName)

#define ICreateTypeInfo_SetFuncDocString(This,index,szDocString)	\
    (This)->lpVtbl -> SetFuncDocString(This,index,szDocString)

#define ICreateTypeInfo_SetVarDocString(This,index,szDocString)	\
    (This)->lpVtbl -> SetVarDocString(This,index,szDocString)

#define ICreateTypeInfo_SetFuncHelpContext(This,index,dwHelpContext)	\
    (This)->lpVtbl -> SetFuncHelpContext(This,index,dwHelpContext)

#define ICreateTypeInfo_SetVarHelpContext(This,index,dwHelpContext)	\
    (This)->lpVtbl -> SetVarHelpContext(This,index,dwHelpContext)

#define ICreateTypeInfo_SetMops(This,index,bstrMops)	\
    (This)->lpVtbl -> SetMops(This,index,bstrMops)

#define ICreateTypeInfo_SetTypeIdldesc(This,pidldesc)	\
    (This)->lpVtbl -> SetTypeIdldesc(This,pidldesc)

#define ICreateTypeInfo_LayOut(This)	\
    (This)->lpVtbl -> LayOut(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT __stdcall ICreateTypeInfo_SetGuid_Proxy( 
    ICreateTypeInfo __RPC_FAR * This,
    /* [in] */ REFGUID guid);


void __RPC_STUB ICreateTypeInfo_SetGuid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ICreateTypeInfo_SetTypeFlags_Proxy( 
    ICreateTypeInfo __RPC_FAR * This,
    /* [in] */ UINT uTypeFlags);


void __RPC_STUB ICreateTypeInfo_SetTypeFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ICreateTypeInfo_SetDocString_Proxy( 
    ICreateTypeInfo __RPC_FAR * This,
    /* [in] */ LPOLESTR lpstrDoc);


void __RPC_STUB ICreateTypeInfo_SetDocString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ICreateTypeInfo_SetHelpContext_Proxy( 
    ICreateTypeInfo __RPC_FAR * This,
    /* [in] */ DWORD dwHelpContext);


void __RPC_STUB ICreateTypeInfo_SetHelpContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ICreateTypeInfo_SetVersion_Proxy( 
    ICreateTypeInfo __RPC_FAR * This,
    /* [in] */ WORD wMajorVerNum,
    /* [in] */ WORD wMinorVerNum);


void __RPC_STUB ICreateTypeInfo_SetVersion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ICreateTypeInfo_AddRefTypeInfo_Proxy( 
    ICreateTypeInfo __RPC_FAR * This,
    /* [in] */ ITypeInfo __RPC_FAR *ptinfo,
    /* [in] */ HREFTYPE __RPC_FAR *phreftype);


void __RPC_STUB ICreateTypeInfo_AddRefTypeInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ICreateTypeInfo_AddFuncDesc_Proxy( 
    ICreateTypeInfo __RPC_FAR * This,
    /* [in] */ UINT index,
    /* [in] */ FUNCDESC __RPC_FAR *pfuncdesc);


void __RPC_STUB ICreateTypeInfo_AddFuncDesc_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ICreateTypeInfo_AddImplType_Proxy( 
    ICreateTypeInfo __RPC_FAR * This,
    /* [in] */ UINT index,
    /* [in] */ HREFTYPE hreftype);


void __RPC_STUB ICreateTypeInfo_AddImplType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ICreateTypeInfo_SetImplTypeFlags_Proxy( 
    ICreateTypeInfo __RPC_FAR * This,
    /* [in] */ UINT index,
    /* [in] */ INT impltypeflags);


void __RPC_STUB ICreateTypeInfo_SetImplTypeFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ICreateTypeInfo_SetAlignment_Proxy( 
    ICreateTypeInfo __RPC_FAR * This,
    /* [in] */ WORD cbAlignment);


void __RPC_STUB ICreateTypeInfo_SetAlignment_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ICreateTypeInfo_SetSchema_Proxy( 
    ICreateTypeInfo __RPC_FAR * This,
    /* [in] */ LPOLESTR lpstrSchema);


void __RPC_STUB ICreateTypeInfo_SetSchema_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ICreateTypeInfo_AddVarDesc_Proxy( 
    ICreateTypeInfo __RPC_FAR * This,
    /* [in] */ UINT index,
    /* [in] */ VARDESC __RPC_FAR *pvardesc);


void __RPC_STUB ICreateTypeInfo_AddVarDesc_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ICreateTypeInfo_SetFuncAndParamNames_Proxy( 
    ICreateTypeInfo __RPC_FAR * This,
    /* [in] */ UINT index,
    /* [in][size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
    /* [in] */ UINT cNames);


void __RPC_STUB ICreateTypeInfo_SetFuncAndParamNames_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ICreateTypeInfo_SetVarName_Proxy( 
    ICreateTypeInfo __RPC_FAR * This,
    /* [in] */ UINT index,
    /* [in] */ LPOLESTR szName);


void __RPC_STUB ICreateTypeInfo_SetVarName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ICreateTypeInfo_SetTypeDescAlias_Proxy( 
    ICreateTypeInfo __RPC_FAR * This,
    /* [in] */ TYPEDESC __RPC_FAR *ptdescAlias);


void __RPC_STUB ICreateTypeInfo_SetTypeDescAlias_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ICreateTypeInfo_DefineFuncAsDllEntry_Proxy( 
    ICreateTypeInfo __RPC_FAR * This,
    /* [in] */ UINT index,
    /* [in] */ LPOLESTR szDllName,
    /* [in] */ LPOLESTR szProcName);


void __RPC_STUB ICreateTypeInfo_DefineFuncAsDllEntry_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ICreateTypeInfo_SetFuncDocString_Proxy( 
    ICreateTypeInfo __RPC_FAR * This,
    /* [in] */ UINT index,
    /* [in] */ LPOLESTR szDocString);


void __RPC_STUB ICreateTypeInfo_SetFuncDocString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ICreateTypeInfo_SetVarDocString_Proxy( 
    ICreateTypeInfo __RPC_FAR * This,
    /* [in] */ UINT index,
    /* [in] */ LPOLESTR szDocString);


void __RPC_STUB ICreateTypeInfo_SetVarDocString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ICreateTypeInfo_SetFuncHelpContext_Proxy( 
    ICreateTypeInfo __RPC_FAR * This,
    /* [in] */ UINT index,
    /* [in] */ DWORD dwHelpContext);


void __RPC_STUB ICreateTypeInfo_SetFuncHelpContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ICreateTypeInfo_SetVarHelpContext_Proxy( 
    ICreateTypeInfo __RPC_FAR * This,
    /* [in] */ UINT index,
    /* [in] */ DWORD dwHelpContext);


void __RPC_STUB ICreateTypeInfo_SetVarHelpContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ICreateTypeInfo_SetMops_Proxy( 
    ICreateTypeInfo __RPC_FAR * This,
    /* [in] */ UINT index,
    /* [in] */ BSTR bstrMops);


void __RPC_STUB ICreateTypeInfo_SetMops_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ICreateTypeInfo_SetTypeIdldesc_Proxy( 
    ICreateTypeInfo __RPC_FAR * This,
    /* [in] */ IDLDESC __RPC_FAR *pidldesc);


void __RPC_STUB ICreateTypeInfo_SetTypeIdldesc_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ICreateTypeInfo_LayOut_Proxy( 
    ICreateTypeInfo __RPC_FAR * This);


void __RPC_STUB ICreateTypeInfo_LayOut_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICreateTypeInfo_INTERFACE_DEFINED__ */


#ifndef __ICreateTypeLib_INTERFACE_DEFINED__
#define __ICreateTypeLib_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ICreateTypeLib
 * at Fri Apr 28 07:02:38 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [local][unique][uuid][object] */ 


			/* size is 4 */
typedef /* [unique] */ ICreateTypeLib __RPC_FAR *LPCREATETYPELIB;


EXTERN_C const IID IID_ICreateTypeLib;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface ICreateTypeLib : public IUnknown
    {
    public:
        virtual HRESULT __stdcall CreateTypeInfo( 
            /* [in] */ LPOLESTR szName,
            /* [in] */ TYPEKIND tkind,
            /* [out] */ ICreateTypeInfo __RPC_FAR *__RPC_FAR *lplpictinfo) = 0;
        
        virtual HRESULT __stdcall SetName( 
            LPOLESTR szName) = 0;
        
        virtual HRESULT __stdcall SetVersion( 
            /* [in] */ WORD wMajorVerNum,
            /* [in] */ WORD wMinorVerNum) = 0;
        
        virtual HRESULT __stdcall SetGuid( 
            /* [in] */ REFGUID guid) = 0;
        
        virtual HRESULT __stdcall SetDocString( 
            /* [in] */ LPOLESTR szDoc) = 0;
        
        virtual HRESULT __stdcall SetHelpFileName( 
            /* [in] */ LPOLESTR szHelpFileName) = 0;
        
        virtual HRESULT __stdcall SetHelpContext( 
            /* [in] */ DWORD dwHelpContext) = 0;
        
        virtual HRESULT __stdcall SetLcid( 
            /* [in] */ LCID lcid) = 0;
        
        virtual HRESULT __stdcall SetLibFlags( 
            /* [in] */ UINT uLibFlags) = 0;
        
        virtual HRESULT __stdcall SaveAllChanges( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICreateTypeLibVtbl
    {
        
        HRESULT ( __stdcall __RPC_FAR *QueryInterface )( 
            ICreateTypeLib __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( __stdcall __RPC_FAR *AddRef )( 
            ICreateTypeLib __RPC_FAR * This);
        
        ULONG ( __stdcall __RPC_FAR *Release )( 
            ICreateTypeLib __RPC_FAR * This);
        
        HRESULT ( __stdcall __RPC_FAR *CreateTypeInfo )( 
            ICreateTypeLib __RPC_FAR * This,
            /* [in] */ LPOLESTR szName,
            /* [in] */ TYPEKIND tkind,
            /* [out] */ ICreateTypeInfo __RPC_FAR *__RPC_FAR *lplpictinfo);
        
        HRESULT ( __stdcall __RPC_FAR *SetName )( 
            ICreateTypeLib __RPC_FAR * This,
            LPOLESTR szName);
        
        HRESULT ( __stdcall __RPC_FAR *SetVersion )( 
            ICreateTypeLib __RPC_FAR * This,
            /* [in] */ WORD wMajorVerNum,
            /* [in] */ WORD wMinorVerNum);
        
        HRESULT ( __stdcall __RPC_FAR *SetGuid )( 
            ICreateTypeLib __RPC_FAR * This,
            /* [in] */ REFGUID guid);
        
        HRESULT ( __stdcall __RPC_FAR *SetDocString )( 
            ICreateTypeLib __RPC_FAR * This,
            /* [in] */ LPOLESTR szDoc);
        
        HRESULT ( __stdcall __RPC_FAR *SetHelpFileName )( 
            ICreateTypeLib __RPC_FAR * This,
            /* [in] */ LPOLESTR szHelpFileName);
        
        HRESULT ( __stdcall __RPC_FAR *SetHelpContext )( 
            ICreateTypeLib __RPC_FAR * This,
            /* [in] */ DWORD dwHelpContext);
        
        HRESULT ( __stdcall __RPC_FAR *SetLcid )( 
            ICreateTypeLib __RPC_FAR * This,
            /* [in] */ LCID lcid);
        
        HRESULT ( __stdcall __RPC_FAR *SetLibFlags )( 
            ICreateTypeLib __RPC_FAR * This,
            /* [in] */ UINT uLibFlags);
        
        HRESULT ( __stdcall __RPC_FAR *SaveAllChanges )( 
            ICreateTypeLib __RPC_FAR * This);
        
    } ICreateTypeLibVtbl;

    interface ICreateTypeLib
    {
        CONST_VTBL struct ICreateTypeLibVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICreateTypeLib_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICreateTypeLib_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICreateTypeLib_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICreateTypeLib_CreateTypeInfo(This,szName,tkind,lplpictinfo)	\
    (This)->lpVtbl -> CreateTypeInfo(This,szName,tkind,lplpictinfo)

#define ICreateTypeLib_SetName(This,szName)	\
    (This)->lpVtbl -> SetName(This,szName)

#define ICreateTypeLib_SetVersion(This,wMajorVerNum,wMinorVerNum)	\
    (This)->lpVtbl -> SetVersion(This,wMajorVerNum,wMinorVerNum)

#define ICreateTypeLib_SetGuid(This,guid)	\
    (This)->lpVtbl -> SetGuid(This,guid)

#define ICreateTypeLib_SetDocString(This,szDoc)	\
    (This)->lpVtbl -> SetDocString(This,szDoc)

#define ICreateTypeLib_SetHelpFileName(This,szHelpFileName)	\
    (This)->lpVtbl -> SetHelpFileName(This,szHelpFileName)

#define ICreateTypeLib_SetHelpContext(This,dwHelpContext)	\
    (This)->lpVtbl -> SetHelpContext(This,dwHelpContext)

#define ICreateTypeLib_SetLcid(This,lcid)	\
    (This)->lpVtbl -> SetLcid(This,lcid)

#define ICreateTypeLib_SetLibFlags(This,uLibFlags)	\
    (This)->lpVtbl -> SetLibFlags(This,uLibFlags)

#define ICreateTypeLib_SaveAllChanges(This)	\
    (This)->lpVtbl -> SaveAllChanges(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT __stdcall ICreateTypeLib_CreateTypeInfo_Proxy( 
    ICreateTypeLib __RPC_FAR * This,
    /* [in] */ LPOLESTR szName,
    /* [in] */ TYPEKIND tkind,
    /* [out] */ ICreateTypeInfo __RPC_FAR *__RPC_FAR *lplpictinfo);


void __RPC_STUB ICreateTypeLib_CreateTypeInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ICreateTypeLib_SetName_Proxy( 
    ICreateTypeLib __RPC_FAR * This,
    LPOLESTR szName);


void __RPC_STUB ICreateTypeLib_SetName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ICreateTypeLib_SetVersion_Proxy( 
    ICreateTypeLib __RPC_FAR * This,
    /* [in] */ WORD wMajorVerNum,
    /* [in] */ WORD wMinorVerNum);


void __RPC_STUB ICreateTypeLib_SetVersion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ICreateTypeLib_SetGuid_Proxy( 
    ICreateTypeLib __RPC_FAR * This,
    /* [in] */ REFGUID guid);


void __RPC_STUB ICreateTypeLib_SetGuid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ICreateTypeLib_SetDocString_Proxy( 
    ICreateTypeLib __RPC_FAR * This,
    /* [in] */ LPOLESTR szDoc);


void __RPC_STUB ICreateTypeLib_SetDocString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ICreateTypeLib_SetHelpFileName_Proxy( 
    ICreateTypeLib __RPC_FAR * This,
    /* [in] */ LPOLESTR szHelpFileName);


void __RPC_STUB ICreateTypeLib_SetHelpFileName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ICreateTypeLib_SetHelpContext_Proxy( 
    ICreateTypeLib __RPC_FAR * This,
    /* [in] */ DWORD dwHelpContext);


void __RPC_STUB ICreateTypeLib_SetHelpContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ICreateTypeLib_SetLcid_Proxy( 
    ICreateTypeLib __RPC_FAR * This,
    /* [in] */ LCID lcid);


void __RPC_STUB ICreateTypeLib_SetLcid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ICreateTypeLib_SetLibFlags_Proxy( 
    ICreateTypeLib __RPC_FAR * This,
    /* [in] */ UINT uLibFlags);


void __RPC_STUB ICreateTypeLib_SetLibFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ICreateTypeLib_SaveAllChanges_Proxy( 
    ICreateTypeLib __RPC_FAR * This);


void __RPC_STUB ICreateTypeLib_SaveAllChanges_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICreateTypeLib_INTERFACE_DEFINED__ */


#ifndef __IDispatch_INTERFACE_DEFINED__
#define __IDispatch_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IDispatch
 * at Fri Apr 28 07:02:38 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [local][unique][uuid][object] */ 


			/* size is 4 */
typedef /* [unique] */ IDispatch __RPC_FAR *LPDISPATCH;

/* DISPID reserved to indicate an "unknown" name */
/* only reserved for data members (properties); reused as a method dispid below */
			/* size is 4 */
#define	DISPID_UNKNOWN	( -1 )

/* DISPID reserved for the "value" property */
			/* size is 4 */
#define	DISPID_VALUE	( 0 )

/* The following DISPID is reserved to indicate the param
 * that is the right-hand-side (or "put" value) of a PropertyPut
 */
			/* size is 4 */
#define	DISPID_PROPERTYPUT	( -3 )

/* DISPID reserved for the standard "NewEnum" method */
			/* size is 4 */
#define	DISPID_NEWENUM	( -4 )

/* DISPID reserved for the standard "Evaluate" method */
			/* size is 4 */
#define	DISPID_EVALUATE	( -5 )

			/* size is 4 */
#define	DISPID_CONSTRUCTOR	( -6 )

			/* size is 4 */
#define	DISPID_DESTRUCTOR	( -7 )

			/* size is 4 */
#define	DISPID_COLLECT	( -8 )

/* The range -500 through -999 is reserved for Controls */
/* The range 0x80010000 through 0x8001FFFF is reserved for Controls */
/* The remainder of the negative DISPIDs are reserved for future use */

EXTERN_C const IID IID_IDispatch;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IDispatch : public IUnknown
    {
    public:
        virtual HRESULT __stdcall GetTypeInfoCount( 
            /* [out] */ UINT __RPC_FAR *pctinfo) = 0;
        
        virtual HRESULT __stdcall GetTypeInfo( 
            /* [in] */ UINT itinfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *pptinfo) = 0;
        
        virtual HRESULT __stdcall GetIDsOfNames( 
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out][in] */ DISPID __RPC_FAR *rgdispid) = 0;
        
        virtual HRESULT __stdcall Invoke( 
            /* [in] */ DISPID dispidMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [unique][in] */ DISPPARAMS __RPC_FAR *pdispparams,
            /* [unique][out][in] */ VARIANT __RPC_FAR *pvarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pexcepinfo,
            /* [out] */ UINT __RPC_FAR *puArgErr) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDispatchVtbl
    {
        
        HRESULT ( __stdcall __RPC_FAR *QueryInterface )( 
            IDispatch __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( __stdcall __RPC_FAR *AddRef )( 
            IDispatch __RPC_FAR * This);
        
        ULONG ( __stdcall __RPC_FAR *Release )( 
            IDispatch __RPC_FAR * This);
        
        HRESULT ( __stdcall __RPC_FAR *GetTypeInfoCount )( 
            IDispatch __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( __stdcall __RPC_FAR *GetTypeInfo )( 
            IDispatch __RPC_FAR * This,
            /* [in] */ UINT itinfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *pptinfo);
        
        HRESULT ( __stdcall __RPC_FAR *GetIDsOfNames )( 
            IDispatch __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out][in] */ DISPID __RPC_FAR *rgdispid);
        
        HRESULT ( __stdcall __RPC_FAR *Invoke )( 
            IDispatch __RPC_FAR * This,
            /* [in] */ DISPID dispidMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [unique][in] */ DISPPARAMS __RPC_FAR *pdispparams,
            /* [unique][out][in] */ VARIANT __RPC_FAR *pvarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pexcepinfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
    } IDispatchVtbl;

    interface IDispatch
    {
        CONST_VTBL struct IDispatchVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDispatch_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDispatch_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDispatch_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDispatch_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDispatch_GetTypeInfo(This,itinfo,lcid,pptinfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,itinfo,lcid,pptinfo)

#define IDispatch_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgdispid)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgdispid)

#define IDispatch_Invoke(This,dispidMember,riid,lcid,wFlags,pdispparams,pvarResult,pexcepinfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispidMember,riid,lcid,wFlags,pdispparams,pvarResult,pexcepinfo,puArgErr)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT __stdcall IDispatch_GetTypeInfoCount_Proxy( 
    IDispatch __RPC_FAR * This,
    /* [out] */ UINT __RPC_FAR *pctinfo);


void __RPC_STUB IDispatch_GetTypeInfoCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IDispatch_GetTypeInfo_Proxy( 
    IDispatch __RPC_FAR * This,
    /* [in] */ UINT itinfo,
    /* [in] */ LCID lcid,
    /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *pptinfo);


void __RPC_STUB IDispatch_GetTypeInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IDispatch_GetIDsOfNames_Proxy( 
    IDispatch __RPC_FAR * This,
    /* [in] */ REFIID riid,
    /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
    /* [in] */ UINT cNames,
    /* [in] */ LCID lcid,
    /* [size_is][out][in] */ DISPID __RPC_FAR *rgdispid);


void __RPC_STUB IDispatch_GetIDsOfNames_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IDispatch_Invoke_Proxy( 
    IDispatch __RPC_FAR * This,
    /* [in] */ DISPID dispidMember,
    /* [in] */ REFIID riid,
    /* [in] */ LCID lcid,
    /* [in] */ WORD wFlags,
    /* [unique][in] */ DISPPARAMS __RPC_FAR *pdispparams,
    /* [unique][out][in] */ VARIANT __RPC_FAR *pvarResult,
    /* [out] */ EXCEPINFO __RPC_FAR *pexcepinfo,
    /* [out] */ UINT __RPC_FAR *puArgErr);


void __RPC_STUB IDispatch_Invoke_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDispatch_INTERFACE_DEFINED__ */


#ifndef __IEnumVARIANT_INTERFACE_DEFINED__
#define __IEnumVARIANT_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IEnumVARIANT
 * at Fri Apr 28 07:02:38 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [unique][uuid][local][object] */ 


			/* size is 4 */
typedef /* [unique] */ IEnumVARIANT __RPC_FAR *LPENUMVARIANT;


EXTERN_C const IID IID_IEnumVARIANT;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IEnumVARIANT : public IUnknown
    {
    public:
        virtual HRESULT __stdcall Next( 
            /* [in] */ unsigned long celt,
            /* [out] */ VARIANT __RPC_FAR *rgvar,
            /* [out] */ unsigned long __RPC_FAR *pceltFetched) = 0;
        
        virtual HRESULT __stdcall Skip( 
            /* [in] */ unsigned long celt) = 0;
        
        virtual HRESULT __stdcall Reset( void) = 0;
        
        virtual HRESULT __stdcall Clone( 
            /* [out] */ IEnumVARIANT __RPC_FAR *__RPC_FAR *ppenum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumVARIANTVtbl
    {
        
        HRESULT ( __stdcall __RPC_FAR *QueryInterface )( 
            IEnumVARIANT __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( __stdcall __RPC_FAR *AddRef )( 
            IEnumVARIANT __RPC_FAR * This);
        
        ULONG ( __stdcall __RPC_FAR *Release )( 
            IEnumVARIANT __RPC_FAR * This);
        
        HRESULT ( __stdcall __RPC_FAR *Next )( 
            IEnumVARIANT __RPC_FAR * This,
            /* [in] */ unsigned long celt,
            /* [out] */ VARIANT __RPC_FAR *rgvar,
            /* [out] */ unsigned long __RPC_FAR *pceltFetched);
        
        HRESULT ( __stdcall __RPC_FAR *Skip )( 
            IEnumVARIANT __RPC_FAR * This,
            /* [in] */ unsigned long celt);
        
        HRESULT ( __stdcall __RPC_FAR *Reset )( 
            IEnumVARIANT __RPC_FAR * This);
        
        HRESULT ( __stdcall __RPC_FAR *Clone )( 
            IEnumVARIANT __RPC_FAR * This,
            /* [out] */ IEnumVARIANT __RPC_FAR *__RPC_FAR *ppenum);
        
    } IEnumVARIANTVtbl;

    interface IEnumVARIANT
    {
        CONST_VTBL struct IEnumVARIANTVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumVARIANT_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumVARIANT_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumVARIANT_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumVARIANT_Next(This,celt,rgvar,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgvar,pceltFetched)

#define IEnumVARIANT_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumVARIANT_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumVARIANT_Clone(This,ppenum)	\
    (This)->lpVtbl -> Clone(This,ppenum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT __stdcall IEnumVARIANT_Next_Proxy( 
    IEnumVARIANT __RPC_FAR * This,
    /* [in] */ unsigned long celt,
    /* [out] */ VARIANT __RPC_FAR *rgvar,
    /* [out] */ unsigned long __RPC_FAR *pceltFetched);


void __RPC_STUB IEnumVARIANT_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IEnumVARIANT_Skip_Proxy( 
    IEnumVARIANT __RPC_FAR * This,
    /* [in] */ unsigned long celt);


void __RPC_STUB IEnumVARIANT_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IEnumVARIANT_Reset_Proxy( 
    IEnumVARIANT __RPC_FAR * This);


void __RPC_STUB IEnumVARIANT_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IEnumVARIANT_Clone_Proxy( 
    IEnumVARIANT __RPC_FAR * This,
    /* [out] */ IEnumVARIANT __RPC_FAR *__RPC_FAR *ppenum);


void __RPC_STUB IEnumVARIANT_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumVARIANT_INTERFACE_DEFINED__ */


#ifndef __ITypeComp_INTERFACE_DEFINED__
#define __ITypeComp_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ITypeComp
 * at Fri Apr 28 07:02:38 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [local][unique][uuid][object] */ 


			/* size is 4 */
typedef /* [unique] */ ITypeComp __RPC_FAR *LPTYPECOMP;

			/* size is 2 */
typedef /* [v1_enum] */ 
enum tagDESCKIND
    {	DESCKIND_NONE	= 0,
	DESCKIND_FUNCDESC	= DESCKIND_NONE + 1,
	DESCKIND_VARDESC	= DESCKIND_FUNCDESC + 1,
	DESCKIND_TYPECOMP	= DESCKIND_VARDESC + 1,
	DESCKIND_IMPLICITAPPOBJ	= DESCKIND_TYPECOMP + 1,
	DESCKIND_MAX	= DESCKIND_IMPLICITAPPOBJ + 1
    }	DESCKIND;

#define DESCKIND_to_xmit(pEnum, ppLong) *(ppLong) = (long *) (pEnum)
#define DESCKIND_from_xmit(pLong, pEnum) *(pEnum) = (DESCKIND) *(pLong)
#define DESCKIND_free_inst(pEnum) 
#define DESCKIND_free_xmit(pLong) 
			/* size is 4 */
/* [switch_type] */ union tagBINDPTR
    {
    /* [case] */ FUNCDESC __RPC_FAR *lpfuncdesc;
    /* [case] */ VARDESC __RPC_FAR *lpvardesc;
    /* [case][unique] */ ITypeComp __RPC_FAR *lptcomp;
    /* [default] */  /* Empty union arm */ 
    };
			/* size is 4 */
typedef union tagBINDPTR BINDPTR;

			/* size is 4 */
typedef BINDPTR __RPC_FAR *LPBINDPTR;


EXTERN_C const IID IID_ITypeComp;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface ITypeComp : public IUnknown
    {
    public:
        virtual HRESULT __stdcall Bind( 
            /* [in] */ LPOLESTR szName,
            /* [in] */ ULONG lHashVal,
            /* [in] */ WORD fFlags,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *pptinfo,
            /* [out] */ DESCKIND __RPC_FAR *pdesckind,
            /* [switch_is][out] */ BINDPTR __RPC_FAR *pbindptr) = 0;
        
        virtual HRESULT __stdcall BindType( 
            /* [in] */ LPOLESTR szName,
            /* [in] */ ULONG lHashVal,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *pptinfo,
            /* [out] */ ITypeComp __RPC_FAR *__RPC_FAR *pptcomp) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITypeCompVtbl
    {
        
        HRESULT ( __stdcall __RPC_FAR *QueryInterface )( 
            ITypeComp __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( __stdcall __RPC_FAR *AddRef )( 
            ITypeComp __RPC_FAR * This);
        
        ULONG ( __stdcall __RPC_FAR *Release )( 
            ITypeComp __RPC_FAR * This);
        
        HRESULT ( __stdcall __RPC_FAR *Bind )( 
            ITypeComp __RPC_FAR * This,
            /* [in] */ LPOLESTR szName,
            /* [in] */ ULONG lHashVal,
            /* [in] */ WORD fFlags,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *pptinfo,
            /* [out] */ DESCKIND __RPC_FAR *pdesckind,
            /* [switch_is][out] */ BINDPTR __RPC_FAR *pbindptr);
        
        HRESULT ( __stdcall __RPC_FAR *BindType )( 
            ITypeComp __RPC_FAR * This,
            /* [in] */ LPOLESTR szName,
            /* [in] */ ULONG lHashVal,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *pptinfo,
            /* [out] */ ITypeComp __RPC_FAR *__RPC_FAR *pptcomp);
        
    } ITypeCompVtbl;

    interface ITypeComp
    {
        CONST_VTBL struct ITypeCompVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITypeComp_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITypeComp_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITypeComp_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITypeComp_Bind(This,szName,lHashVal,fFlags,pptinfo,pdesckind,pbindptr)	\
    (This)->lpVtbl -> Bind(This,szName,lHashVal,fFlags,pptinfo,pdesckind,pbindptr)

#define ITypeComp_BindType(This,szName,lHashVal,pptinfo,pptcomp)	\
    (This)->lpVtbl -> BindType(This,szName,lHashVal,pptinfo,pptcomp)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT __stdcall ITypeComp_Bind_Proxy( 
    ITypeComp __RPC_FAR * This,
    /* [in] */ LPOLESTR szName,
    /* [in] */ ULONG lHashVal,
    /* [in] */ WORD fFlags,
    /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *pptinfo,
    /* [out] */ DESCKIND __RPC_FAR *pdesckind,
    /* [switch_is][out] */ BINDPTR __RPC_FAR *pbindptr);


void __RPC_STUB ITypeComp_Bind_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ITypeComp_BindType_Proxy( 
    ITypeComp __RPC_FAR * This,
    /* [in] */ LPOLESTR szName,
    /* [in] */ ULONG lHashVal,
    /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *pptinfo,
    /* [out] */ ITypeComp __RPC_FAR *__RPC_FAR *pptcomp);


void __RPC_STUB ITypeComp_BindType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITypeComp_INTERFACE_DEFINED__ */


#ifndef __ITypeInfo_INTERFACE_DEFINED__
#define __ITypeInfo_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ITypeInfo
 * at Fri Apr 28 07:02:38 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [local][unique][uuid][object] */ 


			/* size is 4 */
typedef /* [unique] */ ITypeInfo __RPC_FAR *LPTYPEINFO;


EXTERN_C const IID IID_ITypeInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface ITypeInfo : public IUnknown
    {
    public:
        virtual HRESULT __stdcall GetTypeAttr( 
            /* [out] */ TYPEATTR __RPC_FAR *__RPC_FAR *pptypeattr) = 0;
        
        virtual HRESULT __stdcall GetTypeComp( 
            /* [out] */ ITypeComp __RPC_FAR *__RPC_FAR *pptcomp) = 0;
        
        virtual HRESULT __stdcall GetFuncDesc( 
            /* [in] */ UINT index,
            /* [out] */ FUNCDESC __RPC_FAR *__RPC_FAR *pppfuncdesc) = 0;
        
        virtual HRESULT __stdcall GetVarDesc( 
            /* [in] */ UINT index,
            /* [out] */ VARDESC __RPC_FAR *__RPC_FAR *ppvardesc) = 0;
        
        virtual HRESULT __stdcall GetNames( 
            /* [in] */ MEMBERID memid,
            /* [length_is][size_is][out] */ BSTR __RPC_FAR *rgbstrNames,
            /* [in] */ UINT cMaxNames,
            /* [out] */ UINT __RPC_FAR *pcNames) = 0;
        
        virtual HRESULT __stdcall GetRefTypeOfImplType( 
            /* [in] */ UINT index,
            /* [out] */ HREFTYPE __RPC_FAR *hpreftype) = 0;
        
        virtual HRESULT __stdcall GetImplTypeFlags( 
            /* [in] */ UINT index,
            /* [out] */ INT __RPC_FAR *pimpltypeflags) = 0;
        
        virtual HRESULT __stdcall GetIDsOfNames( 
            /* [size_is][in] */ OLECHAR __RPC_FAR *__RPC_FAR *rglpszNames,
            /* [in] */ UINT cNames,
            /* [size_is][out] */ MEMBERID __RPC_FAR *rgmemid) = 0;
        
        virtual HRESULT __stdcall Invoke( 
            /* [unique][in] */ void __RPC_FAR *pvInstance,
            /* [in] */ MEMBERID memid,
            /* [in] */ WORD wFlags,
            /* [in] */ DISPPARAMS __RPC_FAR *pdispparams,
            /* [out] */ VARIANT __RPC_FAR *pvarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pexcepinfo,
            /* [out] */ UINT __RPC_FAR *puArgErr) = 0;
        
        virtual HRESULT __stdcall GetDocumentation( 
            /* [in] */ MEMBERID memid,
            /* [out] */ BSTR __RPC_FAR *pbstrName,
            /* [out] */ BSTR __RPC_FAR *pbstrDocString,
            /* [out] */ DWORD __RPC_FAR *pdwHelpContext,
            /* [out] */ BSTR __RPC_FAR *pbstrHelpFile) = 0;
        
        virtual HRESULT __stdcall GetDllEntry( 
            /* [in] */ MEMBERID memid,
            /* [in] */ INVOKEKIND invkind,
            /* [out] */ BSTR __RPC_FAR *pbstrDllName,
            /* [out] */ BSTR __RPC_FAR *pbstrName,
            /* [out] */ WORD __RPC_FAR *pwOrdinal) = 0;
        
        virtual HRESULT __stdcall GetRefTypeInfo( 
            /* [in] */ HREFTYPE hreftype,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *pptinfo) = 0;
        
        virtual HRESULT __stdcall AddressOfMember( 
            /* [in] */ MEMBERID memid,
            /* [in] */ INVOKEKIND invkind,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppv) = 0;
        
        virtual HRESULT __stdcall CreateInstance( 
            /* [in] */ IUnknown __RPC_FAR *puncOuter,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObj) = 0;
        
        virtual HRESULT __stdcall GetMops( 
            /* [in] */ MEMBERID memid,
            /* [out] */ BSTR __RPC_FAR *pbstrMops) = 0;
        
        virtual HRESULT __stdcall GetContainingTypeLib( 
            /* [out] */ ITypeLib __RPC_FAR *__RPC_FAR *pptlib,
            /* [out] */ UINT __RPC_FAR *pindex) = 0;
        
        virtual void __stdcall ReleaseTypeAttr( 
            /* [in] */ TYPEATTR __RPC_FAR *ptypeattr) = 0;
        
        virtual void __stdcall ReleaseFuncDesc( 
            /* [in] */ FUNCDESC __RPC_FAR *pfuncdesc) = 0;
        
        virtual void __stdcall ReleaseVarDesc( 
            /* [in] */ VARDESC __RPC_FAR *pvardesc) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITypeInfoVtbl
    {
        
        HRESULT ( __stdcall __RPC_FAR *QueryInterface )( 
            ITypeInfo __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( __stdcall __RPC_FAR *AddRef )( 
            ITypeInfo __RPC_FAR * This);
        
        ULONG ( __stdcall __RPC_FAR *Release )( 
            ITypeInfo __RPC_FAR * This);
        
        HRESULT ( __stdcall __RPC_FAR *GetTypeAttr )( 
            ITypeInfo __RPC_FAR * This,
            /* [out] */ TYPEATTR __RPC_FAR *__RPC_FAR *pptypeattr);
        
        HRESULT ( __stdcall __RPC_FAR *GetTypeComp )( 
            ITypeInfo __RPC_FAR * This,
            /* [out] */ ITypeComp __RPC_FAR *__RPC_FAR *pptcomp);
        
        HRESULT ( __stdcall __RPC_FAR *GetFuncDesc )( 
            ITypeInfo __RPC_FAR * This,
            /* [in] */ UINT index,
            /* [out] */ FUNCDESC __RPC_FAR *__RPC_FAR *pppfuncdesc);
        
        HRESULT ( __stdcall __RPC_FAR *GetVarDesc )( 
            ITypeInfo __RPC_FAR * This,
            /* [in] */ UINT index,
            /* [out] */ VARDESC __RPC_FAR *__RPC_FAR *ppvardesc);
        
        HRESULT ( __stdcall __RPC_FAR *GetNames )( 
            ITypeInfo __RPC_FAR * This,
            /* [in] */ MEMBERID memid,
            /* [length_is][size_is][out] */ BSTR __RPC_FAR *rgbstrNames,
            /* [in] */ UINT cMaxNames,
            /* [out] */ UINT __RPC_FAR *pcNames);
        
        HRESULT ( __stdcall __RPC_FAR *GetRefTypeOfImplType )( 
            ITypeInfo __RPC_FAR * This,
            /* [in] */ UINT index,
            /* [out] */ HREFTYPE __RPC_FAR *hpreftype);
        
        HRESULT ( __stdcall __RPC_FAR *GetImplTypeFlags )( 
            ITypeInfo __RPC_FAR * This,
            /* [in] */ UINT index,
            /* [out] */ INT __RPC_FAR *pimpltypeflags);
        
        HRESULT ( __stdcall __RPC_FAR *GetIDsOfNames )( 
            ITypeInfo __RPC_FAR * This,
            /* [size_is][in] */ OLECHAR __RPC_FAR *__RPC_FAR *rglpszNames,
            /* [in] */ UINT cNames,
            /* [size_is][out] */ MEMBERID __RPC_FAR *rgmemid);
        
        HRESULT ( __stdcall __RPC_FAR *Invoke )( 
            ITypeInfo __RPC_FAR * This,
            /* [unique][in] */ void __RPC_FAR *pvInstance,
            /* [in] */ MEMBERID memid,
            /* [in] */ WORD wFlags,
            /* [in] */ DISPPARAMS __RPC_FAR *pdispparams,
            /* [out] */ VARIANT __RPC_FAR *pvarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pexcepinfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        HRESULT ( __stdcall __RPC_FAR *GetDocumentation )( 
            ITypeInfo __RPC_FAR * This,
            /* [in] */ MEMBERID memid,
            /* [out] */ BSTR __RPC_FAR *pbstrName,
            /* [out] */ BSTR __RPC_FAR *pbstrDocString,
            /* [out] */ DWORD __RPC_FAR *pdwHelpContext,
            /* [out] */ BSTR __RPC_FAR *pbstrHelpFile);
        
        HRESULT ( __stdcall __RPC_FAR *GetDllEntry )( 
            ITypeInfo __RPC_FAR * This,
            /* [in] */ MEMBERID memid,
            /* [in] */ INVOKEKIND invkind,
            /* [out] */ BSTR __RPC_FAR *pbstrDllName,
            /* [out] */ BSTR __RPC_FAR *pbstrName,
            /* [out] */ WORD __RPC_FAR *pwOrdinal);
        
        HRESULT ( __stdcall __RPC_FAR *GetRefTypeInfo )( 
            ITypeInfo __RPC_FAR * This,
            /* [in] */ HREFTYPE hreftype,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *pptinfo);
        
        HRESULT ( __stdcall __RPC_FAR *AddressOfMember )( 
            ITypeInfo __RPC_FAR * This,
            /* [in] */ MEMBERID memid,
            /* [in] */ INVOKEKIND invkind,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppv);
        
        HRESULT ( __stdcall __RPC_FAR *CreateInstance )( 
            ITypeInfo __RPC_FAR * This,
            /* [in] */ IUnknown __RPC_FAR *puncOuter,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObj);
        
        HRESULT ( __stdcall __RPC_FAR *GetMops )( 
            ITypeInfo __RPC_FAR * This,
            /* [in] */ MEMBERID memid,
            /* [out] */ BSTR __RPC_FAR *pbstrMops);
        
        HRESULT ( __stdcall __RPC_FAR *GetContainingTypeLib )( 
            ITypeInfo __RPC_FAR * This,
            /* [out] */ ITypeLib __RPC_FAR *__RPC_FAR *pptlib,
            /* [out] */ UINT __RPC_FAR *pindex);
        
        void ( __stdcall __RPC_FAR *ReleaseTypeAttr )( 
            ITypeInfo __RPC_FAR * This,
            /* [in] */ TYPEATTR __RPC_FAR *ptypeattr);
        
        void ( __stdcall __RPC_FAR *ReleaseFuncDesc )( 
            ITypeInfo __RPC_FAR * This,
            /* [in] */ FUNCDESC __RPC_FAR *pfuncdesc);
        
        void ( __stdcall __RPC_FAR *ReleaseVarDesc )( 
            ITypeInfo __RPC_FAR * This,
            /* [in] */ VARDESC __RPC_FAR *pvardesc);
        
    } ITypeInfoVtbl;

    interface ITypeInfo
    {
        CONST_VTBL struct ITypeInfoVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITypeInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITypeInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITypeInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITypeInfo_GetTypeAttr(This,pptypeattr)	\
    (This)->lpVtbl -> GetTypeAttr(This,pptypeattr)

#define ITypeInfo_GetTypeComp(This,pptcomp)	\
    (This)->lpVtbl -> GetTypeComp(This,pptcomp)

#define ITypeInfo_GetFuncDesc(This,index,pppfuncdesc)	\
    (This)->lpVtbl -> GetFuncDesc(This,index,pppfuncdesc)

#define ITypeInfo_GetVarDesc(This,index,ppvardesc)	\
    (This)->lpVtbl -> GetVarDesc(This,index,ppvardesc)

#define ITypeInfo_GetNames(This,memid,rgbstrNames,cMaxNames,pcNames)	\
    (This)->lpVtbl -> GetNames(This,memid,rgbstrNames,cMaxNames,pcNames)

#define ITypeInfo_GetRefTypeOfImplType(This,index,hpreftype)	\
    (This)->lpVtbl -> GetRefTypeOfImplType(This,index,hpreftype)

#define ITypeInfo_GetImplTypeFlags(This,index,pimpltypeflags)	\
    (This)->lpVtbl -> GetImplTypeFlags(This,index,pimpltypeflags)

#define ITypeInfo_GetIDsOfNames(This,rglpszNames,cNames,rgmemid)	\
    (This)->lpVtbl -> GetIDsOfNames(This,rglpszNames,cNames,rgmemid)

#define ITypeInfo_Invoke(This,pvInstance,memid,wFlags,pdispparams,pvarResult,pexcepinfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,pvInstance,memid,wFlags,pdispparams,pvarResult,pexcepinfo,puArgErr)

#define ITypeInfo_GetDocumentation(This,memid,pbstrName,pbstrDocString,pdwHelpContext,pbstrHelpFile)	\
    (This)->lpVtbl -> GetDocumentation(This,memid,pbstrName,pbstrDocString,pdwHelpContext,pbstrHelpFile)

#define ITypeInfo_GetDllEntry(This,memid,invkind,pbstrDllName,pbstrName,pwOrdinal)	\
    (This)->lpVtbl -> GetDllEntry(This,memid,invkind,pbstrDllName,pbstrName,pwOrdinal)

#define ITypeInfo_GetRefTypeInfo(This,hreftype,pptinfo)	\
    (This)->lpVtbl -> GetRefTypeInfo(This,hreftype,pptinfo)

#define ITypeInfo_AddressOfMember(This,memid,invkind,ppv)	\
    (This)->lpVtbl -> AddressOfMember(This,memid,invkind,ppv)

#define ITypeInfo_CreateInstance(This,puncOuter,riid,ppvObj)	\
    (This)->lpVtbl -> CreateInstance(This,puncOuter,riid,ppvObj)

#define ITypeInfo_GetMops(This,memid,pbstrMops)	\
    (This)->lpVtbl -> GetMops(This,memid,pbstrMops)

#define ITypeInfo_GetContainingTypeLib(This,pptlib,pindex)	\
    (This)->lpVtbl -> GetContainingTypeLib(This,pptlib,pindex)

#define ITypeInfo_ReleaseTypeAttr(This,ptypeattr)	\
    (This)->lpVtbl -> ReleaseTypeAttr(This,ptypeattr)

#define ITypeInfo_ReleaseFuncDesc(This,pfuncdesc)	\
    (This)->lpVtbl -> ReleaseFuncDesc(This,pfuncdesc)

#define ITypeInfo_ReleaseVarDesc(This,pvardesc)	\
    (This)->lpVtbl -> ReleaseVarDesc(This,pvardesc)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT __stdcall ITypeInfo_GetTypeAttr_Proxy( 
    ITypeInfo __RPC_FAR * This,
    /* [out] */ TYPEATTR __RPC_FAR *__RPC_FAR *pptypeattr);


void __RPC_STUB ITypeInfo_GetTypeAttr_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ITypeInfo_GetTypeComp_Proxy( 
    ITypeInfo __RPC_FAR * This,
    /* [out] */ ITypeComp __RPC_FAR *__RPC_FAR *pptcomp);


void __RPC_STUB ITypeInfo_GetTypeComp_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ITypeInfo_GetFuncDesc_Proxy( 
    ITypeInfo __RPC_FAR * This,
    /* [in] */ UINT index,
    /* [out] */ FUNCDESC __RPC_FAR *__RPC_FAR *pppfuncdesc);


void __RPC_STUB ITypeInfo_GetFuncDesc_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ITypeInfo_GetVarDesc_Proxy( 
    ITypeInfo __RPC_FAR * This,
    /* [in] */ UINT index,
    /* [out] */ VARDESC __RPC_FAR *__RPC_FAR *ppvardesc);


void __RPC_STUB ITypeInfo_GetVarDesc_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ITypeInfo_GetNames_Proxy( 
    ITypeInfo __RPC_FAR * This,
    /* [in] */ MEMBERID memid,
    /* [length_is][size_is][out] */ BSTR __RPC_FAR *rgbstrNames,
    /* [in] */ UINT cMaxNames,
    /* [out] */ UINT __RPC_FAR *pcNames);


void __RPC_STUB ITypeInfo_GetNames_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ITypeInfo_GetRefTypeOfImplType_Proxy( 
    ITypeInfo __RPC_FAR * This,
    /* [in] */ UINT index,
    /* [out] */ HREFTYPE __RPC_FAR *hpreftype);


void __RPC_STUB ITypeInfo_GetRefTypeOfImplType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ITypeInfo_GetImplTypeFlags_Proxy( 
    ITypeInfo __RPC_FAR * This,
    /* [in] */ UINT index,
    /* [out] */ INT __RPC_FAR *pimpltypeflags);


void __RPC_STUB ITypeInfo_GetImplTypeFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ITypeInfo_GetIDsOfNames_Proxy( 
    ITypeInfo __RPC_FAR * This,
    /* [size_is][in] */ OLECHAR __RPC_FAR *__RPC_FAR *rglpszNames,
    /* [in] */ UINT cNames,
    /* [size_is][out] */ MEMBERID __RPC_FAR *rgmemid);


void __RPC_STUB ITypeInfo_GetIDsOfNames_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ITypeInfo_Invoke_Proxy( 
    ITypeInfo __RPC_FAR * This,
    /* [unique][in] */ void __RPC_FAR *pvInstance,
    /* [in] */ MEMBERID memid,
    /* [in] */ WORD wFlags,
    /* [in] */ DISPPARAMS __RPC_FAR *pdispparams,
    /* [out] */ VARIANT __RPC_FAR *pvarResult,
    /* [out] */ EXCEPINFO __RPC_FAR *pexcepinfo,
    /* [out] */ UINT __RPC_FAR *puArgErr);


void __RPC_STUB ITypeInfo_Invoke_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ITypeInfo_GetDocumentation_Proxy( 
    ITypeInfo __RPC_FAR * This,
    /* [in] */ MEMBERID memid,
    /* [out] */ BSTR __RPC_FAR *pbstrName,
    /* [out] */ BSTR __RPC_FAR *pbstrDocString,
    /* [out] */ DWORD __RPC_FAR *pdwHelpContext,
    /* [out] */ BSTR __RPC_FAR *pbstrHelpFile);


void __RPC_STUB ITypeInfo_GetDocumentation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ITypeInfo_GetDllEntry_Proxy( 
    ITypeInfo __RPC_FAR * This,
    /* [in] */ MEMBERID memid,
    /* [in] */ INVOKEKIND invkind,
    /* [out] */ BSTR __RPC_FAR *pbstrDllName,
    /* [out] */ BSTR __RPC_FAR *pbstrName,
    /* [out] */ WORD __RPC_FAR *pwOrdinal);


void __RPC_STUB ITypeInfo_GetDllEntry_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ITypeInfo_GetRefTypeInfo_Proxy( 
    ITypeInfo __RPC_FAR * This,
    /* [in] */ HREFTYPE hreftype,
    /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *pptinfo);


void __RPC_STUB ITypeInfo_GetRefTypeInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ITypeInfo_AddressOfMember_Proxy( 
    ITypeInfo __RPC_FAR * This,
    /* [in] */ MEMBERID memid,
    /* [in] */ INVOKEKIND invkind,
    /* [out] */ void __RPC_FAR *__RPC_FAR *ppv);


void __RPC_STUB ITypeInfo_AddressOfMember_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ITypeInfo_CreateInstance_Proxy( 
    ITypeInfo __RPC_FAR * This,
    /* [in] */ IUnknown __RPC_FAR *puncOuter,
    /* [in] */ REFIID riid,
    /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObj);


void __RPC_STUB ITypeInfo_CreateInstance_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ITypeInfo_GetMops_Proxy( 
    ITypeInfo __RPC_FAR * This,
    /* [in] */ MEMBERID memid,
    /* [out] */ BSTR __RPC_FAR *pbstrMops);


void __RPC_STUB ITypeInfo_GetMops_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ITypeInfo_GetContainingTypeLib_Proxy( 
    ITypeInfo __RPC_FAR * This,
    /* [out] */ ITypeLib __RPC_FAR *__RPC_FAR *pptlib,
    /* [out] */ UINT __RPC_FAR *pindex);


void __RPC_STUB ITypeInfo_GetContainingTypeLib_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void __stdcall ITypeInfo_ReleaseTypeAttr_Proxy( 
    ITypeInfo __RPC_FAR * This,
    /* [in] */ TYPEATTR __RPC_FAR *ptypeattr);


void __RPC_STUB ITypeInfo_ReleaseTypeAttr_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void __stdcall ITypeInfo_ReleaseFuncDesc_Proxy( 
    ITypeInfo __RPC_FAR * This,
    /* [in] */ FUNCDESC __RPC_FAR *pfuncdesc);


void __RPC_STUB ITypeInfo_ReleaseFuncDesc_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void __stdcall ITypeInfo_ReleaseVarDesc_Proxy( 
    ITypeInfo __RPC_FAR * This,
    /* [in] */ VARDESC __RPC_FAR *pvardesc);


void __RPC_STUB ITypeInfo_ReleaseVarDesc_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITypeInfo_INTERFACE_DEFINED__ */


#ifndef __ITypeLib_INTERFACE_DEFINED__
#define __ITypeLib_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ITypeLib
 * at Fri Apr 28 07:02:38 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [local][unique][uuid][object] */ 


			/* size is 2 */
typedef /* [transmit] */ 
enum tagSYSKIND
    {	SYS_WIN16	= 0,
	SYS_WIN32	= SYS_WIN16 + 1,
	SYS_MAC	= SYS_WIN32 + 1
    }	SYSKIND;

			/* size is 2 */
typedef /* [transmit] */ 
enum tagLIBFLAGS
    {	LIBFLAG_FRESTRICTED	= 0x1,
	LIBFLAG_FCONTROL	= 0x2,
	LIBFLAG_FHIDDEN	= 0x4
    }	LIBFLAGS;

#define SYSKIND_to_xmit(pEnum, ppLong) *(ppLong) = (long *) (pEnum)
#define SYSKIND_from_xmit(pLong, pEnum) *(pEnum) = (SYSKIND) *(pLong)
#define SYSKIND_free_inst(pEnum) 
#define SYSKIND_free_xmit(pLong) 
			/* size is 4 */
typedef /* [unique] */ ITypeLib __RPC_FAR *LPTYPELIB;

			/* size is 28 */
typedef struct  tagTLIBATTR
    {
    GUID guid;
    LCID lcid;
    SYSKIND syskind;
    WORD wMajorVerNum;
    WORD wMinorVerNum;
    WORD wLibFlags;
    }	TLIBATTR;

			/* size is 4 */
typedef TLIBATTR __RPC_FAR *LPTLIBATTR;


EXTERN_C const IID IID_ITypeLib;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface ITypeLib : public IUnknown
    {
    public:
        virtual UINT __stdcall GetTypeInfoCount( void) = 0;
        
        virtual HRESULT __stdcall GetTypeInfo( 
            /* [in] */ UINT index,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppitinfo) = 0;
        
        virtual HRESULT __stdcall GetTypeInfoType( 
            /* [in] */ UINT index,
            /* [out] */ TYPEKIND __RPC_FAR *ptkind) = 0;
        
        virtual HRESULT __stdcall GetTypeInfoOfGuid( 
            /* [in] */ REFGUID guid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *pptinfo) = 0;
        
        virtual HRESULT __stdcall GetLibAttr( 
            /* [out] */ TLIBATTR __RPC_FAR *__RPC_FAR *pptlibattr) = 0;
        
        virtual HRESULT __stdcall GetTypeComp( 
            /* [out] */ ITypeComp __RPC_FAR *__RPC_FAR *pptcomp) = 0;
        
        virtual HRESULT __stdcall GetDocumentation( 
            /* [in] */ INT index,
            /* [out] */ BSTR __RPC_FAR *pbstrName,
            /* [out] */ BSTR __RPC_FAR *pbstrDocString,
            /* [out] */ DWORD __RPC_FAR *pdwHelpContext,
            /* [out] */ BSTR __RPC_FAR *pbstrHelpFile) = 0;
        
        virtual HRESULT __stdcall IsName( 
            /* [in] */ LPOLESTR szNameBuf,
            /* [in] */ ULONG lHashVal,
            /* [out] */ BOOL __RPC_FAR *pfName) = 0;
        
        virtual HRESULT __stdcall FindName( 
            /* [in] */ LPOLESTR szNameBuf,
            /* [in] */ ULONG lHashVal,
            /* [length_is][size_is][out] */ ITypeInfo __RPC_FAR *__RPC_FAR *rgptinfo,
            /* [length_is][size_is][out] */ MEMBERID __RPC_FAR *rgmemid,
            /* [out][in] */ USHORT __RPC_FAR *pcFound) = 0;
        
        virtual void __stdcall ReleaseTLibAttr( 
            /* [in] */ TLIBATTR __RPC_FAR *ptlibattr) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITypeLibVtbl
    {
        
        HRESULT ( __stdcall __RPC_FAR *QueryInterface )( 
            ITypeLib __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( __stdcall __RPC_FAR *AddRef )( 
            ITypeLib __RPC_FAR * This);
        
        ULONG ( __stdcall __RPC_FAR *Release )( 
            ITypeLib __RPC_FAR * This);
        
        UINT ( __stdcall __RPC_FAR *GetTypeInfoCount )( 
            ITypeLib __RPC_FAR * This);
        
        HRESULT ( __stdcall __RPC_FAR *GetTypeInfo )( 
            ITypeLib __RPC_FAR * This,
            /* [in] */ UINT index,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppitinfo);
        
        HRESULT ( __stdcall __RPC_FAR *GetTypeInfoType )( 
            ITypeLib __RPC_FAR * This,
            /* [in] */ UINT index,
            /* [out] */ TYPEKIND __RPC_FAR *ptkind);
        
        HRESULT ( __stdcall __RPC_FAR *GetTypeInfoOfGuid )( 
            ITypeLib __RPC_FAR * This,
            /* [in] */ REFGUID guid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *pptinfo);
        
        HRESULT ( __stdcall __RPC_FAR *GetLibAttr )( 
            ITypeLib __RPC_FAR * This,
            /* [out] */ TLIBATTR __RPC_FAR *__RPC_FAR *pptlibattr);
        
        HRESULT ( __stdcall __RPC_FAR *GetTypeComp )( 
            ITypeLib __RPC_FAR * This,
            /* [out] */ ITypeComp __RPC_FAR *__RPC_FAR *pptcomp);
        
        HRESULT ( __stdcall __RPC_FAR *GetDocumentation )( 
            ITypeLib __RPC_FAR * This,
            /* [in] */ INT index,
            /* [out] */ BSTR __RPC_FAR *pbstrName,
            /* [out] */ BSTR __RPC_FAR *pbstrDocString,
            /* [out] */ DWORD __RPC_FAR *pdwHelpContext,
            /* [out] */ BSTR __RPC_FAR *pbstrHelpFile);
        
        HRESULT ( __stdcall __RPC_FAR *IsName )( 
            ITypeLib __RPC_FAR * This,
            /* [in] */ LPOLESTR szNameBuf,
            /* [in] */ ULONG lHashVal,
            /* [out] */ BOOL __RPC_FAR *pfName);
        
        HRESULT ( __stdcall __RPC_FAR *FindName )( 
            ITypeLib __RPC_FAR * This,
            /* [in] */ LPOLESTR szNameBuf,
            /* [in] */ ULONG lHashVal,
            /* [length_is][size_is][out] */ ITypeInfo __RPC_FAR *__RPC_FAR *rgptinfo,
            /* [length_is][size_is][out] */ MEMBERID __RPC_FAR *rgmemid,
            /* [out][in] */ USHORT __RPC_FAR *pcFound);
        
        void ( __stdcall __RPC_FAR *ReleaseTLibAttr )( 
            ITypeLib __RPC_FAR * This,
            /* [in] */ TLIBATTR __RPC_FAR *ptlibattr);
        
    } ITypeLibVtbl;

    interface ITypeLib
    {
        CONST_VTBL struct ITypeLibVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITypeLib_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITypeLib_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITypeLib_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITypeLib_GetTypeInfoCount(This)	\
    (This)->lpVtbl -> GetTypeInfoCount(This)

#define ITypeLib_GetTypeInfo(This,index,ppitinfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,index,ppitinfo)

#define ITypeLib_GetTypeInfoType(This,index,ptkind)	\
    (This)->lpVtbl -> GetTypeInfoType(This,index,ptkind)

#define ITypeLib_GetTypeInfoOfGuid(This,guid,pptinfo)	\
    (This)->lpVtbl -> GetTypeInfoOfGuid(This,guid,pptinfo)

#define ITypeLib_GetLibAttr(This,pptlibattr)	\
    (This)->lpVtbl -> GetLibAttr(This,pptlibattr)

#define ITypeLib_GetTypeComp(This,pptcomp)	\
    (This)->lpVtbl -> GetTypeComp(This,pptcomp)

#define ITypeLib_GetDocumentation(This,index,pbstrName,pbstrDocString,pdwHelpContext,pbstrHelpFile)	\
    (This)->lpVtbl -> GetDocumentation(This,index,pbstrName,pbstrDocString,pdwHelpContext,pbstrHelpFile)

#define ITypeLib_IsName(This,szNameBuf,lHashVal,pfName)	\
    (This)->lpVtbl -> IsName(This,szNameBuf,lHashVal,pfName)

#define ITypeLib_FindName(This,szNameBuf,lHashVal,rgptinfo,rgmemid,pcFound)	\
    (This)->lpVtbl -> FindName(This,szNameBuf,lHashVal,rgptinfo,rgmemid,pcFound)

#define ITypeLib_ReleaseTLibAttr(This,ptlibattr)	\
    (This)->lpVtbl -> ReleaseTLibAttr(This,ptlibattr)

#endif /* COBJMACROS */


#endif 	/* C style interface */



UINT __stdcall ITypeLib_GetTypeInfoCount_Proxy( 
    ITypeLib __RPC_FAR * This);


void __RPC_STUB ITypeLib_GetTypeInfoCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ITypeLib_GetTypeInfo_Proxy( 
    ITypeLib __RPC_FAR * This,
    /* [in] */ UINT index,
    /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppitinfo);


void __RPC_STUB ITypeLib_GetTypeInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ITypeLib_GetTypeInfoType_Proxy( 
    ITypeLib __RPC_FAR * This,
    /* [in] */ UINT index,
    /* [out] */ TYPEKIND __RPC_FAR *ptkind);


void __RPC_STUB ITypeLib_GetTypeInfoType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ITypeLib_GetTypeInfoOfGuid_Proxy( 
    ITypeLib __RPC_FAR * This,
    /* [in] */ REFGUID guid,
    /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *pptinfo);


void __RPC_STUB ITypeLib_GetTypeInfoOfGuid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ITypeLib_GetLibAttr_Proxy( 
    ITypeLib __RPC_FAR * This,
    /* [out] */ TLIBATTR __RPC_FAR *__RPC_FAR *pptlibattr);


void __RPC_STUB ITypeLib_GetLibAttr_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ITypeLib_GetTypeComp_Proxy( 
    ITypeLib __RPC_FAR * This,
    /* [out] */ ITypeComp __RPC_FAR *__RPC_FAR *pptcomp);


void __RPC_STUB ITypeLib_GetTypeComp_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ITypeLib_GetDocumentation_Proxy( 
    ITypeLib __RPC_FAR * This,
    /* [in] */ INT index,
    /* [out] */ BSTR __RPC_FAR *pbstrName,
    /* [out] */ BSTR __RPC_FAR *pbstrDocString,
    /* [out] */ DWORD __RPC_FAR *pdwHelpContext,
    /* [out] */ BSTR __RPC_FAR *pbstrHelpFile);


void __RPC_STUB ITypeLib_GetDocumentation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ITypeLib_IsName_Proxy( 
    ITypeLib __RPC_FAR * This,
    /* [in] */ LPOLESTR szNameBuf,
    /* [in] */ ULONG lHashVal,
    /* [out] */ BOOL __RPC_FAR *pfName);


void __RPC_STUB ITypeLib_IsName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ITypeLib_FindName_Proxy( 
    ITypeLib __RPC_FAR * This,
    /* [in] */ LPOLESTR szNameBuf,
    /* [in] */ ULONG lHashVal,
    /* [length_is][size_is][out] */ ITypeInfo __RPC_FAR *__RPC_FAR *rgptinfo,
    /* [length_is][size_is][out] */ MEMBERID __RPC_FAR *rgmemid,
    /* [out][in] */ USHORT __RPC_FAR *pcFound);


void __RPC_STUB ITypeLib_FindName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void __stdcall ITypeLib_ReleaseTLibAttr_Proxy( 
    ITypeLib __RPC_FAR * This,
    /* [in] */ TLIBATTR __RPC_FAR *ptlibattr);


void __RPC_STUB ITypeLib_ReleaseTLibAttr_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITypeLib_INTERFACE_DEFINED__ */


#ifndef __IErrorInfo_INTERFACE_DEFINED__
#define __IErrorInfo_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IErrorInfo
 * at Fri Apr 28 07:02:38 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [local][unique][uuid][object] */ 


			/* size is 4 */
typedef /* [unique] */ IErrorInfo __RPC_FAR *LPERRORINFO;


EXTERN_C const IID IID_IErrorInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IErrorInfo : public IUnknown
    {
    public:
        virtual HRESULT __stdcall GetGUID( 
            /* [out] */ GUID __RPC_FAR *pguid) = 0;
        
        virtual HRESULT __stdcall GetSource( 
            /* [out] */ BSTR __RPC_FAR *pbstrSource) = 0;
        
        virtual HRESULT __stdcall GetDescription( 
            /* [out] */ BSTR __RPC_FAR *pbstrDescription) = 0;
        
        virtual HRESULT __stdcall GetHelpFile( 
            /* [out] */ BSTR __RPC_FAR *pbstrHelpFile) = 0;
        
        virtual HRESULT __stdcall GetHelpContext( 
            /* [out] */ DWORD __RPC_FAR *pdwHelpContext) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IErrorInfoVtbl
    {
        
        HRESULT ( __stdcall __RPC_FAR *QueryInterface )( 
            IErrorInfo __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( __stdcall __RPC_FAR *AddRef )( 
            IErrorInfo __RPC_FAR * This);
        
        ULONG ( __stdcall __RPC_FAR *Release )( 
            IErrorInfo __RPC_FAR * This);
        
        HRESULT ( __stdcall __RPC_FAR *GetGUID )( 
            IErrorInfo __RPC_FAR * This,
            /* [out] */ GUID __RPC_FAR *pguid);
        
        HRESULT ( __stdcall __RPC_FAR *GetSource )( 
            IErrorInfo __RPC_FAR * This,
            /* [out] */ BSTR __RPC_FAR *pbstrSource);
        
        HRESULT ( __stdcall __RPC_FAR *GetDescription )( 
            IErrorInfo __RPC_FAR * This,
            /* [out] */ BSTR __RPC_FAR *pbstrDescription);
        
        HRESULT ( __stdcall __RPC_FAR *GetHelpFile )( 
            IErrorInfo __RPC_FAR * This,
            /* [out] */ BSTR __RPC_FAR *pbstrHelpFile);
        
        HRESULT ( __stdcall __RPC_FAR *GetHelpContext )( 
            IErrorInfo __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwHelpContext);
        
    } IErrorInfoVtbl;

    interface IErrorInfo
    {
        CONST_VTBL struct IErrorInfoVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IErrorInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IErrorInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IErrorInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IErrorInfo_GetGUID(This,pguid)	\
    (This)->lpVtbl -> GetGUID(This,pguid)

#define IErrorInfo_GetSource(This,pbstrSource)	\
    (This)->lpVtbl -> GetSource(This,pbstrSource)

#define IErrorInfo_GetDescription(This,pbstrDescription)	\
    (This)->lpVtbl -> GetDescription(This,pbstrDescription)

#define IErrorInfo_GetHelpFile(This,pbstrHelpFile)	\
    (This)->lpVtbl -> GetHelpFile(This,pbstrHelpFile)

#define IErrorInfo_GetHelpContext(This,pdwHelpContext)	\
    (This)->lpVtbl -> GetHelpContext(This,pdwHelpContext)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT __stdcall IErrorInfo_GetGUID_Proxy( 
    IErrorInfo __RPC_FAR * This,
    /* [out] */ GUID __RPC_FAR *pguid);


void __RPC_STUB IErrorInfo_GetGUID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IErrorInfo_GetSource_Proxy( 
    IErrorInfo __RPC_FAR * This,
    /* [out] */ BSTR __RPC_FAR *pbstrSource);


void __RPC_STUB IErrorInfo_GetSource_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IErrorInfo_GetDescription_Proxy( 
    IErrorInfo __RPC_FAR * This,
    /* [out] */ BSTR __RPC_FAR *pbstrDescription);


void __RPC_STUB IErrorInfo_GetDescription_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IErrorInfo_GetHelpFile_Proxy( 
    IErrorInfo __RPC_FAR * This,
    /* [out] */ BSTR __RPC_FAR *pbstrHelpFile);


void __RPC_STUB IErrorInfo_GetHelpFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IErrorInfo_GetHelpContext_Proxy( 
    IErrorInfo __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwHelpContext);


void __RPC_STUB IErrorInfo_GetHelpContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IErrorInfo_INTERFACE_DEFINED__ */


#ifndef __ICreateErrorInfo_INTERFACE_DEFINED__
#define __ICreateErrorInfo_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ICreateErrorInfo
 * at Fri Apr 28 07:02:38 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [local][unique][uuid][object] */ 


			/* size is 4 */
typedef /* [unique] */ ICreateErrorInfo __RPC_FAR *LPCREATEERRORINFO;


EXTERN_C const IID IID_ICreateErrorInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface ICreateErrorInfo : public IUnknown
    {
    public:
        virtual HRESULT __stdcall SetGUID( 
            /* [in] */ REFGUID rguid) = 0;
        
        virtual HRESULT __stdcall SetSource( 
            /* [in] */ LPOLESTR szSource) = 0;
        
        virtual HRESULT __stdcall SetDescription( 
            /* [in] */ LPOLESTR szDescription) = 0;
        
        virtual HRESULT __stdcall SetHelpFile( 
            /* [in] */ LPOLESTR szHelpFile) = 0;
        
        virtual HRESULT __stdcall SetHelpContext( 
            /* [in] */ DWORD dwHelpContext) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICreateErrorInfoVtbl
    {
        
        HRESULT ( __stdcall __RPC_FAR *QueryInterface )( 
            ICreateErrorInfo __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( __stdcall __RPC_FAR *AddRef )( 
            ICreateErrorInfo __RPC_FAR * This);
        
        ULONG ( __stdcall __RPC_FAR *Release )( 
            ICreateErrorInfo __RPC_FAR * This);
        
        HRESULT ( __stdcall __RPC_FAR *SetGUID )( 
            ICreateErrorInfo __RPC_FAR * This,
            /* [in] */ REFGUID rguid);
        
        HRESULT ( __stdcall __RPC_FAR *SetSource )( 
            ICreateErrorInfo __RPC_FAR * This,
            /* [in] */ LPOLESTR szSource);
        
        HRESULT ( __stdcall __RPC_FAR *SetDescription )( 
            ICreateErrorInfo __RPC_FAR * This,
            /* [in] */ LPOLESTR szDescription);
        
        HRESULT ( __stdcall __RPC_FAR *SetHelpFile )( 
            ICreateErrorInfo __RPC_FAR * This,
            /* [in] */ LPOLESTR szHelpFile);
        
        HRESULT ( __stdcall __RPC_FAR *SetHelpContext )( 
            ICreateErrorInfo __RPC_FAR * This,
            /* [in] */ DWORD dwHelpContext);
        
    } ICreateErrorInfoVtbl;

    interface ICreateErrorInfo
    {
        CONST_VTBL struct ICreateErrorInfoVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICreateErrorInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICreateErrorInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICreateErrorInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICreateErrorInfo_SetGUID(This,rguid)	\
    (This)->lpVtbl -> SetGUID(This,rguid)

#define ICreateErrorInfo_SetSource(This,szSource)	\
    (This)->lpVtbl -> SetSource(This,szSource)

#define ICreateErrorInfo_SetDescription(This,szDescription)	\
    (This)->lpVtbl -> SetDescription(This,szDescription)

#define ICreateErrorInfo_SetHelpFile(This,szHelpFile)	\
    (This)->lpVtbl -> SetHelpFile(This,szHelpFile)

#define ICreateErrorInfo_SetHelpContext(This,dwHelpContext)	\
    (This)->lpVtbl -> SetHelpContext(This,dwHelpContext)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT __stdcall ICreateErrorInfo_SetGUID_Proxy( 
    ICreateErrorInfo __RPC_FAR * This,
    /* [in] */ REFGUID rguid);


void __RPC_STUB ICreateErrorInfo_SetGUID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ICreateErrorInfo_SetSource_Proxy( 
    ICreateErrorInfo __RPC_FAR * This,
    /* [in] */ LPOLESTR szSource);


void __RPC_STUB ICreateErrorInfo_SetSource_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ICreateErrorInfo_SetDescription_Proxy( 
    ICreateErrorInfo __RPC_FAR * This,
    /* [in] */ LPOLESTR szDescription);


void __RPC_STUB ICreateErrorInfo_SetDescription_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ICreateErrorInfo_SetHelpFile_Proxy( 
    ICreateErrorInfo __RPC_FAR * This,
    /* [in] */ LPOLESTR szHelpFile);


void __RPC_STUB ICreateErrorInfo_SetHelpFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ICreateErrorInfo_SetHelpContext_Proxy( 
    ICreateErrorInfo __RPC_FAR * This,
    /* [in] */ DWORD dwHelpContext);


void __RPC_STUB ICreateErrorInfo_SetHelpContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICreateErrorInfo_INTERFACE_DEFINED__ */


#ifndef __ISupportErrorInfo_INTERFACE_DEFINED__
#define __ISupportErrorInfo_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ISupportErrorInfo
 * at Fri Apr 28 07:02:38 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [local][unique][uuid][object] */ 


			/* size is 4 */
typedef /* [unique] */ ISupportErrorInfo __RPC_FAR *LPSUPPORTERRORINFO;


EXTERN_C const IID IID_ISupportErrorInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface ISupportErrorInfo : public IUnknown
    {
    public:
        virtual HRESULT __stdcall InterfaceSupportsErrorInfo( 
            /* [in] */ REFIID riid) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISupportErrorInfoVtbl
    {
        
        HRESULT ( __stdcall __RPC_FAR *QueryInterface )( 
            ISupportErrorInfo __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( __stdcall __RPC_FAR *AddRef )( 
            ISupportErrorInfo __RPC_FAR * This);
        
        ULONG ( __stdcall __RPC_FAR *Release )( 
            ISupportErrorInfo __RPC_FAR * This);
        
        HRESULT ( __stdcall __RPC_FAR *InterfaceSupportsErrorInfo )( 
            ISupportErrorInfo __RPC_FAR * This,
            /* [in] */ REFIID riid);
        
    } ISupportErrorInfoVtbl;

    interface ISupportErrorInfo
    {
        CONST_VTBL struct ISupportErrorInfoVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISupportErrorInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISupportErrorInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISupportErrorInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISupportErrorInfo_InterfaceSupportsErrorInfo(This,riid)	\
    (This)->lpVtbl -> InterfaceSupportsErrorInfo(This,riid)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT __stdcall ISupportErrorInfo_InterfaceSupportsErrorInfo_Proxy( 
    ISupportErrorInfo __RPC_FAR * This,
    /* [in] */ REFIID riid);


void __RPC_STUB ISupportErrorInfo_InterfaceSupportsErrorInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISupportErrorInfo_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\inc32\OBJIDL.H ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 2.00.0102 */
/* at Fri Apr 28 07:02:32 1995
 */
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"
#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __objidl_h__
#define __objidl_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IMarshal_FWD_DEFINED__
#define __IMarshal_FWD_DEFINED__
typedef interface IMarshal IMarshal;
#endif 	/* __IMarshal_FWD_DEFINED__ */


#ifndef __IMalloc_FWD_DEFINED__
#define __IMalloc_FWD_DEFINED__
typedef interface IMalloc IMalloc;
#endif 	/* __IMalloc_FWD_DEFINED__ */


#ifndef __IMallocSpy_FWD_DEFINED__
#define __IMallocSpy_FWD_DEFINED__
typedef interface IMallocSpy IMallocSpy;
#endif 	/* __IMallocSpy_FWD_DEFINED__ */


#ifndef __IStdMarshalInfo_FWD_DEFINED__
#define __IStdMarshalInfo_FWD_DEFINED__
typedef interface IStdMarshalInfo IStdMarshalInfo;
#endif 	/* __IStdMarshalInfo_FWD_DEFINED__ */


#ifndef __IExternalConnection_FWD_DEFINED__
#define __IExternalConnection_FWD_DEFINED__
typedef interface IExternalConnection IExternalConnection;
#endif 	/* __IExternalConnection_FWD_DEFINED__ */


#ifndef __IEnumUnknown_FWD_DEFINED__
#define __IEnumUnknown_FWD_DEFINED__
typedef interface IEnumUnknown IEnumUnknown;
#endif 	/* __IEnumUnknown_FWD_DEFINED__ */


#ifndef __IBindCtx_FWD_DEFINED__
#define __IBindCtx_FWD_DEFINED__
typedef interface IBindCtx IBindCtx;
#endif 	/* __IBindCtx_FWD_DEFINED__ */


#ifndef __IEnumMoniker_FWD_DEFINED__
#define __IEnumMoniker_FWD_DEFINED__
typedef interface IEnumMoniker IEnumMoniker;
#endif 	/* __IEnumMoniker_FWD_DEFINED__ */


#ifndef __IRunnableObject_FWD_DEFINED__
#define __IRunnableObject_FWD_DEFINED__
typedef interface IRunnableObject IRunnableObject;
#endif 	/* __IRunnableObject_FWD_DEFINED__ */


#ifndef __IRunningObjectTable_FWD_DEFINED__
#define __IRunningObjectTable_FWD_DEFINED__
typedef interface IRunningObjectTable IRunningObjectTable;
#endif 	/* __IRunningObjectTable_FWD_DEFINED__ */


#ifndef __IPersist_FWD_DEFINED__
#define __IPersist_FWD_DEFINED__
typedef interface IPersist IPersist;
#endif 	/* __IPersist_FWD_DEFINED__ */


#ifndef __IPersistStream_FWD_DEFINED__
#define __IPersistStream_FWD_DEFINED__
typedef interface IPersistStream IPersistStream;
#endif 	/* __IPersistStream_FWD_DEFINED__ */


#ifndef __IMoniker_FWD_DEFINED__
#define __IMoniker_FWD_DEFINED__
typedef interface IMoniker IMoniker;
#endif 	/* __IMoniker_FWD_DEFINED__ */


#ifndef __IROTData_FWD_DEFINED__
#define __IROTData_FWD_DEFINED__
typedef interface IROTData IROTData;
#endif 	/* __IROTData_FWD_DEFINED__ */


#ifndef __IEnumString_FWD_DEFINED__
#define __IEnumString_FWD_DEFINED__
typedef interface IEnumString IEnumString;
#endif 	/* __IEnumString_FWD_DEFINED__ */


#ifndef __IStream_FWD_DEFINED__
#define __IStream_FWD_DEFINED__
typedef interface IStream IStream;
#endif 	/* __IStream_FWD_DEFINED__ */


#ifndef __IEnumSTATSTG_FWD_DEFINED__
#define __IEnumSTATSTG_FWD_DEFINED__
typedef interface IEnumSTATSTG IEnumSTATSTG;
#endif 	/* __IEnumSTATSTG_FWD_DEFINED__ */


#ifndef __IStorage_FWD_DEFINED__
#define __IStorage_FWD_DEFINED__
typedef interface IStorage IStorage;
#endif 	/* __IStorage_FWD_DEFINED__ */


#ifndef __IPersistFile_FWD_DEFINED__
#define __IPersistFile_FWD_DEFINED__
typedef interface IPersistFile IPersistFile;
#endif 	/* __IPersistFile_FWD_DEFINED__ */


#ifndef __IPersistStorage_FWD_DEFINED__
#define __IPersistStorage_FWD_DEFINED__
typedef interface IPersistStorage IPersistStorage;
#endif 	/* __IPersistStorage_FWD_DEFINED__ */


#ifndef __ILockBytes_FWD_DEFINED__
#define __ILockBytes_FWD_DEFINED__
typedef interface ILockBytes ILockBytes;
#endif 	/* __ILockBytes_FWD_DEFINED__ */


#ifndef __IEnumFORMATETC_FWD_DEFINED__
#define __IEnumFORMATETC_FWD_DEFINED__
typedef interface IEnumFORMATETC IEnumFORMATETC;
#endif 	/* __IEnumFORMATETC_FWD_DEFINED__ */


#ifndef __IEnumSTATDATA_FWD_DEFINED__
#define __IEnumSTATDATA_FWD_DEFINED__
typedef interface IEnumSTATDATA IEnumSTATDATA;
#endif 	/* __IEnumSTATDATA_FWD_DEFINED__ */


#ifndef __IRootStorage_FWD_DEFINED__
#define __IRootStorage_FWD_DEFINED__
typedef interface IRootStorage IRootStorage;
#endif 	/* __IRootStorage_FWD_DEFINED__ */


#ifndef __IAdviseSink_FWD_DEFINED__
#define __IAdviseSink_FWD_DEFINED__
typedef interface IAdviseSink IAdviseSink;
#endif 	/* __IAdviseSink_FWD_DEFINED__ */


#ifndef __IAdviseSink2_FWD_DEFINED__
#define __IAdviseSink2_FWD_DEFINED__
typedef interface IAdviseSink2 IAdviseSink2;
#endif 	/* __IAdviseSink2_FWD_DEFINED__ */


#ifndef __IDataObject_FWD_DEFINED__
#define __IDataObject_FWD_DEFINED__
typedef interface IDataObject IDataObject;
#endif 	/* __IDataObject_FWD_DEFINED__ */


#ifndef __IDataAdviseHolder_FWD_DEFINED__
#define __IDataAdviseHolder_FWD_DEFINED__
typedef interface IDataAdviseHolder IDataAdviseHolder;
#endif 	/* __IDataAdviseHolder_FWD_DEFINED__ */


#ifndef __IMessageFilter_FWD_DEFINED__
#define __IMessageFilter_FWD_DEFINED__
typedef interface IMessageFilter IMessageFilter;
#endif 	/* __IMessageFilter_FWD_DEFINED__ */


#ifndef __IRpcChannelBuffer_FWD_DEFINED__
#define __IRpcChannelBuffer_FWD_DEFINED__
typedef interface IRpcChannelBuffer IRpcChannelBuffer;
#endif 	/* __IRpcChannelBuffer_FWD_DEFINED__ */


#ifndef __IRpcProxyBuffer_FWD_DEFINED__
#define __IRpcProxyBuffer_FWD_DEFINED__
typedef interface IRpcProxyBuffer IRpcProxyBuffer;
#endif 	/* __IRpcProxyBuffer_FWD_DEFINED__ */


#ifndef __IRpcStubBuffer_FWD_DEFINED__
#define __IRpcStubBuffer_FWD_DEFINED__
typedef interface IRpcStubBuffer IRpcStubBuffer;
#endif 	/* __IRpcStubBuffer_FWD_DEFINED__ */


#ifndef __IPSFactoryBuffer_FWD_DEFINED__
#define __IPSFactoryBuffer_FWD_DEFINED__
typedef interface IPSFactoryBuffer IPSFactoryBuffer;
#endif 	/* __IPSFactoryBuffer_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/****************************************
 * Generated header for interface: __MIDL__intf_0000
 * at Fri Apr 28 07:02:32 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [local] */ 


			/* size is 0 */

			/* size is 0 */

			/* size is 0 */

			/* size is 0 */

			/* size is 0 */

			/* size is 0 */

			/* size is 0 */

			/* size is 0 */

			/* size is 0 */

			/* size is 0 */



extern RPC_IF_HANDLE __MIDL__intf_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL__intf_0000_v0_0_s_ifspec;

#ifndef __IMarshal_INTERFACE_DEFINED__
#define __IMarshal_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IMarshal
 * at Fri Apr 28 07:02:32 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [uuid][object][local] */ 


//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//--------------------------------------------------------------------------
			/* size is 4 */
typedef /* [unique] */ IMarshal __RPC_FAR *LPMARSHAL;


EXTERN_C const IID IID_IMarshal;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IMarshal : public IUnknown
    {
    public:
        virtual HRESULT __stdcall GetUnmarshalClass( 
            /* [in] */ REFIID riid,
            /* [unique][in] */ void __RPC_FAR *pv,
            /* [in] */ DWORD dwDestContext,
            /* [unique][in] */ void __RPC_FAR *pvDestContext,
            /* [in] */ DWORD mshlflags,
            /* [out] */ CLSID __RPC_FAR *pCid) = 0;
        
        virtual HRESULT __stdcall GetMarshalSizeMax( 
            /* [in] */ REFIID riid,
            /* [unique][in] */ void __RPC_FAR *pv,
            /* [in] */ DWORD dwDestContext,
            /* [unique][in] */ void __RPC_FAR *pvDestContext,
            /* [in] */ DWORD mshlflags,
            /* [out] */ DWORD __RPC_FAR *pSize) = 0;
        
        virtual HRESULT __stdcall MarshalInterface( 
            /* [unique][in] */ IStream __RPC_FAR *pStm,
            /* [in] */ REFIID riid,
            /* [unique][in] */ void __RPC_FAR *pv,
            /* [in] */ DWORD dwDestContext,
            /* [unique][in] */ void __RPC_FAR *pvDestContext,
            /* [in] */ DWORD mshlflags) = 0;
        
        virtual HRESULT __stdcall UnmarshalInterface( 
            /* [unique][in] */ IStream __RPC_FAR *pStm,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppv) = 0;
        
        virtual HRESULT __stdcall ReleaseMarshalData( 
            /* [unique][in] */ IStream __RPC_FAR *pStm) = 0;
        
        virtual HRESULT __stdcall DisconnectObject( 
            /* [in] */ DWORD dwReserved) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMarshalVtbl
    {
        
        HRESULT ( __stdcall __RPC_FAR *QueryInterface )( 
            IMarshal __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( __stdcall __RPC_FAR *AddRef )( 
            IMarshal __RPC_FAR * This);
        
        ULONG ( __stdcall __RPC_FAR *Release )( 
            IMarshal __RPC_FAR * This);
        
        HRESULT ( __stdcall __RPC_FAR *GetUnmarshalClass )( 
            IMarshal __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [unique][in] */ void __RPC_FAR *pv,
            /* [in] */ DWORD dwDestContext,
            /* [unique][in] */ void __RPC_FAR *pvDestContext,
            /* [in] */ DWORD mshlflags,
            /* [out] */ CLSID __RPC_FAR *pCid);
        
        HRESULT ( __stdcall __RPC_FAR *GetMarshalSizeMax )( 
            IMarshal __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [unique][in] */ void __RPC_FAR *pv,
            /* [in] */ DWORD dwDestContext,
            /* [unique][in] */ void __RPC_FAR *pvDestContext,
            /* [in] */ DWORD mshlflags,
            /* [out] */ DWORD __RPC_FAR *pSize);
        
        HRESULT ( __stdcall __RPC_FAR *MarshalInterface )( 
            IMarshal __RPC_FAR * This,
            /* [unique][in] */ IStream __RPC_FAR *pStm,
            /* [in] */ REFIID riid,
            /* [unique][in] */ void __RPC_FAR *pv,
            /* [in] */ DWORD dwDestContext,
            /* [unique][in] */ void __RPC_FAR *pvDestContext,
            /* [in] */ DWORD mshlflags);
        
        HRESULT ( __stdcall __RPC_FAR *UnmarshalInterface )( 
            IMarshal __RPC_FAR * This,
            /* [unique][in] */ IStream __RPC_FAR *pStm,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppv);
        
        HRESULT ( __stdcall __RPC_FAR *ReleaseMarshalData )( 
            IMarshal __RPC_FAR * This,
            /* [unique][in] */ IStream __RPC_FAR *pStm);
        
        HRESULT ( __stdcall __RPC_FAR *DisconnectObject )( 
            IMarshal __RPC_FAR * This,
            /* [in] */ DWORD dwReserved);
        
    } IMarshalVtbl;

    interface IMarshal
    {
        CONST_VTBL struct IMarshalVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMarshal_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMarshal_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMarshal_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMarshal_GetUnmarshalClass(This,riid,pv,dwDestContext,pvDestContext,mshlflags,pCid)	\
    (This)->lpVtbl -> GetUnmarshalClass(This,riid,pv,dwDestContext,pvDestContext,mshlflags,pCid)

#define IMarshal_GetMarshalSizeMax(This,riid,pv,dwDestContext,pvDestContext,mshlflags,pSize)	\
    (This)->lpVtbl -> GetMarshalSizeMax(This,riid,pv,dwDestContext,pvDestContext,mshlflags,pSize)

#define IMarshal_MarshalInterface(This,pStm,riid,pv,dwDestContext,pvDestContext,mshlflags)	\
    (This)->lpVtbl -> MarshalInterface(This,pStm,riid,pv,dwDestContext,pvDestContext,mshlflags)

#define IMarshal_UnmarshalInterface(This,pStm,riid,ppv)	\
    (This)->lpVtbl -> UnmarshalInterface(This,pStm,riid,ppv)

#define IMarshal_ReleaseMarshalData(This,pStm)	\
    (This)->lpVtbl -> ReleaseMarshalData(This,pStm)

#define IMarshal_DisconnectObject(This,dwReserved)	\
    (This)->lpVtbl -> DisconnectObject(This,dwReserved)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT __stdcall IMarshal_GetUnmarshalClass_Proxy( 
    IMarshal __RPC_FAR * This,
    /* [in] */ REFIID riid,
    /* [unique][in] */ void __RPC_FAR *pv,
    /* [in] */ DWORD dwDestContext,
    /* [unique][in] */ void __RPC_FAR *pvDestContext,
    /* [in] */ DWORD mshlflags,
    /* [out] */ CLSID __RPC_FAR *pCid);


void __RPC_STUB IMarshal_GetUnmarshalClass_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IMarshal_GetMarshalSizeMax_Proxy( 
    IMarshal __RPC_FAR * This,
    /* [in] */ REFIID riid,
    /* [unique][in] */ void __RPC_FAR *pv,
    /* [in] */ DWORD dwDestContext,
    /* [unique][in] */ void __RPC_FAR *pvDestContext,
    /* [in] */ DWORD mshlflags,
    /* [out] */ DWORD __RPC_FAR *pSize);


void __RPC_STUB IMarshal_GetMarshalSizeMax_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IMarshal_MarshalInterface_Proxy( 
    IMarshal __RPC_FAR * This,
    /* [unique][in] */ IStream __RPC_FAR *pStm,
    /* [in] */ REFIID riid,
    /* [unique][in] */ void __RPC_FAR *pv,
    /* [in] */ DWORD dwDestContext,
    /* [unique][in] */ void __RPC_FAR *pvDestContext,
    /* [in] */ DWORD mshlflags);


void __RPC_STUB IMarshal_MarshalInterface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IMarshal_UnmarshalInterface_Proxy( 
    IMarshal __RPC_FAR * This,
    /* [unique][in] */ IStream __RPC_FAR *pStm,
    /* [in] */ REFIID riid,
    /* [out] */ void __RPC_FAR *__RPC_FAR *ppv);


void __RPC_STUB IMarshal_UnmarshalInterface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IMarshal_ReleaseMarshalData_Proxy( 
    IMarshal __RPC_FAR * This,
    /* [unique][in] */ IStream __RPC_FAR *pStm);


void __RPC_STUB IMarshal_ReleaseMarshalData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IMarshal_DisconnectObject_Proxy( 
    IMarshal __RPC_FAR * This,
    /* [in] */ DWORD dwReserved);


void __RPC_STUB IMarshal_DisconnectObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMarshal_INTERFACE_DEFINED__ */


#ifndef __IMalloc_INTERFACE_DEFINED__
#define __IMalloc_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IMalloc
 * at Fri Apr 28 07:02:32 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [uuid][object][local] */ 


			/* size is 4 */
typedef /* [unique] */ IMalloc __RPC_FAR *LPMALLOC;


EXTERN_C const IID IID_IMalloc;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IMalloc : public IUnknown
    {
    public:
        virtual void __RPC_FAR *__stdcall Alloc( 
            /* [in] */ ULONG cb) = 0;
        
        virtual void __RPC_FAR *__stdcall Realloc( 
            /* [in] */ void __RPC_FAR *pv,
            /* [in] */ ULONG cb) = 0;
        
        virtual void __stdcall Free( 
            /* [in] */ void __RPC_FAR *pv) = 0;
        
        virtual ULONG __stdcall GetSize( 
            /* [in] */ void __RPC_FAR *pv) = 0;
        
        virtual int __stdcall DidAlloc( 
            void __RPC_FAR *pv) = 0;
        
        virtual void __stdcall HeapMinimize( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMallocVtbl
    {
        
        HRESULT ( __stdcall __RPC_FAR *QueryInterface )( 
            IMalloc __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( __stdcall __RPC_FAR *AddRef )( 
            IMalloc __RPC_FAR * This);
        
        ULONG ( __stdcall __RPC_FAR *Release )( 
            IMalloc __RPC_FAR * This);
        
        void __RPC_FAR *( __stdcall __RPC_FAR *Alloc )( 
            IMalloc __RPC_FAR * This,
            /* [in] */ ULONG cb);
        
        void __RPC_FAR *( __stdcall __RPC_FAR *Realloc )( 
            IMalloc __RPC_FAR * This,
            /* [in] */ void __RPC_FAR *pv,
            /* [in] */ ULONG cb);
        
        void ( __stdcall __RPC_FAR *Free )( 
            IMalloc __RPC_FAR * This,
            /* [in] */ void __RPC_FAR *pv);
        
        ULONG ( __stdcall __RPC_FAR *GetSize )( 
            IMalloc __RPC_FAR * This,
            /* [in] */ void __RPC_FAR *pv);
        
        int ( __stdcall __RPC_FAR *DidAlloc )( 
            IMalloc __RPC_FAR * This,
            void __RPC_FAR *pv);
        
        void ( __stdcall __RPC_FAR *HeapMinimize )( 
            IMalloc __RPC_FAR * This);
        
    } IMallocVtbl;

    interface IMalloc
    {
        CONST_VTBL struct IMallocVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMalloc_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMalloc_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMalloc_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMalloc_Alloc(This,cb)	\
    (This)->lpVtbl -> Alloc(This,cb)

#define IMalloc_Realloc(This,pv,cb)	\
    (This)->lpVtbl -> Realloc(This,pv,cb)

#define IMalloc_Free(This,pv)	\
    (This)->lpVtbl -> Free(This,pv)

#define IMalloc_GetSize(This,pv)	\
    (This)->lpVtbl -> GetSize(This,pv)

#define IMalloc_DidAlloc(This,pv)	\
    (This)->lpVtbl -> DidAlloc(This,pv)

#define IMalloc_HeapMinimize(This)	\
    (This)->lpVtbl -> HeapMinimize(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



void __RPC_FAR *__stdcall IMalloc_Alloc_Proxy( 
    IMalloc __RPC_FAR * This,
    /* [in] */ ULONG cb);


void __RPC_STUB IMalloc_Alloc_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void __RPC_FAR *__stdcall IMalloc_Realloc_Proxy( 
    IMalloc __RPC_FAR * This,
    /* [in] */ void __RPC_FAR *pv,
    /* [in] */ ULONG cb);


void __RPC_STUB IMalloc_Realloc_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void __stdcall IMalloc_Free_Proxy( 
    IMalloc __RPC_FAR * This,
    /* [in] */ void __RPC_FAR *pv);


void __RPC_STUB IMalloc_Free_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


ULONG __stdcall IMalloc_GetSize_Proxy( 
    IMalloc __RPC_FAR * This,
    /* [in] */ void __RPC_FAR *pv);


void __RPC_STUB IMalloc_GetSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


int __stdcall IMalloc_DidAlloc_Proxy( 
    IMalloc __RPC_FAR * This,
    void __RPC_FAR *pv);


void __RPC_STUB IMalloc_DidAlloc_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void __stdcall IMalloc_HeapMinimize_Proxy( 
    IMalloc __RPC_FAR * This);


void __RPC_STUB IMalloc_HeapMinimize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMalloc_INTERFACE_DEFINED__ */


#ifndef __IMallocSpy_INTERFACE_DEFINED__
#define __IMallocSpy_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IMallocSpy
 * at Fri Apr 28 07:02:32 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [uuid][object][local] */ 


			/* size is 4 */
typedef /* [unique] */ IMallocSpy __RPC_FAR *LPMALLOCSPY;


EXTERN_C const IID IID_IMallocSpy;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IMallocSpy : public IUnknown
    {
    public:
        virtual ULONG __stdcall PreAlloc( 
            /* [in] */ ULONG cbRequest) = 0;
        
        virtual void __RPC_FAR *__stdcall PostAlloc( 
            /* [in] */ void __RPC_FAR *pActual) = 0;
        
        virtual void __RPC_FAR *__stdcall PreFree( 
            /* [in] */ void __RPC_FAR *pRequest,
            /* [in] */ BOOL fSpyed) = 0;
        
        virtual void __stdcall PostFree( 
            /* [in] */ BOOL fSpyed) = 0;
        
        virtual ULONG __stdcall PreRealloc( 
            /* [in] */ void __RPC_FAR *pRequest,
            /* [in] */ ULONG cbRequest,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppNewRequest,
            /* [in] */ BOOL fSpyed) = 0;
        
        virtual void __RPC_FAR *__stdcall PostRealloc( 
            /* [in] */ void __RPC_FAR *pActual,
            /* [in] */ BOOL fSpyed) = 0;
        
        virtual void __RPC_FAR *__stdcall PreGetSize( 
            /* [in] */ void __RPC_FAR *pRequest,
            /* [in] */ BOOL fSpyed) = 0;
        
        virtual ULONG __stdcall PostGetSize( 
            /* [in] */ ULONG cbActual,
            /* [in] */ BOOL fSpyed) = 0;
        
        virtual void __RPC_FAR *__stdcall PreDidAlloc( 
            /* [in] */ void __RPC_FAR *pRequest,
            /* [in] */ BOOL fSpyed) = 0;
        
        virtual int __stdcall PostDidAlloc( 
            /* [in] */ void __RPC_FAR *pRequest,
            /* [in] */ BOOL fSpyed,
            /* [in] */ int fActual) = 0;
        
        virtual void __stdcall PreHeapMinimize( void) = 0;
        
        virtual void __stdcall PostHeapMinimize( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMallocSpyVtbl
    {
        
        HRESULT ( __stdcall __RPC_FAR *QueryInterface )( 
            IMallocSpy __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( __stdcall __RPC_FAR *AddRef )( 
            IMallocSpy __RPC_FAR * This);
        
        ULONG ( __stdcall __RPC_FAR *Release )( 
            IMallocSpy __RPC_FAR * This);
        
        ULONG ( __stdcall __RPC_FAR *PreAlloc )( 
            IMallocSpy __RPC_FAR * This,
            /* [in] */ ULONG cbRequest);
        
        void __RPC_FAR *( __stdcall __RPC_FAR *PostAlloc )( 
            IMallocSpy __RPC_FAR * This,
            /* [in] */ void __RPC_FAR *pActual);
        
        void __RPC_FAR *( __stdcall __RPC_FAR *PreFree )( 
            IMallocSpy __RPC_FAR * This,
            /* [in] */ void __RPC_FAR *pRequest,
            /* [in] */ BOOL fSpyed);
        
        void ( __stdcall __RPC_FAR *PostFree )( 
            IMallocSpy __RPC_FAR * This,
            /* [in] */ BOOL fSpyed);
        
        ULONG ( __stdcall __RPC_FAR *PreRealloc )( 
            IMallocSpy __RPC_FAR * This,
            /* [in] */ void __RPC_FAR *pRequest,
            /* [in] */ ULONG cbRequest,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppNewRequest,
            /* [in] */ BOOL fSpyed);
        
        void __RPC_FAR *( __stdcall __RPC_FAR *PostRealloc )( 
            IMallocSpy __RPC_FAR * This,
            /* [in] */ void __RPC_FAR *pActual,
            /* [in] */ BOOL fSpyed);
        
        void __RPC_FAR *( __stdcall __RPC_FAR *PreGetSize )( 
            IMallocSpy __RPC_FAR * This,
            /* [in] */ void __RPC_FAR *pRequest,
            /* [in] */ BOOL fSpyed);
        
        ULONG ( __stdcall __RPC_FAR *PostGetSize )( 
            IMallocSpy __RPC_FAR * This,
            /* [in] */ ULONG cbActual,
            /* [in] */ BOOL fSpyed);
        
        void __RPC_FAR *( __stdcall __RPC_FAR *PreDidAlloc )( 
            IMallocSpy __RPC_FAR * This,
            /* [in] */ void __RPC_FAR *pRequest,
            /* [in] */ BOOL fSpyed);
        
        int ( __stdcall __RPC_FAR *PostDidAlloc )( 
            IMallocSpy __RPC_FAR * This,
            /* [in] */ void __RPC_FAR *pRequest,
            /* [in] */ BOOL fSpyed,
            /* [in] */ int fActual);
        
        void ( __stdcall __RPC_FAR *PreHeapMinimize )( 
            IMallocSpy __RPC_FAR * This);
        
        void ( __stdcall __RPC_FAR *PostHeapMinimize )( 
            IMallocSpy __RPC_FAR * This);
        
    } IMallocSpyVtbl;

    interface IMallocSpy
    {
        CONST_VTBL struct IMallocSpyVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMallocSpy_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMallocSpy_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMallocSpy_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMallocSpy_PreAlloc(This,cbRequest)	\
    (This)->lpVtbl -> PreAlloc(This,cbRequest)

#define IMallocSpy_PostAlloc(This,pActual)	\
    (This)->lpVtbl -> PostAlloc(This,pActual)

#define IMallocSpy_PreFree(This,pRequest,fSpyed)	\
    (This)->lpVtbl -> PreFree(This,pRequest,fSpyed)

#define IMallocSpy_PostFree(This,fSpyed)	\
    (This)->lpVtbl -> PostFree(This,fSpyed)

#define IMallocSpy_PreRealloc(This,pRequest,cbRequest,ppNewRequest,fSpyed)	\
    (This)->lpVtbl -> PreRealloc(This,pRequest,cbRequest,ppNewRequest,fSpyed)

#define IMallocSpy_PostRealloc(This,pActual,fSpyed)	\
    (This)->lpVtbl -> PostRealloc(This,pActual,fSpyed)

#define IMallocSpy_PreGetSize(This,pRequest,fSpyed)	\
    (This)->lpVtbl -> PreGetSize(This,pRequest,fSpyed)

#define IMallocSpy_PostGetSize(This,cbActual,fSpyed)	\
    (This)->lpVtbl -> PostGetSize(This,cbActual,fSpyed)

#define IMallocSpy_PreDidAlloc(This,pRequest,fSpyed)	\
    (This)->lpVtbl -> PreDidAlloc(This,pRequest,fSpyed)

#define IMallocSpy_PostDidAlloc(This,pRequest,fSpyed,fActual)	\
    (This)->lpVtbl -> PostDidAlloc(This,pRequest,fSpyed,fActual)

#define IMallocSpy_PreHeapMinimize(This)	\
    (This)->lpVtbl -> PreHeapMinimize(This)

#define IMallocSpy_PostHeapMinimize(This)	\
    (This)->lpVtbl -> PostHeapMinimize(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



ULONG __stdcall IMallocSpy_PreAlloc_Proxy( 
    IMallocSpy __RPC_FAR * This,
    /* [in] */ ULONG cbRequest);


void __RPC_STUB IMallocSpy_PreAlloc_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void __RPC_FAR *__stdcall IMallocSpy_PostAlloc_Proxy( 
    IMallocSpy __RPC_FAR * This,
    /* [in] */ void __RPC_FAR *pActual);


void __RPC_STUB IMallocSpy_PostAlloc_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void __RPC_FAR *__stdcall IMallocSpy_PreFree_Proxy( 
    IMallocSpy __RPC_FAR * This,
    /* [in] */ void __RPC_FAR *pRequest,
    /* [in] */ BOOL fSpyed);


void __RPC_STUB IMallocSpy_PreFree_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void __stdcall IMallocSpy_PostFree_Proxy( 
    IMallocSpy __RPC_FAR * This,
    /* [in] */ BOOL fSpyed);


void __RPC_STUB IMallocSpy_PostFree_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


ULONG __stdcall IMallocSpy_PreRealloc_Proxy( 
    IMallocSpy __RPC_FAR * This,
    /* [in] */ void __RPC_FAR *pRequest,
    /* [in] */ ULONG cbRequest,
    /* [out] */ void __RPC_FAR *__RPC_FAR *ppNewRequest,
    /* [in] */ BOOL fSpyed);


void __RPC_STUB IMallocSpy_PreRealloc_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void __RPC_FAR *__stdcall IMallocSpy_PostRealloc_Proxy( 
    IMallocSpy __RPC_FAR * This,
    /* [in] */ void __RPC_FAR *pActual,
    /* [in] */ BOOL fSpyed);


void __RPC_STUB IMallocSpy_PostRealloc_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void __RPC_FAR *__stdcall IMallocSpy_PreGetSize_Proxy( 
    IMallocSpy __RPC_FAR * This,
    /* [in] */ void __RPC_FAR *pRequest,
    /* [in] */ BOOL fSpyed);


void __RPC_STUB IMallocSpy_PreGetSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


ULONG __stdcall IMallocSpy_PostGetSize_Proxy( 
    IMallocSpy __RPC_FAR * This,
    /* [in] */ ULONG cbActual,
    /* [in] */ BOOL fSpyed);


void __RPC_STUB IMallocSpy_PostGetSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void __RPC_FAR *__stdcall IMallocSpy_PreDidAlloc_Proxy( 
    IMallocSpy __RPC_FAR * This,
    /* [in] */ void __RPC_FAR *pRequest,
    /* [in] */ BOOL fSpyed);


void __RPC_STUB IMallocSpy_PreDidAlloc_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


int __stdcall IMallocSpy_PostDidAlloc_Proxy( 
    IMallocSpy __RPC_FAR * This,
    /* [in] */ void __RPC_FAR *pRequest,
    /* [in] */ BOOL fSpyed,
    /* [in] */ int fActual);


void __RPC_STUB IMallocSpy_PostDidAlloc_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void __stdcall IMallocSpy_PreHeapMinimize_Proxy( 
    IMallocSpy __RPC_FAR * This);


void __RPC_STUB IMallocSpy_PreHeapMinimize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void __stdcall IMallocSpy_PostHeapMinimize_Proxy( 
    IMallocSpy __RPC_FAR * This);


void __RPC_STUB IMallocSpy_PostHeapMinimize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMallocSpy_INTERFACE_DEFINED__ */


#ifndef __IStdMarshalInfo_INTERFACE_DEFINED__
#define __IStdMarshalInfo_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IStdMarshalInfo
 * at Fri Apr 28 07:02:32 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [uuid][object][local] */ 


			/* size is 4 */
typedef /* [unique] */ IStdMarshalInfo __RPC_FAR *LPSTDMARSHALINFO;


EXTERN_C const IID IID_IStdMarshalInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IStdMarshalInfo : public IUnknown
    {
    public:
        virtual HRESULT __stdcall GetClassForHandler( 
            /* [in] */ DWORD dwDestContext,
            /* [unique][in] */ void __RPC_FAR *pvDestContext,
            /* [out] */ CLSID __RPC_FAR *pClsid) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IStdMarshalInfoVtbl
    {
        
        HRESULT ( __stdcall __RPC_FAR *QueryInterface )( 
            IStdMarshalInfo __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( __stdcall __RPC_FAR *AddRef )( 
            IStdMarshalInfo __RPC_FAR * This);
        
        ULONG ( __stdcall __RPC_FAR *Release )( 
            IStdMarshalInfo __RPC_FAR * This);
        
        HRESULT ( __stdcall __RPC_FAR *GetClassForHandler )( 
            IStdMarshalInfo __RPC_FAR * This,
            /* [in] */ DWORD dwDestContext,
            /* [unique][in] */ void __RPC_FAR *pvDestContext,
            /* [out] */ CLSID __RPC_FAR *pClsid);
        
    } IStdMarshalInfoVtbl;

    interface IStdMarshalInfo
    {
        CONST_VTBL struct IStdMarshalInfoVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IStdMarshalInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IStdMarshalInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IStdMarshalInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IStdMarshalInfo_GetClassForHandler(This,dwDestContext,pvDestContext,pClsid)	\
    (This)->lpVtbl -> GetClassForHandler(This,dwDestContext,pvDestContext,pClsid)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT __stdcall IStdMarshalInfo_GetClassForHandler_Proxy( 
    IStdMarshalInfo __RPC_FAR * This,
    /* [in] */ DWORD dwDestContext,
    /* [unique][in] */ void __RPC_FAR *pvDestContext,
    /* [out] */ CLSID __RPC_FAR *pClsid);


void __RPC_STUB IStdMarshalInfo_GetClassForHandler_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IStdMarshalInfo_INTERFACE_DEFINED__ */


#ifndef __IExternalConnection_INTERFACE_DEFINED__
#define __IExternalConnection_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IExternalConnection
 * at Fri Apr 28 07:02:32 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [uuid][local][object] */ 


			/* size is 4 */
typedef /* [unique] */ IExternalConnection __RPC_FAR *LPEXTERNALCONNECTION;

			/* size is 2 */
typedef 
enum tagEXTCONN
    {	EXTCONN_STRONG	= 0x1,
	EXTCONN_WEAK	= 0x2,
	EXTCONN_CALLABLE	= 0x4
    }	EXTCONN;


EXTERN_C const IID IID_IExternalConnection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IExternalConnection : public IUnknown
    {
    public:
        virtual DWORD __stdcall AddConnection( 
            /* [in] */ DWORD extconn,
            /* [in] */ DWORD reserved) = 0;
        
        virtual DWORD __stdcall ReleaseConnection( 
            /* [in] */ DWORD extconn,
            /* [in] */ DWORD reserved,
            /* [in] */ BOOL fLastReleaseCloses) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IExternalConnectionVtbl
    {
        
        HRESULT ( __stdcall __RPC_FAR *QueryInterface )( 
            IExternalConnection __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( __stdcall __RPC_FAR *AddRef )( 
            IExternalConnection __RPC_FAR * This);
        
        ULONG ( __stdcall __RPC_FAR *Release )( 
            IExternalConnection __RPC_FAR * This);
        
        DWORD ( __stdcall __RPC_FAR *AddConnection )( 
            IExternalConnection __RPC_FAR * This,
            /* [in] */ DWORD extconn,
            /* [in] */ DWORD reserved);
        
        DWORD ( __stdcall __RPC_FAR *ReleaseConnection )( 
            IExternalConnection __RPC_FAR * This,
            /* [in] */ DWORD extconn,
            /* [in] */ DWORD reserved,
            /* [in] */ BOOL fLastReleaseCloses);
        
    } IExternalConnectionVtbl;

    interface IExternalConnection
    {
        CONST_VTBL struct IExternalConnectionVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IExternalConnection_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IExternalConnection_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IExternalConnection_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IExternalConnection_AddConnection(This,extconn,reserved)	\
    (This)->lpVtbl -> AddConnection(This,extconn,reserved)

#define IExternalConnection_ReleaseConnection(This,extconn,reserved,fLastReleaseCloses)	\
    (This)->lpVtbl -> ReleaseConnection(This,extconn,reserved,fLastReleaseCloses)

#endif /* COBJMACROS */


#endif 	/* C style interface */



DWORD __stdcall IExternalConnection_AddConnection_Proxy( 
    IExternalConnection __RPC_FAR * This,
    /* [in] */ DWORD extconn,
    /* [in] */ DWORD reserved);


void __RPC_STUB IExternalConnection_AddConnection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


DWORD __stdcall IExternalConnection_ReleaseConnection_Proxy( 
    IExternalConnection __RPC_FAR * This,
    /* [in] */ DWORD extconn,
    /* [in] */ DWORD reserved,
    /* [in] */ BOOL fLastReleaseCloses);


void __RPC_STUB IExternalConnection_ReleaseConnection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IExternalConnection_INTERFACE_DEFINED__ */


#ifndef __IEnumUnknown_INTERFACE_DEFINED__
#define __IEnumUnknown_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IEnumUnknown
 * at Fri Apr 28 07:02:32 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [unique][uuid][object] */ 


			/* size is 4 */
typedef /* [unique] */ IEnumUnknown __RPC_FAR *LPENUMUNKNOWN;


EXTERN_C const IID IID_IEnumUnknown;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IEnumUnknown : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT __stdcall Next( 
            /* [in] */ ULONG celt,
            /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *rgelt,
            /* [out] */ ULONG __RPC_FAR *pceltFetched) = 0;
        
        virtual HRESULT __stdcall Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT __stdcall Reset( void) = 0;
        
        virtual HRESULT __stdcall Clone( 
            /* [out] */ IEnumUnknown __RPC_FAR *__RPC_FAR *ppenum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumUnknownVtbl
    {
        
        HRESULT ( __stdcall __RPC_FAR *QueryInterface )( 
            IEnumUnknown __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( __stdcall __RPC_FAR *AddRef )( 
            IEnumUnknown __RPC_FAR * This);
        
        ULONG ( __stdcall __RPC_FAR *Release )( 
            IEnumUnknown __RPC_FAR * This);
        
        /* [local] */ HRESULT ( __stdcall __RPC_FAR *Next )( 
            IEnumUnknown __RPC_FAR * This,
            /* [in] */ ULONG celt,
            /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *rgelt,
            /* [out] */ ULONG __RPC_FAR *pceltFetched);
        
        HRESULT ( __stdcall __RPC_FAR *Skip )( 
            IEnumUnknown __RPC_FAR * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( __stdcall __RPC_FAR *Reset )( 
            IEnumUnknown __RPC_FAR * This);
        
        HRESULT ( __stdcall __RPC_FAR *Clone )( 
            IEnumUnknown __RPC_FAR * This,
            /* [out] */ IEnumUnknown __RPC_FAR *__RPC_FAR *ppenum);
        
    } IEnumUnknownVtbl;

    interface IEnumUnknown
    {
        CONST_VTBL struct IEnumUnknownVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumUnknown_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumUnknown_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumUnknown_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumUnknown_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IEnumUnknown_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumUnknown_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumUnknown_Clone(This,ppenum)	\
    (This)->lpVtbl -> Clone(This,ppenum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT __stdcall IEnumUnknown_RemoteNext_Proxy( 
    IEnumUnknown __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ IUnknown __RPC_FAR *__RPC_FAR *rgelt,
    /* [out] */ ULONG __RPC_FAR *pceltFetched);


void __RPC_STUB IEnumUnknown_RemoteNext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IEnumUnknown_Skip_Proxy( 
    IEnumUnknown __RPC_FAR * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IEnumUnknown_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IEnumUnknown_Reset_Proxy( 
    IEnumUnknown __RPC_FAR * This);


void __RPC_STUB IEnumUnknown_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IEnumUnknown_Clone_Proxy( 
    IEnumUnknown __RPC_FAR * This,
    /* [out] */ IEnumUnknown __RPC_FAR *__RPC_FAR *ppenum);


void __RPC_STUB IEnumUnknown_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumUnknown_INTERFACE_DEFINED__ */


#ifndef __IBindCtx_INTERFACE_DEFINED__
#define __IBindCtx_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IBindCtx
 * at Fri Apr 28 07:02:32 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [unique][uuid][object] */ 


			/* size is 4 */
typedef /* [unique] */ IBindCtx __RPC_FAR *LPBC;

			/* size is 4 */
typedef /* [unique] */ IBindCtx __RPC_FAR *LPBINDCTX;

			/* size is 16 */
typedef struct  tagBIND_OPTS
    {
    DWORD cbStruct;
    DWORD grfFlags;
    DWORD grfMode;
    DWORD dwTickCountDeadline;
    }	BIND_OPTS;

			/* size is 4 */
typedef struct tagBIND_OPTS __RPC_FAR *LPBIND_OPTS;

			/* size is 2 */
typedef 
enum tagBIND_FLAGS
    {	BIND_MAYBOTHERUSER	= 1,
	BIND_JUSTTESTEXISTENCE	= 2
    }	BIND_FLAGS;


EXTERN_C const IID IID_IBindCtx;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IBindCtx : public IUnknown
    {
    public:
        virtual HRESULT __stdcall RegisterObjectBound( 
            /* [unique][in] */ IUnknown __RPC_FAR *punk) = 0;
        
        virtual HRESULT __stdcall RevokeObjectBound( 
            /* [unique][in] */ IUnknown __RPC_FAR *punk) = 0;
        
        virtual HRESULT __stdcall ReleaseBoundObjects( void) = 0;
        
        virtual HRESULT __stdcall SetBindOptions( 
            /* [in] */ BIND_OPTS __RPC_FAR *pbindopts) = 0;
        
        virtual HRESULT __stdcall GetBindOptions( 
            /* [out][in] */ BIND_OPTS __RPC_FAR *pbindopts) = 0;
        
        virtual HRESULT __stdcall GetRunningObjectTable( 
            /* [out] */ IRunningObjectTable __RPC_FAR *__RPC_FAR *pprot) = 0;
        
        virtual HRESULT __stdcall RegisterObjectParam( 
            /* [in] */ LPOLESTR pszKey,
            /* [unique][in] */ IUnknown __RPC_FAR *punk) = 0;
        
        virtual HRESULT __stdcall GetObjectParam( 
            /* [in] */ LPOLESTR pszKey,
            /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunk) = 0;
        
        virtual HRESULT __stdcall EnumObjectParam( 
            /* [out] */ IEnumString __RPC_FAR *__RPC_FAR *ppenum) = 0;
        
        virtual HRESULT __stdcall RevokeObjectParam( 
            /* [in] */ LPOLESTR pszKey) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IBindCtxVtbl
    {
        
        HRESULT ( __stdcall __RPC_FAR *QueryInterface )( 
            IBindCtx __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( __stdcall __RPC_FAR *AddRef )( 
            IBindCtx __RPC_FAR * This);
        
        ULONG ( __stdcall __RPC_FAR *Release )( 
            IBindCtx __RPC_FAR * This);
        
        HRESULT ( __stdcall __RPC_FAR *RegisterObjectBound )( 
            IBindCtx __RPC_FAR * This,
            /* [unique][in] */ IUnknown __RPC_FAR *punk);
        
        HRESULT ( __stdcall __RPC_FAR *RevokeObjectBound )( 
            IBindCtx __RPC_FAR * This,
            /* [unique][in] */ IUnknown __RPC_FAR *punk);
        
        HRESULT ( __stdcall __RPC_FAR *ReleaseBoundObjects )( 
            IBindCtx __RPC_FAR * This);
        
        HRESULT ( __stdcall __RPC_FAR *SetBindOptions )( 
            IBindCtx __RPC_FAR * This,
            /* [in] */ BIND_OPTS __RPC_FAR *pbindopts);
        
        HRESULT ( __stdcall __RPC_FAR *GetBindOptions )( 
            IBindCtx __RPC_FAR * This,
            /* [out][in] */ BIND_OPTS __RPC_FAR *pbindopts);
        
        HRESULT ( __stdcall __RPC_FAR *GetRunningObjectTable )( 
            IBindCtx __RPC_FAR * This,
            /* [out] */ IRunningObjectTable __RPC_FAR *__RPC_FAR *pprot);
        
        HRESULT ( __stdcall __RPC_FAR *RegisterObjectParam )( 
            IBindCtx __RPC_FAR * This,
            /* [in] */ LPOLESTR pszKey,
            /* [unique][in] */ IUnknown __RPC_FAR *punk);
        
        HRESULT ( __stdcall __RPC_FAR *GetObjectParam )( 
            IBindCtx __RPC_FAR * This,
            /* [in] */ LPOLESTR pszKey,
            /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunk);
        
        HRESULT ( __stdcall __RPC_FAR *EnumObjectParam )( 
            IBindCtx __RPC_FAR * This,
            /* [out] */ IEnumString __RPC_FAR *__RPC_FAR *ppenum);
        
        HRESULT ( __stdcall __RPC_FAR *RevokeObjectParam )( 
            IBindCtx __RPC_FAR * This,
            /* [in] */ LPOLESTR pszKey);
        
    } IBindCtxVtbl;

    interface IBindCtx
    {
        CONST_VTBL struct IBindCtxVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IBindCtx_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IBindCtx_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IBindCtx_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IBindCtx_RegisterObjectBound(This,punk)	\
    (This)->lpVtbl -> RegisterObjectBound(This,punk)

#define IBindCtx_RevokeObjectBound(This,punk)	\
    (This)->lpVtbl -> RevokeObjectBound(This,punk)

#define IBindCtx_ReleaseBoundObjects(This)	\
    (This)->lpVtbl -> ReleaseBoundObjects(This)

#define IBindCtx_SetBindOptions(This,pbindopts)	\
    (This)->lpVtbl -> SetBindOptions(This,pbindopts)

#define IBindCtx_GetBindOptions(This,pbindopts)	\
    (This)->lpVtbl -> GetBindOptions(This,pbindopts)

#define IBindCtx_GetRunningObjectTable(This,pprot)	\
    (This)->lpVtbl -> GetRunningObjectTable(This,pprot)

#define IBindCtx_RegisterObjectParam(This,pszKey,punk)	\
    (This)->lpVtbl -> RegisterObjectParam(This,pszKey,punk)

#define IBindCtx_GetObjectParam(This,pszKey,ppunk)	\
    (This)->lpVtbl -> GetObjectParam(This,pszKey,ppunk)

#define IBindCtx_EnumObjectParam(This,ppenum)	\
    (This)->lpVtbl -> EnumObjectParam(This,ppenum)

#define IBindCtx_RevokeObjectParam(This,pszKey)	\
    (This)->lpVtbl -> RevokeObjectParam(This,pszKey)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT __stdcall IBindCtx_RegisterObjectBound_Proxy( 
    IBindCtx __RPC_FAR * This,
    /* [unique][in] */ IUnknown __RPC_FAR *punk);


void __RPC_STUB IBindCtx_RegisterObjectBound_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IBindCtx_RevokeObjectBound_Proxy( 
    IBindCtx __RPC_FAR * This,
    /* [unique][in] */ IUnknown __RPC_FAR *punk);


void __RPC_STUB IBindCtx_RevokeObjectBound_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IBindCtx_ReleaseBoundObjects_Proxy( 
    IBindCtx __RPC_FAR * This);


void __RPC_STUB IBindCtx_ReleaseBoundObjects_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IBindCtx_SetBindOptions_Proxy( 
    IBindCtx __RPC_FAR * This,
    /* [in] */ BIND_OPTS __RPC_FAR *pbindopts);


void __RPC_STUB IBindCtx_SetBindOptions_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IBindCtx_GetBindOptions_Proxy( 
    IBindCtx __RPC_FAR * This,
    /* [out][in] */ BIND_OPTS __RPC_FAR *pbindopts);


void __RPC_STUB IBindCtx_GetBindOptions_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IBindCtx_GetRunningObjectTable_Proxy( 
    IBindCtx __RPC_FAR * This,
    /* [out] */ IRunningObjectTable __RPC_FAR *__RPC_FAR *pprot);


void __RPC_STUB IBindCtx_GetRunningObjectTable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IBindCtx_RegisterObjectParam_Proxy( 
    IBindCtx __RPC_FAR * This,
    /* [in] */ LPOLESTR pszKey,
    /* [unique][in] */ IUnknown __RPC_FAR *punk);


void __RPC_STUB IBindCtx_RegisterObjectParam_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IBindCtx_GetObjectParam_Proxy( 
    IBindCtx __RPC_FAR * This,
    /* [in] */ LPOLESTR pszKey,
    /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunk);


void __RPC_STUB IBindCtx_GetObjectParam_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IBindCtx_EnumObjectParam_Proxy( 
    IBindCtx __RPC_FAR * This,
    /* [out] */ IEnumString __RPC_FAR *__RPC_FAR *ppenum);


void __RPC_STUB IBindCtx_EnumObjectParam_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IBindCtx_RevokeObjectParam_Proxy( 
    IBindCtx __RPC_FAR * This,
    /* [in] */ LPOLESTR pszKey);


void __RPC_STUB IBindCtx_RevokeObjectParam_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IBindCtx_INTERFACE_DEFINED__ */


#ifndef __IEnumMoniker_INTERFACE_DEFINED__
#define __IEnumMoniker_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IEnumMoniker
 * at Fri Apr 28 07:02:32 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [unique][uuid][object] */ 


			/* size is 4 */
typedef /* [unique] */ IEnumMoniker __RPC_FAR *LPENUMMONIKER;


EXTERN_C const IID IID_IEnumMoniker;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IEnumMoniker : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT __stdcall Next( 
            /* [in] */ ULONG celt,
            /* [out] */ IMoniker __RPC_FAR *__RPC_FAR *rgelt,
            /* [out] */ ULONG __RPC_FAR *pceltFetched) = 0;
        
        virtual HRESULT __stdcall Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT __stdcall Reset( void) = 0;
        
        virtual HRESULT __stdcall Clone( 
            /* [out] */ IEnumMoniker __RPC_FAR *__RPC_FAR *ppenum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumMonikerVtbl
    {
        
        HRESULT ( __stdcall __RPC_FAR *QueryInterface )( 
            IEnumMoniker __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( __stdcall __RPC_FAR *AddRef )( 
            IEnumMoniker __RPC_FAR * This);
        
        ULONG ( __stdcall __RPC_FAR *Release )( 
            IEnumMoniker __RPC_FAR * This);
        
        /* [local] */ HRESULT ( __stdcall __RPC_FAR *Next )( 
            IEnumMoniker __RPC_FAR * This,
            /* [in] */ ULONG celt,
            /* [out] */ IMoniker __RPC_FAR *__RPC_FAR *rgelt,
            /* [out] */ ULONG __RPC_FAR *pceltFetched);
        
        HRESULT ( __stdcall __RPC_FAR *Skip )( 
            IEnumMoniker __RPC_FAR * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( __stdcall __RPC_FAR *Reset )( 
            IEnumMoniker __RPC_FAR * This);
        
        HRESULT ( __stdcall __RPC_FAR *Clone )( 
            IEnumMoniker __RPC_FAR * This,
            /* [out] */ IEnumMoniker __RPC_FAR *__RPC_FAR *ppenum);
        
    } IEnumMonikerVtbl;

    interface IEnumMoniker
    {
        CONST_VTBL struct IEnumMonikerVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumMoniker_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumMoniker_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumMoniker_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumMoniker_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IEnumMoniker_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumMoniker_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumMoniker_Clone(This,ppenum)	\
    (This)->lpVtbl -> Clone(This,ppenum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT __stdcall IEnumMoniker_RemoteNext_Proxy( 
    IEnumMoniker __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ IMoniker __RPC_FAR *__RPC_FAR *rgelt,
    /* [out] */ ULONG __RPC_FAR *pceltFetched);


void __RPC_STUB IEnumMoniker_RemoteNext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IEnumMoniker_Skip_Proxy( 
    IEnumMoniker __RPC_FAR * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IEnumMoniker_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IEnumMoniker_Reset_Proxy( 
    IEnumMoniker __RPC_FAR * This);


void __RPC_STUB IEnumMoniker_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IEnumMoniker_Clone_Proxy( 
    IEnumMoniker __RPC_FAR * This,
    /* [out] */ IEnumMoniker __RPC_FAR *__RPC_FAR *ppenum);


void __RPC_STUB IEnumMoniker_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumMoniker_INTERFACE_DEFINED__ */


#ifndef __IRunnableObject_INTERFACE_DEFINED__
#define __IRunnableObject_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IRunnableObject
 * at Fri Apr 28 07:02:32 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [uuid][object][local] */ 


			/* size is 4 */
typedef /* [unique] */ IRunnableObject __RPC_FAR *LPRUNNABLEOBJECT;


EXTERN_C const IID IID_IRunnableObject;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IRunnableObject : public IUnknown
    {
    public:
        virtual HRESULT __stdcall GetRunningClass( 
            /* [out] */ LPCLSID lpClsid) = 0;
        
        virtual HRESULT __stdcall Run( 
            /* [in] */ LPBINDCTX pbc) = 0;
        
        virtual BOOL __stdcall IsRunning( void) = 0;
        
        virtual HRESULT __stdcall LockRunning( 
            /* [in] */ BOOL fLock,
            /* [in] */ BOOL fLastUnlockCloses) = 0;
        
        virtual HRESULT __stdcall SetContainedObject( 
            /* [in] */ BOOL fContained) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRunnableObjectVtbl
    {
        
        HRESULT ( __stdcall __RPC_FAR *QueryInterface )( 
            IRunnableObject __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( __stdcall __RPC_FAR *AddRef )( 
            IRunnableObject __RPC_FAR * This);
        
        ULONG ( __stdcall __RPC_FAR *Release )( 
            IRunnableObject __RPC_FAR * This);
        
        HRESULT ( __stdcall __RPC_FAR *GetRunningClass )( 
            IRunnableObject __RPC_FAR * This,
            /* [out] */ LPCLSID lpClsid);
        
        HRESULT ( __stdcall __RPC_FAR *Run )( 
            IRunnableObject __RPC_FAR * This,
            /* [in] */ LPBINDCTX pbc);
        
        BOOL ( __stdcall __RPC_FAR *IsRunning )( 
            IRunnableObject __RPC_FAR * This);
        
        HRESULT ( __stdcall __RPC_FAR *LockRunning )( 
            IRunnableObject __RPC_FAR * This,
            /* [in] */ BOOL fLock,
            /* [in] */ BOOL fLastUnlockCloses);
        
        HRESULT ( __stdcall __RPC_FAR *SetContainedObject )( 
            IRunnableObject __RPC_FAR * This,
            /* [in] */ BOOL fContained);
        
    } IRunnableObjectVtbl;

    interface IRunnableObject
    {
        CONST_VTBL struct IRunnableObjectVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRunnableObject_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRunnableObject_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRunnableObject_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRunnableObject_GetRunningClass(This,lpClsid)	\
    (This)->lpVtbl -> GetRunningClass(This,lpClsid)

#define IRunnableObject_Run(This,pbc)	\
    (This)->lpVtbl -> Run(This,pbc)

#define IRunnableObject_IsRunning(This)	\
    (This)->lpVtbl -> IsRunning(This)

#define IRunnableObject_LockRunning(This,fLock,fLastUnlockCloses)	\
    (This)->lpVtbl -> LockRunning(This,fLock,fLastUnlockCloses)

#define IRunnableObject_SetContainedObject(This,fContained)	\
    (This)->lpVtbl -> SetContainedObject(This,fContained)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT __stdcall IRunnableObject_GetRunningClass_Proxy( 
    IRunnableObject __RPC_FAR * This,
    /* [out] */ LPCLSID lpClsid);


void __RPC_STUB IRunnableObject_GetRunningClass_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IRunnableObject_Run_Proxy( 
    IRunnableObject __RPC_FAR * This,
    /* [in] */ LPBINDCTX pbc);


void __RPC_STUB IRunnableObject_Run_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


BOOL __stdcall IRunnableObject_IsRunning_Proxy( 
    IRunnableObject __RPC_FAR * This);


void __RPC_STUB IRunnableObject_IsRunning_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IRunnableObject_LockRunning_Proxy( 
    IRunnableObject __RPC_FAR * This,
    /* [in] */ BOOL fLock,
    /* [in] */ BOOL fLastUnlockCloses);


void __RPC_STUB IRunnableObject_LockRunning_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IRunnableObject_SetContainedObject_Proxy( 
    IRunnableObject __RPC_FAR * This,
    /* [in] */ BOOL fContained);


void __RPC_STUB IRunnableObject_SetContainedObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRunnableObject_INTERFACE_DEFINED__ */


#ifndef __IRunningObjectTable_INTERFACE_DEFINED__
#define __IRunningObjectTable_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IRunningObjectTable
 * at Fri Apr 28 07:02:32 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [uuid][object] */ 


			/* size is 4 */
typedef /* [unique] */ IRunningObjectTable __RPC_FAR *LPRUNNINGOBJECTTABLE;


EXTERN_C const IID IID_IRunningObjectTable;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IRunningObjectTable : public IUnknown
    {
    public:
        virtual HRESULT __stdcall Register( 
            /* [in] */ DWORD grfFlags,
            /* [unique][in] */ IUnknown __RPC_FAR *punkObject,
            /* [unique][in] */ IMoniker __RPC_FAR *pmkObjectName,
            /* [out] */ DWORD __RPC_FAR *pdwRegister) = 0;
        
        virtual HRESULT __stdcall Revoke( 
            /* [in] */ DWORD dwRegister) = 0;
        
        virtual HRESULT __stdcall IsRunning( 
            /* [unique][in] */ IMoniker __RPC_FAR *pmkObjectName) = 0;
        
        virtual HRESULT __stdcall GetObject( 
            /* [unique][in] */ IMoniker __RPC_FAR *pmkObjectName,
            /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunkObject) = 0;
        
        virtual HRESULT __stdcall NoteChangeTime( 
            /* [in] */ DWORD dwRegister,
            /* [in] */ FILETIME __RPC_FAR *pfiletime) = 0;
        
        virtual HRESULT __stdcall GetTimeOfLastChange( 
            /* [unique][in] */ IMoniker __RPC_FAR *pmkObjectName,
            /* [out] */ FILETIME __RPC_FAR *pfiletime) = 0;
        
        virtual HRESULT __stdcall EnumRunning( 
            /* [out] */ IEnumMoniker __RPC_FAR *__RPC_FAR *ppenumMoniker) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRunningObjectTableVtbl
    {
        
        HRESULT ( __stdcall __RPC_FAR *QueryInterface )( 
            IRunningObjectTable __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( __stdcall __RPC_FAR *AddRef )( 
            IRunningObjectTable __RPC_FAR * This);
        
        ULONG ( __stdcall __RPC_FAR *Release )( 
            IRunningObjectTable __RPC_FAR * This);
        
        HRESULT ( __stdcall __RPC_FAR *Register )( 
            IRunningObjectTable __RPC_FAR * This,
            /* [in] */ DWORD grfFlags,
            /* [unique][in] */ IUnknown __RPC_FAR *punkObject,
            /* [unique][in] */ IMoniker __RPC_FAR *pmkObjectName,
            /* [out] */ DWORD __RPC_FAR *pdwRegister);
        
        HRESULT ( __stdcall __RPC_FAR *Revoke )( 
            IRunningObjectTable __RPC_FAR * This,
            /* [in] */ DWORD dwRegister);
        
        HRESULT ( __stdcall __RPC_FAR *IsRunning )( 
            IRunningObjectTable __RPC_FAR * This,
            /* [unique][in] */ IMoniker __RPC_FAR *pmkObjectName);
        
        HRESULT ( __stdcall __RPC_FAR *GetObject )( 
            IRunningObjectTable __RPC_FAR * This,
            /* [unique][in] */ IMoniker __RPC_FAR *pmkObjectName,
            /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunkObject);
        
        HRESULT ( __stdcall __RPC_FAR *NoteChangeTime )( 
            IRunningObjectTable __RPC_FAR * This,
            /* [in] */ DWORD dwRegister,
            /* [in] */ FILETIME __RPC_FAR *pfiletime);
        
        HRESULT ( __stdcall __RPC_FAR *GetTimeOfLastChange )( 
            IRunningObjectTable __RPC_FAR * This,
            /* [unique][in] */ IMoniker __RPC_FAR *pmkObjectName,
            /* [out] */ FILETIME __RPC_FAR *pfiletime);
        
        HRESULT ( __stdcall __RPC_FAR *EnumRunning )( 
            IRunningObjectTable __RPC_FAR * This,
            /* [out] */ IEnumMoniker __RPC_FAR *__RPC_FAR *ppenumMoniker);
        
    } IRunningObjectTableVtbl;

    interface IRunningObjectTable
    {
        CONST_VTBL struct IRunningObjectTableVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRunningObjectTable_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRunningObjectTable_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRunningObjectTable_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRunningObjectTable_Register(This,grfFlags,punkObject,pmkObjectName,pdwRegister)	\
    (This)->lpVtbl -> Register(This,grfFlags,punkObject,pmkObjectName,pdwRegister)

#define IRunningObjectTable_Revoke(This,dwRegister)	\
    (This)->lpVtbl -> Revoke(This,dwRegister)

#define IRunningObjectTable_IsRunning(This,pmkObjectName)	\
    (This)->lpVtbl -> IsRunning(This,pmkObjectName)

#define IRunningObjectTable_GetObject(This,pmkObjectName,ppunkObject)	\
    (This)->lpVtbl -> GetObject(This,pmkObjectName,ppunkObject)

#define IRunningObjectTable_NoteChangeTime(This,dwRegister,pfiletime)	\
    (This)->lpVtbl -> NoteChangeTime(This,dwRegister,pfiletime)

#define IRunningObjectTable_GetTimeOfLastChange(This,pmkObjectName,pfiletime)	\
    (This)->lpVtbl -> GetTimeOfLastChange(This,pmkObjectName,pfiletime)

#define IRunningObjectTable_EnumRunning(This,ppenumMoniker)	\
    (This)->lpVtbl -> EnumRunning(This,ppenumMoniker)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT __stdcall IRunningObjectTable_Register_Proxy( 
    IRunningObjectTable __RPC_FAR * This,
    /* [in] */ DWORD grfFlags,
    /* [unique][in] */ IUnknown __RPC_FAR *punkObject,
    /* [unique][in] */ IMoniker __RPC_FAR *pmkObjectName,
    /* [out] */ DWORD __RPC_FAR *pdwRegister);


void __RPC_STUB IRunningObjectTable_Register_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IRunningObjectTable_Revoke_Proxy( 
    IRunningObjectTable __RPC_FAR * This,
    /* [in] */ DWORD dwRegister);


void __RPC_STUB IRunningObjectTable_Revoke_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IRunningObjectTable_IsRunning_Proxy( 
    IRunningObjectTable __RPC_FAR * This,
    /* [unique][in] */ IMoniker __RPC_FAR *pmkObjectName);


void __RPC_STUB IRunningObjectTable_IsRunning_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IRunningObjectTable_GetObject_Proxy( 
    IRunningObjectTable __RPC_FAR * This,
    /* [unique][in] */ IMoniker __RPC_FAR *pmkObjectName,
    /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunkObject);


void __RPC_STUB IRunningObjectTable_GetObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IRunningObjectTable_NoteChangeTime_Proxy( 
    IRunningObjectTable __RPC_FAR * This,
    /* [in] */ DWORD dwRegister,
    /* [in] */ FILETIME __RPC_FAR *pfiletime);


void __RPC_STUB IRunningObjectTable_NoteChangeTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IRunningObjectTable_GetTimeOfLastChange_Proxy( 
    IRunningObjectTable __RPC_FAR * This,
    /* [unique][in] */ IMoniker __RPC_FAR *pmkObjectName,
    /* [out] */ FILETIME __RPC_FAR *pfiletime);


void __RPC_STUB IRunningObjectTable_GetTimeOfLastChange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IRunningObjectTable_EnumRunning_Proxy( 
    IRunningObjectTable __RPC_FAR * This,
    /* [out] */ IEnumMoniker __RPC_FAR *__RPC_FAR *ppenumMoniker);


void __RPC_STUB IRunningObjectTable_EnumRunning_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRunningObjectTable_INTERFACE_DEFINED__ */


#ifndef __IPersist_INTERFACE_DEFINED__
#define __IPersist_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IPersist
 * at Fri Apr 28 07:02:32 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [uuid][object] */ 


			/* size is 4 */
typedef /* [unique] */ IPersist __RPC_FAR *LPPERSIST;


EXTERN_C const IID IID_IPersist;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IPersist : public IUnknown
    {
    public:
        virtual HRESULT __stdcall GetClassID( 
            /* [out] */ CLSID __RPC_FAR *pClassID) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPersistVtbl
    {
        
        HRESULT ( __stdcall __RPC_FAR *QueryInterface )( 
            IPersist __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( __stdcall __RPC_FAR *AddRef )( 
            IPersist __RPC_FAR * This);
        
        ULONG ( __stdcall __RPC_FAR *Release )( 
            IPersist __RPC_FAR * This);
        
        HRESULT ( __stdcall __RPC_FAR *GetClassID )( 
            IPersist __RPC_FAR * This,
            /* [out] */ CLSID __RPC_FAR *pClassID);
        
    } IPersistVtbl;

    interface IPersist
    {
        CONST_VTBL struct IPersistVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPersist_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPersist_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPersist_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPersist_GetClassID(This,pClassID)	\
    (This)->lpVtbl -> GetClassID(This,pClassID)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT __stdcall IPersist_GetClassID_Proxy( 
    IPersist __RPC_FAR * This,
    /* [out] */ CLSID __RPC_FAR *pClassID);


void __RPC_STUB IPersist_GetClassID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IPersist_INTERFACE_DEFINED__ */


#ifndef __IPersistStream_INTERFACE_DEFINED__
#define __IPersistStream_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IPersistStream
 * at Fri Apr 28 07:02:32 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [unique][uuid][object] */ 


			/* size is 4 */
typedef /* [unique] */ IPersistStream __RPC_FAR *LPPERSISTSTREAM;


EXTERN_C const IID IID_IPersistStream;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IPersistStream : public IPersist
    {
    public:
        virtual HRESULT __stdcall IsDirty( void) = 0;
        
        virtual HRESULT __stdcall Load( 
            /* [unique][in] */ IStream __RPC_FAR *pStm) = 0;
        
        virtual HRESULT __stdcall Save( 
            /* [unique][in] */ IStream __RPC_FAR *pStm,
            /* [in] */ BOOL fClearDirty) = 0;
        
        virtual HRESULT __stdcall GetSizeMax( 
            /* [out] */ ULARGE_INTEGER __RPC_FAR *pcbSize) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPersistStreamVtbl
    {
        
        HRESULT ( __stdcall __RPC_FAR *QueryInterface )( 
            IPersistStream __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( __stdcall __RPC_FAR *AddRef )( 
            IPersistStream __RPC_FAR * This);
        
        ULONG ( __stdcall __RPC_FAR *Release )( 
            IPersistStream __RPC_FAR * This);
        
        HRESULT ( __stdcall __RPC_FAR *GetClassID )( 
            IPersistStream __RPC_FAR * This,
            /* [out] */ CLSID __RPC_FAR *pClassID);
        
        HRESULT ( __stdcall __RPC_FAR *IsDirty )( 
            IPersistStream __RPC_FAR * This);
        
        HRESULT ( __stdcall __RPC_FAR *Load )( 
            IPersistStream __RPC_FAR * This,
            /* [unique][in] */ IStream __RPC_FAR *pStm);
        
        HRESULT ( __stdcall __RPC_FAR *Save )( 
            IPersistStream __RPC_FAR * This,
            /* [unique][in] */ IStream __RPC_FAR *pStm,
            /* [in] */ BOOL fClearDirty);
        
        HRESULT ( __stdcall __RPC_FAR *GetSizeMax )( 
            IPersistStream __RPC_FAR * This,
            /* [out] */ ULARGE_INTEGER __RPC_FAR *pcbSize);
        
    } IPersistStreamVtbl;

    interface IPersistStream
    {
        CONST_VTBL struct IPersistStreamVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPersistStream_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPersistStream_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPersistStream_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPersistStream_GetClassID(This,pClassID)	\
    (This)->lpVtbl -> GetClassID(This,pClassID)


#define IPersistStream_IsDirty(This)	\
    (This)->lpVtbl -> IsDirty(This)

#define IPersistStream_Load(This,pStm)	\
    (This)->lpVtbl -> Load(This,pStm)

#define IPersistStream_Save(This,pStm,fClearDirty)	\
    (This)->lpVtbl -> Save(This,pStm,fClearDirty)

#define IPersistStream_GetSizeMax(This,pcbSize)	\
    (This)->lpVtbl -> GetSizeMax(This,pcbSize)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT __stdcall IPersistStream_IsDirty_Proxy( 
    IPersistStream __RPC_FAR * This);


void __RPC_STUB IPersistStream_IsDirty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IPersistStream_Load_Proxy( 
    IPersistStream __RPC_FAR * This,
    /* [unique][in] */ IStream __RPC_FAR *pStm);


void __RPC_STUB IPersistStream_Load_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IPersistStream_Save_Proxy( 
    IPersistStream __RPC_FAR * This,
    /* [unique][in] */ IStream __RPC_FAR *pStm,
    /* [in] */ BOOL fClearDirty);


void __RPC_STUB IPersistStream_Save_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IPersistStream_GetSizeMax_Proxy( 
    IPersistStream __RPC_FAR * This,
    /* [out] */ ULARGE_INTEGER __RPC_FAR *pcbSize);


void __RPC_STUB IPersistStream_GetSizeMax_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IPersistStream_INTERFACE_DEFINED__ */


#ifndef __IMoniker_INTERFACE_DEFINED__
#define __IMoniker_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IMoniker
 * at Fri Apr 28 07:02:32 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [unique][uuid][object] */ 


			/* size is 4 */
typedef /* [unique] */ IMoniker __RPC_FAR *LPMONIKER;

			/* size is 2 */
typedef 
enum tagMKSYS
    {	MKSYS_NONE	= 0,
	MKSYS_GENERICCOMPOSITE	= 1,
	MKSYS_FILEMONIKER	= 2,
	MKSYS_ANTIMONIKER	= 3,
	MKSYS_ITEMMONIKER	= 4,
	MKSYS_POINTERMONIKER	= 5
    }	MKSYS;

			/* size is 2 */
typedef /* [v1_enum] */ 
enum tagMKREDUCE
    {	MKRREDUCE_ONE	= 3 << 16,
	MKRREDUCE_TOUSER	= 2 << 16,
	MKRREDUCE_THROUGHUSER	= 1 << 16,
	MKRREDUCE_ALL	= 0
    }	MKRREDUCE;


EXTERN_C const IID IID_IMoniker;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IMoniker : public IPersistStream
    {
    public:
        virtual /* [local] */ HRESULT __stdcall BindToObject( 
            /* [unique][in] */ IBindCtx __RPC_FAR *pbc,
            /* [unique][in] */ IMoniker __RPC_FAR *pmkToLeft,
            /* [in] */ REFIID riidResult,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvResult) = 0;
        
        virtual /* [local] */ HRESULT __stdcall BindToStorage( 
            /* [unique][in] */ IBindCtx __RPC_FAR *pbc,
            /* [unique][in] */ IMoniker __RPC_FAR *pmkToLeft,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObj) = 0;
        
        virtual HRESULT __stdcall Reduce( 
            /* [unique][in] */ IBindCtx __RPC_FAR *pbc,
            /* [in] */ DWORD dwReduceHowFar,
            /* [unique][out][in] */ IMoniker __RPC_FAR *__RPC_FAR *ppmkToLeft,
            /* [out] */ IMoniker __RPC_FAR *__RPC_FAR *ppmkReduced) = 0;
        
        virtual HRESULT __stdcall ComposeWith( 
            /* [unique][in] */ IMoniker __RPC_FAR *pmkRight,
            /* [in] */ BOOL fOnlyIfNotGeneric,
            /* [out] */ IMoniker __RPC_FAR *__RPC_FAR *ppmkComposite) = 0;
        
        virtual HRESULT __stdcall Enum( 
            /* [in] */ BOOL fForward,
            /* [out] */ IEnumMoniker __RPC_FAR *__RPC_FAR *ppenumMoniker) = 0;
        
        virtual HRESULT __stdcall IsEqual( 
            /* [unique][in] */ IMoniker __RPC_FAR *pmkOtherMoniker) = 0;
        
        virtual HRESULT __stdcall Hash( 
            /* [out] */ DWORD __RPC_FAR *pdwHash) = 0;
        
        virtual HRESULT __stdcall IsRunning( 
            /* [unique][in] */ IBindCtx __RPC_FAR *pbc,
            /* [unique][in] */ IMoniker __RPC_FAR *pmkToLeft,
            /* [unique][in] */ IMoniker __RPC_FAR *pmkNewlyRunning) = 0;
        
        virtual HRESULT __stdcall GetTimeOfLastChange( 
            /* [unique][in] */ IBindCtx __RPC_FAR *pbc,
            /* [unique][in] */ IMoniker __RPC_FAR *pmkToLeft,
            /* [out] */ FILETIME __RPC_FAR *pFileTime) = 0;
        
        virtual HRESULT __stdcall Inverse( 
            /* [out] */ IMoniker __RPC_FAR *__RPC_FAR *ppmk) = 0;
        
        virtual HRESULT __stdcall CommonPrefixWith( 
            /* [unique][in] */ IMoniker __RPC_FAR *pmkOther,
            /* [out] */ IMoniker __RPC_FAR *__RPC_FAR *ppmkPrefix) = 0;
        
        virtual HRESULT __stdcall RelativePathTo( 
            /* [unique][in] */ IMoniker __RPC_FAR *pmkOther,
            /* [out] */ IMoniker __RPC_FAR *__RPC_FAR *ppmkRelPath) = 0;
        
        virtual HRESULT __stdcall GetDisplayName( 
            /* [unique][in] */ IBindCtx __RPC_FAR *pbc,
            /* [unique][in] */ IMoniker __RPC_FAR *pmkToLeft,
            /* [out] */ LPOLESTR __RPC_FAR *ppszDisplayName) = 0;
        
        virtual HRESULT __stdcall ParseDisplayName( 
            /* [unique][in] */ IBindCtx __RPC_FAR *pbc,
            /* [unique][in] */ IMoniker __RPC_FAR *pmkToLeft,
            /* [in] */ LPOLESTR pszDisplayName,
            /* [out] */ ULONG __RPC_FAR *pchEaten,
            /* [out] */ IMoniker __RPC_FAR *__RPC_FAR *ppmkOut) = 0;
        
        virtual HRESULT __stdcall IsSystemMoniker( 
            /* [out] */ DWORD __RPC_FAR *pdwMksys) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMonikerVtbl
    {
        
        HRESULT ( __stdcall __RPC_FAR *QueryInterface )( 
            IMoniker __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( __stdcall __RPC_FAR *AddRef )( 
            IMoniker __RPC_FAR * This);
        
        ULONG ( __stdcall __RPC_FAR *Release )( 
            IMoniker __RPC_FAR * This);
        
        HRESULT ( __stdcall __RPC_FAR *GetClassID )( 
            IMoniker __RPC_FAR * This,
            /* [out] */ CLSID __RPC_FAR *pClassID);
        
        HRESULT ( __stdcall __RPC_FAR *IsDirty )( 
            IMoniker __RPC_FAR * This);
        
        HRESULT ( __stdcall __RPC_FAR *Load )( 
            IMoniker __RPC_FAR * This,
            /* [unique][in] */ IStream __RPC_FAR *pStm);
        
        HRESULT ( __stdcall __RPC_FAR *Save )( 
            IMoniker __RPC_FAR * This,
            /* [unique][in] */ IStream __RPC_FAR *pStm,
            /* [in] */ BOOL fClearDirty);
        
        HRESULT ( __stdcall __RPC_FAR *GetSizeMax )( 
            IMoniker __RPC_FAR * This,
            /* [out] */ ULARGE_INTEGER __RPC_FAR *pcbSize);
        
        /* [local] */ HRESULT ( __stdcall __RPC_FAR *BindToObject )( 
            IMoniker __RPC_FAR * This,
            /* [unique][in] */ IBindCtx __RPC_FAR *pbc,
            /* [unique][in] */ IMoniker __RPC_FAR *pmkToLeft,
            /* [in] */ REFIID riidResult,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvResult);
        
        /* [local] */ HRESULT ( __stdcall __RPC_FAR *BindToStorage )( 
            IMoniker __RPC_FAR * This,
            /* [unique][in] */ IBindCtx __RPC_FAR *pbc,
            /* [unique][in] */ IMoniker __RPC_FAR *pmkToLeft,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObj);
        
        HRESULT ( __stdcall __RPC_FAR *Reduce )( 
            IMoniker __RPC_FAR * This,
            /* [unique][in] */ IBindCtx __RPC_FAR *pbc,
            /* [in] */ DWORD dwReduceHowFar,
            /* [unique][out][in] */ IMoniker __RPC_FAR *__RPC_FAR *ppmkToLeft,
            /* [out] */ IMoniker __RPC_FAR *__RPC_FAR *ppmkReduced);
        
        HRESULT ( __stdcall __RPC_FAR *ComposeWith )( 
            IMoniker __RPC_FAR * This,
            /* [unique][in] */ IMoniker __RPC_FAR *pmkRight,
            /* [in] */ BOOL fOnlyIfNotGeneric,
            /* [out] */ IMoniker __RPC_FAR *__RPC_FAR *ppmkComposite);
        
        HRESULT ( __stdcall __RPC_FAR *Enum )( 
            IMoniker __RPC_FAR * This,
            /* [in] */ BOOL fForward,
            /* [out] */ IEnumMoniker __RPC_FAR *__RPC_FAR *ppenumMoniker);
        
        HRESULT ( __stdcall __RPC_FAR *IsEqual )( 
            IMoniker __RPC_FAR * This,
            /* [unique][in] */ IMoniker __RPC_FAR *pmkOtherMoniker);
        
        HRESULT ( __stdcall __RPC_FAR *Hash )( 
            IMoniker __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwHash);
        
        HRESULT ( __stdcall __RPC_FAR *IsRunning )( 
            IMoniker __RPC_FAR * This,
            /* [unique][in] */ IBindCtx __RPC_FAR *pbc,
            /* [unique][in] */ IMoniker __RPC_FAR *pmkToLeft,
            /* [unique][in] */ IMoniker __RPC_FAR *pmkNewlyRunning);
        
        HRESULT ( __stdcall __RPC_FAR *GetTimeOfLastChange )( 
            IMoniker __RPC_FAR * This,
            /* [unique][in] */ IBindCtx __RPC_FAR *pbc,
            /* [unique][in] */ IMoniker __RPC_FAR *pmkToLeft,
            /* [out] */ FILETIME __RPC_FAR *pFileTime);
        
        HRESULT ( __stdcall __RPC_FAR *Inverse )( 
            IMoniker __RPC_FAR * This,
            /* [out] */ IMoniker __RPC_FAR *__RPC_FAR *ppmk);
        
        HRESULT ( __stdcall __RPC_FAR *CommonPrefixWith )( 
            IMoniker __RPC_FAR * This,
            /* [unique][in] */ IMoniker __RPC_FAR *pmkOther,
            /* [out] */ IMoniker __RPC_FAR *__RPC_FAR *ppmkPrefix);
        
        HRESULT ( __stdcall __RPC_FAR *RelativePathTo )( 
            IMoniker __RPC_FAR * This,
            /* [unique][in] */ IMoniker __RPC_FAR *pmkOther,
            /* [out] */ IMoniker __RPC_FAR *__RPC_FAR *ppmkRelPath);
        
        HRESULT ( __stdcall __RPC_FAR *GetDisplayName )( 
            IMoniker __RPC_FAR * This,
            /* [unique][in] */ IBindCtx __RPC_FAR *pbc,
            /* [unique][in] */ IMoniker __RPC_FAR *pmkToLeft,
            /* [out] */ LPOLESTR __RPC_FAR *ppszDisplayName);
        
        HRESULT ( __stdcall __RPC_FAR *ParseDisplayName )( 
            IMoniker __RPC_FAR * This,
            /* [unique][in] */ IBindCtx __RPC_FAR *pbc,
            /* [unique][in] */ IMoniker __RPC_FAR *pmkToLeft,
            /* [in] */ LPOLESTR pszDisplayName,
            /* [out] */ ULONG __RPC_FAR *pchEaten,
            /* [out] */ IMoniker __RPC_FAR *__RPC_FAR *ppmkOut);
        
        HRESULT ( __stdcall __RPC_FAR *IsSystemMoniker )( 
            IMoniker __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwMksys);
        
    } IMonikerVtbl;

    interface IMoniker
    {
        CONST_VTBL struct IMonikerVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMoniker_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMoniker_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMoniker_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMoniker_GetClassID(This,pClassID)	\
    (This)->lpVtbl -> GetClassID(This,pClassID)


#define IMoniker_IsDirty(This)	\
    (This)->lpVtbl -> IsDirty(This)

#define IMoniker_Load(This,pStm)	\
    (This)->lpVtbl -> Load(This,pStm)

#define IMoniker_Save(This,pStm,fClearDirty)	\
    (This)->lpVtbl -> Save(This,pStm,fClearDirty)

#define IMoniker_GetSizeMax(This,pcbSize)	\
    (This)->lpVtbl -> GetSizeMax(This,pcbSize)


#define IMoniker_BindToObject(This,pbc,pmkToLeft,riidResult,ppvResult)	\
    (This)->lpVtbl -> BindToObject(This,pbc,pmkToLeft,riidResult,ppvResult)

#define IMoniker_BindToStorage(This,pbc,pmkToLeft,riid,ppvObj)	\
    (This)->lpVtbl -> BindToStorage(This,pbc,pmkToLeft,riid,ppvObj)

#define IMoniker_Reduce(This,pbc,dwReduceHowFar,ppmkToLeft,ppmkReduced)	\
    (This)->lpVtbl -> Reduce(This,pbc,dwReduceHowFar,ppmkToLeft,ppmkReduced)

#define IMoniker_ComposeWith(This,pmkRight,fOnlyIfNotGeneric,ppmkComposite)	\
    (This)->lpVtbl -> ComposeWith(This,pmkRight,fOnlyIfNotGeneric,ppmkComposite)

#define IMoniker_Enum(This,fForward,ppenumMoniker)	\
    (This)->lpVtbl -> Enum(This,fForward,ppenumMoniker)

#define IMoniker_IsEqual(This,pmkOtherMoniker)	\
    (This)->lpVtbl -> IsEqual(This,pmkOtherMoniker)

#define IMoniker_Hash(This,pdwHash)	\
    (This)->lpVtbl -> Hash(This,pdwHash)

#define IMoniker_IsRunning(This,pbc,pmkToLeft,pmkNewlyRunning)	\
    (This)->lpVtbl -> IsRunning(This,pbc,pmkToLeft,pmkNewlyRunning)

#define IMoniker_GetTimeOfLastChange(This,pbc,pmkToLeft,pFileTime)	\
    (This)->lpVtbl -> GetTimeOfLastChange(This,pbc,pmkToLeft,pFileTime)

#define IMoniker_Inverse(This,ppmk)	\
    (This)->lpVtbl -> Inverse(This,ppmk)

#define IMoniker_CommonPrefixWith(This,pmkOther,ppmkPrefix)	\
    (This)->lpVtbl -> CommonPrefixWith(This,pmkOther,ppmkPrefix)

#define IMoniker_RelativePathTo(This,pmkOther,ppmkRelPath)	\
    (This)->lpVtbl -> RelativePathTo(This,pmkOther,ppmkRelPath)

#define IMoniker_GetDisplayName(This,pbc,pmkToLeft,ppszDisplayName)	\
    (This)->lpVtbl -> GetDisplayName(This,pbc,pmkToLeft,ppszDisplayName)

#define IMoniker_ParseDisplayName(This,pbc,pmkToLeft,pszDisplayName,pchEaten,ppmkOut)	\
    (This)->lpVtbl -> ParseDisplayName(This,pbc,pmkToLeft,pszDisplayName,pchEaten,ppmkOut)

#define IMoniker_IsSystemMoniker(This,pdwMksys)	\
    (This)->lpVtbl -> IsSystemMoniker(This,pdwMksys)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT __stdcall IMoniker_RemoteBindToObject_Proxy( 
    IMoniker __RPC_FAR * This,
    /* [unique][in] */ IBindCtx __RPC_FAR *pbc,
    /* [unique][in] */ IMoniker __RPC_FAR *pmkToLeft,
    /* [in] */ REFIID riidResult,
    /* [iid_is][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppvResult);


void __RPC_STUB IMoniker_RemoteBindToObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT __stdcall IMoniker_RemoteBindToStorage_Proxy( 
    IMoniker __RPC_FAR * This,
    /* [unique][in] */ IBindCtx __RPC_FAR *pbc,
    /* [unique][in] */ IMoniker __RPC_FAR *pmkToLeft,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppvObj);


void __RPC_STUB IMoniker_RemoteBindToStorage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IMoniker_Reduce_Proxy( 
    IMoniker __RPC_FAR * This,
    /* [unique][in] */ IBindCtx __RPC_FAR *pbc,
    /* [in] */ DWORD dwReduceHowFar,
    /* [unique][out][in] */ IMoniker __RPC_FAR *__RPC_FAR *ppmkToLeft,
    /* [out] */ IMoniker __RPC_FAR *__RPC_FAR *ppmkReduced);


void __RPC_STUB IMoniker_Reduce_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IMoniker_ComposeWith_Proxy( 
    IMoniker __RPC_FAR * This,
    /* [unique][in] */ IMoniker __RPC_FAR *pmkRight,
    /* [in] */ BOOL fOnlyIfNotGeneric,
    /* [out] */ IMoniker __RPC_FAR *__RPC_FAR *ppmkComposite);


void __RPC_STUB IMoniker_ComposeWith_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IMoniker_Enum_Proxy( 
    IMoniker __RPC_FAR * This,
    /* [in] */ BOOL fForward,
    /* [out] */ IEnumMoniker __RPC_FAR *__RPC_FAR *ppenumMoniker);


void __RPC_STUB IMoniker_Enum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IMoniker_IsEqual_Proxy( 
    IMoniker __RPC_FAR * This,
    /* [unique][in] */ IMoniker __RPC_FAR *pmkOtherMoniker);


void __RPC_STUB IMoniker_IsEqual_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IMoniker_Hash_Proxy( 
    IMoniker __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwHash);


void __RPC_STUB IMoniker_Hash_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IMoniker_IsRunning_Proxy( 
    IMoniker __RPC_FAR * This,
    /* [unique][in] */ IBindCtx __RPC_FAR *pbc,
    /* [unique][in] */ IMoniker __RPC_FAR *pmkToLeft,
    /* [unique][in] */ IMoniker __RPC_FAR *pmkNewlyRunning);


void __RPC_STUB IMoniker_IsRunning_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IMoniker_GetTimeOfLastChange_Proxy( 
    IMoniker __RPC_FAR * This,
    /* [unique][in] */ IBindCtx __RPC_FAR *pbc,
    /* [unique][in] */ IMoniker __RPC_FAR *pmkToLeft,
    /* [out] */ FILETIME __RPC_FAR *pFileTime);


void __RPC_STUB IMoniker_GetTimeOfLastChange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IMoniker_Inverse_Proxy( 
    IMoniker __RPC_FAR * This,
    /* [out] */ IMoniker __RPC_FAR *__RPC_FAR *ppmk);


void __RPC_STUB IMoniker_Inverse_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IMoniker_CommonPrefixWith_Proxy( 
    IMoniker __RPC_FAR * This,
    /* [unique][in] */ IMoniker __RPC_FAR *pmkOther,
    /* [out] */ IMoniker __RPC_FAR *__RPC_FAR *ppmkPrefix);


void __RPC_STUB IMoniker_CommonPrefixWith_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IMoniker_RelativePathTo_Proxy( 
    IMoniker __RPC_FAR * This,
    /* [unique][in] */ IMoniker __RPC_FAR *pmkOther,
    /* [out] */ IMoniker __RPC_FAR *__RPC_FAR *ppmkRelPath);


void __RPC_STUB IMoniker_RelativePathTo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IMoniker_GetDisplayName_Proxy( 
    IMoniker __RPC_FAR * This,
    /* [unique][in] */ IBindCtx __RPC_FAR *pbc,
    /* [unique][in] */ IMoniker __RPC_FAR *pmkToLeft,
    /* [out] */ LPOLESTR __RPC_FAR *ppszDisplayName);


void __RPC_STUB IMoniker_GetDisplayName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IMoniker_ParseDisplayName_Proxy( 
    IMoniker __RPC_FAR * This,
    /* [unique][in] */ IBindCtx __RPC_FAR *pbc,
    /* [unique][in] */ IMoniker __RPC_FAR *pmkToLeft,
    /* [in] */ LPOLESTR pszDisplayName,
    /* [out] */ ULONG __RPC_FAR *pchEaten,
    /* [out] */ IMoniker __RPC_FAR *__RPC_FAR *ppmkOut);


void __RPC_STUB IMoniker_ParseDisplayName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IMoniker_IsSystemMoniker_Proxy( 
    IMoniker __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwMksys);


void __RPC_STUB IMoniker_IsSystemMoniker_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMoniker_INTERFACE_DEFINED__ */


#ifndef __IROTData_INTERFACE_DEFINED__
#define __IROTData_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IROTData
 * at Fri Apr 28 07:02:32 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_IROTData;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IROTData : public IUnknown
    {
    public:
        virtual HRESULT __stdcall GetComparisonData( 
            /* [size_is][out] */ byte __RPC_FAR *pbData,
            /* [in] */ ULONG cbMax,
            /* [out] */ ULONG __RPC_FAR *pcbData) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IROTDataVtbl
    {
        
        HRESULT ( __stdcall __RPC_FAR *QueryInterface )( 
            IROTData __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( __stdcall __RPC_FAR *AddRef )( 
            IROTData __RPC_FAR * This);
        
        ULONG ( __stdcall __RPC_FAR *Release )( 
            IROTData __RPC_FAR * This);
        
        HRESULT ( __stdcall __RPC_FAR *GetComparisonData )( 
            IROTData __RPC_FAR * This,
            /* [size_is][out] */ byte __RPC_FAR *pbData,
            /* [in] */ ULONG cbMax,
            /* [out] */ ULONG __RPC_FAR *pcbData);
        
    } IROTDataVtbl;

    interface IROTData
    {
        CONST_VTBL struct IROTDataVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IROTData_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IROTData_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IROTData_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IROTData_GetComparisonData(This,pbData,cbMax,pcbData)	\
    (This)->lpVtbl -> GetComparisonData(This,pbData,cbMax,pcbData)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT __stdcall IROTData_GetComparisonData_Proxy( 
    IROTData __RPC_FAR * This,
    /* [size_is][out] */ byte __RPC_FAR *pbData,
    /* [in] */ ULONG cbMax,
    /* [out] */ ULONG __RPC_FAR *pcbData);


void __RPC_STUB IROTData_GetComparisonData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IROTData_INTERFACE_DEFINED__ */


#ifndef __IEnumString_INTERFACE_DEFINED__
#define __IEnumString_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IEnumString
 * at Fri Apr 28 07:02:32 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [unique][uuid][object] */ 


			/* size is 4 */
typedef /* [unique] */ IEnumString __RPC_FAR *LPENUMSTRING;


EXTERN_C const IID IID_IEnumString;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IEnumString : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT __stdcall Next( 
            /* [in] */ ULONG celt,
            /* [out] */ LPOLESTR __RPC_FAR *rgelt,
            /* [out] */ ULONG __RPC_FAR *pceltFetched) = 0;
        
        virtual HRESULT __stdcall Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT __stdcall Reset( void) = 0;
        
        virtual HRESULT __stdcall Clone( 
            /* [out] */ IEnumString __RPC_FAR *__RPC_FAR *ppenum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumStringVtbl
    {
        
        HRESULT ( __stdcall __RPC_FAR *QueryInterface )( 
            IEnumString __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( __stdcall __RPC_FAR *AddRef )( 
            IEnumString __RPC_FAR * This);
        
        ULONG ( __stdcall __RPC_FAR *Release )( 
            IEnumString __RPC_FAR * This);
        
        /* [local] */ HRESULT ( __stdcall __RPC_FAR *Next )( 
            IEnumString __RPC_FAR * This,
            /* [in] */ ULONG celt,
            /* [out] */ LPOLESTR __RPC_FAR *rgelt,
            /* [out] */ ULONG __RPC_FAR *pceltFetched);
        
        HRESULT ( __stdcall __RPC_FAR *Skip )( 
            IEnumString __RPC_FAR * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( __stdcall __RPC_FAR *Reset )( 
            IEnumString __RPC_FAR * This);
        
        HRESULT ( __stdcall __RPC_FAR *Clone )( 
            IEnumString __RPC_FAR * This,
            /* [out] */ IEnumString __RPC_FAR *__RPC_FAR *ppenum);
        
    } IEnumStringVtbl;

    interface IEnumString
    {
        CONST_VTBL struct IEnumStringVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumString_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumString_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumString_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumString_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IEnumString_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumString_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumString_Clone(This,ppenum)	\
    (This)->lpVtbl -> Clone(This,ppenum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT __stdcall IEnumString_RemoteNext_Proxy( 
    IEnumString __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ LPOLESTR __RPC_FAR *rgelt,
    /* [out] */ ULONG __RPC_FAR *pceltFetched);


void __RPC_STUB IEnumString_RemoteNext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IEnumString_Skip_Proxy( 
    IEnumString __RPC_FAR * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IEnumString_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IEnumString_Reset_Proxy( 
    IEnumString __RPC_FAR * This);


void __RPC_STUB IEnumString_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IEnumString_Clone_Proxy( 
    IEnumString __RPC_FAR * This,
    /* [out] */ IEnumString __RPC_FAR *__RPC_FAR *ppenum);


void __RPC_STUB IEnumString_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumString_INTERFACE_DEFINED__ */


#ifndef __IStream_INTERFACE_DEFINED__
#define __IStream_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IStream
 * at Fri Apr 28 07:02:32 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [unique][uuid][object] */ 


			/* size is 4 */
typedef /* [unique] */ IStream __RPC_FAR *LPSTREAM;

			/* size is 72 */
typedef struct  tagSTATSTG
    {
    LPOLESTR pwcsName;
    DWORD type;
    ULARGE_INTEGER cbSize;
    FILETIME mtime;
    FILETIME ctime;
    FILETIME atime;
    DWORD grfMode;
    DWORD grfLocksSupported;
    CLSID clsid;
    DWORD grfStateBits;
    DWORD reserved;
    }	STATSTG;

			/* size is 2 */
typedef 
enum tagSTGTY
    {	STGTY_STORAGE	= 1,
	STGTY_STREAM	= 2,
	STGTY_LOCKBYTES	= 3,
	STGTY_PROPERTY	= 4
    }	STGTY;

			/* size is 2 */
typedef 
enum tagSTREAM_SEEK
    {	STREAM_SEEK_SET	= 0,
	STREAM_SEEK_CUR	= 1,
	STREAM_SEEK_END	= 2
    }	STREAM_SEEK;

			/* size is 2 */
typedef 
enum tagLOCKTYPE
    {	LOCK_WRITE	= 1,
	LOCK_EXCLUSIVE	= 2,
	LOCK_ONLYONCE	= 4
    }	LOCKTYPE;


EXTERN_C const IID IID_IStream;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IStream : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT __stdcall Read( 
            /* [out] */ void __RPC_FAR *pv,
            /* [in] */ ULONG cb,
            /* [out] */ ULONG __RPC_FAR *pcbRead) = 0;
        
        virtual /* [local] */ HRESULT __stdcall Write( 
            /* [size_is][in] */ const void __RPC_FAR *pv,
            /* [in] */ ULONG cb,
            /* [out] */ ULONG __RPC_FAR *pcbWritten) = 0;
        
        virtual /* [local] */ HRESULT __stdcall Seek( 
            /* [in] */ LARGE_INTEGER dlibMove,
            /* [in] */ DWORD dwOrigin,
            /* [out] */ ULARGE_INTEGER __RPC_FAR *plibNewPosition) = 0;
        
        virtual HRESULT __stdcall SetSize( 
            /* [in] */ ULARGE_INTEGER libNewSize) = 0;
        
        virtual /* [local] */ HRESULT __stdcall CopyTo( 
            /* [unique][in] */ IStream __RPC_FAR *pstm,
            /* [in] */ ULARGE_INTEGER cb,
            /* [out] */ ULARGE_INTEGER __RPC_FAR *pcbRead,
            /* [out] */ ULARGE_INTEGER __RPC_FAR *pcbWritten) = 0;
        
        virtual HRESULT __stdcall Commit( 
            /* [in] */ DWORD grfCommitFlags) = 0;
        
        virtual HRESULT __stdcall Revert( void) = 0;
        
        virtual HRESULT __stdcall LockRegion( 
            /* [in] */ ULARGE_INTEGER libOffset,
            /* [in] */ ULARGE_INTEGER cb,
            /* [in] */ DWORD dwLockType) = 0;
        
        virtual HRESULT __stdcall UnlockRegion( 
            /* [in] */ ULARGE_INTEGER libOffset,
            /* [in] */ ULARGE_INTEGER cb,
            /* [in] */ DWORD dwLockType) = 0;
        
        virtual HRESULT __stdcall Stat( 
            /* [out] */ STATSTG __RPC_FAR *pstatstg,
            /* [in] */ DWORD grfStatFlag) = 0;
        
        virtual HRESULT __stdcall Clone( 
            /* [out] */ IStream __RPC_FAR *__RPC_FAR *ppstm) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IStreamVtbl
    {
        
        HRESULT ( __stdcall __RPC_FAR *QueryInterface )( 
            IStream __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( __stdcall __RPC_FAR *AddRef )( 
            IStream __RPC_FAR * This);
        
        ULONG ( __stdcall __RPC_FAR *Release )( 
            IStream __RPC_FAR * This);
        
        /* [local] */ HRESULT ( __stdcall __RPC_FAR *Read )( 
            IStream __RPC_FAR * This,
            /* [out] */ void __RPC_FAR *pv,
            /* [in] */ ULONG cb,
            /* [out] */ ULONG __RPC_FAR *pcbRead);
        
        /* [local] */ HRESULT ( __stdcall __RPC_FAR *Write )( 
            IStream __RPC_FAR * This,
            /* [size_is][in] */ const void __RPC_FAR *pv,
            /* [in] */ ULONG cb,
            /* [out] */ ULONG __RPC_FAR *pcbWritten);
        
        /* [local] */ HRESULT ( __stdcall __RPC_FAR *Seek )( 
            IStream __RPC_FAR * This,
            /* [in] */ LARGE_INTEGER dlibMove,
            /* [in] */ DWORD dwOrigin,
            /* [out] */ ULARGE_INTEGER __RPC_FAR *plibNewPosition);
        
        HRESULT ( __stdcall __RPC_FAR *SetSize )( 
            IStream __RPC_FAR * This,
            /* [in] */ ULARGE_INTEGER libNewSize);
        
        /* [local] */ HRESULT ( __stdcall __RPC_FAR *CopyTo )( 
            IStream __RPC_FAR * This,
            /* [unique][in] */ IStream __RPC_FAR *pstm,
            /* [in] */ ULARGE_INTEGER cb,
            /* [out] */ ULARGE_INTEGER __RPC_FAR *pcbRead,
            /* [out] */ ULARGE_INTEGER __RPC_FAR *pcbWritten);
        
        HRESULT ( __stdcall __RPC_FAR *Commit )( 
            IStream __RPC_FAR * This,
            /* [in] */ DWORD grfCommitFlags);
        
        HRESULT ( __stdcall __RPC_FAR *Revert )( 
            IStream __RPC_FAR * This);
        
        HRESULT ( __stdcall __RPC_FAR *LockRegion )( 
            IStream __RPC_FAR * This,
            /* [in] */ ULARGE_INTEGER libOffset,
            /* [in] */ ULARGE_INTEGER cb,
            /* [in] */ DWORD dwLockType);
        
        HRESULT ( __stdcall __RPC_FAR *UnlockRegion )( 
            IStream __RPC_FAR * This,
            /* [in] */ ULARGE_INTEGER libOffset,
            /* [in] */ ULARGE_INTEGER cb,
            /* [in] */ DWORD dwLockType);
        
        HRESULT ( __stdcall __RPC_FAR *Stat )( 
            IStream __RPC_FAR * This,
            /* [out] */ STATSTG __RPC_FAR *pstatstg,
            /* [in] */ DWORD grfStatFlag);
        
        HRESULT ( __stdcall __RPC_FAR *Clone )( 
            IStream __RPC_FAR * This,
            /* [out] */ IStream __RPC_FAR *__RPC_FAR *ppstm);
        
    } IStreamVtbl;

    interface IStream
    {
        CONST_VTBL struct IStreamVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IStream_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IStream_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IStream_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IStream_Read(This,pv,cb,pcbRead)	\
    (This)->lpVtbl -> Read(This,pv,cb,pcbRead)

#define IStream_Write(This,pv,cb,pcbWritten)	\
    (This)->lpVtbl -> Write(This,pv,cb,pcbWritten)

#define IStream_Seek(This,dlibMove,dwOrigin,plibNewPosition)	\
    (This)->lpVtbl -> Seek(This,dlibMove,dwOrigin,plibNewPosition)

#define IStream_SetSize(This,libNewSize)	\
    (This)->lpVtbl -> SetSize(This,libNewSize)

#define IStream_CopyTo(This,pstm,cb,pcbRead,pcbWritten)	\
    (This)->lpVtbl -> CopyTo(This,pstm,cb,pcbRead,pcbWritten)

#define IStream_Commit(This,grfCommitFlags)	\
    (This)->lpVtbl -> Commit(This,grfCommitFlags)

#define IStream_Revert(This)	\
    (This)->lpVtbl -> Revert(This)

#define IStream_LockRegion(This,libOffset,cb,dwLockType)	\
    (This)->lpVtbl -> LockRegion(This,libOffset,cb,dwLockType)

#define IStream_UnlockRegion(This,libOffset,cb,dwLockType)	\
    (This)->lpVtbl -> UnlockRegion(This,libOffset,cb,dwLockType)

#define IStream_Stat(This,pstatstg,grfStatFlag)	\
    (This)->lpVtbl -> Stat(This,pstatstg,grfStatFlag)

#define IStream_Clone(This,ppstm)	\
    (This)->lpVtbl -> Clone(This,ppstm)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT __stdcall IStream_RemoteRead_Proxy( 
    IStream __RPC_FAR * This,
    /* [length_is][size_is][out] */ byte __RPC_FAR *pv,
    /* [in] */ ULONG cb,
    /* [out] */ ULONG __RPC_FAR *pcbRead);


void __RPC_STUB IStream_RemoteRead_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT __stdcall IStream_RemoteWrite_Proxy( 
    IStream __RPC_FAR * This,
    /* [size_is][in] */ const byte __RPC_FAR *pv,
    /* [in] */ ULONG cb,
    /* [out] */ ULONG __RPC_FAR *pcbWritten);


void __RPC_STUB IStream_RemoteWrite_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT __stdcall IStream_RemoteSeek_Proxy( 
    IStream __RPC_FAR * This,
    /* [in] */ LARGE_INTEGER dlibMove,
    /* [in] */ DWORD dwOrigin,
    /* [out] */ ULARGE_INTEGER __RPC_FAR *plibNewPosition);


void __RPC_STUB IStream_RemoteSeek_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IStream_SetSize_Proxy( 
    IStream __RPC_FAR * This,
    /* [in] */ ULARGE_INTEGER libNewSize);


void __RPC_STUB IStream_SetSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT __stdcall IStream_RemoteCopyTo_Proxy( 
    IStream __RPC_FAR * This,
    /* [unique][in] */ IStream __RPC_FAR *pstm,
    /* [in] */ ULARGE_INTEGER cb,
    /* [out] */ ULARGE_INTEGER __RPC_FAR *pcbRead,
    /* [out] */ ULARGE_INTEGER __RPC_FAR *pcbWritten);


void __RPC_STUB IStream_RemoteCopyTo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IStream_Commit_Proxy( 
    IStream __RPC_FAR * This,
    /* [in] */ DWORD grfCommitFlags);


void __RPC_STUB IStream_Commit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IStream_Revert_Proxy( 
    IStream __RPC_FAR * This);


void __RPC_STUB IStream_Revert_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IStream_LockRegion_Proxy( 
    IStream __RPC_FAR * This,
    /* [in] */ ULARGE_INTEGER libOffset,
    /* [in] */ ULARGE_INTEGER cb,
    /* [in] */ DWORD dwLockType);


void __RPC_STUB IStream_LockRegion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IStream_UnlockRegion_Proxy( 
    IStream __RPC_FAR * This,
    /* [in] */ ULARGE_INTEGER libOffset,
    /* [in] */ ULARGE_INTEGER cb,
    /* [in] */ DWORD dwLockType);


void __RPC_STUB IStream_UnlockRegion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IStream_Stat_Proxy( 
    IStream __RPC_FAR * This,
    /* [out] */ STATSTG __RPC_FAR *pstatstg,
    /* [in] */ DWORD grfStatFlag);


void __RPC_STUB IStream_Stat_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IStream_Clone_Proxy( 
    IStream __RPC_FAR * This,
    /* [out] */ IStream __RPC_FAR *__RPC_FAR *ppstm);


void __RPC_STUB IStream_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IStream_INTERFACE_DEFINED__ */


#ifndef __IEnumSTATSTG_INTERFACE_DEFINED__
#define __IEnumSTATSTG_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IEnumSTATSTG
 * at Fri Apr 28 07:02:32 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [unique][uuid][object] */ 


			/* size is 4 */
typedef /* [unique] */ IEnumSTATSTG __RPC_FAR *LPENUMSTATSTG;


EXTERN_C const IID IID_IEnumSTATSTG;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IEnumSTATSTG : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT __stdcall Next( 
            /* [in] */ ULONG celt,
            /* [in] */ STATSTG __RPC_FAR *rgelt,
            /* [out] */ ULONG __RPC_FAR *pceltFetched) = 0;
        
        virtual HRESULT __stdcall Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT __stdcall Reset( void) = 0;
        
        virtual HRESULT __stdcall Clone( 
            /* [out] */ IEnumSTATSTG __RPC_FAR *__RPC_FAR *ppenum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumSTATSTGVtbl
    {
        
        HRESULT ( __stdcall __RPC_FAR *QueryInterface )( 
            IEnumSTATSTG __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( __stdcall __RPC_FAR *AddRef )( 
            IEnumSTATSTG __RPC_FAR * This);
        
        ULONG ( __stdcall __RPC_FAR *Release )( 
            IEnumSTATSTG __RPC_FAR * This);
        
        /* [local] */ HRESULT ( __stdcall __RPC_FAR *Next )( 
            IEnumSTATSTG __RPC_FAR * This,
            /* [in] */ ULONG celt,
            /* [in] */ STATSTG __RPC_FAR *rgelt,
            /* [out] */ ULONG __RPC_FAR *pceltFetched);
        
        HRESULT ( __stdcall __RPC_FAR *Skip )( 
            IEnumSTATSTG __RPC_FAR * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( __stdcall __RPC_FAR *Reset )( 
            IEnumSTATSTG __RPC_FAR * This);
        
        HRESULT ( __stdcall __RPC_FAR *Clone )( 
            IEnumSTATSTG __RPC_FAR * This,
            /* [out] */ IEnumSTATSTG __RPC_FAR *__RPC_FAR *ppenum);
        
    } IEnumSTATSTGVtbl;

    interface IEnumSTATSTG
    {
        CONST_VTBL struct IEnumSTATSTGVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumSTATSTG_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumSTATSTG_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumSTATSTG_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumSTATSTG_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IEnumSTATSTG_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumSTATSTG_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumSTATSTG_Clone(This,ppenum)	\
    (This)->lpVtbl -> Clone(This,ppenum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT __stdcall IEnumSTATSTG_RemoteNext_Proxy( 
    IEnumSTATSTG __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ STATSTG __RPC_FAR *rgelt,
    /* [out] */ ULONG __RPC_FAR *pceltFetched);


void __RPC_STUB IEnumSTATSTG_RemoteNext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IEnumSTATSTG_Skip_Proxy( 
    IEnumSTATSTG __RPC_FAR * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IEnumSTATSTG_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IEnumSTATSTG_Reset_Proxy( 
    IEnumSTATSTG __RPC_FAR * This);


void __RPC_STUB IEnumSTATSTG_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IEnumSTATSTG_Clone_Proxy( 
    IEnumSTATSTG __RPC_FAR * This,
    /* [out] */ IEnumSTATSTG __RPC_FAR *__RPC_FAR *ppenum);


void __RPC_STUB IEnumSTATSTG_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumSTATSTG_INTERFACE_DEFINED__ */


#ifndef __IStorage_INTERFACE_DEFINED__
#define __IStorage_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IStorage
 * at Fri Apr 28 07:02:32 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [unique][uuid][object] */ 


			/* size is 4 */
typedef /* [unique] */ IStorage __RPC_FAR *LPSTORAGE;

			/* size is 8 */
typedef struct  tagRemSNB
    {
    unsigned long ulCntStr;
    unsigned long ulCntChar;
    /* [size_is] */ OLECHAR rgString[ 1 ];
    }	RemSNB;

			/* size is 4 */
typedef /* [transmit] */ OLECHAR __RPC_FAR *__RPC_FAR *SNB;


EXTERN_C const IID IID_IStorage;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IStorage : public IUnknown
    {
    public:
        virtual HRESULT __stdcall CreateStream( 
            /* [string][in] */ const OLECHAR __RPC_FAR *pwcsName,
            /* [in] */ DWORD grfMode,
            /* [in] */ DWORD reserved1,
            /* [in] */ DWORD reserved2,
            /* [out] */ IStream __RPC_FAR *__RPC_FAR *ppstm) = 0;
        
        virtual /* [local] */ HRESULT __stdcall OpenStream( 
            /* [string][in] */ const OLECHAR __RPC_FAR *pwcsName,
            /* [unique][in] */ void __RPC_FAR *reserved1,
            /* [in] */ DWORD grfMode,
            /* [in] */ DWORD reserved2,
            /* [out] */ IStream __RPC_FAR *__RPC_FAR *ppstm) = 0;
        
        virtual HRESULT __stdcall CreateStorage( 
            /* [string][in] */ const OLECHAR __RPC_FAR *pwcsName,
            /* [in] */ DWORD grfMode,
            /* [in] */ DWORD dwStgFmt,
            /* [in] */ DWORD reserved2,
            /* [out] */ IStorage __RPC_FAR *__RPC_FAR *ppstg) = 0;
        
        virtual HRESULT __stdcall OpenStorage( 
            /* [string][unique][in] */ const OLECHAR __RPC_FAR *pwcsName,
            /* [unique][in] */ IStorage __RPC_FAR *pstgPriority,
            /* [in] */ DWORD grfMode,
            /* [unique][in] */ SNB snbExclude,
            /* [in] */ DWORD reserved,
            /* [out] */ IStorage __RPC_FAR *__RPC_FAR *ppstg) = 0;
        
        virtual HRESULT __stdcall CopyTo( 
            /* [in] */ DWORD ciidExclude,
            /* [size_is][unique][in] */ const IID __RPC_FAR *rgiidExclude,
            /* [unique][in] */ SNB snbExclude,
            /* [unique][in] */ IStorage __RPC_FAR *pstgDest) = 0;
        
        virtual HRESULT __stdcall MoveElementTo( 
            /* [string][in] */ const OLECHAR __RPC_FAR *pwcsName,
            /* [unique][in] */ IStorage __RPC_FAR *pstgDest,
            /* [string][in] */ const OLECHAR __RPC_FAR *pwcsNewName,
            /* [in] */ DWORD grfFlags) = 0;
        
        virtual HRESULT __stdcall Commit( 
            /* [in] */ DWORD grfCommitFlags) = 0;
        
        virtual HRESULT __stdcall Revert( void) = 0;
        
        virtual /* [local] */ HRESULT __stdcall EnumElements( 
            /* [in] */ DWORD reserved1,
            /* [size_is][unique][in] */ void __RPC_FAR *reserved2,
            /* [in] */ DWORD reserved3,
            /* [out] */ IEnumSTATSTG __RPC_FAR *__RPC_FAR *ppenum) = 0;
        
        virtual HRESULT __stdcall DestroyElement( 
            /* [string][in] */ const OLECHAR __RPC_FAR *pwcsName) = 0;
        
        virtual HRESULT __stdcall RenameElement( 
            /* [string][in] */ const OLECHAR __RPC_FAR *pwcsOldName,
            /* [string][in] */ const OLECHAR __RPC_FAR *pwcsNewName) = 0;
        
        virtual HRESULT __stdcall SetElementTimes( 
            /* [string][in] */ const OLECHAR __RPC_FAR *pwcsName,
            /* [in] */ const FILETIME __RPC_FAR *pctime,
            /* [in] */ const FILETIME __RPC_FAR *patime,
            /* [in] */ const FILETIME __RPC_FAR *pmtime) = 0;
        
        virtual HRESULT __stdcall SetClass( 
            /* [in] */ REFCLSID clsid) = 0;
        
        virtual HRESULT __stdcall SetStateBits( 
            /* [in] */ DWORD grfStateBits,
            /* [in] */ DWORD grfMask) = 0;
        
        virtual HRESULT __stdcall Stat( 
            /* [out] */ STATSTG __RPC_FAR *pstatstg,
            /* [in] */ DWORD grfStatFlag) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IStorageVtbl
    {
        
        HRESULT ( __stdcall __RPC_FAR *QueryInterface )( 
            IStorage __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( __stdcall __RPC_FAR *AddRef )( 
            IStorage __RPC_FAR * This);
        
        ULONG ( __stdcall __RPC_FAR *Release )( 
            IStorage __RPC_FAR * This);
        
        HRESULT ( __stdcall __RPC_FAR *CreateStream )( 
            IStorage __RPC_FAR * This,
            /* [string][in] */ const OLECHAR __RPC_FAR *pwcsName,
            /* [in] */ DWORD grfMode,
            /* [in] */ DWORD reserved1,
            /* [in] */ DWORD reserved2,
            /* [out] */ IStream __RPC_FAR *__RPC_FAR *ppstm);
        
        /* [local] */ HRESULT ( __stdcall __RPC_FAR *OpenStream )( 
            IStorage __RPC_FAR * This,
            /* [string][in] */ const OLECHAR __RPC_FAR *pwcsName,
            /* [unique][in] */ void __RPC_FAR *reserved1,
            /* [in] */ DWORD grfMode,
            /* [in] */ DWORD reserved2,
            /* [out] */ IStream __RPC_FAR *__RPC_FAR *ppstm);
        
        HRESULT ( __stdcall __RPC_FAR *CreateStorage )( 
            IStorage __RPC_FAR * This,
            /* [string][in] */ const OLECHAR __RPC_FAR *pwcsName,
            /* [in] */ DWORD grfMode,
            /* [in] */ DWORD dwStgFmt,
            /* [in] */ DWORD reserved2,
            /* [out] */ IStorage __RPC_FAR *__RPC_FAR *ppstg);
        
        HRESULT ( __stdcall __RPC_FAR *OpenStorage )( 
            IStorage __RPC_FAR * This,
            /* [string][unique][in] */ const OLECHAR __RPC_FAR *pwcsName,
            /* [unique][in] */ IStorage __RPC_FAR *pstgPriority,
            /* [in] */ DWORD grfMode,
            /* [unique][in] */ SNB snbExclude,
            /* [in] */ DWORD reserved,
            /* [out] */ IStorage __RPC_FAR *__RPC_FAR *ppstg);
        
        HRESULT ( __stdcall __RPC_FAR *CopyTo )( 
            IStorage __RPC_FAR * This,
            /* [in] */ DWORD ciidExclude,
            /* [size_is][unique][in] */ const IID __RPC_FAR *rgiidExclude,
            /* [unique][in] */ SNB snbExclude,
            /* [unique][in] */ IStorage __RPC_FAR *pstgDest);
        
        HRESULT ( __stdcall __RPC_FAR *MoveElementTo )( 
            IStorage __RPC_FAR * This,
            /* [string][in] */ const OLECHAR __RPC_FAR *pwcsName,
            /* [unique][in] */ IStorage __RPC_FAR *pstgDest,
            /* [string][in] */ const OLECHAR __RPC_FAR *pwcsNewName,
            /* [in] */ DWORD grfFlags);
        
        HRESULT ( __stdcall __RPC_FAR *Commit )( 
            IStorage __RPC_FAR * This,
            /* [in] */ DWORD grfCommitFlags);
        
        HRESULT ( __stdcall __RPC_FAR *Revert )( 
            IStorage __RPC_FAR * This);
        
        /* [local] */ HRESULT ( __stdcall __RPC_FAR *EnumElements )( 
            IStorage __RPC_FAR * This,
            /* [in] */ DWORD reserved1,
            /* [size_is][unique][in] */ void __RPC_FAR *reserved2,
            /* [in] */ DWORD reserved3,
            /* [out] */ IEnumSTATSTG __RPC_FAR *__RPC_FAR *ppenum);
        
        HRESULT ( __stdcall __RPC_FAR *DestroyElement )( 
            IStorage __RPC_FAR * This,
            /* [string][in] */ const OLECHAR __RPC_FAR *pwcsName);
        
        HRESULT ( __stdcall __RPC_FAR *RenameElement )( 
            IStorage __RPC_FAR * This,
            /* [string][in] */ const OLECHAR __RPC_FAR *pwcsOldName,
            /* [string][in] */ const OLECHAR __RPC_FAR *pwcsNewName);
        
        HRESULT ( __stdcall __RPC_FAR *SetElementTimes )( 
            IStorage __RPC_FAR * This,
            /* [string][in] */ const OLECHAR __RPC_FAR *pwcsName,
            /* [in] */ const FILETIME __RPC_FAR *pctime,
            /* [in] */ const FILETIME __RPC_FAR *patime,
            /* [in] */ const FILETIME __RPC_FAR *pmtime);
        
        HRESULT ( __stdcall __RPC_FAR *SetClass )( 
            IStorage __RPC_FAR * This,
            /* [in] */ REFCLSID clsid);
        
        HRESULT ( __stdcall __RPC_FAR *SetStateBits )( 
            IStorage __RPC_FAR * This,
            /* [in] */ DWORD grfStateBits,
            /* [in] */ DWORD grfMask);
        
        HRESULT ( __stdcall __RPC_FAR *Stat )( 
            IStorage __RPC_FAR * This,
            /* [out] */ STATSTG __RPC_FAR *pstatstg,
            /* [in] */ DWORD grfStatFlag);
        
    } IStorageVtbl;

    interface IStorage
    {
        CONST_VTBL struct IStorageVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IStorage_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IStorage_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IStorage_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IStorage_CreateStream(This,pwcsName,grfMode,reserved1,reserved2,ppstm)	\
    (This)->lpVtbl -> CreateStream(This,pwcsName,grfMode,reserved1,reserved2,ppstm)

#define IStorage_OpenStream(This,pwcsName,reserved1,grfMode,reserved2,ppstm)	\
    (This)->lpVtbl -> OpenStream(This,pwcsName,reserved1,grfMode,reserved2,ppstm)

#define IStorage_CreateStorage(This,pwcsName,grfMode,dwStgFmt,reserved2,ppstg)	\
    (This)->lpVtbl -> CreateStorage(This,pwcsName,grfMode,dwStgFmt,reserved2,ppstg)

#define IStorage_OpenStorage(This,pwcsName,pstgPriority,grfMode,snbExclude,reserved,ppstg)	\
    (This)->lpVtbl -> OpenStorage(This,pwcsName,pstgPriority,grfMode,snbExclude,reserved,ppstg)

#define IStorage_CopyTo(This,ciidExclude,rgiidExclude,snbExclude,pstgDest)	\
    (This)->lpVtbl -> CopyTo(This,ciidExclude,rgiidExclude,snbExclude,pstgDest)

#define IStorage_MoveElementTo(This,pwcsName,pstgDest,pwcsNewName,grfFlags)	\
    (This)->lpVtbl -> MoveElementTo(This,pwcsName,pstgDest,pwcsNewName,grfFlags)

#define IStorage_Commit(This,grfCommitFlags)	\
    (This)->lpVtbl -> Commit(This,grfCommitFlags)

#define IStorage_Revert(This)	\
    (This)->lpVtbl -> Revert(This)

#define IStorage_EnumElements(This,reserved1,reserved2,reserved3,ppenum)	\
    (This)->lpVtbl -> EnumElements(This,reserved1,reserved2,reserved3,ppenum)

#define IStorage_DestroyElement(This,pwcsName)	\
    (This)->lpVtbl -> DestroyElement(This,pwcsName)

#define IStorage_RenameElement(This,pwcsOldName,pwcsNewName)	\
    (This)->lpVtbl -> RenameElement(This,pwcsOldName,pwcsNewName)

#define IStorage_SetElementTimes(This,pwcsName,pctime,patime,pmtime)	\
    (This)->lpVtbl -> SetElementTimes(This,pwcsName,pctime,patime,pmtime)

#define IStorage_SetClass(This,clsid)	\
    (This)->lpVtbl -> SetClass(This,clsid)

#define IStorage_SetStateBits(This,grfStateBits,grfMask)	\
    (This)->lpVtbl -> SetStateBits(This,grfStateBits,grfMask)

#define IStorage_Stat(This,pstatstg,grfStatFlag)	\
    (This)->lpVtbl -> Stat(This,pstatstg,grfStatFlag)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT __stdcall IStorage_CreateStream_Proxy( 
    IStorage __RPC_FAR * This,
    /* [string][in] */ const OLECHAR __RPC_FAR *pwcsName,
    /* [in] */ DWORD grfMode,
    /* [in] */ DWORD reserved1,
    /* [in] */ DWORD reserved2,
    /* [out] */ IStream __RPC_FAR *__RPC_FAR *ppstm);


void __RPC_STUB IStorage_CreateStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT __stdcall IStorage_RemoteOpenStream_Proxy( 
    IStorage __RPC_FAR * This,
    /* [string][in] */ const OLECHAR __RPC_FAR *pwcsName,
    /* [in] */ unsigned long cbReserved1,
    /* [size_is][unique][in] */ byte __RPC_FAR *reserved1,
    /* [in] */ DWORD grfMode,
    /* [in] */ DWORD reserved2,
    /* [out] */ IStream __RPC_FAR *__RPC_FAR *ppstm);


void __RPC_STUB IStorage_RemoteOpenStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IStorage_CreateStorage_Proxy( 
    IStorage __RPC_FAR * This,
    /* [string][in] */ const OLECHAR __RPC_FAR *pwcsName,
    /* [in] */ DWORD grfMode,
    /* [in] */ DWORD dwStgFmt,
    /* [in] */ DWORD reserved2,
    /* [out] */ IStorage __RPC_FAR *__RPC_FAR *ppstg);


void __RPC_STUB IStorage_CreateStorage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IStorage_OpenStorage_Proxy( 
    IStorage __RPC_FAR * This,
    /* [string][unique][in] */ const OLECHAR __RPC_FAR *pwcsName,
    /* [unique][in] */ IStorage __RPC_FAR *pstgPriority,
    /* [in] */ DWORD grfMode,
    /* [unique][in] */ SNB snbExclude,
    /* [in] */ DWORD reserved,
    /* [out] */ IStorage __RPC_FAR *__RPC_FAR *ppstg);


void __RPC_STUB IStorage_OpenStorage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IStorage_CopyTo_Proxy( 
    IStorage __RPC_FAR * This,
    /* [in] */ DWORD ciidExclude,
    /* [size_is][unique][in] */ const IID __RPC_FAR *rgiidExclude,
    /* [unique][in] */ SNB snbExclude,
    /* [unique][in] */ IStorage __RPC_FAR *pstgDest);


void __RPC_STUB IStorage_CopyTo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IStorage_MoveElementTo_Proxy( 
    IStorage __RPC_FAR * This,
    /* [string][in] */ const OLECHAR __RPC_FAR *pwcsName,
    /* [unique][in] */ IStorage __RPC_FAR *pstgDest,
    /* [string][in] */ const OLECHAR __RPC_FAR *pwcsNewName,
    /* [in] */ DWORD grfFlags);


void __RPC_STUB IStorage_MoveElementTo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IStorage_Commit_Proxy( 
    IStorage __RPC_FAR * This,
    /* [in] */ DWORD grfCommitFlags);


void __RPC_STUB IStorage_Commit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IStorage_Revert_Proxy( 
    IStorage __RPC_FAR * This);


void __RPC_STUB IStorage_Revert_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT __stdcall IStorage_RemoteEnumElements_Proxy( 
    IStorage __RPC_FAR * This,
    /* [in] */ DWORD reserved1,
    /* [in] */ unsigned long cbReserved2,
    /* [size_is][unique][in] */ byte __RPC_FAR *reserved2,
    /* [in] */ DWORD reserved3,
    /* [out] */ IEnumSTATSTG __RPC_FAR *__RPC_FAR *ppenum);


void __RPC_STUB IStorage_RemoteEnumElements_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IStorage_DestroyElement_Proxy( 
    IStorage __RPC_FAR * This,
    /* [string][in] */ const OLECHAR __RPC_FAR *pwcsName);


void __RPC_STUB IStorage_DestroyElement_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IStorage_RenameElement_Proxy( 
    IStorage __RPC_FAR * This,
    /* [string][in] */ const OLECHAR __RPC_FAR *pwcsOldName,
    /* [string][in] */ const OLECHAR __RPC_FAR *pwcsNewName);


void __RPC_STUB IStorage_RenameElement_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IStorage_SetElementTimes_Proxy( 
    IStorage __RPC_FAR * This,
    /* [string][in] */ const OLECHAR __RPC_FAR *pwcsName,
    /* [in] */ const FILETIME __RPC_FAR *pctime,
    /* [in] */ const FILETIME __RPC_FAR *patime,
    /* [in] */ const FILETIME __RPC_FAR *pmtime);


void __RPC_STUB IStorage_SetElementTimes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IStorage_SetClass_Proxy( 
    IStorage __RPC_FAR * This,
    /* [in] */ REFCLSID clsid);


void __RPC_STUB IStorage_SetClass_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IStorage_SetStateBits_Proxy( 
    IStorage __RPC_FAR * This,
    /* [in] */ DWORD grfStateBits,
    /* [in] */ DWORD grfMask);


void __RPC_STUB IStorage_SetStateBits_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IStorage_Stat_Proxy( 
    IStorage __RPC_FAR * This,
    /* [out] */ STATSTG __RPC_FAR *pstatstg,
    /* [in] */ DWORD grfStatFlag);


void __RPC_STUB IStorage_Stat_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IStorage_INTERFACE_DEFINED__ */


#ifndef __IPersistFile_INTERFACE_DEFINED__
#define __IPersistFile_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IPersistFile
 * at Fri Apr 28 07:02:32 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [unique][uuid][object] */ 


			/* size is 4 */
typedef /* [unique] */ IPersistFile __RPC_FAR *LPPERSISTFILE;


EXTERN_C const IID IID_IPersistFile;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IPersistFile : public IPersist
    {
    public:
        virtual HRESULT __stdcall IsDirty( void) = 0;
        
        virtual HRESULT __stdcall Load( 
            /* [in] */ LPCOLESTR pszFileName,
            /* [in] */ DWORD dwMode) = 0;
        
        virtual HRESULT __stdcall Save( 
            /* [unique][in] */ LPCOLESTR pszFileName,
            /* [in] */ BOOL fRemember) = 0;
        
        virtual HRESULT __stdcall SaveCompleted( 
            /* [unique][in] */ LPCOLESTR pszFileName) = 0;
        
        virtual HRESULT __stdcall GetCurFile( 
            /* [out] */ LPOLESTR __RPC_FAR *ppszFileName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPersistFileVtbl
    {
        
        HRESULT ( __stdcall __RPC_FAR *QueryInterface )( 
            IPersistFile __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( __stdcall __RPC_FAR *AddRef )( 
            IPersistFile __RPC_FAR * This);
        
        ULONG ( __stdcall __RPC_FAR *Release )( 
            IPersistFile __RPC_FAR * This);
        
        HRESULT ( __stdcall __RPC_FAR *GetClassID )( 
            IPersistFile __RPC_FAR * This,
            /* [out] */ CLSID __RPC_FAR *pClassID);
        
        HRESULT ( __stdcall __RPC_FAR *IsDirty )( 
            IPersistFile __RPC_FAR * This);
        
        HRESULT ( __stdcall __RPC_FAR *Load )( 
            IPersistFile __RPC_FAR * This,
            /* [in] */ LPCOLESTR pszFileName,
            /* [in] */ DWORD dwMode);
        
        HRESULT ( __stdcall __RPC_FAR *Save )( 
            IPersistFile __RPC_FAR * This,
            /* [unique][in] */ LPCOLESTR pszFileName,
            /* [in] */ BOOL fRemember);
        
        HRESULT ( __stdcall __RPC_FAR *SaveCompleted )( 
            IPersistFile __RPC_FAR * This,
            /* [unique][in] */ LPCOLESTR pszFileName);
        
        HRESULT ( __stdcall __RPC_FAR *GetCurFile )( 
            IPersistFile __RPC_FAR * This,
            /* [out] */ LPOLESTR __RPC_FAR *ppszFileName);
        
    } IPersistFileVtbl;

    interface IPersistFile
    {
        CONST_VTBL struct IPersistFileVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPersistFile_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPersistFile_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPersistFile_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPersistFile_GetClassID(This,pClassID)	\
    (This)->lpVtbl -> GetClassID(This,pClassID)


#define IPersistFile_IsDirty(This)	\
    (This)->lpVtbl -> IsDirty(This)

#define IPersistFile_Load(This,pszFileName,dwMode)	\
    (This)->lpVtbl -> Load(This,pszFileName,dwMode)

#define IPersistFile_Save(This,pszFileName,fRemember)	\
    (This)->lpVtbl -> Save(This,pszFileName,fRemember)

#define IPersistFile_SaveCompleted(This,pszFileName)	\
    (This)->lpVtbl -> SaveCompleted(This,pszFileName)

#define IPersistFile_GetCurFile(This,ppszFileName)	\
    (This)->lpVtbl -> GetCurFile(This,ppszFileName)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT __stdcall IPersistFile_IsDirty_Proxy( 
    IPersistFile __RPC_FAR * This);


void __RPC_STUB IPersistFile_IsDirty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IPersistFile_Load_Proxy( 
    IPersistFile __RPC_FAR * This,
    /* [in] */ LPCOLESTR pszFileName,
    /* [in] */ DWORD dwMode);


void __RPC_STUB IPersistFile_Load_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IPersistFile_Save_Proxy( 
    IPersistFile __RPC_FAR * This,
    /* [unique][in] */ LPCOLESTR pszFileName,
    /* [in] */ BOOL fRemember);


void __RPC_STUB IPersistFile_Save_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IPersistFile_SaveCompleted_Proxy( 
    IPersistFile __RPC_FAR * This,
    /* [unique][in] */ LPCOLESTR pszFileName);


void __RPC_STUB IPersistFile_SaveCompleted_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IPersistFile_GetCurFile_Proxy( 
    IPersistFile __RPC_FAR * This,
    /* [out] */ LPOLESTR __RPC_FAR *ppszFileName);


void __RPC_STUB IPersistFile_GetCurFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IPersistFile_INTERFACE_DEFINED__ */


#ifndef __IPersistStorage_INTERFACE_DEFINED__
#define __IPersistStorage_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IPersistStorage
 * at Fri Apr 28 07:02:32 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [unique][uuid][object] */ 


			/* size is 4 */
typedef /* [unique] */ IPersistStorage __RPC_FAR *LPPERSISTSTORAGE;


EXTERN_C const IID IID_IPersistStorage;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IPersistStorage : public IPersist
    {
    public:
        virtual HRESULT __stdcall IsDirty( void) = 0;
        
        virtual HRESULT __stdcall InitNew( 
            /* [unique][in] */ IStorage __RPC_FAR *pStg) = 0;
        
        virtual HRESULT __stdcall Load( 
            /* [unique][in] */ IStorage __RPC_FAR *pStg) = 0;
        
        virtual HRESULT __stdcall Save( 
            /* [unique][in] */ IStorage __RPC_FAR *pStgSave,
            /* [in] */ BOOL fSameAsLoad) = 0;
        
        virtual HRESULT __stdcall SaveCompleted( 
            /* [unique][in] */ IStorage __RPC_FAR *pStgNew) = 0;
        
        virtual HRESULT __stdcall HandsOffStorage( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPersistStorageVtbl
    {
        
        HRESULT ( __stdcall __RPC_FAR *QueryInterface )( 
            IPersistStorage __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( __stdcall __RPC_FAR *AddRef )( 
            IPersistStorage __RPC_FAR * This);
        
        ULONG ( __stdcall __RPC_FAR *Release )( 
            IPersistStorage __RPC_FAR * This);
        
        HRESULT ( __stdcall __RPC_FAR *GetClassID )( 
            IPersistStorage __RPC_FAR * This,
            /* [out] */ CLSID __RPC_FAR *pClassID);
        
        HRESULT ( __stdcall __RPC_FAR *IsDirty )( 
            IPersistStorage __RPC_FAR * This);
        
        HRESULT ( __stdcall __RPC_FAR *InitNew )( 
            IPersistStorage __RPC_FAR * This,
            /* [unique][in] */ IStorage __RPC_FAR *pStg);
        
        HRESULT ( __stdcall __RPC_FAR *Load )( 
            IPersistStorage __RPC_FAR * This,
            /* [unique][in] */ IStorage __RPC_FAR *pStg);
        
        HRESULT ( __stdcall __RPC_FAR *Save )( 
            IPersistStorage __RPC_FAR * This,
            /* [unique][in] */ IStorage __RPC_FAR *pStgSave,
            /* [in] */ BOOL fSameAsLoad);
        
        HRESULT ( __stdcall __RPC_FAR *SaveCompleted )( 
            IPersistStorage __RPC_FAR * This,
            /* [unique][in] */ IStorage __RPC_FAR *pStgNew);
        
        HRESULT ( __stdcall __RPC_FAR *HandsOffStorage )( 
            IPersistStorage __RPC_FAR * This);
        
    } IPersistStorageVtbl;

    interface IPersistStorage
    {
        CONST_VTBL struct IPersistStorageVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPersistStorage_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPersistStorage_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPersistStorage_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPersistStorage_GetClassID(This,pClassID)	\
    (This)->lpVtbl -> GetClassID(This,pClassID)


#define IPersistStorage_IsDirty(This)	\
    (This)->lpVtbl -> IsDirty(This)

#define IPersistStorage_InitNew(This,pStg)	\
    (This)->lpVtbl -> InitNew(This,pStg)

#define IPersistStorage_Load(This,pStg)	\
    (This)->lpVtbl -> Load(This,pStg)

#define IPersistStorage_Save(This,pStgSave,fSameAsLoad)	\
    (This)->lpVtbl -> Save(This,pStgSave,fSameAsLoad)

#define IPersistStorage_SaveCompleted(This,pStgNew)	\
    (This)->lpVtbl -> SaveCompleted(This,pStgNew)

#define IPersistStorage_HandsOffStorage(This)	\
    (This)->lpVtbl -> HandsOffStorage(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT __stdcall IPersistStorage_IsDirty_Proxy( 
    IPersistStorage __RPC_FAR * This);


void __RPC_STUB IPersistStorage_IsDirty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IPersistStorage_InitNew_Proxy( 
    IPersistStorage __RPC_FAR * This,
    /* [unique][in] */ IStorage __RPC_FAR *pStg);


void __RPC_STUB IPersistStorage_InitNew_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IPersistStorage_Load_Proxy( 
    IPersistStorage __RPC_FAR * This,
    /* [unique][in] */ IStorage __RPC_FAR *pStg);


void __RPC_STUB IPersistStorage_Load_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IPersistStorage_Save_Proxy( 
    IPersistStorage __RPC_FAR * This,
    /* [unique][in] */ IStorage __RPC_FAR *pStgSave,
    /* [in] */ BOOL fSameAsLoad);


void __RPC_STUB IPersistStorage_Save_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IPersistStorage_SaveCompleted_Proxy( 
    IPersistStorage __RPC_FAR * This,
    /* [unique][in] */ IStorage __RPC_FAR *pStgNew);


void __RPC_STUB IPersistStorage_SaveCompleted_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IPersistStorage_HandsOffStorage_Proxy( 
    IPersistStorage __RPC_FAR * This);


void __RPC_STUB IPersistStorage_HandsOffStorage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IPersistStorage_INTERFACE_DEFINED__ */


#ifndef __ILockBytes_INTERFACE_DEFINED__
#define __ILockBytes_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ILockBytes
 * at Fri Apr 28 07:02:32 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [unique][uuid][object] */ 


			/* size is 4 */
typedef /* [unique] */ ILockBytes __RPC_FAR *LPLOCKBYTES;


EXTERN_C const IID IID_ILockBytes;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface ILockBytes : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT __stdcall ReadAt( 
            /* [in] */ ULARGE_INTEGER ulOffset,
            /* [in] */ void __RPC_FAR *pv,
            /* [in] */ ULONG cb,
            /* [out] */ ULONG __RPC_FAR *pcbRead) = 0;
        
        virtual /* [local] */ HRESULT __stdcall WriteAt( 
            /* [in] */ ULARGE_INTEGER ulOffset,
            /* [in] */ const void __RPC_FAR *pv,
            /* [in] */ ULONG cb,
            /* [out] */ ULONG __RPC_FAR *pcbWritten) = 0;
        
        virtual HRESULT __stdcall Flush( void) = 0;
        
        virtual HRESULT __stdcall SetSize( 
            /* [in] */ ULARGE_INTEGER cb) = 0;
        
        virtual HRESULT __stdcall LockRegion( 
            /* [in] */ ULARGE_INTEGER libOffset,
            /* [in] */ ULARGE_INTEGER cb,
            /* [in] */ DWORD dwLockType) = 0;
        
        virtual HRESULT __stdcall UnlockRegion( 
            /* [in] */ ULARGE_INTEGER libOffset,
            /* [in] */ ULARGE_INTEGER cb,
            /* [in] */ DWORD dwLockType) = 0;
        
        virtual HRESULT __stdcall Stat( 
            /* [out] */ STATSTG __RPC_FAR *pstatstg,
            /* [in] */ DWORD grfStatFlag) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ILockBytesVtbl
    {
        
        HRESULT ( __stdcall __RPC_FAR *QueryInterface )( 
            ILockBytes __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( __stdcall __RPC_FAR *AddRef )( 
            ILockBytes __RPC_FAR * This);
        
        ULONG ( __stdcall __RPC_FAR *Release )( 
            ILockBytes __RPC_FAR * This);
        
        /* [local] */ HRESULT ( __stdcall __RPC_FAR *ReadAt )( 
            ILockBytes __RPC_FAR * This,
            /* [in] */ ULARGE_INTEGER ulOffset,
            /* [in] */ void __RPC_FAR *pv,
            /* [in] */ ULONG cb,
            /* [out] */ ULONG __RPC_FAR *pcbRead);
        
        /* [local] */ HRESULT ( __stdcall __RPC_FAR *WriteAt )( 
            ILockBytes __RPC_FAR * This,
            /* [in] */ ULARGE_INTEGER ulOffset,
            /* [in] */ const void __RPC_FAR *pv,
            /* [in] */ ULONG cb,
            /* [out] */ ULONG __RPC_FAR *pcbWritten);
        
        HRESULT ( __stdcall __RPC_FAR *Flush )( 
            ILockBytes __RPC_FAR * This);
        
        HRESULT ( __stdcall __RPC_FAR *SetSize )( 
            ILockBytes __RPC_FAR * This,
            /* [in] */ ULARGE_INTEGER cb);
        
        HRESULT ( __stdcall __RPC_FAR *LockRegion )( 
            ILockBytes __RPC_FAR * This,
            /* [in] */ ULARGE_INTEGER libOffset,
            /* [in] */ ULARGE_INTEGER cb,
            /* [in] */ DWORD dwLockType);
        
        HRESULT ( __stdcall __RPC_FAR *UnlockRegion )( 
            ILockBytes __RPC_FAR * This,
            /* [in] */ ULARGE_INTEGER libOffset,
            /* [in] */ ULARGE_INTEGER cb,
            /* [in] */ DWORD dwLockType);
        
        HRESULT ( __stdcall __RPC_FAR *Stat )( 
            ILockBytes __RPC_FAR * This,
            /* [out] */ STATSTG __RPC_FAR *pstatstg,
            /* [in] */ DWORD grfStatFlag);
        
    } ILockBytesVtbl;

    interface ILockBytes
    {
        CONST_VTBL struct ILockBytesVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ILockBytes_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ILockBytes_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ILockBytes_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ILockBytes_ReadAt(This,ulOffset,pv,cb,pcbRead)	\
    (This)->lpVtbl -> ReadAt(This,ulOffset,pv,cb,pcbRead)

#define ILockBytes_WriteAt(This,ulOffset,pv,cb,pcbWritten)	\
    (This)->lpVtbl -> WriteAt(This,ulOffset,pv,cb,pcbWritten)

#define ILockBytes_Flush(This)	\
    (This)->lpVtbl -> Flush(This)

#define ILockBytes_SetSize(This,cb)	\
    (This)->lpVtbl -> SetSize(This,cb)

#define ILockBytes_LockRegion(This,libOffset,cb,dwLockType)	\
    (This)->lpVtbl -> LockRegion(This,libOffset,cb,dwLockType)

#define ILockBytes_UnlockRegion(This,libOffset,cb,dwLockType)	\
    (This)->lpVtbl -> UnlockRegion(This,libOffset,cb,dwLockType)

#define ILockBytes_Stat(This,pstatstg,grfStatFlag)	\
    (This)->lpVtbl -> Stat(This,pstatstg,grfStatFlag)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT __stdcall ILockBytes_RemoteReadAt_Proxy( 
    ILockBytes __RPC_FAR * This,
    /* [in] */ ULARGE_INTEGER ulOffset,
    /* [length_is][size_is][out] */ byte __RPC_FAR *pv,
    /* [in] */ ULONG cb,
    /* [out] */ ULONG __RPC_FAR *pcbRead);


void __RPC_STUB ILockBytes_RemoteReadAt_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT __stdcall ILockBytes_RemoteWriteAt_Proxy( 
    ILockBytes __RPC_FAR * This,
    /* [in] */ ULARGE_INTEGER ulOffset,
    /* [size_is][in] */ const byte __RPC_FAR *pv,
    /* [in] */ ULONG cb,
    /* [out] */ ULONG __RPC_FAR *pcbWritten);


void __RPC_STUB ILockBytes_RemoteWriteAt_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ILockBytes_Flush_Proxy( 
    ILockBytes __RPC_FAR * This);


void __RPC_STUB ILockBytes_Flush_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ILockBytes_SetSize_Proxy( 
    ILockBytes __RPC_FAR * This,
    /* [in] */ ULARGE_INTEGER cb);


void __RPC_STUB ILockBytes_SetSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ILockBytes_LockRegion_Proxy( 
    ILockBytes __RPC_FAR * This,
    /* [in] */ ULARGE_INTEGER libOffset,
    /* [in] */ ULARGE_INTEGER cb,
    /* [in] */ DWORD dwLockType);


void __RPC_STUB ILockBytes_LockRegion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ILockBytes_UnlockRegion_Proxy( 
    ILockBytes __RPC_FAR * This,
    /* [in] */ ULARGE_INTEGER libOffset,
    /* [in] */ ULARGE_INTEGER cb,
    /* [in] */ DWORD dwLockType);


void __RPC_STUB ILockBytes_UnlockRegion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ILockBytes_Stat_Proxy( 
    ILockBytes __RPC_FAR * This,
    /* [out] */ STATSTG __RPC_FAR *pstatstg,
    /* [in] */ DWORD grfStatFlag);


void __RPC_STUB ILockBytes_Stat_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ILockBytes_INTERFACE_DEFINED__ */


#ifndef __IEnumFORMATETC_INTERFACE_DEFINED__
#define __IEnumFORMATETC_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IEnumFORMATETC
 * at Fri Apr 28 07:02:32 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [unique][uuid][object] */ 


			/* size is 4 */
typedef /* [unique] */ IEnumFORMATETC __RPC_FAR *LPENUMFORMATETC;

			/* size is 12 */
typedef struct  tagDVTARGETDEVICE
    {
    DWORD tdSize;
    WORD tdDriverNameOffset;
    WORD tdDeviceNameOffset;
    WORD tdPortNameOffset;
    WORD tdExtDevmodeOffset;
    /* [size_is] */ BYTE tdData[ 1 ];
    }	DVTARGETDEVICE;

			/* size is 2 */
typedef WORD CLIPFORMAT;

			/* size is 4 */
typedef CLIPFORMAT __RPC_FAR *LPCLIPFORMAT;

			/* size is 20 */
typedef struct  tagFORMATETC
    {
    CLIPFORMAT cfFormat;
    /* [unique] */ DVTARGETDEVICE __RPC_FAR *ptd;
    DWORD dwAspect;
    LONG lindex;
    DWORD tymed;
    }	FORMATETC;

			/* size is 4 */
typedef struct tagFORMATETC __RPC_FAR *LPFORMATETC;


EXTERN_C const IID IID_IEnumFORMATETC;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IEnumFORMATETC : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT __stdcall Next( 
            /* [in] */ ULONG celt,
            /* [out] */ FORMATETC __RPC_FAR *rgelt,
            /* [out] */ ULONG __RPC_FAR *pceltFetched) = 0;
        
        virtual HRESULT __stdcall Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT __stdcall Reset( void) = 0;
        
        virtual HRESULT __stdcall Clone( 
            /* [out] */ IEnumFORMATETC __RPC_FAR *__RPC_FAR *ppenum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumFORMATETCVtbl
    {
        
        HRESULT ( __stdcall __RPC_FAR *QueryInterface )( 
            IEnumFORMATETC __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( __stdcall __RPC_FAR *AddRef )( 
            IEnumFORMATETC __RPC_FAR * This);
        
        ULONG ( __stdcall __RPC_FAR *Release )( 
            IEnumFORMATETC __RPC_FAR * This);
        
        /* [local] */ HRESULT ( __stdcall __RPC_FAR *Next )( 
            IEnumFORMATETC __RPC_FAR * This,
            /* [in] */ ULONG celt,
            /* [out] */ FORMATETC __RPC_FAR *rgelt,
            /* [out] */ ULONG __RPC_FAR *pceltFetched);
        
        HRESULT ( __stdcall __RPC_FAR *Skip )( 
            IEnumFORMATETC __RPC_FAR * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( __stdcall __RPC_FAR *Reset )( 
            IEnumFORMATETC __RPC_FAR * This);
        
        HRESULT ( __stdcall __RPC_FAR *Clone )( 
            IEnumFORMATETC __RPC_FAR * This,
            /* [out] */ IEnumFORMATETC __RPC_FAR *__RPC_FAR *ppenum);
        
    } IEnumFORMATETCVtbl;

    interface IEnumFORMATETC
    {
        CONST_VTBL struct IEnumFORMATETCVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumFORMATETC_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumFORMATETC_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumFORMATETC_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumFORMATETC_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IEnumFORMATETC_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumFORMATETC_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumFORMATETC_Clone(This,ppenum)	\
    (This)->lpVtbl -> Clone(This,ppenum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT __stdcall IEnumFORMATETC_RemoteNext_Proxy( 
    IEnumFORMATETC __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ FORMATETC __RPC_FAR *rgelt,
    /* [out] */ ULONG __RPC_FAR *pceltFetched);


void __RPC_STUB IEnumFORMATETC_RemoteNext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IEnumFORMATETC_Skip_Proxy( 
    IEnumFORMATETC __RPC_FAR * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IEnumFORMATETC_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IEnumFORMATETC_Reset_Proxy( 
    IEnumFORMATETC __RPC_FAR * This);


void __RPC_STUB IEnumFORMATETC_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IEnumFORMATETC_Clone_Proxy( 
    IEnumFORMATETC __RPC_FAR * This,
    /* [out] */ IEnumFORMATETC __RPC_FAR *__RPC_FAR *ppenum);


void __RPC_STUB IEnumFORMATETC_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumFORMATETC_INTERFACE_DEFINED__ */


#ifndef __IEnumSTATDATA_INTERFACE_DEFINED__
#define __IEnumSTATDATA_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IEnumSTATDATA
 * at Fri Apr 28 07:02:32 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [unique][uuid][object] */ 


			/* size is 4 */
typedef /* [unique] */ IEnumSTATDATA __RPC_FAR *LPENUMSTATDATA;

			/* size is 2 */
typedef 
enum tagADVF
    {	ADVF_NODATA	= 1,
	ADVF_PRIMEFIRST	= 2,
	ADVF_ONLYONCE	= 4,
	ADVF_DATAONSTOP	= 64,
	ADVFCACHE_NOHANDLER	= 8,
	ADVFCACHE_FORCEBUILTIN	= 16,
	ADVFCACHE_ONSAVE	= 32
    }	ADVF;

			/* size is 32 */
typedef struct  tagSTATDATA
    {
    FORMATETC formatetc;
    DWORD advf;
    /* [unique] */ IAdviseSink __RPC_FAR *pAdvSink;
    DWORD dwConnection;
    }	STATDATA;

			/* size is 4 */
typedef STATDATA __RPC_FAR *LPSTATDATA;


EXTERN_C const IID IID_IEnumSTATDATA;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IEnumSTATDATA : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT __stdcall Next( 
            /* [in] */ ULONG celt,
            STATDATA __RPC_FAR *rgelt,
            /* [out] */ ULONG __RPC_FAR *pceltFetched) = 0;
        
        virtual HRESULT __stdcall Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT __stdcall Reset( void) = 0;
        
        virtual HRESULT __stdcall Clone( 
            /* [out] */ IEnumSTATDATA __RPC_FAR *__RPC_FAR *ppenum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumSTATDATAVtbl
    {
        
        HRESULT ( __stdcall __RPC_FAR *QueryInterface )( 
            IEnumSTATDATA __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( __stdcall __RPC_FAR *AddRef )( 
            IEnumSTATDATA __RPC_FAR * This);
        
        ULONG ( __stdcall __RPC_FAR *Release )( 
            IEnumSTATDATA __RPC_FAR * This);
        
        /* [local] */ HRESULT ( __stdcall __RPC_FAR *Next )( 
            IEnumSTATDATA __RPC_FAR * This,
            /* [in] */ ULONG celt,
            STATDATA __RPC_FAR *rgelt,
            /* [out] */ ULONG __RPC_FAR *pceltFetched);
        
        HRESULT ( __stdcall __RPC_FAR *Skip )( 
            IEnumSTATDATA __RPC_FAR * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( __stdcall __RPC_FAR *Reset )( 
            IEnumSTATDATA __RPC_FAR * This);
        
        HRESULT ( __stdcall __RPC_FAR *Clone )( 
            IEnumSTATDATA __RPC_FAR * This,
            /* [out] */ IEnumSTATDATA __RPC_FAR *__RPC_FAR *ppenum);
        
    } IEnumSTATDATAVtbl;

    interface IEnumSTATDATA
    {
        CONST_VTBL struct IEnumSTATDATAVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumSTATDATA_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumSTATDATA_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumSTATDATA_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumSTATDATA_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IEnumSTATDATA_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumSTATDATA_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumSTATDATA_Clone(This,ppenum)	\
    (This)->lpVtbl -> Clone(This,ppenum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT __stdcall IEnumSTATDATA_RemoteNext_Proxy( 
    IEnumSTATDATA __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ STATDATA __RPC_FAR *rgelt,
    /* [out] */ ULONG __RPC_FAR *pceltFetched);


void __RPC_STUB IEnumSTATDATA_RemoteNext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IEnumSTATDATA_Skip_Proxy( 
    IEnumSTATDATA __RPC_FAR * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IEnumSTATDATA_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IEnumSTATDATA_Reset_Proxy( 
    IEnumSTATDATA __RPC_FAR * This);


void __RPC_STUB IEnumSTATDATA_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IEnumSTATDATA_Clone_Proxy( 
    IEnumSTATDATA __RPC_FAR * This,
    /* [out] */ IEnumSTATDATA __RPC_FAR *__RPC_FAR *ppenum);


void __RPC_STUB IEnumSTATDATA_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumSTATDATA_INTERFACE_DEFINED__ */


#ifndef __IRootStorage_INTERFACE_DEFINED__
#define __IRootStorage_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IRootStorage
 * at Fri Apr 28 07:02:32 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [unique][uuid][object] */ 


			/* size is 4 */
typedef /* [unique] */ IRootStorage __RPC_FAR *LPROOTSTORAGE;


EXTERN_C const IID IID_IRootStorage;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IRootStorage : public IUnknown
    {
    public:
        virtual HRESULT __stdcall SwitchToFile( 
            /* [string][in] */ LPOLESTR pszFile) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRootStorageVtbl
    {
        
        HRESULT ( __stdcall __RPC_FAR *QueryInterface )( 
            IRootStorage __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( __stdcall __RPC_FAR *AddRef )( 
            IRootStorage __RPC_FAR * This);
        
        ULONG ( __stdcall __RPC_FAR *Release )( 
            IRootStorage __RPC_FAR * This);
        
        HRESULT ( __stdcall __RPC_FAR *SwitchToFile )( 
            IRootStorage __RPC_FAR * This,
            /* [string][in] */ LPOLESTR pszFile);
        
    } IRootStorageVtbl;

    interface IRootStorage
    {
        CONST_VTBL struct IRootStorageVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRootStorage_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRootStorage_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRootStorage_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRootStorage_SwitchToFile(This,pszFile)	\
    (This)->lpVtbl -> SwitchToFile(This,pszFile)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT __stdcall IRootStorage_SwitchToFile_Proxy( 
    IRootStorage __RPC_FAR * This,
    /* [string][in] */ LPOLESTR pszFile);


void __RPC_STUB IRootStorage_SwitchToFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRootStorage_INTERFACE_DEFINED__ */


#ifndef __IAdviseSink_INTERFACE_DEFINED__
#define __IAdviseSink_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IAdviseSink
 * at Fri Apr 28 07:02:32 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [unique][uuid][object] */ 


			/* size is 4 */
typedef IAdviseSink __RPC_FAR *LPADVISESINK;

			/* size is 2 */
typedef /* [v1_enum] */ 
enum tagTYMED
    {	TYMED_HGLOBAL	= 1,
	TYMED_FILE	= 2,
	TYMED_ISTREAM	= 4,
	TYMED_ISTORAGE	= 8,
	TYMED_GDI	= 16,
	TYMED_MFPICT	= 32,
	TYMED_ENHMF	= 64,
	TYMED_NULL	= 0
    }	TYMED;

#ifndef RC_INVOKED
#pragma warning(disable:4200)
#endif
			/* size is 20 */
typedef struct  tagRemSTGMEDIUM
    {
    DWORD tymed;
    DWORD dwHandleType;
    unsigned long pData;
    unsigned long pUnkForRelease;
    unsigned long cbData;
    /* [size_is] */ byte data[ 1 ];
    }	RemSTGMEDIUM;

#ifndef RC_INVOKED
#pragma warning(default:4200)
#endif
#ifdef NONAMELESSUNION
typedef struct tagSTGMEDIUM {
    DWORD tymed;
    union {
        HBITMAP hBitmap;
        HMETAFILEPICT hMetaFilePict;
        HENHMETAFILE hEnhMetaFile;
        HGLOBAL hGlobal;
        LPOLESTR lpszFileName;
        IStream *pstm;
        IStorage *pstg;
        } u;
    IUnknown *pUnkForRelease;
}STGMEDIUM;
#else
			/* size is 12 */
typedef struct  tagSTGMEDIUM
    {
    DWORD tymed;
    /* [switch_is][switch_type] */ union 
        {
        /* [case] */ HBITMAP hBitmap;
        /* [case] */ HMETAFILEPICT hMetaFilePict;
        /* [case] */ HENHMETAFILE hEnhMetaFile;
        /* [case] */ HGLOBAL hGlobal;
        /* [case] */ LPOLESTR lpszFileName;
        /* [case] */ IStream __RPC_FAR *pstm;
        /* [case] */ IStorage __RPC_FAR *pstg;
        /* [default] */  /* Empty union arm */ 
        }	;
    /* [unique] */ IUnknown __RPC_FAR *pUnkForRelease;
    }	STGMEDIUM;

#endif /* !NONAMELESSUNION */
			/* size is 4 */
typedef STGMEDIUM __RPC_FAR *LPSTGMEDIUM;


EXTERN_C const IID IID_IAdviseSink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IAdviseSink : public IUnknown
    {
    public:
        virtual /* [local] */ void __stdcall OnDataChange( 
            /* [unique][in] */ FORMATETC __RPC_FAR *pFormatetc,
            /* [unique][in] */ STGMEDIUM __RPC_FAR *pStgmed) = 0;
        
        virtual /* [local] */ void __stdcall OnViewChange( 
            /* [in] */ DWORD dwAspect,
            /* [in] */ LONG lindex) = 0;
        
        virtual /* [local] */ void __stdcall OnRename( 
            /* [in] */ IMoniker __RPC_FAR *pmk) = 0;
        
        virtual /* [local] */ void __stdcall OnSave( void) = 0;
        
        virtual /* [local] */ void __stdcall OnClose( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAdviseSinkVtbl
    {
        
        HRESULT ( __stdcall __RPC_FAR *QueryInterface )( 
            IAdviseSink __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( __stdcall __RPC_FAR *AddRef )( 
            IAdviseSink __RPC_FAR * This);
        
        ULONG ( __stdcall __RPC_FAR *Release )( 
            IAdviseSink __RPC_FAR * This);
        
        /* [local] */ void ( __stdcall __RPC_FAR *OnDataChange )( 
            IAdviseSink __RPC_FAR * This,
            /* [unique][in] */ FORMATETC __RPC_FAR *pFormatetc,
            /* [unique][in] */ STGMEDIUM __RPC_FAR *pStgmed);
        
        /* [local] */ void ( __stdcall __RPC_FAR *OnViewChange )( 
            IAdviseSink __RPC_FAR * This,
            /* [in] */ DWORD dwAspect,
            /* [in] */ LONG lindex);
        
        /* [local] */ void ( __stdcall __RPC_FAR *OnRename )( 
            IAdviseSink __RPC_FAR * This,
            /* [in] */ IMoniker __RPC_FAR *pmk);
        
        /* [local] */ void ( __stdcall __RPC_FAR *OnSave )( 
            IAdviseSink __RPC_FAR * This);
        
        /* [local] */ void ( __stdcall __RPC_FAR *OnClose )( 
            IAdviseSink __RPC_FAR * This);
        
    } IAdviseSinkVtbl;

    interface IAdviseSink
    {
        CONST_VTBL struct IAdviseSinkVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAdviseSink_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAdviseSink_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAdviseSink_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAdviseSink_OnDataChange(This,pFormatetc,pStgmed)	\
    (This)->lpVtbl -> OnDataChange(This,pFormatetc,pStgmed)

#define IAdviseSink_OnViewChange(This,dwAspect,lindex)	\
    (This)->lpVtbl -> OnViewChange(This,dwAspect,lindex)

#define IAdviseSink_OnRename(This,pmk)	\
    (This)->lpVtbl -> OnRename(This,pmk)

#define IAdviseSink_OnSave(This)	\
    (This)->lpVtbl -> OnSave(This)

#define IAdviseSink_OnClose(This)	\
    (This)->lpVtbl -> OnClose(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [async][call_as] */ void __stdcall IAdviseSink_RemoteOnDataChange_Proxy( 
    IAdviseSink __RPC_FAR * This,
    /* [unique][in] */ FORMATETC __RPC_FAR *pFormatetc,
    /* [unique][in] */ RemSTGMEDIUM __RPC_FAR *pStgmed);


void __RPC_STUB IAdviseSink_RemoteOnDataChange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [async][call_as] */ void __stdcall IAdviseSink_RemoteOnViewChange_Proxy( 
    IAdviseSink __RPC_FAR * This,
    /* [in] */ DWORD dwAspect,
    /* [in] */ LONG lindex);


void __RPC_STUB IAdviseSink_RemoteOnViewChange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [async][call_as] */ void __stdcall IAdviseSink_RemoteOnRename_Proxy( 
    IAdviseSink __RPC_FAR * This,
    /* [in] */ IMoniker __RPC_FAR *pmk);


void __RPC_STUB IAdviseSink_RemoteOnRename_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [async][call_as] */ void __stdcall IAdviseSink_RemoteOnSave_Proxy( 
    IAdviseSink __RPC_FAR * This);


void __RPC_STUB IAdviseSink_RemoteOnSave_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT __stdcall IAdviseSink_RemoteOnClose_Proxy( 
    IAdviseSink __RPC_FAR * This);


void __RPC_STUB IAdviseSink_RemoteOnClose_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAdviseSink_INTERFACE_DEFINED__ */


#ifndef __IAdviseSink2_INTERFACE_DEFINED__
#define __IAdviseSink2_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IAdviseSink2
 * at Fri Apr 28 07:02:32 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [unique][uuid][object] */ 


			/* size is 4 */
typedef /* [unique] */ IAdviseSink2 __RPC_FAR *LPADVISESINK2;


EXTERN_C const IID IID_IAdviseSink2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IAdviseSink2 : public IAdviseSink
    {
    public:
        virtual /* [local] */ void __stdcall OnLinkSrcChange( 
            /* [unique][in] */ IMoniker __RPC_FAR *pmk) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAdviseSink2Vtbl
    {
        
        HRESULT ( __stdcall __RPC_FAR *QueryInterface )( 
            IAdviseSink2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( __stdcall __RPC_FAR *AddRef )( 
            IAdviseSink2 __RPC_FAR * This);
        
        ULONG ( __stdcall __RPC_FAR *Release )( 
            IAdviseSink2 __RPC_FAR * This);
        
        /* [local] */ void ( __stdcall __RPC_FAR *OnDataChange )( 
            IAdviseSink2 __RPC_FAR * This,
            /* [unique][in] */ FORMATETC __RPC_FAR *pFormatetc,
            /* [unique][in] */ STGMEDIUM __RPC_FAR *pStgmed);
        
        /* [local] */ void ( __stdcall __RPC_FAR *OnViewChange )( 
            IAdviseSink2 __RPC_FAR * This,
            /* [in] */ DWORD dwAspect,
            /* [in] */ LONG lindex);
        
        /* [local] */ void ( __stdcall __RPC_FAR *OnRename )( 
            IAdviseSink2 __RPC_FAR * This,
            /* [in] */ IMoniker __RPC_FAR *pmk);
        
        /* [local] */ void ( __stdcall __RPC_FAR *OnSave )( 
            IAdviseSink2 __RPC_FAR * This);
        
        /* [local] */ void ( __stdcall __RPC_FAR *OnClose )( 
            IAdviseSink2 __RPC_FAR * This);
        
        /* [local] */ void ( __stdcall __RPC_FAR *OnLinkSrcChange )( 
            IAdviseSink2 __RPC_FAR * This,
            /* [unique][in] */ IMoniker __RPC_FAR *pmk);
        
    } IAdviseSink2Vtbl;

    interface IAdviseSink2
    {
        CONST_VTBL struct IAdviseSink2Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAdviseSink2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAdviseSink2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAdviseSink2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAdviseSink2_OnDataChange(This,pFormatetc,pStgmed)	\
    (This)->lpVtbl -> OnDataChange(This,pFormatetc,pStgmed)

#define IAdviseSink2_OnViewChange(This,dwAspect,lindex)	\
    (This)->lpVtbl -> OnViewChange(This,dwAspect,lindex)

#define IAdviseSink2_OnRename(This,pmk)	\
    (This)->lpVtbl -> OnRename(This,pmk)

#define IAdviseSink2_OnSave(This)	\
    (This)->lpVtbl -> OnSave(This)

#define IAdviseSink2_OnClose(This)	\
    (This)->lpVtbl -> OnClose(This)


#define IAdviseSink2_OnLinkSrcChange(This,pmk)	\
    (This)->lpVtbl -> OnLinkSrcChange(This,pmk)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [async][call_as] */ void __stdcall IAdviseSink2_RemoteOnLinkSrcChange_Proxy( 
    IAdviseSink2 __RPC_FAR * This,
    /* [unique][in] */ IMoniker __RPC_FAR *pmk);


void __RPC_STUB IAdviseSink2_RemoteOnLinkSrcChange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAdviseSink2_INTERFACE_DEFINED__ */


#ifndef __IDataObject_INTERFACE_DEFINED__
#define __IDataObject_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IDataObject
 * at Fri Apr 28 07:02:32 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [unique][uuid][object] */ 


			/* size is 4 */
typedef /* [unique] */ IDataObject __RPC_FAR *LPDATAOBJECT;

			/* size is 2 */
typedef 
enum tagDATADIR
    {	DATADIR_GET	= 1,
	DATADIR_SET	= 2
    }	DATADIR;


EXTERN_C const IID IID_IDataObject;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IDataObject : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT __stdcall GetData( 
            /* [unique][in] */ FORMATETC __RPC_FAR *pformatetcIn,
            /* [out] */ STGMEDIUM __RPC_FAR *pmedium) = 0;
        
        virtual /* [local] */ HRESULT __stdcall GetDataHere( 
            /* [unique][in] */ FORMATETC __RPC_FAR *pformatetc,
            /* [out][in] */ STGMEDIUM __RPC_FAR *pmedium) = 0;
        
        virtual HRESULT __stdcall QueryGetData( 
            /* [unique][in] */ FORMATETC __RPC_FAR *pformatetc) = 0;
        
        virtual HRESULT __stdcall GetCanonicalFormatEtc( 
            /* [unique][in] */ FORMATETC __RPC_FAR *pformatectIn,
            /* [out] */ FORMATETC __RPC_FAR *pformatetcOut) = 0;
        
        virtual /* [local] */ HRESULT __stdcall SetData( 
            /* [unique][in] */ FORMATETC __RPC_FAR *pformatetc,
            /* [unique][in] */ STGMEDIUM __RPC_FAR *pmedium,
            /* [in] */ BOOL fRelease) = 0;
        
        virtual HRESULT __stdcall EnumFormatEtc( 
            /* [in] */ DWORD dwDirection,
            /* [out] */ IEnumFORMATETC __RPC_FAR *__RPC_FAR *ppenumFormatEtc) = 0;
        
        virtual HRESULT __stdcall DAdvise( 
            /* [in] */ FORMATETC __RPC_FAR *pformatetc,
            /* [in] */ DWORD advf,
            /* [unique][in] */ IAdviseSink __RPC_FAR *pAdvSink,
            /* [out] */ DWORD __RPC_FAR *pdwConnection) = 0;
        
        virtual HRESULT __stdcall DUnadvise( 
            /* [in] */ DWORD dwConnection) = 0;
        
        virtual HRESULT __stdcall EnumDAdvise( 
            /* [out] */ IEnumSTATDATA __RPC_FAR *__RPC_FAR *ppenumAdvise) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDataObjectVtbl
    {
        
        HRESULT ( __stdcall __RPC_FAR *QueryInterface )( 
            IDataObject __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( __stdcall __RPC_FAR *AddRef )( 
            IDataObject __RPC_FAR * This);
        
        ULONG ( __stdcall __RPC_FAR *Release )( 
            IDataObject __RPC_FAR * This);
        
        /* [local] */ HRESULT ( __stdcall __RPC_FAR *GetData )( 
            IDataObject __RPC_FAR * This,
            /* [unique][in] */ FORMATETC __RPC_FAR *pformatetcIn,
            /* [out] */ STGMEDIUM __RPC_FAR *pmedium);
        
        /* [local] */ HRESULT ( __stdcall __RPC_FAR *GetDataHere )( 
            IDataObject __RPC_FAR * This,
            /* [unique][in] */ FORMATETC __RPC_FAR *pformatetc,
            /* [out][in] */ STGMEDIUM __RPC_FAR *pmedium);
        
        HRESULT ( __stdcall __RPC_FAR *QueryGetData )( 
            IDataObject __RPC_FAR * This,
            /* [unique][in] */ FORMATETC __RPC_FAR *pformatetc);
        
        HRESULT ( __stdcall __RPC_FAR *GetCanonicalFormatEtc )( 
            IDataObject __RPC_FAR * This,
            /* [unique][in] */ FORMATETC __RPC_FAR *pformatectIn,
            /* [out] */ FORMATETC __RPC_FAR *pformatetcOut);
        
        /* [local] */ HRESULT ( __stdcall __RPC_FAR *SetData )( 
            IDataObject __RPC_FAR * This,
            /* [unique][in] */ FORMATETC __RPC_FAR *pformatetc,
            /* [unique][in] */ STGMEDIUM __RPC_FAR *pmedium,
            /* [in] */ BOOL fRelease);
        
        HRESULT ( __stdcall __RPC_FAR *EnumFormatEtc )( 
            IDataObject __RPC_FAR * This,
            /* [in] */ DWORD dwDirection,
            /* [out] */ IEnumFORMATETC __RPC_FAR *__RPC_FAR *ppenumFormatEtc);
        
        HRESULT ( __stdcall __RPC_FAR *DAdvise )( 
            IDataObject __RPC_FAR * This,
            /* [in] */ FORMATETC __RPC_FAR *pformatetc,
            /* [in] */ DWORD advf,
            /* [unique][in] */ IAdviseSink __RPC_FAR *pAdvSink,
            /* [out] */ DWORD __RPC_FAR *pdwConnection);
        
        HRESULT ( __stdcall __RPC_FAR *DUnadvise )( 
            IDataObject __RPC_FAR * This,
            /* [in] */ DWORD dwConnection);
        
        HRESULT ( __stdcall __RPC_FAR *EnumDAdvise )( 
            IDataObject __RPC_FAR * This,
            /* [out] */ IEnumSTATDATA __RPC_FAR *__RPC_FAR *ppenumAdvise);
        
    } IDataObjectVtbl;

    interface IDataObject
    {
        CONST_VTBL struct IDataObjectVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDataObject_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDataObject_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDataObject_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDataObject_GetData(This,pformatetcIn,pmedium)	\
    (This)->lpVtbl -> GetData(This,pformatetcIn,pmedium)

#define IDataObject_GetDataHere(This,pformatetc,pmedium)	\
    (This)->lpVtbl -> GetDataHere(This,pformatetc,pmedium)

#define IDataObject_QueryGetData(This,pformatetc)	\
    (This)->lpVtbl -> QueryGetData(This,pformatetc)

#define IDataObject_GetCanonicalFormatEtc(This,pformatectIn,pformatetcOut)	\
    (This)->lpVtbl -> GetCanonicalFormatEtc(This,pformatectIn,pformatetcOut)

#define IDataObject_SetData(This,pformatetc,pmedium,fRelease)	\
    (This)->lpVtbl -> SetData(This,pformatetc,pmedium,fRelease)

#define IDataObject_EnumFormatEtc(This,dwDirection,ppenumFormatEtc)	\
    (This)->lpVtbl -> EnumFormatEtc(This,dwDirection,ppenumFormatEtc)

#define IDataObject_DAdvise(This,pformatetc,advf,pAdvSink,pdwConnection)	\
    (This)->lpVtbl -> DAdvise(This,pformatetc,advf,pAdvSink,pdwConnection)

#define IDataObject_DUnadvise(This,dwConnection)	\
    (This)->lpVtbl -> DUnadvise(This,dwConnection)

#define IDataObject_EnumDAdvise(This,ppenumAdvise)	\
    (This)->lpVtbl -> EnumDAdvise(This,ppenumAdvise)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT __stdcall IDataObject_RemoteGetData_Proxy( 
    IDataObject __RPC_FAR * This,
    /* [unique][in] */ FORMATETC __RPC_FAR *pformatetcIn,
    /* [out] */ RemSTGMEDIUM __RPC_FAR *__RPC_FAR *ppRemoteMedium);


void __RPC_STUB IDataObject_RemoteGetData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT __stdcall IDataObject_RemoteGetDataHere_Proxy( 
    IDataObject __RPC_FAR * This,
    /* [unique][in] */ FORMATETC __RPC_FAR *pformatetc,
    /* [out][in] */ RemSTGMEDIUM __RPC_FAR *__RPC_FAR *ppRemoteMedium);


void __RPC_STUB IDataObject_RemoteGetDataHere_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IDataObject_QueryGetData_Proxy( 
    IDataObject __RPC_FAR * This,
    /* [unique][in] */ FORMATETC __RPC_FAR *pformatetc);


void __RPC_STUB IDataObject_QueryGetData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IDataObject_GetCanonicalFormatEtc_Proxy( 
    IDataObject __RPC_FAR * This,
    /* [unique][in] */ FORMATETC __RPC_FAR *pformatectIn,
    /* [out] */ FORMATETC __RPC_FAR *pformatetcOut);


void __RPC_STUB IDataObject_GetCanonicalFormatEtc_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT __stdcall IDataObject_RemoteSetData_Proxy( 
    IDataObject __RPC_FAR * This,
    /* [unique][in] */ FORMATETC __RPC_FAR *pformatetc,
    /* [unique][in] */ RemSTGMEDIUM __RPC_FAR *pmedium,
    /* [in] */ BOOL fRelease);


void __RPC_STUB IDataObject_RemoteSetData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IDataObject_EnumFormatEtc_Proxy( 
    IDataObject __RPC_FAR * This,
    /* [in] */ DWORD dwDirection,
    /* [out] */ IEnumFORMATETC __RPC_FAR *__RPC_FAR *ppenumFormatEtc);


void __RPC_STUB IDataObject_EnumFormatEtc_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IDataObject_DAdvise_Proxy( 
    IDataObject __RPC_FAR * This,
    /* [in] */ FORMATETC __RPC_FAR *pformatetc,
    /* [in] */ DWORD advf,
    /* [unique][in] */ IAdviseSink __RPC_FAR *pAdvSink,
    /* [out] */ DWORD __RPC_FAR *pdwConnection);


void __RPC_STUB IDataObject_DAdvise_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IDataObject_DUnadvise_Proxy( 
    IDataObject __RPC_FAR * This,
    /* [in] */ DWORD dwConnection);


void __RPC_STUB IDataObject_DUnadvise_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IDataObject_EnumDAdvise_Proxy( 
    IDataObject __RPC_FAR * This,
    /* [out] */ IEnumSTATDATA __RPC_FAR *__RPC_FAR *ppenumAdvise);


void __RPC_STUB IDataObject_EnumDAdvise_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDataObject_INTERFACE_DEFINED__ */


#ifndef __IDataAdviseHolder_INTERFACE_DEFINED__
#define __IDataAdviseHolder_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IDataAdviseHolder
 * at Fri Apr 28 07:02:32 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [uuid][object][local] */ 


			/* size is 4 */
typedef /* [unique] */ IDataAdviseHolder __RPC_FAR *LPDATAADVISEHOLDER;


EXTERN_C const IID IID_IDataAdviseHolder;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IDataAdviseHolder : public IUnknown
    {
    public:
        virtual HRESULT __stdcall Advise( 
            /* [unique][in] */ IDataObject __RPC_FAR *pDataObject,
            /* [unique][in] */ FORMATETC __RPC_FAR *pFetc,
            /* [in] */ DWORD advf,
            /* [unique][in] */ IAdviseSink __RPC_FAR *pAdvise,
            /* [out] */ DWORD __RPC_FAR *pdwConnection) = 0;
        
        virtual HRESULT __stdcall Unadvise( 
            /* [in] */ DWORD dwConnection) = 0;
        
        virtual HRESULT __stdcall EnumAdvise( 
            /* [out] */ IEnumSTATDATA __RPC_FAR *__RPC_FAR *ppenumAdvise) = 0;
        
        virtual HRESULT __stdcall SendOnDataChange( 
            /* [unique][in] */ IDataObject __RPC_FAR *pDataObject,
            /* [in] */ DWORD dwReserved,
            /* [in] */ DWORD advf) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDataAdviseHolderVtbl
    {
        
        HRESULT ( __stdcall __RPC_FAR *QueryInterface )( 
            IDataAdviseHolder __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( __stdcall __RPC_FAR *AddRef )( 
            IDataAdviseHolder __RPC_FAR * This);
        
        ULONG ( __stdcall __RPC_FAR *Release )( 
            IDataAdviseHolder __RPC_FAR * This);
        
        HRESULT ( __stdcall __RPC_FAR *Advise )( 
            IDataAdviseHolder __RPC_FAR * This,
            /* [unique][in] */ IDataObject __RPC_FAR *pDataObject,
            /* [unique][in] */ FORMATETC __RPC_FAR *pFetc,
            /* [in] */ DWORD advf,
            /* [unique][in] */ IAdviseSink __RPC_FAR *pAdvise,
            /* [out] */ DWORD __RPC_FAR *pdwConnection);
        
        HRESULT ( __stdcall __RPC_FAR *Unadvise )( 
            IDataAdviseHolder __RPC_FAR * This,
            /* [in] */ DWORD dwConnection);
        
        HRESULT ( __stdcall __RPC_FAR *EnumAdvise )( 
            IDataAdviseHolder __RPC_FAR * This,
            /* [out] */ IEnumSTATDATA __RPC_FAR *__RPC_FAR *ppenumAdvise);
        
        HRESULT ( __stdcall __RPC_FAR *SendOnDataChange )( 
            IDataAdviseHolder __RPC_FAR * This,
            /* [unique][in] */ IDataObject __RPC_FAR *pDataObject,
            /* [in] */ DWORD dwReserved,
            /* [in] */ DWORD advf);
        
    } IDataAdviseHolderVtbl;

    interface IDataAdviseHolder
    {
        CONST_VTBL struct IDataAdviseHolderVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDataAdviseHolder_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDataAdviseHolder_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDataAdviseHolder_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDataAdviseHolder_Advise(This,pDataObject,pFetc,advf,pAdvise,pdwConnection)	\
    (This)->lpVtbl -> Advise(This,pDataObject,pFetc,advf,pAdvise,pdwConnection)

#define IDataAdviseHolder_Unadvise(This,dwConnection)	\
    (This)->lpVtbl -> Unadvise(This,dwConnection)

#define IDataAdviseHolder_EnumAdvise(This,ppenumAdvise)	\
    (This)->lpVtbl -> EnumAdvise(This,ppenumAdvise)

#define IDataAdviseHolder_SendOnDataChange(This,pDataObject,dwReserved,advf)	\
    (This)->lpVtbl -> SendOnDataChange(This,pDataObject,dwReserved,advf)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT __stdcall IDataAdviseHolder_Advise_Proxy( 
    IDataAdviseHolder __RPC_FAR * This,
    /* [unique][in] */ IDataObject __RPC_FAR *pDataObject,
    /* [unique][in] */ FORMATETC __RPC_FAR *pFetc,
    /* [in] */ DWORD advf,
    /* [unique][in] */ IAdviseSink __RPC_FAR *pAdvise,
    /* [out] */ DWORD __RPC_FAR *pdwConnection);


void __RPC_STUB IDataAdviseHolder_Advise_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IDataAdviseHolder_Unadvise_Proxy( 
    IDataAdviseHolder __RPC_FAR * This,
    /* [in] */ DWORD dwConnection);


void __RPC_STUB IDataAdviseHolder_Unadvise_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IDataAdviseHolder_EnumAdvise_Proxy( 
    IDataAdviseHolder __RPC_FAR * This,
    /* [out] */ IEnumSTATDATA __RPC_FAR *__RPC_FAR *ppenumAdvise);


void __RPC_STUB IDataAdviseHolder_EnumAdvise_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IDataAdviseHolder_SendOnDataChange_Proxy( 
    IDataAdviseHolder __RPC_FAR * This,
    /* [unique][in] */ IDataObject __RPC_FAR *pDataObject,
    /* [in] */ DWORD dwReserved,
    /* [in] */ DWORD advf);


void __RPC_STUB IDataAdviseHolder_SendOnDataChange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDataAdviseHolder_INTERFACE_DEFINED__ */


#ifndef __IMessageFilter_INTERFACE_DEFINED__
#define __IMessageFilter_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IMessageFilter
 * at Fri Apr 28 07:02:32 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [uuid][object][local] */ 


			/* size is 4 */
typedef /* [unique] */ IMessageFilter __RPC_FAR *LPMESSAGEFILTER;

			/* size is 2 */
typedef 
enum tagCALLTYPE
    {	CALLTYPE_TOPLEVEL	= 1,
	CALLTYPE_NESTED	= 2,
	CALLTYPE_ASYNC	= 3,
	CALLTYPE_TOPLEVEL_CALLPENDING	= 4,
	CALLTYPE_ASYNC_CALLPENDING	= 5
    }	CALLTYPE;

			/* size is 2 */
typedef 
enum tagSERVERCALL
    {	SERVERCALL_ISHANDLED	= 0,
	SERVERCALL_REJECTED	= 1,
	SERVERCALL_RETRYLATER	= 2
    }	SERVERCALL;

			/* size is 2 */
typedef 
enum tagPENDINGTYPE
    {	PENDINGTYPE_TOPLEVEL	= 1,
	PENDINGTYPE_NESTED	= 2
    }	PENDINGTYPE;

			/* size is 2 */
typedef 
enum tagPENDINGMSG
    {	PENDINGMSG_CANCELCALL	= 0,
	PENDINGMSG_WAITNOPROCESS	= 1,
	PENDINGMSG_WAITDEFPROCESS	= 2
    }	PENDINGMSG;

			/* size is 22 */
typedef struct  tagINTERFACEINFO
    {
    IUnknown __RPC_FAR *pUnk;
    IID iid;
    WORD wMethod;
    }	INTERFACEINFO;

			/* size is 4 */
typedef struct tagINTERFACEINFO __RPC_FAR *LPINTERFACEINFO;


EXTERN_C const IID IID_IMessageFilter;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IMessageFilter : public IUnknown
    {
    public:
        virtual DWORD __stdcall HandleInComingCall( 
            /* [in] */ DWORD dwCallType,
            /* [in] */ HTASK htaskCaller,
            /* [in] */ DWORD dwTickCount,
            /* [in] */ LPINTERFACEINFO lpInterfaceInfo) = 0;
        
        virtual DWORD __stdcall RetryRejectedCall( 
            /* [in] */ HTASK htaskCallee,
            /* [in] */ DWORD dwTickCount,
            /* [in] */ DWORD dwRejectType) = 0;
        
        virtual DWORD __stdcall MessagePending( 
            /* [in] */ HTASK htaskCallee,
            /* [in] */ DWORD dwTickCount,
            /* [in] */ DWORD dwPendingType) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMessageFilterVtbl
    {
        
        HRESULT ( __stdcall __RPC_FAR *QueryInterface )( 
            IMessageFilter __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( __stdcall __RPC_FAR *AddRef )( 
            IMessageFilter __RPC_FAR * This);
        
        ULONG ( __stdcall __RPC_FAR *Release )( 
            IMessageFilter __RPC_FAR * This);
        
        DWORD ( __stdcall __RPC_FAR *HandleInComingCall )( 
            IMessageFilter __RPC_FAR * This,
            /* [in] */ DWORD dwCallType,
            /* [in] */ HTASK htaskCaller,
            /* [in] */ DWORD dwTickCount,
            /* [in] */ LPINTERFACEINFO lpInterfaceInfo);
        
        DWORD ( __stdcall __RPC_FAR *RetryRejectedCall )( 
            IMessageFilter __RPC_FAR * This,
            /* [in] */ HTASK htaskCallee,
            /* [in] */ DWORD dwTickCount,
            /* [in] */ DWORD dwRejectType);
        
        DWORD ( __stdcall __RPC_FAR *MessagePending )( 
            IMessageFilter __RPC_FAR * This,
            /* [in] */ HTASK htaskCallee,
            /* [in] */ DWORD dwTickCount,
            /* [in] */ DWORD dwPendingType);
        
    } IMessageFilterVtbl;

    interface IMessageFilter
    {
        CONST_VTBL struct IMessageFilterVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMessageFilter_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMessageFilter_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMessageFilter_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMessageFilter_HandleInComingCall(This,dwCallType,htaskCaller,dwTickCount,lpInterfaceInfo)	\
    (This)->lpVtbl -> HandleInComingCall(This,dwCallType,htaskCaller,dwTickCount,lpInterfaceInfo)

#define IMessageFilter_RetryRejectedCall(This,htaskCallee,dwTickCount,dwRejectType)	\
    (This)->lpVtbl -> RetryRejectedCall(This,htaskCallee,dwTickCount,dwRejectType)

#define IMessageFilter_MessagePending(This,htaskCallee,dwTickCount,dwPendingType)	\
    (This)->lpVtbl -> MessagePending(This,htaskCallee,dwTickCount,dwPendingType)

#endif /* COBJMACROS */


#endif 	/* C style interface */



DWORD __stdcall IMessageFilter_HandleInComingCall_Proxy( 
    IMessageFilter __RPC_FAR * This,
    /* [in] */ DWORD dwCallType,
    /* [in] */ HTASK htaskCaller,
    /* [in] */ DWORD dwTickCount,
    /* [in] */ LPINTERFACEINFO lpInterfaceInfo);


void __RPC_STUB IMessageFilter_HandleInComingCall_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


DWORD __stdcall IMessageFilter_RetryRejectedCall_Proxy( 
    IMessageFilter __RPC_FAR * This,
    /* [in] */ HTASK htaskCallee,
    /* [in] */ DWORD dwTickCount,
    /* [in] */ DWORD dwRejectType);


void __RPC_STUB IMessageFilter_RetryRejectedCall_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


DWORD __stdcall IMessageFilter_MessagePending_Proxy( 
    IMessageFilter __RPC_FAR * This,
    /* [in] */ HTASK htaskCallee,
    /* [in] */ DWORD dwTickCount,
    /* [in] */ DWORD dwPendingType);


void __RPC_STUB IMessageFilter_MessagePending_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMessageFilter_INTERFACE_DEFINED__ */


#ifndef __IRpcChannelBuffer_INTERFACE_DEFINED__
#define __IRpcChannelBuffer_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IRpcChannelBuffer
 * at Fri Apr 28 07:02:32 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [uuid][object][local] */ 


			/* size is 4 */
typedef unsigned long RPCOLEDATAREP;

			/* size is 44 */
typedef struct  tagRPCOLEMESSAGE
    {
    void __RPC_FAR *reserved1;
    RPCOLEDATAREP dataRepresentation;
    void __RPC_FAR *Buffer;
    ULONG cbBuffer;
    ULONG iMethod;
    void __RPC_FAR *reserved2[ 5 ];
    ULONG rpcFlags;
    }	RPCOLEMESSAGE;

			/* size is 4 */
typedef RPCOLEMESSAGE __RPC_FAR *PRPCOLEMESSAGE;


EXTERN_C const IID IID_IRpcChannelBuffer;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IRpcChannelBuffer : public IUnknown
    {
    public:
        virtual HRESULT __stdcall GetBuffer( 
            /* [in] */ RPCOLEMESSAGE __RPC_FAR *pMessage,
            /* [in] */ REFIID riid) = 0;
        
        virtual HRESULT __stdcall SendReceive( 
            /* [out][in] */ RPCOLEMESSAGE __RPC_FAR *pMessage,
            /* [out] */ ULONG __RPC_FAR *pStatus) = 0;
        
        virtual HRESULT __stdcall FreeBuffer( 
            /* [in] */ RPCOLEMESSAGE __RPC_FAR *pMessage) = 0;
        
        virtual HRESULT __stdcall GetDestCtx( 
            /* [out] */ DWORD __RPC_FAR *pdwDestContext,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvDestContext) = 0;
        
        virtual HRESULT __stdcall IsConnected( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRpcChannelBufferVtbl
    {
        
        HRESULT ( __stdcall __RPC_FAR *QueryInterface )( 
            IRpcChannelBuffer __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( __stdcall __RPC_FAR *AddRef )( 
            IRpcChannelBuffer __RPC_FAR * This);
        
        ULONG ( __stdcall __RPC_FAR *Release )( 
            IRpcChannelBuffer __RPC_FAR * This);
        
        HRESULT ( __stdcall __RPC_FAR *GetBuffer )( 
            IRpcChannelBuffer __RPC_FAR * This,
            /* [in] */ RPCOLEMESSAGE __RPC_FAR *pMessage,
            /* [in] */ REFIID riid);
        
        HRESULT ( __stdcall __RPC_FAR *SendReceive )( 
            IRpcChannelBuffer __RPC_FAR * This,
            /* [out][in] */ RPCOLEMESSAGE __RPC_FAR *pMessage,
            /* [out] */ ULONG __RPC_FAR *pStatus);
        
        HRESULT ( __stdcall __RPC_FAR *FreeBuffer )( 
            IRpcChannelBuffer __RPC_FAR * This,
            /* [in] */ RPCOLEMESSAGE __RPC_FAR *pMessage);
        
        HRESULT ( __stdcall __RPC_FAR *GetDestCtx )( 
            IRpcChannelBuffer __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwDestContext,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvDestContext);
        
        HRESULT ( __stdcall __RPC_FAR *IsConnected )( 
            IRpcChannelBuffer __RPC_FAR * This);
        
    } IRpcChannelBufferVtbl;

    interface IRpcChannelBuffer
    {
        CONST_VTBL struct IRpcChannelBufferVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRpcChannelBuffer_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRpcChannelBuffer_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRpcChannelBuffer_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRpcChannelBuffer_GetBuffer(This,pMessage,riid)	\
    (This)->lpVtbl -> GetBuffer(This,pMessage,riid)

#define IRpcChannelBuffer_SendReceive(This,pMessage,pStatus)	\
    (This)->lpVtbl -> SendReceive(This,pMessage,pStatus)

#define IRpcChannelBuffer_FreeBuffer(This,pMessage)	\
    (This)->lpVtbl -> FreeBuffer(This,pMessage)

#define IRpcChannelBuffer_GetDestCtx(This,pdwDestContext,ppvDestContext)	\
    (This)->lpVtbl -> GetDestCtx(This,pdwDestContext,ppvDestContext)

#define IRpcChannelBuffer_IsConnected(This)	\
    (This)->lpVtbl -> IsConnected(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT __stdcall IRpcChannelBuffer_GetBuffer_Proxy( 
    IRpcChannelBuffer __RPC_FAR * This,
    /* [in] */ RPCOLEMESSAGE __RPC_FAR *pMessage,
    /* [in] */ REFIID riid);


void __RPC_STUB IRpcChannelBuffer_GetBuffer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IRpcChannelBuffer_SendReceive_Proxy( 
    IRpcChannelBuffer __RPC_FAR * This,
    /* [out][in] */ RPCOLEMESSAGE __RPC_FAR *pMessage,
    /* [out] */ ULONG __RPC_FAR *pStatus);


void __RPC_STUB IRpcChannelBuffer_SendReceive_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IRpcChannelBuffer_FreeBuffer_Proxy( 
    IRpcChannelBuffer __RPC_FAR * This,
    /* [in] */ RPCOLEMESSAGE __RPC_FAR *pMessage);


void __RPC_STUB IRpcChannelBuffer_FreeBuffer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IRpcChannelBuffer_GetDestCtx_Proxy( 
    IRpcChannelBuffer __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwDestContext,
    /* [out] */ void __RPC_FAR *__RPC_FAR *ppvDestContext);


void __RPC_STUB IRpcChannelBuffer_GetDestCtx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IRpcChannelBuffer_IsConnected_Proxy( 
    IRpcChannelBuffer __RPC_FAR * This);


void __RPC_STUB IRpcChannelBuffer_IsConnected_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRpcChannelBuffer_INTERFACE_DEFINED__ */


#ifndef __IRpcProxyBuffer_INTERFACE_DEFINED__
#define __IRpcProxyBuffer_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IRpcProxyBuffer
 * at Fri Apr 28 07:02:32 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [uuid][object][local] */ 



EXTERN_C const IID IID_IRpcProxyBuffer;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IRpcProxyBuffer : public IUnknown
    {
    public:
        virtual HRESULT __stdcall Connect( 
            /* [unique][in] */ IRpcChannelBuffer __RPC_FAR *pRpcChannelBuffer) = 0;
        
        virtual void __stdcall Disconnect( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRpcProxyBufferVtbl
    {
        
        HRESULT ( __stdcall __RPC_FAR *QueryInterface )( 
            IRpcProxyBuffer __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( __stdcall __RPC_FAR *AddRef )( 
            IRpcProxyBuffer __RPC_FAR * This);
        
        ULONG ( __stdcall __RPC_FAR *Release )( 
            IRpcProxyBuffer __RPC_FAR * This);
        
        HRESULT ( __stdcall __RPC_FAR *Connect )( 
            IRpcProxyBuffer __RPC_FAR * This,
            /* [unique][in] */ IRpcChannelBuffer __RPC_FAR *pRpcChannelBuffer);
        
        void ( __stdcall __RPC_FAR *Disconnect )( 
            IRpcProxyBuffer __RPC_FAR * This);
        
    } IRpcProxyBufferVtbl;

    interface IRpcProxyBuffer
    {
        CONST_VTBL struct IRpcProxyBufferVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRpcProxyBuffer_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRpcProxyBuffer_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRpcProxyBuffer_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRpcProxyBuffer_Connect(This,pRpcChannelBuffer)	\
    (This)->lpVtbl -> Connect(This,pRpcChannelBuffer)

#define IRpcProxyBuffer_Disconnect(This)	\
    (This)->lpVtbl -> Disconnect(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT __stdcall IRpcProxyBuffer_Connect_Proxy( 
    IRpcProxyBuffer __RPC_FAR * This,
    /* [unique][in] */ IRpcChannelBuffer __RPC_FAR *pRpcChannelBuffer);


void __RPC_STUB IRpcProxyBuffer_Connect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void __stdcall IRpcProxyBuffer_Disconnect_Proxy( 
    IRpcProxyBuffer __RPC_FAR * This);


void __RPC_STUB IRpcProxyBuffer_Disconnect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRpcProxyBuffer_INTERFACE_DEFINED__ */


#ifndef __IRpcStubBuffer_INTERFACE_DEFINED__
#define __IRpcStubBuffer_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IRpcStubBuffer
 * at Fri Apr 28 07:02:32 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [uuid][object][local] */ 



EXTERN_C const IID IID_IRpcStubBuffer;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IRpcStubBuffer : public IUnknown
    {
    public:
        virtual HRESULT __stdcall Connect( 
            /* [in] */ IUnknown __RPC_FAR *pUnkServer) = 0;
        
        virtual void __stdcall Disconnect( void) = 0;
        
        virtual HRESULT __stdcall Invoke( 
            /* [in] */ RPCOLEMESSAGE __RPC_FAR *_prpcmsg,
            /* [in] */ IRpcChannelBuffer __RPC_FAR *_pRpcChannelBuffer) = 0;
        
        virtual IRpcStubBuffer __RPC_FAR *__stdcall IsIIDSupported( 
            /* [in] */ REFIID riid) = 0;
        
        virtual ULONG __stdcall CountRefs( void) = 0;
        
        virtual HRESULT __stdcall DebugServerQueryInterface( 
            void __RPC_FAR *__RPC_FAR *ppv) = 0;
        
        virtual void __stdcall DebugServerRelease( 
            void __RPC_FAR *pv) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRpcStubBufferVtbl
    {
        
        HRESULT ( __stdcall __RPC_FAR *QueryInterface )( 
            IRpcStubBuffer __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( __stdcall __RPC_FAR *AddRef )( 
            IRpcStubBuffer __RPC_FAR * This);
        
        ULONG ( __stdcall __RPC_FAR *Release )( 
            IRpcStubBuffer __RPC_FAR * This);
        
        HRESULT ( __stdcall __RPC_FAR *Connect )( 
            IRpcStubBuffer __RPC_FAR * This,
            /* [in] */ IUnknown __RPC_FAR *pUnkServer);
        
        void ( __stdcall __RPC_FAR *Disconnect )( 
            IRpcStubBuffer __RPC_FAR * This);
        
        HRESULT ( __stdcall __RPC_FAR *Invoke )( 
            IRpcStubBuffer __RPC_FAR * This,
            /* [in] */ RPCOLEMESSAGE __RPC_FAR *_prpcmsg,
            /* [in] */ IRpcChannelBuffer __RPC_FAR *_pRpcChannelBuffer);
        
        IRpcStubBuffer __RPC_FAR *( __stdcall __RPC_FAR *IsIIDSupported )( 
            IRpcStubBuffer __RPC_FAR * This,
            /* [in] */ REFIID riid);
        
        ULONG ( __stdcall __RPC_FAR *CountRefs )( 
            IRpcStubBuffer __RPC_FAR * This);
        
        HRESULT ( __stdcall __RPC_FAR *DebugServerQueryInterface )( 
            IRpcStubBuffer __RPC_FAR * This,
            void __RPC_FAR *__RPC_FAR *ppv);
        
        void ( __stdcall __RPC_FAR *DebugServerRelease )( 
            IRpcStubBuffer __RPC_FAR * This,
            void __RPC_FAR *pv);
        
    } IRpcStubBufferVtbl;

    interface IRpcStubBuffer
    {
        CONST_VTBL struct IRpcStubBufferVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRpcStubBuffer_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRpcStubBuffer_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRpcStubBuffer_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRpcStubBuffer_Connect(This,pUnkServer)	\
    (This)->lpVtbl -> Connect(This,pUnkServer)

#define IRpcStubBuffer_Disconnect(This)	\
    (This)->lpVtbl -> Disconnect(This)

#define IRpcStubBuffer_Invoke(This,_prpcmsg,_pRpcChannelBuffer)	\
    (This)->lpVtbl -> Invoke(This,_prpcmsg,_pRpcChannelBuffer)

#define IRpcStubBuffer_IsIIDSupported(This,riid)	\
    (This)->lpVtbl -> IsIIDSupported(This,riid)

#define IRpcStubBuffer_CountRefs(This)	\
    (This)->lpVtbl -> CountRefs(This)

#define IRpcStubBuffer_DebugServerQueryInterface(This,ppv)	\
    (This)->lpVtbl -> DebugServerQueryInterface(This,ppv)

#define IRpcStubBuffer_DebugServerRelease(This,pv)	\
    (This)->lpVtbl -> DebugServerRelease(This,pv)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT __stdcall IRpcStubBuffer_Connect_Proxy( 
    IRpcStubBuffer __RPC_FAR * This,
    /* [in] */ IUnknown __RPC_FAR *pUnkServer);


void __RPC_STUB IRpcStubBuffer_Connect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void __stdcall IRpcStubBuffer_Disconnect_Proxy( 
    IRpcStubBuffer __RPC_FAR * This);


void __RPC_STUB IRpcStubBuffer_Disconnect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IRpcStubBuffer_Invoke_Proxy( 
    IRpcStubBuffer __RPC_FAR * This,
    /* [in] */ RPCOLEMESSAGE __RPC_FAR *_prpcmsg,
    /* [in] */ IRpcChannelBuffer __RPC_FAR *_pRpcChannelBuffer);


void __RPC_STUB IRpcStubBuffer_Invoke_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


IRpcStubBuffer __RPC_FAR *__stdcall IRpcStubBuffer_IsIIDSupported_Proxy( 
    IRpcStubBuffer __RPC_FAR * This,
    /* [in] */ REFIID riid);


void __RPC_STUB IRpcStubBuffer_IsIIDSupported_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


ULONG __stdcall IRpcStubBuffer_CountRefs_Proxy( 
    IRpcStubBuffer __RPC_FAR * This);


void __RPC_STUB IRpcStubBuffer_CountRefs_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IRpcStubBuffer_DebugServerQueryInterface_Proxy( 
    IRpcStubBuffer __RPC_FAR * This,
    void __RPC_FAR *__RPC_FAR *ppv);


void __RPC_STUB IRpcStubBuffer_DebugServerQueryInterface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void __stdcall IRpcStubBuffer_DebugServerRelease_Proxy( 
    IRpcStubBuffer __RPC_FAR * This,
    void __RPC_FAR *pv);


void __RPC_STUB IRpcStubBuffer_DebugServerRelease_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRpcStubBuffer_INTERFACE_DEFINED__ */


#ifndef __IPSFactoryBuffer_INTERFACE_DEFINED__
#define __IPSFactoryBuffer_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IPSFactoryBuffer
 * at Fri Apr 28 07:02:32 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [uuid][object][local] */ 



EXTERN_C const IID IID_IPSFactoryBuffer;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IPSFactoryBuffer : public IUnknown
    {
    public:
        virtual HRESULT __stdcall CreateProxy( 
            /* [in] */ IUnknown __RPC_FAR *pUnkOuter,
            /* [in] */ REFIID riid,
            /* [out] */ IRpcProxyBuffer __RPC_FAR *__RPC_FAR *ppProxy,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppv) = 0;
        
        virtual HRESULT __stdcall CreateStub( 
            /* [in] */ REFIID riid,
            /* [unique][in] */ IUnknown __RPC_FAR *pUnkServer,
            /* [out] */ IRpcStubBuffer __RPC_FAR *__RPC_FAR *ppStub) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPSFactoryBufferVtbl
    {
        
        HRESULT ( __stdcall __RPC_FAR *QueryInterface )( 
            IPSFactoryBuffer __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( __stdcall __RPC_FAR *AddRef )( 
            IPSFactoryBuffer __RPC_FAR * This);
        
        ULONG ( __stdcall __RPC_FAR *Release )( 
            IPSFactoryBuffer __RPC_FAR * This);
        
        HRESULT ( __stdcall __RPC_FAR *CreateProxy )( 
            IPSFactoryBuffer __RPC_FAR * This,
            /* [in] */ IUnknown __RPC_FAR *pUnkOuter,
            /* [in] */ REFIID riid,
            /* [out] */ IRpcProxyBuffer __RPC_FAR *__RPC_FAR *ppProxy,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppv);
        
        HRESULT ( __stdcall __RPC_FAR *CreateStub )( 
            IPSFactoryBuffer __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [unique][in] */ IUnknown __RPC_FAR *pUnkServer,
            /* [out] */ IRpcStubBuffer __RPC_FAR *__RPC_FAR *ppStub);
        
    } IPSFactoryBufferVtbl;

    interface IPSFactoryBuffer
    {
        CONST_VTBL struct IPSFactoryBufferVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPSFactoryBuffer_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPSFactoryBuffer_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPSFactoryBuffer_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPSFactoryBuffer_CreateProxy(This,pUnkOuter,riid,ppProxy,ppv)	\
    (This)->lpVtbl -> CreateProxy(This,pUnkOuter,riid,ppProxy,ppv)

#define IPSFactoryBuffer_CreateStub(This,riid,pUnkServer,ppStub)	\
    (This)->lpVtbl -> CreateStub(This,riid,pUnkServer,ppStub)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT __stdcall IPSFactoryBuffer_CreateProxy_Proxy( 
    IPSFactoryBuffer __RPC_FAR * This,
    /* [in] */ IUnknown __RPC_FAR *pUnkOuter,
    /* [in] */ REFIID riid,
    /* [out] */ IRpcProxyBuffer __RPC_FAR *__RPC_FAR *ppProxy,
    /* [out] */ void __RPC_FAR *__RPC_FAR *ppv);


void __RPC_STUB IPSFactoryBuffer_CreateProxy_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IPSFactoryBuffer_CreateStub_Proxy( 
    IPSFactoryBuffer __RPC_FAR * This,
    /* [in] */ REFIID riid,
    /* [unique][in] */ IUnknown __RPC_FAR *pUnkServer,
    /* [out] */ IRpcStubBuffer __RPC_FAR *__RPC_FAR *ppStub);


void __RPC_STUB IPSFactoryBuffer_CreateStub_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IPSFactoryBuffer_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */


void __RPC_USER SNB_to_xmit( SNB __RPC_FAR *, RemSNB  __RPC_FAR * __RPC_FAR * );
void __RPC_USER SNB_from_xmit( RemSNB  __RPC_FAR *, SNB __RPC_FAR * );
void __RPC_USER SNB_free_inst( SNB __RPC_FAR * );
void __RPC_USER SNB_free_xmit( RemSNB  __RPC_FAR * );

/* [local] */ HRESULT __stdcall IEnumUnknown_Next_Proxy( 
    IEnumUnknown __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *rgelt,
    /* [out] */ ULONG __RPC_FAR *pceltFetched);


/* [call_as] */ HRESULT __stdcall IEnumUnknown_Next_Stub( 
    IEnumUnknown __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ IUnknown __RPC_FAR *__RPC_FAR *rgelt,
    /* [out] */ ULONG __RPC_FAR *pceltFetched);

/* [local] */ HRESULT __stdcall IEnumMoniker_Next_Proxy( 
    IEnumMoniker __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [out] */ IMoniker __RPC_FAR *__RPC_FAR *rgelt,
    /* [out] */ ULONG __RPC_FAR *pceltFetched);


/* [call_as] */ HRESULT __stdcall IEnumMoniker_Next_Stub( 
    IEnumMoniker __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ IMoniker __RPC_FAR *__RPC_FAR *rgelt,
    /* [out] */ ULONG __RPC_FAR *pceltFetched);

/* [local] */ HRESULT __stdcall IMoniker_BindToObject_Proxy( 
    IMoniker __RPC_FAR * This,
    /* [unique][in] */ IBindCtx __RPC_FAR *pbc,
    /* [unique][in] */ IMoniker __RPC_FAR *pmkToLeft,
    /* [in] */ REFIID riidResult,
    /* [out] */ void __RPC_FAR *__RPC_FAR *ppvResult);


/* [call_as] */ HRESULT __stdcall IMoniker_BindToObject_Stub( 
    IMoniker __RPC_FAR * This,
    /* [unique][in] */ IBindCtx __RPC_FAR *pbc,
    /* [unique][in] */ IMoniker __RPC_FAR *pmkToLeft,
    /* [in] */ REFIID riidResult,
    /* [iid_is][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppvResult);

/* [local] */ HRESULT __stdcall IMoniker_BindToStorage_Proxy( 
    IMoniker __RPC_FAR * This,
    /* [unique][in] */ IBindCtx __RPC_FAR *pbc,
    /* [unique][in] */ IMoniker __RPC_FAR *pmkToLeft,
    /* [in] */ REFIID riid,
    /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObj);


/* [call_as] */ HRESULT __stdcall IMoniker_BindToStorage_Stub( 
    IMoniker __RPC_FAR * This,
    /* [unique][in] */ IBindCtx __RPC_FAR *pbc,
    /* [unique][in] */ IMoniker __RPC_FAR *pmkToLeft,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppvObj);

/* [local] */ HRESULT __stdcall IEnumString_Next_Proxy( 
    IEnumString __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [out] */ LPOLESTR __RPC_FAR *rgelt,
    /* [out] */ ULONG __RPC_FAR *pceltFetched);


/* [call_as] */ HRESULT __stdcall IEnumString_Next_Stub( 
    IEnumString __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ LPOLESTR __RPC_FAR *rgelt,
    /* [out] */ ULONG __RPC_FAR *pceltFetched);

/* [local] */ HRESULT __stdcall IStream_Read_Proxy( 
    IStream __RPC_FAR * This,
    /* [out] */ void __RPC_FAR *pv,
    /* [in] */ ULONG cb,
    /* [out] */ ULONG __RPC_FAR *pcbRead);


/* [call_as] */ HRESULT __stdcall IStream_Read_Stub( 
    IStream __RPC_FAR * This,
    /* [length_is][size_is][out] */ byte __RPC_FAR *pv,
    /* [in] */ ULONG cb,
    /* [out] */ ULONG __RPC_FAR *pcbRead);

/* [local] */ HRESULT __stdcall IStream_Write_Proxy( 
    IStream __RPC_FAR * This,
    /* [size_is][in] */ const void __RPC_FAR *pv,
    /* [in] */ ULONG cb,
    /* [out] */ ULONG __RPC_FAR *pcbWritten);


/* [call_as] */ HRESULT __stdcall IStream_Write_Stub( 
    IStream __RPC_FAR * This,
    /* [size_is][in] */ const byte __RPC_FAR *pv,
    /* [in] */ ULONG cb,
    /* [out] */ ULONG __RPC_FAR *pcbWritten);

/* [local] */ HRESULT __stdcall IStream_Seek_Proxy( 
    IStream __RPC_FAR * This,
    /* [in] */ LARGE_INTEGER dlibMove,
    /* [in] */ DWORD dwOrigin,
    /* [out] */ ULARGE_INTEGER __RPC_FAR *plibNewPosition);


/* [call_as] */ HRESULT __stdcall IStream_Seek_Stub( 
    IStream __RPC_FAR * This,
    /* [in] */ LARGE_INTEGER dlibMove,
    /* [in] */ DWORD dwOrigin,
    /* [out] */ ULARGE_INTEGER __RPC_FAR *plibNewPosition);

/* [local] */ HRESULT __stdcall IStream_CopyTo_Proxy( 
    IStream __RPC_FAR * This,
    /* [unique][in] */ IStream __RPC_FAR *pstm,
    /* [in] */ ULARGE_INTEGER cb,
    /* [out] */ ULARGE_INTEGER __RPC_FAR *pcbRead,
    /* [out] */ ULARGE_INTEGER __RPC_FAR *pcbWritten);


/* [call_as] */ HRESULT __stdcall IStream_CopyTo_Stub( 
    IStream __RPC_FAR * This,
    /* [unique][in] */ IStream __RPC_FAR *pstm,
    /* [in] */ ULARGE_INTEGER cb,
    /* [out] */ ULARGE_INTEGER __RPC_FAR *pcbRead,
    /* [out] */ ULARGE_INTEGER __RPC_FAR *pcbWritten);

/* [local] */ HRESULT __stdcall IEnumSTATSTG_Next_Proxy( 
    IEnumSTATSTG __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [in] */ STATSTG __RPC_FAR *rgelt,
    /* [out] */ ULONG __RPC_FAR *pceltFetched);


/* [call_as] */ HRESULT __stdcall IEnumSTATSTG_Next_Stub( 
    IEnumSTATSTG __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ STATSTG __RPC_FAR *rgelt,
    /* [out] */ ULONG __RPC_FAR *pceltFetched);

/* [local] */ HRESULT __stdcall IStorage_OpenStream_Proxy( 
    IStorage __RPC_FAR * This,
    /* [string][in] */ const OLECHAR __RPC_FAR *pwcsName,
    /* [unique][in] */ void __RPC_FAR *reserved1,
    /* [in] */ DWORD grfMode,
    /* [in] */ DWORD reserved2,
    /* [out] */ IStream __RPC_FAR *__RPC_FAR *ppstm);


/* [call_as] */ HRESULT __stdcall IStorage_OpenStream_Stub( 
    IStorage __RPC_FAR * This,
    /* [string][in] */ const OLECHAR __RPC_FAR *pwcsName,
    /* [in] */ unsigned long cbReserved1,
    /* [size_is][unique][in] */ byte __RPC_FAR *reserved1,
    /* [in] */ DWORD grfMode,
    /* [in] */ DWORD reserved2,
    /* [out] */ IStream __RPC_FAR *__RPC_FAR *ppstm);

/* [local] */ HRESULT __stdcall IStorage_EnumElements_Proxy( 
    IStorage __RPC_FAR * This,
    /* [in] */ DWORD reserved1,
    /* [size_is][unique][in] */ void __RPC_FAR *reserved2,
    /* [in] */ DWORD reserved3,
    /* [out] */ IEnumSTATSTG __RPC_FAR *__RPC_FAR *ppenum);


/* [call_as] */ HRESULT __stdcall IStorage_EnumElements_Stub( 
    IStorage __RPC_FAR * This,
    /* [in] */ DWORD reserved1,
    /* [in] */ unsigned long cbReserved2,
    /* [size_is][unique][in] */ byte __RPC_FAR *reserved2,
    /* [in] */ DWORD reserved3,
    /* [out] */ IEnumSTATSTG __RPC_FAR *__RPC_FAR *ppenum);

/* [local] */ HRESULT __stdcall ILockBytes_ReadAt_Proxy( 
    ILockBytes __RPC_FAR * This,
    /* [in] */ ULARGE_INTEGER ulOffset,
    /* [in] */ void __RPC_FAR *pv,
    /* [in] */ ULONG cb,
    /* [out] */ ULONG __RPC_FAR *pcbRead);


/* [call_as] */ HRESULT __stdcall ILockBytes_ReadAt_Stub( 
    ILockBytes __RPC_FAR * This,
    /* [in] */ ULARGE_INTEGER ulOffset,
    /* [length_is][size_is][out] */ byte __RPC_FAR *pv,
    /* [in] */ ULONG cb,
    /* [out] */ ULONG __RPC_FAR *pcbRead);

/* [local] */ HRESULT __stdcall ILockBytes_WriteAt_Proxy( 
    ILockBytes __RPC_FAR * This,
    /* [in] */ ULARGE_INTEGER ulOffset,
    /* [in] */ const void __RPC_FAR *pv,
    /* [in] */ ULONG cb,
    /* [out] */ ULONG __RPC_FAR *pcbWritten);


/* [call_as] */ HRESULT __stdcall ILockBytes_WriteAt_Stub( 
    ILockBytes __RPC_FAR * This,
    /* [in] */ ULARGE_INTEGER ulOffset,
    /* [size_is][in] */ const byte __RPC_FAR *pv,
    /* [in] */ ULONG cb,
    /* [out] */ ULONG __RPC_FAR *pcbWritten);

/* [local] */ HRESULT __stdcall IEnumFORMATETC_Next_Proxy( 
    IEnumFORMATETC __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [out] */ FORMATETC __RPC_FAR *rgelt,
    /* [out] */ ULONG __RPC_FAR *pceltFetched);


/* [call_as] */ HRESULT __stdcall IEnumFORMATETC_Next_Stub( 
    IEnumFORMATETC __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ FORMATETC __RPC_FAR *rgelt,
    /* [out] */ ULONG __RPC_FAR *pceltFetched);

/* [local] */ HRESULT __stdcall IEnumSTATDATA_Next_Proxy( 
    IEnumSTATDATA __RPC_FAR * This,
    /* [in] */ ULONG celt,
    STATDATA __RPC_FAR *rgelt,
    /* [out] */ ULONG __RPC_FAR *pceltFetched);


/* [call_as] */ HRESULT __stdcall IEnumSTATDATA_Next_Stub( 
    IEnumSTATDATA __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ STATDATA __RPC_FAR *rgelt,
    /* [out] */ ULONG __RPC_FAR *pceltFetched);

/* [local] */ void __stdcall IAdviseSink_OnDataChange_Proxy( 
    IAdviseSink __RPC_FAR * This,
    /* [unique][in] */ FORMATETC __RPC_FAR *pFormatetc,
    /* [unique][in] */ STGMEDIUM __RPC_FAR *pStgmed);


/* [async][call_as] */ void __stdcall IAdviseSink_OnDataChange_Stub( 
    IAdviseSink __RPC_FAR * This,
    /* [unique][in] */ FORMATETC __RPC_FAR *pFormatetc,
    /* [unique][in] */ RemSTGMEDIUM __RPC_FAR *pStgmed);

/* [local] */ void __stdcall IAdviseSink_OnViewChange_Proxy( 
    IAdviseSink __RPC_FAR * This,
    /* [in] */ DWORD dwAspect,
    /* [in] */ LONG lindex);


/* [async][call_as] */ void __stdcall IAdviseSink_OnViewChange_Stub( 
    IAdviseSink __RPC_FAR * This,
    /* [in] */ DWORD dwAspect,
    /* [in] */ LONG lindex);

/* [local] */ void __stdcall IAdviseSink_OnRename_Proxy( 
    IAdviseSink __RPC_FAR * This,
    /* [in] */ IMoniker __RPC_FAR *pmk);


/* [async][call_as] */ void __stdcall IAdviseSink_OnRename_Stub( 
    IAdviseSink __RPC_FAR * This,
    /* [in] */ IMoniker __RPC_FAR *pmk);

/* [local] */ void __stdcall IAdviseSink_OnSave_Proxy( 
    IAdviseSink __RPC_FAR * This);


/* [async][call_as] */ void __stdcall IAdviseSink_OnSave_Stub( 
    IAdviseSink __RPC_FAR * This);

/* [local] */ void __stdcall IAdviseSink_OnClose_Proxy( 
    IAdviseSink __RPC_FAR * This);


/* [call_as] */ HRESULT __stdcall IAdviseSink_OnClose_Stub( 
    IAdviseSink __RPC_FAR * This);

/* [local] */ void __stdcall IAdviseSink2_OnLinkSrcChange_Proxy( 
    IAdviseSink2 __RPC_FAR * This,
    /* [unique][in] */ IMoniker __RPC_FAR *pmk);


/* [async][call_as] */ void __stdcall IAdviseSink2_OnLinkSrcChange_Stub( 
    IAdviseSink2 __RPC_FAR * This,
    /* [unique][in] */ IMoniker __RPC_FAR *pmk);

/* [local] */ HRESULT __stdcall IDataObject_GetData_Proxy( 
    IDataObject __RPC_FAR * This,
    /* [unique][in] */ FORMATETC __RPC_FAR *pformatetcIn,
    /* [out] */ STGMEDIUM __RPC_FAR *pmedium);


/* [call_as] */ HRESULT __stdcall IDataObject_GetData_Stub( 
    IDataObject __RPC_FAR * This,
    /* [unique][in] */ FORMATETC __RPC_FAR *pformatetcIn,
    /* [out] */ RemSTGMEDIUM __RPC_FAR *__RPC_FAR *ppRemoteMedium);

/* [local] */ HRESULT __stdcall IDataObject_GetDataHere_Proxy( 
    IDataObject __RPC_FAR * This,
    /* [unique][in] */ FORMATETC __RPC_FAR *pformatetc,
    /* [out][in] */ STGMEDIUM __RPC_FAR *pmedium);


/* [call_as] */ HRESULT __stdcall IDataObject_GetDataHere_Stub( 
    IDataObject __RPC_FAR * This,
    /* [unique][in] */ FORMATETC __RPC_FAR *pformatetc,
    /* [out][in] */ RemSTGMEDIUM __RPC_FAR *__RPC_FAR *ppRemoteMedium);

/* [local] */ HRESULT __stdcall IDataObject_SetData_Proxy( 
    IDataObject __RPC_FAR * This,
    /* [unique][in] */ FORMATETC __RPC_FAR *pformatetc,
    /* [unique][in] */ STGMEDIUM __RPC_FAR *pmedium,
    /* [in] */ BOOL fRelease);


/* [call_as] */ HRESULT __stdcall IDataObject_SetData_Stub( 
    IDataObject __RPC_FAR * This,
    /* [unique][in] */ FORMATETC __RPC_FAR *pformatetc,
    /* [unique][in] */ RemSTGMEDIUM __RPC_FAR *pmedium,
    /* [in] */ BOOL fRelease);



/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\inc32\OLE2.H ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       OLE2.h
//  Contents:   Main OLE2 header; Defines Linking and Emmebbeding interfaces, and API's.
//              Also includes .h files for the compobj, and oleauto  subcomponents.
//
//----------------------------------------------------------------------------
#if !defined( _OLE2_H_ )
#define _OLE2_H_

// Set packing to 8
#include <pshpack8.h>

// Make 100% sure WIN32 is defined
#ifndef WIN32
#define WIN32    100  // 100 == NT version 1.0
#endif


// SET to remove _export from interface definitions


#include <winerror.h>

#include <objbase.h>
#include <oleauto.h>

// View OBJECT Error Codes

#define E_DRAW                  VIEW_E_DRAW

// IDataObject Error Codes
#define DATA_E_FORMATETC        DV_E_FORMATETC





// Common stuff gleamed from OLE.2,

/* verbs */
#define OLEIVERB_PRIMARY            (0L)
#define OLEIVERB_SHOW               (-1L)
#define OLEIVERB_OPEN               (-2L)
#define OLEIVERB_HIDE               (-3L)
#define OLEIVERB_UIACTIVATE         (-4L)
#define OLEIVERB_INPLACEACTIVATE    (-5L)
#define OLEIVERB_DISCARDUNDOSTATE   (-6L)

// for OleCreateEmbeddingHelper flags; roles in low word; options in high word
#define EMBDHLP_INPROC_HANDLER   0x0000L
#define EMBDHLP_INPROC_SERVER    0x0001L
#define EMBDHLP_CREATENOW    0x00000000L
#define EMBDHLP_DELAYCREATE  0x00010000L

/* pull in the MIDL generated header */

#include <oleidl.h>






/****** DV APIs ***********************************************************/


WINOLEAPI CreateDataAdviseHolder(LPDATAADVISEHOLDER FAR* ppDAHolder);







/****** OLE API Prototypes ************************************************/

WINOLEAPI_(DWORD) OleBuildVersion( VOID );

/* helper functions */
WINOLEAPI ReadClassStg(LPSTORAGE pStg, CLSID FAR* pclsid);
WINOLEAPI WriteClassStg(LPSTORAGE pStg, REFCLSID rclsid);
WINOLEAPI ReadClassStm(LPSTREAM pStm, CLSID FAR* pclsid);
WINOLEAPI WriteClassStm(LPSTREAM pStm, REFCLSID rclsid);
WINOLEAPI WriteFmtUserTypeStg (LPSTORAGE pstg, CLIPFORMAT cf, LPOLESTR lpszUserType);
WINOLEAPI ReadFmtUserTypeStg (LPSTORAGE pstg, CLIPFORMAT FAR* pcf, LPOLESTR FAR* lplpszUserType);


/* init/term */

WINOLEAPI OleInitialize(LPVOID pvReserved);
WINOLEAPI_(void) OleUninitialize(void);


/* APIs to query whether (Embedded/Linked) object can be created from
   the data object */

WINOLEAPI  OleQueryLinkFromData(LPDATAOBJECT pSrcDataObject);
WINOLEAPI  OleQueryCreateFromData(LPDATAOBJECT pSrcDataObject);


/* Object creation APIs */

WINOLEAPI  OleCreate(REFCLSID rclsid, REFIID riid, DWORD renderopt,
                LPFORMATETC pFormatEtc, LPOLECLIENTSITE pClientSite,
                LPSTORAGE pStg, LPVOID FAR* ppvObj);

WINOLEAPI  OleCreateFromData(LPDATAOBJECT pSrcDataObj, REFIID riid,
                DWORD renderopt, LPFORMATETC pFormatEtc,
                LPOLECLIENTSITE pClientSite, LPSTORAGE pStg,
                LPVOID FAR* ppvObj);

WINOLEAPI  OleCreateLinkFromData(LPDATAOBJECT pSrcDataObj, REFIID riid,
                DWORD renderopt, LPFORMATETC pFormatEtc,
                LPOLECLIENTSITE pClientSite, LPSTORAGE pStg,
                LPVOID FAR* ppvObj);

WINOLEAPI  OleCreateStaticFromData(LPDATAOBJECT pSrcDataObj, REFIID iid,
                DWORD renderopt, LPFORMATETC pFormatEtc,
                LPOLECLIENTSITE pClientSite, LPSTORAGE pStg,
                LPVOID FAR* ppvObj);


WINOLEAPI  OleCreateLink(LPMONIKER pmkLinkSrc, REFIID riid,
            DWORD renderopt, LPFORMATETC lpFormatEtc,
            LPOLECLIENTSITE pClientSite, LPSTORAGE pStg, LPVOID FAR* ppvObj);

WINOLEAPI  OleCreateLinkToFile(LPCOLESTR lpszFileName, REFIID riid,
            DWORD renderopt, LPFORMATETC lpFormatEtc,
            LPOLECLIENTSITE pClientSite, LPSTORAGE pStg, LPVOID FAR* ppvObj);

WINOLEAPI  OleCreateFromFile(REFCLSID rclsid, LPCOLESTR lpszFileName, REFIID riid,
            DWORD renderopt, LPFORMATETC lpFormatEtc,
            LPOLECLIENTSITE pClientSite, LPSTORAGE pStg, LPVOID FAR* ppvObj);

WINOLEAPI  OleLoad(LPSTORAGE pStg, REFIID riid, LPOLECLIENTSITE pClientSite,
            LPVOID FAR* ppvObj);

WINOLEAPI  OleSave(LPPERSISTSTORAGE pPS, LPSTORAGE pStg, BOOL fSameAsLoad);

WINOLEAPI  OleLoadFromStream( LPSTREAM pStm, REFIID iidInterface, LPVOID FAR* ppvObj);
WINOLEAPI  OleSaveToStream( LPPERSISTSTREAM pPStm, LPSTREAM pStm );


WINOLEAPI  OleSetContainedObject(LPUNKNOWN pUnknown, BOOL fContained);
WINOLEAPI  OleNoteObjectVisible(LPUNKNOWN pUnknown, BOOL fVisible);


/* Drag/Drop APIs */

WINOLEAPI  RegisterDragDrop(HWND hwnd, LPDROPTARGET pDropTarget);
WINOLEAPI  RevokeDragDrop(HWND hwnd);
WINOLEAPI  DoDragDrop(LPDATAOBJECT pDataObj, LPDROPSOURCE pDropSource,
            DWORD dwOKEffects, LPDWORD pdwEffect);

/* Clipboard APIs */

WINOLEAPI  OleSetClipboard(LPDATAOBJECT pDataObj);
WINOLEAPI  OleGetClipboard(LPDATAOBJECT FAR* ppDataObj);
WINOLEAPI  OleFlushClipboard(void);
WINOLEAPI  OleIsCurrentClipboard(LPDATAOBJECT pDataObj);


/* InPlace Editing APIs */

WINOLEAPI_(HOLEMENU)   OleCreateMenuDescriptor (HMENU hmenuCombined,
                                LPOLEMENUGROUPWIDTHS lpMenuWidths);
WINOLEAPI              OleSetMenuDescriptor (HOLEMENU holemenu, HWND hwndFrame,
                                HWND hwndActiveObject,
                                LPOLEINPLACEFRAME lpFrame,
                                LPOLEINPLACEACTIVEOBJECT lpActiveObj);
WINOLEAPI              OleDestroyMenuDescriptor (HOLEMENU holemenu);

WINOLEAPI              OleTranslateAccelerator (LPOLEINPLACEFRAME lpFrame,
                            LPOLEINPLACEFRAMEINFO lpFrameInfo, LPMSG lpmsg);


/* Helper APIs */
WINOLEAPI_(HANDLE) OleDuplicateData (HANDLE hSrc, CLIPFORMAT cfFormat,
                        UINT uiFlags);

WINOLEAPI          OleDraw (LPUNKNOWN pUnknown, DWORD dwAspect, HDC hdcDraw,
                    LPCRECT lprcBounds);

WINOLEAPI          OleRun(LPUNKNOWN pUnknown);
WINOLEAPI_(BOOL)   OleIsRunning(LPOLEOBJECT pObject);
WINOLEAPI          OleLockRunning(LPUNKNOWN pUnknown, BOOL fLock, BOOL fLastUnlockCloses);
WINOLEAPI_(void)   ReleaseStgMedium(LPSTGMEDIUM);
WINOLEAPI          CreateOleAdviseHolder(LPOLEADVISEHOLDER FAR* ppOAHolder);

WINOLEAPI          OleCreateDefaultHandler(REFCLSID clsid, LPUNKNOWN pUnkOuter,
                    REFIID riid, LPVOID FAR* lplpObj);

WINOLEAPI          OleCreateEmbeddingHelper(REFCLSID clsid, LPUNKNOWN pUnkOuter,
                    DWORD flags, LPCLASSFACTORY pCF,
                                        REFIID riid, LPVOID FAR* lplpObj);

WINOLEAPI_(BOOL)   IsAccelerator(HACCEL hAccel, int cAccelEntries, LPMSG lpMsg,
                                        WORD FAR* lpwCmd);
/* Icon extraction Helper APIs */

WINOLEAPI_(HGLOBAL) OleGetIconOfFile(LPOLESTR lpszPath, BOOL fUseFileAsLabel);

WINOLEAPI_(HGLOBAL) OleGetIconOfClass(REFCLSID rclsid,     LPOLESTR lpszLabel,
                                        BOOL fUseTypeAsLabel);

WINOLEAPI_(HGLOBAL) OleMetafilePictFromIconAndLabel(HICON hIcon, LPOLESTR lpszLabel,
                                        LPOLESTR lpszSourceFile, UINT iIconIndex);



/* Registration Database Helper APIs */

WINOLEAPI                  OleRegGetUserType (REFCLSID clsid, DWORD dwFormOfType,
                                        LPOLESTR FAR* pszUserType);

WINOLEAPI                  OleRegGetMiscStatus     (REFCLSID clsid, DWORD dwAspect,
                                        DWORD FAR* pdwStatus);

WINOLEAPI                  OleRegEnumFormatEtc     (REFCLSID clsid, DWORD dwDirection,
                                        LPENUMFORMATETC FAR* ppenum);

WINOLEAPI                  OleRegEnumVerbs (REFCLSID clsid, LPENUMOLEVERB FAR* ppenum);





/* OLE 1.0 conversion APIS */

/***** OLE 1.0 OLESTREAM declarations *************************************/

typedef struct _OLESTREAM FAR*  LPOLESTREAM;

typedef struct _OLESTREAMVTBL
{
    DWORD (CALLBACK* Get)(LPOLESTREAM, void FAR*, DWORD);
    DWORD (CALLBACK* Put)(LPOLESTREAM, const void FAR*, DWORD);
} OLESTREAMVTBL;
typedef  OLESTREAMVTBL FAR*  LPOLESTREAMVTBL;

typedef struct _OLESTREAM
{
    LPOLESTREAMVTBL lpstbl;
} OLESTREAM;


WINOLEAPI OleConvertOLESTREAMToIStorage
    (LPOLESTREAM                lpolestream,
    LPSTORAGE                   pstg,
    const DVTARGETDEVICE FAR*   ptd);

WINOLEAPI OleConvertIStorageToOLESTREAM
    (LPSTORAGE      pstg,
    LPOLESTREAM     lpolestream);


/* Storage Utility APIs */
WINOLEAPI GetHGlobalFromILockBytes (LPLOCKBYTES plkbyt, HGLOBAL FAR* phglobal);
WINOLEAPI CreateILockBytesOnHGlobal (HGLOBAL hGlobal, BOOL fDeleteOnRelease,
                                    LPLOCKBYTES FAR* pplkbyt);

WINOLEAPI GetHGlobalFromStream (LPSTREAM pstm, HGLOBAL FAR* phglobal);
WINOLEAPI CreateStreamOnHGlobal (HGLOBAL hGlobal, BOOL fDeleteOnRelease,
                                LPSTREAM FAR* ppstm);


/* ConvertTo APIS */

WINOLEAPI OleDoAutoConvert(LPSTORAGE pStg, LPCLSID pClsidNew);
WINOLEAPI OleGetAutoConvert(REFCLSID clsidOld, LPCLSID pClsidNew);
WINOLEAPI OleSetAutoConvert(REFCLSID clsidOld, REFCLSID clsidNew);
WINOLEAPI GetConvertStg(LPSTORAGE pStg);
WINOLEAPI SetConvertStg(LPSTORAGE pStg, BOOL fConvert);


WINOLEAPI OleConvertIStorageToOLESTREAMEx
    (LPSTORAGE          pstg,
                                    // Presentation data to OLESTREAM
     CLIPFORMAT         cfFormat,   //      format
     LONG               lWidth,     //      width
     LONG               lHeight,    //      height
     DWORD              dwSize,     //      size in bytes
     LPSTGMEDIUM        pmedium,    //      bits
     LPOLESTREAM        polestm);

WINOLEAPI OleConvertOLESTREAMToIStorageEx
    (LPOLESTREAM        polestm,
     LPSTORAGE          pstg,
                                    // Presentation data from OLESTREAM
     CLIPFORMAT FAR*    pcfFormat,  //      format
     LONG FAR*          plwWidth,   //      width
     LONG FAR*          plHeight,   //      height
     DWORD FAR*         pdwSize,    //      size in bytes
     LPSTGMEDIUM        pmedium);   //      bits

#ifndef RC_INVOKED
#include <poppack.h>
#endif // RC_INVOKED

#endif     // __OLE2_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\inc32\NB30.H ===
//*++
//
// Copyright (c) 1991-1995  Microsoft Corporation
//
// Module Name:
//
//  nb30.h
//
// Abstract:
//
//  This module contains the definitions for portable NetBIOS 3.0
//  support.
//
//--*/

#ifndef NCB_INCLUDED
#define NCB_INCLUDED

#ifdef __cplusplus
extern "C" {
#endif

/****************************************************************
 *                                                              *
 *              Data structure templates                        *
 *                                                              *
 ****************************************************************/

#define NCBNAMSZ        16    /* absolute length of a net name           */
#define MAX_LANA       254    /* lana's in range 0 to MAX_LANA inclusive */

/*
 * Network Control Block
 */

typedef struct _NCB {
    UCHAR   ncb_command;            /* command code                   */
    UCHAR   ncb_retcode;            /* return code                    */
    UCHAR   ncb_lsn;                /* local session number           */
    UCHAR   ncb_num;                /* number of our network name     */
    PUCHAR  ncb_buffer;             /* address of message buffer      */
    WORD    ncb_length;             /* size of message buffer         */
    UCHAR   ncb_callname[NCBNAMSZ]; /* blank-padded name of remote    */
    UCHAR   ncb_name[NCBNAMSZ];     /* our blank-padded netname       */
    UCHAR   ncb_rto;                /* rcv timeout/retry count        */
    UCHAR   ncb_sto;                /* send timeout/sys timeout       */
    void (CALLBACK *ncb_post)( struct _NCB * ); /* POST routine address        */
    UCHAR   ncb_lana_num;           /* lana (adapter) number          */
    UCHAR   ncb_cmd_cplt;           /* 0xff => commmand pending       */
    UCHAR   ncb_reserve[10];        /* reserved, used by BIOS         */
    HANDLE  ncb_event;              /* HANDLE to Win32 event which    */
                                    /* will be set to the signalled   */
                                    /* state when an ASYNCH command   */
                                    /* completes                      */
} NCB, *PNCB;

/*
 *  Structure returned to the NCB command NCBASTAT is ADAPTER_STATUS followed
 *  by an array of NAME_BUFFER structures.
 */

typedef struct _ADAPTER_STATUS {
    UCHAR   adapter_address[6];
    UCHAR   rev_major;
    UCHAR   reserved0;
    UCHAR   adapter_type;
    UCHAR   rev_minor;
    WORD    duration;
    WORD    frmr_recv;
    WORD    frmr_xmit;

    WORD    iframe_recv_err;

    WORD    xmit_aborts;
    DWORD   xmit_success;
    DWORD   recv_success;

    WORD    iframe_xmit_err;

    WORD    recv_buff_unavail;
    WORD    t1_timeouts;
    WORD    ti_timeouts;
    DWORD   reserved1;
    WORD    free_ncbs;
    WORD    max_cfg_ncbs;
    WORD    max_ncbs;
    WORD    xmit_buf_unavail;
    WORD    max_dgram_size;
    WORD    pending_sess;
    WORD    max_cfg_sess;
    WORD    max_sess;
    WORD    max_sess_pkt_size;
    WORD    name_count;
} ADAPTER_STATUS, *PADAPTER_STATUS;

typedef struct _NAME_BUFFER {
    UCHAR   name[NCBNAMSZ];
    UCHAR   name_num;
    UCHAR   name_flags;
} NAME_BUFFER, *PNAME_BUFFER;

//  values for name_flags bits.

#define NAME_FLAGS_MASK 0x87

#define GROUP_NAME      0x80
#define UNIQUE_NAME     0x00

#define REGISTERING     0x00
#define REGISTERED      0x04
#define DEREGISTERED    0x05
#define DUPLICATE       0x06
#define DUPLICATE_DEREG 0x07

/*
 *  Structure returned to the NCB command NCBSSTAT is SESSION_HEADER followed
 *  by an array of SESSION_BUFFER structures. If the NCB_NAME starts with an
 *  asterisk then an array of these structures is returned containing the
 *  status for all names.
 */

typedef struct _SESSION_HEADER {
    UCHAR   sess_name;
    UCHAR   num_sess;
    UCHAR   rcv_dg_outstanding;
    UCHAR   rcv_any_outstanding;
} SESSION_HEADER, *PSESSION_HEADER;

typedef struct _SESSION_BUFFER {
    UCHAR   lsn;
    UCHAR   state;
    UCHAR   local_name[NCBNAMSZ];
    UCHAR   remote_name[NCBNAMSZ];
    UCHAR   rcvs_outstanding;
    UCHAR   sends_outstanding;
} SESSION_BUFFER, *PSESSION_BUFFER;

//  Values for state

#define LISTEN_OUTSTANDING      0x01
#define CALL_PENDING            0x02
#define SESSION_ESTABLISHED     0x03
#define HANGUP_PENDING          0x04
#define HANGUP_COMPLETE         0x05
#define SESSION_ABORTED         0x06

/*
 *  Structure returned to the NCB command NCBENUM.
 *
 *  On a system containing lana's 0, 2 and 3, a structure with
 *  length =3, lana[0]=0, lana[1]=2 and lana[2]=3 will be returned.
 */

typedef struct _LANA_ENUM {
    UCHAR   length;         //  Number of valid entries in lana[]
    UCHAR   lana[MAX_LANA+1];
} LANA_ENUM, *PLANA_ENUM;

/*
 *  Structure returned to the NCB command NCBFINDNAME is FIND_NAME_HEADER followed
 *  by an array of FIND_NAME_BUFFER structures.
 */

typedef struct _FIND_NAME_HEADER {
    WORD    node_count;
    UCHAR   reserved;
    UCHAR   unique_group;
} FIND_NAME_HEADER, *PFIND_NAME_HEADER;

typedef struct _FIND_NAME_BUFFER {
    UCHAR   length;
    UCHAR   access_control;
    UCHAR   frame_control;
    UCHAR   destination_addr[6];
    UCHAR   source_addr[6];
    UCHAR   routing_info[18];
} FIND_NAME_BUFFER, *PFIND_NAME_BUFFER;

/*
 *  Structure provided with NCBACTION. The purpose of NCBACTION is to provide
 *  transport specific extensions to netbios.
 */

typedef struct _ACTION_HEADER {
    ULONG   transport_id;
    USHORT  action_code;
    USHORT  reserved;
} ACTION_HEADER, *PACTION_HEADER;

//  Values for transport_id

#define ALL_TRANSPORTS  "M\0\0\0"
#define MS_NBF          "MNBF"


/****************************************************************
 *                                                              *
 *              Special values and constants                    *
 *                                                              *
 ****************************************************************/

/*
 *      NCB Command codes
 */

#define NCBCALL         0x10            /* NCB CALL                           */
#define NCBLISTEN       0x11            /* NCB LISTEN                         */
#define NCBHANGUP       0x12            /* NCB HANG UP                        */
#define NCBSEND         0x14            /* NCB SEND                           */
#define NCBRECV         0x15            /* NCB RECEIVE                        */
#define NCBRECVANY      0x16            /* NCB RECEIVE ANY                    */
#define NCBCHAINSEND    0x17            /* NCB CHAIN SEND                     */
#define NCBDGSEND       0x20            /* NCB SEND DATAGRAM                  */
#define NCBDGRECV       0x21            /* NCB RECEIVE DATAGRAM               */
#define NCBDGSENDBC     0x22            /* NCB SEND BROADCAST DATAGRAM        */
#define NCBDGRECVBC     0x23            /* NCB RECEIVE BROADCAST DATAGRAM     */
#define NCBADDNAME      0x30            /* NCB ADD NAME                       */
#define NCBDELNAME      0x31            /* NCB DELETE NAME                    */
#define NCBRESET        0x32            /* NCB RESET                          */
#define NCBASTAT        0x33            /* NCB ADAPTER STATUS                 */
#define NCBSSTAT        0x34            /* NCB SESSION STATUS                 */
#define NCBCANCEL       0x35            /* NCB CANCEL                         */
#define NCBADDGRNAME    0x36            /* NCB ADD GROUP NAME                 */
#define NCBENUM         0x37            /* NCB ENUMERATE LANA NUMBERS         */
#define NCBUNLINK       0x70            /* NCB UNLINK                         */
#define NCBSENDNA       0x71            /* NCB SEND NO ACK                    */
#define NCBCHAINSENDNA  0x72            /* NCB CHAIN SEND NO ACK              */
#define NCBLANSTALERT   0x73            /* NCB LAN STATUS ALERT               */
#define NCBACTION       0x77            /* NCB ACTION                         */
#define NCBFINDNAME     0x78            /* NCB FIND NAME                      */
#define NCBTRACE        0x79            /* NCB TRACE                          */


#define ASYNCH          0x80            /* high bit set == asynchronous       */

/*
 *      NCB Return codes
 */

#define NRC_GOODRET     0x00    /* good return                                */
                                /* also returned when ASYNCH request accepted */
#define NRC_BUFLEN      0x01    /* illegal buffer length                      */
#define NRC_ILLCMD      0x03    /* illegal command                            */
#define NRC_CMDTMO      0x05    /* command timed out                          */
#define NRC_INCOMP      0x06    /* message incomplete, issue another command  */
#define NRC_BADDR       0x07    /* illegal buffer address                     */
#define NRC_SNUMOUT     0x08    /* session number out of range                */
#define NRC_NORES       0x09    /* no resource available                      */
#define NRC_SCLOSED     0x0a    /* session closed                             */
#define NRC_CMDCAN      0x0b    /* command cancelled                          */
#define NRC_DUPNAME     0x0d    /* duplicate name                             */
#define NRC_NAMTFUL     0x0e    /* name table full                            */
#define NRC_ACTSES      0x0f    /* no deletions, name has active sessions     */
#define NRC_LOCTFUL     0x11    /* local session table full                   */
#define NRC_REMTFUL     0x12    /* remote session table full                  */
#define NRC_ILLNN       0x13    /* illegal name number                        */
#define NRC_NOCALL      0x14    /* no callname                                */
#define NRC_NOWILD      0x15    /* cannot put * in NCB_NAME                   */
#define NRC_INUSE       0x16    /* name in use on remote adapter              */
#define NRC_NAMERR      0x17    /* name deleted                               */
#define NRC_SABORT      0x18    /* session ended abnormally                   */
#define NRC_NAMCONF     0x19    /* name conflict detected                     */
#define NRC_IFBUSY      0x21    /* interface busy, IRET before retrying       */
#define NRC_TOOMANY     0x22    /* too many commands outstanding, retry later */
#define NRC_BRIDGE      0x23    /* ncb_lana_num field invalid                 */
#define NRC_CANOCCR     0x24    /* command completed while cancel occurring   */
#define NRC_CANCEL      0x26    /* command not valid to cancel                */
#define NRC_DUPENV      0x30    /* name defined by anther local process       */
#define NRC_ENVNOTDEF   0x34    /* environment undefined. RESET required      */
#define NRC_OSRESNOTAV  0x35    /* required OS resources exhausted            */
#define NRC_MAXAPPS     0x36    /* max number of applications exceeded        */
#define NRC_NOSAPS      0x37    /* no saps available for netbios              */
#define NRC_NORESOURCES 0x38    /* requested resources are not available      */
#define NRC_INVADDRESS  0x39    /* invalid ncb address or length > segment    */
#define NRC_INVDDID     0x3B    /* invalid NCB DDID                           */
#define NRC_LOCKFAIL    0x3C    /* lock of user area failed                   */
#define NRC_OPENERR     0x3f    /* NETBIOS not loaded                         */
#define NRC_SYSTEM      0x40    /* system error                               */

#define NRC_PENDING     0xff    /* asynchronous command is not yet finished   */

/****************************************************************
 *                                                              *
 *              main user entry point for NetBIOS 3.0           *
 *                                                              *
 * Usage: result = Netbios( pncb );                             *
 ****************************************************************/

UCHAR
APIENTRY
Netbios(
    PNCB pncb
    );

/****************************************************************
 *                                                              *
 *              Prefix for callback routines                    *
 *                                                              *
 * Usage in a declaration: NCB_POST MyPostRoutine( PNCB pncb ); *
 ****************************************************************/

#define NCB_POST void CALLBACK

#ifdef __cplusplus
}
#endif

#endif /* NCB_INCLUDED */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\inc32\OLE.H ===
/*****************************************************************************\
*                                                                             *
* ole.h -       Object Linking and Embedding functions, types, and definitions*
*                                                                             *
*               Version 1.0                                                   *
*                                                                             *
*               NOTE: windows.h must be #included first                       *
*                                                                             *
*               Copyright (c) 1990-1995, Microsoft Corp.  All rights reserved.*
*                                                                             *
\*****************************************************************************/

#ifndef _INC_OLE
#define _INC_OLE

#ifdef WIN16
#include <pshpack1.h>   /* Assume byte packing throughout */
#endif

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */

#ifndef WINAPI          /* If not included with 3.1 headers... */
#define WINAPI      FAR PASCAL
#define CALLBACK    FAR PASCAL
#define LPCSTR      LPSTR
#define LRESULT     LONG
#define HGLOBAL     HANDLE
#endif  /* _INC_WINDOWS */


#ifdef STRICT
#define OLE_LPCSTR  LPCSTR
#define OLE_CONST   const
#else   /* STRICT */
#define OLE_LPCSTR  LPSTR
#define OLE_CONST
#endif /* !STRICT */

#define LRESULT     LONG
#define HGLOBAL     HANDLE


/* Object types */
#define OT_LINK             1L
#define OT_EMBEDDED         2L
#define OT_STATIC           3L

/* activate verbs */
#define OLEVERB_PRIMARY     0

/* target device info structure */
typedef struct _OLETARGETDEVICE
{
    USHORT otdDeviceNameOffset;
    USHORT otdDriverNameOffset;
    USHORT otdPortNameOffset;
    USHORT otdExtDevmodeOffset;
    USHORT otdExtDevmodeSize;
    USHORT otdEnvironmentOffset;
    USHORT otdEnvironmentSize;
    BYTE otdData[1];
} OLETARGETDEVICE;
typedef OLETARGETDEVICE FAR* LPOLETARGETDEVICE;

/* flags used in some methods */
#define OF_SET              0x0001
#define OF_GET              0x0002
#define OF_HANDLER          0x0004

/* return codes for OLE functions */
typedef enum
{
    OLE_OK,                     /* 0   Function operated correctly             */

    OLE_WAIT_FOR_RELEASE,       /* 1   Command has been initiated, client      */
                                /*     must wait for release. keep dispatching */
                                /*     messages till OLE_RELESE in callback    */

    OLE_BUSY,                   /* 2   Tried to execute a method while another */
                                /*     method is in progress.                  */

    OLE_ERROR_PROTECT_ONLY,     /* 3   Ole APIs are called in real mode        */
    OLE_ERROR_MEMORY,           /* 4   Could not alloc or lock memory          */
    OLE_ERROR_STREAM,           /* 5  (OLESTREAM) stream error                 */
    OLE_ERROR_STATIC,           /* 6   Non static object expected              */
    OLE_ERROR_BLANK,            /* 7   Critical data missing                   */
    OLE_ERROR_DRAW,             /* 8   Error while drawing                     */
    OLE_ERROR_METAFILE,         /* 9   Invalid metafile                        */
    OLE_ERROR_ABORT,            /* 10  Client chose to abort metafile drawing  */
    OLE_ERROR_CLIPBOARD,        /* 11  Failed to get/set clipboard data        */
    OLE_ERROR_FORMAT,           /* 12  Requested format is not available       */
    OLE_ERROR_OBJECT,           /* 13  Not a valid object                      */
    OLE_ERROR_OPTION,           /* 14  Invalid option(link update / render)    */
    OLE_ERROR_PROTOCOL,         /* 15  Invalid protocol                        */
    OLE_ERROR_ADDRESS,          /* 16  One of the pointers is invalid          */
    OLE_ERROR_NOT_EQUAL,        /* 17  Objects are not equal                   */
    OLE_ERROR_HANDLE,           /* 18  Invalid handle encountered              */
    OLE_ERROR_GENERIC,          /* 19  Some general error                      */
    OLE_ERROR_CLASS,            /* 20  Invalid class                           */
    OLE_ERROR_SYNTAX,           /* 21  Command syntax is invalid               */
    OLE_ERROR_DATATYPE,         /* 22  Data format is not supported            */
    OLE_ERROR_PALETTE,          /* 23  Invalid color palette                   */
    OLE_ERROR_NOT_LINK,         /* 24  Not a linked object                     */
    OLE_ERROR_NOT_EMPTY,        /* 25  Client doc contains objects.            */
    OLE_ERROR_SIZE,             /* 26  Incorrect buffer size passed to the api */
                                /*     that places some string in caller's     */
                                /*     buffer                                  */

    OLE_ERROR_DRIVE,            /* 27  Drive letter in doc name is invalid     */
    OLE_ERROR_NETWORK,          /* 28  Failed to establish connection to a     */
                                /*     network share on which the document     */
                                /*     is located                              */

    OLE_ERROR_NAME,             /* 29  Invalid name(doc name, object name),    */
                                /*     etc.. passed to the APIs                */

    OLE_ERROR_TEMPLATE,         /* 30  Server failed to load template          */
    OLE_ERROR_NEW,              /* 31  Server failed to create new doc         */
    OLE_ERROR_EDIT,             /* 32  Server failed to create embedded        */
                                /*     instance                                */
    OLE_ERROR_OPEN,             /* 33  Server failed to open document,         */
                                /*     possible invalid link                   */

    OLE_ERROR_NOT_OPEN,         /* 34  Object is not open for editing          */
    OLE_ERROR_LAUNCH,           /* 35  Failed to launch server                 */
    OLE_ERROR_COMM,             /* 36  Failed to communicate with server       */
    OLE_ERROR_TERMINATE,        /* 37  Error in termination                    */
    OLE_ERROR_COMMAND,          /* 38  Error in execute                        */
    OLE_ERROR_SHOW,             /* 39  Error in show                           */
    OLE_ERROR_DOVERB,           /* 40  Error in sending do verb, or invalid    */
                                /*     verb                                    */
    OLE_ERROR_ADVISE_NATIVE,    /* 41  Item could be missing                   */
    OLE_ERROR_ADVISE_PICT,      /* 42  Item could be missing or server doesn't */
                                /*     this format.                            */

    OLE_ERROR_ADVISE_RENAME,    /* 43  Server doesn't support rename           */
    OLE_ERROR_POKE_NATIVE,      /* 44  Failure of poking native data to server */
    OLE_ERROR_REQUEST_NATIVE,   /* 45  Server failed to render native data     */
    OLE_ERROR_REQUEST_PICT,     /* 46  Server failed to render presentation    */
                                /*     data                                    */
    OLE_ERROR_SERVER_BLOCKED,   /* 47  Trying to block a blocked server or     */
                                /*     trying to revoke a blocked server       */
                                /*     or document                             */

    OLE_ERROR_REGISTRATION,     /* 48  Server is not registered in regestation */
                                /*     data base                               */
    OLE_ERROR_ALREADY_REGISTERED,/*49  Trying to register same doc multiple    */
                                 /*    times                                   */
    OLE_ERROR_TASK,             /* 50  Server or client task is invalid        */
    OLE_ERROR_OUTOFDATE,        /* 51  Object is out of date                   */
    OLE_ERROR_CANT_UPDATE_CLIENT,/* 52 Embed doc's client doesn't accept       */
                                /*     updates                                 */
    OLE_ERROR_UPDATE,           /* 53  erorr while trying to update            */
    OLE_ERROR_SETDATA_FORMAT,   /* 54  Server app doesn't understand the       */
                                /*     format given to its SetData method      */
    OLE_ERROR_STATIC_FROM_OTHER_OS,/* 55 trying to load a static object created */
                                   /*    on another Operating System           */
    OLE_ERROR_FILE_VER,

    /*  Following are warnings */
    OLE_WARN_DELETE_DATA = 1000 /*     Caller must delete the data when he is  */
                                /*     done with it.                           */
} OLESTATUS;



/* Codes for CallBack events */
typedef enum
{
    OLE_CHANGED,            /* 0                                             */
    OLE_SAVED,              /* 1                                             */
    OLE_CLOSED,             /* 2                                             */
    OLE_RENAMED,            /* 3                                             */
    OLE_QUERY_PAINT,        /* 4  Interruptible paint support                */
    OLE_RELEASE,            /* 5  Object is released(asynchronous operation  */
                            /*    is completed)                              */
    OLE_QUERY_RETRY        /* 6  Query for retry when server sends busy ACK */
} OLE_NOTIFICATION;

typedef enum
{
    OLE_NONE,               /* 0  no method active                           */
    OLE_DELETE,             /* 1  object delete                              */
    OLE_LNKPASTE,           /* 2  PasteLink(auto reconnect)                  */
    OLE_EMBPASTE,           /* 3  paste(and update)                          */
    OLE_SHOW,               /* 4  Show                                       */
    OLE_RUN,                /* 5  Run                                        */
    OLE_ACTIVATE,           /* 6  Activate                                   */
    OLE_UPDATE,             /* 7  Update                                     */
    OLE_CLOSE,              /* 8  Close                                      */
    OLE_RECONNECT,          /* 9  Reconnect                                  */
    OLE_SETUPDATEOPTIONS,   /* 10 setting update options                     */
    OLE_SERVERUNLAUNCH,     /* 11 server is being unlaunched                 */
    OLE_LOADFROMSTREAM,     /* 12 LoadFromStream(auto reconnect)             */
    OLE_SETDATA,            /* 13 OleSetData                                 */
    OLE_REQUESTDATA,        /* 14 OleRequestData                             */
    OLE_OTHER,              /* 15 other misc async operations                */
    OLE_CREATE,             /* 16 create                                     */
    OLE_CREATEFROMTEMPLATE, /* 17 CreatefromTemplate                         */
    OLE_CREATELINKFROMFILE, /* 18 CreateLinkFromFile                         */
    OLE_COPYFROMLNK,        /* 19 CopyFromLink(auto reconnect)               */
    OLE_CREATEFROMFILE,     /* 20 CreateFromFile                             */
    OLE_CREATEINVISIBLE     /* 21 CreateInvisible                            */
} OLE_RELEASE_METHOD;

/* rendering options */
typedef enum
{
    olerender_none,
    olerender_draw,
    olerender_format
} OLEOPT_RENDER;

/* standard clipboard format type */
typedef WORD OLECLIPFORMAT;

/* Link update options */
typedef enum
{
    oleupdate_always,
    oleupdate_onsave,
#ifdef OLE_INTERNAL
    oleupdate_oncall,
    oleupdate_onclose
#else
    oleupdate_oncall
#endif  /* OLE_INTERNAL */
} OLEOPT_UPDATE;

typedef HANDLE  HOBJECT;
typedef LONG    LHSERVER;
typedef LONG    LHCLIENTDOC;
typedef LONG    LHSERVERDOC;

typedef struct _OLEOBJECT FAR*  LPOLEOBJECT;
typedef struct _OLESTREAM FAR*  LPOLESTREAM;
typedef struct _OLECLIENT FAR*  LPOLECLIENT;


/* object method table definitions. */
typedef struct _OLEOBJECTVTBL
{
    void FAR*      (CALLBACK* QueryProtocol)        (LPOLEOBJECT, OLE_LPCSTR);
    OLESTATUS      (CALLBACK* Release)              (LPOLEOBJECT);
    OLESTATUS      (CALLBACK* Show)                 (LPOLEOBJECT, BOOL);
    OLESTATUS      (CALLBACK* DoVerb)               (LPOLEOBJECT, UINT, BOOL, BOOL);
    OLESTATUS      (CALLBACK* GetData)              (LPOLEOBJECT, OLECLIPFORMAT, HANDLE FAR*);
    OLESTATUS      (CALLBACK* SetData)              (LPOLEOBJECT, OLECLIPFORMAT, HANDLE);
    OLESTATUS      (CALLBACK* SetTargetDevice)      (LPOLEOBJECT, HGLOBAL);
    OLESTATUS      (CALLBACK* SetBounds)            (LPOLEOBJECT, OLE_CONST RECT FAR*);
    OLECLIPFORMAT  (CALLBACK* EnumFormats)          (LPOLEOBJECT, OLECLIPFORMAT);
    OLESTATUS      (CALLBACK* SetColorScheme)       (LPOLEOBJECT, OLE_CONST LOGPALETTE FAR*);
    /* Server has to implement only the above methods. */

#ifndef SERVERONLY
    /* Extra methods required for client. */
    OLESTATUS      (CALLBACK* Delete)               (LPOLEOBJECT);
    OLESTATUS      (CALLBACK* SetHostNames)         (LPOLEOBJECT, OLE_LPCSTR, OLE_LPCSTR);
    OLESTATUS      (CALLBACK* SaveToStream)         (LPOLEOBJECT, LPOLESTREAM);
    OLESTATUS      (CALLBACK* Clone)                (LPOLEOBJECT, LPOLECLIENT, LHCLIENTDOC, OLE_LPCSTR, LPOLEOBJECT FAR*);
    OLESTATUS      (CALLBACK* CopyFromLink)         (LPOLEOBJECT, LPOLECLIENT, LHCLIENTDOC, OLE_LPCSTR, LPOLEOBJECT FAR*);
    OLESTATUS      (CALLBACK* Equal)                (LPOLEOBJECT, LPOLEOBJECT);
    OLESTATUS      (CALLBACK* CopyToClipboard)      (LPOLEOBJECT);
    OLESTATUS      (CALLBACK* Draw)                 (LPOLEOBJECT, HDC, OLE_CONST RECT FAR*, OLE_CONST RECT FAR*, HDC);
    OLESTATUS      (CALLBACK* Activate)             (LPOLEOBJECT, UINT, BOOL, BOOL, HWND, OLE_CONST RECT FAR*);
    OLESTATUS      (CALLBACK* Execute)              (LPOLEOBJECT, HGLOBAL, UINT);
    OLESTATUS      (CALLBACK* Close)                (LPOLEOBJECT);
    OLESTATUS      (CALLBACK* Update)               (LPOLEOBJECT);
    OLESTATUS      (CALLBACK* Reconnect)            (LPOLEOBJECT);

    OLESTATUS      (CALLBACK* ObjectConvert)        (LPOLEOBJECT, OLE_LPCSTR, LPOLECLIENT, LHCLIENTDOC, OLE_LPCSTR, LPOLEOBJECT FAR*);
    OLESTATUS      (CALLBACK* GetLinkUpdateOptions) (LPOLEOBJECT, OLEOPT_UPDATE FAR*);
    OLESTATUS      (CALLBACK* SetLinkUpdateOptions) (LPOLEOBJECT, OLEOPT_UPDATE);

    OLESTATUS      (CALLBACK* Rename)               (LPOLEOBJECT, OLE_LPCSTR);
    OLESTATUS      (CALLBACK* QueryName)            (LPOLEOBJECT, LPSTR, UINT FAR*);

    OLESTATUS      (CALLBACK* QueryType)            (LPOLEOBJECT, LONG FAR*);
    OLESTATUS      (CALLBACK* QueryBounds)          (LPOLEOBJECT, RECT FAR*);
    OLESTATUS      (CALLBACK* QuerySize)            (LPOLEOBJECT, DWORD FAR*);
    OLESTATUS      (CALLBACK* QueryOpen)            (LPOLEOBJECT);
    OLESTATUS      (CALLBACK* QueryOutOfDate)       (LPOLEOBJECT);

    OLESTATUS      (CALLBACK* QueryReleaseStatus)   (LPOLEOBJECT);
    OLESTATUS      (CALLBACK* QueryReleaseError)    (LPOLEOBJECT);
    OLE_RELEASE_METHOD (CALLBACK* QueryReleaseMethod)(LPOLEOBJECT);

    OLESTATUS      (CALLBACK* RequestData)          (LPOLEOBJECT, OLECLIPFORMAT);
    OLESTATUS      (CALLBACK* ObjectLong)           (LPOLEOBJECT, UINT, LONG FAR*);

/* This method is internal only */
    OLESTATUS      (CALLBACK* ChangeData)           (LPOLEOBJECT, HANDLE, LPOLECLIENT, BOOL);
#endif  /* !SERVERONLY */
} OLEOBJECTVTBL;
typedef  OLEOBJECTVTBL FAR* LPOLEOBJECTVTBL;

#ifndef OLE_INTERNAL
typedef struct _OLEOBJECT
{
    LPOLEOBJECTVTBL    lpvtbl;
} OLEOBJECT;
#endif

/* ole client definitions */
typedef struct _OLECLIENTVTBL
{
    int (CALLBACK* CallBack)(LPOLECLIENT, OLE_NOTIFICATION, LPOLEOBJECT);
} OLECLIENTVTBL;

typedef  OLECLIENTVTBL FAR*  LPOLECLIENTVTBL;

typedef struct _OLECLIENT
{
    LPOLECLIENTVTBL   lpvtbl;
} OLECLIENT;

/* Stream definitions */
typedef struct _OLESTREAMVTBL
{
    DWORD (CALLBACK* Get)(LPOLESTREAM, void FAR*, DWORD);
    DWORD (CALLBACK* Put)(LPOLESTREAM, OLE_CONST void FAR*, DWORD);
} OLESTREAMVTBL;
typedef  OLESTREAMVTBL FAR*  LPOLESTREAMVTBL;

typedef struct _OLESTREAM
{
    LPOLESTREAMVTBL      lpstbl;
} OLESTREAM;

/* Public Function Prototypes */
OLESTATUS   WINAPI  OleDelete(LPOLEOBJECT);
OLESTATUS   WINAPI  OleRelease(LPOLEOBJECT);
OLESTATUS   WINAPI  OleSaveToStream(LPOLEOBJECT, LPOLESTREAM);
OLESTATUS   WINAPI  OleEqual(LPOLEOBJECT, LPOLEOBJECT );
OLESTATUS   WINAPI  OleCopyToClipboard(LPOLEOBJECT);
OLESTATUS   WINAPI  OleSetHostNames(LPOLEOBJECT, LPCSTR, LPCSTR);
OLESTATUS   WINAPI  OleSetTargetDevice(LPOLEOBJECT, HGLOBAL);
OLESTATUS   WINAPI  OleSetBounds(LPOLEOBJECT, const RECT FAR*);
OLESTATUS   WINAPI  OleSetColorScheme(LPOLEOBJECT, const LOGPALETTE FAR*);
OLESTATUS   WINAPI  OleQueryBounds(LPOLEOBJECT, RECT FAR*);
OLESTATUS   WINAPI  OleQuerySize(LPOLEOBJECT, DWORD FAR*);
OLESTATUS   WINAPI  OleDraw(LPOLEOBJECT, HDC, const RECT FAR*, const RECT FAR*, HDC);
OLESTATUS   WINAPI  OleQueryOpen(LPOLEOBJECT);
OLESTATUS   WINAPI  OleActivate(LPOLEOBJECT, UINT, BOOL, BOOL, HWND, const RECT FAR*);
OLESTATUS   WINAPI  OleExecute(LPOLEOBJECT, HGLOBAL, UINT);
OLESTATUS   WINAPI  OleClose(LPOLEOBJECT);
OLESTATUS   WINAPI  OleUpdate(LPOLEOBJECT);
OLESTATUS   WINAPI  OleReconnect(LPOLEOBJECT);
OLESTATUS   WINAPI  OleGetLinkUpdateOptions(LPOLEOBJECT, OLEOPT_UPDATE FAR*);
OLESTATUS   WINAPI  OleSetLinkUpdateOptions(LPOLEOBJECT, OLEOPT_UPDATE);
void FAR*   WINAPI  OleQueryProtocol(LPOLEOBJECT, LPCSTR);

/* Routines related to asynchronous operations. */
OLESTATUS   WINAPI  OleQueryReleaseStatus(LPOLEOBJECT);
OLESTATUS   WINAPI  OleQueryReleaseError(LPOLEOBJECT);
OLE_RELEASE_METHOD WINAPI OleQueryReleaseMethod(LPOLEOBJECT);

OLESTATUS   WINAPI  OleQueryType(LPOLEOBJECT, LONG FAR*);

/* LOWORD is major version, HIWORD is minor version */
DWORD       WINAPI  OleQueryClientVersion(void);
DWORD       WINAPI  OleQueryServerVersion(void);

/* Converting to format (as in clipboard): */
OLECLIPFORMAT  WINAPI  OleEnumFormats(LPOLEOBJECT, OLECLIPFORMAT);
OLESTATUS   WINAPI  OleGetData(LPOLEOBJECT, OLECLIPFORMAT, HANDLE FAR*);
OLESTATUS   WINAPI  OleSetData(LPOLEOBJECT, OLECLIPFORMAT, HANDLE);
OLESTATUS   WINAPI  OleQueryOutOfDate(LPOLEOBJECT);
OLESTATUS   WINAPI  OleRequestData(LPOLEOBJECT, OLECLIPFORMAT);

/* Query apis for creation from clipboard */
OLESTATUS   WINAPI  OleQueryLinkFromClip(LPCSTR, OLEOPT_RENDER, OLECLIPFORMAT);
OLESTATUS   WINAPI  OleQueryCreateFromClip(LPCSTR, OLEOPT_RENDER, OLECLIPFORMAT);

/* Object creation functions */
OLESTATUS   WINAPI  OleCreateFromClip(LPCSTR, LPOLECLIENT, LHCLIENTDOC, LPCSTR,  LPOLEOBJECT FAR*, OLEOPT_RENDER, OLECLIPFORMAT);
OLESTATUS   WINAPI  OleCreateLinkFromClip(LPCSTR, LPOLECLIENT, LHCLIENTDOC, LPCSTR, LPOLEOBJECT FAR*, OLEOPT_RENDER, OLECLIPFORMAT);
OLESTATUS   WINAPI  OleCreateFromFile(LPCSTR, LPOLECLIENT, LPCSTR, LPCSTR, LHCLIENTDOC, LPCSTR, LPOLEOBJECT FAR*, OLEOPT_RENDER, OLECLIPFORMAT);
OLESTATUS   WINAPI  OleCreateLinkFromFile(LPCSTR, LPOLECLIENT, LPCSTR, LPCSTR, LPCSTR, LHCLIENTDOC, LPCSTR, LPOLEOBJECT FAR*, OLEOPT_RENDER, OLECLIPFORMAT);
OLESTATUS   WINAPI  OleLoadFromStream(LPOLESTREAM, LPCSTR, LPOLECLIENT, LHCLIENTDOC, LPCSTR, LPOLEOBJECT FAR*);
OLESTATUS   WINAPI  OleCreate(LPCSTR, LPOLECLIENT, LPCSTR, LHCLIENTDOC, LPCSTR, LPOLEOBJECT FAR*, OLEOPT_RENDER, OLECLIPFORMAT);
OLESTATUS   WINAPI  OleCreateInvisible(LPCSTR, LPOLECLIENT, LPCSTR, LHCLIENTDOC, LPCSTR, LPOLEOBJECT FAR*, OLEOPT_RENDER, OLECLIPFORMAT, BOOL);
OLESTATUS   WINAPI  OleCreateFromTemplate(LPCSTR, LPOLECLIENT, LPCSTR, LHCLIENTDOC, LPCSTR, LPOLEOBJECT FAR*, OLEOPT_RENDER, OLECLIPFORMAT);
OLESTATUS   WINAPI  OleClone(LPOLEOBJECT, LPOLECLIENT, LHCLIENTDOC, LPCSTR, LPOLEOBJECT FAR*);
OLESTATUS   WINAPI  OleCopyFromLink(LPOLEOBJECT, LPCSTR, LPOLECLIENT, LHCLIENTDOC, LPCSTR, LPOLEOBJECT FAR*);
OLESTATUS   WINAPI  OleObjectConvert(LPOLEOBJECT, LPCSTR, LPOLECLIENT, LHCLIENTDOC, LPCSTR, LPOLEOBJECT FAR*);
OLESTATUS   WINAPI  OleRename(LPOLEOBJECT, LPCSTR);
OLESTATUS   WINAPI  OleQueryName(LPOLEOBJECT, LPSTR, UINT FAR*);
OLESTATUS   WINAPI  OleRevokeObject(LPOLECLIENT);
BOOL        WINAPI  OleIsDcMeta(HDC);

/* client document API */
OLESTATUS   WINAPI  OleRegisterClientDoc(LPCSTR, LPCSTR, LONG, LHCLIENTDOC FAR*);
OLESTATUS   WINAPI  OleRevokeClientDoc(LHCLIENTDOC);
OLESTATUS   WINAPI  OleRenameClientDoc(LHCLIENTDOC, LPCSTR);
OLESTATUS   WINAPI  OleRevertClientDoc(LHCLIENTDOC);
OLESTATUS   WINAPI  OleSavedClientDoc(LHCLIENTDOC);
OLESTATUS   WINAPI  OleEnumObjects(LHCLIENTDOC, LPOLEOBJECT FAR*);

/* server usage definitions */
typedef enum {
    OLE_SERVER_MULTI,           /* multiple instances */
    OLE_SERVER_SINGLE           /* single instance(multiple document) */
} OLE_SERVER_USE;

/* Server API */
typedef struct _OLESERVER FAR*  LPOLESERVER;

OLESTATUS   WINAPI  OleRegisterServer(LPCSTR, LPOLESERVER, LHSERVER FAR*, HINSTANCE, OLE_SERVER_USE);
OLESTATUS   WINAPI  OleRevokeServer(LHSERVER);
OLESTATUS   WINAPI  OleBlockServer(LHSERVER);
OLESTATUS   WINAPI  OleUnblockServer(LHSERVER, BOOL FAR*);

/* APIs to keep server open */
OLESTATUS   WINAPI  OleLockServer(LPOLEOBJECT, LHSERVER FAR*);
OLESTATUS   WINAPI  OleUnlockServer(LHSERVER);

/* Server document API */

typedef struct _OLESERVERDOC FAR*  LPOLESERVERDOC;

OLESTATUS   WINAPI  OleRegisterServerDoc(LHSERVER, LPCSTR, LPOLESERVERDOC, LHSERVERDOC FAR*);
OLESTATUS   WINAPI  OleRevokeServerDoc(LHSERVERDOC);
OLESTATUS   WINAPI  OleRenameServerDoc(LHSERVERDOC, LPCSTR);
OLESTATUS   WINAPI  OleRevertServerDoc(LHSERVERDOC);
OLESTATUS   WINAPI  OleSavedServerDoc(LHSERVERDOC);

typedef struct _OLESERVERVTBL
{
    OLESTATUS (CALLBACK* Open)  (LPOLESERVER, LHSERVERDOC, OLE_LPCSTR, LPOLESERVERDOC FAR*);
                                    /* long handle to doc(privtate to DLL)  */
                                    /* lp to OLESERVER                      */
                                    /* document name                        */
                                    /* place holder for returning oledoc.   */

    OLESTATUS (CALLBACK* Create)(LPOLESERVER, LHSERVERDOC, OLE_LPCSTR, OLE_LPCSTR, LPOLESERVERDOC FAR*);
                                    /* long handle to doc(privtate to DLL)  */
                                    /* lp to OLESERVER                      */
                                    /* lp class name                        */
                                    /* lp doc name                          */
                                    /* place holder for returning oledoc.   */

    OLESTATUS (CALLBACK* CreateFromTemplate)(LPOLESERVER, LHSERVERDOC, OLE_LPCSTR, OLE_LPCSTR, OLE_LPCSTR, LPOLESERVERDOC FAR*);
                                    /* long handle to doc(privtate to DLL)  */
                                    /* lp to OLESERVER                      */
                                    /* lp class name                        */
                                    /* lp doc name                          */
                                    /* lp template name                     */
                                    /* place holder for returning oledoc.   */

    OLESTATUS (CALLBACK* Edit)  (LPOLESERVER, LHSERVERDOC, OLE_LPCSTR, OLE_LPCSTR, LPOLESERVERDOC FAR*);
                                    /* long handle to doc(privtate to DLL)  */
                                    /* lp to OLESERVER                      */
                                    /* lp class name                        */
                                    /* lp doc name                          */
                                    /* place holder for returning oledoc.   */

    OLESTATUS (CALLBACK* Exit)  (LPOLESERVER);
                                    /* lp OLESERVER                         */

    OLESTATUS (CALLBACK* Release)  (LPOLESERVER);
                                    /* lp OLESERVER                         */

    OLESTATUS (CALLBACK* Execute)(LPOLESERVER, HGLOBAL);
                                    /* lp OLESERVER                         */
                                    /* handle to command strings            */
} OLESERVERVTBL;
typedef  OLESERVERVTBL FAR*  LPOLESERVERVTBL;

typedef struct _OLESERVER
{
    LPOLESERVERVTBL    lpvtbl;
} OLESERVER;

typedef struct _OLESERVERDOCVTBL
{
    OLESTATUS (CALLBACK* Save)      (LPOLESERVERDOC);
    OLESTATUS (CALLBACK* Close)     (LPOLESERVERDOC);
    OLESTATUS (CALLBACK* SetHostNames)(LPOLESERVERDOC, OLE_LPCSTR, OLE_LPCSTR);
    OLESTATUS (CALLBACK* SetDocDimensions)(LPOLESERVERDOC, OLE_CONST RECT FAR*);
    OLESTATUS (CALLBACK* GetObject) (LPOLESERVERDOC, OLE_LPCSTR, LPOLEOBJECT FAR*, LPOLECLIENT);
    OLESTATUS (CALLBACK* Release)   (LPOLESERVERDOC);
    OLESTATUS (CALLBACK* SetColorScheme)(LPOLESERVERDOC, OLE_CONST LOGPALETTE FAR*);
    OLESTATUS (CALLBACK* Execute)  (LPOLESERVERDOC, HGLOBAL);
} OLESERVERDOCVTBL;
typedef  OLESERVERDOCVTBL FAR*  LPOLESERVERDOCVTBL;

typedef struct _OLESERVERDOC
{
    LPOLESERVERDOCVTBL lpvtbl;
} OLESERVERDOC;

#ifdef __cplusplus
}
#endif  /* __cplusplus */

#ifdef WIN16
#include <poppack.h>
#endif

#endif  /* !_INC_OLE */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\inc32\OLEAUTO.H ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       oleauto.h
//
//  Contents:   Defines the Ole Automation interfaces and APIs.
//
//  Interfaces:
//      IDispatch;
//      ITypeInfo;
//      ITypeLib;
//      ITypeComp;
//      ICreateTypeInfo;
//      ICreateTypeLib;
//      IErrorInfo;
//      ICreateErrorInfo;
//      ISupportErrorInfo;
//
//  Functions:  SysAllocString         BSTR API
//      SysReAllocString
//      SysAllocStringLen
//      SysReAllocStringLen
//      SysFreeString
//      SysStringLen
//      DosDateTimeToVariantTime    Time API
//      VariantTimeToDosDateTime
//      SafeArrayCreate         Safe Array API
//      SafeArrayDestroy
//      SafeArrayGetDim
//      SafeArrayGetElemsize
//      SafeArrayGetUBound
//      SafeArrayGetLBound
//      SafeArrayLock
//      SafeArrayUnlock
//      SafeArrayAccessData
//      SafeArrayUnaccessData
//      SafeArrayGetElement
//      SafeArrayPutElement
//      SafeArrayCopy
//      VariantInit         Variant API
//      VariantClear
//      VariantCopy
//      VariantCopyInd
//      VariantChangeType
//      LHashValOfName          TypeInfo API
//      LoadTypeLib
//      LoadRegTypeLib
//      RegisterTypeLib
//      DeregisterTypeLib
//      CreateTypeLib
//      DispGetParam            Dispatch API
//      DispGetIDsOfNames
//      DispInvoke
//      CreateDispTypeInfo
//      CreateStdDispatch
//      RegisterActiveObject        Active Object Registration API
//      RevokeActiveObject
//      GetActiveObject
//      OaBuildVersion
//
//----------------------------------------------------------------------------

#if !defined( _OLEAUTO_H_ )
#define _OLEAUTO_H_

// Set packing to 8 for ISV, and Win95 support
#ifndef RC_INVOKED
#include <pshpack8.h>
#endif // RC_INVOKED

//  Definition of the OLE Automation APIs, and macros.

#ifdef _OLEAUT32_
#define WINOLEAUTAPI        STDAPI
#define WINOLEAUTAPI_(type) STDAPI_(type)
#else
#define WINOLEAUTAPI        EXTERN_C DECLSPEC_IMPORT HRESULT STDAPICALLTYPE
#define WINOLEAUTAPI_(type) EXTERN_C DECLSPEC_IMPORT type STDAPICALLTYPE
#endif

#define STDOLE_MAJORVERNUM              0x1
#define STDOLE_MINORVERNUM              0x0
#define STDOLE_LCID                     0x0000

/* if not already picked up from olenls.h */
#ifndef _LCID_DEFINED
typedef DWORD LCID;
# define _LCID_DEFINED
#endif

/* pull in the MIDL generated header */
#include <oaidl.h>


/*---------------------------------------------------------------------*/
/*                            BSTR API                                 */
/*---------------------------------------------------------------------*/

WINOLEAUTAPI_(BSTR) SysAllocString(const OLECHAR FAR*);
WINOLEAUTAPI_(int)  SysReAllocString(BSTR FAR*, const OLECHAR FAR*);
WINOLEAUTAPI_(BSTR) SysAllocStringLen(const OLECHAR FAR*, unsigned int);
WINOLEAUTAPI_(int)  SysReAllocStringLen(BSTR FAR*, const OLECHAR FAR*, unsigned int);
WINOLEAUTAPI_(void) SysFreeString(BSTR);
WINOLEAUTAPI_(unsigned int) SysStringLen(BSTR);

#ifdef _WIN32
WINOLEAUTAPI_(unsigned int) SysStringByteLen(BSTR bstr);
WINOLEAUTAPI_(BSTR) SysAllocStringByteLen(const char FAR* psz, unsigned int len);
#endif

/*---------------------------------------------------------------------*/
/*                            Time API                                 */
/*---------------------------------------------------------------------*/

WINOLEAUTAPI_(int)
DosDateTimeToVariantTime(
    unsigned short wDosDate,
    unsigned short wDosTime,
    double FAR* pvtime);

WINOLEAUTAPI_(int)
VariantTimeToDosDateTime(
    double vtime,
    unsigned short FAR* pwDosDate,
    unsigned short FAR* pwDosTime);

/*---------------------------------------------------------------------*/
/*                          SafeArray API                              */
/*---------------------------------------------------------------------*/

WINOLEAUTAPI
SafeArrayAllocDescriptor(unsigned int cDims, SAFEARRAY FAR* FAR* ppsaOut);

WINOLEAUTAPI SafeArrayAllocData(SAFEARRAY FAR* psa);

WINOLEAUTAPI_(SAFEARRAY FAR*)
SafeArrayCreate(
    VARTYPE vt,
    unsigned int cDims,
    SAFEARRAYBOUND FAR* rgsabound);

WINOLEAUTAPI SafeArrayDestroyDescriptor(SAFEARRAY FAR* psa);

WINOLEAUTAPI SafeArrayDestroyData(SAFEARRAY FAR* psa);

WINOLEAUTAPI SafeArrayDestroy(SAFEARRAY FAR* psa);

WINOLEAUTAPI SafeArrayRedim(SAFEARRAY FAR* psa, SAFEARRAYBOUND FAR* psaboundNew);

WINOLEAUTAPI_(unsigned int) SafeArrayGetDim(SAFEARRAY FAR* psa);

WINOLEAUTAPI_(unsigned int) SafeArrayGetElemsize(SAFEARRAY FAR* psa);

WINOLEAUTAPI
SafeArrayGetUBound(SAFEARRAY FAR* psa, unsigned int nDim, long FAR* plUbound);

WINOLEAUTAPI
SafeArrayGetLBound(SAFEARRAY FAR* psa, unsigned int nDim, long FAR* plLbound);

WINOLEAUTAPI SafeArrayLock(SAFEARRAY FAR* psa);

WINOLEAUTAPI SafeArrayUnlock(SAFEARRAY FAR* psa);

WINOLEAUTAPI SafeArrayAccessData(SAFEARRAY FAR* psa, void HUGEP* FAR* ppvData);

WINOLEAUTAPI SafeArrayUnaccessData(SAFEARRAY FAR* psa);

WINOLEAUTAPI
SafeArrayGetElement(
    SAFEARRAY FAR* psa,
    long FAR* rgIndices,
    void FAR* pv);

WINOLEAUTAPI
SafeArrayPutElement(
    SAFEARRAY FAR* psa,
    long FAR* rgIndices,
    void FAR* pv);

WINOLEAUTAPI
SafeArrayCopy(
    SAFEARRAY FAR* psa,
    SAFEARRAY FAR* FAR* ppsaOut);

WINOLEAUTAPI
SafeArrayPtrOfIndex(
    SAFEARRAY FAR* psa,
    long FAR* rgIndices,
    void HUGEP* FAR* ppvData);


/*---------------------------------------------------------------------*/
/*                           VARIANT API                               */
/*---------------------------------------------------------------------*/

WINOLEAUTAPI_(void)
VariantInit(VARIANTARG FAR* pvarg);

WINOLEAUTAPI
VariantClear(VARIANTARG FAR* pvarg);

WINOLEAUTAPI
VariantCopy(
    VARIANTARG FAR* pvargDest,
    VARIANTARG FAR* pvargSrc);

WINOLEAUTAPI
VariantCopyInd(
    VARIANT FAR* pvarDest,
    VARIANTARG FAR* pvargSrc);

WINOLEAUTAPI
VariantChangeType(
    VARIANTARG FAR* pvargDest,
    VARIANTARG FAR* pvarSrc,
    unsigned short wFlags,
    VARTYPE vt);

WINOLEAUTAPI
VariantChangeTypeEx(
    VARIANTARG FAR* pvargDest,
    VARIANTARG FAR* pvarSrc,
    LCID lcid,
    unsigned short wFlags,
    VARTYPE vt);

#define VARIANT_NOVALUEPROP 1


/*---------------------------------------------------------------------*/
/*                     VARTYPE Coercion API                            */
/*---------------------------------------------------------------------*/

/* Note: The routines that convert *from* a string are defined
 * to take a OLECHAR* rather than a BSTR because no allocation is
 * required, and this makes the routines a bit more generic.
 * They may of course still be passed a BSTR as the strIn param.
 */


/* Any of the coersion functions that converts either from or to a string
 * takes an additional lcid and dwFlags arguments. The lcid argument allows
 * locale specific parsing to occur.  The dwFlags allow additional function
 * specific condition to occur.  All function that accept the dwFlags argument
 * can include either 0 or LOCALE_NOUSEROVERRIDE flag. In addition, the
 * VarDateFromStr functions also accepts the VAR_TIMEVALUEONLY and
 * VAR_DATEVALUEONLY flags
 */

#define VAR_TIMEVALUEONLY            0x0001    /* return time value */
#define VAR_DATEVALUEONLY            0x0002    /* return date value */


WINOLEAUTAPI VarUI1FromI2(short sIn, unsigned char FAR* pbOut);
WINOLEAUTAPI VarUI1FromI4(long lIn, unsigned char FAR* pbOut);
WINOLEAUTAPI VarUI1FromR4(float fltIn, unsigned char FAR* pbOut);
WINOLEAUTAPI VarUI1FromR8(double dblIn, unsigned char FAR* pbOut);
WINOLEAUTAPI VarUI1FromCy(CY cyIn, unsigned char FAR* pbOut);
WINOLEAUTAPI VarUI1FromDate(DATE dateIn, unsigned char FAR* pbOut);
WINOLEAUTAPI VarUI1FromStr(OLECHAR FAR* strIn, LCID lcid, unsigned long dwFlags, unsigned char FAR* pbOut);
WINOLEAUTAPI VarUI1FromDisp(IDispatch FAR* pdispIn, LCID lcid, unsigned char FAR* pbOut);
WINOLEAUTAPI VarUI1FromBool(VARIANT_BOOL boolIn, unsigned char FAR* pbOut);

WINOLEAUTAPI VarI2FromUI1(unsigned char bIn, short FAR* psOut);
WINOLEAUTAPI VarI2FromI4(long lIn, short FAR* psOut);
WINOLEAUTAPI VarI2FromR4(float fltIn, short FAR* psOut);
WINOLEAUTAPI VarI2FromR8(double dblIn, short FAR* psOut);
WINOLEAUTAPI VarI2FromCy(CY cyIn, short FAR* psOut);
WINOLEAUTAPI VarI2FromDate(DATE dateIn, short FAR* psOut);
WINOLEAUTAPI VarI2FromStr(OLECHAR FAR* strIn, LCID lcid, unsigned long dwFlags, short FAR* psOut);
WINOLEAUTAPI VarI2FromDisp(IDispatch FAR* pdispIn, LCID lcid, short FAR* psOut);
WINOLEAUTAPI VarI2FromBool(VARIANT_BOOL boolIn, short FAR* psOut);

WINOLEAUTAPI VarI4FromUI1(unsigned char bIn, long FAR* plOut);
WINOLEAUTAPI VarI4FromI2(short sIn, long FAR* plOut);
WINOLEAUTAPI VarI4FromR4(float fltIn, long FAR* plOut);
WINOLEAUTAPI VarI4FromR8(double dblIn, long FAR* plOut);
WINOLEAUTAPI VarI4FromCy(CY cyIn, long FAR* plOut);
WINOLEAUTAPI VarI4FromDate(DATE dateIn, long FAR* plOut);
WINOLEAUTAPI VarI4FromStr(OLECHAR FAR* strIn, LCID lcid, unsigned long dwFlags, long FAR* plOut);
WINOLEAUTAPI VarI4FromDisp(IDispatch FAR* pdispIn, LCID lcid, long FAR* plOut);
WINOLEAUTAPI VarI4FromBool(VARIANT_BOOL boolIn, long FAR* plOut);

WINOLEAUTAPI VarR4FromUI1(unsigned char bIn, float FAR* pfltOut);
WINOLEAUTAPI VarR4FromI2(short sIn, float FAR* pfltOut);
WINOLEAUTAPI VarR4FromI4(long lIn, float FAR* pfltOut);
WINOLEAUTAPI VarR4FromR8(double dblIn, float FAR* pfltOut);
WINOLEAUTAPI VarR4FromCy(CY cyIn, float FAR* pfltOut);
WINOLEAUTAPI VarR4FromDate(DATE dateIn, float FAR* pfltOut);
WINOLEAUTAPI VarR4FromStr(OLECHAR FAR* strIn, LCID lcid, unsigned long dwFlags, float FAR* pfltOut);
WINOLEAUTAPI VarR4FromDisp(IDispatch FAR* pdispIn, LCID lcid, float FAR* pfltOut);
WINOLEAUTAPI VarR4FromBool(VARIANT_BOOL boolIn, float FAR* pfltOut);

WINOLEAUTAPI VarR8FromUI1(unsigned char bIn, double FAR* pdblOut);
WINOLEAUTAPI VarR8FromI2(short sIn, double FAR* pdblOut);
WINOLEAUTAPI VarR8FromI4(long lIn, double FAR* pdblOut);
WINOLEAUTAPI VarR8FromR4(float fltIn, double FAR* pdblOut);
WINOLEAUTAPI VarR8FromCy(CY cyIn, double FAR* pdblOut);
WINOLEAUTAPI VarR8FromDate(DATE dateIn, double FAR* pdblOut);
WINOLEAUTAPI VarR8FromStr(OLECHAR FAR* strIn, LCID lcid, unsigned long dwFlags, double FAR* pdblOut);
WINOLEAUTAPI VarR8FromDisp(IDispatch FAR* pdispIn, LCID lcid, double FAR* pdblOut);
WINOLEAUTAPI VarR8FromBool(VARIANT_BOOL boolIn, double FAR* pdblOut);

WINOLEAUTAPI VarDateFromUI1(unsigned char bIn, DATE FAR* pdateOut);
WINOLEAUTAPI VarDateFromI2(short sIn, DATE FAR* pdateOut);
WINOLEAUTAPI VarDateFromI4(long lIn, DATE FAR* pdateOut);
WINOLEAUTAPI VarDateFromR4(float fltIn, DATE FAR* pdateOut);
WINOLEAUTAPI VarDateFromR8(double dblIn, DATE FAR* pdateOut);
WINOLEAUTAPI VarDateFromCy(CY cyIn, DATE FAR* pdateOut);
WINOLEAUTAPI VarDateFromStr(OLECHAR FAR* strIn, LCID lcid, unsigned long dwFlags, DATE FAR* pdateOut);
WINOLEAUTAPI VarDateFromDisp(IDispatch FAR* pdispIn, LCID lcid, DATE FAR* pdateOut);
WINOLEAUTAPI VarDateFromBool(VARIANT_BOOL boolIn, DATE FAR* pdateOut);

WINOLEAUTAPI VarCyFromUI1(unsigned char bIn, CY FAR* pcyOut);
WINOLEAUTAPI VarCyFromI2(short sIn, CY FAR* pcyOut);
WINOLEAUTAPI VarCyFromI4(long lIn, CY FAR* pcyOut);
WINOLEAUTAPI VarCyFromR4(float fltIn, CY FAR* pcyOut);
WINOLEAUTAPI VarCyFromR8(double dblIn, CY FAR* pcyOut);
WINOLEAUTAPI VarCyFromDate(DATE dateIn, CY FAR* pcyOut);
WINOLEAUTAPI VarCyFromStr(OLECHAR FAR* strIn, LCID lcid, unsigned long dwFlags, CY FAR* pcyOut);
WINOLEAUTAPI VarCyFromDisp(IDispatch FAR* pdispIn, LCID lcid, CY FAR* pcyOut);
WINOLEAUTAPI VarCyFromBool(VARIANT_BOOL boolIn, CY FAR* pcyOut);

WINOLEAUTAPI VarBstrFromUI1(unsigned char bVal, LCID lcid, unsigned long dwFlags, BSTR FAR* pbstrOut);
WINOLEAUTAPI VarBstrFromI2(short iVal, LCID lcid, unsigned long dwFlags, BSTR FAR* pbstrOut);
WINOLEAUTAPI VarBstrFromI4(long lIn, LCID lcid, unsigned long dwFlags, BSTR FAR* pbstrOut);
WINOLEAUTAPI VarBstrFromR4(float fltIn, LCID lcid, unsigned long dwFlags, BSTR FAR* pbstrOut);
WINOLEAUTAPI VarBstrFromR8(double dblIn, LCID lcid, unsigned long dwFlags, BSTR FAR* pbstrOut);
WINOLEAUTAPI VarBstrFromCy(CY cyIn, LCID lcid, unsigned long dwFlags, BSTR FAR* pbstrOut);
WINOLEAUTAPI VarBstrFromDate(DATE dateIn, LCID lcid, unsigned long dwFlags, BSTR FAR* pbstrOut);
WINOLEAUTAPI VarBstrFromDisp(IDispatch FAR* pdispIn, LCID lcid, unsigned long dwFlags, BSTR FAR* pbstrOut);
WINOLEAUTAPI VarBstrFromBool(VARIANT_BOOL boolIn, LCID lcid, unsigned long dwFlags, BSTR FAR* pbstrOut);

WINOLEAUTAPI VarBoolFromUI1(unsigned char bIn, VARIANT_BOOL FAR* pboolOut);
WINOLEAUTAPI VarBoolFromI2(short sIn, VARIANT_BOOL FAR* pboolOut);
WINOLEAUTAPI VarBoolFromI4(long lIn, VARIANT_BOOL FAR* pboolOut);
WINOLEAUTAPI VarBoolFromR4(float fltIn, VARIANT_BOOL FAR* pboolOut);
WINOLEAUTAPI VarBoolFromR8(double dblIn, VARIANT_BOOL FAR* pboolOut);
WINOLEAUTAPI VarBoolFromDate(DATE dateIn, VARIANT_BOOL FAR* pboolOut);
WINOLEAUTAPI VarBoolFromCy(CY cyIn, VARIANT_BOOL FAR* pboolOut);
WINOLEAUTAPI VarBoolFromStr(OLECHAR FAR* strIn, LCID lcid, unsigned long dwFlags, VARIANT_BOOL FAR* pboolOut);
WINOLEAUTAPI VarBoolFromDisp(IDispatch FAR* pdispIn, LCID lcid, VARIANT_BOOL FAR* pboolOut);


/* Mac Note: On the Mac, the coersion functions support the
 * Symantec C++ calling convention for float/double. To support
 * float/double arguments compiled with the MPW C compiler,
 * use the following APIs to move MPW float/double values into
 * a VARIANT.
 */

/*---------------------------------------------------------------------*/
/*                 ITypeLib                    */
/*---------------------------------------------------------------------*/


typedef ITypeLib FAR* LPTYPELIB;


/*---------------------------------------------------------------------*/
/*                ITypeInfo                    */
/*---------------------------------------------------------------------*/


typedef LONG DISPID;
typedef DISPID MEMBERID;

#define MEMBERID_NIL DISPID_UNKNOWN
#define ID_DEFAULTINST  -2


#define IDLFLAG_NONE    0
#define IDLFLAG_FIN     0x1
#define IDLFLAG_FOUT    0x2
#define IDLFLAG_FLCID   0x4
#define IDLFLAG_FRETVAL 0x8


/* Flags for IDispatch::Invoke */
#define DISPATCH_METHOD     0x1
#define DISPATCH_PROPERTYGET    0x2
#define DISPATCH_PROPERTYPUT    0x4
#define DISPATCH_PROPERTYPUTREF 0x8


typedef ITypeInfo FAR* LPTYPEINFO;


/*---------------------------------------------------------------------*/
/*                ITypeComp                    */
/*---------------------------------------------------------------------*/

typedef ITypeComp FAR* LPTYPECOMP;


/*---------------------------------------------------------------------*/
/*             ICreateTypeLib                  */
/*---------------------------------------------------------------------*/

typedef ICreateTypeLib FAR* LPCREATETYPELIB;


typedef ICreateTypeInfo FAR* LPCREATETYPEINFO;

/*---------------------------------------------------------------------*/
/*             TypeInfo API                    */
/*---------------------------------------------------------------------*/

/* compute a 16bit hash value for the given name
 */
#ifdef _WIN32
WINOLEAUTAPI_(ULONG)
LHashValOfNameSysA(SYSKIND syskind, LCID lcid, const char FAR* szName);
#endif

WINOLEAUTAPI_(ULONG)
LHashValOfNameSys(SYSKIND syskind, LCID lcid, const OLECHAR FAR* szName);

#define LHashValOfName(lcid, szName) \
        LHashValOfNameSys(SYS_WIN32, lcid, szName)

#define WHashValOfLHashVal(lhashval) \
        ((unsigned short) (0x0000ffff & (lhashval)))

#define IsHashValCompatible(lhashval1, lhashval2) \
        ((BOOL) ((0x00ff0000 & (lhashval1)) == (0x00ff0000 & (lhashval2))))

/* load the typelib from the file with the given filename
 */
WINOLEAUTAPI
LoadTypeLib(const OLECHAR FAR *szFile, ITypeLib FAR* FAR* pptlib);

/* load registered typelib
 */
WINOLEAUTAPI
LoadRegTypeLib(
    REFGUID rguid,
    WORD wVerMajor,
    WORD wVerMinor,
    LCID lcid,
    ITypeLib FAR* FAR* pptlib);

/* get path to registered typelib
 */
WINOLEAUTAPI
QueryPathOfRegTypeLib(
    REFGUID guid,
    unsigned short wMaj,
    unsigned short wMin,
    LCID lcid,
    LPBSTR lpbstrPathName);

/* add typelib to registry
 */
WINOLEAUTAPI
RegisterTypeLib(ITypeLib FAR* ptlib, OLECHAR FAR *szFullPath,
        OLECHAR FAR *szHelpDir);

/* remove typelib from registry
 */
WINOLEAUTAPI
DeregisterTypeLib(REFGUID rguid, WORD wVerMajor, WORD wVerMinor, LCID lcid);

WINOLEAUTAPI
CreateTypeLib(SYSKIND syskind, const OLECHAR FAR *szFile,
        ICreateTypeLib FAR* FAR* ppctlib);

/*---------------------------------------------------------------------*/

/*---------------------------------------------------------------------*/
/*                 IDispatch                   */
/*---------------------------------------------------------------------*/

typedef IDispatch FAR* LPDISPATCH;



/*---------------------------------------------------------------------*/
/*           IDispatch implementation support              */
/*---------------------------------------------------------------------*/

typedef struct FARSTRUCT tagPARAMDATA {
    OLECHAR FAR* szName;    /* parameter name */
    VARTYPE vt;         /* parameter type */
} PARAMDATA, FAR* LPPARAMDATA;

typedef struct FARSTRUCT tagMETHODDATA {
    OLECHAR FAR* szName;    /* method name */
    PARAMDATA FAR* ppdata;  /* pointer to an array of PARAMDATAs */
    DISPID dispid;      /* method ID */
    UINT iMeth;         /* method index */
    CALLCONV cc;        /* calling convention */
    UINT cArgs;         /* count of arguments */
    WORD wFlags;        /* same wFlags as on IDispatch::Invoke() */
    VARTYPE vtReturn;
} METHODDATA, FAR* LPMETHODDATA;

typedef struct FARSTRUCT tagINTERFACEDATA {
    METHODDATA FAR* pmethdata;  /* pointer to an array of METHODDATAs */
    UINT cMembers;      /* count of members */
} INTERFACEDATA, FAR* LPINTERFACEDATA;



/* Locate the parameter indicated by the given position, and
 * return it coerced to the given target VARTYPE (vtTarg).
 */
WINOLEAUTAPI
DispGetParam(
    DISPPARAMS FAR* pdispparams,
    UINT position,
    VARTYPE vtTarg,
    VARIANT FAR* pvarResult,
    UINT FAR* puArgErr);

/* Automatic TypeInfo driven implementation of IDispatch::GetIDsOfNames()
 */
WINOLEAUTAPI
DispGetIDsOfNames(
    ITypeInfo FAR* ptinfo,
    OLECHAR FAR* FAR* rgszNames,
    UINT cNames,
    DISPID FAR* rgdispid);

/* Automatic TypeInfo driven implementation of IDispatch::Invoke()
 */
WINOLEAUTAPI
DispInvoke(
    void FAR* _this,
    ITypeInfo FAR* ptinfo,
    DISPID dispidMember,
    WORD wFlags,
    DISPPARAMS FAR* pparams,
    VARIANT FAR* pvarResult,
    EXCEPINFO FAR* pexcepinfo,
    UINT FAR* puArgErr);

/* Construct a TypeInfo from an interface data description
 */
WINOLEAUTAPI
CreateDispTypeInfo(
    INTERFACEDATA FAR* pidata,
    LCID lcid,
    ITypeInfo FAR* FAR* pptinfo);

/* Create an instance of the standard TypeInfo driven IDispatch
 * implementation.
 */
WINOLEAUTAPI
CreateStdDispatch(
    IUnknown FAR* punkOuter,
    void FAR* pvThis,
    ITypeInfo FAR* ptinfo,
    IUnknown FAR* FAR* ppunkStdDisp);


/*---------------------------------------------------------------------*/
/*            Active Object Registration API               */
/*---------------------------------------------------------------------*/

/* flags for RegisterActiveObject */
#define ACTIVEOBJECT_STRONG 0x0
#define ACTIVEOBJECT_WEAK 0x1

WINOLEAUTAPI
RegisterActiveObject(
   IUnknown FAR* punk,
   REFCLSID rclsid,
   DWORD dwFlags,
   DWORD FAR* pdwRegister);

WINOLEAUTAPI
RevokeActiveObject(
    DWORD dwRegister,
    void FAR* pvReserved);

WINOLEAUTAPI
GetActiveObject(
    REFCLSID rclsid,
    void FAR* pvReserved,
    IUnknown FAR* FAR* ppunk);

/*---------------------------------------------------------------------*/
/*                           ErrorInfo API                             */
/*---------------------------------------------------------------------*/

WINOLEAUTAPI SetErrorInfo(unsigned long dwReserved, IErrorInfo FAR* perrinfo);
WINOLEAUTAPI GetErrorInfo(unsigned long dwReserved, IErrorInfo FAR* FAR* pperrinfo);
WINOLEAUTAPI CreateErrorInfo(ICreateErrorInfo FAR* FAR* pperrinfo);

/*---------------------------------------------------------------------*/
/*                           MISC API                                  */
/*---------------------------------------------------------------------*/

WINOLEAUTAPI_(unsigned long) OaBuildVersion(void);

// Declare variant access functions.



#ifdef NONAMELESSUNION
# define V_UNION(X, Y) ((X)->u.Y)
#else
# define V_UNION(X, Y) ((X)->Y)
#endif

/* Variant access macros */
#define V_VT(X)          ((X)->vt)
#define V_ISBYREF(X)     (V_VT(X)&VT_BYREF)
#define V_ISARRAY(X)     (V_VT(X)&VT_ARRAY)
#define V_ISVECTOR(X)    (V_VT(X)&VT_VECTOR)

#define V_NONE(X)        V_I2(X)

#define V_UI1(X)         V_UNION(X, bVal)
#define V_UI1REF(X)      V_UNION(X, pbVal)

#define V_I2(X)          V_UNION(X, iVal)
#define V_I2REF(X)       V_UNION(X, piVal)

#define V_I4(X)          V_UNION(X, lVal)
#define V_I4REF(X)       V_UNION(X, plVal)

#define V_I8(X)          V_UNION(X, hVal)
#define V_I8REF(X)       V_UNION(X, phVal)

#define V_R4(X)          V_UNION(X, fltVal)
#define V_R4REF(X)       V_UNION(X, pfltVal)

#define V_R8(X)          V_UNION(X, dblVal)
#define V_R8REF(X)       V_UNION(X, pdblVal)

#define V_CY(X)          V_UNION(X, cyVal)
#define V_CYREF(X)       V_UNION(X, pcyVal)

#define V_DATE(X)        V_UNION(X, date)
#define V_DATEREF(X)     V_UNION(X, pdate)

#define V_BSTR(X)        V_UNION(X, bstrVal)
#define V_BSTRREF(X)     V_UNION(X, pbstrVal)

#define V_DISPATCH(X)    V_UNION(X, pdispVal)
#define V_DISPATCHREF(X) V_UNION(X, ppdispVal)

#define V_ERROR(X)       V_UNION(X, scode)
#define V_ERRORREF(X)    V_UNION(X, pscode)

#define V_BOOL(X)        V_UNION(X, bool)
#define V_BOOLREF(X)     V_UNION(X, pbool)

#define V_UNKNOWN(X)     V_UNION(X, punkVal)
#define V_UNKNOWNREF(X)  V_UNION(X, ppunkVal)


#define V_VARIANTREF(X)  V_UNION(X, pvarVal)

#define V_LPSTR(X)        V_UNION(X, pszVal)
#define V_LPSTRREF(X)     V_UNION(X, ppszVal)

#define V_LPWSTR(X)        V_UNION(X, pwszVal)
#define V_LPWSTRREF(X)     V_UNION(X, ppwszVal)

#define V_FILETIME(X)        V_UNION(X, filetime)
#define V_FILETIMEREF(X)        V_UNION(X, pfiletime)

#define V_BLOB(X)        V_UNION(X, blob)

#define V_UUID(X)        V_UNION(X, puuid)
#define V_CLSID(X)       V_UNION(X, puuid)

#define V_ARRAY(X)       V_UNION(X, parray)
#define V_ARRAYREF(X)    V_UNION(X, pparray)

#define V_BYREF(X)       V_UNION(X, byref)

#ifndef RC_INVOKED
#include <poppack.h>
#endif // RC_INVOKED

#endif     // __OLEAUTO_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\inc32\OBJBASE.H ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       objbase.h
//
//  Contents:   Component object model defintions.
//
//----------------------------------------------------------------------------

#include <rpc.h>
#include <rpcndr.h>

#if !defined( _OBJBASE_H_ )
#define _OBJBASE_H_

#include <pshpack8.h>

// Component Object Model defines, and macros

#ifdef __cplusplus
    #define EXTERN_C    extern "C"
#else
    #define EXTERN_C    extern
#endif

#ifdef _WIN32

// Win32 doesn't support __export

#define STDMETHODCALLTYPE       __stdcall
#define STDMETHODVCALLTYPE      __cdecl

#define STDAPICALLTYPE          __stdcall
#define STDAPIVCALLTYPE         __cdecl

#else

#define STDMETHODCALLTYPE       __export __stdcall
#define STDMETHODVCALLTYPE      __export __cdecl

#define STDAPICALLTYPE          __export __stdcall
#define STDAPIVCALLTYPE         __export __cdecl

#endif


#define STDAPI                  EXTERN_C HRESULT STDAPICALLTYPE
#define STDAPI_(type)           EXTERN_C type STDAPICALLTYPE

#define STDMETHODIMP            HRESULT STDMETHODCALLTYPE
#define STDMETHODIMP_(type)     type STDMETHODCALLTYPE

// The 'V' versions allow Variable Argument lists.

#define STDAPIV                 EXTERN_C HRESULT STDAPIVCALLTYPE
#define STDAPIV_(type)          EXTERN_C type STDAPIVCALLTYPE

#define STDMETHODIMPV           HRESULT STDMETHODVCALLTYPE
#define STDMETHODIMPV_(type)    type STDMETHODVCALLTYPE

#ifdef _OLE32_
#define WINOLEAPI        STDAPI
#define WINOLEAPI_(type) STDAPI_(type)
#else
#define WINOLEAPI        EXTERN_C DECLSPEC_IMPORT HRESULT STDAPICALLTYPE
#define WINOLEAPI_(type) EXTERN_C DECLSPEC_IMPORT type STDAPICALLTYPE
#endif

/****** Interface Declaration ***********************************************/

/*
 *      These are macros for declaring interfaces.  They exist so that
 *      a single definition of the interface is simulataneously a proper
 *      declaration of the interface structures (C++ abstract classes)
 *      for both C and C++.
 *
 *      DECLARE_INTERFACE(iface) is used to declare an interface that does
 *      not derive from a base interface.
 *      DECLARE_INTERFACE_(iface, baseiface) is used to declare an interface
 *      that does derive from a base interface.
 *
 *      By default if the source file has a .c extension the C version of
 *      the interface declaratations will be expanded; if it has a .cpp
 *      extension the C++ version will be expanded. if you want to force
 *      the C version expansion even though the source file has a .cpp
 *      extension, then define the macro "CINTERFACE".
 *      eg.     cl -DCINTERFACE file.cpp
 *
 *      Example Interface declaration:
 *
 *          #undef  INTERFACE
 *          #define INTERFACE   IClassFactory
 *
 *          DECLARE_INTERFACE_(IClassFactory, IUnknown)
 *          {
 *              // *** IUnknown methods ***
 *              STDMETHOD(QueryInterface) (THIS_
 *                                        REFIID riid,
 *                                        LPVOID FAR* ppvObj) PURE;
 *              STDMETHOD_(ULONG,AddRef) (THIS) PURE;
 *              STDMETHOD_(ULONG,Release) (THIS) PURE;
 *
 *              // *** IClassFactory methods ***
 *              STDMETHOD(CreateInstance) (THIS_
 *                                        LPUNKNOWN pUnkOuter,
 *                                        REFIID riid,
 *                                        LPVOID FAR* ppvObject) PURE;
 *          };
 *
 *      Example C++ expansion:
 *
 *          struct FAR IClassFactory : public IUnknown
 *          {
 *              virtual HRESULT STDMETHODCALLTYPE QueryInterface(
 *                                                  IID FAR& riid,
 *                                                  LPVOID FAR* ppvObj) = 0;
 *              virtual HRESULT STDMETHODCALLTYPE AddRef(void) = 0;
 *              virtual HRESULT STDMETHODCALLTYPE Release(void) = 0;
 *              virtual HRESULT STDMETHODCALLTYPE CreateInstance(
 *                                              LPUNKNOWN pUnkOuter,
 *                                              IID FAR& riid,
 *                                              LPVOID FAR* ppvObject) = 0;
 *          };
 *
 *          NOTE: Our documentation says '#define interface class' but we use
 *          'struct' instead of 'class' to keep a lot of 'public:' lines
 *          out of the interfaces.  The 'FAR' forces the 'this' pointers to
 *          be far, which is what we need.
 *
 *      Example C expansion:
 *
 *          typedef struct IClassFactory
 *          {
 *              const struct IClassFactoryVtbl FAR* lpVtbl;
 *          } IClassFactory;
 *
 *          typedef struct IClassFactoryVtbl IClassFactoryVtbl;
 *
 *          struct IClassFactoryVtbl
 *          {
 *              HRESULT (STDMETHODCALLTYPE * QueryInterface) (
 *                                                  IClassFactory FAR* This,
 *                                                  IID FAR* riid,
 *                                                  LPVOID FAR* ppvObj) ;
 *              HRESULT (STDMETHODCALLTYPE * AddRef) (IClassFactory FAR* This) ;
 *              HRESULT (STDMETHODCALLTYPE * Release) (IClassFactory FAR* This) ;
 *              HRESULT (STDMETHODCALLTYPE * CreateInstance) (
 *                                                  IClassFactory FAR* This,
 *                                                  LPUNKNOWN pUnkOuter,
 *                                                  IID FAR* riid,
 *                                                  LPVOID FAR* ppvObject);
 *              HRESULT (STDMETHODCALLTYPE * LockServer) (
 *                                                  IClassFactory FAR* This,
 *                                                  BOOL fLock);
 *          };
 */


#if defined(__cplusplus) && !defined(CINTERFACE)
//#define interface               struct FAR
#define interface struct
#define STDMETHOD(method)       virtual HRESULT STDMETHODCALLTYPE method
#define STDMETHOD_(type,method) virtual type STDMETHODCALLTYPE method
#define PURE                    = 0
#define THIS_
#define THIS                    void
#define DECLARE_INTERFACE(iface)    interface iface
#define DECLARE_INTERFACE_(iface, baseiface)    interface iface : public baseiface



#else

#define interface               struct

#define STDMETHOD(method)       HRESULT (STDMETHODCALLTYPE * method)
#define STDMETHOD_(type,method) type (STDMETHODCALLTYPE * method)




#define PURE
#define THIS_                   INTERFACE FAR* This,
#define THIS                    INTERFACE FAR* This
#ifdef CONST_VTABLE
#define CONST_VTBL const
#define DECLARE_INTERFACE(iface)    typedef interface iface { \
                                    const struct iface##Vtbl FAR* lpVtbl; \
                                } iface; \
                                typedef const struct iface##Vtbl iface##Vtbl; \
                                const struct iface##Vtbl
#else
#define CONST_VTBL
#define DECLARE_INTERFACE(iface)    typedef interface iface { \
                                    struct iface##Vtbl FAR* lpVtbl; \
                                } iface; \
                                typedef struct iface##Vtbl iface##Vtbl; \
                                struct iface##Vtbl
#endif
#define DECLARE_INTERFACE_(iface, baseiface)    DECLARE_INTERFACE(iface)

#endif




/****** Additional basic types **********************************************/


#ifndef FARSTRUCT
#ifdef __cplusplus
#define FARSTRUCT   FAR
#else
#define FARSTRUCT
#endif  // __cplusplus
#endif  // FARSTRUCT



#ifndef HUGEP
#ifdef _WIN32
#define HUGEP
#else
#define HUGEP __huge
#endif // WIN32
#endif // HUGEP


#include <stdlib.h>

#define LISet32(li, v) ((li).HighPart = (v) < 0 ? -1 : 0, (li).LowPart = (v))

#define ULISet32(li, v) ((li).HighPart = 0, (li).LowPart = (v))






#define CLSCTX_ALL              (CLSCTX_INPROC_SERVER| \
                                 CLSCTX_INPROC_HANDLER| \
                                 CLSCTX_LOCAL_SERVER)

#define CLSCTX_INPROC           (CLSCTX_INPROC_SERVER|CLSCTX_INPROC_HANDLER)

#define CLSCTX_SERVER           (CLSCTX_INPROC_SERVER|CLSCTX_LOCAL_SERVER)


// class registration flags; passed to CoRegisterClassObject
typedef enum tagREGCLS
{
    REGCLS_SINGLEUSE = 0,       // class object only generates one instance
    REGCLS_MULTIPLEUSE = 1,     // same class object genereates multiple inst.
                                // and local automatically goes into inproc tbl.
    REGCLS_MULTI_SEPARATE = 2   // multiple use, but separate control over each
                                // context.
} REGCLS;

// interface marshaling definitions
#define MARSHALINTERFACE_MIN 500 // minimum number of bytes for interface marshl


//
// Common typedefs for paramaters used in Storage API's, gleamed from storage.h
// Also contains Storage error codes, which should be moved into the storage
// idl files.
//


#define CWCSTORAGENAME 32

/* Storage instantiation modes */
#define STGM_DIRECT             0x00000000L
#define STGM_TRANSACTED         0x00010000L
#define STGM_SIMPLE             0x08000000L

#define STGM_READ               0x00000000L
#define STGM_WRITE              0x00000001L
#define STGM_READWRITE          0x00000002L

#define STGM_SHARE_DENY_NONE    0x00000040L
#define STGM_SHARE_DENY_READ    0x00000030L
#define STGM_SHARE_DENY_WRITE   0x00000020L
#define STGM_SHARE_EXCLUSIVE    0x00000010L

#define STGM_PRIORITY           0x00040000L
#define STGM_DELETEONRELEASE    0x04000000L
#if (WINVER >= 400)
#define STGM_NOSCRATCH          0x00100000L
#endif /* WINVER */

#define STGM_CREATE             0x00001000L
#define STGM_CONVERT            0x00020000L
#define STGM_FAILIFTHERE        0x00000000L


/* here is where we pull in the MIDL generated headers for the interfaces */
typedef interface    IRpcStubBuffer     IRpcStubBuffer;
typedef interface    IRpcChannelBuffer  IRpcChannelBuffer;

#include <wtypes.h>
#include <unknwn.h>
#include <objidl.h>


// macros to define byte pattern for a GUID.
//      Example: DEFINE_GUID(GUID_XXX, a, b, c, ...);
//
// Each dll/exe must initialize the GUIDs once.  This is done in one of
// two ways.  If you are not using precompiled headers for the file(s) which
// initializes the GUIDs, define INITGUID before including objbase.h.  This
// is how OLE builds the initialized versions of the GUIDs which are included
// in ole2.lib.  The GUIDs in ole2.lib are all defined in the same text
// segment GUID_TEXT.
//
// The alternative (which some versions of the compiler don't handle properly;
// they wind up with the initialized GUIDs in a data, not a text segment),
// is to use a precompiled version of objbase.h and then include initguid.h
// after objbase.h followed by one or more of the guid defintion files.

#ifndef INITGUID
#define DEFINE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
    EXTERN_C const GUID CDECL FAR name
#else

#define DEFINE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
        EXTERN_C const GUID CDECL name \
                = { l, w1, w2, { b1, b2,  b3,  b4,  b5,  b6,  b7,  b8 } }
#endif // INITGUID

#define DEFINE_OLEGUID(name, l, w1, w2) \
    DEFINE_GUID(name, l, w1, w2, 0xC0,0,0,0,0,0,0,0x46)

#ifdef __cplusplus
inline BOOL IsEqualGUID(REFGUID rguid1, REFGUID rguid2)
{
    return !memcmp(&rguid1, &rguid2, sizeof(GUID));
}
#else   //  ! __cplusplus
#define IsEqualGUID(rguid1, rguid2) (!memcmp(rguid1, rguid2, sizeof(GUID)))
#endif  //  __cplusplus

#define IsEqualIID(riid1, riid2) IsEqualGUID(riid1, riid2)
#define IsEqualCLSID(rclsid1, rclsid2) IsEqualGUID(rclsid1, rclsid2)

#ifdef __cplusplus

// because GUID is defined elsewhere in WIN32 land, the operator == and !=
// are moved outside the class to global scope.

inline BOOL operator==(const GUID& guidOne, const GUID& guidOther)
{
#ifdef _WIN32
    return !memcmp(&guidOne,&guidOther,sizeof(GUID));
#else
    return !_fmemcmp(&guidOne,&guidOther,sizeof(GUID)); }
#endif
}

inline BOOL operator!=(const GUID& guidOne, const GUID& guidOther)
{
    return !(guidOne == guidOther);
}

#endif // __cpluscplus


#ifndef INITGUID
#include <cguid.h>
#endif



/****** STD Object API Prototypes *****************************************/

WINOLEAPI_(DWORD) CoBuildVersion( VOID );

/* init/uninit */

WINOLEAPI  CoInitialize(LPVOID pvReserved);
WINOLEAPI_(void)  CoUninitialize(void);
WINOLEAPI  CoGetMalloc(DWORD dwMemContext, LPMALLOC FAR* ppMalloc);
WINOLEAPI_(DWORD) CoGetCurrentProcess(void);
WINOLEAPI  CoRegisterMallocSpy(LPMALLOCSPY pMallocSpy);
WINOLEAPI  CoRevokeMallocSpy(void);
WINOLEAPI  CoCreateStandardMalloc(DWORD memctx, IMalloc FAR* FAR* ppMalloc);

#if DBG == 1
WINOLEAPI_(ULONG) DebugCoGetRpcFault( void );
WINOLEAPI_(void) DebugCoSetRpcFault( ULONG );
#endif

/* register/revoke/get class objects */

WINOLEAPI  CoGetClassObject(REFCLSID rclsid, DWORD dwClsContext, LPVOID pvReserved,
                    REFIID riid, LPVOID FAR* ppv);
WINOLEAPI  CoRegisterClassObject(REFCLSID rclsid, LPUNKNOWN pUnk,
                    DWORD dwClsContext, DWORD flags, LPDWORD lpdwRegister);
WINOLEAPI  CoRevokeClassObject(DWORD dwRegister);


/* marshaling interface pointers */

WINOLEAPI CoGetMarshalSizeMax(ULONG *pulSize, REFIID riid, LPUNKNOWN pUnk,
                    DWORD dwDestContext, LPVOID pvDestContext, DWORD mshlflags);
WINOLEAPI CoMarshalInterface(LPSTREAM pStm, REFIID riid, LPUNKNOWN pUnk,
                    DWORD dwDestContext, LPVOID pvDestContext, DWORD mshlflags);
WINOLEAPI CoUnmarshalInterface(LPSTREAM pStm, REFIID riid, LPVOID FAR* ppv);
WINOLEAPI CoMarshalHresult(LPSTREAM pstm, HRESULT hresult);
WINOLEAPI CoUnmarshalHresult(LPSTREAM pstm, HRESULT FAR * phresult);
WINOLEAPI CoReleaseMarshalData(LPSTREAM pStm);
WINOLEAPI CoDisconnectObject(LPUNKNOWN pUnk, DWORD dwReserved);
WINOLEAPI CoLockObjectExternal(LPUNKNOWN pUnk, BOOL fLock, BOOL fLastUnlockReleases);
WINOLEAPI CoGetStandardMarshal(REFIID riid, LPUNKNOWN pUnk,
                    DWORD dwDestContext, LPVOID pvDestContext, DWORD mshlflags,
                    LPMARSHAL FAR* ppMarshal);

WINOLEAPI_(BOOL) CoIsHandlerConnected(LPUNKNOWN pUnk);
WINOLEAPI_(BOOL) CoHasStrongExternalConnections(LPUNKNOWN pUnk);

// Apartment model inter-thread interface passing helpers
WINOLEAPI CoMarshalInterThreadInterfaceInStream(REFIID riid, LPUNKNOWN pUnk,
                    LPSTREAM *ppStm);

WINOLEAPI CoGetInterfaceAndReleaseStream(LPSTREAM pStm, REFIID iid,
                    LPVOID FAR* ppv);

WINOLEAPI CoCreateFreeThreadedMarshaler(LPUNKNOWN  punkOuter,
                    LPUNKNOWN *ppunkMarshal);

/* dll loading helpers; keeps track of ref counts and unloads all on exit */

WINOLEAPI_(HINSTANCE) CoLoadLibrary(LPOLESTR lpszLibName, BOOL bAutoFree);
WINOLEAPI_(void) CoFreeLibrary(HINSTANCE hInst);
WINOLEAPI_(void) CoFreeAllLibraries(void);
WINOLEAPI_(void) CoFreeUnusedLibraries(void);


/* helper for creating instances */

WINOLEAPI CoCreateInstance(REFCLSID rclsid, LPUNKNOWN pUnkOuter,
                    DWORD dwClsContext, REFIID riid, LPVOID FAR* ppv);


/* other helpers */

WINOLEAPI StringFromCLSID(REFCLSID rclsid, LPOLESTR FAR* lplpsz);
WINOLEAPI CLSIDFromString(LPOLESTR lpsz, LPCLSID pclsid);
WINOLEAPI StringFromIID(REFIID rclsid, LPOLESTR FAR* lplpsz);
WINOLEAPI IIDFromString(LPOLESTR lpsz, LPIID lpiid);
WINOLEAPI_(BOOL) CoIsOle1Class(REFCLSID rclsid);
WINOLEAPI ProgIDFromCLSID (REFCLSID clsid, LPOLESTR FAR* lplpszProgID);
WINOLEAPI CLSIDFromProgID (LPCOLESTR lpszProgID, LPCLSID lpclsid);
WINOLEAPI_(int) StringFromGUID2(REFGUID rguid, LPOLESTR lpsz, int cbMax);

WINOLEAPI CoCreateGuid(GUID FAR *pguid);

WINOLEAPI_(BOOL) CoFileTimeToDosDateTime(
                 FILETIME FAR* lpFileTime, LPWORD lpDosDate, LPWORD lpDosTime);
WINOLEAPI_(BOOL) CoDosDateTimeToFileTime(
                       WORD nDosDate, WORD nDosTime, FILETIME FAR* lpFileTime);
WINOLEAPI  CoFileTimeNow( FILETIME FAR* lpFileTime );


WINOLEAPI CoRegisterMessageFilter( LPMESSAGEFILTER lpMessageFilter,
                                LPMESSAGEFILTER FAR* lplpMessageFilter );


/* TreatAs APIS */

WINOLEAPI CoGetTreatAsClass(REFCLSID clsidOld, LPCLSID pClsidNew);
WINOLEAPI CoTreatAsClass(REFCLSID clsidOld, REFCLSID clsidNew);


/* the server dlls must define their DllGetClassObject and DllCanUnloadNow
 * to match these; the typedefs are located here to ensure all are changed at
 * the same time.
 */

#ifdef _MAC
typedef STDAPICALLTYPE HRESULT (* LPFNGETCLASSOBJECT) (REFCLSID, REFIID, LPVOID *);
#else
typedef HRESULT (STDAPICALLTYPE * LPFNGETCLASSOBJECT) (REFCLSID, REFIID, LPVOID *);
#endif

#ifdef _MAC
typedef STDAPICALLTYPE HRESULT (* LPFNCANUNLOADNOW)(void);
#else
typedef HRESULT (STDAPICALLTYPE * LPFNCANUNLOADNOW)(void);
#endif

STDAPI  DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID FAR* ppv);

STDAPI  DllCanUnloadNow(void);


/****** Default Memory Allocation ******************************************/
WINOLEAPI_(LPVOID) CoTaskMemAlloc(ULONG cb);
WINOLEAPI_(LPVOID) CoTaskMemRealloc(LPVOID pv, ULONG cb);
WINOLEAPI_(void)   CoTaskMemFree(LPVOID pv);

/****** DV APIs ***********************************************************/


WINOLEAPI CreateDataAdviseHolder(LPDATAADVISEHOLDER FAR* ppDAHolder);

WINOLEAPI CreateDataCache(LPUNKNOWN pUnkOuter, REFCLSID rclsid,
                                        REFIID iid, LPVOID FAR* ppv);




/****** Storage API Prototypes ********************************************/


WINOLEAPI StgCreateDocfile(const OLECHAR FAR* pwcsName,
            DWORD grfMode,
            DWORD reserved,
            IStorage FAR * FAR *ppstgOpen);

WINOLEAPI StgCreateDocfileOnILockBytes(ILockBytes FAR *plkbyt,
                    DWORD grfMode,
                    DWORD reserved,
                    IStorage FAR * FAR *ppstgOpen);

WINOLEAPI StgOpenStorage(const OLECHAR FAR* pwcsName,
              IStorage FAR *pstgPriority,
              DWORD grfMode,
              SNB snbExclude,
              DWORD reserved,
              IStorage FAR * FAR *ppstgOpen);
WINOLEAPI StgOpenStorageOnILockBytes(ILockBytes FAR *plkbyt,
                  IStorage FAR *pstgPriority,
                  DWORD grfMode,
                  SNB snbExclude,
                  DWORD reserved,
                  IStorage FAR * FAR *ppstgOpen);

WINOLEAPI StgIsStorageFile(const OLECHAR FAR* pwcsName);
WINOLEAPI StgIsStorageILockBytes(ILockBytes FAR* plkbyt);

WINOLEAPI StgSetTimes(OLECHAR const FAR* lpszName,
                   FILETIME const FAR* pctime,
                   FILETIME const FAR* patime,
                   FILETIME const FAR* pmtime);


//
//  Moniker APIs
//

WINOLEAPI  BindMoniker(LPMONIKER pmk, DWORD grfOpt, REFIID iidResult, LPVOID FAR* ppvResult);
WINOLEAPI  MkParseDisplayName(LPBC pbc, LPCOLESTR szUserName,
                ULONG FAR * pchEaten, LPMONIKER FAR * ppmk);
WINOLEAPI  MonikerRelativePathTo(LPMONIKER pmkSrc, LPMONIKER pmkDest, LPMONIKER
                FAR* ppmkRelPath, BOOL dwReserved);
WINOLEAPI  MonikerCommonPrefixWith(LPMONIKER pmkThis, LPMONIKER pmkOther,
                LPMONIKER FAR* ppmkCommon);
WINOLEAPI  CreateBindCtx(DWORD reserved, LPBC FAR* ppbc);
WINOLEAPI  CreateGenericComposite(LPMONIKER pmkFirst, LPMONIKER pmkRest,
    LPMONIKER FAR* ppmkComposite);
WINOLEAPI  GetClassFile (LPCOLESTR szFilename, CLSID FAR* pclsid);

WINOLEAPI  CreateFileMoniker(LPCOLESTR lpszPathName, LPMONIKER FAR* ppmk);

WINOLEAPI  CreateItemMoniker(LPCOLESTR lpszDelim, LPCOLESTR lpszItem,
    LPMONIKER FAR* ppmk);
WINOLEAPI  CreateAntiMoniker(LPMONIKER FAR* ppmk);
WINOLEAPI  CreatePointerMoniker(LPUNKNOWN punk, LPMONIKER FAR* ppmk);

WINOLEAPI  GetRunningObjectTable( DWORD reserved, LPRUNNINGOBJECTTABLE FAR* pprot);

#ifndef RC_INVOKED
#include <poppack.h>
#endif // RC_INVOKED

#endif     // __OBJBASE_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\inc32\OLEIDL.H ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 2.00.0102 */
/* at Fri Apr 28 07:02:35 1995
 */
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"
#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __oleidl_h__
#define __oleidl_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IOleAdviseHolder_FWD_DEFINED__
#define __IOleAdviseHolder_FWD_DEFINED__
typedef interface IOleAdviseHolder IOleAdviseHolder;
#endif 	/* __IOleAdviseHolder_FWD_DEFINED__ */


#ifndef __IOleCache_FWD_DEFINED__
#define __IOleCache_FWD_DEFINED__
typedef interface IOleCache IOleCache;
#endif 	/* __IOleCache_FWD_DEFINED__ */


#ifndef __IOleCache2_FWD_DEFINED__
#define __IOleCache2_FWD_DEFINED__
typedef interface IOleCache2 IOleCache2;
#endif 	/* __IOleCache2_FWD_DEFINED__ */


#ifndef __IOleCacheControl_FWD_DEFINED__
#define __IOleCacheControl_FWD_DEFINED__
typedef interface IOleCacheControl IOleCacheControl;
#endif 	/* __IOleCacheControl_FWD_DEFINED__ */


#ifndef __IParseDisplayName_FWD_DEFINED__
#define __IParseDisplayName_FWD_DEFINED__
typedef interface IParseDisplayName IParseDisplayName;
#endif 	/* __IParseDisplayName_FWD_DEFINED__ */


#ifndef __IOleContainer_FWD_DEFINED__
#define __IOleContainer_FWD_DEFINED__
typedef interface IOleContainer IOleContainer;
#endif 	/* __IOleContainer_FWD_DEFINED__ */


#ifndef __IOleClientSite_FWD_DEFINED__
#define __IOleClientSite_FWD_DEFINED__
typedef interface IOleClientSite IOleClientSite;
#endif 	/* __IOleClientSite_FWD_DEFINED__ */


#ifndef __IOleObject_FWD_DEFINED__
#define __IOleObject_FWD_DEFINED__
typedef interface IOleObject IOleObject;
#endif 	/* __IOleObject_FWD_DEFINED__ */


#ifndef __IOleWindow_FWD_DEFINED__
#define __IOleWindow_FWD_DEFINED__
typedef interface IOleWindow IOleWindow;
#endif 	/* __IOleWindow_FWD_DEFINED__ */


#ifndef __IOleLink_FWD_DEFINED__
#define __IOleLink_FWD_DEFINED__
typedef interface IOleLink IOleLink;
#endif 	/* __IOleLink_FWD_DEFINED__ */


#ifndef __IOleItemContainer_FWD_DEFINED__
#define __IOleItemContainer_FWD_DEFINED__
typedef interface IOleItemContainer IOleItemContainer;
#endif 	/* __IOleItemContainer_FWD_DEFINED__ */


#ifndef __IOleInPlaceUIWindow_FWD_DEFINED__
#define __IOleInPlaceUIWindow_FWD_DEFINED__
typedef interface IOleInPlaceUIWindow IOleInPlaceUIWindow;
#endif 	/* __IOleInPlaceUIWindow_FWD_DEFINED__ */


#ifndef __IOleInPlaceActiveObject_FWD_DEFINED__
#define __IOleInPlaceActiveObject_FWD_DEFINED__
typedef interface IOleInPlaceActiveObject IOleInPlaceActiveObject;
#endif 	/* __IOleInPlaceActiveObject_FWD_DEFINED__ */


#ifndef __IOleInPlaceFrame_FWD_DEFINED__
#define __IOleInPlaceFrame_FWD_DEFINED__
typedef interface IOleInPlaceFrame IOleInPlaceFrame;
#endif 	/* __IOleInPlaceFrame_FWD_DEFINED__ */


#ifndef __IOleInPlaceObject_FWD_DEFINED__
#define __IOleInPlaceObject_FWD_DEFINED__
typedef interface IOleInPlaceObject IOleInPlaceObject;
#endif 	/* __IOleInPlaceObject_FWD_DEFINED__ */


#ifndef __IOleInPlaceSite_FWD_DEFINED__
#define __IOleInPlaceSite_FWD_DEFINED__
typedef interface IOleInPlaceSite IOleInPlaceSite;
#endif 	/* __IOleInPlaceSite_FWD_DEFINED__ */


#ifndef __IViewObject_FWD_DEFINED__
#define __IViewObject_FWD_DEFINED__
typedef interface IViewObject IViewObject;
#endif 	/* __IViewObject_FWD_DEFINED__ */


#ifndef __IViewObject2_FWD_DEFINED__
#define __IViewObject2_FWD_DEFINED__
typedef interface IViewObject2 IViewObject2;
#endif 	/* __IViewObject2_FWD_DEFINED__ */


#ifndef __IDropSource_FWD_DEFINED__
#define __IDropSource_FWD_DEFINED__
typedef interface IDropSource IDropSource;
#endif 	/* __IDropSource_FWD_DEFINED__ */


#ifndef __IDropTarget_FWD_DEFINED__
#define __IDropTarget_FWD_DEFINED__
typedef interface IDropTarget IDropTarget;
#endif 	/* __IDropTarget_FWD_DEFINED__ */


#ifndef __IEnumOLEVERB_FWD_DEFINED__
#define __IEnumOLEVERB_FWD_DEFINED__
typedef interface IEnumOLEVERB IEnumOLEVERB;
#endif 	/* __IEnumOLEVERB_FWD_DEFINED__ */


/* header files for imported files */
#include "objidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/****************************************
 * Generated header for interface: __MIDL__intf_0000
 * at Fri Apr 28 07:02:35 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [local] */ 


			/* size is 0 */

			/* size is 0 */



extern RPC_IF_HANDLE __MIDL__intf_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL__intf_0000_v0_0_s_ifspec;

#ifndef __IOleAdviseHolder_INTERFACE_DEFINED__
#define __IOleAdviseHolder_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IOleAdviseHolder
 * at Fri Apr 28 07:02:35 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [uuid][object][local] */ 


//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//--------------------------------------------------------------------------
			/* size is 4 */
typedef /* [unique] */ IOleAdviseHolder __RPC_FAR *LPOLEADVISEHOLDER;


EXTERN_C const IID IID_IOleAdviseHolder;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IOleAdviseHolder : public IUnknown
    {
    public:
        virtual HRESULT __stdcall Advise( 
            /* [unique][in] */ IAdviseSink __RPC_FAR *pAdvise,
            /* [out] */ DWORD __RPC_FAR *pdwConnection) = 0;
        
        virtual HRESULT __stdcall Unadvise( 
            /* [in] */ DWORD dwConnection) = 0;
        
        virtual HRESULT __stdcall EnumAdvise( 
            /* [out] */ IEnumSTATDATA __RPC_FAR *__RPC_FAR *ppenumAdvise) = 0;
        
        virtual HRESULT __stdcall SendOnRename( 
            /* [unique][in] */ IMoniker __RPC_FAR *pmk) = 0;
        
        virtual HRESULT __stdcall SendOnSave( void) = 0;
        
        virtual HRESULT __stdcall SendOnClose( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IOleAdviseHolderVtbl
    {
        
        HRESULT ( __stdcall __RPC_FAR *QueryInterface )( 
            IOleAdviseHolder __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( __stdcall __RPC_FAR *AddRef )( 
            IOleAdviseHolder __RPC_FAR * This);
        
        ULONG ( __stdcall __RPC_FAR *Release )( 
            IOleAdviseHolder __RPC_FAR * This);
        
        HRESULT ( __stdcall __RPC_FAR *Advise )( 
            IOleAdviseHolder __RPC_FAR * This,
            /* [unique][in] */ IAdviseSink __RPC_FAR *pAdvise,
            /* [out] */ DWORD __RPC_FAR *pdwConnection);
        
        HRESULT ( __stdcall __RPC_FAR *Unadvise )( 
            IOleAdviseHolder __RPC_FAR * This,
            /* [in] */ DWORD dwConnection);
        
        HRESULT ( __stdcall __RPC_FAR *EnumAdvise )( 
            IOleAdviseHolder __RPC_FAR * This,
            /* [out] */ IEnumSTATDATA __RPC_FAR *__RPC_FAR *ppenumAdvise);
        
        HRESULT ( __stdcall __RPC_FAR *SendOnRename )( 
            IOleAdviseHolder __RPC_FAR * This,
            /* [unique][in] */ IMoniker __RPC_FAR *pmk);
        
        HRESULT ( __stdcall __RPC_FAR *SendOnSave )( 
            IOleAdviseHolder __RPC_FAR * This);
        
        HRESULT ( __stdcall __RPC_FAR *SendOnClose )( 
            IOleAdviseHolder __RPC_FAR * This);
        
    } IOleAdviseHolderVtbl;

    interface IOleAdviseHolder
    {
        CONST_VTBL struct IOleAdviseHolderVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IOleAdviseHolder_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IOleAdviseHolder_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IOleAdviseHolder_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IOleAdviseHolder_Advise(This,pAdvise,pdwConnection)	\
    (This)->lpVtbl -> Advise(This,pAdvise,pdwConnection)

#define IOleAdviseHolder_Unadvise(This,dwConnection)	\
    (This)->lpVtbl -> Unadvise(This,dwConnection)

#define IOleAdviseHolder_EnumAdvise(This,ppenumAdvise)	\
    (This)->lpVtbl -> EnumAdvise(This,ppenumAdvise)

#define IOleAdviseHolder_SendOnRename(This,pmk)	\
    (This)->lpVtbl -> SendOnRename(This,pmk)

#define IOleAdviseHolder_SendOnSave(This)	\
    (This)->lpVtbl -> SendOnSave(This)

#define IOleAdviseHolder_SendOnClose(This)	\
    (This)->lpVtbl -> SendOnClose(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT __stdcall IOleAdviseHolder_Advise_Proxy( 
    IOleAdviseHolder __RPC_FAR * This,
    /* [unique][in] */ IAdviseSink __RPC_FAR *pAdvise,
    /* [out] */ DWORD __RPC_FAR *pdwConnection);


void __RPC_STUB IOleAdviseHolder_Advise_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IOleAdviseHolder_Unadvise_Proxy( 
    IOleAdviseHolder __RPC_FAR * This,
    /* [in] */ DWORD dwConnection);


void __RPC_STUB IOleAdviseHolder_Unadvise_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IOleAdviseHolder_EnumAdvise_Proxy( 
    IOleAdviseHolder __RPC_FAR * This,
    /* [out] */ IEnumSTATDATA __RPC_FAR *__RPC_FAR *ppenumAdvise);


void __RPC_STUB IOleAdviseHolder_EnumAdvise_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IOleAdviseHolder_SendOnRename_Proxy( 
    IOleAdviseHolder __RPC_FAR * This,
    /* [unique][in] */ IMoniker __RPC_FAR *pmk);


void __RPC_STUB IOleAdviseHolder_SendOnRename_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IOleAdviseHolder_SendOnSave_Proxy( 
    IOleAdviseHolder __RPC_FAR * This);


void __RPC_STUB IOleAdviseHolder_SendOnSave_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IOleAdviseHolder_SendOnClose_Proxy( 
    IOleAdviseHolder __RPC_FAR * This);


void __RPC_STUB IOleAdviseHolder_SendOnClose_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IOleAdviseHolder_INTERFACE_DEFINED__ */


#ifndef __IOleCache_INTERFACE_DEFINED__
#define __IOleCache_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IOleCache
 * at Fri Apr 28 07:02:35 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [unique][uuid][object][local] */ 


			/* size is 4 */
typedef /* [unique] */ IOleCache __RPC_FAR *LPOLECACHE;


EXTERN_C const IID IID_IOleCache;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IOleCache : public IUnknown
    {
    public:
        virtual HRESULT __stdcall Cache( 
            /* [unique][in] */ FORMATETC __RPC_FAR *pformatetc,
            /* [in] */ DWORD advf,
            /* [out] */ DWORD __RPC_FAR *pdwConnection) = 0;
        
        virtual HRESULT __stdcall Uncache( 
            /* [in] */ DWORD dwConnection) = 0;
        
        virtual HRESULT __stdcall EnumCache( 
            /* [out] */ IEnumSTATDATA __RPC_FAR *__RPC_FAR *ppenumSTATDATA) = 0;
        
        virtual HRESULT __stdcall InitCache( 
            /* [unique][in] */ IDataObject __RPC_FAR *pDataObject) = 0;
        
        virtual HRESULT __stdcall SetData( 
            /* [unique][in] */ FORMATETC __RPC_FAR *pformatetc,
            /* [unique][in] */ STGMEDIUM __RPC_FAR *pmedium,
            /* [in] */ BOOL fRelease) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IOleCacheVtbl
    {
        
        HRESULT ( __stdcall __RPC_FAR *QueryInterface )( 
            IOleCache __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( __stdcall __RPC_FAR *AddRef )( 
            IOleCache __RPC_FAR * This);
        
        ULONG ( __stdcall __RPC_FAR *Release )( 
            IOleCache __RPC_FAR * This);
        
        HRESULT ( __stdcall __RPC_FAR *Cache )( 
            IOleCache __RPC_FAR * This,
            /* [unique][in] */ FORMATETC __RPC_FAR *pformatetc,
            /* [in] */ DWORD advf,
            /* [out] */ DWORD __RPC_FAR *pdwConnection);
        
        HRESULT ( __stdcall __RPC_FAR *Uncache )( 
            IOleCache __RPC_FAR * This,
            /* [in] */ DWORD dwConnection);
        
        HRESULT ( __stdcall __RPC_FAR *EnumCache )( 
            IOleCache __RPC_FAR * This,
            /* [out] */ IEnumSTATDATA __RPC_FAR *__RPC_FAR *ppenumSTATDATA);
        
        HRESULT ( __stdcall __RPC_FAR *InitCache )( 
            IOleCache __RPC_FAR * This,
            /* [unique][in] */ IDataObject __RPC_FAR *pDataObject);
        
        HRESULT ( __stdcall __RPC_FAR *SetData )( 
            IOleCache __RPC_FAR * This,
            /* [unique][in] */ FORMATETC __RPC_FAR *pformatetc,
            /* [unique][in] */ STGMEDIUM __RPC_FAR *pmedium,
            /* [in] */ BOOL fRelease);
        
    } IOleCacheVtbl;

    interface IOleCache
    {
        CONST_VTBL struct IOleCacheVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IOleCache_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IOleCache_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IOleCache_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IOleCache_Cache(This,pformatetc,advf,pdwConnection)	\
    (This)->lpVtbl -> Cache(This,pformatetc,advf,pdwConnection)

#define IOleCache_Uncache(This,dwConnection)	\
    (This)->lpVtbl -> Uncache(This,dwConnection)

#define IOleCache_EnumCache(This,ppenumSTATDATA)	\
    (This)->lpVtbl -> EnumCache(This,ppenumSTATDATA)

#define IOleCache_InitCache(This,pDataObject)	\
    (This)->lpVtbl -> InitCache(This,pDataObject)

#define IOleCache_SetData(This,pformatetc,pmedium,fRelease)	\
    (This)->lpVtbl -> SetData(This,pformatetc,pmedium,fRelease)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT __stdcall IOleCache_Cache_Proxy( 
    IOleCache __RPC_FAR * This,
    /* [unique][in] */ FORMATETC __RPC_FAR *pformatetc,
    /* [in] */ DWORD advf,
    /* [out] */ DWORD __RPC_FAR *pdwConnection);


void __RPC_STUB IOleCache_Cache_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IOleCache_Uncache_Proxy( 
    IOleCache __RPC_FAR * This,
    /* [in] */ DWORD dwConnection);


void __RPC_STUB IOleCache_Uncache_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IOleCache_EnumCache_Proxy( 
    IOleCache __RPC_FAR * This,
    /* [out] */ IEnumSTATDATA __RPC_FAR *__RPC_FAR *ppenumSTATDATA);


void __RPC_STUB IOleCache_EnumCache_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IOleCache_InitCache_Proxy( 
    IOleCache __RPC_FAR * This,
    /* [unique][in] */ IDataObject __RPC_FAR *pDataObject);


void __RPC_STUB IOleCache_InitCache_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IOleCache_SetData_Proxy( 
    IOleCache __RPC_FAR * This,
    /* [unique][in] */ FORMATETC __RPC_FAR *pformatetc,
    /* [unique][in] */ STGMEDIUM __RPC_FAR *pmedium,
    /* [in] */ BOOL fRelease);


void __RPC_STUB IOleCache_SetData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IOleCache_INTERFACE_DEFINED__ */


#ifndef __IOleCache2_INTERFACE_DEFINED__
#define __IOleCache2_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IOleCache2
 * at Fri Apr 28 07:02:35 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [unique][uuid][local][object] */ 


			/* size is 4 */
typedef /* [unique] */ IOleCache2 __RPC_FAR *LPOLECACHE2;

			/* size is 4 */
#define	UPDFCACHE_NODATACACHE	( 0x1 )

			/* size is 4 */
#define	UPDFCACHE_ONSAVECACHE	( 0x2 )

			/* size is 4 */
#define	UPDFCACHE_ONSTOPCACHE	( 0x4 )

			/* size is 4 */
#define	UPDFCACHE_NORMALCACHE	( 0x8 )

			/* size is 4 */
#define	UPDFCACHE_IFBLANK	( 0x10 )

			/* size is 4 */
#define	UPDFCACHE_ONLYIFBLANK	( 0x80000000 )

			/* size is 4 */
#define	UPDFCACHE_IFBLANKORONSAVECACHE	( UPDFCACHE_IFBLANK | UPDFCACHE_ONSAVECACHE )

			/* size is 4 */
#define	UPDFCACHE_ALL	( ( DWORD  )~UPDFCACHE_ONLYIFBLANK )

			/* size is 4 */
#define	UPDFCACHE_ALLBUTNODATACACHE	( UPDFCACHE_ALL & ( DWORD  )~UPDFCACHE_NODATACACHE )

			/* size is 2 */
typedef /* [transmit] */ 
enum tagDISCARDCACHE
    {	DISCARDCACHE_SAVEIFDIRTY	= 0,
	DISCARDCACHE_NOSAVE	= 1
    }	DISCARDCACHE;

#define DISCARDCACHE_to_xmit(pEnum, ppLong) *(ppLong) = (long *) (pEnum)
#define DISCARDCACHE_from_xmit(pLong, pEnum) *(pEnum) = (DISCARDCACHE) *(pLong)
#define DISCARDCACHE_free_inst(pEnum) 
#define DISCARDCACHE_free_xmit(pLong) 

EXTERN_C const IID IID_IOleCache2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IOleCache2 : public IOleCache
    {
    public:
        virtual HRESULT __stdcall UpdateCache( 
            /* [in] */ LPDATAOBJECT pDataObject,
            /* [in] */ DWORD grfUpdf,
            /* [in] */ LPVOID pReserved) = 0;
        
        virtual HRESULT __stdcall DiscardCache( 
            /* [in] */ DWORD dwDiscardOptions) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IOleCache2Vtbl
    {
        
        HRESULT ( __stdcall __RPC_FAR *QueryInterface )( 
            IOleCache2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( __stdcall __RPC_FAR *AddRef )( 
            IOleCache2 __RPC_FAR * This);
        
        ULONG ( __stdcall __RPC_FAR *Release )( 
            IOleCache2 __RPC_FAR * This);
        
        HRESULT ( __stdcall __RPC_FAR *Cache )( 
            IOleCache2 __RPC_FAR * This,
            /* [unique][in] */ FORMATETC __RPC_FAR *pformatetc,
            /* [in] */ DWORD advf,
            /* [out] */ DWORD __RPC_FAR *pdwConnection);
        
        HRESULT ( __stdcall __RPC_FAR *Uncache )( 
            IOleCache2 __RPC_FAR * This,
            /* [in] */ DWORD dwConnection);
        
        HRESULT ( __stdcall __RPC_FAR *EnumCache )( 
            IOleCache2 __RPC_FAR * This,
            /* [out] */ IEnumSTATDATA __RPC_FAR *__RPC_FAR *ppenumSTATDATA);
        
        HRESULT ( __stdcall __RPC_FAR *InitCache )( 
            IOleCache2 __RPC_FAR * This,
            /* [unique][in] */ IDataObject __RPC_FAR *pDataObject);
        
        HRESULT ( __stdcall __RPC_FAR *SetData )( 
            IOleCache2 __RPC_FAR * This,
            /* [unique][in] */ FORMATETC __RPC_FAR *pformatetc,
            /* [unique][in] */ STGMEDIUM __RPC_FAR *pmedium,
            /* [in] */ BOOL fRelease);
        
        HRESULT ( __stdcall __RPC_FAR *UpdateCache )( 
            IOleCache2 __RPC_FAR * This,
            /* [in] */ LPDATAOBJECT pDataObject,
            /* [in] */ DWORD grfUpdf,
            /* [in] */ LPVOID pReserved);
        
        HRESULT ( __stdcall __RPC_FAR *DiscardCache )( 
            IOleCache2 __RPC_FAR * This,
            /* [in] */ DWORD dwDiscardOptions);
        
    } IOleCache2Vtbl;

    interface IOleCache2
    {
        CONST_VTBL struct IOleCache2Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IOleCache2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IOleCache2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IOleCache2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IOleCache2_Cache(This,pformatetc,advf,pdwConnection)	\
    (This)->lpVtbl -> Cache(This,pformatetc,advf,pdwConnection)

#define IOleCache2_Uncache(This,dwConnection)	\
    (This)->lpVtbl -> Uncache(This,dwConnection)

#define IOleCache2_EnumCache(This,ppenumSTATDATA)	\
    (This)->lpVtbl -> EnumCache(This,ppenumSTATDATA)

#define IOleCache2_InitCache(This,pDataObject)	\
    (This)->lpVtbl -> InitCache(This,pDataObject)

#define IOleCache2_SetData(This,pformatetc,pmedium,fRelease)	\
    (This)->lpVtbl -> SetData(This,pformatetc,pmedium,fRelease)


#define IOleCache2_UpdateCache(This,pDataObject,grfUpdf,pReserved)	\
    (This)->lpVtbl -> UpdateCache(This,pDataObject,grfUpdf,pReserved)

#define IOleCache2_DiscardCache(This,dwDiscardOptions)	\
    (This)->lpVtbl -> DiscardCache(This,dwDiscardOptions)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT __stdcall IOleCache2_UpdateCache_Proxy( 
    IOleCache2 __RPC_FAR * This,
    /* [in] */ LPDATAOBJECT pDataObject,
    /* [in] */ DWORD grfUpdf,
    /* [in] */ LPVOID pReserved);


void __RPC_STUB IOleCache2_UpdateCache_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IOleCache2_DiscardCache_Proxy( 
    IOleCache2 __RPC_FAR * This,
    /* [in] */ DWORD dwDiscardOptions);


void __RPC_STUB IOleCache2_DiscardCache_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IOleCache2_INTERFACE_DEFINED__ */


#ifndef __IOleCacheControl_INTERFACE_DEFINED__
#define __IOleCacheControl_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IOleCacheControl
 * at Fri Apr 28 07:02:35 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [uuid][local][object] */ 


			/* size is 4 */
typedef /* [unique] */ IOleCacheControl __RPC_FAR *LPOLECACHECONTROL;


EXTERN_C const IID IID_IOleCacheControl;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IOleCacheControl : public IUnknown
    {
    public:
        virtual HRESULT __stdcall OnRun( 
            LPDATAOBJECT pDataObject) = 0;
        
        virtual HRESULT __stdcall OnStop( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IOleCacheControlVtbl
    {
        
        HRESULT ( __stdcall __RPC_FAR *QueryInterface )( 
            IOleCacheControl __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( __stdcall __RPC_FAR *AddRef )( 
            IOleCacheControl __RPC_FAR * This);
        
        ULONG ( __stdcall __RPC_FAR *Release )( 
            IOleCacheControl __RPC_FAR * This);
        
        HRESULT ( __stdcall __RPC_FAR *OnRun )( 
            IOleCacheControl __RPC_FAR * This,
            LPDATAOBJECT pDataObject);
        
        HRESULT ( __stdcall __RPC_FAR *OnStop )( 
            IOleCacheControl __RPC_FAR * This);
        
    } IOleCacheControlVtbl;

    interface IOleCacheControl
    {
        CONST_VTBL struct IOleCacheControlVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IOleCacheControl_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IOleCacheControl_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IOleCacheControl_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IOleCacheControl_OnRun(This,pDataObject)	\
    (This)->lpVtbl -> OnRun(This,pDataObject)

#define IOleCacheControl_OnStop(This)	\
    (This)->lpVtbl -> OnStop(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT __stdcall IOleCacheControl_OnRun_Proxy( 
    IOleCacheControl __RPC_FAR * This,
    LPDATAOBJECT pDataObject);


void __RPC_STUB IOleCacheControl_OnRun_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IOleCacheControl_OnStop_Proxy( 
    IOleCacheControl __RPC_FAR * This);


void __RPC_STUB IOleCacheControl_OnStop_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IOleCacheControl_INTERFACE_DEFINED__ */


#ifndef __IParseDisplayName_INTERFACE_DEFINED__
#define __IParseDisplayName_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IParseDisplayName
 * at Fri Apr 28 07:02:35 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [unique][uuid][object] */ 


			/* size is 4 */
typedef /* [unique] */ IParseDisplayName __RPC_FAR *LPPARSEDISPLAYNAME;


EXTERN_C const IID IID_IParseDisplayName;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IParseDisplayName : public IUnknown
    {
    public:
        virtual HRESULT __stdcall ParseDisplayName( 
            /* [unique][in] */ IBindCtx __RPC_FAR *pbc,
            /* [in] */ LPOLESTR pszDisplayName,
            /* [out] */ ULONG __RPC_FAR *pchEaten,
            /* [out] */ IMoniker __RPC_FAR *__RPC_FAR *ppmkOut) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IParseDisplayNameVtbl
    {
        
        HRESULT ( __stdcall __RPC_FAR *QueryInterface )( 
            IParseDisplayName __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( __stdcall __RPC_FAR *AddRef )( 
            IParseDisplayName __RPC_FAR * This);
        
        ULONG ( __stdcall __RPC_FAR *Release )( 
            IParseDisplayName __RPC_FAR * This);
        
        HRESULT ( __stdcall __RPC_FAR *ParseDisplayName )( 
            IParseDisplayName __RPC_FAR * This,
            /* [unique][in] */ IBindCtx __RPC_FAR *pbc,
            /* [in] */ LPOLESTR pszDisplayName,
            /* [out] */ ULONG __RPC_FAR *pchEaten,
            /* [out] */ IMoniker __RPC_FAR *__RPC_FAR *ppmkOut);
        
    } IParseDisplayNameVtbl;

    interface IParseDisplayName
    {
        CONST_VTBL struct IParseDisplayNameVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IParseDisplayName_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IParseDisplayName_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IParseDisplayName_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IParseDisplayName_ParseDisplayName(This,pbc,pszDisplayName,pchEaten,ppmkOut)	\
    (This)->lpVtbl -> ParseDisplayName(This,pbc,pszDisplayName,pchEaten,ppmkOut)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT __stdcall IParseDisplayName_ParseDisplayName_Proxy( 
    IParseDisplayName __RPC_FAR * This,
    /* [unique][in] */ IBindCtx __RPC_FAR *pbc,
    /* [in] */ LPOLESTR pszDisplayName,
    /* [out] */ ULONG __RPC_FAR *pchEaten,
    /* [out] */ IMoniker __RPC_FAR *__RPC_FAR *ppmkOut);


void __RPC_STUB IParseDisplayName_ParseDisplayName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IParseDisplayName_INTERFACE_DEFINED__ */


#ifndef __IOleContainer_INTERFACE_DEFINED__
#define __IOleContainer_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IOleContainer
 * at Fri Apr 28 07:02:35 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [unique][uuid][object] */ 


			/* size is 4 */
typedef /* [unique] */ IOleContainer __RPC_FAR *LPOLECONTAINER;


EXTERN_C const IID IID_IOleContainer;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IOleContainer : public IParseDisplayName
    {
    public:
        virtual HRESULT __stdcall EnumObjects( 
            /* [in] */ DWORD grfFlags,
            /* [out] */ IEnumUnknown __RPC_FAR *__RPC_FAR *ppenum) = 0;
        
        virtual HRESULT __stdcall LockContainer( 
            /* [in] */ BOOL fLock) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IOleContainerVtbl
    {
        
        HRESULT ( __stdcall __RPC_FAR *QueryInterface )( 
            IOleContainer __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( __stdcall __RPC_FAR *AddRef )( 
            IOleContainer __RPC_FAR * This);
        
        ULONG ( __stdcall __RPC_FAR *Release )( 
            IOleContainer __RPC_FAR * This);
        
        HRESULT ( __stdcall __RPC_FAR *ParseDisplayName )( 
            IOleContainer __RPC_FAR * This,
            /* [unique][in] */ IBindCtx __RPC_FAR *pbc,
            /* [in] */ LPOLESTR pszDisplayName,
            /* [out] */ ULONG __RPC_FAR *pchEaten,
            /* [out] */ IMoniker __RPC_FAR *__RPC_FAR *ppmkOut);
        
        HRESULT ( __stdcall __RPC_FAR *EnumObjects )( 
            IOleContainer __RPC_FAR * This,
            /* [in] */ DWORD grfFlags,
            /* [out] */ IEnumUnknown __RPC_FAR *__RPC_FAR *ppenum);
        
        HRESULT ( __stdcall __RPC_FAR *LockContainer )( 
            IOleContainer __RPC_FAR * This,
            /* [in] */ BOOL fLock);
        
    } IOleContainerVtbl;

    interface IOleContainer
    {
        CONST_VTBL struct IOleContainerVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IOleContainer_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IOleContainer_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IOleContainer_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IOleContainer_ParseDisplayName(This,pbc,pszDisplayName,pchEaten,ppmkOut)	\
    (This)->lpVtbl -> ParseDisplayName(This,pbc,pszDisplayName,pchEaten,ppmkOut)


#define IOleContainer_EnumObjects(This,grfFlags,ppenum)	\
    (This)->lpVtbl -> EnumObjects(This,grfFlags,ppenum)

#define IOleContainer_LockContainer(This,fLock)	\
    (This)->lpVtbl -> LockContainer(This,fLock)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT __stdcall IOleContainer_EnumObjects_Proxy( 
    IOleContainer __RPC_FAR * This,
    /* [in] */ DWORD grfFlags,
    /* [out] */ IEnumUnknown __RPC_FAR *__RPC_FAR *ppenum);


void __RPC_STUB IOleContainer_EnumObjects_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IOleContainer_LockContainer_Proxy( 
    IOleContainer __RPC_FAR * This,
    /* [in] */ BOOL fLock);


void __RPC_STUB IOleContainer_LockContainer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IOleContainer_INTERFACE_DEFINED__ */


#ifndef __IOleClientSite_INTERFACE_DEFINED__
#define __IOleClientSite_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IOleClientSite
 * at Fri Apr 28 07:02:35 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [unique][uuid][object] */ 


			/* size is 4 */
typedef /* [unique] */ IOleClientSite __RPC_FAR *LPOLECLIENTSITE;


EXTERN_C const IID IID_IOleClientSite;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IOleClientSite : public IUnknown
    {
    public:
        virtual HRESULT __stdcall SaveObject( void) = 0;
        
        virtual HRESULT __stdcall GetMoniker( 
            /* [in] */ DWORD dwAssign,
            /* [in] */ DWORD dwWhichMoniker,
            /* [out] */ IMoniker __RPC_FAR *__RPC_FAR *ppmk) = 0;
        
        virtual HRESULT __stdcall GetContainer( 
            /* [out] */ IOleContainer __RPC_FAR *__RPC_FAR *ppContainer) = 0;
        
        virtual HRESULT __stdcall ShowObject( void) = 0;
        
        virtual HRESULT __stdcall OnShowWindow( 
            /* [in] */ BOOL fShow) = 0;
        
        virtual HRESULT __stdcall RequestNewObjectLayout( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IOleClientSiteVtbl
    {
        
        HRESULT ( __stdcall __RPC_FAR *QueryInterface )( 
            IOleClientSite __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( __stdcall __RPC_FAR *AddRef )( 
            IOleClientSite __RPC_FAR * This);
        
        ULONG ( __stdcall __RPC_FAR *Release )( 
            IOleClientSite __RPC_FAR * This);
        
        HRESULT ( __stdcall __RPC_FAR *SaveObject )( 
            IOleClientSite __RPC_FAR * This);
        
        HRESULT ( __stdcall __RPC_FAR *GetMoniker )( 
            IOleClientSite __RPC_FAR * This,
            /* [in] */ DWORD dwAssign,
            /* [in] */ DWORD dwWhichMoniker,
            /* [out] */ IMoniker __RPC_FAR *__RPC_FAR *ppmk);
        
        HRESULT ( __stdcall __RPC_FAR *GetContainer )( 
            IOleClientSite __RPC_FAR * This,
            /* [out] */ IOleContainer __RPC_FAR *__RPC_FAR *ppContainer);
        
        HRESULT ( __stdcall __RPC_FAR *ShowObject )( 
            IOleClientSite __RPC_FAR * This);
        
        HRESULT ( __stdcall __RPC_FAR *OnShowWindow )( 
            IOleClientSite __RPC_FAR * This,
            /* [in] */ BOOL fShow);
        
        HRESULT ( __stdcall __RPC_FAR *RequestNewObjectLayout )( 
            IOleClientSite __RPC_FAR * This);
        
    } IOleClientSiteVtbl;

    interface IOleClientSite
    {
        CONST_VTBL struct IOleClientSiteVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IOleClientSite_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IOleClientSite_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IOleClientSite_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IOleClientSite_SaveObject(This)	\
    (This)->lpVtbl -> SaveObject(This)

#define IOleClientSite_GetMoniker(This,dwAssign,dwWhichMoniker,ppmk)	\
    (This)->lpVtbl -> GetMoniker(This,dwAssign,dwWhichMoniker,ppmk)

#define IOleClientSite_GetContainer(This,ppContainer)	\
    (This)->lpVtbl -> GetContainer(This,ppContainer)

#define IOleClientSite_ShowObject(This)	\
    (This)->lpVtbl -> ShowObject(This)

#define IOleClientSite_OnShowWindow(This,fShow)	\
    (This)->lpVtbl -> OnShowWindow(This,fShow)

#define IOleClientSite_RequestNewObjectLayout(This)	\
    (This)->lpVtbl -> RequestNewObjectLayout(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT __stdcall IOleClientSite_SaveObject_Proxy( 
    IOleClientSite __RPC_FAR * This);


void __RPC_STUB IOleClientSite_SaveObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IOleClientSite_GetMoniker_Proxy( 
    IOleClientSite __RPC_FAR * This,
    /* [in] */ DWORD dwAssign,
    /* [in] */ DWORD dwWhichMoniker,
    /* [out] */ IMoniker __RPC_FAR *__RPC_FAR *ppmk);


void __RPC_STUB IOleClientSite_GetMoniker_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IOleClientSite_GetContainer_Proxy( 
    IOleClientSite __RPC_FAR * This,
    /* [out] */ IOleContainer __RPC_FAR *__RPC_FAR *ppContainer);


void __RPC_STUB IOleClientSite_GetContainer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IOleClientSite_ShowObject_Proxy( 
    IOleClientSite __RPC_FAR * This);


void __RPC_STUB IOleClientSite_ShowObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IOleClientSite_OnShowWindow_Proxy( 
    IOleClientSite __RPC_FAR * This,
    /* [in] */ BOOL fShow);


void __RPC_STUB IOleClientSite_OnShowWindow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IOleClientSite_RequestNewObjectLayout_Proxy( 
    IOleClientSite __RPC_FAR * This);


void __RPC_STUB IOleClientSite_RequestNewObjectLayout_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IOleClientSite_INTERFACE_DEFINED__ */


#ifndef __IOleObject_INTERFACE_DEFINED__
#define __IOleObject_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IOleObject
 * at Fri Apr 28 07:02:35 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [unique][uuid][object] */ 


			/* size is 4 */
typedef /* [unique] */ IOleObject __RPC_FAR *LPOLEOBJECT;

			/* size is 2 */
typedef 
enum tagOLEGETMONIKER
    {	OLEGETMONIKER_ONLYIFTHERE	= 1,
	OLEGETMONIKER_FORCEASSIGN	= 2,
	OLEGETMONIKER_UNASSIGN	= 3,
	OLEGETMONIKER_TEMPFORUSER	= 4
    }	OLEGETMONIKER;

			/* size is 2 */
typedef 
enum tagOLEWHICHMK
    {	OLEWHICHMK_CONTAINER	= 1,
	OLEWHICHMK_OBJREL	= 2,
	OLEWHICHMK_OBJFULL	= 3
    }	OLEWHICHMK;

			/* size is 2 */
typedef 
enum tagUSERCLASSTYPE
    {	USERCLASSTYPE_FULL	= 1,
	USERCLASSTYPE_SHORT	= 2,
	USERCLASSTYPE_APPNAME	= 3
    }	USERCLASSTYPE;

			/* size is 2 */
typedef 
enum tagOLEMISC
    {	OLEMISC_RECOMPOSEONRESIZE	= 1,
	OLEMISC_ONLYICONIC	= 2,
	OLEMISC_INSERTNOTREPLACE	= 4,
	OLEMISC_STATIC	= 8,
	OLEMISC_CANTLINKINSIDE	= 16,
	OLEMISC_CANLINKBYOLE1	= 32,
	OLEMISC_ISLINKOBJECT	= 64,
	OLEMISC_INSIDEOUT	= 128,
	OLEMISC_ACTIVATEWHENVISIBLE	= 256,
	OLEMISC_RENDERINGISDEVICEINDEPENDENT	= 512
    }	OLEMISC;

			/* size is 2 */
typedef 
enum tagOLECLOSE
    {	OLECLOSE_SAVEIFDIRTY	= 0,
	OLECLOSE_NOSAVE	= 1,
	OLECLOSE_PROMPTSAVE	= 2
    }	OLECLOSE;


EXTERN_C const IID IID_IOleObject;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IOleObject : public IUnknown
    {
    public:
        virtual HRESULT __stdcall SetClientSite( 
            /* [unique][in] */ IOleClientSite __RPC_FAR *pClientSite) = 0;
        
        virtual HRESULT __stdcall GetClientSite( 
            /* [out] */ IOleClientSite __RPC_FAR *__RPC_FAR *ppClientSite) = 0;
        
        virtual HRESULT __stdcall SetHostNames( 
            /* [in] */ LPCOLESTR szContainerApp,
            /* [unique][in] */ LPCOLESTR szContainerObj) = 0;
        
        virtual HRESULT __stdcall Close( 
            /* [in] */ DWORD dwSaveOption) = 0;
        
        virtual HRESULT __stdcall SetMoniker( 
            /* [in] */ DWORD dwWhichMoniker,
            /* [unique][in] */ IMoniker __RPC_FAR *pmk) = 0;
        
        virtual HRESULT __stdcall GetMoniker( 
            /* [in] */ DWORD dwAssign,
            /* [in] */ DWORD dwWhichMoniker,
            /* [out] */ IMoniker __RPC_FAR *__RPC_FAR *ppmk) = 0;
        
        virtual HRESULT __stdcall InitFromData( 
            /* [unique][in] */ IDataObject __RPC_FAR *pDataObject,
            /* [in] */ BOOL fCreation,
            /* [in] */ DWORD dwReserved) = 0;
        
        virtual HRESULT __stdcall GetClipboardData( 
            /* [in] */ DWORD dwReserved,
            /* [out] */ IDataObject __RPC_FAR *__RPC_FAR *ppDataObject) = 0;
        
        virtual HRESULT __stdcall DoVerb( 
            /* [in] */ LONG iVerb,
            /* [unique][in] */ LPMSG lpmsg,
            /* [unique][in] */ IOleClientSite __RPC_FAR *pActiveSite,
            /* [in] */ LONG lindex,
            /* [in] */ HWND hwndParent,
            /* [unique][in] */ LPCRECT lprcPosRect) = 0;
        
        virtual HRESULT __stdcall EnumVerbs( 
            /* [out] */ IEnumOLEVERB __RPC_FAR *__RPC_FAR *ppEnumOleVerb) = 0;
        
        virtual HRESULT __stdcall Update( void) = 0;
        
        virtual HRESULT __stdcall IsUpToDate( void) = 0;
        
        virtual HRESULT __stdcall GetUserClassID( 
            /* [out] */ CLSID __RPC_FAR *pClsid) = 0;
        
        virtual HRESULT __stdcall GetUserType( 
            /* [in] */ DWORD dwFormOfType,
            /* [out] */ LPOLESTR __RPC_FAR *pszUserType) = 0;
        
        virtual HRESULT __stdcall SetExtent( 
            /* [in] */ DWORD dwDrawAspect,
            /* [in] */ SIZEL __RPC_FAR *psizel) = 0;
        
        virtual HRESULT __stdcall GetExtent( 
            /* [in] */ DWORD dwDrawAspect,
            /* [out] */ SIZEL __RPC_FAR *psizel) = 0;
        
        virtual HRESULT __stdcall Advise( 
            /* [unique][in] */ IAdviseSink __RPC_FAR *pAdvSink,
            /* [out] */ DWORD __RPC_FAR *pdwConnection) = 0;
        
        virtual HRESULT __stdcall Unadvise( 
            /* [in] */ DWORD dwConnection) = 0;
        
        virtual HRESULT __stdcall EnumAdvise( 
            /* [out] */ IEnumSTATDATA __RPC_FAR *__RPC_FAR *ppenumAdvise) = 0;
        
        virtual HRESULT __stdcall GetMiscStatus( 
            /* [in] */ DWORD dwAspect,
            /* [out] */ DWORD __RPC_FAR *pdwStatus) = 0;
        
        virtual HRESULT __stdcall SetColorScheme( 
            /* [in] */ LOGPALETTE __RPC_FAR *pLogpal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IOleObjectVtbl
    {
        
        HRESULT ( __stdcall __RPC_FAR *QueryInterface )( 
            IOleObject __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( __stdcall __RPC_FAR *AddRef )( 
            IOleObject __RPC_FAR * This);
        
        ULONG ( __stdcall __RPC_FAR *Release )( 
            IOleObject __RPC_FAR * This);
        
        HRESULT ( __stdcall __RPC_FAR *SetClientSite )( 
            IOleObject __RPC_FAR * This,
            /* [unique][in] */ IOleClientSite __RPC_FAR *pClientSite);
        
        HRESULT ( __stdcall __RPC_FAR *GetClientSite )( 
            IOleObject __RPC_FAR * This,
            /* [out] */ IOleClientSite __RPC_FAR *__RPC_FAR *ppClientSite);
        
        HRESULT ( __stdcall __RPC_FAR *SetHostNames )( 
            IOleObject __RPC_FAR * This,
            /* [in] */ LPCOLESTR szContainerApp,
            /* [unique][in] */ LPCOLESTR szContainerObj);
        
        HRESULT ( __stdcall __RPC_FAR *Close )( 
            IOleObject __RPC_FAR * This,
            /* [in] */ DWORD dwSaveOption);
        
        HRESULT ( __stdcall __RPC_FAR *SetMoniker )( 
            IOleObject __RPC_FAR * This,
            /* [in] */ DWORD dwWhichMoniker,
            /* [unique][in] */ IMoniker __RPC_FAR *pmk);
        
        HRESULT ( __stdcall __RPC_FAR *GetMoniker )( 
            IOleObject __RPC_FAR * This,
            /* [in] */ DWORD dwAssign,
            /* [in] */ DWORD dwWhichMoniker,
            /* [out] */ IMoniker __RPC_FAR *__RPC_FAR *ppmk);
        
        HRESULT ( __stdcall __RPC_FAR *InitFromData )( 
            IOleObject __RPC_FAR * This,
            /* [unique][in] */ IDataObject __RPC_FAR *pDataObject,
            /* [in] */ BOOL fCreation,
            /* [in] */ DWORD dwReserved);
        
        HRESULT ( __stdcall __RPC_FAR *GetClipboardData )( 
            IOleObject __RPC_FAR * This,
            /* [in] */ DWORD dwReserved,
            /* [out] */ IDataObject __RPC_FAR *__RPC_FAR *ppDataObject);
        
        HRESULT ( __stdcall __RPC_FAR *DoVerb )( 
            IOleObject __RPC_FAR * This,
            /* [in] */ LONG iVerb,
            /* [unique][in] */ LPMSG lpmsg,
            /* [unique][in] */ IOleClientSite __RPC_FAR *pActiveSite,
            /* [in] */ LONG lindex,
            /* [in] */ HWND hwndParent,
            /* [unique][in] */ LPCRECT lprcPosRect);
        
        HRESULT ( __stdcall __RPC_FAR *EnumVerbs )( 
            IOleObject __RPC_FAR * This,
            /* [out] */ IEnumOLEVERB __RPC_FAR *__RPC_FAR *ppEnumOleVerb);
        
        HRESULT ( __stdcall __RPC_FAR *Update )( 
            IOleObject __RPC_FAR * This);
        
        HRESULT ( __stdcall __RPC_FAR *IsUpToDate )( 
            IOleObject __RPC_FAR * This);
        
        HRESULT ( __stdcall __RPC_FAR *GetUserClassID )( 
            IOleObject __RPC_FAR * This,
            /* [out] */ CLSID __RPC_FAR *pClsid);
        
        HRESULT ( __stdcall __RPC_FAR *GetUserType )( 
            IOleObject __RPC_FAR * This,
            /* [in] */ DWORD dwFormOfType,
            /* [out] */ LPOLESTR __RPC_FAR *pszUserType);
        
        HRESULT ( __stdcall __RPC_FAR *SetExtent )( 
            IOleObject __RPC_FAR * This,
            /* [in] */ DWORD dwDrawAspect,
            /* [in] */ SIZEL __RPC_FAR *psizel);
        
        HRESULT ( __stdcall __RPC_FAR *GetExtent )( 
            IOleObject __RPC_FAR * This,
            /* [in] */ DWORD dwDrawAspect,
            /* [out] */ SIZEL __RPC_FAR *psizel);
        
        HRESULT ( __stdcall __RPC_FAR *Advise )( 
            IOleObject __RPC_FAR * This,
            /* [unique][in] */ IAdviseSink __RPC_FAR *pAdvSink,
            /* [out] */ DWORD __RPC_FAR *pdwConnection);
        
        HRESULT ( __stdcall __RPC_FAR *Unadvise )( 
            IOleObject __RPC_FAR * This,
            /* [in] */ DWORD dwConnection);
        
        HRESULT ( __stdcall __RPC_FAR *EnumAdvise )( 
            IOleObject __RPC_FAR * This,
            /* [out] */ IEnumSTATDATA __RPC_FAR *__RPC_FAR *ppenumAdvise);
        
        HRESULT ( __stdcall __RPC_FAR *GetMiscStatus )( 
            IOleObject __RPC_FAR * This,
            /* [in] */ DWORD dwAspect,
            /* [out] */ DWORD __RPC_FAR *pdwStatus);
        
        HRESULT ( __stdcall __RPC_FAR *SetColorScheme )( 
            IOleObject __RPC_FAR * This,
            /* [in] */ LOGPALETTE __RPC_FAR *pLogpal);
        
    } IOleObjectVtbl;

    interface IOleObject
    {
        CONST_VTBL struct IOleObjectVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IOleObject_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IOleObject_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IOleObject_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IOleObject_SetClientSite(This,pClientSite)	\
    (This)->lpVtbl -> SetClientSite(This,pClientSite)

#define IOleObject_GetClientSite(This,ppClientSite)	\
    (This)->lpVtbl -> GetClientSite(This,ppClientSite)

#define IOleObject_SetHostNames(This,szContainerApp,szContainerObj)	\
    (This)->lpVtbl -> SetHostNames(This,szContainerApp,szContainerObj)

#define IOleObject_Close(This,dwSaveOption)	\
    (This)->lpVtbl -> Close(This,dwSaveOption)

#define IOleObject_SetMoniker(This,dwWhichMoniker,pmk)	\
    (This)->lpVtbl -> SetMoniker(This,dwWhichMoniker,pmk)

#define IOleObject_GetMoniker(This,dwAssign,dwWhichMoniker,ppmk)	\
    (This)->lpVtbl -> GetMoniker(This,dwAssign,dwWhichMoniker,ppmk)

#define IOleObject_InitFromData(This,pDataObject,fCreation,dwReserved)	\
    (This)->lpVtbl -> InitFromData(This,pDataObject,fCreation,dwReserved)

#define IOleObject_GetClipboardData(This,dwReserved,ppDataObject)	\
    (This)->lpVtbl -> GetClipboardData(This,dwReserved,ppDataObject)

#define IOleObject_DoVerb(This,iVerb,lpmsg,pActiveSite,lindex,hwndParent,lprcPosRect)	\
    (This)->lpVtbl -> DoVerb(This,iVerb,lpmsg,pActiveSite,lindex,hwndParent,lprcPosRect)

#define IOleObject_EnumVerbs(This,ppEnumOleVerb)	\
    (This)->lpVtbl -> EnumVerbs(This,ppEnumOleVerb)

#define IOleObject_Update(This)	\
    (This)->lpVtbl -> Update(This)

#define IOleObject_IsUpToDate(This)	\
    (This)->lpVtbl -> IsUpToDate(This)

#define IOleObject_GetUserClassID(This,pClsid)	\
    (This)->lpVtbl -> GetUserClassID(This,pClsid)

#define IOleObject_GetUserType(This,dwFormOfType,pszUserType)	\
    (This)->lpVtbl -> GetUserType(This,dwFormOfType,pszUserType)

#define IOleObject_SetExtent(This,dwDrawAspect,psizel)	\
    (This)->lpVtbl -> SetExtent(This,dwDrawAspect,psizel)

#define IOleObject_GetExtent(This,dwDrawAspect,psizel)	\
    (This)->lpVtbl -> GetExtent(This,dwDrawAspect,psizel)

#define IOleObject_Advise(This,pAdvSink,pdwConnection)	\
    (This)->lpVtbl -> Advise(This,pAdvSink,pdwConnection)

#define IOleObject_Unadvise(This,dwConnection)	\
    (This)->lpVtbl -> Unadvise(This,dwConnection)

#define IOleObject_EnumAdvise(This,ppenumAdvise)	\
    (This)->lpVtbl -> EnumAdvise(This,ppenumAdvise)

#define IOleObject_GetMiscStatus(This,dwAspect,pdwStatus)	\
    (This)->lpVtbl -> GetMiscStatus(This,dwAspect,pdwStatus)

#define IOleObject_SetColorScheme(This,pLogpal)	\
    (This)->lpVtbl -> SetColorScheme(This,pLogpal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT __stdcall IOleObject_SetClientSite_Proxy( 
    IOleObject __RPC_FAR * This,
    /* [unique][in] */ IOleClientSite __RPC_FAR *pClientSite);


void __RPC_STUB IOleObject_SetClientSite_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IOleObject_GetClientSite_Proxy( 
    IOleObject __RPC_FAR * This,
    /* [out] */ IOleClientSite __RPC_FAR *__RPC_FAR *ppClientSite);


void __RPC_STUB IOleObject_GetClientSite_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IOleObject_SetHostNames_Proxy( 
    IOleObject __RPC_FAR * This,
    /* [in] */ LPCOLESTR szContainerApp,
    /* [unique][in] */ LPCOLESTR szContainerObj);


void __RPC_STUB IOleObject_SetHostNames_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IOleObject_Close_Proxy( 
    IOleObject __RPC_FAR * This,
    /* [in] */ DWORD dwSaveOption);


void __RPC_STUB IOleObject_Close_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IOleObject_SetMoniker_Proxy( 
    IOleObject __RPC_FAR * This,
    /* [in] */ DWORD dwWhichMoniker,
    /* [unique][in] */ IMoniker __RPC_FAR *pmk);


void __RPC_STUB IOleObject_SetMoniker_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IOleObject_GetMoniker_Proxy( 
    IOleObject __RPC_FAR * This,
    /* [in] */ DWORD dwAssign,
    /* [in] */ DWORD dwWhichMoniker,
    /* [out] */ IMoniker __RPC_FAR *__RPC_FAR *ppmk);


void __RPC_STUB IOleObject_GetMoniker_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IOleObject_InitFromData_Proxy( 
    IOleObject __RPC_FAR * This,
    /* [unique][in] */ IDataObject __RPC_FAR *pDataObject,
    /* [in] */ BOOL fCreation,
    /* [in] */ DWORD dwReserved);


void __RPC_STUB IOleObject_InitFromData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IOleObject_GetClipboardData_Proxy( 
    IOleObject __RPC_FAR * This,
    /* [in] */ DWORD dwReserved,
    /* [out] */ IDataObject __RPC_FAR *__RPC_FAR *ppDataObject);


void __RPC_STUB IOleObject_GetClipboardData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IOleObject_DoVerb_Proxy( 
    IOleObject __RPC_FAR * This,
    /* [in] */ LONG iVerb,
    /* [unique][in] */ LPMSG lpmsg,
    /* [unique][in] */ IOleClientSite __RPC_FAR *pActiveSite,
    /* [in] */ LONG lindex,
    /* [in] */ HWND hwndParent,
    /* [unique][in] */ LPCRECT lprcPosRect);


void __RPC_STUB IOleObject_DoVerb_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IOleObject_EnumVerbs_Proxy( 
    IOleObject __RPC_FAR * This,
    /* [out] */ IEnumOLEVERB __RPC_FAR *__RPC_FAR *ppEnumOleVerb);


void __RPC_STUB IOleObject_EnumVerbs_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IOleObject_Update_Proxy( 
    IOleObject __RPC_FAR * This);


void __RPC_STUB IOleObject_Update_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IOleObject_IsUpToDate_Proxy( 
    IOleObject __RPC_FAR * This);


void __RPC_STUB IOleObject_IsUpToDate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IOleObject_GetUserClassID_Proxy( 
    IOleObject __RPC_FAR * This,
    /* [out] */ CLSID __RPC_FAR *pClsid);


void __RPC_STUB IOleObject_GetUserClassID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IOleObject_GetUserType_Proxy( 
    IOleObject __RPC_FAR * This,
    /* [in] */ DWORD dwFormOfType,
    /* [out] */ LPOLESTR __RPC_FAR *pszUserType);


void __RPC_STUB IOleObject_GetUserType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IOleObject_SetExtent_Proxy( 
    IOleObject __RPC_FAR * This,
    /* [in] */ DWORD dwDrawAspect,
    /* [in] */ SIZEL __RPC_FAR *psizel);


void __RPC_STUB IOleObject_SetExtent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IOleObject_GetExtent_Proxy( 
    IOleObject __RPC_FAR * This,
    /* [in] */ DWORD dwDrawAspect,
    /* [out] */ SIZEL __RPC_FAR *psizel);


void __RPC_STUB IOleObject_GetExtent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IOleObject_Advise_Proxy( 
    IOleObject __RPC_FAR * This,
    /* [unique][in] */ IAdviseSink __RPC_FAR *pAdvSink,
    /* [out] */ DWORD __RPC_FAR *pdwConnection);


void __RPC_STUB IOleObject_Advise_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IOleObject_Unadvise_Proxy( 
    IOleObject __RPC_FAR * This,
    /* [in] */ DWORD dwConnection);


void __RPC_STUB IOleObject_Unadvise_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IOleObject_EnumAdvise_Proxy( 
    IOleObject __RPC_FAR * This,
    /* [out] */ IEnumSTATDATA __RPC_FAR *__RPC_FAR *ppenumAdvise);


void __RPC_STUB IOleObject_EnumAdvise_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IOleObject_GetMiscStatus_Proxy( 
    IOleObject __RPC_FAR * This,
    /* [in] */ DWORD dwAspect,
    /* [out] */ DWORD __RPC_FAR *pdwStatus);


void __RPC_STUB IOleObject_GetMiscStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IOleObject_SetColorScheme_Proxy( 
    IOleObject __RPC_FAR * This,
    /* [in] */ LOGPALETTE __RPC_FAR *pLogpal);


void __RPC_STUB IOleObject_SetColorScheme_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IOleObject_INTERFACE_DEFINED__ */


#ifndef __IOLETypes_INTERFACE_DEFINED__
#define __IOLETypes_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IOLETypes
 * at Fri Apr 28 07:02:35 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [auto_handle][uuid] */ 


			/* size is 2 */
typedef 
enum tagOLERENDER
    {	OLERENDER_NONE	= 0,
	OLERENDER_DRAW	= 1,
	OLERENDER_FORMAT	= 2,
	OLERENDER_ASIS	= 3
    }	OLERENDER;

			/* size is 4 */
typedef OLERENDER __RPC_FAR *LPOLERENDER;

			/* size is 52 */
typedef struct  tagOBJECTDESCRIPTOR
    {
    ULONG cbSize;
    CLSID clsid;
    DWORD dwDrawAspect;
    SIZEL sizel;
    POINTL pointl;
    DWORD dwStatus;
    DWORD dwFullUserTypeName;
    DWORD dwSrcOfCopy;
    }	OBJECTDESCRIPTOR;

			/* size is 4 */
typedef struct tagOBJECTDESCRIPTOR __RPC_FAR *POBJECTDESCRIPTOR;

			/* size is 4 */
typedef struct tagOBJECTDESCRIPTOR __RPC_FAR *LPOBJECTDESCRIPTOR;

			/* size is 52 */
typedef struct tagOBJECTDESCRIPTOR LINKSRCDESCRIPTOR;

			/* size is 4 */
typedef struct tagOBJECTDESCRIPTOR __RPC_FAR *PLINKSRCDESCRIPTOR;

			/* size is 4 */
typedef struct tagOBJECTDESCRIPTOR __RPC_FAR *LPLINKSRCDESCRIPTOR;



extern RPC_IF_HANDLE IOLETypes_v0_0_c_ifspec;
extern RPC_IF_HANDLE IOLETypes_v0_0_s_ifspec;
#endif /* __IOLETypes_INTERFACE_DEFINED__ */

#ifndef __IOleWindow_INTERFACE_DEFINED__
#define __IOleWindow_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IOleWindow
 * at Fri Apr 28 07:02:35 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [unique][uuid][object] */ 


			/* size is 4 */
typedef /* [unique] */ IOleWindow __RPC_FAR *LPOLEWINDOW;


EXTERN_C const IID IID_IOleWindow;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IOleWindow : public IUnknown
    {
    public:
        virtual /* [input_sync] */ HRESULT __stdcall GetWindow( 
            /* [out] */ HWND __RPC_FAR *phwnd) = 0;
        
        virtual HRESULT __stdcall ContextSensitiveHelp( 
            /* [in] */ BOOL fEnterMode) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IOleWindowVtbl
    {
        
        HRESULT ( __stdcall __RPC_FAR *QueryInterface )( 
            IOleWindow __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( __stdcall __RPC_FAR *AddRef )( 
            IOleWindow __RPC_FAR * This);
        
        ULONG ( __stdcall __RPC_FAR *Release )( 
            IOleWindow __RPC_FAR * This);
        
        /* [input_sync] */ HRESULT ( __stdcall __RPC_FAR *GetWindow )( 
            IOleWindow __RPC_FAR * This,
            /* [out] */ HWND __RPC_FAR *phwnd);
        
        HRESULT ( __stdcall __RPC_FAR *ContextSensitiveHelp )( 
            IOleWindow __RPC_FAR * This,
            /* [in] */ BOOL fEnterMode);
        
    } IOleWindowVtbl;

    interface IOleWindow
    {
        CONST_VTBL struct IOleWindowVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IOleWindow_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IOleWindow_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IOleWindow_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IOleWindow_GetWindow(This,phwnd)	\
    (This)->lpVtbl -> GetWindow(This,phwnd)

#define IOleWindow_ContextSensitiveHelp(This,fEnterMode)	\
    (This)->lpVtbl -> ContextSensitiveHelp(This,fEnterMode)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [input_sync] */ HRESULT __stdcall IOleWindow_GetWindow_Proxy( 
    IOleWindow __RPC_FAR * This,
    /* [out] */ HWND __RPC_FAR *phwnd);


void __RPC_STUB IOleWindow_GetWindow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IOleWindow_ContextSensitiveHelp_Proxy( 
    IOleWindow __RPC_FAR * This,
    /* [in] */ BOOL fEnterMode);


void __RPC_STUB IOleWindow_ContextSensitiveHelp_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IOleWindow_INTERFACE_DEFINED__ */


#ifndef __IOleLink_INTERFACE_DEFINED__
#define __IOleLink_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IOleLink
 * at Fri Apr 28 07:02:35 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [uuid][object][local] */ 


			/* size is 4 */
typedef /* [unique] */ IOleLink __RPC_FAR *LPOLELINK;

			/* size is 2 */
typedef 
enum tagOLEUPDATE
    {	OLEUPDATE_ALWAYS	= 1,
	OLEUPDATE_ONCALL	= 3
    }	OLEUPDATE;

			/* size is 4 */
typedef OLEUPDATE __RPC_FAR *LPOLEUPDATE;

			/* size is 4 */
typedef OLEUPDATE __RPC_FAR *POLEUPDATE;

			/* size is 2 */
typedef 
enum tagOLELINKBIND
    {	OLELINKBIND_EVENIFCLASSDIFF	= 1
    }	OLELINKBIND;


EXTERN_C const IID IID_IOleLink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IOleLink : public IUnknown
    {
    public:
        virtual HRESULT __stdcall SetUpdateOptions( 
            /* [in] */ DWORD dwUpdateOpt) = 0;
        
        virtual HRESULT __stdcall GetUpdateOptions( 
            /* [out] */ DWORD __RPC_FAR *pdwUpdateOpt) = 0;
        
        virtual HRESULT __stdcall SetSourceMoniker( 
            /* [unique][in] */ IMoniker __RPC_FAR *pmk,
            /* [in] */ REFCLSID rclsid) = 0;
        
        virtual HRESULT __stdcall GetSourceMoniker( 
            /* [out] */ IMoniker __RPC_FAR *__RPC_FAR *ppmk) = 0;
        
        virtual HRESULT __stdcall SetSourceDisplayName( 
            /* [in] */ LPCOLESTR pszStatusText) = 0;
        
        virtual HRESULT __stdcall GetSourceDisplayName( 
            /* [out] */ LPOLESTR __RPC_FAR *ppszDisplayName) = 0;
        
        virtual HRESULT __stdcall BindToSource( 
            /* [in] */ DWORD bindflags,
            /* [unique][in] */ IBindCtx __RPC_FAR *pbc) = 0;
        
        virtual HRESULT __stdcall BindIfRunning( void) = 0;
        
        virtual HRESULT __stdcall GetBoundSource( 
            /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunk) = 0;
        
        virtual HRESULT __stdcall UnbindSource( void) = 0;
        
        virtual HRESULT __stdcall Update( 
            /* [unique][in] */ IBindCtx __RPC_FAR *pbc) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IOleLinkVtbl
    {
        
        HRESULT ( __stdcall __RPC_FAR *QueryInterface )( 
            IOleLink __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( __stdcall __RPC_FAR *AddRef )( 
            IOleLink __RPC_FAR * This);
        
        ULONG ( __stdcall __RPC_FAR *Release )( 
            IOleLink __RPC_FAR * This);
        
        HRESULT ( __stdcall __RPC_FAR *SetUpdateOptions )( 
            IOleLink __RPC_FAR * This,
            /* [in] */ DWORD dwUpdateOpt);
        
        HRESULT ( __stdcall __RPC_FAR *GetUpdateOptions )( 
            IOleLink __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwUpdateOpt);
        
        HRESULT ( __stdcall __RPC_FAR *SetSourceMoniker )( 
            IOleLink __RPC_FAR * This,
            /* [unique][in] */ IMoniker __RPC_FAR *pmk,
            /* [in] */ REFCLSID rclsid);
        
        HRESULT ( __stdcall __RPC_FAR *GetSourceMoniker )( 
            IOleLink __RPC_FAR * This,
            /* [out] */ IMoniker __RPC_FAR *__RPC_FAR *ppmk);
        
        HRESULT ( __stdcall __RPC_FAR *SetSourceDisplayName )( 
            IOleLink __RPC_FAR * This,
            /* [in] */ LPCOLESTR pszStatusText);
        
        HRESULT ( __stdcall __RPC_FAR *GetSourceDisplayName )( 
            IOleLink __RPC_FAR * This,
            /* [out] */ LPOLESTR __RPC_FAR *ppszDisplayName);
        
        HRESULT ( __stdcall __RPC_FAR *BindToSource )( 
            IOleLink __RPC_FAR * This,
            /* [in] */ DWORD bindflags,
            /* [unique][in] */ IBindCtx __RPC_FAR *pbc);
        
        HRESULT ( __stdcall __RPC_FAR *BindIfRunning )( 
            IOleLink __RPC_FAR * This);
        
        HRESULT ( __stdcall __RPC_FAR *GetBoundSource )( 
            IOleLink __RPC_FAR * This,
            /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunk);
        
        HRESULT ( __stdcall __RPC_FAR *UnbindSource )( 
            IOleLink __RPC_FAR * This);
        
        HRESULT ( __stdcall __RPC_FAR *Update )( 
            IOleLink __RPC_FAR * This,
            /* [unique][in] */ IBindCtx __RPC_FAR *pbc);
        
    } IOleLinkVtbl;

    interface IOleLink
    {
        CONST_VTBL struct IOleLinkVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IOleLink_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IOleLink_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IOleLink_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IOleLink_SetUpdateOptions(This,dwUpdateOpt)	\
    (This)->lpVtbl -> SetUpdateOptions(This,dwUpdateOpt)

#define IOleLink_GetUpdateOptions(This,pdwUpdateOpt)	\
    (This)->lpVtbl -> GetUpdateOptions(This,pdwUpdateOpt)

#define IOleLink_SetSourceMoniker(This,pmk,rclsid)	\
    (This)->lpVtbl -> SetSourceMoniker(This,pmk,rclsid)

#define IOleLink_GetSourceMoniker(This,ppmk)	\
    (This)->lpVtbl -> GetSourceMoniker(This,ppmk)

#define IOleLink_SetSourceDisplayName(This,pszStatusText)	\
    (This)->lpVtbl -> SetSourceDisplayName(This,pszStatusText)

#define IOleLink_GetSourceDisplayName(This,ppszDisplayName)	\
    (This)->lpVtbl -> GetSourceDisplayName(This,ppszDisplayName)

#define IOleLink_BindToSource(This,bindflags,pbc)	\
    (This)->lpVtbl -> BindToSource(This,bindflags,pbc)

#define IOleLink_BindIfRunning(This)	\
    (This)->lpVtbl -> BindIfRunning(This)

#define IOleLink_GetBoundSource(This,ppunk)	\
    (This)->lpVtbl -> GetBoundSource(This,ppunk)

#define IOleLink_UnbindSource(This)	\
    (This)->lpVtbl -> UnbindSource(This)

#define IOleLink_Update(This,pbc)	\
    (This)->lpVtbl -> Update(This,pbc)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT __stdcall IOleLink_SetUpdateOptions_Proxy( 
    IOleLink __RPC_FAR * This,
    /* [in] */ DWORD dwUpdateOpt);


void __RPC_STUB IOleLink_SetUpdateOptions_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IOleLink_GetUpdateOptions_Proxy( 
    IOleLink __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwUpdateOpt);


void __RPC_STUB IOleLink_GetUpdateOptions_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IOleLink_SetSourceMoniker_Proxy( 
    IOleLink __RPC_FAR * This,
    /* [unique][in] */ IMoniker __RPC_FAR *pmk,
    /* [in] */ REFCLSID rclsid);


void __RPC_STUB IOleLink_SetSourceMoniker_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IOleLink_GetSourceMoniker_Proxy( 
    IOleLink __RPC_FAR * This,
    /* [out] */ IMoniker __RPC_FAR *__RPC_FAR *ppmk);


void __RPC_STUB IOleLink_GetSourceMoniker_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IOleLink_SetSourceDisplayName_Proxy( 
    IOleLink __RPC_FAR * This,
    /* [in] */ LPCOLESTR pszStatusText);


void __RPC_STUB IOleLink_SetSourceDisplayName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IOleLink_GetSourceDisplayName_Proxy( 
    IOleLink __RPC_FAR * This,
    /* [out] */ LPOLESTR __RPC_FAR *ppszDisplayName);


void __RPC_STUB IOleLink_GetSourceDisplayName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IOleLink_BindToSource_Proxy( 
    IOleLink __RPC_FAR * This,
    /* [in] */ DWORD bindflags,
    /* [unique][in] */ IBindCtx __RPC_FAR *pbc);


void __RPC_STUB IOleLink_BindToSource_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IOleLink_BindIfRunning_Proxy( 
    IOleLink __RPC_FAR * This);


void __RPC_STUB IOleLink_BindIfRunning_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IOleLink_GetBoundSource_Proxy( 
    IOleLink __RPC_FAR * This,
    /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunk);


void __RPC_STUB IOleLink_GetBoundSource_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IOleLink_UnbindSource_Proxy( 
    IOleLink __RPC_FAR * This);


void __RPC_STUB IOleLink_UnbindSource_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IOleLink_Update_Proxy( 
    IOleLink __RPC_FAR * This,
    /* [unique][in] */ IBindCtx __RPC_FAR *pbc);


void __RPC_STUB IOleLink_Update_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IOleLink_INTERFACE_DEFINED__ */


#ifndef __IOleItemContainer_INTERFACE_DEFINED__
#define __IOleItemContainer_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IOleItemContainer
 * at Fri Apr 28 07:02:35 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [unique][uuid][object] */ 


			/* size is 4 */
typedef /* [unique] */ IOleItemContainer __RPC_FAR *LPOLEITEMCONTAINER;

			/* size is 2 */
typedef 
enum tagBINDSPEED
    {	BINDSPEED_INDEFINITE	= 1,
	BINDSPEED_MODERATE	= 2,
	BINDSPEED_IMMEDIATE	= 3
    }	BINDSPEED;

			/* size is 2 */
typedef /* [v1_enum] */ 
enum tagOLECONTF
    {	OLECONTF_EMBEDDINGS	= 1,
	OLECONTF_LINKS	= 2,
	OLECONTF_OTHERS	= 4,
	OLECONTF_ONLYUSER	= 8,
	OLECONTF_ONLYIFRUNNING	= 16
    }	OLECONTF;


EXTERN_C const IID IID_IOleItemContainer;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IOleItemContainer : public IOleContainer
    {
    public:
        virtual /* [local] */ HRESULT __stdcall GetObject( 
            /* [in] */ LPOLESTR pszItem,
            /* [in] */ DWORD dwSpeedNeeded,
            /* [unique][in] */ IBindCtx __RPC_FAR *pbc,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject) = 0;
        
        virtual /* [local] */ HRESULT __stdcall GetObjectStorage( 
            /* [in] */ LPOLESTR pszItem,
            /* [unique][in] */ IBindCtx __RPC_FAR *pbc,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvStorage) = 0;
        
        virtual HRESULT __stdcall IsRunning( 
            /* [in] */ LPOLESTR pszItem) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IOleItemContainerVtbl
    {
        
        HRESULT ( __stdcall __RPC_FAR *QueryInterface )( 
            IOleItemContainer __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( __stdcall __RPC_FAR *AddRef )( 
            IOleItemContainer __RPC_FAR * This);
        
        ULONG ( __stdcall __RPC_FAR *Release )( 
            IOleItemContainer __RPC_FAR * This);
        
        HRESULT ( __stdcall __RPC_FAR *ParseDisplayName )( 
            IOleItemContainer __RPC_FAR * This,
            /* [unique][in] */ IBindCtx __RPC_FAR *pbc,
            /* [in] */ LPOLESTR pszDisplayName,
            /* [out] */ ULONG __RPC_FAR *pchEaten,
            /* [out] */ IMoniker __RPC_FAR *__RPC_FAR *ppmkOut);
        
        HRESULT ( __stdcall __RPC_FAR *EnumObjects )( 
            IOleItemContainer __RPC_FAR * This,
            /* [in] */ DWORD grfFlags,
            /* [out] */ IEnumUnknown __RPC_FAR *__RPC_FAR *ppenum);
        
        HRESULT ( __stdcall __RPC_FAR *LockContainer )( 
            IOleItemContainer __RPC_FAR * This,
            /* [in] */ BOOL fLock);
        
        /* [local] */ HRESULT ( __stdcall __RPC_FAR *GetObject )( 
            IOleItemContainer __RPC_FAR * This,
            /* [in] */ LPOLESTR pszItem,
            /* [in] */ DWORD dwSpeedNeeded,
            /* [unique][in] */ IBindCtx __RPC_FAR *pbc,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        /* [local] */ HRESULT ( __stdcall __RPC_FAR *GetObjectStorage )( 
            IOleItemContainer __RPC_FAR * This,
            /* [in] */ LPOLESTR pszItem,
            /* [unique][in] */ IBindCtx __RPC_FAR *pbc,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvStorage);
        
        HRESULT ( __stdcall __RPC_FAR *IsRunning )( 
            IOleItemContainer __RPC_FAR * This,
            /* [in] */ LPOLESTR pszItem);
        
    } IOleItemContainerVtbl;

    interface IOleItemContainer
    {
        CONST_VTBL struct IOleItemContainerVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IOleItemContainer_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IOleItemContainer_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IOleItemContainer_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IOleItemContainer_ParseDisplayName(This,pbc,pszDisplayName,pchEaten,ppmkOut)	\
    (This)->lpVtbl -> ParseDisplayName(This,pbc,pszDisplayName,pchEaten,ppmkOut)


#define IOleItemContainer_EnumObjects(This,grfFlags,ppenum)	\
    (This)->lpVtbl -> EnumObjects(This,grfFlags,ppenum)

#define IOleItemContainer_LockContainer(This,fLock)	\
    (This)->lpVtbl -> LockContainer(This,fLock)


#define IOleItemContainer_GetObject(This,pszItem,dwSpeedNeeded,pbc,riid,ppvObject)	\
    (This)->lpVtbl -> GetObject(This,pszItem,dwSpeedNeeded,pbc,riid,ppvObject)

#define IOleItemContainer_GetObjectStorage(This,pszItem,pbc,riid,ppvStorage)	\
    (This)->lpVtbl -> GetObjectStorage(This,pszItem,pbc,riid,ppvStorage)

#define IOleItemContainer_IsRunning(This,pszItem)	\
    (This)->lpVtbl -> IsRunning(This,pszItem)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT __stdcall IOleItemContainer_RemoteGetObject_Proxy( 
    IOleItemContainer __RPC_FAR * This,
    /* [in] */ LPOLESTR pszItem,
    /* [in] */ DWORD dwSpeedNeeded,
    /* [unique][in] */ IBindCtx __RPC_FAR *pbc,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppvObject);


void __RPC_STUB IOleItemContainer_RemoteGetObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT __stdcall IOleItemContainer_RemoteGetObjectStorage_Proxy( 
    IOleItemContainer __RPC_FAR * This,
    /* [in] */ LPOLESTR pszItem,
    /* [unique][in] */ IBindCtx __RPC_FAR *pbc,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppvStorage);


void __RPC_STUB IOleItemContainer_RemoteGetObjectStorage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IOleItemContainer_IsRunning_Proxy( 
    IOleItemContainer __RPC_FAR * This,
    /* [in] */ LPOLESTR pszItem);


void __RPC_STUB IOleItemContainer_IsRunning_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IOleItemContainer_INTERFACE_DEFINED__ */


#ifndef __IOleInPlaceUIWindow_INTERFACE_DEFINED__
#define __IOleInPlaceUIWindow_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IOleInPlaceUIWindow
 * at Fri Apr 28 07:02:35 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [unique][uuid][object] */ 


			/* size is 4 */
typedef /* [unique] */ IOleInPlaceUIWindow __RPC_FAR *LPOLEINPLACEUIWINDOW;

			/* size is 16 */
typedef RECT BORDERWIDTHS;

			/* size is 4 */
typedef LPRECT LPBORDERWIDTHS;

			/* size is 4 */
typedef LPCRECT LPCBORDERWIDTHS;


EXTERN_C const IID IID_IOleInPlaceUIWindow;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IOleInPlaceUIWindow : public IOleWindow
    {
    public:
        virtual /* [input_sync] */ HRESULT __stdcall GetBorder( 
            /* [out] */ LPRECT lprectBorder) = 0;
        
        virtual /* [input_sync] */ HRESULT __stdcall RequestBorderSpace( 
            /* [unique][in] */ LPCBORDERWIDTHS pborderwidths) = 0;
        
        virtual /* [input_sync] */ HRESULT __stdcall SetBorderSpace( 
            /* [unique][in] */ LPCBORDERWIDTHS pborderwidths) = 0;
        
        virtual HRESULT __stdcall SetActiveObject( 
            /* [unique][in] */ IOleInPlaceActiveObject __RPC_FAR *pActiveObject,
            /* [unique][string][in] */ LPCOLESTR pszObjName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IOleInPlaceUIWindowVtbl
    {
        
        HRESULT ( __stdcall __RPC_FAR *QueryInterface )( 
            IOleInPlaceUIWindow __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( __stdcall __RPC_FAR *AddRef )( 
            IOleInPlaceUIWindow __RPC_FAR * This);
        
        ULONG ( __stdcall __RPC_FAR *Release )( 
            IOleInPlaceUIWindow __RPC_FAR * This);
        
        /* [input_sync] */ HRESULT ( __stdcall __RPC_FAR *GetWindow )( 
            IOleInPlaceUIWindow __RPC_FAR * This,
            /* [out] */ HWND __RPC_FAR *phwnd);
        
        HRESULT ( __stdcall __RPC_FAR *ContextSensitiveHelp )( 
            IOleInPlaceUIWindow __RPC_FAR * This,
            /* [in] */ BOOL fEnterMode);
        
        /* [input_sync] */ HRESULT ( __stdcall __RPC_FAR *GetBorder )( 
            IOleInPlaceUIWindow __RPC_FAR * This,
            /* [out] */ LPRECT lprectBorder);
        
        /* [input_sync] */ HRESULT ( __stdcall __RPC_FAR *RequestBorderSpace )( 
            IOleInPlaceUIWindow __RPC_FAR * This,
            /* [unique][in] */ LPCBORDERWIDTHS pborderwidths);
        
        /* [input_sync] */ HRESULT ( __stdcall __RPC_FAR *SetBorderSpace )( 
            IOleInPlaceUIWindow __RPC_FAR * This,
            /* [unique][in] */ LPCBORDERWIDTHS pborderwidths);
        
        HRESULT ( __stdcall __RPC_FAR *SetActiveObject )( 
            IOleInPlaceUIWindow __RPC_FAR * This,
            /* [unique][in] */ IOleInPlaceActiveObject __RPC_FAR *pActiveObject,
            /* [unique][string][in] */ LPCOLESTR pszObjName);
        
    } IOleInPlaceUIWindowVtbl;

    interface IOleInPlaceUIWindow
    {
        CONST_VTBL struct IOleInPlaceUIWindowVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IOleInPlaceUIWindow_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IOleInPlaceUIWindow_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IOleInPlaceUIWindow_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IOleInPlaceUIWindow_GetWindow(This,phwnd)	\
    (This)->lpVtbl -> GetWindow(This,phwnd)

#define IOleInPlaceUIWindow_ContextSensitiveHelp(This,fEnterMode)	\
    (This)->lpVtbl -> ContextSensitiveHelp(This,fEnterMode)


#define IOleInPlaceUIWindow_GetBorder(This,lprectBorder)	\
    (This)->lpVtbl -> GetBorder(This,lprectBorder)

#define IOleInPlaceUIWindow_RequestBorderSpace(This,pborderwidths)	\
    (This)->lpVtbl -> RequestBorderSpace(This,pborderwidths)

#define IOleInPlaceUIWindow_SetBorderSpace(This,pborderwidths)	\
    (This)->lpVtbl -> SetBorderSpace(This,pborderwidths)

#define IOleInPlaceUIWindow_SetActiveObject(This,pActiveObject,pszObjName)	\
    (This)->lpVtbl -> SetActiveObject(This,pActiveObject,pszObjName)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [input_sync] */ HRESULT __stdcall IOleInPlaceUIWindow_GetBorder_Proxy( 
    IOleInPlaceUIWindow __RPC_FAR * This,
    /* [out] */ LPRECT lprectBorder);


void __RPC_STUB IOleInPlaceUIWindow_GetBorder_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [input_sync] */ HRESULT __stdcall IOleInPlaceUIWindow_RequestBorderSpace_Proxy( 
    IOleInPlaceUIWindow __RPC_FAR * This,
    /* [unique][in] */ LPCBORDERWIDTHS pborderwidths);


void __RPC_STUB IOleInPlaceUIWindow_RequestBorderSpace_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [input_sync] */ HRESULT __stdcall IOleInPlaceUIWindow_SetBorderSpace_Proxy( 
    IOleInPlaceUIWindow __RPC_FAR * This,
    /* [unique][in] */ LPCBORDERWIDTHS pborderwidths);


void __RPC_STUB IOleInPlaceUIWindow_SetBorderSpace_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IOleInPlaceUIWindow_SetActiveObject_Proxy( 
    IOleInPlaceUIWindow __RPC_FAR * This,
    /* [unique][in] */ IOleInPlaceActiveObject __RPC_FAR *pActiveObject,
    /* [unique][string][in] */ LPCOLESTR pszObjName);


void __RPC_STUB IOleInPlaceUIWindow_SetActiveObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IOleInPlaceUIWindow_INTERFACE_DEFINED__ */


#ifndef __IOleInPlaceActiveObject_INTERFACE_DEFINED__
#define __IOleInPlaceActiveObject_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IOleInPlaceActiveObject
 * at Fri Apr 28 07:02:35 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [uuid][object] */ 


			/* size is 4 */
typedef /* [unique] */ IOleInPlaceActiveObject __RPC_FAR *LPOLEINPLACEACTIVEOBJECT;


EXTERN_C const IID IID_IOleInPlaceActiveObject;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IOleInPlaceActiveObject : public IOleWindow
    {
    public:
        virtual /* [local] */ HRESULT __stdcall TranslateAccelerator( 
            /* [in] */ LPMSG lpmsg) = 0;
        
        virtual /* [input_sync] */ HRESULT __stdcall OnFrameWindowActivate( 
            /* [in] */ BOOL fActivate) = 0;
        
        virtual /* [input_sync] */ HRESULT __stdcall OnDocWindowActivate( 
            /* [in] */ BOOL fActivate) = 0;
        
        virtual /* [local] */ HRESULT __stdcall ResizeBorder( 
            /* [in] */ LPCRECT prcBorder,
            /* [unique][in] */ IOleInPlaceUIWindow __RPC_FAR *pUIWindow,
            /* [in] */ BOOL fFrameWindow) = 0;
        
        virtual HRESULT __stdcall EnableModeless( 
            /* [in] */ BOOL fEnable) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IOleInPlaceActiveObjectVtbl
    {
        
        HRESULT ( __stdcall __RPC_FAR *QueryInterface )( 
            IOleInPlaceActiveObject __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( __stdcall __RPC_FAR *AddRef )( 
            IOleInPlaceActiveObject __RPC_FAR * This);
        
        ULONG ( __stdcall __RPC_FAR *Release )( 
            IOleInPlaceActiveObject __RPC_FAR * This);
        
        /* [input_sync] */ HRESULT ( __stdcall __RPC_FAR *GetWindow )( 
            IOleInPlaceActiveObject __RPC_FAR * This,
            /* [out] */ HWND __RPC_FAR *phwnd);
        
        HRESULT ( __stdcall __RPC_FAR *ContextSensitiveHelp )( 
            IOleInPlaceActiveObject __RPC_FAR * This,
            /* [in] */ BOOL fEnterMode);
        
        /* [local] */ HRESULT ( __stdcall __RPC_FAR *TranslateAccelerator )( 
            IOleInPlaceActiveObject __RPC_FAR * This,
            /* [in] */ LPMSG lpmsg);
        
        /* [input_sync] */ HRESULT ( __stdcall __RPC_FAR *OnFrameWindowActivate )( 
            IOleInPlaceActiveObject __RPC_FAR * This,
            /* [in] */ BOOL fActivate);
        
        /* [input_sync] */ HRESULT ( __stdcall __RPC_FAR *OnDocWindowActivate )( 
            IOleInPlaceActiveObject __RPC_FAR * This,
            /* [in] */ BOOL fActivate);
        
        /* [local] */ HRESULT ( __stdcall __RPC_FAR *ResizeBorder )( 
            IOleInPlaceActiveObject __RPC_FAR * This,
            /* [in] */ LPCRECT prcBorder,
            /* [unique][in] */ IOleInPlaceUIWindow __RPC_FAR *pUIWindow,
            /* [in] */ BOOL fFrameWindow);
        
        HRESULT ( __stdcall __RPC_FAR *EnableModeless )( 
            IOleInPlaceActiveObject __RPC_FAR * This,
            /* [in] */ BOOL fEnable);
        
    } IOleInPlaceActiveObjectVtbl;

    interface IOleInPlaceActiveObject
    {
        CONST_VTBL struct IOleInPlaceActiveObjectVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IOleInPlaceActiveObject_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IOleInPlaceActiveObject_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IOleInPlaceActiveObject_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IOleInPlaceActiveObject_GetWindow(This,phwnd)	\
    (This)->lpVtbl -> GetWindow(This,phwnd)

#define IOleInPlaceActiveObject_ContextSensitiveHelp(This,fEnterMode)	\
    (This)->lpVtbl -> ContextSensitiveHelp(This,fEnterMode)


#define IOleInPlaceActiveObject_TranslateAccelerator(This,lpmsg)	\
    (This)->lpVtbl -> TranslateAccelerator(This,lpmsg)

#define IOleInPlaceActiveObject_OnFrameWindowActivate(This,fActivate)	\
    (This)->lpVtbl -> OnFrameWindowActivate(This,fActivate)

#define IOleInPlaceActiveObject_OnDocWindowActivate(This,fActivate)	\
    (This)->lpVtbl -> OnDocWindowActivate(This,fActivate)

#define IOleInPlaceActiveObject_ResizeBorder(This,prcBorder,pUIWindow,fFrameWindow)	\
    (This)->lpVtbl -> ResizeBorder(This,prcBorder,pUIWindow,fFrameWindow)

#define IOleInPlaceActiveObject_EnableModeless(This,fEnable)	\
    (This)->lpVtbl -> EnableModeless(This,fEnable)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT __stdcall IOleInPlaceActiveObject_RemoteTranslateAccelerator_Proxy( 
    IOleInPlaceActiveObject __RPC_FAR * This);


void __RPC_STUB IOleInPlaceActiveObject_RemoteTranslateAccelerator_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [input_sync] */ HRESULT __stdcall IOleInPlaceActiveObject_OnFrameWindowActivate_Proxy( 
    IOleInPlaceActiveObject __RPC_FAR * This,
    /* [in] */ BOOL fActivate);


void __RPC_STUB IOleInPlaceActiveObject_OnFrameWindowActivate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [input_sync] */ HRESULT __stdcall IOleInPlaceActiveObject_OnDocWindowActivate_Proxy( 
    IOleInPlaceActiveObject __RPC_FAR * This,
    /* [in] */ BOOL fActivate);


void __RPC_STUB IOleInPlaceActiveObject_OnDocWindowActivate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [input_sync][call_as] */ HRESULT __stdcall IOleInPlaceActiveObject_RemoteResizeBorder_Proxy( 
    IOleInPlaceActiveObject __RPC_FAR * This,
    /* [in] */ LPCRECT prcBorder,
    /* [in] */ REFIID riid,
    /* [iid_is][unique][in] */ IOleInPlaceUIWindow __RPC_FAR *pUIWindow,
    /* [in] */ BOOL fFrameWindow);


void __RPC_STUB IOleInPlaceActiveObject_RemoteResizeBorder_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IOleInPlaceActiveObject_EnableModeless_Proxy( 
    IOleInPlaceActiveObject __RPC_FAR * This,
    /* [in] */ BOOL fEnable);


void __RPC_STUB IOleInPlaceActiveObject_EnableModeless_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IOleInPlaceActiveObject_INTERFACE_DEFINED__ */


#ifndef __IOleInPlaceFrame_INTERFACE_DEFINED__
#define __IOleInPlaceFrame_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IOleInPlaceFrame
 * at Fri Apr 28 07:02:35 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [unique][uuid][object] */ 


			/* size is 4 */
typedef /* [unique] */ IOleInPlaceFrame __RPC_FAR *LPOLEINPLACEFRAME;

			/* size is 20 */
typedef struct  tagOIFI
    {
    UINT cb;
    BOOL fMDIApp;
    HWND hwndFrame;
    HACCEL haccel;
    UINT cAccelEntries;
    }	OLEINPLACEFRAMEINFO;

			/* size is 4 */
typedef struct tagOIFI __RPC_FAR *LPOLEINPLACEFRAMEINFO;

			/* size is 24 */
typedef struct  tagOleMenuGroupWidths
    {
    LONG width[ 6 ];
    }	OLEMENUGROUPWIDTHS;

			/* size is 4 */
typedef struct tagOleMenuGroupWidths __RPC_FAR *LPOLEMENUGROUPWIDTHS;

			/* size is 4 */
typedef HGLOBAL HOLEMENU;


EXTERN_C const IID IID_IOleInPlaceFrame;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IOleInPlaceFrame : public IOleInPlaceUIWindow
    {
    public:
        virtual HRESULT __stdcall InsertMenus( 
            /* [in] */ HMENU hmenuShared,
            /* [out][in] */ LPOLEMENUGROUPWIDTHS lpMenuWidths) = 0;
        
        virtual /* [input_sync] */ HRESULT __stdcall SetMenu( 
            /* [in] */ HMENU hmenuShared,
            /* [in] */ HOLEMENU holemenu,
            /* [in] */ HWND hwndActiveObject) = 0;
        
        virtual HRESULT __stdcall RemoveMenus( 
            /* [in] */ HMENU hmenuShared) = 0;
        
        virtual /* [input_sync] */ HRESULT __stdcall SetStatusText( 
            /* [in] */ LPCOLESTR pszStatusText) = 0;
        
        virtual HRESULT __stdcall EnableModeless( 
            /* [in] */ BOOL fEnable) = 0;
        
        virtual HRESULT __stdcall TranslateAccelerator( 
            /* [in] */ LPMSG lpmsg,
            /* [in] */ WORD wID) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IOleInPlaceFrameVtbl
    {
        
        HRESULT ( __stdcall __RPC_FAR *QueryInterface )( 
            IOleInPlaceFrame __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( __stdcall __RPC_FAR *AddRef )( 
            IOleInPlaceFrame __RPC_FAR * This);
        
        ULONG ( __stdcall __RPC_FAR *Release )( 
            IOleInPlaceFrame __RPC_FAR * This);
        
        /* [input_sync] */ HRESULT ( __stdcall __RPC_FAR *GetWindow )( 
            IOleInPlaceFrame __RPC_FAR * This,
            /* [out] */ HWND __RPC_FAR *phwnd);
        
        HRESULT ( __stdcall __RPC_FAR *ContextSensitiveHelp )( 
            IOleInPlaceFrame __RPC_FAR * This,
            /* [in] */ BOOL fEnterMode);
        
        /* [input_sync] */ HRESULT ( __stdcall __RPC_FAR *GetBorder )( 
            IOleInPlaceFrame __RPC_FAR * This,
            /* [out] */ LPRECT lprectBorder);
        
        /* [input_sync] */ HRESULT ( __stdcall __RPC_FAR *RequestBorderSpace )( 
            IOleInPlaceFrame __RPC_FAR * This,
            /* [unique][in] */ LPCBORDERWIDTHS pborderwidths);
        
        /* [input_sync] */ HRESULT ( __stdcall __RPC_FAR *SetBorderSpace )( 
            IOleInPlaceFrame __RPC_FAR * This,
            /* [unique][in] */ LPCBORDERWIDTHS pborderwidths);
        
        HRESULT ( __stdcall __RPC_FAR *SetActiveObject )( 
            IOleInPlaceFrame __RPC_FAR * This,
            /* [unique][in] */ IOleInPlaceActiveObject __RPC_FAR *pActiveObject,
            /* [unique][string][in] */ LPCOLESTR pszObjName);
        
        HRESULT ( __stdcall __RPC_FAR *InsertMenus )( 
            IOleInPlaceFrame __RPC_FAR * This,
            /* [in] */ HMENU hmenuShared,
            /* [out][in] */ LPOLEMENUGROUPWIDTHS lpMenuWidths);
        
        /* [input_sync] */ HRESULT ( __stdcall __RPC_FAR *SetMenu )( 
            IOleInPlaceFrame __RPC_FAR * This,
            /* [in] */ HMENU hmenuShared,
            /* [in] */ HOLEMENU holemenu,
            /* [in] */ HWND hwndActiveObject);
        
        HRESULT ( __stdcall __RPC_FAR *RemoveMenus )( 
            IOleInPlaceFrame __RPC_FAR * This,
            /* [in] */ HMENU hmenuShared);
        
        /* [input_sync] */ HRESULT ( __stdcall __RPC_FAR *SetStatusText )( 
            IOleInPlaceFrame __RPC_FAR * This,
            /* [in] */ LPCOLESTR pszStatusText);
        
        HRESULT ( __stdcall __RPC_FAR *EnableModeless )( 
            IOleInPlaceFrame __RPC_FAR * This,
            /* [in] */ BOOL fEnable);
        
        HRESULT ( __stdcall __RPC_FAR *TranslateAccelerator )( 
            IOleInPlaceFrame __RPC_FAR * This,
            /* [in] */ LPMSG lpmsg,
            /* [in] */ WORD wID);
        
    } IOleInPlaceFrameVtbl;

    interface IOleInPlaceFrame
    {
        CONST_VTBL struct IOleInPlaceFrameVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IOleInPlaceFrame_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IOleInPlaceFrame_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IOleInPlaceFrame_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IOleInPlaceFrame_GetWindow(This,phwnd)	\
    (This)->lpVtbl -> GetWindow(This,phwnd)

#define IOleInPlaceFrame_ContextSensitiveHelp(This,fEnterMode)	\
    (This)->lpVtbl -> ContextSensitiveHelp(This,fEnterMode)


#define IOleInPlaceFrame_GetBorder(This,lprectBorder)	\
    (This)->lpVtbl -> GetBorder(This,lprectBorder)

#define IOleInPlaceFrame_RequestBorderSpace(This,pborderwidths)	\
    (This)->lpVtbl -> RequestBorderSpace(This,pborderwidths)

#define IOleInPlaceFrame_SetBorderSpace(This,pborderwidths)	\
    (This)->lpVtbl -> SetBorderSpace(This,pborderwidths)

#define IOleInPlaceFrame_SetActiveObject(This,pActiveObject,pszObjName)	\
    (This)->lpVtbl -> SetActiveObject(This,pActiveObject,pszObjName)


#define IOleInPlaceFrame_InsertMenus(This,hmenuShared,lpMenuWidths)	\
    (This)->lpVtbl -> InsertMenus(This,hmenuShared,lpMenuWidths)

#define IOleInPlaceFrame_SetMenu(This,hmenuShared,holemenu,hwndActiveObject)	\
    (This)->lpVtbl -> SetMenu(This,hmenuShared,holemenu,hwndActiveObject)

#define IOleInPlaceFrame_RemoveMenus(This,hmenuShared)	\
    (This)->lpVtbl -> RemoveMenus(This,hmenuShared)

#define IOleInPlaceFrame_SetStatusText(This,pszStatusText)	\
    (This)->lpVtbl -> SetStatusText(This,pszStatusText)

#define IOleInPlaceFrame_EnableModeless(This,fEnable)	\
    (This)->lpVtbl -> EnableModeless(This,fEnable)

#define IOleInPlaceFrame_TranslateAccelerator(This,lpmsg,wID)	\
    (This)->lpVtbl -> TranslateAccelerator(This,lpmsg,wID)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT __stdcall IOleInPlaceFrame_InsertMenus_Proxy( 
    IOleInPlaceFrame __RPC_FAR * This,
    /* [in] */ HMENU hmenuShared,
    /* [out][in] */ LPOLEMENUGROUPWIDTHS lpMenuWidths);


void __RPC_STUB IOleInPlaceFrame_InsertMenus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [input_sync] */ HRESULT __stdcall IOleInPlaceFrame_SetMenu_Proxy( 
    IOleInPlaceFrame __RPC_FAR * This,
    /* [in] */ HMENU hmenuShared,
    /* [in] */ HOLEMENU holemenu,
    /* [in] */ HWND hwndActiveObject);


void __RPC_STUB IOleInPlaceFrame_SetMenu_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IOleInPlaceFrame_RemoveMenus_Proxy( 
    IOleInPlaceFrame __RPC_FAR * This,
    /* [in] */ HMENU hmenuShared);


void __RPC_STUB IOleInPlaceFrame_RemoveMenus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [input_sync] */ HRESULT __stdcall IOleInPlaceFrame_SetStatusText_Proxy( 
    IOleInPlaceFrame __RPC_FAR * This,
    /* [in] */ LPCOLESTR pszStatusText);


void __RPC_STUB IOleInPlaceFrame_SetStatusText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IOleInPlaceFrame_EnableModeless_Proxy( 
    IOleInPlaceFrame __RPC_FAR * This,
    /* [in] */ BOOL fEnable);


void __RPC_STUB IOleInPlaceFrame_EnableModeless_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IOleInPlaceFrame_TranslateAccelerator_Proxy( 
    IOleInPlaceFrame __RPC_FAR * This,
    /* [in] */ LPMSG lpmsg,
    /* [in] */ WORD wID);


void __RPC_STUB IOleInPlaceFrame_TranslateAccelerator_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IOleInPlaceFrame_INTERFACE_DEFINED__ */


#ifndef __IOleInPlaceObject_INTERFACE_DEFINED__
#define __IOleInPlaceObject_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IOleInPlaceObject
 * at Fri Apr 28 07:02:35 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [unique][uuid][object] */ 


			/* size is 4 */
typedef /* [unique] */ IOleInPlaceObject __RPC_FAR *LPOLEINPLACEOBJECT;


EXTERN_C const IID IID_IOleInPlaceObject;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IOleInPlaceObject : public IOleWindow
    {
    public:
        virtual HRESULT __stdcall InPlaceDeactivate( void) = 0;
        
        virtual HRESULT __stdcall UIDeactivate( void) = 0;
        
        virtual /* [input_sync] */ HRESULT __stdcall SetObjectRects( 
            /* [in] */ LPCRECT lprcPosRect,
            /* [in] */ LPCRECT lprcClipRect) = 0;
        
        virtual HRESULT __stdcall ReactivateAndUndo( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IOleInPlaceObjectVtbl
    {
        
        HRESULT ( __stdcall __RPC_FAR *QueryInterface )( 
            IOleInPlaceObject __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( __stdcall __RPC_FAR *AddRef )( 
            IOleInPlaceObject __RPC_FAR * This);
        
        ULONG ( __stdcall __RPC_FAR *Release )( 
            IOleInPlaceObject __RPC_FAR * This);
        
        /* [input_sync] */ HRESULT ( __stdcall __RPC_FAR *GetWindow )( 
            IOleInPlaceObject __RPC_FAR * This,
            /* [out] */ HWND __RPC_FAR *phwnd);
        
        HRESULT ( __stdcall __RPC_FAR *ContextSensitiveHelp )( 
            IOleInPlaceObject __RPC_FAR * This,
            /* [in] */ BOOL fEnterMode);
        
        HRESULT ( __stdcall __RPC_FAR *InPlaceDeactivate )( 
            IOleInPlaceObject __RPC_FAR * This);
        
        HRESULT ( __stdcall __RPC_FAR *UIDeactivate )( 
            IOleInPlaceObject __RPC_FAR * This);
        
        /* [input_sync] */ HRESULT ( __stdcall __RPC_FAR *SetObjectRects )( 
            IOleInPlaceObject __RPC_FAR * This,
            /* [in] */ LPCRECT lprcPosRect,
            /* [in] */ LPCRECT lprcClipRect);
        
        HRESULT ( __stdcall __RPC_FAR *ReactivateAndUndo )( 
            IOleInPlaceObject __RPC_FAR * This);
        
    } IOleInPlaceObjectVtbl;

    interface IOleInPlaceObject
    {
        CONST_VTBL struct IOleInPlaceObjectVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IOleInPlaceObject_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IOleInPlaceObject_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IOleInPlaceObject_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IOleInPlaceObject_GetWindow(This,phwnd)	\
    (This)->lpVtbl -> GetWindow(This,phwnd)

#define IOleInPlaceObject_ContextSensitiveHelp(This,fEnterMode)	\
    (This)->lpVtbl -> ContextSensitiveHelp(This,fEnterMode)


#define IOleInPlaceObject_InPlaceDeactivate(This)	\
    (This)->lpVtbl -> InPlaceDeactivate(This)

#define IOleInPlaceObject_UIDeactivate(This)	\
    (This)->lpVtbl -> UIDeactivate(This)

#define IOleInPlaceObject_SetObjectRects(This,lprcPosRect,lprcClipRect)	\
    (This)->lpVtbl -> SetObjectRects(This,lprcPosRect,lprcClipRect)

#define IOleInPlaceObject_ReactivateAndUndo(This)	\
    (This)->lpVtbl -> ReactivateAndUndo(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT __stdcall IOleInPlaceObject_InPlaceDeactivate_Proxy( 
    IOleInPlaceObject __RPC_FAR * This);


void __RPC_STUB IOleInPlaceObject_InPlaceDeactivate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IOleInPlaceObject_UIDeactivate_Proxy( 
    IOleInPlaceObject __RPC_FAR * This);


void __RPC_STUB IOleInPlaceObject_UIDeactivate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [input_sync] */ HRESULT __stdcall IOleInPlaceObject_SetObjectRects_Proxy( 
    IOleInPlaceObject __RPC_FAR * This,
    /* [in] */ LPCRECT lprcPosRect,
    /* [in] */ LPCRECT lprcClipRect);


void __RPC_STUB IOleInPlaceObject_SetObjectRects_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IOleInPlaceObject_ReactivateAndUndo_Proxy( 
    IOleInPlaceObject __RPC_FAR * This);


void __RPC_STUB IOleInPlaceObject_ReactivateAndUndo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IOleInPlaceObject_INTERFACE_DEFINED__ */


#ifndef __IOleInPlaceSite_INTERFACE_DEFINED__
#define __IOleInPlaceSite_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IOleInPlaceSite
 * at Fri Apr 28 07:02:35 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [unique][uuid][object] */ 


			/* size is 4 */
typedef /* [unique] */ IOleInPlaceSite __RPC_FAR *LPOLEINPLACESITE;


EXTERN_C const IID IID_IOleInPlaceSite;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IOleInPlaceSite : public IOleWindow
    {
    public:
        virtual HRESULT __stdcall CanInPlaceActivate( void) = 0;
        
        virtual HRESULT __stdcall OnInPlaceActivate( void) = 0;
        
        virtual HRESULT __stdcall OnUIActivate( void) = 0;
        
        virtual HRESULT __stdcall GetWindowContext( 
            /* [out] */ IOleInPlaceFrame __RPC_FAR *__RPC_FAR *ppFrame,
            /* [out] */ IOleInPlaceUIWindow __RPC_FAR *__RPC_FAR *ppDoc,
            /* [out] */ LPRECT lprcPosRect,
            /* [out] */ LPRECT lprcClipRect,
            /* [out][in] */ LPOLEINPLACEFRAMEINFO lpFrameInfo) = 0;
        
        virtual HRESULT __stdcall Scroll( 
            /* [in] */ SIZE scrollExtant) = 0;
        
        virtual HRESULT __stdcall OnUIDeactivate( 
            /* [in] */ BOOL fUndoable) = 0;
        
        virtual HRESULT __stdcall OnInPlaceDeactivate( void) = 0;
        
        virtual HRESULT __stdcall DiscardUndoState( void) = 0;
        
        virtual HRESULT __stdcall DeactivateAndUndo( void) = 0;
        
        virtual HRESULT __stdcall OnPosRectChange( 
            /* [in] */ LPCRECT lprcPosRect) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IOleInPlaceSiteVtbl
    {
        
        HRESULT ( __stdcall __RPC_FAR *QueryInterface )( 
            IOleInPlaceSite __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( __stdcall __RPC_FAR *AddRef )( 
            IOleInPlaceSite __RPC_FAR * This);
        
        ULONG ( __stdcall __RPC_FAR *Release )( 
            IOleInPlaceSite __RPC_FAR * This);
        
        /* [input_sync] */ HRESULT ( __stdcall __RPC_FAR *GetWindow )( 
            IOleInPlaceSite __RPC_FAR * This,
            /* [out] */ HWND __RPC_FAR *phwnd);
        
        HRESULT ( __stdcall __RPC_FAR *ContextSensitiveHelp )( 
            IOleInPlaceSite __RPC_FAR * This,
            /* [in] */ BOOL fEnterMode);
        
        HRESULT ( __stdcall __RPC_FAR *CanInPlaceActivate )( 
            IOleInPlaceSite __RPC_FAR * This);
        
        HRESULT ( __stdcall __RPC_FAR *OnInPlaceActivate )( 
            IOleInPlaceSite __RPC_FAR * This);
        
        HRESULT ( __stdcall __RPC_FAR *OnUIActivate )( 
            IOleInPlaceSite __RPC_FAR * This);
        
        HRESULT ( __stdcall __RPC_FAR *GetWindowContext )( 
            IOleInPlaceSite __RPC_FAR * This,
            /* [out] */ IOleInPlaceFrame __RPC_FAR *__RPC_FAR *ppFrame,
            /* [out] */ IOleInPlaceUIWindow __RPC_FAR *__RPC_FAR *ppDoc,
            /* [out] */ LPRECT lprcPosRect,
            /* [out] */ LPRECT lprcClipRect,
            /* [out][in] */ LPOLEINPLACEFRAMEINFO lpFrameInfo);
        
        HRESULT ( __stdcall __RPC_FAR *Scroll )( 
            IOleInPlaceSite __RPC_FAR * This,
            /* [in] */ SIZE scrollExtant);
        
        HRESULT ( __stdcall __RPC_FAR *OnUIDeactivate )( 
            IOleInPlaceSite __RPC_FAR * This,
            /* [in] */ BOOL fUndoable);
        
        HRESULT ( __stdcall __RPC_FAR *OnInPlaceDeactivate )( 
            IOleInPlaceSite __RPC_FAR * This);
        
        HRESULT ( __stdcall __RPC_FAR *DiscardUndoState )( 
            IOleInPlaceSite __RPC_FAR * This);
        
        HRESULT ( __stdcall __RPC_FAR *DeactivateAndUndo )( 
            IOleInPlaceSite __RPC_FAR * This);
        
        HRESULT ( __stdcall __RPC_FAR *OnPosRectChange )( 
            IOleInPlaceSite __RPC_FAR * This,
            /* [in] */ LPCRECT lprcPosRect);
        
    } IOleInPlaceSiteVtbl;

    interface IOleInPlaceSite
    {
        CONST_VTBL struct IOleInPlaceSiteVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IOleInPlaceSite_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IOleInPlaceSite_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IOleInPlaceSite_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IOleInPlaceSite_GetWindow(This,phwnd)	\
    (This)->lpVtbl -> GetWindow(This,phwnd)

#define IOleInPlaceSite_ContextSensitiveHelp(This,fEnterMode)	\
    (This)->lpVtbl -> ContextSensitiveHelp(This,fEnterMode)


#define IOleInPlaceSite_CanInPlaceActivate(This)	\
    (This)->lpVtbl -> CanInPlaceActivate(This)

#define IOleInPlaceSite_OnInPlaceActivate(This)	\
    (This)->lpVtbl -> OnInPlaceActivate(This)

#define IOleInPlaceSite_OnUIActivate(This)	\
    (This)->lpVtbl -> OnUIActivate(This)

#define IOleInPlaceSite_GetWindowContext(This,ppFrame,ppDoc,lprcPosRect,lprcClipRect,lpFrameInfo)	\
    (This)->lpVtbl -> GetWindowContext(This,ppFrame,ppDoc,lprcPosRect,lprcClipRect,lpFrameInfo)

#define IOleInPlaceSite_Scroll(This,scrollExtant)	\
    (This)->lpVtbl -> Scroll(This,scrollExtant)

#define IOleInPlaceSite_OnUIDeactivate(This,fUndoable)	\
    (This)->lpVtbl -> OnUIDeactivate(This,fUndoable)

#define IOleInPlaceSite_OnInPlaceDeactivate(This)	\
    (This)->lpVtbl -> OnInPlaceDeactivate(This)

#define IOleInPlaceSite_DiscardUndoState(This)	\
    (This)->lpVtbl -> DiscardUndoState(This)

#define IOleInPlaceSite_DeactivateAndUndo(This)	\
    (This)->lpVtbl -> DeactivateAndUndo(This)

#define IOleInPlaceSite_OnPosRectChange(This,lprcPosRect)	\
    (This)->lpVtbl -> OnPosRectChange(This,lprcPosRect)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT __stdcall IOleInPlaceSite_CanInPlaceActivate_Proxy( 
    IOleInPlaceSite __RPC_FAR * This);


void __RPC_STUB IOleInPlaceSite_CanInPlaceActivate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IOleInPlaceSite_OnInPlaceActivate_Proxy( 
    IOleInPlaceSite __RPC_FAR * This);


void __RPC_STUB IOleInPlaceSite_OnInPlaceActivate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IOleInPlaceSite_OnUIActivate_Proxy( 
    IOleInPlaceSite __RPC_FAR * This);


void __RPC_STUB IOleInPlaceSite_OnUIActivate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IOleInPlaceSite_GetWindowContext_Proxy( 
    IOleInPlaceSite __RPC_FAR * This,
    /* [out] */ IOleInPlaceFrame __RPC_FAR *__RPC_FAR *ppFrame,
    /* [out] */ IOleInPlaceUIWindow __RPC_FAR *__RPC_FAR *ppDoc,
    /* [out] */ LPRECT lprcPosRect,
    /* [out] */ LPRECT lprcClipRect,
    /* [out][in] */ LPOLEINPLACEFRAMEINFO lpFrameInfo);


void __RPC_STUB IOleInPlaceSite_GetWindowContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IOleInPlaceSite_Scroll_Proxy( 
    IOleInPlaceSite __RPC_FAR * This,
    /* [in] */ SIZE scrollExtant);


void __RPC_STUB IOleInPlaceSite_Scroll_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IOleInPlaceSite_OnUIDeactivate_Proxy( 
    IOleInPlaceSite __RPC_FAR * This,
    /* [in] */ BOOL fUndoable);


void __RPC_STUB IOleInPlaceSite_OnUIDeactivate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IOleInPlaceSite_OnInPlaceDeactivate_Proxy( 
    IOleInPlaceSite __RPC_FAR * This);


void __RPC_STUB IOleInPlaceSite_OnInPlaceDeactivate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IOleInPlaceSite_DiscardUndoState_Proxy( 
    IOleInPlaceSite __RPC_FAR * This);


void __RPC_STUB IOleInPlaceSite_DiscardUndoState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IOleInPlaceSite_DeactivateAndUndo_Proxy( 
    IOleInPlaceSite __RPC_FAR * This);


void __RPC_STUB IOleInPlaceSite_DeactivateAndUndo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IOleInPlaceSite_OnPosRectChange_Proxy( 
    IOleInPlaceSite __RPC_FAR * This,
    /* [in] */ LPCRECT lprcPosRect);


void __RPC_STUB IOleInPlaceSite_OnPosRectChange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IOleInPlaceSite_INTERFACE_DEFINED__ */


#ifndef __IViewObject_INTERFACE_DEFINED__
#define __IViewObject_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IViewObject
 * at Fri Apr 28 07:02:35 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [uuid][object][local] */ 


			/* size is 4 */
typedef /* [unique] */ IViewObject __RPC_FAR *LPVIEWOBJECT;


EXTERN_C const IID IID_IViewObject;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IViewObject : public IUnknown
    {
    public:
        virtual HRESULT __stdcall Draw( 
            /* [in] */ DWORD dwDrawAspect,
            /* [in] */ LONG lindex,
            /* [unique][in] */ void __RPC_FAR *pvAspect,
            /* [unique][in] */ DVTARGETDEVICE __RPC_FAR *ptd,
            /* [in] */ HDC hdcTargetDev,
            /* [in] */ HDC hdcDraw,
            /* [in] */ LPCRECTL lprcBounds,
            /* [in] */ LPCRECTL lprcWBounds,
            /* [in] */ BOOL ( __stdcall __stdcall __RPC_FAR *pfnContinue )( 
                DWORD dwContinue),
            /* [in] */ DWORD dwContinue) = 0;
        
        virtual HRESULT __stdcall GetColorSet( 
            /* [in] */ DWORD dwDrawAspect,
            /* [in] */ LONG lindex,
            /* [unique][in] */ void __RPC_FAR *pvAspect,
            /* [in] */ DVTARGETDEVICE __RPC_FAR *ptd,
            /* [in] */ HDC hicTargetDev,
            /* [out] */ LOGPALETTE __RPC_FAR *__RPC_FAR *ppColorSet) = 0;
        
        virtual HRESULT __stdcall Freeze( 
            /* [in] */ DWORD dwDrawAspect,
            /* [in] */ LONG lindex,
            /* [unique][in] */ void __RPC_FAR *pvAspect,
            /* [out] */ DWORD __RPC_FAR *pdwFreeze) = 0;
        
        virtual HRESULT __stdcall Unfreeze( 
            /* [in] */ DWORD dwFreeze) = 0;
        
        virtual HRESULT __stdcall SetAdvise( 
            /* [in] */ DWORD aspects,
            /* [in] */ DWORD advf,
            /* [unique][in] */ IAdviseSink __RPC_FAR *pAdvSink) = 0;
        
        virtual HRESULT __stdcall GetAdvise( 
            /* [out] */ DWORD __RPC_FAR *pAspects,
            /* [out] */ DWORD __RPC_FAR *pAdvf,
            /* [out] */ IAdviseSink __RPC_FAR *__RPC_FAR *ppAdvSink) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IViewObjectVtbl
    {
        
        HRESULT ( __stdcall __RPC_FAR *QueryInterface )( 
            IViewObject __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( __stdcall __RPC_FAR *AddRef )( 
            IViewObject __RPC_FAR * This);
        
        ULONG ( __stdcall __RPC_FAR *Release )( 
            IViewObject __RPC_FAR * This);
        
        HRESULT ( __stdcall __RPC_FAR *Draw )( 
            IViewObject __RPC_FAR * This,
            /* [in] */ DWORD dwDrawAspect,
            /* [in] */ LONG lindex,
            /* [unique][in] */ void __RPC_FAR *pvAspect,
            /* [unique][in] */ DVTARGETDEVICE __RPC_FAR *ptd,
            /* [in] */ HDC hdcTargetDev,
            /* [in] */ HDC hdcDraw,
            /* [in] */ LPCRECTL lprcBounds,
            /* [in] */ LPCRECTL lprcWBounds,
            /* [in] */ BOOL ( __stdcall __stdcall __RPC_FAR *pfnContinue )( 
                DWORD dwContinue),
            /* [in] */ DWORD dwContinue);
        
        HRESULT ( __stdcall __RPC_FAR *GetColorSet )( 
            IViewObject __RPC_FAR * This,
            /* [in] */ DWORD dwDrawAspect,
            /* [in] */ LONG lindex,
            /* [unique][in] */ void __RPC_FAR *pvAspect,
            /* [in] */ DVTARGETDEVICE __RPC_FAR *ptd,
            /* [in] */ HDC hicTargetDev,
            /* [out] */ LOGPALETTE __RPC_FAR *__RPC_FAR *ppColorSet);
        
        HRESULT ( __stdcall __RPC_FAR *Freeze )( 
            IViewObject __RPC_FAR * This,
            /* [in] */ DWORD dwDrawAspect,
            /* [in] */ LONG lindex,
            /* [unique][in] */ void __RPC_FAR *pvAspect,
            /* [out] */ DWORD __RPC_FAR *pdwFreeze);
        
        HRESULT ( __stdcall __RPC_FAR *Unfreeze )( 
            IViewObject __RPC_FAR * This,
            /* [in] */ DWORD dwFreeze);
        
        HRESULT ( __stdcall __RPC_FAR *SetAdvise )( 
            IViewObject __RPC_FAR * This,
            /* [in] */ DWORD aspects,
            /* [in] */ DWORD advf,
            /* [unique][in] */ IAdviseSink __RPC_FAR *pAdvSink);
        
        HRESULT ( __stdcall __RPC_FAR *GetAdvise )( 
            IViewObject __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pAspects,
            /* [out] */ DWORD __RPC_FAR *pAdvf,
            /* [out] */ IAdviseSink __RPC_FAR *__RPC_FAR *ppAdvSink);
        
    } IViewObjectVtbl;

    interface IViewObject
    {
        CONST_VTBL struct IViewObjectVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IViewObject_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IViewObject_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IViewObject_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IViewObject_Draw(This,dwDrawAspect,lindex,pvAspect,ptd,hdcTargetDev,hdcDraw,lprcBounds,lprcWBounds,pfnContinue,dwContinue)	\
    (This)->lpVtbl -> Draw(This,dwDrawAspect,lindex,pvAspect,ptd,hdcTargetDev,hdcDraw,lprcBounds,lprcWBounds,pfnContinue,dwContinue)

#define IViewObject_GetColorSet(This,dwDrawAspect,lindex,pvAspect,ptd,hicTargetDev,ppColorSet)	\
    (This)->lpVtbl -> GetColorSet(This,dwDrawAspect,lindex,pvAspect,ptd,hicTargetDev,ppColorSet)

#define IViewObject_Freeze(This,dwDrawAspect,lindex,pvAspect,pdwFreeze)	\
    (This)->lpVtbl -> Freeze(This,dwDrawAspect,lindex,pvAspect,pdwFreeze)

#define IViewObject_Unfreeze(This,dwFreeze)	\
    (This)->lpVtbl -> Unfreeze(This,dwFreeze)

#define IViewObject_SetAdvise(This,aspects,advf,pAdvSink)	\
    (This)->lpVtbl -> SetAdvise(This,aspects,advf,pAdvSink)

#define IViewObject_GetAdvise(This,pAspects,pAdvf,ppAdvSink)	\
    (This)->lpVtbl -> GetAdvise(This,pAspects,pAdvf,ppAdvSink)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT __stdcall IViewObject_Draw_Proxy( 
    IViewObject __RPC_FAR * This,
    /* [in] */ DWORD dwDrawAspect,
    /* [in] */ LONG lindex,
    /* [unique][in] */ void __RPC_FAR *pvAspect,
    /* [unique][in] */ DVTARGETDEVICE __RPC_FAR *ptd,
    /* [in] */ HDC hdcTargetDev,
    /* [in] */ HDC hdcDraw,
    /* [in] */ LPCRECTL lprcBounds,
    /* [in] */ LPCRECTL lprcWBounds,
    /* [in] */ BOOL ( __stdcall __stdcall __RPC_FAR *pfnContinue )( 
        DWORD dwContinue),
    /* [in] */ DWORD dwContinue);


void __RPC_STUB IViewObject_Draw_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IViewObject_GetColorSet_Proxy( 
    IViewObject __RPC_FAR * This,
    /* [in] */ DWORD dwDrawAspect,
    /* [in] */ LONG lindex,
    /* [unique][in] */ void __RPC_FAR *pvAspect,
    /* [in] */ DVTARGETDEVICE __RPC_FAR *ptd,
    /* [in] */ HDC hicTargetDev,
    /* [out] */ LOGPALETTE __RPC_FAR *__RPC_FAR *ppColorSet);


void __RPC_STUB IViewObject_GetColorSet_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IViewObject_Freeze_Proxy( 
    IViewObject __RPC_FAR * This,
    /* [in] */ DWORD dwDrawAspect,
    /* [in] */ LONG lindex,
    /* [unique][in] */ void __RPC_FAR *pvAspect,
    /* [out] */ DWORD __RPC_FAR *pdwFreeze);


void __RPC_STUB IViewObject_Freeze_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IViewObject_Unfreeze_Proxy( 
    IViewObject __RPC_FAR * This,
    /* [in] */ DWORD dwFreeze);


void __RPC_STUB IViewObject_Unfreeze_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IViewObject_SetAdvise_Proxy( 
    IViewObject __RPC_FAR * This,
    /* [in] */ DWORD aspects,
    /* [in] */ DWORD advf,
    /* [unique][in] */ IAdviseSink __RPC_FAR *pAdvSink);


void __RPC_STUB IViewObject_SetAdvise_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IViewObject_GetAdvise_Proxy( 
    IViewObject __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pAspects,
    /* [out] */ DWORD __RPC_FAR *pAdvf,
    /* [out] */ IAdviseSink __RPC_FAR *__RPC_FAR *ppAdvSink);


void __RPC_STUB IViewObject_GetAdvise_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IViewObject_INTERFACE_DEFINED__ */


#ifndef __IViewObject2_INTERFACE_DEFINED__
#define __IViewObject2_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IViewObject2
 * at Fri Apr 28 07:02:35 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [uuid][object][local] */ 


			/* size is 4 */
typedef /* [unique] */ IViewObject2 __RPC_FAR *LPVIEWOBJECT2;


EXTERN_C const IID IID_IViewObject2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IViewObject2 : public IViewObject
    {
    public:
        virtual HRESULT __stdcall GetExtent( 
            /* [in] */ DWORD dwDrawAspect,
            /* [in] */ LONG lindex,
            /* [in] */ DVTARGETDEVICE __RPC_FAR *ptd,
            /* [out] */ LPSIZEL lpsizel) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IViewObject2Vtbl
    {
        
        HRESULT ( __stdcall __RPC_FAR *QueryInterface )( 
            IViewObject2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( __stdcall __RPC_FAR *AddRef )( 
            IViewObject2 __RPC_FAR * This);
        
        ULONG ( __stdcall __RPC_FAR *Release )( 
            IViewObject2 __RPC_FAR * This);
        
        HRESULT ( __stdcall __RPC_FAR *Draw )( 
            IViewObject2 __RPC_FAR * This,
            /* [in] */ DWORD dwDrawAspect,
            /* [in] */ LONG lindex,
            /* [unique][in] */ void __RPC_FAR *pvAspect,
            /* [unique][in] */ DVTARGETDEVICE __RPC_FAR *ptd,
            /* [in] */ HDC hdcTargetDev,
            /* [in] */ HDC hdcDraw,
            /* [in] */ LPCRECTL lprcBounds,
            /* [in] */ LPCRECTL lprcWBounds,
            /* [in] */ BOOL ( __stdcall __stdcall __RPC_FAR *pfnContinue )( 
                DWORD dwContinue),
            /* [in] */ DWORD dwContinue);
        
        HRESULT ( __stdcall __RPC_FAR *GetColorSet )( 
            IViewObject2 __RPC_FAR * This,
            /* [in] */ DWORD dwDrawAspect,
            /* [in] */ LONG lindex,
            /* [unique][in] */ void __RPC_FAR *pvAspect,
            /* [in] */ DVTARGETDEVICE __RPC_FAR *ptd,
            /* [in] */ HDC hicTargetDev,
            /* [out] */ LOGPALETTE __RPC_FAR *__RPC_FAR *ppColorSet);
        
        HRESULT ( __stdcall __RPC_FAR *Freeze )( 
            IViewObject2 __RPC_FAR * This,
            /* [in] */ DWORD dwDrawAspect,
            /* [in] */ LONG lindex,
            /* [unique][in] */ void __RPC_FAR *pvAspect,
            /* [out] */ DWORD __RPC_FAR *pdwFreeze);
        
        HRESULT ( __stdcall __RPC_FAR *Unfreeze )( 
            IViewObject2 __RPC_FAR * This,
            /* [in] */ DWORD dwFreeze);
        
        HRESULT ( __stdcall __RPC_FAR *SetAdvise )( 
            IViewObject2 __RPC_FAR * This,
            /* [in] */ DWORD aspects,
            /* [in] */ DWORD advf,
            /* [unique][in] */ IAdviseSink __RPC_FAR *pAdvSink);
        
        HRESULT ( __stdcall __RPC_FAR *GetAdvise )( 
            IViewObject2 __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pAspects,
            /* [out] */ DWORD __RPC_FAR *pAdvf,
            /* [out] */ IAdviseSink __RPC_FAR *__RPC_FAR *ppAdvSink);
        
        HRESULT ( __stdcall __RPC_FAR *GetExtent )( 
            IViewObject2 __RPC_FAR * This,
            /* [in] */ DWORD dwDrawAspect,
            /* [in] */ LONG lindex,
            /* [in] */ DVTARGETDEVICE __RPC_FAR *ptd,
            /* [out] */ LPSIZEL lpsizel);
        
    } IViewObject2Vtbl;

    interface IViewObject2
    {
        CONST_VTBL struct IViewObject2Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IViewObject2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IViewObject2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IViewObject2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IViewObject2_Draw(This,dwDrawAspect,lindex,pvAspect,ptd,hdcTargetDev,hdcDraw,lprcBounds,lprcWBounds,pfnContinue,dwContinue)	\
    (This)->lpVtbl -> Draw(This,dwDrawAspect,lindex,pvAspect,ptd,hdcTargetDev,hdcDraw,lprcBounds,lprcWBounds,pfnContinue,dwContinue)

#define IViewObject2_GetColorSet(This,dwDrawAspect,lindex,pvAspect,ptd,hicTargetDev,ppColorSet)	\
    (This)->lpVtbl -> GetColorSet(This,dwDrawAspect,lindex,pvAspect,ptd,hicTargetDev,ppColorSet)

#define IViewObject2_Freeze(This,dwDrawAspect,lindex,pvAspect,pdwFreeze)	\
    (This)->lpVtbl -> Freeze(This,dwDrawAspect,lindex,pvAspect,pdwFreeze)

#define IViewObject2_Unfreeze(This,dwFreeze)	\
    (This)->lpVtbl -> Unfreeze(This,dwFreeze)

#define IViewObject2_SetAdvise(This,aspects,advf,pAdvSink)	\
    (This)->lpVtbl -> SetAdvise(This,aspects,advf,pAdvSink)

#define IViewObject2_GetAdvise(This,pAspects,pAdvf,ppAdvSink)	\
    (This)->lpVtbl -> GetAdvise(This,pAspects,pAdvf,ppAdvSink)


#define IViewObject2_GetExtent(This,dwDrawAspect,lindex,ptd,lpsizel)	\
    (This)->lpVtbl -> GetExtent(This,dwDrawAspect,lindex,ptd,lpsizel)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT __stdcall IViewObject2_GetExtent_Proxy( 
    IViewObject2 __RPC_FAR * This,
    /* [in] */ DWORD dwDrawAspect,
    /* [in] */ LONG lindex,
    /* [in] */ DVTARGETDEVICE __RPC_FAR *ptd,
    /* [out] */ LPSIZEL lpsizel);


void __RPC_STUB IViewObject2_GetExtent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IViewObject2_INTERFACE_DEFINED__ */


#ifndef __IDropSource_INTERFACE_DEFINED__
#define __IDropSource_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IDropSource
 * at Fri Apr 28 07:02:35 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [uuid][object][local] */ 


			/* size is 4 */
typedef /* [unique] */ IDropSource __RPC_FAR *LPDROPSOURCE;


EXTERN_C const IID IID_IDropSource;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IDropSource : public IUnknown
    {
    public:
        virtual HRESULT __stdcall QueryContinueDrag( 
            /* [in] */ BOOL fEscapePressed,
            /* [in] */ DWORD grfKeyState) = 0;
        
        virtual HRESULT __stdcall GiveFeedback( 
            /* [in] */ DWORD dwEffect) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDropSourceVtbl
    {
        
        HRESULT ( __stdcall __RPC_FAR *QueryInterface )( 
            IDropSource __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( __stdcall __RPC_FAR *AddRef )( 
            IDropSource __RPC_FAR * This);
        
        ULONG ( __stdcall __RPC_FAR *Release )( 
            IDropSource __RPC_FAR * This);
        
        HRESULT ( __stdcall __RPC_FAR *QueryContinueDrag )( 
            IDropSource __RPC_FAR * This,
            /* [in] */ BOOL fEscapePressed,
            /* [in] */ DWORD grfKeyState);
        
        HRESULT ( __stdcall __RPC_FAR *GiveFeedback )( 
            IDropSource __RPC_FAR * This,
            /* [in] */ DWORD dwEffect);
        
    } IDropSourceVtbl;

    interface IDropSource
    {
        CONST_VTBL struct IDropSourceVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDropSource_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDropSource_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDropSource_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDropSource_QueryContinueDrag(This,fEscapePressed,grfKeyState)	\
    (This)->lpVtbl -> QueryContinueDrag(This,fEscapePressed,grfKeyState)

#define IDropSource_GiveFeedback(This,dwEffect)	\
    (This)->lpVtbl -> GiveFeedback(This,dwEffect)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT __stdcall IDropSource_QueryContinueDrag_Proxy( 
    IDropSource __RPC_FAR * This,
    /* [in] */ BOOL fEscapePressed,
    /* [in] */ DWORD grfKeyState);


void __RPC_STUB IDropSource_QueryContinueDrag_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IDropSource_GiveFeedback_Proxy( 
    IDropSource __RPC_FAR * This,
    /* [in] */ DWORD dwEffect);


void __RPC_STUB IDropSource_GiveFeedback_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDropSource_INTERFACE_DEFINED__ */


#ifndef __IDropTarget_INTERFACE_DEFINED__
#define __IDropTarget_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IDropTarget
 * at Fri Apr 28 07:02:35 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [unique][uuid][object] */ 


			/* size is 4 */
typedef /* [unique] */ IDropTarget __RPC_FAR *LPDROPTARGET;

			/* size is 4 */
#define	MK_ALT	( 0x20 )

			/* size is 4 */
#define	DROPEFFECT_NONE	( 0 )

			/* size is 4 */
#define	DROPEFFECT_COPY	( 1 )

			/* size is 4 */
#define	DROPEFFECT_MOVE	( 2 )

			/* size is 4 */
#define	DROPEFFECT_LINK	( 4 )

			/* size is 4 */
#define	DROPEFFECT_SCROLL	( 0x80000000 )

// default inset-width of the hot zone, in pixels
//   typical use: GetProfileInt("windows","DragScrollInset",DD_DEFSCROLLINSET)
			/* size is 4 */
#define	DD_DEFSCROLLINSET	( 11 )

// default delay before scrolling, in milliseconds
//   typical use: GetProfileInt("windows","DragScrollDelay",DD_DEFSCROLLDELAY)
			/* size is 4 */
#define	DD_DEFSCROLLDELAY	( 50 )

// default scroll interval, in milliseconds
//   typical use: GetProfileInt("windows","DragScrollInterval", DD_DEFSCROLLINTERVAL)
			/* size is 4 */
#define	DD_DEFSCROLLINTERVAL	( 50 )

// default delay before dragging should start, in milliseconds
//   typical use: GetProfileInt("windows", "DragDelay", DD_DEFDRAGDELAY)
			/* size is 4 */
#define	DD_DEFDRAGDELAY	( 200 )

// default minimum distance (radius) before dragging should start, in pixels
//   typical use: GetProfileInt("windows", "DragMinDist", DD_DEFDRAGMINDIST)
			/* size is 4 */
#define	DD_DEFDRAGMINDIST	( 2 )


EXTERN_C const IID IID_IDropTarget;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IDropTarget : public IUnknown
    {
    public:
        virtual HRESULT __stdcall DragEnter( 
            /* [unique][in] */ IDataObject __RPC_FAR *pDataObj,
            /* [in] */ DWORD grfKeyState,
            /* [in] */ POINTL pt,
            /* [out][in] */ DWORD __RPC_FAR *pdwEffect) = 0;
        
        virtual HRESULT __stdcall DragOver( 
            /* [in] */ DWORD grfKeyState,
            /* [in] */ POINTL pt,
            /* [out][in] */ DWORD __RPC_FAR *pdwEffect) = 0;
        
        virtual HRESULT __stdcall DragLeave( void) = 0;
        
        virtual HRESULT __stdcall Drop( 
            /* [unique][in] */ IDataObject __RPC_FAR *pDataObj,
            /* [in] */ DWORD grfKeyState,
            /* [in] */ POINTL pt,
            /* [out][in] */ DWORD __RPC_FAR *pdwEffect) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDropTargetVtbl
    {
        
        HRESULT ( __stdcall __RPC_FAR *QueryInterface )( 
            IDropTarget __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( __stdcall __RPC_FAR *AddRef )( 
            IDropTarget __RPC_FAR * This);
        
        ULONG ( __stdcall __RPC_FAR *Release )( 
            IDropTarget __RPC_FAR * This);
        
        HRESULT ( __stdcall __RPC_FAR *DragEnter )( 
            IDropTarget __RPC_FAR * This,
            /* [unique][in] */ IDataObject __RPC_FAR *pDataObj,
            /* [in] */ DWORD grfKeyState,
            /* [in] */ POINTL pt,
            /* [out][in] */ DWORD __RPC_FAR *pdwEffect);
        
        HRESULT ( __stdcall __RPC_FAR *DragOver )( 
            IDropTarget __RPC_FAR * This,
            /* [in] */ DWORD grfKeyState,
            /* [in] */ POINTL pt,
            /* [out][in] */ DWORD __RPC_FAR *pdwEffect);
        
        HRESULT ( __stdcall __RPC_FAR *DragLeave )( 
            IDropTarget __RPC_FAR * This);
        
        HRESULT ( __stdcall __RPC_FAR *Drop )( 
            IDropTarget __RPC_FAR * This,
            /* [unique][in] */ IDataObject __RPC_FAR *pDataObj,
            /* [in] */ DWORD grfKeyState,
            /* [in] */ POINTL pt,
            /* [out][in] */ DWORD __RPC_FAR *pdwEffect);
        
    } IDropTargetVtbl;

    interface IDropTarget
    {
        CONST_VTBL struct IDropTargetVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDropTarget_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDropTarget_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDropTarget_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDropTarget_DragEnter(This,pDataObj,grfKeyState,pt,pdwEffect)	\
    (This)->lpVtbl -> DragEnter(This,pDataObj,grfKeyState,pt,pdwEffect)

#define IDropTarget_DragOver(This,grfKeyState,pt,pdwEffect)	\
    (This)->lpVtbl -> DragOver(This,grfKeyState,pt,pdwEffect)

#define IDropTarget_DragLeave(This)	\
    (This)->lpVtbl -> DragLeave(This)

#define IDropTarget_Drop(This,pDataObj,grfKeyState,pt,pdwEffect)	\
    (This)->lpVtbl -> Drop(This,pDataObj,grfKeyState,pt,pdwEffect)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT __stdcall IDropTarget_DragEnter_Proxy( 
    IDropTarget __RPC_FAR * This,
    /* [unique][in] */ IDataObject __RPC_FAR *pDataObj,
    /* [in] */ DWORD grfKeyState,
    /* [in] */ POINTL pt,
    /* [out][in] */ DWORD __RPC_FAR *pdwEffect);


void __RPC_STUB IDropTarget_DragEnter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IDropTarget_DragOver_Proxy( 
    IDropTarget __RPC_FAR * This,
    /* [in] */ DWORD grfKeyState,
    /* [in] */ POINTL pt,
    /* [out][in] */ DWORD __RPC_FAR *pdwEffect);


void __RPC_STUB IDropTarget_DragOver_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IDropTarget_DragLeave_Proxy( 
    IDropTarget __RPC_FAR * This);


void __RPC_STUB IDropTarget_DragLeave_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IDropTarget_Drop_Proxy( 
    IDropTarget __RPC_FAR * This,
    /* [unique][in] */ IDataObject __RPC_FAR *pDataObj,
    /* [in] */ DWORD grfKeyState,
    /* [in] */ POINTL pt,
    /* [out][in] */ DWORD __RPC_FAR *pdwEffect);


void __RPC_STUB IDropTarget_Drop_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDropTarget_INTERFACE_DEFINED__ */


#ifndef __IEnumOLEVERB_INTERFACE_DEFINED__
#define __IEnumOLEVERB_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IEnumOLEVERB
 * at Fri Apr 28 07:02:35 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [unique][uuid][object] */ 


			/* size is 4 */
typedef /* [unique] */ IEnumOLEVERB __RPC_FAR *LPENUMOLEVERB;

			/* size is 16 */
typedef struct  tagOLEVERB
    {
    LONG lVerb;
    LPOLESTR lpszVerbName;
    DWORD fuFlags;
    DWORD grfAttribs;
    }	OLEVERB;

			/* size is 4 */
typedef struct tagOLEVERB __RPC_FAR *LPOLEVERB;

			/* size is 2 */
typedef /* [v1_enum] */ 
enum tagOLEVERBATTRIB
    {	OLEVERBATTRIB_NEVERDIRTIES	= 1,
	OLEVERBATTRIB_ONCONTAINERMENU	= 2
    }	OLEVERBATTRIB;


EXTERN_C const IID IID_IEnumOLEVERB;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IEnumOLEVERB : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT __stdcall Next( 
            /* [in] */ ULONG celt,
            /* [out] */ LPOLEVERB rgelt,
            /* [out] */ ULONG __RPC_FAR *pceltFetched) = 0;
        
        virtual HRESULT __stdcall Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT __stdcall Reset( void) = 0;
        
        virtual HRESULT __stdcall Clone( 
            /* [out] */ IEnumOLEVERB __RPC_FAR *__RPC_FAR *ppenum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumOLEVERBVtbl
    {
        
        HRESULT ( __stdcall __RPC_FAR *QueryInterface )( 
            IEnumOLEVERB __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( __stdcall __RPC_FAR *AddRef )( 
            IEnumOLEVERB __RPC_FAR * This);
        
        ULONG ( __stdcall __RPC_FAR *Release )( 
            IEnumOLEVERB __RPC_FAR * This);
        
        /* [local] */ HRESULT ( __stdcall __RPC_FAR *Next )( 
            IEnumOLEVERB __RPC_FAR * This,
            /* [in] */ ULONG celt,
            /* [out] */ LPOLEVERB rgelt,
            /* [out] */ ULONG __RPC_FAR *pceltFetched);
        
        HRESULT ( __stdcall __RPC_FAR *Skip )( 
            IEnumOLEVERB __RPC_FAR * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( __stdcall __RPC_FAR *Reset )( 
            IEnumOLEVERB __RPC_FAR * This);
        
        HRESULT ( __stdcall __RPC_FAR *Clone )( 
            IEnumOLEVERB __RPC_FAR * This,
            /* [out] */ IEnumOLEVERB __RPC_FAR *__RPC_FAR *ppenum);
        
    } IEnumOLEVERBVtbl;

    interface IEnumOLEVERB
    {
        CONST_VTBL struct IEnumOLEVERBVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumOLEVERB_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumOLEVERB_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumOLEVERB_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumOLEVERB_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IEnumOLEVERB_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumOLEVERB_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumOLEVERB_Clone(This,ppenum)	\
    (This)->lpVtbl -> Clone(This,ppenum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT __stdcall IEnumOLEVERB_RemoteNext_Proxy( 
    IEnumOLEVERB __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ LPOLEVERB rgelt,
    /* [out] */ ULONG __RPC_FAR *pceltFetched);


void __RPC_STUB IEnumOLEVERB_RemoteNext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IEnumOLEVERB_Skip_Proxy( 
    IEnumOLEVERB __RPC_FAR * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IEnumOLEVERB_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IEnumOLEVERB_Reset_Proxy( 
    IEnumOLEVERB __RPC_FAR * This);


void __RPC_STUB IEnumOLEVERB_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IEnumOLEVERB_Clone_Proxy( 
    IEnumOLEVERB __RPC_FAR * This,
    /* [out] */ IEnumOLEVERB __RPC_FAR *__RPC_FAR *ppenum);


void __RPC_STUB IEnumOLEVERB_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumOLEVERB_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */


void __RPC_USER UINT_to_xmit( UINT __RPC_FAR *, unsigned long  __RPC_FAR * __RPC_FAR * );
void __RPC_USER UINT_from_xmit( unsigned long  __RPC_FAR *, UINT __RPC_FAR * );
void __RPC_USER UINT_free_inst( UINT __RPC_FAR * );
void __RPC_USER UINT_free_xmit( unsigned long  __RPC_FAR * );

void __RPC_USER WPARAM_to_xmit( WPARAM __RPC_FAR *, unsigned long  __RPC_FAR * __RPC_FAR * );
void __RPC_USER WPARAM_from_xmit( unsigned long  __RPC_FAR *, WPARAM __RPC_FAR * );
void __RPC_USER WPARAM_free_inst( WPARAM __RPC_FAR * );
void __RPC_USER WPARAM_free_xmit( unsigned long  __RPC_FAR * );

void __RPC_USER HWND_to_xmit( HWND __RPC_FAR *, long  __RPC_FAR * __RPC_FAR * );
void __RPC_USER HWND_from_xmit( long  __RPC_FAR *, HWND __RPC_FAR * );
void __RPC_USER HWND_free_inst( HWND __RPC_FAR * );
void __RPC_USER HWND_free_xmit( long  __RPC_FAR * );

void __RPC_USER HMENU_to_xmit( HMENU __RPC_FAR *, long  __RPC_FAR * __RPC_FAR * );
void __RPC_USER HMENU_from_xmit( long  __RPC_FAR *, HMENU __RPC_FAR * );
void __RPC_USER HMENU_free_inst( HMENU __RPC_FAR * );
void __RPC_USER HMENU_free_xmit( long  __RPC_FAR * );

void __RPC_USER HACCEL_to_xmit( HACCEL __RPC_FAR *, long  __RPC_FAR * __RPC_FAR * );
void __RPC_USER HACCEL_from_xmit( long  __RPC_FAR *, HACCEL __RPC_FAR * );
void __RPC_USER HACCEL_free_inst( HACCEL __RPC_FAR * );
void __RPC_USER HACCEL_free_xmit( long  __RPC_FAR * );

void __RPC_USER HOLEMENU_to_xmit( HOLEMENU __RPC_FAR *, RemHGLOBAL  __RPC_FAR * __RPC_FAR * );
void __RPC_USER HOLEMENU_from_xmit( RemHGLOBAL  __RPC_FAR *, HOLEMENU __RPC_FAR * );
void __RPC_USER HOLEMENU_free_inst( HOLEMENU __RPC_FAR * );
void __RPC_USER HOLEMENU_free_xmit( RemHGLOBAL  __RPC_FAR * );

/* [local] */ HRESULT __stdcall IOleItemContainer_GetObject_Proxy( 
    IOleItemContainer __RPC_FAR * This,
    /* [in] */ LPOLESTR pszItem,
    /* [in] */ DWORD dwSpeedNeeded,
    /* [unique][in] */ IBindCtx __RPC_FAR *pbc,
    /* [in] */ REFIID riid,
    /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);


/* [call_as] */ HRESULT __stdcall IOleItemContainer_GetObject_Stub( 
    IOleItemContainer __RPC_FAR * This,
    /* [in] */ LPOLESTR pszItem,
    /* [in] */ DWORD dwSpeedNeeded,
    /* [unique][in] */ IBindCtx __RPC_FAR *pbc,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppvObject);

/* [local] */ HRESULT __stdcall IOleItemContainer_GetObjectStorage_Proxy( 
    IOleItemContainer __RPC_FAR * This,
    /* [in] */ LPOLESTR pszItem,
    /* [unique][in] */ IBindCtx __RPC_FAR *pbc,
    /* [in] */ REFIID riid,
    /* [out] */ void __RPC_FAR *__RPC_FAR *ppvStorage);


/* [call_as] */ HRESULT __stdcall IOleItemContainer_GetObjectStorage_Stub( 
    IOleItemContainer __RPC_FAR * This,
    /* [in] */ LPOLESTR pszItem,
    /* [unique][in] */ IBindCtx __RPC_FAR *pbc,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppvStorage);

/* [local] */ HRESULT __stdcall IOleInPlaceActiveObject_TranslateAccelerator_Proxy( 
    IOleInPlaceActiveObject __RPC_FAR * This,
    /* [in] */ LPMSG lpmsg);


/* [call_as] */ HRESULT __stdcall IOleInPlaceActiveObject_TranslateAccelerator_Stub( 
    IOleInPlaceActiveObject __RPC_FAR * This);

/* [local] */ HRESULT __stdcall IOleInPlaceActiveObject_ResizeBorder_Proxy( 
    IOleInPlaceActiveObject __RPC_FAR * This,
    /* [in] */ LPCRECT prcBorder,
    /* [unique][in] */ IOleInPlaceUIWindow __RPC_FAR *pUIWindow,
    /* [in] */ BOOL fFrameWindow);


/* [input_sync][call_as] */ HRESULT __stdcall IOleInPlaceActiveObject_ResizeBorder_Stub( 
    IOleInPlaceActiveObject __RPC_FAR * This,
    /* [in] */ LPCRECT prcBorder,
    /* [in] */ REFIID riid,
    /* [iid_is][unique][in] */ IOleInPlaceUIWindow __RPC_FAR *pUIWindow,
    /* [in] */ BOOL fFrameWindow);

/* [local] */ HRESULT __stdcall IEnumOLEVERB_Next_Proxy( 
    IEnumOLEVERB __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [out] */ LPOLEVERB rgelt,
    /* [out] */ ULONG __RPC_FAR *pceltFetched);


/* [call_as] */ HRESULT __stdcall IEnumOLEVERB_Next_Stub( 
    IEnumOLEVERB __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ LPOLEVERB rgelt,
    /* [out] */ ULONG __RPC_FAR *pceltFetched);



/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\inc32\PSHPACK1.H ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    pshpack1.h

Abstract:

    This file turns 1 byte packing of structures on.  (That is, it disables
    automatic alignment of structure fields.)  An include file is needed
    because various compilers do this in different ways.  For Microsoft
    compatible compilers, this files uses the push option to the pack pragma
    so that the poppack.h include file can restore the previous packing
    reliably.

    The file poppack.h is the complement to this file.

--*/

#if ! (defined(lint) || defined(_lint) || defined(RC_INVOKED))
#if ( _MSC_VER >= 800 ) || defined(_PUSHPOP_SUPPORTED)
#pragma warning(disable:4103)
#if !(defined( MIDL_PASS )) || defined( __midl )
#pragma pack(push)
#endif
#pragma pack(1)
#else
#pragma pack(1)
#endif
#endif // ! (defined(lint) || defined(_lint) || defined(RC_INVOKED))
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\inc32\POPPACK.H ===
/*++

Copyright (c) 1990,95  Microsoft Corporation

Module Name:

    poppack.h

Abstract:

    This file turns packing of structures off.  (That is, it enables
    automatic alignment of structure fields.)  An include file is needed
    because various compilers do this in different ways.

    poppack.h is the complement to pshpack?.h.  An inclusion of poppack.h
    MUST ALWAYS be preceded by an inclusion of one of pshpack?.h, in one-to-one
    correspondence.

    For Microsoft compatible compilers, this file uses the pop option
    to the pack pragma so that it can restore the previous saved by the
    pshpack?.h include file.

--*/

#if ! (defined(lint) || defined(_lint) || defined(RC_INVOKED))
#if ( _MSC_VER >= 800 ) || defined(_PUSHPOP_SUPPORTED)
#pragma warning(disable:4103)
#if !(defined( MIDL_PASS )) || defined( __midl )
#pragma pack(pop)
#else
#pragma pack()
#endif
#else
#pragma pack()
#endif
#endif // ! (defined(lint) || defined(_lint) || defined(RC_INVOKED))
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\inc32\PSHPACK4.H ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    pshpack4.h

Abstract:

    This file turns 4 byte packing of structures on.  (That is, it disables
    automatic alignment of structure fields.)  An include file is needed
    because various compilers do this in different ways.  For Microsoft
    compatible compilers, this files uses the push option to the pack pragma
    so that the poppack.h include file can restore the previous packing
    reliably.

    The file poppack.h is the complement to this file.

--*/

#if ! (defined(lint) || defined(_lint) || defined(RC_INVOKED))
#if ( _MSC_VER >= 800 )
#pragma warning(disable:4103)
#if !(defined( MIDL_PASS )) || defined( __midl )
#pragma pack(push)
#endif
#pragma pack(4)
#else
#pragma pack(4)
#endif
#endif // ! (defined(lint) || defined(_lint) || defined(RC_INVOKED))
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\inc32\PSHPACK8.H ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    pshpack8.h

Abstract:

    This file turns 8 byte packing of structures on.  (That is, it disables
    automatic alignment of structure fields.)  An include file is needed
    because various compilers do this in different ways.  For Microsoft
    compatible compilers, this files uses the push option to the pack pragma
    so that the poppack.h include file can restore the previous packing
    reliably.

    The file poppack.h is the complement to this file.

--*/

#if ! (defined(lint) || defined(_lint) || defined(RC_INVOKED))
#if ( _MSC_VER >= 800 ) || defined(_PUSHPOP_SUPPORTED)
#pragma warning(disable:4103)
#if !(defined( MIDL_PASS )) || defined( __midl )
#pragma pack(push)
#endif
#pragma pack(8)
#else
#pragma pack(8)
#endif
#endif // ! (defined(lint) || defined(_lint) || defined(RC_INVOKED))
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\inc32\PSHPACK2.H ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    pshpack2.h

Abstract:

    This file turns 2 byte packing of structures on.  (That is, it disables
    automatic alignment of structure fields.)  An include file is needed
    because various compilers do this in different ways.  For Microsoft
    compatible compilers, this files uses the push option to the pack pragma
    so that the poppack.h include file can restore the previous packing
    reliably.

    The file poppack.h is the complement to this file.

--*/

#if ! (defined(lint) || defined(_lint) || defined(RC_INVOKED))
#if ( _MSC_VER >= 800 ) || defined(_PUSHPOP_SUPPORTED)
#pragma warning(disable:4103)
#if !(defined( MIDL_PASS )) || defined( __midl )
#pragma pack(push)
#endif
#pragma pack(2)
#else
#pragma pack(2)
#endif
#endif // ! (defined(lint) || defined(_lint) || defined(RC_INVOKED))
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\inc32\RPC.H ===
/*++

Copyright (c) 1991-1995 Microsoft Corporation

Module Name:

    rpc.h

Abstract:

    Master include file for RPC applications.

--*/

#ifndef RPC_NO_WINDOWS_H
#include <windows.h>
#endif // RPC_NO_WINDOWS_H

#ifndef __RPC_H__
#define __RPC_H__

#ifdef __cplusplus
extern "C" {
#endif

#define __RPC_WIN32__
#define __RPC_NT__

#ifndef __MIDL_USER_DEFINED
#define midl_user_allocate MIDL_user_allocate
#define midl_user_free     MIDL_user_free
#define __MIDL_USER_DEFINED
#endif

typedef void * I_RPC_HANDLE;
typedef long RPC_STATUS;

#define RPC_UNICODE_SUPPORTED
#if   (_MSC_VER >= 800) || defined(_STDCALL_SUPPORTED)
#define __RPC_FAR
#define __RPC_API  __stdcall
#define __RPC_USER __stdcall
#define __RPC_STUB __stdcall
#define RPC_ENTRY  __stdcall
#else
#define __RPC_FAR
#define __RPC_API
#define __RPC_USER
#define __RPC_STUB
#define RPC_ENTRY
#endif

#ifdef IN
#undef IN
#undef OUT
#undef OPTIONAL
#endif /* IN */

#include <rpcdce.h>
#include <rpcnsi.h>
#include <rpcnterr.h>


#include <excpt.h>
#include <winerror.h>

#define RpcTryExcept \
    __try \
        {

// trystmts

#define RpcExcept(expr) \
        } \
    __except (expr) \
        {

// exceptstmts

#define RpcEndExcept \
        }

#define RpcTryFinally \
    __try \
        {

// trystmts

#define RpcFinally \
        } \
    __finally \
        {

// finallystmts

#define RpcEndFinally \
        }

#define RpcExceptionCode() GetExceptionCode()
#define RpcAbnormalTermination() AbnormalTermination()

RPC_STATUS RPC_ENTRY
RpcImpersonateClient (
    IN RPC_BINDING_HANDLE BindingHandle OPTIONAL
    );

RPC_STATUS RPC_ENTRY
RpcRevertToSelf (
    );

long RPC_ENTRY
I_RpcMapWin32Status (
    IN RPC_STATUS Status
    );

#ifdef __cplusplus
}
#endif

#endif // __RPC_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\inc32\PRSHT.H ===
/*****************************************************************************\
*                                                                             *
* prsht.h - - Interface for the Windows Property Sheet Pages                  *
*                                                                             *
* Version 1.0                                                                 *
*                                                                             *
* Copyright (c) 1991-1995, Microsoft Corp.      All rights reserved.          *
*                                                                             *
\*****************************************************************************/

#ifndef _PRSHT_H_
#define _PRSHT_H_

//
// Define API decoration for direct importing of DLL references.
//
#ifndef WINCOMMCTRLAPI
#if !defined(_COMCTL32_) && defined(_WIN32)
#define WINCOMMCTRLAPI DECLSPEC_IMPORT
#else
#define WINCOMMCTRLAPI
#endif
#endif // WINCOMMCTRLAPI

//
// For compilers that don't support nameless unions
//
#ifndef DUMMYUNIONNAME
#ifdef NONAMELESSUNION
#define DUMMYUNIONNAME   u
#define DUMMYUNIONNAME2  u2
#define DUMMYUNIONNAME3  u3
#else
#define DUMMYUNIONNAME
#define DUMMYUNIONNAME2
#define DUMMYUNIONNAME3
#endif
#endif // DUMMYUNIONNAME

#ifdef __cplusplus
extern "C" {
#endif

#if (WINVER >= 0x0400)

#define MAXPROPPAGES            100

struct _PSP;
typedef struct _PSP FAR* HPROPSHEETPAGE;

typedef struct _PROPSHEETPAGEA FAR *LPPROPSHEETPAGEA;
typedef struct _PROPSHEETPAGEW FAR *LPPROPSHEETPAGEW;

typedef UINT (CALLBACK FAR * LPFNPSPCALLBACKA)(HWND hwnd, UINT uMsg, LPPROPSHEETPAGEA ppsp);
typedef UINT (CALLBACK FAR * LPFNPSPCALLBACKW)(HWND hwnd, UINT uMsg, LPPROPSHEETPAGEW ppsp);

#ifdef UNICODE
#define LPFNPSPCALLBACK         LPFNPSPCALLBACKW
#else
#define LPFNPSPCALLBACK         LPFNPSPCALLBACKA
#endif

#define PSP_DEFAULT             0x0000
#define PSP_DLGINDIRECT         0x0001
#define PSP_USEHICON            0x0002
#define PSP_USEICONID           0x0004
#define PSP_USETITLE            0x0008
#define PSP_RTLREADING          0x0010

#define PSP_HASHELP             0x0020
#define PSP_USEREFPARENT        0x0040
#define PSP_USECALLBACK         0x0080

#define PSPCB_RELEASE           1
#define PSPCB_CREATE            2


typedef struct _PROPSHEETPAGEA {
        DWORD           dwSize;
        DWORD           dwFlags;
        HINSTANCE       hInstance;
        union {
            LPCSTR          pszTemplate;
#ifdef _WIN32
            LPCDLGTEMPLATE  pResource;
#else
            const VOID FAR *pResource;
#endif
        } DUMMYUNIONNAME;
        union {
            HICON       hIcon;
            LPCSTR      pszIcon;
        } DUMMYUNIONNAME2;
        LPCSTR          pszTitle;
        DLGPROC         pfnDlgProc;
        LPARAM          lParam;
        LPFNPSPCALLBACKA pfnCallback;
        UINT FAR * pcRefParent;
} PROPSHEETPAGEA, FAR *LPPROPSHEETPAGEA;
typedef const PROPSHEETPAGEA FAR *LPCPROPSHEETPAGEA;

typedef struct _PROPSHEETPAGEW {
        DWORD           dwSize;
        DWORD           dwFlags;
        HINSTANCE       hInstance;
        union {
            LPCWSTR          pszTemplate;
#ifdef _WIN32
            LPCDLGTEMPLATE  pResource;
#else
            const VOID FAR *pResource;
#endif
        }DUMMYUNIONNAME;
        union {
            HICON       hIcon;
            LPCWSTR      pszIcon;
        }DUMMYUNIONNAME2;
        LPCWSTR          pszTitle;
        DLGPROC         pfnDlgProc;
        LPARAM          lParam;
        LPFNPSPCALLBACKW pfnCallback;
        UINT FAR * pcRefParent;
} PROPSHEETPAGEW, FAR *LPPROPSHEETPAGEW;
typedef const PROPSHEETPAGEW FAR *LPCPROPSHEETPAGEW;

#ifdef UNICODE
#define PROPSHEETPAGE           PROPSHEETPAGEW
#define LPPROPSHEETPAGE         LPPROPSHEETPAGEW
#define LPCPROPSHEETPAGE        LPCPROPSHEETPAGEW
#else
#define PROPSHEETPAGE           PROPSHEETPAGEA
#define LPPROPSHEETPAGE         LPPROPSHEETPAGEA
#define LPCPROPSHEETPAGE        LPCPROPSHEETPAGEA
#endif


#define PSH_DEFAULT             0x0000
#define PSH_PROPTITLE           0x0001
#define PSH_USEHICON            0x0002
#define PSH_USEICONID           0x0004
#define PSH_PROPSHEETPAGE       0x0008
#define PSH_WIZARD              0x0020
#define PSH_USEPSTARTPAGE       0x0040
#define PSH_NOAPPLYNOW          0x0080
#define PSH_USECALLBACK         0x0100
#define PSH_HASHELP             0x0200
#define PSH_MODELESS            0x0400
#define PSH_RTLREADING          0x0800

typedef int (CALLBACK *PFNPROPSHEETCALLBACK)(HWND, UINT, LPARAM);

typedef struct _PROPSHEETHEADERA {
        DWORD           dwSize;
        DWORD           dwFlags;
        HWND            hwndParent;
        HINSTANCE       hInstance;
        union {
            HICON       hIcon;
            LPCSTR      pszIcon;
        }DUMMYUNIONNAME;
        LPCSTR          pszCaption;


        UINT            nPages;
        union {
            UINT        nStartPage;
            LPCSTR      pStartPage;
        }DUMMYUNIONNAME2;
        union {
            LPCPROPSHEETPAGEA ppsp;
            HPROPSHEETPAGE FAR *phpage;
        }DUMMYUNIONNAME3;
        PFNPROPSHEETCALLBACK pfnCallback;
} PROPSHEETHEADERA, FAR *LPPROPSHEETHEADERA;
typedef const PROPSHEETHEADERA FAR *LPCPROPSHEETHEADERA;

typedef struct _PROPSHEETHEADERW {
        DWORD           dwSize;
        DWORD           dwFlags;
        HWND            hwndParent;
        HINSTANCE       hInstance;
        union {
            HICON       hIcon;
            LPCWSTR     pszIcon;
        }DUMMYUNIONNAME;
        LPCWSTR         pszCaption;


        UINT            nPages;
        union {
            UINT        nStartPage;
            LPCWSTR     pStartPage;
        }DUMMYUNIONNAME2;
        union {
            LPCPROPSHEETPAGEW ppsp;
            HPROPSHEETPAGE FAR *phpage;
        }DUMMYUNIONNAME3;
        PFNPROPSHEETCALLBACK pfnCallback;
} PROPSHEETHEADERW, FAR *LPPROPSHEETHEADERW;
typedef const PROPSHEETHEADERW FAR *LPCPROPSHEETHEADERW;

#ifdef UNICODE
#define PROPSHEETHEADER         PROPSHEETHEADERW
#define LPPROPSHEETHEADER       LPPROPSHEETHEADERW
#define LPCPROPSHEETHEADER      LPCPROPSHEETHEADERW
#else
#define PROPSHEETHEADER         PROPSHEETHEADERA
#define LPPROPSHEETHEADER       LPPROPSHEETHEADERA
#define LPCPROPSHEETHEADER      LPCPROPSHEETHEADERA
#endif


#define PSCB_INITIALIZED  1
#define PSCB_PRECREATE    2

WINCOMMCTRLAPI HPROPSHEETPAGE WINAPI CreatePropertySheetPageA(LPCPROPSHEETPAGEA);
WINCOMMCTRLAPI HPROPSHEETPAGE WINAPI CreatePropertySheetPageW(LPCPROPSHEETPAGEW);
WINCOMMCTRLAPI BOOL           WINAPI DestroyPropertySheetPage(HPROPSHEETPAGE);
WINCOMMCTRLAPI int            WINAPI PropertySheetA(LPCPROPSHEETHEADERA);
WINCOMMCTRLAPI int            WINAPI PropertySheetW(LPCPROPSHEETHEADERW);

#ifdef UNICODE
#define CreatePropertySheetPage  CreatePropertySheetPageW
#define PropertySheet            PropertySheetW
#else
#define CreatePropertySheetPage  CreatePropertySheetPageA
#define PropertySheet            PropertySheetA
#endif



typedef BOOL (CALLBACK FAR * LPFNADDPROPSHEETPAGE)(HPROPSHEETPAGE, LPARAM);
typedef BOOL (CALLBACK FAR * LPFNADDPROPSHEETPAGES)(LPVOID, LPFNADDPROPSHEETPAGE, LPARAM);


typedef struct _PSHNOTIFY
{
    NMHDR hdr;
    LPARAM lParam;
} PSHNOTIFY, FAR *LPPSHNOTIFY;


#define PSN_FIRST               (0U-200U)
#define PSN_LAST                (0U-299U)


#define PSN_SETACTIVE           (PSN_FIRST-0)
#define PSN_KILLACTIVE          (PSN_FIRST-1)
// #define PSN_VALIDATE            (PSN_FIRST-1)
#define PSN_APPLY               (PSN_FIRST-2)
#define PSN_RESET               (PSN_FIRST-3)
// #define PSN_CANCEL              (PSN_FIRST-3)
#define PSN_HELP                (PSN_FIRST-5)
#define PSN_WIZBACK             (PSN_FIRST-6)
#define PSN_WIZNEXT             (PSN_FIRST-7)
#define PSN_WIZFINISH           (PSN_FIRST-8)
#define PSN_QUERYCANCEL         (PSN_FIRST-9)


#define PSNRET_NOERROR              0
#define PSNRET_INVALID              1
#define PSNRET_INVALID_NOCHANGEPAGE 2


#define PSM_SETCURSEL           (WM_USER + 101)
#define PropSheet_SetCurSel(hDlg, hpage, index) \
        SendMessage(hDlg, PSM_SETCURSEL, (WPARAM)index, (LPARAM)hpage)


#define PSM_REMOVEPAGE          (WM_USER + 102)
#define PropSheet_RemovePage(hDlg, index, hpage) \
        SendMessage(hDlg, PSM_REMOVEPAGE, index, (LPARAM)hpage)


#define PSM_ADDPAGE             (WM_USER + 103)
#define PropSheet_AddPage(hDlg, hpage) \
        SendMessage(hDlg, PSM_ADDPAGE, 0, (LPARAM)hpage)


#define PSM_CHANGED             (WM_USER + 104)
#define PropSheet_Changed(hDlg, hwnd) \
        SendMessage(hDlg, PSM_CHANGED, (WPARAM)hwnd, 0L)


#define PSM_RESTARTWINDOWS      (WM_USER + 105)
#define PropSheet_RestartWindows(hDlg) \
        SendMessage(hDlg, PSM_RESTARTWINDOWS, 0, 0L)


#define PSM_REBOOTSYSTEM        (WM_USER + 106)
#define PropSheet_RebootSystem(hDlg) \
        SendMessage(hDlg, PSM_REBOOTSYSTEM, 0, 0L)


#define PSM_CANCELTOCLOSE       (WM_USER + 107)
#define PropSheet_CancelToClose(hDlg) \
        SendMessage(hDlg, PSM_CANCELTOCLOSE, 0, 0L)


#define PSM_QUERYSIBLINGS       (WM_USER + 108)
#define PropSheet_QuerySiblings(hDlg, wParam, lParam) \
        SendMessage(hDlg, PSM_QUERYSIBLINGS, wParam, lParam)


#define PSM_UNCHANGED           (WM_USER + 109)
#define PropSheet_UnChanged(hDlg, hwnd) \
        SendMessage(hDlg, PSM_UNCHANGED, (WPARAM)hwnd, 0L)


#define PSM_APPLY               (WM_USER + 110)
#define PropSheet_Apply(hDlg) \
        SendMessage(hDlg, PSM_APPLY, 0, 0L)


#define PSM_SETTITLEA           (WM_USER + 111)
#define PSM_SETTITLEW           (WM_USER + 120)

#ifdef UNICODE
#define PSM_SETTITLE            PSM_SETTITLEW
#else
#define PSM_SETTITLE            PSM_SETTITLEA
#endif

#define PropSheet_SetTitle(hDlg, wStyle, lpszText)\
        SendMessage(hDlg, PSM_SETTITLE, wStyle, (LPARAM)(LPCTSTR)lpszText)


#define PSM_SETWIZBUTTONS       (WM_USER + 112)
#define PropSheet_SetWizButtons(hDlg, dwFlags) \
        PostMessage(hDlg, PSM_SETWIZBUTTONS, 0, (LPARAM)dwFlags)



#define PSWIZB_BACK             0x00000001
#define PSWIZB_NEXT             0x00000002
#define PSWIZB_FINISH           0x00000004
#define PSWIZB_DISABLEDFINISH   0x00000008


#define PSM_PRESSBUTTON         (WM_USER + 113)
#define PropSheet_PressButton(hDlg, iButton) \
        SendMessage(hDlg, PSM_PRESSBUTTON, (WPARAM)iButton, 0)


#define PSBTN_BACK              0
#define PSBTN_NEXT              1
#define PSBTN_FINISH            2
#define PSBTN_OK                3
#define PSBTN_APPLYNOW          4
#define PSBTN_CANCEL            5
#define PSBTN_HELP              6
#define PSBTN_MAX               6



#define PSM_SETCURSELID         (WM_USER + 114)
#define PropSheet_SetCurSelByID(hDlg, id) \
        SendMessage(hDlg, PSM_SETCURSELID, 0, (LPARAM)id)


#define PSM_SETFINISHTEXTA      (WM_USER + 115)
#define PSM_SETFINISHTEXTW      (WM_USER + 121)

#ifdef UNICODE
#define PSM_SETFINISHTEXT       PSM_SETFINISHTEXTW
#else
#define PSM_SETFINISHTEXT       PSM_SETFINISHTEXTA
#endif

#define PropSheet_SetFinishText(hDlg, lpszText) \
        SendMessage(hDlg, PSM_SETFINISHTEXT, 0, (LPARAM)lpszText)


#define PSM_GETTABCONTROL       (WM_USER + 116)
#define PropSheet_GetTabControl(hDlg) \
        (HWND)SendMessage(hDlg, PSM_GETTABCONTROL, 0, 0)

#define PSM_ISDIALOGMESSAGE     (WM_USER + 117)
#define PropSheet_IsDialogMessage(hDlg, pMsg) \
        (BOOL)SendMessage(hDlg, PSM_ISDIALOGMESSAGE, 0, (LPARAM)pMsg)

#define PSM_GETCURRENTPAGEHWND  (WM_USER + 118)
#define PropSheet_GetCurrentPageHwnd(hDlg) \
        (HWND)SendMessage(hDlg, PSM_GETCURRENTPAGEHWND, 0, 0L)

#define ID_PSRESTARTWINDOWS     0x2
#define ID_PSREBOOTSYSTEM       (ID_PSRESTARTWINDOWS | 0x1)


#define WIZ_CXDLG               276
#define WIZ_CYDLG               140

#define WIZ_CXBMP               80

#define WIZ_BODYX               92
#define WIZ_BODYCX              184

#define PROP_SM_CXDLG           212
#define PROP_SM_CYDLG           188

#define PROP_MED_CXDLG          227
#define PROP_MED_CYDLG          215

#define PROP_LG_CXDLG           252
#define PROP_LG_CYDLG           218

#endif // (WINVER >= 0x0400)

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\inc32\RPCDCE.H ===
/*++

Copyright (c) 1991-1995 Microsoft Corporation

Module Name:

    rpcdce.h

Abstract:

    This module contains the DCE RPC runtime APIs.

--*/

#ifndef __RPCDCE_H__
#define __RPCDCE_H__

#ifdef __cplusplus
extern "C" {
#endif

#define IN
#define OUT
#define OPTIONAL

/*typedef char small;*/
/*typedef unsigned char byte;*/
/*typedef unsigned char boolean;*/

typedef I_RPC_HANDLE RPC_BINDING_HANDLE;
typedef RPC_BINDING_HANDLE handle_t;
#define rpc_binding_handle_t RPC_BINDING_HANDLE

#ifndef GUID_DEFINED
#define GUID_DEFINED
typedef struct _GUID
{
    unsigned long Data1;
    unsigned short Data2;
    unsigned short Data3;
    unsigned char Data4[8];
} GUID;
#endif /* GUID_DEFINED */

#ifndef UUID_DEFINED
#define UUID_DEFINED
typedef GUID UUID;
#ifndef uuid_t
#define uuid_t UUID
#endif
#endif

typedef struct _RPC_BINDING_VECTOR
{
    unsigned long Count;
    RPC_BINDING_HANDLE BindingH[1];
} RPC_BINDING_VECTOR;
#ifndef rpc_binding_vector_t
#define rpc_binding_vector_t RPC_BINDING_VECTOR
#endif

typedef struct _UUID_VECTOR
{
  unsigned long Count;
  UUID *Uuid[1];
} UUID_VECTOR;
#ifndef uuid_vector_t
#define uuid_vector_t UUID_VECTOR
#endif

typedef void __RPC_FAR * RPC_IF_HANDLE;

#ifndef IFID_DEFINED
#define IFID_DEFINED
typedef struct _RPC_IF_ID
{
    UUID Uuid;
    unsigned short VersMajor;
    unsigned short VersMinor;
} RPC_IF_ID;
#endif

#define RPC_C_BINDING_INFINITE_TIMEOUT 10
#define RPC_C_BINDING_MIN_TIMEOUT 0
#define RPC_C_BINDING_DEFAULT_TIMEOUT 5
#define RPC_C_BINDING_MAX_TIMEOUT 9

#define RPC_C_CANCEL_INFINITE_TIMEOUT -1

#define RPC_C_LISTEN_MAX_CALLS_DEFAULT 1234
#define RPC_C_PROTSEQ_MAX_REQS_DEFAULT 10

#ifdef RPC_UNICODE_SUPPORTED

typedef struct _RPC_PROTSEQ_VECTORA
{
    unsigned int Count;
    unsigned char __RPC_FAR * Protseq[1];
} RPC_PROTSEQ_VECTORA;

typedef struct _RPC_PROTSEQ_VECTORW
{
    unsigned int Count;
    unsigned short __RPC_FAR * Protseq[1];
} RPC_PROTSEQ_VECTORW;

#ifdef UNICODE
#define RPC_PROTSEQ_VECTOR RPC_PROTSEQ_VECTORW
#else /* UNICODE */
#define RPC_PROTSEQ_VECTOR RPC_PROTSEQ_VECTORA
#endif /* UNICODE */

#else /* RPC_UNICODE_SUPPORTED */

typedef struct _RPC_PROTSEQ_VECTOR
{
    unsigned int Count;
    unsigned char __RPC_FAR * Protseq[1];
} RPC_PROTSEQ_VECTOR;

#endif /* RPC_UNICODE_SUPPORTED */

typedef void __RPC_USER
RPC_OBJECT_INQ_FN (
    IN UUID __RPC_FAR * ObjectUuid,
    OUT UUID __RPC_FAR * TypeUuid,
    OUT RPC_STATUS __RPC_FAR * Status
    );

#define RPC_MGR_EPV void

typedef struct
{
    unsigned int Count;
    unsigned long Stats[1];
} RPC_STATS_VECTOR;

#define RPC_C_STATS_CALLS_IN 0
#define RPC_C_STATS_CALLS_OUT 1
#define RPC_C_STATS_PKTS_IN 2
#define RPC_C_STATS_PKTS_OUT 3

typedef struct
{
  unsigned long Count;
  RPC_IF_ID __RPC_FAR * IfId[1];
} RPC_IF_ID_VECTOR;

/* client */
RPC_STATUS RPC_ENTRY
RpcBindingCopy (
    IN RPC_BINDING_HANDLE SourceBinding,
    OUT RPC_BINDING_HANDLE __RPC_FAR * DestinationBinding
    );

/* client */
RPC_STATUS RPC_ENTRY
RpcBindingFree (
    IN OUT RPC_BINDING_HANDLE __RPC_FAR * Binding
    );

/* client */

#ifdef RPC_UNICODE_SUPPORTED

RPC_STATUS RPC_ENTRY
RpcBindingFromStringBindingA (
    IN unsigned char __RPC_FAR * StringBinding,
    OUT RPC_BINDING_HANDLE __RPC_FAR * Binding
    );

RPC_STATUS RPC_ENTRY
RpcBindingFromStringBindingW (
    IN unsigned short __RPC_FAR * StringBinding,
    OUT RPC_BINDING_HANDLE __RPC_FAR * Binding
    );

#ifdef UNICODE
#define RpcBindingFromStringBinding RpcBindingFromStringBindingW
#else /* UNICODE */
#define RpcBindingFromStringBinding RpcBindingFromStringBindingA
#endif /* UNICODE */

#else /* RPC_UNICODE_SUPPORTED */

RPC_STATUS RPC_ENTRY
RpcBindingFromStringBinding (
    IN unsigned char __RPC_FAR * StringBinding,
    OUT RPC_BINDING_HANDLE __RPC_FAR * Binding
    );

#endif /* RPC_UNICODE_SUPPORTED */

/* RpcBindingInqAuthClient */
/* RpcBindingInqAuthInfo */

/* client/server */
RPC_STATUS RPC_ENTRY
RpcBindingInqObject (
    IN RPC_BINDING_HANDLE Binding,
    OUT UUID __RPC_FAR * ObjectUuid
    );

/* client */
RPC_STATUS RPC_ENTRY
RpcBindingReset (
    IN RPC_BINDING_HANDLE Binding
    );

/* RpcBindingServerFromClient : UNSUPPORTED */
/* RpcBindingSetAuthInfo */

/* client */
RPC_STATUS RPC_ENTRY
RpcBindingSetObject (
    IN RPC_BINDING_HANDLE Binding,
    IN UUID __RPC_FAR * ObjectUuid
    );

/* client/server */
RPC_STATUS RPC_ENTRY
RpcMgmtInqDefaultProtectLevel(
    IN  unsigned long AuthnSvc,
    OUT unsigned long __RPC_FAR *AuthnLevel
    );

/* client/server */

#ifdef RPC_UNICODE_SUPPORTED

RPC_STATUS RPC_ENTRY
RpcBindingToStringBindingA (
    IN RPC_BINDING_HANDLE Binding,
    OUT unsigned char __RPC_FAR * __RPC_FAR * StringBinding
    );

RPC_STATUS RPC_ENTRY
RpcBindingToStringBindingW (
    IN RPC_BINDING_HANDLE Binding,
    OUT unsigned short __RPC_FAR * __RPC_FAR * StringBinding
    );

#ifdef UNICODE
#define RpcBindingToStringBinding RpcBindingToStringBindingW
#else /* UNICODE */
#define RpcBindingToStringBinding RpcBindingToStringBindingA
#endif /* UNICODE */

#else /* RPC_UNICODE_SUPPORTED */

RPC_STATUS RPC_ENTRY
RpcBindingToStringBinding (
    IN RPC_BINDING_HANDLE Binding,
    OUT unsigned char __RPC_FAR * __RPC_FAR * StringBinding
    );

#endif /* RPC_UNICODE_SUPPORTED */

/* client/server */
RPC_STATUS RPC_ENTRY
RpcBindingVectorFree (
    IN OUT RPC_BINDING_VECTOR __RPC_FAR * __RPC_FAR * BindingVector
    );

/* client/server */

#ifdef RPC_UNICODE_SUPPORTED

RPC_STATUS RPC_ENTRY
RpcStringBindingComposeA (
    IN unsigned char __RPC_FAR * ObjUuid OPTIONAL,
    IN unsigned char __RPC_FAR * Protseq OPTIONAL,
    IN unsigned char __RPC_FAR * NetworkAddr OPTIONAL,
    IN unsigned char __RPC_FAR * Endpoint OPTIONAL,
    IN unsigned char __RPC_FAR * Options OPTIONAL,
    OUT unsigned char __RPC_FAR * __RPC_FAR * StringBinding OPTIONAL
    );

RPC_STATUS RPC_ENTRY
RpcStringBindingComposeW (
    IN unsigned short __RPC_FAR * ObjUuid OPTIONAL,
    IN unsigned short __RPC_FAR * Protseq OPTIONAL,
    IN unsigned short __RPC_FAR * NetworkAddr OPTIONAL,
    IN unsigned short __RPC_FAR * Endpoint OPTIONAL,
    IN unsigned short __RPC_FAR * Options OPTIONAL,
    OUT unsigned short __RPC_FAR * __RPC_FAR * StringBinding OPTIONAL
    );

#ifdef UNICODE
#define RpcStringBindingCompose RpcStringBindingComposeW
#else /* UNICODE */
#define RpcStringBindingCompose RpcStringBindingComposeA
#endif /* UNICODE */

#else /* RPC_UNICODE_SUPPORTED */

RPC_STATUS RPC_ENTRY
RpcStringBindingCompose (
    IN unsigned char __RPC_FAR * ObjUuid OPTIONAL,
    IN unsigned char __RPC_FAR * Protseq OPTIONAL,
    IN unsigned char __RPC_FAR * NetworkAddr OPTIONAL,
    IN unsigned char __RPC_FAR * Endpoint OPTIONAL,
    IN unsigned char __RPC_FAR * Options OPTIONAL,
    OUT unsigned char __RPC_FAR * __RPC_FAR * StringBinding OPTIONAL
    );

#endif /* RPC_UNICODE_SUPPORTED */

/* client/server */

#ifdef RPC_UNICODE_SUPPORTED

RPC_STATUS RPC_ENTRY
RpcStringBindingParseA (
    IN unsigned char __RPC_FAR * StringBinding,
    OUT unsigned char __RPC_FAR * __RPC_FAR * ObjUuid OPTIONAL,
    OUT unsigned char __RPC_FAR * __RPC_FAR * Protseq OPTIONAL,
    OUT unsigned char __RPC_FAR * __RPC_FAR * NetworkAddr OPTIONAL,
    OUT unsigned char __RPC_FAR * __RPC_FAR * Endpoint OPTIONAL,
    OUT unsigned char __RPC_FAR * __RPC_FAR * NetworkOptions OPTIONAL
    );

RPC_STATUS RPC_ENTRY
RpcStringBindingParseW (
    IN unsigned short __RPC_FAR * StringBinding,
    OUT unsigned short __RPC_FAR * __RPC_FAR * ObjUuid OPTIONAL,
    OUT unsigned short __RPC_FAR * __RPC_FAR * Protseq OPTIONAL,
    OUT unsigned short __RPC_FAR * __RPC_FAR * NetworkAddr OPTIONAL,
    OUT unsigned short __RPC_FAR * __RPC_FAR * Endpoint OPTIONAL,
    OUT unsigned short __RPC_FAR * __RPC_FAR * NetworkOptions OPTIONAL
    );

#ifdef UNICODE
#define RpcStringBindingParse RpcStringBindingParseW
#else /* UNICODE */
#define RpcStringBindingParse RpcStringBindingParseA
#endif /* UNICODE */

#else /* RPC_UNICODE_SUPPORTED */

RPC_STATUS RPC_ENTRY
RpcStringBindingParse (
    IN unsigned char __RPC_FAR * StringBinding,
    OUT unsigned char __RPC_FAR * __RPC_FAR * ObjUuid OPTIONAL,
    OUT unsigned char __RPC_FAR * __RPC_FAR * Protseq OPTIONAL,
    OUT unsigned char __RPC_FAR * __RPC_FAR * NetworkAddr OPTIONAL,
    OUT unsigned char __RPC_FAR * __RPC_FAR * Endpoint OPTIONAL,
    OUT unsigned char __RPC_FAR * __RPC_FAR * NetworkOptions OPTIONAL
    );

#endif /* RPC_UNICODE_SUPPORTED */

/* client/server */

#ifdef RPC_UNICODE_SUPPORTED

RPC_STATUS RPC_ENTRY
RpcStringFreeA (
    IN OUT unsigned char __RPC_FAR * __RPC_FAR * String
    );

RPC_STATUS RPC_ENTRY
RpcStringFreeW (
    IN OUT unsigned short __RPC_FAR * __RPC_FAR * String
    );

#ifdef UNICODE
#define RpcStringFree RpcStringFreeW
#else /* UNICODE */
#define RpcStringFree RpcStringFreeA
#endif /* UNICODE */

#else /* RPC_UNICODE_SUPPORTED */

RPC_STATUS RPC_ENTRY
RpcStringFree (
    IN OUT unsigned char __RPC_FAR * __RPC_FAR * String
    );

#endif /* RPC_UNICODE_SUPPORTED */

/* client/server */
RPC_STATUS RPC_ENTRY
RpcIfInqId (
    IN RPC_IF_HANDLE RpcIfHandle,
    OUT RPC_IF_ID __RPC_FAR * RpcIfId
    );

/* client/server */

#ifdef RPC_UNICODE_SUPPORTED

RPC_STATUS RPC_ENTRY
RpcNetworkIsProtseqValidA (
    IN unsigned char __RPC_FAR * Protseq
    );

RPC_STATUS RPC_ENTRY
RpcNetworkIsProtseqValidW (
    IN unsigned short __RPC_FAR * Protseq
    );

#ifdef UNICODE
#define RpcNetworkIsProtseqValid RpcNetworkIsProtseqValidW
#else /* UNICODE */
#define RpcNetworkIsProtseqValid RpcNetworkIsProtseqValidA
#endif /* UNICODE */

#else /* RPC_UNICODE_SUPPORTED */

RPC_STATUS RPC_ENTRY
RpcNetworkIsProtseqValid (
    IN unsigned char __RPC_FAR * Protseq
    );

#endif /* RPC_UNICODE_SUPPORTED */

/* client */
RPC_STATUS RPC_ENTRY
RpcMgmtInqComTimeout (
    IN RPC_BINDING_HANDLE Binding,
    OUT unsigned int __RPC_FAR * Timeout
    );

/* client */
RPC_STATUS RPC_ENTRY
RpcMgmtSetComTimeout (
    IN RPC_BINDING_HANDLE Binding,
    IN unsigned int Timeout
    );

/* client */
RPC_STATUS RPC_ENTRY
RpcMgmtSetCancelTimeout(
    long Timeout
    );


/* server */

#ifdef RPC_UNICODE_SUPPORTED

RPC_STATUS RPC_ENTRY
RpcNetworkInqProtseqsA (
    OUT RPC_PROTSEQ_VECTORA __RPC_FAR * __RPC_FAR * ProtseqVector
    );

RPC_STATUS RPC_ENTRY
RpcNetworkInqProtseqsW (
    OUT RPC_PROTSEQ_VECTORW __RPC_FAR * __RPC_FAR * ProtseqVector
    );

#ifdef UNICODE
#define RpcNetworkInqProtseqs RpcNetworkInqProtseqsW
#else /* UNICODE */
#define RpcNetworkInqProtseqs RpcNetworkInqProtseqsA
#endif /* UNICODE */

#else /* RPC_UNICODE_SUPPORTED */

RPC_STATUS RPC_ENTRY
RpcNetworkInqProtseqs (
    OUT RPC_PROTSEQ_VECTOR __RPC_FAR * __RPC_FAR * ProtseqVector
    );

#endif /* RPC_UNICODE_SUPPORTED */

/* server */
RPC_STATUS RPC_ENTRY
RpcObjectInqType (
    IN UUID __RPC_FAR * ObjUuid,
    OUT UUID __RPC_FAR * TypeUuid OPTIONAL
    );

/* server */
RPC_STATUS RPC_ENTRY
RpcObjectSetInqFn (
    IN RPC_OBJECT_INQ_FN __RPC_FAR * InquiryFn
    );

/* server */
RPC_STATUS RPC_ENTRY
RpcObjectSetType (
    IN UUID __RPC_FAR * ObjUuid,
    IN UUID __RPC_FAR * TypeUuid OPTIONAL
    );

/* server */

#ifdef RPC_UNICODE_SUPPORTED

RPC_STATUS RPC_ENTRY
RpcProtseqVectorFreeA (
    IN OUT RPC_PROTSEQ_VECTORA __RPC_FAR * __RPC_FAR * ProtseqVector
    );

RPC_STATUS RPC_ENTRY
RpcProtseqVectorFreeW (
    IN OUT RPC_PROTSEQ_VECTORW __RPC_FAR * __RPC_FAR * ProtseqVector
    );

#ifdef UNICODE
#define RpcProtseqVectorFree RpcProtseqVectorFreeW
#else /* UNICODE */
#define RpcProtseqVectorFree RpcProtseqVectorFreeA
#endif /* UNICODE */

#else /* RPC_UNICODE_SUPPORTED */

RPC_STATUS RPC_ENTRY
RpcProtseqVectorFree (
    IN OUT RPC_PROTSEQ_VECTOR __RPC_FAR * __RPC_FAR * ProtseqVector
    );

#endif /* RPC_UNICODE_SUPPORTED */

/* server */
RPC_STATUS RPC_ENTRY
RpcServerInqBindings (
    OUT RPC_BINDING_VECTOR __RPC_FAR * __RPC_FAR * BindingVector
    );

/* server */
RPC_STATUS RPC_ENTRY
RpcServerInqIf (
    IN RPC_IF_HANDLE IfSpec,
    IN UUID __RPC_FAR * MgrTypeUuid, OPTIONAL
    OUT RPC_MGR_EPV __RPC_FAR * __RPC_FAR * MgrEpv
    );

/* server */
RPC_STATUS RPC_ENTRY
RpcServerListen (
    IN unsigned int MinimumCallThreads,
    IN unsigned int MaxCalls,
    IN unsigned int DontWait
    );

/* server */
RPC_STATUS RPC_ENTRY
RpcServerRegisterIf (
    IN RPC_IF_HANDLE IfSpec,
    IN UUID __RPC_FAR * MgrTypeUuid OPTIONAL,
    IN RPC_MGR_EPV __RPC_FAR * MgrEpv OPTIONAL
    );

/* server */
RPC_STATUS RPC_ENTRY
RpcServerUnregisterIf (
    IN RPC_IF_HANDLE IfSpec,
    IN UUID __RPC_FAR * MgrTypeUuid, OPTIONAL
    IN unsigned int WaitForCallsToComplete
    );

/* server */
RPC_STATUS RPC_ENTRY
RpcServerUseAllProtseqs (
    IN unsigned int MaxCalls,
    IN void __RPC_FAR * SecurityDescriptor OPTIONAL
    );

/* server */
RPC_STATUS RPC_ENTRY
RpcServerUseAllProtseqsIf (
    IN unsigned int MaxCalls,
    IN RPC_IF_HANDLE IfSpec,
    IN void __RPC_FAR * SecurityDescriptor OPTIONAL
    );

/* server */

#ifdef RPC_UNICODE_SUPPORTED

RPC_STATUS RPC_ENTRY
RpcServerUseProtseqA (
    IN unsigned char __RPC_FAR * Protseq,
    IN unsigned int MaxCalls,
    IN void __RPC_FAR * SecurityDescriptor OPTIONAL
    );

RPC_STATUS RPC_ENTRY
RpcServerUseProtseqW (
    IN unsigned short __RPC_FAR * Protseq,
    IN unsigned int MaxCalls,
    IN void __RPC_FAR * SecurityDescriptor OPTIONAL
    );

#ifdef UNICODE
#define RpcServerUseProtseq RpcServerUseProtseqW
#else /* UNICODE */
#define RpcServerUseProtseq RpcServerUseProtseqA
#endif /* UNICODE */

#else /* RPC_UNICODE_SUPPORTED */

RPC_STATUS RPC_ENTRY
RpcServerUseProtseq (
    IN unsigned char __RPC_FAR * Protseq,
    IN unsigned int MaxCalls,
    IN void __RPC_FAR * SecurityDescriptor OPTIONAL
    );

#endif /* RPC_UNICODE_SUPPORTED */

/* server */

#ifdef RPC_UNICODE_SUPPORTED

RPC_STATUS RPC_ENTRY
RpcServerUseProtseqEpA (
    IN unsigned char __RPC_FAR * Protseq,
    IN unsigned int MaxCalls,
    IN unsigned char __RPC_FAR * Endpoint,
    IN void __RPC_FAR * SecurityDescriptor OPTIONAL
    );

RPC_STATUS RPC_ENTRY
RpcServerUseProtseqEpW (
    IN unsigned short __RPC_FAR * Protseq,
    IN unsigned int MaxCalls,
    IN unsigned short __RPC_FAR * Endpoint,
    IN void __RPC_FAR * SecurityDescriptor OPTIONAL
    );

#ifdef UNICODE
#define RpcServerUseProtseqEp RpcServerUseProtseqEpW
#else /* UNICODE */
#define RpcServerUseProtseqEp RpcServerUseProtseqEpA
#endif /* UNICODE */

#else /* RPC_UNICODE_SUPPORTED */

RPC_STATUS RPC_ENTRY
RpcServerUseProtseqEp (
    IN unsigned char __RPC_FAR * Protseq,
    IN unsigned int MaxCalls,
    IN unsigned char __RPC_FAR * Endpoint,
    IN void __RPC_FAR * SecurityDescriptor OPTIONAL
    );

#endif /* RPC_UNICODE_SUPPORTED */

/* server */

#ifdef RPC_UNICODE_SUPPORTED

RPC_STATUS RPC_ENTRY
RpcServerUseProtseqIfA (
    IN unsigned char __RPC_FAR * Protseq,
    IN unsigned int MaxCalls,
    IN RPC_IF_HANDLE IfSpec,
    IN void __RPC_FAR * SecurityDescriptor OPTIONAL
    );

RPC_STATUS RPC_ENTRY
RpcServerUseProtseqIfW (
    IN unsigned short __RPC_FAR * Protseq,
    IN unsigned int MaxCalls,
    IN RPC_IF_HANDLE IfSpec,
    IN void __RPC_FAR * SecurityDescriptor OPTIONAL
    );

#ifdef UNICODE
#define RpcServerUseProtseqIf RpcServerUseProtseqIfW
#else /* UNICODE */
#define RpcServerUseProtseqIf RpcServerUseProtseqIfA
#endif /* UNICODE */

#else /* RPC_UNICODE_SUPPORTED */

RPC_STATUS RPC_ENTRY
RpcServerUseProtseqIf (
    IN unsigned char __RPC_FAR * Protseq,
    IN unsigned int MaxCalls,
    IN RPC_IF_HANDLE IfSpec,
    IN void __RPC_FAR * SecurityDescriptor OPTIONAL
    );

#endif /* RPC_UNICODE_SUPPORTED */

/* server */
RPC_STATUS RPC_ENTRY
RpcMgmtStatsVectorFree (
    IN RPC_STATS_VECTOR ** StatsVector
    );

/* server */
RPC_STATUS RPC_ENTRY
RpcMgmtInqStats (
    IN RPC_BINDING_HANDLE Binding,
    OUT RPC_STATS_VECTOR ** Statistics
    );

/* server */
RPC_STATUS RPC_ENTRY
RpcMgmtIsServerListening (
    IN RPC_BINDING_HANDLE Binding
    );

/* server */
RPC_STATUS RPC_ENTRY
RpcMgmtStopServerListening (
    IN RPC_BINDING_HANDLE Binding
    );

/* server */
RPC_STATUS RPC_ENTRY
RpcMgmtWaitServerListen (
    void
    );

/* server */
RPC_STATUS RPC_ENTRY
RpcMgmtSetServerStackSize (
    IN unsigned long ThreadStackSize
    );

/* client */
RPC_STATUS RPC_ENTRY
RpcMgmtEnableIdleCleanup (
    void
    );

RPC_STATUS RPC_ENTRY
RpcMgmtInqIfIds (
    IN RPC_BINDING_HANDLE Binding,
    OUT RPC_IF_ID_VECTOR __RPC_FAR * __RPC_FAR * IfIdVector
    );

RPC_STATUS RPC_ENTRY
RpcIfIdVectorFree (
    IN OUT RPC_IF_ID_VECTOR __RPC_FAR * __RPC_FAR * IfIdVector
    );

#ifdef RPC_UNICODE_SUPPORTED

RPC_STATUS RPC_ENTRY
RpcMgmtInqServerPrincNameA (
    IN RPC_BINDING_HANDLE Binding,
    IN unsigned long AuthnSvc,
    OUT unsigned char __RPC_FAR * __RPC_FAR * ServerPrincName
    );

RPC_STATUS RPC_ENTRY
RpcMgmtInqServerPrincNameW (
    IN RPC_BINDING_HANDLE Binding,
    IN unsigned long AuthnSvc,
    OUT unsigned short __RPC_FAR * __RPC_FAR * ServerPrincName
    );

#ifdef UNICODE
#define RpcMgmtInqServerPrincName RpcMgmtInqServerPrincNameW
#else /* UNICODE */
#define RpcMgmtInqServerPrincName RpcMgmtInqServerPrincNameA
#endif /* UNICODE */

#else /* RPC_UNICODE_SUPPORTED */

RPC_STATUS RPC_ENTRY
RpcMgmtInqServerPrincName (
    IN RPC_BINDING_HANDLE Binding,
    IN unsigned long AuthnSvc,
    OUT unsigned char __RPC_FAR * __RPC_FAR * ServerPrincName
    );

#endif /* RPC_UNICODE_SUPPORTED */

#ifdef RPC_UNICODE_SUPPORTED

RPC_STATUS RPC_ENTRY
RpcServerInqDefaultPrincNameA (
    IN unsigned long AuthnSvc,
    OUT unsigned char __RPC_FAR * __RPC_FAR * PrincName
    );

RPC_STATUS RPC_ENTRY
RpcServerInqDefaultPrincNameW (
    IN unsigned long AuthnSvc,
    OUT unsigned short __RPC_FAR * __RPC_FAR * PrincName
    );

#ifdef UNICODE
#define RpcServerInqDefaultPrincName RpcServerInqDefaultPrincNameW
#else /* UNICODE */
#define RpcServerInqDefaultPrincName RpcServerInqDefaultPrincNameA
#endif /* UNICODE */

#else /* RPC_UNICODE_SUPPORTED */

RPC_STATUS RPC_ENTRY
RpcServerInqDefaultPrincName (
    IN unsigned long AuthnSvc,
    OUT unsigned char __RPC_FAR * __RPC_FAR * PrincName
    );

#endif /* RPC_UNICODE_SUPPORTED */

/* client */
RPC_STATUS RPC_ENTRY
RpcEpResolveBinding (
    IN RPC_BINDING_HANDLE Binding,
    IN RPC_IF_HANDLE IfSpec
    );

/* client */

#ifdef RPC_UNICODE_SUPPORTED

RPC_STATUS RPC_ENTRY
RpcNsBindingInqEntryNameA (
    IN RPC_BINDING_HANDLE Binding,
    IN unsigned long EntryNameSyntax,
    OUT unsigned char __RPC_FAR * __RPC_FAR * EntryName
    );

RPC_STATUS RPC_ENTRY
RpcNsBindingInqEntryNameW (
    IN RPC_BINDING_HANDLE Binding,
    IN unsigned long EntryNameSyntax,
    OUT unsigned short __RPC_FAR * __RPC_FAR * EntryName
    );

#ifdef UNICODE
#define RpcNsBindingInqEntryName RpcNsBindingInqEntryNameW
#else /* UNICODE */
#define RpcNsBindingInqEntryName RpcNsBindingInqEntryNameA
#endif /* UNICODE */

#else /* RPC_UNICODE_SUPPORTED */

RPC_STATUS RPC_ENTRY
RpcNsBindingInqEntryName (
    IN RPC_BINDING_HANDLE Binding,
    IN unsigned long EntryNameSyntax,
    OUT unsigned char __RPC_FAR * __RPC_FAR * EntryName
    );

#endif /* RPC_UNICODE_SUPPORTED */

typedef void __RPC_FAR * RPC_AUTH_IDENTITY_HANDLE;
typedef void __RPC_FAR * RPC_AUTHZ_HANDLE;

#define RPC_C_AUTHN_LEVEL_DEFAULT 0
#define RPC_C_AUTHN_LEVEL_NONE 1
#define RPC_C_AUTHN_LEVEL_CONNECT 2
#define RPC_C_AUTHN_LEVEL_CALL 3
#define RPC_C_AUTHN_LEVEL_PKT 4
#define RPC_C_AUTHN_LEVEL_PKT_INTEGRITY 5
#define RPC_C_AUTHN_LEVEL_PKT_PRIVACY 6


#define RPC_C_PROTECT_LEVEL_DEFAULT       (RPC_C_AUTHN_LEVEL_DEFAULT)
#define RPC_C_PROTECT_LEVEL_NONE          (RPC_C_AUTHN_LEVEL_NONE)
#define RPC_C_PROTECT_LEVEL_CONNECT       (RPC_C_AUTHN_LEVEL_CONNECT)
#define RPC_C_PROTECT_LEVEL_CALL          (RPC_C_AUTHN_LEVEL_CALL)
#define RPC_C_PROTECT_LEVEL_PKT           (RPC_C_AUTHN_LEVEL_PKT)
#define RPC_C_PROTECT_LEVEL_PKT_INTEGRITY (RPC_C_AUTHN_LEVEL_PKT_INTEGRITY)
#define RPC_C_PROTECT_LEVEL_PKT_PRIVACY   (RPC_C_AUTHN_LEVEL_PKT_PRIVACY)

#define RPC_C_AUTHN_NONE 0
#define RPC_C_AUTHN_DCE_PRIVATE 1
#define RPC_C_AUTHN_DCE_PUBLIC 2
#define RPC_C_AUTHN_DEC_PUBLIC 4
#define RPC_C_AUTHN_WINNT       10
#define RPC_C_AUTHN_DEFAULT 0xFFFFFFFFL

#if defined(__RPC_DOS__) || defined(__RPC_WIN16__)
typedef struct _SEC_WINNT_AUTH_IDENTITY
{
  char __RPC_FAR *User;
  char __RPC_FAR *Domain;
  char __RPC_FAR *Password;
} SEC_WINNT_AUTH_IDENTITY;
#else


#define SEC_WINNT_AUTH_IDENTITY_ANSI 0x1
#define SEC_WINNT_AUTH_IDENTITY_UNICODE 0x2

typedef struct _SEC_WINNT_AUTH_IDENTITY_W {
  unsigned short __RPC_FAR *User;
  unsigned long UserLength;
  unsigned short __RPC_FAR *Domain;
  unsigned long DomainLength;
  unsigned short __RPC_FAR *Password;
  unsigned long PasswordLength;
  unsigned long Flags;
} SEC_WINNT_AUTH_IDENTITY_W, *PSEC_WINNT_AUTH_IDENTITY_W;

typedef struct _SEC_WINNT_AUTH_IDENTITY_A {
  unsigned char __RPC_FAR *User;
  unsigned long UserLength;
  unsigned char __RPC_FAR *Domain;
  unsigned long DomainLength;
  unsigned char __RPC_FAR *Password;
  unsigned long PasswordLength;
  unsigned long Flags;
} SEC_WINNT_AUTH_IDENTITY_A, *PSEC_WINNT_AUTH_IDENTITY_A;

#ifdef UNICODE
#define SEC_WINNT_AUTH_IDENTITY SEC_WINNT_AUTH_IDENTITY_W
#define PSEC_WINNT_AUTH_IDENTITY PSEC_WINNT_AUTH_IDENTITY_W
#define _SEC_WINNT_AUTH_IDENTITY _SEC_WINNT_AUTH_IDENTITY_W
#else // UNICODE
#define SEC_WINNT_AUTH_IDENTITY SEC_WINNT_AUTH_IDENTITY_A
#define PSEC_WINNT_AUTH_IDENTITY PSEC_WINNT_AUTH_IDENTITY_A
#define _SEC_WINNT_AUTH_IDENTITY _SEC_WINNT_AUTH_IDENTITY_A
#endif // UNICODE
#endif // defined(__RPC_DOS__) || defined(__RPC_WIN16__)

#define RPC_C_AUTHZ_NONE 0
#define RPC_C_AUTHZ_NAME 1
#define RPC_C_AUTHZ_DCE 2

#ifdef RPC_UNICODE_SUPPORTED

RPC_STATUS RPC_ENTRY
RpcBindingInqAuthClientA (
    IN RPC_BINDING_HANDLE ClientBinding, OPTIONAL
    OUT RPC_AUTHZ_HANDLE __RPC_FAR * Privs,
    OUT unsigned char __RPC_FAR * __RPC_FAR * ServerPrincName, OPTIONAL
    OUT unsigned long __RPC_FAR * AuthnLevel, OPTIONAL
    OUT unsigned long __RPC_FAR * AuthnSvc, OPTIONAL
    OUT unsigned long __RPC_FAR * AuthzSvc OPTIONAL
    );

RPC_STATUS RPC_ENTRY
RpcBindingInqAuthClientW (
    IN RPC_BINDING_HANDLE ClientBinding, OPTIONAL
    OUT RPC_AUTHZ_HANDLE __RPC_FAR * Privs,
    OUT unsigned short __RPC_FAR * __RPC_FAR * ServerPrincName, OPTIONAL
    OUT unsigned long __RPC_FAR * AuthnLevel, OPTIONAL
    OUT unsigned long __RPC_FAR * AuthnSvc, OPTIONAL
    OUT unsigned long __RPC_FAR * AuthzSvc OPTIONAL
    );

RPC_STATUS RPC_ENTRY
RpcBindingInqAuthInfoA (
    IN RPC_BINDING_HANDLE Binding,
    OUT unsigned char __RPC_FAR * __RPC_FAR * ServerPrincName, OPTIONAL
    OUT unsigned long __RPC_FAR * AuthnLevel, OPTIONAL
    OUT unsigned long __RPC_FAR * AuthnSvc, OPTIONAL
    OUT RPC_AUTH_IDENTITY_HANDLE __RPC_FAR * AuthIdentity, OPTIONAL
    OUT unsigned long __RPC_FAR * AuthzSvc OPTIONAL
    );

RPC_STATUS RPC_ENTRY
RpcBindingInqAuthInfoW (
    IN RPC_BINDING_HANDLE Binding,
    OUT unsigned short __RPC_FAR * __RPC_FAR * ServerPrincName, OPTIONAL
    OUT unsigned long __RPC_FAR * AuthnLevel, OPTIONAL
    OUT unsigned long __RPC_FAR * AuthnSvc, OPTIONAL
    OUT RPC_AUTH_IDENTITY_HANDLE __RPC_FAR * AuthIdentity, OPTIONAL
    OUT unsigned long __RPC_FAR * AuthzSvc OPTIONAL
    );

RPC_STATUS RPC_ENTRY
RpcBindingSetAuthInfoA (
    IN RPC_BINDING_HANDLE Binding,
    IN unsigned char __RPC_FAR * ServerPrincName,
    IN unsigned long AuthnLevel,
    IN unsigned long AuthnSvc,
    IN RPC_AUTH_IDENTITY_HANDLE AuthIdentity, OPTIONAL
    IN unsigned long AuthzSvc
    );

RPC_STATUS RPC_ENTRY
RpcBindingSetAuthInfoW (
    IN RPC_BINDING_HANDLE Binding,
    IN unsigned short __RPC_FAR * ServerPrincName,
    IN unsigned long AuthnLevel,
    IN unsigned long AuthnSvc,
    IN RPC_AUTH_IDENTITY_HANDLE AuthIdentity, OPTIONAL
    IN unsigned long AuthzSvc
    );

typedef void
(__RPC_USER * RPC_AUTH_KEY_RETRIEVAL_FN) (
    IN void __RPC_FAR * Arg,
    IN unsigned short __RPC_FAR * ServerPrincName,
    IN unsigned long KeyVer,
    OUT void __RPC_FAR * __RPC_FAR * Key,
    OUT RPC_STATUS __RPC_FAR * Status
    );

RPC_STATUS RPC_ENTRY
RpcServerRegisterAuthInfoA (
    IN unsigned char __RPC_FAR * ServerPrincName,
    IN unsigned long AuthnSvc,
    IN RPC_AUTH_KEY_RETRIEVAL_FN GetKeyFn OPTIONAL,
    IN void __RPC_FAR * Arg OPTIONAL
    );

RPC_STATUS RPC_ENTRY
RpcServerRegisterAuthInfoW (
    IN unsigned short __RPC_FAR * ServerPrincName,
    IN unsigned long AuthnSvc,
    IN RPC_AUTH_KEY_RETRIEVAL_FN GetKeyFn OPTIONAL,
    IN void __RPC_FAR * Arg OPTIONAL
    );

#ifdef UNICODE
#define RpcBindingInqAuthClient RpcBindingInqAuthClientW
#define RpcBindingInqAuthInfo RpcBindingInqAuthInfoW
#define RpcBindingSetAuthInfo RpcBindingSetAuthInfoW
#define RpcServerRegisterAuthInfo RpcServerRegisterAuthInfoW
#else /* UNICODE */
#define RpcBindingInqAuthClient RpcBindingInqAuthClientA
#define RpcBindingInqAuthInfo RpcBindingInqAuthInfoA
#define RpcBindingSetAuthInfo RpcBindingSetAuthInfoA
#define RpcServerRegisterAuthInfo RpcServerRegisterAuthInfoA
#endif /* UNICODE */

#else /* RPC_UNICODE_SUPPORTED */

RPC_STATUS RPC_ENTRY
RpcBindingInqAuthClient (
    IN RPC_BINDING_HANDLE ClientBinding, OPTIONAL
    OUT RPC_AUTHZ_HANDLE __RPC_FAR * Privs,
    OUT unsigned char __RPC_FAR * __RPC_FAR * ServerPrincName, OPTIONAL
    OUT unsigned long __RPC_FAR * AuthnLevel, OPTIONAL
    OUT unsigned long __RPC_FAR * AuthnSvc, OPTIONAL
    OUT unsigned long __RPC_FAR * AuthzSvc OPTIONAL
    );

RPC_STATUS RPC_ENTRY
RpcBindingInqAuthInfo (
    IN RPC_BINDING_HANDLE Binding,
    OUT unsigned char __RPC_FAR * __RPC_FAR * ServerPrincName, OPTIONAL
    OUT unsigned long __RPC_FAR * AuthnLevel, OPTIONAL
    OUT unsigned long __RPC_FAR * AuthnSvc, OPTIONAL
    OUT RPC_AUTH_IDENTITY_HANDLE __RPC_FAR * AuthIdentity, OPTIONAL
    OUT unsigned long __RPC_FAR * AuthzSvc OPTIONAL
    );

RPC_STATUS RPC_ENTRY
RpcBindingSetAuthInfo (
    IN RPC_BINDING_HANDLE Binding,
    IN unsigned char __RPC_FAR * ServerPrincName,
    IN unsigned long AuthnLevel,
    IN unsigned long AuthnSvc,
    IN RPC_AUTH_IDENTITY_HANDLE AuthIdentity, OPTIONAL
    IN unsigned long AuthzSvc
    );

typedef void
(__RPC_USER * RPC_AUTH_KEY_RETRIEVAL_FN) (
    IN void __RPC_FAR * Arg,
    IN unsigned char __RPC_FAR * ServerPrincName,
    IN unsigned long KeyVer,
    OUT void __RPC_FAR * __RPC_FAR * Key,
    OUT RPC_STATUS __RPC_FAR * Status
    );

RPC_STATUS RPC_ENTRY
RpcServerRegisterAuthInfo (
    IN unsigned char __RPC_FAR * ServerPrincName,
    IN unsigned long AuthnSvc,
    IN RPC_AUTH_KEY_RETRIEVAL_FN GetKeyFn OPTIONAL,
    IN void __RPC_FAR * Arg OPTIONAL
    );

#endif /* RPC_UNICODE_SUPPORTED */

typedef struct {
    unsigned char __RPC_FAR * UserName;
    unsigned char __RPC_FAR * ComputerName;
    unsigned short Privilege;
    unsigned long AuthFlags;
} RPC_CLIENT_INFORMATION1, __RPC_FAR * PRPC_CLIENT_INFORMATION1;

RPC_STATUS RPC_ENTRY
RpcBindingServerFromClient (
    IN RPC_BINDING_HANDLE ClientBinding,
    OUT RPC_BINDING_HANDLE __RPC_FAR * ServerBinding
    );

void RPC_ENTRY
RpcRaiseException (
    IN RPC_STATUS exception
    );

RPC_STATUS RPC_ENTRY
RpcTestCancel(
    );

RPC_STATUS RPC_ENTRY
RpcCancelThread(
    IN void * Thread
    );

/* client/server */
RPC_STATUS RPC_ENTRY
UuidCreate (
    OUT UUID __RPC_FAR * Uuid
    );

#ifdef RPC_UNICODE_SUPPORTED

/* client/server */
RPC_STATUS RPC_ENTRY
UuidToStringA (
    IN UUID __RPC_FAR * Uuid,
    OUT unsigned char __RPC_FAR * __RPC_FAR * StringUuid
    );

/* client/server */
RPC_STATUS RPC_ENTRY
UuidFromStringA (
    IN unsigned char __RPC_FAR * StringUuid,
    OUT UUID __RPC_FAR * Uuid
    );

/* client/server */
RPC_STATUS RPC_ENTRY
UuidToStringW (
    IN UUID __RPC_FAR * Uuid,
    OUT unsigned short __RPC_FAR * __RPC_FAR * StringUuid
    );

/* client/server */
RPC_STATUS RPC_ENTRY
UuidFromStringW (
    IN unsigned short __RPC_FAR * StringUuid,
    OUT UUID __RPC_FAR * Uuid
    );

#ifdef UNICODE
#define UuidFromString UuidFromStringW
#define UuidToString UuidToStringW
#else /* UNICODE */
#define UuidFromString UuidFromStringA
#define UuidToString UuidToStringA
#endif /* UNICODE */

#else /* RPC_UNICODE_SUPPORTED */

/* client/server */
RPC_STATUS RPC_ENTRY
UuidToString (
    IN UUID __RPC_FAR * Uuid,
    OUT unsigned char __RPC_FAR * __RPC_FAR * StringUuid
    );

/* client/server */
RPC_STATUS RPC_ENTRY
UuidFromString (
    IN unsigned char __RPC_FAR * StringUuid,
    OUT UUID __RPC_FAR * Uuid
    );

#endif /* RPC_UNICODE_SUPPORTED */

signed int RPC_ENTRY
UuidCompare (
    IN UUID __RPC_FAR * Uuid1,
    IN UUID __RPC_FAR * Uuid2,
    OUT RPC_STATUS __RPC_FAR * Status
    );

RPC_STATUS RPC_ENTRY
UuidCreateNil (
    OUT UUID __RPC_FAR * NilUuid
    );

int RPC_ENTRY
UuidEqual (
    IN UUID __RPC_FAR * Uuid1,
    IN UUID __RPC_FAR * Uuid2,
    OUT RPC_STATUS __RPC_FAR * Status
    );

unsigned short RPC_ENTRY
UuidHash (
    IN UUID __RPC_FAR * Uuid,
    OUT RPC_STATUS __RPC_FAR * Status
    );

int RPC_ENTRY
UuidIsNil (
    IN UUID __RPC_FAR * Uuid,
    OUT RPC_STATUS __RPC_FAR * Status
    );

#ifdef RPC_UNICODE_SUPPORTED

RPC_STATUS RPC_ENTRY
RpcEpRegisterNoReplaceA (
    IN RPC_IF_HANDLE IfSpec,
    IN RPC_BINDING_VECTOR * BindingVector,
    IN UUID_VECTOR * UuidVector OPTIONAL,
    IN unsigned char * Annotation
    );

RPC_STATUS RPC_ENTRY
RpcEpRegisterNoReplaceW (
    IN RPC_IF_HANDLE IfSpec,
    IN RPC_BINDING_VECTOR * BindingVector,
    IN UUID_VECTOR * UuidVector OPTIONAL,
    IN unsigned short  * Annotation
    );

RPC_STATUS RPC_ENTRY
RpcEpRegisterA (
    IN RPC_IF_HANDLE IfSpec,
    IN RPC_BINDING_VECTOR * BindingVector,
    IN UUID_VECTOR * UuidVector OPTIONAL,
    IN unsigned char * Annotation
    );

RPC_STATUS RPC_ENTRY
RpcEpRegisterW (
    IN RPC_IF_HANDLE IfSpec,
    IN RPC_BINDING_VECTOR * BindingVector,
    IN UUID_VECTOR * UuidVector OPTIONAL,
    IN unsigned short * Annotation
    );

#ifdef UNICODE
#define RpcEpRegisterNoReplace RpcEpRegisterNoReplaceW
#define RpcEpRegister RpcEpRegisterW
#else /* UNICODE */
#define RpcEpRegisterNoReplace RpcEpRegisterNoReplaceA
#define RpcEpRegister RpcEpRegisterA
#endif /* UNICODE */

#else /* RPC_UNICODE_SUPPORTED */

RPC_STATUS RPC_ENTRY
RpcEpRegisterNoReplace (
    IN RPC_IF_HANDLE IfSpec,
    IN RPC_BINDING_VECTOR * BindingVector,
    IN UUID_VECTOR * UuidVector OPTIONAL,
    IN unsigned  char * Annotation
    );

RPC_STATUS RPC_ENTRY
RpcEpRegister (
    IN RPC_IF_HANDLE IfSpec,
    IN RPC_BINDING_VECTOR * BindingVector,
    IN UUID_VECTOR * UuidVector OPTIONAL,
    IN unsigned char * Annotation
    );

#endif /* RPC_UNICODE_SUPPORTED */


RPC_STATUS RPC_ENTRY
RpcEpUnregister(
    IN RPC_IF_HANDLE IfSpec,
    IN RPC_BINDING_VECTOR * BindingVector,
    IN UUID_VECTOR * UuidVector
    );

#ifdef RPC_UNICODE_SUPPORTED

RPC_STATUS RPC_ENTRY
DceErrorInqTextA (
    IN RPC_STATUS RpcStatus,
    OUT unsigned char __RPC_FAR * ErrorText
    );

RPC_STATUS RPC_ENTRY
DceErrorInqTextW (
    IN RPC_STATUS RpcStatus,
    OUT unsigned short __RPC_FAR * ErrorText
    );

#ifdef UNICODE
#define DceErrorInqText DceErrorInqTextW
#else /* UNICODE */
#define DceErrorInqText DceErrorInqTextA
#endif /* UNICODE */

#else /* RPC_UNICODE_SUPPORTED */

RPC_STATUS RPC_ENTRY
DceErrorInqText (
    IN RPC_STATUS RpcStatus,
    OUT unsigned char __RPC_FAR * ErrorText
    );

#endif /* RPC_UNICODE_SUPPORTED */

#define DCE_C_ERROR_STRING_LEN 256

typedef I_RPC_HANDLE * RPC_EP_INQ_HANDLE;

#define  RPC_C_EP_ALL_ELTS        0
#define  RPC_C_EP_MATCH_BY_IF     1
#define  RPC_C_EP_MATCH_BY_OBJ    2
#define  RPC_C_EP_MATCH_BY_BOTH   3

#define  RPC_C_VERS_ALL           1
#define  RPC_C_VERS_COMPATIBLE    2
#define  RPC_C_VERS_EXACT         3
#define  RPC_C_VERS_MAJOR_ONLY    4
#define  RPC_C_VERS_UPTO          5

RPC_STATUS RPC_ENTRY
RpcMgmtEpEltInqBegin (
    IN RPC_BINDING_HANDLE EpBinding OPTIONAL,
    IN unsigned long InquiryType,
    IN RPC_IF_ID __RPC_FAR * IfId OPTIONAL,
    IN unsigned long VersOption OPTIONAL,
    IN UUID __RPC_FAR * ObjectUuid OPTIONAL,
    OUT RPC_EP_INQ_HANDLE __RPC_FAR * InquiryContext
    );

RPC_STATUS RPC_ENTRY
RpcMgmtEpEltInqDone (
    IN OUT RPC_EP_INQ_HANDLE __RPC_FAR * InquiryContext
    );

#ifdef RPC_UNICODE_SUPPORTED

RPC_STATUS RPC_ENTRY
RpcMgmtEpEltInqNextA (
    IN RPC_EP_INQ_HANDLE InquiryContext,
    OUT RPC_IF_ID __RPC_FAR * IfId,
    OUT RPC_BINDING_HANDLE __RPC_FAR * Binding OPTIONAL,
    OUT UUID __RPC_FAR * ObjectUuid OPTIONAL,
    OUT unsigned char __RPC_FAR * __RPC_FAR * Annotation OPTIONAL
    );

RPC_STATUS RPC_ENTRY
RpcMgmtEpEltInqNextW (
    IN RPC_EP_INQ_HANDLE InquiryContext,
    OUT RPC_IF_ID __RPC_FAR * IfId,
    OUT RPC_BINDING_HANDLE __RPC_FAR * Binding OPTIONAL,
    OUT UUID __RPC_FAR * ObjectUuid OPTIONAL,
    OUT unsigned short __RPC_FAR * __RPC_FAR * Annotation OPTIONAL
    );

#ifdef UNICODE
#define RpcMgmtEpEltInqNext RpcMgmtEpEltInqNextW
#else /* UNICODE */
#define RpcMgmtEpEltInqNext RpcMgmtEpEltInqNextA
#endif /* UNICODE */

#else /* RPC_UNICODE_SUPPORTED */

RPC_STATUS RPC_ENTRY
RpcMgmtEpEltInqNext (
    IN RPC_EP_INQ_HANDLE InquiryContext,
    OUT RPC_IF_ID __RPC_FAR * IfId,
    OUT RPC_BINDING_HANDLE __RPC_FAR * Binding OPTIONAL,
    OUT unsigned char __RPC_FAR * __RPC_FAR * Annotation OPTIONAL
    );

#endif /* RPC_UNICODE_SUPPORTED */

RPC_STATUS RPC_ENTRY
RpcMgmtEpUnregister (
    IN RPC_BINDING_HANDLE EpBinding OPTIONAL,
    IN RPC_IF_ID __RPC_FAR * IfId,
    IN RPC_BINDING_HANDLE Binding,
    IN UUID __RPC_FAR * ObjectUuid OPTIONAL
    );

typedef int
(__RPC_API * RPC_MGMT_AUTHORIZATION_FN) (
    IN RPC_BINDING_HANDLE ClientBinding,
    IN unsigned long RequestedMgmtOperation,
    OUT RPC_STATUS __RPC_FAR * Status
    );

#define RPC_C_MGMT_INQ_IF_IDS         0
#define RPC_C_MGMT_INQ_PRINC_NAME     1
#define RPC_C_MGMT_INQ_STATS          2
#define RPC_C_MGMT_IS_SERVER_LISTEN   3
#define RPC_C_MGMT_STOP_SERVER_LISTEN 4

RPC_STATUS RPC_ENTRY
RpcMgmtSetAuthorizationFn (
    IN RPC_MGMT_AUTHORIZATION_FN AuthorizationFn
    );

#include <rpcdcep.h>

#ifdef __cplusplus
}
#endif

#endif /* __RPCDCE_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\inc32\RPCNSI.H ===
/*++

Copyright (c) 1992-1995 Microsoft Corporation

Module Name:

    rpcnsi.h

Abstract:

    This file contains the types and function definitions to use the
    Name Service Independent APIs.

--*/

#ifndef __RPCNSI_H__
#define __RPCNSI_H__

typedef void __RPC_FAR * RPC_NS_HANDLE;

#define RPC_C_NS_SYNTAX_DEFAULT 0
#define RPC_C_NS_SYNTAX_DCE 3

#define RPC_C_PROFILE_DEFAULT_ELT 0
#define RPC_C_PROFILE_ALL_ELT 1
#define RPC_C_PROFILE_MATCH_BY_IF 2
#define RPC_C_PROFILE_MATCH_BY_MBR 3
#define RPC_C_PROFILE_MATCH_BY_BOTH 4

#define RPC_C_NS_DEFAULT_EXP_AGE -1

/* Server APIs */

RPC_STATUS RPC_ENTRY
RpcNsBindingExportA(
    IN unsigned long EntryNameSyntax OPTIONAL,
    IN unsigned char __RPC_FAR * EntryName,
    IN RPC_IF_HANDLE IfSpec OPTIONAL,
    IN RPC_BINDING_VECTOR __RPC_FAR * BindingVec OPTIONAL,
    IN UUID_VECTOR __RPC_FAR * ObjectUuidVec OPTIONAL
    );


RPC_STATUS RPC_ENTRY
RpcNsBindingUnexportA(
    IN unsigned long EntryNameSyntax OPTIONAL,
    IN unsigned char __RPC_FAR * EntryName,
    IN RPC_IF_HANDLE IfSpec OPTIONAL,
    IN UUID_VECTOR __RPC_FAR * ObjectUuidVec OPTIONAL
    );

#ifdef RPC_UNICODE_SUPPORTED

RPC_STATUS RPC_ENTRY
RpcNsBindingExportW(
    IN unsigned long EntryNameSyntax OPTIONAL,
    IN unsigned short __RPC_FAR * EntryName,
    IN RPC_IF_HANDLE IfSpec OPTIONAL,
    IN RPC_BINDING_VECTOR __RPC_FAR * BindingVec OPTIONAL,
    IN UUID_VECTOR __RPC_FAR * ObjectUuidVec OPTIONAL
    );

RPC_STATUS RPC_ENTRY
RpcNsBindingUnexportW(
    IN unsigned long EntryNameSyntax OPTIONAL,
    IN unsigned short __RPC_FAR * EntryName,
    IN RPC_IF_HANDLE IfSpec OPTIONAL,
    IN UUID_VECTOR __RPC_FAR * ObjectUuidVec OPTIONAL
    );

#endif

/* Client APIs */

RPC_STATUS RPC_ENTRY
RpcNsBindingLookupBeginA(
    IN unsigned long EntryNameSyntax OPTIONAL,
    IN unsigned char __RPC_FAR * EntryName OPTIONAL,
    IN RPC_IF_HANDLE IfSpec OPTIONAL,
    IN UUID __RPC_FAR * ObjUuid OPTIONAL,
    IN unsigned long BindingMaxCount OPTIONAL,
    OUT RPC_NS_HANDLE __RPC_FAR * LookupContext
    );

#ifdef RPC_UNICODE_SUPPORTED

RPC_STATUS RPC_ENTRY
RpcNsBindingLookupBeginW(
    IN unsigned long EntryNameSyntax OPTIONAL,
    IN unsigned short __RPC_FAR * EntryName OPTIONAL,
    IN RPC_IF_HANDLE IfSpec OPTIONAL,
    IN UUID __RPC_FAR * ObjUuid OPTIONAL,
    IN unsigned long BindingMaxCount OPTIONAL,
    OUT RPC_NS_HANDLE __RPC_FAR * LookupContext
    );
#endif

RPC_STATUS RPC_ENTRY
RpcNsBindingLookupNext(
    IN  RPC_NS_HANDLE LookupContext,
    OUT RPC_BINDING_VECTOR __RPC_FAR * __RPC_FAR * BindingVec
    );

RPC_STATUS RPC_ENTRY
RpcNsBindingLookupDone(
    IN OUT RPC_NS_HANDLE __RPC_FAR * LookupContext
    );

/* Group APIs */

RPC_STATUS RPC_ENTRY
RpcNsGroupDeleteA(
    IN unsigned long GroupNameSyntax OPTIONAL,
    IN unsigned char __RPC_FAR * GroupName
    );

RPC_STATUS RPC_ENTRY
RpcNsGroupMbrAddA(
    IN unsigned long GroupNameSyntax OPTIONAL,
    IN unsigned char __RPC_FAR * GroupName,
    IN unsigned long MemberNameSyntax OPTIONAL,
    IN unsigned char __RPC_FAR * MemberName
    );

RPC_STATUS RPC_ENTRY
RpcNsGroupMbrRemoveA(
    IN unsigned long GroupNameSyntax OPTIONAL,
    IN unsigned char __RPC_FAR * GroupName,
    IN unsigned long MemberNameSyntax OPTIONAL,
    IN unsigned char __RPC_FAR * MemberName
    );

RPC_STATUS RPC_ENTRY
RpcNsGroupMbrInqBeginA(
    IN unsigned long GroupNameSyntax OPTIONAL,
    IN unsigned char __RPC_FAR * GroupName,
    IN unsigned long MemberNameSyntax OPTIONAL,
    OUT RPC_NS_HANDLE __RPC_FAR * InquiryContext
    );

RPC_STATUS RPC_ENTRY
RpcNsGroupMbrInqNextA(
    IN  RPC_NS_HANDLE InquiryContext,
    OUT unsigned char __RPC_FAR * __RPC_FAR * MemberName
    );

#ifdef RPC_UNICODE_SUPPORTED

RPC_STATUS RPC_ENTRY
RpcNsGroupDeleteW(
    IN unsigned long GroupNameSyntax OPTIONAL,
    IN unsigned short __RPC_FAR * GroupName
    );

RPC_STATUS RPC_ENTRY
RpcNsGroupMbrAddW(
    IN unsigned long GroupNameSyntax OPTIONAL,
    IN unsigned short __RPC_FAR * GroupName,
    IN unsigned long MemberNameSyntax OPTIONAL,
    IN unsigned short __RPC_FAR * MemberName
    );

RPC_STATUS RPC_ENTRY
RpcNsGroupMbrRemoveW(
    IN unsigned long GroupNameSyntax OPTIONAL,
    IN unsigned short __RPC_FAR * GroupName,
    IN unsigned long MemberNameSyntax OPTIONAL,
    IN unsigned short __RPC_FAR * MemberName
    );

RPC_STATUS RPC_ENTRY
RpcNsGroupMbrInqBeginW(
    IN unsigned long GroupNameSyntax OPTIONAL,
    IN unsigned short __RPC_FAR * GroupName,
    IN unsigned long MemberNameSyntax OPTIONAL,
    OUT RPC_NS_HANDLE __RPC_FAR * InquiryContext
    );

RPC_STATUS RPC_ENTRY
RpcNsGroupMbrInqNextW(
    IN  RPC_NS_HANDLE InquiryContext,
    OUT unsigned short __RPC_FAR * __RPC_FAR * MemberName
    );

#endif

RPC_STATUS RPC_ENTRY
RpcNsGroupMbrInqDone(
    IN OUT RPC_NS_HANDLE __RPC_FAR * InquiryContext
    );

/* Profile APIs */

RPC_STATUS RPC_ENTRY
RpcNsProfileDeleteA(
    IN unsigned long ProfileNameSyntax OPTIONAL,
    IN unsigned char __RPC_FAR * ProfileName
    );

RPC_STATUS RPC_ENTRY
RpcNsProfileEltAddA(
    IN unsigned long ProfileNameSyntax OPTIONAL,
    IN unsigned char __RPC_FAR * ProfileName,
    IN RPC_IF_ID __RPC_FAR * IfId OPTIONAL,
    IN unsigned long MemberNameSyntax OPTIONAL,
    IN unsigned char __RPC_FAR * MemberName,
    IN unsigned long Priority,
    IN unsigned char __RPC_FAR * Annotation OPTIONAL
    );

RPC_STATUS RPC_ENTRY
RpcNsProfileEltRemoveA(
    IN unsigned long ProfileNameSyntax OPTIONAL,
    IN unsigned char __RPC_FAR * ProfileName,
    IN RPC_IF_ID __RPC_FAR * IfId OPTIONAL,
    IN unsigned long MemberNameSyntax OPTIONAL,
    IN unsigned char __RPC_FAR * MemberName
    );

RPC_STATUS RPC_ENTRY
RpcNsProfileEltInqBeginA(
    IN unsigned long ProfileNameSyntax OPTIONAL,
    IN unsigned char __RPC_FAR * ProfileName,
    IN unsigned long InquiryType,
    IN RPC_IF_ID __RPC_FAR * IfId OPTIONAL,
    IN unsigned long VersOption,
    IN unsigned long MemberNameSyntax OPTIONAL,
    IN unsigned char __RPC_FAR * MemberName OPTIONAL,
    OUT RPC_NS_HANDLE __RPC_FAR * InquiryContext
    );

RPC_STATUS RPC_ENTRY
RpcNsProfileEltInqNextA(
    IN RPC_NS_HANDLE InquiryContext,
    OUT RPC_IF_ID __RPC_FAR * IfId,
    OUT unsigned char __RPC_FAR * __RPC_FAR * MemberName,
    OUT unsigned long __RPC_FAR * Priority,
    OUT unsigned char __RPC_FAR * __RPC_FAR * Annotation
    );

#ifdef RPC_UNICODE_SUPPORTED

RPC_STATUS RPC_ENTRY
RpcNsProfileDeleteW(
    IN unsigned long ProfileNameSyntax OPTIONAL,
    IN unsigned short __RPC_FAR * ProfileName
    );

RPC_STATUS RPC_ENTRY
RpcNsProfileEltAddW(
    IN unsigned long ProfileNameSyntax OPTIONAL,
    IN unsigned short __RPC_FAR * ProfileName,
    IN RPC_IF_ID __RPC_FAR * IfId OPTIONAL,
    IN unsigned long MemberNameSyntax OPTIONAL,
    IN unsigned short __RPC_FAR * MemberName,
    IN unsigned long Priority,
    IN unsigned short __RPC_FAR * Annotation OPTIONAL
    );

RPC_STATUS RPC_ENTRY
RpcNsProfileEltRemoveW(
    IN unsigned long ProfileNameSyntax OPTIONAL,
    IN unsigned short __RPC_FAR * ProfileName,
    IN RPC_IF_ID __RPC_FAR * IfId OPTIONAL,
    IN unsigned long MemberNameSyntax OPTIONAL,
    IN unsigned short __RPC_FAR * MemberName
    );

RPC_STATUS RPC_ENTRY
RpcNsProfileEltInqBeginW(
    IN unsigned long ProfileNameSyntax OPTIONAL,
    IN unsigned short __RPC_FAR * ProfileName,
    IN unsigned long InquiryType,
    IN RPC_IF_ID __RPC_FAR * IfId OPTIONAL,
    IN unsigned long VersOption,
    IN unsigned long MemberNameSyntax OPTIONAL,
    IN unsigned short __RPC_FAR * MemberName OPTIONAL,
    OUT RPC_NS_HANDLE __RPC_FAR * InquiryContext
    );

RPC_STATUS RPC_ENTRY
RpcNsProfileEltInqNextW(
    IN RPC_NS_HANDLE InquiryContext,
    OUT RPC_IF_ID __RPC_FAR * IfId,
    OUT unsigned short __RPC_FAR * __RPC_FAR * MemberName,
    OUT unsigned long __RPC_FAR * Priority,
    OUT unsigned short __RPC_FAR * __RPC_FAR * Annotation
    );

#endif

RPC_STATUS RPC_ENTRY
RpcNsProfileEltInqDone(
    IN OUT RPC_NS_HANDLE __RPC_FAR * InquiryContext
    );

/* Entry object APIs */

RPC_STATUS RPC_ENTRY
RpcNsEntryObjectInqBeginA(
    IN unsigned long EntryNameSyntax OPTIONAL,
    IN unsigned char __RPC_FAR * EntryName,
    OUT RPC_NS_HANDLE __RPC_FAR * InquiryContext
    );

#ifdef RPC_UNICODE_SUPPORTED

RPC_STATUS RPC_ENTRY
RpcNsEntryObjectInqBeginW(
    IN unsigned long EntryNameSyntax OPTIONAL,
    IN unsigned short __RPC_FAR * EntryName,
    OUT RPC_NS_HANDLE __RPC_FAR * InquiryContext
    );

#endif

RPC_STATUS RPC_ENTRY
RpcNsEntryObjectInqNext(
    IN  RPC_NS_HANDLE InquiryContext,
    OUT UUID __RPC_FAR * ObjUuid
    );

RPC_STATUS RPC_ENTRY
RpcNsEntryObjectInqDone(
    IN OUT RPC_NS_HANDLE __RPC_FAR * InquiryContext
    );

/* Management and MISC APIs */

RPC_STATUS RPC_ENTRY
RpcNsEntryExpandNameA(
    IN unsigned long EntryNameSyntax OPTIONAL,
    IN unsigned char __RPC_FAR * EntryName,
    OUT unsigned char __RPC_FAR * __RPC_FAR * ExpandedName
    );

RPC_STATUS RPC_ENTRY
RpcNsMgmtBindingUnexportA(
    IN unsigned long EntryNameSyntax OPTIONAL,
    IN unsigned char __RPC_FAR * EntryName,
    IN RPC_IF_ID __RPC_FAR * IfId OPTIONAL,
    IN unsigned long VersOption,
    IN UUID_VECTOR __RPC_FAR * ObjectUuidVec OPTIONAL
    );

RPC_STATUS RPC_ENTRY
RpcNsMgmtEntryCreateA(
    IN unsigned long EntryNameSyntax OPTIONAL,
    IN unsigned char __RPC_FAR * EntryName
    );

RPC_STATUS RPC_ENTRY
RpcNsMgmtEntryDeleteA(
    IN unsigned long EntryNameSyntax OPTIONAL,
    IN unsigned char __RPC_FAR * EntryName
    );

RPC_STATUS RPC_ENTRY
RpcNsMgmtEntryInqIfIdsA(
    IN unsigned long EntryNameSyntax OPTIONAL,
    IN unsigned char __RPC_FAR * EntryName,
    OUT RPC_IF_ID_VECTOR __RPC_FAR * __RPC_FAR * IfIdVec
    );

RPC_STATUS RPC_ENTRY
RpcNsMgmtHandleSetExpAge(
    IN RPC_NS_HANDLE NsHandle,
    IN unsigned long ExpirationAge
    );

RPC_STATUS RPC_ENTRY
RpcNsMgmtInqExpAge(
    OUT unsigned long __RPC_FAR * ExpirationAge
    );

RPC_STATUS RPC_ENTRY
RpcNsMgmtSetExpAge(
    IN unsigned long ExpirationAge
    );

#ifdef RPC_UNICODE_SUPPORTED

RPC_STATUS RPC_ENTRY
RpcNsEntryExpandNameW(
    IN unsigned long EntryNameSyntax OPTIONAL,
    IN unsigned short __RPC_FAR * EntryName,
    OUT unsigned short __RPC_FAR * __RPC_FAR * ExpandedName
    );

RPC_STATUS RPC_ENTRY
RpcNsMgmtBindingUnexportW(
    IN unsigned long EntryNameSyntax OPTIONAL,
    IN unsigned short __RPC_FAR * EntryName,
    IN RPC_IF_ID __RPC_FAR * IfId OPTIONAL,
    IN unsigned long VersOption,
    IN UUID_VECTOR __RPC_FAR * ObjectUuidVec OPTIONAL
    );

RPC_STATUS RPC_ENTRY
RpcNsMgmtEntryCreateW(
    IN unsigned long EntryNameSyntax OPTIONAL,
    IN unsigned short __RPC_FAR * EntryName
    );

RPC_STATUS RPC_ENTRY
RpcNsMgmtEntryDeleteW(
    IN unsigned long EntryNameSyntax OPTIONAL,
    IN unsigned short __RPC_FAR * EntryName
    );

RPC_STATUS RPC_ENTRY
RpcNsMgmtEntryInqIfIdsW(
    IN unsigned long EntryNameSyntax OPTIONAL,
    IN unsigned short __RPC_FAR * EntryName,
    OUT RPC_IF_ID_VECTOR __RPC_FAR * __RPC_FAR * IfIdVec
    );

#endif

/* Client API's implemented in wrappers. */

RPC_STATUS RPC_ENTRY
RpcNsBindingImportBeginA(
    IN unsigned long EntryNameSyntax OPTIONAL,
    IN unsigned char __RPC_FAR * EntryName OPTIONAL,
    IN RPC_IF_HANDLE IfSpec OPTIONAL,
    IN UUID __RPC_FAR * ObjUuid OPTIONAL,
    OUT RPC_NS_HANDLE __RPC_FAR * ImportContext
    );

#ifdef RPC_UNICODE_SUPPORTED

RPC_STATUS RPC_ENTRY
RpcNsBindingImportBeginW(
    IN unsigned long EntryNameSyntax OPTIONAL,
    IN unsigned short __RPC_FAR * EntryName OPTIONAL,
    IN RPC_IF_HANDLE IfSpec OPTIONAL,
    IN UUID __RPC_FAR * ObjUuid OPTIONAL,
    OUT RPC_NS_HANDLE __RPC_FAR * ImportContext
    );

#endif

RPC_STATUS RPC_ENTRY
RpcNsBindingImportNext(
    IN RPC_NS_HANDLE ImportContext,
    OUT RPC_BINDING_HANDLE  __RPC_FAR * Binding
    );

RPC_STATUS RPC_ENTRY
RpcNsBindingImportDone(
    IN OUT RPC_NS_HANDLE __RPC_FAR * ImportContext
    );

RPC_STATUS RPC_ENTRY
RpcNsBindingSelect(
    IN OUT RPC_BINDING_VECTOR __RPC_FAR * BindingVec,
    OUT RPC_BINDING_HANDLE  __RPC_FAR * Binding
    );

#ifdef UNICODE

#define RpcNsBindingLookupBegin RpcNsBindingLookupBeginW
#define RpcNsBindingImportBegin RpcNsBindingImportBeginW
#define RpcNsBindingExport RpcNsBindingExportW
#define RpcNsBindingUnexport RpcNsBindingUnexportW
#define RpcNsGroupDelete RpcNsGroupDeleteW
#define RpcNsGroupMbrAdd RpcNsGroupMbrAddW
#define RpcNsGroupMbrRemove RpcNsGroupMbrRemoveW
#define RpcNsGroupMbrInqBegin RpcNsGroupMbrInqBeginW
#define RpcNsGroupMbrInqNext RpcNsGroupMbrInqNextW
#define RpcNsEntryExpandName RpcNsEntryExpandNameW
#define RpcNsEntryObjectInqBegin RpcNsEntryObjectInqBeginW
#define RpcNsMgmtBindingUnexport RpcNsMgmtBindingUnexportW
#define RpcNsMgmtEntryCreate RpcNsMgmtEntryCreateW
#define RpcNsMgmtEntryDelete RpcNsMgmtEntryDeleteW
#define RpcNsMgmtEntryInqIfIds RpcNsMgmtEntryInqIfIdsW
#define RpcNsProfileDelete RpcNsProfileDeleteW
#define RpcNsProfileEltAdd RpcNsProfileEltAddW
#define RpcNsProfileEltRemove RpcNsProfileEltRemoveW
#define RpcNsProfileEltInqBegin RpcNsProfileEltInqBeginW
#define RpcNsProfileEltInqNext RpcNsProfileEltInqNextW

#else

#define RpcNsBindingLookupBegin RpcNsBindingLookupBeginA
#define RpcNsBindingImportBegin RpcNsBindingImportBeginA
#define RpcNsBindingExport RpcNsBindingExportA
#define RpcNsBindingUnexport RpcNsBindingUnexportA
#define RpcNsGroupDelete RpcNsGroupDeleteA
#define RpcNsGroupMbrAdd RpcNsGroupMbrAddA
#define RpcNsGroupMbrRemove RpcNsGroupMbrRemoveA
#define RpcNsGroupMbrInqBegin RpcNsGroupMbrInqBeginA
#define RpcNsGroupMbrInqNext RpcNsGroupMbrInqNextA
#define RpcNsEntryExpandName RpcNsEntryExpandNameA
#define RpcNsEntryObjectInqBegin RpcNsEntryObjectInqBeginA
#define RpcNsMgmtBindingUnexport RpcNsMgmtBindingUnexportA
#define RpcNsMgmtEntryCreate RpcNsMgmtEntryCreateA
#define RpcNsMgmtEntryDelete RpcNsMgmtEntryDeleteA
#define RpcNsMgmtEntryInqIfIds RpcNsMgmtEntryInqIfIdsA
#define RpcNsProfileDelete RpcNsProfileDeleteA
#define RpcNsProfileEltAdd RpcNsProfileEltAddA
#define RpcNsProfileEltRemove RpcNsProfileEltRemoveA
#define RpcNsProfileEltInqBegin RpcNsProfileEltInqBeginA
#define RpcNsProfileEltInqNext RpcNsProfileEltInqNextA

#endif /* UNICODE */

#endif /* __RPCNSI_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\inc32\RPCNTERR.H ===
/*********************************************************/
/**               Microsoft LAN Manager                 **/
/**       Copyright(c) Microsoft Corp., 1987-1995       **/
/**                                                     **/
/**     Rpc Error Codes from the compiler and runtime   **/
/**                                                     **/
/*********************************************************/

/*
If you change this file, you must also change rpcerr.h.
*/

#ifndef __RPCNTERR_H__
#define __RPCNTERR_H__

#define RPC_S_OK                          ERROR_SUCCESS
#define RPC_S_INVALID_ARG                 ERROR_INVALID_PARAMETER
#define RPC_S_OUT_OF_MEMORY               ERROR_OUTOFMEMORY
#define RPC_S_OUT_OF_THREADS              ERROR_MAX_THRDS_REACHED
#define RPC_S_INVALID_LEVEL               ERROR_INVALID_PARAMETER
#define RPC_S_BUFFER_TOO_SMALL            ERROR_INSUFFICIENT_BUFFER
#define RPC_S_INVALID_SECURITY_DESC       ERROR_INVALID_SECURITY_DESCR
#define RPC_S_ACCESS_DENIED               ERROR_ACCESS_DENIED
#define RPC_S_SERVER_OUT_OF_MEMORY        ERROR_NOT_ENOUGH_SERVER_MEMORY

#define RPC_X_NO_MEMORY                   RPC_S_OUT_OF_MEMORY
#define RPC_X_INVALID_BOUND               RPC_S_INVALID_BOUND
#define RPC_X_INVALID_TAG                 RPC_S_INVALID_TAG
#define RPC_X_ENUM_VALUE_TOO_LARGE        RPC_X_ENUM_VALUE_OUT_OF_RANGE
#define RPC_X_SS_CONTEXT_MISMATCH         ERROR_INVALID_HANDLE
#define RPC_X_INVALID_BUFFER              ERROR_INVALID_USER_BUFFER

#endif /* __RPCNTERR_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\inc32\RPCDCEP.H ===
/*++

Copyright (c) 1991-1995 Microsoft Corporation

Module Name:

    rpcdcep.h

Abstract:

    This module contains the private RPC runtime APIs for use by the
    stubs and by support libraries.  Applications must not call these
    routines.

--*/

#ifndef __RPCDCEP_H__
#define __RPCDCEP_H__

// Set the packing level for RPC structures for Dos and Windows.

#if defined(__RPC_DOS__) || defined(__RPC_WIN16__)
#pragma pack(2)
#endif

#ifdef __cplusplus
extern "C" {
#endif

typedef struct _RPC_VERSION {
    unsigned short MajorVersion;
    unsigned short MinorVersion;
} RPC_VERSION;

typedef struct _RPC_SYNTAX_IDENTIFIER {
    GUID SyntaxGUID;
    RPC_VERSION SyntaxVersion;
} RPC_SYNTAX_IDENTIFIER, __RPC_FAR * PRPC_SYNTAX_IDENTIFIER;

typedef struct _RPC_MESSAGE
{
    RPC_BINDING_HANDLE Handle;
    unsigned long DataRepresentation;
    void __RPC_FAR * Buffer;
    unsigned int BufferLength;
    unsigned int ProcNum;
    PRPC_SYNTAX_IDENTIFIER TransferSyntax;
    void __RPC_FAR * RpcInterfaceInformation;
    void __RPC_FAR * ReservedForRuntime;
    RPC_MGR_EPV __RPC_FAR * ManagerEpv;
    void __RPC_FAR * ImportContext;
    unsigned long RpcFlags;
} RPC_MESSAGE, __RPC_FAR * PRPC_MESSAGE;


typedef RPC_STATUS RPC_ENTRY RPC_FORWARD_FUNCTION(
                       IN UUID             __RPC_FAR * InterfaceId,
                       IN RPC_VERSION      __RPC_FAR * InterfaceVersion,
                       IN UUID             __RPC_FAR * ObjectId,
                       IN unsigned char         __RPC_FAR * Rpcpro,
                       IN void __RPC_FAR * __RPC_FAR * ppDestEndpoint);

/*
 * Types of function calls for datagram and rpc
 */

#define RPC_NCA_FLAGS_DEFAULT       0x00000000  /* 0b000...000 */
#define RPC_NCA_FLAGS_IDEMPOTENT    0x00000001  /* 0b000...001 */
#define RPC_NCA_FLAGS_BROADCAST     0x00000002  /* 0b000...010 */
#define RPC_NCA_FLAGS_MAYBE         0x00000004  /* 0b000...100 */
#define RPCFLG_ASYNCHRONOUS         0x40000000UL
#define RPCFLG_INPUT_SYNCHRONOUS    0x20000000UL

#if defined(__RPC_DOS__) || defined(__RPC_WIN16__)
#define RPC_FLAGS_VALID_BIT 0x8000
#endif

#if defined(__RPC_WIN32__) || defined(__RPC_MAC__)
#define RPC_FLAGS_VALID_BIT 0x00008000
#endif

typedef
void
(__RPC_STUB __RPC_FAR * RPC_DISPATCH_FUNCTION) (
    IN OUT PRPC_MESSAGE Message
    );

typedef struct {
    unsigned int DispatchTableCount;
    RPC_DISPATCH_FUNCTION __RPC_FAR * DispatchTable;
    int Reserved;
} RPC_DISPATCH_TABLE, __RPC_FAR * PRPC_DISPATCH_TABLE;

typedef struct _RPC_PROTSEQ_ENDPOINT
{
    unsigned char __RPC_FAR * RpcProtocolSequence;
    unsigned char __RPC_FAR * Endpoint;
} RPC_PROTSEQ_ENDPOINT, __RPC_FAR * PRPC_PROTSEQ_ENDPOINT;

/*
Both of these types MUST start with the InterfaceId and TransferSyntax.
Look at RpcIfInqId and I_RpcIfInqTransferSyntaxes to see why.
*/

typedef struct _RPC_SERVER_INTERFACE
{
    unsigned int Length;
    RPC_SYNTAX_IDENTIFIER InterfaceId;
    RPC_SYNTAX_IDENTIFIER TransferSyntax;
    PRPC_DISPATCH_TABLE DispatchTable;
    unsigned int RpcProtseqEndpointCount;
    PRPC_PROTSEQ_ENDPOINT RpcProtseqEndpoint;
    RPC_MGR_EPV __RPC_FAR *DefaultManagerEpv;
    void const __RPC_FAR *InterpreterInfo;
} RPC_SERVER_INTERFACE, __RPC_FAR * PRPC_SERVER_INTERFACE;

typedef struct _RPC_CLIENT_INTERFACE
{
    unsigned int Length;
    RPC_SYNTAX_IDENTIFIER InterfaceId;
    RPC_SYNTAX_IDENTIFIER TransferSyntax;
    PRPC_DISPATCH_TABLE DispatchTable;
    unsigned int RpcProtseqEndpointCount;
    PRPC_PROTSEQ_ENDPOINT RpcProtseqEndpoint;
    unsigned long Reserved;
    void const __RPC_FAR * InterpreterInfo;
} RPC_CLIENT_INTERFACE, __RPC_FAR * PRPC_CLIENT_INTERFACE;

RPC_STATUS RPC_ENTRY
I_RpcGetBuffer (
    IN OUT RPC_MESSAGE __RPC_FAR * Message
    );

RPC_STATUS RPC_ENTRY
I_RpcSendReceive (
    IN OUT RPC_MESSAGE __RPC_FAR * Message
    );

RPC_STATUS RPC_ENTRY
I_RpcFreeBuffer (
    IN OUT RPC_MESSAGE __RPC_FAR * Message
    );

typedef void * I_RPC_MUTEX;

void RPC_ENTRY
I_RpcRequestMutex (
    IN OUT I_RPC_MUTEX * Mutex
    );

void RPC_ENTRY
I_RpcClearMutex (
    IN I_RPC_MUTEX Mutex
    );

void RPC_ENTRY
I_RpcDeleteMutex (
    IN I_RPC_MUTEX Mutex
    );

void __RPC_FAR * RPC_ENTRY
I_RpcAllocate (
    IN unsigned int Size
    );

void RPC_ENTRY
I_RpcFree (
    IN void __RPC_FAR * Object
    );

void RPC_ENTRY
I_RpcPauseExecution (
    IN unsigned long Milliseconds
    );

typedef
void
(__RPC_USER __RPC_FAR * PRPC_RUNDOWN) (
    void __RPC_FAR * AssociationContext
    );

RPC_STATUS RPC_ENTRY
I_RpcMonitorAssociation (
    IN RPC_BINDING_HANDLE Handle,
    IN PRPC_RUNDOWN RundownRoutine,
    IN void * Context
    );

RPC_STATUS RPC_ENTRY
I_RpcStopMonitorAssociation (
    IN RPC_BINDING_HANDLE Handle
    );

RPC_BINDING_HANDLE RPC_ENTRY
I_RpcGetCurrentCallHandle(
    void
    );

RPC_STATUS RPC_ENTRY
I_RpcGetAssociationContext (
    OUT void __RPC_FAR * __RPC_FAR * AssociationContext
    );

RPC_STATUS RPC_ENTRY
I_RpcSetAssociationContext (
    IN void __RPC_FAR * AssociationContext
    );

#ifdef __RPC_NT__

RPC_STATUS RPC_ENTRY
I_RpcNsBindingSetEntryName (
    IN RPC_BINDING_HANDLE Binding,
    IN unsigned long EntryNameSyntax,
    IN unsigned short __RPC_FAR * EntryName
    );

#else 

RPC_STATUS RPC_ENTRY
I_RpcNsBindingSetEntryName (
    IN RPC_BINDING_HANDLE Binding,
    IN unsigned long EntryNameSyntax,
    IN unsigned char __RPC_FAR * EntryName
    );

#endif 

#ifdef __RPC_NT__

RPC_STATUS RPC_ENTRY
I_RpcBindingInqDynamicEndpoint (
    IN RPC_BINDING_HANDLE Binding,
    OUT unsigned short __RPC_FAR * __RPC_FAR * DynamicEndpoint
    );

#else 

RPC_STATUS RPC_ENTRY
I_RpcBindingInqDynamicEndpoint (
    IN RPC_BINDING_HANDLE Binding,
    OUT unsigned char __RPC_FAR * __RPC_FAR * DynamicEndpoint
    );

#endif 

#define TRANSPORT_TYPE_CN   0x1
#define TRANSPORT_TYPE_DG   0x2
#define TRANSPORT_TYPE_LPC  0x4
#define TRANSPORT_TYPE_WMSG 0x8

RPC_STATUS RPC_ENTRY
I_RpcBindingInqTransportType (
    IN RPC_BINDING_HANDLE Binding,
    OUT unsigned int __RPC_FAR * Type
    );

typedef struct _RPC_TRANSFER_SYNTAX
{
    UUID Uuid;
    unsigned short VersMajor;
    unsigned short VersMinor;
} RPC_TRANSFER_SYNTAX;

RPC_STATUS RPC_ENTRY
I_RpcIfInqTransferSyntaxes (
    IN RPC_IF_HANDLE RpcIfHandle,
    OUT RPC_TRANSFER_SYNTAX __RPC_FAR * TransferSyntaxes,
    IN unsigned int TransferSyntaxSize,
    OUT unsigned int __RPC_FAR * TransferSyntaxCount
    );

RPC_STATUS RPC_ENTRY
I_UuidCreate (
    OUT UUID __RPC_FAR * Uuid
    );

RPC_STATUS RPC_ENTRY
I_RpcBindingCopy (
    IN RPC_BINDING_HANDLE SourceBinding,
    OUT RPC_BINDING_HANDLE __RPC_FAR * DestinationBinding
    );

RPC_STATUS RPC_ENTRY
I_RpcBindingIsClientLocal (
    IN RPC_BINDING_HANDLE BindingHandle OPTIONAL,
    OUT unsigned int __RPC_FAR * ClientLocalFlag
    );

void RPC_ENTRY
I_RpcSsDontSerializeContext (
    void
    );


RPC_STATUS RPC_ENTRY
I_RpcServerRegisterForwardFunction (
    IN RPC_FORWARD_FUNCTION __RPC_FAR * pForwardFunction
                       );
RPC_STATUS RPC_ENTRY
I_RpcConnectionInqSockBuffSize(
  OUT unsigned long __RPC_FAR * RecvBuffSize,
  OUT unsigned long __RPC_FAR * SendBuffSize
  );

RPC_STATUS RPC_ENTRY
I_RpcConnectionSetSockBuffSize(
  IN unsigned long RecvBuffSize,
  IN unsigned long SendBuffSize
  );

#ifdef __RPC_WIN32__

typedef
RPC_STATUS
(__RPC_USER __RPC_FAR * RPC_BLOCKING_FUNCTION) (
    IN void __RPC_FAR *RpcWindowHandle,
    IN void __RPC_FAR *Context
    );

RPC_STATUS RPC_ENTRY
I_RpcBindingSetAsync(
    IN RPC_BINDING_HANDLE Binding,
    IN RPC_BLOCKING_FUNCTION BlockingHook
    );

RPC_STATUS RPC_ENTRY
I_RpcAsyncSendReceive(
    IN OUT RPC_MESSAGE __RPC_FAR * Message,
    IN void __RPC_FAR * Context
    );

RPC_STATUS RPC_ENTRY
I_RpcGetThreadWindowHandle(
    OUT void __RPC_FAR * __RPC_FAR * WindowHandle
    );

RPC_STATUS RPC_ENTRY
I_RpcServerThreadPauseListening(
    );

RPC_STATUS RPC_ENTRY
I_RpcServerThreadContinueListening(
    );

RPC_STATUS RPC_ENTRY
I_RpcServerUnregisterEndpointA (
    IN unsigned char * Protseq,
    IN unsigned char * Endpoint
    );

RPC_STATUS RPC_ENTRY
I_RpcServerUnregisterEndpointW (
    IN unsigned short * Protseq,
    IN unsigned short * Endpoint
    );

#ifdef UNICODE
#define I_RpcServerUnregisterEndpoint I_RpcServerUnregisterEndpointW
#else
#define I_RpcServerUnregisterEndpoint I_RpcServerUnregisterEndpointA
#endif

#endif // __RPC_WIN32__

#ifdef __cplusplus
}
#endif

// Reset the packing level for Dos and Windows.

#if defined(__RPC_DOS__) || defined(__RPC_WIN16__)
#pragma pack()
#endif

#endif /* __RPCDCEP_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\inc32\RPCNSIP.H ===
/*++

Copyright (c) 1992-1993 Microsoft Corporation

Module Name:

    rpcnsip.h

Abstract:

    This file contains the types and function definitions to use the
    to implement the autohandle features of the runtime.

--*/

#ifndef __RPCNSIP_H__
#define __RPCNSIP_H__

#ifdef __cplusplus
extern "C" {
#endif

typedef struct
{
   RPC_NS_HANDLE        LookupContext;
   RPC_BINDING_HANDLE   ProposedHandle;
   RPC_BINDING_VECTOR * Bindings;

} RPC_IMPORT_CONTEXT_P, * PRPC_IMPORT_CONTEXT_P;


/* Stub Auto Binding routines. */

RPC_STATUS RPC_ENTRY
I_RpcNsGetBuffer(
    IN PRPC_MESSAGE Message
    );

RPC_STATUS RPC_ENTRY
I_RpcNsSendReceive(
    IN PRPC_MESSAGE Message,
    OUT RPC_BINDING_HANDLE __RPC_FAR * Handle
    );

void RPC_ENTRY
I_RpcNsRaiseException(
    IN PRPC_MESSAGE Message,
    IN RPC_STATUS Status
    );

RPC_STATUS RPC_ENTRY
I_RpcReBindBuffer(
    IN PRPC_MESSAGE Message
    );

RPC_STATUS RPC_ENTRY
I_NsServerBindSearch(
    );

RPC_STATUS RPC_ENTRY
I_NsClientBindSearch(
    );

void RPC_ENTRY
I_NsClientBindDone(
    );

#ifdef __cplusplus
}
#endif

#endif /* __RPCNSIP_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\inc32\SHELLAPI.H ===
/*****************************************************************************\
*                                                                             *
* shellapi.h -  SHELL.DLL functions, types, and definitions                   *
*                                                                             *
* Copyright (c) 1992-1995, Microsoft Corp.  All rights reserved               *
*                                                                             *
\*****************************************************************************/

#ifndef _INC_SHELLAPI
#define _INC_SHELLAPI



//
// Define API decoration for direct importing of DLL references.
//
#ifndef WINSHELLAPI
#if !defined(_SHELL32_)
#define WINSHELLAPI DECLSPEC_IMPORT
#else
#define WINSHELLAPI
#endif
#endif // WINSHELLAPI

#include <pshpack1.h>

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */



DECLARE_HANDLE(HDROP);

WINSHELLAPI UINT APIENTRY DragQueryFileA(HDROP,UINT,LPSTR,UINT);
WINSHELLAPI UINT APIENTRY DragQueryFileW(HDROP,UINT,LPWSTR,UINT);
#ifdef UNICODE
#define DragQueryFile  DragQueryFileW
#else
#define DragQueryFile  DragQueryFileA
#endif // !UNICODE
WINSHELLAPI BOOL APIENTRY DragQueryPoint(HDROP,LPPOINT);
WINSHELLAPI VOID APIENTRY DragFinish(HDROP);
WINSHELLAPI VOID APIENTRY DragAcceptFiles(HWND,BOOL);

WINSHELLAPI HINSTANCE APIENTRY ShellExecuteA(HWND hwnd, LPCSTR lpOperation, LPCSTR lpFile, LPCSTR lpParameters, LPCSTR lpDirectory, INT nShowCmd);
WINSHELLAPI HINSTANCE APIENTRY ShellExecuteW(HWND hwnd, LPCWSTR lpOperation, LPCWSTR lpFile, LPCWSTR lpParameters, LPCWSTR lpDirectory, INT nShowCmd);
#ifdef UNICODE
#define ShellExecute  ShellExecuteW
#else
#define ShellExecute  ShellExecuteA
#endif // !UNICODE
WINSHELLAPI HINSTANCE APIENTRY FindExecutableA(LPCSTR lpFile, LPCSTR lpDirectory, LPSTR lpResult);
WINSHELLAPI HINSTANCE APIENTRY FindExecutableW(LPCWSTR lpFile, LPCWSTR lpDirectory, LPWSTR lpResult);
#ifdef UNICODE
#define FindExecutable  FindExecutableW
#else
#define FindExecutable  FindExecutableA
#endif // !UNICODE
WINSHELLAPI LPWSTR *  APIENTRY CommandLineToArgvW(LPCWSTR lpCmdLine, int*pNumArgs);

WINSHELLAPI INT       APIENTRY ShellAboutA(HWND hWnd, LPCSTR szApp, LPCSTR szOtherStuff, HICON hIcon);
WINSHELLAPI INT       APIENTRY ShellAboutW(HWND hWnd, LPCWSTR szApp, LPCWSTR szOtherStuff, HICON hIcon);
#ifdef UNICODE
#define ShellAbout  ShellAboutW
#else
#define ShellAbout  ShellAboutA
#endif // !UNICODE
WINSHELLAPI HICON     APIENTRY DuplicateIcon(HINSTANCE hInst, HICON hIcon);
WINSHELLAPI HICON     APIENTRY ExtractAssociatedIconA(HINSTANCE hInst, LPSTR lpIconPath, LPWORD lpiIcon);
WINSHELLAPI HICON     APIENTRY ExtractAssociatedIconW(HINSTANCE hInst, LPWSTR lpIconPath, LPWORD lpiIcon);
#ifdef UNICODE
#define ExtractAssociatedIcon  ExtractAssociatedIconW
#else
#define ExtractAssociatedIcon  ExtractAssociatedIconA
#endif // !UNICODE
WINSHELLAPI HICON     APIENTRY ExtractIconA(HINSTANCE hInst, LPCSTR lpszExeFileName, UINT nIconIndex);
WINSHELLAPI HICON     APIENTRY ExtractIconW(HINSTANCE hInst, LPCWSTR lpszExeFileName, UINT nIconIndex);
#ifdef UNICODE
#define ExtractIcon  ExtractIconW
#else
#define ExtractIcon  ExtractIconA
#endif // !UNICODE

#if(WINVER >= 0x0400)
typedef struct _DRAGINFOA {
    UINT uSize;                 /* init with sizeof(DRAGINFO) */
    POINT pt;
    BOOL fNC;
    LPSTR   lpFileList;
    DWORD grfKeyState;
} DRAGINFOA, FAR* LPDRAGINFOA;
typedef struct _DRAGINFOW {
    UINT uSize;                 /* init with sizeof(DRAGINFO) */
    POINT pt;
    BOOL fNC;
    LPWSTR  lpFileList;
    DWORD grfKeyState;
} DRAGINFOW, FAR* LPDRAGINFOW;
#ifdef UNICODE
typedef DRAGINFOW DRAGINFO;
typedef LPDRAGINFOW LPDRAGINFO;
#else
typedef DRAGINFOA DRAGINFO;
typedef LPDRAGINFOA LPDRAGINFO;
#endif // UNICODE


////
//// AppBar stuff
////
#define ABM_NEW           0x00000000
#define ABM_REMOVE        0x00000001
#define ABM_QUERYPOS      0x00000002
#define ABM_SETPOS        0x00000003
#define ABM_GETSTATE      0x00000004
#define ABM_GETTASKBARPOS 0x00000005
#define ABM_ACTIVATE      0x00000006  // lParam == TRUE/FALSE means activate/deactivate
#define ABM_GETAUTOHIDEBAR 0x00000007
#define ABM_SETAUTOHIDEBAR 0x00000008  // this can fail at any time.  MUST check the result
                                        // lParam = TRUE/FALSE  Set/Unset
                                        // uEdge = what edge
#define ABM_WINDOWPOSCHANGED 0x0000009


// these are put in the wparam of callback messages
#define ABN_STATECHANGE    0x0000000
#define ABN_POSCHANGED     0x0000001
#define ABN_FULLSCREENAPP  0x0000002
#define ABN_WINDOWARRANGE  0x0000003 // lParam == TRUE means hide

// flags for get state
#define ABS_AUTOHIDE    0x0000001
#define ABS_ALWAYSONTOP 0x0000002

#define ABE_LEFT        0
#define ABE_TOP         1
#define ABE_RIGHT       2
#define ABE_BOTTOM      3

typedef struct _AppBarData
{
    DWORD cbSize;
    HWND hWnd;
    UINT uCallbackMessage;
    UINT uEdge;
    RECT rc;
    LPARAM lParam; // message specific
} APPBARDATA, *PAPPBARDATA;

WINSHELLAPI UINT APIENTRY SHAppBarMessage(DWORD dwMessage, PAPPBARDATA pData);

////
////  EndAppBar
////



WINSHELLAPI DWORD   APIENTRY DoEnvironmentSubstA(LPSTR szString, UINT cbString);
WINSHELLAPI DWORD   APIENTRY DoEnvironmentSubstW(LPWSTR szString, UINT cbString);
#ifdef UNICODE
#define DoEnvironmentSubst  DoEnvironmentSubstW
#else
#define DoEnvironmentSubst  DoEnvironmentSubstA
#endif // !UNICODE
WINSHELLAPI LPSTR APIENTRY FindEnvironmentStringA(LPSTR szEnvVar);
WINSHELLAPI LPWSTR APIENTRY FindEnvironmentStringW(LPWSTR szEnvVar);
#ifdef UNICODE
#define FindEnvironmentString  FindEnvironmentStringW
#else
#define FindEnvironmentString  FindEnvironmentStringA
#endif // !UNICODE

#define EIRESID(x) (-1 * (int)(x))
WINSHELLAPI UINT WINAPI ExtractIconExA(LPCSTR lpszFile, int nIconIndex, HICON FAR *phiconLarge, HICON FAR *phiconSmall, UINT nIcons);
WINSHELLAPI UINT WINAPI ExtractIconExW(LPCWSTR lpszFile, int nIconIndex, HICON FAR *phiconLarge, HICON FAR *phiconSmall, UINT nIcons);
#ifdef UNICODE
#define ExtractIconEx  ExtractIconExW
#else
#define ExtractIconEx  ExtractIconExA
#endif // !UNICODE



////
//// Shell File Operations
////

#ifndef FO_MOVE //these need to be kept in sync with the ones in shlobj.h

#define FO_MOVE           0x0001
#define FO_COPY           0x0002
#define FO_DELETE         0x0003
#define FO_RENAME         0x0004

#define FOF_MULTIDESTFILES         0x0001
#define FOF_CONFIRMMOUSE           0x0002
#define FOF_SILENT                 0x0004  // don't create progress/report
#define FOF_RENAMEONCOLLISION      0x0008
#define FOF_NOCONFIRMATION         0x0010  // Don't prompt the user.
#define FOF_WANTMAPPINGHANDLE      0x0020  // Fill in SHFILEOPSTRUCT.hNameMappings
                                      // Must be freed using SHFreeNameMappings
#define FOF_ALLOWUNDO              0x0040
#define FOF_FILESONLY              0x0080  // on *.*, do only files
#define FOF_SIMPLEPROGRESS         0x0100  // means don't show names of files
#define FOF_NOCONFIRMMKDIR         0x0200  // don't confirm making any needed dirs

typedef WORD FILEOP_FLAGS;

#define PO_DELETE       0x0013  // printer is being deleted
#define PO_RENAME       0x0014  // printer is being renamed
#define PO_PORTCHANGE   0x0020  // port this printer connected to is being changed
                                // if this id is set, the strings received by
                                // the copyhook are a doubly-null terminated
                                // list of strings.  The first is the printer
                                // name and the second is the printer port.
#define PO_REN_PORT     0x0034  // PO_RENAME and PO_PORTCHANGE at same time.

// no POF_ flags currently defined

typedef WORD PRINTEROP_FLAGS;

#endif // FO_MOVE

// implicit parameters are:
//      if pFrom or pTo are unqualified names the current directories are
//      taken from the global current drive/directory settings managed
//      by Get/SetCurrentDrive/Directory
//
//      the global confirmation settings

typedef struct _SHFILEOPSTRUCTA
{
        HWND            hwnd;
        UINT            wFunc;
        LPCSTR          pFrom;
        LPCSTR          pTo;
        FILEOP_FLAGS    fFlags;
        BOOL            fAnyOperationsAborted;
        LPVOID          hNameMappings;
        LPCSTR           lpszProgressTitle; // only used if FOF_SIMPLEPROGRESS
} SHFILEOPSTRUCTA, FAR *LPSHFILEOPSTRUCTA;
typedef struct _SHFILEOPSTRUCTW
{
        HWND            hwnd;
        UINT            wFunc;
        LPCWSTR         pFrom;
        LPCWSTR         pTo;
        FILEOP_FLAGS    fFlags;
        BOOL            fAnyOperationsAborted;
        LPVOID          hNameMappings;
        LPCWSTR          lpszProgressTitle; // only used if FOF_SIMPLEPROGRESS
} SHFILEOPSTRUCTW, FAR *LPSHFILEOPSTRUCTW;
#ifdef UNICODE
typedef SHFILEOPSTRUCTW SHFILEOPSTRUCT;
typedef LPSHFILEOPSTRUCTW LPSHFILEOPSTRUCT;
#else
typedef SHFILEOPSTRUCTA SHFILEOPSTRUCT;
typedef LPSHFILEOPSTRUCTA LPSHFILEOPSTRUCT;
#endif // UNICODE

WINSHELLAPI int WINAPI SHFileOperationA(LPSHFILEOPSTRUCTA lpFileOp);
WINSHELLAPI int WINAPI SHFileOperationW(LPSHFILEOPSTRUCTW lpFileOp);
#ifdef UNICODE
#define SHFileOperation  SHFileOperationW
#else
#define SHFileOperation  SHFileOperationA
#endif // !UNICODE

WINSHELLAPI void WINAPI SHFreeNameMappings(HANDLE hNameMappings);

typedef struct _SHNAMEMAPPINGA
{
    LPSTR   pszOldPath;
    LPSTR   pszNewPath;
    int   cchOldPath;
    int   cchNewPath;
} SHNAMEMAPPINGA, FAR *LPSHNAMEMAPPINGA;
typedef struct _SHNAMEMAPPINGW
{
    LPWSTR  pszOldPath;
    LPWSTR  pszNewPath;
    int   cchOldPath;
    int   cchNewPath;
} SHNAMEMAPPINGW, FAR *LPSHNAMEMAPPINGW;
#ifdef UNICODE
typedef SHNAMEMAPPINGW SHNAMEMAPPING;
typedef LPSHNAMEMAPPINGW LPSHNAMEMAPPING;
#else
typedef SHNAMEMAPPINGA SHNAMEMAPPING;
typedef LPSHNAMEMAPPINGA LPSHNAMEMAPPING;
#endif // UNICODE

#define SHGetNameMappingCount(_hnm) \
        DSA_GetItemCount(_hnm)
#define SHGetNameMappingPtr(_hnm, _iItem) \
        (LPSHNAMEMAPPING)DSA_GetItemPtr(_hnm, _iItem)

////
//// End Shell File Operations
////

////
////  Begin ShellExecuteEx and family
////









/* ShellExecute() and ShellExecuteEx() error codes */

/* regular WinExec() codes */
#define SE_ERR_FNF              2       // file not found
#define SE_ERR_PNF              3       // path not found
#define SE_ERR_ACCESSDENIED     5       // access denied
#define SE_ERR_OOM              8       // out of memory
#define SE_ERR_DLLNOTFOUND              32

#endif /* WINVER >= 0x0400 */

/* error values for ShellExecute() beyond the regular WinExec() codes */
#define SE_ERR_SHARE                    26
#define SE_ERR_ASSOCINCOMPLETE          27
#define SE_ERR_DDETIMEOUT               28
#define SE_ERR_DDEFAIL                  29
#define SE_ERR_DDEBUSY                  30
#define SE_ERR_NOASSOC                  31

#if(WINVER >= 0x0400)

// Note CLASSKEY overrides CLASSNAME
#define SEE_MASK_CLASSNAME      0x00000001
#define SEE_MASK_CLASSKEY       0x00000003
// Note INVOKEIDLIST overrides IDLIST
#define SEE_MASK_IDLIST         0x00000004
#define SEE_MASK_INVOKEIDLIST   0x0000000c
#define SEE_MASK_ICON           0x00000010
#define SEE_MASK_HOTKEY         0x00000020
#define SEE_MASK_NOCLOSEPROCESS 0x00000040
#define SEE_MASK_CONNECTNETDRV  0x00000080
#define SEE_MASK_FLAG_DDEWAIT   0x00000100
#define SEE_MASK_DOENVSUBST     0x00000200
#define SEE_MASK_FLAG_NO_UI     0x00000400
#define SEE_MASK_UNICODE        0x00010000

typedef struct _SHELLEXECUTEINFOA
{
        DWORD cbSize;
        ULONG fMask;
        HWND hwnd;
        LPCSTR   lpVerb;
        LPCSTR   lpFile;
        LPCSTR   lpParameters;
        LPCSTR   lpDirectory;
        int nShow;
        HINSTANCE hInstApp;
        // Optional fields
        LPVOID lpIDList;
        LPCSTR   lpClass;
        HKEY hkeyClass;
        DWORD dwHotKey;
        HANDLE hIcon;
        HANDLE hProcess;
} SHELLEXECUTEINFOA, FAR *LPSHELLEXECUTEINFOA;
typedef struct _SHELLEXECUTEINFOW
{
        DWORD cbSize;
        ULONG fMask;
        HWND hwnd;
        LPCWSTR  lpVerb;
        LPCWSTR  lpFile;
        LPCWSTR  lpParameters;
        LPCWSTR  lpDirectory;
        int nShow;
        HINSTANCE hInstApp;
        // Optional fields
        LPVOID lpIDList;
        LPCWSTR  lpClass;
        HKEY hkeyClass;
        DWORD dwHotKey;
        HANDLE hIcon;
        HANDLE hProcess;
} SHELLEXECUTEINFOW, FAR *LPSHELLEXECUTEINFOW;
#ifdef UNICODE
typedef SHELLEXECUTEINFOW SHELLEXECUTEINFO;
typedef LPSHELLEXECUTEINFOW LPSHELLEXECUTEINFO;
#else
typedef SHELLEXECUTEINFOA SHELLEXECUTEINFO;
typedef LPSHELLEXECUTEINFOA LPSHELLEXECUTEINFO;
#endif // UNICODE

WINSHELLAPI BOOL WINAPI ShellExecuteExA(LPSHELLEXECUTEINFOA lpExecInfo);
WINSHELLAPI BOOL WINAPI ShellExecuteExW(LPSHELLEXECUTEINFOW lpExecInfo);
#ifdef UNICODE
#define ShellExecuteEx  ShellExecuteExW
#else
#define ShellExecuteEx  ShellExecuteExA
#endif // !UNICODE
WINSHELLAPI void WINAPI WinExecErrorA(HWND hwnd, int error, LPCSTR lpstrFileName, LPCSTR lpstrTitle);
WINSHELLAPI void WINAPI WinExecErrorW(HWND hwnd, int error, LPCWSTR lpstrFileName, LPCWSTR lpstrTitle);
#ifdef UNICODE
#define WinExecError  WinExecErrorW
#else
#define WinExecError  WinExecErrorA
#endif // !UNICODE

////
////  End ShellExecuteEx and family
////


////
//// Tray notification definitions
////

typedef struct _NOTIFYICONDATAA {
        DWORD cbSize;
        HWND hWnd;
        UINT uID;
        UINT uFlags;
        UINT uCallbackMessage;
        HICON hIcon;
        CHAR   szTip[64];
} NOTIFYICONDATAA, *PNOTIFYICONDATAA;
typedef struct _NOTIFYICONDATAW {
        DWORD cbSize;
        HWND hWnd;
        UINT uID;
        UINT uFlags;
        UINT uCallbackMessage;
        HICON hIcon;
        WCHAR  szTip[64];
} NOTIFYICONDATAW, *PNOTIFYICONDATAW;
#ifdef UNICODE
typedef NOTIFYICONDATAW NOTIFYICONDATA;
typedef PNOTIFYICONDATAW PNOTIFYICONDATA;
#else
typedef NOTIFYICONDATAA NOTIFYICONDATA;
typedef PNOTIFYICONDATAA PNOTIFYICONDATA;
#endif // UNICODE


#define NIM_ADD         0x00000000
#define NIM_MODIFY      0x00000001
#define NIM_DELETE      0x00000002

#define NIF_MESSAGE     0x00000001
#define NIF_ICON        0x00000002
#define NIF_TIP         0x00000004

WINSHELLAPI BOOL WINAPI Shell_NotifyIconA(DWORD dwMessage, PNOTIFYICONDATAA lpData);
WINSHELLAPI BOOL WINAPI Shell_NotifyIconW(DWORD dwMessage, PNOTIFYICONDATAW lpData);
#ifdef UNICODE
#define Shell_NotifyIcon  Shell_NotifyIconW
#else
#define Shell_NotifyIcon  Shell_NotifyIconA
#endif // !UNICODE

////
//// End Tray Notification Icons
////



////
//// Begin SHGetFileInfo
////

/*
 * The SHGetFileInfo API provides an easy way to get attributes
 * for a file given a pathname.
 *
 *   PARAMETERS
 *
 *     pszPath              file name to get info about
 *     dwFileAttributes     file attribs, only used with SHGFI_USEFILEATTRIBUTES
 *     psfi                 place to return file info
 *     cbFileInfo           size of structure
 *     uFlags               flags
 *
 *   RETURN
 *     TRUE if things worked
 */

typedef struct _SHFILEINFOA
{
        HICON       hIcon;                      // out: icon
        int         iIcon;                      // out: icon index
        DWORD       dwAttributes;               // out: SFGAO_ flags
        CHAR        szDisplayName[MAX_PATH];    // out: display name (or path)
        CHAR        szTypeName[80];             // out: type name
} SHFILEINFOA;
typedef struct _SHFILEINFOW
{
        HICON       hIcon;                      // out: icon
        int         iIcon;                      // out: icon index
        DWORD       dwAttributes;               // out: SFGAO_ flags
        WCHAR       szDisplayName[MAX_PATH];    // out: display name (or path)
        WCHAR       szTypeName[80];             // out: type name
} SHFILEINFOW;
#ifdef UNICODE
typedef SHFILEINFOW SHFILEINFO;
#else
typedef SHFILEINFOA SHFILEINFO;
#endif // UNICODE

#define SHGFI_ICON              0x000000100     // get icon
#define SHGFI_DISPLAYNAME       0x000000200     // get display name
#define SHGFI_TYPENAME          0x000000400     // get type name
#define SHGFI_ATTRIBUTES        0x000000800     // get attributes
#define SHGFI_ICONLOCATION      0x000001000     // get icon location
#define SHGFI_EXETYPE           0x000002000     // return exe type
#define SHGFI_SYSICONINDEX      0x000004000     // get system icon index
#define SHGFI_LINKOVERLAY       0x000008000     // put a link overlay on icon
#define SHGFI_SELECTED          0x000010000     // show icon in selected state
#define SHGFI_LARGEICON         0x000000000     // get large icon
#define SHGFI_SMALLICON         0x000000001     // get small icon
#define SHGFI_OPENICON          0x000000002     // get open icon
#define SHGFI_SHELLICONSIZE     0x000000004     // get shell size icon
#define SHGFI_PIDL              0x000000008     // pszPath is a pidl
#define SHGFI_USEFILEATTRIBUTES 0x000000010     // use passed dwFileAttribute

WINSHELLAPI DWORD WINAPI SHGetFileInfoA(LPCSTR pszPath, DWORD dwFileAttributes, SHFILEINFOA FAR *psfi, UINT cbFileInfo, UINT uFlags);
WINSHELLAPI DWORD WINAPI SHGetFileInfoW(LPCWSTR pszPath, DWORD dwFileAttributes, SHFILEINFOW FAR *psfi, UINT cbFileInfo, UINT uFlags);
#ifdef UNICODE
#define SHGetFileInfo  SHGetFileInfoW
#else
#define SHGetFileInfo  SHGetFileInfoA
#endif // !UNICODE


WINSHELLAPI BOOL WINAPI SHGetNewLinkInfoA(LPCSTR pszLinkTo, LPCSTR pszDir, LPSTR pszName,
                             BOOL FAR * pfMustCopy, UINT uFlags);
WINSHELLAPI BOOL WINAPI SHGetNewLinkInfoW(LPCWSTR pszLinkTo, LPCWSTR pszDir, LPWSTR pszName,
                             BOOL FAR * pfMustCopy, UINT uFlags);
#ifdef UNICODE
#define SHGetNewLinkInfo  SHGetNewLinkInfoW
#else
#define SHGetNewLinkInfo  SHGetNewLinkInfoA
#endif // !UNICODE

#define SHGNLI_PIDL             0x000000001     // pszLinkTo is a pidl
#define SHGNLI_PREFIXNAME       0x000000002     // Make name "Shortcut to xxx"


////
//// End SHGetFileInfo
////




#endif /* WINVER >= 0x0400 */

#ifdef __cplusplus
}
#endif  /* __cplusplus */

#include <poppack.h>

#endif  /* _INC_SHELLAPI */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\inc32\RPCNDR.H ===
/*++

Copyright (c) 1992-1995 Microsoft Corporation

Module Name:

    rpcndr.h

Abstract:

    Definitions for stub data structures and prototypes of helper functions.

Environment:

    DOS, Win 3.X, and Win/NT.

--*/

#ifndef __RPCNDR_H__
#define __RPCNDR_H__

//
// Set the packing level for RPC structures for Dos, Windows and Mac.
//

#if defined(__RPC_DOS__) || defined(__RPC_WIN16__) || defined(__RPC_MAC__)
#pragma pack(2)
#endif

#if defined(__RPC_MAC__)
#define _MAC_
#endif

#include <rpcnsip.h>

#ifdef __cplusplus
extern "C" {
#endif

/****************************************************************************

     Network Computing Architecture (NCA) definition:

     Network Data Representation: (NDR) Label format:
     An unsigned long (32 bits) with the following layout:

     3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
     1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
    +---------------+---------------+---------------+-------+-------+
    |   Reserved    |   Reserved    |Floating point | Int   | Char  |
    |               |               |Representation | Rep.  | Rep.  |
    +---------------+---------------+---------------+-------+-------+

     Where

         Reserved:

             Must be zero (0) for NCA 1.5 and NCA 2.0.

         Floating point Representation is:

             0 - IEEE
             1 - VAX
             2 - Cray
             3 - IBM

         Int Rep. is Integer Representation:

             0 - Big Endian
             1 - Little Endian

         Char Rep. is Character Representation:

             0 - ASCII
             1 - EBCDIC

     The Microsoft Local Data Representation (for all platforms which are
     of interest currently is edefined below:

 ****************************************************************************/

#define NDR_CHAR_REP_MASK               (unsigned long)0X0000000FL
#define NDR_INT_REP_MASK                (unsigned long)0X000000F0L
#define NDR_FLOAT_REP_MASK              (unsigned long)0X0000FF00L

#define NDR_LITTLE_ENDIAN               (unsigned long)0X00000010L
#define NDR_BIG_ENDIAN                  (unsigned long)0X00000000L

#define NDR_IEEE_FLOAT                  (unsigned long)0X00000000L
#define NDR_VAX_FLOAT                   (unsigned long)0X00000100L

#define NDR_ASCII_CHAR                  (unsigned long)0X00000000L
#define NDR_EBCDIC_CHAR                 (unsigned long)0X00000001L

#if defined(__RPC_MAC__)
#define NDR_LOCAL_DATA_REPRESENTATION   (unsigned long)0X00000000L
#define NDR_LOCAL_ENDIAN                NDR_BIG_ENDIAN
#else
#define NDR_LOCAL_DATA_REPRESENTATION   (unsigned long)0X00000010L
#define NDR_LOCAL_ENDIAN                NDR_LITTLE_ENDIAN
#endif

/****************************************************************************
 *  Other MIDL base types / predefined types:
 ****************************************************************************/

#define small char
typedef unsigned char byte;
typedef unsigned char boolean;

#ifndef _HYPER_DEFINED
#define _HYPER_DEFINED

#if !defined(__RPC_DOS__) && !defined(__RPC_WIN16__) && !defined(__RPC_MAC__) && (!defined(_M_IX86) || (defined(_INTEGRAL_MAX_BITS) && _INTEGRAL_MAX_BITS >= 64))
#define  hyper           __int64
#define MIDL_uhyper  unsigned __int64
#else
typedef double  hyper;
typedef double MIDL_uhyper;
#endif

#endif // _HYPER_DEFINED

#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif

#ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif

#ifdef __RPC_DOS__
#define __RPC_CALLEE       __far __pascal
#endif

#ifdef __RPC_WIN16__
#define __RPC_CALLEE       __far __pascal __export
#endif

#ifdef __RPC_WIN32__
#if   (_MSC_VER >= 800) || defined(_STDCALL_SUPPORTED)
#define __RPC_CALLEE       __stdcall
#else
#define __RPC_CALLEE
#endif
#endif

#ifdef __RPC_MAC__
#define __RPC_CALLEE __far
#endif

#ifndef __MIDL_USER_DEFINED
#define midl_user_allocate MIDL_user_allocate
#define midl_user_free     MIDL_user_free
#define __MIDL_USER_DEFINED
#endif

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void             __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

#ifdef __RPC_WIN16__
#define RPC_VAR_ENTRY __export __cdecl
#else
#define RPC_VAR_ENTRY __cdecl
#endif


/* winnt only */
#if defined(_M_MRX000) || defined(_M_IX86) || defined(_M_ALPHA)
#define __MIDL_DECLSPEC_DLLIMPORT   __declspec(dllimport)
#define __MIDL_DECLSPEC_DLLEXPORT   __declspec(dllexport)
#else
#define __MIDL_DECLSPEC_DLLIMPORT
#define __MIDL_DECLSPEC_DLLEXPORT
#endif

/****************************************************************************
 * Context handle management related definitions:
 *
 * Client and Server Contexts. 
 *
 ****************************************************************************/

typedef void __RPC_FAR * NDR_CCONTEXT;

typedef struct
    {
    void __RPC_FAR * pad[2];
    void __RPC_FAR * userContext;
    } __RPC_FAR * NDR_SCONTEXT;

#define NDRSContextValue(hContext) (&(hContext)->userContext)

#define cbNDRContext 20         /* size of context on WIRE */

typedef void (__RPC_USER __RPC_FAR * NDR_RUNDOWN)(void __RPC_FAR * context);

typedef struct _SCONTEXT_QUEUE {
    unsigned long   NumberOfObjects;
    NDR_SCONTEXT  * ArrayOfObjects;
    } SCONTEXT_QUEUE, __RPC_FAR * PSCONTEXT_QUEUE;

RPC_BINDING_HANDLE RPC_ENTRY
NDRCContextBinding (
    IN NDR_CCONTEXT CContext
    );

void RPC_ENTRY
NDRCContextMarshall (
        IN  NDR_CCONTEXT CContext,
        OUT void __RPC_FAR *pBuff
        );

void RPC_ENTRY
NDRCContextUnmarshall (
        OUT NDR_CCONTEXT __RPC_FAR *pCContext,
        IN  RPC_BINDING_HANDLE hBinding,
        IN  void __RPC_FAR *pBuff,
        IN  unsigned long DataRepresentation
        );

void RPC_ENTRY
NDRSContextMarshall (
        IN  NDR_SCONTEXT CContext,
        OUT void __RPC_FAR *pBuff,
        IN  NDR_RUNDOWN userRunDownIn
        );

NDR_SCONTEXT RPC_ENTRY
NDRSContextUnmarshall (
    IN  void __RPC_FAR *pBuff,
    IN  unsigned long DataRepresentation
    );

void RPC_ENTRY
RpcSsDestroyClientContext (
    IN void __RPC_FAR * __RPC_FAR * ContextHandle
    );


/****************************************************************************
    NDR conversion related definitions.
 ****************************************************************************/

#define byte_from_ndr(source, target) \
    { \
    *(target) = *(*(char __RPC_FAR * __RPC_FAR *)&(source)->Buffer)++; \
    }

#define byte_array_from_ndr(Source, LowerIndex, UpperIndex, Target) \
    { \
    NDRcopy ( \
        (((char __RPC_FAR *)(Target))+(LowerIndex)), \
        (Source)->Buffer, \
        (unsigned int)((UpperIndex)-(LowerIndex))); \
    *(unsigned long __RPC_FAR *)&(Source)->Buffer += ((UpperIndex)-(LowerIndex)); \
    }

#define boolean_from_ndr(source, target) \
    { \
    *(target) = *(*(char __RPC_FAR * __RPC_FAR *)&(source)->Buffer)++; \
    }

#define boolean_array_from_ndr(Source, LowerIndex, UpperIndex, Target) \
    { \
    NDRcopy ( \
        (((char __RPC_FAR *)(Target))+(LowerIndex)), \
        (Source)->Buffer, \
        (unsigned int)((UpperIndex)-(LowerIndex))); \
    *(unsigned long __RPC_FAR *)&(Source)->Buffer += ((UpperIndex)-(LowerIndex)); \
    }

#define small_from_ndr(source, target) \
    { \
    *(target) = *(*(char __RPC_FAR * __RPC_FAR *)&(source)->Buffer)++; \
    }

#define small_from_ndr_temp(source, target, format) \
    { \
    *(target) = *(*(char __RPC_FAR * __RPC_FAR *)(source))++; \
    }

#define small_array_from_ndr(Source, LowerIndex, UpperIndex, Target) \
    { \
    NDRcopy ( \
        (((char __RPC_FAR *)(Target))+(LowerIndex)), \
        (Source)->Buffer, \
        (unsigned int)((UpperIndex)-(LowerIndex))); \
    *(unsigned long __RPC_FAR *)&(Source)->Buffer += ((UpperIndex)-(LowerIndex)); \
    }

/****************************************************************************
    Platform specific mapping of c-runtime functions.
 ****************************************************************************/

#ifdef __RPC_DOS__
#define MIDL_ascii_strlen(string) \
    _fstrlen(string)
#define MIDL_ascii_strcpy(target,source) \
    _fstrcpy(target,source)
#define MIDL_memset(s,c,n) \
    _fmemset(s,c,n)
#endif

#ifdef __RPC_WIN16__
#define MIDL_ascii_strlen(string) \
    _fstrlen(string)
#define MIDL_ascii_strcpy(target,source) \
    _fstrcpy(target,source)
#define MIDL_memset(s,c,n) \
    _fmemset(s,c,n)
#endif

#if defined(__RPC_WIN32__) || defined(__RPC_MAC__)
#define MIDL_ascii_strlen(string) \
    strlen(string)
#define MIDL_ascii_strcpy(target,source) \
    strcpy(target,source)
#define MIDL_memset(s,c,n) \
    memset(s,c,n)
#endif

/****************************************************************************
    Ndr Library helper function prototypes for MIDL 1.0 ndr functions.
 ****************************************************************************/

void RPC_ENTRY
NDRcopy (
    IN void __RPC_FAR *pTarget,
    IN void __RPC_FAR *pSource,
    IN unsigned int size
    );

size_t RPC_ENTRY
MIDL_wchar_strlen (
    IN wchar_t __RPC_FAR *   s
    );

void RPC_ENTRY
MIDL_wchar_strcpy (
    OUT void __RPC_FAR *     t,
    IN wchar_t __RPC_FAR *   s
    );

void RPC_ENTRY
char_from_ndr (
    IN OUT PRPC_MESSAGE                           SourceMessage,
    OUT unsigned char __RPC_FAR *                 Target
    );

void RPC_ENTRY
char_array_from_ndr (
    IN OUT PRPC_MESSAGE                           SourceMessage,
    IN unsigned long                              LowerIndex,
    IN unsigned long                              UpperIndex,
    OUT unsigned char __RPC_FAR *                 Target
    );

void RPC_ENTRY
short_from_ndr (
    IN OUT PRPC_MESSAGE                           source,
    OUT unsigned short __RPC_FAR *                target
    );

void RPC_ENTRY
short_array_from_ndr(
    IN OUT PRPC_MESSAGE                           SourceMessage,
    IN unsigned long                              LowerIndex,
    IN unsigned long                              UpperIndex,
    OUT unsigned short __RPC_FAR *                Target
    );

void RPC_ENTRY
short_from_ndr_temp (
    IN OUT unsigned char __RPC_FAR * __RPC_FAR *  source,
    OUT unsigned short __RPC_FAR *                target,
    IN unsigned long                              format
    );

void RPC_ENTRY
long_from_ndr (
    IN OUT PRPC_MESSAGE                           source,
    OUT unsigned long __RPC_FAR *                 target
    );

void RPC_ENTRY
long_array_from_ndr(
    IN OUT PRPC_MESSAGE                           SourceMessage,
    IN unsigned long                              LowerIndex,
    IN unsigned long                              UpperIndex,
    OUT unsigned long __RPC_FAR *                 Target
    );

void RPC_ENTRY
long_from_ndr_temp (
    IN OUT unsigned char __RPC_FAR * __RPC_FAR *  source,
    OUT unsigned long __RPC_FAR *                 target,
    IN unsigned long                              format
    );

void RPC_ENTRY
enum_from_ndr(
    IN OUT PRPC_MESSAGE                           SourceMessage,
    OUT unsigned int __RPC_FAR *                  Target
    );

void RPC_ENTRY
float_from_ndr (
    IN OUT PRPC_MESSAGE                           SourceMessage,
    OUT void __RPC_FAR *                          Target
    );

void RPC_ENTRY
float_array_from_ndr (
    IN OUT PRPC_MESSAGE                           SourceMessage,
    IN unsigned long                              LowerIndex,
    IN unsigned long                              UpperIndex,
    OUT void __RPC_FAR *                          Target
    );

void RPC_ENTRY
double_from_ndr (
    IN OUT PRPC_MESSAGE                           SourceMessage,
    OUT void __RPC_FAR *                          Target
    );

void RPC_ENTRY
double_array_from_ndr (
    IN OUT PRPC_MESSAGE                           SourceMessage,
    IN unsigned long                              LowerIndex,
    IN unsigned long                              UpperIndex,
    OUT void __RPC_FAR *                          Target
    );

void RPC_ENTRY
hyper_from_ndr (
    IN OUT PRPC_MESSAGE                           source,
    OUT    hyper __RPC_FAR *                      target
    );

void RPC_ENTRY
hyper_array_from_ndr(
    IN OUT PRPC_MESSAGE                           SourceMessage,
    IN unsigned long                              LowerIndex,
    IN unsigned long                              UpperIndex,
    OUT          hyper __RPC_FAR *                Target
    );

void RPC_ENTRY
hyper_from_ndr_temp (
    IN OUT unsigned char __RPC_FAR * __RPC_FAR *  source,
    OUT             hyper __RPC_FAR *             target,
    IN   unsigned   long                          format
    );

void RPC_ENTRY
data_from_ndr (
    PRPC_MESSAGE                                  source,
    void __RPC_FAR *                              target,
    char __RPC_FAR *                              format,
    unsigned char                                 MscPak
    );

void RPC_ENTRY
data_into_ndr (
    void __RPC_FAR *                              source,
    PRPC_MESSAGE                                  target,
    char __RPC_FAR *                              format,
    unsigned char                                 MscPak
    );

void RPC_ENTRY
tree_into_ndr (
    void __RPC_FAR *                              source,
    PRPC_MESSAGE                                  target,
    char __RPC_FAR *                              format,
    unsigned char                                 MscPak
    );

void RPC_ENTRY
data_size_ndr (
    void __RPC_FAR *                              source,
    PRPC_MESSAGE                                  target,
    char __RPC_FAR *                              format,
    unsigned char                                 MscPak
    );

void RPC_ENTRY
tree_size_ndr (
    void __RPC_FAR *                              source,
    PRPC_MESSAGE                                  target,
    char __RPC_FAR *                              format,
    unsigned char                                 MscPak
    );

void RPC_ENTRY
tree_peek_ndr (
    PRPC_MESSAGE                                  source,
    unsigned char __RPC_FAR * __RPC_FAR *         buffer,
    char __RPC_FAR *                              format,
    unsigned char                                 MscPak
    );

void __RPC_FAR * RPC_ENTRY
midl_allocate (
    size_t      size
    );

/****************************************************************************
    MIDL 2.0 ndr definitions.
 ****************************************************************************/

typedef unsigned long error_status_t;

#define _midl_ma1( p, cast )    *(*( cast **)&p)++
#define _midl_ma2( p, cast )    *(*( cast **)&p)++
#define _midl_ma4( p, cast )    *(*( cast **)&p)++
#define _midl_ma8( p, cast )    *(*( cast **)&p)++

#define _midl_unma1( p, cast )  *(( cast *)p)++
#define _midl_unma2( p, cast )  *(( cast *)p)++
#define _midl_unma3( p, cast )  *(( cast *)p)++
#define _midl_unma4( p, cast )  *(( cast *)p)++

// Some alignment specific macros.


#define _midl_fa2( p )          (p = (RPC_BUFPTR )((unsigned long)(p+1) & 0xfffffffe))
#define _midl_fa4( p )          (p = (RPC_BUFPTR )((unsigned long)(p+3) & 0xfffffffc))
#define _midl_fa8( p )          (p = (RPC_BUFPTR )((unsigned long)(p+7) & 0xfffffff8))

#define _midl_addp( p, n )      (p += n)

// Marshalling macros

#define _midl_marsh_lhs( p, cast )  *(*( cast **)&p)++
#define _midl_marsh_up( mp, p )     *(*(unsigned long **)&mp)++ = (unsigned long)p
#define _midl_advmp( mp )           *(*(unsigned long **)&mp)++
#define _midl_unmarsh_up( p )       (*(*(unsigned long **)&p)++) 


////////////////////////////////////////////////////////////////////////////
// Ndr macros.
////////////////////////////////////////////////////////////////////////////

#define NdrMarshConfStringHdr( p, s, l )    (_midl_ma4( p, unsigned long) = s, \
                                            _midl_ma4( p, unsigned long) = 0, \
                                            _midl_ma4( p, unsigned long) = l)

#define NdrUnMarshConfStringHdr(p, s, l)    ((s=_midl_unma4(p,unsigned long),\
                                            (_midl_addp(p,4)),               \
                                            (l=_midl_unma4(p,unsigned long))
        
#define NdrMarshCCtxtHdl(pc,p)  (NDRCContextMarshall( (NDR_CCONTEXT)pc, p ),p+20)

#define NdrUnMarshCCtxtHdl(pc,p,h,drep) \
        (NDRCContextUnmarshall((NDR_CONTEXT)pc,h,p,drep), p+20)

#define NdrUnMarshSCtxtHdl(pc, p,drep)  (pc = NdrSContextUnMarshall(p,drep ))
    

#define NdrMarshSCtxtHdl(pc,p,rd)   (NdrSContextMarshall((NDR_SCONTEXT)pc,p, (NDR_RUNDOWN)rd)

#define NdrFieldOffset(s,f)     (long)(& (((s __RPC_FAR *)0)->f))
#define NdrFieldPad(s,f,p,t)    (NdrFieldOffset(s,f) - NdrFieldOffset(s,p) - sizeof(t))

#if defined(__RPC_MAC__)
#define NdrFcShort(s)   (unsigned char)(s >> 8), (unsigned char)(s & 0xff)
#define NdrFcLong(s)    (unsigned char)(s >> 24), (unsigned char)((s & 0x00ff0000) >> 16), \
                        (unsigned char)((s & 0x0000ff00) >> 8), (unsigned char)(s & 0xff)
#else
#define NdrFcShort(s)   (unsigned char)(s & 0xff), (unsigned char)(s >> 8)
#define NdrFcLong(s)    (unsigned char)(s & 0xff), (unsigned char)((s & 0x0000ff00) >> 8), \
                        (unsigned char)((s & 0x00ff0000) >> 16), (unsigned char)(s >> 24)
#endif //  Mac

/////////////////////////////////////////////////////////////////////////////
// Some stub helper functions.
/////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////
// Stub helper structures.
////////////////////////////////////////////////////////////////////////////

struct _MIDL_STUB_MESSAGE;
struct _MIDL_STUB_DESC;
struct _FULL_PTR_XLAT_TABLES;

typedef unsigned char __RPC_FAR * RPC_BUFPTR;
typedef unsigned long             RPC_LENGTH;

// Expression evaluation callback routine prototype.
typedef void (__RPC_USER __RPC_FAR * EXPR_EVAL)( struct _MIDL_STUB_MESSAGE __RPC_FAR * );

typedef const unsigned char __RPC_FAR * PFORMAT_STRING;

/*
 * Multidimensional conformant/varying array struct.
 */
typedef struct 
    {
    long                            Dimension;

    /* These fields MUST be (unsigned long *) */
    unsigned long __RPC_FAR *       BufferConformanceMark;
    unsigned long __RPC_FAR *       BufferVarianceMark;

    /* Count arrays, used for top level arrays in -Os stubs */
    unsigned long __RPC_FAR *       MaxCountArray;
    unsigned long __RPC_FAR *       OffsetArray;
    unsigned long __RPC_FAR *       ActualCountArray;
    } ARRAY_INFO, __RPC_FAR *PARRAY_INFO;

/*
 * MIDL Stub Message
 */
#if !defined(__RPC_DOS__) && !defined(__RPC_WIN16__) && !defined(__RPC_MAC__)
#include <pshpack4.h>
#endif 

typedef struct _MIDL_STUB_MESSAGE
    {
    /* RPC message structure. */
    PRPC_MESSAGE                RpcMsg;

    /* Pointer into RPC message buffer. */
    unsigned char __RPC_FAR *   Buffer;

    /*
     * These are used internally by the Ndr routines to mark the beginning
     * and end of an incoming RPC buffer.
     */
    unsigned char __RPC_FAR *   BufferStart;
    unsigned char __RPC_FAR *   BufferEnd;

    /*
     * Used internally by the Ndr routines as a place holder in the buffer.
     * On the marshalling side it's used to mark the location where conformance
     * size should be marshalled.
     * On the unmarshalling side it's used to mark the location in the buffer
     * used during pointer unmarshalling to base pointer offsets off of.
     */
    unsigned char __RPC_FAR *   BufferMark;

    /* Set by the buffer sizing routines. */
    unsigned long               BufferLength;

    /* Set by the memory sizing routines. */
    unsigned long               MemorySize;

    /* Pointer to user memory. */
    unsigned char __RPC_FAR *   Memory;

    /* Is the Ndr routine begin called from a client side stub. */
    int                         IsClient;

    /* Can the buffer be re-used for memory on unmarshalling. */
    int                         ReuseBuffer;    

    /* Holds the current pointer to an allocate all nodes memory block. */
    unsigned char __RPC_FAR *   AllocAllNodesMemory;

    /* Used for debugging asserts only, remove later. */
    unsigned char __RPC_FAR *   AllocAllNodesMemoryEnd;

    /* 
     * Stuff needed while handling complex structures 
     */

    /* Ignore imbeded pointers while computing buffer or memory sizes. */
    int                         IgnoreEmbeddedPointers;

    /* 
     * This marks the location in the buffer where pointees of a complex
     * struct reside.
     */
    unsigned char __RPC_FAR *   PointerBufferMark;

    /*
     * Used to catch errors in SendReceive.
     */
    unsigned char               fBufferValid;

    /*
     * Obsolete unused field (formerly MaxContextHandleNumber).
     */
    unsigned char               Unused;

    /* 
     * Used internally by the Ndr routines.  Holds the max counts for 
     * a conformant array.
     */
    unsigned long               MaxCount;

    /* 
     * Used internally by the Ndr routines.  Holds the offsets for a varying
     * array.
     */
    unsigned long               Offset;

    /* 
     * Used internally by the Ndr routines.  Holds the actual counts for 
     * a varying array.
     */
    unsigned long               ActualCount;

    /* Allocation and Free routine to be used by the Ndr routines. */
    void __RPC_FAR *    (__RPC_FAR __RPC_API * pfnAllocate)(size_t);
    void                (__RPC_FAR __RPC_API * pfnFree)(void __RPC_FAR *);

    /*
     * Top of parameter stack.  Used for "single call" stubs during marshalling 
     * to hold the beginning of the parameter list on the stack.  Needed to 
     * extract parameters which hold attribute values for top level arrays and 
     * pointers. 
     */
    unsigned char __RPC_FAR *       StackTop;

    /*
     *  Fields used for the transmit_as and represent_as objects.
     *  For represent_as the mapping is: presented=local, transmit=named.
     */
    unsigned char __RPC_FAR *       pPresentedType;
    unsigned char __RPC_FAR *       pTransmitType;

    /* 
     * When we first construct a binding on the client side, stick it
     * in the rpcmessage and later call RpcGetBuffer, the handle field
     * in the rpcmessage is changed. That's fine except that we need to
     * have that original handle for use in unmarshalling context handles
     * (the second argument in NDRCContextUnmarshall to be exact). So
     * stash the contructed handle here and extract it when needed.
     */
    handle_t                        SavedHandle;

    /*
     * Pointer back to the stub descriptor.  Use this to get all handle info.
     */
    const struct _MIDL_STUB_DESC __RPC_FAR *    StubDesc;

    /*
     * Full pointer stuff.
     */
    struct _FULL_PTR_XLAT_TABLES __RPC_FAR *    FullPtrXlatTables;

    unsigned long                   FullPtrRefId;

    /*
     * flags
     */

    int                             fCheckBounds;

    int                             fInDontFree       :1;
    int                             fDontCallFreeInst :1;
    int                             fInOnlyParam      :1;
    int                             fHasReturn        :1;

    unsigned long                   dwDestContext;
    void __RPC_FAR *                pvDestContext;

    NDR_SCONTEXT *                  SavedContextHandles;

    long                            ParamNumber;

    struct IRpcChannelBuffer __RPC_FAR *    pRpcChannelBuffer;

    PARRAY_INFO                     pArrayInfo;

    /* 
     * This is where the Beta2 stub message ends.
     */

    unsigned long __RPC_FAR *       SizePtrCountArray;
    unsigned long __RPC_FAR *       SizePtrOffsetArray;
    unsigned long __RPC_FAR *       SizePtrLengthArray;

    /*
     * Interpreter argument queue.  Used on server side only.
     */
    void __RPC_FAR *                pArgQueue;

    unsigned long                   dwStubPhase;

    /*
     * Reserved for future use.
     */
    
    unsigned long                   Reserved[5];

    } MIDL_STUB_MESSAGE, __RPC_FAR *PMIDL_STUB_MESSAGE;

#if !defined(__RPC_DOS__) && !defined(__RPC_WIN16__) && !defined(__RPC_MAC__)
#include <poppack.h>
#endif 

/*
 * Generic handle bind/unbind routine pair.
 */
typedef void __RPC_FAR * 
        (__RPC_FAR __RPC_API * GENERIC_BINDING_ROUTINE)
        (void __RPC_FAR *);
typedef void             
        (__RPC_FAR __RPC_API * GENERIC_UNBIND_ROUTINE)
        (void __RPC_FAR *, unsigned char __RPC_FAR *);

typedef struct _GENERIC_BINDING_ROUTINE_PAIR
    {
    GENERIC_BINDING_ROUTINE     pfnBind;
    GENERIC_UNBIND_ROUTINE      pfnUnbind;
    } GENERIC_BINDING_ROUTINE_PAIR, __RPC_FAR *PGENERIC_BINDING_ROUTINE_PAIR;

typedef struct __GENERIC_BINDING_INFO 
    {
    void __RPC_FAR *            pObj;
    unsigned int                Size;
    GENERIC_BINDING_ROUTINE     pfnBind;
    GENERIC_UNBIND_ROUTINE      pfnUnbind;
    } GENERIC_BINDING_INFO, __RPC_FAR *PGENERIC_BINDING_INFO;

// typedef EXPR_EVAL - see above

typedef void (__RPC_FAR __RPC_USER * XMIT_HELPER_ROUTINE)( PMIDL_STUB_MESSAGE );

typedef struct _XMIT_ROUTINE_QUINTUPLE
    {
    XMIT_HELPER_ROUTINE     pfnTranslateToXmit;
    XMIT_HELPER_ROUTINE     pfnTranslateFromXmit;
    XMIT_HELPER_ROUTINE     pfnFreeXmit;
    XMIT_HELPER_ROUTINE     pfnFreeInst;
    } XMIT_ROUTINE_QUINTUPLE, __RPC_FAR *PXMIT_ROUTINE_QUINTUPLE;

typedef struct _MALLOC_FREE_STRUCT
    {
    void __RPC_FAR *	(__RPC_FAR __RPC_USER * pfnAllocate)(size_t);
    void                (__RPC_FAR __RPC_USER * pfnFree)(void __RPC_FAR *);
    } MALLOC_FREE_STRUCT;

typedef struct _COMM_FAULT_OFFSETS
    {
    short       CommOffset;
    short       FaultOffset;
    } COMM_FAULT_OFFSETS;

/*
 * MIDL Stub Descriptor
 */
typedef struct _MIDL_STUB_DESC
    {

    void __RPC_FAR *    RpcInterfaceInformation;

    void __RPC_FAR *    (__RPC_FAR __RPC_API * pfnAllocate)(size_t);
    void                (__RPC_FAR __RPC_API * pfnFree)(void __RPC_FAR *);

    union
        {
        handle_t __RPC_FAR *            pAutoHandle;
        handle_t __RPC_FAR *            pPrimitiveHandle;
        PGENERIC_BINDING_INFO           pGenericBindingInfo;
        } IMPLICIT_HANDLE_INFO;

    const NDR_RUNDOWN __RPC_FAR *                   apfnNdrRundownRoutines;
    const GENERIC_BINDING_ROUTINE_PAIR __RPC_FAR *  aGenericBindingRoutinePairs;

    const EXPR_EVAL __RPC_FAR *                     apfnExprEval;

    const XMIT_ROUTINE_QUINTUPLE __RPC_FAR *        aXmitQuintuple;

    const unsigned char __RPC_FAR *             pFormatTypes;

    int                                 fCheckBounds;

    /* Ndr library version. */
    unsigned long                       Version;

    /*
     * Reserved for future use.
     */

    MALLOC_FREE_STRUCT __RPC_FAR *      pMallocFreeStruct;

    long                                MIDLVersion;

    const COMM_FAULT_OFFSETS __RPC_FAR *    CommFaultOffsets;

    } MIDL_STUB_DESC; 

typedef const MIDL_STUB_DESC __RPC_FAR * PMIDL_STUB_DESC;

typedef void __RPC_FAR * PMIDL_XMIT_TYPE;

/*
 * MIDL Stub Format String.  This is a const in the stub.
 */
#if !defined( RC_INVOKED )
#pragma warning( disable:4200 )
#endif
typedef struct _MIDL_FORMAT_STRING
    {
    short               Pad;
    unsigned char       Format[];
    } MIDL_FORMAT_STRING;
#if !defined( RC_INVOKED )
#pragma warning( default:4200 )
#endif

/*
 * Stub thunk used for some interpreted server stubs.
 */
typedef void (__RPC_FAR __RPC_API * STUB_THUNK)( PMIDL_STUB_MESSAGE );

typedef long (__RPC_FAR __RPC_API * SERVER_ROUTINE)();

/*
 * Server Interpreter's information strucuture.
 */ 
typedef struct  _MIDL_SERVER_INFO_ 
    {
    PMIDL_STUB_DESC             pStubDesc;
    const SERVER_ROUTINE *      DispatchTable;
    PFORMAT_STRING              ProcString;
    const unsigned short *      FmtStringOffset;
    const STUB_THUNK *          ThunkTable;
    } MIDL_SERVER_INFO, *PMIDL_SERVER_INFO;

/*
 * Stubless object proxy information structure.
 */
typedef struct _MIDL_STUBLESS_PROXY_INFO 
    {
    PMIDL_STUB_DESC                     pStubDesc;
    PFORMAT_STRING                      ProcFormatString;
    const unsigned short __RPC_FAR *    FormatStringOffset;
    } MIDL_STUBLESS_PROXY_INFO;

typedef MIDL_STUBLESS_PROXY_INFO __RPC_FAR * PMIDL_STUBLESS_PROXY_INFO;

/* 
 * This is the return value from NdrClientCall.
 */
typedef union _CLIENT_CALL_RETURN 
    {
    void __RPC_FAR *        Pointer;
    long                    Simple;
    } CLIENT_CALL_RETURN;

/*
 * Full pointer data structures.
 */

typedef enum 
        {
        XLAT_SERVER = 1,
        XLAT_CLIENT
        } XLAT_SIDE;

/*
 * Stores the translation for the conversion from a full pointer into it's
 * corresponding ref id.
 */
typedef struct _FULL_PTR_TO_REFID_ELEMENT
    {
    struct _FULL_PTR_TO_REFID_ELEMENT __RPC_FAR *  Next;

    void __RPC_FAR *            Pointer;
    unsigned long       RefId;
    unsigned char       State;
    } FULL_PTR_TO_REFID_ELEMENT, __RPC_FAR *PFULL_PTR_TO_REFID_ELEMENT;

/*
 * Full pointer translation tables.
 */
typedef struct _FULL_PTR_XLAT_TABLES
    {
    /*
     * Ref id to pointer translation information.
     */
    struct
        {
        void __RPC_FAR *__RPC_FAR *             XlatTable;
        unsigned char __RPC_FAR *     StateTable;
        unsigned long       NumberOfEntries;
        } RefIdToPointer;

    /*
     * Pointer to ref id translation information.
     */
    struct
        {
        PFULL_PTR_TO_REFID_ELEMENT __RPC_FAR *  XlatTable;
        unsigned long                   NumberOfBuckets;
        unsigned long                   HashMask;
        } PointerToRefId;

    /*
     * Next ref id to use.
     */
    unsigned long           NextRefId;

    /*
     * Keep track of the translation size we're handling : server or client.
     * This tells us when we have to do reverse translations when we insert
     * new translations.  On the server we must insert a pointer-to-refid 
     * translation whenever we insert a refid-to-pointer translation, and 
     * vica versa for the client.
     */
    XLAT_SIDE               XlatSide;
    } FULL_PTR_XLAT_TABLES, __RPC_FAR *PFULL_PTR_XLAT_TABLES;

/***************************************************************************
 ** New MIDL 2.0 Ndr routine templates
 ***************************************************************************/

/*
 * Marshall routines
 */

void RPC_ENTRY
NdrSimpleTypeMarshall( 
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *                       pMemory, 
    unsigned char                       FormatChar   
    );

unsigned char __RPC_FAR * RPC_ENTRY
NdrPointerMarshall( 
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory, 
    PFORMAT_STRING                      pFormat   
    );

/* Structures */

unsigned char __RPC_FAR * RPC_ENTRY
NdrSimpleStructMarshall( 
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory, 
    PFORMAT_STRING                      pFormat   
    );

unsigned char __RPC_FAR * RPC_ENTRY
NdrConformantStructMarshall( 
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory, 
    PFORMAT_STRING                      pFormat   
    );

unsigned char __RPC_FAR * RPC_ENTRY
NdrConformantVaryingStructMarshall( 
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory, 
    PFORMAT_STRING                      pFormat   
    );

unsigned char __RPC_FAR * RPC_ENTRY
NdrHardStructMarshall( 
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory, 
    PFORMAT_STRING                      pFormat   
    );

unsigned char __RPC_FAR * RPC_ENTRY
NdrComplexStructMarshall( 
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory, 
    PFORMAT_STRING                      pFormat   
    );

/* Arrays */

unsigned char __RPC_FAR * RPC_ENTRY
NdrFixedArrayMarshall( 
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory, 
    PFORMAT_STRING                      pFormat   
    );

unsigned char __RPC_FAR * RPC_ENTRY
NdrConformantArrayMarshall( 
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory, 
    PFORMAT_STRING                      pFormat   
    );

unsigned char __RPC_FAR * RPC_ENTRY
NdrConformantVaryingArrayMarshall( 
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory, 
    PFORMAT_STRING                      pFormat   
    );

unsigned char __RPC_FAR * RPC_ENTRY
NdrVaryingArrayMarshall( 
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory, 
    PFORMAT_STRING                      pFormat   
    );

unsigned char __RPC_FAR * RPC_ENTRY
NdrComplexArrayMarshall( 
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory, 
    PFORMAT_STRING                      pFormat   
    );

/* Strings */

unsigned char __RPC_FAR * RPC_ENTRY
NdrNonConformantStringMarshall( 
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory, 
    PFORMAT_STRING                      pFormat   
    );

unsigned char __RPC_FAR * RPC_ENTRY
NdrConformantStringMarshall( 
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory, 
    PFORMAT_STRING                      pFormat   
    );

/* Unions */

unsigned char __RPC_FAR * RPC_ENTRY
NdrEncapsulatedUnionMarshall( 
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory, 
    PFORMAT_STRING                      pFormat   
    );

unsigned char __RPC_FAR * RPC_ENTRY
NdrNonEncapsulatedUnionMarshall( 
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory, 
    PFORMAT_STRING                      pFormat   
    );

/* Byte count pointer */

unsigned char __RPC_FAR * RPC_ENTRY
NdrByteCountPointerMarshall( 
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory, 
    PFORMAT_STRING                      pFormat   
    );

/* Transmit as and represent as*/

unsigned char __RPC_FAR * RPC_ENTRY
NdrXmitOrRepAsMarshall( 
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory, 
    PFORMAT_STRING                      pFormat   
    );

/* Cairo interface pointer */

unsigned char __RPC_FAR * RPC_ENTRY
NdrInterfacePointerMarshall( 
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory, 
    PFORMAT_STRING                      pFormat   
    );

/* Context handles */

void RPC_ENTRY
NdrClientContextMarshall( 
    PMIDL_STUB_MESSAGE    pStubMsg,
    NDR_CCONTEXT          ContextHandle,
    int                   fCheck 
    );

void RPC_ENTRY
NdrServerContextMarshall( 
    PMIDL_STUB_MESSAGE    pStubMsg,
    NDR_SCONTEXT          ContextHandle,
    NDR_RUNDOWN           RundownRoutine 
    );

/*
 * Unmarshall routines
 */

void RPC_ENTRY 
NdrSimpleTypeUnmarshall( 
    PMIDL_STUB_MESSAGE                  pStubMsg, 
    unsigned char __RPC_FAR *           pMemory, 
    unsigned char                       FormatChar
    );

unsigned char __RPC_FAR * RPC_ENTRY 
NdrPointerUnmarshall( 
    PMIDL_STUB_MESSAGE                      pStubMsg, 
    unsigned char __RPC_FAR * __RPC_FAR *   ppMemory, 
    PFORMAT_STRING                          pFormat,
    unsigned char                           fMustAlloc
    );

/* Structures */

unsigned char __RPC_FAR * RPC_ENTRY
NdrSimpleStructUnmarshall( 
    PMIDL_STUB_MESSAGE                      pStubMsg, 
    unsigned char __RPC_FAR * __RPC_FAR *   ppMemory, 
    PFORMAT_STRING                          pFormat,
    unsigned char                           fMustAlloc 
    );

unsigned char __RPC_FAR * RPC_ENTRY
NdrConformantStructUnmarshall( 
    PMIDL_STUB_MESSAGE                      pStubMsg, 
    unsigned char __RPC_FAR * __RPC_FAR *   ppMemory, 
    PFORMAT_STRING                          pFormat,
    unsigned char                           fMustAlloc 
    );

unsigned char __RPC_FAR * RPC_ENTRY
NdrConformantVaryingStructUnmarshall( 
    PMIDL_STUB_MESSAGE                      pStubMsg, 
    unsigned char __RPC_FAR * __RPC_FAR *   ppMemory, 
    PFORMAT_STRING                          pFormat,
    unsigned char                           fMustAlloc 
    );

unsigned char __RPC_FAR * RPC_ENTRY 
NdrHardStructUnmarshall( 
    PMIDL_STUB_MESSAGE                      pStubMsg, 
    unsigned char __RPC_FAR * __RPC_FAR *   ppMemory, 
    PFORMAT_STRING                          pFormat,
    unsigned char                           fMustAlloc 
    );

unsigned char __RPC_FAR * RPC_ENTRY 
NdrComplexStructUnmarshall( 
    PMIDL_STUB_MESSAGE                      pStubMsg, 
    unsigned char __RPC_FAR * __RPC_FAR *   ppMemory, 
    PFORMAT_STRING                          pFormat,
    unsigned char                           fMustAlloc 
    );

/* Arrays */

unsigned char __RPC_FAR * RPC_ENTRY
NdrFixedArrayUnmarshall( 
    PMIDL_STUB_MESSAGE                      pStubMsg, 
    unsigned char __RPC_FAR * __RPC_FAR *   ppMemory, 
    PFORMAT_STRING                          pFormat,
    unsigned char                           fMustAlloc 
    );

unsigned char __RPC_FAR * RPC_ENTRY
NdrConformantArrayUnmarshall( 
    PMIDL_STUB_MESSAGE                      pStubMsg, 
    unsigned char __RPC_FAR * __RPC_FAR *   ppMemory, 
    PFORMAT_STRING                          pFormat,
    unsigned char                           fMustAlloc 
    );

unsigned char __RPC_FAR * RPC_ENTRY
NdrConformantVaryingArrayUnmarshall( 
    PMIDL_STUB_MESSAGE                      pStubMsg, 
    unsigned char __RPC_FAR * __RPC_FAR *   ppMemory, 
    PFORMAT_STRING                          pFormat,
    unsigned char                           fMustAlloc 
    );

unsigned char __RPC_FAR * RPC_ENTRY
NdrVaryingArrayUnmarshall( 
    PMIDL_STUB_MESSAGE                      pStubMsg, 
    unsigned char __RPC_FAR * __RPC_FAR *   ppMemory, 
    PFORMAT_STRING                          pFormat,
    unsigned char                           fMustAlloc 
    );

unsigned char __RPC_FAR * RPC_ENTRY
NdrComplexArrayUnmarshall( 
    PMIDL_STUB_MESSAGE                      pStubMsg, 
    unsigned char __RPC_FAR * __RPC_FAR *   ppMemory, 
    PFORMAT_STRING                          pFormat,   
    unsigned char                           fMustAlloc 
    );

/* Strings */

unsigned char __RPC_FAR * RPC_ENTRY
NdrNonConformantStringUnmarshall( 
    PMIDL_STUB_MESSAGE                      pStubMsg, 
    unsigned char __RPC_FAR * __RPC_FAR *   ppMemory, 
    PFORMAT_STRING                          pFormat,
    unsigned char                           fMustAlloc 
    );

unsigned char __RPC_FAR * RPC_ENTRY
NdrConformantStringUnmarshall( 
    PMIDL_STUB_MESSAGE                      pStubMsg, 
    unsigned char __RPC_FAR * __RPC_FAR *   ppMemory, 
    PFORMAT_STRING                          pFormat,   
    unsigned char                           fMustAlloc 
    );

/* Unions */

unsigned char __RPC_FAR * RPC_ENTRY
NdrEncapsulatedUnionUnmarshall( 
    PMIDL_STUB_MESSAGE                      pStubMsg, 
    unsigned char __RPC_FAR * __RPC_FAR *   ppMemory, 
    PFORMAT_STRING                          pFormat,   
    unsigned char                           fMustAlloc 
    );

unsigned char __RPC_FAR * RPC_ENTRY
NdrNonEncapsulatedUnionUnmarshall( 
    PMIDL_STUB_MESSAGE                      pStubMsg, 
    unsigned char __RPC_FAR * __RPC_FAR *   ppMemory, 
    PFORMAT_STRING                          pFormat,   
    unsigned char                           fMustAlloc 
    );

/* Byte count pointer */

unsigned char __RPC_FAR * RPC_ENTRY 
NdrByteCountPointerUnmarshall( 
    PMIDL_STUB_MESSAGE                      pStubMsg, 
    unsigned char __RPC_FAR * __RPC_FAR *   ppMemory, 
    PFORMAT_STRING                          pFormat,   
    unsigned char                           fMustAlloc
    );

/* Transmit as and represent as*/

unsigned char __RPC_FAR * RPC_ENTRY 
NdrXmitOrRepAsUnmarshall( 
    PMIDL_STUB_MESSAGE                      pStubMsg, 
    unsigned char __RPC_FAR * __RPC_FAR *   ppMemory, 
    PFORMAT_STRING                          pFormat,   
    unsigned char                           fMustAlloc
    );

/* Cairo interface pointer */

unsigned char __RPC_FAR * RPC_ENTRY 
NdrInterfacePointerUnmarshall( 
    PMIDL_STUB_MESSAGE                      pStubMsg, 
    unsigned char __RPC_FAR * __RPC_FAR *   ppMemory, 
    PFORMAT_STRING                          pFormat,   
    unsigned char                           fMustAlloc
    );

/* Context handles */

void RPC_ENTRY
NdrClientContextUnmarshall( 
    PMIDL_STUB_MESSAGE          pStubMsg,
    NDR_CCONTEXT __RPC_FAR *    pContextHandle,
    RPC_BINDING_HANDLE          BindHandle 
    );

NDR_SCONTEXT RPC_ENTRY
NdrServerContextUnmarshall( 
    PMIDL_STUB_MESSAGE          pStubMsg 
    );

/*
 * Buffer sizing routines
 */

void RPC_ENTRY
NdrPointerBufferSize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory, 
    PFORMAT_STRING                      pFormat   
    );

/* Structures */

void RPC_ENTRY
NdrSimpleStructBufferSize( 
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory, 
    PFORMAT_STRING                      pFormat   
    );

void RPC_ENTRY 
NdrConformantStructBufferSize( 
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory, 
    PFORMAT_STRING                      pFormat   
    );

void RPC_ENTRY 
NdrConformantVaryingStructBufferSize( 
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory, 
    PFORMAT_STRING                      pFormat   
    );

void RPC_ENTRY 
NdrHardStructBufferSize( 
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory, 
    PFORMAT_STRING                      pFormat   
    );

void RPC_ENTRY 
NdrComplexStructBufferSize( 
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory, 
    PFORMAT_STRING                      pFormat   
    );

/* Arrays */

void RPC_ENTRY 
NdrFixedArrayBufferSize( 
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory, 
    PFORMAT_STRING                      pFormat   
    );

void RPC_ENTRY 
NdrConformantArrayBufferSize( 
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory, 
    PFORMAT_STRING                      pFormat   
    );

void RPC_ENTRY 
NdrConformantVaryingArrayBufferSize( 
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory, 
    PFORMAT_STRING                      pFormat   
    );

void RPC_ENTRY 
NdrVaryingArrayBufferSize( 
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory, 
    PFORMAT_STRING                      pFormat   
    );

void RPC_ENTRY
NdrComplexArrayBufferSize( 
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory, 
    PFORMAT_STRING                      pFormat   
    );

/* Strings */

void RPC_ENTRY 
NdrConformantStringBufferSize( 
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory, 
    PFORMAT_STRING                      pFormat   
    );

void RPC_ENTRY 
NdrNonConformantStringBufferSize( 
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory, 
    PFORMAT_STRING                      pFormat   
    );

/* Unions */

void RPC_ENTRY 
NdrEncapsulatedUnionBufferSize( 
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory, 
    PFORMAT_STRING                      pFormat   
    );

void RPC_ENTRY 
NdrNonEncapsulatedUnionBufferSize( 
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory, 
    PFORMAT_STRING                      pFormat   
    );

/* Byte count pointer */

void RPC_ENTRY
NdrByteCountPointerBufferSize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory, 
    PFORMAT_STRING                      pFormat   
    );

/* Transmit as and represent as*/

void RPC_ENTRY
NdrXmitOrRepAsBufferSize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory, 
    PFORMAT_STRING                      pFormat   
    );

/* Cairo Interface pointer */

void RPC_ENTRY
NdrInterfacePointerBufferSize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory, 
    PFORMAT_STRING                      pFormat   
    );

// Context Handle size
//
void RPC_ENTRY
NdrContextHandleSize(
    PMIDL_STUB_MESSAGE          pStubMsg,
    unsigned char __RPC_FAR *           pMemory, 
    PFORMAT_STRING                      pFormat   
    );

/*
 * Memory sizing routines
 */

unsigned long RPC_ENTRY
NdrPointerMemorySize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat
    );

/* Structures */

unsigned long RPC_ENTRY
NdrSimpleStructMemorySize( 
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat
    );

unsigned long RPC_ENTRY 
NdrConformantStructMemorySize( 
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat
    );

unsigned long RPC_ENTRY 
NdrConformantVaryingStructMemorySize( 
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat
    );

unsigned long RPC_ENTRY 
NdrHardStructMemorySize( 
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat
    );

unsigned long RPC_ENTRY 
NdrComplexStructMemorySize( 
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat
    );

/* Arrays */

unsigned long RPC_ENTRY 
NdrFixedArrayMemorySize( 
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat
    );

unsigned long RPC_ENTRY 
NdrConformantArrayMemorySize( 
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat
    );

unsigned long RPC_ENTRY 
NdrConformantVaryingArrayMemorySize( 
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat
    );

unsigned long RPC_ENTRY 
NdrVaryingArrayMemorySize( 
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat
    );

unsigned long RPC_ENTRY 
NdrComplexArrayMemorySize( 
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat
    );

/* Strings */

unsigned long RPC_ENTRY 
NdrConformantStringMemorySize( 
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat
    );

unsigned long RPC_ENTRY 
NdrNonConformantStringMemorySize( 
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat
    );

/* Unions */

unsigned long RPC_ENTRY 
NdrEncapsulatedUnionMemorySize( 
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat
    );

unsigned long RPC_ENTRY 
NdrNonEncapsulatedUnionMemorySize( 
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat
    );

/* Transmit as and represent as*/

unsigned long RPC_ENTRY
NdrXmitOrRepAsMemorySize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat
    );

/* Cairo Interface pointer */

unsigned long RPC_ENTRY
NdrInterfacePointerMemorySize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat
    );

/*
 * Freeing routines
 */

void RPC_ENTRY
NdrPointerFree(
    PMIDL_STUB_MESSAGE                  pStubMsg, 
    unsigned char __RPC_FAR *           pMemory, 
    PFORMAT_STRING                      pFormat   
    );

/* Structures */

void RPC_ENTRY 
NdrSimpleStructFree( 
    PMIDL_STUB_MESSAGE                  pStubMsg, 
    unsigned char __RPC_FAR *           pMemory, 
    PFORMAT_STRING                      pFormat   
    );

void RPC_ENTRY 
NdrConformantStructFree( 
    PMIDL_STUB_MESSAGE                  pStubMsg, 
    unsigned char __RPC_FAR *           pMemory, 
    PFORMAT_STRING                      pFormat   
    );

void RPC_ENTRY 
NdrConformantVaryingStructFree( 
    PMIDL_STUB_MESSAGE                  pStubMsg, 
    unsigned char __RPC_FAR *           pMemory, 
    PFORMAT_STRING                      pFormat   
    );

void RPC_ENTRY
NdrHardStructFree( 
    PMIDL_STUB_MESSAGE                  pStubMsg, 
    unsigned char __RPC_FAR *           pMemory, 
    PFORMAT_STRING                      pFormat   
    );

void RPC_ENTRY
NdrComplexStructFree( 
    PMIDL_STUB_MESSAGE                  pStubMsg, 
    unsigned char __RPC_FAR *           pMemory, 
    PFORMAT_STRING                      pFormat   
    );

/* Arrays */

void RPC_ENTRY 
NdrFixedArrayFree( 
    PMIDL_STUB_MESSAGE                  pStubMsg, 
    unsigned char __RPC_FAR *           pMemory, 
    PFORMAT_STRING                      pFormat   
    );

void RPC_ENTRY 
NdrConformantArrayFree( 
    PMIDL_STUB_MESSAGE                  pStubMsg, 
    unsigned char __RPC_FAR *           pMemory, 
    PFORMAT_STRING                      pFormat   
    );

void RPC_ENTRY 
NdrConformantVaryingArrayFree( 
    PMIDL_STUB_MESSAGE                  pStubMsg, 
    unsigned char __RPC_FAR *           pMemory, 
    PFORMAT_STRING                      pFormat   
    );

void RPC_ENTRY 
NdrVaryingArrayFree( 
    PMIDL_STUB_MESSAGE                  pStubMsg, 
    unsigned char __RPC_FAR *           pMemory, 
    PFORMAT_STRING                      pFormat   
    );

void RPC_ENTRY 
NdrComplexArrayFree( 
    PMIDL_STUB_MESSAGE                  pStubMsg, 
    unsigned char __RPC_FAR *           pMemory, 
    PFORMAT_STRING                      pFormat   
    );

/* Unions */

void RPC_ENTRY 
NdrEncapsulatedUnionFree( 
    PMIDL_STUB_MESSAGE                  pStubMsg, 
    unsigned char __RPC_FAR *           pMemory, 
    PFORMAT_STRING                      pFormat   
    );

void RPC_ENTRY 
NdrNonEncapsulatedUnionFree(  
    PMIDL_STUB_MESSAGE                  pStubMsg, 
    unsigned char __RPC_FAR *           pMemory, 
    PFORMAT_STRING                      pFormat   
    );

/* Byte count */

void RPC_ENTRY 
NdrByteCountPointerFree( 
    PMIDL_STUB_MESSAGE                  pStubMsg, 
    unsigned char __RPC_FAR *           pMemory, 
    PFORMAT_STRING                      pFormat   
    );

/* Transmit as and represent as*/

void RPC_ENTRY 
NdrXmitOrRepAsFree( 
    PMIDL_STUB_MESSAGE                  pStubMsg, 
    unsigned char __RPC_FAR *           pMemory, 
    PFORMAT_STRING                      pFormat   
    );

/* Cairo Interface pointer */

void RPC_ENTRY 
NdrInterfacePointerFree( 
    PMIDL_STUB_MESSAGE                  pStubMsg, 
    unsigned char __RPC_FAR *           pMemory, 
    PFORMAT_STRING                      pFormat   
    );

/*
 * Endian conversion routine.
 */

void RPC_ENTRY 
NdrConvert( 
    PMIDL_STUB_MESSAGE                  pStubMsg, 
    PFORMAT_STRING                      pFormat   
    );

/* 
 * Auxilary routines
 */

void RPC_ENTRY 
NdrClientInitializeNew( 
    PRPC_MESSAGE                        pRpcMsg,
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PMIDL_STUB_DESC                     pStubDescriptor,
    unsigned int                        ProcNum
    );

unsigned char __RPC_FAR * RPC_ENTRY
NdrServerInitializeNew( 
    PRPC_MESSAGE                        pRpcMsg,
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PMIDL_STUB_DESC                     pStubDescriptor
    );

void RPC_ENTRY 
NdrClientInitialize( 
    PRPC_MESSAGE                        pRpcMsg,
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PMIDL_STUB_DESC                     pStubDescriptor,
    unsigned int                        ProcNum
    );

unsigned char __RPC_FAR * RPC_ENTRY
NdrServerInitialize( 
    PRPC_MESSAGE                        pRpcMsg,
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PMIDL_STUB_DESC                     pStubDescriptor
    );

unsigned char __RPC_FAR * RPC_ENTRY
NdrServerInitializeUnmarshall ( 
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PMIDL_STUB_DESC                     pStubDescriptor,
    PRPC_MESSAGE                        pRpcMsg 
    );

void RPC_ENTRY
NdrServerInitializeMarshall ( 
    PRPC_MESSAGE                        pRpcMsg,
    PMIDL_STUB_MESSAGE                  pStubMsg 
    );

unsigned char __RPC_FAR * RPC_ENTRY
NdrGetBuffer( 
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned long                       BufferLength,
    RPC_BINDING_HANDLE                  Handle
    );

unsigned char __RPC_FAR * RPC_ENTRY
NdrNsGetBuffer( 
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned long                       BufferLength,
    RPC_BINDING_HANDLE                  Handle
    );

unsigned char __RPC_FAR * RPC_ENTRY
NdrSendReceive(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR*                        pBufferEnd
    );

unsigned char __RPC_FAR * RPC_ENTRY
NdrNsSendReceive(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *                       pBufferEnd,
    RPC_BINDING_HANDLE __RPC_FAR *              pAutoHandle
    );

void RPC_ENTRY
NdrFreeBuffer(
    PMIDL_STUB_MESSAGE                  pStubMsg
    );

/* 
 * Interpeter calls.
 */

/* client */

CLIENT_CALL_RETURN RPC_VAR_ENTRY
NdrClientCall( 
    PMIDL_STUB_DESC                     pStubDescriptor,
    PFORMAT_STRING                      pFormat,
    ...
    );

/* server */
typedef enum {
    STUB_UNMARSHAL,
    STUB_CALL_SERVER,
    STUB_MARSHAL,
    STUB_CALL_SERVER_NO_HRESULT
}STUB_PHASE;

typedef enum {
    PROXY_CALCSIZE,
    PROXY_GETBUFFER,
    PROXY_MARSHAL,
    PROXY_SENDRECEIVE,
    PROXY_UNMARSHAL
}PROXY_PHASE;


long RPC_ENTRY
NdrStubCall (
    struct IRpcStubBuffer __RPC_FAR *    pThis,
    struct IRpcChannelBuffer __RPC_FAR * pChannel,
    PRPC_MESSAGE                         pRpcMsg,
    unsigned long __RPC_FAR *            pdwStubPhase
    );

void RPC_ENTRY
NdrServerCall(
    PRPC_MESSAGE                        pRpcMsg
    );

int RPC_ENTRY
NdrServerUnmarshall( 
    struct IRpcChannelBuffer __RPC_FAR * pChannel,
    PRPC_MESSAGE                         pRpcMsg,
    PMIDL_STUB_MESSAGE                   pStubMsg,
    PMIDL_STUB_DESC                      pStubDescriptor,
    PFORMAT_STRING                       pFormat,
    void __RPC_FAR *                     pParamList
    );

void RPC_ENTRY
NdrServerMarshall(
    struct IRpcStubBuffer __RPC_FAR *    pThis,
    struct IRpcChannelBuffer __RPC_FAR * pChannel,
    PMIDL_STUB_MESSAGE                   pStubMsg,
    PFORMAT_STRING                       pFormat
    );

/* Comm and Fault status */

RPC_STATUS RPC_ENTRY
NdrMapCommAndFaultStatus(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned long __RPC_FAR *                       pCommStatus,
    unsigned long __RPC_FAR *                       pFaultStatus,
    RPC_STATUS                          Status
    );

/* Helper routines */

int RPC_ENTRY
NdrSH_UPDecision(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char           __RPC_FAR *__RPC_FAR *          pPtrInMem,
    RPC_BUFPTR                          pBuffer
    );

int RPC_ENTRY
NdrSH_TLUPDecision(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char           __RPC_FAR *__RPC_FAR *          pPtrInMem
    );

int RPC_ENTRY
NdrSH_TLUPDecisionBuffer(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char           __RPC_FAR *__RPC_FAR *          pPtrInMem
    );

int RPC_ENTRY
NdrSH_IfAlloc(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char           __RPC_FAR *__RPC_FAR *          pPtrInMem,
    unsigned long                       Count
    );

int RPC_ENTRY
NdrSH_IfAllocRef(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char           __RPC_FAR *__RPC_FAR *          pPtrInMem,
    unsigned long                       Count
    );

int RPC_ENTRY
NdrSH_IfAllocSet(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char           __RPC_FAR *__RPC_FAR *          pPtrInMem,
    unsigned long                       Count
    );

RPC_BUFPTR RPC_ENTRY
NdrSH_IfCopy(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char           __RPC_FAR *__RPC_FAR *          pPtrInMem,
    unsigned long                       Count
    );

RPC_BUFPTR RPC_ENTRY
NdrSH_IfAllocCopy(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char           __RPC_FAR *__RPC_FAR *          pPtrInMem,
    unsigned long                       Count
    );

unsigned long RPC_ENTRY
NdrSH_Copy(
    unsigned char           __RPC_FAR *         pStubMsg,
    unsigned char           __RPC_FAR *         pPtrInMem,
    unsigned long                       Count
    );

void RPC_ENTRY
NdrSH_IfFree(
    PMIDL_STUB_MESSAGE                  pMessage,
    unsigned char           __RPC_FAR *         pPtr );


RPC_BUFPTR  RPC_ENTRY
NdrSH_StringMarshall(
    PMIDL_STUB_MESSAGE                  pMessage,
    unsigned char           __RPC_FAR *         pMemory,
    unsigned long                       Count,
    int                                 Size );

RPC_BUFPTR  RPC_ENTRY
NdrSH_StringUnMarshall(
    PMIDL_STUB_MESSAGE                  pMessage,
    unsigned char           __RPC_FAR *__RPC_FAR *          pMemory,
    int                                 Size );

/****************************************************************************
    MIDL 2.0 memory package: rpc_ss_* rpc_sm_*
 ****************************************************************************/

typedef void __RPC_FAR * RPC_SS_THREAD_HANDLE;

typedef void __RPC_FAR * __RPC_API 
RPC_CLIENT_ALLOC (
    IN size_t Size
    );

typedef void __RPC_API 
RPC_CLIENT_FREE (
    IN void __RPC_FAR * Ptr
    );

/*++
     RpcSs* package
--*/

void __RPC_FAR * RPC_ENTRY
RpcSsAllocate (
    IN size_t Size
    );

void RPC_ENTRY
RpcSsDisableAllocate (
    void
    );

void RPC_ENTRY
RpcSsEnableAllocate (
    void
    );

void RPC_ENTRY
RpcSsFree (
    IN void __RPC_FAR * NodeToFree
    );

RPC_SS_THREAD_HANDLE RPC_ENTRY
RpcSsGetThreadHandle (
    void
    );

void RPC_ENTRY
RpcSsSetClientAllocFree (
    IN RPC_CLIENT_ALLOC __RPC_FAR * ClientAlloc,
    IN RPC_CLIENT_FREE __RPC_FAR * ClientFree
    );

void RPC_ENTRY
RpcSsSetThreadHandle (
    IN RPC_SS_THREAD_HANDLE Id
    );

void RPC_ENTRY
RpcSsSwapClientAllocFree (
    IN RPC_CLIENT_ALLOC __RPC_FAR * ClientAlloc,
    IN RPC_CLIENT_FREE __RPC_FAR * ClientFree,
    OUT RPC_CLIENT_ALLOC __RPC_FAR * __RPC_FAR * OldClientAlloc,
    OUT RPC_CLIENT_FREE __RPC_FAR * __RPC_FAR * OldClientFree
    );

/*++
     RpcSm* package
--*/

void __RPC_FAR * RPC_ENTRY
RpcSmAllocate (
    IN  size_t          Size,
    OUT RPC_STATUS __RPC_FAR *    pStatus
    );

RPC_STATUS RPC_ENTRY
RpcSmClientFree (
    IN  void __RPC_FAR * pNodeToFree
    );

RPC_STATUS  RPC_ENTRY
RpcSmDestroyClientContext (
    IN void __RPC_FAR * __RPC_FAR * ContextHandle
    );

RPC_STATUS  RPC_ENTRY
RpcSmDisableAllocate (
    void
    );

RPC_STATUS  RPC_ENTRY
RpcSmEnableAllocate (
    void
    );

RPC_STATUS  RPC_ENTRY
RpcSmFree (
    IN void __RPC_FAR * NodeToFree
    );

RPC_SS_THREAD_HANDLE RPC_ENTRY
RpcSmGetThreadHandle (
    OUT RPC_STATUS __RPC_FAR *    pStatus
    );

RPC_STATUS  RPC_ENTRY
RpcSmSetClientAllocFree (
    IN RPC_CLIENT_ALLOC __RPC_FAR * ClientAlloc,
    IN RPC_CLIENT_FREE __RPC_FAR * ClientFree
    );

RPC_STATUS  RPC_ENTRY
RpcSmSetThreadHandle (
    IN RPC_SS_THREAD_HANDLE Id
    );

RPC_STATUS  RPC_ENTRY
RpcSmSwapClientAllocFree (
    IN RPC_CLIENT_ALLOC __RPC_FAR * ClientAlloc,
    IN RPC_CLIENT_FREE __RPC_FAR * ClientFree,
    OUT RPC_CLIENT_ALLOC __RPC_FAR * __RPC_FAR * OldClientAlloc,
    OUT RPC_CLIENT_FREE __RPC_FAR * __RPC_FAR * OldClientFree
    );

/*++
     Ndr stub entry points
--*/

void RPC_ENTRY
NdrRpcSsEnableAllocate(
    PMIDL_STUB_MESSAGE      pMessage );

void RPC_ENTRY
NdrRpcSsDisableAllocate(
    PMIDL_STUB_MESSAGE      pMessage );

void RPC_ENTRY
NdrRpcSmSetClientToOsf(
    PMIDL_STUB_MESSAGE      pMessage );

void __RPC_FAR *  RPC_ENTRY
NdrRpcSmClientAllocate (
    IN size_t Size
    );

void  RPC_ENTRY
NdrRpcSmClientFree (
    IN void __RPC_FAR * NodeToFree
    );

void __RPC_FAR *  RPC_ENTRY
NdrRpcSsDefaultAllocate (
    IN size_t Size
    );

void  RPC_ENTRY
NdrRpcSsDefaultFree (
    IN void __RPC_FAR * NodeToFree
    );

/****************************************************************************
    end of memory package: rpc_ss_* rpc_sm_*
 ****************************************************************************/

/****************************************************************************
 * Full Pointer APIs
 ****************************************************************************/

PFULL_PTR_XLAT_TABLES RPC_ENTRY
NdrFullPointerXlatInit( 
    unsigned long           NumberOfPointers,
    XLAT_SIDE               XlatSide
    );

void RPC_ENTRY
NdrFullPointerXlatFree( 
    PFULL_PTR_XLAT_TABLES   pXlatTables
    );

int RPC_ENTRY
NdrFullPointerQueryPointer( 
    PFULL_PTR_XLAT_TABLES   pXlatTables,
    void __RPC_FAR *                    pPointer,
    unsigned char           QueryType,
    unsigned long __RPC_FAR *           pRefId
    );

int RPC_ENTRY
NdrFullPointerQueryRefId( 
    PFULL_PTR_XLAT_TABLES   pXlatTables,
    unsigned long           RefId,
    unsigned char           QueryType,
    void __RPC_FAR *__RPC_FAR *                 ppPointer
    );

void RPC_ENTRY
NdrFullPointerInsertRefId( 
    PFULL_PTR_XLAT_TABLES   pXlatTables,
    unsigned long           RefId,
    void __RPC_FAR *                    pPointer
    );

int RPC_ENTRY
NdrFullPointerFree( 
    PFULL_PTR_XLAT_TABLES   pXlatTables,
    void __RPC_FAR *                    Pointer
    );

void __RPC_FAR *  RPC_ENTRY
NdrAllocate( 
    PMIDL_STUB_MESSAGE      pStubMsg,
    size_t                  Len 
    );

void RPC_ENTRY
NdrClearOutParameters(
    PMIDL_STUB_MESSAGE      pStubMsg,
    PFORMAT_STRING          pFormat,
    void __RPC_FAR *        ArgAddr
    );


/****************************************************************************
 * Proxy APIs
 ****************************************************************************/

void __RPC_FAR * RPC_ENTRY
NdrOleAllocate (
    IN size_t Size
    );

void RPC_ENTRY
NdrOleFree (
    IN void __RPC_FAR * NodeToFree
    );

#ifdef CONST_VTABLE
#define CONST_VTBL const
#else
#define CONST_VTBL
#endif




#ifdef __cplusplus
}
#endif

// Reset the packing level for DOS, Windows and Mac.

#if defined(__RPC_DOS__) || defined(__RPC_WIN16__) || defined(__RPC_MAC__)
#pragma pack()
#endif

#endif /* __RPCNDR_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\inc32\STDARG.H ===
/***
*stdarg.h - defines ANSI-style macros for variable argument functions
*
*	Copyright (c) 1985-1994, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	This file defines ANSI-style macros for accessing arguments
*	of functions which take a variable number of arguments.
*	[ANSI]
*
****/

#ifndef _INC_STDARG
#define _INC_STDARG

#ifdef __cplusplus
extern "C" {
#endif



#ifndef _VA_LIST_DEFINED
#ifdef	_M_ALPHA
typedef struct {
	char *a0;	/* pointer to first homed integer argument */
	int offset;	/* byte offset of next parameter */
} va_list;
#else
typedef char *	va_list;
#endif
#define _VA_LIST_DEFINED
#endif

#ifdef	_M_IX86


#define _INTSIZEOF(n)	( (sizeof(n) + sizeof(int) - 1) & ~(sizeof(int) - 1) ) 

#define va_start(ap,v)	( ap = (va_list)&v + _INTSIZEOF(v) )
#define va_arg(ap,t)	( *(t *)((ap += _INTSIZEOF(t)) - _INTSIZEOF(t)) )
#define va_end(ap)	( ap = (va_list)0 )


#elif	defined(_M_MRX000)


/* Use these types and definitions if generating code for MIPS */

#define va_start(ap,v) ap  = (va_list)&v + sizeof(v)
#define va_end(list)
#define va_arg(list, mode) ((mode *)(list =\
 (char *) ((((int)list + (__builtin_alignof(mode)<=4?3:7)) &\
 (__builtin_alignof(mode)<=4?-4:-8))+sizeof(mode))))[-1]

/*  +++++++++++++++++++++++++++++++++++++++++++
    Because of parameter passing conventions in C:
    use mode=int for char, and short types
    use mode=double for float types
    use a pointer for array types
    +++++++++++++++++++++++++++++++++++++++++++ */


#elif	defined(_M_ALPHA)


/* Use these types and definitions if generating code for ALPHA */

/*
 * The Alpha compiler supports two builtin functions that are used to
 * implement stdarg/varargs.  The __builtin_va_start function is used
 * by va_start to initialize the data structure that locates the next
 * argument.  The __builtin_isfloat function is used by va_arg to pick
 * which part of the home area a given register argument is stored in.
 * The home area is where up to six integer and/or six floating point
 * register arguments are stored down (so they can also be referenced
 * by a pointer like any arguments passed on the stack).
 */

extern void * __builtin_va_start(va_list, ...);

#ifdef	_CFRONT
#define __builtin_isfloat(a) __builtin_alignof(a)
#endif

#define va_start(list, v) __builtin_va_start(list, v, 1)
#define va_end(list)
#define va_arg(list, mode) \
    ( *(        ((list).offset += ((int)sizeof(mode) + 7) & -8) , \
        (mode *)((list).a0 + (list).offset - \
                    ((__builtin_isfloat(mode) && (list).offset <= (6 * 8)) ? \
                        (6 * 8) + 8 : ((int)sizeof(mode) + 7) & -8) \
                ) \
       ) \
    )


#else


/* A guess at the proper definitions for other platforms */

#define _INTSIZEOF(n)	( (sizeof(n) + sizeof(int) - 1) & ~(sizeof(int) - 1) )

#define va_start(ap,v)	( ap = (va_list)&v + _INTSIZEOF(v) )
#define va_arg(ap,t)	( *(t *)((ap += _INTSIZEOF(t)) - _INTSIZEOF(t)) )
#define va_end(ap)	( ap = (va_list)0 )


#endif


#ifdef __cplusplus
}
#endif

#endif	/* _INC_STDARG */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\inc32\STDLIB.H ===
/***
*stdlib.h - declarations/definitions for commonly used library functions
*
*	Copyright (c) 1985-1994, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	This include file contains the function declarations for
*	commonly used library functions which either don't fit somewhere
*	else, or, like toupper/tolower, can't be declared in the normal
*	place for other reasons.
*	[ANSI]
*
****/

#ifndef _INC_STDLIB
#define _INC_STDLIB

#ifdef __cplusplus
extern "C" {
#endif


/* Define _CRTAPI1 (for compatibility with the NT SDK) */

#ifndef _CRTAPI1
#if	( (_MSC_VER >= 800) && (_M_IX86 >= 300) )
#define _CRTAPI1 __cdecl
#else
#define _CRTAPI1
#endif
#endif


/* Define _CRTAPI2 (for compatibility with the NT SDK) */

#ifndef _CRTAPI2
#if	( (_MSC_VER >= 800) && (_M_IX86 >= 300) )
#define _CRTAPI2 __cdecl
#else
#define _CRTAPI2
#endif
#endif


/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef	_NTSDK
/* definition compatible with NT SDK */
#define _CRTIMP
#else	/* ndef _NTSDK */
/* current definition */
#ifdef	_DLL
#define _CRTIMP __declspec(dllimport)
#else	/* ndef _DLL */
#define _CRTIMP
#endif	/* _DLL */
#endif	/* _NTSDK */
#endif	/* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if	( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif


#ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif


#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif


/* Define NULL pointer value */

#ifndef NULL
#ifdef __cplusplus
#define NULL	0
#else
#define NULL	((void *)0)
#endif
#endif


/* Definition of the argument values for the exit() function */

#define EXIT_SUCCESS	0
#define EXIT_FAILURE	1


#ifndef _ONEXIT_T_DEFINED
typedef int (__cdecl * _onexit_t)(void);
#if !__STDC__
/* Non-ANSI name for compatibility */
#define onexit_t _onexit_t
#endif
#define _ONEXIT_T_DEFINED
#endif


/* Data structure definitions for div and ldiv runtimes. */

#ifndef _DIV_T_DEFINED

typedef struct _div_t {
	int quot;
	int rem;
} div_t;

typedef struct _ldiv_t {
	long quot;
	long rem;
} ldiv_t;

#define _DIV_T_DEFINED
#endif

/* Maximum value that can be returned by the rand function. */

#define RAND_MAX 0x7fff

/*
 * Maximum number of bytes in multi-byte character in the current locale
 * (also defined in ctype.h).
 */
#ifndef MB_CUR_MAX

#ifdef	_NTSDK

/* definition compatible with NT SDK */
#ifdef	_DLL
#define __mb_cur_max	(*__mb_cur_max_dll)
#define MB_CUR_MAX	(*__mb_cur_max_dll)
extern	int *__mb_cur_max_dll;
#else	/* ndef _DLL */
#define MB_CUR_MAX __mb_cur_max
extern	int __mb_cur_max;
#endif	/* _DLL */

#else	/* ndef _NTSDK */

/* current definition */
#if	defined(_DLL) && defined(_M_IX86)
#define MB_CUR_MAX	(*__p___mb_cur_max())
_CRTIMP int * __cdecl __p___mb_cur_max(void);
#else	/* !(defined(_DLL) && defined(_M_IX86)) */
#define MB_CUR_MAX __mb_cur_max
_CRTIMP extern int __mb_cur_max;
#endif	/* defined(_DLL) && defined(_M_IX86) */

#endif	/* _NTSDK */

#endif	/* MB_CUR_MAX */


/* Minimum and maximum macros */

#define __max(a,b)	(((a) > (b)) ? (a) : (b))
#define __min(a,b)	(((a) < (b)) ? (a) : (b))

/*
 * Sizes for buffers used by the _makepath() and _splitpath() functions.
 * note that the sizes include space for 0-terminator
 */
#define _MAX_PATH	260	/* max. length of full pathname */
#define _MAX_DRIVE	3	/* max. length of drive component */
#define _MAX_DIR	256	/* max. length of path component */
#define _MAX_FNAME	256	/* max. length of file name component */
#define _MAX_EXT	256	/* max. length of extension component */


/* External variable declarations */

#if defined(_MT) || defined(_DLL)
_CRTIMP int * __cdecl _errno(void);
_CRTIMP unsigned long * __cdecl __doserrno(void);
#define errno	    (*_errno())
#define _doserrno   (*__doserrno())
#else	/* ndef _MT && ndef _DLL */
_CRTIMP extern int errno;			/* XENIX style error number */
_CRTIMP extern unsigned long _doserrno; 	/* OS system error value */
#endif	/* _MT || _DLL */

#ifdef	_NTSDK

/* Definitions and declarations compatible with the NT SDK */

#ifdef	_DLL

extern char ** _sys_errlist;	/* perror error message table */

#define _sys_nerr   (*_sys_nerr_dll)
#define __argc      (*__argc_dll)
#define __argc      (*__argc_dll)
#define __argv      (*__argv_dll)
#define __wargv     (*__wargv_dll)
#define _environ    (*_environ_dll)
#define _wenviron   (*_wenviron_dll)
#define _fmode	    (*_fmode_dll)
#define _fileinfo   (*_fileinfo_dll)

extern int * _sys_nerr_dll;	/* # of entries in sys_errlist table */
extern int * __argc_dll;	/* count of cmd line args */
extern char *** __argv_dll;	/* pointer to table of cmd line args */
extern wchar_t *** __wargv_dll;	/* pointer to table of wide cmd line args */
extern char *** _environ_dll;	/* pointer to environment table */
extern wchar_t *** _wenviron_dll;	/* pointer to wide environment table */
extern int * _fmode_dll;	/* default file translation mode */
extern int * _fileinfo_dll;	/* open file info mode (for spawn) */

#define _pgmptr     (*_pgmptr_dll)
#define _wpgmptr    (*_wpgmptr_dll)

#define _osver      (*_osver_dll)
#define _winver     (*_winver_dll)
#define _winmajor   (*_winmajor_dll)
#define _winminor   (*_winminor_dll)

extern char ** _pgmptr_dll;
extern wchar_t ** _wpgmptr_dll;

extern unsigned int * _osver_dll;
extern unsigned int * _winver_dll;
extern unsigned int * _winmajor_dll;
extern unsigned int * _winminor_dll;

#else	/* ndef _DLL */


extern char * _sys_errlist[];	/* perror error message table */
extern int _sys_nerr;		/* # of entries in sys_errlist table */

extern int __argc;		/* count of cmd line args */
extern char ** __argv;		/* pointer to table of cmd line args */
extern wchar_t ** __wargv;	/* pointer to table of wide cmd line args */

#ifdef _POSIX_
extern char ** environ;		/* pointer to environment table */
#else
extern char **    _environ;     /* pointer to environment table */
extern wchar_t ** _wenviron;    /* pointer to wide environment table */
#endif

extern int _fmode;		/* default file translation mode */
extern int _fileinfo;		/* open file info mode (for spawn) */

extern char * _pgmptr;		/* points to the module (EXE) name */
extern wchar_t * _wpgmptr;	/* points to the module (EXE) wide name */

/* Windows major/minor and O.S. version numbers */

extern unsigned int _osver;
extern unsigned int _winver;
extern unsigned int _winmajor;
extern unsigned int _winminor;

#endif	/* _DLL */

#else	/* ndef _NTSDK */

/* Current definitions and declarations */

_CRTIMP extern char * _sys_errlist[];	/* perror error message table */
_CRTIMP extern int _sys_nerr;		/* # of entries in sys_errlist table */

#if	defined(_DLL) && defined(_M_IX86)

#define __argc	    (*__p___argc())	/* count of cmd line args */
#define __argv	    (*__p___argv())	/* pointer to table of cmd line args */
#define __wargv     (*__p___wargv())	/* pointer to table of wide cmd line args */
#define _environ    (*__p__environ())	/* pointer to environment table */
#define _wenviron   (*__p__wenviron())	/* pointer to wide environment table */
#define _fmode	    (*__p__fmode())
#define _osver	    (*__p__osver())
#define _pgmptr     (*__p__pgmptr())	/* points to the module (EXE) name */
#define _wpgmptr    (*__p__wpgmptr())	/* points to the module (EXE) wide name */
#define _winver     (*__p__winver())
#define _winmajor   (*__p__winmajor())
#define _winminor   (*__p__winminor())

_CRTIMP int *	       __cdecl __p___argc(void);
_CRTIMP char ***       __cdecl __p___argv(void);
_CRTIMP wchar_t ***    __cdecl __p___wargv(void);
_CRTIMP char ***       __cdecl __p__environ(void);
_CRTIMP wchar_t ***    __cdecl __p__wenviron(void);
_CRTIMP int *	       __cdecl __p__fmode(void);
_CRTIMP unsigned int * __cdecl __p__osver(void);
_CRTIMP char **	       __cdecl __p__pgmptr(void);
_CRTIMP wchar_t **     __cdecl __p__wpgmptr(void);
_CRTIMP unsigned int * __cdecl __p__winver(void);
_CRTIMP unsigned int * __cdecl __p__winmajor(void);
_CRTIMP unsigned int * __cdecl __p__winminor(void);

#else	/* !(defined(_DLL) && defined(_M_IX86)) */
_CRTIMP extern int __argc;		/* count of cmd line args */
_CRTIMP extern char ** __argv;		/* pointer to table of cmd line args */
_CRTIMP extern wchar_t ** __wargv;	/* pointer to table of wide cmd line args */

_CRTIMP extern char **    _environ;     /* pointer to environment table */
_CRTIMP extern wchar_t ** _wenviron;    /* pointer to wide environment table */

_CRTIMP extern int _fmode;		/* default file translation mode */
_CRTIMP extern int _fileinfo;		/* open file info mode (for spawn) */

_CRTIMP extern char * _pgmptr;		/* points to the module (EXE) name */
_CRTIMP extern wchar_t * _wpgmptr;	/* points to the module (EXE) wide name */

/* Windows major/minor and O.S. version numbers */

_CRTIMP extern unsigned int _osver;
_CRTIMP extern unsigned int _winver;
_CRTIMP extern unsigned int _winmajor;
_CRTIMP extern unsigned int _winminor;
#endif	/* defined(_DLL) && defined(_M_IX86) */

#endif	/* _NTSDK */

/* function prototypes */

_CRTIMP void   __cdecl abort(void);
	int    __cdecl abs(int);
	int    __cdecl atexit(void (__cdecl *)(void));
_CRTIMP double __cdecl atof(const char *);
_CRTIMP int    __cdecl atoi(const char *);
_CRTIMP long   __cdecl atol(const char *);
_CRTIMP void * __cdecl bsearch(const void *, const void *, size_t, size_t,
	int (__cdecl *)(const void *, const void *));
_CRTIMP void * __cdecl calloc(size_t, size_t);
_CRTIMP div_t  __cdecl div(int, int);
_CRTIMP void   __cdecl exit(int);
_CRTIMP void   __cdecl free(void *);
_CRTIMP char * __cdecl getenv(const char *);
_CRTIMP char * __cdecl _itoa(int, char *, int);
	long __cdecl labs(long);
_CRTIMP ldiv_t __cdecl ldiv(long, long);
_CRTIMP char * __cdecl _ltoa(long, char *, int);
_CRTIMP void * __cdecl malloc(size_t);
_CRTIMP int    __cdecl mblen(const char *, size_t);
_CRTIMP size_t __cdecl _mbstrlen(const char *s);
_CRTIMP int    __cdecl mbtowc(wchar_t *, const char *, size_t);
_CRTIMP size_t __cdecl mbstowcs(wchar_t *, const char *, size_t);
_CRTIMP void   __cdecl qsort(void *, size_t, size_t, int (__cdecl *)
	(const void *, const void *));
_CRTIMP int    __cdecl rand(void);
_CRTIMP void * __cdecl realloc(void *, size_t);
_CRTIMP void   __cdecl srand(unsigned int);
_CRTIMP double __cdecl strtod(const char *, char **);
_CRTIMP long   __cdecl strtol(const char *, char **, int);
_CRTIMP unsigned long __cdecl strtoul(const char *, char **, int);
_CRTIMP int    __cdecl system(const char *);
_CRTIMP char * __cdecl _ultoa(unsigned long, char *, int);
_CRTIMP int    __cdecl wctomb(char *, wchar_t);
_CRTIMP size_t __cdecl wcstombs(char *, const wchar_t *, size_t);

#ifndef _WSTDLIB_DEFINED

/* wide function prototypes, also declared in wchar.h  */

_CRTIMP wchar_t * __cdecl _itow (int, wchar_t *, int);
_CRTIMP wchar_t * __cdecl _ltow (long, wchar_t *, int);
_CRTIMP wchar_t * __cdecl _ultow (unsigned long, wchar_t *, int);
_CRTIMP double __cdecl wcstod(const wchar_t *, wchar_t **);
_CRTIMP long   __cdecl wcstol(const wchar_t *, wchar_t **, int);
_CRTIMP unsigned long __cdecl wcstoul(const wchar_t *, wchar_t **, int);
_CRTIMP wchar_t * __cdecl _wgetenv(const wchar_t *);
_CRTIMP int    __cdecl _wsystem(const wchar_t *);
_CRTIMP int __cdecl _wtoi(const wchar_t *);
_CRTIMP long __cdecl _wtol(const wchar_t *);

#define _WSTDLIB_DEFINED
#endif

#ifndef _POSIX_

_CRTIMP char * __cdecl _ecvt(double, int, int *, int *);
_CRTIMP void   __cdecl _exit(int);
_CRTIMP char * __cdecl _fcvt(double, int, int *, int *);
_CRTIMP char * __cdecl _fullpath(char *, const char *, size_t);
_CRTIMP char * __cdecl _gcvt(double, int, char *);
	unsigned long __cdecl _lrotl(unsigned long, int);
	unsigned long __cdecl _lrotr(unsigned long, int);
_CRTIMP void   __cdecl _makepath(char *, const char *, const char *, const char *,
	const char *);
	_onexit_t __cdecl _onexit(_onexit_t);
_CRTIMP void   __cdecl perror(const char *);
_CRTIMP int    __cdecl _putenv(const char *);
	unsigned int __cdecl _rotl(unsigned int, int);
	unsigned int __cdecl _rotr(unsigned int, int);
_CRTIMP void   __cdecl _searchenv(const char *, const char *, char *);
_CRTIMP void   __cdecl _splitpath(const char *, char *, char *, char *, char *);
_CRTIMP void   __cdecl _swab(char *, char *, int);

#ifndef _WSTDLIBP_DEFINED

/* wide function prototypes, also declared in wchar.h  */

_CRTIMP wchar_t * __cdecl _wfullpath(wchar_t *, const wchar_t *, size_t);
_CRTIMP void   __cdecl _wmakepath(wchar_t *, const wchar_t *, const wchar_t *, const wchar_t *,
	const wchar_t *);
_CRTIMP void   __cdecl _wperror(const wchar_t *);
_CRTIMP int    __cdecl _wputenv(const wchar_t *);
_CRTIMP void   __cdecl _wsearchenv(const wchar_t *, const wchar_t *, wchar_t *);
_CRTIMP void   __cdecl _wsplitpath(const wchar_t *, wchar_t *, wchar_t *, wchar_t *, wchar_t *);

#define _WSTDLIBP_DEFINED
#endif

/* --------- The following functions are OBSOLETE --------- */
/* The Win32 API SetErrorMode, Beep and Sleep should be used instead. */
_CRTIMP void _seterrormode(int);
_CRTIMP void _beep(unsigned, unsigned);
_CRTIMP void _sleep(unsigned long);
/*  --------- The preceding functions are OBSOLETE --------- */

#endif	/* _POSIX_ */

#ifndef tolower 	/* tolower has been undefined - use function */
_CRTIMP int __cdecl tolower(int);
#endif	/* tolower */

#ifndef toupper 	/* toupper has been undefined - use function */
_CRTIMP int __cdecl toupper(int);
#endif	/* toupper */


#if	!__STDC__

/* Non-ANSI names for compatibility */

#ifdef	_NTSDK

#ifndef _POSIX_

#ifndef __cplusplus
#define max(a,b)	(((a) > (b)) ? (a) : (b))
#define min(a,b)	(((a) < (b)) ? (a) : (b))
#endif

#define sys_errlist _sys_errlist
#define sys_nerr    _sys_nerr
#define environ     _environ

#define DOS_MODE    _DOS_MODE
#define OS2_MODE    _OS2_MODE

#define ecvt	    _ecvt
#define fcvt	    _fcvt
#define gcvt	    _gcvt
#define itoa	    _itoa
#define ltoa	    _ltoa
#define onexit	    _onexit
#define putenv	    _putenv
#define swab	    _swab
#define ultoa	    _ultoa

#endif	/* _POSIX_ */

#else	/* ndef _NTSDK */

#ifndef __cplusplus
#define max(a,b)	(((a) > (b)) ? (a) : (b))
#define min(a,b)	(((a) < (b)) ? (a) : (b))
#endif

#define sys_errlist _sys_errlist
#define sys_nerr    _sys_nerr
#define environ     _environ

_CRTIMP char * __cdecl ecvt(double, int, int *, int *);
_CRTIMP char * __cdecl fcvt(double, int, int *, int *);
_CRTIMP char * __cdecl gcvt(double, int, char *);
_CRTIMP char * __cdecl itoa(int, char *, int);
_CRTIMP char * __cdecl ltoa(long, char *, int);
	onexit_t __cdecl onexit(onexit_t);
_CRTIMP int    __cdecl putenv(const char *);
_CRTIMP void   __cdecl swab(char *, char *, int);
_CRTIMP char * __cdecl ultoa(unsigned long, char *, int);

#endif	/* _NTSDK */

#endif	/* __STDC__ */

#ifdef __cplusplus
}
#endif


#endif	/* _INC_STDLIB */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\inc32\WINBASE.H ===
/************************************************************************
*                                                                       *
*   winbase.h -- This module defines the 32-Bit Windows Base APIs       *
*                                                                       *
*   Copyright (c) 1990-1995, Microsoft Corp. All rights reserved.       *
*                                                                       *
************************************************************************/
#ifndef _WINBASE_
#define _WINBASE_


//
// Define API decoration for direct importing of DLL references.
//

#if !defined(_ADVAPI32_)
#define WINADVAPI DECLSPEC_IMPORT
#else
#define WINADVAPI
#endif

#if !defined(_KERNEL32_)
#define WINBASEAPI DECLSPEC_IMPORT
#else
#define WINBASEAPI
#endif

#ifdef __cplusplus
extern "C" {
#endif

/*
 * Compatibility macros
 */

#define DefineHandleTable(w)            ((w),TRUE)
#define LimitEmsPages(dw)
#define SetSwapAreaSize(w)              (w)
#define LockSegment(w)                  GlobalFix((HANDLE)(w))
#define UnlockSegment(w)                GlobalUnfix((HANDLE)(w))
#define GetCurrentTime()                GetTickCount()

#define Yield()

#define INVALID_HANDLE_VALUE (HANDLE)-1
#define INVALID_FILE_SIZE (DWORD)0xFFFFFFFF

#define FILE_BEGIN           0
#define FILE_CURRENT         1
#define FILE_END             2

#define TIME_ZONE_ID_INVALID (DWORD)0xFFFFFFFF

#define WAIT_FAILED (DWORD)0xFFFFFFFF
#define WAIT_OBJECT_0       ((STATUS_WAIT_0 ) + 0 )

#define WAIT_ABANDONED         ((STATUS_ABANDONED_WAIT_0 ) + 0 )
#define WAIT_ABANDONED_0       ((STATUS_ABANDONED_WAIT_0 ) + 0 )

#define WAIT_TIMEOUT                        STATUS_TIMEOUT
#define WAIT_IO_COMPLETION                  STATUS_USER_APC
#define STILL_ACTIVE                        STATUS_PENDING
#define EXCEPTION_ACCESS_VIOLATION          STATUS_ACCESS_VIOLATION
#define EXCEPTION_DATATYPE_MISALIGNMENT     STATUS_DATATYPE_MISALIGNMENT
#define EXCEPTION_BREAKPOINT                STATUS_BREAKPOINT
#define EXCEPTION_SINGLE_STEP               STATUS_SINGLE_STEP
#define EXCEPTION_ARRAY_BOUNDS_EXCEEDED     STATUS_ARRAY_BOUNDS_EXCEEDED
#define EXCEPTION_FLT_DENORMAL_OPERAND      STATUS_FLOAT_DENORMAL_OPERAND
#define EXCEPTION_FLT_DIVIDE_BY_ZERO        STATUS_FLOAT_DIVIDE_BY_ZERO
#define EXCEPTION_FLT_INEXACT_RESULT        STATUS_FLOAT_INEXACT_RESULT
#define EXCEPTION_FLT_INVALID_OPERATION     STATUS_FLOAT_INVALID_OPERATION
#define EXCEPTION_FLT_OVERFLOW              STATUS_FLOAT_OVERFLOW
#define EXCEPTION_FLT_STACK_CHECK           STATUS_FLOAT_STACK_CHECK
#define EXCEPTION_FLT_UNDERFLOW             STATUS_FLOAT_UNDERFLOW
#define EXCEPTION_INT_DIVIDE_BY_ZERO        STATUS_INTEGER_DIVIDE_BY_ZERO
#define EXCEPTION_INT_OVERFLOW              STATUS_INTEGER_OVERFLOW
#define EXCEPTION_PRIV_INSTRUCTION          STATUS_PRIVILEGED_INSTRUCTION
#define EXCEPTION_IN_PAGE_ERROR             STATUS_IN_PAGE_ERROR
#define EXCEPTION_ILLEGAL_INSTRUCTION       STATUS_ILLEGAL_INSTRUCTION
#define EXCEPTION_NONCONTINUABLE_EXCEPTION  STATUS_NONCONTINUABLE_EXCEPTION
#define EXCEPTION_STACK_OVERFLOW            STATUS_STACK_OVERFLOW
#define EXCEPTION_INVALID_DISPOSITION       STATUS_INVALID_DISPOSITION
#define EXCEPTION_GUARD_PAGE                STATUS_GUARD_PAGE_VIOLATION
#define CONTROL_C_EXIT                      STATUS_CONTROL_C_EXIT
#define MoveMemory RtlMoveMemory
#define CopyMemory RtlCopyMemory
#define FillMemory RtlFillMemory
#define ZeroMemory RtlZeroMemory

//
// File creation flags must start at the high end since they
// are combined with the attributes
//

#define FILE_FLAG_WRITE_THROUGH         0x80000000
#define FILE_FLAG_OVERLAPPED            0x40000000
#define FILE_FLAG_NO_BUFFERING          0x20000000
#define FILE_FLAG_RANDOM_ACCESS         0x10000000
#define FILE_FLAG_SEQUENTIAL_SCAN       0x08000000
#define FILE_FLAG_DELETE_ON_CLOSE       0x04000000
#define FILE_FLAG_BACKUP_SEMANTICS      0x02000000
#define FILE_FLAG_POSIX_SEMANTICS       0x01000000

#define CREATE_NEW          1
#define CREATE_ALWAYS       2
#define OPEN_EXISTING       3
#define OPEN_ALWAYS         4
#define TRUNCATE_EXISTING   5

//
// Define the NamedPipe definitions
//


//
// Define the dwOpenMode values for CreateNamedPipe
//

#define PIPE_ACCESS_INBOUND         0x00000001
#define PIPE_ACCESS_OUTBOUND        0x00000002
#define PIPE_ACCESS_DUPLEX          0x00000003

//
// Define the Named Pipe End flags for GetNamedPipeInfo
//

#define PIPE_CLIENT_END             0x00000000
#define PIPE_SERVER_END             0x00000001

//
// Define the dwPipeMode values for CreateNamedPipe
//

#define PIPE_WAIT                   0x00000000
#define PIPE_NOWAIT                 0x00000001
#define PIPE_READMODE_BYTE          0x00000000
#define PIPE_READMODE_MESSAGE       0x00000002
#define PIPE_TYPE_BYTE              0x00000000
#define PIPE_TYPE_MESSAGE           0x00000004

//
// Define the well known values for CreateNamedPipe nMaxInstances
//

#define PIPE_UNLIMITED_INSTANCES    255

//
// Define the Security Quality of Service bits to be passed
// into CreateFile
//

#define SECURITY_ANONYMOUS          ( SecurityAnonymous      << 16 )
#define SECURITY_IDENTIFICATION     ( SecurityIdentification << 16 )
#define SECURITY_IMPERSONATION      ( SecurityImpersonation  << 16 )
#define SECURITY_DELEGATION         ( SecurityDelegation     << 16 )

#define SECURITY_CONTEXT_TRACKING  0x00040000
#define SECURITY_EFFECTIVE_ONLY    0x00080000

#define SECURITY_SQOS_PRESENT      0x00100000
#define SECURITY_VALID_SQOS_FLAGS  0x001F0000

//
//  File structures
//

typedef struct _OVERLAPPED {
    DWORD   Internal;
    DWORD   InternalHigh;
    DWORD   Offset;
    DWORD   OffsetHigh;
    HANDLE  hEvent;
} OVERLAPPED, *LPOVERLAPPED;

typedef struct _SECURITY_ATTRIBUTES {
    DWORD nLength;
    LPVOID lpSecurityDescriptor;
    BOOL bInheritHandle;
} SECURITY_ATTRIBUTES, *PSECURITY_ATTRIBUTES, *LPSECURITY_ATTRIBUTES;

typedef struct _PROCESS_INFORMATION {
    HANDLE hProcess;
    HANDLE hThread;
    DWORD dwProcessId;
    DWORD dwThreadId;
} PROCESS_INFORMATION, *PPROCESS_INFORMATION, *LPPROCESS_INFORMATION;

//
//  File System time stamps are represented with the following structure:
//

typedef struct _FILETIME {
    DWORD dwLowDateTime;
    DWORD dwHighDateTime;
} FILETIME, *PFILETIME, *LPFILETIME;

//
// System time is represented with the following structure:
//

typedef struct _SYSTEMTIME {
    WORD wYear;
    WORD wMonth;
    WORD wDayOfWeek;
    WORD wDay;
    WORD wHour;
    WORD wMinute;
    WORD wSecond;
    WORD wMilliseconds;
} SYSTEMTIME, *PSYSTEMTIME, *LPSYSTEMTIME;

typedef DWORD (WINAPI *PTHREAD_START_ROUTINE)(
    LPVOID lpThreadParameter
    );
typedef PTHREAD_START_ROUTINE LPTHREAD_START_ROUTINE;

typedef RTL_CRITICAL_SECTION CRITICAL_SECTION;
typedef PRTL_CRITICAL_SECTION PCRITICAL_SECTION;
typedef PRTL_CRITICAL_SECTION LPCRITICAL_SECTION;

typedef RTL_CRITICAL_SECTION_DEBUG CRITICAL_SECTION_DEBUG;
typedef PRTL_CRITICAL_SECTION_DEBUG PCRITICAL_SECTION_DEBUG;
typedef PRTL_CRITICAL_SECTION_DEBUG LPCRITICAL_SECTION_DEBUG;

#ifdef _X86_
typedef PLDT_ENTRY LPLDT_ENTRY;
#else
typedef LPVOID LPLDT_ENTRY;
#endif

#define MUTEX_MODIFY_STATE MUTANT_QUERY_STATE
#define MUTEX_ALL_ACCESS MUTANT_ALL_ACCESS

//
// Serial provider type.
//

#define SP_SERIALCOMM    ((DWORD)0x00000001)

//
// Provider SubTypes
//

#define PST_UNSPECIFIED      ((DWORD)0x00000000)
#define PST_RS232            ((DWORD)0x00000001)
#define PST_PARALLELPORT     ((DWORD)0x00000002)
#define PST_RS422            ((DWORD)0x00000003)
#define PST_RS423            ((DWORD)0x00000004)
#define PST_RS449            ((DWORD)0x00000005)
#define PST_MODEM            ((DWORD)0x00000006)
#define PST_FAX              ((DWORD)0x00000021)
#define PST_SCANNER          ((DWORD)0x00000022)
#define PST_NETWORK_BRIDGE   ((DWORD)0x00000100)
#define PST_LAT              ((DWORD)0x00000101)
#define PST_TCPIP_TELNET     ((DWORD)0x00000102)
#define PST_X25              ((DWORD)0x00000103)


//
// Provider capabilities flags.
//

#define PCF_DTRDSR        ((DWORD)0x0001)
#define PCF_RTSCTS        ((DWORD)0x0002)
#define PCF_RLSD          ((DWORD)0x0004)
#define PCF_PARITY_CHECK  ((DWORD)0x0008)
#define PCF_XONXOFF       ((DWORD)0x0010)
#define PCF_SETXCHAR      ((DWORD)0x0020)
#define PCF_TOTALTIMEOUTS ((DWORD)0x0040)
#define PCF_INTTIMEOUTS   ((DWORD)0x0080)
#define PCF_SPECIALCHARS  ((DWORD)0x0100)
#define PCF_16BITMODE     ((DWORD)0x0200)

//
// Comm provider settable parameters.
//

#define SP_PARITY         ((DWORD)0x0001)
#define SP_BAUD           ((DWORD)0x0002)
#define SP_DATABITS       ((DWORD)0x0004)
#define SP_STOPBITS       ((DWORD)0x0008)
#define SP_HANDSHAKING    ((DWORD)0x0010)
#define SP_PARITY_CHECK   ((DWORD)0x0020)
#define SP_RLSD           ((DWORD)0x0040)

//
// Settable baud rates in the provider.
//

#define BAUD_075          ((DWORD)0x00000001)
#define BAUD_110          ((DWORD)0x00000002)
#define BAUD_134_5        ((DWORD)0x00000004)
#define BAUD_150          ((DWORD)0x00000008)
#define BAUD_300          ((DWORD)0x00000010)
#define BAUD_600          ((DWORD)0x00000020)
#define BAUD_1200         ((DWORD)0x00000040)
#define BAUD_1800         ((DWORD)0x00000080)
#define BAUD_2400         ((DWORD)0x00000100)
#define BAUD_4800         ((DWORD)0x00000200)
#define BAUD_7200         ((DWORD)0x00000400)
#define BAUD_9600         ((DWORD)0x00000800)
#define BAUD_14400        ((DWORD)0x00001000)
#define BAUD_19200        ((DWORD)0x00002000)
#define BAUD_38400        ((DWORD)0x00004000)
#define BAUD_56K          ((DWORD)0x00008000)
#define BAUD_128K         ((DWORD)0x00010000)
#define BAUD_115200       ((DWORD)0x00020000)
#define BAUD_57600        ((DWORD)0x00040000)
#define BAUD_USER         ((DWORD)0x10000000)

//
// Settable Data Bits
//

#define DATABITS_5        ((WORD)0x0001)
#define DATABITS_6        ((WORD)0x0002)
#define DATABITS_7        ((WORD)0x0004)
#define DATABITS_8        ((WORD)0x0008)
#define DATABITS_16       ((WORD)0x0010)
#define DATABITS_16X      ((WORD)0x0020)

//
// Settable Stop and Parity bits.
//

#define STOPBITS_10       ((WORD)0x0001)
#define STOPBITS_15       ((WORD)0x0002)
#define STOPBITS_20       ((WORD)0x0004)
#define PARITY_NONE       ((WORD)0x0100)
#define PARITY_ODD        ((WORD)0x0200)
#define PARITY_EVEN       ((WORD)0x0400)
#define PARITY_MARK       ((WORD)0x0800)
#define PARITY_SPACE      ((WORD)0x1000)

typedef struct _COMMPROP {
    WORD wPacketLength;
    WORD wPacketVersion;
    DWORD dwServiceMask;
    DWORD dwReserved1;
    DWORD dwMaxTxQueue;
    DWORD dwMaxRxQueue;
    DWORD dwMaxBaud;
    DWORD dwProvSubType;
    DWORD dwProvCapabilities;
    DWORD dwSettableParams;
    DWORD dwSettableBaud;
    WORD wSettableData;
    WORD wSettableStopParity;
    DWORD dwCurrentTxQueue;
    DWORD dwCurrentRxQueue;
    DWORD dwProvSpec1;
    DWORD dwProvSpec2;
    WCHAR wcProvChar[1];
} COMMPROP,*LPCOMMPROP;

//
// Set dwProvSpec1 to COMMPROP_INITIALIZED to indicate that wPacketLength
// is valid before a call to GetCommProperties().
//
#define COMMPROP_INITIALIZED ((DWORD)0xE73CF52E)

typedef struct _COMSTAT {
    DWORD fCtsHold : 1;
    DWORD fDsrHold : 1;
    DWORD fRlsdHold : 1;
    DWORD fXoffHold : 1;
    DWORD fXoffSent : 1;
    DWORD fEof : 1;
    DWORD fTxim : 1;
    DWORD fReserved : 25;
    DWORD cbInQue;
    DWORD cbOutQue;
} COMSTAT, *LPCOMSTAT;

//
// DTR Control Flow Values.
//
#define DTR_CONTROL_DISABLE    0x00
#define DTR_CONTROL_ENABLE     0x01
#define DTR_CONTROL_HANDSHAKE  0x02

//
// RTS Control Flow Values
//
#define RTS_CONTROL_DISABLE    0x00
#define RTS_CONTROL_ENABLE     0x01
#define RTS_CONTROL_HANDSHAKE  0x02
#define RTS_CONTROL_TOGGLE     0x03

typedef struct _DCB {
    DWORD DCBlength;      /* sizeof(DCB)                     */
    DWORD BaudRate;       /* Baudrate at which running       */
    DWORD fBinary: 1;     /* Binary Mode (skip EOF check)    */
    DWORD fParity: 1;     /* Enable parity checking          */
    DWORD fOutxCtsFlow:1; /* CTS handshaking on output       */
    DWORD fOutxDsrFlow:1; /* DSR handshaking on output       */
    DWORD fDtrControl:2;  /* DTR Flow control                */
    DWORD fDsrSensitivity:1; /* DSR Sensitivity              */
    DWORD fTXContinueOnXoff: 1; /* Continue TX when Xoff sent */
    DWORD fOutX: 1;       /* Enable output X-ON/X-OFF        */
    DWORD fInX: 1;        /* Enable input X-ON/X-OFF         */
    DWORD fErrorChar: 1;  /* Enable Err Replacement          */
    DWORD fNull: 1;       /* Enable Null stripping           */
    DWORD fRtsControl:2;  /* Rts Flow control                */
    DWORD fAbortOnError:1; /* Abort all reads and writes on Error */
    DWORD fDummy2:17;     /* Reserved                        */
    WORD wReserved;       /* Not currently used              */
    WORD XonLim;          /* Transmit X-ON threshold         */
    WORD XoffLim;         /* Transmit X-OFF threshold        */
    BYTE ByteSize;        /* Number of bits/byte, 4-8        */
    BYTE Parity;          /* 0-4=None,Odd,Even,Mark,Space    */
    BYTE StopBits;        /* 0,1,2 = 1, 1.5, 2               */
    char XonChar;         /* Tx and Rx X-ON character        */
    char XoffChar;        /* Tx and Rx X-OFF character       */
    char ErrorChar;       /* Error replacement char          */
    char EofChar;         /* End of Input character          */
    char EvtChar;         /* Received Event character        */
    WORD wReserved1;      /* Fill for now.                   */
} DCB, *LPDCB;

typedef struct _COMMTIMEOUTS {
    DWORD ReadIntervalTimeout;          /* Maximum time between read chars. */
    DWORD ReadTotalTimeoutMultiplier;   /* Multiplier of characters.        */
    DWORD ReadTotalTimeoutConstant;     /* Constant in milliseconds.        */
    DWORD WriteTotalTimeoutMultiplier;  /* Multiplier of characters.        */
    DWORD WriteTotalTimeoutConstant;    /* Constant in milliseconds.        */
} COMMTIMEOUTS,*LPCOMMTIMEOUTS;

typedef struct _COMMCONFIG {
    DWORD dwSize;               /* Size of the entire struct */
    WORD wVersion;              /* version of the structure */
    WORD wReserved;             /* alignment */
    DCB dcb;                    /* device control block */
    DWORD dwProviderSubType;    /* ordinal value for identifying
                                   provider-defined data structure format*/
    DWORD dwProviderOffset;     /* Specifies the offset of provider specific
                                   data field in bytes from the start */
    DWORD dwProviderSize;       /* size of the provider-specific data field */
    WCHAR wcProviderData[1];    /* provider-specific data */
} COMMCONFIG,*LPCOMMCONFIG;

typedef struct _SYSTEM_INFO {
    union {
        DWORD dwOemId;          // Obsolete field...do not use
        struct {
            WORD wProcessorArchitecture;
            WORD wReserved;
        };
    };
    DWORD dwPageSize;
    LPVOID lpMinimumApplicationAddress;
    LPVOID lpMaximumApplicationAddress;
    DWORD dwActiveProcessorMask;
    DWORD dwNumberOfProcessors;
    DWORD dwProcessorType;
    DWORD dwAllocationGranularity;
    WORD wProcessorLevel;
    WORD wProcessorRevision;
} SYSTEM_INFO, *LPSYSTEM_INFO;

//
//


#define FreeModule(hLibModule) FreeLibrary((hLibModule))
#define MakeProcInstance(lpProc,hInstance) (lpProc)
#define FreeProcInstance(lpProc) (lpProc)

/* Global Memory Flags */
#define GMEM_FIXED          0x0000
#define GMEM_MOVEABLE       0x0002
#define GMEM_NOCOMPACT      0x0010
#define GMEM_NODISCARD      0x0020
#define GMEM_ZEROINIT       0x0040
#define GMEM_MODIFY         0x0080
#define GMEM_DISCARDABLE    0x0100
#define GMEM_NOT_BANKED     0x1000
#define GMEM_SHARE          0x2000
#define GMEM_DDESHARE       0x2000
#define GMEM_NOTIFY         0x4000
#define GMEM_LOWER          GMEM_NOT_BANKED
#define GMEM_VALID_FLAGS    0x7F72
#define GMEM_INVALID_HANDLE 0x8000

#define GHND                (GMEM_MOVEABLE | GMEM_ZEROINIT)
#define GPTR                (GMEM_FIXED | GMEM_ZEROINIT)

#define GlobalLRUNewest( h )    (HANDLE)(h)
#define GlobalLRUOldest( h )    (HANDLE)(h)
#define GlobalDiscard( h )      GlobalReAlloc( (h), 0, GMEM_MOVEABLE )

/* Flags returned by GlobalFlags (in addition to GMEM_DISCARDABLE) */
#define GMEM_DISCARDED      0x4000
#define GMEM_LOCKCOUNT      0x00FF

typedef struct _MEMORYSTATUS {
    DWORD dwLength;
    DWORD dwMemoryLoad;
    DWORD dwTotalPhys;
    DWORD dwAvailPhys;
    DWORD dwTotalPageFile;
    DWORD dwAvailPageFile;
    DWORD dwTotalVirtual;
    DWORD dwAvailVirtual;
} MEMORYSTATUS, *LPMEMORYSTATUS;

/* Local Memory Flags */
#define LMEM_FIXED          0x0000
#define LMEM_MOVEABLE       0x0002
#define LMEM_NOCOMPACT      0x0010
#define LMEM_NODISCARD      0x0020
#define LMEM_ZEROINIT       0x0040
#define LMEM_MODIFY         0x0080
#define LMEM_DISCARDABLE    0x0F00
#define LMEM_VALID_FLAGS    0x0F72
#define LMEM_INVALID_HANDLE 0x8000

#define LHND                (LMEM_MOVEABLE | LMEM_ZEROINIT)
#define LPTR                (LMEM_FIXED | LMEM_ZEROINIT)

#define NONZEROLHND         (LMEM_MOVEABLE)
#define NONZEROLPTR         (LMEM_FIXED)

#define LocalDiscard( h )   LocalReAlloc( (h), 0, LMEM_MOVEABLE )

/* Flags returned by LocalFlags (in addition to LMEM_DISCARDABLE) */
#define LMEM_DISCARDED      0x4000
#define LMEM_LOCKCOUNT      0x00FF

//
// dwCreationFlag values
//

#define DEBUG_PROCESS               0x00000001
#define DEBUG_ONLY_THIS_PROCESS     0x00000002

#define CREATE_SUSPENDED            0x00000004

#define DETACHED_PROCESS            0x00000008

#define CREATE_NEW_CONSOLE          0x00000010

#define NORMAL_PRIORITY_CLASS       0x00000020
#define IDLE_PRIORITY_CLASS         0x00000040
#define HIGH_PRIORITY_CLASS         0x00000080
#define REALTIME_PRIORITY_CLASS     0x00000100

#define CREATE_NEW_PROCESS_GROUP    0x00000200
#define CREATE_UNICODE_ENVIRONMENT  0x00000400

#define CREATE_SEPARATE_WOW_VDM     0x00000800
#define CREATE_SHARED_WOW_VDM       0x00001000

#define CREATE_DEFAULT_ERROR_MODE   0x04000000
#define CREATE_NO_WINDOW            0x08000000

#define PROFILE_USER                0x10000000
#define PROFILE_KERNEL              0x20000000
#define PROFILE_SERVER              0x40000000

#define THREAD_PRIORITY_LOWEST          THREAD_BASE_PRIORITY_MIN
#define THREAD_PRIORITY_BELOW_NORMAL    (THREAD_PRIORITY_LOWEST+1)
#define THREAD_PRIORITY_NORMAL          0
#define THREAD_PRIORITY_HIGHEST         THREAD_BASE_PRIORITY_MAX
#define THREAD_PRIORITY_ABOVE_NORMAL    (THREAD_PRIORITY_HIGHEST-1)
#define THREAD_PRIORITY_ERROR_RETURN    (MAXLONG)

#define THREAD_PRIORITY_TIME_CRITICAL   THREAD_BASE_PRIORITY_LOWRT
#define THREAD_PRIORITY_IDLE            THREAD_BASE_PRIORITY_IDLE

//
// Debug APIs
//
#define EXCEPTION_DEBUG_EVENT       1
#define CREATE_THREAD_DEBUG_EVENT   2
#define CREATE_PROCESS_DEBUG_EVENT  3
#define EXIT_THREAD_DEBUG_EVENT     4
#define EXIT_PROCESS_DEBUG_EVENT    5
#define LOAD_DLL_DEBUG_EVENT        6
#define UNLOAD_DLL_DEBUG_EVENT      7
#define OUTPUT_DEBUG_STRING_EVENT   8
#define RIP_EVENT                   9

typedef struct _EXCEPTION_DEBUG_INFO {
    EXCEPTION_RECORD ExceptionRecord;
    DWORD dwFirstChance;
} EXCEPTION_DEBUG_INFO, *LPEXCEPTION_DEBUG_INFO;

typedef struct _CREATE_THREAD_DEBUG_INFO {
    HANDLE hThread;
    LPVOID lpThreadLocalBase;
    LPTHREAD_START_ROUTINE lpStartAddress;
} CREATE_THREAD_DEBUG_INFO, *LPCREATE_THREAD_DEBUG_INFO;

typedef struct _CREATE_PROCESS_DEBUG_INFO {
    HANDLE hFile;
    HANDLE hProcess;
    HANDLE hThread;
    LPVOID lpBaseOfImage;
    DWORD dwDebugInfoFileOffset;
    DWORD nDebugInfoSize;
    LPVOID lpThreadLocalBase;
    LPTHREAD_START_ROUTINE lpStartAddress;
    LPVOID lpImageName;
    WORD fUnicode;
} CREATE_PROCESS_DEBUG_INFO, *LPCREATE_PROCESS_DEBUG_INFO;

typedef struct _EXIT_THREAD_DEBUG_INFO {
    DWORD dwExitCode;
} EXIT_THREAD_DEBUG_INFO, *LPEXIT_THREAD_DEBUG_INFO;

typedef struct _EXIT_PROCESS_DEBUG_INFO {
    DWORD dwExitCode;
} EXIT_PROCESS_DEBUG_INFO, *LPEXIT_PROCESS_DEBUG_INFO;

typedef struct _LOAD_DLL_DEBUG_INFO {
    HANDLE hFile;
    LPVOID lpBaseOfDll;
    DWORD dwDebugInfoFileOffset;
    DWORD nDebugInfoSize;
    LPVOID lpImageName;
    WORD fUnicode;
} LOAD_DLL_DEBUG_INFO, *LPLOAD_DLL_DEBUG_INFO;

typedef struct _UNLOAD_DLL_DEBUG_INFO {
    LPVOID lpBaseOfDll;
} UNLOAD_DLL_DEBUG_INFO, *LPUNLOAD_DLL_DEBUG_INFO;

typedef struct _OUTPUT_DEBUG_STRING_INFO {
    LPSTR lpDebugStringData;
    WORD fUnicode;
    WORD nDebugStringLength;
} OUTPUT_DEBUG_STRING_INFO, *LPOUTPUT_DEBUG_STRING_INFO;

typedef struct _RIP_INFO {
    DWORD dwError;
    DWORD dwType;
} RIP_INFO, *LPRIP_INFO;


typedef struct _DEBUG_EVENT {
    DWORD dwDebugEventCode;
    DWORD dwProcessId;
    DWORD dwThreadId;
    union {
        EXCEPTION_DEBUG_INFO Exception;
        CREATE_THREAD_DEBUG_INFO CreateThread;
        CREATE_PROCESS_DEBUG_INFO CreateProcessInfo;
        EXIT_THREAD_DEBUG_INFO ExitThread;
        EXIT_PROCESS_DEBUG_INFO ExitProcess;
        LOAD_DLL_DEBUG_INFO LoadDll;
        UNLOAD_DLL_DEBUG_INFO UnloadDll;
        OUTPUT_DEBUG_STRING_INFO DebugString;
        RIP_INFO RipInfo;
    } u;
} DEBUG_EVENT, *LPDEBUG_EVENT;

#if !defined(MIDL_PASS)
typedef PCONTEXT LPCONTEXT;
typedef PEXCEPTION_RECORD LPEXCEPTION_RECORD;
typedef PEXCEPTION_POINTERS LPEXCEPTION_POINTERS;
#endif

#define DRIVE_UNKNOWN     0
#define DRIVE_NO_ROOT_DIR 1
#define DRIVE_REMOVABLE   2
#define DRIVE_FIXED       3
#define DRIVE_REMOTE      4
#define DRIVE_CDROM       5
#define DRIVE_RAMDISK     6


#define GetFreeSpace(w)                 (0x100000L)


#define FILE_TYPE_UNKNOWN   0x0000
#define FILE_TYPE_DISK      0x0001
#define FILE_TYPE_CHAR      0x0002
#define FILE_TYPE_PIPE      0x0003
#define FILE_TYPE_REMOTE    0x8000


#define STD_INPUT_HANDLE    (DWORD)-10
#define STD_OUTPUT_HANDLE   (DWORD)-11
#define STD_ERROR_HANDLE      (DWORD)-12

#define NOPARITY            0
#define ODDPARITY           1
#define EVENPARITY          2
#define MARKPARITY          3
#define SPACEPARITY         4

#define ONESTOPBIT          0
#define ONE5STOPBITS        1
#define TWOSTOPBITS         2

#define IGNORE              0       // Ignore signal
#define INFINITE            0xFFFFFFFF  // Infinite timeout

//
// Basud rates at which the communication device operates
//

#define CBR_110             110
#define CBR_300             300
#define CBR_600             600
#define CBR_1200            1200
#define CBR_2400            2400
#define CBR_4800            4800
#define CBR_9600            9600
#define CBR_14400           14400
#define CBR_19200           19200
#define CBR_38400           38400
#define CBR_56000           56000
#define CBR_57600           57600
#define CBR_115200          115200
#define CBR_128000          128000
#define CBR_256000          256000

//
// Error Flags
//

#define CE_RXOVER           0x0001  // Receive Queue overflow
#define CE_OVERRUN          0x0002  // Receive Overrun Error
#define CE_RXPARITY         0x0004  // Receive Parity Error
#define CE_FRAME            0x0008  // Receive Framing error
#define CE_BREAK            0x0010  // Break Detected
#define CE_TXFULL           0x0100  // TX Queue is full
#define CE_PTO              0x0200  // LPTx Timeout
#define CE_IOE              0x0400  // LPTx I/O Error
#define CE_DNS              0x0800  // LPTx Device not selected
#define CE_OOP              0x1000  // LPTx Out-Of-Paper
#define CE_MODE             0x8000  // Requested mode unsupported

#define IE_BADID            (-1)    // Invalid or unsupported id
#define IE_OPEN             (-2)    // Device Already Open
#define IE_NOPEN            (-3)    // Device Not Open
#define IE_MEMORY           (-4)    // Unable to allocate queues
#define IE_DEFAULT          (-5)    // Error in default parameters
#define IE_HARDWARE         (-10)   // Hardware Not Present
#define IE_BYTESIZE         (-11)   // Illegal Byte Size
#define IE_BAUDRATE         (-12)   // Unsupported BaudRate

//
// Events
//

#define EV_RXCHAR           0x0001  // Any Character received
#define EV_RXFLAG           0x0002  // Received certain character
#define EV_TXEMPTY          0x0004  // Transmitt Queue Empty
#define EV_CTS              0x0008  // CTS changed state
#define EV_DSR              0x0010  // DSR changed state
#define EV_RLSD             0x0020  // RLSD changed state
#define EV_BREAK            0x0040  // BREAK received
#define EV_ERR              0x0080  // Line status error occurred
#define EV_RING             0x0100  // Ring signal detected
#define EV_PERR             0x0200  // Printer error occured
#define EV_RX80FULL         0x0400  // Receive buffer is 80 percent full
#define EV_EVENT1           0x0800  // Provider specific event 1
#define EV_EVENT2           0x1000  // Provider specific event 2

//
// Escape Functions
//

#define SETXOFF             1       // Simulate XOFF received
#define SETXON              2       // Simulate XON received
#define SETRTS              3       // Set RTS high
#define CLRRTS              4       // Set RTS low
#define SETDTR              5       // Set DTR high
#define CLRDTR              6       // Set DTR low
#define RESETDEV            7       // Reset device if possible
#define SETBREAK            8       // Set the device break line.
#define CLRBREAK            9       // Clear the device break line.

//
// PURGE function flags.
//
#define PURGE_TXABORT       0x0001  // Kill the pending/current writes to the comm port.
#define PURGE_RXABORT       0x0002  // Kill the pending/current reads to the comm port.
#define PURGE_TXCLEAR       0x0004  // Kill the transmit queue if there.
#define PURGE_RXCLEAR       0x0008  // Kill the typeahead buffer if there.

#define LPTx                0x80    // Set if ID is for LPT device

//
// Modem Status Flags
//
#define MS_CTS_ON           ((DWORD)0x0010)
#define MS_DSR_ON           ((DWORD)0x0020)
#define MS_RING_ON          ((DWORD)0x0040)
#define MS_RLSD_ON          ((DWORD)0x0080)

//
// WaitSoundState() Constants
//

#define S_QUEUEEMPTY        0
#define S_THRESHOLD         1
#define S_ALLTHRESHOLD      2

//
// Accent Modes
//

#define S_NORMAL      0
#define S_LEGATO      1
#define S_STACCATO    2

//
// SetSoundNoise() Sources
//

#define S_PERIOD512   0     // Freq = N/512 high pitch, less coarse hiss
#define S_PERIOD1024  1     // Freq = N/1024
#define S_PERIOD2048  2     // Freq = N/2048 low pitch, more coarse hiss
#define S_PERIODVOICE 3     // Source is frequency from voice channel (3)
#define S_WHITE512    4     // Freq = N/512 high pitch, less coarse hiss
#define S_WHITE1024   5     // Freq = N/1024
#define S_WHITE2048   6     // Freq = N/2048 low pitch, more coarse hiss
#define S_WHITEVOICE  7     // Source is frequency from voice channel (3)

#define S_SERDVNA     (-1)  // Device not available
#define S_SEROFM      (-2)  // Out of memory
#define S_SERMACT     (-3)  // Music active
#define S_SERQFUL     (-4)  // Queue full
#define S_SERBDNT     (-5)  // Invalid note
#define S_SERDLN      (-6)  // Invalid note length
#define S_SERDCC      (-7)  // Invalid note count
#define S_SERDTP      (-8)  // Invalid tempo
#define S_SERDVL      (-9)  // Invalid volume
#define S_SERDMD      (-10) // Invalid mode
#define S_SERDSH      (-11) // Invalid shape
#define S_SERDPT      (-12) // Invalid pitch
#define S_SERDFQ      (-13) // Invalid frequency
#define S_SERDDR      (-14) // Invalid duration
#define S_SERDSR      (-15) // Invalid source
#define S_SERDST      (-16) // Invalid state

#define NMPWAIT_WAIT_FOREVER            0xffffffff
#define NMPWAIT_NOWAIT                  0x00000001
#define NMPWAIT_USE_DEFAULT_WAIT        0x00000000

#define FS_CASE_IS_PRESERVED            FILE_CASE_PRESERVED_NAMES
#define FS_CASE_SENSITIVE               FILE_CASE_SENSITIVE_SEARCH
#define FS_UNICODE_STORED_ON_DISK       FILE_UNICODE_ON_DISK
#define FS_PERSISTENT_ACLS              FILE_PERSISTENT_ACLS
#define FS_VOL_IS_COMPRESSED            FILE_VOLUME_IS_COMPRESSED
#define FS_FILE_COMPRESSION             FILE_FILE_COMPRESSION






#define FILE_MAP_COPY       SECTION_QUERY
#define FILE_MAP_WRITE      SECTION_MAP_WRITE
#define FILE_MAP_READ       SECTION_MAP_READ
#define FILE_MAP_ALL_ACCESS SECTION_ALL_ACCESS

#define OF_READ             0x00000000
#define OF_WRITE            0x00000001
#define OF_READWRITE        0x00000002
#define OF_SHARE_COMPAT     0x00000000
#define OF_SHARE_EXCLUSIVE  0x00000010
#define OF_SHARE_DENY_WRITE 0x00000020
#define OF_SHARE_DENY_READ  0x00000030
#define OF_SHARE_DENY_NONE  0x00000040
#define OF_PARSE            0x00000100
#define OF_DELETE           0x00000200
#define OF_VERIFY           0x00000400
#define OF_CANCEL           0x00000800
#define OF_CREATE           0x00001000
#define OF_PROMPT           0x00002000
#define OF_EXIST            0x00004000
#define OF_REOPEN           0x00008000

#define OFS_MAXPATHNAME 128
typedef struct _OFSTRUCT {
    BYTE cBytes;
    BYTE fFixedDisk;
    WORD nErrCode;
    WORD Reserved1;
    WORD Reserved2;
    CHAR szPathName[OFS_MAXPATHNAME];
} OFSTRUCT, *LPOFSTRUCT, *POFSTRUCT;

//
// The MS-MIPS and Alpha compilers support intrinsic functions for interlocked
// increment, decrement, and exchange.
//

#if (defined(_M_MRX000) || defined(_M_ALPHA)) && !defined(RC_INVOKED)

#define InterlockedIncrement _InterlockedIncrement
#define InterlockedDecrement _InterlockedDecrement
#define InterlockedExchange _InterlockedExchange

LONG
WINAPI
InterlockedIncrement(
    LPLONG lpAddend
    );

LONG
WINAPI
InterlockedDecrement(
    LPLONG lpAddend
    );

LONG
WINAPI
InterlockedExchange(
    LPLONG Target,
    LONG Value
    );

#pragma intrinsic(_InterlockedIncrement)
#pragma intrinsic(_InterlockedDecrement)
#pragma intrinsic(_InterlockedExchange)

#else

#ifndef _NTOS_

WINBASEAPI
LONG
WINAPI
InterlockedIncrement(
    LPLONG lpAddend
    );

WINBASEAPI
LONG
WINAPI
InterlockedDecrement(
    LPLONG lpAddend
    );

WINBASEAPI
LONG
WINAPI
InterlockedExchange(
    LPLONG Target,
    LONG Value
    );

#endif /* NT_INCLUDED */

#endif

WINBASEAPI
BOOL
WINAPI
FreeResource(
        HGLOBAL hResData
        );

WINBASEAPI
LPVOID
WINAPI
LockResource(
        HGLOBAL hResData
        );

#define UnlockResource(hResData) ((hResData), 0)
#define MAXINTATOM 0xC000
#define MAKEINTATOM(i)  (LPTSTR)((DWORD)((WORD)(i)))
#define INVALID_ATOM ((ATOM)0)

int
WINAPI
WinMain(
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    LPSTR lpCmdLine,
    int nShowCmd
    );

WINBASEAPI
BOOL
WINAPI
FreeLibrary(
    HMODULE hLibModule
    );


WINBASEAPI
VOID
WINAPI
FreeLibraryAndExitThread(
    HMODULE hLibModule,
    DWORD dwExitCode
    );

WINBASEAPI
BOOL
WINAPI
DisableThreadLibraryCalls(
    HMODULE hLibModule
    );

WINBASEAPI
FARPROC
WINAPI
GetProcAddress(
    HMODULE hModule,
    LPCSTR lpProcName
    );

WINBASEAPI
DWORD
WINAPI
GetVersion( VOID );

WINBASEAPI
HGLOBAL
WINAPI
GlobalAlloc(
    UINT uFlags,
    DWORD dwBytes
    );

WINBASEAPI
HGLOBAL
WINAPI
GlobalReAlloc(
    HGLOBAL hMem,
    DWORD dwBytes,
    UINT uFlags
    );

WINBASEAPI
DWORD
WINAPI
GlobalSize(
    HGLOBAL hMem
    );

WINBASEAPI
UINT
WINAPI
GlobalFlags(
    HGLOBAL hMem
    );


WINBASEAPI
LPVOID
WINAPI
GlobalLock(
    HGLOBAL hMem
    );

//!!!MWH My version  win31 = DWORD WINAPI GlobalHandle(UINT)
WINBASEAPI
HGLOBAL
WINAPI
GlobalHandle(
    LPCVOID pMem
    );


WINBASEAPI
BOOL
WINAPI
GlobalUnlock(
    HGLOBAL hMem
    );


WINBASEAPI
HGLOBAL
WINAPI
GlobalFree(
    HGLOBAL hMem
    );

WINBASEAPI
UINT
WINAPI
GlobalCompact(
    DWORD dwMinFree
    );

WINBASEAPI
VOID
WINAPI
GlobalFix(
    HGLOBAL hMem
    );

WINBASEAPI
VOID
WINAPI
GlobalUnfix(
    HGLOBAL hMem
    );

WINBASEAPI
LPVOID
WINAPI
GlobalWire(
    HGLOBAL hMem
    );

WINBASEAPI
BOOL
WINAPI
GlobalUnWire(
    HGLOBAL hMem
    );

WINBASEAPI
VOID
WINAPI
GlobalMemoryStatus(
    LPMEMORYSTATUS lpBuffer
    );

WINBASEAPI
HLOCAL
WINAPI
LocalAlloc(
    UINT uFlags,
    UINT uBytes
    );

WINBASEAPI
HLOCAL
WINAPI
LocalReAlloc(
    HLOCAL hMem,
    UINT uBytes,
    UINT uFlags
    );

WINBASEAPI
LPVOID
WINAPI
LocalLock(
    HLOCAL hMem
    );

WINBASEAPI
HLOCAL
WINAPI
LocalHandle(
    LPCVOID pMem
    );

WINBASEAPI
BOOL
WINAPI
LocalUnlock(
    HLOCAL hMem
    );

WINBASEAPI
UINT
WINAPI
LocalSize(
    HLOCAL hMem
    );

WINBASEAPI
UINT
WINAPI
LocalFlags(
    HLOCAL hMem
    );

WINBASEAPI
HLOCAL
WINAPI
LocalFree(
    HLOCAL hMem
    );

WINBASEAPI
UINT
WINAPI
LocalShrink(
    HLOCAL hMem,
    UINT cbNewSize
    );

WINBASEAPI
UINT
WINAPI
LocalCompact(
    UINT uMinFree
    );

WINBASEAPI
BOOL
WINAPI
FlushInstructionCache(
    HANDLE hProcess,
    LPCVOID lpBaseAddress,
    DWORD dwSize
    );

WINBASEAPI
LPVOID
WINAPI
VirtualAlloc(
    LPVOID lpAddress,
    DWORD dwSize,
    DWORD flAllocationType,
    DWORD flProtect
    );

WINBASEAPI
BOOL
WINAPI
VirtualFree(
    LPVOID lpAddress,
    DWORD dwSize,
    DWORD dwFreeType
    );

WINBASEAPI
BOOL
WINAPI
VirtualProtect(
    LPVOID lpAddress,
    DWORD dwSize,
    DWORD flNewProtect,
    PDWORD lpflOldProtect
    );

WINBASEAPI
DWORD
WINAPI
VirtualQuery(
    LPCVOID lpAddress,
    PMEMORY_BASIC_INFORMATION lpBuffer,
    DWORD dwLength
    );

WINBASEAPI
BOOL
WINAPI
VirtualProtectEx(
    HANDLE hProcess,
    LPVOID lpAddress,
    DWORD dwSize,
    DWORD flNewProtect,
    PDWORD lpflOldProtect
    );

WINBASEAPI
DWORD
WINAPI
VirtualQueryEx(
    HANDLE hProcess,
    LPCVOID lpAddress,
    PMEMORY_BASIC_INFORMATION lpBuffer,
    DWORD dwLength
    );

WINBASEAPI
HANDLE
WINAPI
HeapCreate(
    DWORD flOptions,
    DWORD dwInitialSize,
    DWORD dwMaximumSize
    );

WINBASEAPI
BOOL
WINAPI
HeapDestroy(
    HANDLE hHeap
    );


WINBASEAPI
LPVOID
WINAPI
HeapAlloc(
    HANDLE hHeap,
    DWORD dwFlags,
    DWORD dwBytes
    );

WINBASEAPI
LPVOID
WINAPI
HeapReAlloc(
    HANDLE hHeap,
    DWORD dwFlags,
    LPVOID lpMem,
    DWORD dwBytes
    );

WINBASEAPI
BOOL
WINAPI
HeapFree(
    HANDLE hHeap,
    DWORD dwFlags,
    LPVOID lpMem
    );

WINBASEAPI
DWORD
WINAPI
HeapSize(
    HANDLE hHeap,
    DWORD dwFlags,
    LPCVOID lpMem
    );

WINBASEAPI
BOOL
WINAPI
HeapValidate(
    HANDLE hHeap,
    DWORD dwFlags,
    LPCVOID lpMem
    );

WINBASEAPI
UINT
WINAPI
HeapCompact(
    HANDLE hHeap,
    DWORD dwFlags
    );

WINBASEAPI
HANDLE
WINAPI
GetProcessHeap( VOID );

WINBASEAPI
DWORD
WINAPI
GetProcessHeaps(
    DWORD NumberOfHeaps,
    PHANDLE ProcessHeaps
    );

typedef struct _PROCESS_HEAP_ENTRY {
    PVOID lpData;
    DWORD cbData;
    BYTE cbOverhead;
    BYTE iRegionIndex;
    WORD wFlags;
    union {
        struct {
            HANDLE hMem;
            DWORD dwReserved[ 3 ];
        } Block;
        struct {
            DWORD dwCommittedSize;
            DWORD dwUnCommittedSize;
            LPVOID lpFirstBlock;
            LPVOID lpLastBlock;
        } Region;
    };
} PROCESS_HEAP_ENTRY, *LPPROCESS_HEAP_ENTRY, *PPROCESS_HEAP_ENTRY;

#define PROCESS_HEAP_REGION             0x0001
#define PROCESS_HEAP_UNCOMMITTED_RANGE  0x0002
#define PROCESS_HEAP_ENTRY_BUSY         0x0004
#define PROCESS_HEAP_ENTRY_MOVEABLE     0x0010
#define PROCESS_HEAP_ENTRY_DDESHARE     0x0020

WINBASEAPI
BOOL
WINAPI
HeapLock(
    HANDLE hHeap
    );

WINBASEAPI
BOOL
WINAPI
HeapUnlock(
    HANDLE hHeap
    );


WINBASEAPI
BOOL
WINAPI
HeapWalk(
    HANDLE hHeap,
    LPPROCESS_HEAP_ENTRY lpEntry
    );

// GetBinaryType return values.

#define SCS_32BIT_BINARY    0
#define SCS_DOS_BINARY      1
#define SCS_WOW_BINARY      2
#define SCS_PIF_BINARY      3
#define SCS_POSIX_BINARY    4
#define SCS_OS216_BINARY    5

WINBASEAPI
BOOL
WINAPI
GetBinaryTypeA(
    LPCSTR lpApplicationName,
    LPDWORD lpBinaryType
    );
WINBASEAPI
BOOL
WINAPI
GetBinaryTypeW(
    LPCWSTR lpApplicationName,
    LPDWORD lpBinaryType
    );
#ifdef UNICODE
#define GetBinaryType  GetBinaryTypeW
#else
#define GetBinaryType  GetBinaryTypeA
#endif // !UNICODE

WINBASEAPI
DWORD
WINAPI
GetShortPathNameA(
    LPCSTR lpszLongPath,
    LPSTR  lpszShortPath,
    DWORD    cchBuffer
    );
WINBASEAPI
DWORD
WINAPI
GetShortPathNameW(
    LPCWSTR lpszLongPath,
    LPWSTR  lpszShortPath,
    DWORD    cchBuffer
    );
#ifdef UNICODE
#define GetShortPathName  GetShortPathNameW
#else
#define GetShortPathName  GetShortPathNameA
#endif // !UNICODE

WINBASEAPI
BOOL
WINAPI
GetProcessAffinityMask(
    HANDLE hProcess,
    LPDWORD lpProcessAffinityMask,
    LPDWORD lpSystemAffinityMask
    );

WINBASEAPI
BOOL
WINAPI
GetProcessTimes(
    HANDLE hProcess,
    LPFILETIME lpCreationTime,
    LPFILETIME lpExitTime,
    LPFILETIME lpKernelTime,
    LPFILETIME lpUserTime
    );

WINBASEAPI
BOOL
WINAPI
GetProcessWorkingSetSize(
    HANDLE hProcess,
    LPDWORD lpMinimumWorkingSetSize,
    LPDWORD lpMaximumWorkingSetSize
    );

WINBASEAPI
BOOL
WINAPI
SetProcessWorkingSetSize(
    HANDLE hProcess,
    DWORD dwMinimumWorkingSetSize,
    DWORD dwMaximumWorkingSetSize
    );

WINBASEAPI
HANDLE
WINAPI
OpenProcess(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    DWORD dwProcessId
    );

WINBASEAPI
HANDLE
WINAPI
GetCurrentProcess(
    VOID
    );

WINBASEAPI
DWORD
WINAPI
GetCurrentProcessId(
    VOID
    );

WINBASEAPI
VOID
WINAPI
ExitProcess(
    UINT uExitCode
    );

WINBASEAPI
BOOL
WINAPI
TerminateProcess(
    HANDLE hProcess,
    UINT uExitCode
    );

WINBASEAPI
BOOL
WINAPI
GetExitCodeProcess(
    HANDLE hProcess,
    LPDWORD lpExitCode
    );


WINBASEAPI
VOID
WINAPI
FatalExit(
    int ExitCode
    );

WINBASEAPI
LPSTR
WINAPI
GetEnvironmentStrings(
    VOID
    );

WINBASEAPI
LPWSTR
WINAPI
GetEnvironmentStringsW(
    VOID
    );

#ifdef UNICODE
#define GetEnvironmentStrings  GetEnvironmentStringsW
#else
#define GetEnvironmentStringsA  GetEnvironmentStrings
#endif // !UNICODE

WINBASEAPI
BOOL
WINAPI
FreeEnvironmentStringsA(
    LPSTR
    );
WINBASEAPI
BOOL
WINAPI
FreeEnvironmentStringsW(
    LPWSTR
    );
#ifdef UNICODE
#define FreeEnvironmentStrings  FreeEnvironmentStringsW
#else
#define FreeEnvironmentStrings  FreeEnvironmentStringsA
#endif // !UNICODE

WINBASEAPI
VOID
WINAPI
RaiseException(
    DWORD dwExceptionCode,
    DWORD dwExceptionFlags,
    DWORD nNumberOfArguments,
    CONST DWORD *lpArguments
    );

WINBASEAPI
LONG
WINAPI
UnhandledExceptionFilter(
    struct _EXCEPTION_POINTERS *ExceptionInfo
    );

typedef LONG (WINAPI *PTOP_LEVEL_EXCEPTION_FILTER)(
    struct _EXCEPTION_POINTERS *ExceptionInfo
    );
typedef PTOP_LEVEL_EXCEPTION_FILTER LPTOP_LEVEL_EXCEPTION_FILTER;

WINBASEAPI
LPTOP_LEVEL_EXCEPTION_FILTER
WINAPI
SetUnhandledExceptionFilter(
    LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter
    );

WINBASEAPI
HANDLE
WINAPI
CreateThread(
    LPSECURITY_ATTRIBUTES lpThreadAttributes,
    DWORD dwStackSize,
    LPTHREAD_START_ROUTINE lpStartAddress,
    LPVOID lpParameter,
    DWORD dwCreationFlags,
    LPDWORD lpThreadId
    );

WINBASEAPI
HANDLE
WINAPI
CreateRemoteThread(
    HANDLE hProcess,
    LPSECURITY_ATTRIBUTES lpThreadAttributes,
    DWORD dwStackSize,
    LPTHREAD_START_ROUTINE lpStartAddress,
    LPVOID lpParameter,
    DWORD dwCreationFlags,
    LPDWORD lpThreadId
    );

WINBASEAPI
HANDLE
WINAPI
GetCurrentThread(
    VOID
    );

WINBASEAPI
DWORD
WINAPI
GetCurrentThreadId(
    VOID
    );

WINBASEAPI
DWORD
WINAPI
SetThreadAffinityMask(
    HANDLE hThread,
    DWORD dwThreadAffinityMask
    );

WINBASEAPI
BOOL
WINAPI
SetThreadPriority(
    HANDLE hThread,
    int nPriority
    );

WINBASEAPI
int
WINAPI
GetThreadPriority(
    HANDLE hThread
    );

WINBASEAPI
BOOL
WINAPI
GetThreadTimes(
    HANDLE hThread,
    LPFILETIME lpCreationTime,
    LPFILETIME lpExitTime,
    LPFILETIME lpKernelTime,
    LPFILETIME lpUserTime
    );

WINBASEAPI
VOID
WINAPI
ExitThread(
    DWORD dwExitCode
    );

WINBASEAPI
BOOL
WINAPI
TerminateThread(
    HANDLE hThread,
    DWORD dwExitCode
    );

WINBASEAPI
BOOL
WINAPI
GetExitCodeThread(
    HANDLE hThread,
    LPDWORD lpExitCode
    );

WINBASEAPI
BOOL
WINAPI
GetThreadSelectorEntry(
    HANDLE hThread,
    DWORD dwSelector,
    LPLDT_ENTRY lpSelectorEntry
    );

WINBASEAPI
DWORD
WINAPI
GetLastError(
    VOID
    );

WINBASEAPI
VOID
WINAPI
SetLastError(
    DWORD dwErrCode
    );

WINBASEAPI
BOOL
WINAPI
GetOverlappedResult(
    HANDLE hFile,
    LPOVERLAPPED lpOverlapped,
    LPDWORD lpNumberOfBytesTransferred,
    BOOL bWait
    );

WINBASEAPI
HANDLE
WINAPI
CreateIoCompletionPort(
    HANDLE FileHandle,
    HANDLE ExistingCompletionPort,
    DWORD CompletionKey,
    DWORD NumberOfConcurrentThreads
    );

WINBASEAPI
BOOL
WINAPI
GetQueuedCompletionStatus(
    HANDLE CompletionPort,
    LPDWORD lpNumberOfBytesTransferred,
    LPDWORD lpCompletionKey,
    LPOVERLAPPED *lpOverlapped,
    DWORD dwMilliseconds
    );

WINBASEAPI
BOOL
WINAPI
PostQueuedCompletionStatus(
    HANDLE CompletionPort,
    DWORD dwNumberOfBytesTransferred,
    DWORD dwCompletionKey,
    LPOVERLAPPED lpOverlapped
    );

#define SEM_FAILCRITICALERRORS      0x0001
#define SEM_NOGPFAULTERRORBOX       0x0002
#define SEM_NOALIGNMENTFAULTEXCEPT  0x0004
#define SEM_NOOPENFILEERRORBOX      0x8000

WINBASEAPI
UINT
WINAPI
SetErrorMode(
    UINT uMode
    );

WINBASEAPI
BOOL
WINAPI
ReadProcessMemory(
    HANDLE hProcess,
    LPCVOID lpBaseAddress,
    LPVOID lpBuffer,
    DWORD nSize,
    LPDWORD lpNumberOfBytesRead
    );

WINBASEAPI
BOOL
WINAPI
WriteProcessMemory(
    HANDLE hProcess,
    LPVOID lpBaseAddress,
    LPVOID lpBuffer,
    DWORD nSize,
    LPDWORD lpNumberOfBytesWritten
    );

#if !defined(MIDL_PASS)
WINBASEAPI
BOOL
WINAPI
GetThreadContext(
    HANDLE hThread,
    LPCONTEXT lpContext
    );

WINBASEAPI
BOOL
WINAPI
SetThreadContext(
    HANDLE hThread,
    CONST CONTEXT *lpContext
    );
#endif

WINBASEAPI
DWORD
WINAPI
SuspendThread(
    HANDLE hThread
    );

WINBASEAPI
DWORD
WINAPI
ResumeThread(
    HANDLE hThread
    );

WINBASEAPI
VOID
WINAPI
DebugBreak(
    VOID
    );

WINBASEAPI
BOOL
WINAPI
WaitForDebugEvent(
    LPDEBUG_EVENT lpDebugEvent,
    DWORD dwMilliseconds
    );

WINBASEAPI
BOOL
WINAPI
ContinueDebugEvent(
    DWORD dwProcessId,
    DWORD dwThreadId,
    DWORD dwContinueStatus
    );

WINBASEAPI
BOOL
WINAPI
DebugActiveProcess(
    DWORD dwProcessId
    );

WINBASEAPI
VOID
WINAPI
InitializeCriticalSection(
    LPCRITICAL_SECTION lpCriticalSection
    );

WINBASEAPI
VOID
WINAPI
EnterCriticalSection(
    LPCRITICAL_SECTION lpCriticalSection
    );

WINBASEAPI
VOID
WINAPI
LeaveCriticalSection(
    LPCRITICAL_SECTION lpCriticalSection
    );

WINBASEAPI
VOID
WINAPI
DeleteCriticalSection(
    LPCRITICAL_SECTION lpCriticalSection
    );

WINBASEAPI
BOOL
WINAPI
SetEvent(
    HANDLE hEvent
    );

WINBASEAPI
BOOL
WINAPI
ResetEvent(
    HANDLE hEvent
    );

WINBASEAPI
BOOL
WINAPI
PulseEvent(
    HANDLE hEvent
    );

WINBASEAPI
BOOL
WINAPI
ReleaseSemaphore(
    HANDLE hSemaphore,
    LONG lReleaseCount,
    LPLONG lpPreviousCount
    );

WINBASEAPI
BOOL
WINAPI
ReleaseMutex(
    HANDLE hMutex
    );

WINBASEAPI
DWORD
WINAPI
WaitForSingleObject(
    HANDLE hHandle,
    DWORD dwMilliseconds
    );

WINBASEAPI
DWORD
WINAPI
WaitForMultipleObjects(
    DWORD nCount,
    CONST HANDLE *lpHandles,
    BOOL bWaitAll,
    DWORD dwMilliseconds
    );

WINBASEAPI
VOID
WINAPI
Sleep(
    DWORD dwMilliseconds
    );

WINBASEAPI
HGLOBAL
WINAPI
LoadResource(
    HMODULE hModule,
    HRSRC hResInfo
    );

WINBASEAPI
DWORD
WINAPI
SizeofResource(
    HMODULE hModule,
    HRSRC hResInfo
    );


WINBASEAPI
ATOM
WINAPI
GlobalDeleteAtom(
    ATOM nAtom
    );

WINBASEAPI
BOOL
WINAPI
InitAtomTable(
    DWORD nSize
    );

WINBASEAPI
ATOM
WINAPI
DeleteAtom(
    ATOM nAtom
    );

WINBASEAPI
UINT
WINAPI
SetHandleCount(
    UINT uNumber
    );

WINBASEAPI
DWORD
WINAPI
GetLogicalDrives(
    VOID
    );

WINBASEAPI
BOOL
WINAPI
LockFile(
    HANDLE hFile,
    DWORD dwFileOffsetLow,
    DWORD dwFileOffsetHigh,
    DWORD nNumberOfBytesToLockLow,
    DWORD nNumberOfBytesToLockHigh
    );

WINBASEAPI
BOOL
WINAPI
UnlockFile(
    HANDLE hFile,
    DWORD dwFileOffsetLow,
    DWORD dwFileOffsetHigh,
    DWORD nNumberOfBytesToUnlockLow,
    DWORD nNumberOfBytesToUnlockHigh
    );

WINBASEAPI
BOOL
WINAPI
LockFileEx(
    HANDLE hFile,
    DWORD dwFlags,
    DWORD dwReserved,
    DWORD nNumberOfBytesToLockLow,
    DWORD nNumberOfBytesToLockHigh,
    LPOVERLAPPED lpOverlapped
    );

#define LOCKFILE_FAIL_IMMEDIATELY   0x00000001
#define LOCKFILE_EXCLUSIVE_LOCK     0x00000002

WINBASEAPI
BOOL
WINAPI
UnlockFileEx(
    HANDLE hFile,
    DWORD dwReserved,
    DWORD nNumberOfBytesToUnlockLow,
    DWORD nNumberOfBytesToUnlockHigh,
    LPOVERLAPPED lpOverlapped
    );

typedef struct _BY_HANDLE_FILE_INFORMATION {
    DWORD dwFileAttributes;
    FILETIME ftCreationTime;
    FILETIME ftLastAccessTime;
    FILETIME ftLastWriteTime;
    DWORD dwVolumeSerialNumber;
    DWORD nFileSizeHigh;
    DWORD nFileSizeLow;
    DWORD nNumberOfLinks;
    DWORD nFileIndexHigh;
    DWORD nFileIndexLow;
} BY_HANDLE_FILE_INFORMATION, *PBY_HANDLE_FILE_INFORMATION, *LPBY_HANDLE_FILE_INFORMATION;

WINBASEAPI
BOOL
WINAPI
GetFileInformationByHandle(
    HANDLE hFile,
    LPBY_HANDLE_FILE_INFORMATION lpFileInformation
    );

WINBASEAPI
DWORD
WINAPI
GetFileType(
    HANDLE hFile
    );

WINBASEAPI
DWORD
WINAPI
GetFileSize(
    HANDLE hFile,
    LPDWORD lpFileSizeHigh
    );

WINBASEAPI
HANDLE
WINAPI
GetStdHandle(
    DWORD nStdHandle
    );

WINBASEAPI
BOOL
WINAPI
SetStdHandle(
    DWORD nStdHandle,
    HANDLE hHandle
    );

WINBASEAPI
BOOL
WINAPI
WriteFile(
    HANDLE hFile,
    LPCVOID lpBuffer,
    DWORD nNumberOfBytesToWrite,
    LPDWORD lpNumberOfBytesWritten,
    LPOVERLAPPED lpOverlapped
    );

WINBASEAPI
BOOL
WINAPI
ReadFile(
    HANDLE hFile,
    LPVOID lpBuffer,
    DWORD nNumberOfBytesToRead,
    LPDWORD lpNumberOfBytesRead,
    LPOVERLAPPED lpOverlapped
    );

WINBASEAPI
BOOL
WINAPI
FlushFileBuffers(
    HANDLE hFile
    );

WINBASEAPI
BOOL
WINAPI
DeviceIoControl(
    HANDLE hDevice,
    DWORD dwIoControlCode,
    LPVOID lpInBuffer,
    DWORD nInBufferSize,
    LPVOID lpOutBuffer,
    DWORD nOutBufferSize,
    LPDWORD lpBytesReturned,
    LPOVERLAPPED lpOverlapped
    );

WINBASEAPI
BOOL
WINAPI
SetEndOfFile(
    HANDLE hFile
    );

WINBASEAPI
DWORD
WINAPI
SetFilePointer(
    HANDLE hFile,
    LONG lDistanceToMove,
    PLONG lpDistanceToMoveHigh,
    DWORD dwMoveMethod
    );

WINBASEAPI
BOOL
WINAPI
FindClose(
    HANDLE hFindFile
    );

WINBASEAPI
BOOL
WINAPI
GetFileTime(
    HANDLE hFile,
    LPFILETIME lpCreationTime,
    LPFILETIME lpLastAccessTime,
    LPFILETIME lpLastWriteTime
    );

WINBASEAPI
BOOL
WINAPI
SetFileTime(
    HANDLE hFile,
    CONST FILETIME *lpCreationTime,
    CONST FILETIME *lpLastAccessTime,
    CONST FILETIME *lpLastWriteTime
    );

WINBASEAPI
BOOL
WINAPI
CloseHandle(
    HANDLE hObject
    );

WINBASEAPI
BOOL
WINAPI
DuplicateHandle(
    HANDLE hSourceProcessHandle,
    HANDLE hSourceHandle,
    HANDLE hTargetProcessHandle,
    LPHANDLE lpTargetHandle,
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    DWORD dwOptions
    );

WINBASEAPI
BOOL
WINAPI
GetHandleInformation(
    HANDLE hObject,
    LPDWORD lpdwFlags
    );

WINBASEAPI
BOOL
WINAPI
SetHandleInformation(
    HANDLE hObject,
    DWORD dwMask,
    DWORD dwFlags
    );

#define HANDLE_FLAG_INHERIT             0x00000001
#define HANDLE_FLAG_PROTECT_FROM_CLOSE  0x00000002

#define HINSTANCE_ERROR 32

WINBASEAPI
DWORD
WINAPI
LoadModule(
    LPCSTR lpModuleName,
    LPVOID lpParameterBlock
    );

WINBASEAPI
UINT
WINAPI
WinExec(
    LPCSTR lpCmdLine,
    UINT uCmdShow
    );

WINBASEAPI
BOOL
WINAPI
ClearCommBreak(
    HANDLE hFile
    );

WINBASEAPI
BOOL
WINAPI
ClearCommError(
    HANDLE hFile,
    LPDWORD lpErrors,
    LPCOMSTAT lpStat
    );

WINBASEAPI
BOOL
WINAPI
SetupComm(
    HANDLE hFile,
    DWORD dwInQueue,
    DWORD dwOutQueue
    );

WINBASEAPI
BOOL
WINAPI
EscapeCommFunction(
    HANDLE hFile,
    DWORD dwFunc
    );

WINBASEAPI
BOOL
WINAPI
GetCommConfig(
    HANDLE hCommDev,
    LPCOMMCONFIG lpCC,
    LPDWORD lpdwSize
    );

WINBASEAPI
BOOL
WINAPI
GetCommMask(
    HANDLE hFile,
    LPDWORD lpEvtMask
    );

WINBASEAPI
BOOL
WINAPI
GetCommProperties(
    HANDLE hFile,
    LPCOMMPROP lpCommProp
    );

WINBASEAPI
BOOL
WINAPI
GetCommModemStatus(
    HANDLE hFile,
    LPDWORD lpModemStat
    );

WINBASEAPI
BOOL
WINAPI
GetCommState(
    HANDLE hFile,
    LPDCB lpDCB
    );

WINBASEAPI
BOOL
WINAPI
GetCommTimeouts(
    HANDLE hFile,
    LPCOMMTIMEOUTS lpCommTimeouts
    );

WINBASEAPI
BOOL
WINAPI
PurgeComm(
    HANDLE hFile,
    DWORD dwFlags
    );

WINBASEAPI
BOOL
WINAPI
SetCommBreak(
    HANDLE hFile
    );

WINBASEAPI
BOOL
WINAPI
SetCommConfig(
    HANDLE hCommDev,
    LPCOMMCONFIG lpCC,
    DWORD dwSize
    );

WINBASEAPI
BOOL
WINAPI
SetCommMask(
    HANDLE hFile,
    DWORD dwEvtMask
    );

WINBASEAPI
BOOL
WINAPI
SetCommState(
    HANDLE hFile,
    LPDCB lpDCB
    );

WINBASEAPI
BOOL
WINAPI
SetCommTimeouts(
    HANDLE hFile,
    LPCOMMTIMEOUTS lpCommTimeouts
    );

WINBASEAPI
BOOL
WINAPI
TransmitCommChar(
    HANDLE hFile,
    char cChar
    );

WINBASEAPI
BOOL
WINAPI
WaitCommEvent(
    HANDLE hFile,
    LPDWORD lpEvtMask,
    LPOVERLAPPED lpOverlapped
    );


WINBASEAPI
DWORD
WINAPI
SetTapePosition(
    HANDLE hDevice,
    DWORD dwPositionMethod,
    DWORD dwPartition,
    DWORD dwOffsetLow,
    DWORD dwOffsetHigh,
    BOOL bImmediate
    );

WINBASEAPI
DWORD
WINAPI
GetTapePosition(
    HANDLE hDevice,
    DWORD dwPositionType,
    LPDWORD lpdwPartition,
    LPDWORD lpdwOffsetLow,
    LPDWORD lpdwOffsetHigh
    );

WINBASEAPI
DWORD
WINAPI
PrepareTape(
    HANDLE hDevice,
    DWORD dwOperation,
    BOOL bImmediate
    );

WINBASEAPI
DWORD
WINAPI
EraseTape(
    HANDLE hDevice,
    DWORD dwEraseType,
    BOOL bImmediate
    );

WINBASEAPI
DWORD
WINAPI
CreateTapePartition(
    HANDLE hDevice,
    DWORD dwPartitionMethod,
    DWORD dwCount,
    DWORD dwSize
    );

WINBASEAPI
DWORD
WINAPI
WriteTapemark(
    HANDLE hDevice,
    DWORD dwTapemarkType,
    DWORD dwTapemarkCount,
    BOOL bImmediate
    );

WINBASEAPI
DWORD
WINAPI
GetTapeStatus(
    HANDLE hDevice
    );

WINBASEAPI
DWORD
WINAPI
GetTapeParameters(
    HANDLE hDevice,
    DWORD dwOperation,
    LPDWORD lpdwSize,
    LPVOID lpTapeInformation
    );

#define GET_TAPE_MEDIA_INFORMATION 0
#define GET_TAPE_DRIVE_INFORMATION 1

WINBASEAPI
DWORD
WINAPI
SetTapeParameters(
    HANDLE hDevice,
    DWORD dwOperation,
    LPVOID lpTapeInformation
    );

#define SET_TAPE_MEDIA_INFORMATION 0
#define SET_TAPE_DRIVE_INFORMATION 1

WINBASEAPI
BOOL
WINAPI
Beep(
    DWORD dwFreq,
    DWORD dwDuration
    );

WINBASEAPI
VOID
WINAPI
OpenSound(
    VOID
    );

WINBASEAPI
VOID
WINAPI
CloseSound(
    VOID
    );

WINBASEAPI
VOID
WINAPI
StartSound(
    VOID
    );

WINBASEAPI
VOID
WINAPI
StopSound(
    VOID
    );

WINBASEAPI
DWORD
WINAPI
WaitSoundState(
    DWORD nState
    );

WINBASEAPI
DWORD
WINAPI
SyncAllVoices(
    VOID
    );

WINBASEAPI
DWORD
WINAPI
CountVoiceNotes(
    DWORD nVoice
    );

WINBASEAPI
LPDWORD
WINAPI
GetThresholdEvent(
    VOID
    );

WINBASEAPI
DWORD
WINAPI
GetThresholdStatus(
    VOID
    );

WINBASEAPI
DWORD
WINAPI
SetSoundNoise(
    DWORD nSource,
    DWORD nDuration
    );

WINBASEAPI
DWORD
WINAPI
SetVoiceAccent(
    DWORD nVoice,
    DWORD nTempo,
    DWORD nVolume,
    DWORD nMode,
    DWORD nPitch
    );

WINBASEAPI
DWORD
WINAPI
SetVoiceEnvelope(
    DWORD nVoice,
    DWORD nShape,
    DWORD nRepeat
    );

WINBASEAPI
DWORD
WINAPI
SetVoiceNote(
    DWORD nVoice,
    DWORD nValue,
    DWORD nLength,
    DWORD nCdots
    );

WINBASEAPI
DWORD
WINAPI
SetVoiceQueueSize(
    DWORD nVoice,
    DWORD nBytes
    );

WINBASEAPI
DWORD
WINAPI
SetVoiceSound(
    DWORD nVoice,
    DWORD Frequency,
    DWORD nDuration
    );

WINBASEAPI
DWORD
WINAPI
SetVoiceThreshold(
    DWORD nVoice,
    DWORD nNotes
    );

WINBASEAPI
int
WINAPI
MulDiv(
    int nNumber,
    int nNumerator,
    int nDenominator
    );

WINBASEAPI
VOID
WINAPI
GetSystemTime(
    LPSYSTEMTIME lpSystemTime
    );

WINBASEAPI
VOID
WINAPI
GetSystemTimeAsFileTime(
    LPFILETIME lpSystemTimeAsFileTime
    );

WINBASEAPI
BOOL
WINAPI
SetSystemTime(
    CONST SYSTEMTIME *lpSystemTime
    );

WINBASEAPI
VOID
WINAPI
GetLocalTime(
    LPSYSTEMTIME lpSystemTime
    );

WINBASEAPI
BOOL
WINAPI
SetLocalTime(
    CONST SYSTEMTIME *lpSystemTime
    );

WINBASEAPI
VOID
WINAPI
GetSystemInfo(
    LPSYSTEM_INFO lpSystemInfo
    );

typedef struct _TIME_ZONE_INFORMATION {
    LONG Bias;
    WCHAR StandardName[ 32 ];
    SYSTEMTIME StandardDate;
    LONG StandardBias;
    WCHAR DaylightName[ 32 ];
    SYSTEMTIME DaylightDate;
    LONG DaylightBias;
} TIME_ZONE_INFORMATION, *PTIME_ZONE_INFORMATION, *LPTIME_ZONE_INFORMATION;

WINBASEAPI
BOOL
WINAPI
SystemTimeToTzSpecificLocalTime(
    LPTIME_ZONE_INFORMATION lpTimeZoneInformation,
    LPSYSTEMTIME lpUniversalTime,
    LPSYSTEMTIME lpLocalTime
    );

WINBASEAPI
DWORD
WINAPI
GetTimeZoneInformation(
    LPTIME_ZONE_INFORMATION lpTimeZoneInformation
    );

WINBASEAPI
BOOL
WINAPI
SetTimeZoneInformation(
    CONST TIME_ZONE_INFORMATION *lpTimeZoneInformation
    );


//
// Routines to convert back and forth between system time and file time
//

WINBASEAPI
BOOL
WINAPI
SystemTimeToFileTime(
    CONST SYSTEMTIME *lpSystemTime,
    LPFILETIME lpFileTime
    );

WINBASEAPI
BOOL
WINAPI
FileTimeToLocalFileTime(
    CONST FILETIME *lpFileTime,
    LPFILETIME lpLocalFileTime
    );

WINBASEAPI
BOOL
WINAPI
LocalFileTimeToFileTime(
    CONST FILETIME *lpLocalFileTime,
    LPFILETIME lpFileTime
    );

WINBASEAPI
BOOL
WINAPI
FileTimeToSystemTime(
    CONST FILETIME *lpFileTime,
    LPSYSTEMTIME lpSystemTime
    );

WINBASEAPI
LONG
WINAPI
CompareFileTime(
    CONST FILETIME *lpFileTime1,
    CONST FILETIME *lpFileTime2
    );

WINBASEAPI
BOOL
WINAPI
FileTimeToDosDateTime(
    CONST FILETIME *lpFileTime,
    LPWORD lpFatDate,
    LPWORD lpFatTime
    );

WINBASEAPI
BOOL
WINAPI
DosDateTimeToFileTime(
    WORD wFatDate,
    WORD wFatTime,
    LPFILETIME lpFileTime
    );

WINBASEAPI
DWORD
WINAPI
GetTickCount(
    VOID
    );

WINBASEAPI
BOOL
WINAPI
SetSystemTimeAdjustment(
    DWORD dwTimeAdjustment,
    BOOL  bTimeAdjustmentDisabled
    );

WINBASEAPI
BOOL
WINAPI
GetSystemTimeAdjustment(
    PDWORD lpTimeAdjustment,
    PDWORD lpTimeIncrement,
    PBOOL  lpTimeAdjustmentDisabled
    );

#if !defined(MIDL_PASS)
WINBASEAPI
DWORD
WINAPI
FormatMessageA(
    DWORD dwFlags,
    LPCVOID lpSource,
    DWORD dwMessageId,
    DWORD dwLanguageId,
    LPSTR lpBuffer,
    DWORD nSize,
    va_list *Arguments
    );
WINBASEAPI
DWORD
WINAPI
FormatMessageW(
    DWORD dwFlags,
    LPCVOID lpSource,
    DWORD dwMessageId,
    DWORD dwLanguageId,
    LPWSTR lpBuffer,
    DWORD nSize,
    va_list *Arguments
    );
#ifdef UNICODE
#define FormatMessage  FormatMessageW
#else
#define FormatMessage  FormatMessageA
#endif // !UNICODE
#endif

#define FORMAT_MESSAGE_ALLOCATE_BUFFER 0x00000100
#define FORMAT_MESSAGE_IGNORE_INSERTS  0x00000200
#define FORMAT_MESSAGE_FROM_STRING     0x00000400
#define FORMAT_MESSAGE_FROM_HMODULE    0x00000800
#define FORMAT_MESSAGE_FROM_SYSTEM     0x00001000
#define FORMAT_MESSAGE_ARGUMENT_ARRAY  0x00002000
#define FORMAT_MESSAGE_MAX_WIDTH_MASK  0x000000FF


WINBASEAPI
BOOL
WINAPI
CreatePipe(
    PHANDLE hReadPipe,
    PHANDLE hWritePipe,
    LPSECURITY_ATTRIBUTES lpPipeAttributes,
    DWORD nSize
    );

WINBASEAPI
BOOL
WINAPI
ConnectNamedPipe(
    HANDLE hNamedPipe,
    LPOVERLAPPED lpOverlapped
    );

WINBASEAPI
BOOL
WINAPI
DisconnectNamedPipe(
    HANDLE hNamedPipe
    );

WINBASEAPI
BOOL
WINAPI
SetNamedPipeHandleState(
    HANDLE hNamedPipe,
    LPDWORD lpMode,
    LPDWORD lpMaxCollectionCount,
    LPDWORD lpCollectDataTimeout
    );

WINBASEAPI
BOOL
WINAPI
GetNamedPipeInfo(
    HANDLE hNamedPipe,
    LPDWORD lpFlags,
    LPDWORD lpOutBufferSize,
    LPDWORD lpInBufferSize,
    LPDWORD lpMaxInstances
    );

WINBASEAPI
BOOL
WINAPI
PeekNamedPipe(
    HANDLE hNamedPipe,
    LPVOID lpBuffer,
    DWORD nBufferSize,
    LPDWORD lpBytesRead,
    LPDWORD lpTotalBytesAvail,
    LPDWORD lpBytesLeftThisMessage
    );

WINBASEAPI
BOOL
WINAPI
TransactNamedPipe(
    HANDLE hNamedPipe,
    LPVOID lpInBuffer,
    DWORD nInBufferSize,
    LPVOID lpOutBuffer,
    DWORD nOutBufferSize,
    LPDWORD lpBytesRead,
    LPOVERLAPPED lpOverlapped
    );

WINBASEAPI
HANDLE
WINAPI
CreateMailslotA(
    LPCSTR lpName,
    DWORD nMaxMessageSize,
    DWORD lReadTimeout,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes
    );
WINBASEAPI
HANDLE
WINAPI
CreateMailslotW(
    LPCWSTR lpName,
    DWORD nMaxMessageSize,
    DWORD lReadTimeout,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes
    );
#ifdef UNICODE
#define CreateMailslot  CreateMailslotW
#else
#define CreateMailslot  CreateMailslotA
#endif // !UNICODE

WINBASEAPI
BOOL
WINAPI
GetMailslotInfo(
    HANDLE hMailslot,
    LPDWORD lpMaxMessageSize,
    LPDWORD lpNextSize,
    LPDWORD lpMessageCount,
    LPDWORD lpReadTimeout
    );

WINBASEAPI
BOOL
WINAPI
SetMailslotInfo(
    HANDLE hMailslot,
    DWORD lReadTimeout
    );

WINBASEAPI
LPVOID
WINAPI
MapViewOfFile(
    HANDLE hFileMappingObject,
    DWORD dwDesiredAccess,
    DWORD dwFileOffsetHigh,
    DWORD dwFileOffsetLow,
    DWORD dwNumberOfBytesToMap
    );

WINBASEAPI
BOOL
WINAPI
FlushViewOfFile(
    LPCVOID lpBaseAddress,
    DWORD dwNumberOfBytesToFlush
    );

WINBASEAPI
BOOL
WINAPI
UnmapViewOfFile(
    LPCVOID lpBaseAddress
    );


//
// _l Compat Functions
//

WINBASEAPI
int
WINAPI
lstrcmpA(
    LPCSTR lpString1,
    LPCSTR lpString2
    );
WINBASEAPI
int
WINAPI
lstrcmpW(
    LPCWSTR lpString1,
    LPCWSTR lpString2
    );
#ifdef UNICODE
#define lstrcmp  lstrcmpW
#else
#define lstrcmp  lstrcmpA
#endif // !UNICODE

WINBASEAPI
int
WINAPI
lstrcmpiA(
    LPCSTR lpString1,
    LPCSTR lpString2
    );
WINBASEAPI
int
WINAPI
lstrcmpiW(
    LPCWSTR lpString1,
    LPCWSTR lpString2
    );
#ifdef UNICODE
#define lstrcmpi  lstrcmpiW
#else
#define lstrcmpi  lstrcmpiA
#endif // !UNICODE

WINBASEAPI
LPSTR
WINAPI
lstrcpynA(
    LPSTR lpString1,
    LPCSTR lpString2,
    int iMaxLength
    );
WINBASEAPI
LPWSTR
WINAPI
lstrcpynW(
    LPWSTR lpString1,
    LPCWSTR lpString2,
    int iMaxLength
    );
#ifdef UNICODE
#define lstrcpyn  lstrcpynW
#else
#define lstrcpyn  lstrcpynA
#endif // !UNICODE

WINBASEAPI
LPSTR
WINAPI
lstrcpyA(
    LPSTR lpString1,
    LPCSTR lpString2
    );
WINBASEAPI
LPWSTR
WINAPI
lstrcpyW(
    LPWSTR lpString1,
    LPCWSTR lpString2
    );
#ifdef UNICODE
#define lstrcpy  lstrcpyW
#else
#define lstrcpy  lstrcpyA
#endif // !UNICODE

WINBASEAPI
LPSTR
WINAPI
lstrcatA(
    LPSTR lpString1,
    LPCSTR lpString2
    );
WINBASEAPI
LPWSTR
WINAPI
lstrcatW(
    LPWSTR lpString1,
    LPCWSTR lpString2
    );
#ifdef UNICODE
#define lstrcat  lstrcatW
#else
#define lstrcat  lstrcatA
#endif // !UNICODE

WINBASEAPI
int
WINAPI
lstrlenA(
    LPCSTR lpString
    );
WINBASEAPI
int
WINAPI
lstrlenW(
    LPCWSTR lpString
    );
#ifdef UNICODE
#define lstrlen  lstrlenW
#else
#define lstrlen  lstrlenA
#endif // !UNICODE

WINBASEAPI
HFILE
WINAPI
OpenFile(
    LPCSTR lpFileName,
    LPOFSTRUCT lpReOpenBuff,
    UINT uStyle
    );

WINBASEAPI
HFILE
WINAPI
_lopen(
    LPCSTR lpPathName,
    int iReadWrite
    );

WINBASEAPI
HFILE
WINAPI
_lcreat(
    LPCSTR lpPathName,
    int  iAttribute
    );

WINBASEAPI
UINT
WINAPI
_lread(
    HFILE hFile,
    LPVOID lpBuffer,
    UINT uBytes
    );

WINBASEAPI
UINT
WINAPI
_lwrite(
    HFILE hFile,
    LPCSTR lpBuffer,
    UINT uBytes
    );

WINBASEAPI
long
WINAPI
_hread(
    HFILE hFile,
    LPVOID lpBuffer,
    long lBytes
    );

WINBASEAPI
long
WINAPI
_hwrite(
    HFILE hFile,
    LPCSTR lpBuffer,
    long lBytes
    );

WINBASEAPI
HFILE
WINAPI
_lclose(
    HFILE hFile
    );

WINBASEAPI
LONG
WINAPI
_llseek(
    HFILE hFile,
    LONG lOffset,
    int iOrigin
    );

WINADVAPI
BOOL
WINAPI
IsTextUnicode(
    CONST LPVOID lpBuffer,
    int cb,
    LPINT lpi
    );

WINBASEAPI
DWORD
WINAPI
TlsAlloc(
    VOID
    );

#define TLS_OUT_OF_INDEXES (DWORD)0xFFFFFFFF

WINBASEAPI
LPVOID
WINAPI
TlsGetValue(
    DWORD dwTlsIndex
    );

WINBASEAPI
BOOL
WINAPI
TlsSetValue(
    DWORD dwTlsIndex,
    LPVOID lpTlsValue
    );

WINBASEAPI
BOOL
WINAPI
TlsFree(
    DWORD dwTlsIndex
    );

typedef
VOID
(WINAPI *LPOVERLAPPED_COMPLETION_ROUTINE)(
    DWORD dwErrorCode,
    DWORD dwNumberOfBytesTransfered,
    LPOVERLAPPED lpOverlapped
    );

WINBASEAPI
DWORD
WINAPI
SleepEx(
    DWORD dwMilliseconds,
    BOOL bAlertable
    );

WINBASEAPI
DWORD
WINAPI
WaitForSingleObjectEx(
    HANDLE hHandle,
    DWORD dwMilliseconds,
    BOOL bAlertable
    );

WINBASEAPI
DWORD
WINAPI
WaitForMultipleObjectsEx(
    DWORD nCount,
    CONST HANDLE *lpHandles,
    BOOL bWaitAll,
    DWORD dwMilliseconds,
    BOOL bAlertable
    );

WINBASEAPI
BOOL
WINAPI
ReadFileEx(
    HANDLE hFile,
    LPVOID lpBuffer,
    DWORD nNumberOfBytesToRead,
    LPOVERLAPPED lpOverlapped,
    LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
    );

WINBASEAPI
BOOL
WINAPI
WriteFileEx(
    HANDLE hFile,
    LPCVOID lpBuffer,
    DWORD nNumberOfBytesToWrite,
    LPOVERLAPPED lpOverlapped,
    LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
    );

WINBASEAPI
BOOL
WINAPI
BackupRead(
    HANDLE hFile,
    LPBYTE lpBuffer,
    DWORD nNumberOfBytesToRead,
    LPDWORD lpNumberOfBytesRead,
    BOOL bAbort,
    BOOL bProcessSecurity,
    LPVOID *lpContext
    );

WINBASEAPI
BOOL
WINAPI
BackupSeek(
    HANDLE hFile,
    DWORD  dwLowBytesToSeek,
    DWORD  dwHighBytesToSeek,
    LPDWORD lpdwLowByteSeeked,
    LPDWORD lpdwHighByteSeeked,
    LPVOID *lpContext
    );

WINBASEAPI
BOOL
WINAPI
BackupWrite(
    HANDLE hFile,
    LPBYTE lpBuffer,
    DWORD nNumberOfBytesToWrite,
    LPDWORD lpNumberOfBytesWritten,
    BOOL bAbort,
    BOOL bProcessSecurity,
    LPVOID *lpContext
    );

//
//  Stream id structure
//
typedef struct _WIN32_STREAM_ID {
        DWORD          dwStreamId ;
        DWORD          dwStreamAttributes ;
        LARGE_INTEGER  Size ;
        DWORD          dwStreamNameSize ;
        WCHAR          cStreamName[ ANYSIZE_ARRAY ] ;
} WIN32_STREAM_ID, *LPWIN32_STREAM_ID ;

//
//  Stream Ids
//

#define BACKUP_INVALID          0x00000000
#define BACKUP_DATA             0x00000001
#define BACKUP_EA_DATA          0x00000002
#define BACKUP_SECURITY_DATA    0x00000003
#define BACKUP_ALTERNATE_DATA   0x00000004
#define BACKUP_LINK             0x00000005
#define BACKUP_PROPERTY_DATA    0x00000006

//
//  Stream Attributes
//

#define STREAM_NORMAL_ATTRIBUTE         0x00000000
#define STREAM_MODIFIED_WHEN_READ       0x00000001
#define STREAM_CONTAINS_SECURITY        0x00000002
#define STREAM_CONTAINS_PROPERTIES      0x00000004

//
// Dual Mode API below this line. Dual Mode Structures also included.
//

#define STARTF_USESHOWWINDOW    0x00000001
#define STARTF_USESIZE          0x00000002
#define STARTF_USEPOSITION      0x00000004
#define STARTF_USECOUNTCHARS    0x00000008
#define STARTF_USEFILLATTRIBUTE 0x00000010
#define STARTF_RUNFULLSCREEN    0x00000020  // ignored for non-x86 platforms
#define STARTF_FORCEONFEEDBACK  0x00000040
#define STARTF_FORCEOFFFEEDBACK 0x00000080
#define STARTF_USESTDHANDLES    0x00000100
#if(WINVER >= 0x0400)
#define STARTF_USEHOTKEY        0x00000200
#endif /* WINVER >= 0x0400 */

typedef struct _STARTUPINFOA {
    DWORD   cb;
    LPSTR   lpReserved;
    LPSTR   lpDesktop;
    LPSTR   lpTitle;
    DWORD   dwX;
    DWORD   dwY;
    DWORD   dwXSize;
    DWORD   dwYSize;
    DWORD   dwXCountChars;
    DWORD   dwYCountChars;
    DWORD   dwFillAttribute;
    DWORD   dwFlags;
    WORD    wShowWindow;
    WORD    cbReserved2;
    LPBYTE  lpReserved2;
    HANDLE  hStdInput;
    HANDLE  hStdOutput;
    HANDLE  hStdError;
} STARTUPINFOA, *LPSTARTUPINFOA;
typedef struct _STARTUPINFOW {
    DWORD   cb;
    LPWSTR  lpReserved;
    LPWSTR  lpDesktop;
    LPWSTR  lpTitle;
    DWORD   dwX;
    DWORD   dwY;
    DWORD   dwXSize;
    DWORD   dwYSize;
    DWORD   dwXCountChars;
    DWORD   dwYCountChars;
    DWORD   dwFillAttribute;
    DWORD   dwFlags;
    WORD    wShowWindow;
    WORD    cbReserved2;
    LPBYTE  lpReserved2;
    HANDLE  hStdInput;
    HANDLE  hStdOutput;
    HANDLE  hStdError;
} STARTUPINFOW, *LPSTARTUPINFOW;
#ifdef UNICODE
typedef STARTUPINFOW STARTUPINFO;
typedef LPSTARTUPINFOW LPSTARTUPINFO;
#else
typedef STARTUPINFOA STARTUPINFO;
typedef LPSTARTUPINFOA LPSTARTUPINFO;
#endif // UNICODE

#define SHUTDOWN_NORETRY                0x00000001

typedef struct _WIN32_FIND_DATAA {
    DWORD dwFileAttributes;
    FILETIME ftCreationTime;
    FILETIME ftLastAccessTime;
    FILETIME ftLastWriteTime;
    DWORD nFileSizeHigh;
    DWORD nFileSizeLow;
    DWORD dwReserved0;
    DWORD dwReserved1;
    CHAR   cFileName[ MAX_PATH ];
    CHAR   cAlternateFileName[ 14 ];
} WIN32_FIND_DATAA, *PWIN32_FIND_DATAA, *LPWIN32_FIND_DATAA;
typedef struct _WIN32_FIND_DATAW {
    DWORD dwFileAttributes;
    FILETIME ftCreationTime;
    FILETIME ftLastAccessTime;
    FILETIME ftLastWriteTime;
    DWORD nFileSizeHigh;
    DWORD nFileSizeLow;
    DWORD dwReserved0;
    DWORD dwReserved1;
    WCHAR  cFileName[ MAX_PATH ];
    WCHAR  cAlternateFileName[ 14 ];
} WIN32_FIND_DATAW, *PWIN32_FIND_DATAW, *LPWIN32_FIND_DATAW;
#ifdef UNICODE
typedef WIN32_FIND_DATAW WIN32_FIND_DATA;
typedef PWIN32_FIND_DATAW PWIN32_FIND_DATA;
typedef LPWIN32_FIND_DATAW LPWIN32_FIND_DATA;
#else
typedef WIN32_FIND_DATAA WIN32_FIND_DATA;
typedef PWIN32_FIND_DATAA PWIN32_FIND_DATA;
typedef LPWIN32_FIND_DATAA LPWIN32_FIND_DATA;
#endif // UNICODE

WINBASEAPI
HANDLE
WINAPI
CreateMutexA(
    LPSECURITY_ATTRIBUTES lpMutexAttributes,
    BOOL bInitialOwner,
    LPCSTR lpName
    );
WINBASEAPI
HANDLE
WINAPI
CreateMutexW(
    LPSECURITY_ATTRIBUTES lpMutexAttributes,
    BOOL bInitialOwner,
    LPCWSTR lpName
    );
#ifdef UNICODE
#define CreateMutex  CreateMutexW
#else
#define CreateMutex  CreateMutexA
#endif // !UNICODE

WINBASEAPI
HANDLE
WINAPI
OpenMutexA(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    LPCSTR lpName
    );
WINBASEAPI
HANDLE
WINAPI
OpenMutexW(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    LPCWSTR lpName
    );
#ifdef UNICODE
#define OpenMutex  OpenMutexW
#else
#define OpenMutex  OpenMutexA
#endif // !UNICODE

WINBASEAPI
HANDLE
WINAPI
CreateEventA(
    LPSECURITY_ATTRIBUTES lpEventAttributes,
    BOOL bManualReset,
    BOOL bInitialState,
    LPCSTR lpName
    );
WINBASEAPI
HANDLE
WINAPI
CreateEventW(
    LPSECURITY_ATTRIBUTES lpEventAttributes,
    BOOL bManualReset,
    BOOL bInitialState,
    LPCWSTR lpName
    );
#ifdef UNICODE
#define CreateEvent  CreateEventW
#else
#define CreateEvent  CreateEventA
#endif // !UNICODE

WINBASEAPI
HANDLE
WINAPI
OpenEventA(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    LPCSTR lpName
    );
WINBASEAPI
HANDLE
WINAPI
OpenEventW(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    LPCWSTR lpName
    );
#ifdef UNICODE
#define OpenEvent  OpenEventW
#else
#define OpenEvent  OpenEventA
#endif // !UNICODE

WINBASEAPI
HANDLE
WINAPI
CreateSemaphoreA(
    LPSECURITY_ATTRIBUTES lpSemaphoreAttributes,
    LONG lInitialCount,
    LONG lMaximumCount,
    LPCSTR lpName
    );
WINBASEAPI
HANDLE
WINAPI
CreateSemaphoreW(
    LPSECURITY_ATTRIBUTES lpSemaphoreAttributes,
    LONG lInitialCount,
    LONG lMaximumCount,
    LPCWSTR lpName
    );
#ifdef UNICODE
#define CreateSemaphore  CreateSemaphoreW
#else
#define CreateSemaphore  CreateSemaphoreA
#endif // !UNICODE

WINBASEAPI
HANDLE
WINAPI
OpenSemaphoreA(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    LPCSTR lpName
    );
WINBASEAPI
HANDLE
WINAPI
OpenSemaphoreW(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    LPCWSTR lpName
    );
#ifdef UNICODE
#define OpenSemaphore  OpenSemaphoreW
#else
#define OpenSemaphore  OpenSemaphoreA
#endif // !UNICODE

WINBASEAPI
HANDLE
WINAPI
CreateFileMappingA(
    HANDLE hFile,
    LPSECURITY_ATTRIBUTES lpFileMappingAttributes,
    DWORD flProtect,
    DWORD dwMaximumSizeHigh,
    DWORD dwMaximumSizeLow,
    LPCSTR lpName
    );
WINBASEAPI
HANDLE
WINAPI
CreateFileMappingW(
    HANDLE hFile,
    LPSECURITY_ATTRIBUTES lpFileMappingAttributes,
    DWORD flProtect,
    DWORD dwMaximumSizeHigh,
    DWORD dwMaximumSizeLow,
    LPCWSTR lpName
    );
#ifdef UNICODE
#define CreateFileMapping  CreateFileMappingW
#else
#define CreateFileMapping  CreateFileMappingA
#endif // !UNICODE

WINBASEAPI
HANDLE
WINAPI
OpenFileMappingA(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    LPCSTR lpName
    );
WINBASEAPI
HANDLE
WINAPI
OpenFileMappingW(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    LPCWSTR lpName
    );
#ifdef UNICODE
#define OpenFileMapping  OpenFileMappingW
#else
#define OpenFileMapping  OpenFileMappingA
#endif // !UNICODE

WINBASEAPI
DWORD
WINAPI
GetLogicalDriveStringsA(
    DWORD nBufferLength,
    LPSTR lpBuffer
    );
WINBASEAPI
DWORD
WINAPI
GetLogicalDriveStringsW(
    DWORD nBufferLength,
    LPWSTR lpBuffer
    );
#ifdef UNICODE
#define GetLogicalDriveStrings  GetLogicalDriveStringsW
#else
#define GetLogicalDriveStrings  GetLogicalDriveStringsA
#endif // !UNICODE

WINBASEAPI
HMODULE
WINAPI
LoadLibraryA(
    LPCSTR lpLibFileName
    );
WINBASEAPI
HMODULE
WINAPI
LoadLibraryW(
    LPCWSTR lpLibFileName
    );
#ifdef UNICODE
#define LoadLibrary  LoadLibraryW
#else
#define LoadLibrary  LoadLibraryA
#endif // !UNICODE

WINBASEAPI
HMODULE
WINAPI
LoadLibraryExA(
    LPCSTR lpLibFileName,
    HANDLE hFile,
    DWORD dwFlags
    );
WINBASEAPI
HMODULE
WINAPI
LoadLibraryExW(
    LPCWSTR lpLibFileName,
    HANDLE hFile,
    DWORD dwFlags
    );
#ifdef UNICODE
#define LoadLibraryEx  LoadLibraryExW
#else
#define LoadLibraryEx  LoadLibraryExA
#endif // !UNICODE


#define DONT_RESOLVE_DLL_REFERENCES     0x00000001
#define LOAD_LIBRARY_AS_DATAFILE        0x00000002
#define LOAD_WITH_ALTERED_SEARCH_PATH   0x00000008


WINBASEAPI
DWORD
WINAPI
GetModuleFileNameA(
    HMODULE hModule,
    LPSTR lpFilename,
    DWORD nSize
    );
WINBASEAPI
DWORD
WINAPI
GetModuleFileNameW(
    HMODULE hModule,
    LPWSTR lpFilename,
    DWORD nSize
    );
#ifdef UNICODE
#define GetModuleFileName  GetModuleFileNameW
#else
#define GetModuleFileName  GetModuleFileNameA
#endif // !UNICODE

WINBASEAPI
HMODULE
WINAPI
GetModuleHandleA(
    LPCSTR lpModuleName
    );
WINBASEAPI
HMODULE
WINAPI
GetModuleHandleW(
    LPCWSTR lpModuleName
    );
#ifdef UNICODE
#define GetModuleHandle  GetModuleHandleW
#else
#define GetModuleHandle  GetModuleHandleA
#endif // !UNICODE

WINBASEAPI
BOOL
WINAPI
CreateProcessA(
    LPCSTR lpApplicationName,
    LPSTR lpCommandLine,
    LPSECURITY_ATTRIBUTES lpProcessAttributes,
    LPSECURITY_ATTRIBUTES lpThreadAttributes,
    BOOL bInheritHandles,
    DWORD dwCreationFlags,
    LPVOID lpEnvironment,
    LPCSTR lpCurrentDirectory,
    LPSTARTUPINFOA lpStartupInfo,
    LPPROCESS_INFORMATION lpProcessInformation
    );
WINBASEAPI
BOOL
WINAPI
CreateProcessW(
    LPCWSTR lpApplicationName,
    LPWSTR lpCommandLine,
    LPSECURITY_ATTRIBUTES lpProcessAttributes,
    LPSECURITY_ATTRIBUTES lpThreadAttributes,
    BOOL bInheritHandles,
    DWORD dwCreationFlags,
    LPVOID lpEnvironment,
    LPCWSTR lpCurrentDirectory,
    LPSTARTUPINFOW lpStartupInfo,
    LPPROCESS_INFORMATION lpProcessInformation
    );
#ifdef UNICODE
#define CreateProcess  CreateProcessW
#else
#define CreateProcess  CreateProcessA
#endif // !UNICODE

WINBASEAPI
BOOL
WINAPI
SetProcessShutdownParameters(
    DWORD dwLevel,
    DWORD dwFlags
    );

WINBASEAPI
BOOL
WINAPI
GetProcessShutdownParameters(
    LPDWORD lpdwLevel,
    LPDWORD lpdwFlags
    );

WINBASEAPI
DWORD
WINAPI
GetProcessVersion(
    DWORD ProcessId
    );

WINBASEAPI
VOID
WINAPI
FatalAppExitA(
    UINT uAction,
    LPCSTR lpMessageText
    );
WINBASEAPI
VOID
WINAPI
FatalAppExitW(
    UINT uAction,
    LPCWSTR lpMessageText
    );
#ifdef UNICODE
#define FatalAppExit  FatalAppExitW
#else
#define FatalAppExit  FatalAppExitA
#endif // !UNICODE

WINBASEAPI
VOID
WINAPI
GetStartupInfoA(
    LPSTARTUPINFOA lpStartupInfo
    );
WINBASEAPI
VOID
WINAPI
GetStartupInfoW(
    LPSTARTUPINFOW lpStartupInfo
    );
#ifdef UNICODE
#define GetStartupInfo  GetStartupInfoW
#else
#define GetStartupInfo  GetStartupInfoA
#endif // !UNICODE

WINBASEAPI
LPSTR
WINAPI
GetCommandLineA(
    VOID
    );
WINBASEAPI
LPWSTR
WINAPI
GetCommandLineW(
    VOID
    );
#ifdef UNICODE
#define GetCommandLine  GetCommandLineW
#else
#define GetCommandLine  GetCommandLineA
#endif // !UNICODE

WINBASEAPI
DWORD
WINAPI
GetEnvironmentVariableA(
    LPCSTR lpName,
    LPSTR lpBuffer,
    DWORD nSize
    );
WINBASEAPI
DWORD
WINAPI
GetEnvironmentVariableW(
    LPCWSTR lpName,
    LPWSTR lpBuffer,
    DWORD nSize
    );
#ifdef UNICODE
#define GetEnvironmentVariable  GetEnvironmentVariableW
#else
#define GetEnvironmentVariable  GetEnvironmentVariableA
#endif // !UNICODE

WINBASEAPI
BOOL
WINAPI
SetEnvironmentVariableA(
    LPCSTR lpName,
    LPCSTR lpValue
    );
WINBASEAPI
BOOL
WINAPI
SetEnvironmentVariableW(
    LPCWSTR lpName,
    LPCWSTR lpValue
    );
#ifdef UNICODE
#define SetEnvironmentVariable  SetEnvironmentVariableW
#else
#define SetEnvironmentVariable  SetEnvironmentVariableA
#endif // !UNICODE

WINBASEAPI
DWORD
WINAPI
ExpandEnvironmentStringsA(
    LPCSTR lpSrc,
    LPSTR lpDst,
    DWORD nSize
    );
WINBASEAPI
DWORD
WINAPI
ExpandEnvironmentStringsW(
    LPCWSTR lpSrc,
    LPWSTR lpDst,
    DWORD nSize
    );
#ifdef UNICODE
#define ExpandEnvironmentStrings  ExpandEnvironmentStringsW
#else
#define ExpandEnvironmentStrings  ExpandEnvironmentStringsA
#endif // !UNICODE

WINBASEAPI
VOID
WINAPI
OutputDebugStringA(
    LPCSTR lpOutputString
    );
WINBASEAPI
VOID
WINAPI
OutputDebugStringW(
    LPCWSTR lpOutputString
    );
#ifdef UNICODE
#define OutputDebugString  OutputDebugStringW
#else
#define OutputDebugString  OutputDebugStringA
#endif // !UNICODE

WINBASEAPI
HRSRC
WINAPI
FindResourceA(
    HMODULE hModule,
    LPCSTR lpName,
    LPCSTR lpType
    );
WINBASEAPI
HRSRC
WINAPI
FindResourceW(
    HMODULE hModule,
    LPCWSTR lpName,
    LPCWSTR lpType
    );
#ifdef UNICODE
#define FindResource  FindResourceW
#else
#define FindResource  FindResourceA
#endif // !UNICODE

WINBASEAPI
HRSRC
WINAPI
FindResourceExA(
    HMODULE hModule,
    LPCSTR lpType,
    LPCSTR lpName,
    WORD    wLanguage
    );
WINBASEAPI
HRSRC
WINAPI
FindResourceExW(
    HMODULE hModule,
    LPCWSTR lpType,
    LPCWSTR lpName,
    WORD    wLanguage
    );
#ifdef UNICODE
#define FindResourceEx  FindResourceExW
#else
#define FindResourceEx  FindResourceExA
#endif // !UNICODE

#ifdef STRICT
typedef BOOL (CALLBACK* ENUMRESTYPEPROC)(HMODULE hModule, LPTSTR lpType,
        LONG lParam);
typedef BOOL (CALLBACK* ENUMRESNAMEPROC)(HMODULE hModule, LPCTSTR lpType,
        LPTSTR lpName, LONG lParam);
typedef BOOL (CALLBACK* ENUMRESLANGPROC)(HMODULE hModule, LPCTSTR lpType,
        LPCTSTR lpName, WORD  wLanguage, LONG lParam);
#else
typedef FARPROC ENUMRESTYPEPROC;
typedef FARPROC ENUMRESNAMEPROC;
typedef FARPROC ENUMRESLANGPROC;
#endif

WINBASEAPI
BOOL
WINAPI
EnumResourceTypesA(
    HMODULE hModule,
    ENUMRESTYPEPROC lpEnumFunc,
    LONG lParam
    );
WINBASEAPI
BOOL
WINAPI
EnumResourceTypesW(
    HMODULE hModule,
    ENUMRESTYPEPROC lpEnumFunc,
    LONG lParam
    );
#ifdef UNICODE
#define EnumResourceTypes  EnumResourceTypesW
#else
#define EnumResourceTypes  EnumResourceTypesA
#endif // !UNICODE


WINBASEAPI
BOOL
WINAPI
EnumResourceNamesA(
    HMODULE hModule,
    LPCSTR lpType,
    ENUMRESNAMEPROC lpEnumFunc,
    LONG lParam
    );
WINBASEAPI
BOOL
WINAPI
EnumResourceNamesW(
    HMODULE hModule,
    LPCWSTR lpType,
    ENUMRESNAMEPROC lpEnumFunc,
    LONG lParam
    );
#ifdef UNICODE
#define EnumResourceNames  EnumResourceNamesW
#else
#define EnumResourceNames  EnumResourceNamesA
#endif // !UNICODE

WINBASEAPI
BOOL
WINAPI
EnumResourceLanguagesA(
    HMODULE hModule,
    LPCSTR lpType,
    LPCSTR lpName,
    ENUMRESLANGPROC lpEnumFunc,
    LONG lParam
    );
WINBASEAPI
BOOL
WINAPI
EnumResourceLanguagesW(
    HMODULE hModule,
    LPCWSTR lpType,
    LPCWSTR lpName,
    ENUMRESLANGPROC lpEnumFunc,
    LONG lParam
    );
#ifdef UNICODE
#define EnumResourceLanguages  EnumResourceLanguagesW
#else
#define EnumResourceLanguages  EnumResourceLanguagesA
#endif // !UNICODE

WINBASEAPI
HANDLE
WINAPI
BeginUpdateResourceA(
    LPCSTR pFileName,
    BOOL bDeleteExistingResources
    );
WINBASEAPI
HANDLE
WINAPI
BeginUpdateResourceW(
    LPCWSTR pFileName,
    BOOL bDeleteExistingResources
    );
#ifdef UNICODE
#define BeginUpdateResource  BeginUpdateResourceW
#else
#define BeginUpdateResource  BeginUpdateResourceA
#endif // !UNICODE

WINBASEAPI
BOOL
WINAPI
UpdateResourceA(
    HANDLE      hUpdate,
    LPCSTR     lpType,
    LPCSTR     lpName,
    WORD        wLanguage,
    LPVOID      lpData,
    DWORD       cbData
    );
WINBASEAPI
BOOL
WINAPI
UpdateResourceW(
    HANDLE      hUpdate,
    LPCWSTR     lpType,
    LPCWSTR     lpName,
    WORD        wLanguage,
    LPVOID      lpData,
    DWORD       cbData
    );
#ifdef UNICODE
#define UpdateResource  UpdateResourceW
#else
#define UpdateResource  UpdateResourceA
#endif // !UNICODE

WINBASEAPI
BOOL
WINAPI
EndUpdateResourceA(
    HANDLE      hUpdate,
    BOOL        fDiscard
    );
WINBASEAPI
BOOL
WINAPI
EndUpdateResourceW(
    HANDLE      hUpdate,
    BOOL        fDiscard
    );
#ifdef UNICODE
#define EndUpdateResource  EndUpdateResourceW
#else
#define EndUpdateResource  EndUpdateResourceA
#endif // !UNICODE

WINBASEAPI
ATOM
WINAPI
GlobalAddAtomA(
    LPCSTR lpString
    );
WINBASEAPI
ATOM
WINAPI
GlobalAddAtomW(
    LPCWSTR lpString
    );
#ifdef UNICODE
#define GlobalAddAtom  GlobalAddAtomW
#else
#define GlobalAddAtom  GlobalAddAtomA
#endif // !UNICODE

WINBASEAPI
ATOM
WINAPI
GlobalFindAtomA(
    LPCSTR lpString
    );
WINBASEAPI
ATOM
WINAPI
GlobalFindAtomW(
    LPCWSTR lpString
    );
#ifdef UNICODE
#define GlobalFindAtom  GlobalFindAtomW
#else
#define GlobalFindAtom  GlobalFindAtomA
#endif // !UNICODE

WINBASEAPI
UINT
WINAPI
GlobalGetAtomNameA(
    ATOM nAtom,
    LPSTR lpBuffer,
    int nSize
    );
WINBASEAPI
UINT
WINAPI
GlobalGetAtomNameW(
    ATOM nAtom,
    LPWSTR lpBuffer,
    int nSize
    );
#ifdef UNICODE
#define GlobalGetAtomName  GlobalGetAtomNameW
#else
#define GlobalGetAtomName  GlobalGetAtomNameA
#endif // !UNICODE

WINBASEAPI
ATOM
WINAPI
AddAtomA(
    LPCSTR lpString
    );
WINBASEAPI
ATOM
WINAPI
AddAtomW(
    LPCWSTR lpString
    );
#ifdef UNICODE
#define AddAtom  AddAtomW
#else
#define AddAtom  AddAtomA
#endif // !UNICODE

WINBASEAPI
ATOM
WINAPI
FindAtomA(
    LPCSTR lpString
    );
WINBASEAPI
ATOM
WINAPI
FindAtomW(
    LPCWSTR lpString
    );
#ifdef UNICODE
#define FindAtom  FindAtomW
#else
#define FindAtom  FindAtomA
#endif // !UNICODE

WINBASEAPI
UINT
WINAPI
GetAtomNameA(
    ATOM nAtom,
    LPSTR lpBuffer,
    int nSize
    );
WINBASEAPI
UINT
WINAPI
GetAtomNameW(
    ATOM nAtom,
    LPWSTR lpBuffer,
    int nSize
    );
#ifdef UNICODE
#define GetAtomName  GetAtomNameW
#else
#define GetAtomName  GetAtomNameA
#endif // !UNICODE

WINBASEAPI
UINT
WINAPI
GetProfileIntA(
    LPCSTR lpAppName,
    LPCSTR lpKeyName,
    INT nDefault
    );
WINBASEAPI
UINT
WINAPI
GetProfileIntW(
    LPCWSTR lpAppName,
    LPCWSTR lpKeyName,
    INT nDefault
    );
#ifdef UNICODE
#define GetProfileInt  GetProfileIntW
#else
#define GetProfileInt  GetProfileIntA
#endif // !UNICODE

WINBASEAPI
DWORD
WINAPI
GetProfileStringA(
    LPCSTR lpAppName,
    LPCSTR lpKeyName,
    LPCSTR lpDefault,
    LPSTR lpReturnedString,
    DWORD nSize
    );
WINBASEAPI
DWORD
WINAPI
GetProfileStringW(
    LPCWSTR lpAppName,
    LPCWSTR lpKeyName,
    LPCWSTR lpDefault,
    LPWSTR lpReturnedString,
    DWORD nSize
    );
#ifdef UNICODE
#define GetProfileString  GetProfileStringW
#else
#define GetProfileString  GetProfileStringA
#endif // !UNICODE

WINBASEAPI
BOOL
WINAPI
WriteProfileStringA(
    LPCSTR lpAppName,
    LPCSTR lpKeyName,
    LPCSTR lpString
    );
WINBASEAPI
BOOL
WINAPI
WriteProfileStringW(
    LPCWSTR lpAppName,
    LPCWSTR lpKeyName,
    LPCWSTR lpString
    );
#ifdef UNICODE
#define WriteProfileString  WriteProfileStringW
#else
#define WriteProfileString  WriteProfileStringA
#endif // !UNICODE

WINBASEAPI
DWORD
WINAPI
GetProfileSectionA(
    LPCSTR lpAppName,
    LPSTR lpReturnedString,
    DWORD nSize
    );
WINBASEAPI
DWORD
WINAPI
GetProfileSectionW(
    LPCWSTR lpAppName,
    LPWSTR lpReturnedString,
    DWORD nSize
    );
#ifdef UNICODE
#define GetProfileSection  GetProfileSectionW
#else
#define GetProfileSection  GetProfileSectionA
#endif // !UNICODE

WINBASEAPI
BOOL
WINAPI
WriteProfileSectionA(
    LPCSTR lpAppName,
    LPCSTR lpString
    );
WINBASEAPI
BOOL
WINAPI
WriteProfileSectionW(
    LPCWSTR lpAppName,
    LPCWSTR lpString
    );
#ifdef UNICODE
#define WriteProfileSection  WriteProfileSectionW
#else
#define WriteProfileSection  WriteProfileSectionA
#endif // !UNICODE

WINBASEAPI
UINT
WINAPI
GetPrivateProfileIntA(
    LPCSTR lpAppName,
    LPCSTR lpKeyName,
    INT nDefault,
    LPCSTR lpFileName
    );
WINBASEAPI
UINT
WINAPI
GetPrivateProfileIntW(
    LPCWSTR lpAppName,
    LPCWSTR lpKeyName,
    INT nDefault,
    LPCWSTR lpFileName
    );
#ifdef UNICODE
#define GetPrivateProfileInt  GetPrivateProfileIntW
#else
#define GetPrivateProfileInt  GetPrivateProfileIntA
#endif // !UNICODE

WINBASEAPI
DWORD
WINAPI
GetPrivateProfileStringA(
    LPCSTR lpAppName,
    LPCSTR lpKeyName,
    LPCSTR lpDefault,
    LPSTR lpReturnedString,
    DWORD nSize,
    LPCSTR lpFileName
    );
WINBASEAPI
DWORD
WINAPI
GetPrivateProfileStringW(
    LPCWSTR lpAppName,
    LPCWSTR lpKeyName,
    LPCWSTR lpDefault,
    LPWSTR lpReturnedString,
    DWORD nSize,
    LPCWSTR lpFileName
    );
#ifdef UNICODE
#define GetPrivateProfileString  GetPrivateProfileStringW
#else
#define GetPrivateProfileString  GetPrivateProfileStringA
#endif // !UNICODE

WINBASEAPI
BOOL
WINAPI
WritePrivateProfileStringA(
    LPCSTR lpAppName,
    LPCSTR lpKeyName,
    LPCSTR lpString,
    LPCSTR lpFileName
    );
WINBASEAPI
BOOL
WINAPI
WritePrivateProfileStringW(
    LPCWSTR lpAppName,
    LPCWSTR lpKeyName,
    LPCWSTR lpString,
    LPCWSTR lpFileName
    );
#ifdef UNICODE
#define WritePrivateProfileString  WritePrivateProfileStringW
#else
#define WritePrivateProfileString  WritePrivateProfileStringA
#endif // !UNICODE

WINBASEAPI
DWORD
WINAPI
GetPrivateProfileSectionA(
    LPCSTR lpAppName,
    LPSTR lpReturnedString,
    DWORD nSize,
    LPCSTR lpFileName
    );
WINBASEAPI
DWORD
WINAPI
GetPrivateProfileSectionW(
    LPCWSTR lpAppName,
    LPWSTR lpReturnedString,
    DWORD nSize,
    LPCWSTR lpFileName
    );
#ifdef UNICODE
#define GetPrivateProfileSection  GetPrivateProfileSectionW
#else
#define GetPrivateProfileSection  GetPrivateProfileSectionA
#endif // !UNICODE

WINBASEAPI
BOOL
WINAPI
WritePrivateProfileSectionA(
    LPCSTR lpAppName,
    LPCSTR lpString,
    LPCSTR lpFileName
    );
WINBASEAPI
BOOL
WINAPI
WritePrivateProfileSectionW(
    LPCWSTR lpAppName,
    LPCWSTR lpString,
    LPCWSTR lpFileName
    );
#ifdef UNICODE
#define WritePrivateProfileSection  WritePrivateProfileSectionW
#else
#define WritePrivateProfileSection  WritePrivateProfileSectionA
#endif // !UNICODE


WINBASEAPI
DWORD
WINAPI
GetPrivateProfileSectionNamesA(
    LPSTR lpszReturnBuffer,
    DWORD nSize,
    LPCSTR lpFileName
    );
WINBASEAPI
DWORD
WINAPI
GetPrivateProfileSectionNamesW(
    LPWSTR lpszReturnBuffer,
    DWORD nSize,
    LPCWSTR lpFileName
    );
#ifdef UNICODE
#define GetPrivateProfileSectionNames  GetPrivateProfileSectionNamesW
#else
#define GetPrivateProfileSectionNames  GetPrivateProfileSectionNamesA
#endif // !UNICODE

WINBASEAPI
BOOL
WINAPI
GetPrivateProfileStructA(
    LPCSTR lpszSection,
    LPCSTR lpszKey,
    LPVOID   lpStruct,
    UINT     uSizeStruct,
    LPCSTR szFile
    );
WINBASEAPI
BOOL
WINAPI
GetPrivateProfileStructW(
    LPCWSTR lpszSection,
    LPCWSTR lpszKey,
    LPVOID   lpStruct,
    UINT     uSizeStruct,
    LPCWSTR szFile
    );
#ifdef UNICODE
#define GetPrivateProfileStruct  GetPrivateProfileStructW
#else
#define GetPrivateProfileStruct  GetPrivateProfileStructA
#endif // !UNICODE

WINBASEAPI
BOOL
WINAPI
WritePrivateProfileStructA(
    LPCSTR lpszSection,
    LPCSTR lpszKey,
    LPVOID   lpStruct,
    UINT     uSizeStruct,
    LPCSTR szFile
    );
WINBASEAPI
BOOL
WINAPI
WritePrivateProfileStructW(
    LPCWSTR lpszSection,
    LPCWSTR lpszKey,
    LPVOID   lpStruct,
    UINT     uSizeStruct,
    LPCWSTR szFile
    );
#ifdef UNICODE
#define WritePrivateProfileStruct  WritePrivateProfileStructW
#else
#define WritePrivateProfileStruct  WritePrivateProfileStructA
#endif // !UNICODE


WINBASEAPI
UINT
WINAPI
GetDriveTypeA(
    LPCSTR lpRootPathName
    );
WINBASEAPI
UINT
WINAPI
GetDriveTypeW(
    LPCWSTR lpRootPathName
    );
#ifdef UNICODE
#define GetDriveType  GetDriveTypeW
#else
#define GetDriveType  GetDriveTypeA
#endif // !UNICODE

WINBASEAPI
UINT
WINAPI
GetSystemDirectoryA(
    LPSTR lpBuffer,
    UINT uSize
    );
WINBASEAPI
UINT
WINAPI
GetSystemDirectoryW(
    LPWSTR lpBuffer,
    UINT uSize
    );
#ifdef UNICODE
#define GetSystemDirectory  GetSystemDirectoryW
#else
#define GetSystemDirectory  GetSystemDirectoryA
#endif // !UNICODE

WINBASEAPI
DWORD
WINAPI
GetTempPathA(
    DWORD nBufferLength,
    LPSTR lpBuffer
    );
WINBASEAPI
DWORD
WINAPI
GetTempPathW(
    DWORD nBufferLength,
    LPWSTR lpBuffer
    );
#ifdef UNICODE
#define GetTempPath  GetTempPathW
#else
#define GetTempPath  GetTempPathA
#endif // !UNICODE

WINBASEAPI
UINT
WINAPI
GetTempFileNameA(
    LPCSTR lpPathName,
    LPCSTR lpPrefixString,
    UINT uUnique,
    LPSTR lpTempFileName
    );
WINBASEAPI
UINT
WINAPI
GetTempFileNameW(
    LPCWSTR lpPathName,
    LPCWSTR lpPrefixString,
    UINT uUnique,
    LPWSTR lpTempFileName
    );
#ifdef UNICODE
#define GetTempFileName  GetTempFileNameW
#else
#define GetTempFileName  GetTempFileNameA
#endif // !UNICODE

WINBASEAPI
UINT
WINAPI
GetWindowsDirectoryA(
    LPSTR lpBuffer,
    UINT uSize
    );
WINBASEAPI
UINT
WINAPI
GetWindowsDirectoryW(
    LPWSTR lpBuffer,
    UINT uSize
    );
#ifdef UNICODE
#define GetWindowsDirectory  GetWindowsDirectoryW
#else
#define GetWindowsDirectory  GetWindowsDirectoryA
#endif // !UNICODE

WINBASEAPI
BOOL
WINAPI
SetCurrentDirectoryA(
    LPCSTR lpPathName
    );
WINBASEAPI
BOOL
WINAPI
SetCurrentDirectoryW(
    LPCWSTR lpPathName
    );
#ifdef UNICODE
#define SetCurrentDirectory  SetCurrentDirectoryW
#else
#define SetCurrentDirectory  SetCurrentDirectoryA
#endif // !UNICODE

WINBASEAPI
DWORD
WINAPI
GetCurrentDirectoryA(
    DWORD nBufferLength,
    LPSTR lpBuffer
    );
WINBASEAPI
DWORD
WINAPI
GetCurrentDirectoryW(
    DWORD nBufferLength,
    LPWSTR lpBuffer
    );
#ifdef UNICODE
#define GetCurrentDirectory  GetCurrentDirectoryW
#else
#define GetCurrentDirectory  GetCurrentDirectoryA
#endif // !UNICODE

WINBASEAPI
BOOL
WINAPI
GetDiskFreeSpaceA(
    LPCSTR lpRootPathName,
    LPDWORD lpSectorsPerCluster,
    LPDWORD lpBytesPerSector,
    LPDWORD lpNumberOfFreeClusters,
    LPDWORD lpTotalNumberOfClusters
    );
WINBASEAPI
BOOL
WINAPI
GetDiskFreeSpaceW(
    LPCWSTR lpRootPathName,
    LPDWORD lpSectorsPerCluster,
    LPDWORD lpBytesPerSector,
    LPDWORD lpNumberOfFreeClusters,
    LPDWORD lpTotalNumberOfClusters
    );
#ifdef UNICODE
#define GetDiskFreeSpace  GetDiskFreeSpaceW
#else
#define GetDiskFreeSpace  GetDiskFreeSpaceA
#endif // !UNICODE

WINBASEAPI
BOOL
WINAPI
CreateDirectoryA(
    LPCSTR lpPathName,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes
    );
WINBASEAPI
BOOL
WINAPI
CreateDirectoryW(
    LPCWSTR lpPathName,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes
    );
#ifdef UNICODE
#define CreateDirectory  CreateDirectoryW
#else
#define CreateDirectory  CreateDirectoryA
#endif // !UNICODE

WINBASEAPI
BOOL
WINAPI
CreateDirectoryExA(
    LPCSTR lpTemplateDirectory,
    LPCSTR lpNewDirectory,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes
    );
WINBASEAPI
BOOL
WINAPI
CreateDirectoryExW(
    LPCWSTR lpTemplateDirectory,
    LPCWSTR lpNewDirectory,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes
    );
#ifdef UNICODE
#define CreateDirectoryEx  CreateDirectoryExW
#else
#define CreateDirectoryEx  CreateDirectoryExA
#endif // !UNICODE

WINBASEAPI
BOOL
WINAPI
RemoveDirectoryA(
    LPCSTR lpPathName
    );
WINBASEAPI
BOOL
WINAPI
RemoveDirectoryW(
    LPCWSTR lpPathName
    );
#ifdef UNICODE
#define RemoveDirectory  RemoveDirectoryW
#else
#define RemoveDirectory  RemoveDirectoryA
#endif // !UNICODE

WINBASEAPI
DWORD
WINAPI
GetFullPathNameA(
    LPCSTR lpFileName,
    DWORD nBufferLength,
    LPSTR lpBuffer,
    LPSTR *lpFilePart
    );
WINBASEAPI
DWORD
WINAPI
GetFullPathNameW(
    LPCWSTR lpFileName,
    DWORD nBufferLength,
    LPWSTR lpBuffer,
    LPWSTR *lpFilePart
    );
#ifdef UNICODE
#define GetFullPathName  GetFullPathNameW
#else
#define GetFullPathName  GetFullPathNameA
#endif // !UNICODE


#define DDD_RAW_TARGET_PATH         0x00000001
#define DDD_REMOVE_DEFINITION       0x00000002
#define DDD_EXACT_MATCH_ON_REMOVE   0x00000004

WINBASEAPI
BOOL
WINAPI
DefineDosDeviceA(
    DWORD dwFlags,
    LPCSTR lpDeviceName,
    LPCSTR lpTargetPath
    );
WINBASEAPI
BOOL
WINAPI
DefineDosDeviceW(
    DWORD dwFlags,
    LPCWSTR lpDeviceName,
    LPCWSTR lpTargetPath
    );
#ifdef UNICODE
#define DefineDosDevice  DefineDosDeviceW
#else
#define DefineDosDevice  DefineDosDeviceA
#endif // !UNICODE

WINBASEAPI
DWORD
WINAPI
QueryDosDeviceA(
    LPCSTR lpDeviceName,
    LPSTR lpTargetPath,
    DWORD ucchMax
    );
WINBASEAPI
DWORD
WINAPI
QueryDosDeviceW(
    LPCWSTR lpDeviceName,
    LPWSTR lpTargetPath,
    DWORD ucchMax
    );
#ifdef UNICODE
#define QueryDosDevice  QueryDosDeviceW
#else
#define QueryDosDevice  QueryDosDeviceA
#endif // !UNICODE

#define EXPAND_LOCAL_DRIVES

WINBASEAPI
HANDLE
WINAPI
CreateFileA(
    LPCSTR lpFileName,
    DWORD dwDesiredAccess,
    DWORD dwShareMode,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    DWORD dwCreationDisposition,
    DWORD dwFlagsAndAttributes,
    HANDLE hTemplateFile
    );
WINBASEAPI
HANDLE
WINAPI
CreateFileW(
    LPCWSTR lpFileName,
    DWORD dwDesiredAccess,
    DWORD dwShareMode,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    DWORD dwCreationDisposition,
    DWORD dwFlagsAndAttributes,
    HANDLE hTemplateFile
    );
#ifdef UNICODE
#define CreateFile  CreateFileW
#else
#define CreateFile  CreateFileA
#endif // !UNICODE

WINBASEAPI
BOOL
WINAPI
SetFileAttributesA(
    LPCSTR lpFileName,
    DWORD dwFileAttributes
    );
WINBASEAPI
BOOL
WINAPI
SetFileAttributesW(
    LPCWSTR lpFileName,
    DWORD dwFileAttributes
    );
#ifdef UNICODE
#define SetFileAttributes  SetFileAttributesW
#else
#define SetFileAttributes  SetFileAttributesA
#endif // !UNICODE

WINBASEAPI
DWORD
WINAPI
GetFileAttributesA(
    LPCSTR lpFileName
    );
WINBASEAPI
DWORD
WINAPI
GetFileAttributesW(
    LPCWSTR lpFileName
    );
#ifdef UNICODE
#define GetFileAttributes  GetFileAttributesW
#else
#define GetFileAttributes  GetFileAttributesA
#endif // !UNICODE

WINBASEAPI
DWORD
WINAPI
GetCompressedFileSizeA(
    LPCSTR lpFileName,
    LPDWORD lpFileSizeHigh
    );
WINBASEAPI
DWORD
WINAPI
GetCompressedFileSizeW(
    LPCWSTR lpFileName,
    LPDWORD lpFileSizeHigh
    );
#ifdef UNICODE
#define GetCompressedFileSize  GetCompressedFileSizeW
#else
#define GetCompressedFileSize  GetCompressedFileSizeA
#endif // !UNICODE

WINBASEAPI
BOOL
WINAPI
DeleteFileA(
    LPCSTR lpFileName
    );
WINBASEAPI
BOOL
WINAPI
DeleteFileW(
    LPCWSTR lpFileName
    );
#ifdef UNICODE
#define DeleteFile  DeleteFileW
#else
#define DeleteFile  DeleteFileA
#endif // !UNICODE

WINBASEAPI
HANDLE
WINAPI
FindFirstFileA(
    LPCSTR lpFileName,
    LPWIN32_FIND_DATAA lpFindFileData
    );
WINBASEAPI
HANDLE
WINAPI
FindFirstFileW(
    LPCWSTR lpFileName,
    LPWIN32_FIND_DATAW lpFindFileData
    );
#ifdef UNICODE
#define FindFirstFile  FindFirstFileW
#else
#define FindFirstFile  FindFirstFileA
#endif // !UNICODE

WINBASEAPI
BOOL
WINAPI
FindNextFileA(
    HANDLE hFindFile,
    LPWIN32_FIND_DATAA lpFindFileData
    );
WINBASEAPI
BOOL
WINAPI
FindNextFileW(
    HANDLE hFindFile,
    LPWIN32_FIND_DATAW lpFindFileData
    );
#ifdef UNICODE
#define FindNextFile  FindNextFileW
#else
#define FindNextFile  FindNextFileA
#endif // !UNICODE

WINBASEAPI
DWORD
WINAPI
SearchPathA(
    LPCSTR lpPath,
    LPCSTR lpFileName,
    LPCSTR lpExtension,
    DWORD nBufferLength,
    LPSTR lpBuffer,
    LPSTR *lpFilePart
    );
WINBASEAPI
DWORD
WINAPI
SearchPathW(
    LPCWSTR lpPath,
    LPCWSTR lpFileName,
    LPCWSTR lpExtension,
    DWORD nBufferLength,
    LPWSTR lpBuffer,
    LPWSTR *lpFilePart
    );
#ifdef UNICODE
#define SearchPath  SearchPathW
#else
#define SearchPath  SearchPathA
#endif // !UNICODE

WINBASEAPI
BOOL
WINAPI
CopyFileA(
    LPCSTR lpExistingFileName,
    LPCSTR lpNewFileName,
    BOOL bFailIfExists
    );
WINBASEAPI
BOOL
WINAPI
CopyFileW(
    LPCWSTR lpExistingFileName,
    LPCWSTR lpNewFileName,
    BOOL bFailIfExists
    );
#ifdef UNICODE
#define CopyFile  CopyFileW
#else
#define CopyFile  CopyFileA
#endif // !UNICODE

WINBASEAPI
BOOL
WINAPI
MoveFileA(
    LPCSTR lpExistingFileName,
    LPCSTR lpNewFileName
    );
WINBASEAPI
BOOL
WINAPI
MoveFileW(
    LPCWSTR lpExistingFileName,
    LPCWSTR lpNewFileName
    );
#ifdef UNICODE
#define MoveFile  MoveFileW
#else
#define MoveFile  MoveFileA
#endif // !UNICODE

WINBASEAPI
BOOL
WINAPI
MoveFileExA(
    LPCSTR lpExistingFileName,
    LPCSTR lpNewFileName,
    DWORD dwFlags
    );
WINBASEAPI
BOOL
WINAPI
MoveFileExW(
    LPCWSTR lpExistingFileName,
    LPCWSTR lpNewFileName,
    DWORD dwFlags
    );
#ifdef UNICODE
#define MoveFileEx  MoveFileExW
#else
#define MoveFileEx  MoveFileExA
#endif // !UNICODE

#define MOVEFILE_REPLACE_EXISTING   0x00000001
#define MOVEFILE_COPY_ALLOWED       0x00000002
#define MOVEFILE_DELAY_UNTIL_REBOOT 0x00000004

WINBASEAPI
HANDLE
WINAPI
CreateNamedPipeA(
    LPCSTR lpName,
    DWORD dwOpenMode,
    DWORD dwPipeMode,
    DWORD nMaxInstances,
    DWORD nOutBufferSize,
    DWORD nInBufferSize,
    DWORD nDefaultTimeOut,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes
    );
WINBASEAPI
HANDLE
WINAPI
CreateNamedPipeW(
    LPCWSTR lpName,
    DWORD dwOpenMode,
    DWORD dwPipeMode,
    DWORD nMaxInstances,
    DWORD nOutBufferSize,
    DWORD nInBufferSize,
    DWORD nDefaultTimeOut,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes
    );
#ifdef UNICODE
#define CreateNamedPipe  CreateNamedPipeW
#else
#define CreateNamedPipe  CreateNamedPipeA
#endif // !UNICODE

WINBASEAPI
BOOL
WINAPI
GetNamedPipeHandleStateA(
    HANDLE hNamedPipe,
    LPDWORD lpState,
    LPDWORD lpCurInstances,
    LPDWORD lpMaxCollectionCount,
    LPDWORD lpCollectDataTimeout,
    LPSTR lpUserName,
    DWORD nMaxUserNameSize
    );
WINBASEAPI
BOOL
WINAPI
GetNamedPipeHandleStateW(
    HANDLE hNamedPipe,
    LPDWORD lpState,
    LPDWORD lpCurInstances,
    LPDWORD lpMaxCollectionCount,
    LPDWORD lpCollectDataTimeout,
    LPWSTR lpUserName,
    DWORD nMaxUserNameSize
    );
#ifdef UNICODE
#define GetNamedPipeHandleState  GetNamedPipeHandleStateW
#else
#define GetNamedPipeHandleState  GetNamedPipeHandleStateA
#endif // !UNICODE

WINBASEAPI
BOOL
WINAPI
CallNamedPipeA(
    LPCSTR lpNamedPipeName,
    LPVOID lpInBuffer,
    DWORD nInBufferSize,
    LPVOID lpOutBuffer,
    DWORD nOutBufferSize,
    LPDWORD lpBytesRead,
    DWORD nTimeOut
    );
WINBASEAPI
BOOL
WINAPI
CallNamedPipeW(
    LPCWSTR lpNamedPipeName,
    LPVOID lpInBuffer,
    DWORD nInBufferSize,
    LPVOID lpOutBuffer,
    DWORD nOutBufferSize,
    LPDWORD lpBytesRead,
    DWORD nTimeOut
    );
#ifdef UNICODE
#define CallNamedPipe  CallNamedPipeW
#else
#define CallNamedPipe  CallNamedPipeA
#endif // !UNICODE

WINBASEAPI
BOOL
WINAPI
WaitNamedPipeA(
    LPCSTR lpNamedPipeName,
    DWORD nTimeOut
    );
WINBASEAPI
BOOL
WINAPI
WaitNamedPipeW(
    LPCWSTR lpNamedPipeName,
    DWORD nTimeOut
    );
#ifdef UNICODE
#define WaitNamedPipe  WaitNamedPipeW
#else
#define WaitNamedPipe  WaitNamedPipeA
#endif // !UNICODE

WINBASEAPI
BOOL
WINAPI
SetVolumeLabelA(
    LPCSTR lpRootPathName,
    LPCSTR lpVolumeName
    );
WINBASEAPI
BOOL
WINAPI
SetVolumeLabelW(
    LPCWSTR lpRootPathName,
    LPCWSTR lpVolumeName
    );
#ifdef UNICODE
#define SetVolumeLabel  SetVolumeLabelW
#else
#define SetVolumeLabel  SetVolumeLabelA
#endif // !UNICODE

WINBASEAPI
VOID
WINAPI
SetFileApisToOEM( VOID );

WINBASEAPI
VOID
WINAPI
SetFileApisToANSI( VOID );

WINBASEAPI
BOOL
WINAPI
AreFileApisANSI( VOID );

WINBASEAPI
BOOL
WINAPI
GetVolumeInformationA(
    LPCSTR lpRootPathName,
    LPSTR lpVolumeNameBuffer,
    DWORD nVolumeNameSize,
    LPDWORD lpVolumeSerialNumber,
    LPDWORD lpMaximumComponentLength,
    LPDWORD lpFileSystemFlags,
    LPSTR lpFileSystemNameBuffer,
    DWORD nFileSystemNameSize
    );
WINBASEAPI
BOOL
WINAPI
GetVolumeInformationW(
    LPCWSTR lpRootPathName,
    LPWSTR lpVolumeNameBuffer,
    DWORD nVolumeNameSize,
    LPDWORD lpVolumeSerialNumber,
    LPDWORD lpMaximumComponentLength,
    LPDWORD lpFileSystemFlags,
    LPWSTR lpFileSystemNameBuffer,
    DWORD nFileSystemNameSize
    );
#ifdef UNICODE
#define GetVolumeInformation  GetVolumeInformationW
#else
#define GetVolumeInformation  GetVolumeInformationA
#endif // !UNICODE

//
// Event logging APIs
//

WINADVAPI
BOOL
WINAPI
ClearEventLogA (
    HANDLE hEventLog,
    LPCSTR lpBackupFileName
    );
WINADVAPI
BOOL
WINAPI
ClearEventLogW (
    HANDLE hEventLog,
    LPCWSTR lpBackupFileName
    );
#ifdef UNICODE
#define ClearEventLog  ClearEventLogW
#else
#define ClearEventLog  ClearEventLogA
#endif // !UNICODE

WINADVAPI
BOOL
WINAPI
BackupEventLogA (
    HANDLE hEventLog,
    LPCSTR lpBackupFileName
    );
WINADVAPI
BOOL
WINAPI
BackupEventLogW (
    HANDLE hEventLog,
    LPCWSTR lpBackupFileName
    );
#ifdef UNICODE
#define BackupEventLog  BackupEventLogW
#else
#define BackupEventLog  BackupEventLogA
#endif // !UNICODE

WINADVAPI
BOOL
WINAPI
CloseEventLog (
    HANDLE hEventLog
    );

WINADVAPI
BOOL
WINAPI
DeregisterEventSource (
    HANDLE hEventLog
    );

WINADVAPI
BOOL
WINAPI
NotifyChangeEventLog(
    HANDLE  hEventLog,
    HANDLE  hEvent
    );

WINADVAPI
BOOL
WINAPI
GetNumberOfEventLogRecords (
    HANDLE hEventLog,
    PDWORD NumberOfRecords
    );

WINADVAPI
BOOL
WINAPI
GetOldestEventLogRecord (
    HANDLE hEventLog,
    PDWORD OldestRecord
    );

WINADVAPI
HANDLE
WINAPI
OpenEventLogA (
    LPCSTR lpUNCServerName,
    LPCSTR lpSourceName
    );
WINADVAPI
HANDLE
WINAPI
OpenEventLogW (
    LPCWSTR lpUNCServerName,
    LPCWSTR lpSourceName
    );
#ifdef UNICODE
#define OpenEventLog  OpenEventLogW
#else
#define OpenEventLog  OpenEventLogA
#endif // !UNICODE

WINADVAPI
HANDLE
WINAPI
RegisterEventSourceA (
    LPCSTR lpUNCServerName,
    LPCSTR lpSourceName
    );
WINADVAPI
HANDLE
WINAPI
RegisterEventSourceW (
    LPCWSTR lpUNCServerName,
    LPCWSTR lpSourceName
    );
#ifdef UNICODE
#define RegisterEventSource  RegisterEventSourceW
#else
#define RegisterEventSource  RegisterEventSourceA
#endif // !UNICODE

WINADVAPI
HANDLE
WINAPI
OpenBackupEventLogA (
    LPCSTR lpUNCServerName,
    LPCSTR lpFileName
    );
WINADVAPI
HANDLE
WINAPI
OpenBackupEventLogW (
    LPCWSTR lpUNCServerName,
    LPCWSTR lpFileName
    );
#ifdef UNICODE
#define OpenBackupEventLog  OpenBackupEventLogW
#else
#define OpenBackupEventLog  OpenBackupEventLogA
#endif // !UNICODE

WINADVAPI
BOOL
WINAPI
ReadEventLogA (
     HANDLE     hEventLog,
     DWORD      dwReadFlags,
     DWORD      dwRecordOffset,
     LPVOID     lpBuffer,
     DWORD      nNumberOfBytesToRead,
     DWORD      *pnBytesRead,
     DWORD      *pnMinNumberOfBytesNeeded
    );
WINADVAPI
BOOL
WINAPI
ReadEventLogW (
     HANDLE     hEventLog,
     DWORD      dwReadFlags,
     DWORD      dwRecordOffset,
     LPVOID     lpBuffer,
     DWORD      nNumberOfBytesToRead,
     DWORD      *pnBytesRead,
     DWORD      *pnMinNumberOfBytesNeeded
    );
#ifdef UNICODE
#define ReadEventLog  ReadEventLogW
#else
#define ReadEventLog  ReadEventLogA
#endif // !UNICODE

WINADVAPI
BOOL
WINAPI
ReportEventA (
     HANDLE     hEventLog,
     WORD       wType,
     WORD       wCategory,
     DWORD      dwEventID,
     PSID       lpUserSid,
     WORD       wNumStrings,
     DWORD      dwDataSize,
     LPCSTR   *lpStrings,
     LPVOID     lpRawData
    );
WINADVAPI
BOOL
WINAPI
ReportEventW (
     HANDLE     hEventLog,
     WORD       wType,
     WORD       wCategory,
     DWORD      dwEventID,
     PSID       lpUserSid,
     WORD       wNumStrings,
     DWORD      dwDataSize,
     LPCWSTR   *lpStrings,
     LPVOID     lpRawData
    );
#ifdef UNICODE
#define ReportEvent  ReportEventW
#else
#define ReportEvent  ReportEventA
#endif // !UNICODE

//
//
// Security APIs
//


WINADVAPI
BOOL
WINAPI
DuplicateToken(
    HANDLE ExistingTokenHandle,
    SECURITY_IMPERSONATION_LEVEL ImpersonationLevel,
    PHANDLE DuplicateTokenHandle
    );

WINADVAPI
BOOL
WINAPI
GetKernelObjectSecurity (
    HANDLE Handle,
    SECURITY_INFORMATION RequestedInformation,
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    DWORD nLength,
    LPDWORD lpnLengthNeeded
    );

WINADVAPI
BOOL
WINAPI
ImpersonateNamedPipeClient(
    HANDLE hNamedPipe
    );

WINADVAPI
BOOL
WINAPI
ImpersonateSelf(
    SECURITY_IMPERSONATION_LEVEL ImpersonationLevel
    );


WINADVAPI
BOOL
WINAPI
RevertToSelf (
    VOID
    );

WINADVAPI
BOOL
APIENTRY
SetThreadToken (
    PHANDLE Thread,
    HANDLE Token
    );

WINADVAPI
BOOL
WINAPI
AccessCheck (
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    HANDLE ClientToken,
    DWORD DesiredAccess,
    PGENERIC_MAPPING GenericMapping,
    PPRIVILEGE_SET PrivilegeSet,
    LPDWORD PrivilegeSetLength,
    LPDWORD GrantedAccess,
    LPBOOL AccessStatus
    );


WINADVAPI
BOOL
WINAPI
OpenProcessToken (
    HANDLE ProcessHandle,
    DWORD DesiredAccess,
    PHANDLE TokenHandle
    );


WINADVAPI
BOOL
WINAPI
OpenThreadToken (
    HANDLE ThreadHandle,
    DWORD DesiredAccess,
    BOOL OpenAsSelf,
    PHANDLE TokenHandle
    );


WINADVAPI
BOOL
WINAPI
GetTokenInformation (
    HANDLE TokenHandle,
    TOKEN_INFORMATION_CLASS TokenInformationClass,
    LPVOID TokenInformation,
    DWORD TokenInformationLength,
    PDWORD ReturnLength
    );


WINADVAPI
BOOL
WINAPI
SetTokenInformation (
    HANDLE TokenHandle,
    TOKEN_INFORMATION_CLASS TokenInformationClass,
    LPVOID TokenInformation,
    DWORD TokenInformationLength
    );


WINADVAPI
BOOL
WINAPI
AdjustTokenPrivileges (
    HANDLE TokenHandle,
    BOOL DisableAllPrivileges,
    PTOKEN_PRIVILEGES NewState,
    DWORD BufferLength,
    PTOKEN_PRIVILEGES PreviousState,
    PDWORD ReturnLength
    );


WINADVAPI
BOOL
WINAPI
AdjustTokenGroups (
    HANDLE TokenHandle,
    BOOL ResetToDefault,
    PTOKEN_GROUPS NewState,
    DWORD BufferLength,
    PTOKEN_GROUPS PreviousState,
    PDWORD ReturnLength
    );


WINADVAPI
BOOL
WINAPI
PrivilegeCheck (
    HANDLE ClientToken,
    PPRIVILEGE_SET RequiredPrivileges,
    LPBOOL pfResult
    );


WINADVAPI
BOOL
WINAPI
AccessCheckAndAuditAlarmA (
    LPCSTR SubsystemName,
    LPVOID HandleId,
    LPSTR ObjectTypeName,
    LPSTR ObjectName,
    PSECURITY_DESCRIPTOR SecurityDescriptor,
    DWORD DesiredAccess,
    PGENERIC_MAPPING GenericMapping,
    BOOL ObjectCreation,
    LPDWORD GrantedAccess,
    LPBOOL AccessStatus,
    LPBOOL pfGenerateOnClose
    );
WINADVAPI
BOOL
WINAPI
AccessCheckAndAuditAlarmW (
    LPCWSTR SubsystemName,
    LPVOID HandleId,
    LPWSTR ObjectTypeName,
    LPWSTR ObjectName,
    PSECURITY_DESCRIPTOR SecurityDescriptor,
    DWORD DesiredAccess,
    PGENERIC_MAPPING GenericMapping,
    BOOL ObjectCreation,
    LPDWORD GrantedAccess,
    LPBOOL AccessStatus,
    LPBOOL pfGenerateOnClose
    );
#ifdef UNICODE
#define AccessCheckAndAuditAlarm  AccessCheckAndAuditAlarmW
#else
#define AccessCheckAndAuditAlarm  AccessCheckAndAuditAlarmA
#endif // !UNICODE


WINADVAPI
BOOL
WINAPI
ObjectOpenAuditAlarmA (
    LPCSTR SubsystemName,
    LPVOID HandleId,
    LPSTR ObjectTypeName,
    LPSTR ObjectName,
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    HANDLE ClientToken,
    DWORD DesiredAccess,
    DWORD GrantedAccess,
    PPRIVILEGE_SET Privileges,
    BOOL ObjectCreation,
    BOOL AccessGranted,
    LPBOOL GenerateOnClose
    );
WINADVAPI
BOOL
WINAPI
ObjectOpenAuditAlarmW (
    LPCWSTR SubsystemName,
    LPVOID HandleId,
    LPWSTR ObjectTypeName,
    LPWSTR ObjectName,
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    HANDLE ClientToken,
    DWORD DesiredAccess,
    DWORD GrantedAccess,
    PPRIVILEGE_SET Privileges,
    BOOL ObjectCreation,
    BOOL AccessGranted,
    LPBOOL GenerateOnClose
    );
#ifdef UNICODE
#define ObjectOpenAuditAlarm  ObjectOpenAuditAlarmW
#else
#define ObjectOpenAuditAlarm  ObjectOpenAuditAlarmA
#endif // !UNICODE


WINADVAPI
BOOL
WINAPI
ObjectPrivilegeAuditAlarmA (
    LPCSTR SubsystemName,
    LPVOID HandleId,
    HANDLE ClientToken,
    DWORD DesiredAccess,
    PPRIVILEGE_SET Privileges,
    BOOL AccessGranted
    );
WINADVAPI
BOOL
WINAPI
ObjectPrivilegeAuditAlarmW (
    LPCWSTR SubsystemName,
    LPVOID HandleId,
    HANDLE ClientToken,
    DWORD DesiredAccess,
    PPRIVILEGE_SET Privileges,
    BOOL AccessGranted
    );
#ifdef UNICODE
#define ObjectPrivilegeAuditAlarm  ObjectPrivilegeAuditAlarmW
#else
#define ObjectPrivilegeAuditAlarm  ObjectPrivilegeAuditAlarmA
#endif // !UNICODE


WINADVAPI
BOOL
WINAPI
ObjectCloseAuditAlarmA (
    LPCSTR SubsystemName,
    LPVOID HandleId,
    BOOL GenerateOnClose
    );
WINADVAPI
BOOL
WINAPI
ObjectCloseAuditAlarmW (
    LPCWSTR SubsystemName,
    LPVOID HandleId,
    BOOL GenerateOnClose
    );
#ifdef UNICODE
#define ObjectCloseAuditAlarm  ObjectCloseAuditAlarmW
#else
#define ObjectCloseAuditAlarm  ObjectCloseAuditAlarmA
#endif // !UNICODE


WINADVAPI
BOOL
WINAPI
PrivilegedServiceAuditAlarmA (
    LPCSTR SubsystemName,
    LPCSTR ServiceName,
    HANDLE ClientToken,
    PPRIVILEGE_SET Privileges,
    BOOL AccessGranted
    );
WINADVAPI
BOOL
WINAPI
PrivilegedServiceAuditAlarmW (
    LPCWSTR SubsystemName,
    LPCWSTR ServiceName,
    HANDLE ClientToken,
    PPRIVILEGE_SET Privileges,
    BOOL AccessGranted
    );
#ifdef UNICODE
#define PrivilegedServiceAuditAlarm  PrivilegedServiceAuditAlarmW
#else
#define PrivilegedServiceAuditAlarm  PrivilegedServiceAuditAlarmA
#endif // !UNICODE


WINADVAPI
BOOL
WINAPI
IsValidSid (
    PSID pSid
    );


WINADVAPI
BOOL
WINAPI
EqualSid (
    PSID pSid1,
    PSID pSid2
    );


WINADVAPI
BOOL
WINAPI
EqualPrefixSid (
    PSID pSid1,
    PSID pSid2
    );


WINADVAPI
DWORD
WINAPI
GetSidLengthRequired (
    UCHAR nSubAuthorityCount
    );


WINADVAPI
BOOL
WINAPI
AllocateAndInitializeSid (
    PSID_IDENTIFIER_AUTHORITY pIdentifierAuthority,
    BYTE nSubAuthorityCount,
    DWORD nSubAuthority0,
    DWORD nSubAuthority1,
    DWORD nSubAuthority2,
    DWORD nSubAuthority3,
    DWORD nSubAuthority4,
    DWORD nSubAuthority5,
    DWORD nSubAuthority6,
    DWORD nSubAuthority7,
    PSID *pSid
    );

WINADVAPI
PVOID
WINAPI
FreeSid(
    PSID pSid
    );

WINADVAPI
BOOL
WINAPI
InitializeSid (
    PSID Sid,
    PSID_IDENTIFIER_AUTHORITY pIdentifierAuthority,
    BYTE nSubAuthorityCount
    );


WINADVAPI
PSID_IDENTIFIER_AUTHORITY
WINAPI
GetSidIdentifierAuthority (
    PSID pSid
    );


WINADVAPI
PDWORD
WINAPI
GetSidSubAuthority (
    PSID pSid,
    DWORD nSubAuthority
    );


WINADVAPI
PUCHAR
WINAPI
GetSidSubAuthorityCount (
    PSID pSid
    );


WINADVAPI
DWORD
WINAPI
GetLengthSid (
    PSID pSid
    );


WINADVAPI
BOOL
WINAPI
CopySid (
    DWORD nDestinationSidLength,
    PSID pDestinationSid,
    PSID pSourceSid
    );


WINADVAPI
BOOL
WINAPI
AreAllAccessesGranted (
    DWORD GrantedAccess,
    DWORD DesiredAccess
    );


WINADVAPI
BOOL
WINAPI
AreAnyAccessesGranted (
    DWORD GrantedAccess,
    DWORD DesiredAccess
    );


WINADVAPI
VOID
WINAPI
MapGenericMask (
    PDWORD AccessMask,
    PGENERIC_MAPPING GenericMapping
    );


WINADVAPI
BOOL
WINAPI
IsValidAcl (
    PACL pAcl
    );


WINADVAPI
BOOL
WINAPI
InitializeAcl (
    PACL pAcl,
    DWORD nAclLength,
    DWORD dwAclRevision
    );


WINADVAPI
BOOL
WINAPI
GetAclInformation (
    PACL pAcl,
    LPVOID pAclInformation,
    DWORD nAclInformationLength,
    ACL_INFORMATION_CLASS dwAclInformationClass
    );


WINADVAPI
BOOL
WINAPI
SetAclInformation (
    PACL pAcl,
    LPVOID pAclInformation,
    DWORD nAclInformationLength,
    ACL_INFORMATION_CLASS dwAclInformationClass
    );


WINADVAPI
BOOL
WINAPI
AddAce (
    PACL pAcl,
    DWORD dwAceRevision,
    DWORD dwStartingAceIndex,
    LPVOID pAceList,
    DWORD nAceListLength
    );


WINADVAPI
BOOL
WINAPI
DeleteAce (
    PACL pAcl,
    DWORD dwAceIndex
    );


WINADVAPI
BOOL
WINAPI
GetAce (
    PACL pAcl,
    DWORD dwAceIndex,
    LPVOID *pAce
    );


WINADVAPI
BOOL
WINAPI
AddAccessAllowedAce (
    PACL pAcl,
    DWORD dwAceRevision,
    DWORD AccessMask,
    PSID pSid
    );


WINADVAPI
BOOL
WINAPI
AddAccessDeniedAce (
    PACL pAcl,
    DWORD dwAceRevision,
    DWORD AccessMask,
    PSID pSid
    );


WINADVAPI
BOOL
WINAPI
AddAuditAccessAce(
    PACL pAcl,
    DWORD dwAceRevision,
    DWORD dwAccessMask,
    PSID pSid,
    BOOL bAuditSuccess,
    BOOL bAuditFailure
    );


WINADVAPI
BOOL
WINAPI
FindFirstFreeAce (
    PACL pAcl,
    LPVOID *pAce
    );


WINADVAPI
BOOL
WINAPI
InitializeSecurityDescriptor (
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    DWORD dwRevision
    );


WINADVAPI
BOOL
WINAPI
IsValidSecurityDescriptor (
    PSECURITY_DESCRIPTOR pSecurityDescriptor
    );


WINADVAPI
DWORD
WINAPI
GetSecurityDescriptorLength (
    PSECURITY_DESCRIPTOR pSecurityDescriptor
    );


WINADVAPI
BOOL
WINAPI
GetSecurityDescriptorControl (
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    PSECURITY_DESCRIPTOR_CONTROL pControl,
    LPDWORD lpdwRevision
    );


WINADVAPI
BOOL
WINAPI
SetSecurityDescriptorDacl (
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    BOOL bDaclPresent,
    PACL pDacl,
    BOOL bDaclDefaulted
    );


WINADVAPI
BOOL
WINAPI
GetSecurityDescriptorDacl (
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    LPBOOL lpbDaclPresent,
    PACL *pDacl,
    LPBOOL lpbDaclDefaulted
    );


WINADVAPI
BOOL
WINAPI
SetSecurityDescriptorSacl (
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    BOOL bSaclPresent,
    PACL pSacl,
    BOOL bSaclDefaulted
    );


WINADVAPI
BOOL
WINAPI
GetSecurityDescriptorSacl (
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    LPBOOL lpbSaclPresent,
    PACL *pSacl,
    LPBOOL lpbSaclDefaulted
    );


WINADVAPI
BOOL
WINAPI
SetSecurityDescriptorOwner (
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    PSID pOwner,
    BOOL bOwnerDefaulted
    );


WINADVAPI
BOOL
WINAPI
GetSecurityDescriptorOwner (
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    PSID *pOwner,
    LPBOOL lpbOwnerDefaulted
    );


WINADVAPI
BOOL
WINAPI
SetSecurityDescriptorGroup (
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    PSID pGroup,
    BOOL bGroupDefaulted
    );


WINADVAPI
BOOL
WINAPI
GetSecurityDescriptorGroup (
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    PSID *pGroup,
    LPBOOL lpbGroupDefaulted
    );


WINADVAPI
BOOL
WINAPI
CreatePrivateObjectSecurity (
    PSECURITY_DESCRIPTOR ParentDescriptor,
    PSECURITY_DESCRIPTOR CreatorDescriptor,
    PSECURITY_DESCRIPTOR * NewDescriptor,
    BOOL IsDirectoryObject,
    HANDLE Token,
    PGENERIC_MAPPING GenericMapping
    );


WINADVAPI
BOOL
WINAPI
SetPrivateObjectSecurity (
    SECURITY_INFORMATION SecurityInformation,
    PSECURITY_DESCRIPTOR ModificationDescriptor,
    PSECURITY_DESCRIPTOR *ObjectsSecurityDescriptor,
    PGENERIC_MAPPING GenericMapping,
    HANDLE Token
    );


WINADVAPI
BOOL
WINAPI
GetPrivateObjectSecurity (
    PSECURITY_DESCRIPTOR ObjectDescriptor,
    SECURITY_INFORMATION SecurityInformation,
    PSECURITY_DESCRIPTOR ResultantDescriptor,
    DWORD DescriptorLength,
    PDWORD ReturnLength
    );


WINADVAPI
BOOL
WINAPI
DestroyPrivateObjectSecurity (
    PSECURITY_DESCRIPTOR * ObjectDescriptor
    );


WINADVAPI
BOOL
WINAPI
MakeSelfRelativeSD (
    PSECURITY_DESCRIPTOR pAbsoluteSecurityDescriptor,
    PSECURITY_DESCRIPTOR pSelfRelativeSecurityDescriptor,
    LPDWORD lpdwBufferLength
    );


WINADVAPI
BOOL
WINAPI
MakeAbsoluteSD (
    PSECURITY_DESCRIPTOR pSelfRelativeSecurityDescriptor,
    PSECURITY_DESCRIPTOR pAbsoluteSecurityDescriptor,
    LPDWORD lpdwAbsoluteSecurityDescriptorSize,
    PACL pDacl,
    LPDWORD lpdwDaclSize,
    PACL pSacl,
    LPDWORD lpdwSaclSize,
    PSID pOwner,
    LPDWORD lpdwOwnerSize,
    PSID pPrimaryGroup,
    LPDWORD lpdwPrimaryGroupSize
    );


WINADVAPI
BOOL
WINAPI
SetFileSecurityA (
    LPCSTR lpFileName,
    SECURITY_INFORMATION SecurityInformation,
    PSECURITY_DESCRIPTOR pSecurityDescriptor
    );
WINADVAPI
BOOL
WINAPI
SetFileSecurityW (
    LPCWSTR lpFileName,
    SECURITY_INFORMATION SecurityInformation,
    PSECURITY_DESCRIPTOR pSecurityDescriptor
    );
#ifdef UNICODE
#define SetFileSecurity  SetFileSecurityW
#else
#define SetFileSecurity  SetFileSecurityA
#endif // !UNICODE


WINADVAPI
BOOL
WINAPI
GetFileSecurityA (
    LPCSTR lpFileName,
    SECURITY_INFORMATION RequestedInformation,
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    DWORD nLength,
    LPDWORD lpnLengthNeeded
    );
WINADVAPI
BOOL
WINAPI
GetFileSecurityW (
    LPCWSTR lpFileName,
    SECURITY_INFORMATION RequestedInformation,
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    DWORD nLength,
    LPDWORD lpnLengthNeeded
    );
#ifdef UNICODE
#define GetFileSecurity  GetFileSecurityW
#else
#define GetFileSecurity  GetFileSecurityA
#endif // !UNICODE


WINADVAPI
BOOL
WINAPI
SetKernelObjectSecurity (
    HANDLE Handle,
    SECURITY_INFORMATION SecurityInformation,
    PSECURITY_DESCRIPTOR SecurityDescriptor
    );



WINBASEAPI
HANDLE
WINAPI
FindFirstChangeNotificationA(
    LPCSTR lpPathName,
    BOOL bWatchSubtree,
    DWORD dwNotifyFilter
    );
WINBASEAPI
HANDLE
WINAPI
FindFirstChangeNotificationW(
    LPCWSTR lpPathName,
    BOOL bWatchSubtree,
    DWORD dwNotifyFilter
    );
#ifdef UNICODE
#define FindFirstChangeNotification  FindFirstChangeNotificationW
#else
#define FindFirstChangeNotification  FindFirstChangeNotificationA
#endif // !UNICODE

WINBASEAPI
BOOL
WINAPI
FindNextChangeNotification(
    HANDLE hChangeHandle
    );

WINBASEAPI
BOOL
WINAPI
FindCloseChangeNotification(
    HANDLE hChangeHandle
    );

WINBASEAPI
BOOL
WINAPI
VirtualLock(
    LPVOID lpAddress,
    DWORD dwSize
    );

WINBASEAPI
BOOL
WINAPI
VirtualUnlock(
    LPVOID lpAddress,
    DWORD dwSize
    );

WINBASEAPI
LPVOID
WINAPI
MapViewOfFileEx(
    HANDLE hFileMappingObject,
    DWORD dwDesiredAccess,
    DWORD dwFileOffsetHigh,
    DWORD dwFileOffsetLow,
    DWORD dwNumberOfBytesToMap,
    LPVOID lpBaseAddress
    );

WINBASEAPI
BOOL
WINAPI
SetPriorityClass(
    HANDLE hProcess,
    DWORD dwPriorityClass
    );

WINBASEAPI
DWORD
WINAPI
GetPriorityClass(
    HANDLE hProcess
    );

WINBASEAPI
BOOL
WINAPI
IsBadReadPtr(
    CONST VOID *lp,
    UINT ucb
    );

WINBASEAPI
BOOL
WINAPI
IsBadWritePtr(
    LPVOID lp,
    UINT ucb
    );

WINBASEAPI
BOOL
WINAPI
IsBadHugeReadPtr(
    CONST VOID *lp,
    UINT ucb
    );

WINBASEAPI
BOOL
WINAPI
IsBadHugeWritePtr(
    LPVOID lp,
    UINT ucb
    );

WINBASEAPI
BOOL
WINAPI
IsBadCodePtr(
    FARPROC lpfn
    );

WINBASEAPI
BOOL
WINAPI
IsBadStringPtrA(
    LPCSTR lpsz,
    UINT ucchMax
    );
WINBASEAPI
BOOL
WINAPI
IsBadStringPtrW(
    LPCWSTR lpsz,
    UINT ucchMax
    );
#ifdef UNICODE
#define IsBadStringPtr  IsBadStringPtrW
#else
#define IsBadStringPtr  IsBadStringPtrA
#endif // !UNICODE

WINADVAPI
BOOL
WINAPI
LookupAccountSidA(
    LPCSTR lpSystemName,
    PSID Sid,
    LPSTR Name,
    LPDWORD cbName,
    LPSTR ReferencedDomainName,
    LPDWORD cbReferencedDomainName,
    PSID_NAME_USE peUse
    );
WINADVAPI
BOOL
WINAPI
LookupAccountSidW(
    LPCWSTR lpSystemName,
    PSID Sid,
    LPWSTR Name,
    LPDWORD cbName,
    LPWSTR ReferencedDomainName,
    LPDWORD cbReferencedDomainName,
    PSID_NAME_USE peUse
    );
#ifdef UNICODE
#define LookupAccountSid  LookupAccountSidW
#else
#define LookupAccountSid  LookupAccountSidA
#endif // !UNICODE

WINADVAPI
BOOL
WINAPI
LookupAccountNameA(
    LPCSTR lpSystemName,
    LPCSTR lpAccountName,
    PSID Sid,
    LPDWORD cbSid,
    LPSTR ReferencedDomainName,
    LPDWORD cbReferencedDomainName,
    PSID_NAME_USE peUse
    );
WINADVAPI
BOOL
WINAPI
LookupAccountNameW(
    LPCWSTR lpSystemName,
    LPCWSTR lpAccountName,
    PSID Sid,
    LPDWORD cbSid,
    LPWSTR ReferencedDomainName,
    LPDWORD cbReferencedDomainName,
    PSID_NAME_USE peUse
    );
#ifdef UNICODE
#define LookupAccountName  LookupAccountNameW
#else
#define LookupAccountName  LookupAccountNameA
#endif // !UNICODE

WINADVAPI
BOOL
WINAPI
LookupPrivilegeValueA(
    LPCSTR lpSystemName,
    LPCSTR lpName,
    PLUID   lpLuid
    );
WINADVAPI
BOOL
WINAPI
LookupPrivilegeValueW(
    LPCWSTR lpSystemName,
    LPCWSTR lpName,
    PLUID   lpLuid
    );
#ifdef UNICODE
#define LookupPrivilegeValue  LookupPrivilegeValueW
#else
#define LookupPrivilegeValue  LookupPrivilegeValueA
#endif // !UNICODE

WINADVAPI
BOOL
WINAPI
LookupPrivilegeNameA(
    LPCSTR lpSystemName,
    PLUID   lpLuid,
    LPSTR lpName,
    LPDWORD cbName
    );
WINADVAPI
BOOL
WINAPI
LookupPrivilegeNameW(
    LPCWSTR lpSystemName,
    PLUID   lpLuid,
    LPWSTR lpName,
    LPDWORD cbName
    );
#ifdef UNICODE
#define LookupPrivilegeName  LookupPrivilegeNameW
#else
#define LookupPrivilegeName  LookupPrivilegeNameA
#endif // !UNICODE

WINADVAPI
BOOL
WINAPI
LookupPrivilegeDisplayNameA(
    LPCSTR lpSystemName,
    LPCSTR lpName,
    LPSTR lpDisplayName,
    LPDWORD cbDisplayName,
    LPDWORD lpLanguageId
    );
WINADVAPI
BOOL
WINAPI
LookupPrivilegeDisplayNameW(
    LPCWSTR lpSystemName,
    LPCWSTR lpName,
    LPWSTR lpDisplayName,
    LPDWORD cbDisplayName,
    LPDWORD lpLanguageId
    );
#ifdef UNICODE
#define LookupPrivilegeDisplayName  LookupPrivilegeDisplayNameW
#else
#define LookupPrivilegeDisplayName  LookupPrivilegeDisplayNameA
#endif // !UNICODE

WINADVAPI
BOOL
WINAPI
AllocateLocallyUniqueId(
    PLUID Luid
    );

WINBASEAPI
BOOL
WINAPI
BuildCommDCBA(
    LPCSTR lpDef,
    LPDCB lpDCB
    );
WINBASEAPI
BOOL
WINAPI
BuildCommDCBW(
    LPCWSTR lpDef,
    LPDCB lpDCB
    );
#ifdef UNICODE
#define BuildCommDCB  BuildCommDCBW
#else
#define BuildCommDCB  BuildCommDCBA
#endif // !UNICODE

WINBASEAPI
BOOL
WINAPI
BuildCommDCBAndTimeoutsA(
    LPCSTR lpDef,
    LPDCB lpDCB,
    LPCOMMTIMEOUTS lpCommTimeouts
    );
WINBASEAPI
BOOL
WINAPI
BuildCommDCBAndTimeoutsW(
    LPCWSTR lpDef,
    LPDCB lpDCB,
    LPCOMMTIMEOUTS lpCommTimeouts
    );
#ifdef UNICODE
#define BuildCommDCBAndTimeouts  BuildCommDCBAndTimeoutsW
#else
#define BuildCommDCBAndTimeouts  BuildCommDCBAndTimeoutsA
#endif // !UNICODE

WINBASEAPI
BOOL
WINAPI
CommConfigDialogA(
    LPCSTR lpszName,
    HWND hWnd,
    LPCOMMCONFIG lpCC
    );
WINBASEAPI
BOOL
WINAPI
CommConfigDialogW(
    LPCWSTR lpszName,
    HWND hWnd,
    LPCOMMCONFIG lpCC
    );
#ifdef UNICODE
#define CommConfigDialog  CommConfigDialogW
#else
#define CommConfigDialog  CommConfigDialogA
#endif // !UNICODE

WINBASEAPI
BOOL
WINAPI
GetDefaultCommConfigA(
    LPCSTR lpszName,
    LPCOMMCONFIG lpCC,
    LPDWORD lpdwSize
    );
WINBASEAPI
BOOL
WINAPI
GetDefaultCommConfigW(
    LPCWSTR lpszName,
    LPCOMMCONFIG lpCC,
    LPDWORD lpdwSize
    );
#ifdef UNICODE
#define GetDefaultCommConfig  GetDefaultCommConfigW
#else
#define GetDefaultCommConfig  GetDefaultCommConfigA
#endif // !UNICODE

WINBASEAPI
BOOL
WINAPI
SetDefaultCommConfigA(
    LPCSTR lpszName,
    LPCOMMCONFIG lpCC,
    DWORD dwSize
    );
WINBASEAPI
BOOL
WINAPI
SetDefaultCommConfigW(
    LPCWSTR lpszName,
    LPCOMMCONFIG lpCC,
    DWORD dwSize
    );
#ifdef UNICODE
#define SetDefaultCommConfig  SetDefaultCommConfigW
#else
#define SetDefaultCommConfig  SetDefaultCommConfigA
#endif // !UNICODE

#define MAX_COMPUTERNAME_LENGTH 15

WINBASEAPI
BOOL
WINAPI
GetComputerNameA (
    LPSTR lpBuffer,
    LPDWORD nSize
    );
WINBASEAPI
BOOL
WINAPI
GetComputerNameW (
    LPWSTR lpBuffer,
    LPDWORD nSize
    );
#ifdef UNICODE
#define GetComputerName  GetComputerNameW
#else
#define GetComputerName  GetComputerNameA
#endif // !UNICODE

WINBASEAPI
BOOL
WINAPI
SetComputerNameA (
    LPCSTR lpComputerName
    );
WINBASEAPI
BOOL
WINAPI
SetComputerNameW (
    LPCWSTR lpComputerName
    );
#ifdef UNICODE
#define SetComputerName  SetComputerNameW
#else
#define SetComputerName  SetComputerNameA
#endif // !UNICODE

WINADVAPI
BOOL
WINAPI
GetUserNameA (
    LPSTR lpBuffer,
    LPDWORD nSize
    );
WINADVAPI
BOOL
WINAPI
GetUserNameW (
    LPWSTR lpBuffer,
    LPDWORD nSize
    );
#ifdef UNICODE
#define GetUserName  GetUserNameW
#else
#define GetUserName  GetUserNameA
#endif // !UNICODE

//
// Logon Support APIs
//

#define LOGON32_LOGON_INTERACTIVE   2
#define LOGON32_LOGON_BATCH         4
#define LOGON32_LOGON_SERVICE       5

#define LOGON32_PROVIDER_DEFAULT    0
#define LOGON32_PROVIDER_WINNT35    1



WINADVAPI
BOOL
WINAPI
LogonUserA (
    LPSTR lpszUsername,
    LPSTR lpszDomain,
    LPSTR lpszPassword,
    DWORD dwLogonType,
    DWORD dwLogonProvider,
    PHANDLE phToken
    );
WINADVAPI
BOOL
WINAPI
LogonUserW (
    LPWSTR lpszUsername,
    LPWSTR lpszDomain,
    LPWSTR lpszPassword,
    DWORD dwLogonType,
    DWORD dwLogonProvider,
    PHANDL